<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/macosx/classes/sun/java2d/opengl/CGLVolatileSurfaceManager.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.java2d.opengl;
 27 
 28 import java.awt.BufferCapabilities;
 29 import static java.awt.BufferCapabilities.FlipContents.*;
 30 import java.awt.Component;
 31 import java.awt.GraphicsConfiguration;
 32 import java.awt.Transparency;
 33 import java.awt.image.ColorModel;
 34 import java.awt.peer.ComponentPeer;
 35 
 36 import sun.awt.AWTAccessor;
 37 import sun.awt.AWTAccessor.ComponentAccessor;
 38 import sun.awt.image.SunVolatileImage;
 39 import sun.awt.image.VolatileSurfaceManager;
 40 import sun.java2d.BackBufferCapsProvider;
 41 import sun.java2d.SurfaceData;
 42 import static sun.java2d.opengl.OGLContext.OGLContextCaps.*;
 43 import sun.java2d.pipe.hw.ExtendedBufferCapabilities;
 44 import static sun.java2d.pipe.hw.ExtendedBufferCapabilities.VSyncType.*;
 45 
 46 public class CGLVolatileSurfaceManager extends VolatileSurfaceManager {
 47 
 48     private final boolean accelerationEnabled;
 49 
 50     public CGLVolatileSurfaceManager(SunVolatileImage vImg, Object context) {
 51         super(vImg, context);
 52 
 53         /*
 54          * We will attempt to accelerate this image only under the
 55          * following conditions:
 56          *   - the image is not bitmask AND the GraphicsConfig supports the FBO
 57          *     extension
 58          */
 59         int transparency = vImg.getTransparency();
 60         CGLGraphicsConfig gc = (CGLGraphicsConfig) vImg.getGraphicsConfig();
 61         accelerationEnabled = gc.isCapPresent(CAPS_EXT_FBOBJECT)
 62                 &amp;&amp; transparency != Transparency.BITMASK;
 63     }
 64 
 65     protected boolean isAccelerationEnabled() {
 66         return accelerationEnabled;
 67     }
 68 
 69     /**
 70      * Create a FBO-based SurfaceData object (or init the backbuffer
 71      * of an existing window if this is a double buffered GraphicsConfig)
 72      */
 73     protected SurfaceData initAcceleratedSurface() {
 74         SurfaceData sData = null;
 75         Component comp = vImg.getComponent();
 76         final ComponentAccessor acc = AWTAccessor.getComponentAccessor();
 77         final ComponentPeer peer = (comp != null) ? acc.getPeer(comp) : null;
 78 
 79         try {
 80             boolean createVSynced = false;
 81             boolean forceback = false;
 82             if (context instanceof Boolean) {
 83                 forceback = ((Boolean)context).booleanValue();
 84                 if (forceback &amp;&amp; peer instanceof BackBufferCapsProvider) {
 85                     BackBufferCapsProvider provider =
 86                         (BackBufferCapsProvider)peer;
 87                     BufferCapabilities caps = provider.getBackBufferCaps();
 88                     if (caps instanceof ExtendedBufferCapabilities) {
 89                         ExtendedBufferCapabilities ebc =
 90                             (ExtendedBufferCapabilities)caps;
 91                         if (ebc.getVSync() == VSYNC_ON &amp;&amp;
 92                             ebc.getFlipContents() == COPIED)
 93                         {
 94                             createVSynced = true;
 95                             forceback = false;
 96                         }
 97                     }
 98                 }
 99             }
100 
101             if (forceback) {
102                 // peer must be non-null in this case
103                 // TODO: modify parameter to delegate
104                 //                sData = CGLSurfaceData.createData(peer, vImg, FLIP_BACKBUFFER);
105             } else {
106                 CGLGraphicsConfig gc =
107                     (CGLGraphicsConfig)vImg.getGraphicsConfig();
108                 ColorModel cm = gc.getColorModel(vImg.getTransparency());
109                 int type = vImg.getForcedAccelSurfaceType();
110                 // if acceleration type is forced (type != UNDEFINED) then
111                 // use the forced type, otherwise choose FBOBJECT
112                 if (type == OGLSurfaceData.UNDEFINED) {
113                     type = OGLSurfaceData.FBOBJECT;
114                 }
115                 if (createVSynced) {
116                     // TODO: modify parameter to delegate
117 //                  sData = CGLSurfaceData.createData(peer, vImg, type);
118                 } else {
119                     sData = CGLSurfaceData.createData(gc,
120                                                       vImg.getWidth(),
121                                                       vImg.getHeight(),
122                                                       cm, vImg, type);
123                 }
124             }
125         } catch (NullPointerException ex) {
126             sData = null;
127         } catch (OutOfMemoryError er) {
128             sData = null;
129         }
130 
131         return sData;
132     }
133 
134     @Override
135     protected boolean isConfigValid(GraphicsConfiguration gc) {
136         return ((gc == null) || (gc == vImg.getGraphicsConfig()));
137     }
138 
139     @Override
140     public void initContents() {
141         if (vImg.getForcedAccelSurfaceType() != OGLSurfaceData.TEXTURE) {
142             super.initContents();
143         }
144     }
145 }
146 
    </pre>
  </body>
</html>
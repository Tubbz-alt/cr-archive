<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/classes/sun/java2d/opengl/CGLGraphicsConfig.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../font/CFontManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CGLLayer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/classes/sun/java2d/opengl/CGLGraphicsConfig.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38 import java.awt.image.BufferedImage;
 39 import java.awt.image.ColorModel;
 40 import java.awt.image.DataBuffer;
 41 import java.awt.image.DirectColorModel;
 42 import java.awt.image.VolatileImage;
 43 import java.awt.image.WritableRaster;
 44 
 45 import sun.awt.CGraphicsConfig;
 46 import sun.awt.CGraphicsDevice;
 47 import sun.awt.image.OffScreenImage;
 48 import sun.awt.image.SunVolatileImage;
 49 import sun.java2d.Disposer;
 50 import sun.java2d.DisposerRecord;
 51 import sun.java2d.Surface;
 52 import sun.java2d.SurfaceData;
 53 import sun.java2d.opengl.OGLContext.OGLContextCaps;
 54 import sun.java2d.pipe.hw.AccelSurface;
 55 import sun.java2d.pipe.hw.AccelTypedVolatileImage;
 56 import sun.java2d.pipe.hw.ContextCapabilities;
 57 import sun.lwawt.LWComponentPeer;
<span class="line-removed"> 58 import sun.lwawt.macosx.CPlatformView;</span>
 59 
 60 import static sun.java2d.opengl.OGLContext.OGLContextCaps.CAPS_DOUBLEBUFFERED;
 61 import static sun.java2d.opengl.OGLContext.OGLContextCaps.CAPS_EXT_FBOBJECT;
 62 import static sun.java2d.opengl.OGLSurfaceData.FBOBJECT;
 63 import static sun.java2d.opengl.OGLSurfaceData.TEXTURE;
 64 
 65 public final class CGLGraphicsConfig extends CGraphicsConfig
 66     implements OGLGraphicsConfig
 67 {
 68     //private static final int kOpenGLSwapInterval =
 69     // RuntimeOptions.getCurrentOptions().OpenGLSwapInterval;
 70     private static final int kOpenGLSwapInterval = 0; // TODO
 71     private static boolean cglAvailable;
 72     private static ImageCapabilities imageCaps = new CGLImageCaps();
 73 
 74     private int pixfmt;
 75     private BufferCapabilities bufferCaps;
 76     private long pConfigInfo;
 77     private ContextCapabilities oglCaps;
<span class="line-modified"> 78     private OGLContext context;</span>
 79     private final Object disposerReferent = new Object();
 80     private final int maxTextureSize;
 81 
 82     private static native boolean initCGL();
 83     private static native long getCGLConfigInfo(int displayID, int visualnum,
 84                                                 int swapInterval);
 85     private static native int getOGLCapabilities(long configInfo);
 86 
 87     /**
 88      * Returns GL_MAX_TEXTURE_SIZE from the shared opengl context. Must be
 89      * called under OGLRQ lock, because this method change current context.
 90      *
 91      * @return GL_MAX_TEXTURE_SIZE
 92      */
 93     private static native int nativeGetMaxTextureSize();
 94 
 95     static {
 96         cglAvailable = initCGL();
 97     }
 98 
 99     private CGLGraphicsConfig(CGraphicsDevice device, int pixfmt,
100                               long configInfo, int maxTextureSize,
101                               ContextCapabilities oglCaps) {
102         super(device);
103 
104         this.pixfmt = pixfmt;
105         this.pConfigInfo = configInfo;
106         this.oglCaps = oglCaps;
107         this.maxTextureSize = maxTextureSize;
<span class="line-modified">108         context = new OGLContext(OGLRenderQueue.getInstance(), this);</span>
109 
110         // add a record to the Disposer so that we destroy the native
111         // CGLGraphicsConfigInfo data when this object goes away
112         Disposer.addRecord(disposerReferent,
113                            new CGLGCDisposerRecord(pConfigInfo));
114     }
115 
116     @Override
117     public Object getProxyKey() {
118         return this;
119     }
120 
121     @Override
122     public SurfaceData createManagedSurface(int w, int h, int transparency) {
123         return CGLSurfaceData.createData(this, w, h,
124                                          getColorModel(transparency),
125                                          null,
126                                          OGLSurfaceData.TEXTURE);
127     }
128 
</pre>
<hr />
<pre>
241         //super.displayChanged();
242 
243         // the context could hold a reference to a CGLSurfaceData, which in
244         // turn has a reference back to this CGLGraphicsConfig, so in order
245         // for this instance to be disposed we need to break the connection
246         OGLRenderQueue rq = OGLRenderQueue.getInstance();
247         rq.lock();
248         try {
249             OGLContext.invalidateCurrentContext();
250         } finally {
251             rq.unlock();
252         }
253     }
254 
255     @Override
256     public String toString() {
257         String display = getDevice().getIDstring();
258         return (&quot;CGLGraphicsConfig[&quot; + display + &quot;, pixfmt=&quot; + pixfmt + &quot;]&quot;);
259     }
260 
<span class="line-removed">261     @Override</span>
<span class="line-removed">262     public SurfaceData createSurfaceData(CPlatformView pView) {</span>
<span class="line-removed">263         return CGLSurfaceData.createData(pView);</span>
<span class="line-removed">264     }</span>
<span class="line-removed">265 </span>
266     @Override
267     public SurfaceData createSurfaceData(CGLLayer layer) {
268         return CGLSurfaceData.createData(layer);
269     }
270 
271     @Override
272     public Image createAcceleratedImage(Component target,
273                                         int width, int height)
274     {
275         ColorModel model = getColorModel(Transparency.OPAQUE);
276         WritableRaster wr = model.createCompatibleWritableRaster(width, height);
277         return new OffScreenImage(target, model, wr,
278                                   model.isAlphaPremultiplied());
279     }
280 
281     @Override
282     public void assertOperationSupported(final int numBuffers,
283                                          final BufferCapabilities caps)
284             throws AWTException {
285         // Assume this method is never called with numBuffers != 2, as 0 is
</pre>
</td>
<td>
<hr />
<pre>
 38 import java.awt.image.BufferedImage;
 39 import java.awt.image.ColorModel;
 40 import java.awt.image.DataBuffer;
 41 import java.awt.image.DirectColorModel;
 42 import java.awt.image.VolatileImage;
 43 import java.awt.image.WritableRaster;
 44 
 45 import sun.awt.CGraphicsConfig;
 46 import sun.awt.CGraphicsDevice;
 47 import sun.awt.image.OffScreenImage;
 48 import sun.awt.image.SunVolatileImage;
 49 import sun.java2d.Disposer;
 50 import sun.java2d.DisposerRecord;
 51 import sun.java2d.Surface;
 52 import sun.java2d.SurfaceData;
 53 import sun.java2d.opengl.OGLContext.OGLContextCaps;
 54 import sun.java2d.pipe.hw.AccelSurface;
 55 import sun.java2d.pipe.hw.AccelTypedVolatileImage;
 56 import sun.java2d.pipe.hw.ContextCapabilities;
 57 import sun.lwawt.LWComponentPeer;

 58 
 59 import static sun.java2d.opengl.OGLContext.OGLContextCaps.CAPS_DOUBLEBUFFERED;
 60 import static sun.java2d.opengl.OGLContext.OGLContextCaps.CAPS_EXT_FBOBJECT;
 61 import static sun.java2d.opengl.OGLSurfaceData.FBOBJECT;
 62 import static sun.java2d.opengl.OGLSurfaceData.TEXTURE;
 63 
 64 public final class CGLGraphicsConfig extends CGraphicsConfig
 65     implements OGLGraphicsConfig
 66 {
 67     //private static final int kOpenGLSwapInterval =
 68     // RuntimeOptions.getCurrentOptions().OpenGLSwapInterval;
 69     private static final int kOpenGLSwapInterval = 0; // TODO
 70     private static boolean cglAvailable;
 71     private static ImageCapabilities imageCaps = new CGLImageCaps();
 72 
 73     private int pixfmt;
 74     private BufferCapabilities bufferCaps;
 75     private long pConfigInfo;
 76     private ContextCapabilities oglCaps;
<span class="line-modified"> 77     private final OGLContext context;</span>
 78     private final Object disposerReferent = new Object();
 79     private final int maxTextureSize;
 80 
 81     private static native boolean initCGL();
 82     private static native long getCGLConfigInfo(int displayID, int visualnum,
 83                                                 int swapInterval);
 84     private static native int getOGLCapabilities(long configInfo);
 85 
 86     /**
 87      * Returns GL_MAX_TEXTURE_SIZE from the shared opengl context. Must be
 88      * called under OGLRQ lock, because this method change current context.
 89      *
 90      * @return GL_MAX_TEXTURE_SIZE
 91      */
 92     private static native int nativeGetMaxTextureSize();
 93 
 94     static {
 95         cglAvailable = initCGL();
 96     }
 97 
 98     private CGLGraphicsConfig(CGraphicsDevice device, int pixfmt,
 99                               long configInfo, int maxTextureSize,
100                               ContextCapabilities oglCaps) {
101         super(device);
102 
103         this.pixfmt = pixfmt;
104         this.pConfigInfo = configInfo;
105         this.oglCaps = oglCaps;
106         this.maxTextureSize = maxTextureSize;
<span class="line-modified">107         context = new OGLContext(OGLRenderQueue.getInstance());</span>
108 
109         // add a record to the Disposer so that we destroy the native
110         // CGLGraphicsConfigInfo data when this object goes away
111         Disposer.addRecord(disposerReferent,
112                            new CGLGCDisposerRecord(pConfigInfo));
113     }
114 
115     @Override
116     public Object getProxyKey() {
117         return this;
118     }
119 
120     @Override
121     public SurfaceData createManagedSurface(int w, int h, int transparency) {
122         return CGLSurfaceData.createData(this, w, h,
123                                          getColorModel(transparency),
124                                          null,
125                                          OGLSurfaceData.TEXTURE);
126     }
127 
</pre>
<hr />
<pre>
240         //super.displayChanged();
241 
242         // the context could hold a reference to a CGLSurfaceData, which in
243         // turn has a reference back to this CGLGraphicsConfig, so in order
244         // for this instance to be disposed we need to break the connection
245         OGLRenderQueue rq = OGLRenderQueue.getInstance();
246         rq.lock();
247         try {
248             OGLContext.invalidateCurrentContext();
249         } finally {
250             rq.unlock();
251         }
252     }
253 
254     @Override
255     public String toString() {
256         String display = getDevice().getIDstring();
257         return (&quot;CGLGraphicsConfig[&quot; + display + &quot;, pixfmt=&quot; + pixfmt + &quot;]&quot;);
258     }
259 





260     @Override
261     public SurfaceData createSurfaceData(CGLLayer layer) {
262         return CGLSurfaceData.createData(layer);
263     }
264 
265     @Override
266     public Image createAcceleratedImage(Component target,
267                                         int width, int height)
268     {
269         ColorModel model = getColorModel(Transparency.OPAQUE);
270         WritableRaster wr = model.createCompatibleWritableRaster(width, height);
271         return new OffScreenImage(target, model, wr,
272                                   model.isAlphaPremultiplied());
273     }
274 
275     @Override
276     public void assertOperationSupported(final int numBuffers,
277                                          final BufferCapabilities caps)
278             throws AWTException {
279         // Assume this method is never called with numBuffers != 2, as 0 is
</pre>
</td>
</tr>
</table>
<center><a href="../../font/CFontManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CGLLayer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/macosx/classes/sun/java2d/opengl/CGLSurfaceData.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.java2d.opengl;
 27 
 28 import java.awt.Graphics;
 29 import java.awt.GraphicsConfiguration;
 30 import java.awt.GraphicsDevice;
 31 import java.awt.GraphicsEnvironment;
 32 import java.awt.Image;
 33 import java.awt.Rectangle;
 34 import java.awt.image.ColorModel;
 35 
 36 import sun.java2d.SunGraphics2D;
 37 import sun.java2d.SurfaceData;
 38 
 39 import sun.lwawt.macosx.CPlatformView;
 40 
 41 public abstract class CGLSurfaceData extends OGLSurfaceData {
 42 
 43     protected final int scale;
 44     protected final int width;
 45     protected final int height;
 46     protected CPlatformView pView;
 47     private CGLGraphicsConfig graphicsConfig;
 48 
 49     native void validate(int xoff, int yoff, int width, int height, boolean isOpaque);
 50 
 51     private native void initOps(long pConfigInfo, long pPeerData, long layerPtr,
 52                                 int xoff, int yoff, boolean isOpaque);
 53 
 54     protected CGLSurfaceData(CGLGraphicsConfig gc, ColorModel cm, int type,
 55                              int width, int height) {
 56         super(gc, cm, type);
 57         // TEXTURE shouldn&#39;t be scaled, it is used for managed BufferedImages.
 58         scale = type == TEXTURE ? 1 : gc.getDevice().getScaleFactor();
 59         this.width = width * scale;
 60         this.height = height * scale;
 61     }
 62 
 63     protected CGLSurfaceData(CPlatformView pView, CGLGraphicsConfig gc,
 64                              ColorModel cm, int type,int width, int height)
 65     {
 66         this(gc, cm, type, width, height);
 67         this.pView = pView;
 68         this.graphicsConfig = gc;
 69 
 70         long pConfigInfo = gc.getNativeConfigInfo();
 71         long pPeerData = 0L;
 72         boolean isOpaque = true;
 73         if (pView != null) {
 74             pPeerData = pView.getAWTView();
 75             isOpaque = pView.isOpaque();
 76         }
 77         initOps(pConfigInfo, pPeerData, 0, 0, 0, isOpaque);
 78     }
 79 
 80     protected CGLSurfaceData(CGLLayer layer, CGLGraphicsConfig gc,
 81                              ColorModel cm, int type,int width, int height)
 82     {
 83         this(gc, cm, type, width, height);
 84         this.graphicsConfig = gc;
 85 
 86         long pConfigInfo = gc.getNativeConfigInfo();
 87         long layerPtr = 0L;
 88         boolean isOpaque = true;
 89         if (layer != null) {
 90             layerPtr = layer.getPointer();
 91             isOpaque = layer.isOpaque();
 92         }
 93         initOps(pConfigInfo, 0, layerPtr, 0, 0, isOpaque);
 94     }
 95 
 96     @Override //SurfaceData
 97     public GraphicsConfiguration getDeviceConfiguration() {
 98         return graphicsConfig;
 99     }
100 
101     /**
102      * Creates a SurfaceData object representing the primary (front) buffer of
103      * an on-screen Window.
104      */
105     public static CGLWindowSurfaceData createData(CPlatformView pView) {
106         CGLGraphicsConfig gc = getGC(pView);
107         return new CGLWindowSurfaceData(pView, gc);
108     }
109 
110     /**
111      * Creates a SurfaceData object representing the intermediate buffer
112      * between the Java2D flusher thread and the AppKit thread.
113      */
114     public static CGLLayerSurfaceData createData(CGLLayer layer) {
115         CGLGraphicsConfig gc = getGC(layer);
116         Rectangle r = layer.getBounds();
117         return new CGLLayerSurfaceData(layer, gc, r.width, r.height);
118     }
119 
120     /**
121      * Creates a SurfaceData object representing the back buffer of a
122      * double-buffered on-screen Window.
123      */
124     public static CGLOffScreenSurfaceData createData(CPlatformView pView,
125             Image image, int type) {
126         CGLGraphicsConfig gc = getGC(pView);
127         Rectangle r = pView.getBounds();
128         if (type == FLIP_BACKBUFFER) {
129             return new CGLOffScreenSurfaceData(pView, gc, r.width, r.height,
130                     image, gc.getColorModel(), FLIP_BACKBUFFER);
131         } else {
132             return new CGLVSyncOffScreenSurfaceData(pView, gc, r.width,
133                     r.height, image, gc.getColorModel(), type);
134         }
135     }
136 
137     /**
138      * Creates a SurfaceData object representing an off-screen buffer (either a
139      * FBO or Texture).
140      */
141     public static CGLOffScreenSurfaceData createData(CGLGraphicsConfig gc,
142             int width, int height, ColorModel cm, Image image, int type) {
143         return new CGLOffScreenSurfaceData(null, gc, width, height, image, cm,
144                 type);
145     }
146 
147     public static CGLGraphicsConfig getGC(CPlatformView pView) {
148         if (pView != null) {
149             return (CGLGraphicsConfig)pView.getGraphicsConfiguration();
150         } else {
151             // REMIND: this should rarely (never?) happen, but what if
152             // default config is not CGL?
153             GraphicsEnvironment env = GraphicsEnvironment
154                 .getLocalGraphicsEnvironment();
155             GraphicsDevice gd = env.getDefaultScreenDevice();
156             return (CGLGraphicsConfig) gd.getDefaultConfiguration();
157         }
158     }
159 
160     public static CGLGraphicsConfig getGC(CGLLayer layer) {
161         return (CGLGraphicsConfig)layer.getGraphicsConfiguration();
162     }
163 
164     public void validate() {
165         // Overridden in CGLWindowSurfaceData below
166     }
167 
168     @Override
169     public double getDefaultScaleX() {
170         return scale;
171     }
172 
173     @Override
174     public double getDefaultScaleY() {
175         return scale;
176     }
177 
178     protected native void clearWindow();
179 
180     public static class CGLWindowSurfaceData extends CGLSurfaceData {
181 
182         public CGLWindowSurfaceData(CPlatformView pView,
183                 CGLGraphicsConfig gc) {
184             super(pView, gc, gc.getColorModel(), WINDOW, 0, 0);
185         }
186 
187         @Override
188         public SurfaceData getReplacement() {
189             return pView.getSurfaceData();
190         }
191 
192         @Override
193         public Rectangle getBounds() {
194             Rectangle r = pView.getBounds();
195             return new Rectangle(0, 0, r.width, r.height);
196         }
197 
198         /**
199          * Returns destination Component associated with this SurfaceData.
200          */
201         @Override
202         public Object getDestination() {
203             return pView.getDestination();
204         }
205 
206         public void validate() {
207             OGLRenderQueue rq = OGLRenderQueue.getInstance();
208             rq.lock();
209             try {
210                 rq.flushAndInvokeNow(new Runnable() {
211                     public void run() {
212                         Rectangle peerBounds = pView.getBounds();
213                         validate(0, 0, peerBounds.width, peerBounds.height, pView.isOpaque());
214                     }
215                 });
216             } finally {
217                 rq.unlock();
218             }
219         }
220 
221         @Override
222         public void invalidate() {
223             super.invalidate();
224             clearWindow();
225         }
226     }
227 
228     /**
229      * A surface which implements an intermediate buffer between
230      * the Java2D flusher thread and the AppKit thread.
231      *
232      * This surface serves as a buffer attached to a CGLLayer and
233      * the layer redirects all painting to the buffer&#39;s graphics.
234      */
235     public static class CGLLayerSurfaceData extends CGLSurfaceData {
236 
237         private CGLLayer layer;
238 
239         public CGLLayerSurfaceData(CGLLayer layer, CGLGraphicsConfig gc,
240                                    int width, int height) {
241             super(layer, gc, gc.getColorModel(), FBOBJECT, width, height);
242             this.layer = layer;
243             initSurface(this.width, this.height);
244         }
245 
246         @Override
247         public SurfaceData getReplacement() {
248             return layer.getSurfaceData();
249         }
250 
251         @Override
252         boolean isOnScreen() {
253             return true;
254         }
255 
256         @Override
257         public Rectangle getBounds() {
258             return new Rectangle(width, height);
259         }
260 
261         @Override
262         public Object getDestination() {
263             return layer.getDestination();
264         }
265 
266         @Override
267         public int getTransparency() {
268             return layer.getTransparency();
269         }
270 
271         @Override
272         public void invalidate() {
273             super.invalidate();
274             clearWindow();
275         }
276     }
277 
278     /**
279      * A surface which implements a v-synced flip back-buffer with COPIED
280      * FlipContents.
281      *
282      * This surface serves as a back-buffer to the outside world, while it is
283      * actually an offscreen surface. When the BufferStrategy this surface
284      * belongs to is showed, it is first copied to the real private
285      * FLIP_BACKBUFFER, which is then flipped.
286      */
287     public static class CGLVSyncOffScreenSurfaceData extends
288             CGLOffScreenSurfaceData {
289         private CGLOffScreenSurfaceData flipSurface;
290 
291         public CGLVSyncOffScreenSurfaceData(CPlatformView pView,
292                 CGLGraphicsConfig gc, int width, int height, Image image,
293                 ColorModel cm, int type) {
294             super(pView, gc, width, height, image, cm, type);
295             flipSurface = CGLSurfaceData.createData(pView, image,
296                     FLIP_BACKBUFFER);
297         }
298 
299         public SurfaceData getFlipSurface() {
300             return flipSurface;
301         }
302 
303         @Override
304         public void flush() {
305             flipSurface.flush();
306             super.flush();
307         }
308     }
309 
310     public static class CGLOffScreenSurfaceData extends CGLSurfaceData {
311         private Image offscreenImage;
312 
313         public CGLOffScreenSurfaceData(CPlatformView pView,
314                                        CGLGraphicsConfig gc, int width, int height, Image image,
315                                        ColorModel cm, int type) {
316             super(pView, gc, cm, type, width, height);
317             offscreenImage = image;
318             initSurface(this.width, this.height);
319         }
320 
321         @Override
322         public SurfaceData getReplacement() {
323             return restoreContents(offscreenImage);
324         }
325 
326         @Override
327         public Rectangle getBounds() {
328             if (type == FLIP_BACKBUFFER) {
329                 Rectangle r = pView.getBounds();
330                 return new Rectangle(0, 0, r.width, r.height);
331             } else {
332                 return new Rectangle(width, height);
333             }
334         }
335 
336         /**
337          * Returns destination Image associated with this SurfaceData.
338          */
339         @Override
340         public Object getDestination() {
341             return offscreenImage;
342         }
343     }
344 
345     // Mac OS X specific APIs for JOGL/Java2D bridge...
346 
347     // given a surface create and attach GL context, then return it
348     private static native long createCGLContextOnSurface(CGLSurfaceData sd,
349             long sharedContext);
350 
351     public static long createOGLContextOnSurface(Graphics g, long sharedContext) {
352         SurfaceData sd = ((SunGraphics2D) g).surfaceData;
353         if ((sd instanceof CGLSurfaceData) == true) {
354             CGLSurfaceData cglsd = (CGLSurfaceData) sd;
355             return createCGLContextOnSurface(cglsd, sharedContext);
356         } else {
357             return 0L;
358         }
359     }
360 
361     // returns whether or not the makeCurrent operation succeeded
362     static native boolean makeCGLContextCurrentOnSurface(CGLSurfaceData sd,
363             long ctx);
364 
365     public static boolean makeOGLContextCurrentOnSurface(Graphics g, long ctx) {
366         SurfaceData sd = ((SunGraphics2D) g).surfaceData;
367         if ((ctx != 0L) &amp;&amp; ((sd instanceof CGLSurfaceData) == true)) {
368             CGLSurfaceData cglsd = (CGLSurfaceData) sd;
369             return makeCGLContextCurrentOnSurface(cglsd, ctx);
370         } else {
371             return false;
372         }
373     }
374 
375     // additional cleanup
376     private static native void destroyCGLContext(long ctx);
377 
378     public static void destroyOGLContext(long ctx) {
379         if (ctx != 0L) {
380             destroyCGLContext(ctx);
381         }
382     }
383 }
    </pre>
  </body>
</html>
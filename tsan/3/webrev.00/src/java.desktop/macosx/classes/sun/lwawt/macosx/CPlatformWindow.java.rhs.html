<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/classes/sun/lwawt/macosx/CPlatformWindow.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.lwawt.macosx;
  27 
  28 import java.awt.Color;
  29 import java.awt.Component;
  30 import java.awt.DefaultKeyboardFocusManager;
  31 import java.awt.Dialog;
  32 import java.awt.Dialog.ModalityType;
  33 import java.awt.Font;
  34 import java.awt.FontMetrics;
  35 import java.awt.Frame;
  36 import java.awt.GraphicsDevice;
  37 import java.awt.Insets;
  38 import java.awt.MenuBar;
  39 import java.awt.Point;
  40 import java.awt.Rectangle;
  41 import java.awt.Toolkit;
  42 import java.awt.Window;
  43 import java.awt.event.FocusEvent;
  44 import java.awt.event.WindowEvent;
  45 import java.beans.PropertyChangeEvent;
  46 import java.beans.PropertyChangeListener;
  47 import java.lang.reflect.InvocationTargetException;
  48 import java.util.ArrayList;
  49 import java.util.Arrays;
  50 import java.util.Comparator;
  51 import java.util.concurrent.atomic.AtomicBoolean;
  52 import java.util.concurrent.atomic.AtomicLong;
  53 import java.util.concurrent.atomic.AtomicReference;
  54 
  55 import javax.swing.JRootPane;
  56 import javax.swing.RootPaneContainer;
  57 import javax.swing.SwingUtilities;
  58 
  59 import com.apple.laf.ClientPropertyApplicator;
  60 import com.apple.laf.ClientPropertyApplicator.Property;
  61 import sun.awt.AWTAccessor;
  62 import sun.awt.AWTAccessor.ComponentAccessor;
  63 import sun.awt.AWTAccessor.WindowAccessor;
  64 import sun.java2d.SurfaceData;
<a name="1" id="anc1"></a>
  65 import sun.lwawt.LWLightweightFramePeer;
  66 import sun.lwawt.LWToolkit;
  67 import sun.lwawt.LWWindowPeer;
  68 import sun.lwawt.LWWindowPeer.PeerType;
  69 import sun.lwawt.PlatformWindow;
  70 import sun.util.logging.PlatformLogger;
  71 
  72 public class CPlatformWindow extends CFRetainedResource implements PlatformWindow {
  73     private native long nativeCreateNSWindow(long nsViewPtr,long ownerPtr, long styleBits, double x, double y, double w, double h);
  74     private static native void nativeSetNSWindowStyleBits(long nsWindowPtr, int mask, int data);
  75     private static native void nativeSetNSWindowMenuBar(long nsWindowPtr, long menuBarPtr);
  76     private static native Insets nativeGetNSWindowInsets(long nsWindowPtr);
  77     private static native void nativeSetNSWindowBounds(long nsWindowPtr, double x, double y, double w, double h);
  78     private static native void nativeSetNSWindowLocationByPlatform(long nsWindowPtr);
  79     private static native void nativeSetNSWindowStandardFrame(long nsWindowPtr,
  80             double x, double y, double w, double h);
  81     private static native void nativeSetNSWindowMinMax(long nsWindowPtr, double minW, double minH, double maxW, double maxH);
  82     private static native void nativePushNSWindowToBack(long nsWindowPtr);
  83     private static native void nativePushNSWindowToFront(long nsWindowPtr);
  84     private static native void nativeSetNSWindowTitle(long nsWindowPtr, String title);
  85     private static native void nativeRevalidateNSWindowShadow(long nsWindowPtr);
  86     private static native void nativeSetNSWindowMinimizedIcon(long nsWindowPtr, long nsImage);
  87     private static native void nativeSetNSWindowRepresentedFilename(long nsWindowPtr, String representedFilename);
  88     private static native void nativeSetEnabled(long nsWindowPtr, boolean isEnabled);
  89     private static native void nativeSynthesizeMouseEnteredExitedEvents();
  90     private static native void nativeSynthesizeMouseEnteredExitedEvents(long nsWindowPtr, int eventType);
  91     private static native void nativeDispose(long nsWindowPtr);
  92     private static native void nativeEnterFullScreenMode(long nsWindowPtr);
  93     private static native void nativeExitFullScreenMode(long nsWindowPtr);
  94     static native CPlatformWindow nativeGetTopmostPlatformWindowUnderMouse();
  95 
  96     // Loger to report issues happened during execution but that do not affect functionality
  97     private static final PlatformLogger logger = PlatformLogger.getLogger(&quot;sun.lwawt.macosx.CPlatformWindow&quot;);
  98     private static final PlatformLogger focusLogger = PlatformLogger.getLogger(&quot;sun.lwawt.macosx.focus.CPlatformWindow&quot;);
  99 
 100     // for client properties
 101     public static final String WINDOW_BRUSH_METAL_LOOK = &quot;apple.awt.brushMetalLook&quot;;
 102     public static final String WINDOW_DRAGGABLE_BACKGROUND = &quot;apple.awt.draggableWindowBackground&quot;;
 103 
 104     public static final String WINDOW_ALPHA = &quot;Window.alpha&quot;;
 105     public static final String WINDOW_SHADOW = &quot;Window.shadow&quot;;
 106 
 107     public static final String WINDOW_STYLE = &quot;Window.style&quot;;
 108     public static final String WINDOW_SHADOW_REVALIDATE_NOW = &quot;apple.awt.windowShadow.revalidateNow&quot;;
 109 
 110     public static final String WINDOW_DOCUMENT_MODIFIED = &quot;Window.documentModified&quot;;
 111     public static final String WINDOW_DOCUMENT_FILE = &quot;Window.documentFile&quot;;
 112 
 113     public static final String WINDOW_CLOSEABLE = &quot;Window.closeable&quot;;
 114     public static final String WINDOW_MINIMIZABLE = &quot;Window.minimizable&quot;;
 115     public static final String WINDOW_ZOOMABLE = &quot;Window.zoomable&quot;;
 116     public static final String WINDOW_HIDES_ON_DEACTIVATE=&quot;Window.hidesOnDeactivate&quot;;
 117 
 118     public static final String WINDOW_DOC_MODAL_SHEET = &quot;apple.awt.documentModalSheet&quot;;
 119     public static final String WINDOW_FADE_DELEGATE = &quot;apple.awt._windowFadeDelegate&quot;;
 120     public static final String WINDOW_FADE_IN = &quot;apple.awt._windowFadeIn&quot;;
 121     public static final String WINDOW_FADE_OUT = &quot;apple.awt._windowFadeOut&quot;;
 122     public static final String WINDOW_FULLSCREENABLE = &quot;apple.awt.fullscreenable&quot;;
 123     public static final String WINDOW_FULL_CONTENT = &quot;apple.awt.fullWindowContent&quot;;
 124     public static final String WINDOW_TRANSPARENT_TITLE_BAR = &quot;apple.awt.transparentTitleBar&quot;;
 125 
 126     // Yeah, I know. But it&#39;s easier to deal with ints from JNI
 127     static final int MODELESS = 0;
 128     static final int DOCUMENT_MODAL = 1;
 129     static final int APPLICATION_MODAL = 2;
 130     static final int TOOLKIT_MODAL = 3;
 131 
 132     // window style bits
 133     static final int _RESERVED_FOR_DATA = 1 &lt;&lt; 0;
 134 
 135     // corresponds to native style mask bits
 136     static final int DECORATED = 1 &lt;&lt; 1;
 137     static final int TEXTURED = 1 &lt;&lt; 2;
 138     static final int UNIFIED = 1 &lt;&lt; 3;
 139     static final int UTILITY = 1 &lt;&lt; 4;
 140     static final int HUD = 1 &lt;&lt; 5;
 141     static final int SHEET = 1 &lt;&lt; 6;
 142 
 143     static final int CLOSEABLE = 1 &lt;&lt; 7;
 144     static final int MINIMIZABLE = 1 &lt;&lt; 8;
 145 
 146     static final int RESIZABLE = 1 &lt;&lt; 9; // both a style bit and prop bit
 147     static final int NONACTIVATING = 1 &lt;&lt; 24;
 148     static final int IS_DIALOG = 1 &lt;&lt; 25;
 149     static final int IS_MODAL = 1 &lt;&lt; 26;
 150     static final int IS_POPUP = 1 &lt;&lt; 27;
 151 
 152     static final int FULL_WINDOW_CONTENT = 1 &lt;&lt; 14;
 153 
 154     static final int _STYLE_PROP_BITMASK = DECORATED | TEXTURED | UNIFIED | UTILITY | HUD | SHEET | CLOSEABLE
 155                                              | MINIMIZABLE | RESIZABLE | FULL_WINDOW_CONTENT;
 156 
 157     // corresponds to method-based properties
 158     static final int HAS_SHADOW = 1 &lt;&lt; 10;
 159     static final int ZOOMABLE = 1 &lt;&lt; 11;
 160 
 161     static final int ALWAYS_ON_TOP = 1 &lt;&lt; 15;
 162     static final int HIDES_ON_DEACTIVATE = 1 &lt;&lt; 17;
 163     static final int DRAGGABLE_BACKGROUND = 1 &lt;&lt; 19;
 164     static final int DOCUMENT_MODIFIED = 1 &lt;&lt; 21;
 165     static final int FULLSCREENABLE = 1 &lt;&lt; 23;
 166     static final int TRANSPARENT_TITLE_BAR = 1 &lt;&lt; 18;
 167 
 168     static final int _METHOD_PROP_BITMASK = RESIZABLE | HAS_SHADOW | ZOOMABLE | ALWAYS_ON_TOP | HIDES_ON_DEACTIVATE
 169                                               | DRAGGABLE_BACKGROUND | DOCUMENT_MODIFIED | FULLSCREENABLE
 170                                               | TRANSPARENT_TITLE_BAR;
 171 
 172     // corresponds to callback-based properties
 173     static final int SHOULD_BECOME_KEY = 1 &lt;&lt; 12;
 174     static final int SHOULD_BECOME_MAIN = 1 &lt;&lt; 13;
 175     static final int MODAL_EXCLUDED = 1 &lt;&lt; 16;
 176 
 177     static final int _CALLBACK_PROP_BITMASK = SHOULD_BECOME_KEY | SHOULD_BECOME_MAIN | MODAL_EXCLUDED;
 178 
 179     static int SET(final int bits, final int mask, final boolean value) {
 180         if (value) return (bits | mask);
 181         return bits &amp; ~mask;
 182     }
 183 
 184     static boolean IS(final int bits, final int mask) {
 185         return (bits &amp; mask) != 0;
 186     }
 187 
 188     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 189     static ClientPropertyApplicator&lt;JRootPane, CPlatformWindow&gt; CLIENT_PROPERTY_APPLICATOR = new ClientPropertyApplicator&lt;JRootPane, CPlatformWindow&gt;(new Property[] {
 190         new Property&lt;CPlatformWindow&gt;(WINDOW_DOCUMENT_MODIFIED) { public void applyProperty(final CPlatformWindow c, final Object value) {
 191             c.setStyleBits(DOCUMENT_MODIFIED, value == null ? false : Boolean.parseBoolean(value.toString()));
 192         }},
 193         new Property&lt;CPlatformWindow&gt;(WINDOW_BRUSH_METAL_LOOK) { public void applyProperty(final CPlatformWindow c, final Object value) {
 194             c.setStyleBits(TEXTURED, Boolean.parseBoolean(value.toString()));
 195         }},
 196         new Property&lt;CPlatformWindow&gt;(WINDOW_ALPHA) { public void applyProperty(final CPlatformWindow c, final Object value) {
 197             c.target.setOpacity(value == null ? 1.0f : Float.parseFloat(value.toString()));
 198         }},
 199         new Property&lt;CPlatformWindow&gt;(WINDOW_SHADOW) { public void applyProperty(final CPlatformWindow c, final Object value) {
 200             c.setStyleBits(HAS_SHADOW, value == null ? true : Boolean.parseBoolean(value.toString()));
 201         }},
 202         new Property&lt;CPlatformWindow&gt;(WINDOW_MINIMIZABLE) { public void applyProperty(final CPlatformWindow c, final Object value) {
 203             c.setStyleBits(MINIMIZABLE, Boolean.parseBoolean(value.toString()));
 204         }},
 205         new Property&lt;CPlatformWindow&gt;(WINDOW_CLOSEABLE) { public void applyProperty(final CPlatformWindow c, final Object value) {
 206             c.setStyleBits(CLOSEABLE, Boolean.parseBoolean(value.toString()));
 207         }},
 208         new Property&lt;CPlatformWindow&gt;(WINDOW_ZOOMABLE) { public void applyProperty(final CPlatformWindow c, final Object value) {
 209             boolean zoomable = Boolean.parseBoolean(value.toString());
 210             if (c.target instanceof RootPaneContainer
 211                     &amp;&amp; c.getPeer().getPeerType() == PeerType.FRAME) {
 212                 if (c.isInFullScreen &amp;&amp; !zoomable) {
 213                     c.toggleFullScreen();
 214                 }
 215             }
 216             c.setStyleBits(ZOOMABLE, zoomable);
 217         }},
 218         new Property&lt;CPlatformWindow&gt;(WINDOW_FULLSCREENABLE) { public void applyProperty(final CPlatformWindow c, final Object value) {
 219             boolean fullscrenable = Boolean.parseBoolean(value.toString());
 220             if (c.target instanceof RootPaneContainer
 221                     &amp;&amp; c.getPeer().getPeerType() == PeerType.FRAME) {
 222                 if (c.isInFullScreen &amp;&amp; !fullscrenable) {
 223                     c.toggleFullScreen();
 224                 }
 225             }
 226             c.setStyleBits(FULLSCREENABLE, fullscrenable);
 227         }},
 228         new Property&lt;CPlatformWindow&gt;(WINDOW_SHADOW_REVALIDATE_NOW) { public void applyProperty(final CPlatformWindow c, final Object value) {
 229             c.execute(ptr -&gt; nativeRevalidateNSWindowShadow(ptr));
 230         }},
 231         new Property&lt;CPlatformWindow&gt;(WINDOW_DOCUMENT_FILE) { public void applyProperty(final CPlatformWindow c, final Object value) {
 232             if (value == null || !(value instanceof java.io.File)) {
 233                 c.execute(ptr-&gt;nativeSetNSWindowRepresentedFilename(ptr, null));
 234                 return;
 235             }
 236 
 237             final String filename = ((java.io.File)value).getAbsolutePath();
 238             c.execute(ptr-&gt;nativeSetNSWindowRepresentedFilename(ptr, filename));
 239         }},
 240         new Property&lt;CPlatformWindow&gt;(WINDOW_FULL_CONTENT) {
 241             public void applyProperty(final CPlatformWindow c, final Object value) {
 242                 boolean isFullWindowContent = Boolean.parseBoolean(value.toString());
 243                 c.setStyleBits(FULL_WINDOW_CONTENT, isFullWindowContent);
 244             }
 245         },
 246         new Property&lt;CPlatformWindow&gt;(WINDOW_TRANSPARENT_TITLE_BAR) {
 247             public void applyProperty(final CPlatformWindow c, final Object value) {
 248                 boolean isTransparentTitleBar = Boolean.parseBoolean(value.toString());
 249                 c.setStyleBits(TRANSPARENT_TITLE_BAR, isTransparentTitleBar);
 250             }
 251         }
 252     }) {
 253         @SuppressWarnings(&quot;deprecation&quot;)
 254         public CPlatformWindow convertJComponentToTarget(final JRootPane p) {
 255             Component root = SwingUtilities.getRoot(p);
 256             final ComponentAccessor acc = AWTAccessor.getComponentAccessor();
 257             if (root == null || acc.getPeer(root) == null) return null;
 258             return (CPlatformWindow)((LWWindowPeer)acc.getPeer(root)).getPlatformWindow();
 259         }
 260     };
 261     private final Comparator&lt;Window&gt; siblingsComparator = (w1, w2) -&gt; {
 262         if (w1 == w2) {
 263             return 0;
 264         }
 265         ComponentAccessor componentAccessor = AWTAccessor.getComponentAccessor();
 266         Object p1 = componentAccessor.getPeer(w1);
 267         Object p2 = componentAccessor.getPeer(w2);
 268         long time1 = 0;
 269         if (p1 instanceof LWWindowPeer) {
 270             time1 = ((CPlatformWindow) (((LWWindowPeer) p1).getPlatformWindow())).lastBecomeMainTime;
 271         }
 272         long time2 = 0;
 273         if (p2 instanceof LWWindowPeer) {
 274             time2 = ((CPlatformWindow) (((LWWindowPeer) p2).getPlatformWindow())).lastBecomeMainTime;
 275         }
 276         return Long.compare(time1, time2);
 277     };
 278 
 279     // Bounds of the native widget but in the Java coordinate system.
 280     // In order to keep it up-to-date we will update them on
 281     // 1) setting native bounds via nativeSetBounds() call
 282     // 2) getting notification from the native level via deliverMoveResizeEvent()
 283     private Rectangle nativeBounds = new Rectangle(0, 0, 0, 0);
 284     private volatile boolean isFullScreenMode;
 285     private boolean isFullScreenAnimationOn;
 286 
 287     private volatile boolean isInFullScreen;
 288     private volatile boolean isIconifyAnimationActive;
 289     private volatile boolean isZoomed;
 290 
 291     private Window target;
 292     private LWWindowPeer peer;
 293     protected CPlatformView contentView;
 294     protected CPlatformWindow owner;
 295     protected boolean visible = false; // visibility status from native perspective
 296     private boolean undecorated; // initialized in getInitialStyleBits()
 297     private Rectangle normalBounds = null; // not-null only for undecorated maximized windows
 298     private CPlatformResponder responder;
 299     private long lastBecomeMainTime; // this is necessary to preserve right siblings order
 300 
 301     public CPlatformWindow() {
 302         super(0, true);
 303     }
 304 
 305     /*
 306      * Delegate initialization (create native window and all the
 307      * related resources).
 308      */
 309     @Override // PlatformWindow
 310     public void initialize(Window _target, LWWindowPeer _peer, PlatformWindow _owner) {
<a name="2" id="anc2"></a><span class="line-modified"> 311         initializeBase(_target, _peer, _owner);</span>
 312 
 313         final int styleBits = getInitialStyleBits();
 314 
 315         responder = createPlatformResponder();
<a name="3" id="anc3"></a>
 316         contentView.initialize(peer, responder);
 317 
 318         Rectangle bounds;
 319         if (!IS(DECORATED, styleBits)) {
 320             // For undecorated frames the move/resize event does not come if the frame is centered on the screen
 321             // so we need to set a stub location to force an initial move/resize. Real bounds would be set later.
 322             bounds = new Rectangle(0, 0, 1, 1);
 323         } else {
 324             bounds = _peer.constrainBounds(_target.getBounds());
 325         }
 326         AtomicLong ref = new AtomicLong();
 327         contentView.execute(viewPtr -&gt; {
 328             boolean hasOwnerPtr = false;
 329 
 330             if (owner != null) {
 331                 hasOwnerPtr = 0L != owner.executeGet(ownerPtr -&gt; {
 332                     ref.set(nativeCreateNSWindow(viewPtr, ownerPtr, styleBits,
 333                                                     bounds.x, bounds.y,
 334                                                     bounds.width, bounds.height));
 335                     return 1;
 336                 });
 337             }
 338 
 339             if (!hasOwnerPtr) {
 340                 ref.set(nativeCreateNSWindow(viewPtr, 0,
 341                                              styleBits, bounds.x, bounds.y,
 342                                              bounds.width, bounds.height));
 343             }
 344         });
 345         setPtr(ref.get());
 346 
 347         if (target instanceof javax.swing.RootPaneContainer) {
 348             final javax.swing.JRootPane rootpane = ((javax.swing.RootPaneContainer)target).getRootPane();
 349             if (rootpane != null) rootpane.addPropertyChangeListener(&quot;ancestor&quot;, new PropertyChangeListener() {
 350                 public void propertyChange(final PropertyChangeEvent evt) {
 351                     CLIENT_PROPERTY_APPLICATOR.attachAndApplyClientProperties(rootpane);
 352                     rootpane.removePropertyChangeListener(&quot;ancestor&quot;, this);
 353                 }
 354             });
 355         }
<a name="4" id="anc4"></a>

 356     }
 357 
<a name="5" id="anc5"></a><span class="line-modified"> 358     void initializeBase(Window target, LWWindowPeer peer, PlatformWindow owner) {</span>
 359         this.peer = peer;
 360         this.target = target;
 361         if (owner instanceof CPlatformWindow) {
 362             this.owner = (CPlatformWindow)owner;
 363         }
<a name="6" id="anc6"></a><span class="line-modified"> 364         contentView = createContentView();</span>
 365     }
 366 
 367     protected CPlatformResponder createPlatformResponder() {
 368         return new CPlatformResponder(peer, false);
 369     }
 370 
<a name="7" id="anc7"></a><span class="line-modified"> 371     CPlatformView createContentView() {</span>
 372         return new CPlatformView();
 373     }
 374 
 375     protected int getInitialStyleBits() {
 376         // defaults style bits
 377         int styleBits = DECORATED | HAS_SHADOW | CLOSEABLE | MINIMIZABLE | ZOOMABLE | RESIZABLE;
 378 
 379         if (isNativelyFocusableWindow()) {
 380             styleBits = SET(styleBits, SHOULD_BECOME_KEY, true);
 381             styleBits = SET(styleBits, SHOULD_BECOME_MAIN, true);
 382         }
 383 
 384         final boolean isFrame = (target instanceof Frame);
 385         final boolean isDialog = (target instanceof Dialog);
 386         final boolean isPopup = (target.getType() == Window.Type.POPUP);
 387         if (isDialog) {
 388             styleBits = SET(styleBits, MINIMIZABLE, false);
 389         }
 390 
 391         // Either java.awt.Frame or java.awt.Dialog can be undecorated, however java.awt.Window always is undecorated.
 392         {
 393             this.undecorated = isFrame ? ((Frame)target).isUndecorated() : (isDialog ? ((Dialog)target).isUndecorated() : true);
 394             if (this.undecorated) styleBits = SET(styleBits, DECORATED, false);
 395         }
 396 
 397         // Either java.awt.Frame or java.awt.Dialog can be resizable, however java.awt.Window is never resizable
 398         {
 399             final boolean resizable = isFrame ? ((Frame)target).isResizable() : (isDialog ? ((Dialog)target).isResizable() : false);
 400             styleBits = SET(styleBits, RESIZABLE, resizable);
 401             if (!resizable) {
 402                 styleBits = SET(styleBits, ZOOMABLE, false);
 403             }
 404         }
 405 
 406         if (target.isAlwaysOnTop()) {
 407             styleBits = SET(styleBits, ALWAYS_ON_TOP, true);
 408         }
 409 
 410         if (target.getModalExclusionType() == Dialog.ModalExclusionType.APPLICATION_EXCLUDE) {
 411             styleBits = SET(styleBits, MODAL_EXCLUDED, true);
 412         }
 413 
 414         // If the target is a dialog, popup or tooltip we want it to ignore the brushed metal look.
 415         if (isPopup) {
 416             styleBits = SET(styleBits, TEXTURED, false);
 417             // Popups in applets don&#39;t activate applet&#39;s process
 418             styleBits = SET(styleBits, NONACTIVATING, true);
 419             styleBits = SET(styleBits, IS_POPUP, true);
 420         }
 421 
 422         if (Window.Type.UTILITY.equals(target.getType())) {
 423             styleBits = SET(styleBits, UTILITY, true);
 424         }
 425 
 426         if (target instanceof javax.swing.RootPaneContainer) {
 427             javax.swing.JRootPane rootpane = ((javax.swing.RootPaneContainer)target).getRootPane();
 428             Object prop = null;
 429 
 430             prop = rootpane.getClientProperty(WINDOW_BRUSH_METAL_LOOK);
 431             if (prop != null) {
 432                 styleBits = SET(styleBits, TEXTURED, Boolean.parseBoolean(prop.toString()));
 433             }
 434 
 435             if (isDialog &amp;&amp; ((Dialog)target).getModalityType() == ModalityType.DOCUMENT_MODAL) {
 436                 prop = rootpane.getClientProperty(WINDOW_DOC_MODAL_SHEET);
 437                 if (prop != null) {
 438                     styleBits = SET(styleBits, SHEET, Boolean.parseBoolean(prop.toString()));
 439                 }
 440             }
 441 
 442             prop = rootpane.getClientProperty(WINDOW_STYLE);
 443             if (prop != null) {
 444                 if (&quot;small&quot;.equals(prop))  {
 445                     styleBits = SET(styleBits, UTILITY, true);
 446                     if (target.isAlwaysOnTop() &amp;&amp; rootpane.getClientProperty(WINDOW_HIDES_ON_DEACTIVATE) == null) {
 447                         styleBits = SET(styleBits, HIDES_ON_DEACTIVATE, true);
 448                     }
 449                 }
 450                 if (&quot;textured&quot;.equals(prop)) styleBits = SET(styleBits, TEXTURED, true);
 451                 if (&quot;unified&quot;.equals(prop)) styleBits = SET(styleBits, UNIFIED, true);
 452                 if (&quot;hud&quot;.equals(prop)) styleBits = SET(styleBits, HUD, true);
 453             }
 454 
 455             prop = rootpane.getClientProperty(WINDOW_HIDES_ON_DEACTIVATE);
 456             if (prop != null) {
 457                 styleBits = SET(styleBits, HIDES_ON_DEACTIVATE, Boolean.parseBoolean(prop.toString()));
 458             }
 459 
 460             prop = rootpane.getClientProperty(WINDOW_CLOSEABLE);
 461             if (prop != null) {
 462                 styleBits = SET(styleBits, CLOSEABLE, Boolean.parseBoolean(prop.toString()));
 463             }
 464 
 465             prop = rootpane.getClientProperty(WINDOW_MINIMIZABLE);
 466             if (prop != null) {
 467                 styleBits = SET(styleBits, MINIMIZABLE, Boolean.parseBoolean(prop.toString()));
 468             }
 469 
 470             prop = rootpane.getClientProperty(WINDOW_ZOOMABLE);
 471             if (prop != null) {
 472                 styleBits = SET(styleBits, ZOOMABLE, Boolean.parseBoolean(prop.toString()));
 473             }
 474 
 475             prop = rootpane.getClientProperty(WINDOW_FULLSCREENABLE);
 476             if (prop != null) {
 477                 styleBits = SET(styleBits, FULLSCREENABLE, Boolean.parseBoolean(prop.toString()));
 478             }
 479 
 480             prop = rootpane.getClientProperty(WINDOW_SHADOW);
 481             if (prop != null) {
 482                 styleBits = SET(styleBits, HAS_SHADOW, Boolean.parseBoolean(prop.toString()));
 483             }
 484 
 485             prop = rootpane.getClientProperty(WINDOW_DRAGGABLE_BACKGROUND);
 486             if (prop != null) {
 487                 styleBits = SET(styleBits, DRAGGABLE_BACKGROUND, Boolean.parseBoolean(prop.toString()));
 488             }
 489 
 490             prop = rootpane.getClientProperty(WINDOW_FULL_CONTENT);
 491             if (prop != null) {
 492                 styleBits = SET(styleBits, FULL_WINDOW_CONTENT, Boolean.parseBoolean(prop.toString()));
 493             }
 494 
 495             prop = rootpane.getClientProperty(WINDOW_TRANSPARENT_TITLE_BAR);
 496             if (prop != null) {
 497                 styleBits = SET(styleBits, TRANSPARENT_TITLE_BAR, Boolean.parseBoolean(prop.toString()));
 498             }
 499         }
 500 
 501         if (isDialog) {
 502             styleBits = SET(styleBits, IS_DIALOG, true);
 503             if (((Dialog) target).isModal()) {
 504                 styleBits = SET(styleBits, IS_MODAL, true);
 505             }
 506         }
 507 
 508         peer.setTextured(IS(TEXTURED, styleBits));
 509 
 510         return styleBits;
 511     }
 512 
 513     // this is the counter-point to -[CWindow _nativeSetStyleBit:]
 514     private void setStyleBits(final int mask, final boolean value) {
 515         execute(ptr -&gt; nativeSetNSWindowStyleBits(ptr, mask, value ? mask : 0));
 516     }
 517 
 518     private native void _toggleFullScreenMode(final long model);
 519 
 520     public void toggleFullScreen() {
 521         execute(this::_toggleFullScreenMode);
 522     }
 523 
 524     @Override // PlatformWindow
 525     public void setMenuBar(MenuBar mb) {
 526         CMenuBar mbPeer = (CMenuBar)LWToolkit.targetToPeer(mb);
 527         execute(nsWindowPtr-&gt;{
 528             if (mbPeer != null) {
 529                 mbPeer.execute(ptr -&gt; nativeSetNSWindowMenuBar(nsWindowPtr, ptr));
 530             } else {
 531                 nativeSetNSWindowMenuBar(nsWindowPtr, 0);
 532             }
 533         });
 534     }
 535 
 536     @Override // PlatformWindow
 537     public void dispose() {
 538         contentView.dispose();
 539         execute(CPlatformWindow::nativeDispose);
 540         CPlatformWindow.super.dispose();
 541     }
 542 
 543     @Override // PlatformWindow
 544     public FontMetrics getFontMetrics(Font f) {
 545         // TODO: not implemented
 546         (new RuntimeException(&quot;unimplemented&quot;)).printStackTrace();
 547         return null;
 548     }
 549 
 550     @Override // PlatformWindow
 551     public Insets getInsets() {
 552         AtomicReference&lt;Insets&gt; ref = new AtomicReference&lt;&gt;();
 553         execute(ptr -&gt; {
 554             ref.set(nativeGetNSWindowInsets(ptr));
 555         });
 556         return ref.get() != null ? ref.get() : new Insets(0, 0, 0, 0);
 557     }
 558 
 559     @Override // PlatformWindow
 560     public Point getLocationOnScreen() {
 561         return new Point(nativeBounds.x, nativeBounds.y);
 562     }
 563 
 564     @Override
 565     public GraphicsDevice getGraphicsDevice() {
 566         return contentView.getGraphicsDevice();
 567     }
 568 
 569     @Override // PlatformWindow
 570     public SurfaceData getScreenSurface() {
 571         // TODO: not implemented
 572         return null;
 573     }
 574 
 575     @Override // PlatformWindow
 576     public SurfaceData replaceSurfaceData() {
 577         return contentView.replaceSurfaceData();
 578     }
 579 
 580     @Override // PlatformWindow
 581     public void setBounds(int x, int y, int w, int h) {
 582         execute(ptr -&gt; nativeSetNSWindowBounds(ptr, x, y, w, h));
 583     }
 584 
 585     public void setMaximizedBounds(int x, int y, int w, int h) {
 586         execute(ptr -&gt; nativeSetNSWindowStandardFrame(ptr, x, y, w, h));
 587     }
 588 
 589     private boolean isMaximized() {
 590         return undecorated ? this.normalBounds != null
 591                 : isZoomed;
 592     }
 593 
 594     private void maximize() {
 595         if (peer == null || isMaximized()) {
 596             return;
 597         }
 598         if (!undecorated) {
 599             execute(CWrapper.NSWindow::zoom);
 600         } else {
 601             deliverZoom(true);
 602 
 603             // We need an up to date size of the peer, so we flush the native events
 604             // to be sure that there are no setBounds requests in the queue.
 605             LWCToolkit.flushNativeSelectors();
 606             this.normalBounds = peer.getBounds();
 607             Rectangle maximizedBounds = peer.getMaximizedBounds();
 608             setBounds(maximizedBounds.x, maximizedBounds.y,
 609                     maximizedBounds.width, maximizedBounds.height);
 610         }
 611     }
 612 
 613     private void unmaximize() {
 614         if (!isMaximized()) {
 615             return;
 616         }
 617         if (!undecorated) {
 618             execute(CWrapper.NSWindow::zoom);
 619         } else {
 620             deliverZoom(false);
 621 
 622             Rectangle toBounds = this.normalBounds;
 623             this.normalBounds = null;
 624             setBounds(toBounds.x, toBounds.y, toBounds.width, toBounds.height);
 625         }
 626     }
 627 
 628     public boolean isVisible() {
 629         return this.visible;
 630     }
 631 
 632     @Override // PlatformWindow
 633     public void setVisible(boolean visible) {
 634         // Configure stuff
 635         updateIconImages();
 636         updateFocusabilityForAutoRequestFocus(false);
 637 
 638         boolean wasMaximized = isMaximized();
 639 
 640         if (visible &amp;&amp; target.isLocationByPlatform()) {
 641             execute(CPlatformWindow::nativeSetNSWindowLocationByPlatform);
 642         }
 643 
 644         // Actually show or hide the window
 645         LWWindowPeer blocker = (peer == null)? null : peer.getBlocker();
 646         if (blocker == null || !visible) {
 647             // If it ain&#39;t blocked, or is being hidden, go regular way
 648             if (visible) {
 649                 contentView.execute(viewPtr -&gt; {
 650                     execute(ptr -&gt; CWrapper.NSWindow.makeFirstResponder(ptr,
 651                                                                         viewPtr));
 652                 });
 653 
 654                 boolean isPopup = (target.getType() == Window.Type.POPUP);
 655                 execute(ptr -&gt; {
 656                     if (isPopup) {
 657                         // Popups in applets don&#39;t activate applet&#39;s process
 658                         CWrapper.NSWindow.orderFrontRegardless(ptr);
 659                     } else {
 660                         CWrapper.NSWindow.orderFront(ptr);
 661                     }
 662 
 663                     boolean isKeyWindow = CWrapper.NSWindow.isKeyWindow(ptr);
 664                     if (!isKeyWindow) {
 665                         CWrapper.NSWindow.makeKeyWindow(ptr);
 666                     }
 667 
 668                     if (owner != null
 669                             &amp;&amp; owner.getPeer() instanceof LWLightweightFramePeer) {
 670                         LWLightweightFramePeer peer =
 671                                 (LWLightweightFramePeer) owner.getPeer();
 672 
 673                         long ownerWindowPtr = peer.getOverriddenWindowHandle();
 674                         if (ownerWindowPtr != 0) {
 675                             //Place window above JavaFX stage
 676                             CWrapper.NSWindow.addChildWindow(
 677                                     ownerWindowPtr, ptr,
 678                                     CWrapper.NSWindow.NSWindowAbove);
 679                         }
 680                     }
 681                 });
 682             } else {
 683                 execute(ptr-&gt;{
 684                     // immediately hide the window
 685                     CWrapper.NSWindow.orderOut(ptr);
 686                     // process the close
 687                     CWrapper.NSWindow.close(ptr);
 688                 });
 689             }
 690         } else {
 691             // otherwise, put it in a proper z-order
 692             CPlatformWindow bw
 693                     = (CPlatformWindow) blocker.getPlatformWindow();
 694             bw.execute(blockerPtr -&gt; {
 695                 execute(ptr -&gt; {
 696                     CWrapper.NSWindow.orderWindow(ptr,
 697                                                   CWrapper.NSWindow.NSWindowBelow,
 698                                                   blockerPtr);
 699                 });
 700             });
 701         }
 702         this.visible = visible;
 703 
 704         // Manage the extended state when showing
 705         if (visible) {
 706             /* Frame or Dialog should be set property WINDOW_FULLSCREENABLE to true if the
 707             Frame or Dialog is resizable.
 708             **/
 709             final boolean resizable = (target instanceof Frame) ? ((Frame)target).isResizable() :
 710             ((target instanceof Dialog) ? ((Dialog)target).isResizable() : false);
 711             if (resizable) {
 712                 setCanFullscreen(true);
 713             }
 714 
 715             // Apply the extended state as expected in shared code
 716             if (target instanceof Frame) {
 717                 if (!wasMaximized &amp;&amp; isMaximized()) {
 718                     // setVisible could have changed the native maximized state
 719                     deliverZoom(true);
 720                 } else {
 721                     int frameState = ((Frame)target).getExtendedState();
 722                     if ((frameState &amp; Frame.ICONIFIED) != 0) {
 723                         // Treat all state bit masks with ICONIFIED bit as ICONIFIED state.
 724                         frameState = Frame.ICONIFIED;
 725                     }
 726 
 727                     switch (frameState) {
 728                         case Frame.ICONIFIED:
 729                             execute(CWrapper.NSWindow::miniaturize);
 730                             break;
 731                         case Frame.MAXIMIZED_BOTH:
 732                             maximize();
 733                             break;
 734                         default: // NORMAL
 735                             unmaximize(); // in case it was maximized, otherwise this is a no-op
 736                             break;
 737                     }
 738                 }
 739             }
 740         }
 741 
 742         nativeSynthesizeMouseEnteredExitedEvents();
 743 
 744         // Configure stuff #2
 745         updateFocusabilityForAutoRequestFocus(true);
 746 
 747         // Manage parent-child relationship when showing
 748         final ComponentAccessor acc = AWTAccessor.getComponentAccessor();
 749 
 750         if (visible) {
 751             // Order myself above my parent
 752             if (owner != null &amp;&amp; owner.isVisible()) {
 753                 owner.execute(ownerPtr -&gt; {
 754                     execute(ptr -&gt; {
 755                         CWrapper.NSWindow.orderWindow(ptr, CWrapper.NSWindow.NSWindowAbove, ownerPtr);
 756                     });
 757                 });
 758                 execute(CWrapper.NSWindow::orderFront);
 759                 applyWindowLevel(target);
 760             }
 761 
 762             // Order my own children above myself
 763             for (Window w : target.getOwnedWindows()) {
 764                 final Object p = acc.getPeer(w);
 765                 if (p instanceof LWWindowPeer) {
 766                     CPlatformWindow pw = (CPlatformWindow)((LWWindowPeer)p).getPlatformWindow();
 767                     if (pw != null &amp;&amp; pw.isVisible()) {
 768                         pw.execute(childPtr -&gt; {
 769                             execute(ptr -&gt; {
 770                                 CWrapper.NSWindow.orderWindow(childPtr, CWrapper.NSWindow.NSWindowAbove, ptr);
 771                             });
 772                         });
 773                         pw.applyWindowLevel(w);
 774                     }
 775                 }
 776             }
 777         }
 778 
 779         // Deal with the blocker of the window being shown
 780         if (blocker != null &amp;&amp; visible) {
 781             // Make sure the blocker is above its siblings
 782             ((CPlatformWindow)blocker.getPlatformWindow()).orderAboveSiblings();
 783         }
 784     }
 785 
 786     @Override // PlatformWindow
 787     public void setTitle(String title) {
 788         execute(ptr -&gt; nativeSetNSWindowTitle(ptr, title));
 789     }
 790 
 791     // Should be called on every window key property change.
 792     @Override // PlatformWindow
 793     public void updateIconImages() {
 794         final CImage cImage = getImageForTarget();
 795         execute(ptr -&gt; {
 796             if (cImage == null) {
 797                 nativeSetNSWindowMinimizedIcon(ptr, 0L);
 798             } else {
 799                 cImage.execute(imagePtr -&gt; {
 800                     nativeSetNSWindowMinimizedIcon(ptr, imagePtr);
 801                 });
 802             }
 803         });
 804     }
 805 
 806     public SurfaceData getSurfaceData() {
 807         return contentView.getSurfaceData();
 808     }
 809 
 810     @Override  // PlatformWindow
 811     public void toBack() {
 812         execute(CPlatformWindow::nativePushNSWindowToBack);
 813     }
 814 
 815     @Override  // PlatformWindow
 816     public void toFront() {
 817         LWCToolkit lwcToolkit = (LWCToolkit) Toolkit.getDefaultToolkit();
 818         Window w = DefaultKeyboardFocusManager.getCurrentKeyboardFocusManager().getActiveWindow();
 819         final ComponentAccessor acc = AWTAccessor.getComponentAccessor();
 820         if( w != null &amp;&amp; acc.getPeer(w) != null
 821                 &amp;&amp; ((LWWindowPeer)acc.getPeer(w)).getPeerType() == LWWindowPeer.PeerType.EMBEDDED_FRAME
 822                 &amp;&amp; !lwcToolkit.isApplicationActive()) {
 823             lwcToolkit.activateApplicationIgnoringOtherApps();
 824         }
 825         updateFocusabilityForAutoRequestFocus(false);
 826         execute(CPlatformWindow::nativePushNSWindowToFront);
 827         updateFocusabilityForAutoRequestFocus(true);
 828     }
 829 
 830     private void setCanFullscreen(final boolean canFullScreen) {
 831         if (target instanceof RootPaneContainer
 832                 &amp;&amp; getPeer().getPeerType() == PeerType.FRAME) {
 833 
 834             if (isInFullScreen &amp;&amp; !canFullScreen) {
 835                 toggleFullScreen();
 836             }
 837 
 838             final RootPaneContainer rpc = (RootPaneContainer) target;
 839             rpc.getRootPane().putClientProperty(
 840                     CPlatformWindow.WINDOW_FULLSCREENABLE, canFullScreen);
 841         }
 842     }
 843 
 844     @Override
 845     public void setResizable(final boolean resizable) {
 846         setCanFullscreen(resizable);
 847         setStyleBits(RESIZABLE, resizable);
 848         setStyleBits(ZOOMABLE, resizable);
 849     }
 850 
 851     @Override
 852     public void setSizeConstraints(int minW, int minH, int maxW, int maxH) {
 853         execute(ptr -&gt; nativeSetNSWindowMinMax(ptr, minW, minH, maxW, maxH));
 854     }
 855 
 856     @Override
 857     public boolean rejectFocusRequest(FocusEvent.Cause cause) {
 858         // Cross-app activation requests are not allowed.
 859         if (cause != FocusEvent.Cause.MOUSE_EVENT &amp;&amp;
 860             !((LWCToolkit)Toolkit.getDefaultToolkit()).isApplicationActive())
 861         {
 862             focusLogger.fine(&quot;the app is inactive, so the request is rejected&quot;);
 863             return true;
 864         }
 865         return false;
 866     }
 867 
 868     @Override
 869     public boolean requestWindowFocus() {
 870         execute(ptr -&gt; {
 871             if (CWrapper.NSWindow.canBecomeMainWindow(ptr)) {
 872                 CWrapper.NSWindow.makeMainWindow(ptr);
 873             }
 874             CWrapper.NSWindow.makeKeyAndOrderFront(ptr);
 875         });
 876         return true;
 877     }
 878 
 879     @Override
 880     public boolean isActive() {
 881         AtomicBoolean ref = new AtomicBoolean();
 882         execute(ptr -&gt; {
 883             ref.set(CWrapper.NSWindow.isKeyWindow(ptr));
 884         });
 885         return ref.get();
 886     }
 887 
 888     @Override
 889     public void updateFocusableWindowState() {
 890         final boolean isFocusable = isNativelyFocusableWindow();
 891         setStyleBits(SHOULD_BECOME_KEY | SHOULD_BECOME_MAIN, isFocusable); // set both bits at once
 892     }
 893 
 894     @Override
 895     public void setAlwaysOnTop(boolean isAlwaysOnTop) {
 896         setStyleBits(ALWAYS_ON_TOP, isAlwaysOnTop);
 897     }
 898 
 899     @Override
 900     public void setOpacity(float opacity) {
 901         execute(ptr -&gt; CWrapper.NSWindow.setAlphaValue(ptr, opacity));
 902     }
 903 
 904     @Override
 905     public void setOpaque(boolean isOpaque) {
 906         execute(ptr -&gt; CWrapper.NSWindow.setOpaque(ptr, isOpaque));
 907         boolean isTextured = (peer == null) ? false : peer.isTextured();
 908         if (!isTextured) {
 909             if (!isOpaque) {
 910                 execute(ptr -&gt; CWrapper.NSWindow.setBackgroundColor(ptr, 0));
 911             } else if (peer != null) {
 912                 Color color = peer.getBackground();
 913                 if (color != null) {
 914                     int rgb = color.getRGB();
 915                     execute(ptr-&gt;CWrapper.NSWindow.setBackgroundColor(ptr, rgb));
 916                 }
 917             }
 918         }
 919 
 920         //This is a temporary workaround. Looks like after 7124236 will be fixed
 921         //the correct place for invalidateShadow() is CGLayer.drawInCGLContext.
 922         SwingUtilities.invokeLater(this::invalidateShadow);
 923     }
 924 
 925     @Override
 926     public void enterFullScreenMode() {
 927         isFullScreenMode = true;
 928         execute(CPlatformWindow::nativeEnterFullScreenMode);
 929     }
 930 
 931     @Override
 932     public void exitFullScreenMode() {
 933         execute(CPlatformWindow::nativeExitFullScreenMode);
 934         isFullScreenMode = false;
 935     }
 936 
 937     @Override
 938     public boolean isFullScreenMode() {
 939         return isFullScreenMode;
 940     }
 941 
 942     @Override
 943     public void setWindowState(int windowState) {
 944         if (peer == null || !peer.isVisible()) {
 945             // setVisible() applies the state
 946             return;
 947         }
 948 
 949         int prevWindowState = peer.getState();
 950         if (prevWindowState == windowState) return;
 951 
 952         if ((windowState &amp; Frame.ICONIFIED) != 0) {
 953             // Treat all state bit masks with ICONIFIED bit as ICONIFIED state.
 954             windowState = Frame.ICONIFIED;
 955         }
 956 
 957         switch (windowState) {
 958             case Frame.ICONIFIED:
 959                 if (prevWindowState == Frame.MAXIMIZED_BOTH) {
 960                     // let&#39;s return into the normal states first
 961                     // the zoom call toggles between the normal and the max states
 962                     unmaximize();
 963                 }
 964                 execute(CWrapper.NSWindow::miniaturize);
 965                 break;
 966             case Frame.MAXIMIZED_BOTH:
 967                 if (prevWindowState == Frame.ICONIFIED) {
 968                     // let&#39;s return into the normal states first
 969                     execute(CWrapper.NSWindow::deminiaturize);
 970                 }
 971                 maximize();
 972                 break;
 973             case Frame.NORMAL:
 974                 if (prevWindowState == Frame.ICONIFIED) {
 975                     execute(CWrapper.NSWindow::deminiaturize);
 976                 } else if (prevWindowState == Frame.MAXIMIZED_BOTH) {
 977                     // the zoom call toggles between the normal and the max states
 978                     unmaximize();
 979                 }
 980                 break;
 981             default:
 982                 throw new RuntimeException(&quot;Unknown window state: &quot; + windowState);
 983         }
 984 
 985         // NOTE: the SWP.windowState field gets updated to the newWindowState
 986         //       value when the native notification comes to us
 987     }
 988 
 989     @Override
 990     public void setModalBlocked(boolean blocked) {
 991         if (target.getModalExclusionType() == Dialog.ModalExclusionType.APPLICATION_EXCLUDE) {
 992             return;
 993         }
 994 
 995         if (blocked) {
 996             // We are going to show a modal window. Previously displayed window will be
 997             // blocked/disabled. So we have to send mouse exited event to it now, since
 998             // all mouse events are discarded for blocked/disabled windows.
 999             execute(ptr -&gt; nativeSynthesizeMouseEnteredExitedEvents(ptr, CocoaConstants.NSMouseExited));
1000         }
1001 
1002         execute(ptr -&gt; nativeSetEnabled(ptr, !blocked));
1003         checkBlockingAndOrder();
1004     }
1005 
1006     public final void invalidateShadow() {
1007         execute(ptr -&gt; nativeRevalidateNSWindowShadow(ptr));
1008     }
1009 
1010     // ----------------------------------------------------------------------
1011     //                          UTILITY METHODS
1012     // ----------------------------------------------------------------------
1013 
1014     /**
1015      * Find image to install into Title or into Application icon. First try
1016      * icons installed for toplevel. Null is returned, if there is no icon and
1017      * default Duke image should be used.
1018      */
1019     private CImage getImageForTarget() {
1020         CImage icon = null;
1021         try {
1022             icon = CImage.getCreator().createFromImages(target.getIconImages());
1023         } catch (Exception ignored) {
1024             // Perhaps the icon passed into Java is broken. Skipping this icon.
1025         }
1026         return icon;
1027     }
1028 
1029     /*
1030      * Returns LWWindowPeer associated with this delegate.
1031      */
1032     @Override
1033     public LWWindowPeer getPeer() {
1034         return peer;
1035     }
1036 
1037     @Override
1038     public boolean isUnderMouse() {
1039         return contentView.isUnderMouse();
1040     }
1041 
1042     public CPlatformView getContentView() {
1043         return contentView;
1044     }
1045 
1046     @Override
1047     public long getLayerPtr() {
1048         return contentView.getWindowLayerPtr();
1049     }
1050 
<a name="8" id="anc8"></a>






1051     void flushBuffers() {
1052         if (isVisible() &amp;&amp; !nativeBounds.isEmpty() &amp;&amp; !isFullScreenMode) {
1053             try {
1054                 LWCToolkit.invokeAndWait(new Runnable() {
1055                     @Override
1056                     public void run() {
1057                         //Posting an empty to flush the EventQueue without blocking the main thread
1058                     }
1059                 }, target);
1060             } catch (InvocationTargetException e) {
1061                 e.printStackTrace();
1062             }
1063         }
1064     }
1065 
1066     /**
1067      * Helper method to get a pointer to the native view from the PlatformWindow.
1068      */
1069     static long getNativeViewPtr(PlatformWindow platformWindow) {
1070         long nativePeer = 0L;
1071         if (platformWindow instanceof CPlatformWindow) {
1072             nativePeer = ((CPlatformWindow) platformWindow).getContentView().getAWTView();
1073         } else if (platformWindow instanceof CViewPlatformEmbeddedFrame){
1074             nativePeer = ((CViewPlatformEmbeddedFrame) platformWindow).getNSViewPtr();
1075         }
1076         return nativePeer;
1077     }
1078 
1079     /*************************************************************
1080      * Callbacks from the AWTWindow and AWTView objc classes.
1081      *************************************************************/
1082     private void deliverWindowFocusEvent(boolean gained, CPlatformWindow opposite){
1083         // Fix for 7150349: ingore &quot;gained&quot; notifications when the app is inactive.
1084         if (gained &amp;&amp; !((LWCToolkit)Toolkit.getDefaultToolkit()).isApplicationActive()) {
1085             focusLogger.fine(&quot;the app is inactive, so the notification is ignored&quot;);
1086             return;
1087         }
1088 
1089         LWWindowPeer oppositePeer = (opposite == null)? null : opposite.getPeer();
1090         responder.handleWindowFocusEvent(gained, oppositePeer);
1091     }
1092 
1093     protected void deliverMoveResizeEvent(int x, int y, int width, int height,
1094                                         boolean byUser) {
1095         AtomicBoolean ref = new AtomicBoolean();
1096         execute(ptr -&gt; {
1097             ref.set(CWrapper.NSWindow.isZoomed(ptr));
1098         });
1099         isZoomed = ref.get();
1100         checkZoom();
1101 
1102         final Rectangle oldB = nativeBounds;
1103         nativeBounds = new Rectangle(x, y, width, height);
1104         if (peer != null) {
1105             peer.notifyReshape(x, y, width, height);
1106             // System-dependent appearance optimization.
1107             if ((byUser &amp;&amp; !oldB.getSize().equals(nativeBounds.getSize()))
1108                     || isFullScreenAnimationOn) {
1109                 flushBuffers();
1110             }
1111         }
1112     }
1113 
1114     private void deliverWindowClosingEvent() {
1115         if (peer != null &amp;&amp; peer.getBlocker() == null) {
1116             peer.postEvent(new WindowEvent(target, WindowEvent.WINDOW_CLOSING));
1117         }
1118     }
1119 
1120     private void deliverIconify(final boolean iconify) {
1121         if (peer != null) {
1122             peer.notifyIconify(iconify);
1123         }
1124         if (iconify) {
1125             isIconifyAnimationActive = false;
1126         }
1127     }
1128 
1129     private void deliverZoom(final boolean isZoomed) {
1130         if (peer != null) {
1131             peer.notifyZoom(isZoomed);
1132         }
1133     }
1134 
1135     private void checkZoom() {
1136         if (peer != null) {
1137             int state = peer.getState();
1138             if (state != Frame.MAXIMIZED_BOTH &amp;&amp; isMaximized()) {
1139                 deliverZoom(true);
1140             } else if (state == Frame.MAXIMIZED_BOTH &amp;&amp; !isMaximized()) {
1141                 deliverZoom(false);
1142             }
1143         }
1144     }
1145 
1146     private void deliverNCMouseDown() {
1147         if (peer != null) {
1148             peer.notifyNCMouseDown();
1149         }
1150     }
1151 
1152     /*
1153      * Our focus model is synthetic and only non-simple window
1154      * may become natively focusable window.
1155      */
1156     private boolean isNativelyFocusableWindow() {
1157         if (peer == null) {
1158             return false;
1159         }
1160 
1161         return !peer.isSimpleWindow() &amp;&amp; target.getFocusableWindowState();
1162     }
1163 
1164     private boolean isBlocked() {
1165         LWWindowPeer blocker = (peer != null) ? peer.getBlocker() : null;
1166         return (blocker != null);
1167     }
1168 
1169     /*
1170      * An utility method for the support of the auto request focus.
1171      * Updates the focusable state of the window under certain
1172      * circumstances.
1173      */
1174     private void updateFocusabilityForAutoRequestFocus(boolean isFocusable) {
1175         if (target.isAutoRequestFocus() || !isNativelyFocusableWindow()) return;
1176         setStyleBits(SHOULD_BECOME_KEY | SHOULD_BECOME_MAIN, isFocusable); // set both bits at once
1177     }
1178 
1179     private boolean checkBlockingAndOrder() {
1180         LWWindowPeer blocker = (peer == null)? null : peer.getBlocker();
1181         if (blocker == null) {
1182             return false;
1183         }
1184 
1185         if (blocker instanceof CPrinterDialogPeer) {
1186             return true;
1187         }
1188 
1189         CPlatformWindow pWindow = (CPlatformWindow)blocker.getPlatformWindow();
1190 
1191         pWindow.orderAboveSiblings();
1192 
1193         pWindow.execute(ptr -&gt; {
1194             CWrapper.NSWindow.orderFrontRegardless(ptr);
1195             CWrapper.NSWindow.makeKeyAndOrderFront(ptr);
1196             CWrapper.NSWindow.makeMainWindow(ptr);
1197         });
1198         return true;
1199     }
1200 
1201     private boolean isIconified() {
1202         boolean isIconified = false;
1203         if (target instanceof Frame) {
1204             int state = ((Frame)target).getExtendedState();
1205             if ((state &amp; Frame.ICONIFIED) != 0) {
1206                 isIconified = true;
1207             }
1208         }
1209         return isIconifyAnimationActive || isIconified;
1210     }
1211 
1212     private boolean isOneOfOwnersOrSelf(CPlatformWindow window) {
1213         while (window != null) {
1214             if (this == window) {
1215                 return true;
1216             }
1217             window = window.owner;
1218         }
1219         return false;
1220     }
1221 
1222     private CPlatformWindow getRootOwner() {
1223         CPlatformWindow rootOwner = this;
1224         while (rootOwner.owner != null) {
1225             rootOwner = rootOwner.owner;
1226         }
1227         return rootOwner;
1228     }
1229 
1230     private void orderAboveSiblings() {
1231         // Recursively pop up the windows from the very bottom, (i.e. root owner) so that
1232         // the windows are ordered above their nearest owner; ancestors of the window,
1233         // which is going to become &#39;main window&#39;, are placed above their siblings.
1234         CPlatformWindow rootOwner = getRootOwner();
1235         if (rootOwner.isVisible() &amp;&amp; !rootOwner.isIconified() &amp;&amp; !rootOwner.isActive()) {
1236             rootOwner.execute(CWrapper.NSWindow::orderFront);
1237         }
1238 
1239         // Do not order child windows of iconified owner.
1240         if (!rootOwner.isIconified()) {
1241             final WindowAccessor windowAccessor = AWTAccessor.getWindowAccessor();
1242             orderAboveSiblingsImpl(windowAccessor.getOwnedWindows(rootOwner.target));
1243         }
1244     }
1245 
1246     private void orderAboveSiblingsImpl(Window[] windows) {
1247         ArrayList&lt;Window&gt; childWindows = new ArrayList&lt;Window&gt;();
1248 
1249         final ComponentAccessor componentAccessor = AWTAccessor.getComponentAccessor();
1250         final WindowAccessor windowAccessor = AWTAccessor.getWindowAccessor();
1251         Arrays.sort(windows, siblingsComparator);
1252         // Go through the list of windows and perform ordering.
1253         CPlatformWindow pwUnder = null;
1254         for (Window w : windows) {
1255             boolean iconified = false;
1256             final Object p = componentAccessor.getPeer(w);
1257             if (p instanceof LWWindowPeer) {
1258                 CPlatformWindow pw = (CPlatformWindow)((LWWindowPeer)p).getPlatformWindow();
1259                 iconified = isIconified();
1260                 if (pw != null &amp;&amp; pw.isVisible() &amp;&amp; !iconified) {
1261                     // If the window is one of ancestors of &#39;main window&#39; or is going to become main by itself,
1262                     // the window should be ordered above its siblings; otherwise the window is just ordered
1263                     // above its nearest parent.
1264                     if (pw.isOneOfOwnersOrSelf(this)) {
1265                         pw.execute(CWrapper.NSWindow::orderFront);
1266                     } else {
1267                         if (pwUnder == null) {
1268                             pwUnder = pw.owner;
1269                         }
1270                         pwUnder.execute(underPtr -&gt; {
1271                             pw.execute(ptr -&gt; {
1272                                 CWrapper.NSWindow.orderWindow(ptr, CWrapper.NSWindow.NSWindowAbove, underPtr);
1273                             });
1274                         });
1275                         pwUnder = pw;
1276                     }
1277                     pw.applyWindowLevel(w);
1278                 }
1279             }
1280             // Retrieve the child windows for each window from the list except iconified ones
1281             // and store them for future use.
1282             // Note: we collect data about child windows even for invisible owners, since they may have
1283             // visible children.
1284             if (!iconified) {
1285                 childWindows.addAll(Arrays.asList(windowAccessor.getOwnedWindows(w)));
1286             }
1287         }
1288         // If some windows, which have just been ordered, have any child windows, let&#39;s start new iteration
1289         // and order these child windows.
1290         if (!childWindows.isEmpty()) {
1291             orderAboveSiblingsImpl(childWindows.toArray(new Window[0]));
1292         }
1293     }
1294 
1295     protected void applyWindowLevel(Window target) {
1296         if (target.isAlwaysOnTop() &amp;&amp; target.getType() != Window.Type.POPUP) {
1297             execute(ptr-&gt;CWrapper.NSWindow.setLevel(ptr, CWrapper.NSWindow.NSFloatingWindowLevel));
1298         } else if (target.getType() == Window.Type.POPUP) {
1299             execute(ptr-&gt;CWrapper.NSWindow.setLevel(ptr, CWrapper.NSWindow.NSPopUpMenuWindowLevel));
1300         }
1301     }
1302 
1303     private Window getOwnerFrameOrDialog(Window window) {
1304         Window owner = window.getOwner();
1305         while (owner != null &amp;&amp; !(owner instanceof Frame || owner instanceof Dialog)) {
1306             owner = owner.getOwner();
1307         }
1308         return owner;
1309     }
1310 
1311     private boolean isSimpleWindowOwnedByEmbeddedFrame() {
1312         if (peer != null &amp;&amp; peer.isSimpleWindow()) {
1313             return (getOwnerFrameOrDialog(target) instanceof CEmbeddedFrame);
1314         }
1315         return false;
1316     }
1317     // ----------------------------------------------------------------------
1318     //                          NATIVE CALLBACKS
1319     // ----------------------------------------------------------------------
1320 
1321     private void windowWillMiniaturize() {
1322         isIconifyAnimationActive = true;
1323     }
1324 
1325     private void windowDidBecomeMain() {
1326         lastBecomeMainTime = System.currentTimeMillis();
1327         if (checkBlockingAndOrder()) return;
1328         // If it&#39;s not blocked, make sure it&#39;s above its siblings
1329         orderAboveSiblings();
1330     }
1331 
1332     private void windowWillEnterFullScreen() {
1333         isFullScreenAnimationOn = true;
1334     }
1335 
1336     private void windowDidEnterFullScreen() {
1337         isInFullScreen = true;
1338         isFullScreenAnimationOn = false;
1339     }
1340 
1341     private void windowWillExitFullScreen() {
1342         isFullScreenAnimationOn = true;
1343     }
1344 
1345     private void windowDidExitFullScreen() {
1346         isInFullScreen = false;
1347         isFullScreenAnimationOn = false;
1348     }
1349 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
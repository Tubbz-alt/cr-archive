<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/classes/sun/awt/CGraphicsDevice.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.awt;
 27 
 28 import java.awt.AWTPermission;
 29 import java.awt.DisplayMode;
 30 import java.awt.GraphicsConfiguration;
 31 import java.awt.GraphicsDevice;
 32 import java.awt.Insets;
 33 import java.awt.Rectangle;
 34 import java.awt.Window;
 35 import java.awt.geom.Rectangle2D;
<a name="1" id="anc1"></a>
 36 import java.util.Objects;
 37 
 38 import sun.java2d.SunGraphicsEnvironment;
 39 import sun.java2d.opengl.CGLGraphicsConfig;
 40 
<a name="2" id="anc2"></a>

 41 public final class CGraphicsDevice extends GraphicsDevice
 42         implements DisplayChangedListener {
 43 
 44     /**
 45      * CoreGraphics display ID. This identifier can become non-valid at any time
 46      * therefore methods, which is using this id should be ready to it.
 47      */
 48     private volatile int displayID;
 49     private volatile double xResolution;
 50     private volatile double yResolution;
 51     private volatile Rectangle bounds;
 52     private volatile int scale;
 53 
 54     private final GraphicsConfiguration config;
 55 
 56     private static AWTPermission fullScreenExclusivePermission;
 57 
 58     // Save/restore DisplayMode for the Full Screen mode
 59     private DisplayMode originalMode;
 60 
 61     public CGraphicsDevice(final int displayID) {
 62         this.displayID = displayID;
 63         config = CGLGraphicsConfig.getConfig(this, displayID, 0);
<a name="3" id="anc3"></a>



 64     }
 65 
 66     /**
 67      * Return a list of all configurations.
 68      */
 69     @Override
 70     public GraphicsConfiguration[] getConfigurations() {
 71         return new GraphicsConfiguration[]{config};
 72     }
 73 
 74     /**
 75      * Return the default configuration.
 76      */
 77     @Override
 78     public GraphicsConfiguration getDefaultConfiguration() {
 79         return config;
 80     }
 81 
 82     /**
 83      * Return a human-readable screen description.
 84      */
 85     @Override
 86     public String getIDstring() {
 87         return &quot;Display &quot; + displayID;
 88     }
 89 
 90     /**
 91      * Returns the type of the graphics device.
 92      * @see #TYPE_RASTER_SCREEN
 93      * @see #TYPE_PRINTER
 94      * @see #TYPE_IMAGE_BUFFER
 95      */
 96     @Override
 97     public int getType() {
 98         return TYPE_RASTER_SCREEN;
 99     }
100 
101     public double getXResolution() {
102         return xResolution;
103     }
104 
105     public double getYResolution() {
106         return yResolution;
107     }
108 
109     Rectangle getBounds() {
110         return bounds.getBounds();
111     }
112 
113     public Insets getScreenInsets() {
114         // the insets are queried synchronously and are not cached
115         // since there are no Quartz or Cocoa means to receive notifications
116         // on insets changes (e.g. when the Dock is resized):
117         // the existing CGDisplayReconfigurationCallBack is not notified
118         // as well as the NSApplicationDidChangeScreenParametersNotification
119         // is fired on the Dock location changes only
120         return nativeGetScreenInsets(displayID);
121     }
122 
123     public int getScaleFactor() {
124         return scale;
125     }
126 
127     public void invalidate(final int defaultDisplayID) {
<a name="4" id="anc4"></a>
128         displayID = defaultDisplayID;
129     }
130 
131     @Override
132     public void displayChanged() {
133         xResolution = nativeGetXResolution(displayID);
134         yResolution = nativeGetYResolution(displayID);
135         bounds = nativeGetBounds(displayID).getBounds(); //does integer rounding
136         initScaleFactor();
<a name="5" id="anc5"></a><span class="line-modified">137         //TODO configs/fullscreenWindow/modes?</span>

138     }
139 
140     @Override
141     public void paletteChanged() {
142         // devices do not need to react to this event.
143     }
144 
145     /**
146      * Enters full-screen mode, or returns to windowed mode.
147      */
148     @Override
149     public synchronized void setFullScreenWindow(Window w) {
150         Window old = getFullScreenWindow();
151         if (w == old) {
152             return;
153         }
154 
155         boolean fsSupported = isFullScreenSupported();
156 
157         if (fsSupported &amp;&amp; old != null) {
158             // enter windowed mode and restore original display mode
159             exitFullScreenExclusive(old);
160             if (originalMode != null) {
161                 setDisplayMode(originalMode);
162                 originalMode = null;
163             }
164         }
165 
166         super.setFullScreenWindow(w);
167 
168         if (fsSupported &amp;&amp; w != null) {
169             if (isDisplayChangeSupported()) {
170                 originalMode = getDisplayMode();
171             }
172             // enter fullscreen mode
173             enterFullScreenExclusive(w);
174         }
175     }
176 
177     /**
178      * Returns true if this GraphicsDevice supports
179      * full-screen exclusive mode and false otherwise.
180      */
181     @Override
182     public boolean isFullScreenSupported() {
183         return isFSExclusiveModeAllowed();
184     }
185 
186     private static boolean isFSExclusiveModeAllowed() {
187         SecurityManager security = System.getSecurityManager();
188         if (security != null) {
189             if (fullScreenExclusivePermission == null) {
190                 fullScreenExclusivePermission =
191                     new AWTPermission(&quot;fullScreenExclusive&quot;);
192             }
193             try {
194                 security.checkPermission(fullScreenExclusivePermission);
195             } catch (SecurityException e) {
196                 return false;
197             }
198         }
199         return true;
200     }
201 
202     private static void enterFullScreenExclusive(Window w) {
203         FullScreenCapable peer = AWTAccessor.getComponentAccessor().getPeer(w);
204         if (peer != null) {
205             peer.enterFullScreenMode();
206         }
207     }
208 
209     private static void exitFullScreenExclusive(Window w) {
210         FullScreenCapable peer = AWTAccessor.getComponentAccessor().getPeer(w);
211         if (peer != null) {
212             peer.exitFullScreenMode();
213         }
214     }
215 
<a name="6" id="anc6"></a>











216     @Override
217     public boolean isDisplayChangeSupported() {
218         return true;
219     }
220 
221     @Override
222     public void setDisplayMode(final DisplayMode dm) {
223         if (dm == null) {
224             throw new IllegalArgumentException(&quot;Invalid display mode&quot;);
225         }
226         if (!Objects.equals(dm, getDisplayMode())) {
227             nativeSetDisplayMode(displayID, dm.getWidth(), dm.getHeight(),
<a name="7" id="anc7"></a><span class="line-modified">228                     dm.getBitDepth(), dm.getRefreshRate());</span>
<span class="line-removed">229             if (isFullScreenSupported() &amp;&amp; getFullScreenWindow() != null) {</span>
<span class="line-removed">230                 getFullScreenWindow().setSize(dm.getWidth(), dm.getHeight());</span>
<span class="line-removed">231             }</span>
232         }
233     }
234 
235     @Override
236     public DisplayMode getDisplayMode() {
237         return nativeGetDisplayMode(displayID);
238     }
239 
240     @Override
241     public DisplayMode[] getDisplayModes() {
242         return nativeGetDisplayModes(displayID);
243     }
244 
245     private void initScaleFactor() {
246         if (SunGraphicsEnvironment.isUIScaleEnabled()) {
247             double debugScale = SunGraphicsEnvironment.getDebugScale();
248             scale = (int) (debugScale &gt;= 1
249                     ? Math.round(debugScale)
250                     : nativeGetScaleFactor(displayID));
251         } else {
252             scale = 1;
253         }
254     }
255 
256     private static native double nativeGetScaleFactor(int displayID);
257 
258     private static native void nativeSetDisplayMode(int displayID, int w, int h, int bpp, int refrate);
259 
260     private static native DisplayMode nativeGetDisplayMode(int displayID);
261 
262     private static native DisplayMode[] nativeGetDisplayModes(int displayID);
263 
264     private static native double nativeGetXResolution(int displayID);
265 
266     private static native double nativeGetYResolution(int displayID);
267 
268     private static native Insets nativeGetScreenInsets(int displayID);
269 
270     private static native Rectangle2D nativeGetBounds(int displayID);
271 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
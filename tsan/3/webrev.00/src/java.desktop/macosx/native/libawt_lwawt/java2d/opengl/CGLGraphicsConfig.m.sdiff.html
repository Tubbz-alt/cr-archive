<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/opengl/CGLGraphicsConfig.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CGLGraphicsConfig.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CGLLayer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/opengl/CGLGraphicsConfig.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 63             NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
 64             [NSOpenGLContext clearCurrentContext];
 65             [ctxinfo-&gt;context clearDrawable];
 66             [ctxinfo-&gt;context release];
 67             if (ctxinfo-&gt;scratchSurface != 0) {
 68                 [ctxinfo-&gt;scratchSurface release];
 69             }
 70             [pool drain];
 71             free(ctxinfo);
 72             oglc-&gt;ctxInfo = NULL;
 73         }
 74         cglinfo-&gt;context = NULL;
 75     }
 76 
 77     free(cglinfo);
 78 }
 79 
 80 #pragma mark -
 81 #pragma mark &quot;--- CGLGraphicsConfig methods ---&quot;
 82 
<span class="line-removed"> 83 #ifdef REMOTELAYER</span>
<span class="line-removed"> 84 mach_port_t JRSRemotePort;</span>
<span class="line-removed"> 85 int remoteSocketFD = -1;</span>
<span class="line-removed"> 86 </span>
<span class="line-removed"> 87 static void *JRSRemoteThreadFn(void *data) {</span>
<span class="line-removed"> 88     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];</span>
<span class="line-removed"> 89 </span>
<span class="line-removed"> 90     // Negotiate a unix domain socket to communicate the</span>
<span class="line-removed"> 91     // out of band data: to read the mach port server name, and</span>
<span class="line-removed"> 92     // subsequently write out the layer ID.</span>
<span class="line-removed"> 93     static char* sock_path = &quot;/tmp/JRSRemoteDemoSocket&quot;;</span>
<span class="line-removed"> 94     struct sockaddr_un address;</span>
<span class="line-removed"> 95     int  socket_fd, nbytes;</span>
<span class="line-removed"> 96     int BUFLEN = 256;</span>
<span class="line-removed"> 97     char buffer[BUFLEN];</span>
<span class="line-removed"> 98 </span>
<span class="line-removed"> 99     remoteSocketFD = socket(PF_LOCAL, SOCK_STREAM, 0);</span>
<span class="line-removed">100     if (remoteSocketFD &lt; 0) {</span>
<span class="line-removed">101         NSLog(@&quot;socket() failed&quot;);</span>
<span class="line-removed">102         return NULL;</span>
<span class="line-removed">103     }</span>
<span class="line-removed">104     memset(&amp;address, 0, sizeof(struct sockaddr_un));</span>
<span class="line-removed">105     address.sun_family = AF_UNIX;</span>
<span class="line-removed">106     memcpy(address.sun_path, sock_path, strlen(sock_path)+1);</span>
<span class="line-removed">107     int tries=0, status=-1;</span>
<span class="line-removed">108     while (status !=0 &amp;&amp; tries&lt;600) {</span>
<span class="line-removed">109         status = connect(remoteSocketFD, (struct sockaddr *) &amp;address,</span>
<span class="line-removed">110                          sizeof(struct sockaddr_un));</span>
<span class="line-removed">111         if (status != 0) {</span>
<span class="line-removed">112             tries++;</span>
<span class="line-removed">113             NSLog(@&quot;connection attempt %d failed.&quot;, tries);</span>
<span class="line-removed">114             usleep(5000000);</span>
<span class="line-removed">115         }</span>
<span class="line-removed">116     }</span>
<span class="line-removed">117     if (status != 0) {</span>
<span class="line-removed">118         NSLog(@&quot;failed to connect&quot;);</span>
<span class="line-removed">119         return NULL;</span>
<span class="line-removed">120     }</span>
<span class="line-removed">121     nbytes = read(remoteSocketFD, buffer, BUFLEN);</span>
<span class="line-removed">122     NSString* serverString = [[NSString alloc] initWithUTF8String:buffer];</span>
<span class="line-removed">123     CFRetain(serverString);</span>
<span class="line-removed">124     NSLog(@&quot;Read server name %@&quot;, serverString);</span>
<span class="line-removed">125     JRSRemotePort = [JRSRenderServer recieveRenderServer:serverString];</span>
<span class="line-removed">126     NSLog(@&quot;Read server port %d&quot;, JRSRemotePort);</span>
<span class="line-removed">127 </span>
<span class="line-removed">128     [pool drain];</span>
<span class="line-removed">129     return NULL;</span>
<span class="line-removed">130 }</span>
<span class="line-removed">131 </span>
<span class="line-removed">132 void sendLayerID(int layerID) {</span>
<span class="line-removed">133     if (JRSRemotePort == 0 || remoteSocketFD &lt; 0) {</span>
<span class="line-removed">134         NSLog(@&quot;No connection to send ID&quot;);</span>
<span class="line-removed">135         return;</span>
<span class="line-removed">136     }</span>
<span class="line-removed">137     int BUFLEN = 256;</span>
<span class="line-removed">138     char buffer[BUFLEN];</span>
<span class="line-removed">139     snprintf(buffer, BUFLEN, &quot;%d&quot;, layerID);</span>
<span class="line-removed">140     write(remoteSocketFD, buffer, BUFLEN);</span>
<span class="line-removed">141 }</span>
<span class="line-removed">142 #endif  /* REMOTELAYER */</span>
<span class="line-removed">143 </span>
144 /**
145  * This is a globally shared context used when creating textures.  When any
146  * new contexts are created, they specify this context as the &quot;share list&quot;
147  * context, which means any texture objects created when this shared context
148  * is current will be available to any other context in any other thread.
149  */
150 NSOpenGLContext *sharedContext = NULL;
151 NSOpenGLPixelFormat *sharedPixelFormat = NULL;
152 
153 /**
154  * Attempts to initialize CGL and the core OpenGL library.
155  */
156 JNIEXPORT jboolean JNICALL
157 Java_sun_java2d_opengl_CGLGraphicsConfig_initCGL
158     (JNIEnv *env, jclass cglgc)
159 {
160     J2dRlsTraceLn(J2D_TRACE_INFO, &quot;CGLGraphicsConfig_initCGL&quot;);
161 
162     if (!OGLFuncs_OpenLibrary()) {
163         return JNI_FALSE;
164     }
165 
166     if (!OGLFuncs_InitPlatformFuncs() ||
167         !OGLFuncs_InitBaseFuncs() ||
168         !OGLFuncs_InitExtFuncs())
169     {
170         OGLFuncs_CloseLibrary();
171         return JNI_FALSE;
172     }
<span class="line-removed">173 #ifdef REMOTELAYER</span>
<span class="line-removed">174     pthread_t jrsRemoteThread;</span>
<span class="line-removed">175     pthread_create(&amp;jrsRemoteThread, NULL, JRSRemoteThreadFn, NULL);</span>
<span class="line-removed">176 #endif</span>
177     return JNI_TRUE;
178 }
179 
180 
181 /**
182  * Determines whether the CGL pipeline can be used for a given GraphicsConfig
183  * provided its screen number and visual ID.  If the minimum requirements are
184  * met, the native CGLGraphicsConfigInfo structure is initialized for this
185  * GraphicsConfig with the necessary information (pixel format, etc.)
186  * and a pointer to this structure is returned as a jlong.  If
187  * initialization fails at any point, zero is returned, indicating that CGL
188  * cannot be used for this GraphicsConfig (we should fallback on an existing
189  * 2D pipeline).
190  */
191 JNIEXPORT jlong JNICALL
192 Java_sun_java2d_opengl_CGLGraphicsConfig_getCGLConfigInfo
193     (JNIEnv *env, jclass cglgc,
194      jint displayID, jint pixfmt, jint swapInterval)
195 {
196   jlong ret = 0L;
</pre>
<hr />
<pre>
200   [retArray addObject: [NSNumber numberWithInt: (int)pixfmt]];
201   [retArray addObject: [NSNumber numberWithInt: (int)swapInterval]];
202   if ([NSThread isMainThread]) {
203       [GraphicsConfigUtil _getCGLConfigInfo: retArray];
204   } else {
205       [GraphicsConfigUtil performSelectorOnMainThread: @selector(_getCGLConfigInfo:) withObject: retArray waitUntilDone: YES];
206   }
207   NSNumber * num = (NSNumber *)[retArray objectAtIndex: 0];
208   ret = (jlong)[num longValue];
209   JNF_COCOA_EXIT(env);
210   return ret;
211 }
212 
213 
214 
215 @implementation GraphicsConfigUtil
216 + (void) _getCGLConfigInfo: (NSMutableArray *)argValue {
217     AWT_ASSERT_APPKIT_THREAD;
218 
219     jint displayID = (jint)[(NSNumber *)[argValue objectAtIndex: 0] intValue];
<span class="line-removed">220     jint pixfmt = (jint)[(NSNumber *)[argValue objectAtIndex: 1] intValue];</span>
221     jint swapInterval = (jint)[(NSNumber *)[argValue objectAtIndex: 2] intValue];
222     JNIEnv *env = [ThreadUtilities getJNIEnvUncached];
223     [argValue removeAllObjects];
224 
225     J2dRlsTraceLn(J2D_TRACE_INFO, &quot;CGLGraphicsConfig_getCGLConfigInfo&quot;);
226 
227     NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
228 
<span class="line-removed">229     CGOpenGLDisplayMask glMask = (CGOpenGLDisplayMask)pixfmt;</span>
230     if (sharedContext == NULL) {
<span class="line-removed">231         if (glMask == 0) {</span>
<span class="line-removed">232             glMask = CGDisplayIDToOpenGLDisplayMask(displayID);</span>
<span class="line-removed">233         }</span>
234 
235         NSOpenGLPixelFormatAttribute attrs[] = {
236             NSOpenGLPFAAllowOfflineRenderers,
237             NSOpenGLPFAClosestPolicy,
238             NSOpenGLPFAWindow,
239             NSOpenGLPFAPixelBuffer,
240             NSOpenGLPFADoubleBuffer,
241             NSOpenGLPFAColorSize, 32,
242             NSOpenGLPFAAlphaSize, 8,
243             NSOpenGLPFADepthSize, 16,
<span class="line-removed">244             NSOpenGLPFAScreenMask, glMask,</span>
245             0
246         };
247 
248         sharedPixelFormat =
249             [[NSOpenGLPixelFormat alloc] initWithAttributes:attrs];
250         if (sharedPixelFormat == nil) {
<span class="line-modified">251             J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: shared NSOpenGLPixelFormat is NULL&quot;);</span>
<span class="line-modified">252             [argValue addObject: [NSNumber numberWithLong: 0L]];</span>
<span class="line-modified">253             return;</span>


254         }
255 
256         sharedContext =
257             [[NSOpenGLContext alloc]
258                 initWithFormat:sharedPixelFormat
259                 shareContext: NULL];
260         if (sharedContext == nil) {
261             J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: shared NSOpenGLContext is NULL&quot;);
262             [argValue addObject: [NSNumber numberWithLong: 0L]];
263             return;
264         }
265     }
266 
267 #if USE_NSVIEW_FOR_SCRATCH
268     NSRect contentRect = NSMakeRect(0, 0, 64, 64);
269     NSWindow *window =
270         [[NSWindow alloc]
271             initWithContentRect: contentRect
272             styleMask: NSBorderlessWindowMask
273             backing: NSBackingStoreBuffered
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 63             NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
 64             [NSOpenGLContext clearCurrentContext];
 65             [ctxinfo-&gt;context clearDrawable];
 66             [ctxinfo-&gt;context release];
 67             if (ctxinfo-&gt;scratchSurface != 0) {
 68                 [ctxinfo-&gt;scratchSurface release];
 69             }
 70             [pool drain];
 71             free(ctxinfo);
 72             oglc-&gt;ctxInfo = NULL;
 73         }
 74         cglinfo-&gt;context = NULL;
 75     }
 76 
 77     free(cglinfo);
 78 }
 79 
 80 #pragma mark -
 81 #pragma mark &quot;--- CGLGraphicsConfig methods ---&quot;
 82 





























































 83 /**
 84  * This is a globally shared context used when creating textures.  When any
 85  * new contexts are created, they specify this context as the &quot;share list&quot;
 86  * context, which means any texture objects created when this shared context
 87  * is current will be available to any other context in any other thread.
 88  */
 89 NSOpenGLContext *sharedContext = NULL;
 90 NSOpenGLPixelFormat *sharedPixelFormat = NULL;
 91 
 92 /**
 93  * Attempts to initialize CGL and the core OpenGL library.
 94  */
 95 JNIEXPORT jboolean JNICALL
 96 Java_sun_java2d_opengl_CGLGraphicsConfig_initCGL
 97     (JNIEnv *env, jclass cglgc)
 98 {
 99     J2dRlsTraceLn(J2D_TRACE_INFO, &quot;CGLGraphicsConfig_initCGL&quot;);
100 
101     if (!OGLFuncs_OpenLibrary()) {
102         return JNI_FALSE;
103     }
104 
105     if (!OGLFuncs_InitPlatformFuncs() ||
106         !OGLFuncs_InitBaseFuncs() ||
107         !OGLFuncs_InitExtFuncs())
108     {
109         OGLFuncs_CloseLibrary();
110         return JNI_FALSE;
111     }




112     return JNI_TRUE;
113 }
114 
115 
116 /**
117  * Determines whether the CGL pipeline can be used for a given GraphicsConfig
118  * provided its screen number and visual ID.  If the minimum requirements are
119  * met, the native CGLGraphicsConfigInfo structure is initialized for this
120  * GraphicsConfig with the necessary information (pixel format, etc.)
121  * and a pointer to this structure is returned as a jlong.  If
122  * initialization fails at any point, zero is returned, indicating that CGL
123  * cannot be used for this GraphicsConfig (we should fallback on an existing
124  * 2D pipeline).
125  */
126 JNIEXPORT jlong JNICALL
127 Java_sun_java2d_opengl_CGLGraphicsConfig_getCGLConfigInfo
128     (JNIEnv *env, jclass cglgc,
129      jint displayID, jint pixfmt, jint swapInterval)
130 {
131   jlong ret = 0L;
</pre>
<hr />
<pre>
135   [retArray addObject: [NSNumber numberWithInt: (int)pixfmt]];
136   [retArray addObject: [NSNumber numberWithInt: (int)swapInterval]];
137   if ([NSThread isMainThread]) {
138       [GraphicsConfigUtil _getCGLConfigInfo: retArray];
139   } else {
140       [GraphicsConfigUtil performSelectorOnMainThread: @selector(_getCGLConfigInfo:) withObject: retArray waitUntilDone: YES];
141   }
142   NSNumber * num = (NSNumber *)[retArray objectAtIndex: 0];
143   ret = (jlong)[num longValue];
144   JNF_COCOA_EXIT(env);
145   return ret;
146 }
147 
148 
149 
150 @implementation GraphicsConfigUtil
151 + (void) _getCGLConfigInfo: (NSMutableArray *)argValue {
152     AWT_ASSERT_APPKIT_THREAD;
153 
154     jint displayID = (jint)[(NSNumber *)[argValue objectAtIndex: 0] intValue];

155     jint swapInterval = (jint)[(NSNumber *)[argValue objectAtIndex: 2] intValue];
156     JNIEnv *env = [ThreadUtilities getJNIEnvUncached];
157     [argValue removeAllObjects];
158 
159     J2dRlsTraceLn(J2D_TRACE_INFO, &quot;CGLGraphicsConfig_getCGLConfigInfo&quot;);
160 
161     NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
162 

163     if (sharedContext == NULL) {



164 
165         NSOpenGLPixelFormatAttribute attrs[] = {
166             NSOpenGLPFAAllowOfflineRenderers,
167             NSOpenGLPFAClosestPolicy,
168             NSOpenGLPFAWindow,
169             NSOpenGLPFAPixelBuffer,
170             NSOpenGLPFADoubleBuffer,
171             NSOpenGLPFAColorSize, 32,
172             NSOpenGLPFAAlphaSize, 8,
173             NSOpenGLPFADepthSize, 16,

174             0
175         };
176 
177         sharedPixelFormat =
178             [[NSOpenGLPixelFormat alloc] initWithAttributes:attrs];
179         if (sharedPixelFormat == nil) {
<span class="line-modified">180             J2dRlsTraceLn(J2D_TRACE_ERROR, </span>
<span class="line-modified">181                           &quot;CGLGraphicsConfig_getCGLConfigInfo: shared NSOpenGLPixelFormat is NULL&quot;);</span>
<span class="line-modified">182                 </span>
<span class="line-added">183            [argValue addObject: [NSNumber numberWithLong: 0L]];</span>
<span class="line-added">184            return;</span>
185         }
186 
187         sharedContext =
188             [[NSOpenGLContext alloc]
189                 initWithFormat:sharedPixelFormat
190                 shareContext: NULL];
191         if (sharedContext == nil) {
192             J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: shared NSOpenGLContext is NULL&quot;);
193             [argValue addObject: [NSNumber numberWithLong: 0L]];
194             return;
195         }
196     }
197 
198 #if USE_NSVIEW_FOR_SCRATCH
199     NSRect contentRect = NSMakeRect(0, 0, 64, 64);
200     NSWindow *window =
201         [[NSWindow alloc]
202             initWithContentRect: contentRect
203             styleMask: NSBorderlessWindowMask
204             backing: NSBackingStoreBuffered
</pre>
</td>
</tr>
</table>
<center><a href="CGLGraphicsConfig.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CGLLayer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
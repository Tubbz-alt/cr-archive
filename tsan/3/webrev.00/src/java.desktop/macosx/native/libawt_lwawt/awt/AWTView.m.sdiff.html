<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/awt/AWTView.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="AWTView.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="AWTWindow.m.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/awt/AWTView.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  82     fProcessingKeystroke = NO;
  83 
  84     fEnablePressAndHold = shouldUsePressAndHold();
  85     fInPressAndHold = NO;
  86     fPAHNeedsToSelect = NO;
  87 
  88     mouseIsOver = NO;
  89     [self resetTrackingArea];
  90     [self setAutoresizesSubviews:NO];
  91 
  92     if (windowLayer != nil) {
  93         self.cglLayer = windowLayer;
  94         //Layer hosting view
  95         [self setLayer: cglLayer];
  96         [self setWantsLayer: YES];
  97         //Layer backed view
  98         //[self.layer addSublayer: (CALayer *)cglLayer];
  99         //[self setLayerContentsRedrawPolicy: NSViewLayerContentsRedrawDuringViewResize];
 100         //[self setLayerContentsPlacement: NSViewLayerContentsPlacementTopLeft];
 101         //[self setAutoresizingMask: NSViewHeightSizable | NSViewWidthSizable];
<span class="line-removed"> 102 </span>
<span class="line-removed"> 103 #ifdef REMOTELAYER</span>
<span class="line-removed"> 104         CGLLayer *parentLayer = (CGLLayer*)self.cglLayer;</span>
<span class="line-removed"> 105         parentLayer.parentLayer = NULL;</span>
<span class="line-removed"> 106         parentLayer.remoteLayer = NULL;</span>
<span class="line-removed"> 107         if (JRSRemotePort != 0 &amp;&amp; remoteSocketFD &gt; 0) {</span>
<span class="line-removed"> 108             CGLLayer *remoteLayer = [[CGLLayer alloc] initWithJavaLayer: parentLayer.javaLayer];</span>
<span class="line-removed"> 109             remoteLayer.target = GL_TEXTURE_2D;</span>
<span class="line-removed"> 110             NSLog(@&quot;Creating Parent=%p, Remote=%p&quot;, parentLayer, remoteLayer);</span>
<span class="line-removed"> 111             parentLayer.remoteLayer = remoteLayer;</span>
<span class="line-removed"> 112             remoteLayer.parentLayer = parentLayer;</span>
<span class="line-removed"> 113             remoteLayer.remoteLayer = NULL;</span>
<span class="line-removed"> 114             remoteLayer.jrsRemoteLayer = [remoteLayer createRemoteLayerBoundTo:JRSRemotePort];</span>
<span class="line-removed"> 115             [remoteLayer retain];  // REMIND</span>
<span class="line-removed"> 116             remoteLayer.frame = CGRectMake(0, 0, 720, 500); // REMIND</span>
<span class="line-removed"> 117             [remoteLayer.jrsRemoteLayer retain]; // REMIND</span>
<span class="line-removed"> 118             int layerID = [remoteLayer.jrsRemoteLayer layerID];</span>
<span class="line-removed"> 119             NSLog(@&quot;layer id to send = %d&quot;, layerID);</span>
<span class="line-removed"> 120             sendLayerID(layerID);</span>
<span class="line-removed"> 121         }</span>
<span class="line-removed"> 122 #endif /* REMOTELAYER */</span>
 123     }
 124 
 125     return self;
 126 }
 127 
 128 - (void) dealloc {
 129     AWT_ASSERT_APPKIT_THREAD;
 130 
 131     self.cglLayer = nil;
 132 
 133     JNIEnv *env = [ThreadUtilities getJNIEnvUncached];
 134     (*env)-&gt;DeleteWeakGlobalRef(env, m_cPlatformView);
 135     m_cPlatformView = NULL;
 136 
 137     if (fInputMethodLOCKABLE != NULL)
 138     {
 139         JNIEnv *env = [ThreadUtilities getJNIEnvUncached];
 140 
 141         JNFDeleteGlobalRef(env, fInputMethodLOCKABLE);
 142         fInputMethodLOCKABLE = NULL;
</pre>
<hr />
<pre>
 955     fprintf(stderr, &quot;AWTView InputMethod Selector Called : [insertText]: %s\n&quot;, [aString UTF8String]);
 956 #endif // IM_DEBUG
 957 
 958     if (fInputMethodLOCKABLE == NULL) {
 959         return;
 960     }
 961 
 962     // Insert happens at the end of PAH
 963     fInPressAndHold = NO;
 964 
 965     // insertText gets called when the user commits text generated from an input method.  It also gets
 966     // called during ordinary input as well.  We only need to send an input method event when we have marked
 967     // text, or &#39;text in progress&#39;.  We also need to send the event if we get an insert text out of the blue!
 968     // (i.e., when the user uses the Character palette or Inkwell), or when the string to insert is a complex
 969     // Unicode value.
 970 
 971     NSMutableString * useString = [self parseString:aString];
 972     NSUInteger utf16Length = [useString lengthOfBytesUsingEncoding:NSUTF16StringEncoding];
 973     NSUInteger utf8Length = [useString lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
 974     BOOL aStringIsComplex = NO;







 975     if ((utf16Length &gt; 2) ||
<span class="line-modified"> 976         ((utf8Length &gt; 1) &amp;&amp; [self isCodePointInUnicodeBlockNeedingIMEvent:[useString characterAtIndex:0]])) {</span>

 977         aStringIsComplex = YES;
 978     }
 979 
 980     if ([self hasMarkedText] || !fProcessingKeystroke || aStringIsComplex) {
 981         JNIEnv *env = [ThreadUtilities getJNIEnv];
 982 
 983         static JNF_MEMBER_CACHE(jm_selectPreviousGlyph, jc_CInputMethod, &quot;selectPreviousGlyph&quot;, &quot;()V&quot;);
 984         // We need to select the previous glyph so that it is overwritten.
 985         if (fPAHNeedsToSelect) {
 986             JNFCallVoidMethod(env, fInputMethodLOCKABLE, jm_selectPreviousGlyph);
 987             fPAHNeedsToSelect = NO;
 988         }
 989 
 990         static JNF_MEMBER_CACHE(jm_insertText, jc_CInputMethod, &quot;insertText&quot;, &quot;(Ljava/lang/String;)V&quot;);
 991         jstring insertedText =  JNFNSToJavaString(env, useString);
 992         JNFCallVoidMethod(env, fInputMethodLOCKABLE, jm_insertText, insertedText); // AWT_THREADING Safe (AWTRunLoopMode)
 993         (*env)-&gt;DeleteLocalRef(env, insertedText);
 994 
 995         // The input method event will create psuedo-key events for each character in the committed string.
 996         // We also don&#39;t want to send the character that triggered the insertText, usually a return. [3337563]
 997         fKeyEventsNeeded = NO;
 998     }
 999     else {
1000         // Need to set back the fKeyEventsNeeded flag so that the string following the
1001         // marked text is not ignored by keyDown
1002         if ([useString length] &gt; 0) {
1003             fKeyEventsNeeded = YES;
1004         }
1005     }
1006     fPAHNeedsToSelect = NO;
1007 
1008     // Abandon input to reset IM and unblock input after entering accented
1009     // symbols
1010 
1011     [self abandonInput];
1012 }
1013 









1014 - (void) doCommandBySelector:(SEL)aSelector
1015 {
1016 #ifdef IM_DEBUG
1017     fprintf(stderr, &quot;AWTView InputMethod Selector Called : [doCommandBySelector]\n&quot;);
1018     NSLog(@&quot;%@&quot;, NSStringFromSelector(aSelector));
1019 #endif // IM_DEBUG
1020     if (@selector(insertNewline:) == aSelector || @selector(insertTab:) == aSelector || @selector(deleteBackward:) == aSelector)
1021     {
1022         fKeyEventsNeeded = YES;
1023     }
1024 }
1025 
1026 // setMarkedText: cannot take a nil first argument. aString can be NSString or NSAttributedString
1027 - (void) setMarkedText:(id)aString selectedRange:(NSRange)selectionRange replacementRange:(NSRange)replacementRange
1028 {
1029     if (!fInputMethodLOCKABLE)
1030         return;
1031 
1032     BOOL isAttributedString = [aString isKindOfClass:[NSAttributedString class]];
1033     NSAttributedString *attrString = (isAttributedString ? (NSAttributedString *)aString : nil);
</pre>
<hr />
<pre>
1319 }
1320 
1321 - (void)setInputMethod:(jobject)inputMethod
1322 {
1323 #ifdef IM_DEBUG
1324     fprintf(stderr, &quot;AWTView InputMethod Selector Called : [setInputMethod]\n&quot;);
1325 #endif // IM_DEBUG
1326 
1327     JNIEnv *env = [ThreadUtilities getJNIEnv];
1328 
1329     // Get rid of the old one
1330     if (fInputMethodLOCKABLE) {
1331         JNFDeleteGlobalRef(env, fInputMethodLOCKABLE);
1332     }
1333 
1334     // Save a global ref to the new input method.
1335     if (inputMethod != NULL)
1336         fInputMethodLOCKABLE = JNFNewGlobalRef(env, inputMethod);
1337     else
1338         fInputMethodLOCKABLE = NULL;







1339 }
1340 
1341 - (void)abandonInput
1342 {
1343 #ifdef IM_DEBUG
1344     fprintf(stderr, &quot;AWTView InputMethod Selector Called : [abandonInput]\n&quot;);
1345 #endif // IM_DEBUG
1346 
1347     [ThreadUtilities performOnMainThread:@selector(markedTextAbandoned:) on:[NSInputManager currentInputManager] withObject:self waitUntilDone:YES];
1348     [self unmarkText];
1349 }
1350 
1351 /********************************   END NSTextInputClient Protocol   ********************************/
1352 
1353 
1354 
1355 
1356 @end // AWTView
1357 
1358 /*
</pre>
<hr />
<pre>
1412 
1413     }];
1414     JNF_COCOA_EXIT(env);
1415 }
1416 
1417 /*
1418  * Class:     sun_lwawt_macosx_CPlatformView
1419  * Method:    nativeGetNSViewDisplayID
1420  * Signature: (J)I;
1421  */
1422 
1423 JNIEXPORT jint JNICALL
1424 Java_sun_lwawt_macosx_CPlatformView_nativeGetNSViewDisplayID
1425 (JNIEnv *env, jclass cls, jlong viewPtr)
1426 {
1427     __block jint ret; //CGDirectDisplayID
1428 
1429     JNF_COCOA_ENTER(env);
1430 
1431     NSView *view = (NSView *)jlong_to_ptr(viewPtr);
<span class="line-removed">1432     NSWindow *window = [view window];</span>
<span class="line-removed">1433 </span>
1434     [ThreadUtilities performOnMainThreadWaiting:YES block:^(){
<span class="line-modified">1435 </span>
1436         ret = (jint)[[AWTWindow getNSWindowDisplayID_AppKitThread: window] intValue];
1437     }];
1438 
1439     JNF_COCOA_EXIT(env);
1440 
1441     return ret;
1442 }
1443 
1444 /*
1445  * Class:     sun_lwawt_macosx_CPlatformView
1446  * Method:    nativeGetLocationOnScreen
1447  * Signature: (J)Ljava/awt/Rectangle;
1448  */
1449 
1450 JNIEXPORT jobject JNICALL
1451 Java_sun_lwawt_macosx_CPlatformView_nativeGetLocationOnScreen
1452 (JNIEnv *env, jclass cls, jlong viewPtr)
1453 {
1454     jobject jRect = NULL;
1455 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  82     fProcessingKeystroke = NO;
  83 
  84     fEnablePressAndHold = shouldUsePressAndHold();
  85     fInPressAndHold = NO;
  86     fPAHNeedsToSelect = NO;
  87 
  88     mouseIsOver = NO;
  89     [self resetTrackingArea];
  90     [self setAutoresizesSubviews:NO];
  91 
  92     if (windowLayer != nil) {
  93         self.cglLayer = windowLayer;
  94         //Layer hosting view
  95         [self setLayer: cglLayer];
  96         [self setWantsLayer: YES];
  97         //Layer backed view
  98         //[self.layer addSublayer: (CALayer *)cglLayer];
  99         //[self setLayerContentsRedrawPolicy: NSViewLayerContentsRedrawDuringViewResize];
 100         //[self setLayerContentsPlacement: NSViewLayerContentsPlacementTopLeft];
 101         //[self setAutoresizingMask: NSViewHeightSizable | NSViewWidthSizable];





















 102     }
 103 
 104     return self;
 105 }
 106 
 107 - (void) dealloc {
 108     AWT_ASSERT_APPKIT_THREAD;
 109 
 110     self.cglLayer = nil;
 111 
 112     JNIEnv *env = [ThreadUtilities getJNIEnvUncached];
 113     (*env)-&gt;DeleteWeakGlobalRef(env, m_cPlatformView);
 114     m_cPlatformView = NULL;
 115 
 116     if (fInputMethodLOCKABLE != NULL)
 117     {
 118         JNIEnv *env = [ThreadUtilities getJNIEnvUncached];
 119 
 120         JNFDeleteGlobalRef(env, fInputMethodLOCKABLE);
 121         fInputMethodLOCKABLE = NULL;
</pre>
<hr />
<pre>
 934     fprintf(stderr, &quot;AWTView InputMethod Selector Called : [insertText]: %s\n&quot;, [aString UTF8String]);
 935 #endif // IM_DEBUG
 936 
 937     if (fInputMethodLOCKABLE == NULL) {
 938         return;
 939     }
 940 
 941     // Insert happens at the end of PAH
 942     fInPressAndHold = NO;
 943 
 944     // insertText gets called when the user commits text generated from an input method.  It also gets
 945     // called during ordinary input as well.  We only need to send an input method event when we have marked
 946     // text, or &#39;text in progress&#39;.  We also need to send the event if we get an insert text out of the blue!
 947     // (i.e., when the user uses the Character palette or Inkwell), or when the string to insert is a complex
 948     // Unicode value.
 949 
 950     NSMutableString * useString = [self parseString:aString];
 951     NSUInteger utf16Length = [useString lengthOfBytesUsingEncoding:NSUTF16StringEncoding];
 952     NSUInteger utf8Length = [useString lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
 953     BOOL aStringIsComplex = NO;
<span class="line-added"> 954 </span>
<span class="line-added"> 955     unichar codePoint = [useString characterAtIndex:0];</span>
<span class="line-added"> 956 </span>
<span class="line-added"> 957 #ifdef IM_DEBUG</span>
<span class="line-added"> 958     NSLog(@&quot;insertText kbdlayout %@ &quot;,(NSString *)kbdLayout);</span>
<span class="line-added"> 959 #endif // IM_DEBUG</span>
<span class="line-added"> 960 </span>
 961     if ((utf16Length &gt; 2) ||
<span class="line-modified"> 962         ((utf8Length &gt; 1) &amp;&amp; [self isCodePointInUnicodeBlockNeedingIMEvent:codePoint]) ||</span>
<span class="line-added"> 963         ((codePoint == 0x5c) &amp;&amp; ([(NSString *)kbdLayout containsString:@&quot;Kotoeri&quot;]))) {</span>
 964         aStringIsComplex = YES;
 965     }
 966 
 967     if ([self hasMarkedText] || !fProcessingKeystroke || aStringIsComplex) {
 968         JNIEnv *env = [ThreadUtilities getJNIEnv];
 969 
 970         static JNF_MEMBER_CACHE(jm_selectPreviousGlyph, jc_CInputMethod, &quot;selectPreviousGlyph&quot;, &quot;()V&quot;);
 971         // We need to select the previous glyph so that it is overwritten.
 972         if (fPAHNeedsToSelect) {
 973             JNFCallVoidMethod(env, fInputMethodLOCKABLE, jm_selectPreviousGlyph);
 974             fPAHNeedsToSelect = NO;
 975         }
 976 
 977         static JNF_MEMBER_CACHE(jm_insertText, jc_CInputMethod, &quot;insertText&quot;, &quot;(Ljava/lang/String;)V&quot;);
 978         jstring insertedText =  JNFNSToJavaString(env, useString);
 979         JNFCallVoidMethod(env, fInputMethodLOCKABLE, jm_insertText, insertedText); // AWT_THREADING Safe (AWTRunLoopMode)
 980         (*env)-&gt;DeleteLocalRef(env, insertedText);
 981 
 982         // The input method event will create psuedo-key events for each character in the committed string.
 983         // We also don&#39;t want to send the character that triggered the insertText, usually a return. [3337563]
 984         fKeyEventsNeeded = NO;
 985     }
 986     else {
 987         // Need to set back the fKeyEventsNeeded flag so that the string following the
 988         // marked text is not ignored by keyDown
 989         if ([useString length] &gt; 0) {
 990             fKeyEventsNeeded = YES;
 991         }
 992     }
 993     fPAHNeedsToSelect = NO;
 994 
 995     // Abandon input to reset IM and unblock input after entering accented
 996     // symbols
 997 
 998     [self abandonInput];
 999 }
1000 
<span class="line-added">1001 - (void)keyboardInputSourceChanged:(NSNotification *)notification</span>
<span class="line-added">1002 {</span>
<span class="line-added">1003 #ifdef IM_DEBUG</span>
<span class="line-added">1004     NSLog(@&quot;keyboardInputSourceChangeNotification received&quot;);</span>
<span class="line-added">1005 #endif</span>
<span class="line-added">1006     NSTextInputContext *curContxt = [NSTextInputContext currentInputContext];</span>
<span class="line-added">1007     kbdLayout = curContxt.selectedKeyboardInputSource;</span>
<span class="line-added">1008 }</span>
<span class="line-added">1009 </span>
1010 - (void) doCommandBySelector:(SEL)aSelector
1011 {
1012 #ifdef IM_DEBUG
1013     fprintf(stderr, &quot;AWTView InputMethod Selector Called : [doCommandBySelector]\n&quot;);
1014     NSLog(@&quot;%@&quot;, NSStringFromSelector(aSelector));
1015 #endif // IM_DEBUG
1016     if (@selector(insertNewline:) == aSelector || @selector(insertTab:) == aSelector || @selector(deleteBackward:) == aSelector)
1017     {
1018         fKeyEventsNeeded = YES;
1019     }
1020 }
1021 
1022 // setMarkedText: cannot take a nil first argument. aString can be NSString or NSAttributedString
1023 - (void) setMarkedText:(id)aString selectedRange:(NSRange)selectionRange replacementRange:(NSRange)replacementRange
1024 {
1025     if (!fInputMethodLOCKABLE)
1026         return;
1027 
1028     BOOL isAttributedString = [aString isKindOfClass:[NSAttributedString class]];
1029     NSAttributedString *attrString = (isAttributedString ? (NSAttributedString *)aString : nil);
</pre>
<hr />
<pre>
1315 }
1316 
1317 - (void)setInputMethod:(jobject)inputMethod
1318 {
1319 #ifdef IM_DEBUG
1320     fprintf(stderr, &quot;AWTView InputMethod Selector Called : [setInputMethod]\n&quot;);
1321 #endif // IM_DEBUG
1322 
1323     JNIEnv *env = [ThreadUtilities getJNIEnv];
1324 
1325     // Get rid of the old one
1326     if (fInputMethodLOCKABLE) {
1327         JNFDeleteGlobalRef(env, fInputMethodLOCKABLE);
1328     }
1329 
1330     // Save a global ref to the new input method.
1331     if (inputMethod != NULL)
1332         fInputMethodLOCKABLE = JNFNewGlobalRef(env, inputMethod);
1333     else
1334         fInputMethodLOCKABLE = NULL;
<span class="line-added">1335 </span>
<span class="line-added">1336     NSTextInputContext *curContxt = [NSTextInputContext currentInputContext];</span>
<span class="line-added">1337     kbdLayout = curContxt.selectedKeyboardInputSource;</span>
<span class="line-added">1338     [[NSNotificationCenter defaultCenter] addObserver:self</span>
<span class="line-added">1339                                            selector:@selector(keyboardInputSourceChanged:)</span>
<span class="line-added">1340                                                name:NSTextInputContextKeyboardSelectionDidChangeNotification</span>
<span class="line-added">1341                                              object:nil];</span>
1342 }
1343 
1344 - (void)abandonInput
1345 {
1346 #ifdef IM_DEBUG
1347     fprintf(stderr, &quot;AWTView InputMethod Selector Called : [abandonInput]\n&quot;);
1348 #endif // IM_DEBUG
1349 
1350     [ThreadUtilities performOnMainThread:@selector(markedTextAbandoned:) on:[NSInputManager currentInputManager] withObject:self waitUntilDone:YES];
1351     [self unmarkText];
1352 }
1353 
1354 /********************************   END NSTextInputClient Protocol   ********************************/
1355 
1356 
1357 
1358 
1359 @end // AWTView
1360 
1361 /*
</pre>
<hr />
<pre>
1415 
1416     }];
1417     JNF_COCOA_EXIT(env);
1418 }
1419 
1420 /*
1421  * Class:     sun_lwawt_macosx_CPlatformView
1422  * Method:    nativeGetNSViewDisplayID
1423  * Signature: (J)I;
1424  */
1425 
1426 JNIEXPORT jint JNICALL
1427 Java_sun_lwawt_macosx_CPlatformView_nativeGetNSViewDisplayID
1428 (JNIEnv *env, jclass cls, jlong viewPtr)
1429 {
1430     __block jint ret; //CGDirectDisplayID
1431 
1432     JNF_COCOA_ENTER(env);
1433 
1434     NSView *view = (NSView *)jlong_to_ptr(viewPtr);


1435     [ThreadUtilities performOnMainThreadWaiting:YES block:^(){
<span class="line-modified">1436         NSWindow *window = [view window];</span>
1437         ret = (jint)[[AWTWindow getNSWindowDisplayID_AppKitThread: window] intValue];
1438     }];
1439 
1440     JNF_COCOA_EXIT(env);
1441 
1442     return ret;
1443 }
1444 
1445 /*
1446  * Class:     sun_lwawt_macosx_CPlatformView
1447  * Method:    nativeGetLocationOnScreen
1448  * Signature: (J)Ljava/awt/Rectangle;
1449  */
1450 
1451 JNIEXPORT jobject JNICALL
1452 Java_sun_lwawt_macosx_CPlatformView_nativeGetLocationOnScreen
1453 (JNIEnv *env, jclass cls, jlong viewPtr)
1454 {
1455     jobject jRect = NULL;
1456 
</pre>
</td>
</tr>
</table>
<center><a href="AWTView.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="AWTWindow.m.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
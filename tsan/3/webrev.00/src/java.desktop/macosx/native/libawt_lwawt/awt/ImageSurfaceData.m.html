<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/macosx/native/libawt_lwawt/awt/ImageSurfaceData.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #import &quot;ImageSurfaceData.h&quot;
  27 
  28 #import &quot;java_awt_Transparency.h&quot;
  29 #import &quot;java_awt_image_BufferedImage.h&quot;
  30 #import &quot;sun_awt_image_BufImgSurfaceData.h&quot;
  31 #import &quot;sun_java2d_OSXOffScreenSurfaceData.h&quot;
  32 
  33 #import &quot;jni_util.h&quot;
  34 #import &lt;JavaNativeFoundation/JavaNativeFoundation.h&gt;
  35 
  36 #import &quot;BufImgSurfaceData.h&quot;
  37 
  38 //#define DEBUG 1
  39 #if defined DEBUG
  40     #define IMAGE_SURFACE_INLINE
  41     #define PRINT(msg) {fprintf(stderr, &quot;%s\n&quot;, msg);fflush(stderr);}
  42 #else
  43     #define IMAGE_SURFACE_INLINE static inline
  44     #define PRINT(msg) {}
  45 #endif
  46 
  47 // same value as defined in Sun&#39;s own code
  48 #define XOR_ALPHA_CUTOFF 128
  49 
  50 // for vImage framework headers
  51 #include &lt;Accelerate/Accelerate.h&gt;
  52 
  53 static ContextInfo sDefaultContextInfo[sun_java2d_OSXOffScreenSurfaceData_TYPE_3BYTE_RGB+1] =
  54 {
  55     {YES,    YES,    8,        4,        0,        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,    NULL},    // TYPE_CUSTOM            // special case
  56     {YES,    YES,    8,        4,        0,        kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host,        NULL},    // TYPE_INT_RGB
  57     {YES,    YES,    8,        4,        0,        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,    NULL},    // TYPE_INT_ARGB
  58     {YES,    YES,    8,        4,        0,        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,    NULL},    // TYPE_INT_ARGB_PRE
  59     {YES,    YES,    8,        4,        0,        kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host,        NULL},    // TYPE_INT_BGR
  60     {YES,    NO,        8,        4,        0,        kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host,        NULL},    // TYPE_3BYTE_BGR        // use the default ARGB_PRE context synce we have to sync by hand anyway
  61     {YES,    YES,    8,        4,        0,        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,    NULL},    // TYPE_4BYTE_ABGR
  62     {YES,    YES,    8,        4,        0,        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,    NULL},    // TYPE_4BYTE_ABGR_PRE
  63 #ifdef __LITTLE_ENDIAN__
  64     {YES,    YES,    5,        2,        0,        kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder16Host,        NULL},    // TYPE_USHORT_565_RGB
  65     {YES,    YES,    5,        2,        0,        kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder16Host,        NULL},    // TYPE_USHORT_555_RGB
  66 #else
  67     {YES,    YES,    5,        2,        0,        kCGImageAlphaNoneSkipFirst,                                    NULL},    // TYPE_USHORT_565_RGB
  68     {YES,    YES,    5,        2,        0,        kCGImageAlphaNoneSkipFirst,                                    NULL},    // TYPE_USHORT_555_RGB
  69 #endif
  70     {YES,    YES,    8,        1,        0,        kCGImageAlphaNone,                                            NULL},    // TYPE_BYTE_GRAY
  71     {YES,    NO,        8,        4,        0,        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,    NULL},    // TYPE_USHORT_GRAY        // use the default ARGB_PRE context synce we have to sync by hand anyway
  72     {NO,    NO,        8,        4,        0,        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,    NULL},    // TYPE_BYTE_BINARY        mapped to TYPE_CUSTOM
  73     {YES,    NO,        8,        4,        0,        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,    NULL},    // TYPE_BYTE_INDEXED    // use the default ARGB_PRE context synce we have to sync by hand anyway
  74     {YES,    NO,        8,        4,        0,        kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host,        NULL},    // TYPE_3BYTE_RGB
  75 };
  76 
  77 static ImageInfo sDefaultImageInfo[sun_java2d_OSXOffScreenSurfaceData_TYPE_3BYTE_RGB+1] =
  78 {
  79     {8,        32,        4,        0,        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,    NULL},    // TYPE_CUSTOM
  80     {8,        32,        4,        0,        kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host,        NULL},    // TYPE_INT_RGB
  81     {8,        32,        4,        0,        kCGImageAlphaFirst | kCGBitmapByteOrder32Host,                NULL},    // TYPE_INT_ARGB
  82     {8,        32,        4,        0,        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,    NULL},    // TYPE_INT_ARGB_PRE
  83     {8,        32,        4,        0,        kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host,        NULL},    // TYPE_INT_BGR
  84     {8,        32,        4,        0,        kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host,        NULL},    // TYPE_3BYTE_BGR
  85     {8,        32,        4,        0,        kCGImageAlphaFirst | kCGBitmapByteOrder32Host,                NULL},    // TYPE_4BYTE_ABGR
  86     {8,        32,        4,        0,        kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,    NULL},    // TYPE_4BYTE_ABGR_PRE
  87 #ifdef __LITTLE_ENDIAN__
  88     {5,        16,        2,        0,        kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder16Host,        NULL},    // TYPE_USHORT_565_RGB
  89     {5,        16,        2,        0,        kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder16Host,        NULL},    // TYPE_USHORT_555_RGB
  90 #else
  91     {5,        16,        2,        0,        kCGImageAlphaNoneSkipFirst,                                    NULL},    // TYPE_USHORT_565_RGB
  92     {5,        16,        2,        0,        kCGImageAlphaNoneSkipFirst,                                    NULL},    // TYPE_USHORT_555_RGB
  93 #endif
  94     {8,        8,        1,        0,        kCGImageAlphaNone,                                            NULL},    // TYPE_BYTE_GRAY
  95     {16,    16,        2,        0,        kCGImageAlphaNone | kCGBitmapByteOrder16Host,                NULL},    // TYPE_USHORT_GRAY
  96     {0,        0,        0,        0,        -1,                                                            NULL},    // TYPE_BYTE_BINARY        mapped to TYPE_CUSTOM
  97     {8,        32,        4,        0,        kCGImageAlphaFirst | kCGBitmapByteOrder32Host,                NULL},    // TYPE_BYTE_INDEXED  // Fully OPAQUE INDEXED images will use kCGImageAlphaNoneSkipFirst for performance reasosn. see &lt;rdar://4224874&gt;
  98     {8,        32,        4,        0,        kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host,        NULL},    // TYPE_3BYTE_RGB
  99 };
 100 
 101 static jfieldID        rgbID;
 102 static jfieldID        mapSizeID;
 103 static jfieldID        CMpDataID;
 104 static jfieldID        allGrayID;
 105 
 106 
 107 static JNF_CLASS_CACHE(jc_OSXOffScreenSurfaceData, &quot;sun/java2d/OSXOffScreenSurfaceData&quot;);
 108 static JNF_MEMBER_CACHE(jm_syncFromCustom, jc_OSXOffScreenSurfaceData, &quot;syncFromCustom&quot;, &quot;()V&quot;);
 109 static JNF_MEMBER_CACHE(jm_syncToCustom, jc_OSXOffScreenSurfaceData, &quot;syncToCustom&quot;, &quot;()V&quot;);
 110 static JNF_CLASS_CACHE(jc_BufferedImage, &quot;java/awt/image/BufferedImage&quot;);
 111 static JNF_MEMBER_CACHE(jm_SurfaceData, jc_BufferedImage, &quot;sData&quot;, &quot;Lsun/java2d/SurfaceData;&quot;);
 112 static JNF_CLASS_CACHE(jc_IndexColorModel, &quot;java/awt/image/IndexColorModel&quot;);
 113 static JNF_MEMBER_CACHE(jm_rgb, jc_IndexColorModel, &quot;rgb&quot;, &quot;[I&quot;);
 114 static JNF_MEMBER_CACHE(jm_transparency, jc_IndexColorModel, &quot;transparency&quot;, &quot;I&quot;);
 115 static JNF_MEMBER_CACHE(jm_transparent_index, jc_IndexColorModel, &quot;transparent_index&quot;, &quot;I&quot;);
 116 
 117 CGColorSpaceRef gColorspaceRGB = NULL;
 118 CGColorSpaceRef gColorspaceGray = NULL;
 119 
 120 IMAGE_SURFACE_INLINE void PrintImageInfo(ImageSDOps* isdo)
 121 {
 122     fprintf(stderr, &quot;\n&quot;);
 123     fprintf(stderr, &quot;PrintImageInfo:\n&quot;);
 124     fprintf(stderr, &quot;\t \n&quot;);
 125     //fprintf(stderr, &quot;\t magicID=%d\n&quot;, (jint)isdo-&gt;magicID);
 126     //fprintf(stderr, &quot;\n&quot;);
 127     fprintf(stderr, &quot;\t isdo=%p\n&quot;, isdo);
 128     fprintf(stderr, &quot;\t \n&quot;);
 129     fprintf(stderr, &quot;\t contextInfo:\n&quot;);
 130     fprintf(stderr, &quot;\t        useWindowContextReference=%d\n&quot;, isdo-&gt;contextInfo.useWindowContextReference);
 131     fprintf(stderr, &quot;\t        canUseJavaPixelsAsContext=%d\n&quot;, isdo-&gt;contextInfo.canUseJavaPixelsAsContext);
 132     fprintf(stderr, &quot;\t        bitsPerComponent=%ld\n&quot;, (long)isdo-&gt;contextInfo.bitsPerComponent);
 133     fprintf(stderr, &quot;\t        bytesPerPixel=%ld\n&quot;, (long)isdo-&gt;contextInfo.bytesPerPixel);
 134     fprintf(stderr, &quot;\t        bytesPerRow=%ld\n&quot;, (long)isdo-&gt;contextInfo.bytesPerRow);
 135     fprintf(stderr, &quot;\t        alphaInfo=%ld\n&quot;, (long)isdo-&gt;contextInfo.alphaInfo);
 136     fprintf(stderr, &quot;\t \n&quot;);
 137     fprintf(stderr, &quot;\t imageInfo:\n&quot;);
 138     fprintf(stderr, &quot;\t        bitsPerComponent=%ld\n&quot;, (long)isdo-&gt;imageInfo.bitsPerComponent);
 139     fprintf(stderr, &quot;\t        bitsPerPixel=%ld\n&quot;, (long)isdo-&gt;imageInfo.bitsPerPixel);
 140     fprintf(stderr, &quot;\t        bytesPerPixel=%ld\n&quot;, (long)isdo-&gt;imageInfo.bytesPerPixel);
 141     fprintf(stderr, &quot;\t        bytesPerRow=%ld\n&quot;, (long)isdo-&gt;imageInfo.bytesPerRow);
 142     fprintf(stderr, &quot;\t        alphaInfo=%ld\n&quot;, (long)isdo-&gt;imageInfo.alphaInfo);
 143     fprintf(stderr, &quot;\t \n&quot;);
 144     fprintf(stderr, &quot;\t isSubImage=%d\n&quot;, isdo-&gt;isSubImage);
 145     fprintf(stderr, &quot;\t \n&quot;);
 146     fprintf(stderr, &quot;\t java info:\n&quot;);
 147     fprintf(stderr, &quot;\t        array=%p\n&quot;, isdo-&gt;array);
 148     fprintf(stderr, &quot;\t        offset=%d\n&quot;, (int)isdo-&gt;offset);
 149     fprintf(stderr, &quot;\t        width=%d\n&quot;, (int)isdo-&gt;width);
 150     fprintf(stderr, &quot;\t        height=%d\n&quot;, (int)isdo-&gt;height);
 151     fprintf(stderr, &quot;\t        javaPixelBytes=%d\n&quot;, (int)isdo-&gt;javaPixelBytes);
 152     fprintf(stderr, &quot;\t        javaPixelsBytesPerRow=%d\n&quot;, (int)isdo-&gt;javaPixelsBytesPerRow);
 153     fprintf(stderr, &quot;\t        icm=%p\n&quot;, isdo-&gt;icm);
 154     fprintf(stderr, &quot;\t        type=%d\n&quot;, (int)isdo-&gt;type);
 155     fprintf(stderr, &quot;\n&quot;);
 156     fprintf(stderr, &quot;\t cgRef=%p\n&quot;, isdo-&gt;qsdo.cgRef);
 157     fprintf(stderr, &quot;\t nsRef=%p\n&quot;, isdo-&gt;nsRef);
 158     fprintf(stderr, &quot;\n&quot;);
 159     fprintf(stderr, &quot;\t pixelsLocked=%p\n&quot;, isdo-&gt;pixelsLocked);
 160     fprintf(stderr, &quot;\t pixels=%p\n&quot;, isdo-&gt;pixels);
 161     fprintf(stderr, &quot;\n&quot;);
 162     fprintf(stderr, &quot;\t indexedColorTable=%p\n&quot;, isdo-&gt;indexedColorTable);
 163     fprintf(stderr, &quot;\t lutData=%p\n&quot;, isdo-&gt;lutData);
 164     fprintf(stderr, &quot;\t lutDataSize=%u\n&quot;, (unsigned)isdo-&gt;lutDataSize);
 165     fprintf(stderr, &quot;\n&quot;);
 166     fprintf(stderr, &quot;\t nrOfPixelsOwners=%u\n&quot;, (unsigned)isdo-&gt;nrOfPixelsOwners);
 167     fprintf(stderr, &quot;\n&quot;);
 168 }
 169 
 170 // if there is no image created for isdo.imgRef, it creates and image using the isdo.dataProvider
 171 // If there is an image present, this is a no-op
 172 void makeSureImageIsCreated(ImageSDOps* isdo)
 173 {
 174     if (isdo-&gt;imgRef == NULL)  // create the image
 175     {
 176         isdo-&gt;imgRef = CGImageCreate(isdo-&gt;width,
 177                                       isdo-&gt;height,
 178                                       isdo-&gt;contextInfo.bitsPerComponent,
 179                                       isdo-&gt;contextInfo.bytesPerPixel * 8,
 180                                       isdo-&gt;contextInfo.bytesPerRow,
 181                                       isdo-&gt;contextInfo.colorSpace,
 182                                       isdo-&gt;contextInfo.alphaInfo,
 183                                       isdo-&gt;dataProvider,
 184                                       NULL,
 185                                       NO,
 186                                       kCGRenderingIntentDefault);
 187     }
 188 }
 189 
 190 IMAGE_SURFACE_INLINE void customPixelsFromJava(JNIEnv *env, ImageSDOps *isdo)
 191 {
 192 PRINT(&quot;    customPixelsFromJava&quot;)
 193 
 194     SurfaceDataOps *sdo = (SurfaceDataOps*)isdo;
 195     JNFCallVoidMethod(env, sdo-&gt;sdObject, jm_syncFromCustom); // AWT_THREADING Safe (known object)
 196 }
 197 
 198 IMAGE_SURFACE_INLINE void copyBits(jint w, jint h, jint javaPixelsBytesPerRow, Pixel8bit *pixelsSrc, jint dstPixelsBytesPerRow, Pixel8bit *pixelsDst)
 199 {
 200 PRINT(&quot;    copyBits&quot;)
 201 
 202     if (javaPixelsBytesPerRow == dstPixelsBytesPerRow)
 203     {
 204         memcpy(pixelsDst, pixelsSrc, h*javaPixelsBytesPerRow);
 205     }
 206     else
 207     {
 208         register jint y;
 209         for (y=0; y&lt;h; y++)
 210         {
 211             memcpy(pixelsDst, pixelsSrc, dstPixelsBytesPerRow);
 212 
 213             pixelsSrc += javaPixelsBytesPerRow;
 214             pixelsDst += dstPixelsBytesPerRow;
 215         }
 216     }
 217 }
 218 
 219 IMAGE_SURFACE_INLINE void copySwapRandB_32bit_TYPE_4BYTE(jint w, jint h, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel32bit *pixelsSrc, Pixel32bit *pixelsDst, size_t extraBytesPerRow)
 220 {
 221 PRINT(&quot;    copySwapRandB_32bit_TYPE_4BYTE&quot;)
 222 
 223     register Pixel8bit *p8Bit = NULL;
 224     register jint skip = (javaPixelsBytesPerRow/javaPixelBytes)-w; // in pixelsSrc units
 225     register Pixel32bit pixel, red, blue;
 226     register jint x, y;
 227 
 228     for (y=0; y&lt;h; y++)
 229     {
 230         for (x=0; x&lt;w; x++)
 231         {
 232             pixel = *pixelsSrc++;
 233 
 234 #ifdef __LITTLE_ENDIAN__
 235             pixel = CFSwapInt32BigToHost(pixel);   // the jint is in big endian format, we need to swap the bits
 236 #endif
 237 
 238             red        = (pixel &amp; 0x00ff0000) &gt;&gt; 16; // get original red and shift to new position
 239             blue    = (pixel &amp; 0x000000ff) &lt;&lt; 16; // get original blue and shift to new position
 240 
 241             pixel    = (pixel &amp; 0xff00ff00); // erase original red&amp;blue
 242 
 243             pixel    = pixel | red | blue; // construct new pixel
 244 
 245             *pixelsDst++ = pixel;
 246         }
 247         pixelsSrc += skip;
 248 
 249         p8Bit = (Pixel8bit *) pixelsDst;
 250         p8Bit += extraBytesPerRow;
 251         pixelsDst = (Pixel32bit *) p8Bit;
 252     }
 253 }
 254 
 255 
 256 IMAGE_SURFACE_INLINE void copySwapRandB_32bit_TYPE_INT(jint w, jint h, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel32bit *pixelsSrc, Pixel32bit *pixelsDst, size_t extraBytesPerRow)
 257 {
 258 PRINT(&quot;    copySwapRandB_32bit_TYPE_INT&quot;)
 259 
 260     register Pixel8bit *p8Bit = NULL;
 261     register jint skip = (javaPixelsBytesPerRow/javaPixelBytes)-w; // in pixelsSrc units
 262     register Pixel32bit pixel, red, blue;
 263     register jint x, y;
 264 
 265     for (y=0; y&lt;h; y++)
 266     {
 267         for (x=0; x&lt;w; x++)
 268         {
 269             pixel = *pixelsSrc++;
 270 
 271             red        = (pixel &amp; 0x00ff0000) &gt;&gt; 16; // get original red and shift to new position
 272             blue    = (pixel &amp; 0x000000ff) &lt;&lt; 16; // get original blue and shift to new position
 273 
 274             pixel    = (pixel &amp; 0xff00ff00); // erase original red&amp;blue
 275 
 276             pixel    = pixel | red | blue; // construct new pixel
 277 
 278             *pixelsDst++ = pixel;
 279         }
 280         pixelsSrc += skip;
 281 
 282         p8Bit = (Pixel8bit *) pixelsDst;
 283         p8Bit += extraBytesPerRow;
 284         pixelsDst = (Pixel32bit *) p8Bit;
 285     }
 286 }
 287 
 288 
 289 IMAGE_SURFACE_INLINE void copyBGR_24bitToXRGB_32bit(jint w, jint h, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel8bit *pixelsSrc, Pixel32bit *pixelsDst, size_t extraBytesPerRow)
 290 {
 291 PRINT(&quot;    copyBGR_24bitToXRGB_32bit&quot;)
 292 
 293     register Pixel8bit *p8Bit = NULL;
 294     register jint skip = ((javaPixelsBytesPerRow/javaPixelBytes)-w)*javaPixelBytes; // in pixelsSrc units
 295     register Pixel32bit red, green, blue, pixel;
 296     register jint x, y;
 297 
 298     for (y=0; y&lt;h; y++)
 299     {
 300         for (x=0; x&lt;w; x++)
 301         {
 302             pixel        = *pixelsSrc++;
 303             blue        = pixel &lt;&lt; 0;
 304 
 305             pixel        = *pixelsSrc++;
 306             green        = pixel &lt;&lt; 8;
 307 
 308             pixel        = *pixelsSrc++;
 309             red            = pixel &lt;&lt; 16;
 310 
 311             *pixelsDst    = red | green | blue;
 312 
 313             *pixelsDst = 0xff000000 | *pixelsDst;
 314 
 315             pixelsDst++;
 316         }
 317         pixelsSrc += skip;
 318 
 319         p8Bit = (Pixel8bit *) pixelsDst;
 320         p8Bit += extraBytesPerRow;
 321         pixelsDst = (Pixel32bit *) p8Bit;
 322     }
 323 }
 324 
 325 IMAGE_SURFACE_INLINE void copyRGB_24bitToXRGB_32bit(jint w, jint h, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel8bit *pixelsSrc, Pixel32bit *pixelsDst, size_t extraBytesPerRow)
 326 {
 327 PRINT(&quot;    copyRGB_24bitToXRGB_32bit&quot;)
 328 
 329     register Pixel8bit *p8Bit = NULL;
 330     register jint skip = ((javaPixelsBytesPerRow/javaPixelBytes)-w)*javaPixelBytes; // in pixelsSrc units
 331     register Pixel32bit red, green, blue, pixel;
 332     register jint x, y;
 333 
 334     for (y=0; y&lt;h; y++)
 335     {
 336         for (x=0; x&lt;w; x++)
 337         {
 338             pixel        = *pixelsSrc++;
 339             red            = pixel &lt;&lt; 16;
 340 
 341             pixel        = *pixelsSrc++;
 342             green        = pixel &lt;&lt; 8;
 343 
 344             pixel        = *pixelsSrc++;
 345             blue        = pixel &lt;&lt; 0;
 346 
 347             *pixelsDst    = red | green | blue;
 348 
 349             *pixelsDst = 0xff000000 | *pixelsDst;
 350 
 351             pixelsDst++;
 352         }
 353         pixelsSrc += skip;
 354 
 355         p8Bit = (Pixel8bit *) pixelsDst;
 356         p8Bit += extraBytesPerRow;
 357         pixelsDst = (Pixel32bit *) p8Bit;
 358     }
 359 }
 360 
 361 IMAGE_SURFACE_INLINE void copyIndexed_8bitToARGB_32bit(jint w, jint h, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel8bit *pixelsSrc,
 362                                                         Pixel32bit* lutdata, Pixel32bit *pixelsDst, size_t extraBytesPerRow)
 363 {
 364 PRINT(&quot;    copyIndexed_8bitToARGB_32bit&quot;)
 365 
 366     //gznote: how is the performance if the extraBytesPerRow != 0 ?
 367     const vImage_Buffer src = {pixelsSrc, h, w, javaPixelsBytesPerRow};
 368     const vImage_Buffer dest = {pixelsDst, h, w, w*sizeof(Pixel32bit)+extraBytesPerRow};
 369     vImage_Error err = vImageLookupTable_Planar8toPlanarF(&amp;src, &amp;dest, (Pixel_F*)lutdata, kvImageDoNotTile);
 370     if (err != kvImageNoError)
 371     {
 372         fprintf(stderr, &quot;Error in copyIndexed_8bitToARGB_32bit: vImageLookupTable_Planar8toPlanarF returns %ld\n&quot;, (long)err);
 373         register Pixel8bit *p8Bit = NULL;
 374         register jint skip = (javaPixelsBytesPerRow/javaPixelBytes)-w; // in pixelsSrc units
 375         register jint x, y;
 376         for (y=0; y&lt;h; y++)
 377         {
 378             for (x=0; x&lt;w; x++)
 379             {
 380                 *pixelsDst++ = lutdata[*pixelsSrc++];        // case 1
 381                 //*pixelsDst++ = *(lutdata + *pixelsSrc++);    // case 2: at best ~1% better than case 1
 382             }
 383             pixelsSrc += skip;
 384 
 385             p8Bit = (Pixel8bit *) pixelsDst;
 386             p8Bit += extraBytesPerRow;
 387             pixelsDst = (Pixel32bit *) p8Bit;
 388         }
 389     }
 390 }
 391 
 392 IMAGE_SURFACE_INLINE void copy565_16bitTo555_16bit(jint w, jint h, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel16bit *pixelsSrc, Pixel16bit *pixelsDst, size_t extraBytesPerRow)
 393 {
 394 PRINT(&quot;    copy565_16bitTo555_16bit&quot;)
 395 
 396     register Pixel8bit *p8Bit = NULL;
 397     register jint skip = (javaPixelsBytesPerRow/javaPixelBytes)-w; // in pixelsSrc units
 398     register jint green;
 399     register Pixel16bit pixel;
 400     register jint x, y;
 401     for (y=0; y&lt;h; y++)
 402     {
 403         for (x=0; x&lt;w; x++)
 404         {
 405             pixel = *pixelsSrc++;
 406 
 407             green = ((pixel &gt;&gt; 5) &amp; 63);  // rrrrrggggggbbbbb =&gt; shift 5 right = 00000rrrrrgggggg =&gt; and 63 = 0000000000gggggg
 408             green = ((jint) (((CGFloat) green / 63.0f) * 31.0f)) &amp; 31; // first normalize to value between 0 and 1 and then un-normalize to 5 bit (31 = 0000000000011111)
 409 
 410             *pixelsDst++ = ((pixel&amp;0xf800)&gt;&gt;1) | (green &lt;&lt; 5) | (pixel&amp;0x01f);
 411         }
 412         pixelsSrc += skip;
 413 
 414         p8Bit = (Pixel8bit *) pixelsDst;
 415         p8Bit += extraBytesPerRow;
 416         pixelsDst = (Pixel16bit *) p8Bit;
 417     }
 418 }
 419 
 420 
 421 IMAGE_SURFACE_INLINE void customPixelsToJava(JNIEnv *env, ImageSDOps *isdo)
 422 {
 423 PRINT(&quot;    customPixelsToJava&quot;)
 424 
 425     SurfaceDataOps *sdo = (SurfaceDataOps*)isdo;
 426     JNFCallVoidMethod(env, sdo-&gt;sdObject, jm_syncToCustom); // AWT_THREADING Safe (known object)
 427 }
 428 
 429 IMAGE_SURFACE_INLINE void removeAlphaPre_32bit(jint w, jint h, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel32bit *pixelsSrc)
 430 {
 431 PRINT(&quot;    removeAlphaPre_32bit&quot;)
 432 
 433     register jint skip = (javaPixelsBytesPerRow/javaPixelBytes)-w; // in pixelsSrc units
 434     register Pixel32bit pixel, alpha, red, green, blue;
 435     register jint x, y;
 436 
 437     for (y=0; y&lt;h; y++)
 438     {
 439         for (x=0; x&lt;w; x++)
 440         {
 441             pixel = *pixelsSrc;
 442 
 443             alpha        = (pixel &gt;&gt; 24) &amp; 0xff;
 444 
 445             if (alpha != 0)
 446             {
 447                 // get color components
 448                 red            = (pixel &gt;&gt; 16) &amp; 0xff;
 449                 green        = (pixel &gt;&gt; 8) &amp; 0xff;
 450                 blue        = (pixel &gt;&gt; 0) &amp; 0xff;
 451 
 452                 // remove alpha pre
 453                 red            = ((red * 0xff) + 0x7f) / alpha;
 454                 green        = ((green * 0xff) + 0x7f) / alpha;
 455                 blue        = ((blue * 0xff) + 0x7f) / alpha;
 456 
 457                 // clamp
 458                 red            = (red &lt;= 0xff) ? red : 0xff;
 459                 green        = (green &lt;= 0xff) ? green : 0xff;
 460                 blue        = (blue &lt;= 0xff) ? blue : 0xff;
 461 
 462                 *pixelsSrc++ = (alpha&lt;&lt;24) | (red&lt;&lt;16) | (green&lt;&lt;8) | blue; // construct new pixel
 463             }
 464             else
 465             {
 466                 *pixelsSrc++ = 0;
 467             }
 468         }
 469 
 470         pixelsSrc += skip;
 471     }
 472 }
 473 
 474 IMAGE_SURFACE_INLINE void swapRandBAndRemoveAlphaPre_32bit(jint w, jint h, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel32bit *pixelsSrc)
 475 {
 476 PRINT(&quot;    swapRandBAndRemoveAlphaPre_32bit&quot;)
 477 
 478     register jint skip = (javaPixelsBytesPerRow/javaPixelBytes)-w; // in pixelsSrc units
 479     register Pixel32bit pixel, alpha, red, green, blue;
 480     register jint x, y;
 481 
 482     for (y=0; y&lt;h; y++)
 483     {
 484         for (x=0; x&lt;w; x++)
 485         {
 486             pixel = *pixelsSrc;
 487 
 488             alpha        = (pixel &amp; 0xff000000) &gt;&gt; 24;
 489 
 490             if (alpha != 0)
 491             {
 492                 // get color components
 493                 red            = (pixel &amp; 0x00ff0000) &gt;&gt; 16;
 494                 green        = (pixel &amp; 0x0000ff00) &gt;&gt; 8;
 495                 blue        = (pixel &amp; 0x000000ff) &gt;&gt; 0;
 496 
 497                 // remove alpha pre
 498                 red            = ((red * 0xff) + 0x7f) / alpha;
 499                 green        = ((green * 0xff) + 0x7f) / alpha;
 500                 blue        = ((blue * 0xff) + 0x7f) / alpha;
 501 
 502                 // clamp
 503                 red            = (red &lt;= 0xff) ? red : 0xff;
 504                 green        = (green &lt;= 0xff) ? green : 0xff;
 505                 blue        = (blue &lt;= 0xff) ? blue : 0xff;
 506 
 507                 pixel = (alpha&lt;&lt;24) | (blue&lt;&lt;16) | (green&lt;&lt;8) | red; // construct new pixel
 508 
 509 #ifdef __LITTLE_ENDIAN__
 510                 pixel = CFSwapInt32HostToBig(pixel);  // the jint is little endian, we need to swap the bits before we send it back to Java
 511 #endif
 512 
 513                 *pixelsSrc++ = pixel;
 514             }
 515             else
 516             {
 517                 *pixelsSrc++ = 0;
 518             }
 519         }
 520 
 521         pixelsSrc += skip;
 522     }
 523 }
 524 
 525 IMAGE_SURFACE_INLINE void swapRandB_32bit_TYPE_INT(jint w, jint h, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel32bit *pixelsSrc)
 526 {
 527 PRINT(&quot;    swapRandB_32bit_TYPE_INT&quot;)
 528 
 529     register jint skip = (javaPixelsBytesPerRow/javaPixelBytes)-w; // in pixelsSrc units
 530     register Pixel32bit pixel, red, blue;
 531     register jint x, y;
 532 
 533     for (y=0; y&lt;h; y++)
 534     {
 535         for (x=0; x&lt;w; x++)
 536         {
 537             pixel = *pixelsSrc;
 538 
 539             red        = (pixel &amp; 0x00ff0000) &gt;&gt; 16; // get original red and shift to new position
 540             blue    = (pixel &amp; 0x000000ff) &lt;&lt; 16; // get original blue and shift to new position
 541 
 542             pixel    = (pixel &amp; 0xff00ff00); // erase original red&amp;blue
 543 
 544             pixel    = pixel | red | blue; // construct new pixel
 545 
 546             *pixelsSrc++ = pixel;
 547         }
 548 
 549         pixelsSrc += skip;
 550     }
 551 }
 552 
 553 IMAGE_SURFACE_INLINE void swapRandB_32bit_TYPE_4BYTE(jint w, jint h, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel32bit *pixelsSrc)
 554 {
 555 PRINT(&quot;    swapRandB_32bit_TYPE_4BYTE&quot;)
 556 
 557     register jint skip = (javaPixelsBytesPerRow/javaPixelBytes)-w; // in pixelsSrc units
 558     register Pixel32bit pixel, red, blue;
 559     register jint x, y;
 560 
 561     for (y=0; y&lt;h; y++)
 562     {
 563         for (x=0; x&lt;w; x++)
 564         {
 565             pixel = *pixelsSrc;
 566 
 567             red        = (pixel &amp; 0x00ff0000) &gt;&gt; 16; // get original red and shift to new position
 568             blue    = (pixel &amp; 0x000000ff) &lt;&lt; 16; // get original blue and shift to new position
 569 
 570             pixel    = (pixel &amp; 0xff00ff00); // erase original red&amp;blue
 571 
 572             pixel    = pixel | red | blue; // construct new pixel
 573 
 574 #ifdef __LITTLE_ENDIAN__
 575             pixel = CFSwapInt32HostToBig(pixel); // the jint is little endian, we need to swap the bits before we send it back to Java
 576 #endif
 577 
 578             *pixelsSrc++ = pixel;
 579         }
 580 
 581         pixelsSrc += skip;
 582     }
 583 }
 584 
 585 IMAGE_SURFACE_INLINE void map555_16bitTo565_16bit(jint w, jint h, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel16bit *pixelsSrc)
 586 {
 587 PRINT(&quot;    map555_16bitTo565_16bit&quot;)
 588     register jint skip = (javaPixelsBytesPerRow/javaPixelBytes)-w; // in pixelsSrc units
 589     register jint green;
 590     register Pixel16bit pixel;
 591     register jint x, y;
 592     for (y=0; y&lt;h; y++)
 593     {
 594         for (x=0; x&lt;w; x++)
 595         {
 596             pixel = *pixelsSrc;
 597 
 598             green = ((pixel &gt;&gt; 5)  &amp; 31);   // rrrrrgggggbbbbb =&gt; shift 5 right = 000000rrrrrggggg =&gt; and 31 = 00000000000ggggg
 599             green = ((jint) (((CGFloat) green / 31.0f) * 63.0f)) &amp; 63; // first normalize between 0 and 1 and then un-normalize to 6 bit (63 = 0000000000111111)
 600 
 601             *pixelsSrc++ = ((pixel&amp;0x7c00)&lt;&lt;1) | (green &lt;&lt; 5) | (pixel&amp;0x01f);
 602         }
 603 
 604         pixelsSrc += skip;
 605     }
 606 }
 607 
 608 IMAGE_SURFACE_INLINE void copyARGB_PRE_32bitToBGR_24bit(jint w, jint h, jint nativePixelsBytesPerRow, Pixel32bit *pixelsSrc, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel8bit *pixelsDst)
 609 {
 610 PRINT(&quot;    copyARGB_PRE_32bitToBGR_24bit&quot;)
 611 
 612     static const jint mask = 0x000000ff;
 613     register jint skipSrc = (nativePixelsBytesPerRow/sizeof(Pixel32bit))-w; // in pixelsSrc units
 614     register jint skipDst = ((javaPixelsBytesPerRow/javaPixelBytes)-w)*javaPixelBytes; // in pixelsDst units
 615     register Pixel32bit pixel, alpha, red, green, blue;
 616     register jint x, y;
 617 
 618     for (y=0; y&lt;h; y++)
 619     {
 620         for (x=0; x&lt;w; x++)
 621         {
 622             pixel = *pixelsSrc;
 623 
 624             alpha        = (pixel &gt;&gt; 24) &amp; mask;
 625 
 626             if (alpha != 0)
 627             {
 628                 // extract color components
 629                 red            = (pixel &gt;&gt; 16) &amp; mask;
 630                 green        = (pixel &gt;&gt; 8) &amp; mask;
 631                 blue        = (pixel &gt;&gt; 0) &amp; mask;
 632 
 633                 // remove alpha pre
 634                 red            = ((red * 0xff) + 0x7f) / alpha;
 635                 green        = ((green * 0xff) + 0x7f) / alpha;
 636                 blue        = ((blue * 0xff) + 0x7f) / alpha;
 637 
 638                 // clamp
 639                 *pixelsDst++ = (blue &lt;= 0xff) ? blue : 0xff;
 640                 *pixelsDst++ = (green &lt;= 0xff) ? green : 0xff;
 641                 *pixelsDst++ = (red &lt;= 0xff) ? red : 0xff;
 642             }
 643             else
 644             {
 645                 *pixelsDst++ = 0; // blue
 646                 *pixelsDst++ = 0; // green
 647                 *pixelsDst++ = 0; // red
 648             }
 649 
 650             pixelsSrc++;
 651         }
 652 
 653         pixelsSrc += skipSrc;
 654         pixelsDst += skipDst;
 655     }
 656 }
 657 
 658 
 659 IMAGE_SURFACE_INLINE void copyARGB_PRE_32bitToRGB_24bit(jint w, jint h, jint nativePixelsBytesPerRow, Pixel32bit *pixelsSrc, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel8bit *pixelsDst)
 660 {
 661     PRINT(&quot;    copyARGB_PRE_32bitToRGB_24bit&quot;)
 662 
 663     static const jint mask = 0x000000ff;
 664     register jint skipSrc = (nativePixelsBytesPerRow/sizeof(Pixel32bit))-w; // in pixelsSrc units
 665     register jint skipDst = ((javaPixelsBytesPerRow/javaPixelBytes)-w)*javaPixelBytes; // in pixelsDst units
 666     register Pixel32bit pixel, alpha, red, green, blue;
 667     register jint x, y;
 668 
 669     for (y=0; y&lt;h; y++)
 670     {
 671         for (x=0; x&lt;w; x++)
 672         {
 673             pixel = *pixelsSrc;
 674 
 675             alpha        = (pixel &gt;&gt; 24) &amp; mask;
 676 
 677             if (alpha != 0)
 678             {
 679                 // extract color components
 680                 red            = (pixel &gt;&gt; 16) &amp; mask;
 681                 green        = (pixel &gt;&gt; 8) &amp; mask;
 682                 blue        = (pixel &gt;&gt; 0) &amp; mask;
 683 
 684                 // remove alpha pre
 685                 red            = ((red * 0xff) + 0x7f) / alpha;
 686                 green        = ((green * 0xff) + 0x7f) / alpha;
 687                 blue        = ((blue * 0xff) + 0x7f) / alpha;
 688 
 689                 // clamp
 690                 *pixelsDst++ = (red &lt;= 0xff) ? red : 0xff;
 691                 *pixelsDst++ = (green &lt;= 0xff) ? green : 0xff;
 692                 *pixelsDst++ = (blue &lt;= 0xff) ? blue : 0xff;
 693             }
 694             else
 695             {
 696                 *pixelsDst++ = 0; // blue
 697                 *pixelsDst++ = 0; // green
 698                 *pixelsDst++ = 0; // red
 699             }
 700 
 701             pixelsSrc++;
 702         }
 703 
 704         pixelsSrc += skipSrc;
 705         pixelsDst += skipDst;
 706     }
 707 }
 708 
 709 
 710 // gray = 0.3red + 0.59green + 0.11blue - NTSC standard (according to Luke Wallis)
 711 IMAGE_SURFACE_INLINE void copyARGB_PRE_32bitToGray_16bit(jint w, jint h, jint nativePixelsBytesPerRow, Pixel32bit *pixelsSrc, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel16bit *pixelsDst)
 712 {
 713 PRINT(&quot;    copyARGB_PRE_32bitToGray_16bit&quot;)
 714 
 715     static const jint mask = 0x000000ff;
 716     register jint skipSrc = (nativePixelsBytesPerRow/sizeof(Pixel32bit))-w; // in pixelsSrc units
 717     register jint skipDst = (javaPixelsBytesPerRow/javaPixelBytes)-w; // in pixelsDst units
 718     register Pixel32bit alpha;
 719     register Pixel32bit pixel, red, green, blue;
 720     register CGFloat pixelFloat;
 721     register jint x, y;
 722 
 723     for (y=0; y&lt;h; y++)
 724     {
 725         for (x=0; x&lt;w; x++)
 726         {
 727             pixel        = *pixelsSrc;
 728 
 729             // gznote: do we remove alpha pre here?
 730             alpha        = ((pixel &gt;&gt; 24) &amp; mask); //extract
 731 
 732             if (alpha != 0)
 733             {
 734                 red            = ((pixel &gt;&gt; 16) &amp; mask); // extract
 735                 green        = ((pixel &gt;&gt; 8) &amp; mask); // extract
 736                 blue        = ((pixel &gt;&gt; 0) &amp; mask); // extract
 737 
 738                 alpha        *= 0xff; // upsample to 16bit
 739                 red            *= 0xff; // upsample to 16bit
 740                 green        *= 0xff; // upsample to 16bit
 741                 blue        *= 0xff; // upsample to 16bit
 742 
 743                 red            = ((red * 0xffff) + 0x7fff) / alpha; // remove alpha pre
 744                 red            = (red &lt;= 0xffff) ? red : 0xffff;
 745                 green        = ((green * 0xffff) + 0x7fff) / alpha; // remove alpha pre
 746                 green        = (green &lt;= 0xffff) ? green : 0xffff;
 747                 blue        = ((blue * 0xffff) + 0x7fff) / alpha; // remove alpha pre
 748                 blue        = (blue &lt;= 0xffff) ? blue : 0xffff;
 749 
 750                 pixelFloat    = red*0.3f + green*0.59f + blue*0.11f; // rgb-&gt;gray NTSC conversion
 751             }
 752             else
 753             {
 754                 pixelFloat = 0;
 755             }
 756 
 757             *pixelsDst    = (jint)pixelFloat;
 758             pixelsDst++;
 759 
 760             pixelsSrc++;
 761         }
 762 
 763         pixelsSrc += skipSrc;
 764         pixelsDst += skipDst;
 765     }
 766 }
 767 
 768 // 1. first &quot;dither&quot; the true color down by creating a 16 bit value of the real color that will serve as an index into the cache of indexes
 769 // 2. if the cache has a valid entry use it otherwise go through 3 and 4
 770 // 3. go through the color table and calculate Euclidian distance between the true color and the indexed colors
 771 // 4. map the shortest distance into the one and true index color and stick it into the dst (and cache)
 772 IMAGE_SURFACE_INLINE UInt16* copyARGB_PRE_bitToIndexed_8bit(jint w, jint h, jint nativePixelsBytesPerRow, Pixel32bit *pixelsSrc, jint javaPixelsBytesPerRow, jint javaPixelBytes, Pixel8bit *pixelsDst, Pixel32bit* lutdata, UInt32 lutDataSize, UInt16 *indexedColorTable)
 773 {
 774 PRINT(&quot;    copyARGB_PRE_bitToIndexed_8bit&quot;)
 775     static const UInt32 mask            = 0x000000ff;
 776 
 777     static const UInt32 indexSize        = 65536;        // 2^16 - 16 bits of precision
 778     static const UInt32 indexMask        = 0x000000f0;    // 00000000000000000000000011110000
 779     static const UInt16 invalidIndex    = 0xffff;        // 1111111111111111
 780 
 781     register jint skipSrc = (nativePixelsBytesPerRow/sizeof(Pixel32bit))-w; // in pixelsSrc units
 782     register jint skipDst = (javaPixelsBytesPerRow/javaPixelBytes)-w; // in pixelsSrc units
 783     register jint indexOfBest, indexOfBestCached = -1;
 784     register CGFloat distanceOfBest, distance;
 785     register UInt32 p1, p1Cached = 0, p1a, p1r, p1g, p1b, p2;
 786     register SInt32 da, dr, dg, db;
 787     register jint x, y, i;
 788     BOOL cachedValueReady = NO;
 789 
 790     if (indexedColorTable == NULL)
 791     {
 792         indexedColorTable = (UInt16*)malloc(indexSize*sizeof(UInt16));    // 15 bit precision, each entry capable of holding a 2 byte value
 793                                                                         // (lower byte for the actual index, higher byte to mark it valid/invalid)
 794 
 795         if (indexedColorTable != NULL)
 796         {
 797             memset((void*)indexedColorTable, invalidIndex, indexSize*sizeof(UInt16));
 798         }
 799         else
 800         {
 801             fprintf(stderr, &quot;ERROR: malloc returns NULL for isdo-&gt;indexedColorTable in copyARGB_PRE_bitToIndexed_8bit&quot;);
 802             return NULL;
 803         }
 804     }
 805 
 806     register UInt16 cacheIndex;
 807 
 808     for (y=0; y&lt;h; y++)
 809     {
 810         for (x=0; x&lt;w; x++)
 811         {
 812             p1 = *pixelsSrc;
 813 
 814             if ((p1Cached != p1) || (cachedValueReady == NO))
 815             {
 816                 p1a = ((p1 &gt;&gt; 24) &amp; mask);
 817 
 818                 if (p1a != 0)
 819                 {
 820                     // extract color components
 821                     p1r = ((p1 &gt;&gt; 16) &amp; mask);
 822                     p1g = ((p1 &gt;&gt; 8) &amp; mask);
 823                     p1b = ((p1 &gt;&gt; 0) &amp; mask);
 824 
 825                     // remove alpha pre
 826                     p1r = ((p1r * 0xff) + 0x7f) / p1a;
 827                     p1g = ((p1g * 0xff) + 0x7f) / p1a;
 828                     p1b = ((p1b * 0xff) + 0x7f) / p1a;
 829 
 830                     // clamp
 831                     p1r = (p1r &lt;= 0xff) ? p1r : 0xff;
 832                     p1g = (p1g &lt;= 0xff) ? p1g : 0xff;
 833                     p1b = (p1b &lt;= 0xff) ? p1b : 0xff;
 834                 }
 835                 else
 836                 {
 837                     p1r = 0;
 838                     p1g = 0;
 839                     p1b = 0;
 840                 }
 841 
 842                 cacheIndex = (UInt16)(((p1a &amp; indexMask) &lt;&lt; 8) | ((p1r &amp; indexMask) &lt;&lt; 4) | ((p1g &amp; indexMask) &lt;&lt; 0) | ((p1b &amp; indexMask) &gt;&gt; 4));
 843                 if (indexedColorTable[cacheIndex] == invalidIndex)
 844                 {
 845                     indexOfBest = 0;
 846                     distanceOfBest = DBL_MAX;
 847 
 848                     for (i=0; (unsigned)i&lt;lutDataSize; i++)
 849                     {
 850                         p2 = lutdata[i];
 851 
 852                         da = p1a - ((p2 &gt;&gt; 24) &amp; mask);
 853                         dr = p1r - ((p2 &gt;&gt; 16) &amp; mask);
 854                         dg = p1g - ((p2 &gt;&gt; 8) &amp; mask);
 855                         db = p1b - ((p2 &gt;&gt; 0) &amp; mask);
 856 
 857                         distance = sqrt((da*da)+(dr*dr)+(dg*dg)+(db*db));
 858                         if (distance &lt; distanceOfBest)
 859                         {
 860                             distanceOfBest = distance;
 861                             indexOfBest = i;
 862                         }
 863                     }
 864 
 865                     indexedColorTable[cacheIndex] = indexOfBest;
 866                 }
 867                 else
 868                 {
 869                     indexOfBest = indexedColorTable[cacheIndex];
 870                 }
 871 
 872                 cachedValueReady = YES;
 873                 p1Cached = p1;
 874                 indexOfBestCached = indexOfBest;
 875             }
 876             else
 877             {
 878                 indexOfBest = indexOfBestCached;
 879             }
 880 
 881             *pixelsDst = indexOfBest;
 882 
 883             pixelsDst++;
 884             pixelsSrc++;
 885         }
 886         pixelsSrc += skipSrc;
 887         pixelsDst += skipDst;
 888     }
 889 
 890     return indexedColorTable;
 891 }
 892 
 893 // callback from CG telling us it&#39;s done with the data. &lt;rdar://problem/4762033&gt;
 894 static void releaseDataFromProvider(void *info, const void *data, size_t size)
 895 {
 896     if (data != NULL)
 897     {
 898         free((void*)data);
 899     }
 900 }
 901 
 902 IMAGE_SURFACE_INLINE void createContext(JNIEnv *env, ImageSDOps *isdo)
 903 {
 904 PRINT(&quot;createContext&quot;)
 905 
 906     QuartzSDOps *qsdo = (QuartzSDOps*)isdo;
 907     if (qsdo-&gt;cgRef == NULL)  // lazy creation
 908     {
 909         size_t bitsPerComponent = isdo-&gt;contextInfo.bitsPerComponent;
 910         CGColorSpaceRef colorSpace = isdo-&gt;contextInfo.colorSpace;
 911         CGImageAlphaInfo alphaInfo = isdo-&gt;contextInfo.alphaInfo;
 912 
 913         size_t bytesPerRow = isdo-&gt;contextInfo.bytesPerRow;
 914         size_t size = bytesPerRow * isdo-&gt;height;
 915         isdo-&gt;nativePixels = malloc(size);
 916 
 917         if (isdo-&gt;nativePixels == NULL)
 918         {
 919             fprintf(stderr, &quot;malloc failed for size %d bytes in ImageSurfaceData.createContext()\n&quot;, (int) size);
 920         }
 921 
 922 //fprintf(stderr, &quot;isdo=%p isdo-&gt;type=%d, bitsPerComponent=%d, bytesPerRow=%d, colorSpace=%p, alphaInfo=%d, width=%d, height=%d, size=%d\n&quot;, isdo, type, (jint)bitsPerComponent, (jint)bytesPerRow, colorSpace, (jint)alphaInfo, (jint) isdo-&gt;width, (jint) isdo-&gt;height, (jint) size);
 923 
 924         qsdo-&gt;cgRef = CGBitmapContextCreate(isdo-&gt;nativePixels, isdo-&gt;width, isdo-&gt;height, bitsPerComponent, bytesPerRow, colorSpace, alphaInfo);
 925         isdo-&gt;dataProvider = CGDataProviderCreateWithData(NULL, isdo-&gt;nativePixels, size, releaseDataFromProvider);
 926     }
 927 
 928 //fprintf(stderr, &quot;cgRef=%p\n&quot;, qsdo-&gt;cgRef);
 929     if (qsdo-&gt;cgRef == NULL)
 930     {
 931         fprintf(stderr, &quot;ERROR: (qsdo-&gt;cgRef == NULL) in createContext!\n&quot;);
 932     }
 933 
 934     // intitalize the context to match the Java coordinate system
 935 
 936     // BG, since the context is created above, we can just concat
 937     CGContextConcatCTM(qsdo-&gt;cgRef, CGAffineTransformMake(1, 0, 0, -1, 0, isdo-&gt;height));
 938 
 939     CGContextSaveGState(qsdo-&gt;cgRef); // this will make sure we don&#39;t go pass device context settings
 940     CGContextSaveGState(qsdo-&gt;cgRef); // this will put user settings on top, used by LazyStateManagement code
 941     qsdo-&gt;newContext = YES;
 942 }
 943 
 944 IMAGE_SURFACE_INLINE void holdJavaPixels(JNIEnv* env, ImageSDOps* isdo)
 945 {
 946 PRINT(&quot;holdJavaPixels&quot;)
 947 
 948     if (isdo-&gt;type != java_awt_image_BufferedImage_TYPE_CUSTOM)
 949     {
 950         Pixel8bit* pixels = NULL;
 951         if (isdo-&gt;nrOfPixelsOwners == 0)
 952         {
 953             pixels = (Pixel8bit*)((*env)-&gt;GetPrimitiveArrayCritical(env, isdo-&gt;array, NULL));
 954             if (pixels != NULL)
 955             {
 956                 isdo-&gt;pixelsLocked = pixels;
 957 
 958                 isdo-&gt;pixels = isdo-&gt;pixelsLocked + isdo-&gt;offset;
 959             }
 960             else
 961             {
 962                 fprintf(stderr, &quot;ERROR: GetPrimitiveArrayCritical returns NULL for pixels in holdJavaPixels!\n&quot;);
 963             }
 964         }
 965         isdo-&gt;nrOfPixelsOwners++;
 966     }
 967     else if (isdo-&gt;pixels == NULL)
 968     {
 969         isdo-&gt;pixels = (Pixel8bit*)((*env)-&gt;GetDirectBufferAddress(env, isdo-&gt;array));
 970     }
 971 }
 972 
 973 IMAGE_SURFACE_INLINE void unholdJavaPixels(JNIEnv* env, ImageSDOps* isdo)
 974 {
 975 PRINT(&quot;unholdJavaPixels&quot;)
 976 
 977     if (isdo-&gt;type != java_awt_image_BufferedImage_TYPE_CUSTOM)
 978     {
 979         isdo-&gt;nrOfPixelsOwners--;
 980         if (isdo-&gt;nrOfPixelsOwners == 0)
 981         {
 982             isdo-&gt;pixels = NULL;
 983 
 984             (*env)-&gt;ReleasePrimitiveArrayCritical(env, isdo-&gt;array, isdo-&gt;pixelsLocked, 0); // Do not use JNI_COMMIT, as that will not free the buffer copy when +ProtectJavaHeap is on.
 985             isdo-&gt;pixelsLocked = NULL;
 986         }
 987     }
 988 }
 989 
 990 static void imageDataProvider_UnholdJavaPixels(void *info, const void *data, size_t size)
 991 {
 992 PRINT(&quot;imageDataProvider_UnholdJavaPixels&quot;)
 993 
 994     // Currently do nothing
 995 }
 996 
 997 static void imageDataProvider_FreeTempPixels(void *info, const void *data, size_t size)
 998 {
 999 PRINT(&quot;imageDataProvider_FreeTempPixels&quot;)
1000 
1001     free((void *)data);
1002 }
1003 IMAGE_SURFACE_INLINE void syncFromJavaPixels(JNIEnv* env, ImageSDOps* isdo)
1004 {
1005 PRINT(&quot;syncFromJavaPixels&quot;)
1006 
1007     // check to see if we have any work to do
1008     if (isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex] == 1)
1009     {
1010         // if we do, lock down Java pixels, this halts GarbageCollector!
1011         holdJavaPixels(env, isdo);
1012         if (isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex] == 1)
1013         {
1014             isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex] = 0;
1015 
1016             void *dataProviderData = NULL;
1017             void *dataProviderInfo = NULL;
1018             void *dataProviderCallback = NULL;
1019             size_t dataProviderDataSize = 0;
1020             size_t width = isdo-&gt;width;
1021             size_t height = isdo-&gt;height;
1022             size_t bitsPerComponent = isdo-&gt;imageInfo.bitsPerComponent;
1023             size_t bitsPerPixel = isdo-&gt;imageInfo.bitsPerPixel;
1024             size_t bytesPerRow = 0;
1025             size_t extraBytesPerRow = 0; // these are the extra bytesPerRow used for alignement
1026 
1027             switch (isdo-&gt;type)
1028             {
1029                 //case java_awt_image_BufferedImage_TYPE_BYTE_BINARY: // mapped to TYPE_CUSTOM
1030                 case java_awt_image_BufferedImage_TYPE_CUSTOM:
1031                     holdJavaPixels(env, isdo);    // we lock again since we are reusing pixels, but we must ensure CGImageRef immutability
1032                                                 // we can lock these pixels down because they are nio based, so we don&#39;t halt the GarbageCollector
1033                     bytesPerRow = isdo-&gt;javaPixelsBytesPerRow;
1034                     dataProviderDataSize = bytesPerRow*isdo-&gt;height;
1035                     dataProviderData = isdo-&gt;pixels;
1036                     dataProviderInfo = isdo;
1037                     dataProviderCallback = imageDataProvider_UnholdJavaPixels;
1038                     break;
1039                 default:
1040                     bytesPerRow = isdo-&gt;imageInfo.bytesPerRow;
1041                     dataProviderDataSize = bytesPerRow*height;
1042                     dataProviderData = malloc(dataProviderDataSize);
1043                     dataProviderInfo = isdo;
1044                     dataProviderCallback = imageDataProvider_FreeTempPixels;
1045             }
1046 
1047             switch (isdo-&gt;type)
1048             {
1049                 //case java_awt_image_BufferedImage_TYPE_BYTE_BINARY: // mapped to TYPE_CUSTOM
1050                 case java_awt_image_BufferedImage_TYPE_CUSTOM:
1051                     customPixelsFromJava(env, isdo);
1052                     break;
1053                 case java_awt_image_BufferedImage_TYPE_INT_RGB:
1054                 case java_awt_image_BufferedImage_TYPE_INT_ARGB:
1055                 case java_awt_image_BufferedImage_TYPE_INT_ARGB_PRE:
1056                 case java_awt_image_BufferedImage_TYPE_USHORT_555_RGB:
1057                 case java_awt_image_BufferedImage_TYPE_USHORT_GRAY:
1058                 case java_awt_image_BufferedImage_TYPE_BYTE_GRAY:
1059                     copyBits(width, height, isdo-&gt;javaPixelsBytesPerRow, (Pixel8bit*)isdo-&gt;pixels, bytesPerRow, dataProviderData);
1060                     break;
1061                 case java_awt_image_BufferedImage_TYPE_INT_BGR:
1062                     copySwapRandB_32bit_TYPE_INT(width, height, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, (Pixel32bit*)isdo-&gt;pixels, dataProviderData, extraBytesPerRow);
1063                     break;
1064                 case java_awt_image_BufferedImage_TYPE_4BYTE_ABGR:
1065                 case java_awt_image_BufferedImage_TYPE_4BYTE_ABGR_PRE:
1066                     copySwapRandB_32bit_TYPE_4BYTE(width, height, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, (Pixel32bit*)isdo-&gt;pixels, dataProviderData, extraBytesPerRow);
1067                     break;
1068                 case java_awt_image_BufferedImage_TYPE_3BYTE_BGR:
1069                     copyBGR_24bitToXRGB_32bit(width, height, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, isdo-&gt;pixels, dataProviderData, extraBytesPerRow);
1070                     break;
1071                 case sun_java2d_OSXOffScreenSurfaceData_TYPE_3BYTE_RGB:
1072                     copyRGB_24bitToXRGB_32bit(width, height, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, isdo-&gt;pixels, dataProviderData, extraBytesPerRow);
1073                     break;
1074                 case java_awt_image_BufferedImage_TYPE_USHORT_565_RGB:
1075                     copy565_16bitTo555_16bit(width, height, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, (Pixel16bit*)isdo-&gt;pixels, dataProviderData, extraBytesPerRow);
1076                     break;
1077                 case java_awt_image_BufferedImage_TYPE_BYTE_INDEXED:
1078                     copyIndexed_8bitToARGB_32bit(width, height, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, isdo-&gt;pixels, isdo-&gt;lutData, dataProviderData, extraBytesPerRow);
1079                     break;
1080                 default:
1081                     break;
1082             }
1083 
1084             CGDataProviderRef provider = CGDataProviderCreateWithData(dataProviderInfo, dataProviderData, dataProviderDataSize, dataProviderCallback);
1085             CGImageRef javaImg = CGImageCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow,
1086                                                 isdo-&gt;imageInfo.colorSpace, isdo-&gt;imageInfo.alphaInfo, provider, NULL, NO, kCGRenderingIntentDefault);
1087 //fprintf(stderr, &quot;javaImg=%p\n&quot;, javaImg);
1088             CGDataProviderRelease(provider);
1089 
1090             if (javaImg != NULL)
1091             {
1092                 QuartzSDOps *qsdo = (QuartzSDOps*)isdo;
1093 
1094                 if (isdo-&gt;imgRef != NULL)
1095                 {
1096                     CGImageRelease(isdo-&gt;imgRef);
1097                     isdo-&gt;imgRef = NULL;
1098                 }
1099 
1100                 if (qsdo-&gt;cgRef == NULL)
1101                 {
1102                     createContext(env, isdo);
1103                 }
1104 
1105                 if (qsdo-&gt;cgRef != NULL)
1106                 {
1107                     CGContextSaveGState(qsdo-&gt;cgRef);
1108                     CGAffineTransform currCTM = CGContextGetCTM(qsdo-&gt;cgRef);
1109                     CGAffineTransform inverse = CGAffineTransformInvert(currCTM);
1110                     CGContextConcatCTM(qsdo-&gt;cgRef, inverse);
1111                     CGContextConcatCTM(qsdo-&gt;cgRef, CGAffineTransformMake(1, 0, 0, 1, 0, 0));
1112                     CGContextSetBlendMode(qsdo-&gt;cgRef, kCGBlendModeCopy);
1113                     CGContextSetAlpha(qsdo-&gt;cgRef, 1.0f);
1114                     CGContextDrawImage(qsdo-&gt;cgRef, CGRectMake(0, 0, width, height), javaImg);
1115                     CGContextFlush(qsdo-&gt;cgRef);
1116                     CGContextRestoreGState(qsdo-&gt;cgRef);
1117                     CGImageRelease(javaImg);
1118                 }
1119                 else
1120                 {
1121                     fprintf(stderr, &quot;ERROR: (cgRef == NULL) in syncFromJavaPixels!\n&quot;);
1122                 }
1123             }
1124             else
1125             {
1126 //fprintf(stderr, &quot;isdo-&gt;type=%d, isdo-&gt;width=%d, isdo-&gt;height=%d, isdo-&gt;imageInfo.bitsPerComponent=%d, isdo-&gt;imageInfo.bytesPerPixel=%d, isdo-&gt;imageInfo.bitsPerPixel=%d, isdo-&gt;imageInfo.bytesPerRow=%d, isdo-&gt;imageInfo.colorSpace=%p, isdo-&gt;imageInfo.alphaInfo=%d\n&quot;,
1127 //(jint)isdo-&gt;type, (jint)isdo-&gt;width, (jint)isdo-&gt;height, (jint)isdo-&gt;imageInfo.bitsPerComponent, (jint)isdo-&gt;imageInfo.bytesPerPixel, (jint)isdo-&gt;imageInfo.bitsPerPixel, (jint)isdo-&gt;imageInfo.bytesPerRow, isdo-&gt;imageInfo.colorSpace, (jint)isdo-&gt;imageInfo.alphaInfo);
1128                 fprintf(stderr, &quot;ERROR: (javaImg == NULL) in syncFromJavaPixels!\n&quot;);
1129             }
1130         }
1131 
1132         unholdJavaPixels(env, isdo);
1133     }
1134 }
1135 
1136 IMAGE_SURFACE_INLINE void processPixels(ImageSDOps* isdo, jint x, jint y, jint width, jint height, void (*processPixelsCallback) (ImageSDOps *, jint, Pixel32bit *, jint, jint, jint, jint))
1137 {
1138     processPixelsCallback(isdo, (jint) isdo-&gt;contextInfo.bytesPerRow, (Pixel32bit *) isdo-&gt;nativePixels, x, y, width, height);
1139 }
1140 
1141 IMAGE_SURFACE_INLINE void syncToJavaPixels_processPixelsCallback(ImageSDOps* isdo, jint nativePixelsBytesPerRow, Pixel32bit *dataSrc, jint x, jint y, jint width, jint height)
1142 {
1143     switch (isdo-&gt;type)
1144     {
1145         case java_awt_image_BufferedImage_TYPE_3BYTE_BGR:
1146             copyARGB_PRE_32bitToBGR_24bit(isdo-&gt;width, isdo-&gt;height, nativePixelsBytesPerRow, dataSrc, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, isdo-&gt;pixels);
1147             break;
1148         case sun_java2d_OSXOffScreenSurfaceData_TYPE_3BYTE_RGB:
1149             copyARGB_PRE_32bitToRGB_24bit(isdo-&gt;width, isdo-&gt;height, nativePixelsBytesPerRow, dataSrc, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, isdo-&gt;pixels);
1150             break;
1151         case java_awt_image_BufferedImage_TYPE_USHORT_GRAY:
1152             copyARGB_PRE_32bitToGray_16bit(isdo-&gt;width, isdo-&gt;height, nativePixelsBytesPerRow, dataSrc, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, (Pixel16bit*)isdo-&gt;pixels);
1153             break;
1154         case java_awt_image_BufferedImage_TYPE_BYTE_INDEXED:
1155             isdo-&gt;indexedColorTable = copyARGB_PRE_bitToIndexed_8bit(isdo-&gt;width, isdo-&gt;height, nativePixelsBytesPerRow, dataSrc, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, isdo-&gt;pixels, isdo-&gt;lutData, isdo-&gt;lutDataSize, isdo-&gt;indexedColorTable);
1156             break;
1157         default:
1158             break;
1159     }
1160 }
1161 
1162 
1163 IMAGE_SURFACE_INLINE void syncToJavaPixels(JNIEnv* env, ImageSDOps* isdo)
1164 {
1165 PRINT(&quot;syncToJavaPixels&quot;)
1166 
1167     holdJavaPixels(env, isdo);
1168 
1169     QuartzSDOps *qsdo = (QuartzSDOps*)isdo;
1170     if (qsdo-&gt;cgRef == NULL)
1171     {
1172         createContext(env, isdo);
1173     }
1174 
1175     isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNativePixelsChangedIndex] = 0;
1176 
1177     if (isdo-&gt;contextInfo.canUseJavaPixelsAsContext == YES)
1178     {
1179 
1180         jint srcBytesPerRow = isdo-&gt;contextInfo.bytesPerRow;
1181         jint dstBytesPerRow = isdo-&gt;javaPixelsBytesPerRow;
1182         jint h = isdo-&gt;height;
1183         Pixel8bit *pixelsSrc = isdo-&gt;nativePixels;
1184         Pixel8bit *pixelsDst = isdo-&gt;pixels;
1185 
1186         if (srcBytesPerRow == dstBytesPerRow)
1187         {
1188             memcpy(pixelsDst, pixelsSrc, h * dstBytesPerRow);
1189         }
1190         else
1191         {
1192             jint widthInBytes = isdo-&gt;width * isdo-&gt;contextInfo.bytesPerPixel;
1193             jint y;
1194             for (y=0; y &lt; h; y++)
1195             {
1196                 memcpy(pixelsDst, pixelsSrc, widthInBytes);
1197 
1198                 pixelsSrc += srcBytesPerRow;
1199                 pixelsDst += dstBytesPerRow;
1200             }
1201         }
1202 
1203         switch (isdo-&gt;type)
1204         {
1205             //case java_awt_image_BufferedImage_TYPE_BYTE_BINARY: // mapped to TYPE_CUSTOM
1206             case java_awt_image_BufferedImage_TYPE_CUSTOM:
1207                 customPixelsToJava(env, isdo);
1208                 break;
1209             case java_awt_image_BufferedImage_TYPE_INT_ARGB:
1210                 removeAlphaPre_32bit(isdo-&gt;width, isdo-&gt;height, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, (Pixel32bit*)isdo-&gt;pixels);
1211                 break;
1212             case java_awt_image_BufferedImage_TYPE_4BYTE_ABGR:
1213                 swapRandBAndRemoveAlphaPre_32bit(isdo-&gt;width, isdo-&gt;height, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, (Pixel32bit*)isdo-&gt;pixels);
1214                 break;
1215             case java_awt_image_BufferedImage_TYPE_INT_BGR:
1216                 swapRandB_32bit_TYPE_INT(isdo-&gt;width, isdo-&gt;height, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, (Pixel32bit*)isdo-&gt;pixels);
1217                 break;
1218             case java_awt_image_BufferedImage_TYPE_4BYTE_ABGR_PRE:
1219                 swapRandB_32bit_TYPE_4BYTE(isdo-&gt;width, isdo-&gt;height, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, (Pixel32bit*)isdo-&gt;pixels);
1220                 break;
1221             case java_awt_image_BufferedImage_TYPE_USHORT_565_RGB:
1222                 map555_16bitTo565_16bit(isdo-&gt;width, isdo-&gt;height, isdo-&gt;javaPixelsBytesPerRow, isdo-&gt;javaPixelBytes, (Pixel16bit*)isdo-&gt;pixels);
1223                 break;
1224             default:
1225                 break;
1226         }
1227     }
1228     else
1229     {
1230         processPixels(isdo, 0, 0, isdo-&gt;width, isdo-&gt;height, &amp;syncToJavaPixels_processPixelsCallback);
1231     }
1232 
1233     unholdJavaPixels(env, isdo);
1234 }
1235 
1236 
1237 IMAGE_SURFACE_INLINE jboolean xorSurfacePixels(JNIEnv *env, jobject dstIsd, jobject srcIsd, jint colorXOR, jint x, jint y, jint w, jint h)
1238 {
1239 PRINT(&quot;xorSurfacePixels&quot;)
1240 
1241     jboolean handled = JNI_FALSE;
1242 
1243 JNF_COCOA_ENTER(env);
1244     ImageSDOps* srcIsdo = LockImagePixels(env, srcIsd);
1245     ImageSDOps* dstIsdo = LockImagePixels(env, dstIsd);
1246 
1247     if ((x &lt; 0) || (y &lt; 0) || (x+w &gt; dstIsdo-&gt;width) || (y+h &gt; dstIsdo-&gt;height) || (w &gt; srcIsdo-&gt;width) || (h &gt; srcIsdo-&gt;height))
1248     {
1249 #ifdef PRINT_WARNINGS
1250 fprintf(stderr, &quot;xorSurfacePixels INVALID parameters: x=%d, y=%d, w=%d, h=%d\n&quot;, x, y, w, h);
1251 fprintf(stderr, &quot;   dstIsdo-&gt;width=%d, dstIsdo-&gt;height=%d, biqsdoPixels-&gt;width=%d, biqsdoPixels-&gt;height=%d\n&quot;,
1252                         dstIsdo-&gt;width, dstIsdo-&gt;height, srcIsdo-&gt;width, srcIsdo-&gt;height);
1253 #endif
1254         UnlockImagePixels(env, srcIsdo);
1255         UnlockImagePixels(env, dstIsdo);
1256 
1257         return JNI_FALSE;
1258     }
1259 
1260     jint offset = (dstIsdo-&gt;width*y)+x;
1261     register Pixel32bit* dstPixels = (Pixel32bit*)dstIsdo-&gt;pixels;
1262     register jint skip = dstIsdo-&gt;width - w;
1263     register Pixel32bit* srcPixels = (Pixel32bit*)srcIsdo-&gt;pixels;
1264     register jint skipPixels = srcIsdo-&gt;width - w;
1265     register jint i, j;
1266 
1267     dstPixels += offset;
1268 
1269     switch (dstIsdo-&gt;type)
1270     {
1271         case java_awt_image_BufferedImage_TYPE_INT_RGB:
1272         case java_awt_image_BufferedImage_TYPE_INT_ARGB:
1273         case java_awt_image_BufferedImage_TYPE_INT_ARGB_PRE:
1274         {
1275             dstIsdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex] = 1;
1276 
1277             if (dstIsdo-&gt;type == java_awt_image_BufferedImage_TYPE_INT_ARGB_PRE)
1278             {
1279                 Pixel8bit alpha = (colorXOR&gt;&gt;24)&amp;0xff;
1280                 Pixel8bit red = (colorXOR&gt;&gt;16)&amp;0xff;
1281                 red = (jint)(((CGFloat)red/255.0f * (CGFloat)alpha/255.0f)*255.0f);
1282                 Pixel8bit green = (colorXOR&gt;&gt;8)&amp;0xff;
1283                 green = (jint)(((CGFloat)green/255.0f * (CGFloat)alpha/255.0f)*255.0f);
1284                 Pixel8bit blue = (colorXOR&gt;&gt;0)&amp;0xff;
1285                 blue = (jint)(((CGFloat)blue/255.0f * (CGFloat)alpha/255.0f)*255.0f);
1286                 colorXOR = (alpha&lt;&lt;24) | (red&lt;&lt;16) | (green&lt;&lt;8) | blue; // the color is now alpha premultiplied
1287             }
1288 
1289             for (i=0; i&lt;h; i++)
1290             {
1291                 for (j=0; j&lt;w; j++)
1292                 {
1293                     Pixel32bit srcPixel = *srcPixels;
1294                     Pixel8bit pixelAlpha = (srcPixel&gt;&gt;24);
1295                     if (pixelAlpha &gt; XOR_ALPHA_CUTOFF)
1296                     {
1297                         *dstPixels = (*dstPixels ^ (srcPixel ^ colorXOR));
1298                     }
1299                     dstPixels++; srcPixels++;
1300                 }
1301 
1302                 dstPixels += skip;
1303                 srcPixels += skipPixels;
1304             }
1305 
1306             handled = JNI_TRUE;
1307             break;
1308         }
1309         default:
1310         {
1311             handled = JNI_FALSE;
1312 #if defined(PRINT_WARNINGS)
1313             fprintf(stderr, &quot;WARNING: unknown type (%d) in compositeXOR\n&quot;, dstIsdo-&gt;type);
1314             PrintImageInfo(dstIsdo);
1315 #endif
1316         }
1317     }
1318 
1319     UnlockImagePixels(env, srcIsdo);
1320     UnlockImagePixels(env, dstIsdo);
1321 
1322 JNF_COCOA_EXIT(env);
1323     return handled;
1324 }
1325 
1326 IMAGE_SURFACE_INLINE jboolean clearSurfacePixels(JNIEnv *env, jobject bisd, jint w, jint h)
1327 {
1328 PRINT(&quot;clearSurfacePixels&quot;)
1329     jboolean handled = JNI_FALSE;
1330 
1331 JNF_COCOA_ENTER(env);
1332 
1333     ImageSDOps *isdo = LockImagePixels(env, bisd);
1334 
1335     if (isdo-&gt;type == java_awt_image_BufferedImage_TYPE_INT_ARGB_PRE)
1336     {
1337         isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex] = 1;
1338 
1339         w = (w &lt; isdo-&gt;width) ? w : isdo-&gt;width;
1340         h = (h &lt; isdo-&gt;height) ? h : isdo-&gt;height;
1341 
1342         register Pixel32bit* data = (Pixel32bit*)isdo-&gt;pixels;
1343         register jint i;
1344         if ((w &lt; isdo-&gt;width) || (h &lt; isdo-&gt;height)) //cmcnote: necessary to special-case for small height? wouldn&#39;t 4*w*h do it?
1345         {
1346             register jint skip = isdo-&gt;width;
1347             register jint row = 4*w;
1348             for (i=0; i&lt;h; i++)
1349             {
1350                 bzero(data, row);
1351                 data += skip;
1352             }
1353         }
1354         else
1355         {
1356             bzero(data, 4*w*h);
1357         }
1358 
1359         handled = JNI_TRUE;
1360     }
1361     UnlockImagePixels(env, isdo);
1362 
1363 JNF_COCOA_EXIT(env);
1364 
1365     return handled;
1366 }
1367 
1368 static void ImageSD_startCGContext(JNIEnv *env, QuartzSDOps *qsdo, SDRenderType renderType)
1369 {
1370 PRINT(&quot;ImageSD_startCGContext&quot;)
1371 
1372     ImageSDOps *isdo = (ImageSDOps*)qsdo;
1373 
1374     pthread_mutex_lock(&amp;isdo-&gt;lock);
1375 
1376     if (isdo-&gt;imgRef != NULL)
1377     {
1378         CGImageRelease(isdo-&gt;imgRef);
1379         isdo-&gt;imgRef = NULL;
1380     }
1381 
1382     if (qsdo-&gt;cgRef == NULL)
1383     {
1384         createContext(env, isdo);
1385     }
1386     else
1387     {
1388         qsdo-&gt;newContext = NO;
1389     }
1390 
1391     if (qsdo-&gt;cgRef != NULL)
1392     {
1393         if (isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kImageStolenIndex] == 1)
1394         {
1395             isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex] = 1;
1396         }
1397 
1398         // sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex can be set right above or somewhere else
1399         if (isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex] == 1)
1400         {
1401             syncFromJavaPixels(env, isdo);
1402         }
1403 
1404         isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNativePixelsChangedIndex] = 1;
1405 
1406         SetUpCGContext(env, qsdo, renderType);
1407     }
1408 }
1409 static void ImageSD_finishCGContext(JNIEnv *env, QuartzSDOps *qsdo)
1410 {
1411 PRINT(&quot;ImageSD_finishCGContext&quot;)
1412 
1413     ImageSDOps *isdo = (ImageSDOps*)qsdo;
1414 
1415     if (qsdo-&gt;cgRef != NULL)
1416     {
1417         CompleteCGContext(env, qsdo);
1418 
1419         if (isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kImageStolenIndex] == 1)
1420         {
1421             syncToJavaPixels(env, isdo);
1422             isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex] = 1;
1423         }
1424     }
1425 
1426     pthread_mutex_unlock(&amp;isdo-&gt;lock);
1427 }
1428 
1429 static void ImageSD_dispose(JNIEnv *env, SurfaceDataOps *ops)
1430 {
1431 PRINT(&quot;ImageSD_dispose&quot;)
1432 
1433     // copied from BufImg_Dispose in BufImgSurfaceData.c
1434     {
1435         /* ops is assumed non-null as it is checked in SurfaceData_DisposeOps */
1436         BufImgSDOps *bisdo = (BufImgSDOps *)ops;
1437         (*env)-&gt;DeleteWeakGlobalRef(env, bisdo-&gt;array);
1438         if (bisdo-&gt;lutarray != NULL) {
1439         (*env)-&gt;DeleteWeakGlobalRef(env, bisdo-&gt;lutarray);
1440         }
1441         if (bisdo-&gt;icm != NULL) {
1442         (*env)-&gt;DeleteWeakGlobalRef(env, bisdo-&gt;icm);
1443         }
1444     }
1445 
1446     QuartzSDOps *qsdo = (QuartzSDOps *)ops;
1447 
1448     if (qsdo-&gt;graphicsStateInfo.batchedLines != NULL)
1449     {
1450         free(qsdo-&gt;graphicsStateInfo.batchedLines);
1451         qsdo-&gt;graphicsStateInfo.batchedLines = NULL;
1452     }
1453 
1454     JNFDeleteGlobalRef(env, qsdo-&gt;javaGraphicsStatesObjects);
1455 
1456     if (qsdo-&gt;cgRef != NULL)
1457     {
1458         CGContextRelease(qsdo-&gt;cgRef);
1459         qsdo-&gt;cgRef = NULL;
1460     }
1461 
1462     ImageSDOps *isdo = (ImageSDOps *)ops;
1463 
1464     if (isdo-&gt;dataProvider != NULL)
1465     {
1466         CGDataProviderRelease(isdo-&gt;dataProvider);
1467         isdo-&gt;dataProvider = NULL;
1468     }
1469     if (isdo-&gt;imgRef != NULL)
1470     {
1471         CGImageRelease(isdo-&gt;imgRef);
1472         isdo-&gt;imgRef = NULL;
1473     }
1474     if (isdo-&gt;indexedColorTable != NULL)
1475     {
1476         free(isdo-&gt;indexedColorTable);
1477         isdo-&gt;indexedColorTable = NULL;
1478     }
1479     if (isdo-&gt;lutData != NULL)
1480     {
1481         free(isdo-&gt;lutData);
1482         isdo-&gt;indexedColorTable = NULL;
1483     }
1484     if (isdo-&gt;array != NULL)
1485     {
1486         JNFDeleteGlobalRef(env, isdo-&gt;array);
1487         isdo-&gt;array = NULL;
1488     }
1489     if (isdo-&gt;icm != NULL)
1490     {
1491         JNFDeleteGlobalRef(env, isdo-&gt;icm);
1492         isdo-&gt;icm = NULL;
1493     }
1494 
1495     if (isdo-&gt;nsRef) {
1496         [isdo-&gt;nsRef release];
1497         isdo-&gt;nsRef = nil;
1498     }
1499 
1500     pthread_mutex_destroy(&amp;isdo-&gt;lock);
1501 }
1502 
1503 // used by XOR (Java pixels must be up to date)
1504 ImageSDOps* LockImagePixels(JNIEnv* env, jobject imageSurfaceData)
1505 {
1506 PRINT(&quot;LockImagePixels&quot;)
1507 
1508     ImageSDOps* isdo = (ImageSDOps*)SurfaceData_GetOps(env, imageSurfaceData);
1509 
1510     pthread_mutex_lock(&amp;isdo-&gt;lock);
1511 
1512     holdJavaPixels(env, isdo);
1513 
1514     // if we need to access this image&#39;s pixels we need to convert native pixels (if any) back to Java
1515     if (isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNativePixelsChangedIndex] == 1)
1516     {
1517         syncToJavaPixels(env, isdo);
1518         isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex] = 1;
1519     }
1520 
1521     return isdo;
1522 }
1523 void UnlockImagePixels(JNIEnv* env, ImageSDOps* isdo)
1524 {
1525 PRINT(&quot;UnlockImagePixels&quot;)
1526     // don&#39;t do that since the native pixels haven&#39;t changed (Java pixels == native pixels)
1527     //syncToJavaPixels(env, isdo);
1528 
1529     unholdJavaPixels(env, isdo);
1530 
1531     pthread_mutex_unlock(&amp;isdo-&gt;lock);
1532 }
1533 
1534 // used by drawImage (native pixels must be up to date)
1535 ImageSDOps* LockImage(JNIEnv* env, jobject imageSurfaceData)
1536 {
1537 PRINT(&quot;LockImage&quot;)
1538 
1539     ImageSDOps* isdo = (ImageSDOps*)SurfaceData_GetOps(env, imageSurfaceData);
1540 
1541     pthread_mutex_lock(&amp;isdo-&gt;lock);
1542 
1543     // if we need to access this image&#39;s pixels we need to convert native pixels (if any) back to Java
1544     // for those images whose context type doesn&#39;t match layer type or is a custom image
1545     if (isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kImageStolenIndex] == 1)
1546     {
1547         isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex] = 1;
1548     }
1549 
1550     // sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex can be set right above or somewhere else
1551     if (isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex] == 1)
1552     {
1553         syncFromJavaPixels(env, isdo);
1554     }
1555 
1556     return isdo;
1557 }
1558 void UnlockImage(JNIEnv* env, ImageSDOps* isdo)
1559 {
1560 PRINT(&quot;UnlockImage&quot;)
1561 
1562     // don&#39;t do that since the native pixels haven&#39;t changed (Java pixels == native pixels)
1563     //syncToJavaPixels(env, isdo);
1564 
1565     pthread_mutex_unlock(&amp;isdo-&gt;lock);
1566 }
1567 
1568 JNIEXPORT jobject JNICALL Java_sun_awt_image_BufImgSurfaceData_getSurfaceData
1569     (JNIEnv *env, jclass bisd, jobject bufImg)
1570 {
1571     static jfieldID sDataID = 0;
1572     if (sDataID == 0)
1573     {
1574         static char *bimgName = &quot;java/awt/image/BufferedImage&quot;;
1575         jclass bimg = (*env)-&gt;FindClass(env, bimgName);
1576         CHECK_NULL_RETURN(bimg, NULL);
1577         sDataID = (*env)-&gt;GetFieldID(env, bimg, &quot;sData&quot;, &quot;Lsun/java2d/SurfaceData;&quot;);
1578         CHECK_NULL_RETURN(sDataID, NULL);
1579     }
1580 
1581     return (*env)-&gt;GetObjectField(env, bufImg, sDataID);
1582 }
1583 
1584 JNIEXPORT void JNICALL Java_sun_awt_image_BufImgSurfaceData_setSurfaceData
1585     (JNIEnv *env, jclass bisd, jobject bufImg, jobject sData)
1586 {
1587     static jfieldID sDataID = 0;
1588     if (sDataID == 0)
1589     {
1590         static char *bimgName = &quot;java/awt/image/BufferedImage&quot;;
1591         jclass bimg = (*env)-&gt;FindClass(env, bimgName);
1592         CHECK_NULL(bimg);
1593         sDataID = (*env)-&gt;GetFieldID(env, bimg, &quot;sData&quot;, &quot;Lsun/java2d/SurfaceData;&quot;);
1594         CHECK_NULL(sDataID);
1595     }
1596 
1597     (*env)-&gt;SetObjectField(env, bufImg, sDataID, sData);
1598 }
1599 
1600 JNIEXPORT void JNICALL Java_sun_java2d_OSXOffScreenSurfaceData_initIDs(JNIEnv *env, jclass bisd)
1601 {
1602 //PRINT(&quot;initIDs&quot;)
1603     // copied from Java_sun_awt_image_BufImgSurfaceData_initIDs in BufImgSurfaceData.c
1604     {
1605         static char *icmName = &quot;java/awt/image/IndexColorModel&quot;;
1606         jclass icm;
1607 
1608         if (sizeof(BufImgRIPrivate) &gt; SD_RASINFO_PRIVATE_SIZE) {
1609         JNU_ThrowInternalError(env, &quot;Private RasInfo structure too large!&quot;);
1610         return;
1611         }
1612 
1613         CHECK_NULL(icm = (*env)-&gt;FindClass(env, icmName));
1614         CHECK_NULL(rgbID = (*env)-&gt;GetFieldID(env, icm, &quot;rgb&quot;, &quot;[I&quot;));
1615         CHECK_NULL(allGrayID = (*env)-&gt;GetFieldID(env, icm, &quot;allgrayopaque&quot;, &quot;Z&quot;));
1616         CHECK_NULL(mapSizeID = (*env)-&gt;GetFieldID(env, icm, &quot;map_size&quot;, &quot;I&quot;));
1617         CHECK_NULL(CMpDataID = (*env)-&gt;GetFieldID(env, icm, &quot;pData&quot;, &quot;J&quot;));
1618     }
1619 
1620     gColorspaceRGB = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
1621     gColorspaceGray = CGColorSpaceCreateWithName(kCGColorSpaceGenericGray);
1622 //fprintf(stderr, &quot;gColorspaceRGB=%p, gColorspaceGray=%p\n&quot;, gColorspaceRGB, gColorspaceGray);
1623 }
1624 
1625 JNIEXPORT jobject JNICALL Java_sun_java2d_OSXOffScreenSurfaceData_getSurfaceData
1626     (JNIEnv *env, jclass bisd, jobject bufImg)
1627 {
1628 PRINT(&quot;getSurfaceData&quot;)
1629 
1630     return JNFGetObjectField(env, bufImg, jm_SurfaceData);
1631 }
1632 
1633 JNIEXPORT void JNICALL Java_sun_java2d_OSXOffScreenSurfaceData_setSurfaceData
1634     (JNIEnv *env, jclass bisd, jobject bufImg, jobject sData)
1635 {
1636 PRINT(&quot;setSurfaceData&quot;)
1637 
1638     JNFSetObjectField(env, bufImg, jm_SurfaceData, sData);
1639 }
1640 
1641 static jint ImageSD_Lock(JNIEnv *env, SurfaceDataOps *ops, SurfaceDataRasInfo *pRasInfo, jint lockflags)
1642 {
1643     ImageSDOps *isdo = (ImageSDOps*)ops;
1644     pthread_mutex_lock(&amp;isdo-&gt;lock);
1645 
1646     // copied from BufImg_Lock in BufImgSurfaceData.c
1647     {
1648         BufImgSDOps *bisdo = (BufImgSDOps *)ops;
1649         BufImgRIPrivate *bipriv = (BufImgRIPrivate *) &amp;(pRasInfo-&gt;priv);
1650 
1651         if ((lockflags &amp; (SD_LOCK_LUT)) != 0 &amp;&amp; !bisdo-&gt;lutarray) {
1652             /* REMIND: Should this be an InvalidPipe exception? */
1653             JNU_ThrowNullPointerException(env, &quot;Attempt to lock missing colormap&quot;);
1654             return SD_FAILURE;
1655         }
1656 // TODO:BG
1657         /*
1658         if ((lockflags &amp; SD_LOCK_INVCOLOR) != 0 ||
1659             (lockflags &amp; SD_LOCK_INVGRAY) != 0)
1660         {
1661             bipriv-&gt;cData = BufImg_SetupICM(env, bisdo);
1662             if (bipriv-&gt;cData == NULL) {
1663                 JNU_ThrowNullPointerException(env, &quot;Could not initialize &quot;
1664                                               &quot;inverse tables&quot;);
1665                 return SD_FAILURE;
1666             }
1667         } else {
1668             bipriv-&gt;cData = NULL;
1669         }
1670         */
1671         bipriv-&gt;cData = NULL;
1672 
1673         bipriv-&gt;lockFlags = lockflags;
1674         bipriv-&gt;base = NULL;
1675         bipriv-&gt;lutbase = NULL;
1676 
1677         SurfaceData_IntersectBounds(&amp;pRasInfo-&gt;bounds, &amp;bisdo-&gt;rasbounds);
1678 
1679         /* TODO:BG
1680         if ((bipriv-&gt;lockFlags &amp; SD_LOCK_WRITE) &amp;&amp;
1681             bisdo-&gt;sdOps.dirty != TRUE) {
1682             SurfaceData_MarkDirty(env, &amp;bisdo-&gt;sdOps);
1683         } */
1684         return SD_SUCCESS;
1685     }
1686 }
1687 static void ImageSD_Unlock(JNIEnv *env, SurfaceDataOps *ops, SurfaceDataRasInfo *pRasInfo)
1688 {
1689     ImageSDOps *isdo = (ImageSDOps*)ops;
1690 
1691     // For every ImageSD_Unlock, we need to be conservative and mark the pixels
1692     // as modified by the Sun2D renderer.
1693     isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kNeedToSyncFromJavaPixelsIndex] = 1;
1694 
1695     pthread_mutex_unlock(&amp;isdo-&gt;lock);
1696 }
1697 static void ImageSD_GetRasInfo(JNIEnv *env, SurfaceDataOps *ops, SurfaceDataRasInfo *pRasInfo)
1698 {
1699     // copied from BufImg_GetRasInfo in BufImgSurfaceData.c
1700     {
1701         BufImgSDOps *bisdo = (BufImgSDOps *)ops;
1702         BufImgRIPrivate *bipriv = (BufImgRIPrivate *) &amp;(pRasInfo-&gt;priv);
1703 
1704         if ((bipriv-&gt;lockFlags &amp; (SD_LOCK_RD_WR)) != 0) {
1705             bipriv-&gt;base =
1706                 (*env)-&gt;GetPrimitiveArrayCritical(env, bisdo-&gt;array, NULL);
1707         }
1708         if ((bipriv-&gt;lockFlags &amp; (SD_LOCK_LUT)) != 0) {
1709             bipriv-&gt;lutbase =
1710                 (*env)-&gt;GetPrimitiveArrayCritical(env, bisdo-&gt;lutarray, NULL);
1711         }
1712 
1713         if (bipriv-&gt;base == NULL) {
1714             pRasInfo-&gt;rasBase = NULL;
1715             pRasInfo-&gt;pixelStride = 0;
1716             pRasInfo-&gt;scanStride = 0;
1717         } else {
1718             pRasInfo-&gt;rasBase = (void *)
1719                 (((uintptr_t) bipriv-&gt;base) + bisdo-&gt;offset);
1720             pRasInfo-&gt;pixelStride = bisdo-&gt;pixStr;
1721             pRasInfo-&gt;scanStride = bisdo-&gt;scanStr;
1722         }
1723         if (bipriv-&gt;lutbase == NULL) {
1724             pRasInfo-&gt;lutBase = NULL;
1725             pRasInfo-&gt;lutSize = 0;
1726         } else {
1727             pRasInfo-&gt;lutBase = bipriv-&gt;lutbase;
1728             pRasInfo-&gt;lutSize = bisdo-&gt;lutsize;
1729         }
1730         if (bipriv-&gt;cData == NULL) {
1731             pRasInfo-&gt;invColorTable = NULL;
1732             pRasInfo-&gt;redErrTable = NULL;
1733             pRasInfo-&gt;grnErrTable = NULL;
1734             pRasInfo-&gt;bluErrTable = NULL;
1735         } else {
1736             pRasInfo-&gt;invColorTable = bipriv-&gt;cData-&gt;img_clr_tbl;
1737             pRasInfo-&gt;redErrTable = bipriv-&gt;cData-&gt;img_oda_red;
1738             pRasInfo-&gt;grnErrTable = bipriv-&gt;cData-&gt;img_oda_green;
1739             pRasInfo-&gt;bluErrTable = bipriv-&gt;cData-&gt;img_oda_blue;
1740             pRasInfo-&gt;invGrayTable = bipriv-&gt;cData-&gt;pGrayInverseLutData;
1741         }
1742     }
1743 }
1744 static void ImageSD_Release(JNIEnv *env, SurfaceDataOps *ops, SurfaceDataRasInfo *pRasInfo)
1745 {
1746     // copied from BufImg_Release in BufImgSurfaceData.c
1747     {
1748         BufImgSDOps *bisdo = (BufImgSDOps *)ops;
1749         BufImgRIPrivate *bipriv = (BufImgRIPrivate *) &amp;(pRasInfo-&gt;priv);
1750 
1751         if (bipriv-&gt;base != NULL) {
1752             jint mode = (((bipriv-&gt;lockFlags &amp; (SD_LOCK_WRITE)) != 0)
1753                          ? 0 : JNI_ABORT);
1754             (*env)-&gt;ReleasePrimitiveArrayCritical(env, bisdo-&gt;array,
1755                                                   bipriv-&gt;base, mode);
1756         }
1757         if (bipriv-&gt;lutbase != NULL) {
1758             (*env)-&gt;ReleasePrimitiveArrayCritical(env, bisdo-&gt;lutarray,
1759                                                   bipriv-&gt;lutbase, JNI_ABORT);
1760         }
1761     }
1762 }
1763 
1764 JNIEXPORT void JNICALL Java_sun_java2d_OSXOffScreenSurfaceData_initRaster(JNIEnv *env, jobject bisd, jobject array, jint offset, jint width, jint height,
1765                                                                                 jint pixelStride, jint scanStride, jobject icm, jint type,
1766                                                                                     jobject jGraphicsState, jobjectArray jGraphicsStateObject, jobject jImageInfo)
1767 {
1768 PRINT(&quot;Java_sun_java2d_OSXOffScreenSurfaceData_initRaster&quot;)
1769 
1770     ImageSDOps* isdo = (ImageSDOps*)SurfaceData_InitOps(env, bisd, sizeof(ImageSDOps));
1771     if (isdo == NULL) {
1772         JNU_ThrowOutOfMemoryError(env, &quot;Initialization of SurfaceData failed.&quot;);
1773         return;
1774     }
1775 
1776     pthread_mutexattr_t attr;
1777     pthread_mutexattr_init(&amp;attr);
1778     pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
1779     pthread_mutex_init(&amp;isdo-&gt;lock, &amp;attr);
1780     pthread_mutex_lock(&amp;isdo-&gt;lock);
1781     pthread_mutexattr_destroy(&amp;attr);
1782 
1783     // copied (and modified) from Java_sun_awt_image_BufImgSurfaceData_initRaster in BufImgSurfaceData.c
1784     {
1785         BufImgSDOps *bisdo =
1786         //(BufImgSDOps*)SurfaceData_InitOps(env, bisd, sizeof(BufImgSDOps));
1787         (BufImgSDOps*)isdo;
1788         //bisdo-&gt;sdOps.Lock = BufImg_Lock;
1789         //bisdo-&gt;sdOps.GetRasInfo = BufImg_GetRasInfo;
1790         //bisdo-&gt;sdOps.Release = BufImg_Release;
1791         //bisdo-&gt;sdOps.Unlock = NULL;
1792         //bisdo-&gt;sdOps.Dispose = BufImg_Dispose;
1793 
1794         bisdo-&gt;array = (*env)-&gt;NewWeakGlobalRef(env, array);
1795         if (array != NULL) CHECK_NULL(bisdo-&gt;array);
1796         bisdo-&gt;offset = offset;
1797         //bisdo-&gt;scanStr = scanStr;
1798         bisdo-&gt;scanStr = scanStride;
1799         //bisdo-&gt;pixStr = pixStr;
1800         bisdo-&gt;pixStr = pixelStride;
1801         if (!icm) {
1802             bisdo-&gt;lutarray = NULL;
1803             bisdo-&gt;lutsize = 0;
1804             bisdo-&gt;icm = NULL;
1805         } else {
1806             jobject lutarray = (*env)-&gt;GetObjectField(env, icm, rgbID);
1807             bisdo-&gt;lutarray = (*env)-&gt;NewWeakGlobalRef(env, lutarray);
1808             if (lutarray != NULL) CHECK_NULL(bisdo-&gt;lutarray);
1809             bisdo-&gt;lutsize = (*env)-&gt;GetIntField(env, icm, mapSizeID);
1810             bisdo-&gt;icm = (*env)-&gt;NewWeakGlobalRef(env, icm);
1811             if (icm != NULL) CHECK_NULL(bisdo-&gt;icm);
1812         }
1813         bisdo-&gt;rasbounds.x1 = 0;
1814         bisdo-&gt;rasbounds.y1 = 0;
1815         bisdo-&gt;rasbounds.x2 = width;
1816         bisdo-&gt;rasbounds.y2 = height;
1817     }
1818 
1819     isdo-&gt;nrOfPixelsOwners = 0;
1820 
1821     isdo-&gt;contextInfo                    = sDefaultContextInfo[type];
1822     isdo-&gt;imageInfo                        = sDefaultImageInfo[type];
1823 
1824     isdo-&gt;contextInfo.bytesPerRow        = width*isdo-&gt;contextInfo.bytesPerPixel;
1825     isdo-&gt;imageInfo.bytesPerRow            = width*isdo-&gt;imageInfo.bytesPerPixel;
1826 
1827     switch (type)
1828     {
1829         case java_awt_image_BufferedImage_TYPE_BYTE_GRAY:
1830             isdo-&gt;contextInfo.colorSpace = isdo-&gt;imageInfo.colorSpace = gColorspaceGray;
1831             break;
1832         case java_awt_image_BufferedImage_TYPE_USHORT_GRAY:
1833             isdo-&gt;contextInfo.colorSpace = gColorspaceRGB;
1834             isdo-&gt;imageInfo.colorSpace = gColorspaceGray;
1835             break;
1836         default:
1837             isdo-&gt;contextInfo.colorSpace = isdo-&gt;imageInfo.colorSpace = gColorspaceRGB;
1838             break;
1839     }
1840     isdo-&gt;isSubImage                    = (offset%scanStride != 0) || (scanStride != (pixelStride*width));
1841 
1842     // parameters specifying this image given to us from Java
1843     isdo-&gt;javaImageInfo                    = (jint*)((*env)-&gt;GetDirectBufferAddress(env, jImageInfo));
1844     isdo-&gt;array                            = (array != NULL) ? JNFNewGlobalRef(env, array) : NULL;
1845     isdo-&gt;offset                        = offset;
1846     isdo-&gt;width                            = width;
1847     isdo-&gt;height                        = height;
1848     isdo-&gt;javaPixelBytes                = pixelStride;
1849     isdo-&gt;javaPixelsBytesPerRow            = scanStride;
1850     isdo-&gt;icm                            = (icm != NULL) ? JNFNewGlobalRef(env, icm) : NULL;
1851     isdo-&gt;type                            = type;
1852 
1853     if ((isdo-&gt;javaImageInfo[sun_java2d_OSXOffScreenSurfaceData_kImageStolenIndex] == 1) ||
1854         (isdo-&gt;type == java_awt_image_BufferedImage_TYPE_CUSTOM))
1855     {
1856         // don&#39;t waste (precious, precious) VRAM on stolen or custom images that will be slow no matter what
1857         isdo-&gt;contextInfo.useWindowContextReference = NO;
1858     }
1859 
1860     // needed by TYPE_BYTE_INDEXED
1861     isdo-&gt;indexedColorTable                = NULL;
1862     isdo-&gt;lutData                        = NULL;
1863     isdo-&gt;lutDataSize                    = 0;
1864     if ((type == java_awt_image_BufferedImage_TYPE_BYTE_INDEXED) &amp;&amp; ((*env)-&gt;IsSameObject(env, icm, NULL) == NO))
1865     {
1866         jarray lutarray = JNFGetObjectField(env, icm, jm_rgb);
1867         isdo-&gt;lutDataSize = (*env)-&gt;GetArrayLength(env, lutarray);
1868         if (isdo-&gt;lutDataSize &gt; 0)
1869         {
1870             jint transparency = JNFGetIntField(env, icm, jm_transparency);
1871             jint transparent_index = -1;
1872             if (transparency == java_awt_Transparency_BITMASK)
1873             {
1874                 transparent_index = JNFGetIntField(env, icm, jm_transparent_index);
1875             }
1876 
1877             Pixel32bit* lutdata = (Pixel32bit*)((*env)-&gt;GetPrimitiveArrayCritical(env, lutarray, NULL));
1878             if (lutdata != NULL)
1879             {
1880                 isdo-&gt;lutData = NULL;
1881 
1882                 isdo-&gt;lutData = malloc(isdo-&gt;lutDataSize * sizeof(Pixel32bit));
1883                 if (isdo-&gt;lutData != NULL)
1884                 {
1885                     if (transparency == java_awt_Transparency_BITMASK)
1886                     {
1887                         Pixel32bit* src = lutdata;
1888                         Pixel32bit* dst = isdo-&gt;lutData;
1889                         jint i;
1890                         for (i=0; (unsigned)i&lt;isdo-&gt;lutDataSize; i++)
1891                         {
1892                             if (i != transparent_index)
1893                             {
1894                                 *dst = *src;
1895                                 // rdar://problem/3390518 - don&#39;t force all indexed colors
1896                                 // to be fully opaque. They could be set up for us.
1897                                 // we used to call:  *dst = 0xff000000 | *src;
1898                                 // but that was forcing colors to be opaque when developers
1899                                 // could have set the alpha.
1900                             }
1901                             else
1902                             {
1903                                 *dst = 0x00000000; // mark as translucent color
1904                             }
1905                             dst++; src++;
1906                         }
1907                     }
1908                     else //if ((transparency == java_awt_Transparency_OPAQUE) || (transparency == java_awt_Transparency_TRANSLUCENT))
1909                     {
1910                         jint mask = 0x00000000;
1911                         // &lt;rdar://4224874&gt; If the color model is OPAQUE than we need to create an opaque image for performance purposes.
1912                         // the default alphaInfo for INDEXED images is kCGImageAlphaFirst. Therefore we need to special case this.
1913                         if ((transparency == java_awt_Transparency_OPAQUE))
1914                         {
1915                             isdo-&gt;imageInfo.alphaInfo = kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host;
1916                             mask = 0xff000000; // this is just a safeguard to make sure we fill the alpha
1917                         }
1918 
1919                         Pixel32bit* src = lutdata;
1920                         Pixel32bit* dst = isdo-&gt;lutData;
1921                         jint i;
1922                         for (i=0; (unsigned)i&lt;isdo-&gt;lutDataSize; i++)
1923                         {
1924                             *dst = *src | mask;
1925                             dst++; src++;
1926                         }
1927                     }
1928 
1929                     (*env)-&gt;ReleasePrimitiveArrayCritical(env, lutarray, lutdata, 0);
1930                 }
1931                 else
1932                 {
1933                     fprintf(stderr, &quot;ERROR: malloc returns NULL for isdo-&gt;lutData in initRaster!\n&quot;);
1934                 }
1935             }
1936             else
1937             {
1938                 fprintf(stderr, &quot;ERROR: GetPrimitiveArrayCritical returns NULL for lutdata in initRaster!\n&quot;);
1939             }
1940         }
1941         (*env)-&gt;DeleteLocalRef(env, lutarray);
1942     }
1943 
1944     QuartzSDOps *qsdo = (QuartzSDOps*)isdo;
1945     qsdo-&gt;BeginSurface                    = ImageSD_startCGContext;
1946     qsdo-&gt;FinishSurface                    = ImageSD_finishCGContext;
1947 
1948     qsdo-&gt;javaGraphicsStates            = (jint*)((*env)-&gt;GetDirectBufferAddress(env, jGraphicsState));
1949     qsdo-&gt;javaGraphicsStatesObjects        = JNFNewGlobalRef(env, jGraphicsStateObject);
1950 
1951     qsdo-&gt;graphicsStateInfo.batchedLines = NULL;
1952     qsdo-&gt;graphicsStateInfo.batchedLinesCount = 0;
1953 
1954     SurfaceDataOps *sdo = (SurfaceDataOps*)qsdo;
1955     sdo-&gt;Lock        = ImageSD_Lock;
1956     sdo-&gt;Unlock        = ImageSD_Unlock;
1957     sdo-&gt;GetRasInfo    = ImageSD_GetRasInfo;
1958     sdo-&gt;Release    = ImageSD_Release;
1959     sdo-&gt;Setup        = NULL;
1960     sdo-&gt;Dispose    = ImageSD_dispose;
1961 
1962     pthread_mutex_unlock(&amp;isdo-&gt;lock);
1963 
1964 //PrintImageInfo(isdo);
1965 }
1966 
1967 JNIEXPORT void JNICALL Java_sun_java2d_OSXOffScreenSurfaceData_initCustomRaster(JNIEnv* env, jobject bisd, jobject array, jint width, jint height,
1968                                                                                     jobject jGraphicsState, jobject jGraphicsStateObject, jobject jImageInfo)
1969 {
1970 PRINT(&quot;Java_sun_java2d_OSXOffScreenSurfaceData_initCustomRaster&quot;)
1971     jint offset = 0;
1972     jint pixelStride = 4;
1973     jint scanStride = pixelStride*width;
1974     jobject icm = NULL;
1975     jint type = java_awt_image_BufferedImage_TYPE_CUSTOM;
1976 
1977     Java_sun_java2d_OSXOffScreenSurfaceData_initRaster(env, bisd, array, offset, width, height, pixelStride, scanStride, icm, type, jGraphicsState, jGraphicsStateObject, jImageInfo);
1978 }
1979 
1980 JNIEXPORT void JNICALL Java_sun_java2d_OSXOffScreenSurfaceData_syncToJavaPixels(JNIEnv *env, jobject bisd)
1981 {
1982 PRINT(&quot;Java_sun_java2d_OSXOffScreenSurfaceData_syncToJavaPixels&quot;)
1983 
1984     syncToJavaPixels(env, (ImageSDOps*)SurfaceData_GetOps(env, bisd));
1985 }
1986 
1987 JNIEXPORT jboolean JNICALL Java_sun_java2d_OSXOffScreenSurfaceData_xorSurfacePixels
1988   (JNIEnv *env, jobject dstIsd, jobject srcIsd, jint colorXOR, jint x, jint y, jint w, jint h)
1989 {
1990 PRINT(&quot;Java_sun_java2d_OSXOffScreenSurfaceData_xorSurfacePixels&quot;)
1991     return xorSurfacePixels(env, dstIsd, srcIsd, colorXOR, x, y, w, h);
1992 }
1993 
1994 JNIEXPORT jboolean JNICALL Java_sun_java2d_OSXOffScreenSurfaceData_clearSurfacePixels
1995   (JNIEnv *env, jobject bisd, jint w, jint h)
1996 {
1997 PRINT(&quot;Java_sun_java2d_OSXOffScreenSurfaceData_clearSurfacePixels&quot;)
1998     return clearSurfacePixels(env, bisd, w, h);
1999 
2000 }
    </pre>
  </body>
</html>
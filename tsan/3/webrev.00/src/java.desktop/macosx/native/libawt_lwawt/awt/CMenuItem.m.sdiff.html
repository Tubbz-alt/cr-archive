<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/awt/CMenuItem.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="CMenu.m.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="CRobot.m.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/awt/CMenuItem.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 53             [fMenuItem setTarget:self];
 54         }
 55         fIsCheckbox = NO;
 56         fIsEnabled = YES;
 57     }
 58     return self;
 59 }
 60 
 61 // This is because NSApplication doesn&#39;t check the target&#39;s window when sending
 62 // actions; they only check the target itself.  We always return YES,
 63 // since we shouldn&#39;t even be installed unless our window is active.
 64 - (BOOL) worksWhenModal {
 65     return YES;
 66 }
 67 
 68 // Events
 69 - (void)handleAction:(NSMenuItem *)sender {
 70     AWT_ASSERT_APPKIT_THREAD;
 71     JNIEnv *env = [ThreadUtilities getJNIEnv];
 72     JNF_COCOA_ENTER(env);
<span class="line-modified"> 73     </span>
 74     // If we are called as a result of user pressing a shortcut, do nothing,
 75     // because AVTView has already sent corresponding key event to the Java
 76     // layer from performKeyEquivalent.
 77     // There is an exception from the rule above, though: if a window with
 78     // a menu gets minimized by user and there are no other windows to take
 79     // focus, the window&#39;s menu won&#39;t be removed from the global menu bar.
 80     // However, the Java layer won&#39;t handle invocation by a shortcut coming
 81     // from this &quot;frameless&quot; menu, because there are no active windows. This
 82     // means we have to handle it here.
 83     NSEvent *currEvent = [[NSApplication sharedApplication] currentEvent];










 84     if (fIsCheckbox) {
 85         static JNF_CLASS_CACHE(jc_CCheckboxMenuItem, &quot;sun/lwawt/macosx/CCheckboxMenuItem&quot;);
 86         static JNF_MEMBER_CACHE(jm_ckHandleAction, jc_CCheckboxMenuItem, &quot;handleAction&quot;, &quot;(Z)V&quot;);
<span class="line-modified"> 87         </span>
 88         // Send the opposite of what&#39;s currently checked -- the action
 89         // indicates what state we&#39;re going to.
 90         NSInteger state = [sender state];
 91         jboolean newState = (state == NSOnState ? JNI_FALSE : JNI_TRUE);
 92         JNFCallVoidMethod(env, fPeer, jm_ckHandleAction, newState);
<span class="line-modified"> 93     }</span>
<span class="line-removed"> 94     else {</span>
<span class="line-removed"> 95         if ([currEvent type] == NSKeyDown) {</span>
<span class="line-removed"> 96             // Event available through sender variable hence NSApplication</span>
<span class="line-removed"> 97             // not needed for checking the keyboard input sans the modifier keys</span>
<span class="line-removed"> 98             // Also, the method used to fetch eventKey earlier would be locale dependent</span>
<span class="line-removed"> 99             // With earlier implementation, if MenuKey: e EventKey: à¤¾ ; if input method</span>
<span class="line-removed">100             // is not U.S. (Devanagari in this case)</span>
<span class="line-removed">101             // With current implementation, EventKey = MenuKey = e irrespective of</span>
<span class="line-removed">102             // input method</span>
<span class="line-removed">103             NSString *eventKey = [sender keyEquivalent];</span>
<span class="line-removed">104             // Apple uses characters from private Unicode range for some of the</span>
<span class="line-removed">105             // keys, so we need to do the same translation here that we do</span>
<span class="line-removed">106             // for the regular key down events</span>
<span class="line-removed">107             if ([eventKey length] == 1) {</span>
<span class="line-removed">108                 unichar origChar = [eventKey characterAtIndex:0];</span>
<span class="line-removed">109                 unichar newChar =  NsCharToJavaChar(origChar, 0);</span>
<span class="line-removed">110                 if (newChar == java_awt_event_KeyEvent_CHAR_UNDEFINED) {</span>
<span class="line-removed">111                     newChar = origChar;</span>
<span class="line-removed">112                 }</span>
<span class="line-removed">113                 eventKey = [NSString stringWithCharacters: &amp;newChar length: 1];</span>
<span class="line-removed">114             }</span>
<span class="line-removed">115             // The action event can be ignored only if the key window is an AWT window.</span>
<span class="line-removed">116             // Otherwise, the action event is the only notification and must be processed.</span>
<span class="line-removed">117             NSWindow *keyWindow = [NSApp keyWindow];</span>
<span class="line-removed">118             if (keyWindow != nil &amp;&amp; [AWTWindow isAWTWindow: keyWindow]) {</span>
<span class="line-removed">119                 return;</span>
<span class="line-removed">120             }</span>
<span class="line-removed">121         }</span>
<span class="line-removed">122         </span>
123         static JNF_CLASS_CACHE(jc_CMenuItem, &quot;sun/lwawt/macosx/CMenuItem&quot;);
124         static JNF_MEMBER_CACHE(jm_handleAction, jc_CMenuItem, &quot;handleAction&quot;, &quot;(JI)V&quot;); // AWT_THREADING Safe (event)
125 
126         NSUInteger modifiers = [currEvent modifierFlags];
127         jint javaModifiers = NsKeyModifiersToJavaModifiers(modifiers, NO);
128 
129         JNFCallVoidMethod(env, fPeer, jm_handleAction, UTC(currEvent), javaModifiers); // AWT_THREADING Safe (event)
130     }
131     JNF_COCOA_EXIT(env);
<span class="line-removed">132     </span>
133 }
134 
135 - (void) setJavaLabel:(NSString *)theLabel shortcut:(NSString *)theKeyEquivalent modifierMask:(jint)modifiers {
136     
137     NSUInteger modifierMask = 0;
138     
139     if (![theKeyEquivalent isEqualToString:@&quot;&quot;]) {
140         // Force the key equivalent to lower case if not using the shift key.
141         // Otherwise AppKit will draw a Shift glyph in the menu.
142         if ((modifiers &amp; java_awt_event_KeyEvent_SHIFT_MASK) == 0) {
143             theKeyEquivalent = [theKeyEquivalent lowercaseString];
144         }
145         
146         // Hack for the question mark -- SHIFT and / means use the question mark.
147         if ((modifiers &amp; java_awt_event_KeyEvent_SHIFT_MASK) != 0 &amp;&amp;
148             [theKeyEquivalent isEqualToString:@&quot;/&quot;])
149         {
150             theKeyEquivalent = @&quot;?&quot;;
151             modifiers &amp;= ~java_awt_event_KeyEvent_SHIFT_MASK;
152         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 53             [fMenuItem setTarget:self];
 54         }
 55         fIsCheckbox = NO;
 56         fIsEnabled = YES;
 57     }
 58     return self;
 59 }
 60 
 61 // This is because NSApplication doesn&#39;t check the target&#39;s window when sending
 62 // actions; they only check the target itself.  We always return YES,
 63 // since we shouldn&#39;t even be installed unless our window is active.
 64 - (BOOL) worksWhenModal {
 65     return YES;
 66 }
 67 
 68 // Events
 69 - (void)handleAction:(NSMenuItem *)sender {
 70     AWT_ASSERT_APPKIT_THREAD;
 71     JNIEnv *env = [ThreadUtilities getJNIEnv];
 72     JNF_COCOA_ENTER(env);
<span class="line-modified"> 73 </span>
 74     // If we are called as a result of user pressing a shortcut, do nothing,
 75     // because AVTView has already sent corresponding key event to the Java
 76     // layer from performKeyEquivalent.
 77     // There is an exception from the rule above, though: if a window with
 78     // a menu gets minimized by user and there are no other windows to take
 79     // focus, the window&#39;s menu won&#39;t be removed from the global menu bar.
 80     // However, the Java layer won&#39;t handle invocation by a shortcut coming
 81     // from this &quot;frameless&quot; menu, because there are no active windows. This
 82     // means we have to handle it here.
 83     NSEvent *currEvent = [[NSApplication sharedApplication] currentEvent];
<span class="line-added"> 84 </span>
<span class="line-added"> 85     if ([currEvent type] == NSKeyDown) {</span>
<span class="line-added"> 86         // The action event can be ignored only if the key window is an AWT window.</span>
<span class="line-added"> 87         // Otherwise, the action event is the only notification and must be processed.</span>
<span class="line-added"> 88         NSWindow *keyWindow = [NSApp keyWindow];</span>
<span class="line-added"> 89         if (keyWindow != nil &amp;&amp; [AWTWindow isAWTWindow: keyWindow]) {</span>
<span class="line-added"> 90             return;</span>
<span class="line-added"> 91         }</span>
<span class="line-added"> 92     }</span>
<span class="line-added"> 93 </span>
 94     if (fIsCheckbox) {
 95         static JNF_CLASS_CACHE(jc_CCheckboxMenuItem, &quot;sun/lwawt/macosx/CCheckboxMenuItem&quot;);
 96         static JNF_MEMBER_CACHE(jm_ckHandleAction, jc_CCheckboxMenuItem, &quot;handleAction&quot;, &quot;(Z)V&quot;);
<span class="line-modified"> 97 </span>
 98         // Send the opposite of what&#39;s currently checked -- the action
 99         // indicates what state we&#39;re going to.
100         NSInteger state = [sender state];
101         jboolean newState = (state == NSOnState ? JNI_FALSE : JNI_TRUE);
102         JNFCallVoidMethod(env, fPeer, jm_ckHandleAction, newState);
<span class="line-modified">103     } else {</span>





























104         static JNF_CLASS_CACHE(jc_CMenuItem, &quot;sun/lwawt/macosx/CMenuItem&quot;);
105         static JNF_MEMBER_CACHE(jm_handleAction, jc_CMenuItem, &quot;handleAction&quot;, &quot;(JI)V&quot;); // AWT_THREADING Safe (event)
106 
107         NSUInteger modifiers = [currEvent modifierFlags];
108         jint javaModifiers = NsKeyModifiersToJavaModifiers(modifiers, NO);
109 
110         JNFCallVoidMethod(env, fPeer, jm_handleAction, UTC(currEvent), javaModifiers); // AWT_THREADING Safe (event)
111     }
112     JNF_COCOA_EXIT(env);

113 }
114 
115 - (void) setJavaLabel:(NSString *)theLabel shortcut:(NSString *)theKeyEquivalent modifierMask:(jint)modifiers {
116     
117     NSUInteger modifierMask = 0;
118     
119     if (![theKeyEquivalent isEqualToString:@&quot;&quot;]) {
120         // Force the key equivalent to lower case if not using the shift key.
121         // Otherwise AppKit will draw a Shift glyph in the menu.
122         if ((modifiers &amp; java_awt_event_KeyEvent_SHIFT_MASK) == 0) {
123             theKeyEquivalent = [theKeyEquivalent lowercaseString];
124         }
125         
126         // Hack for the question mark -- SHIFT and / means use the question mark.
127         if ((modifiers &amp; java_awt_event_KeyEvent_SHIFT_MASK) != 0 &amp;&amp;
128             [theKeyEquivalent isEqualToString:@&quot;/&quot;])
129         {
130             theKeyEquivalent = @&quot;?&quot;;
131             modifiers &amp;= ~java_awt_event_KeyEvent_SHIFT_MASK;
132         }
</pre>
</td>
</tr>
</table>
<center><a href="CMenu.m.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="CRobot.m.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
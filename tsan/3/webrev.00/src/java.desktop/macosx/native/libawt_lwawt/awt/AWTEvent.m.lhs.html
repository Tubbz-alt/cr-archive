<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/awt/AWTEvent.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #import &quot;java_awt_event_InputEvent.h&quot;
 27 #import &quot;java_awt_event_KeyEvent.h&quot;
 28 #import &quot;LWCToolkit.h&quot;
 29 
 30 #import &quot;jni_util.h&quot;
 31 
 32 #import &lt;JavaNativeFoundation/JavaNativeFoundation.h&gt;
 33 #import &lt;sys/time.h&gt;
 34 #import &lt;Carbon/Carbon.h&gt;
 35 
 36 /*
 37  * Table to map typed characters to their Java virtual key equivalent and back.
 38  * We use the incoming unichar (ignoring all modifiers) and try to figure out
 39  * which virtual key code is appropriate. A lot of them just have direct
 40  * mappings (the function keys, arrow keys, etc.) so they aren&#39;t a problem.
 41  * We had to do something a little funky to catch the keys on the numeric
 42  * key pad (i.e. using event mask to distinguish between period on regular
 43  * keyboard and decimal on keypad). We also have to do something incredibly
 44  * hokey with regards to the shifted punctuation characters. For examples,
 45  * consider &#39;&amp;&#39; which is usually Shift-7.  For the Java key typed events,
 46  * that&#39;s no problem, we just say pass the unichar. But for the
 47  * KeyPressed/Released events, we need to identify the virtual key code
 48  * (which roughly correspond to hardware keys) which means we are supposed
 49  * to say the virtual 7 key was pressed.  But how are we supposed to know
 50  * when we get a punctuation char what was the real hardware key was that
 51  * was pressed?  Although &#39;&amp;&#39; often comes from Shift-7 the keyboard can be
 52  * remapped!  I don&#39;t think there really is a good answer, and hopefully
 53  * all good applets are only interested in logical key typed events not
 54  * press/release.  Meanwhile, we are hard-coding the shifted punctuation
 55  * to trigger the virtual keys that are the expected ones under a standard
 56  * keymapping. Looking at Windows &amp; Mac, they don&#39;t actually do this, the
 57  * Mac seems to just put the ascii code in for the shifted punctuation
 58  * (which means they actually end up with bogus key codes on the Java side),
 59  * Windows I can&#39;t even figure out what it&#39;s doing.
 60  */
 61 #define KL_STANDARD java_awt_event_KeyEvent_KEY_LOCATION_STANDARD
 62 #define KL_NUMPAD   java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD
 63 #define KL_UNKNOWN  java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN
 64 static struct _key
 65 {
 66     unsigned short keyCode;
 67     BOOL postsTyped;
 68     jint javaKeyLocation;
 69     jint javaKeyCode;
 70 }
 71 const keyTable[] =
 72 {
 73     {0x00, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_A},
 74     {0x01, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_S},
 75     {0x02, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_D},
 76     {0x03, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_F},
 77     {0x04, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_H},
 78     {0x05, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_G},
 79     {0x06, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_Z},
 80     {0x07, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_X},
 81     {0x08, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_C},
 82     {0x09, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_V},
 83     {0x0A, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_BACK_QUOTE},
 84     {0x0B, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_B},
 85     {0x0C, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_Q},
 86     {0x0D, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_W},
 87     {0x0E, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_E},
 88     {0x0F, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_R},
 89     {0x10, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_Y},
 90     {0x11, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_T},
 91     {0x12, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_1},
 92     {0x13, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_2},
 93     {0x14, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_3},
 94     {0x15, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_4},
 95     {0x16, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_6},
 96     {0x17, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_5},
 97     {0x18, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_EQUALS},
 98     {0x19, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_9},
 99     {0x1A, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_7},
100     {0x1B, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_MINUS},
101     {0x1C, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_8},
102     {0x1D, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_0},
103     {0x1E, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_CLOSE_BRACKET},
104     {0x1F, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_O},
105     {0x20, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_U},
106     {0x21, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_OPEN_BRACKET},
107     {0x22, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_I},
108     {0x23, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_P},
109     {0x24, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_ENTER},
110     {0x25, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_L},
111     {0x26, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_J},
112     {0x27, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_QUOTE},
113     {0x28, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_K},
114     {0x29, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_SEMICOLON},
115     {0x2A, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_BACK_SLASH},
116     {0x2B, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_COMMA},
117     {0x2C, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_SLASH},
118     {0x2D, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_N},
119     {0x2E, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_M},
120     {0x2F, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_PERIOD},
121     {0x30, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_TAB},
122     {0x31, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_SPACE},
123     {0x32, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_BACK_QUOTE},
124     {0x33, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_BACK_SPACE},
125     {0x34, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_ENTER},
126     {0x35, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_ESCAPE},
127     {0x36, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
128     {0x37, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_META},      // ****
129     {0x38, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_SHIFT},     // ****
130     {0x39, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_CAPS_LOCK},
131     {0x3A, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_ALT},       // ****
132     {0x3B, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_CONTROL},   // ****
133     {0x3C, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
134     {0x3D, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_ALT_GRAPH},
135     {0x3E, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
136     {0x3F, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED}, // the &#39;fn&#39; key on PowerBooks
137     {0x40, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F17},
138     {0x41, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_DECIMAL},
139     {0x42, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
140     {0x43, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_MULTIPLY},
141     {0x44, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
142     {0x45, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_ADD},
143     {0x46, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
144     {0x47, NO,  KL_NUMPAD,   java_awt_event_KeyEvent_VK_CLEAR},
145     {0x48, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
146     {0x49, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
147     {0x4A, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
148     {0x4B, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_DIVIDE},
149     {0x4C, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_ENTER},
150     {0x4D, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
151     {0x4E, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_SUBTRACT},
152     {0x4F, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F18},
153     {0x50, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F19},
154     {0x51, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_EQUALS},
155     {0x52, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_NUMPAD0},
156     {0x53, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_NUMPAD1},
157     {0x54, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_NUMPAD2},
158     {0x55, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_NUMPAD3},
159     {0x56, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_NUMPAD4},
160     {0x57, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_NUMPAD5},
161     {0x58, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_NUMPAD6},
162     {0x59, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_NUMPAD7},
163     {0x5A, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F20},
164     {0x5B, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_NUMPAD8},
165     {0x5C, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_NUMPAD9},
166     {0x5D, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_BACK_SLASH}, // This is a combo yen/backslash on JIS keyboards.
167     {0x5E, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_UNDERSCORE},
168     {0x5F, YES, KL_NUMPAD,   java_awt_event_KeyEvent_VK_COMMA},
169     {0x60, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F5},
170     {0x61, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F6},
171     {0x62, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F7},
172     {0x63, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F3},
173     {0x64, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F8},
174     {0x65, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F9},
175     {0x66, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_ALPHANUMERIC},
176     {0x67, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F11},
177     {0x68, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_KATAKANA},
178     {0x69, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F13},
179     {0x6A, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F16},
180     {0x6B, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F14},
181     {0x6C, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
182     {0x6D, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F10},
183     {0x6E, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
184     {0x6F, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F12},
185     {0x70, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
186     {0x71, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F15},
187     {0x72, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_HELP},
188     {0x73, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_HOME},
189     {0x74, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_PAGE_UP},
190     {0x75, YES, KL_STANDARD, java_awt_event_KeyEvent_VK_DELETE},
191     {0x76, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F4},
192     {0x77, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_END},
193     {0x78, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F2},
194     {0x79, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_PAGE_DOWN},
195     {0x7A, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_F1},
196     {0x7B, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_LEFT},
197     {0x7C, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_RIGHT},
198     {0x7D, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_DOWN},
199     {0x7E, NO,  KL_STANDARD, java_awt_event_KeyEvent_VK_UP},
200     {0x7F, NO,  KL_UNKNOWN,  java_awt_event_KeyEvent_VK_UNDEFINED},
201 };
202 
203 /*
204  * This table was stolen from the Windows implementation for mapping
205  * Unicode values to VK codes for dead keys.  On Windows, some layouts
206  * return ASCII punctuation for dead accents, while some return spacing
207  * accent chars, so both should be listed.  However, in all of the
208  * keyboard layouts I tried only the Unicode values are used.
209  */
210 struct CharToVKEntry {
211     UniChar c;
212     jint javaKey;
213 };
214 static const struct CharToVKEntry charToDeadVKTable[] = {
215     {0x0060, java_awt_event_KeyEvent_VK_DEAD_GRAVE},
216     {0x00B4, java_awt_event_KeyEvent_VK_DEAD_ACUTE},
217     {0x0384, java_awt_event_KeyEvent_VK_DEAD_ACUTE}, // Unicode &quot;GREEK TONOS&quot; -- Greek keyboard, semicolon key
218     {0x005E, java_awt_event_KeyEvent_VK_DEAD_CIRCUMFLEX},
219     {0x007E, java_awt_event_KeyEvent_VK_DEAD_TILDE},
220     {0x02DC, java_awt_event_KeyEvent_VK_DEAD_TILDE}, // Unicode &quot;SMALL TILDE&quot;
221     {0x00AF, java_awt_event_KeyEvent_VK_DEAD_MACRON},
222     {0x02D8, java_awt_event_KeyEvent_VK_DEAD_BREVE},
223     {0x02D9, java_awt_event_KeyEvent_VK_DEAD_ABOVEDOT},
224     {0x00A8, java_awt_event_KeyEvent_VK_DEAD_DIAERESIS},
225     {0x02DA, java_awt_event_KeyEvent_VK_DEAD_ABOVERING},
226     {0x02DD, java_awt_event_KeyEvent_VK_DEAD_DOUBLEACUTE},
227     {0x02C7, java_awt_event_KeyEvent_VK_DEAD_CARON},
228     {0x00B8, java_awt_event_KeyEvent_VK_DEAD_CEDILLA},
229     {0x02DB, java_awt_event_KeyEvent_VK_DEAD_OGONEK},
230     {0x037A, java_awt_event_KeyEvent_VK_DEAD_IOTA},
231     {0x309B, java_awt_event_KeyEvent_VK_DEAD_VOICED_SOUND},
232     {0x309C, java_awt_event_KeyEvent_VK_DEAD_SEMIVOICED_SOUND},
233     {0,0}
234 };
235 
236 // TODO: some constants below are part of CGS (private interfaces)...
237 // for now we will look at the raw key code to determine left/right status
238 // but not sure this is foolproof...
239 static struct _nsKeyToJavaModifier
240 {
241     NSUInteger nsMask;
242     //NSUInteger cgsLeftMask;
243     //NSUInteger cgsRightMask;
244     unsigned short leftKeyCode;
245     unsigned short rightKeyCode;
246     jint javaExtMask;
247     jint javaMask;
248     jint javaKey;
249 }
250 const nsKeyToJavaModifierTable[] =
251 {
252     {
253         NSAlphaShiftKeyMask,
254         0,
255         0,
256         0, // no Java equivalent
257         0, // no Java equivalent
258         java_awt_event_KeyEvent_VK_CAPS_LOCK
259     },
260     {
261         NSShiftKeyMask,
262         //kCGSFlagsMaskAppleShiftKey,
263         //kCGSFlagsMaskAppleRightShiftKey,
264         56,
265         60,
266         java_awt_event_InputEvent_SHIFT_DOWN_MASK,
267         java_awt_event_InputEvent_SHIFT_MASK,
268         java_awt_event_KeyEvent_VK_SHIFT
269     },
270     {
271         NSControlKeyMask,
272         //kCGSFlagsMaskAppleControlKey,
273         //kCGSFlagsMaskAppleRightControlKey,
274         59,
275         62,
276         java_awt_event_InputEvent_CTRL_DOWN_MASK,
277         java_awt_event_InputEvent_CTRL_MASK,
278         java_awt_event_KeyEvent_VK_CONTROL
279     },
280     {
281         NSCommandKeyMask,
282         //kCGSFlagsMaskAppleLeftCommandKey,
283         //kCGSFlagsMaskAppleRightCommandKey,
284         55,
285         54,
286         java_awt_event_InputEvent_META_DOWN_MASK,
287         java_awt_event_InputEvent_META_MASK,
288         java_awt_event_KeyEvent_VK_META
289     },
290     {
291         NSAlternateKeyMask,
292         //kCGSFlagsMaskAppleLeftAlternateKey,
293         //kCGSFlagsMaskAppleRightAlternateKey,
294         58,
295         0,
296         java_awt_event_InputEvent_ALT_DOWN_MASK,
297         java_awt_event_InputEvent_ALT_MASK,
298         java_awt_event_KeyEvent_VK_ALT
299     },
300     {
301         NSAlternateKeyMask,
302         0,
303         61,
304         java_awt_event_InputEvent_ALT_DOWN_MASK | java_awt_event_InputEvent_ALT_GRAPH_DOWN_MASK,
305         java_awt_event_InputEvent_ALT_MASK | java_awt_event_InputEvent_ALT_GRAPH_MASK,
306         java_awt_event_KeyEvent_VK_ALT | java_awt_event_KeyEvent_VK_ALT_GRAPH
307     },
308     // NSNumericPadKeyMask
309     {
310         NSHelpKeyMask,
311         0,
312         0,
313         0, // no Java equivalent
314         0, // no Java equivalent
315         java_awt_event_KeyEvent_VK_HELP
316     },
317     // NSFunctionKeyMask
318     {0, 0, 0, 0, 0, 0}
319 };
320 
321 static BOOL leftAltKeyPressed;
<a name="2" id="anc2"></a><span class="line-removed">322 static BOOL altGRPressed = NO;</span>
323 
324 /*
325  * Almost all unicode characters just go from NS to Java with no translation.
326  *  For the few exceptions, we handle it here with this small table.
327  */
328 #define ALL_NS_KEY_MODIFIERS_MASK \
329     (NSShiftKeyMask | NSControlKeyMask | NSAlternateKeyMask | NSCommandKeyMask)
330 
331 static struct _char {
332     NSUInteger modifier;
333     unichar nsChar;
334     unichar javaChar;
335 }
336 const charTable[] = {
337     // map enter on keypad to same as return key
338     {0,                         NSEnterCharacter,          NSNewlineCharacter},
339 
340     // [3134616] return newline instead of carriage return
341     {0,                         NSCarriageReturnCharacter, NSNewlineCharacter},
342 
343     // &quot;delete&quot; means backspace in Java
344     {ALL_NS_KEY_MODIFIERS_MASK, NSDeleteCharacter,         NSBackspaceCharacter},
345     {ALL_NS_KEY_MODIFIERS_MASK, NSDeleteFunctionKey,       NSDeleteCharacter},
346 
347     // back-tab is only differentiated from tab by Shift flag
348     {NSShiftKeyMask,            NSBackTabCharacter,        NSTabCharacter},
349 
350     {0, 0, 0}
351 };
352 
353 unichar NsCharToJavaChar(unichar nsChar, NSUInteger modifiers, BOOL spaceKeyTyped)
354 {
355     const struct _char *cur;
356     // Mask off just the keyboard modifiers from the event modifier mask.
357     NSUInteger testableFlags = (modifiers &amp; ALL_NS_KEY_MODIFIERS_MASK);
358 
359     // walk through table &amp; find the match
360     for (cur = charTable; cur-&gt;nsChar != 0 ; cur++) {
361         // &lt;rdar://Problem/3476426&gt; Need to determine if we are looking at
362         // a plain keypress or a modified keypress.  Don&#39;t adjust the
363         // character of a keypress with a modifier.
364         if (cur-&gt;nsChar == nsChar) {
365             if (cur-&gt;modifier == 0 &amp;&amp; testableFlags == 0) {
366                 // If the modifier field is 0, that means to transform
367                 // this character if no additional keyboard modifiers are set.
368                 // This lets ctrl-C be reported as ctrl-C and not transformed
369                 // into Newline.
370                 return cur-&gt;javaChar;
371             } else if (cur-&gt;modifier != 0 &amp;&amp;
372                        (testableFlags &amp; cur-&gt;modifier) == testableFlags)
373             {
374                 // Likewise, if the modifier field is nonzero, that means
375                 // transform this character if only these modifiers are
376                 // set in the testable flags.
377                 return cur-&gt;javaChar;
378             }
379         }
380     }
381 
382     if (nsChar &gt;= NSUpArrowFunctionKey &amp;&amp; nsChar &lt;= NSModeSwitchFunctionKey) {
383         return java_awt_event_KeyEvent_CHAR_UNDEFINED;
384     }
385 
386     // nsChar receives value 0 when SPACE key is typed.
387     if (nsChar == 0 &amp;&amp; spaceKeyTyped == YES) {
388         return java_awt_event_KeyEvent_VK_SPACE;
389     }
390 
391     // otherwise return character unchanged
392     return nsChar;
393 }
394 
395 static unichar NsGetDeadKeyChar(unsigned short keyCode)
396 {
397     TISInputSourceRef currentKeyboard = TISCopyCurrentKeyboardInputSource();
398     CFDataRef uchr = (CFDataRef)TISGetInputSourceProperty(currentKeyboard, kTISPropertyUnicodeKeyLayoutData);
399     if (uchr == nil) { return 0; }
400     const UCKeyboardLayout *keyboardLayout = (const UCKeyboardLayout*)CFDataGetBytePtr(uchr);
401     // Carbon modifiers should be used instead of NSEvent modifiers
402     UInt32 modifierKeyState = (GetCurrentEventKeyModifiers() &gt;&gt; 8) &amp; 0xFF;
403 
404     if (keyboardLayout) {
405         UInt32 deadKeyState = 0;
406         UniCharCount maxStringLength = 255;
407         UniCharCount actualStringLength = 0;
408         UniChar unicodeString[maxStringLength];
409 
410         // get the deadKeyState
411         OSStatus status = UCKeyTranslate(keyboardLayout,
412                                          keyCode, kUCKeyActionDown, modifierKeyState,
413                                          LMGetKbdType(), kUCKeyTranslateNoDeadKeysBit,
414                                          &amp;deadKeyState,
415                                          maxStringLength,
416                                          &amp;actualStringLength, unicodeString);
417 
418         if (status == noErr &amp;&amp; deadKeyState != 0) {
419             // Press SPACE to get the dead key char
420             status = UCKeyTranslate(keyboardLayout,
421                                     kVK_Space, kUCKeyActionDown, 0,
422                                     LMGetKbdType(), 0,
423                                     &amp;deadKeyState,
424                                     maxStringLength,
425                                     &amp;actualStringLength, unicodeString);
426 
427             if (status == noErr &amp;&amp; actualStringLength &gt; 0) {
428                 return unicodeString[0];
429             }
430         }
431     }
432     return 0;
433 }
434 
435 /*
436  * This is the function that uses the table above to take incoming
437  * NSEvent keyCodes and translate to the Java virtual key code.
438  */
439 static void
440 NsCharToJavaVirtualKeyCode(unichar ch, BOOL isDeadChar,
441                            NSUInteger flags, unsigned short key,
442                            jint *keyCode, jint *keyLocation, BOOL *postsTyped,
443                            unichar *deadChar)
444 {
445     static size_t size = sizeof(keyTable) / sizeof(struct _key);
446     NSInteger offset;
447 
448     if (isDeadChar) {
449         unichar testDeadChar = NsGetDeadKeyChar(key);
450         const struct CharToVKEntry *map;
451         for (map = charToDeadVKTable; map-&gt;c != 0; ++map) {
452             if (testDeadChar == map-&gt;c) {
453                 *keyCode = map-&gt;javaKey;
454                 *postsTyped = NO;
455                 // TODO: use UNKNOWN here?
456                 *keyLocation = java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN;
457                 *deadChar = testDeadChar;
458                 return;
459             }
460         }
461         // If we got here, we keep looking for a normal key.
462     }
463 
464     if ([[NSCharacterSet letterCharacterSet] characterIsMember:ch]) {
465         // key is an alphabetic character
466         unichar lower;
467         lower = tolower(ch);
468         offset = lower - &#39;a&#39;;
469         if (offset &gt;= 0 &amp;&amp; offset &lt;= 25) {
470             // some chars in letter set are NOT actually A-Z characters?!
471             // skip them...
472             *postsTyped = YES;
473             // do quick conversion
474             *keyCode = java_awt_event_KeyEvent_VK_A + offset;
475             *keyLocation = java_awt_event_KeyEvent_KEY_LOCATION_STANDARD;
476             return;
477         }
478     }
479 
480     if ([[NSCharacterSet decimalDigitCharacterSet] characterIsMember:ch]) {
481         // key is a digit
482         offset = ch - &#39;0&#39;;
483         // make sure in range for decimal digits
484         if (offset &gt;= 0 &amp;&amp; offset &lt;= 9)    {
485             jboolean numpad = ((flags &amp; NSNumericPadKeyMask) &amp;&amp;
486                                (key &gt; 81 &amp;&amp; key &lt; 93));
487             *postsTyped = YES;
488             if (numpad) {
489                 *keyCode = offset + java_awt_event_KeyEvent_VK_NUMPAD0;
490                 *keyLocation = java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD;
491             } else {
492                 *keyCode = offset + java_awt_event_KeyEvent_VK_0;
493                 *keyLocation = java_awt_event_KeyEvent_KEY_LOCATION_STANDARD;
494             }
495             return;
496         }
497     }
498 
499     if (key &lt; size) {
500         *postsTyped = keyTable[key].postsTyped;
501         *keyCode = keyTable[key].javaKeyCode;
502         *keyLocation = keyTable[key].javaKeyLocation;
503     } else {
504         // Should we report this? This means we&#39;ve got a keyboard
505         // we don&#39;t know about...
506         *postsTyped = NO;
507         *keyCode = java_awt_event_KeyEvent_VK_UNDEFINED;
508         *keyLocation = java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN;
509     }
510 }
511 
512 /*
513  * This returns the java key data for the key NSEvent modifiers
514  * (after NSFlagChanged).
515  */
516 static void
517 NsKeyModifiersToJavaKeyInfo(NSUInteger nsFlags, unsigned short eventKeyCode,
518                             jint *javaKeyCode,
519                             jint *javaKeyLocation,
520                             jint *javaKeyType)
521 {
522     static NSUInteger sPreviousNSFlags = 0;
523 
524     const struct _nsKeyToJavaModifier* cur;
525     NSUInteger oldNSFlags = sPreviousNSFlags;
526     NSUInteger changedNSFlags = oldNSFlags ^ nsFlags;
527     sPreviousNSFlags = nsFlags;
528 
529     *javaKeyCode = java_awt_event_KeyEvent_VK_UNDEFINED;
530     *javaKeyLocation = java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN;
531     *javaKeyType = java_awt_event_KeyEvent_KEY_PRESSED;
532 
533     for (cur = nsKeyToJavaModifierTable; cur-&gt;nsMask != 0; ++cur) {
534         if (changedNSFlags &amp; cur-&gt;nsMask) {
535             *javaKeyCode = cur-&gt;javaKey;
536             *javaKeyLocation = java_awt_event_KeyEvent_KEY_LOCATION_STANDARD;
537             // TODO: uses SPI...
538             //if (changedNSFlags &amp; cur-&gt;cgsLeftMask) {
539             //    *javaKeyLocation = java_awt_event_KeyEvent_KEY_LOCATION_LEFT;
540             //} else if (changedNSFlags &amp; cur-&gt;cgsRightMask) {
541             //    *javaKeyLocation = java_awt_event_KeyEvent_KEY_LOCATION_RIGHT;
542             //}
543             if (eventKeyCode == cur-&gt;leftKeyCode) {
544                 leftAltKeyPressed = YES;
545                 *javaKeyLocation = java_awt_event_KeyEvent_KEY_LOCATION_LEFT;
546             } else if (eventKeyCode == cur-&gt;rightKeyCode) {
547                 *javaKeyLocation = java_awt_event_KeyEvent_KEY_LOCATION_RIGHT;
548             } else if (cur-&gt;nsMask == NSAlternateKeyMask) {
549                 leftAltKeyPressed = NO;
550                 continue;
551             }
552             *javaKeyType = (cur-&gt;nsMask &amp; nsFlags) ?
553             java_awt_event_KeyEvent_KEY_PRESSED :
554             java_awt_event_KeyEvent_KEY_RELEASED;
555             break;
556         }
557     }
558 }
559 
560 /*
561  * This returns the java modifiers for a key NSEvent.
562  */
563 jint NsKeyModifiersToJavaModifiers(NSUInteger nsFlags, BOOL isExtMods)
564 {
565     jint javaModifiers = 0;
566     const struct _nsKeyToJavaModifier* cur;
567 
568     for (cur = nsKeyToJavaModifierTable; cur-&gt;nsMask != 0; ++cur) {
569         if ((cur-&gt;nsMask &amp; nsFlags) != 0) {
<a name="3" id="anc3"></a><span class="line-modified">570 </span>
<span class="line-modified">571             if (cur-&gt;nsMask == NSAlternateKeyMask) {</span>
<span class="line-modified">572                 if (leftAltKeyPressed == YES) {</span>
<span class="line-removed">573                     javaModifiers |= isExtMods? cur-&gt;javaExtMask : cur-&gt;javaMask;</span>
<span class="line-removed">574                     if (altGRPressed == NO)</span>
<span class="line-removed">575                         break;</span>
<span class="line-removed">576                     } else {</span>
<span class="line-removed">577                         leftAltKeyPressed = YES;</span>
<span class="line-removed">578                         altGRPressed = YES;</span>
<span class="line-removed">579                         continue;</span>
<span class="line-removed">580                     }</span>
<span class="line-removed">581                 }</span>
582             javaModifiers |= isExtMods ? cur-&gt;javaExtMask : cur-&gt;javaMask;
<a name="4" id="anc4"></a>


583         }
584     }
585 
586     return javaModifiers;
587 }
588 
589 /*
590  * This returns the NSEvent flags for java key modifiers.
591  */
592 NSUInteger JavaModifiersToNsKeyModifiers(jint javaModifiers, BOOL isExtMods)
593 {
594     NSUInteger nsFlags = 0;
595     const struct _nsKeyToJavaModifier* cur;
596 
597     for (cur = nsKeyToJavaModifierTable; cur-&gt;nsMask != 0; ++cur) {
598         jint mask = isExtMods? cur-&gt;javaExtMask : cur-&gt;javaMask;
599         if ((mask &amp; javaModifiers) != 0) {
600             nsFlags |= cur-&gt;nsMask;
601         }
602     }
603 
604     // special case
605     jint mask = isExtMods? java_awt_event_InputEvent_ALT_GRAPH_DOWN_MASK :
606                            java_awt_event_InputEvent_ALT_GRAPH_MASK;
607 
608     if ((mask &amp; javaModifiers) != 0) {
609         nsFlags |= NSAlternateKeyMask;
610     }
611 
612     return nsFlags;
613 }
614 
615 
616 jint GetJavaMouseModifiers(NSUInteger modifierFlags)
617 {
618     // Mousing needs the key modifiers
619     jint modifiers = NsKeyModifiersToJavaModifiers(modifierFlags, YES);
620 
621 
622     /*
623      * Ask Quartz about mouse buttons state
624      */
625 
626     if (CGEventSourceButtonState(kCGEventSourceStateCombinedSessionState,
627                                  kCGMouseButtonLeft)) {
628         modifiers |= java_awt_event_InputEvent_BUTTON1_DOWN_MASK;
629     }
630 
631     if (CGEventSourceButtonState(kCGEventSourceStateCombinedSessionState,
632                                  kCGMouseButtonRight)) {
633         modifiers |= java_awt_event_InputEvent_BUTTON3_DOWN_MASK;
634     }
635 
636     if (CGEventSourceButtonState(kCGEventSourceStateCombinedSessionState,
637                                  kCGMouseButtonCenter)) {
638         modifiers |= java_awt_event_InputEvent_BUTTON2_DOWN_MASK;
639     }
640 
641     NSInteger extraButton = 3;
642     for (; extraButton &lt; gNumberOfButtons; extraButton++) {
643         if (CGEventSourceButtonState(kCGEventSourceStateCombinedSessionState,
644                                  extraButton)) {
645             modifiers |= gButtonDownMasks[extraButton];
646         }
647     }
648 
649     return modifiers;
650 }
651 
652 jlong UTC(NSEvent *event) {
653     struct timeval tv;
654     if (gettimeofday(&amp;tv, NULL) == 0) {
655         long long sec = (long long)tv.tv_sec;
656         return (sec*1000) + (tv.tv_usec/1000);
657     }
658     return 0;
659 }
660 
661 JNIEXPORT void JNICALL
662 Java_java_awt_AWTEvent_nativeSetSource
663     (JNIEnv *env, jobject self, jobject newSource)
664 {
665 }
666 
667 /*
668  * Class:     sun_lwawt_macosx_NSEvent
669  * Method:    nsToJavaModifiers
670  * Signature: (II)I
671  */
672 JNIEXPORT jint JNICALL
673 Java_sun_lwawt_macosx_NSEvent_nsToJavaModifiers
674 (JNIEnv *env, jclass cls, jint modifierFlags)
675 {
676     jint jmodifiers = 0;
677 
678 JNF_COCOA_ENTER(env);
679 
680     jmodifiers = GetJavaMouseModifiers(modifierFlags);
681 
682 JNF_COCOA_EXIT(env);
683 
684     return jmodifiers;
685 }
686 
687 /*
688  * Class:     sun_lwawt_macosx_NSEvent
689  * Method:    nsToJavaKeyInfo
690  * Signature: ([I[I)Z
691  */
692 JNIEXPORT jboolean JNICALL
693 Java_sun_lwawt_macosx_NSEvent_nsToJavaKeyInfo
694 (JNIEnv *env, jclass cls, jintArray inData, jintArray outData)
695 {
696     BOOL postsTyped = NO;
697 
698 JNF_COCOA_ENTER(env);
699 
700     jboolean copy = JNI_FALSE;
701     jint *data = (*env)-&gt;GetIntArrayElements(env, inData, &amp;copy);
702     CHECK_NULL_RETURN(data, postsTyped);
703 
704     // in  = [testChar, testDeadChar, modifierFlags, keyCode]
705     jchar testChar = (jchar)data[0];
706     BOOL isDeadChar = (data[1] != 0);
707     jint modifierFlags = data[2];
708     jshort keyCode = (jshort)data[3];
709 
710     jint jkeyCode = java_awt_event_KeyEvent_VK_UNDEFINED;
711     jint jkeyLocation = java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN;
712     jint testDeadChar = 0;
713 
714     NsCharToJavaVirtualKeyCode((unichar)testChar, isDeadChar,
715                                (NSUInteger)modifierFlags, (unsigned short)keyCode,
716                                &amp;jkeyCode, &amp;jkeyLocation, &amp;postsTyped,
717                                (unichar *) &amp;testDeadChar);
718 
719     // out = [jkeyCode, jkeyLocation, deadChar];
720     (*env)-&gt;SetIntArrayRegion(env, outData, 0, 1, &amp;jkeyCode);
721     (*env)-&gt;SetIntArrayRegion(env, outData, 1, 1, &amp;jkeyLocation);
722     (*env)-&gt;SetIntArrayRegion(env, outData, 2, 1, &amp;testDeadChar);
723 
724     (*env)-&gt;ReleaseIntArrayElements(env, inData, data, 0);
725 
726 JNF_COCOA_EXIT(env);
727 
728     return postsTyped;
729 }
730 
731 /*
732  * Class:     sun_lwawt_macosx_NSEvent
733  * Method:    nsKeyModifiersToJavaKeyInfo
734  * Signature: ([I[I)V
735  */
736 JNIEXPORT void JNICALL
737 Java_sun_lwawt_macosx_NSEvent_nsKeyModifiersToJavaKeyInfo
738 (JNIEnv *env, jclass cls, jintArray inData, jintArray outData)
739 {
740 JNF_COCOA_ENTER(env);
741 
742     jboolean copy = JNI_FALSE;
743     jint *data = (*env)-&gt;GetIntArrayElements(env, inData, &amp;copy);
744     CHECK_NULL(data);
745 
746     // in  = [modifierFlags, keyCode]
747     jint modifierFlags = data[0];
748     jshort keyCode = (jshort)data[1];
749 
750     jint jkeyCode = java_awt_event_KeyEvent_VK_UNDEFINED;
751     jint jkeyLocation = java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN;
752     jint jkeyType = java_awt_event_KeyEvent_KEY_PRESSED;
753 
754     NsKeyModifiersToJavaKeyInfo(modifierFlags,
755                                 keyCode,
756                                 &amp;jkeyCode,
757                                 &amp;jkeyLocation,
758                                 &amp;jkeyType);
759 
760     // out = [jkeyCode, jkeyLocation, jkeyType];
761     (*env)-&gt;SetIntArrayRegion(env, outData, 0, 1, &amp;jkeyCode);
762     (*env)-&gt;SetIntArrayRegion(env, outData, 1, 1, &amp;jkeyLocation);
763     (*env)-&gt;SetIntArrayRegion(env, outData, 2, 1, &amp;jkeyType);
764 
765     (*env)-&gt;ReleaseIntArrayElements(env, inData, data, 0);
766 
767 JNF_COCOA_EXIT(env);
768 }
769 
770 /*
771  * Class:     sun_lwawt_macosx_NSEvent
772  * Method:    nsToJavaChar
773  * Signature: (CI)C
774  */
775 JNIEXPORT jint JNICALL
776 Java_sun_lwawt_macosx_NSEvent_nsToJavaChar
777 (JNIEnv *env, jclass cls, jchar nsChar, jint modifierFlags, jboolean spaceKeyTyped)
778 {
779     jchar javaChar = 0;
780 
781 JNF_COCOA_ENTER(env);
782 
783     javaChar = NsCharToJavaChar(nsChar, modifierFlags, spaceKeyTyped);
784 
785 JNF_COCOA_EXIT(env);
786 
787     return javaChar;
788 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
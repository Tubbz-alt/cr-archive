<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/macosx/native/libawt_lwawt/java2d/opengl/CGLGraphicsConfig.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CGLGraphicsConfig.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CGLLayer.h.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/opengl/CGLGraphicsConfig.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -78,71 +78,10 @@</span>
  }
  
  #pragma mark -
  #pragma mark &quot;--- CGLGraphicsConfig methods ---&quot;
  
<span class="udiff-line-removed">- #ifdef REMOTELAYER</span>
<span class="udiff-line-removed">- mach_port_t JRSRemotePort;</span>
<span class="udiff-line-removed">- int remoteSocketFD = -1;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void *JRSRemoteThreadFn(void *data) {</span>
<span class="udiff-line-removed">-     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Negotiate a unix domain socket to communicate the</span>
<span class="udiff-line-removed">-     // out of band data: to read the mach port server name, and</span>
<span class="udiff-line-removed">-     // subsequently write out the layer ID.</span>
<span class="udiff-line-removed">-     static char* sock_path = &quot;/tmp/JRSRemoteDemoSocket&quot;;</span>
<span class="udiff-line-removed">-     struct sockaddr_un address;</span>
<span class="udiff-line-removed">-     int  socket_fd, nbytes;</span>
<span class="udiff-line-removed">-     int BUFLEN = 256;</span>
<span class="udiff-line-removed">-     char buffer[BUFLEN];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     remoteSocketFD = socket(PF_LOCAL, SOCK_STREAM, 0);</span>
<span class="udiff-line-removed">-     if (remoteSocketFD &lt; 0) {</span>
<span class="udiff-line-removed">-         NSLog(@&quot;socket() failed&quot;);</span>
<span class="udiff-line-removed">-         return NULL;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     memset(&amp;address, 0, sizeof(struct sockaddr_un));</span>
<span class="udiff-line-removed">-     address.sun_family = AF_UNIX;</span>
<span class="udiff-line-removed">-     memcpy(address.sun_path, sock_path, strlen(sock_path)+1);</span>
<span class="udiff-line-removed">-     int tries=0, status=-1;</span>
<span class="udiff-line-removed">-     while (status !=0 &amp;&amp; tries&lt;600) {</span>
<span class="udiff-line-removed">-         status = connect(remoteSocketFD, (struct sockaddr *) &amp;address,</span>
<span class="udiff-line-removed">-                          sizeof(struct sockaddr_un));</span>
<span class="udiff-line-removed">-         if (status != 0) {</span>
<span class="udiff-line-removed">-             tries++;</span>
<span class="udiff-line-removed">-             NSLog(@&quot;connection attempt %d failed.&quot;, tries);</span>
<span class="udiff-line-removed">-             usleep(5000000);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (status != 0) {</span>
<span class="udiff-line-removed">-         NSLog(@&quot;failed to connect&quot;);</span>
<span class="udiff-line-removed">-         return NULL;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     nbytes = read(remoteSocketFD, buffer, BUFLEN);</span>
<span class="udiff-line-removed">-     NSString* serverString = [[NSString alloc] initWithUTF8String:buffer];</span>
<span class="udiff-line-removed">-     CFRetain(serverString);</span>
<span class="udiff-line-removed">-     NSLog(@&quot;Read server name %@&quot;, serverString);</span>
<span class="udiff-line-removed">-     JRSRemotePort = [JRSRenderServer recieveRenderServer:serverString];</span>
<span class="udiff-line-removed">-     NSLog(@&quot;Read server port %d&quot;, JRSRemotePort);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     [pool drain];</span>
<span class="udiff-line-removed">-     return NULL;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void sendLayerID(int layerID) {</span>
<span class="udiff-line-removed">-     if (JRSRemotePort == 0 || remoteSocketFD &lt; 0) {</span>
<span class="udiff-line-removed">-         NSLog(@&quot;No connection to send ID&quot;);</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     int BUFLEN = 256;</span>
<span class="udiff-line-removed">-     char buffer[BUFLEN];</span>
<span class="udiff-line-removed">-     snprintf(buffer, BUFLEN, &quot;%d&quot;, layerID);</span>
<span class="udiff-line-removed">-     write(remoteSocketFD, buffer, BUFLEN);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif  /* REMOTELAYER */</span>
<span class="udiff-line-removed">- </span>
  /**
   * This is a globally shared context used when creating textures.  When any
   * new contexts are created, they specify this context as the &quot;share list&quot;
   * context, which means any texture objects created when this shared context
   * is current will be available to any other context in any other thread.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -168,14 +107,10 @@</span>
          !OGLFuncs_InitExtFuncs())
      {
          OGLFuncs_CloseLibrary();
          return JNI_FALSE;
      }
<span class="udiff-line-removed">- #ifdef REMOTELAYER</span>
<span class="udiff-line-removed">-     pthread_t jrsRemoteThread;</span>
<span class="udiff-line-removed">-     pthread_create(&amp;jrsRemoteThread, NULL, JRSRemoteThreadFn, NULL);</span>
<span class="udiff-line-removed">- #endif</span>
      return JNI_TRUE;
  }
  
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -215,44 +150,40 @@</span>
  @implementation GraphicsConfigUtil
  + (void) _getCGLConfigInfo: (NSMutableArray *)argValue {
      AWT_ASSERT_APPKIT_THREAD;
  
      jint displayID = (jint)[(NSNumber *)[argValue objectAtIndex: 0] intValue];
<span class="udiff-line-removed">-     jint pixfmt = (jint)[(NSNumber *)[argValue objectAtIndex: 1] intValue];</span>
      jint swapInterval = (jint)[(NSNumber *)[argValue objectAtIndex: 2] intValue];
      JNIEnv *env = [ThreadUtilities getJNIEnvUncached];
      [argValue removeAllObjects];
  
      J2dRlsTraceLn(J2D_TRACE_INFO, &quot;CGLGraphicsConfig_getCGLConfigInfo&quot;);
  
      NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
  
<span class="udiff-line-removed">-     CGOpenGLDisplayMask glMask = (CGOpenGLDisplayMask)pixfmt;</span>
      if (sharedContext == NULL) {
<span class="udiff-line-removed">-         if (glMask == 0) {</span>
<span class="udiff-line-removed">-             glMask = CGDisplayIDToOpenGLDisplayMask(displayID);</span>
<span class="udiff-line-removed">-         }</span>
  
          NSOpenGLPixelFormatAttribute attrs[] = {
              NSOpenGLPFAAllowOfflineRenderers,
              NSOpenGLPFAClosestPolicy,
              NSOpenGLPFAWindow,
              NSOpenGLPFAPixelBuffer,
              NSOpenGLPFADoubleBuffer,
              NSOpenGLPFAColorSize, 32,
              NSOpenGLPFAAlphaSize, 8,
              NSOpenGLPFADepthSize, 16,
<span class="udiff-line-removed">-             NSOpenGLPFAScreenMask, glMask,</span>
              0
          };
  
          sharedPixelFormat =
              [[NSOpenGLPixelFormat alloc] initWithAttributes:attrs];
          if (sharedPixelFormat == nil) {
<span class="udiff-line-modified-removed">-             J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: shared NSOpenGLPixelFormat is NULL&quot;);</span>
<span class="udiff-line-modified-removed">-             [argValue addObject: [NSNumber numberWithLong: 0L]];</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-added">+             J2dRlsTraceLn(J2D_TRACE_ERROR, </span>
<span class="udiff-line-modified-added">+                           &quot;CGLGraphicsConfig_getCGLConfigInfo: shared NSOpenGLPixelFormat is NULL&quot;);</span>
<span class="udiff-line-modified-added">+                 </span>
<span class="udiff-line-added">+            [argValue addObject: [NSNumber numberWithLong: 0L]];</span>
<span class="udiff-line-added">+            return;</span>
          }
  
          sharedContext =
              [[NSOpenGLContext alloc]
                  initWithFormat:sharedPixelFormat
</pre>
<center><a href="CGLGraphicsConfig.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CGLLayer.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libsplashscreen/splashscreen_sys.m</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;splashscreen_impl.h&quot;
 27 
 28 #import &lt;Cocoa/Cocoa.h&gt;
 29 #import &lt;objc/objc-auto.h&gt;
 30 
<a name="2" id="anc2"></a>
 31 #import &lt;JavaNativeFoundation/JavaNativeFoundation.h&gt;
 32 #import &quot;NSApplicationAWT.h&quot;
 33 
 34 #include &lt;sys/time.h&gt;
 35 #include &lt;pthread.h&gt;
 36 #include &lt;iconv.h&gt;
 37 #include &lt;langinfo.h&gt;
 38 #include &lt;locale.h&gt;
 39 #include &lt;fcntl.h&gt;
 40 #include &lt;poll.h&gt;
 41 #include &lt;errno.h&gt;
 42 #include &lt;sys/types.h&gt;
 43 #include &lt;signal.h&gt;
 44 #include &lt;unistd.h&gt;
 45 #include &lt;dlfcn.h&gt;
 46 
 47 #include &lt;sizecalc.h&gt;
 48 #import &quot;ThreadUtilities.h&quot;
 49 
 50 NSString* findScaledImageName(NSString *fileName,
 51                               NSUInteger dotIndex,
 52                               NSString *strToAppend);
 53 
 54 static NSScreen* SplashNSScreen()
 55 {
 56     return [[NSScreen screens] objectAtIndex: 0];
 57 }
 58 
 59 static void SplashCenter(Splash * splash)
 60 {
 61     NSRect screenFrame = [SplashNSScreen() frame];
 62 
 63     splash-&gt;x = (screenFrame.size.width - splash-&gt;width) / 2;
 64     splash-&gt;y = (screenFrame.size.height - splash-&gt;height) / 2 + screenFrame.origin.y;
 65 }
 66 
 67 unsigned
 68 SplashTime(void) {
 69     struct timeval tv;
 70     struct timezone tz;
 71     unsigned long long msec;
 72 
 73     gettimeofday(&amp;tv, &amp;tz);
 74     msec = (unsigned long long) tv.tv_sec * 1000 +
 75         (unsigned long long) tv.tv_usec / 1000;
 76 
 77     return (unsigned) msec;
 78 }
 79 
 80 /* Could use npt but decided to cut down on linked code size */
 81 char* SplashConvertStringAlloc(const char* in, int* size) {
 82     const char     *codeset;
 83     const char     *codeset_out;
 84     iconv_t         cd;
 85     size_t          rc;
 86     char           *buf = NULL, *out;
 87     size_t          bufSize, inSize, outSize;
 88     const char* old_locale;
 89 
 90     if (!in) {
 91         return NULL;
 92     }
 93     old_locale = setlocale(LC_ALL, &quot;&quot;);
 94 
 95     codeset = nl_langinfo(CODESET);
 96     if ( codeset == NULL || codeset[0] == 0 ) {
 97         goto done;
 98     }
 99     /* we don&#39;t need BOM in output so we choose native BE or LE encoding here */
100     codeset_out = (platformByteOrder()==BYTE_ORDER_MSBFIRST) ?
101         &quot;UCS-2BE&quot; : &quot;UCS-2LE&quot;;
102 
103     cd = iconv_open(codeset_out, codeset);
104     if (cd == (iconv_t)-1 ) {
105         goto done;
106     }
107     inSize = strlen(in);
108     buf = SAFE_SIZE_ARRAY_ALLOC(malloc, inSize, 2);
109     if (!buf) {
110         return NULL;
111     }
112     bufSize = inSize*2; // need 2 bytes per char for UCS-2, this is
113                         // 2 bytes per source byte max
114     out = buf; outSize = bufSize;
115     /* linux iconv wants char** source and solaris wants const char**...
116        cast to void* */
117     rc = iconv(cd, (void*)&amp;in, &amp;inSize, &amp;out, &amp;outSize);
118     iconv_close(cd);
119 
120     if (rc == (size_t)-1) {
121         free(buf);
122         buf = NULL;
123     } else {
124         if (size) {
125             *size = (bufSize-outSize)/2; /* bytes to wchars */
126         }
127     }
128 done:
129     setlocale(LC_ALL, old_locale);
130     return buf;
131 }
132 
133 BOOL isSWTRunning() {
134     char envVar[80];
135     // If this property is present we are running SWT
136     snprintf(envVar, sizeof(envVar), &quot;JAVA_STARTED_ON_FIRST_THREAD_%d&quot;, getpid());
137     return getenv(envVar) != NULL;
138 }
139 
140 jboolean SplashGetScaledImageName(const char* jar, const char* file,
141                                   float *scaleFactor, char *scaledFile,
142                                   const size_t scaledImageLength) {
143     *scaleFactor = 1;
144 
145     if(isSWTRunning()){
146         return JNI_FALSE;
147     }
148 
149     NSAutoreleasePool *pool = [NSAutoreleasePool new];
150     __block float screenScaleFactor = 1;
151 
152     [ThreadUtilities performOnMainThreadWaiting:YES block:^(){
153         // initialize NSApplication and AWT stuff
154         [NSApplicationAWT sharedApplication];
155         screenScaleFactor = [SplashNSScreen() backingScaleFactor];
156     }];
157 
158     if (screenScaleFactor &gt; 1) {
159         NSString *fileName = [NSString stringWithUTF8String: file];
160         NSUInteger length = [fileName length];
161         NSRange range = [fileName rangeOfString: @&quot;.&quot;
162                                         options:NSBackwardsSearch];
163         NSUInteger dotIndex = range.location;
164         NSString *fileName2x = nil;
165 
166         fileName2x = findScaledImageName(fileName, dotIndex, @&quot;@2x&quot;);
167         if(![[NSFileManager defaultManager]
168                 fileExistsAtPath: fileName2x]) {
169             fileName2x = findScaledImageName(fileName, dotIndex, @&quot;@200pct&quot;);
170         }
171         if (jar || [[NSFileManager defaultManager]
172                 fileExistsAtPath: fileName2x]){
173             if (strlen([fileName2x UTF8String]) &gt; scaledImageLength) {
174                 [pool drain];
175                 return JNI_FALSE;
176             }
177             *scaleFactor = 2;
178             strcpy(scaledFile, [fileName2x UTF8String]);
179             [pool drain];
180             return JNI_TRUE;
181         }
182     }
183     [pool drain];
184     return JNI_FALSE;
185 }
186 
<a name="3" id="anc3"></a><span class="line-modified">187 void</span>




















188 SplashInitPlatform(Splash * splash) {
<a name="4" id="anc4"></a>


189     pthread_mutex_init(&amp;splash-&gt;lock, NULL);
190 
191     splash-&gt;maskRequired = 0;
192 
<a name="5" id="anc5"></a><span class="line-modified">193     </span>
194     //TODO: the following is too much of a hack but should work in 90% cases.
195     //      besides we don&#39;t use device-dependent drawing, so probably
196     //      that&#39;s very fine indeed
197     splash-&gt;byteAlignment = 1;
198     initFormat(&amp;splash-&gt;screenFormat, 0xff &lt;&lt; 8,
199             0xff &lt;&lt; 16, 0xff &lt;&lt; 24, 0xff &lt;&lt; 0);
200     splash-&gt;screenFormat.byteOrder = 1 ?  BYTE_ORDER_LSBFIRST : BYTE_ORDER_MSBFIRST;
201     splash-&gt;screenFormat.depthBytes = 4;
202 
203     // If we are running SWT we should not start a runLoop
204     if (!isSWTRunning()) {
205         [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^() {
206             [NSApplicationAWT runAWTLoopWithApp:[NSApplicationAWT sharedApplication]];
207         }];
208     }
<a name="6" id="anc6"></a>
209 }
210 
211 void
212 SplashCleanupPlatform(Splash * splash) {
213     splash-&gt;maskRequired = 0;
214 }
215 
216 void
217 SplashDonePlatform(Splash * splash) {
218     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
219 
220     pthread_mutex_destroy(&amp;splash-&gt;lock);
221     [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){
222         if (splash-&gt;window) {
223             [splash-&gt;window orderOut:nil];
224             [splash-&gt;window release];
225         }
226     }];
227     [pool drain];
228 }
229 
230 void
231 SplashLock(Splash * splash) {
232     pthread_mutex_lock(&amp;splash-&gt;lock);
233 }
234 
235 void
236 SplashUnlock(Splash * splash) {
237     pthread_mutex_unlock(&amp;splash-&gt;lock);
238 }
239 
240 void
241 SplashInitFrameShape(Splash * splash, int imageIndex) {
242     // No shapes, we rely on alpha compositing
243 }
244 
245 void * SplashScreenThread(void *param);
246 void
247 SplashCreateThread(Splash * splash) {
248     pthread_t thr;
249     pthread_attr_t attr;
250     int rc;
251 
252     pthread_attr_init(&amp;attr);
253     rc = pthread_create(&amp;thr, &amp;attr, SplashScreenThread, (void *) splash);
254 }
255 
256 void
257 SplashRedrawWindow(Splash * splash) {
258     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
259 
<a name="7" id="anc7"></a><span class="line-removed">260     SplashUpdateScreenData(splash);</span>
<span class="line-removed">261 </span>
262     [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){
<a name="8" id="anc8"></a>



263         // NSDeviceRGBColorSpace vs. NSCalibratedRGBColorSpace ?
264         NSBitmapImageRep * rep = [[NSBitmapImageRep alloc]
265             initWithBitmapDataPlanes: (unsigned char**)&amp;splash-&gt;screenData
266                           pixelsWide: splash-&gt;width
267                           pixelsHigh: splash-&gt;height
268                        bitsPerSample: 8
269                      samplesPerPixel: 4
270                             hasAlpha: YES
271                             isPlanar: NO
272                       colorSpaceName: NSDeviceRGBColorSpace
273                         bitmapFormat: NSAlphaFirstBitmapFormat | NSAlphaNonpremultipliedBitmapFormat
274                          bytesPerRow: splash-&gt;width * 4
275                         bitsPerPixel: 32];
276 
277         NSImage * image = [[NSImage alloc]
278             initWithSize: NSMakeSize(splash-&gt;width, splash-&gt;height)];
279         [image setBackgroundColor: [NSColor clearColor]];
280 
281         [image addRepresentation: rep];
282         float scaleFactor = splash-&gt;scaleFactor;
283         if (scaleFactor &gt; 0 &amp;&amp; scaleFactor != 1) {
284             NSSize size = [image size];
285             size.width /= scaleFactor;
286             size.height /= scaleFactor;
287             [image setSize: size];
288         }
<a name="9" id="anc9"></a><span class="line-modified">289         </span>
290         NSImageView * view = [[NSImageView alloc] init];
291 
292         [view setImage: image];
293         [view setEditable: NO];
294         //NOTE: we don&#39;t set a &#39;wait cursor&#39; for the view because:
295         //      1. The Cocoa GUI guidelines suggest to avoid it, and use a progress
296         //         bar instead.
297         //      2. There simply isn&#39;t an instance of NSCursor that represent
298         //         the &#39;wait cursor&#39;. So that is undoable.
299 
300         //TODO: only the first image in an animated gif preserves transparency.
301         //      Loos like the splash-&gt;screenData contains inappropriate data
302         //      for all but the first frame.
303 
304         [image release];
305         [rep release];
306 
307         [splash-&gt;window setContentView: view];
308         [splash-&gt;window orderFrontRegardless];
309     }];
310 
311     [pool drain];
312 }
313 
314 void SplashReconfigureNow(Splash * splash) {
315     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
316 
317     [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){
318         SplashCenter(splash);
319 
320         if (!splash-&gt;window) {
321             return;
322         }
323 
324         [splash-&gt;window orderOut:nil];
325         [splash-&gt;window setFrame: NSMakeRect(splash-&gt;x, splash-&gt;y, splash-&gt;width, splash-&gt;height)
326                          display: NO];
327     }];
328 
329     [pool drain];
330 
331     SplashRedrawWindow(splash);
332 }
333 
334 void
335 SplashEventLoop(Splash * splash) {
336 
337     /* we should have splash _locked_ on entry!!! */
338 
339     while (1) {
340         struct pollfd pfd[1];
341         int timeout = -1;
342         int ctl = splash-&gt;controlpipe[0];
343         int rc;
344         int pipes_empty;
345 
346         pfd[0].fd = ctl;
347         pfd[0].events = POLLIN | POLLPRI;
348 
349         errno = 0;
350         if (splash-&gt;isVisible&gt;0 &amp;&amp; SplashIsStillLooping(splash)) {
351             timeout = splash-&gt;time + splash-&gt;frames[splash-&gt;currentFrame].delay
352                 - SplashTime();
353             if (timeout &lt; 0) {
354                 timeout = 0;
355             }
356         }
357         SplashUnlock(splash);
358         rc = poll(pfd, 1, timeout);
359         SplashLock(splash);
360         if (splash-&gt;isVisible &gt; 0 &amp;&amp; splash-&gt;currentFrame &gt;= 0 &amp;&amp;
361                 SplashTime() &gt;= splash-&gt;time + splash-&gt;frames[splash-&gt;currentFrame].delay) {
362             SplashNextFrame(splash);
363             SplashRedrawWindow(splash);
364         }
365         if (rc &lt;= 0) {
366             errno = 0;
367             continue;
368         }
369         pipes_empty = 0;
370         while(!pipes_empty) {
371             char buf;
372 
373             pipes_empty = 1;
374             if (read(ctl, &amp;buf, sizeof(buf)) &gt; 0) {
375                 pipes_empty = 0;
376                 switch (buf) {
377                 case SPLASHCTL_UPDATE:
378                     if (splash-&gt;isVisible&gt;0) {
379                         SplashRedrawWindow(splash);
380                     }
381                     break;
382                 case SPLASHCTL_RECONFIGURE:
383                     if (splash-&gt;isVisible&gt;0) {
384                         SplashReconfigureNow(splash);
385                     }
386                     break;
387                 case SPLASHCTL_QUIT:
388                     return;
389                 }
390             }
391         }
392     }
393 }
394 
395 void *
396 SplashScreenThread(void *param) {
397     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
398     Splash *splash = (Splash *) param;
399 
400     SplashLock(splash);
401     pipe(splash-&gt;controlpipe);
402     fcntl(splash-&gt;controlpipe[0], F_SETFL,
403         fcntl(splash-&gt;controlpipe[0], F_GETFL, 0) | O_NONBLOCK);
404     splash-&gt;time = SplashTime();
405     splash-&gt;currentFrame = 0;
406     [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){
407         SplashCenter(splash);
408 
409         splash-&gt;window = (void*) [[NSWindow alloc]
410             initWithContentRect: NSMakeRect(splash-&gt;x, splash-&gt;y, splash-&gt;width, splash-&gt;height)
411                       styleMask: NSBorderlessWindowMask
412                         backing: NSBackingStoreBuffered
413                           defer: NO
414                          screen: SplashNSScreen()];
415 
416         [splash-&gt;window setOpaque: NO];
417         [splash-&gt;window setBackgroundColor: [NSColor clearColor]];
418     }];
419     fflush(stdout);
420     if (splash-&gt;window) {
421         [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){
422             [splash-&gt;window orderFrontRegardless];
423         }];
424         SplashRedrawWindow(splash);
425         SplashEventLoop(splash);
426     }
427     SplashUnlock(splash);
428     SplashDone(splash);
429 
430     splash-&gt;isVisible=-1;
431 
432     [pool drain];
433 
434     return 0;
435 }
436 
437 void
438 sendctl(Splash * splash, char code) {
439     if (splash &amp;&amp; splash-&gt;controlpipe[1]) {
440         write(splash-&gt;controlpipe[1], &amp;code, 1);
441     }
442 }
443 
444 void
445 SplashClosePlatform(Splash * splash) {
446     sendctl(splash, SPLASHCTL_QUIT);
447 }
448 
449 void
450 SplashUpdate(Splash * splash) {
451     sendctl(splash, SPLASHCTL_UPDATE);
452 }
453 
454 void
455 SplashReconfigure(Splash * splash) {
456     sendctl(splash, SPLASHCTL_RECONFIGURE);
457 }
458 
459 NSString* findScaledImageName(NSString *fileName, NSUInteger dotIndex, NSString *strToAppend) {
460     NSString *fileName2x = nil;
461     if (dotIndex == NSNotFound) {
462         fileName2x = [fileName stringByAppendingString: strToAppend];
463     } else {
464         fileName2x = [fileName substringToIndex: dotIndex];
465         fileName2x = [fileName2x stringByAppendingString: strToAppend];
466         fileName2x = [fileName2x stringByAppendingString:
467                       [fileName substringFromIndex: dotIndex]];
468     }
469     return fileName2x;
470 }
471 
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
diff a/src/java.desktop/macosx/native/libsplashscreen/splashscreen_sys.m b/src/java.desktop/macosx/native/libsplashscreen/splashscreen_sys.m
--- a/src/java.desktop/macosx/native/libsplashscreen/splashscreen_sys.m
+++ b/src/java.desktop/macosx/native/libsplashscreen/splashscreen_sys.m
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -26,10 +26,11 @@
 #include "splashscreen_impl.h"
 
 #import <Cocoa/Cocoa.h>
 #import <objc/objc-auto.h>
 
+#include <Security/AuthSession.h>
 #import <JavaNativeFoundation/JavaNativeFoundation.h>
 #import "NSApplicationAWT.h"
 
 #include <sys/time.h>
 #include <pthread.h>
@@ -182,17 +183,40 @@
     }
     [pool drain];
     return JNI_FALSE;
 }
 
-void
+static int isInAquaSession() {
+    // environment variable to bypass the aqua session check
+    char *ev = getenv("AWT_FORCE_HEADFUL");
+    if (ev && (strncasecmp(ev, "true", 4) == 0)) {
+        // if "true" then tell the caller we're in
+        // an Aqua session without actually checking
+        return 1;
+    }
+    // Is the WindowServer available?
+    SecuritySessionId session_id;
+    SessionAttributeBits session_info;
+    OSStatus status = SessionGetInfo(callerSecuritySession, &session_id, &session_info);
+    if (status == noErr) {
+        if (session_info & sessionHasGraphicAccess) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+int
 SplashInitPlatform(Splash * splash) {
+    if (!isInAquaSession()) {
+        return 0;
+    }
     pthread_mutex_init(&splash->lock, NULL);
 
     splash->maskRequired = 0;
 
-    
+
     //TODO: the following is too much of a hack but should work in 90% cases.
     //      besides we don't use device-dependent drawing, so probably
     //      that's very fine indeed
     splash->byteAlignment = 1;
     initFormat(&splash->screenFormat, 0xff << 8,
@@ -204,10 +228,11 @@
     if (!isSWTRunning()) {
         [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^() {
             [NSApplicationAWT runAWTLoopWithApp:[NSApplicationAWT sharedApplication]];
         }];
     }
+    return 1;
 }
 
 void
 SplashCleanupPlatform(Splash * splash) {
     splash->maskRequired = 0;
@@ -255,13 +280,15 @@
 
 void
 SplashRedrawWindow(Splash * splash) {
     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 
-    SplashUpdateScreenData(splash);
-
     [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){
+        // drop the reference to the old view and image
+        [splash->window setContentView: nil];
+        SplashUpdateScreenData(splash);
+
         // NSDeviceRGBColorSpace vs. NSCalibratedRGBColorSpace ?
         NSBitmapImageRep * rep = [[NSBitmapImageRep alloc]
             initWithBitmapDataPlanes: (unsigned char**)&splash->screenData
                           pixelsWide: splash->width
                           pixelsHigh: splash->height
@@ -284,11 +311,11 @@
             NSSize size = [image size];
             size.width /= scaleFactor;
             size.height /= scaleFactor;
             [image setSize: size];
         }
-        
+
         NSImageView * view = [[NSImageView alloc] init];
 
         [view setImage: image];
         [view setEditable: NO];
         //NOTE: we don't set a 'wait cursor' for the view because:

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/macosx/native/libsplashscreen/splashscreen_sys.m</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;splashscreen_impl.h&quot;
 27 
 28 #import &lt;Cocoa/Cocoa.h&gt;
 29 #import &lt;objc/objc-auto.h&gt;
 30 
 31 #include &lt;Security/AuthSession.h&gt;
 32 #import &lt;JavaNativeFoundation/JavaNativeFoundation.h&gt;
 33 #import &quot;NSApplicationAWT.h&quot;
 34 
 35 #include &lt;sys/time.h&gt;
 36 #include &lt;pthread.h&gt;
 37 #include &lt;iconv.h&gt;
 38 #include &lt;langinfo.h&gt;
 39 #include &lt;locale.h&gt;
 40 #include &lt;fcntl.h&gt;
 41 #include &lt;poll.h&gt;
 42 #include &lt;errno.h&gt;
 43 #include &lt;sys/types.h&gt;
 44 #include &lt;signal.h&gt;
 45 #include &lt;unistd.h&gt;
 46 #include &lt;dlfcn.h&gt;
 47 
 48 #include &lt;sizecalc.h&gt;
 49 #import &quot;ThreadUtilities.h&quot;
 50 
 51 NSString* findScaledImageName(NSString *fileName,
 52                               NSUInteger dotIndex,
 53                               NSString *strToAppend);
 54 
 55 static NSScreen* SplashNSScreen()
 56 {
 57     return [[NSScreen screens] objectAtIndex: 0];
 58 }
 59 
 60 static void SplashCenter(Splash * splash)
 61 {
 62     NSRect screenFrame = [SplashNSScreen() frame];
 63 
 64     splash-&gt;x = (screenFrame.size.width - splash-&gt;width) / 2;
 65     splash-&gt;y = (screenFrame.size.height - splash-&gt;height) / 2 + screenFrame.origin.y;
 66 }
 67 
 68 unsigned
 69 SplashTime(void) {
 70     struct timeval tv;
 71     struct timezone tz;
 72     unsigned long long msec;
 73 
 74     gettimeofday(&amp;tv, &amp;tz);
 75     msec = (unsigned long long) tv.tv_sec * 1000 +
 76         (unsigned long long) tv.tv_usec / 1000;
 77 
 78     return (unsigned) msec;
 79 }
 80 
 81 /* Could use npt but decided to cut down on linked code size */
 82 char* SplashConvertStringAlloc(const char* in, int* size) {
 83     const char     *codeset;
 84     const char     *codeset_out;
 85     iconv_t         cd;
 86     size_t          rc;
 87     char           *buf = NULL, *out;
 88     size_t          bufSize, inSize, outSize;
 89     const char* old_locale;
 90 
 91     if (!in) {
 92         return NULL;
 93     }
 94     old_locale = setlocale(LC_ALL, &quot;&quot;);
 95 
 96     codeset = nl_langinfo(CODESET);
 97     if ( codeset == NULL || codeset[0] == 0 ) {
 98         goto done;
 99     }
100     /* we don&#39;t need BOM in output so we choose native BE or LE encoding here */
101     codeset_out = (platformByteOrder()==BYTE_ORDER_MSBFIRST) ?
102         &quot;UCS-2BE&quot; : &quot;UCS-2LE&quot;;
103 
104     cd = iconv_open(codeset_out, codeset);
105     if (cd == (iconv_t)-1 ) {
106         goto done;
107     }
108     inSize = strlen(in);
109     buf = SAFE_SIZE_ARRAY_ALLOC(malloc, inSize, 2);
110     if (!buf) {
111         return NULL;
112     }
113     bufSize = inSize*2; // need 2 bytes per char for UCS-2, this is
114                         // 2 bytes per source byte max
115     out = buf; outSize = bufSize;
116     /* linux iconv wants char** source and solaris wants const char**...
117        cast to void* */
118     rc = iconv(cd, (void*)&amp;in, &amp;inSize, &amp;out, &amp;outSize);
119     iconv_close(cd);
120 
121     if (rc == (size_t)-1) {
122         free(buf);
123         buf = NULL;
124     } else {
125         if (size) {
126             *size = (bufSize-outSize)/2; /* bytes to wchars */
127         }
128     }
129 done:
130     setlocale(LC_ALL, old_locale);
131     return buf;
132 }
133 
134 BOOL isSWTRunning() {
135     char envVar[80];
136     // If this property is present we are running SWT
137     snprintf(envVar, sizeof(envVar), &quot;JAVA_STARTED_ON_FIRST_THREAD_%d&quot;, getpid());
138     return getenv(envVar) != NULL;
139 }
140 
141 jboolean SplashGetScaledImageName(const char* jar, const char* file,
142                                   float *scaleFactor, char *scaledFile,
143                                   const size_t scaledImageLength) {
144     *scaleFactor = 1;
145 
146     if(isSWTRunning()){
147         return JNI_FALSE;
148     }
149 
150     NSAutoreleasePool *pool = [NSAutoreleasePool new];
151     __block float screenScaleFactor = 1;
152 
153     [ThreadUtilities performOnMainThreadWaiting:YES block:^(){
154         // initialize NSApplication and AWT stuff
155         [NSApplicationAWT sharedApplication];
156         screenScaleFactor = [SplashNSScreen() backingScaleFactor];
157     }];
158 
159     if (screenScaleFactor &gt; 1) {
160         NSString *fileName = [NSString stringWithUTF8String: file];
161         NSUInteger length = [fileName length];
162         NSRange range = [fileName rangeOfString: @&quot;.&quot;
163                                         options:NSBackwardsSearch];
164         NSUInteger dotIndex = range.location;
165         NSString *fileName2x = nil;
166 
167         fileName2x = findScaledImageName(fileName, dotIndex, @&quot;@2x&quot;);
168         if(![[NSFileManager defaultManager]
169                 fileExistsAtPath: fileName2x]) {
170             fileName2x = findScaledImageName(fileName, dotIndex, @&quot;@200pct&quot;);
171         }
172         if (jar || [[NSFileManager defaultManager]
173                 fileExistsAtPath: fileName2x]){
174             if (strlen([fileName2x UTF8String]) &gt; scaledImageLength) {
175                 [pool drain];
176                 return JNI_FALSE;
177             }
178             *scaleFactor = 2;
179             strcpy(scaledFile, [fileName2x UTF8String]);
180             [pool drain];
181             return JNI_TRUE;
182         }
183     }
184     [pool drain];
185     return JNI_FALSE;
186 }
187 
188 static int isInAquaSession() {
189     // environment variable to bypass the aqua session check
190     char *ev = getenv(&quot;AWT_FORCE_HEADFUL&quot;);
191     if (ev &amp;&amp; (strncasecmp(ev, &quot;true&quot;, 4) == 0)) {
192         // if &quot;true&quot; then tell the caller we&#39;re in
193         // an Aqua session without actually checking
194         return 1;
195     }
196     // Is the WindowServer available?
197     SecuritySessionId session_id;
198     SessionAttributeBits session_info;
199     OSStatus status = SessionGetInfo(callerSecuritySession, &amp;session_id, &amp;session_info);
200     if (status == noErr) {
201         if (session_info &amp; sessionHasGraphicAccess) {
202             return 1;
203         }
204     }
205     return 0;
206 }
207 
208 int
209 SplashInitPlatform(Splash * splash) {
210     if (!isInAquaSession()) {
211         return 0;
212     }
213     pthread_mutex_init(&amp;splash-&gt;lock, NULL);
214 
215     splash-&gt;maskRequired = 0;
216 
217 
218     //TODO: the following is too much of a hack but should work in 90% cases.
219     //      besides we don&#39;t use device-dependent drawing, so probably
220     //      that&#39;s very fine indeed
221     splash-&gt;byteAlignment = 1;
222     initFormat(&amp;splash-&gt;screenFormat, 0xff &lt;&lt; 8,
223             0xff &lt;&lt; 16, 0xff &lt;&lt; 24, 0xff &lt;&lt; 0);
224     splash-&gt;screenFormat.byteOrder = 1 ?  BYTE_ORDER_LSBFIRST : BYTE_ORDER_MSBFIRST;
225     splash-&gt;screenFormat.depthBytes = 4;
226 
227     // If we are running SWT we should not start a runLoop
228     if (!isSWTRunning()) {
229         [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^() {
230             [NSApplicationAWT runAWTLoopWithApp:[NSApplicationAWT sharedApplication]];
231         }];
232     }
233     return 1;
234 }
235 
236 void
237 SplashCleanupPlatform(Splash * splash) {
238     splash-&gt;maskRequired = 0;
239 }
240 
241 void
242 SplashDonePlatform(Splash * splash) {
243     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
244 
245     pthread_mutex_destroy(&amp;splash-&gt;lock);
246     [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){
247         if (splash-&gt;window) {
248             [splash-&gt;window orderOut:nil];
249             [splash-&gt;window release];
250         }
251     }];
252     [pool drain];
253 }
254 
255 void
256 SplashLock(Splash * splash) {
257     pthread_mutex_lock(&amp;splash-&gt;lock);
258 }
259 
260 void
261 SplashUnlock(Splash * splash) {
262     pthread_mutex_unlock(&amp;splash-&gt;lock);
263 }
264 
265 void
266 SplashInitFrameShape(Splash * splash, int imageIndex) {
267     // No shapes, we rely on alpha compositing
268 }
269 
270 void * SplashScreenThread(void *param);
271 void
272 SplashCreateThread(Splash * splash) {
273     pthread_t thr;
274     pthread_attr_t attr;
275     int rc;
276 
277     pthread_attr_init(&amp;attr);
278     rc = pthread_create(&amp;thr, &amp;attr, SplashScreenThread, (void *) splash);
279 }
280 
281 void
282 SplashRedrawWindow(Splash * splash) {
283     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
284 
285     [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){
286         // drop the reference to the old view and image
287         [splash-&gt;window setContentView: nil];
288         SplashUpdateScreenData(splash);
289 
290         // NSDeviceRGBColorSpace vs. NSCalibratedRGBColorSpace ?
291         NSBitmapImageRep * rep = [[NSBitmapImageRep alloc]
292             initWithBitmapDataPlanes: (unsigned char**)&amp;splash-&gt;screenData
293                           pixelsWide: splash-&gt;width
294                           pixelsHigh: splash-&gt;height
295                        bitsPerSample: 8
296                      samplesPerPixel: 4
297                             hasAlpha: YES
298                             isPlanar: NO
299                       colorSpaceName: NSDeviceRGBColorSpace
300                         bitmapFormat: NSAlphaFirstBitmapFormat | NSAlphaNonpremultipliedBitmapFormat
301                          bytesPerRow: splash-&gt;width * 4
302                         bitsPerPixel: 32];
303 
304         NSImage * image = [[NSImage alloc]
305             initWithSize: NSMakeSize(splash-&gt;width, splash-&gt;height)];
306         [image setBackgroundColor: [NSColor clearColor]];
307 
308         [image addRepresentation: rep];
309         float scaleFactor = splash-&gt;scaleFactor;
310         if (scaleFactor &gt; 0 &amp;&amp; scaleFactor != 1) {
311             NSSize size = [image size];
312             size.width /= scaleFactor;
313             size.height /= scaleFactor;
314             [image setSize: size];
315         }
316 
317         NSImageView * view = [[NSImageView alloc] init];
318 
319         [view setImage: image];
320         [view setEditable: NO];
321         //NOTE: we don&#39;t set a &#39;wait cursor&#39; for the view because:
322         //      1. The Cocoa GUI guidelines suggest to avoid it, and use a progress
323         //         bar instead.
324         //      2. There simply isn&#39;t an instance of NSCursor that represent
325         //         the &#39;wait cursor&#39;. So that is undoable.
326 
327         //TODO: only the first image in an animated gif preserves transparency.
328         //      Loos like the splash-&gt;screenData contains inappropriate data
329         //      for all but the first frame.
330 
331         [image release];
332         [rep release];
333 
334         [splash-&gt;window setContentView: view];
335         [splash-&gt;window orderFrontRegardless];
336     }];
337 
338     [pool drain];
339 }
340 
341 void SplashReconfigureNow(Splash * splash) {
342     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
343 
344     [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){
345         SplashCenter(splash);
346 
347         if (!splash-&gt;window) {
348             return;
349         }
350 
351         [splash-&gt;window orderOut:nil];
352         [splash-&gt;window setFrame: NSMakeRect(splash-&gt;x, splash-&gt;y, splash-&gt;width, splash-&gt;height)
353                          display: NO];
354     }];
355 
356     [pool drain];
357 
358     SplashRedrawWindow(splash);
359 }
360 
361 void
362 SplashEventLoop(Splash * splash) {
363 
364     /* we should have splash _locked_ on entry!!! */
365 
366     while (1) {
367         struct pollfd pfd[1];
368         int timeout = -1;
369         int ctl = splash-&gt;controlpipe[0];
370         int rc;
371         int pipes_empty;
372 
373         pfd[0].fd = ctl;
374         pfd[0].events = POLLIN | POLLPRI;
375 
376         errno = 0;
377         if (splash-&gt;isVisible&gt;0 &amp;&amp; SplashIsStillLooping(splash)) {
378             timeout = splash-&gt;time + splash-&gt;frames[splash-&gt;currentFrame].delay
379                 - SplashTime();
380             if (timeout &lt; 0) {
381                 timeout = 0;
382             }
383         }
384         SplashUnlock(splash);
385         rc = poll(pfd, 1, timeout);
386         SplashLock(splash);
387         if (splash-&gt;isVisible &gt; 0 &amp;&amp; splash-&gt;currentFrame &gt;= 0 &amp;&amp;
388                 SplashTime() &gt;= splash-&gt;time + splash-&gt;frames[splash-&gt;currentFrame].delay) {
389             SplashNextFrame(splash);
390             SplashRedrawWindow(splash);
391         }
392         if (rc &lt;= 0) {
393             errno = 0;
394             continue;
395         }
396         pipes_empty = 0;
397         while(!pipes_empty) {
398             char buf;
399 
400             pipes_empty = 1;
401             if (read(ctl, &amp;buf, sizeof(buf)) &gt; 0) {
402                 pipes_empty = 0;
403                 switch (buf) {
404                 case SPLASHCTL_UPDATE:
405                     if (splash-&gt;isVisible&gt;0) {
406                         SplashRedrawWindow(splash);
407                     }
408                     break;
409                 case SPLASHCTL_RECONFIGURE:
410                     if (splash-&gt;isVisible&gt;0) {
411                         SplashReconfigureNow(splash);
412                     }
413                     break;
414                 case SPLASHCTL_QUIT:
415                     return;
416                 }
417             }
418         }
419     }
420 }
421 
422 void *
423 SplashScreenThread(void *param) {
424     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
425     Splash *splash = (Splash *) param;
426 
427     SplashLock(splash);
428     pipe(splash-&gt;controlpipe);
429     fcntl(splash-&gt;controlpipe[0], F_SETFL,
430         fcntl(splash-&gt;controlpipe[0], F_GETFL, 0) | O_NONBLOCK);
431     splash-&gt;time = SplashTime();
432     splash-&gt;currentFrame = 0;
433     [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){
434         SplashCenter(splash);
435 
436         splash-&gt;window = (void*) [[NSWindow alloc]
437             initWithContentRect: NSMakeRect(splash-&gt;x, splash-&gt;y, splash-&gt;width, splash-&gt;height)
438                       styleMask: NSBorderlessWindowMask
439                         backing: NSBackingStoreBuffered
440                           defer: NO
441                          screen: SplashNSScreen()];
442 
443         [splash-&gt;window setOpaque: NO];
444         [splash-&gt;window setBackgroundColor: [NSColor clearColor]];
445     }];
446     fflush(stdout);
447     if (splash-&gt;window) {
448         [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){
449             [splash-&gt;window orderFrontRegardless];
450         }];
451         SplashRedrawWindow(splash);
452         SplashEventLoop(splash);
453     }
454     SplashUnlock(splash);
455     SplashDone(splash);
456 
457     splash-&gt;isVisible=-1;
458 
459     [pool drain];
460 
461     return 0;
462 }
463 
464 void
465 sendctl(Splash * splash, char code) {
466     if (splash &amp;&amp; splash-&gt;controlpipe[1]) {
467         write(splash-&gt;controlpipe[1], &amp;code, 1);
468     }
469 }
470 
471 void
472 SplashClosePlatform(Splash * splash) {
473     sendctl(splash, SPLASHCTL_QUIT);
474 }
475 
476 void
477 SplashUpdate(Splash * splash) {
478     sendctl(splash, SPLASHCTL_UPDATE);
479 }
480 
481 void
482 SplashReconfigure(Splash * splash) {
483     sendctl(splash, SPLASHCTL_RECONFIGURE);
484 }
485 
486 NSString* findScaledImageName(NSString *fileName, NSUInteger dotIndex, NSString *strToAppend) {
487     NSString *fileName2x = nil;
488     if (dotIndex == NSNotFound) {
489         fileName2x = [fileName stringByAppendingString: strToAppend];
490     } else {
491         fileName2x = [fileName substringToIndex: dotIndex];
492         fileName2x = [fileName2x stringByAppendingString: strToAppend];
493         fileName2x = [fileName2x stringByAppendingString:
494                       [fileName substringFromIndex: dotIndex]];
495     }
496     return fileName2x;
497 }
498 
    </pre>
  </body>
</html>
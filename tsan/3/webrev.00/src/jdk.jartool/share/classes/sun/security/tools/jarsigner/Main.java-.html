<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.tools.jarsigner;
  27 
  28 import java.io.*;
  29 import java.net.UnknownHostException;
  30 import java.security.cert.CertPathValidatorException;
  31 import java.security.cert.PKIXBuilderParameters;
  32 import java.util.*;
  33 import java.util.stream.Collectors;
  34 import java.util.zip.*;
  35 import java.util.jar.*;
  36 import java.net.URI;
  37 import java.text.Collator;
  38 import java.text.MessageFormat;
  39 import java.security.cert.Certificate;
  40 import java.security.cert.X509Certificate;
  41 import java.security.cert.CertificateException;
  42 import java.security.*;
  43 
  44 import java.net.SocketTimeoutException;
  45 import java.net.URL;
  46 import java.security.cert.CertPath;
  47 import java.security.cert.CertificateExpiredException;
  48 import java.security.cert.CertificateFactory;
  49 import java.security.cert.CertificateNotYetValidException;
  50 import java.security.cert.TrustAnchor;
  51 import java.util.Map.Entry;
  52 
  53 import jdk.security.jarsigner.JarSigner;
  54 import jdk.security.jarsigner.JarSignerException;
  55 import sun.security.pkcs.PKCS7;
  56 import sun.security.pkcs.SignerInfo;
  57 import sun.security.timestamp.TimestampToken;
  58 import sun.security.tools.KeyStoreUtil;
  59 import sun.security.validator.Validator;
  60 import sun.security.validator.ValidatorException;
  61 import sun.security.x509.*;
  62 import sun.security.util.*;
  63 
  64 
  65 /**
  66  * &lt;p&gt;The jarsigner utility.
  67  *
  68  * The exit codes for the main method are:
  69  *
  70  * 0: success
  71  * 1: any error that the jar cannot be signed or verified, including:
  72  *      keystore loading error
  73  *      TSP communication error
  74  *      jarsigner command line error...
  75  * otherwise: error codes from -strict
  76  *
  77  * @author Roland Schemers
  78  * @author Jan Luehe
  79  */
  80 public class Main {
  81 
  82     // for i18n
  83     private static final java.util.ResourceBundle rb =
  84         java.util.ResourceBundle.getBundle
  85         (&quot;sun.security.tools.jarsigner.Resources&quot;);
  86     private static final Collator collator = Collator.getInstance();
  87     static {
  88         // this is for case insensitive string comparisions
  89         collator.setStrength(Collator.PRIMARY);
  90     }
  91 
  92     private static final String NONE = &quot;NONE&quot;;
  93     private static final String P11KEYSTORE = &quot;PKCS11&quot;;
  94 
  95     private static final long SIX_MONTHS = 180*24*60*60*1000L; //milliseconds
  96     private static final long ONE_YEAR = 366*24*60*60*1000L;
  97 
  98     private static final DisabledAlgorithmConstraints DISABLED_CHECK =
  99             new DisabledAlgorithmConstraints(
 100                     DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS);
 101 
 102     private static final Set&lt;CryptoPrimitive&gt; DIGEST_PRIMITIVE_SET = Collections
 103             .unmodifiableSet(EnumSet.of(CryptoPrimitive.MESSAGE_DIGEST));
 104     private static final Set&lt;CryptoPrimitive&gt; SIG_PRIMITIVE_SET = Collections
 105             .unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 106 
 107     static final String VERSION = &quot;1.0&quot;;
 108 
 109     static final int IN_KEYSTORE = 0x01;        // signer is in keystore
 110     static final int NOT_ALIAS = 0x04;          // alias list is NOT empty and
 111     // signer is not in alias list
 112     static final int SIGNED_BY_ALIAS = 0x08;    // signer is in alias list
 113 
 114     // Attention:
 115     // This is the entry that get launched by the security tool jarsigner.
 116     public static void main(String args[]) throws Exception {
 117         Main js = new Main();
 118         js.run(args);
 119     }
 120 
 121     X509Certificate[] certChain;    // signer&#39;s cert chain (when composing)
 122     PrivateKey privateKey;          // private key
 123     KeyStore store;                 // the keystore specified by -keystore
 124                                     // or the default keystore, never null
 125 
 126     String keystore; // key store file
 127     boolean nullStream = false; // null keystore input stream (NONE)
 128     boolean token = false; // token-based keystore
 129     String jarfile;  // jar files to sign or verify
 130     String alias;    // alias to sign jar with
 131     List&lt;String&gt; ckaliases = new ArrayList&lt;&gt;(); // aliases in -verify
 132     char[] storepass; // keystore password
 133     boolean protectedPath; // protected authentication path
 134     String storetype; // keystore type
 135     String providerName; // provider name
 136     List&lt;String&gt; providers = null; // list of provider names
 137     List&lt;String&gt; providerClasses = null; // list of provider classes
 138     // arguments for provider constructors
 139     HashMap&lt;String,String&gt; providerArgs = new HashMap&lt;&gt;();
 140     char[] keypass; // private key password
 141     String sigfile; // name of .SF file
 142     String sigalg; // name of signature algorithm
 143     String digestalg; // name of digest algorithm
 144     String signedjar; // output filename
 145     String tsaUrl; // location of the Timestamping Authority
 146     String tsaAlias; // alias for the Timestamping Authority&#39;s certificate
 147     String altCertChain; // file to read alternative cert chain from
 148     String tSAPolicyID;
 149     String tSADigestAlg;
 150     boolean verify = false; // verify the jar
 151     String verbose = null; // verbose output when signing/verifying
 152     boolean showcerts = false; // show certs when verifying
 153     boolean debug = false; // debug
 154     boolean signManifest = true; // &quot;sign&quot; the whole manifest
 155     boolean externalSF = true; // leave the .SF out of the PKCS7 block
 156     boolean strict = false;  // treat warnings as error
 157 
 158     // read zip entry raw bytes
 159     private String altSignerClass = null;
 160     private String altSignerClasspath = null;
 161     private ZipFile zipFile = null;
 162 
 163     // Informational warnings
 164     private boolean hasExpiringCert = false;
 165     private boolean hasExpiringTsaCert = false;
 166     private boolean noTimestamp = true;
 167 
 168     // Expiration date. The value could be null if signed by a trusted cert.
 169     private Date expireDate = null;
 170     private Date tsaExpireDate = null;
 171 
 172     // If there is a time stamp block inside the PKCS7 block file
 173     boolean hasTimestampBlock = false;
 174 
 175 
 176     // Severe warnings.
 177 
 178     // jarsigner used to check signer cert chain validity and key usages
 179     // itself and set various warnings. Later CertPath validation is
 180     // added but chainNotValidated is only flagged when no other existing
 181     // warnings are set. TSA cert chain check is added separately and
 182     // only tsaChainNotValidated is set, i.e. has no affect on hasExpiredCert,
 183     // notYetValidCert, or any badXyzUsage.
 184 
 185     private int weakAlg = 0; // 1. digestalg, 2. sigalg, 4. tsadigestalg
 186     private boolean hasExpiredCert = false;
 187     private boolean hasExpiredTsaCert = false;
 188     private boolean notYetValidCert = false;
 189     private boolean chainNotValidated = false;
 190     private boolean tsaChainNotValidated = false;
 191     private boolean notSignedByAlias = false;
 192     private boolean aliasNotInStore = false;
 193     private boolean hasUnsignedEntry = false;
 194     private boolean badKeyUsage = false;
 195     private boolean badExtendedKeyUsage = false;
 196     private boolean badNetscapeCertType = false;
 197     private boolean signerSelfSigned = false;
 198 
 199     private Throwable chainNotValidatedReason = null;
 200     private Throwable tsaChainNotValidatedReason = null;
 201 
 202     private boolean seeWeak = false;
 203 
 204     PKIXBuilderParameters pkixParameters;
 205     Set&lt;X509Certificate&gt; trustedCerts = new HashSet&lt;&gt;();
 206 
 207     public void run(String args[]) {
 208         try {
 209             args = parseArgs(args);
 210 
 211             // Try to load and install the specified providers
 212             if (providers != null) {
 213                 for (String provName: providers) {
 214                     try {
 215                         KeyStoreUtil.loadProviderByName(provName,
 216                                 providerArgs.get(provName));
 217                         if (debug) {
 218                             System.out.println(&quot;loadProviderByName: &quot; + provName);
 219                         }
 220                     } catch (IllegalArgumentException e) {
 221                         throw new Exception(String.format(rb.getString(
 222                                 &quot;provider.name.not.found&quot;), provName));
 223                     }
 224                 }
 225             }
 226 
 227             if (providerClasses != null) {
 228                 ClassLoader cl = ClassLoader.getSystemClassLoader();
 229                 for (String provClass: providerClasses) {
 230                     try {
 231                         KeyStoreUtil.loadProviderByClass(provClass,
 232                                 providerArgs.get(provClass), cl);
 233                         if (debug) {
 234                             System.out.println(&quot;loadProviderByClass: &quot; + provClass);
 235                         }
 236                     } catch (ClassCastException cce) {
 237                         throw new Exception(String.format(rb.getString(
 238                                 &quot;provclass.not.a.provider&quot;), provClass));
 239                     } catch (IllegalArgumentException e) {
 240                         throw new Exception(String.format(rb.getString(
 241                                 &quot;provider.class.not.found&quot;), provClass), e.getCause());
 242                     }
 243                 }
 244             }
 245 
 246             if (verify) {
 247                 try {
 248                     loadKeyStore(keystore, false);
 249                 } catch (Exception e) {
 250                     if ((keystore != null) || (storepass != null)) {
 251                         System.out.println(rb.getString(&quot;jarsigner.error.&quot;) +
 252                                         e.getMessage());
 253                         if (debug) {
 254                             e.printStackTrace();
 255                         }
 256                         System.exit(1);
 257                     }
 258                 }
 259                 /*              if (debug) {
 260                     SignatureFileVerifier.setDebug(true);
 261                     ManifestEntryVerifier.setDebug(true);
 262                 }
 263                 */
 264                 verifyJar(jarfile);
 265             } else {
 266                 loadKeyStore(keystore, true);
 267                 getAliasInfo(alias);
 268 
 269                 signJar(jarfile, alias);
 270             }
 271         } catch (Exception e) {
 272             System.out.println(rb.getString(&quot;jarsigner.error.&quot;) + e);
 273             if (debug) {
 274                 e.printStackTrace();
 275             }
 276             System.exit(1);
 277         } finally {
 278             // zero-out private key password
 279             if (keypass != null) {
 280                 Arrays.fill(keypass, &#39; &#39;);
 281                 keypass = null;
 282             }
 283             // zero-out keystore password
 284             if (storepass != null) {
 285                 Arrays.fill(storepass, &#39; &#39;);
 286                 storepass = null;
 287             }
 288         }
 289 
 290         if (strict) {
 291             int exitCode = 0;
 292             if (weakAlg != 0 || chainNotValidated || hasExpiredCert
 293                     || hasExpiredTsaCert || notYetValidCert || signerSelfSigned) {
 294                 exitCode |= 4;
 295             }
 296             if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType) {
 297                 exitCode |= 8;
 298             }
 299             if (hasUnsignedEntry) {
 300                 exitCode |= 16;
 301             }
 302             if (notSignedByAlias || aliasNotInStore) {
 303                 exitCode |= 32;
 304             }
 305             if (tsaChainNotValidated) {
 306                 exitCode |= 64;
 307             }
 308             if (exitCode != 0) {
 309                 System.exit(exitCode);
 310             }
 311         }
 312     }
 313 
 314     /*
 315      * Parse command line arguments.
 316      */
 317     String[] parseArgs(String args[]) throws Exception {
 318         /* parse flags */
 319         int n = 0;
 320 
 321         if (args.length == 0) fullusage();
 322 
 323         String confFile = null;
 324         String command = &quot;-sign&quot;;
 325         for (n=0; n &lt; args.length; n++) {
 326             if (collator.compare(args[n], &quot;-verify&quot;) == 0) {
 327                 command = &quot;-verify&quot;;
 328             } else if (collator.compare(args[n], &quot;-conf&quot;) == 0) {
 329                 if (n == args.length - 1) {
 330                     usageNoArg();
 331                 }
 332                 confFile = args[++n];
 333             }
 334         }
 335 
 336         if (confFile != null) {
 337             args = KeyStoreUtil.expandArgs(
 338                     &quot;jarsigner&quot;, confFile, command, null, args);
 339         }
 340 
 341         debug = Arrays.stream(args).anyMatch(
 342                 x -&gt; collator.compare(x, &quot;-debug&quot;) == 0);
 343 
 344         if (debug) {
 345             // No need to localize debug output
 346             System.out.println(&quot;Command line args: &quot; +
 347                     Arrays.toString(args));
 348         }
 349 
 350         for (n=0; n &lt; args.length; n++) {
 351 
 352             String flags = args[n];
 353             String modifier = null;
 354 
 355             if (flags.startsWith(&quot;-&quot;)) {
 356                 int pos = flags.indexOf(&#39;:&#39;);
 357                 if (pos &gt; 0) {
 358                     modifier = flags.substring(pos+1);
 359                     flags = flags.substring(0, pos);
 360                 }
 361             }
 362 
 363             if (!flags.startsWith(&quot;-&quot;)) {
 364                 if (jarfile == null) {
 365                     jarfile = flags;
 366                 } else {
 367                     alias = flags;
 368                     ckaliases.add(alias);
 369                 }
 370             } else if (collator.compare(flags, &quot;-conf&quot;) == 0) {
 371                 if (++n == args.length) usageNoArg();
 372             } else if (collator.compare(flags, &quot;-keystore&quot;) == 0) {
 373                 if (++n == args.length) usageNoArg();
 374                 keystore = args[n];
 375             } else if (collator.compare(flags, &quot;-storepass&quot;) ==0) {
 376                 if (++n == args.length) usageNoArg();
 377                 storepass = getPass(modifier, args[n]);
 378             } else if (collator.compare(flags, &quot;-storetype&quot;) ==0) {
 379                 if (++n == args.length) usageNoArg();
 380                 storetype = args[n];
 381             } else if (collator.compare(flags, &quot;-providerName&quot;) ==0) {
 382                 if (++n == args.length) usageNoArg();
 383                 providerName = args[n];
 384             } else if (collator.compare(flags, &quot;-provider&quot;) == 0 ||
 385                         collator.compare(flags, &quot;-providerClass&quot;) == 0) {
 386                 if (++n == args.length) usageNoArg();
 387                 if (providerClasses == null) {
 388                     providerClasses = new ArrayList&lt;&gt;(3);
 389                 }
 390                 providerClasses.add(args[n]);
 391 
 392                 if (args.length &gt; (n+1)) {
 393                     flags = args[n+1];
 394                     if (collator.compare(flags, &quot;-providerArg&quot;) == 0) {
 395                         if (args.length == (n+2)) usageNoArg();
 396                         providerArgs.put(args[n], args[n+2]);
 397                         n += 2;
 398                     }
 399                 }
 400             } else if (collator.compare(flags, &quot;-addprovider&quot;) == 0) {
 401                 if (++n == args.length) usageNoArg();
 402                 if (providers == null) {
 403                     providers = new ArrayList&lt;&gt;(3);
 404                 }
 405                 providers.add(args[n]);
 406 
 407                 if (args.length &gt; (n+1)) {
 408                     flags = args[n+1];
 409                     if (collator.compare(flags, &quot;-providerArg&quot;) == 0) {
 410                         if (args.length == (n+2)) usageNoArg();
 411                         providerArgs.put(args[n], args[n+2]);
 412                         n += 2;
 413                     }
 414                 }
 415             } else if (collator.compare(flags, &quot;-protected&quot;) ==0) {
 416                 protectedPath = true;
 417             } else if (collator.compare(flags, &quot;-certchain&quot;) ==0) {
 418                 if (++n == args.length) usageNoArg();
 419                 altCertChain = args[n];
 420             } else if (collator.compare(flags, &quot;-tsapolicyid&quot;) ==0) {
 421                 if (++n == args.length) usageNoArg();
 422                 tSAPolicyID = args[n];
 423             } else if (collator.compare(flags, &quot;-tsadigestalg&quot;) ==0) {
 424                 if (++n == args.length) usageNoArg();
 425                 tSADigestAlg = args[n];
 426             } else if (collator.compare(flags, &quot;-debug&quot;) ==0) {
 427                 // Already processed
 428             } else if (collator.compare(flags, &quot;-keypass&quot;) ==0) {
 429                 if (++n == args.length) usageNoArg();
 430                 keypass = getPass(modifier, args[n]);
 431             } else if (collator.compare(flags, &quot;-sigfile&quot;) ==0) {
 432                 if (++n == args.length) usageNoArg();
 433                 sigfile = args[n];
 434             } else if (collator.compare(flags, &quot;-signedjar&quot;) ==0) {
 435                 if (++n == args.length) usageNoArg();
 436                 signedjar = args[n];
 437             } else if (collator.compare(flags, &quot;-tsa&quot;) ==0) {
 438                 if (++n == args.length) usageNoArg();
 439                 tsaUrl = args[n];
 440             } else if (collator.compare(flags, &quot;-tsacert&quot;) ==0) {
 441                 if (++n == args.length) usageNoArg();
 442                 tsaAlias = args[n];
 443             } else if (collator.compare(flags, &quot;-altsigner&quot;) ==0) {
 444                 if (++n == args.length) usageNoArg();
 445                 altSignerClass = args[n];
 446                 System.err.println(
 447                         rb.getString(&quot;This.option.is.deprecated&quot;) +
 448                                 &quot;-altsigner&quot;);
 449             } else if (collator.compare(flags, &quot;-altsignerpath&quot;) ==0) {
 450                 if (++n == args.length) usageNoArg();
 451                 altSignerClasspath = args[n];
 452                 System.err.println(
 453                         rb.getString(&quot;This.option.is.deprecated&quot;) +
 454                                 &quot;-altsignerpath&quot;);
 455             } else if (collator.compare(flags, &quot;-sectionsonly&quot;) ==0) {
 456                 signManifest = false;
 457             } else if (collator.compare(flags, &quot;-internalsf&quot;) ==0) {
 458                 externalSF = false;
 459             } else if (collator.compare(flags, &quot;-verify&quot;) ==0) {
 460                 verify = true;
 461             } else if (collator.compare(flags, &quot;-verbose&quot;) ==0) {
 462                 verbose = (modifier != null) ? modifier : &quot;all&quot;;
 463             } else if (collator.compare(flags, &quot;-sigalg&quot;) ==0) {
 464                 if (++n == args.length) usageNoArg();
 465                 sigalg = args[n];
 466             } else if (collator.compare(flags, &quot;-digestalg&quot;) ==0) {
 467                 if (++n == args.length) usageNoArg();
 468                 digestalg = args[n];
 469             } else if (collator.compare(flags, &quot;-certs&quot;) ==0) {
 470                 showcerts = true;
 471             } else if (collator.compare(flags, &quot;-strict&quot;) ==0) {
 472                 strict = true;
 473             } else if (collator.compare(flags, &quot;-?&quot;) == 0 ||
 474                        collator.compare(flags, &quot;-h&quot;) == 0 ||
 475                        collator.compare(flags, &quot;--help&quot;) == 0 ||
 476                        // -help: legacy.
 477                        collator.compare(flags, &quot;-help&quot;) == 0) {
 478                 fullusage();
 479             } else {
 480                 System.err.println(
 481                         rb.getString(&quot;Illegal.option.&quot;) + flags);
 482                 usage();
 483             }
 484         }
 485 
 486         // -certs must always be specified with -verbose
 487         if (verbose == null) showcerts = false;
 488 
 489         if (jarfile == null) {
 490             System.err.println(rb.getString(&quot;Please.specify.jarfile.name&quot;));
 491             usage();
 492         }
 493         if (!verify &amp;&amp; alias == null) {
 494             System.err.println(rb.getString(&quot;Please.specify.alias.name&quot;));
 495             usage();
 496         }
 497         if (!verify &amp;&amp; ckaliases.size() &gt; 1) {
 498             System.err.println(rb.getString(&quot;Only.one.alias.can.be.specified&quot;));
 499             usage();
 500         }
 501 
 502         if (storetype == null) {
 503             storetype = KeyStore.getDefaultType();
 504         }
 505         storetype = KeyStoreUtil.niceStoreTypeName(storetype);
 506 
 507         try {
 508             if (signedjar != null &amp;&amp; new File(signedjar).getCanonicalPath().equals(
 509                     new File(jarfile).getCanonicalPath())) {
 510                 signedjar = null;
 511             }
 512         } catch (IOException ioe) {
 513             // File system error?
 514             // Just ignore it.
 515         }
 516 
 517         if (P11KEYSTORE.equalsIgnoreCase(storetype) ||
 518                 KeyStoreUtil.isWindowsKeyStore(storetype)) {
 519             token = true;
 520             if (keystore == null) {
 521                 keystore = NONE;
 522             }
 523         }
 524 
 525         if (NONE.equals(keystore)) {
 526             nullStream = true;
 527         }
 528 
 529         if (token &amp;&amp; !nullStream) {
 530             System.err.println(MessageFormat.format(rb.getString
 531                 (&quot;.keystore.must.be.NONE.if.storetype.is.{0}&quot;), storetype));
 532             usage();
 533         }
 534 
 535         if (token &amp;&amp; keypass != null) {
 536             System.err.println(MessageFormat.format(rb.getString
 537                 (&quot;.keypass.can.not.be.specified.if.storetype.is.{0}&quot;), storetype));
 538             usage();
 539         }
 540 
 541         if (protectedPath) {
 542             if (storepass != null || keypass != null) {
 543                 System.err.println(rb.getString
 544                         (&quot;If.protected.is.specified.then.storepass.and.keypass.must.not.be.specified&quot;));
 545                 usage();
 546             }
 547         }
 548         if (KeyStoreUtil.isWindowsKeyStore(storetype)) {
 549             if (storepass != null || keypass != null) {
 550                 System.err.println(rb.getString
 551                         (&quot;If.keystore.is.not.password.protected.then.storepass.and.keypass.must.not.be.specified&quot;));
 552                 usage();
 553             }
 554         }
 555         return args;
 556     }
 557 
 558     static char[] getPass(String modifier, String arg) {
 559         char[] output = KeyStoreUtil.getPassWithModifier(modifier, arg, rb);
 560         if (output != null) return output;
 561         usage();
 562         return null;    // Useless, usage() already exit
 563     }
 564 
 565     static void usageNoArg() {
 566         System.out.println(rb.getString(&quot;Option.lacks.argument&quot;));
 567         usage();
 568     }
 569 
 570     static void usage() {
 571         System.out.println();
 572         System.out.println(rb.getString(&quot;Please.type.jarsigner.help.for.usage&quot;));
 573         System.exit(1);
 574     }
 575 
 576     static void fullusage() {
 577         System.out.println(rb.getString
 578                 (&quot;Usage.jarsigner.options.jar.file.alias&quot;));
 579         System.out.println(rb.getString
 580                 (&quot;.jarsigner.verify.options.jar.file.alias.&quot;));
 581         System.out.println();
 582         System.out.println(rb.getString
 583                 (&quot;.keystore.url.keystore.location&quot;));
 584         System.out.println();
 585         System.out.println(rb.getString
 586                 (&quot;.storepass.password.password.for.keystore.integrity&quot;));
 587         System.out.println();
 588         System.out.println(rb.getString
 589                 (&quot;.storetype.type.keystore.type&quot;));
 590         System.out.println();
 591         System.out.println(rb.getString
 592                 (&quot;.keypass.password.password.for.private.key.if.different.&quot;));
 593         System.out.println();
 594         System.out.println(rb.getString
 595                 (&quot;.certchain.file.name.of.alternative.certchain.file&quot;));
 596         System.out.println();
 597         System.out.println(rb.getString
 598                 (&quot;.sigfile.file.name.of.SF.DSA.file&quot;));
 599         System.out.println();
 600         System.out.println(rb.getString
 601                 (&quot;.signedjar.file.name.of.signed.JAR.file&quot;));
 602         System.out.println();
 603         System.out.println(rb.getString
 604                 (&quot;.digestalg.algorithm.name.of.digest.algorithm&quot;));
 605         System.out.println();
 606         System.out.println(rb.getString
 607                 (&quot;.sigalg.algorithm.name.of.signature.algorithm&quot;));
 608         System.out.println();
 609         System.out.println(rb.getString
 610                 (&quot;.verify.verify.a.signed.JAR.file&quot;));
 611         System.out.println();
 612         System.out.println(rb.getString
 613                 (&quot;.verbose.suboptions.verbose.output.when.signing.verifying.&quot;));
 614         System.out.println(rb.getString
 615                 (&quot;.suboptions.can.be.all.grouped.or.summary&quot;));
 616         System.out.println();
 617         System.out.println(rb.getString
 618                 (&quot;.certs.display.certificates.when.verbose.and.verifying&quot;));
 619         System.out.println();
 620         System.out.println(rb.getString
 621                 (&quot;.tsa.url.location.of.the.Timestamping.Authority&quot;));
 622         System.out.println();
 623         System.out.println(rb.getString
 624                 (&quot;.tsacert.alias.public.key.certificate.for.Timestamping.Authority&quot;));
 625         System.out.println();
 626         System.out.println(rb.getString
 627                 (&quot;.tsapolicyid.tsapolicyid.for.Timestamping.Authority&quot;));
 628         System.out.println();
 629         System.out.println(rb.getString
 630                 (&quot;.tsadigestalg.algorithm.of.digest.data.in.timestamping.request&quot;));
 631         System.out.println();
 632         System.out.println(rb.getString
 633                 (&quot;.altsigner.class.class.name.of.an.alternative.signing.mechanism&quot;));
 634         System.out.println();
 635         System.out.println(rb.getString
 636                 (&quot;.altsignerpath.pathlist.location.of.an.alternative.signing.mechanism&quot;));
 637         System.out.println();
 638         System.out.println(rb.getString
 639                 (&quot;.internalsf.include.the.SF.file.inside.the.signature.block&quot;));
 640         System.out.println();
 641         System.out.println(rb.getString
 642                 (&quot;.sectionsonly.don.t.compute.hash.of.entire.manifest&quot;));
 643         System.out.println();
 644         System.out.println(rb.getString
 645                 (&quot;.protected.keystore.has.protected.authentication.path&quot;));
 646         System.out.println();
 647         System.out.println(rb.getString
 648                 (&quot;.providerName.name.provider.name&quot;));
 649         System.out.println();
 650         System.out.println(rb.getString
 651                 (&quot;.add.provider.option&quot;));
 652         System.out.println(rb.getString
 653                 (&quot;.providerArg.option.1&quot;));
 654         System.out.println();
 655         System.out.println(rb.getString
 656                 (&quot;.providerClass.option&quot;));
 657         System.out.println(rb.getString
 658                 (&quot;.providerArg.option.2&quot;));
 659         System.out.println();
 660         System.out.println(rb.getString
 661                 (&quot;.strict.treat.warnings.as.errors&quot;));
 662         System.out.println();
 663         System.out.println(rb.getString
 664                 (&quot;.conf.url.specify.a.pre.configured.options.file&quot;));
 665         System.out.println();
 666         System.out.println(rb.getString
 667                 (&quot;.print.this.help.message&quot;));
 668         System.out.println();
 669 
 670         System.exit(0);
 671     }
 672 
 673     void verifyJar(String jarName)
 674         throws Exception
 675     {
 676         boolean anySigned = false;  // if there exists entry inside jar signed
 677         JarFile jf = null;
 678         Map&lt;String,String&gt; digestMap = new HashMap&lt;&gt;();
 679         Map&lt;String,PKCS7&gt; sigMap = new HashMap&lt;&gt;();
 680         Map&lt;String,String&gt; sigNameMap = new HashMap&lt;&gt;();
 681         Map&lt;String,String&gt; unparsableSignatures = new HashMap&lt;&gt;();
 682 
 683         try {
 684             jf = new JarFile(jarName, true);
 685             Vector&lt;JarEntry&gt; entriesVec = new Vector&lt;&gt;();
 686             byte[] buffer = new byte[8192];
 687 
 688             Enumeration&lt;JarEntry&gt; entries = jf.entries();
 689             while (entries.hasMoreElements()) {
 690                 JarEntry je = entries.nextElement();
 691                 entriesVec.addElement(je);
 692                 try (InputStream is = jf.getInputStream(je)) {
 693                     String name = je.getName();
 694                     if (signatureRelated(name)
 695                             &amp;&amp; SignatureFileVerifier.isBlockOrSF(name)) {
 696                         String alias = name.substring(name.lastIndexOf(&#39;/&#39;) + 1,
 697                                 name.lastIndexOf(&#39;.&#39;));
 698                         try {
 699                             if (name.endsWith(&quot;.SF&quot;)) {
 700                                 Manifest sf = new Manifest(is);
 701                                 boolean found = false;
 702                                 for (Object obj : sf.getMainAttributes().keySet()) {
 703                                     String key = obj.toString();
 704                                     if (key.endsWith(&quot;-Digest-Manifest&quot;)) {
 705                                         digestMap.put(alias,
 706                                                 key.substring(0, key.length() - 16));
 707                                         found = true;
 708                                         break;
 709                                     }
 710                                 }
 711                                 if (!found) {
 712                                     unparsableSignatures.putIfAbsent(alias,
 713                                         String.format(
 714                                             rb.getString(&quot;history.unparsable&quot;),
 715                                             name));
 716                                 }
 717                             } else {
 718                                 sigNameMap.put(alias, name);
 719                                 sigMap.put(alias, new PKCS7(is));
 720                             }
 721                         } catch (IOException ioe) {
 722                             unparsableSignatures.putIfAbsent(alias, String.format(
 723                                     rb.getString(&quot;history.unparsable&quot;), name));
 724                         }
 725                     } else {
 726                         while (is.read(buffer, 0, buffer.length) != -1) {
 727                             // we just read. this will throw a SecurityException
 728                             // if  a signature/digest check fails.
 729                         }
 730                     }
 731                 }
 732             }
 733 
 734             Manifest man = jf.getManifest();
 735             boolean hasSignature = false;
 736 
 737             // The map to record display info, only used when -verbose provided
 738             //      key: signer info string
 739             //      value: the list of files with common key
 740             Map&lt;String,List&lt;String&gt;&gt; output = new LinkedHashMap&lt;&gt;();
 741 
 742             if (man != null) {
 743                 if (verbose != null) System.out.println();
 744                 Enumeration&lt;JarEntry&gt; e = entriesVec.elements();
 745 
 746                 String tab = rb.getString(&quot;6SPACE&quot;);
 747 
 748                 while (e.hasMoreElements()) {
 749                     JarEntry je = e.nextElement();
 750                     String name = je.getName();
 751 
 752                     hasSignature = hasSignature
 753                             || SignatureFileVerifier.isBlockOrSF(name);
 754 
 755                     CodeSigner[] signers = je.getCodeSigners();
 756                     boolean isSigned = (signers != null);
 757                     anySigned |= isSigned;
 758                     hasUnsignedEntry |= !je.isDirectory() &amp;&amp; !isSigned
 759                                         &amp;&amp; !signatureRelated(name);
 760 
 761                     int inStoreWithAlias = inKeyStore(signers);
 762 
 763                     boolean inStore = (inStoreWithAlias &amp; IN_KEYSTORE) != 0;
 764 
 765                     notSignedByAlias |= (inStoreWithAlias &amp; NOT_ALIAS) != 0;
 766                     if (keystore != null) {
 767                         aliasNotInStore |= isSigned &amp;&amp; !inStore;
 768                     }
 769 
 770                     // Only used when -verbose provided
 771                     StringBuffer sb = null;
 772                     if (verbose != null) {
 773                         sb = new StringBuffer();
 774                         boolean inManifest =
 775                             ((man.getAttributes(name) != null) ||
 776                              (man.getAttributes(&quot;./&quot;+name) != null) ||
 777                              (man.getAttributes(&quot;/&quot;+name) != null));
 778                         sb.append(isSigned ? rb.getString(&quot;s&quot;) : rb.getString(&quot;SPACE&quot;))
 779                                 .append(inManifest ? rb.getString(&quot;m&quot;) : rb.getString(&quot;SPACE&quot;))
 780                                 .append(inStore ? rb.getString(&quot;k&quot;) : rb.getString(&quot;SPACE&quot;))
 781                                 .append((inStoreWithAlias &amp; NOT_ALIAS) != 0 ? &#39;X&#39; : &#39; &#39;)
 782                                 .append(rb.getString(&quot;SPACE&quot;));
 783                         sb.append(&#39;|&#39;);
 784                     }
 785 
 786                     // When -certs provided, display info has extra empty
 787                     // lines at the beginning and end.
 788                     if (isSigned) {
 789                         if (showcerts) sb.append(&#39;\n&#39;);
 790                         for (CodeSigner signer: signers) {
 791                             // signerInfo() must be called even if -verbose
 792                             // not provided. The method updates various
 793                             // warning flags.
 794                             String si = signerInfo(signer, tab);
 795                             if (showcerts) {
 796                                 sb.append(si);
 797                                 sb.append(&#39;\n&#39;);
 798                             }
 799                         }
 800                     } else if (showcerts &amp;&amp; !verbose.equals(&quot;all&quot;)) {
 801                         // Print no info for unsigned entries when -verbose:all,
 802                         // to be consistent with old behavior.
 803                         if (signatureRelated(name)) {
 804                             sb.append(&#39;\n&#39;)
 805                                     .append(tab)
 806                                     .append(rb
 807                                             .getString(&quot;.Signature.related.entries.&quot;))
 808                                     .append(&quot;\n\n&quot;);
 809                         } else {
 810                             sb.append(&#39;\n&#39;).append(tab)
 811                                     .append(rb.getString(&quot;.Unsigned.entries.&quot;))
 812                                     .append(&quot;\n\n&quot;);
 813                         }
 814                     }
 815 
 816                     if (verbose != null) {
 817                         String label = sb.toString();
 818                         if (signatureRelated(name)) {
 819                             // Entries inside META-INF and other unsigned
 820                             // entries are grouped separately.
 821                             label = &quot;-&quot; + label;
 822                         }
 823 
 824                         // The label finally contains 2 parts separated by &#39;|&#39;:
 825                         // The legend displayed before the entry names, and
 826                         // the cert info (if -certs specified).
 827 
 828                         if (!output.containsKey(label)) {
 829                             output.put(label, new ArrayList&lt;String&gt;());
 830                         }
 831 
 832                         StringBuilder fb = new StringBuilder();
 833                         String s = Long.toString(je.getSize());
 834                         for (int i = 6 - s.length(); i &gt; 0; --i) {
 835                             fb.append(&#39; &#39;);
 836                         }
 837                         fb.append(s).append(&#39; &#39;).
 838                                 append(new Date(je.getTime()).toString());
 839                         fb.append(&#39; &#39;).append(name);
 840 
 841                         output.get(label).add(fb.toString());
 842                     }
 843                 }
 844             }
 845             if (verbose != null) {
 846                 for (Entry&lt;String,List&lt;String&gt;&gt; s: output.entrySet()) {
 847                     List&lt;String&gt; files = s.getValue();
 848                     String key = s.getKey();
 849                     if (key.charAt(0) == &#39;-&#39;) { // the signature-related group
 850                         key = key.substring(1);
 851                     }
 852                     int pipe = key.indexOf(&#39;|&#39;);
 853                     if (verbose.equals(&quot;all&quot;)) {
 854                         for (String f: files) {
 855                             System.out.println(key.substring(0, pipe) + f);
 856                             System.out.printf(key.substring(pipe+1));
 857                         }
 858                     } else {
 859                         if (verbose.equals(&quot;grouped&quot;)) {
 860                             for (String f: files) {
 861                                 System.out.println(key.substring(0, pipe) + f);
 862                             }
 863                         } else if (verbose.equals(&quot;summary&quot;)) {
 864                             System.out.print(key.substring(0, pipe));
 865                             if (files.size() &gt; 1) {
 866                                 System.out.println(files.get(0) + &quot; &quot; +
 867                                         String.format(rb.getString(
 868                                         &quot;.and.d.more.&quot;), files.size()-1));
 869                             } else {
 870                                 System.out.println(files.get(0));
 871                             }
 872                         }
 873                         System.out.printf(key.substring(pipe+1));
 874                     }
 875                 }
 876                 System.out.println();
 877                 System.out.println(rb.getString(
 878                     &quot;.s.signature.was.verified.&quot;));
 879                 System.out.println(rb.getString(
 880                     &quot;.m.entry.is.listed.in.manifest&quot;));
 881                 System.out.println(rb.getString(
 882                     &quot;.k.at.least.one.certificate.was.found.in.keystore&quot;));
 883                 if (ckaliases.size() &gt; 0) {
 884                     System.out.println(rb.getString(
 885                         &quot;.X.not.signed.by.specified.alias.es.&quot;));
 886                 }
 887             }
 888             if (man == null) {
 889                 System.out.println();
 890                 System.out.println(rb.getString(&quot;no.manifest.&quot;));
 891             }
 892 
 893             // If signer is a trusted cert or private entry in user&#39;s own
 894             // keystore, it can be self-signed. Please note aliasNotInStore
 895             // is always false when ~/.keystore is used.
 896             if (!aliasNotInStore &amp;&amp; keystore != null) {
 897                 signerSelfSigned = false;
 898             }
 899 
 900             // Even if the verbose option is not specified, all out strings
 901             // must be generated so seeWeak can be updated.
 902             if (!digestMap.isEmpty()
 903                     || !sigMap.isEmpty()
 904                     || !unparsableSignatures.isEmpty()) {
 905                 if (verbose != null) {
 906                     System.out.println();
 907                 }
 908                 for (String s : sigMap.keySet()) {
 909                     if (!digestMap.containsKey(s)) {
 910                         unparsableSignatures.putIfAbsent(s, String.format(
 911                                 rb.getString(&quot;history.nosf&quot;), s));
 912                     }
 913                 }
 914                 for (String s : digestMap.keySet()) {
 915                     PKCS7 p7 = sigMap.get(s);
 916                     if (p7 != null) {
 917                         String history;
 918                         try {
 919                             SignerInfo si = p7.getSignerInfos()[0];
 920                             X509Certificate signer = si.getCertificate(p7);
 921                             String digestAlg = digestMap.get(s);
 922                             String sigAlg = AlgorithmId.makeSigAlg(
 923                                     si.getDigestAlgorithmId().getName(),
 924                                     si.getDigestEncryptionAlgorithmId().getName());
 925                             PublicKey key = signer.getPublicKey();
 926                             PKCS7 tsToken = si.getTsToken();
 927                             if (tsToken != null) {
 928                                 hasTimestampBlock = true;
 929                                 SignerInfo tsSi = tsToken.getSignerInfos()[0];
 930                                 X509Certificate tsSigner = tsSi.getCertificate(tsToken);
 931                                 byte[] encTsTokenInfo = tsToken.getContentInfo().getData();
 932                                 TimestampToken tsTokenInfo = new TimestampToken(encTsTokenInfo);
 933                                 PublicKey tsKey = tsSigner.getPublicKey();
 934                                 String tsDigestAlg = tsTokenInfo.getHashAlgorithm().getName();
 935                                 String tsSigAlg = AlgorithmId.makeSigAlg(
 936                                         tsSi.getDigestAlgorithmId().getName(),
 937                                         tsSi.getDigestEncryptionAlgorithmId().getName());
 938                                 Calendar c = Calendar.getInstance(
 939                                         TimeZone.getTimeZone(&quot;UTC&quot;),
 940                                         Locale.getDefault(Locale.Category.FORMAT));
 941                                 c.setTime(tsTokenInfo.getDate());
 942                                 history = String.format(
 943                                         rb.getString(&quot;history.with.ts&quot;),
 944                                         signer.getSubjectX500Principal(),
 945                                         withWeak(digestAlg, DIGEST_PRIMITIVE_SET),
 946                                         withWeak(sigAlg, SIG_PRIMITIVE_SET),
 947                                         withWeak(key),
 948                                         c,
 949                                         tsSigner.getSubjectX500Principal(),
 950                                         withWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET),
 951                                         withWeak(tsSigAlg, SIG_PRIMITIVE_SET),
 952                                         withWeak(tsKey));
 953                             } else {
 954                                 history = String.format(
 955                                         rb.getString(&quot;history.without.ts&quot;),
 956                                         signer.getSubjectX500Principal(),
 957                                         withWeak(digestAlg, DIGEST_PRIMITIVE_SET),
 958                                         withWeak(sigAlg, SIG_PRIMITIVE_SET),
 959                                         withWeak(key));
 960                             }
 961                         } catch (Exception e) {
 962                             // The only usage of sigNameMap, remember the name
 963                             // of the block file if it&#39;s invalid.
 964                             history = String.format(
 965                                     rb.getString(&quot;history.unparsable&quot;),
 966                                     sigNameMap.get(s));
 967                         }
 968                         if (verbose != null) {
 969                             System.out.println(history);
 970                         }
 971                     } else {
 972                         unparsableSignatures.putIfAbsent(s, String.format(
 973                                 rb.getString(&quot;history.nobk&quot;), s));
 974                     }
 975                 }
 976                 if (verbose != null) {
 977                     for (String s : unparsableSignatures.keySet()) {
 978                         System.out.println(unparsableSignatures.get(s));
 979                     }
 980                 }
 981             }
 982             System.out.println();
 983             if (!anySigned) {
 984                 if (seeWeak) {
 985                     if (verbose != null) {
 986                         System.out.println(rb.getString(&quot;jar.treated.unsigned.see.weak.verbose&quot;));
 987                         System.out.println(&quot;\n  &quot; +
 988                                 DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS +
 989                                 &quot;=&quot; + Security.getProperty(DisabledAlgorithmConstraints.PROPERTY_JAR_DISABLED_ALGS));
 990                     } else {
 991                         System.out.println(rb.getString(&quot;jar.treated.unsigned.see.weak&quot;));
 992                     }
 993                 } else if (hasSignature) {
 994                     System.out.println(rb.getString(&quot;jar.treated.unsigned&quot;));
 995                 } else {
 996                     System.out.println(rb.getString(&quot;jar.is.unsigned&quot;));
 997                 }
 998             } else {
 999                 displayMessagesAndResult(false);
1000             }
1001             return;
1002         } catch (Exception e) {
1003             System.out.println(rb.getString(&quot;jarsigner.&quot;) + e);
1004             if (debug) {
1005                 e.printStackTrace();
1006             }
1007         } finally { // close the resource
1008             if (jf != null) {
1009                 jf.close();
1010             }
1011         }
1012 
1013         System.exit(1);
1014     }
1015 
1016     private void displayMessagesAndResult(boolean isSigning) {
1017         String result;
1018         List&lt;String&gt; errors = new ArrayList&lt;&gt;();
1019         List&lt;String&gt; warnings = new ArrayList&lt;&gt;();
1020         List&lt;String&gt; info = new ArrayList&lt;&gt;();
1021 
1022         boolean signerNotExpired = expireDate == null
1023                 || expireDate.after(new Date());
1024 
1025         if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType ||
1026                 notYetValidCert || chainNotValidated || hasExpiredCert ||
1027                 hasUnsignedEntry || signerSelfSigned || (weakAlg != 0) ||
1028                 aliasNotInStore || notSignedByAlias ||
1029                 tsaChainNotValidated ||
1030                 (hasExpiredTsaCert &amp;&amp; !signerNotExpired)) {
1031 
1032             if (strict) {
1033                 result = isSigning
1034                         ? rb.getString(&quot;jar.signed.with.signer.errors.&quot;)
1035                         : rb.getString(&quot;jar.verified.with.signer.errors.&quot;);
1036             } else {
1037                 result = isSigning
1038                         ? rb.getString(&quot;jar.signed.&quot;)
1039                         : rb.getString(&quot;jar.verified.&quot;);
1040             }
1041 
1042             if (badKeyUsage) {
1043                 errors.add(isSigning
1044                         ? rb.getString(&quot;The.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;)
1045                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.KeyUsage.extension.doesn.t.allow.code.signing.&quot;));
1046             }
1047 
1048             if (badExtendedKeyUsage) {
1049                 errors.add(isSigning
1050                         ? rb.getString(&quot;The.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;)
1051                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.ExtendedKeyUsage.extension.doesn.t.allow.code.signing.&quot;));
1052             }
1053 
1054             if (badNetscapeCertType) {
1055                 errors.add(isSigning
1056                         ? rb.getString(&quot;The.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;)
1057                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.s.NetscapeCertType.extension.doesn.t.allow.code.signing.&quot;));
1058             }
1059 
1060             // only in verifying
1061             if (hasUnsignedEntry) {
1062                 errors.add(rb.getString(
1063                         &quot;This.jar.contains.unsigned.entries.which.have.not.been.integrity.checked.&quot;));
1064             }
1065             if (hasExpiredCert) {
1066                 errors.add(isSigning
1067                         ? rb.getString(&quot;The.signer.certificate.has.expired.&quot;)
1068                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.has.expired.&quot;));
1069             }
1070             if (notYetValidCert) {
1071                 errors.add(isSigning
1072                         ? rb.getString(&quot;The.signer.certificate.is.not.yet.valid.&quot;)
1073                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.is.not.yet.valid.&quot;));
1074             }
1075 
1076             if (chainNotValidated) {
1077                 errors.add(String.format(isSigning
1078                                 ? rb.getString(&quot;The.signer.s.certificate.chain.is.invalid.reason.1&quot;)
1079                                 : rb.getString(&quot;This.jar.contains.entries.whose.certificate.chain.is.invalid.reason.1&quot;),
1080                         chainNotValidatedReason.getLocalizedMessage()));
1081             }
1082 
1083             if (hasExpiredTsaCert) {
1084                 errors.add(rb.getString(&quot;The.timestamp.has.expired.&quot;));
1085             }
1086             if (tsaChainNotValidated) {
1087                 errors.add(String.format(isSigning
1088                                 ? rb.getString(&quot;The.tsa.certificate.chain.is.invalid.reason.1&quot;)
1089                                 : rb.getString(&quot;This.jar.contains.entries.whose.tsa.certificate.chain.is.invalid.reason.1&quot;),
1090                         tsaChainNotValidatedReason.getLocalizedMessage()));
1091             }
1092 
1093             // only in verifying
1094             if (notSignedByAlias) {
1095                 errors.add(
1096                         rb.getString(&quot;This.jar.contains.signed.entries.which.is.not.signed.by.the.specified.alias.es.&quot;));
1097             }
1098 
1099             // only in verifying
1100             if (aliasNotInStore) {
1101                 errors.add(rb.getString(&quot;This.jar.contains.signed.entries.that.s.not.signed.by.alias.in.this.keystore.&quot;));
1102             }
1103 
1104             if (signerSelfSigned) {
1105                 errors.add(isSigning
1106                         ? rb.getString(&quot;The.signer.s.certificate.is.self.signed.&quot;)
1107                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.is.self.signed.&quot;));
1108             }
1109 
1110             // weakAlg only detected in signing. The jar file is
1111             // now simply treated unsigned in verifying.
1112             if ((weakAlg &amp; 1) == 1) {
1113                 errors.add(String.format(
1114                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.&quot;),
1115                         digestalg, &quot;-digestalg&quot;));
1116             }
1117 
1118             if ((weakAlg &amp; 2) == 2) {
1119                 errors.add(String.format(
1120                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.&quot;),
1121                         sigalg, &quot;-sigalg&quot;));
1122             }
1123             if ((weakAlg &amp; 4) == 4) {
1124                 errors.add(String.format(
1125                         rb.getString(&quot;The.1.algorithm.specified.for.the.2.option.is.considered.a.security.risk.&quot;),
1126                         tSADigestAlg, &quot;-tsadigestalg&quot;));
1127             }
1128             if ((weakAlg &amp; 8) == 8) {
1129                 errors.add(String.format(
1130                         rb.getString(&quot;The.1.signing.key.has.a.keysize.of.2.which.is.considered.a.security.risk.&quot;),
1131                         privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));
1132             }
1133         } else {
1134             result = isSigning ? rb.getString(&quot;jar.signed.&quot;) : rb.getString(&quot;jar.verified.&quot;);
1135         }
1136 
1137         if (hasExpiredTsaCert) {
1138             // No need to warn about expiring if already expired
1139             hasExpiringTsaCert = false;
1140         }
1141 
1142         if (hasExpiringCert ||
1143                 (hasExpiringTsaCert  &amp;&amp; expireDate != null) ||
1144                 (noTimestamp &amp;&amp; expireDate != null) ||
1145                 (hasExpiredTsaCert &amp;&amp; signerNotExpired)) {
1146 
1147             if (hasExpiredTsaCert &amp;&amp; signerNotExpired) {
1148                 if (expireDate != null) {
1149                     warnings.add(String.format(
1150                             rb.getString(&quot;The.timestamp.expired.1.but.usable.2&quot;),
1151                             tsaExpireDate,
1152                             expireDate));
1153                 }
1154                 // Reset the flag so exit code is 0
1155                 hasExpiredTsaCert = false;
1156             }
1157             if (hasExpiringCert) {
1158                 warnings.add(isSigning
1159                         ? rb.getString(&quot;The.signer.certificate.will.expire.within.six.months.&quot;)
1160                         : rb.getString(&quot;This.jar.contains.entries.whose.signer.certificate.will.expire.within.six.months.&quot;));
1161             }
1162             if (hasExpiringTsaCert &amp;&amp; expireDate != null) {
1163                 if (expireDate.after(tsaExpireDate)) {
1164                     warnings.add(String.format(rb.getString(
1165                             &quot;The.timestamp.will.expire.within.one.year.on.1.but.2&quot;), tsaExpireDate, expireDate));
1166                 } else {
1167                     warnings.add(String.format(rb.getString(
1168                             &quot;The.timestamp.will.expire.within.one.year.on.1&quot;), tsaExpireDate));
1169                 }
1170             }
1171             if (noTimestamp &amp;&amp; expireDate != null) {
1172                 if (hasTimestampBlock) {
1173                     warnings.add(String.format(isSigning
1174                             ? rb.getString(&quot;invalid.timestamp.signing&quot;)
1175                             : rb.getString(&quot;bad.timestamp.verifying&quot;), expireDate));
1176                 } else {
1177                     warnings.add(String.format(isSigning
1178                             ? rb.getString(&quot;no.timestamp.signing&quot;)
1179                             : rb.getString(&quot;no.timestamp.verifying&quot;), expireDate));
1180                 }
1181             }
1182         }
1183 
1184         System.out.println(result);
1185         if (strict) {
1186             if (!errors.isEmpty()) {
1187                 System.out.println();
1188                 System.out.println(rb.getString(&quot;Error.&quot;));
1189                 errors.forEach(System.out::println);
1190             }
1191             if (!warnings.isEmpty()) {
1192                 System.out.println();
1193                 System.out.println(rb.getString(&quot;Warning.&quot;));
1194                 warnings.forEach(System.out::println);
1195             }
1196         } else {
1197             if (!errors.isEmpty() || !warnings.isEmpty()) {
1198                 System.out.println();
1199                 System.out.println(rb.getString(&quot;Warning.&quot;));
1200                 errors.forEach(System.out::println);
1201                 warnings.forEach(System.out::println);
1202             }
1203         }
1204         if (!isSigning &amp;&amp; (!errors.isEmpty() || !warnings.isEmpty())) {
1205             if (! (verbose != null &amp;&amp; showcerts)) {
1206                 System.out.println();
1207                 System.out.println(rb.getString(
1208                         &quot;Re.run.with.the.verbose.and.certs.options.for.more.details.&quot;));
1209             }
1210         }
1211 
1212         if (isSigning || verbose != null) {
1213             // Always print out expireDate, unless expired or expiring.
1214             if (!hasExpiringCert &amp;&amp; !hasExpiredCert
1215                     &amp;&amp; expireDate != null &amp;&amp; signerNotExpired) {
1216                 info.add(String.format(rb.getString(
1217                         &quot;The.signer.certificate.will.expire.on.1.&quot;), expireDate));
1218             }
1219             if (!noTimestamp) {
1220                 if (!hasExpiringTsaCert &amp;&amp; !hasExpiredTsaCert &amp;&amp; tsaExpireDate != null) {
1221                     if (signerNotExpired) {
1222                         info.add(String.format(rb.getString(
1223                                 &quot;The.timestamp.will.expire.on.1.&quot;), tsaExpireDate));
1224                     } else {
1225                         info.add(String.format(rb.getString(
1226                                 &quot;signer.cert.expired.1.but.timestamp.good.2.&quot;),
1227                                 expireDate,
1228                                 tsaExpireDate));
1229                     }
1230                 }
1231             }
1232         }
1233 
1234         if (!info.isEmpty()) {
1235             System.out.println();
1236             info.forEach(System.out::println);
1237         }
1238     }
1239 
1240     private String withWeak(String alg, Set&lt;CryptoPrimitive&gt; primitiveSet) {
1241         if (DISABLED_CHECK.permits(primitiveSet, alg, null)) {
1242             return alg;
1243         } else {
1244             seeWeak = true;
1245             return String.format(rb.getString(&quot;with.weak&quot;), alg);
1246         }
1247     }
1248 
1249     private String withWeak(PublicKey key) {
1250         if (DISABLED_CHECK.permits(SIG_PRIMITIVE_SET, key)) {
1251             int kLen = KeyUtil.getKeySize(key);
1252             if (kLen &gt;= 0) {
1253                 return String.format(rb.getString(&quot;key.bit&quot;), kLen);
1254             } else {
1255                 return rb.getString(&quot;unknown.size&quot;);
1256             }
1257         } else {
1258             seeWeak = true;
1259             return String.format(
1260                     rb.getString(&quot;key.bit.weak&quot;), KeyUtil.getKeySize(key));
1261         }
1262     }
1263 
1264     private static MessageFormat validityTimeForm = null;
1265     private static MessageFormat notYetTimeForm = null;
1266     private static MessageFormat expiredTimeForm = null;
1267     private static MessageFormat expiringTimeForm = null;
1268 
1269     /**
1270      * Returns a string about a certificate:
1271      *
1272      * [&lt;tab&gt;] &lt;cert-type&gt; [&quot;, &quot; &lt;subject-DN&gt;] [&quot; (&quot; &lt;keystore-entry-alias&gt; &quot;)&quot;]
1273      * [&lt;validity-period&gt; | &lt;expiry-warning&gt;]
1274      * [&lt;key-usage-warning&gt;]
1275      *
1276      * Note: no newline character at the end.
1277      *
1278      * This method sets global flags like hasExpiringCert, hasExpiredCert,
1279      * notYetValidCert, badKeyUsage, badExtendedKeyUsage, badNetscapeCertType,
1280      * hasExpiringTsaCert, hasExpiredTsaCert.
1281      *
1282      * @param isTsCert true if c is in the TSA cert chain, false otherwise.
1283      * @param checkUsage true to check code signer keyUsage
1284      */
1285     String printCert(boolean isTsCert, String tab, Certificate c,
1286         Date timestamp, boolean checkUsage) throws Exception {
1287 
1288         StringBuilder certStr = new StringBuilder();
1289         String space = rb.getString(&quot;SPACE&quot;);
1290         X509Certificate x509Cert = null;
1291 
1292         if (c instanceof X509Certificate) {
1293             x509Cert = (X509Certificate) c;
1294             certStr.append(tab).append(x509Cert.getType())
1295                 .append(rb.getString(&quot;COMMA&quot;))
1296                 .append(x509Cert.getSubjectDN().getName());
1297         } else {
1298             certStr.append(tab).append(c.getType());
1299         }
1300 
1301         String alias = storeHash.get(c);
1302         if (alias != null) {
1303             certStr.append(space).append(alias);
1304         }
1305 
1306         if (x509Cert != null) {
1307 
1308             certStr.append(&quot;\n&quot;).append(tab).append(&quot;[&quot;);
1309 
1310             if (trustedCerts.contains(x509Cert)) {
1311                 certStr.append(rb.getString(&quot;trusted.certificate&quot;));
1312             } else {
1313                 Date notAfter = x509Cert.getNotAfter();
1314                 try {
1315                     boolean printValidity = true;
1316                     if (isTsCert) {
1317                         if (tsaExpireDate == null || tsaExpireDate.after(notAfter)) {
1318                             tsaExpireDate = notAfter;
1319                         }
1320                     } else {
1321                         if (expireDate == null || expireDate.after(notAfter)) {
1322                             expireDate = notAfter;
1323                         }
1324                     }
1325                     if (timestamp == null) {
1326                         x509Cert.checkValidity();
1327                         // test if cert will expire within six months (or one year for tsa)
1328                         long age = isTsCert ? ONE_YEAR : SIX_MONTHS;
1329                         if (notAfter.getTime() &lt; System.currentTimeMillis() + age) {
1330                             if (isTsCert) {
1331                                 hasExpiringTsaCert = true;
1332                             } else {
1333                                 hasExpiringCert = true;
1334                             }
1335                             if (expiringTimeForm == null) {
1336                                 expiringTimeForm = new MessageFormat(
1337                                         rb.getString(&quot;certificate.will.expire.on&quot;));
1338                             }
1339                             Object[] source = {notAfter};
1340                             certStr.append(expiringTimeForm.format(source));
1341                             printValidity = false;
1342                         }
1343                     } else {
1344                         x509Cert.checkValidity(timestamp);
1345                     }
1346                     if (printValidity) {
1347                         if (validityTimeForm == null) {
1348                             validityTimeForm = new MessageFormat(
1349                                     rb.getString(&quot;certificate.is.valid.from&quot;));
1350                         }
1351                         Object[] source = {x509Cert.getNotBefore(), notAfter};
1352                         certStr.append(validityTimeForm.format(source));
1353                     }
1354                 } catch (CertificateExpiredException cee) {
1355                     if (isTsCert) {
1356                         hasExpiredTsaCert = true;
1357                     } else {
1358                         hasExpiredCert = true;
1359                     }
1360 
1361                     if (expiredTimeForm == null) {
1362                         expiredTimeForm = new MessageFormat(
1363                                 rb.getString(&quot;certificate.expired.on&quot;));
1364                     }
1365                     Object[] source = {notAfter};
1366                     certStr.append(expiredTimeForm.format(source));
1367 
1368                 } catch (CertificateNotYetValidException cnyve) {
1369                     if (!isTsCert) notYetValidCert = true;
1370 
1371                     if (notYetTimeForm == null) {
1372                         notYetTimeForm = new MessageFormat(
1373                                 rb.getString(&quot;certificate.is.not.valid.until&quot;));
1374                     }
1375                     Object[] source = {x509Cert.getNotBefore()};
1376                     certStr.append(notYetTimeForm.format(source));
1377                 }
1378             }
1379             certStr.append(&quot;]&quot;);
1380 
1381             if (checkUsage) {
1382                 boolean[] bad = new boolean[3];
1383                 checkCertUsage(x509Cert, bad);
1384                 if (bad[0] || bad[1] || bad[2]) {
1385                     String x = &quot;&quot;;
1386                     if (bad[0]) {
1387                         x =&quot;KeyUsage&quot;;
1388                     }
1389                     if (bad[1]) {
1390                         if (x.length() &gt; 0) x = x + &quot;, &quot;;
1391                         x = x + &quot;ExtendedKeyUsage&quot;;
1392                     }
1393                     if (bad[2]) {
1394                         if (x.length() &gt; 0) x = x + &quot;, &quot;;
1395                         x = x + &quot;NetscapeCertType&quot;;
1396                     }
1397                     certStr.append(&quot;\n&quot;).append(tab)
1398                         .append(MessageFormat.format(rb.getString(
1399                         &quot;.{0}.extension.does.not.support.code.signing.&quot;), x));
1400                 }
1401             }
1402         }
1403         return certStr.toString();
1404     }
1405 
1406     private static MessageFormat signTimeForm = null;
1407 
1408     private String printTimestamp(String tab, Timestamp timestamp) {
1409 
1410         if (signTimeForm == null) {
1411             signTimeForm =
1412                 new MessageFormat(rb.getString(&quot;entry.was.signed.on&quot;));
1413         }
1414         Object[] source = { timestamp.getTimestamp() };
1415 
1416         return new StringBuilder().append(tab).append(&quot;[&quot;)
1417             .append(signTimeForm.format(source)).append(&quot;]&quot;).toString();
1418     }
1419 
1420     private Map&lt;CodeSigner,Integer&gt; cacheForInKS = new IdentityHashMap&lt;&gt;();
1421 
1422     private int inKeyStoreForOneSigner(CodeSigner signer) {
1423         if (cacheForInKS.containsKey(signer)) {
1424             return cacheForInKS.get(signer);
1425         }
1426 
1427         int result = 0;
1428         List&lt;? extends Certificate&gt; certs = signer.getSignerCertPath().getCertificates();
1429         for (Certificate c : certs) {
1430             String alias = storeHash.get(c);
1431             if (alias != null) {
1432                 if (alias.startsWith(&quot;(&quot;)) {
1433                     result |= IN_KEYSTORE;
1434                 }
1435                 if (ckaliases.contains(alias.substring(1, alias.length() - 1))) {
1436                     result |= SIGNED_BY_ALIAS;
1437                 }
1438             } else {
1439                 if (store != null) {
1440                     try {
1441                         alias = store.getCertificateAlias(c);
1442                     } catch (KeyStoreException kse) {
1443                         // never happens, because keystore has been loaded
1444                     }
1445                     if (alias != null) {
1446                         storeHash.put(c, &quot;(&quot; + alias + &quot;)&quot;);
1447                         result |= IN_KEYSTORE;
1448                     }
1449                 }
1450                 if (ckaliases.contains(alias)) {
1451                     result |= SIGNED_BY_ALIAS;
1452                 }
1453             }
1454         }
1455         cacheForInKS.put(signer, result);
1456         return result;
1457     }
1458 
1459     Hashtable&lt;Certificate, String&gt; storeHash = new Hashtable&lt;&gt;();
1460 
1461     int inKeyStore(CodeSigner[] signers) {
1462 
1463         if (signers == null)
1464             return 0;
1465 
1466         int output = 0;
1467 
1468         for (CodeSigner signer: signers) {
1469             int result = inKeyStoreForOneSigner(signer);
1470             output |= result;
1471         }
1472         if (ckaliases.size() &gt; 0 &amp;&amp; (output &amp; SIGNED_BY_ALIAS) == 0) {
1473             output |= NOT_ALIAS;
1474         }
1475         return output;
1476     }
1477 
1478     void signJar(String jarName, String alias)
1479             throws Exception {
1480 
1481         if (digestalg != null &amp;&amp; !DISABLED_CHECK.permits(
1482                 DIGEST_PRIMITIVE_SET, digestalg, null)) {
1483             weakAlg |= 1;
1484         }
1485         if (tSADigestAlg != null &amp;&amp; !DISABLED_CHECK.permits(
1486                 DIGEST_PRIMITIVE_SET, tSADigestAlg, null)) {
1487             weakAlg |= 4;
1488         }
1489         if (sigalg != null &amp;&amp; !DISABLED_CHECK.permits(
1490                 SIG_PRIMITIVE_SET , sigalg, null)) {
1491             weakAlg |= 2;
1492         }
1493         if (!DISABLED_CHECK.permits(
1494                 SIG_PRIMITIVE_SET, privateKey)) {
1495             weakAlg |= 8;
1496         }
1497 
1498         boolean aliasUsed = false;
1499         X509Certificate tsaCert = null;
1500 
1501         if (sigfile == null) {
1502             sigfile = alias;
1503             aliasUsed = true;
1504         }
1505 
1506         if (sigfile.length() &gt; 8) {
1507             sigfile = sigfile.substring(0, 8).toUpperCase(Locale.ENGLISH);
1508         } else {
1509             sigfile = sigfile.toUpperCase(Locale.ENGLISH);
1510         }
1511 
1512         StringBuilder tmpSigFile = new StringBuilder(sigfile.length());
1513         for (int j = 0; j &lt; sigfile.length(); j++) {
1514             char c = sigfile.charAt(j);
1515             if (!
1516                     ((c&gt;= &#39;A&#39; &amp;&amp; c&lt;= &#39;Z&#39;) ||
1517                             (c&gt;= &#39;0&#39; &amp;&amp; c&lt;= &#39;9&#39;) ||
1518                             (c == &#39;-&#39;) ||
1519                             (c == &#39;_&#39;))) {
1520                 if (aliasUsed) {
1521                     // convert illegal characters from the alias to be _&#39;s
1522                     c = &#39;_&#39;;
1523                 } else {
1524                     throw new
1525                             RuntimeException(rb.getString
1526                             (&quot;signature.filename.must.consist.of.the.following.characters.A.Z.0.9.or.&quot;));
1527                 }
1528             }
1529             tmpSigFile.append(c);
1530         }
1531 
1532         sigfile = tmpSigFile.toString();
1533 
1534         String tmpJarName;
1535         if (signedjar == null) tmpJarName = jarName+&quot;.sig&quot;;
1536         else tmpJarName = signedjar;
1537 
1538         File jarFile = new File(jarName);
1539         File signedJarFile = new File(tmpJarName);
1540 
1541         // Open the jar (zip) file
1542         try {
1543             zipFile = new ZipFile(jarName);
1544         } catch (IOException ioe) {
1545             error(rb.getString(&quot;unable.to.open.jar.file.&quot;)+jarName, ioe);
1546         }
1547 
1548         CertPath cp = CertificateFactory.getInstance(&quot;X.509&quot;)
1549                 .generateCertPath(Arrays.asList(certChain));
1550         JarSigner.Builder builder = new JarSigner.Builder(privateKey, cp);
1551 
1552         if (verbose != null) {
1553             builder.eventHandler((action, file) -&gt; {
1554                 switch (action) {
1555                     case &quot;signing&quot;:
1556                         System.out.println(rb.getString(&quot;.signing.&quot;) + file);
1557                         break;
1558                     case &quot;adding&quot;:
1559                         System.out.println(rb.getString(&quot;.adding.&quot;) + file);
1560                         break;
1561                     case &quot;updating&quot;:
1562                         System.out.println(rb.getString(&quot;.updating.&quot;) + file);
1563                         break;
1564                     default:
1565                         throw new IllegalArgumentException(&quot;unknown action: &quot;
1566                                 + action);
1567                 }
1568             });
1569         }
1570 
1571         if (digestalg != null) {
1572             builder.digestAlgorithm(digestalg);
1573         }
1574         if (sigalg != null) {
1575             builder.signatureAlgorithm(sigalg);
1576         }
1577 
1578         URI tsaURI = null;
1579 
1580         if (tsaUrl != null) {
1581             tsaURI = new URI(tsaUrl);
1582         } else if (tsaAlias != null) {
1583             tsaCert = getTsaCert(tsaAlias);
1584             tsaURI = TimestampedSigner.getTimestampingURI(tsaCert);
1585         }
1586 
1587         if (tsaURI != null) {
1588             if (verbose != null) {
1589                 System.out.println(
1590                         rb.getString(&quot;requesting.a.signature.timestamp&quot;));
1591                 if (tsaUrl != null) {
1592                     System.out.println(rb.getString(&quot;TSA.location.&quot;) + tsaUrl);
1593                 } else if (tsaCert != null) {
1594                     System.out.println(rb.getString(&quot;TSA.certificate.&quot;) +
1595                             printCert(true, &quot;&quot;, tsaCert, null, false));
1596                 }
1597             }
1598             builder.tsa(tsaURI);
1599             if (tSADigestAlg != null) {
1600                 builder.setProperty(&quot;tsaDigestAlg&quot;, tSADigestAlg);
1601             }
1602 
1603             if (tSAPolicyID != null) {
1604                 builder.setProperty(&quot;tsaPolicyId&quot;, tSAPolicyID);
1605             }
1606         }
1607 
1608         if (altSignerClass != null) {
1609             builder.setProperty(&quot;altSigner&quot;, altSignerClass);
1610             if (verbose != null) {
1611                 System.out.println(
1612                         rb.getString(&quot;using.an.alternative.signing.mechanism&quot;));
1613             }
1614         }
1615 
1616         if (altSignerClasspath != null) {
1617             builder.setProperty(&quot;altSignerPath&quot;, altSignerClasspath);
1618         }
1619 
1620         builder.signerName(sigfile);
1621 
1622         builder.setProperty(&quot;sectionsOnly&quot;, Boolean.toString(!signManifest));
1623         builder.setProperty(&quot;internalSF&quot;, Boolean.toString(!externalSF));
1624 
1625         FileOutputStream fos = null;
1626         try {
1627             fos = new FileOutputStream(signedJarFile);
1628         } catch (IOException ioe) {
1629             error(rb.getString(&quot;unable.to.create.&quot;)+tmpJarName, ioe);
1630         }
1631 
1632         Throwable failedCause = null;
1633         String failedMessage = null;
1634 
1635         try {
1636             builder.build().sign(zipFile, fos);
1637         } catch (JarSignerException e) {
1638             failedCause = e.getCause();
1639             if (failedCause instanceof SocketTimeoutException
1640                     || failedCause instanceof UnknownHostException) {
1641                 // Provide a helpful message when TSA is beyond a firewall
1642                 failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) +
1643                         rb.getString(&quot;no.response.from.the.Timestamping.Authority.&quot;) +
1644                         &quot;\n  -J-Dhttp.proxyHost=&lt;hostname&gt;&quot; +
1645                         &quot;\n  -J-Dhttp.proxyPort=&lt;portnumber&gt;\n&quot; +
1646                         rb.getString(&quot;or&quot;) +
1647                         &quot;\n  -J-Dhttps.proxyHost=&lt;hostname&gt; &quot; +
1648                         &quot;\n  -J-Dhttps.proxyPort=&lt;portnumber&gt; &quot;;
1649             } else {
1650                 // JarSignerException might have a null cause
1651                 if (failedCause == null) {
1652                     failedCause = e;
1653                 }
1654                 failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) + failedCause;
1655             }
1656         } catch (Exception e) {
1657             failedCause = e;
1658             failedMessage = rb.getString(&quot;unable.to.sign.jar.&quot;) + failedCause;
1659         } finally {
1660             // close the resources
1661             if (zipFile != null) {
1662                 zipFile.close();
1663                 zipFile = null;
1664             }
1665 
1666             if (fos != null) {
1667                 fos.close();
1668             }
1669 
1670         }
1671 
1672         if (failedCause != null) {
1673             signedJarFile.delete();
1674             error(failedMessage, failedCause);
1675         }
1676 
1677         if (verbose != null) {
1678             System.out.println();
1679         }
1680 
1681         // The JarSigner API always accepts the timestamp received.
1682         // We need to extract the certs from the signed jar to
1683         // validate it.
1684         try (JarFile check = new JarFile(signedJarFile)) {
1685             PKCS7 p7 = new PKCS7(check.getInputStream(check.getEntry(
1686                     &quot;META-INF/&quot; + sigfile + &quot;.&quot; + privateKey.getAlgorithm())));
1687             Timestamp ts = null;
1688             try {
1689                 SignerInfo si = p7.getSignerInfos()[0];
1690                 if (si.getTsToken() != null) {
1691                     hasTimestampBlock = true;
1692                 }
1693                 ts = si.getTimestamp();
1694             } catch (Exception e) {
1695                 tsaChainNotValidated = true;
1696                 tsaChainNotValidatedReason = e;
1697             }
1698             // Spaces before the &quot;&gt;&gt;&gt; Signer&quot; and other lines are different
1699             String result = certsAndTSInfo(&quot;&quot;, &quot;    &quot;, Arrays.asList(certChain), ts);
1700             if (verbose != null) {
1701                 System.out.println(result);
1702             }
1703         } catch (Exception e) {
1704             if (debug) {
1705                 e.printStackTrace();
1706             }
1707         }
1708 
1709         if (signedjar == null) {
1710             // attempt an atomic rename. If that fails,
1711             // rename the original jar file, then the signed
1712             // one, then delete the original.
1713             if (!signedJarFile.renameTo(jarFile)) {
1714                 File origJar = new File(jarName+&quot;.orig&quot;);
1715 
1716                 if (jarFile.renameTo(origJar)) {
1717                     if (signedJarFile.renameTo(jarFile)) {
1718                         origJar.delete();
1719                     } else {
1720                         MessageFormat form = new MessageFormat(rb.getString
1721                     (&quot;attempt.to.rename.signedJarFile.to.jarFile.failed&quot;));
1722                         Object[] source = {signedJarFile, jarFile};
1723                         error(form.format(source));
1724                     }
1725                 } else {
1726                     MessageFormat form = new MessageFormat(rb.getString
1727                         (&quot;attempt.to.rename.jarFile.to.origJar.failed&quot;));
1728                     Object[] source = {jarFile, origJar};
1729                     error(form.format(source));
1730                 }
1731             }
1732         }
1733 
1734         displayMessagesAndResult(true);
1735     }
1736 
1737     /**
1738      * signature-related files include:
1739      * . META-INF/MANIFEST.MF
1740      * . META-INF/SIG-*
1741      * . META-INF/*.SF
1742      * . META-INF/*.DSA
1743      * . META-INF/*.RSA
1744      * . META-INF/*.EC
1745      */
1746     private boolean signatureRelated(String name) {
1747         return SignatureFileVerifier.isSigningRelated(name);
1748     }
1749 
1750     Map&lt;CodeSigner,String&gt; cacheForSignerInfo = new IdentityHashMap&lt;&gt;();
1751 
1752     /**
1753      * Returns a string of signer info, with a newline at the end.
1754      * Called by verifyJar().
1755      */
1756     private String signerInfo(CodeSigner signer, String tab) throws Exception {
1757         if (cacheForSignerInfo.containsKey(signer)) {
1758             return cacheForSignerInfo.get(signer);
1759         }
1760         List&lt;? extends Certificate&gt; certs = signer.getSignerCertPath().getCertificates();
1761         // signing time is only displayed on verification
1762         Timestamp ts = signer.getTimestamp();
1763         String tsLine = &quot;&quot;;
1764         if (ts != null) {
1765             tsLine = printTimestamp(tab, ts) + &quot;\n&quot;;
1766         }
1767         // Spaces before the &quot;&gt;&gt;&gt; Signer&quot; and other lines are the same.
1768 
1769         String result = certsAndTSInfo(tab, tab, certs, ts);
1770         cacheForSignerInfo.put(signer, tsLine + result);
1771         return result;
1772     }
1773 
1774     /**
1775      * Fills info on certs and timestamp into a StringBuilder, sets
1776      * warning flags (through printCert) and validates cert chains.
1777      *
1778      * @param tab1 spaces before the &quot;&gt;&gt;&gt; Signer&quot; line
1779      * @param tab2 spaces before the other lines
1780      * @param certs the signer cert
1781      * @param ts the timestamp, can be null
1782      * @return the info as a string
1783      */
1784     private String certsAndTSInfo(
1785             String tab1,
1786             String tab2,
1787             List&lt;? extends Certificate&gt; certs, Timestamp ts)
1788             throws Exception {
1789 
1790         Date timestamp;
1791         if (ts != null) {
1792             timestamp = ts.getTimestamp();
1793             noTimestamp = false;
1794         } else {
1795             timestamp = null;
1796         }
1797         // display the certificate(sb). The first one is end-entity cert and
1798         // its KeyUsage should be checked.
1799         boolean first = true;
1800         StringBuilder sb = new StringBuilder();
1801         sb.append(tab1).append(rb.getString(&quot;...Signer&quot;)).append(&#39;\n&#39;);
1802         for (Certificate c : certs) {
1803             sb.append(printCert(false, tab2, c, timestamp, first));
1804             sb.append(&#39;\n&#39;);
1805             first = false;
1806         }
1807         try {
1808             validateCertChain(Validator.VAR_CODE_SIGNING, certs, ts);
1809         } catch (Exception e) {
1810             chainNotValidated = true;
1811             chainNotValidatedReason = e;
1812             sb.append(tab2).append(rb.getString(&quot;.Invalid.certificate.chain.&quot;))
1813                     .append(e.getLocalizedMessage()).append(&quot;]\n&quot;);
1814         }
1815         if (ts != null) {
1816             sb.append(tab1).append(rb.getString(&quot;...TSA&quot;)).append(&#39;\n&#39;);
1817             for (Certificate c : ts.getSignerCertPath().getCertificates()) {
1818                 sb.append(printCert(true, tab2, c, null, false));
1819                 sb.append(&#39;\n&#39;);
1820             }
1821             try {
1822                 validateCertChain(Validator.VAR_TSA_SERVER,
1823                         ts.getSignerCertPath().getCertificates(), null);
1824             } catch (Exception e) {
1825                 tsaChainNotValidated = true;
1826                 tsaChainNotValidatedReason = e;
1827                 sb.append(tab2).append(rb.getString(&quot;.Invalid.TSA.certificate.chain.&quot;))
1828                         .append(e.getLocalizedMessage()).append(&quot;]\n&quot;);
1829             }
1830         }
1831         if (certs.size() == 1
1832                 &amp;&amp; KeyStoreUtil.isSelfSigned((X509Certificate)certs.get(0))) {
1833             signerSelfSigned = true;
1834         }
1835 
1836         return sb.toString();
1837     }
1838 
1839     void loadKeyStore(String keyStoreName, boolean prompt) {
1840 
1841         if (!nullStream &amp;&amp; keyStoreName == null) {
1842             keyStoreName = System.getProperty(&quot;user.home&quot;) + File.separator
1843                 + &quot;.keystore&quot;;
1844         }
1845 
1846         try {
1847             try {
1848                 KeyStore caks = KeyStoreUtil.getCacertsKeyStore();
1849                 if (caks != null) {
1850                     Enumeration&lt;String&gt; aliases = caks.aliases();
1851                     while (aliases.hasMoreElements()) {
1852                         String a = aliases.nextElement();
1853                         try {
1854                             trustedCerts.add((X509Certificate)caks.getCertificate(a));
1855                         } catch (Exception e2) {
1856                             // ignore, when a SecretkeyEntry does not include a cert
1857                         }
1858                     }
1859                 }
1860             } catch (Exception e) {
1861                 // Ignore, if cacerts cannot be loaded
1862             }
1863 
1864             if (providerName == null) {
1865                 store = KeyStore.getInstance(storetype);
1866             } else {
1867                 store = KeyStore.getInstance(storetype, providerName);
1868             }
1869 
1870             // Get pass phrase
1871             // XXX need to disable echo; on UNIX, call getpass(char *prompt)Z
1872             // and on NT call ??
1873             if (token &amp;&amp; storepass == null &amp;&amp; !protectedPath
1874                     &amp;&amp; !KeyStoreUtil.isWindowsKeyStore(storetype)) {
1875                 storepass = getPass
1876                         (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
1877             } else if (!token &amp;&amp; storepass == null &amp;&amp; prompt) {
1878                 storepass = getPass
1879                         (rb.getString(&quot;Enter.Passphrase.for.keystore.&quot;));
1880             }
1881 
1882             try {
1883                 if (nullStream) {
1884                     store.load(null, storepass);
1885                 } else {
1886                     keyStoreName = keyStoreName.replace(File.separatorChar, &#39;/&#39;);
1887                     URL url = null;
1888                     try {
1889                         url = new URL(keyStoreName);
1890                     } catch (java.net.MalformedURLException e) {
1891                         // try as file
1892                         url = new File(keyStoreName).toURI().toURL();
1893                     }
1894                     InputStream is = null;
1895                     try {
1896                         is = url.openStream();
1897                         store.load(is, storepass);
1898                     } finally {
1899                         if (is != null) {
1900                             is.close();
1901                         }
1902                     }
1903                 }
1904                 Enumeration&lt;String&gt; aliases = store.aliases();
1905                 while (aliases.hasMoreElements()) {
1906                     String a = aliases.nextElement();
1907                     try {
1908                         X509Certificate c = (X509Certificate)store.getCertificate(a);
1909                         // Only add TrustedCertificateEntry and self-signed
1910                         // PrivateKeyEntry
1911                         if (store.isCertificateEntry(a) ||
1912                                 c.getSubjectDN().equals(c.getIssuerDN())) {
1913                             trustedCerts.add(c);
1914                         }
1915                     } catch (Exception e2) {
1916                         // ignore, when a SecretkeyEntry does not include a cert
1917                     }
1918                 }
1919             } finally {
1920                 try {
1921                     pkixParameters = new PKIXBuilderParameters(
1922                             trustedCerts.stream()
1923                                     .map(c -&gt; new TrustAnchor(c, null))
1924                                     .collect(Collectors.toSet()),
1925                             null);
1926                     pkixParameters.setRevocationEnabled(false);
1927                 } catch (InvalidAlgorithmParameterException ex) {
1928                     // Only if tas is empty
1929                 }
1930             }
1931         } catch (IOException ioe) {
1932             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
1933                                         ioe.getMessage());
1934         } catch (java.security.cert.CertificateException ce) {
1935             throw new RuntimeException(rb.getString(&quot;certificate.exception.&quot;) +
1936                                         ce.getMessage());
1937         } catch (NoSuchProviderException pe) {
1938             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
1939                                         pe.getMessage());
1940         } catch (NoSuchAlgorithmException nsae) {
1941             throw new RuntimeException(rb.getString(&quot;keystore.load.&quot;) +
1942                                         nsae.getMessage());
1943         } catch (KeyStoreException kse) {
1944             throw new RuntimeException
1945                 (rb.getString(&quot;unable.to.instantiate.keystore.class.&quot;) +
1946                 kse.getMessage());
1947         }
1948     }
1949 
1950     X509Certificate getTsaCert(String alias) {
1951 
1952         java.security.cert.Certificate cs = null;
1953 
1954         try {
1955             cs = store.getCertificate(alias);
1956         } catch (KeyStoreException kse) {
1957             // this never happens, because keystore has been loaded
1958         }
1959         if (cs == null || (!(cs instanceof X509Certificate))) {
1960             MessageFormat form = new MessageFormat(rb.getString
1961                 (&quot;Certificate.not.found.for.alias.alias.must.reference.a.valid.KeyStore.entry.containing.an.X.509.public.key.certificate.for.the&quot;));
1962             Object[] source = {alias, alias};
1963             error(form.format(source));
1964         }
1965         return (X509Certificate) cs;
1966     }
1967 
1968     /**
1969      * Check if userCert is designed to be a code signer
1970      * @param userCert the certificate to be examined
1971      * @param bad 3 booleans to show if the KeyUsage, ExtendedKeyUsage,
1972      *            NetscapeCertType has codeSigning flag turned on.
1973      *            If null, the class field badKeyUsage, badExtendedKeyUsage,
1974      *            badNetscapeCertType will be set.
1975      */
1976     void checkCertUsage(X509Certificate userCert, boolean[] bad) {
1977 
1978         // Can act as a signer?
1979         // 1. if KeyUsage, then [0:digitalSignature] or
1980         //    [1:nonRepudiation] should be true
1981         // 2. if ExtendedKeyUsage, then should contains ANY or CODE_SIGNING
1982         // 3. if NetscapeCertType, then should contains OBJECT_SIGNING
1983         // 1,2,3 must be true
1984 
1985         if (bad != null) {
1986             bad[0] = bad[1] = bad[2] = false;
1987         }
1988 
1989         boolean[] keyUsage = userCert.getKeyUsage();
1990         if (keyUsage != null) {
1991             keyUsage = Arrays.copyOf(keyUsage, 9);
1992             if (!keyUsage[0] &amp;&amp; !keyUsage[1]) {
1993                 if (bad != null) {
1994                     bad[0] = true;
1995                     badKeyUsage = true;
1996                 }
1997             }
1998         }
1999 
2000         try {
2001             List&lt;String&gt; xKeyUsage = userCert.getExtendedKeyUsage();
2002             if (xKeyUsage != null) {
2003                 if (!xKeyUsage.contains(&quot;2.5.29.37.0&quot;) // anyExtendedKeyUsage
2004                         &amp;&amp; !xKeyUsage.contains(&quot;1.3.6.1.5.5.7.3.3&quot;)) {  // codeSigning
2005                     if (bad != null) {
2006                         bad[1] = true;
2007                         badExtendedKeyUsage = true;
2008                     }
2009                 }
2010             }
2011         } catch (java.security.cert.CertificateParsingException e) {
2012             // shouldn&#39;t happen
2013         }
2014 
2015         try {
2016             // OID_NETSCAPE_CERT_TYPE
2017             byte[] netscapeEx = userCert.getExtensionValue
2018                     (&quot;2.16.840.1.113730.1.1&quot;);
2019             if (netscapeEx != null) {
2020                 DerInputStream in = new DerInputStream(netscapeEx);
2021                 byte[] encoded = in.getOctetString();
2022                 encoded = new DerValue(encoded).getUnalignedBitString()
2023                         .toByteArray();
2024 
2025                 NetscapeCertTypeExtension extn =
2026                         new NetscapeCertTypeExtension(encoded);
2027 
2028                 Boolean val = extn.get(NetscapeCertTypeExtension.OBJECT_SIGNING);
2029                 if (!val) {
2030                     if (bad != null) {
2031                         bad[2] = true;
2032                         badNetscapeCertType = true;
2033                     }
2034                 }
2035             }
2036         } catch (IOException e) {
2037             //
2038         }
2039     }
2040 
2041     // Called by signJar().
2042     void getAliasInfo(String alias) throws Exception {
2043 
2044         Key key = null;
2045 
2046         try {
2047             java.security.cert.Certificate[] cs = null;
2048             if (altCertChain != null) {
2049                 try (FileInputStream fis = new FileInputStream(altCertChain)) {
2050                     cs = CertificateFactory.getInstance(&quot;X.509&quot;).
2051                             generateCertificates(fis).
2052                             toArray(new Certificate[0]);
2053                 } catch (FileNotFoundException ex) {
2054                     error(rb.getString(&quot;File.specified.by.certchain.does.not.exist&quot;));
2055                 } catch (CertificateException | IOException ex) {
2056                     error(rb.getString(&quot;Cannot.restore.certchain.from.file.specified&quot;));
2057                 }
2058             } else {
2059                 try {
2060                     cs = store.getCertificateChain(alias);
2061                 } catch (KeyStoreException kse) {
2062                     // this never happens, because keystore has been loaded
2063                 }
2064             }
2065             if (cs == null || cs.length == 0) {
2066                 if (altCertChain != null) {
2067                     error(rb.getString
2068                             (&quot;Certificate.chain.not.found.in.the.file.specified.&quot;));
2069                 } else {
2070                     MessageFormat form = new MessageFormat(rb.getString
2071                         (&quot;Certificate.chain.not.found.for.alias.alias.must.reference.a.valid.KeyStore.key.entry.containing.a.private.key.and&quot;));
2072                     Object[] source = {alias, alias};
2073                     error(form.format(source));
2074                 }
2075             }
2076 
2077             certChain = new X509Certificate[cs.length];
2078             for (int i=0; i&lt;cs.length; i++) {
2079                 if (!(cs[i] instanceof X509Certificate)) {
2080                     error(rb.getString
2081                         (&quot;found.non.X.509.certificate.in.signer.s.chain&quot;));
2082                 }
2083                 certChain[i] = (X509Certificate)cs[i];
2084             }
2085 
2086             try {
2087                 if (!token &amp;&amp; keypass == null)
2088                     key = store.getKey(alias, storepass);
2089                 else
2090                     key = store.getKey(alias, keypass);
2091             } catch (UnrecoverableKeyException e) {
2092                 if (token) {
2093                     throw e;
2094                 } else if (keypass == null) {
2095                     // Did not work out, so prompt user for key password
2096                     MessageFormat form = new MessageFormat(rb.getString
2097                         (&quot;Enter.key.password.for.alias.&quot;));
2098                     Object[] source = {alias};
2099                     keypass = getPass(form.format(source));
2100                     key = store.getKey(alias, keypass);
2101                 }
2102             }
2103         } catch (NoSuchAlgorithmException e) {
2104             error(e.getMessage());
2105         } catch (UnrecoverableKeyException e) {
2106             error(rb.getString(&quot;unable.to.recover.key.from.keystore&quot;));
2107         } catch (KeyStoreException kse) {
2108             // this never happens, because keystore has been loaded
2109         }
2110 
2111         if (!(key instanceof PrivateKey)) {
2112             MessageFormat form = new MessageFormat(rb.getString
2113                 (&quot;key.associated.with.alias.not.a.private.key&quot;));
2114             Object[] source = {alias};
2115             error(form.format(source));
2116         } else {
2117             privateKey = (PrivateKey)key;
2118         }
2119     }
2120 
2121     void error(String message) {
2122         System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
2123         System.exit(1);
2124     }
2125 
2126 
2127     void error(String message, Throwable e) {
2128         System.out.println(rb.getString(&quot;jarsigner.&quot;)+message);
2129         if (debug) {
2130             e.printStackTrace();
2131         }
2132         System.exit(1);
2133     }
2134 
2135     /**
2136      * Validates a cert chain.
2137      *
2138      * @param parameter this might be a timestamp
2139      */
2140     void validateCertChain(String variant, List&lt;? extends Certificate&gt; certs,
2141                            Timestamp parameter)
2142             throws Exception {
2143         try {
2144             Validator.getInstance(Validator.TYPE_PKIX,
2145                     variant,
2146                     pkixParameters)
2147                     .validate(certs.toArray(new X509Certificate[certs.size()]),
2148                             null, parameter);
2149         } catch (Exception e) {
2150             if (debug) {
2151                 e.printStackTrace();
2152             }
2153 
2154             // Exception might be dismissed if another warning flag
2155             // is already set by printCert.
2156 
2157             if (variant.equals(Validator.VAR_TSA_SERVER) &amp;&amp;
2158                     e instanceof ValidatorException) {
2159                 // Throw cause if it&#39;s CertPathValidatorException,
2160                 if (e.getCause() != null &amp;&amp;
2161                         e.getCause() instanceof CertPathValidatorException) {
2162                     e = (Exception) e.getCause();
2163                     Throwable t = e.getCause();
2164                     if ((t instanceof CertificateExpiredException &amp;&amp;
2165                             hasExpiredTsaCert)) {
2166                         // we already have hasExpiredTsaCert
2167                         return;
2168                     }
2169                 }
2170             }
2171 
2172             if (variant.equals(Validator.VAR_CODE_SIGNING) &amp;&amp;
2173                     e instanceof ValidatorException) {
2174                 // Throw cause if it&#39;s CertPathValidatorException,
2175                 if (e.getCause() != null &amp;&amp;
2176                         e.getCause() instanceof CertPathValidatorException) {
2177                     e = (Exception) e.getCause();
2178                     Throwable t = e.getCause();
2179                     if ((t instanceof CertificateExpiredException &amp;&amp;
2180                                 hasExpiredCert) ||
2181                             (t instanceof CertificateNotYetValidException &amp;&amp;
2182                                     notYetValidCert)) {
2183                         // we already have hasExpiredCert and notYetValidCert
2184                         return;
2185                     }
2186                 }
2187                 if (e instanceof ValidatorException) {
2188                     ValidatorException ve = (ValidatorException)e;
2189                     if (ve.getErrorType() == ValidatorException.T_EE_EXTENSIONS &amp;&amp;
2190                             (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType)) {
2191                         // We already have badKeyUsage, badExtendedKeyUsage
2192                         // and badNetscapeCertType
2193                         return;
2194                     }
2195                 }
2196             }
2197             throw e;
2198         }
2199     }
2200 
2201     char[] getPass(String prompt) {
2202         System.err.print(prompt);
2203         System.err.flush();
2204         try {
2205             char[] pass = Password.readPassword(System.in);
2206 
2207             if (pass == null) {
2208                 error(rb.getString(&quot;you.must.enter.key.password&quot;));
2209             } else {
2210                 return pass;
2211             }
2212         } catch (IOException ioe) {
2213             error(rb.getString(&quot;unable.to.read.password.&quot;)+ioe.getMessage());
2214         }
2215         // this shouldn&#39;t happen
2216         return null;
2217     }
2218 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jartool/share/classes/sun/tools/jar/GNUStyleOptions.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.tools.jar;
 27 
 28 import java.io.File;
 29 import java.io.PrintWriter;
 30 import java.lang.module.ModuleDescriptor.Version;
 31 import java.nio.file.Path;
 32 import java.nio.file.Paths;
 33 import java.util.regex.Pattern;
 34 import java.util.regex.PatternSyntaxException;
 35 import jdk.internal.module.ModulePath;
 36 import jdk.internal.module.ModuleResolution;
 37 
 38 /**
 39  * Parser for GNU Style Options.
 40  */
 41 class GNUStyleOptions {
 42 
 43     static class BadArgs extends Exception {
 44         static final long serialVersionUID = 0L;
 45 
 46         boolean showUsage;
 47 
 48         BadArgs(String key, String arg) { super(Main.formatMsg(key, arg)); }
 49         BadArgs(String key) { super(Main.getMsg(key)); }
 50 
 51         BadArgs showUsage(boolean b) {
 52             showUsage = b;
 53             return this;
 54         }
 55     }
 56 
 57     static Option[] recognizedOptions = {
 58             // Main operations
 59             new Option(false, OptionType.MAIN_OPERATION, &quot;--create&quot;, &quot;-c&quot;) {
 60                 void process(Main tool, String opt, String arg) throws BadArgs {
 61                     if (tool.iflag || tool.tflag || tool.uflag || tool.xflag || tool.dflag)
 62                         throw new BadArgs(&quot;error.multiple.main.operations&quot;).showUsage(true);
 63                     tool.cflag = true;
 64                 }
 65             },
 66             new Option(true, OptionType.MAIN_OPERATION, &quot;--generate-index&quot;, &quot;-i&quot;) {
 67                 void process(Main tool, String opt, String arg) throws BadArgs {
 68                     if (tool.cflag || tool.tflag || tool.uflag || tool.xflag || tool.dflag)
 69                         throw new BadArgs(&quot;error.multiple.main.operations&quot;).showUsage(true);
 70                     tool.iflag = true;
 71                     tool.rootjar = arg;
 72                 }
 73             },
 74             new Option(false, OptionType.MAIN_OPERATION, &quot;--list&quot;, &quot;-t&quot;) {
 75                 void process(Main tool, String opt, String arg) throws BadArgs {
 76                     if (tool.cflag || tool.iflag || tool.uflag || tool.xflag || tool.dflag)
 77                         throw new BadArgs(&quot;error.multiple.main.operations&quot;).showUsage(true);
 78                     tool.tflag = true;
 79                 }
 80             },
 81             new Option(false, OptionType.MAIN_OPERATION, &quot;--update&quot;, &quot;-u&quot;) {
 82                 void process(Main tool, String opt, String arg) throws BadArgs {
 83                     if (tool.cflag || tool.iflag || tool.tflag || tool.xflag || tool.dflag)
 84                         throw new BadArgs(&quot;error.multiple.main.operations&quot;).showUsage(true);
 85                     tool.uflag = true;
 86                 }
 87             },
 88             new Option(false, OptionType.MAIN_OPERATION, &quot;--extract&quot;, &quot;-x&quot;) {
 89                 void process(Main tool, String opt, String arg) throws BadArgs {
 90                     if (tool.cflag || tool.iflag  || tool.tflag || tool.uflag || tool.dflag)
 91                         throw new BadArgs(&quot;error.multiple.main.operations&quot;).showUsage(true);
 92                     tool.xflag = true;
 93                 }
 94             },
 95             new Option(false, OptionType.MAIN_OPERATION, &quot;--describe-module&quot;, &quot;-d&quot;) {
 96                 void process(Main tool, String opt, String arg) throws BadArgs {
 97                     if (tool.cflag || tool.iflag  || tool.tflag || tool.uflag || tool.xflag)
 98                         throw new BadArgs(&quot;error.multiple.main.operations&quot;).showUsage(true);
 99                     tool.dflag = true;
100                 }
101             },
102 
103             // Additional options
104             new Option(true, OptionType.ANY, &quot;--file&quot;, &quot;-f&quot;) {
105                 void process(Main jartool, String opt, String arg) {
106                     jartool.fname = arg;
107                 }
108             },
109             new Option(false, OptionType.ANY, &quot;--verbose&quot;, &quot;-v&quot;) {
110                 void process(Main jartool, String opt, String arg) {
111                     jartool.vflag = true;
112                 }
113             },
114             new Option(true, OptionType.CREATE_UPDATE, &quot;--main-class&quot;, &quot;-e&quot;) {
115                 void process(Main jartool, String opt, String arg) {
116                     jartool.ename = arg;
117                 }
118             },
119             new Option(true, OptionType.CREATE_UPDATE, &quot;--manifest&quot;, &quot;-m&quot;) {
120                 void process(Main jartool, String opt, String arg) {
121                     jartool.mname = arg;
122                 }
123             },
124             new Option(false, OptionType.CREATE_UPDATE, &quot;--no-manifest&quot;, &quot;-M&quot;) {
125                 void process(Main jartool, String opt, String arg) {
126                     jartool.Mflag = true;
127                 }
128             },
129             new Option(true, OptionType.CREATE_UPDATE, &quot;--module-version&quot;) {
130                 void process(Main jartool, String opt, String arg) {
131                     jartool.moduleVersion = Version.parse(arg);
132                 }
133             },
134             new Option(true, OptionType.CREATE_UPDATE, &quot;--hash-modules&quot;) {
135                 void process(Main jartool, String opt, String arg) throws BadArgs {
136                     try {
137                         jartool.modulesToHash = Pattern.compile(arg);
138                     } catch (PatternSyntaxException e) {
139                         throw new BadArgs(&quot;err.badpattern&quot;, arg).showUsage(true);
140                     }
141                 }
142             },
143             new Option(true, OptionType.CREATE_UPDATE, &quot;--module-path&quot;, &quot;-p&quot;) {
144                 void process(Main jartool, String opt, String arg) {
145                     String[] dirs = arg.split(File.pathSeparator);
146                     Path[] paths = new Path[dirs.length];
147                     int i = 0;
148                     for (String dir : dirs) {
149                         paths[i++] = Paths.get(dir);
150                     }
151                     jartool.moduleFinder = ModulePath.of(Runtime.version(), true, paths);
152                 }
153             },
154             new Option(false, OptionType.CREATE_UPDATE, &quot;--do-not-resolve-by-default&quot;) {
155                 void process(Main jartool, String opt, String arg) {
156                     ModuleResolution mres = jartool.moduleResolution;
157                     jartool.moduleResolution = mres.withDoNotResolveByDefault();
158                 }
159                 boolean isExtra() { return true; }
160             },
161             new Option(true, OptionType.CREATE_UPDATE, &quot;--warn-if-resolved&quot;) {
162                 void process(Main jartool, String opt, String arg) throws BadArgs {
163                     ModuleResolution mres = ModuleResolution.empty();
164                     if (jartool.moduleResolution.doNotResolveByDefault()) {
165                         mres.withDoNotResolveByDefault();
166                     }
167                     if (arg.equals(&quot;deprecated&quot;)) {
168                         jartool.moduleResolution = mres.withDeprecated();
169                     } else if (arg.equals(&quot;deprecated-for-removal&quot;)) {
170                         jartool.moduleResolution = mres.withDeprecatedForRemoval();
171                     } else if (arg.equals(&quot;incubating&quot;)) {
172                         jartool.moduleResolution = mres.withIncubating();
173                     } else {
174                         throw new BadArgs(&quot;error.bad.reason&quot;, arg);
175                     }
176                 }
177                 boolean isExtra() { return true; }
178             },
179             new Option(false, OptionType.CREATE_UPDATE_INDEX, &quot;--no-compress&quot;, &quot;-0&quot;) {
180                 void process(Main jartool, String opt, String arg) {
181                     jartool.flag0 = true;
182                 }
183             },
184 
185             // Hidden options
186             new Option(false, OptionType.OTHER, &quot;-P&quot;) {
187                 void process(Main jartool, String opt, String arg) {
188                     jartool.pflag = true;
189                 }
190                 boolean isHidden() { return true; }
191             },
192 
193             // Other options
194             new Option(true, true, OptionType.OTHER, &quot;--help&quot;, &quot;-h&quot;, &quot;-?&quot;) {
195                 void process(Main jartool, String opt, String arg) throws BadArgs {
196                     if (jartool.info == null) {
197                         if (arg == null) {
198                             jartool.info = GNUStyleOptions::printHelp;  //  Main.Info.HELP;
199                             return;
200                         }
201                         if (!arg.equals(&quot;compat&quot;))
202                             throw new BadArgs(&quot;error.illegal.option&quot;, arg).showUsage(true);
203                         // jartool.info = Main.Info.COMPAT_HELP;
204                         jartool.info = GNUStyleOptions::printCompatHelp;
205                     }
206                 }
207             },
208             new Option(false, OptionType.OTHER, &quot;--help-extra&quot;) {
209                 void process(Main jartool, String opt, String arg) throws BadArgs {
210                     jartool.info = GNUStyleOptions::printHelpExtra;
211                 }
212             },
213             new Option(false, OptionType.OTHER, &quot;--version&quot;) {
214                 void process(Main jartool, String opt, String arg) {
215                     if (jartool.info == null)
216                         jartool.info = GNUStyleOptions::printVersion;
217                 }
218             }
219     };
220 
221     enum OptionType {
222         MAIN_OPERATION(&quot;main&quot;),
223         ANY(&quot;any&quot;),
224         CREATE(&quot;create&quot;),
225         CREATE_UPDATE(&quot;create.update&quot;),
226         CREATE_UPDATE_INDEX(&quot;create.update.index&quot;),
227         OTHER(&quot;other&quot;);
228 
229         /** Resource lookup section prefix. */
230         final String name;
231 
232         OptionType(String name) { this.name = name; }
233     }
234 
235     static abstract class Option {
236         final boolean hasArg;
237         final boolean argIsOptional;
238         final String[] aliases;
239         final OptionType type;
240 
241         Option(boolean hasArg, OptionType type, String... aliases) {
242             this(hasArg, false, type, aliases);
243         }
244 
245         Option(boolean hasArg, boolean argIsOptional, OptionType type, String... aliases) {
246             this.hasArg = hasArg;
247             this.argIsOptional = argIsOptional;
248             this.type = type;
249             this.aliases = aliases;
250         }
251 
252         boolean isHidden() { return false; }
253 
254         boolean isExtra() { return false; }
255 
256         boolean matches(String opt) {
257             for (String a : aliases) {
258                 if (a.equals(opt)) {
259                     return true;
260                 } else if (opt.startsWith(&quot;--&quot;) &amp;&amp; hasArg &amp;&amp; opt.startsWith(a + &quot;=&quot;)) {
261                     return true;
262                 } else if (opt.startsWith(&quot;--help&quot;) &amp;&amp; opt.startsWith(a + &quot;:&quot;)) {
263                     return true;
264                 }
265             }
266             return false;
267         }
268 
269         abstract void process(Main jartool, String opt, String arg) throws BadArgs;
270     }
271 
272     static int parseOptions(Main jartool, String[] args) throws BadArgs {
273         int count = 0;
274         if (args.length == 0) {
275             jartool.info = GNUStyleOptions::printUsageTryHelp;  //  never be here
276             return 0;
277         }
278 
279         // process options
280         for (; count &lt; args.length; count++) {
281             if (args[count].charAt(0) != &#39;-&#39; || args[count].equals(&quot;-C&quot;) ||
282                 args[count].equals(&quot;--release&quot;))
283                 break;
284 
285             String name = args[count];
286             if (name.equals(&quot;-XDsuppress-tool-removal-message&quot;)) {
287                 jartool.suppressDeprecateMsg = true;
288                 continue;
289             }
290             Option option = getOption(name);
291             String param = null;
292             if (option.hasArg) {
293                 if (name.startsWith(&quot;--help&quot;)) {  // &quot;special&quot; optional separator
294                     if (name.indexOf(&#39;:&#39;) &gt; 0) {
295                         param = name.substring(name.indexOf(&#39;:&#39;) + 1, name.length());
296                     }
297                 } else if (name.startsWith(&quot;--&quot;) &amp;&amp; name.indexOf(&#39;=&#39;) &gt; 0) {
298                     param = name.substring(name.indexOf(&#39;=&#39;) + 1, name.length());
299                 } else if (count + 1 &lt; args.length) {
300                     param = args[++count];
301                 }
302                 if (!option.argIsOptional &amp;&amp;
303                     (param == null || param.isEmpty() || param.charAt(0) == &#39;-&#39;)) {
304                     throw new BadArgs(&quot;error.missing.arg&quot;, name).showUsage(true);
305                 }
306             }
307             option.process(jartool, name, param);
308         }
309 
310         return count;
311     }
312 
313     private static Option getOption(String name) throws BadArgs {
314         for (Option o : recognizedOptions) {
315             if (o.matches(name)) {
316                 return o;
317             }
318         }
319         throw new BadArgs(&quot;error.unrecognized.option&quot;, name).showUsage(true);
320     }
321 
322     static void printHelpExtra(PrintWriter out) {
323         printHelp0(out, true);
324     }
325 
326     static void printHelp(PrintWriter out) {
327         printHelp0(out, false);
328     }
329 
330     private static void printHelp0(PrintWriter out, boolean printExtra) {
331         out.format(&quot;%s%n&quot;, Main.getMsg(&quot;main.help.preopt&quot;));
332         for (OptionType type : OptionType.values()) {
333             boolean typeHeadingWritten = false;
334 
335             for (Option o : recognizedOptions) {
336                 if (!o.type.equals(type))
337                     continue;
338                 String name = o.aliases[0].substring(1); // there must always be at least one name
339                 name = name.charAt(0) == &#39;-&#39; ? name.substring(1) : name;
340                 if (o.isHidden() || name.equals(&quot;h&quot;)) {
341                     continue;
342                 }
343                 if (o.isExtra() &amp;&amp; !printExtra) {
344                     continue;
345                 }
346                 if (!typeHeadingWritten) {
347                     out.format(&quot;%n%s%n&quot;, Main.getMsg(&quot;main.help.opt.&quot; + type.name));
348                     typeHeadingWritten = true;
349                 }
350                 out.format(&quot;%s%n&quot;, Main.getMsg(&quot;main.help.opt.&quot; + type.name + &quot;.&quot; + name));
351             }
352         }
353         out.format(&quot;%n%s%n%n&quot;, Main.getMsg(&quot;main.help.postopt&quot;));
354     }
355 
356     static void printCompatHelp(PrintWriter out) {
357         out.format(&quot;%s%n&quot;, Main.getMsg(&quot;usage.compat&quot;));
358     }
359 
360     static void printUsageTryHelp(PrintWriter out) {
361         out.format(&quot;%s%n&quot;, Main.getMsg(&quot;main.usage.summary.try&quot;));
362     }
363 
364     static void printVersion(PrintWriter out) {
365         out.format(&quot;%s %s%n&quot;, &quot;jar&quot;, System.getProperty(&quot;java.version&quot;));
366     }
367 }
    </pre>
  </body>
</html>
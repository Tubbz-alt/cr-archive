<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../module-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Resources.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 668         System.out.println();
 669 
 670         System.exit(0);
 671     }
 672 
 673     void verifyJar(String jarName)
 674         throws Exception
 675     {
 676         boolean anySigned = false;  // if there exists entry inside jar signed
 677         JarFile jf = null;
 678         Map&lt;String,String&gt; digestMap = new HashMap&lt;&gt;();
 679         Map&lt;String,PKCS7&gt; sigMap = new HashMap&lt;&gt;();
 680         Map&lt;String,String&gt; sigNameMap = new HashMap&lt;&gt;();
 681         Map&lt;String,String&gt; unparsableSignatures = new HashMap&lt;&gt;();
 682 
 683         try {
 684             jf = new JarFile(jarName, true);
 685             Vector&lt;JarEntry&gt; entriesVec = new Vector&lt;&gt;();
 686             byte[] buffer = new byte[8192];
 687 






 688             Enumeration&lt;JarEntry&gt; entries = jf.entries();
 689             while (entries.hasMoreElements()) {
 690                 JarEntry je = entries.nextElement();
 691                 entriesVec.addElement(je);
 692                 try (InputStream is = jf.getInputStream(je)) {
 693                     String name = je.getName();
 694                     if (signatureRelated(name)
 695                             &amp;&amp; SignatureFileVerifier.isBlockOrSF(name)) {
 696                         String alias = name.substring(name.lastIndexOf(&#39;/&#39;) + 1,
 697                                 name.lastIndexOf(&#39;.&#39;));
 698                         try {
 699                             if (name.endsWith(&quot;.SF&quot;)) {
 700                                 Manifest sf = new Manifest(is);
 701                                 boolean found = false;
 702                                 for (Object obj : sf.getMainAttributes().keySet()) {
 703                                     String key = obj.toString();
<span class="line-modified"> 704                                     if (key.endsWith(&quot;-Digest-Manifest&quot;)) {</span>
<span class="line-modified"> 705                                         digestMap.put(alias,</span>
<span class="line-modified"> 706                                                 key.substring(0, key.length() - 16));</span>





 707                                         found = true;
 708                                         break;
 709                                     }
 710                                 }
 711                                 if (!found) {
 712                                     unparsableSignatures.putIfAbsent(alias,
 713                                         String.format(
 714                                             rb.getString(&quot;history.unparsable&quot;),
 715                                             name));
 716                                 }
 717                             } else {
 718                                 sigNameMap.put(alias, name);
 719                                 sigMap.put(alias, new PKCS7(is));
 720                             }
 721                         } catch (IOException ioe) {
 722                             unparsableSignatures.putIfAbsent(alias, String.format(
 723                                     rb.getString(&quot;history.unparsable&quot;), name));
 724                         }
 725                     } else {
 726                         while (is.read(buffer, 0, buffer.length) != -1) {
</pre>
<hr />
<pre>
1283      * @param checkUsage true to check code signer keyUsage
1284      */
1285     String printCert(boolean isTsCert, String tab, Certificate c,
1286         Date timestamp, boolean checkUsage) throws Exception {
1287 
1288         StringBuilder certStr = new StringBuilder();
1289         String space = rb.getString(&quot;SPACE&quot;);
1290         X509Certificate x509Cert = null;
1291 
1292         if (c instanceof X509Certificate) {
1293             x509Cert = (X509Certificate) c;
1294             certStr.append(tab).append(x509Cert.getType())
1295                 .append(rb.getString(&quot;COMMA&quot;))
1296                 .append(x509Cert.getSubjectDN().getName());
1297         } else {
1298             certStr.append(tab).append(c.getType());
1299         }
1300 
1301         String alias = storeHash.get(c);
1302         if (alias != null) {
<span class="line-modified">1303             certStr.append(space).append(alias);</span>
1304         }
1305 
1306         if (x509Cert != null) {
1307 
1308             certStr.append(&quot;\n&quot;).append(tab).append(&quot;[&quot;);
1309 
1310             if (trustedCerts.contains(x509Cert)) {
1311                 certStr.append(rb.getString(&quot;trusted.certificate&quot;));
1312             } else {
1313                 Date notAfter = x509Cert.getNotAfter();
1314                 try {
1315                     boolean printValidity = true;
1316                     if (isTsCert) {
1317                         if (tsaExpireDate == null || tsaExpireDate.after(notAfter)) {
1318                             tsaExpireDate = notAfter;
1319                         }
1320                     } else {
1321                         if (expireDate == null || expireDate.after(notAfter)) {
1322                             expireDate = notAfter;
1323                         }
</pre>
<hr />
<pre>
1408     private String printTimestamp(String tab, Timestamp timestamp) {
1409 
1410         if (signTimeForm == null) {
1411             signTimeForm =
1412                 new MessageFormat(rb.getString(&quot;entry.was.signed.on&quot;));
1413         }
1414         Object[] source = { timestamp.getTimestamp() };
1415 
1416         return new StringBuilder().append(tab).append(&quot;[&quot;)
1417             .append(signTimeForm.format(source)).append(&quot;]&quot;).toString();
1418     }
1419 
1420     private Map&lt;CodeSigner,Integer&gt; cacheForInKS = new IdentityHashMap&lt;&gt;();
1421 
1422     private int inKeyStoreForOneSigner(CodeSigner signer) {
1423         if (cacheForInKS.containsKey(signer)) {
1424             return cacheForInKS.get(signer);
1425         }
1426 
1427         int result = 0;
<span class="line-modified">1428         List&lt;? extends Certificate&gt; certs = signer.getSignerCertPath().getCertificates();</span>
<span class="line-modified">1429         for (Certificate c : certs) {</span>
<span class="line-modified">1430             String alias = storeHash.get(c);</span>
<span class="line-modified">1431             if (alias != null) {</span>
<span class="line-modified">1432                 if (alias.startsWith(&quot;(&quot;)) {</span>
<span class="line-modified">1433                     result |= IN_KEYSTORE;</span>
<span class="line-modified">1434                 }</span>
<span class="line-removed">1435                 if (ckaliases.contains(alias.substring(1, alias.length() - 1))) {</span>
<span class="line-removed">1436                     result |= SIGNED_BY_ALIAS;</span>
<span class="line-removed">1437                 }</span>
<span class="line-removed">1438             } else {</span>
<span class="line-removed">1439                 if (store != null) {</span>
<span class="line-removed">1440                     try {</span>
1441                         alias = store.getCertificateAlias(c);
<span class="line-modified">1442                     } catch (KeyStoreException kse) {</span>
<span class="line-modified">1443                         // never happens, because keystore has been loaded</span>

1444                     }
1445                     if (alias != null) {
<span class="line-removed">1446                         storeHash.put(c, &quot;(&quot; + alias + &quot;)&quot;);</span>
1447                         result |= IN_KEYSTORE;
1448                     }









1449                 }
<span class="line-modified">1450                 if (ckaliases.contains(alias)) {</span>
<span class="line-modified">1451                     result |= SIGNED_BY_ALIAS;</span>
<span class="line-removed">1452                 }</span>
1453             }
1454         }
1455         cacheForInKS.put(signer, result);
1456         return result;
1457     }
1458 




1459     Hashtable&lt;Certificate, String&gt; storeHash = new Hashtable&lt;&gt;();
1460 
1461     int inKeyStore(CodeSigner[] signers) {
1462 
1463         if (signers == null)
1464             return 0;
1465 
1466         int output = 0;
1467 
1468         for (CodeSigner signer: signers) {
1469             int result = inKeyStoreForOneSigner(signer);
1470             output |= result;
1471         }
1472         if (ckaliases.size() &gt; 0 &amp;&amp; (output &amp; SIGNED_BY_ALIAS) == 0) {
1473             output |= NOT_ALIAS;
1474         }
1475         return output;
1476     }
1477 
1478     void signJar(String jarName, String alias)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 668         System.out.println();
 669 
 670         System.exit(0);
 671     }
 672 
 673     void verifyJar(String jarName)
 674         throws Exception
 675     {
 676         boolean anySigned = false;  // if there exists entry inside jar signed
 677         JarFile jf = null;
 678         Map&lt;String,String&gt; digestMap = new HashMap&lt;&gt;();
 679         Map&lt;String,PKCS7&gt; sigMap = new HashMap&lt;&gt;();
 680         Map&lt;String,String&gt; sigNameMap = new HashMap&lt;&gt;();
 681         Map&lt;String,String&gt; unparsableSignatures = new HashMap&lt;&gt;();
 682 
 683         try {
 684             jf = new JarFile(jarName, true);
 685             Vector&lt;JarEntry&gt; entriesVec = new Vector&lt;&gt;();
 686             byte[] buffer = new byte[8192];
 687 
<span class="line-added"> 688             String suffix1 = &quot;-Digest-Manifest&quot;;</span>
<span class="line-added"> 689             String suffix2 = &quot;-Digest-&quot; + ManifestDigester.MF_MAIN_ATTRS;</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691             int suffixLength1 = suffix1.length();</span>
<span class="line-added"> 692             int suffixLength2 = suffix2.length();</span>
<span class="line-added"> 693 </span>
 694             Enumeration&lt;JarEntry&gt; entries = jf.entries();
 695             while (entries.hasMoreElements()) {
 696                 JarEntry je = entries.nextElement();
 697                 entriesVec.addElement(je);
 698                 try (InputStream is = jf.getInputStream(je)) {
 699                     String name = je.getName();
 700                     if (signatureRelated(name)
 701                             &amp;&amp; SignatureFileVerifier.isBlockOrSF(name)) {
 702                         String alias = name.substring(name.lastIndexOf(&#39;/&#39;) + 1,
 703                                 name.lastIndexOf(&#39;.&#39;));
 704                         try {
 705                             if (name.endsWith(&quot;.SF&quot;)) {
 706                                 Manifest sf = new Manifest(is);
 707                                 boolean found = false;
 708                                 for (Object obj : sf.getMainAttributes().keySet()) {
 709                                     String key = obj.toString();
<span class="line-modified"> 710                                     if (key.endsWith(suffix1)) {</span>
<span class="line-modified"> 711                                         digestMap.put(alias, key.substring(</span>
<span class="line-modified"> 712                                                 0, key.length() - suffixLength1));</span>
<span class="line-added"> 713                                         found = true;</span>
<span class="line-added"> 714                                         break;</span>
<span class="line-added"> 715                                     } else if (key.endsWith(suffix2)) {</span>
<span class="line-added"> 716                                         digestMap.put(alias, key.substring(</span>
<span class="line-added"> 717                                                 0, key.length() - suffixLength2));</span>
 718                                         found = true;
 719                                         break;
 720                                     }
 721                                 }
 722                                 if (!found) {
 723                                     unparsableSignatures.putIfAbsent(alias,
 724                                         String.format(
 725                                             rb.getString(&quot;history.unparsable&quot;),
 726                                             name));
 727                                 }
 728                             } else {
 729                                 sigNameMap.put(alias, name);
 730                                 sigMap.put(alias, new PKCS7(is));
 731                             }
 732                         } catch (IOException ioe) {
 733                             unparsableSignatures.putIfAbsent(alias, String.format(
 734                                     rb.getString(&quot;history.unparsable&quot;), name));
 735                         }
 736                     } else {
 737                         while (is.read(buffer, 0, buffer.length) != -1) {
</pre>
<hr />
<pre>
1294      * @param checkUsage true to check code signer keyUsage
1295      */
1296     String printCert(boolean isTsCert, String tab, Certificate c,
1297         Date timestamp, boolean checkUsage) throws Exception {
1298 
1299         StringBuilder certStr = new StringBuilder();
1300         String space = rb.getString(&quot;SPACE&quot;);
1301         X509Certificate x509Cert = null;
1302 
1303         if (c instanceof X509Certificate) {
1304             x509Cert = (X509Certificate) c;
1305             certStr.append(tab).append(x509Cert.getType())
1306                 .append(rb.getString(&quot;COMMA&quot;))
1307                 .append(x509Cert.getSubjectDN().getName());
1308         } else {
1309             certStr.append(tab).append(c.getType());
1310         }
1311 
1312         String alias = storeHash.get(c);
1313         if (alias != null) {
<span class="line-modified">1314             certStr.append(space).append(&quot;(&quot;).append(alias).append(&quot;)&quot;);</span>
1315         }
1316 
1317         if (x509Cert != null) {
1318 
1319             certStr.append(&quot;\n&quot;).append(tab).append(&quot;[&quot;);
1320 
1321             if (trustedCerts.contains(x509Cert)) {
1322                 certStr.append(rb.getString(&quot;trusted.certificate&quot;));
1323             } else {
1324                 Date notAfter = x509Cert.getNotAfter();
1325                 try {
1326                     boolean printValidity = true;
1327                     if (isTsCert) {
1328                         if (tsaExpireDate == null || tsaExpireDate.after(notAfter)) {
1329                             tsaExpireDate = notAfter;
1330                         }
1331                     } else {
1332                         if (expireDate == null || expireDate.after(notAfter)) {
1333                             expireDate = notAfter;
1334                         }
</pre>
<hr />
<pre>
1419     private String printTimestamp(String tab, Timestamp timestamp) {
1420 
1421         if (signTimeForm == null) {
1422             signTimeForm =
1423                 new MessageFormat(rb.getString(&quot;entry.was.signed.on&quot;));
1424         }
1425         Object[] source = { timestamp.getTimestamp() };
1426 
1427         return new StringBuilder().append(tab).append(&quot;[&quot;)
1428             .append(signTimeForm.format(source)).append(&quot;]&quot;).toString();
1429     }
1430 
1431     private Map&lt;CodeSigner,Integer&gt; cacheForInKS = new IdentityHashMap&lt;&gt;();
1432 
1433     private int inKeyStoreForOneSigner(CodeSigner signer) {
1434         if (cacheForInKS.containsKey(signer)) {
1435             return cacheForInKS.get(signer);
1436         }
1437 
1438         int result = 0;
<span class="line-modified">1439         if (store != null) {</span>
<span class="line-modified">1440             try {</span>
<span class="line-modified">1441                 List&lt;? extends Certificate&gt; certs =</span>
<span class="line-modified">1442                         signer.getSignerCertPath().getCertificates();</span>
<span class="line-modified">1443                 for (Certificate c : certs) {</span>
<span class="line-modified">1444                     String alias = storeHash.get(c);</span>
<span class="line-modified">1445                     if (alias == null) {</span>






1446                         alias = store.getCertificateAlias(c);
<span class="line-modified">1447                         if (alias != null) {</span>
<span class="line-modified">1448                             storeHash.put(c, alias);</span>
<span class="line-added">1449                         }</span>
1450                     }
1451                     if (alias != null) {

1452                         result |= IN_KEYSTORE;
1453                     }
<span class="line-added">1454                     for (String ckalias : ckaliases) {</span>
<span class="line-added">1455                         if (c.equals(store.getCertificate(ckalias))) {</span>
<span class="line-added">1456                             result |= SIGNED_BY_ALIAS;</span>
<span class="line-added">1457                             // must continue with next certificate c and cannot</span>
<span class="line-added">1458                             // return or break outer loop because has to fill</span>
<span class="line-added">1459                             // storeHash for printCert</span>
<span class="line-added">1460                             break;</span>
<span class="line-added">1461                         }</span>
<span class="line-added">1462                     }</span>
1463                 }
<span class="line-modified">1464             } catch (KeyStoreException kse) {</span>
<span class="line-modified">1465                 // never happens, because keystore has been loaded</span>

1466             }
1467         }
1468         cacheForInKS.put(signer, result);
1469         return result;
1470     }
1471 
<span class="line-added">1472     /**</span>
<span class="line-added">1473      * Maps certificates (as keys) to alias names associated in the keystore</span>
<span class="line-added">1474      * {@link #store} (as values).</span>
<span class="line-added">1475      */</span>
1476     Hashtable&lt;Certificate, String&gt; storeHash = new Hashtable&lt;&gt;();
1477 
1478     int inKeyStore(CodeSigner[] signers) {
1479 
1480         if (signers == null)
1481             return 0;
1482 
1483         int output = 0;
1484 
1485         for (CodeSigner signer: signers) {
1486             int result = inKeyStoreForOneSigner(signer);
1487             output |= result;
1488         }
1489         if (ckaliases.size() &gt; 0 &amp;&amp; (output &amp; SIGNED_BY_ALIAS) == 0) {
1490             output |= NOT_ALIAS;
1491         }
1492         return output;
1493     }
1494 
1495     void signJar(String jarName, String alias)
</pre>
</td>
</tr>
</table>
<center><a href="../../../../module-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Resources.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jartool/share/classes/sun/tools/jar/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="GNUStyleOptions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="resources/jar.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jartool/share/classes/sun/tools/jar/Main.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 133     // if --release option found followed by at least file
 134     boolean isMultiRelease;
 135 
 136     // The last parsed --release value, if any. Used in conjunction with
 137     // &quot;-d,--describe-module&quot; to select the operative module descriptor.
 138     int releaseValue = -1;
 139 
 140     /*
 141      * cflag: create
 142      * uflag: update
 143      * xflag: xtract
 144      * tflag: table
 145      * vflag: verbose
 146      * flag0: no zip compression (store only)
 147      * Mflag: DO NOT generate a manifest file (just ZIP)
 148      * iflag: generate jar index
 149      * nflag: Perform jar normalization at the end
 150      * pflag: preserve/don&#39;t strip leading slash and .. component from file name
 151      * dflag: print module descriptor
 152      */
<span class="line-modified"> 153     boolean cflag, uflag, xflag, tflag, vflag, flag0, Mflag, iflag, nflag, pflag, dflag;</span>
 154 
 155     boolean suppressDeprecateMsg = false;
 156 
 157     /* To support additional GNU Style informational options */
 158     Consumer&lt;PrintWriter&gt; info;
 159 
 160     /* Modular jar related options */
 161     Version moduleVersion;
 162     Pattern modulesToHash;
 163     ModuleResolution moduleResolution = ModuleResolution.empty();
 164     ModuleFinder moduleFinder = ModuleFinder.of();
 165 
 166     static final String MODULE_INFO = &quot;module-info.class&quot;;
 167     static final String MANIFEST_DIR = &quot;META-INF/&quot;;
 168     static final String VERSIONS_DIR = MANIFEST_DIR + &quot;versions/&quot;;
 169     static final String VERSION = &quot;1.0&quot;;
 170     static final int VERSIONS_DIR_LENGTH = VERSIONS_DIR.length();
 171     private static ResourceBundle rsrc;
 172 
 173     /**
</pre>
<hr />
<pre>
 301                         return false;
 302 
 303                 } else if (moduleVersion != null || modulesToHash != null) {
 304                     error(getMsg(&quot;error.module.options.without.info&quot;));
 305                     return false;
 306                 }
 307                 if (vflag &amp;&amp; fname == null) {
 308                     // Disable verbose output so that it does not appear
 309                     // on stdout along with file data
 310                     // error(&quot;Warning: -v option ignored&quot;);
 311                     vflag = false;
 312                 }
 313                 final String tmpbase = (fname == null)
 314                         ? &quot;tmpjar&quot;
 315                         : fname.substring(fname.indexOf(File.separatorChar) + 1);
 316 
 317                 tmpFile = createTemporaryFile(tmpbase, &quot;.jar&quot;);
 318                 try (OutputStream out = new FileOutputStream(tmpFile)) {
 319                     create(new BufferedOutputStream(out, 4096), manifest);
 320                 }
<span class="line-removed"> 321                 if (nflag) {</span>
<span class="line-removed"> 322                     if (!suppressDeprecateMsg) {</span>
<span class="line-removed"> 323                         warn(formatMsg(&quot;warn.flag.is.deprecated&quot;, &quot;-n&quot;));</span>
<span class="line-removed"> 324                     }</span>
<span class="line-removed"> 325                     File packFile = createTemporaryFile(tmpbase, &quot;.pack&quot;);</span>
<span class="line-removed"> 326                     try {</span>
<span class="line-removed"> 327                         java.util.jar.Pack200.Packer packer = java.util.jar.Pack200.newPacker();</span>
<span class="line-removed"> 328                         Map&lt;String, String&gt; p = packer.properties();</span>
<span class="line-removed"> 329                         p.put(java.util.jar.Pack200.Packer.EFFORT, &quot;1&quot;); // Minimal effort to conserve CPU</span>
<span class="line-removed"> 330                         try (JarFile jarFile = new JarFile(tmpFile.getCanonicalPath());</span>
<span class="line-removed"> 331                              OutputStream pack = new FileOutputStream(packFile))</span>
<span class="line-removed"> 332                         {</span>
<span class="line-removed"> 333                             packer.pack(jarFile, pack);</span>
<span class="line-removed"> 334                         }</span>
<span class="line-removed"> 335                         if (tmpFile.exists()) {</span>
<span class="line-removed"> 336                             tmpFile.delete();</span>
<span class="line-removed"> 337                         }</span>
<span class="line-removed"> 338                         tmpFile = createTemporaryFile(tmpbase, &quot;.jar&quot;);</span>
<span class="line-removed"> 339                         try (OutputStream out = new FileOutputStream(tmpFile);</span>
<span class="line-removed"> 340                              JarOutputStream jos = new JarOutputStream(out))</span>
<span class="line-removed"> 341                         {</span>
<span class="line-removed"> 342                             java.util.jar.Pack200.Unpacker unpacker = java.util.jar.Pack200.newUnpacker();</span>
<span class="line-removed"> 343                             unpacker.unpack(packFile, jos);</span>
<span class="line-removed"> 344                         }</span>
<span class="line-removed"> 345                     } finally {</span>
<span class="line-removed"> 346                         Files.deleteIfExists(packFile.toPath());</span>
<span class="line-removed"> 347                     }</span>
<span class="line-removed"> 348                 }</span>
 349                 validateAndClose(tmpFile);
 350             } else if (uflag) {
 351                 File inputFile = null;
 352                 if (fname != null) {
 353                     inputFile = new File(fname);
 354                     tmpFile = createTempFileInSameDirectoryAs(inputFile);
 355                 } else {
 356                     vflag = false;
 357                     tmpFile = createTemporaryFile(&quot;tmpjar&quot;, &quot;.jar&quot;);
 358                 }
 359                 expand();
 360                 try (FileInputStream in = (fname != null) ? new FileInputStream(inputFile)
 361                         : new FileInputStream(FileDescriptor.in);
 362                      FileOutputStream out = new FileOutputStream(tmpFile);
 363                      InputStream manifest = (!Mflag &amp;&amp; (mname != null)) ?
 364                             (new FileInputStream(mname)) : null;
 365                 ) {
 366                     boolean updateOk = update(in, new BufferedOutputStream(out),
 367                         manifest, moduleInfos, null);
 368                     if (ok) {
</pre>
<hr />
<pre>
 570                             vflag = true;
 571                             break;
 572                         case &#39;f&#39;:
 573                             fname = args[count++];
 574                             break;
 575                         case &#39;m&#39;:
 576                             mname = args[count++];
 577                             break;
 578                         case &#39;0&#39;:
 579                             flag0 = true;
 580                             break;
 581                         case &#39;i&#39;:
 582                             if (cflag || uflag || xflag || tflag) {
 583                                 usageError(getMsg(&quot;error.multiple.main.operations&quot;));
 584                                 return false;
 585                             }
 586                             // do not increase the counter, files will contain rootjar
 587                             rootjar = args[count++];
 588                             iflag = true;
 589                             break;
<span class="line-removed"> 590                         case &#39;n&#39;:</span>
<span class="line-removed"> 591                             nflag = true;</span>
<span class="line-removed"> 592                             break;</span>
 593                         case &#39;e&#39;:
 594                             ename = args[count++];
 595                             break;
 596                         case &#39;P&#39;:
 597                             pflag = true;
 598                             break;
 599                         default:
 600                             usageError(formatMsg(&quot;error.illegal.option&quot;,
 601                                        String.valueOf(flags.charAt(i))));
 602                             return false;
 603                     }
 604                 }
 605             }
 606         } catch (ArrayIndexOutOfBoundsException e) {
 607             usageError(getMsg(&quot;main.usage.summary&quot;));
 608             return false;
 609         }
 610         if (!cflag &amp;&amp; !tflag &amp;&amp; !xflag &amp;&amp; !uflag &amp;&amp; !iflag &amp;&amp; !dflag) {
 611             usageError(getMsg(&quot;error.bad.option&quot;));
 612             return false;
</pre>
<hr />
<pre>
 927             addIndex(jarIndex, zos);
 928         }
 929 
 930         // put the old entries first, replace if necessary
 931         while ((e = zis.getNextEntry()) != null) {
 932             String name = e.getName();
 933 
 934             boolean isManifestEntry = equalsIgnoreCase(name, MANIFEST_NAME);
 935             boolean isModuleInfoEntry = isModuleInfoEntry(name);
 936 
 937             if ((jarIndex != null &amp;&amp; equalsIgnoreCase(name, INDEX_NAME))
 938                 || (Mflag &amp;&amp; isManifestEntry)) {
 939                 continue;
 940             } else if (isManifestEntry &amp;&amp; ((newManifest != null) ||
 941                         (ename != null) || isMultiRelease)) {
 942                 foundManifest = true;
 943                 if (newManifest != null) {
 944                     // Don&#39;t read from the newManifest InputStream, as we
 945                     // might need it below, and we can&#39;t re-read the same data
 946                     // twice.
<span class="line-modified"> 947                     FileInputStream fis = new FileInputStream(mname);</span>
<span class="line-modified"> 948                     boolean ambiguous = isAmbiguousMainClass(new Manifest(fis));</span>
<span class="line-modified"> 949                     fis.close();</span>
<span class="line-modified"> 950                     if (ambiguous) {</span>
<span class="line-removed"> 951                         return false;</span>
 952                     }
 953                 }
 954                 // Update the manifest.
 955                 Manifest old = new Manifest(zis);
 956                 if (newManifest != null) {
 957                     old.read(newManifest);
 958                 }
 959                 if (!updateManifest(old, zos)) {
 960                     return false;
 961                 }
 962             } else if (moduleInfos != null &amp;&amp; isModuleInfoEntry) {
 963                 moduleInfos.putIfAbsent(name, zis.readAllBytes());
 964             } else {
 965                 boolean isDir = e.isDirectory();
 966                 if (!entryMap.containsKey(name)) { // copy the old stuff
 967                     // do our own compression
 968                     ZipEntry e2 = new ZipEntry(name);
 969                     e2.setMethod(e.getMethod());
 970                     e2.setTime(e.getTime());
 971                     e2.setComment(e.getComment());
</pre>
</td>
<td>
<hr />
<pre>
 133     // if --release option found followed by at least file
 134     boolean isMultiRelease;
 135 
 136     // The last parsed --release value, if any. Used in conjunction with
 137     // &quot;-d,--describe-module&quot; to select the operative module descriptor.
 138     int releaseValue = -1;
 139 
 140     /*
 141      * cflag: create
 142      * uflag: update
 143      * xflag: xtract
 144      * tflag: table
 145      * vflag: verbose
 146      * flag0: no zip compression (store only)
 147      * Mflag: DO NOT generate a manifest file (just ZIP)
 148      * iflag: generate jar index
 149      * nflag: Perform jar normalization at the end
 150      * pflag: preserve/don&#39;t strip leading slash and .. component from file name
 151      * dflag: print module descriptor
 152      */
<span class="line-modified"> 153     boolean cflag, uflag, xflag, tflag, vflag, flag0, Mflag, iflag, pflag, dflag;</span>
 154 
 155     boolean suppressDeprecateMsg = false;
 156 
 157     /* To support additional GNU Style informational options */
 158     Consumer&lt;PrintWriter&gt; info;
 159 
 160     /* Modular jar related options */
 161     Version moduleVersion;
 162     Pattern modulesToHash;
 163     ModuleResolution moduleResolution = ModuleResolution.empty();
 164     ModuleFinder moduleFinder = ModuleFinder.of();
 165 
 166     static final String MODULE_INFO = &quot;module-info.class&quot;;
 167     static final String MANIFEST_DIR = &quot;META-INF/&quot;;
 168     static final String VERSIONS_DIR = MANIFEST_DIR + &quot;versions/&quot;;
 169     static final String VERSION = &quot;1.0&quot;;
 170     static final int VERSIONS_DIR_LENGTH = VERSIONS_DIR.length();
 171     private static ResourceBundle rsrc;
 172 
 173     /**
</pre>
<hr />
<pre>
 301                         return false;
 302 
 303                 } else if (moduleVersion != null || modulesToHash != null) {
 304                     error(getMsg(&quot;error.module.options.without.info&quot;));
 305                     return false;
 306                 }
 307                 if (vflag &amp;&amp; fname == null) {
 308                     // Disable verbose output so that it does not appear
 309                     // on stdout along with file data
 310                     // error(&quot;Warning: -v option ignored&quot;);
 311                     vflag = false;
 312                 }
 313                 final String tmpbase = (fname == null)
 314                         ? &quot;tmpjar&quot;
 315                         : fname.substring(fname.indexOf(File.separatorChar) + 1);
 316 
 317                 tmpFile = createTemporaryFile(tmpbase, &quot;.jar&quot;);
 318                 try (OutputStream out = new FileOutputStream(tmpFile)) {
 319                     create(new BufferedOutputStream(out, 4096), manifest);
 320                 }




























 321                 validateAndClose(tmpFile);
 322             } else if (uflag) {
 323                 File inputFile = null;
 324                 if (fname != null) {
 325                     inputFile = new File(fname);
 326                     tmpFile = createTempFileInSameDirectoryAs(inputFile);
 327                 } else {
 328                     vflag = false;
 329                     tmpFile = createTemporaryFile(&quot;tmpjar&quot;, &quot;.jar&quot;);
 330                 }
 331                 expand();
 332                 try (FileInputStream in = (fname != null) ? new FileInputStream(inputFile)
 333                         : new FileInputStream(FileDescriptor.in);
 334                      FileOutputStream out = new FileOutputStream(tmpFile);
 335                      InputStream manifest = (!Mflag &amp;&amp; (mname != null)) ?
 336                             (new FileInputStream(mname)) : null;
 337                 ) {
 338                     boolean updateOk = update(in, new BufferedOutputStream(out),
 339                         manifest, moduleInfos, null);
 340                     if (ok) {
</pre>
<hr />
<pre>
 542                             vflag = true;
 543                             break;
 544                         case &#39;f&#39;:
 545                             fname = args[count++];
 546                             break;
 547                         case &#39;m&#39;:
 548                             mname = args[count++];
 549                             break;
 550                         case &#39;0&#39;:
 551                             flag0 = true;
 552                             break;
 553                         case &#39;i&#39;:
 554                             if (cflag || uflag || xflag || tflag) {
 555                                 usageError(getMsg(&quot;error.multiple.main.operations&quot;));
 556                                 return false;
 557                             }
 558                             // do not increase the counter, files will contain rootjar
 559                             rootjar = args[count++];
 560                             iflag = true;
 561                             break;



 562                         case &#39;e&#39;:
 563                             ename = args[count++];
 564                             break;
 565                         case &#39;P&#39;:
 566                             pflag = true;
 567                             break;
 568                         default:
 569                             usageError(formatMsg(&quot;error.illegal.option&quot;,
 570                                        String.valueOf(flags.charAt(i))));
 571                             return false;
 572                     }
 573                 }
 574             }
 575         } catch (ArrayIndexOutOfBoundsException e) {
 576             usageError(getMsg(&quot;main.usage.summary&quot;));
 577             return false;
 578         }
 579         if (!cflag &amp;&amp; !tflag &amp;&amp; !xflag &amp;&amp; !uflag &amp;&amp; !iflag &amp;&amp; !dflag) {
 580             usageError(getMsg(&quot;error.bad.option&quot;));
 581             return false;
</pre>
<hr />
<pre>
 896             addIndex(jarIndex, zos);
 897         }
 898 
 899         // put the old entries first, replace if necessary
 900         while ((e = zis.getNextEntry()) != null) {
 901             String name = e.getName();
 902 
 903             boolean isManifestEntry = equalsIgnoreCase(name, MANIFEST_NAME);
 904             boolean isModuleInfoEntry = isModuleInfoEntry(name);
 905 
 906             if ((jarIndex != null &amp;&amp; equalsIgnoreCase(name, INDEX_NAME))
 907                 || (Mflag &amp;&amp; isManifestEntry)) {
 908                 continue;
 909             } else if (isManifestEntry &amp;&amp; ((newManifest != null) ||
 910                         (ename != null) || isMultiRelease)) {
 911                 foundManifest = true;
 912                 if (newManifest != null) {
 913                     // Don&#39;t read from the newManifest InputStream, as we
 914                     // might need it below, and we can&#39;t re-read the same data
 915                     // twice.
<span class="line-modified"> 916                     try (FileInputStream fis = new FileInputStream(mname)) {</span>
<span class="line-modified"> 917                         if (isAmbiguousMainClass(new Manifest(fis))) {</span>
<span class="line-modified"> 918                             return false;</span>
<span class="line-modified"> 919                         }</span>

 920                     }
 921                 }
 922                 // Update the manifest.
 923                 Manifest old = new Manifest(zis);
 924                 if (newManifest != null) {
 925                     old.read(newManifest);
 926                 }
 927                 if (!updateManifest(old, zos)) {
 928                     return false;
 929                 }
 930             } else if (moduleInfos != null &amp;&amp; isModuleInfoEntry) {
 931                 moduleInfos.putIfAbsent(name, zis.readAllBytes());
 932             } else {
 933                 boolean isDir = e.isDirectory();
 934                 if (!entryMap.containsKey(name)) { // copy the old stuff
 935                     // do our own compression
 936                     ZipEntry e2 = new ZipEntry(name);
 937                     e2.setMethod(e.getMethod());
 938                     e2.setTime(e.getTime());
 939                     e2.setComment(e.getComment());
</pre>
</td>
</tr>
</table>
<center><a href="GNUStyleOptions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="resources/jar.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
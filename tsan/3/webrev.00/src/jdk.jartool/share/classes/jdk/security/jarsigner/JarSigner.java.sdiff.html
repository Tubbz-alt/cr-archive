<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../jdk.internal.vm.compiler/share/classes/org.graalvm.util.test/src/org/graalvm/util/test/CollectionSizeTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../module-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 654     private void sign0(ZipFile zipFile, OutputStream os)
 655             throws IOException, CertificateException, NoSuchAlgorithmException,
 656             SignatureException, InvalidKeyException {
 657         MessageDigest[] digests;
 658         try {
 659             digests = new MessageDigest[digestalg.length];
 660             for (int i = 0; i &lt; digestalg.length; i++) {
 661                 if (digestProvider == null) {
 662                     digests[i] = MessageDigest.getInstance(digestalg[i]);
 663                 } else {
 664                     digests[i] = MessageDigest.getInstance(
 665                             digestalg[i], digestProvider);
 666                 }
 667             }
 668         } catch (NoSuchAlgorithmException asae) {
 669             // Should not happen. User provided alg were checked, and default
 670             // alg should always be available.
 671             throw new AssertionError(asae);
 672         }
 673 
<span class="line-modified"> 674         PrintStream ps = new PrintStream(os);</span>
<span class="line-removed"> 675         ZipOutputStream zos = new ZipOutputStream(ps);</span>
 676 
 677         Manifest manifest = new Manifest();
<span class="line-removed"> 678         Map&lt;String, Attributes&gt; mfEntries = manifest.getEntries();</span>
<span class="line-removed"> 679 </span>
<span class="line-removed"> 680         // The Attributes of manifest before updating</span>
<span class="line-removed"> 681         Attributes oldAttr = null;</span>
<span class="line-removed"> 682 </span>
<span class="line-removed"> 683         boolean mfModified = false;</span>
<span class="line-removed"> 684         boolean mfCreated = false;</span>
 685         byte[] mfRawBytes = null;
 686 
 687         // Check if manifest exists
<span class="line-modified"> 688         ZipEntry mfFile;</span>
<span class="line-modified"> 689         if ((mfFile = getManifestFile(zipFile)) != null) {</span>

 690             // Manifest exists. Read its raw bytes.
 691             mfRawBytes = zipFile.getInputStream(mfFile).readAllBytes();
 692             manifest.read(new ByteArrayInputStream(mfRawBytes));
<span class="line-removed"> 693             oldAttr = (Attributes) (manifest.getMainAttributes().clone());</span>
 694         } else {
 695             // Create new manifest
 696             Attributes mattr = manifest.getMainAttributes();
 697             mattr.putValue(Attributes.Name.MANIFEST_VERSION.toString(),
 698                     &quot;1.0&quot;);
 699             String javaVendor = System.getProperty(&quot;java.vendor&quot;);
 700             String jdkVersion = System.getProperty(&quot;java.version&quot;);
 701             mattr.putValue(&quot;Created-By&quot;, jdkVersion + &quot; (&quot; + javaVendor
 702                     + &quot;)&quot;);
 703             mfFile = new ZipEntry(JarFile.MANIFEST_NAME);
<span class="line-removed"> 704             mfCreated = true;</span>
 705         }
 706 
 707         /*
 708          * For each entry in jar
 709          * (except for signature-related META-INF entries),
 710          * do the following:
 711          *
 712          * - if entry is not contained in manifest, add it to manifest;
 713          * - if entry is contained in manifest, calculate its hash and
 714          *   compare it with the one in the manifest; if they are
 715          *   different, replace the hash in the manifest with the newly
 716          *   generated one. (This may invalidate existing signatures!)
 717          */
 718         Vector&lt;ZipEntry&gt; mfFiles = new Vector&lt;&gt;();
 719 
 720         boolean wasSigned = false;
 721 
 722         for (Enumeration&lt;? extends ZipEntry&gt; enum_ = zipFile.entries();
 723              enum_.hasMoreElements(); ) {
 724             ZipEntry ze = enum_.nextElement();
 725 
 726             if (ze.getName().startsWith(META_INF)) {
 727                 // Store META-INF files in vector, so they can be written
 728                 // out first
 729                 mfFiles.addElement(ze);
 730 
<span class="line-modified"> 731                 if (SignatureFileVerifier.isBlockOrSF(</span>
<span class="line-modified"> 732                         ze.getName().toUpperCase(Locale.ENGLISH))) {</span>




 733                     wasSigned = true;
 734                 }
 735 
 736                 if (SignatureFileVerifier.isSigningRelated(ze.getName())) {
 737                     // ignore signature-related and manifest files
 738                     continue;
 739                 }
 740             }
 741 
 742             if (manifest.getAttributes(ze.getName()) != null) {
 743                 // jar entry is contained in manifest, check and
 744                 // possibly update its digest attributes
<span class="line-modified"> 745                 if (updateDigests(ze, zipFile, digests,</span>
<span class="line-removed"> 746                         manifest)) {</span>
<span class="line-removed"> 747                     mfModified = true;</span>
<span class="line-removed"> 748                 }</span>
 749             } else if (!ze.isDirectory()) {
 750                 // Add entry to manifest
 751                 Attributes attrs = getDigestAttributes(ze, zipFile, digests);
<span class="line-modified"> 752                 mfEntries.put(ze.getName(), attrs);</span>
<span class="line-removed"> 753                 mfModified = true;</span>
 754             }
 755         }
 756 
<span class="line-modified"> 757         // Recalculate the manifest raw bytes if necessary</span>
<span class="line-modified"> 758         if (mfModified) {</span>
<span class="line-modified"> 759             ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>










 760             manifest.write(baos);
<span class="line-modified"> 761             if (wasSigned) {</span>
<span class="line-modified"> 762                 byte[] newBytes = baos.toByteArray();</span>
<span class="line-modified"> 763                 if (mfRawBytes != null</span>
<span class="line-modified"> 764                         &amp;&amp; oldAttr.equals(manifest.getMainAttributes())) {</span>
<span class="line-modified"> 765 </span>
<span class="line-modified"> 766                     /*</span>
<span class="line-modified"> 767                      * Note:</span>
<span class="line-modified"> 768                      *</span>
<span class="line-modified"> 769                      * The Attributes object is based on HashMap and can handle</span>
<span class="line-modified"> 770                      * continuation columns. Therefore, even if the contents are</span>
<span class="line-modified"> 771                      * not changed (in a Map view), the bytes that it write()</span>
<span class="line-modified"> 772                      * may be different from the original bytes that it read()</span>
<span class="line-modified"> 773                      * from. Since the signature on the main attributes is based</span>
<span class="line-modified"> 774                      * on raw bytes, we must retain the exact bytes.</span>
<span class="line-modified"> 775                      */</span>
<span class="line-modified"> 776 </span>
<span class="line-modified"> 777                     int newPos = findHeaderEnd(newBytes);</span>
<span class="line-modified"> 778                     int oldPos = findHeaderEnd(mfRawBytes);</span>
<span class="line-modified"> 779 </span>
<span class="line-modified"> 780                     if (newPos == oldPos) {</span>
<span class="line-modified"> 781                         System.arraycopy(mfRawBytes, 0, newBytes, 0, oldPos);</span>















 782                     } else {
<span class="line-modified"> 783                         // cat oldHead newTail &gt; newBytes</span>
<span class="line-removed"> 784                         byte[] lastBytes = new byte[oldPos +</span>
<span class="line-removed"> 785                                 newBytes.length - newPos];</span>
<span class="line-removed"> 786                         System.arraycopy(mfRawBytes, 0, lastBytes, 0, oldPos);</span>
<span class="line-removed"> 787                         System.arraycopy(newBytes, newPos, lastBytes, oldPos,</span>
<span class="line-removed"> 788                                 newBytes.length - newPos);</span>
<span class="line-removed"> 789                         newBytes = lastBytes;</span>
 790                     }
 791                 }
<span class="line-modified"> 792                 mfRawBytes = newBytes;</span>
<span class="line-removed"> 793             } else {</span>
 794                 mfRawBytes = baos.toByteArray();
 795             }
 796         }
 797 
 798         // Write out the manifest
 799         if (mfModified) {
 800             // manifest file has new length
 801             mfFile = new ZipEntry(JarFile.MANIFEST_NAME);
 802         }
 803         if (handler != null) {
<span class="line-modified"> 804             if (mfCreated) {</span>
 805                 handler.accept(&quot;adding&quot;, mfFile.getName());
<span class="line-modified"> 806             } else if (mfModified) {</span>
 807                 handler.accept(&quot;updating&quot;, mfFile.getName());
 808             }
 809         }
<span class="line-removed"> 810 </span>
 811         zos.putNextEntry(mfFile);
 812         zos.write(mfRawBytes);
 813 
 814         // Calculate SignatureFile (&quot;.SF&quot;) and SignatureBlockFile
 815         ManifestDigester manDig = new ManifestDigester(mfRawBytes);
 816         SignatureFile sf = new SignatureFile(digests, manifest, manDig,
 817                 signerName, signManifest);
 818 
 819         byte[] block;
 820 
 821         Signature signer;
 822         if (sigProvider == null ) {
 823             signer = Signature.getInstance(sigalg);
 824         } else {
 825             signer = Signature.getInstance(sigalg, sigProvider);
 826         }
 827         signer.initSign(privateKey);
 828 
<span class="line-modified"> 829         ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
 830         sf.write(baos);
<span class="line-removed"> 831 </span>
 832         byte[] content = baos.toByteArray();
 833 
 834         signer.update(content);
 835         byte[] signature = signer.sign();
 836 
 837         @SuppressWarnings(&quot;deprecation&quot;)
 838         ContentSigner signingMechanism = null;
 839         if (altSigner != null) {
 840             signingMechanism = loadSigningMechanism(altSigner,
 841                     altSignerPath);
 842         }
 843 
 844         @SuppressWarnings(&quot;deprecation&quot;)
 845         ContentSignerParameters params =
 846                 new JarSignerParameters(null, tsaUrl, tSAPolicyID,
 847                         tSADigestAlg, signature,
 848                         signer.getAlgorithm(), certChain, content, zipFile);
 849         block = sf.generateBlock(params, externalSF, signingMechanism);
 850 
 851         String sfFilename = sf.getMetaName();
</pre>
<hr />
<pre>
 872 
 873         // signature block file
 874         zos.putNextEntry(bkFile);
 875         zos.write(block);
 876 
 877         if (handler != null) {
 878             if (zipFile.getEntry(bkFilename) != null) {
 879                 handler.accept(&quot;updating&quot;, bkFilename);
 880             } else {
 881                 handler.accept(&quot;adding&quot;, bkFilename);
 882             }
 883         }
 884 
 885         // Write out all other META-INF files that we stored in the
 886         // vector
 887         for (int i = 0; i &lt; mfFiles.size(); i++) {
 888             ZipEntry ze = mfFiles.elementAt(i);
 889             if (!ze.getName().equalsIgnoreCase(JarFile.MANIFEST_NAME)
 890                     &amp;&amp; !ze.getName().equalsIgnoreCase(sfFilename)
 891                     &amp;&amp; !ze.getName().equalsIgnoreCase(bkFilename)) {








 892                 if (handler != null) {
 893                     if (manifest.getAttributes(ze.getName()) != null) {
 894                         handler.accept(&quot;signing&quot;, ze.getName());
 895                     } else if (!ze.isDirectory()) {
 896                         handler.accept(&quot;adding&quot;, ze.getName());
 897                     }
 898                 }
 899                 writeEntry(zipFile, zos, ze);
 900             }
 901         }
 902 
 903         // Write out all other files
 904         for (Enumeration&lt;? extends ZipEntry&gt; enum_ = zipFile.entries();
 905              enum_.hasMoreElements(); ) {
 906             ZipEntry ze = enum_.nextElement();
 907 
 908             if (!ze.getName().startsWith(META_INF)) {
 909                 if (handler != null) {
 910                     if (manifest.getAttributes(ze.getName()) != null) {
 911                         handler.accept(&quot;signing&quot;, ze.getName());
</pre>
<hr />
<pre>
 925         ZipEntry ze2 = new ZipEntry(ze.getName());
 926         ze2.setMethod(ze.getMethod());
 927         ze2.setTime(ze.getTime());
 928         ze2.setComment(ze.getComment());
 929         ze2.setExtra(ze.getExtra());
 930         if (ze.getMethod() == ZipEntry.STORED) {
 931             ze2.setSize(ze.getSize());
 932             ze2.setCrc(ze.getCrc());
 933         }
 934         os.putNextEntry(ze2);
 935         writeBytes(zf, ze, os);
 936     }
 937 
 938     private void writeBytes
 939             (ZipFile zf, ZipEntry ze, ZipOutputStream os) throws IOException {
 940         try (InputStream is = zf.getInputStream(ze)) {
 941             is.transferTo(os);
 942         }
 943     }
 944 
<span class="line-modified"> 945     private boolean updateDigests(ZipEntry ze, ZipFile zf,</span>
 946                                   MessageDigest[] digests,
 947                                   Manifest mf) throws IOException {
<span class="line-removed"> 948         boolean update = false;</span>
<span class="line-removed"> 949 </span>
 950         Attributes attrs = mf.getAttributes(ze.getName());
 951         String[] base64Digests = getDigests(ze, zf, digests);
 952 
 953         for (int i = 0; i &lt; digests.length; i++) {
 954             // The entry name to be written into attrs
 955             String name = null;
 956             try {
 957                 // Find if the digest already exists. An algorithm could have
 958                 // different names. For example, last time it was SHA, and this
 959                 // time it&#39;s SHA-1.
 960                 AlgorithmId aid = AlgorithmId.get(digests[i].getAlgorithm());
 961                 for (Object key : attrs.keySet()) {
 962                     if (key instanceof Attributes.Name) {
 963                         String n = key.toString();
 964                         if (n.toUpperCase(Locale.ENGLISH).endsWith(&quot;-DIGEST&quot;)) {
 965                             String tmp = n.substring(0, n.length() - 7);
 966                             if (AlgorithmId.get(tmp).equals(aid)) {
 967                                 name = n;
 968                                 break;
 969                             }
 970                         }
 971                     }
 972                 }
 973             } catch (NoSuchAlgorithmException nsae) {
 974                 // Ignored. Writing new digest entry.
 975             }
 976 
 977             if (name == null) {
 978                 name = digests[i].getAlgorithm() + &quot;-Digest&quot;;
<span class="line-removed"> 979                 attrs.putValue(name, base64Digests[i]);</span>
<span class="line-removed"> 980                 update = true;</span>
<span class="line-removed"> 981             } else {</span>
<span class="line-removed"> 982                 // compare digests, and replace the one in the manifest</span>
<span class="line-removed"> 983                 // if they are different</span>
<span class="line-removed"> 984                 String mfDigest = attrs.getValue(name);</span>
<span class="line-removed"> 985                 if (!mfDigest.equalsIgnoreCase(base64Digests[i])) {</span>
<span class="line-removed"> 986                     attrs.putValue(name, base64Digests[i]);</span>
<span class="line-removed"> 987                     update = true;</span>
<span class="line-removed"> 988                 }</span>
 989             }

 990         }
<span class="line-removed"> 991         return update;</span>
 992     }
 993 
 994     private Attributes getDigestAttributes(
 995             ZipEntry ze, ZipFile zf, MessageDigest[] digests)
 996             throws IOException {
 997 
 998         String[] base64Digests = getDigests(ze, zf, digests);
 999         Attributes attrs = new Attributes();
1000 
1001         for (int i = 0; i &lt; digests.length; i++) {
1002             attrs.putValue(digests[i].getAlgorithm() + &quot;-Digest&quot;,
1003                     base64Digests[i]);
1004         }
1005         return attrs;
1006     }
1007 
1008     /*
1009      * Returns manifest entry from given jar file, or null if given jar file
1010      * does not have a manifest entry.
1011      */
</pre>
<hr />
<pre>
1034             long left = ze.getSize();
1035             byte[] buffer = new byte[8192];
1036             while ((left &gt; 0)
1037                     &amp;&amp; (n = is.read(buffer, 0, buffer.length)) != -1) {
1038                 for (i = 0; i &lt; digests.length; i++) {
1039                     digests[i].update(buffer, 0, n);
1040                 }
1041                 left -= n;
1042             }
1043         }
1044 
1045         // complete the digests
1046         String[] base64Digests = new String[digests.length];
1047         for (i = 0; i &lt; digests.length; i++) {
1048             base64Digests[i] = Base64.getEncoder()
1049                     .encodeToString(digests[i].digest());
1050         }
1051         return base64Digests;
1052     }
1053 
<span class="line-removed">1054     @SuppressWarnings(&quot;fallthrough&quot;)</span>
<span class="line-removed">1055     private int findHeaderEnd(byte[] bs) {</span>
<span class="line-removed">1056         // Initial state true to deal with empty header</span>
<span class="line-removed">1057         boolean newline = true;     // just met a newline</span>
<span class="line-removed">1058         int len = bs.length;</span>
<span class="line-removed">1059         for (int i = 0; i &lt; len; i++) {</span>
<span class="line-removed">1060             switch (bs[i]) {</span>
<span class="line-removed">1061                 case &#39;\r&#39;:</span>
<span class="line-removed">1062                     if (i &lt; len - 1 &amp;&amp; bs[i + 1] == &#39;\n&#39;) i++;</span>
<span class="line-removed">1063                     // fallthrough</span>
<span class="line-removed">1064                 case &#39;\n&#39;:</span>
<span class="line-removed">1065                     if (newline) return i + 1;    //+1 to get length</span>
<span class="line-removed">1066                     newline = true;</span>
<span class="line-removed">1067                     break;</span>
<span class="line-removed">1068                 default:</span>
<span class="line-removed">1069                     newline = false;</span>
<span class="line-removed">1070             }</span>
<span class="line-removed">1071         }</span>
<span class="line-removed">1072         // If header end is not found, it means the MANIFEST.MF has only</span>
<span class="line-removed">1073         // the main attributes section and it does not end with 2 newlines.</span>
<span class="line-removed">1074         // Returns the whole length so that it can be completely replaced.</span>
<span class="line-removed">1075         return len;</span>
<span class="line-removed">1076     }</span>
<span class="line-removed">1077 </span>
1078     /*
1079      * Try to load the specified signing mechanism.
1080      * The URL class loader is used.
1081      */
1082     @SuppressWarnings(&quot;deprecation&quot;)
1083     private ContentSigner loadSigningMechanism(String signerClassName,
1084                                                String signerClassPath) {
1085 
1086         // construct class loader
1087         String cpString;   // make sure env.class.path defaults to dot
1088 
1089         // do prepends to get correct ordering
1090         cpString = PathList.appendPath(
1091                 System.getProperty(&quot;env.class.path&quot;), null);
1092         cpString = PathList.appendPath(
1093                 System.getProperty(&quot;java.class.path&quot;), cpString);
1094         cpString = PathList.appendPath(signerClassPath, cpString);
1095         URL[] urls = PathList.pathToURLs(cpString);
1096         ClassLoader appClassLoader = new URLClassLoader(urls);
1097 
</pre>
<hr />
<pre>
1128             this.baseName = baseName;
1129 
1130             String version = System.getProperty(&quot;java.version&quot;);
1131             String javaVendor = System.getProperty(&quot;java.vendor&quot;);
1132 
1133             sf = new Manifest();
1134             Attributes mattr = sf.getMainAttributes();
1135 
1136             mattr.putValue(Attributes.Name.SIGNATURE_VERSION.toString(), &quot;1.0&quot;);
1137             mattr.putValue(&quot;Created-By&quot;, version + &quot; (&quot; + javaVendor + &quot;)&quot;);
1138 
1139             if (signManifest) {
1140                 for (MessageDigest digest: digests) {
1141                     mattr.putValue(digest.getAlgorithm() + &quot;-Digest-Manifest&quot;,
1142                             Base64.getEncoder().encodeToString(
1143                                     md.manifestDigest(digest)));
1144                 }
1145             }
1146 
1147             // create digest of the manifest main attributes
<span class="line-modified">1148             ManifestDigester.Entry mde =</span>
<span class="line-removed">1149                     md.get(ManifestDigester.MF_MAIN_ATTRS, false);</span>
1150             if (mde != null) {
<span class="line-modified">1151                 for (MessageDigest digest: digests) {</span>
<span class="line-modified">1152                     mattr.putValue(digest.getAlgorithm() +</span>
<span class="line-modified">1153                                     &quot;-Digest-&quot; + ManifestDigester.MF_MAIN_ATTRS,</span>
<span class="line-modified">1154                             Base64.getEncoder().encodeToString(</span>
<span class="line-removed">1155                                     mde.digest(digest)));</span>
1156                 }
1157             } else {
1158                 throw new IllegalStateException
1159                         (&quot;ManifestDigester failed to create &quot; +
1160                                 &quot;Manifest-Main-Attribute entry&quot;);
1161             }
1162 
1163             // go through the manifest entries and create the digests
1164             Map&lt;String, Attributes&gt; entries = sf.getEntries();
1165             for (String name: mf.getEntries().keySet()) {
1166                 mde = md.get(name, false);
1167                 if (mde != null) {
1168                     Attributes attr = new Attributes();
1169                     for (MessageDigest digest: digests) {
1170                         attr.putValue(digest.getAlgorithm() + &quot;-Digest&quot;,
1171                                 Base64.getEncoder().encodeToString(
1172                                         mde.digest(digest)));
1173                     }
1174                     entries.put(name, attr);
1175                 }
1176             }
1177         }
1178 
1179         // Write .SF file
1180         public void write(OutputStream out) throws IOException {
1181             sf.write(out);
1182         }
1183 




1184         // get .SF file name
1185         public String getMetaName() {
<span class="line-modified">1186             return &quot;META-INF/&quot; + baseName + &quot;.SF&quot;;</span>
1187         }
1188 
1189         // get .DSA (or .DSA, .EC) file name
1190         public String getBlockName(PrivateKey privateKey) {
1191             String keyAlgorithm = privateKey.getAlgorithm();
<span class="line-modified">1192             return &quot;META-INF/&quot; + baseName + &quot;.&quot; + keyAlgorithm;</span>
1193         }
1194 
1195         // Generates the PKCS#7 content of block file
1196         @SuppressWarnings(&quot;deprecation&quot;)
1197         public byte[] generateBlock(ContentSignerParameters params,
1198                                     boolean externalSF,
1199                                     ContentSigner signingMechanism)
1200                 throws NoSuchAlgorithmException,
1201                        IOException, CertificateException {
1202 
1203             if (signingMechanism == null) {
1204                 signingMechanism = new TimestampedSigner();
1205             }
1206             return signingMechanism.generateSignedData(
1207                     params,
1208                     externalSF,
1209                     params.getTimestampingAuthority() != null
1210                         || params.getTimestampingAuthorityCertificate() != null);
1211         }
1212     }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 654     private void sign0(ZipFile zipFile, OutputStream os)
 655             throws IOException, CertificateException, NoSuchAlgorithmException,
 656             SignatureException, InvalidKeyException {
 657         MessageDigest[] digests;
 658         try {
 659             digests = new MessageDigest[digestalg.length];
 660             for (int i = 0; i &lt; digestalg.length; i++) {
 661                 if (digestProvider == null) {
 662                     digests[i] = MessageDigest.getInstance(digestalg[i]);
 663                 } else {
 664                     digests[i] = MessageDigest.getInstance(
 665                             digestalg[i], digestProvider);
 666                 }
 667             }
 668         } catch (NoSuchAlgorithmException asae) {
 669             // Should not happen. User provided alg were checked, and default
 670             // alg should always be available.
 671             throw new AssertionError(asae);
 672         }
 673 
<span class="line-modified"> 674         ZipOutputStream zos = new ZipOutputStream(os);</span>

 675 
 676         Manifest manifest = new Manifest();







 677         byte[] mfRawBytes = null;
 678 
 679         // Check if manifest exists
<span class="line-modified"> 680         ZipEntry mfFile = getManifestFile(zipFile);</span>
<span class="line-modified"> 681         boolean mfCreated = mfFile == null;</span>
<span class="line-added"> 682         if (!mfCreated) {</span>
 683             // Manifest exists. Read its raw bytes.
 684             mfRawBytes = zipFile.getInputStream(mfFile).readAllBytes();
 685             manifest.read(new ByteArrayInputStream(mfRawBytes));

 686         } else {
 687             // Create new manifest
 688             Attributes mattr = manifest.getMainAttributes();
 689             mattr.putValue(Attributes.Name.MANIFEST_VERSION.toString(),
 690                     &quot;1.0&quot;);
 691             String javaVendor = System.getProperty(&quot;java.vendor&quot;);
 692             String jdkVersion = System.getProperty(&quot;java.version&quot;);
 693             mattr.putValue(&quot;Created-By&quot;, jdkVersion + &quot; (&quot; + javaVendor
 694                     + &quot;)&quot;);
 695             mfFile = new ZipEntry(JarFile.MANIFEST_NAME);

 696         }
 697 
 698         /*
 699          * For each entry in jar
 700          * (except for signature-related META-INF entries),
 701          * do the following:
 702          *
 703          * - if entry is not contained in manifest, add it to manifest;
 704          * - if entry is contained in manifest, calculate its hash and
 705          *   compare it with the one in the manifest; if they are
 706          *   different, replace the hash in the manifest with the newly
 707          *   generated one. (This may invalidate existing signatures!)
 708          */
 709         Vector&lt;ZipEntry&gt; mfFiles = new Vector&lt;&gt;();
 710 
 711         boolean wasSigned = false;
 712 
 713         for (Enumeration&lt;? extends ZipEntry&gt; enum_ = zipFile.entries();
 714              enum_.hasMoreElements(); ) {
 715             ZipEntry ze = enum_.nextElement();
 716 
 717             if (ze.getName().startsWith(META_INF)) {
 718                 // Store META-INF files in vector, so they can be written
 719                 // out first
 720                 mfFiles.addElement(ze);
 721 
<span class="line-modified"> 722                 String zeNameUp = ze.getName().toUpperCase(Locale.ENGLISH);</span>
<span class="line-modified"> 723                 if (SignatureFileVerifier.isBlockOrSF(zeNameUp)</span>
<span class="line-added"> 724                     // no need to preserve binary manifest portions</span>
<span class="line-added"> 725                     // if the only existing signature will be replaced</span>
<span class="line-added"> 726                         &amp;&amp; !zeNameUp.startsWith(SignatureFile</span>
<span class="line-added"> 727                             .getBaseSignatureFilesName(signerName))) {</span>
 728                     wasSigned = true;
 729                 }
 730 
 731                 if (SignatureFileVerifier.isSigningRelated(ze.getName())) {
 732                     // ignore signature-related and manifest files
 733                     continue;
 734                 }
 735             }
 736 
 737             if (manifest.getAttributes(ze.getName()) != null) {
 738                 // jar entry is contained in manifest, check and
 739                 // possibly update its digest attributes
<span class="line-modified"> 740                 updateDigests(ze, zipFile, digests, manifest);</span>



 741             } else if (!ze.isDirectory()) {
 742                 // Add entry to manifest
 743                 Attributes attrs = getDigestAttributes(ze, zipFile, digests);
<span class="line-modified"> 744                 manifest.getEntries().put(ze.getName(), attrs);</span>

 745             }
 746         }
 747 
<span class="line-modified"> 748         /*</span>
<span class="line-modified"> 749          * Note:</span>
<span class="line-modified"> 750          *</span>
<span class="line-added"> 751          * The Attributes object is based on HashMap and can handle</span>
<span class="line-added"> 752          * continuation lines. Therefore, even if the contents are not changed</span>
<span class="line-added"> 753          * (in a Map view), the bytes that it write() may be different from</span>
<span class="line-added"> 754          * the original bytes that it read() from. Since the signature is</span>
<span class="line-added"> 755          * based on raw bytes, we must retain the exact bytes.</span>
<span class="line-added"> 756          */</span>
<span class="line-added"> 757         boolean mfModified;</span>
<span class="line-added"> 758         ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="line-added"> 759         if (mfCreated || !wasSigned) {</span>
<span class="line-added"> 760             mfModified = true;</span>
 761             manifest.write(baos);
<span class="line-modified"> 762             mfRawBytes = baos.toByteArray();</span>
<span class="line-modified"> 763         } else {</span>
<span class="line-modified"> 764 </span>
<span class="line-modified"> 765             // the manifest before updating</span>
<span class="line-modified"> 766             Manifest oldManifest = new Manifest(</span>
<span class="line-modified"> 767                     new ByteArrayInputStream(mfRawBytes));</span>
<span class="line-modified"> 768             mfModified = !oldManifest.equals(manifest);</span>
<span class="line-modified"> 769             if (!mfModified) {</span>
<span class="line-modified"> 770                 // leave whole manifest (mfRawBytes) unmodified</span>
<span class="line-modified"> 771             } else {</span>
<span class="line-modified"> 772                 // reproduce the manifest raw bytes for unmodified sections</span>
<span class="line-modified"> 773                 manifest.write(baos);</span>
<span class="line-modified"> 774                 byte[] mfNewRawBytes = baos.toByteArray();</span>
<span class="line-modified"> 775                 baos.reset();</span>
<span class="line-modified"> 776 </span>
<span class="line-modified"> 777                 ManifestDigester oldMd = new ManifestDigester(mfRawBytes);</span>
<span class="line-modified"> 778                 ManifestDigester newMd = new ManifestDigester(mfNewRawBytes);</span>
<span class="line-modified"> 779 </span>
<span class="line-modified"> 780                 // main attributes</span>
<span class="line-modified"> 781                 if (manifest.getMainAttributes().equals(</span>
<span class="line-modified"> 782                         oldManifest.getMainAttributes())</span>
<span class="line-added"> 783                         &amp;&amp; (manifest.getEntries().isEmpty() ||</span>
<span class="line-added"> 784                             oldMd.getMainAttsEntry().isProperlyDelimited())) {</span>
<span class="line-added"> 785                     oldMd.getMainAttsEntry().reproduceRaw(baos);</span>
<span class="line-added"> 786                 } else {</span>
<span class="line-added"> 787                     newMd.getMainAttsEntry().reproduceRaw(baos);</span>
<span class="line-added"> 788                 }</span>
<span class="line-added"> 789 </span>
<span class="line-added"> 790                 // individual sections</span>
<span class="line-added"> 791                 for (Map.Entry&lt;String,Attributes&gt; entry :</span>
<span class="line-added"> 792                         manifest.getEntries().entrySet()) {</span>
<span class="line-added"> 793                     String sectionName = entry.getKey();</span>
<span class="line-added"> 794                     Attributes entryAtts = entry.getValue();</span>
<span class="line-added"> 795                     if (entryAtts.equals(oldManifest.getAttributes(sectionName))</span>
<span class="line-added"> 796                             &amp;&amp; oldMd.get(sectionName).isProperlyDelimited()) {</span>
<span class="line-added"> 797                         oldMd.get(sectionName).reproduceRaw(baos);</span>
 798                     } else {
<span class="line-modified"> 799                         newMd.get(sectionName).reproduceRaw(baos);</span>






 800                     }
 801                 }
<span class="line-modified"> 802 </span>

 803                 mfRawBytes = baos.toByteArray();
 804             }
 805         }
 806 
 807         // Write out the manifest
 808         if (mfModified) {
 809             // manifest file has new length
 810             mfFile = new ZipEntry(JarFile.MANIFEST_NAME);
 811         }
 812         if (handler != null) {
<span class="line-modified"> 813             if (mfCreated || !mfModified) {</span>
 814                 handler.accept(&quot;adding&quot;, mfFile.getName());
<span class="line-modified"> 815             } else {</span>
 816                 handler.accept(&quot;updating&quot;, mfFile.getName());
 817             }
 818         }

 819         zos.putNextEntry(mfFile);
 820         zos.write(mfRawBytes);
 821 
 822         // Calculate SignatureFile (&quot;.SF&quot;) and SignatureBlockFile
 823         ManifestDigester manDig = new ManifestDigester(mfRawBytes);
 824         SignatureFile sf = new SignatureFile(digests, manifest, manDig,
 825                 signerName, signManifest);
 826 
 827         byte[] block;
 828 
 829         Signature signer;
 830         if (sigProvider == null ) {
 831             signer = Signature.getInstance(sigalg);
 832         } else {
 833             signer = Signature.getInstance(sigalg, sigProvider);
 834         }
 835         signer.initSign(privateKey);
 836 
<span class="line-modified"> 837         baos.reset();</span>
 838         sf.write(baos);

 839         byte[] content = baos.toByteArray();
 840 
 841         signer.update(content);
 842         byte[] signature = signer.sign();
 843 
 844         @SuppressWarnings(&quot;deprecation&quot;)
 845         ContentSigner signingMechanism = null;
 846         if (altSigner != null) {
 847             signingMechanism = loadSigningMechanism(altSigner,
 848                     altSignerPath);
 849         }
 850 
 851         @SuppressWarnings(&quot;deprecation&quot;)
 852         ContentSignerParameters params =
 853                 new JarSignerParameters(null, tsaUrl, tSAPolicyID,
 854                         tSADigestAlg, signature,
 855                         signer.getAlgorithm(), certChain, content, zipFile);
 856         block = sf.generateBlock(params, externalSF, signingMechanism);
 857 
 858         String sfFilename = sf.getMetaName();
</pre>
<hr />
<pre>
 879 
 880         // signature block file
 881         zos.putNextEntry(bkFile);
 882         zos.write(block);
 883 
 884         if (handler != null) {
 885             if (zipFile.getEntry(bkFilename) != null) {
 886                 handler.accept(&quot;updating&quot;, bkFilename);
 887             } else {
 888                 handler.accept(&quot;adding&quot;, bkFilename);
 889             }
 890         }
 891 
 892         // Write out all other META-INF files that we stored in the
 893         // vector
 894         for (int i = 0; i &lt; mfFiles.size(); i++) {
 895             ZipEntry ze = mfFiles.elementAt(i);
 896             if (!ze.getName().equalsIgnoreCase(JarFile.MANIFEST_NAME)
 897                     &amp;&amp; !ze.getName().equalsIgnoreCase(sfFilename)
 898                     &amp;&amp; !ze.getName().equalsIgnoreCase(bkFilename)) {
<span class="line-added"> 899                 if (ze.getName().startsWith(SignatureFile</span>
<span class="line-added"> 900                         .getBaseSignatureFilesName(signerName))</span>
<span class="line-added"> 901                         &amp;&amp; SignatureFileVerifier.isBlockOrSF(ze.getName())) {</span>
<span class="line-added"> 902                     if (handler != null) {</span>
<span class="line-added"> 903                         handler.accept(&quot;updating&quot;, ze.getName());</span>
<span class="line-added"> 904                     }</span>
<span class="line-added"> 905                     continue;</span>
<span class="line-added"> 906                 }</span>
 907                 if (handler != null) {
 908                     if (manifest.getAttributes(ze.getName()) != null) {
 909                         handler.accept(&quot;signing&quot;, ze.getName());
 910                     } else if (!ze.isDirectory()) {
 911                         handler.accept(&quot;adding&quot;, ze.getName());
 912                     }
 913                 }
 914                 writeEntry(zipFile, zos, ze);
 915             }
 916         }
 917 
 918         // Write out all other files
 919         for (Enumeration&lt;? extends ZipEntry&gt; enum_ = zipFile.entries();
 920              enum_.hasMoreElements(); ) {
 921             ZipEntry ze = enum_.nextElement();
 922 
 923             if (!ze.getName().startsWith(META_INF)) {
 924                 if (handler != null) {
 925                     if (manifest.getAttributes(ze.getName()) != null) {
 926                         handler.accept(&quot;signing&quot;, ze.getName());
</pre>
<hr />
<pre>
 940         ZipEntry ze2 = new ZipEntry(ze.getName());
 941         ze2.setMethod(ze.getMethod());
 942         ze2.setTime(ze.getTime());
 943         ze2.setComment(ze.getComment());
 944         ze2.setExtra(ze.getExtra());
 945         if (ze.getMethod() == ZipEntry.STORED) {
 946             ze2.setSize(ze.getSize());
 947             ze2.setCrc(ze.getCrc());
 948         }
 949         os.putNextEntry(ze2);
 950         writeBytes(zf, ze, os);
 951     }
 952 
 953     private void writeBytes
 954             (ZipFile zf, ZipEntry ze, ZipOutputStream os) throws IOException {
 955         try (InputStream is = zf.getInputStream(ze)) {
 956             is.transferTo(os);
 957         }
 958     }
 959 
<span class="line-modified"> 960     private void updateDigests(ZipEntry ze, ZipFile zf,</span>
 961                                   MessageDigest[] digests,
 962                                   Manifest mf) throws IOException {


 963         Attributes attrs = mf.getAttributes(ze.getName());
 964         String[] base64Digests = getDigests(ze, zf, digests);
 965 
 966         for (int i = 0; i &lt; digests.length; i++) {
 967             // The entry name to be written into attrs
 968             String name = null;
 969             try {
 970                 // Find if the digest already exists. An algorithm could have
 971                 // different names. For example, last time it was SHA, and this
 972                 // time it&#39;s SHA-1.
 973                 AlgorithmId aid = AlgorithmId.get(digests[i].getAlgorithm());
 974                 for (Object key : attrs.keySet()) {
 975                     if (key instanceof Attributes.Name) {
 976                         String n = key.toString();
 977                         if (n.toUpperCase(Locale.ENGLISH).endsWith(&quot;-DIGEST&quot;)) {
 978                             String tmp = n.substring(0, n.length() - 7);
 979                             if (AlgorithmId.get(tmp).equals(aid)) {
 980                                 name = n;
 981                                 break;
 982                             }
 983                         }
 984                     }
 985                 }
 986             } catch (NoSuchAlgorithmException nsae) {
 987                 // Ignored. Writing new digest entry.
 988             }
 989 
 990             if (name == null) {
 991                 name = digests[i].getAlgorithm() + &quot;-Digest&quot;;










 992             }
<span class="line-added"> 993             attrs.putValue(name, base64Digests[i]);</span>
 994         }

 995     }
 996 
 997     private Attributes getDigestAttributes(
 998             ZipEntry ze, ZipFile zf, MessageDigest[] digests)
 999             throws IOException {
1000 
1001         String[] base64Digests = getDigests(ze, zf, digests);
1002         Attributes attrs = new Attributes();
1003 
1004         for (int i = 0; i &lt; digests.length; i++) {
1005             attrs.putValue(digests[i].getAlgorithm() + &quot;-Digest&quot;,
1006                     base64Digests[i]);
1007         }
1008         return attrs;
1009     }
1010 
1011     /*
1012      * Returns manifest entry from given jar file, or null if given jar file
1013      * does not have a manifest entry.
1014      */
</pre>
<hr />
<pre>
1037             long left = ze.getSize();
1038             byte[] buffer = new byte[8192];
1039             while ((left &gt; 0)
1040                     &amp;&amp; (n = is.read(buffer, 0, buffer.length)) != -1) {
1041                 for (i = 0; i &lt; digests.length; i++) {
1042                     digests[i].update(buffer, 0, n);
1043                 }
1044                 left -= n;
1045             }
1046         }
1047 
1048         // complete the digests
1049         String[] base64Digests = new String[digests.length];
1050         for (i = 0; i &lt; digests.length; i++) {
1051             base64Digests[i] = Base64.getEncoder()
1052                     .encodeToString(digests[i].digest());
1053         }
1054         return base64Digests;
1055     }
1056 
























1057     /*
1058      * Try to load the specified signing mechanism.
1059      * The URL class loader is used.
1060      */
1061     @SuppressWarnings(&quot;deprecation&quot;)
1062     private ContentSigner loadSigningMechanism(String signerClassName,
1063                                                String signerClassPath) {
1064 
1065         // construct class loader
1066         String cpString;   // make sure env.class.path defaults to dot
1067 
1068         // do prepends to get correct ordering
1069         cpString = PathList.appendPath(
1070                 System.getProperty(&quot;env.class.path&quot;), null);
1071         cpString = PathList.appendPath(
1072                 System.getProperty(&quot;java.class.path&quot;), cpString);
1073         cpString = PathList.appendPath(signerClassPath, cpString);
1074         URL[] urls = PathList.pathToURLs(cpString);
1075         ClassLoader appClassLoader = new URLClassLoader(urls);
1076 
</pre>
<hr />
<pre>
1107             this.baseName = baseName;
1108 
1109             String version = System.getProperty(&quot;java.version&quot;);
1110             String javaVendor = System.getProperty(&quot;java.vendor&quot;);
1111 
1112             sf = new Manifest();
1113             Attributes mattr = sf.getMainAttributes();
1114 
1115             mattr.putValue(Attributes.Name.SIGNATURE_VERSION.toString(), &quot;1.0&quot;);
1116             mattr.putValue(&quot;Created-By&quot;, version + &quot; (&quot; + javaVendor + &quot;)&quot;);
1117 
1118             if (signManifest) {
1119                 for (MessageDigest digest: digests) {
1120                     mattr.putValue(digest.getAlgorithm() + &quot;-Digest-Manifest&quot;,
1121                             Base64.getEncoder().encodeToString(
1122                                     md.manifestDigest(digest)));
1123                 }
1124             }
1125 
1126             // create digest of the manifest main attributes
<span class="line-modified">1127             ManifestDigester.Entry mde = md.getMainAttsEntry(false);</span>

1128             if (mde != null) {
<span class="line-modified">1129                 for (MessageDigest digest : digests) {</span>
<span class="line-modified">1130                     mattr.putValue(digest.getAlgorithm() + &quot;-Digest-&quot; +</span>
<span class="line-modified">1131                             ManifestDigester.MF_MAIN_ATTRS,</span>
<span class="line-modified">1132                             Base64.getEncoder().encodeToString(mde.digest(digest)));</span>

1133                 }
1134             } else {
1135                 throw new IllegalStateException
1136                         (&quot;ManifestDigester failed to create &quot; +
1137                                 &quot;Manifest-Main-Attribute entry&quot;);
1138             }
1139 
1140             // go through the manifest entries and create the digests
1141             Map&lt;String, Attributes&gt; entries = sf.getEntries();
1142             for (String name: mf.getEntries().keySet()) {
1143                 mde = md.get(name, false);
1144                 if (mde != null) {
1145                     Attributes attr = new Attributes();
1146                     for (MessageDigest digest: digests) {
1147                         attr.putValue(digest.getAlgorithm() + &quot;-Digest&quot;,
1148                                 Base64.getEncoder().encodeToString(
1149                                         mde.digest(digest)));
1150                     }
1151                     entries.put(name, attr);
1152                 }
1153             }
1154         }
1155 
1156         // Write .SF file
1157         public void write(OutputStream out) throws IOException {
1158             sf.write(out);
1159         }
1160 
<span class="line-added">1161         private static String getBaseSignatureFilesName(String baseName) {</span>
<span class="line-added">1162             return &quot;META-INF/&quot; + baseName + &quot;.&quot;;</span>
<span class="line-added">1163         }</span>
<span class="line-added">1164 </span>
1165         // get .SF file name
1166         public String getMetaName() {
<span class="line-modified">1167             return getBaseSignatureFilesName(baseName) + &quot;SF&quot;;</span>
1168         }
1169 
1170         // get .DSA (or .DSA, .EC) file name
1171         public String getBlockName(PrivateKey privateKey) {
1172             String keyAlgorithm = privateKey.getAlgorithm();
<span class="line-modified">1173             return getBaseSignatureFilesName(baseName) + keyAlgorithm;</span>
1174         }
1175 
1176         // Generates the PKCS#7 content of block file
1177         @SuppressWarnings(&quot;deprecation&quot;)
1178         public byte[] generateBlock(ContentSignerParameters params,
1179                                     boolean externalSF,
1180                                     ContentSigner signingMechanism)
1181                 throws NoSuchAlgorithmException,
1182                        IOException, CertificateException {
1183 
1184             if (signingMechanism == null) {
1185                 signingMechanism = new TimestampedSigner();
1186             }
1187             return signingMechanism.generateSignedData(
1188                     params,
1189                     externalSF,
1190                     params.getTimestampingAuthority() != null
1191                         || params.getTimestampingAuthorityCertificate() != null);
1192         }
1193     }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../jdk.internal.vm.compiler/share/classes/org.graalvm.util.test/src/org/graalvm/util/test/CollectionSizeTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../module-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
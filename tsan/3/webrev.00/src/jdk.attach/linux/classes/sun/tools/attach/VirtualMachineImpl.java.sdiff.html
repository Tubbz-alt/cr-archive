<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.attach/linux/classes/sun/tools/attach/VirtualMachineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../aix/classes/sun/tools/attach/VirtualMachineImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../macosx/classes/sun/tools/attach/VirtualMachineImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.attach/linux/classes/sun/tools/attach/VirtualMachineImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 43 public class VirtualMachineImpl extends HotSpotVirtualMachine {
 44     // &quot;/tmp&quot; is used as a global well-known location for the files
 45     // .java_pid&lt;pid&gt;. and .attach_pid&lt;pid&gt;. It is important that this
 46     // location is the same for all processes, otherwise the tools
 47     // will not be able to find all Hotspot processes.
 48     // Any changes to this needs to be synchronized with HotSpot.
 49     private static final String tmpdir = &quot;/tmp&quot;;
 50     String socket_path;
 51     /**
 52      * Attaches to the target VM
 53      */
 54     VirtualMachineImpl(AttachProvider provider, String vmid)
 55         throws AttachNotSupportedException, IOException
 56     {
 57         super(provider, vmid);
 58 
 59         // This provider only understands pids
 60         int pid;
 61         try {
 62             pid = Integer.parseInt(vmid);



 63         } catch (NumberFormatException x) {
<span class="line-modified"> 64             throw new AttachNotSupportedException(&quot;Invalid process identifier&quot;);</span>
 65         }
 66 
 67         // Try to resolve to the &quot;inner most&quot; pid namespace
 68         int ns_pid = getNamespacePid(pid);
 69 
 70         // Find the socket file. If not found then we attempt to start the
 71         // attach mechanism in the target VM by sending it a QUIT signal.
 72         // Then we attempt to find the socket file again.
 73         File socket_file = findSocketFile(pid, ns_pid);
 74         socket_path = socket_file.getPath();
 75         if (!socket_file.exists()) {
 76             File f = createAttachFile(pid, ns_pid);
 77             try {
 78                 sendQuitTo(pid);
 79 
 80                 // give the target VM time to start the attach mechanism
 81                 final int delay_step = 100;
 82                 final long timeout = attachTimeout();
 83                 long time_spend = 0;
 84                 long delay = 0;
</pre>
<hr />
<pre>
216             if (cmd.equals(&quot;load&quot;)) {
217                 String msg = &quot;Failed to load agent library&quot;;
218                 if (!message.isEmpty())
219                     msg += &quot;: &quot; + message;
220                 throw new AgentLoadException(msg);
221             } else {
222                 if (message.isEmpty())
223                     message = &quot;Command failed in target VM&quot;;
224                 throw new AttachOperationFailedException(message);
225             }
226         }
227 
228         // Return the input stream so that the command output can be read
229         return sis;
230     }
231 
232     /*
233      * InputStream for the socket connection to get target VM
234      */
235     private class SocketInputStream extends InputStream {
<span class="line-modified">236         int s;</span>
237 
238         public SocketInputStream(int s) {
239             this.s = s;
240         }
241 
242         public synchronized int read() throws IOException {
243             byte b[] = new byte[1];
244             int n = this.read(b, 0, 1);
245             if (n == 1) {
246                 return b[0] &amp; 0xff;
247             } else {
248                 return -1;
249             }
250         }
251 
252         public synchronized int read(byte[] bs, int off, int len) throws IOException {
253             if ((off &lt; 0) || (off &gt; bs.length) || (len &lt; 0) ||
254                 ((off + len) &gt; bs.length) || ((off + len) &lt; 0)) {
255                 throw new IndexOutOfBoundsException();
256             } else if (len == 0) {
257                 return 0;
258             }
259 
260             return VirtualMachineImpl.read(s, bs, off, len);
261         }
262 
<span class="line-modified">263         public void close() throws IOException {</span>
<span class="line-modified">264             VirtualMachineImpl.close(s);</span>




265         }
266     }
267 
268     // Return the socket file for the given process.
269     private File findSocketFile(int pid, int ns_pid) {
270         // A process may not exist in the same mount namespace as the caller.
271         // Instead, attach relative to the target root filesystem as exposed by
272         // procfs regardless of namespaces.
273         String root = &quot;/proc/&quot; + pid + &quot;/root/&quot; + tmpdir;
274         return new File(root, &quot;.java_pid&quot; + ns_pid);
275     }
276 
277     // On Linux a simple handshake is used to start the attach mechanism
278     // if not already started. The client creates a .attach_pid&lt;pid&gt; file in the
279     // target VM&#39;s working directory (or temp directory), and the SIGQUIT handler
280     // checks for the file.
281     private File createAttachFile(int pid, int ns_pid) throws IOException {
282         String fn = &quot;.attach_pid&quot; + ns_pid;
283         String path = &quot;/proc/&quot; + pid + &quot;/cwd/&quot; + fn;
284         File f = new File(path);
</pre>
</td>
<td>
<hr />
<pre>
 43 public class VirtualMachineImpl extends HotSpotVirtualMachine {
 44     // &quot;/tmp&quot; is used as a global well-known location for the files
 45     // .java_pid&lt;pid&gt;. and .attach_pid&lt;pid&gt;. It is important that this
 46     // location is the same for all processes, otherwise the tools
 47     // will not be able to find all Hotspot processes.
 48     // Any changes to this needs to be synchronized with HotSpot.
 49     private static final String tmpdir = &quot;/tmp&quot;;
 50     String socket_path;
 51     /**
 52      * Attaches to the target VM
 53      */
 54     VirtualMachineImpl(AttachProvider provider, String vmid)
 55         throws AttachNotSupportedException, IOException
 56     {
 57         super(provider, vmid);
 58 
 59         // This provider only understands pids
 60         int pid;
 61         try {
 62             pid = Integer.parseInt(vmid);
<span class="line-added"> 63             if (pid &lt; 1) {</span>
<span class="line-added"> 64                 throw new NumberFormatException();</span>
<span class="line-added"> 65             }</span>
 66         } catch (NumberFormatException x) {
<span class="line-modified"> 67             throw new AttachNotSupportedException(&quot;Invalid process identifier: &quot; + vmid);</span>
 68         }
 69 
 70         // Try to resolve to the &quot;inner most&quot; pid namespace
 71         int ns_pid = getNamespacePid(pid);
 72 
 73         // Find the socket file. If not found then we attempt to start the
 74         // attach mechanism in the target VM by sending it a QUIT signal.
 75         // Then we attempt to find the socket file again.
 76         File socket_file = findSocketFile(pid, ns_pid);
 77         socket_path = socket_file.getPath();
 78         if (!socket_file.exists()) {
 79             File f = createAttachFile(pid, ns_pid);
 80             try {
 81                 sendQuitTo(pid);
 82 
 83                 // give the target VM time to start the attach mechanism
 84                 final int delay_step = 100;
 85                 final long timeout = attachTimeout();
 86                 long time_spend = 0;
 87                 long delay = 0;
</pre>
<hr />
<pre>
219             if (cmd.equals(&quot;load&quot;)) {
220                 String msg = &quot;Failed to load agent library&quot;;
221                 if (!message.isEmpty())
222                     msg += &quot;: &quot; + message;
223                 throw new AgentLoadException(msg);
224             } else {
225                 if (message.isEmpty())
226                     message = &quot;Command failed in target VM&quot;;
227                 throw new AttachOperationFailedException(message);
228             }
229         }
230 
231         // Return the input stream so that the command output can be read
232         return sis;
233     }
234 
235     /*
236      * InputStream for the socket connection to get target VM
237      */
238     private class SocketInputStream extends InputStream {
<span class="line-modified">239         int s = -1;</span>
240 
241         public SocketInputStream(int s) {
242             this.s = s;
243         }
244 
245         public synchronized int read() throws IOException {
246             byte b[] = new byte[1];
247             int n = this.read(b, 0, 1);
248             if (n == 1) {
249                 return b[0] &amp; 0xff;
250             } else {
251                 return -1;
252             }
253         }
254 
255         public synchronized int read(byte[] bs, int off, int len) throws IOException {
256             if ((off &lt; 0) || (off &gt; bs.length) || (len &lt; 0) ||
257                 ((off + len) &gt; bs.length) || ((off + len) &lt; 0)) {
258                 throw new IndexOutOfBoundsException();
259             } else if (len == 0) {
260                 return 0;
261             }
262 
263             return VirtualMachineImpl.read(s, bs, off, len);
264         }
265 
<span class="line-modified">266         public synchronized void close() throws IOException {</span>
<span class="line-modified">267             if (s != -1) {</span>
<span class="line-added">268                 int toClose = s;</span>
<span class="line-added">269                 s = -1;</span>
<span class="line-added">270                 VirtualMachineImpl.close(toClose);</span>
<span class="line-added">271             }</span>
272         }
273     }
274 
275     // Return the socket file for the given process.
276     private File findSocketFile(int pid, int ns_pid) {
277         // A process may not exist in the same mount namespace as the caller.
278         // Instead, attach relative to the target root filesystem as exposed by
279         // procfs regardless of namespaces.
280         String root = &quot;/proc/&quot; + pid + &quot;/root/&quot; + tmpdir;
281         return new File(root, &quot;.java_pid&quot; + ns_pid);
282     }
283 
284     // On Linux a simple handshake is used to start the attach mechanism
285     // if not already started. The client creates a .attach_pid&lt;pid&gt; file in the
286     // target VM&#39;s working directory (or temp directory), and the SIGQUIT handler
287     // checks for the file.
288     private File createAttachFile(int pid, int ns_pid) throws IOException {
289         String fn = &quot;.attach_pid&quot; + ns_pid;
290         String path = &quot;/proc/&quot; + pid + &quot;/cwd/&quot; + fn;
291         File f = new File(path);
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../aix/classes/sun/tools/attach/VirtualMachineImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../macosx/classes/sun/tools/attach/VirtualMachineImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
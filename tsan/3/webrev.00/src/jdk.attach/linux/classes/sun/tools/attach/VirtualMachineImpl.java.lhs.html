<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.attach/linux/classes/sun/tools/attach/VirtualMachineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.tools.attach;
 26 
 27 import com.sun.tools.attach.AttachOperationFailedException;
 28 import com.sun.tools.attach.AgentLoadException;
 29 import com.sun.tools.attach.AttachNotSupportedException;
 30 import com.sun.tools.attach.spi.AttachProvider;
 31 
 32 import java.io.InputStream;
 33 import java.io.IOException;
 34 import java.io.File;
 35 import java.nio.charset.StandardCharsets;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.nio.file.Files;
 39 
 40 /*
 41  * Linux implementation of HotSpotVirtualMachine
 42  */
 43 public class VirtualMachineImpl extends HotSpotVirtualMachine {
 44     // &quot;/tmp&quot; is used as a global well-known location for the files
 45     // .java_pid&lt;pid&gt;. and .attach_pid&lt;pid&gt;. It is important that this
 46     // location is the same for all processes, otherwise the tools
 47     // will not be able to find all Hotspot processes.
 48     // Any changes to this needs to be synchronized with HotSpot.
 49     private static final String tmpdir = &quot;/tmp&quot;;
 50     String socket_path;
 51     /**
 52      * Attaches to the target VM
 53      */
 54     VirtualMachineImpl(AttachProvider provider, String vmid)
 55         throws AttachNotSupportedException, IOException
 56     {
 57         super(provider, vmid);
 58 
 59         // This provider only understands pids
 60         int pid;
 61         try {
 62             pid = Integer.parseInt(vmid);
<a name="1" id="anc1"></a>


 63         } catch (NumberFormatException x) {
<a name="2" id="anc2"></a><span class="line-modified"> 64             throw new AttachNotSupportedException(&quot;Invalid process identifier&quot;);</span>
 65         }
 66 
 67         // Try to resolve to the &quot;inner most&quot; pid namespace
 68         int ns_pid = getNamespacePid(pid);
 69 
 70         // Find the socket file. If not found then we attempt to start the
 71         // attach mechanism in the target VM by sending it a QUIT signal.
 72         // Then we attempt to find the socket file again.
 73         File socket_file = findSocketFile(pid, ns_pid);
 74         socket_path = socket_file.getPath();
 75         if (!socket_file.exists()) {
 76             File f = createAttachFile(pid, ns_pid);
 77             try {
 78                 sendQuitTo(pid);
 79 
 80                 // give the target VM time to start the attach mechanism
 81                 final int delay_step = 100;
 82                 final long timeout = attachTimeout();
 83                 long time_spend = 0;
 84                 long delay = 0;
 85                 do {
 86                     // Increase timeout on each attempt to reduce polling
 87                     delay += delay_step;
 88                     try {
 89                         Thread.sleep(delay);
 90                     } catch (InterruptedException x) { }
 91 
 92                     time_spend += delay;
 93                     if (time_spend &gt; timeout/2 &amp;&amp; !socket_file.exists()) {
 94                         // Send QUIT again to give target VM the last chance to react
 95                         sendQuitTo(pid);
 96                     }
 97                 } while (time_spend &lt;= timeout &amp;&amp; !socket_file.exists());
 98                 if (!socket_file.exists()) {
 99                     throw new AttachNotSupportedException(
100                         String.format(&quot;Unable to open socket file %s: &quot; +
101                           &quot;target process %d doesn&#39;t respond within %dms &quot; +
102                           &quot;or HotSpot VM not loaded&quot;, socket_path, pid,
103                                       time_spend));
104                 }
105             } finally {
106                 f.delete();
107             }
108         }
109 
110         // Check that the file owner/permission to avoid attaching to
111         // bogus process
112         checkPermissions(socket_path);
113 
114         // Check that we can connect to the process
115         // - this ensures we throw the permission denied error now rather than
116         // later when we attempt to enqueue a command.
117         int s = socket();
118         try {
119             connect(s, socket_path);
120         } finally {
121             close(s);
122         }
123     }
124 
125     /**
126      * Detach from the target VM
127      */
128     public void detach() throws IOException {
129         synchronized (this) {
130             if (socket_path != null) {
131                 socket_path = null;
132             }
133         }
134     }
135 
136     // protocol version
137     private final static String PROTOCOL_VERSION = &quot;1&quot;;
138 
139     // known errors
140     private final static int ATTACH_ERROR_BADVERSION = 101;
141 
142     /**
143      * Execute the given command in the target VM.
144      */
145     InputStream execute(String cmd, Object ... args) throws AgentLoadException, IOException {
146         assert args.length &lt;= 3;                // includes null
147 
148         // did we detach?
149         synchronized (this) {
150             if (socket_path == null) {
151                 throw new IOException(&quot;Detached from target VM&quot;);
152             }
153         }
154 
155         // create UNIX socket
156         int s = socket();
157 
158         // connect to target VM
159         try {
160             connect(s, socket_path);
161         } catch (IOException x) {
162             close(s);
163             throw x;
164         }
165 
166         IOException ioe = null;
167 
168         // connected - write request
169         // &lt;ver&gt; &lt;cmd&gt; &lt;args...&gt;
170         try {
171             writeString(s, PROTOCOL_VERSION);
172             writeString(s, cmd);
173 
174             for (int i = 0; i &lt; 3; i++) {
175                 if (i &lt; args.length &amp;&amp; args[i] != null) {
176                     writeString(s, (String)args[i]);
177                 } else {
178                     writeString(s, &quot;&quot;);
179                 }
180             }
181         } catch (IOException x) {
182             ioe = x;
183         }
184 
185 
186         // Create an input stream to read reply
187         SocketInputStream sis = new SocketInputStream(s);
188 
189         // Read the command completion status
190         int completionStatus;
191         try {
192             completionStatus = readInt(sis);
193         } catch (IOException x) {
194             sis.close();
195             if (ioe != null) {
196                 throw ioe;
197             } else {
198                 throw x;
199             }
200         }
201 
202         if (completionStatus != 0) {
203             // read from the stream and use that as the error message
204             String message = readErrorMessage(sis);
205             sis.close();
206 
207             // In the event of a protocol mismatch then the target VM
208             // returns a known error so that we can throw a reasonable
209             // error.
210             if (completionStatus == ATTACH_ERROR_BADVERSION) {
211                 throw new IOException(&quot;Protocol mismatch with target VM&quot;);
212             }
213 
214             // Special-case the &quot;load&quot; command so that the right exception is
215             // thrown.
216             if (cmd.equals(&quot;load&quot;)) {
217                 String msg = &quot;Failed to load agent library&quot;;
218                 if (!message.isEmpty())
219                     msg += &quot;: &quot; + message;
220                 throw new AgentLoadException(msg);
221             } else {
222                 if (message.isEmpty())
223                     message = &quot;Command failed in target VM&quot;;
224                 throw new AttachOperationFailedException(message);
225             }
226         }
227 
228         // Return the input stream so that the command output can be read
229         return sis;
230     }
231 
232     /*
233      * InputStream for the socket connection to get target VM
234      */
235     private class SocketInputStream extends InputStream {
<a name="3" id="anc3"></a><span class="line-modified">236         int s;</span>
237 
238         public SocketInputStream(int s) {
239             this.s = s;
240         }
241 
242         public synchronized int read() throws IOException {
243             byte b[] = new byte[1];
244             int n = this.read(b, 0, 1);
245             if (n == 1) {
246                 return b[0] &amp; 0xff;
247             } else {
248                 return -1;
249             }
250         }
251 
252         public synchronized int read(byte[] bs, int off, int len) throws IOException {
253             if ((off &lt; 0) || (off &gt; bs.length) || (len &lt; 0) ||
254                 ((off + len) &gt; bs.length) || ((off + len) &lt; 0)) {
255                 throw new IndexOutOfBoundsException();
256             } else if (len == 0) {
257                 return 0;
258             }
259 
260             return VirtualMachineImpl.read(s, bs, off, len);
261         }
262 
<a name="4" id="anc4"></a><span class="line-modified">263         public void close() throws IOException {</span>
<span class="line-modified">264             VirtualMachineImpl.close(s);</span>




265         }
266     }
267 
268     // Return the socket file for the given process.
269     private File findSocketFile(int pid, int ns_pid) {
270         // A process may not exist in the same mount namespace as the caller.
271         // Instead, attach relative to the target root filesystem as exposed by
272         // procfs regardless of namespaces.
273         String root = &quot;/proc/&quot; + pid + &quot;/root/&quot; + tmpdir;
274         return new File(root, &quot;.java_pid&quot; + ns_pid);
275     }
276 
277     // On Linux a simple handshake is used to start the attach mechanism
278     // if not already started. The client creates a .attach_pid&lt;pid&gt; file in the
279     // target VM&#39;s working directory (or temp directory), and the SIGQUIT handler
280     // checks for the file.
281     private File createAttachFile(int pid, int ns_pid) throws IOException {
282         String fn = &quot;.attach_pid&quot; + ns_pid;
283         String path = &quot;/proc/&quot; + pid + &quot;/cwd/&quot; + fn;
284         File f = new File(path);
285         try {
286             f = f.getCanonicalFile();
287             f.createNewFile();
288         } catch (IOException x) {
289             String root;
290             if (pid != ns_pid) {
291                 // A process may not exist in the same mount namespace as the caller.
292                 // Instead, attach relative to the target root filesystem as exposed by
293                 // procfs regardless of namespaces.
294                 root = &quot;/proc/&quot; + pid + &quot;/root/&quot; + tmpdir;
295             } else {
296                 root = tmpdir;
297             }
298             f = new File(root, fn);
299             f = f.getCanonicalFile();
300             f.createNewFile();
301         }
302         return f;
303     }
304 
305     /*
306      * Write/sends the given to the target VM. String is transmitted in
307      * UTF-8 encoding.
308      */
309     private void writeString(int fd, String s) throws IOException {
310         if (s.length() &gt; 0) {
311             byte b[];
312             try {
313                 b = s.getBytes(&quot;UTF-8&quot;);
314             } catch (java.io.UnsupportedEncodingException x) {
315                 throw new InternalError(x);
316             }
317             VirtualMachineImpl.write(fd, b, 0, b.length);
318         }
319         byte b[] = new byte[1];
320         b[0] = 0;
321         write(fd, b, 0, 1);
322     }
323 
324 
325     // Return the inner most namespaced PID if there is one,
326     // otherwise return the original PID.
327     private int getNamespacePid(int pid) throws AttachNotSupportedException, IOException {
328         // Assuming a real procfs sits beneath, reading this doesn&#39;t block
329         // nor will it consume a lot of memory.
330         String statusFile = &quot;/proc/&quot; + pid + &quot;/status&quot;;
331         File f = new File(statusFile);
332         if (!f.exists()) {
333             return pid; // Likely a bad pid, but this is properly handled later.
334         }
335 
336         Path statusPath = Paths.get(statusFile);
337 
338         try {
339             for (String line : Files.readAllLines(statusPath, StandardCharsets.UTF_8)) {
340                 String[] parts = line.split(&quot;:&quot;);
341                 if (parts.length == 2 &amp;&amp; parts[0].trim().equals(&quot;NSpid&quot;)) {
342                     parts = parts[1].trim().split(&quot;\\s+&quot;);
343                     // The last entry represents the PID the JVM &quot;thinks&quot; it is.
344                     // Even in non-namespaced pids these entries should be
345                     // valid. You could refer to it as the inner most pid.
346                     int ns_pid = Integer.parseInt(parts[parts.length - 1]);
347                     return ns_pid;
348                 }
349             }
350             // Old kernels may not have NSpid field (i.e. 3.10).
351             // Fallback to original pid in the event we cannot deduce.
352             return pid;
353         } catch (NumberFormatException | IOException x) {
354             throw new AttachNotSupportedException(&quot;Unable to parse namespace&quot;);
355         }
356     }
357 
358 
359     //-- native methods
360 
361     static native void sendQuitTo(int pid) throws IOException;
362 
363     static native void checkPermissions(String path) throws IOException;
364 
365     static native int socket() throws IOException;
366 
367     static native void connect(int fd, String path) throws IOException;
368 
369     static native void close(int fd) throws IOException;
370 
371     static native int read(int fd, byte buf[], int off, int bufLen) throws IOException;
372 
373     static native void write(int fd, byte buf[], int off, int bufLen) throws IOException;
374 
375     static {
376         System.loadLibrary(&quot;attach&quot;);
377     }
378 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
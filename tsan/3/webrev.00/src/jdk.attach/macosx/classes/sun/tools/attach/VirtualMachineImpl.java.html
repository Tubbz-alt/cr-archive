<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.attach/macosx/classes/sun/tools/attach/VirtualMachineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.tools.attach;
 26 
 27 import com.sun.tools.attach.AttachOperationFailedException;
 28 import com.sun.tools.attach.AgentLoadException;
 29 import com.sun.tools.attach.AttachNotSupportedException;
 30 import com.sun.tools.attach.spi.AttachProvider;
 31 
 32 import java.io.InputStream;
 33 import java.io.IOException;
 34 import java.io.File;
 35 
 36 /*
 37  * Bsd implementation of HotSpotVirtualMachine
 38  */
 39 public class VirtualMachineImpl extends HotSpotVirtualMachine {
 40     // &quot;tmpdir&quot; is used as a global well-known location for the files
 41     // .java_pid&lt;pid&gt;. and .attach_pid&lt;pid&gt;. It is important that this
 42     // location is the same for all processes, otherwise the tools
 43     // will not be able to find all Hotspot processes.
 44     // This is intentionally not the same as java.io.tmpdir, since
 45     // the latter can be changed by the user.
 46     // Any changes to this needs to be synchronized with HotSpot.
 47     private static final String tmpdir;
 48     String socket_path;
 49 
 50     /**
 51      * Attaches to the target VM
 52      */
 53     VirtualMachineImpl(AttachProvider provider, String vmid)
 54         throws AttachNotSupportedException, IOException
 55     {
 56         super(provider, vmid);
 57 
 58         // This provider only understands pids
 59         int pid;
 60         try {
 61             pid = Integer.parseInt(vmid);
 62             if (pid &lt; 1) {
 63                 throw new NumberFormatException();
 64             }
 65         } catch (NumberFormatException x) {
 66             throw new AttachNotSupportedException(&quot;Invalid process identifier: &quot; + vmid);
 67         }
 68 
 69         // Find the socket file. If not found then we attempt to start the
 70         // attach mechanism in the target VM by sending it a QUIT signal.
 71         // Then we attempt to find the socket file again.
 72         File socket_file = new File(tmpdir, &quot;.java_pid&quot; + pid);
 73         socket_path = socket_file.getPath();
 74         if (!socket_file.exists()) {
 75             File f = createAttachFile(pid);
 76             try {
 77                 sendQuitTo(pid);
 78 
 79                 // give the target VM time to start the attach mechanism
 80                 final int delay_step = 100;
 81                 final long timeout = attachTimeout();
 82                 long time_spend = 0;
 83                 long delay = 0;
 84                 do {
 85                     // Increase timeout on each attempt to reduce polling
 86                     delay += delay_step;
 87                     try {
 88                         Thread.sleep(delay);
 89                     } catch (InterruptedException x) { }
 90 
 91                     time_spend += delay;
 92                     if (time_spend &gt; timeout/2 &amp;&amp; !socket_file.exists()) {
 93                         // Send QUIT again to give target VM the last chance to react
 94                         sendQuitTo(pid);
 95                     }
 96                 } while (time_spend &lt;= timeout &amp;&amp; !socket_file.exists());
 97                 if (!socket_file.exists()) {
 98                     throw new AttachNotSupportedException(
 99                         String.format(&quot;Unable to open socket file %s: &quot; +
100                                       &quot;target process %d doesn&#39;t respond within %dms &quot; +
101                                       &quot;or HotSpot VM not loaded&quot;, socket_path,
102                                       pid, time_spend));
103                 }
104             } finally {
105                 f.delete();
106             }
107         }
108 
109         // Check that the file owner/permission to avoid attaching to
110         // bogus process
111         checkPermissions(socket_path);
112 
113         // Check that we can connect to the process
114         // - this ensures we throw the permission denied error now rather than
115         // later when we attempt to enqueue a command.
116         int s = socket();
117         try {
118             connect(s, socket_path);
119         } finally {
120             close(s);
121         }
122     }
123 
124     /**
125      * Detach from the target VM
126      */
127     public void detach() throws IOException {
128         synchronized (this) {
129             if (socket_path != null) {
130                 socket_path = null;
131             }
132         }
133     }
134 
135     // protocol version
136     private final static String PROTOCOL_VERSION = &quot;1&quot;;
137 
138     // known errors
139     private final static int ATTACH_ERROR_BADVERSION = 101;
140 
141     /**
142      * Execute the given command in the target VM.
143      */
144     InputStream execute(String cmd, Object ... args) throws AgentLoadException, IOException {
145         assert args.length &lt;= 3;                // includes null
146 
147         // did we detach?
148         synchronized (this) {
149             if (socket_path == null) {
150                 throw new IOException(&quot;Detached from target VM&quot;);
151             }
152         }
153 
154         // create UNIX socket
155         int s = socket();
156 
157         // connect to target VM
158         try {
159             connect(s, socket_path);
160         } catch (IOException x) {
161             close(s);
162             throw x;
163         }
164 
165         IOException ioe = null;
166 
167         // connected - write request
168         // &lt;ver&gt; &lt;cmd&gt; &lt;args...&gt;
169         try {
170             writeString(s, PROTOCOL_VERSION);
171             writeString(s, cmd);
172 
173             for (int i = 0; i &lt; 3; i++) {
174                 if (i &lt; args.length &amp;&amp; args[i] != null) {
175                     writeString(s, (String)args[i]);
176                 } else {
177                     writeString(s, &quot;&quot;);
178                 }
179             }
180         } catch (IOException x) {
181             ioe = x;
182         }
183 
184 
185         // Create an input stream to read reply
186         SocketInputStream sis = new SocketInputStream(s);
187 
188         // Read the command completion status
189         int completionStatus;
190         try {
191             completionStatus = readInt(sis);
192         } catch (IOException x) {
193             sis.close();
194             if (ioe != null) {
195                 throw ioe;
196             } else {
197                 throw x;
198             }
199         }
200 
201         if (completionStatus != 0) {
202             // read from the stream and use that as the error message
203             String message = readErrorMessage(sis);
204             sis.close();
205 
206             // In the event of a protocol mismatch then the target VM
207             // returns a known error so that we can throw a reasonable
208             // error.
209             if (completionStatus == ATTACH_ERROR_BADVERSION) {
210                 throw new IOException(&quot;Protocol mismatch with target VM&quot;);
211             }
212 
213             // Special-case the &quot;load&quot; command so that the right exception is
214             // thrown.
215             if (cmd.equals(&quot;load&quot;)) {
216                 String msg = &quot;Failed to load agent library&quot;;
217                 if (!message.isEmpty())
218                     msg += &quot;: &quot; + message;
219                 throw new AgentLoadException(msg);
220             } else {
221                 if (message.isEmpty())
222                     message = &quot;Command failed in target VM&quot;;
223                 throw new AttachOperationFailedException(message);
224             }
225         }
226 
227         // Return the input stream so that the command output can be read
228         return sis;
229     }
230 
231     /*
232      * InputStream for the socket connection to get target VM
233      */
234     private class SocketInputStream extends InputStream {
235         int s;
236 
237         public SocketInputStream(int s) {
238             this.s = s;
239         }
240 
241         public synchronized int read() throws IOException {
242             byte b[] = new byte[1];
243             int n = this.read(b, 0, 1);
244             if (n == 1) {
245                 return b[0] &amp; 0xff;
246             } else {
247                 return -1;
248             }
249         }
250 
251         public synchronized int read(byte[] bs, int off, int len) throws IOException {
252             if ((off &lt; 0) || (off &gt; bs.length) || (len &lt; 0) ||
253                 ((off + len) &gt; bs.length) || ((off + len) &lt; 0)) {
254                 throw new IndexOutOfBoundsException();
255             } else if (len == 0) {
256                 return 0;
257             }
258 
259             return VirtualMachineImpl.read(s, bs, off, len);
260         }
261 
262         public synchronized void close() throws IOException {
263             if (s != -1) {
264                 int toClose = s;
265                 s = -1;
266                 VirtualMachineImpl.close(toClose);
267             }
268         }
269     }
270 
271     /*
272      * Write/sends the given to the target VM. String is transmitted in
273      * UTF-8 encoding.
274      */
275     private void writeString(int fd, String s) throws IOException {
276         if (s.length() &gt; 0) {
277             byte b[];
278             try {
279                 b = s.getBytes(&quot;UTF-8&quot;);
280             } catch (java.io.UnsupportedEncodingException x) {
281                 throw new InternalError(x);
282             }
283             VirtualMachineImpl.write(fd, b, 0, b.length);
284         }
285         byte b[] = new byte[1];
286         b[0] = 0;
287         write(fd, b, 0, 1);
288     }
289 
290     private File createAttachFile(int pid) throws IOException {
291         File f = new File(tmpdir, &quot;.attach_pid&quot; + pid);
292         createAttachFile0(f.getPath());
293         return f;
294     }
295 
296     //-- native methods
297 
298     static native void sendQuitTo(int pid) throws IOException;
299 
300     static native void checkPermissions(String path) throws IOException;
301 
302     static native int socket() throws IOException;
303 
304     static native void connect(int fd, String path) throws IOException;
305 
306     static native void close(int fd) throws IOException;
307 
308     static native int read(int fd, byte buf[], int off, int bufLen) throws IOException;
309 
310     static native void write(int fd, byte buf[], int off, int bufLen) throws IOException;
311 
312     static native void createAttachFile0(String path);
313 
314     static native String getTempDir();
315 
316     static {
317         System.loadLibrary(&quot;attach&quot;);
318         tmpdir = getTempDir();
319     }
320 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.attach/macosx/classes/sun/tools/attach/VirtualMachineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.tools.attach;
 26 
 27 import com.sun.tools.attach.AttachOperationFailedException;
 28 import com.sun.tools.attach.AgentLoadException;
 29 import com.sun.tools.attach.AttachNotSupportedException;
 30 import com.sun.tools.attach.spi.AttachProvider;
 31 
 32 import java.io.InputStream;
 33 import java.io.IOException;
 34 import java.io.File;
 35 
 36 /*
 37  * Bsd implementation of HotSpotVirtualMachine
 38  */
 39 public class VirtualMachineImpl extends HotSpotVirtualMachine {
 40     // &quot;tmpdir&quot; is used as a global well-known location for the files
 41     // .java_pid&lt;pid&gt;. and .attach_pid&lt;pid&gt;. It is important that this
 42     // location is the same for all processes, otherwise the tools
 43     // will not be able to find all Hotspot processes.
 44     // This is intentionally not the same as java.io.tmpdir, since
 45     // the latter can be changed by the user.
 46     // Any changes to this needs to be synchronized with HotSpot.
 47     private static final String tmpdir;
 48     String socket_path;
 49 
 50     /**
 51      * Attaches to the target VM
 52      */
 53     VirtualMachineImpl(AttachProvider provider, String vmid)
 54         throws AttachNotSupportedException, IOException
 55     {
 56         super(provider, vmid);
 57 
 58         // This provider only understands pids
 59         int pid;
 60         try {
 61             pid = Integer.parseInt(vmid);
<a name="1" id="anc1"></a>


 62         } catch (NumberFormatException x) {
<a name="2" id="anc2"></a><span class="line-modified"> 63             throw new AttachNotSupportedException(&quot;Invalid process identifier&quot;);</span>
 64         }
 65 
 66         // Find the socket file. If not found then we attempt to start the
 67         // attach mechanism in the target VM by sending it a QUIT signal.
 68         // Then we attempt to find the socket file again.
 69         File socket_file = new File(tmpdir, &quot;.java_pid&quot; + pid);
 70         socket_path = socket_file.getPath();
 71         if (!socket_file.exists()) {
 72             File f = createAttachFile(pid);
 73             try {
 74                 sendQuitTo(pid);
 75 
 76                 // give the target VM time to start the attach mechanism
 77                 final int delay_step = 100;
 78                 final long timeout = attachTimeout();
 79                 long time_spend = 0;
 80                 long delay = 0;
 81                 do {
 82                     // Increase timeout on each attempt to reduce polling
 83                     delay += delay_step;
 84                     try {
 85                         Thread.sleep(delay);
 86                     } catch (InterruptedException x) { }
 87 
 88                     time_spend += delay;
 89                     if (time_spend &gt; timeout/2 &amp;&amp; !socket_file.exists()) {
 90                         // Send QUIT again to give target VM the last chance to react
 91                         sendQuitTo(pid);
 92                     }
 93                 } while (time_spend &lt;= timeout &amp;&amp; !socket_file.exists());
 94                 if (!socket_file.exists()) {
 95                     throw new AttachNotSupportedException(
 96                         String.format(&quot;Unable to open socket file %s: &quot; +
 97                                       &quot;target process %d doesn&#39;t respond within %dms &quot; +
 98                                       &quot;or HotSpot VM not loaded&quot;, socket_path,
 99                                       pid, time_spend));
100                 }
101             } finally {
102                 f.delete();
103             }
104         }
105 
106         // Check that the file owner/permission to avoid attaching to
107         // bogus process
108         checkPermissions(socket_path);
109 
110         // Check that we can connect to the process
111         // - this ensures we throw the permission denied error now rather than
112         // later when we attempt to enqueue a command.
113         int s = socket();
114         try {
115             connect(s, socket_path);
116         } finally {
117             close(s);
118         }
119     }
120 
121     /**
122      * Detach from the target VM
123      */
124     public void detach() throws IOException {
125         synchronized (this) {
126             if (socket_path != null) {
127                 socket_path = null;
128             }
129         }
130     }
131 
132     // protocol version
133     private final static String PROTOCOL_VERSION = &quot;1&quot;;
134 
135     // known errors
136     private final static int ATTACH_ERROR_BADVERSION = 101;
137 
138     /**
139      * Execute the given command in the target VM.
140      */
141     InputStream execute(String cmd, Object ... args) throws AgentLoadException, IOException {
142         assert args.length &lt;= 3;                // includes null
143 
144         // did we detach?
145         synchronized (this) {
146             if (socket_path == null) {
147                 throw new IOException(&quot;Detached from target VM&quot;);
148             }
149         }
150 
151         // create UNIX socket
152         int s = socket();
153 
154         // connect to target VM
155         try {
156             connect(s, socket_path);
157         } catch (IOException x) {
158             close(s);
159             throw x;
160         }
161 
162         IOException ioe = null;
163 
164         // connected - write request
165         // &lt;ver&gt; &lt;cmd&gt; &lt;args...&gt;
166         try {
167             writeString(s, PROTOCOL_VERSION);
168             writeString(s, cmd);
169 
170             for (int i = 0; i &lt; 3; i++) {
171                 if (i &lt; args.length &amp;&amp; args[i] != null) {
172                     writeString(s, (String)args[i]);
173                 } else {
174                     writeString(s, &quot;&quot;);
175                 }
176             }
177         } catch (IOException x) {
178             ioe = x;
179         }
180 
181 
182         // Create an input stream to read reply
183         SocketInputStream sis = new SocketInputStream(s);
184 
185         // Read the command completion status
186         int completionStatus;
187         try {
188             completionStatus = readInt(sis);
189         } catch (IOException x) {
190             sis.close();
191             if (ioe != null) {
192                 throw ioe;
193             } else {
194                 throw x;
195             }
196         }
197 
198         if (completionStatus != 0) {
199             // read from the stream and use that as the error message
200             String message = readErrorMessage(sis);
201             sis.close();
202 
203             // In the event of a protocol mismatch then the target VM
204             // returns a known error so that we can throw a reasonable
205             // error.
206             if (completionStatus == ATTACH_ERROR_BADVERSION) {
207                 throw new IOException(&quot;Protocol mismatch with target VM&quot;);
208             }
209 
210             // Special-case the &quot;load&quot; command so that the right exception is
211             // thrown.
212             if (cmd.equals(&quot;load&quot;)) {
213                 String msg = &quot;Failed to load agent library&quot;;
214                 if (!message.isEmpty())
215                     msg += &quot;: &quot; + message;
216                 throw new AgentLoadException(msg);
217             } else {
218                 if (message.isEmpty())
219                     message = &quot;Command failed in target VM&quot;;
220                 throw new AttachOperationFailedException(message);
221             }
222         }
223 
224         // Return the input stream so that the command output can be read
225         return sis;
226     }
227 
228     /*
229      * InputStream for the socket connection to get target VM
230      */
231     private class SocketInputStream extends InputStream {
232         int s;
233 
234         public SocketInputStream(int s) {
235             this.s = s;
236         }
237 
238         public synchronized int read() throws IOException {
239             byte b[] = new byte[1];
240             int n = this.read(b, 0, 1);
241             if (n == 1) {
242                 return b[0] &amp; 0xff;
243             } else {
244                 return -1;
245             }
246         }
247 
248         public synchronized int read(byte[] bs, int off, int len) throws IOException {
249             if ((off &lt; 0) || (off &gt; bs.length) || (len &lt; 0) ||
250                 ((off + len) &gt; bs.length) || ((off + len) &lt; 0)) {
251                 throw new IndexOutOfBoundsException();
252             } else if (len == 0) {
253                 return 0;
254             }
255 
256             return VirtualMachineImpl.read(s, bs, off, len);
257         }
258 
<a name="3" id="anc3"></a><span class="line-modified">259         public void close() throws IOException {</span>
<span class="line-modified">260             VirtualMachineImpl.close(s);</span>




261         }
262     }
263 
264     /*
265      * Write/sends the given to the target VM. String is transmitted in
266      * UTF-8 encoding.
267      */
268     private void writeString(int fd, String s) throws IOException {
269         if (s.length() &gt; 0) {
270             byte b[];
271             try {
272                 b = s.getBytes(&quot;UTF-8&quot;);
273             } catch (java.io.UnsupportedEncodingException x) {
274                 throw new InternalError(x);
275             }
276             VirtualMachineImpl.write(fd, b, 0, b.length);
277         }
278         byte b[] = new byte[1];
279         b[0] = 0;
280         write(fd, b, 0, 1);
281     }
282 
283     private File createAttachFile(int pid) throws IOException {
284         File f = new File(tmpdir, &quot;.attach_pid&quot; + pid);
285         createAttachFile0(f.getPath());
286         return f;
287     }
288 
289     //-- native methods
290 
291     static native void sendQuitTo(int pid) throws IOException;
292 
293     static native void checkPermissions(String path) throws IOException;
294 
295     static native int socket() throws IOException;
296 
297     static native void connect(int fd, String path) throws IOException;
298 
299     static native void close(int fd) throws IOException;
300 
301     static native int read(int fd, byte buf[], int off, int bufLen) throws IOException;
302 
303     static native void write(int fd, byte buf[], int off, int bufLen) throws IOException;
304 
305     static native void createAttachFile0(String path);
306 
307     static native String getTempDir();
308 
309     static {
310         System.loadLibrary(&quot;attach&quot;);
311         tmpdir = getTempDir();
312     }
313 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
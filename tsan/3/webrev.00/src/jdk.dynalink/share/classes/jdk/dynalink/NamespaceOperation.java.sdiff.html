<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.dynalink/share/classes/jdk/dynalink/NamespaceOperation.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../jdk.crypto.ucrypto/solaris/classes/module-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../jdk.hotspot.agent/linux/native/libsaproc/libproc.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.dynalink/share/classes/jdk/dynalink/NamespaceOperation.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 72  *     StandardNamespace.PROPERTY);
 73  * &lt;/pre&gt;
 74  * They are often combined with {@link NamedOperation}, e.g. to express a
 75  * property getter for a property named &quot;color&quot;, you would construct:
 76  * &lt;pre&gt;
 77  * Operation colorPropertyGetter = new NamedOperation(
 78  *     new NamespaceOperation(
 79  *         StandardOperation.GET,
 80  *         StandardNamespace.PROPERTY),
 81  *     &quot;color&quot;);
 82  * &lt;/pre&gt;
 83  * &lt;p&gt;While {@code NamespaceOperation} can be constructed directly, it is often convenient
 84  * to use the {@link Operation#withNamespace(Namespace)} and {@link Operation#withNamespaces(Namespace...)} factory
 85  * methods instead, e.g.:
 86  * &lt;pre&gt;
 87  * Operation getElementOrPropertyEmpty =
 88  *     StandardOperation.GET
 89  *         .withNamespace(StandardNamespace.PROPERTY)
 90  *         .named(&quot;color&quot;);
 91  * &lt;/pre&gt;
<span class="line-modified"> 92  * &lt;h3&gt;Operations on multiple namespaces&lt;/h3&gt;</span>
 93  * If multiple namespaces are specified, the namespaces are treated as
 94  * alternatives to each other in order of preference. The semantics of
 95  * such operation is &quot;first applicable&quot;.
 96  * That is, a composite of {@code GET:PROPERTY|ELEMENT:color} should be
 97  * interpreted as &lt;i&gt;get the property named &quot;color&quot; on the object, but if the
 98  * property does not exist, then get the collection element named &quot;color&quot;
 99  * instead&lt;/i&gt;.
100  * &lt;p&gt;
101  * Operations with multiple namespaces are helpful in implementation of languages that
102  * don&#39;t distinguish between one or more of the namespaces, or when expressing operations
103  * against objects that can be considered both ordinary objects and collections, e.g. Java
104  * {@link java.util.Map} objects. A {@code GET:PROPERTY|ELEMENT:empty} operation
105  * against a Java map will always match
106  * the {@link java.util.Map#isEmpty()} property, but
107  * {@code GET:ELEMENT|PROPERTY:empty} will actually match a map element with
108  * key {@code &quot;empty&quot;} if the map contains that key, and only fall back to the
109  * {@code isEmpty()} property getter if the map does not contain the key. If
110  * the source language mandates this semantics, it can be easily achieved using
111  * operations on multiple namespaces.
112  * &lt;p&gt;
</pre>
</td>
<td>
<hr />
<pre>
 72  *     StandardNamespace.PROPERTY);
 73  * &lt;/pre&gt;
 74  * They are often combined with {@link NamedOperation}, e.g. to express a
 75  * property getter for a property named &quot;color&quot;, you would construct:
 76  * &lt;pre&gt;
 77  * Operation colorPropertyGetter = new NamedOperation(
 78  *     new NamespaceOperation(
 79  *         StandardOperation.GET,
 80  *         StandardNamespace.PROPERTY),
 81  *     &quot;color&quot;);
 82  * &lt;/pre&gt;
 83  * &lt;p&gt;While {@code NamespaceOperation} can be constructed directly, it is often convenient
 84  * to use the {@link Operation#withNamespace(Namespace)} and {@link Operation#withNamespaces(Namespace...)} factory
 85  * methods instead, e.g.:
 86  * &lt;pre&gt;
 87  * Operation getElementOrPropertyEmpty =
 88  *     StandardOperation.GET
 89  *         .withNamespace(StandardNamespace.PROPERTY)
 90  *         .named(&quot;color&quot;);
 91  * &lt;/pre&gt;
<span class="line-modified"> 92  * &lt;h2&gt;Operations on multiple namespaces&lt;/h2&gt;</span>
 93  * If multiple namespaces are specified, the namespaces are treated as
 94  * alternatives to each other in order of preference. The semantics of
 95  * such operation is &quot;first applicable&quot;.
 96  * That is, a composite of {@code GET:PROPERTY|ELEMENT:color} should be
 97  * interpreted as &lt;i&gt;get the property named &quot;color&quot; on the object, but if the
 98  * property does not exist, then get the collection element named &quot;color&quot;
 99  * instead&lt;/i&gt;.
100  * &lt;p&gt;
101  * Operations with multiple namespaces are helpful in implementation of languages that
102  * don&#39;t distinguish between one or more of the namespaces, or when expressing operations
103  * against objects that can be considered both ordinary objects and collections, e.g. Java
104  * {@link java.util.Map} objects. A {@code GET:PROPERTY|ELEMENT:empty} operation
105  * against a Java map will always match
106  * the {@link java.util.Map#isEmpty()} property, but
107  * {@code GET:ELEMENT|PROPERTY:empty} will actually match a map element with
108  * key {@code &quot;empty&quot;} if the map contains that key, and only fall back to the
109  * {@code isEmpty()} property getter if the map does not contain the key. If
110  * the source language mandates this semantics, it can be easily achieved using
111  * operations on multiple namespaces.
112  * &lt;p&gt;
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../jdk.crypto.ucrypto/solaris/classes/module-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../jdk.hotspot.agent/linux/native/libsaproc/libproc.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/share/native/libapplauncher/Platform.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;Platform.h&quot;
 27 #include &quot;Messages.h&quot;
 28 #include &quot;PlatformString.h&quot;
 29 #include &quot;FilePath.h&quot;
 30 
 31 #include &lt;fstream&gt;
 32 #include &lt;locale&gt;
 33 
 34 #ifdef WINDOWS
 35 #include &quot;WindowsPlatform.h&quot;
 36 #endif // WINDOWS
 37 #ifdef LINUX
 38 #include &quot;LinuxPlatform.h&quot;
 39 #endif // LINUX
 40 #ifdef MAC
 41 #include &quot;MacPlatform.h&quot;
 42 #endif // MAC
 43 
 44 Platform&amp; Platform::GetInstance() {
 45 #ifdef WINDOWS
 46     static WindowsPlatform instance;
 47 #endif // WINDOWS
 48 
 49 #ifdef LINUX
 50     static LinuxPlatform instance;
 51 #endif // LINUX
 52 
 53 #ifdef MAC
 54     static MacPlatform instance;
 55 #endif // MAC
 56 
 57     return instance;
 58 }
 59 
 60 TString Platform::GetConfigFileName() {
 61     TString result;
 62     TString basedir = GetPackageAppDirectory();
 63 
 64     if (basedir.empty() == false) {
 65         basedir = FilePath::IncludeTrailingSeparator(basedir);
 66         TString appConfig = basedir + GetAppName() + _T(&quot;.cfg&quot;);
 67 
 68         if (FilePath::FileExists(appConfig) == true) {
 69             result = appConfig;
 70         }
 71         else {
 72             result = basedir + _T(&quot;package.cfg&quot;);
 73 
 74             if (FilePath::FileExists(result) == false) {
 75                 result = _T(&quot;&quot;);
 76             }
 77         }
 78     }
 79 
 80     return result;
 81 }
 82 
 83 std::list&lt;TString&gt; Platform::LoadFromFile(TString FileName) {
 84     std::list&lt;TString&gt; result;
 85 
 86     if (FilePath::FileExists(FileName) == true) {
 87         std::wifstream stream(FileName.data());
 88         InitStreamLocale(&amp;stream);
 89 
 90         if (stream.is_open() == true) {
 91             while (stream.eof() == false) {
 92                 std::wstring line;
 93                 std::getline(stream, line);
 94 
 95                 // # at the first character will comment out the line.
 96                 if (line.empty() == false &amp;&amp; line[0] != &#39;#&#39;) {
 97                     result.push_back(PlatformString(line).toString());
 98                 }
 99             }
100         }
101     }
102 
103     return result;
104 }
105 
106 void Platform::SaveToFile(TString FileName, std::list&lt;TString&gt; Contents, bool ownerOnly) {
107     TString path = FilePath::ExtractFilePath(FileName);
108 
109     if (FilePath::DirectoryExists(path) == false) {
110         FilePath::CreateDirectory(path, ownerOnly);
111     }
112 
113     std::wofstream stream(FileName.data());
114     InitStreamLocale(&amp;stream);
115 
116     FilePath::ChangePermissions(FileName.data(), ownerOnly);
117 
118     if (stream.is_open() == true) {
119         for (std::list&lt;TString&gt;::const_iterator iterator =
120                 Contents.begin(); iterator != Contents.end(); iterator++) {
121             TString line = *iterator;
122             stream &lt;&lt; PlatformString(line).toUnicodeString() &lt;&lt; std::endl;
123         }
124     }
125 }
126 
127 std::map&lt;TString, TString&gt; Platform::GetKeys() {
128     std::map&lt;TString, TString&gt; keys;
129     keys.insert(std::map&lt;TString, TString&gt;::value_type(CONFIG_VERSION,
130             _T(&quot;app.version&quot;)));
131     keys.insert(std::map&lt;TString, TString&gt;::value_type(CONFIG_MAINJAR_KEY,
132             _T(&quot;app.mainjar&quot;)));
133     keys.insert(std::map&lt;TString, TString&gt;::value_type(CONFIG_MAINMODULE_KEY,
134             _T(&quot;app.mainmodule&quot;)));
135     keys.insert(std::map&lt;TString, TString&gt;::value_type(CONFIG_MAINCLASSNAME_KEY,
136             _T(&quot;app.mainclass&quot;)));
137     keys.insert(std::map&lt;TString, TString&gt;::value_type(CONFIG_CLASSPATH_KEY,
138             _T(&quot;app.classpath&quot;)));
139     keys.insert(std::map&lt;TString, TString&gt;::value_type(CONFIG_MODULEPATH_KEY,
140             _T(&quot;app.modulepath&quot;)));
141     keys.insert(std::map&lt;TString, TString&gt;::value_type(APP_NAME_KEY,
142             _T(&quot;app.name&quot;)));
143     keys.insert(std::map&lt;TString, TString&gt;::value_type(JAVA_RUNTIME_KEY,
144             _T(&quot;app.runtime&quot;)));
145     keys.insert(std::map&lt;TString, TString&gt;::value_type(JPACKAGE_APP_DATA_DIR,
146             _T(&quot;app.identifier&quot;)));
147     keys.insert(std::map&lt;TString, TString&gt;::value_type(CONFIG_SPLASH_KEY,
148             _T(&quot;app.splash&quot;)));
149     keys.insert(std::map&lt;TString, TString&gt;::value_type(CONFIG_APP_MEMORY,
150             _T(&quot;app.memory&quot;)));
151     keys.insert(std::map&lt;TString, TString&gt;::value_type(CONFIG_APP_DEBUG,
152             _T(&quot;app.debug&quot;)));
153     keys.insert(std::map&lt;TString,
154             TString&gt;::value_type(CONFIG_APPLICATION_INSTANCE,
155             _T(&quot;app.application.instance&quot;)));
156     keys.insert(std::map&lt;TString,
157             TString&gt;::value_type(CONFIG_SECTION_APPLICATION,
158             _T(&quot;Application&quot;)));
159     keys.insert(std::map&lt;TString,
160             TString&gt;::value_type(CONFIG_SECTION_JAVAOPTIONS,
161             _T(&quot;JavaOptions&quot;)));
162     keys.insert(std::map&lt;TString,
163             TString&gt;::value_type(CONFIG_SECTION_APPCDSJAVAOPTIONS,
164             _T(&quot;AppCDSJavaOptions&quot;)));
165     keys.insert(std::map&lt;TString,
166             TString&gt;::value_type(CONFIG_SECTION_APPCDSGENERATECACHEJAVAOPTIONS,
167             _T(&quot;AppCDSGenerateCacheJavaOptions&quot;)));
168     keys.insert(std::map&lt;TString,
169             TString&gt;::value_type(CONFIG_SECTION_ARGOPTIONS,
170             _T(&quot;ArgOptions&quot;)));
171 
172     return keys;
173 }
    </pre>
  </body>
</html>
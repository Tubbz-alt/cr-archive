<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/share/native/libapplauncher/Properties.h</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef PROPERTIES_H
 27 #define PROPERTIES_H
 28 
 29 #include &quot;PlatformDefs.h&quot;
 30 #include &quot;OrderedMap.h&quot;
 31 
 32 //#include &lt;stdio.h&gt;
 33 //#include &lt;stdlib.h&gt;
 34 //#include &lt;memory.h&gt;
 35 //#include &lt;string&gt;
 36 //#include &lt;map&gt;
 37 //#include &lt;list&gt;
 38 //#include &lt;vector&gt;
 39 //#include &lt;fstream&gt;
 40 
 41 //using namespace std;
 42 
 43 template &lt;typename ObjectType, typename ValueType,
 44         ValueType (ObjectType::*getter)(void),
 45         void (ObjectType::*setter)(ValueType)&gt;
 46 class Property {
 47 private:
 48     ObjectType* FObject;
 49 
 50 public:
 51     Property() {
 52         FObject = NULL;
 53     }
 54 
 55     void SetInstance(ObjectType* Value) {
 56         FObject = Value;
 57     }
 58 
 59     // To set the value using the set method.
 60     ValueType operator =(const ValueType&amp; Value) {
 61         assert(FObject != NULL);
 62         (FObject-&gt;*setter)(Value);
 63         return Value;
 64     }
 65 
 66     // The Property class is treated as the internal type.
 67     operator ValueType() {
 68         assert(FObject != NULL);
 69         return (FObject-&gt;*getter)();
 70     }
 71 };
 72 
 73 template &lt;typename ObjectType, typename ValueType,
 74         ValueType (ObjectType::*getter)(void)&gt;
 75 class ReadProperty {
 76 private:
 77     ObjectType* FObject;
 78 
 79 public:
 80     ReadProperty() {
 81         FObject = NULL;
 82     }
 83 
 84     void SetInstance(ObjectType* Value) {
 85         FObject = Value;
 86     }
 87 
 88     // The Property class is treated as the internal type.
 89     operator ValueType() {
 90         assert(FObject != NULL);
 91         return (FObject-&gt;*getter)();
 92     }
 93 };
 94 
 95 template &lt;typename ObjectType, typename ValueType,
 96         void (ObjectType::*setter)(ValueType)&gt;
 97 class WriteProperty {
 98 private:
 99     ObjectType* FObject;
100 
101 public:
102     WriteProperty() {
103         FObject = NULL;
104     }
105 
106     void SetInstance(ObjectType* Value) {
107         FObject = Value;
108     }
109 
110     // To set the value using the set method.
111     ValueType operator =(const ValueType&amp; Value) {
112         assert(FObject != NULL);
113         (FObject-&gt;*setter)(Value);
114         return Value;
115     }
116 };
117 
118 template &lt;typename ValueType,
119         ValueType (*getter)(void), void (*setter)(ValueType)&gt;
120 class StaticProperty {
121 public:
122     StaticProperty() {
123     }
124 
125     // To set the value using the set method.
126     ValueType operator =(const ValueType&amp; Value) {
127         (*getter)(Value);
128         return Value;
129     }
130 
131     // The Property class is treated as the internal type which is the getter.
132     operator ValueType() {
133         return (*setter)();
134     }
135 };
136 
137 template &lt;typename ValueType, ValueType (*getter)(void)&gt;
138 class StaticReadProperty {
139 public:
140     StaticReadProperty() {
141     }
142 
143     // The Property class is treated as the internal type which is the getter.
144     operator ValueType() {
145         return (*getter)();
146     }
147 };
148 
149 template &lt;typename ValueType, void (*setter)(ValueType)&gt;
150 class StaticWriteProperty {
151 public:
152     StaticWriteProperty() {
153     }
154 
155     // To set the value using the set method.
156     ValueType operator =(const ValueType&amp; Value) {
157         (*setter)(Value);
158         return Value;
159     }
160 };
161 
162 class IPropertyContainer {
163 public:
164     IPropertyContainer(void) {}
165     virtual ~IPropertyContainer(void) {}
166 
167     virtual bool GetValue(const TString Key, TString&amp; Value) = 0;
168     virtual size_t GetCount() = 0;
169 };
170 
171 class ISectionalPropertyContainer {
172 public:
173     ISectionalPropertyContainer(void) {}
174     virtual ~ISectionalPropertyContainer(void) {}
175 
176     virtual bool GetValue(const TString SectionName,
177             const TString Key, TString&amp; Value) = 0;
178     virtual bool ContainsSection(const TString SectionName) = 0;
179     virtual bool GetSection(const TString SectionName,
180             OrderedMap&lt;TString, TString&gt; &amp;Data) = 0;
181 };
182 
183 #endif // PROPERTIES_H
184 
    </pre>
  </body>
</html>
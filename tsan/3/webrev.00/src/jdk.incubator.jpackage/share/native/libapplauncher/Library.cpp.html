<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/share/native/libapplauncher/Library.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;Library.h&quot;
 27 #include &quot;Platform.h&quot;
 28 #include &quot;Messages.h&quot;
 29 #include &quot;PlatformString.h&quot;
 30 
 31 #include &lt;fstream&gt;
 32 #include &lt;locale&gt;
 33 
 34 Library::Library() {
 35     Initialize();
 36 }
 37 
 38 Library::Library(const TString &amp;FileName) {
 39     Initialize();
 40     Load(FileName);
 41 }
 42 
 43 Library::~Library() {
 44     Unload();
 45 }
 46 
 47 void Library::Initialize() {
 48     FModule = NULL;
 49     FDependentLibraryNames = NULL;
 50     FDependenciesLibraries = NULL;
 51 }
 52 
 53 void Library::InitializeDependencies() {
 54     if (FDependentLibraryNames == NULL) {
 55         FDependentLibraryNames = new std::vector&lt;TString&gt;();
 56     }
 57 
 58     if (FDependenciesLibraries == NULL) {
 59         FDependenciesLibraries = new std::vector&lt;Library*&gt;();
 60     }
 61 }
 62 
 63 void Library::LoadDependencies() {
 64     if (FDependentLibraryNames != NULL &amp;&amp; FDependenciesLibraries != NULL) {
 65         for (std::vector&lt;TString&gt;::const_iterator iterator =
 66                 FDependentLibraryNames-&gt;begin();
 67                 iterator != FDependentLibraryNames-&gt;end(); iterator++) {
 68             Library* library = new Library();
 69 
 70             if (library-&gt;Load(*iterator) == true) {
 71                 FDependenciesLibraries-&gt;push_back(library);
 72             }
 73         }
 74 
 75         delete FDependentLibraryNames;
 76         FDependentLibraryNames = NULL;
 77     }
 78 }
 79 
 80 void Library::UnloadDependencies() {
 81     if (FDependenciesLibraries != NULL) {
 82         for (std::vector&lt;Library*&gt;::const_iterator iterator =
 83                 FDependenciesLibraries-&gt;begin();
 84                 iterator != FDependenciesLibraries-&gt;end(); iterator++) {
 85             Library* library = *iterator;
 86 
 87             if (library != NULL) {
 88                 library-&gt;Unload();
 89                 delete library;
 90             }
 91         }
 92 
 93         delete FDependenciesLibraries;
 94         FDependenciesLibraries = NULL;
 95     }
 96 }
 97 
 98 Procedure Library::GetProcAddress(const std::string&amp; MethodName) const {
 99     Platform&amp; platform = Platform::GetInstance();
100     return platform.GetProcAddress(FModule, MethodName);
101 }
102 
103 bool Library::Load(const TString &amp;FileName) {
104     bool result = true;
105 
106     if (FModule == NULL) {
107         LoadDependencies();
108         Platform&amp; platform = Platform::GetInstance();
109         FModule = platform.LoadLibrary(FileName);
110 
111         if (FModule == NULL) {
112             Messages&amp; messages = Messages::GetInstance();
113             platform.ShowMessage(messages.GetMessage(LIBRARY_NOT_FOUND),
114                     FileName);
115             result = false;
116         } else {
117             fname = PlatformString(FileName).toStdString();
118         }
119     }
120 
121     return result;
122 }
123 
124 bool Library::Unload() {
125     bool result = false;
126 
127     if (FModule != NULL) {
128         Platform&amp; platform = Platform::GetInstance();
129         platform.FreeLibrary(FModule);
130         FModule = NULL;
131         UnloadDependencies();
132         result = true;
133     }
134 
135     return result;
136 }
137 
138 void Library::AddDependency(const TString &amp;FileName) {
139     InitializeDependencies();
140 
141     if (FDependentLibraryNames != NULL) {
142         FDependentLibraryNames-&gt;push_back(FileName);
143     }
144 }
145 
146 void Library::AddDependencies(const std::vector&lt;TString&gt; &amp;Dependencies) {
147     if (Dependencies.size() &gt; 0) {
148         InitializeDependencies();
149 
150         if (FDependentLibraryNames != NULL) {
151             for (std::vector&lt;TString&gt;::const_iterator iterator =
152                     FDependentLibraryNames-&gt;begin();
153                     iterator != FDependentLibraryNames-&gt;end(); iterator++) {
154                 TString fileName = *iterator;
155                 AddDependency(fileName);
156             }
157         }
158     }
159 }
160 
161 JavaLibrary::JavaLibrary() : Library(), FCreateProc(NULL) {
162 }
163 
164 bool JavaLibrary::JavaVMCreate(size_t argc, char *argv[]) {
165     if (FCreateProc == NULL) {
166         FCreateProc = (JAVA_CREATE) GetProcAddress(LAUNCH_FUNC);
167     }
168 
169     if (FCreateProc == NULL) {
170         Platform&amp; platform = Platform::GetInstance();
171         Messages&amp; messages = Messages::GetInstance();
172         platform.ShowMessage(
173                 messages.GetMessage(FAILED_LOCATING_JVM_ENTRY_POINT));
174         return false;
175     }
176 
177     return FCreateProc((int) argc, argv,
178             0, NULL,
179             0, NULL,
180             &quot;&quot;,
181             &quot;&quot;,
182             &quot;java&quot;,
183             &quot;java&quot;,
184             false,
185             false,
186             false,
187             0) == 0;
188 }
    </pre>
  </body>
</html>
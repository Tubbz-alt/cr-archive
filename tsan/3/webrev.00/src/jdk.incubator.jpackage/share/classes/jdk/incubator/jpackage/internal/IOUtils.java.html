<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/share/classes/jdk/incubator/jpackage/internal/IOUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.*;
 29 import java.lang.reflect.InvocationHandler;
 30 import java.lang.reflect.Method;
 31 import java.lang.reflect.Proxy;
 32 import java.nio.channels.FileChannel;
 33 import java.nio.file.FileVisitResult;
 34 import java.nio.file.Files;
 35 import java.nio.file.Path;
 36 import java.nio.file.SimpleFileVisitor;
 37 import java.nio.file.StandardCopyOption;
 38 import java.nio.file.attribute.BasicFileAttributes;
 39 import java.util.*;
 40 import javax.xml.stream.XMLOutputFactory;
 41 import javax.xml.stream.XMLStreamException;
 42 import javax.xml.stream.XMLStreamWriter;
 43 
 44 /**
 45  * IOUtils
 46  *
 47  * A collection of static utility methods.
 48  */
 49 public class IOUtils {
 50 
 51     public static void deleteRecursive(File path) throws IOException {
 52         if (!path.exists()) {
 53             return;
 54         }
 55         Path directory = path.toPath();
 56         Files.walkFileTree(directory, new SimpleFileVisitor&lt;Path&gt;() {
 57             @Override
 58             public FileVisitResult visitFile(Path file,
 59                             BasicFileAttributes attr) throws IOException {
 60                 if (Platform.getPlatform() == Platform.WINDOWS) {
 61                     Files.setAttribute(file, &quot;dos:readonly&quot;, false);
 62                 }
 63                 Files.delete(file);
 64                 return FileVisitResult.CONTINUE;
 65             }
 66 
 67             @Override
 68             public FileVisitResult preVisitDirectory(Path dir,
 69                             BasicFileAttributes attr) throws IOException {
 70                 if (Platform.getPlatform() == Platform.WINDOWS) {
 71                     Files.setAttribute(dir, &quot;dos:readonly&quot;, false);
 72                 }
 73                 return FileVisitResult.CONTINUE;
 74             }
 75 
 76             @Override
 77             public FileVisitResult postVisitDirectory(Path dir, IOException e)
 78                             throws IOException {
 79                 Files.delete(dir);
 80                 return FileVisitResult.CONTINUE;
 81             }
 82         });
 83     }
 84 
 85     public static void copyRecursive(Path src, Path dest) throws IOException {
 86         copyRecursive(src, dest, List.of());
 87     }
 88 
 89     public static void copyRecursive(Path src, Path dest,
 90             final List&lt;String&gt; excludes) throws IOException {
 91         Files.walkFileTree(src, new SimpleFileVisitor&lt;Path&gt;() {
 92             @Override
 93             public FileVisitResult preVisitDirectory(final Path dir,
 94                     final BasicFileAttributes attrs) throws IOException {
 95                 if (excludes.contains(dir.toFile().getName())) {
 96                     return FileVisitResult.SKIP_SUBTREE;
 97                 } else {
 98                     Files.createDirectories(dest.resolve(src.relativize(dir)));
 99                     return FileVisitResult.CONTINUE;
100                 }
101             }
102 
103             @Override
104             public FileVisitResult visitFile(final Path file,
105                     final BasicFileAttributes attrs) throws IOException {
106                 if (!excludes.contains(file.toFile().getName())) {
107                     Files.copy(file, dest.resolve(src.relativize(file)));
108                 }
109                 return FileVisitResult.CONTINUE;
110             }
111         });
112     }
113 
114     public static void copyFile(File sourceFile, File destFile)
115             throws IOException {
116         Files.createDirectories(destFile.getParentFile().toPath());
117 
118         Files.copy(sourceFile.toPath(), destFile.toPath(),
119                    StandardCopyOption.REPLACE_EXISTING,
120                    StandardCopyOption.COPY_ATTRIBUTES);
121     }
122 
123     // run &quot;launcher paramfile&quot; in the directory where paramfile is kept
124     public static void run(String launcher, File paramFile)
125             throws IOException {
126         if (paramFile != null &amp;&amp; paramFile.exists()) {
127             ProcessBuilder pb =
128                     new ProcessBuilder(launcher, paramFile.getName());
129             pb = pb.directory(paramFile.getParentFile());
130             exec(pb);
131         }
132     }
133 
134     public static void exec(ProcessBuilder pb)
135             throws IOException {
136         exec(pb, false, null, false);
137     }
138 
139     // Reading output from some processes (currently known &quot;hdiutil attach&quot; might hang even if process already
140     // exited. Only possible workaround found in &quot;hdiutil attach&quot; case is to wait for process to exit before
141     // reading output.
142     public static void exec(ProcessBuilder pb, boolean waitBeforeOutput)
143             throws IOException {
144         exec(pb, false, null, waitBeforeOutput);
145     }
146 
147     static void exec(ProcessBuilder pb, boolean testForPresenceOnly,
148             PrintStream consumer) throws IOException {
149         exec(pb, testForPresenceOnly, consumer, false);
150     }
151 
152     static void exec(ProcessBuilder pb, boolean testForPresenceOnly,
153             PrintStream consumer, boolean waitBeforeOutput) throws IOException {
154         List&lt;String&gt; output = new ArrayList&lt;&gt;();
155         Executor exec = Executor.of(pb).setWaitBeforeOutput(waitBeforeOutput).setOutputConsumer(lines -&gt; {
156             lines.forEach(output::add);
157             if (consumer != null) {
158                 output.forEach(consumer::println);
159             }
160         });
161 
162         if (testForPresenceOnly) {
163             exec.execute();
164         } else {
165             exec.executeExpectSuccess();
166         }
167     }
168 
169     public static int getProcessOutput(List&lt;String&gt; result, String... args)
170             throws IOException, InterruptedException {
171 
172         ProcessBuilder pb = new ProcessBuilder(args);
173 
174         final Process p = pb.start();
175 
176         List&lt;String&gt; list = new ArrayList&lt;&gt;();
177 
178         final BufferedReader in =
179                 new BufferedReader(new InputStreamReader(p.getInputStream()));
180         final BufferedReader err =
181                 new BufferedReader(new InputStreamReader(p.getErrorStream()));
182 
183         Thread t = new Thread(() -&gt; {
184             try {
185                 String line;
186                 while ((line = in.readLine()) != null) {
187                     list.add(line);
188                 }
189             } catch (IOException ioe) {
190                 Log.verbose(ioe);
191             }
192 
193             try {
194                 String line;
195                 while ((line = err.readLine()) != null) {
196                     Log.error(line);
197                 }
198             } catch (IOException ioe) {
199                   Log.verbose(ioe);
200             }
201         });
202         t.setDaemon(true);
203         t.start();
204 
205         int ret = p.waitFor();
206 
207         result.clear();
208         result.addAll(list);
209 
210         return ret;
211     }
212 
213     static void writableOutputDir(Path outdir) throws PackagerException {
214         File file = outdir.toFile();
215 
216         if (!file.isDirectory() &amp;&amp; !file.mkdirs()) {
217             throw new PackagerException(&quot;error.cannot-create-output-dir&quot;,
218                     file.getAbsolutePath());
219         }
220         if (!file.canWrite()) {
221             throw new PackagerException(&quot;error.cannot-write-to-output-dir&quot;,
222                     file.getAbsolutePath());
223         }
224     }
225 
226     public static Path replaceSuffix(Path path, String suffix) {
227         Path parent = path.getParent();
228         String filename = path.getFileName().toString().replaceAll(&quot;\\.[^.]*$&quot;, &quot;&quot;)
229                 + Optional.ofNullable(suffix).orElse(&quot;&quot;);
230         return parent != null ? parent.resolve(filename) : Path.of(filename);
231     }
232 
233     public static Path addSuffix(Path path, String suffix) {
234         Path parent = path.getParent();
235         String filename = path.getFileName().toString() + suffix;
236         return parent != null ? parent.resolve(filename) : Path.of(filename);
237     }
238 
239     public static String getSuffix(Path path) {
240         String filename = replaceSuffix(path.getFileName(), null).toString();
241         return path.getFileName().toString().substring(filename.length());
242     }
243 
244     @FunctionalInterface
245     public static interface XmlConsumer {
246         void accept(XMLStreamWriter xml) throws IOException, XMLStreamException;
247     }
248 
249     public static void createXml(Path dstFile, XmlConsumer xmlConsumer) throws
250             IOException {
251         XMLOutputFactory xmlFactory = XMLOutputFactory.newInstance();
252         try (Writer w = Files.newBufferedWriter(dstFile)) {
253             // Wrap with pretty print proxy
254             XMLStreamWriter xml = (XMLStreamWriter) Proxy.newProxyInstance(
255                     XMLStreamWriter.class.getClassLoader(), new Class&lt;?&gt;[]{
256                 XMLStreamWriter.class}, new PrettyPrintHandler(
257                     xmlFactory.createXMLStreamWriter(w)));
258 
259             xml.writeStartDocument();
260             xmlConsumer.accept(xml);
261             xml.writeEndDocument();
262             xml.flush();
263             xml.close();
264         } catch (XMLStreamException ex) {
265             throw new IOException(ex);
266         } catch (IOException ex) {
267             throw ex;
268         }
269     }
270 
271     private static class PrettyPrintHandler implements InvocationHandler {
272 
273         PrettyPrintHandler(XMLStreamWriter target) {
274             this.target = target;
275         }
276 
277         @Override
278         public Object invoke(Object proxy, Method method, Object[] args) throws
279                 Throwable {
280             switch (method.getName()) {
281                 case &quot;writeStartElement&quot;:
282                     // update state of parent node
283                     if (depth &gt; 0) {
284                         hasChildElement.put(depth - 1, true);
285                     }
286                     // reset state of current node
287                     hasChildElement.put(depth, false);
288                     // indent for current depth
289                     target.writeCharacters(EOL);
290                     target.writeCharacters(repeat(depth, INDENT));
291                     depth++;
292                     break;
293                 case &quot;writeEndElement&quot;:
294                     depth--;
295                     if (hasChildElement.get(depth) == true) {
296                         target.writeCharacters(EOL);
297                         target.writeCharacters(repeat(depth, INDENT));
298                     }
299                     break;
300                 case &quot;writeProcessingInstruction&quot;:
301                 case &quot;writeEmptyElement&quot;:
302                     // update state of parent node
303                     if (depth &gt; 0) {
304                         hasChildElement.put(depth - 1, true);
305                     }
306                     // indent for current depth
307                     target.writeCharacters(EOL);
308                     target.writeCharacters(repeat(depth, INDENT));
309                     break;
310                 default:
311                     break;
312             }
313             method.invoke(target, args);
314             return null;
315         }
316 
317         private static String repeat(int d, String s) {
318             StringBuilder sb = new StringBuilder();
319             while (d-- &gt; 0) {
320                 sb.append(s);
321             }
322             return sb.toString();
323         }
324 
325         private final XMLStreamWriter target;
326         private int depth = 0;
327         private final Map&lt;Integer, Boolean&gt; hasChildElement = new HashMap&lt;&gt;();
328         private static final String INDENT = &quot;  &quot;;
329         private static final String EOL = &quot;\n&quot;;
330     }
331 }
    </pre>
  </body>
</html>
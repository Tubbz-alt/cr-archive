<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/unix/native/libapplauncher/PosixPlatform.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;PosixPlatform.h&quot;
 27 
 28 #include &quot;PlatformString.h&quot;
 29 #include &quot;FilePath.h&quot;
 30 #include &quot;Helpers.h&quot;
 31 
 32 #include &lt;assert.h&gt;
 33 #include &lt;stdbool.h&gt;
 34 #include &lt;sys/types.h&gt;
 35 #include &lt;unistd.h&gt;
 36 #include &lt;sys/file.h&gt;
 37 #include &lt;sys/stat.h&gt;
 38 #include &lt;sys/wait.h&gt;
 39 #include &lt;errno.h&gt;
 40 #include &lt;limits.h&gt;
 41 #include &lt;pwd.h&gt;
 42 #include &lt;iostream&gt;
 43 #include &lt;algorithm&gt;
 44 #include &lt;dlfcn.h&gt;
 45 #include &lt;signal.h&gt;
 46 
 47 using namespace std;
 48 
 49 PosixPlatform::PosixPlatform(void) {
 50 }
 51 
 52 PosixPlatform::~PosixPlatform(void) {
 53 }
 54 
 55 TString PosixPlatform::GetTempDirectory() {
 56     struct passwd* pw = getpwuid(getuid());
 57     TString homedir(pw-&gt;pw_dir);
 58     homedir += getTmpDirString();
 59     if (!FilePath::DirectoryExists(homedir)) {
 60         if (!FilePath::CreateDirectory(homedir, false)) {
 61             homedir.clear();
 62         }
 63     }
 64 
 65     return homedir;
 66 }
 67 
 68 TString PosixPlatform::fixName(const TString&amp; name) {
 69     TString fixedName(name);
 70     const TString chars(&quot;?:*&lt;&gt;/\\&quot;);
 71     for (TString::const_iterator it = chars.begin(); it != chars.end(); it++) {
 72         fixedName.erase(std::remove(fixedName.begin(),
 73                 fixedName.end(), *it), fixedName.end());
 74     }
 75     return fixedName;
 76 }
 77 
 78 MessageResponse PosixPlatform::ShowResponseMessage(TString title,
 79         TString description) {
 80     MessageResponse result = mrCancel;
 81 
 82     printf(&quot;%s %s (Y/N)\n&quot;, PlatformString(title).toPlatformString(),
 83             PlatformString(description).toPlatformString());
 84     fflush(stdout);
 85 
 86     std::string input;
 87     std::cin &gt;&gt; input;
 88 
 89     if (input == &quot;Y&quot;) {
 90         result = mrOK;
 91     }
 92 
 93     return result;
 94 }
 95 
 96 Module PosixPlatform::LoadLibrary(TString FileName) {
 97     return dlopen(StringToFileSystemString(FileName), RTLD_LAZY);
 98 }
 99 
100 void PosixPlatform::FreeLibrary(Module AModule) {
101     dlclose(AModule);
102 }
103 
104 Procedure PosixPlatform::GetProcAddress(Module AModule,
105         std::string MethodName) {
106     return dlsym(AModule, PlatformString(MethodName));
107 }
108 
109 Process* PosixPlatform::CreateProcess() {
110     return new PosixProcess();
111 }
112 
113 void PosixPlatform::addPlatformDependencies(JavaLibrary *pJavaLibrary) {
114 }
115 
116 void Platform::CopyString(char *Destination,
117         size_t NumberOfElements, const char *Source) {
118     strncpy(Destination, Source, NumberOfElements);
119 
120     if (NumberOfElements &gt; 0) {
121         Destination[NumberOfElements - 1] = &#39;\0&#39;;
122     }
123 }
124 
125 void Platform::CopyString(wchar_t *Destination,
126         size_t NumberOfElements, const wchar_t *Source) {
127     wcsncpy(Destination, Source, NumberOfElements);
128 
129     if (NumberOfElements &gt; 0) {
130         Destination[NumberOfElements - 1] = &#39;\0&#39;;
131     }
132 }
133 
134 // Owner must free the return value.
135 
136 MultibyteString Platform::WideStringToMultibyteString(
137         const wchar_t* value) {
138     MultibyteString result;
139     size_t count = 0;
140 
141     if (value == NULL) {
142         return result;
143     }
144 
145     count = wcstombs(NULL, value, 0);
146     if (count &gt; 0) {
147         result.data = new char[count + 1];
148         result.data[count] = &#39;\0&#39;;
149         result.length = count;
150         wcstombs(result.data, value, count);
151     }
152 
153     return result;
154 }
155 
156 // Owner must free the return value.
157 
158 WideString Platform::MultibyteStringToWideString(const char* value) {
159     WideString result;
160     size_t count = 0;
161 
162     if (value == NULL) {
163         return result;
164     }
165 
166     count = mbstowcs(NULL, value, 0);
167     if (count &gt; 0) {
168         result.data = new wchar_t[count + 1];
169         result.data[count] = &#39;\0&#39;;
170         result.length = count;
171         mbstowcs(result.data, value, count);
172     }
173 
174     return result;
175 }
176 
177 void PosixPlatform::InitStreamLocale(wios *stream) {
178     // Nothing to do for POSIX platforms.
179 }
180 
181 PosixProcess::PosixProcess() : Process() {
182     FChildPID = 0;
183     FRunning = false;
184     FOutputHandle = 0;
185     FInputHandle = 0;
186 }
187 
188 PosixProcess::~PosixProcess() {
189     Terminate();
190 }
191 
192 bool PosixProcess::ReadOutput() {
193     bool result = false;
194 
195     if (FOutputHandle != 0 &amp;&amp; IsRunning() == true) {
196         char buffer[4096] = {0};
197 
198         ssize_t count = read(FOutputHandle, buffer, sizeof (buffer));
199 
200         if (count == -1) {
201             if (errno == EINTR) {
202                 // continue;
203             } else {
204                 perror(&quot;read&quot;);
205                 exit(1);
206             }
207         } else if (count == 0) {
208             // break;
209         } else {
210             std::list&lt;TString&gt; output = Helpers::StringToArray(buffer);
211             FOutput.splice(FOutput.end(), output, output.begin(), output.end());
212             result = true;
213         }
214     }
215 
216     return false;
217 }
218 
219 bool PosixProcess::IsRunning() {
220     bool result = false;
221 
222     if (kill(FChildPID, 0) == 0) {
223         result = true;
224     }
225 
226     return result;
227 }
228 
229 bool PosixProcess::Terminate() {
230     bool result = false;
231 
232     if (IsRunning() == true &amp;&amp; FRunning == true) {
233         FRunning = false;
234         Cleanup();
235         int status = kill(FChildPID, SIGTERM);
236 
237         if (status == 0) {
238             result = true;
239         } else {
240 #ifdef DEBUG
241             if (errno == EINVAL) {
242                 printf(&quot;Kill error: The value of the sig argument is an invalid or unsupported signal number.&quot;);
243             } else if (errno == EPERM) {
244                 printf(&quot;Kill error: The process does not have permission to send the signal to any receiving process.&quot;);
245             } else if (errno == ESRCH) {
246                 printf(&quot;Kill error: No process or process group can be found corresponding to that specified by pid.&quot;);
247             }
248 #endif // DEBUG
249             if (IsRunning() == true) {
250                 status = kill(FChildPID, SIGKILL);
251 
252                 if (status == 0) {
253                     result = true;
254                 }
255             }
256         }
257     }
258 
259     return result;
260 }
261 
262 bool PosixProcess::Wait() {
263     bool result = false;
264 
265     int status = 0;
266     pid_t wpid = 0;
267 
268     wpid = wait(&amp;status);
269     if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
270         if (errno != EINTR) {
271             status = -1;
272         }
273     }
274 
275 #ifdef DEBUG
276     if (WIFEXITED(status)) {
277         printf(&quot;child exited, status=%d\n&quot;, WEXITSTATUS(status));
278     } else if (WIFSIGNALED(status)) {
279         printf(&quot;child killed (signal %d)\n&quot;, WTERMSIG(status));
280     } else if (WIFSTOPPED(status)) {
281         printf(&quot;child stopped (signal %d)\n&quot;, WSTOPSIG(status));
282 #ifdef WIFCONTINUED // Not all implementations support this
283     } else if (WIFCONTINUED(status)) {
284         printf(&quot;child continued\n&quot;);
285 #endif // WIFCONTINUED
286     } else { // Non-standard case -- may never happen
287         printf(&quot;Unexpected status (0x%x)\n&quot;, status);
288     }
289 #endif // DEBUG
290 
291     if (wpid != -1) {
292         result = true;
293     }
294 
295     return result;
296 }
297 
298 TProcessID PosixProcess::GetProcessID() {
299     return FChildPID;
300 }
301 
302 void PosixProcess::SetInput(TString Value) {
303     if (FInputHandle != 0) {
304         if (write(FInputHandle, Value.data(), Value.size()) &lt; 0) {
305             throw Exception(_T(&quot;Internal Error - write failed&quot;));
306         }
307     }
308 }
309 
310 std::list&lt;TString&gt; PosixProcess::GetOutput() {
311     ReadOutput();
312     return Process::GetOutput();
313 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.crypto.cryptoki/share/native/libj2pkcs11/pkcs11.h</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="p11_util.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="pkcs11f.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.cryptoki/share/native/libj2pkcs11/pkcs11.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /* pkcs11.h include file for PKCS #11. */</span>
<span class="line-modified">  2 /* $Revision: 1.4 $ */</span>
<span class="line-modified">  3 </span>
<span class="line-modified">  4 /* License to copy and use this software is granted provided that it is</span>
<span class="line-modified">  5  * identified as &quot;RSA Security Inc. PKCS #11 Cryptographic Token Interface</span>
<span class="line-modified">  6  * (Cryptoki)&quot; in all material mentioning or referencing this software.</span>
<span class="line-removed">  7 </span>
<span class="line-removed">  8  * License is also granted to make and use derivative works provided that</span>
<span class="line-removed">  9  * such works are identified as &quot;derived from the RSA Security Inc. PKCS #11</span>
<span class="line-removed"> 10  * Cryptographic Token Interface (Cryptoki)&quot; in all material mentioning or</span>
<span class="line-removed"> 11  * referencing the derived work.</span>
 12 
<span class="line-modified"> 13  * RSA Security Inc. makes no representations concerning either the</span>
<span class="line-modified"> 14  * merchantability of this software or the suitability of this software for</span>
<span class="line-removed"> 15  * any particular purpose. It is provided &quot;as is&quot; without express or implied</span>
<span class="line-removed"> 16  * warranty of any kind.</span>
 17  */
 18 
 19 #ifndef _PKCS11_H_
 20 #define _PKCS11_H_ 1
 21 
 22 #ifdef __cplusplus
 23 extern &quot;C&quot; {
 24 #endif
 25 
 26 /* Before including this file (pkcs11.h) (or pkcs11t.h by
<span class="line-modified"> 27  * itself), 6 platform-specific macros must be defined.  These</span>
 28  * macros are described below, and typical definitions for them
 29  * are also given.  Be advised that these definitions can depend
 30  * on both the platform and the compiler used (and possibly also
 31  * on whether a Cryptoki library is linked statically or
 32  * dynamically).
 33  *
<span class="line-modified"> 34  * In addition to defining these 6 macros, the packing convention</span>
 35  * for Cryptoki structures should be set.  The Cryptoki
 36  * convention on packing is that structures should be 1-byte
 37  * aligned.
 38  *
 39  * If you&#39;re using Microsoft Developer Studio 5.0 to produce
 40  * Win32 stuff, this might be done by using the following
 41  * preprocessor directive before including pkcs11.h or pkcs11t.h:
 42  *
 43  * #pragma pack(push, cryptoki, 1)
 44  *
 45  * and using the following preprocessor directive after including
 46  * pkcs11.h or pkcs11t.h:
 47  *
 48  * #pragma pack(pop, cryptoki)
 49  *
 50  * If you&#39;re using an earlier version of Microsoft Developer
 51  * Studio to produce Win16 stuff, this might be done by using
 52  * the following preprocessor directive before including
 53  * pkcs11.h or pkcs11t.h:
 54  *
</pre>
<hr />
<pre>
 64  * 1. CK_PTR: The indirection string for making a pointer to an
 65  * object.  It can be used like this:
 66  *
 67  * typedef CK_BYTE CK_PTR CK_BYTE_PTR;
 68  *
 69  * If you&#39;re using Microsoft Developer Studio 5.0 to produce
 70  * Win32 stuff, it might be defined by:
 71  *
 72  * #define CK_PTR *
 73  *
 74  * If you&#39;re using an earlier version of Microsoft Developer
 75  * Studio to produce Win16 stuff, it might be defined by:
 76  *
 77  * #define CK_PTR far *
 78  *
 79  * In a typical UNIX environment, it might be defined by:
 80  *
 81  * #define CK_PTR *
 82  *
 83  *
<span class="line-modified"> 84  * 2. CK_DEFINE_FUNCTION(returnType, name): A macro which makes</span>
<span class="line-removed"> 85  * an exportable Cryptoki library function definition out of a</span>
<span class="line-removed"> 86  * return type and a function name.  It should be used in the</span>
<span class="line-removed"> 87  * following fashion to define the exposed Cryptoki functions in</span>
<span class="line-removed"> 88  * a Cryptoki library:</span>
<span class="line-removed"> 89  *</span>
<span class="line-removed"> 90  * CK_DEFINE_FUNCTION(CK_RV, C_Initialize)(</span>
<span class="line-removed"> 91  *   CK_VOID_PTR pReserved</span>
<span class="line-removed"> 92  * )</span>
<span class="line-removed"> 93  * {</span>
<span class="line-removed"> 94  *   ...</span>
<span class="line-removed"> 95  * }</span>
<span class="line-removed"> 96  *</span>
<span class="line-removed"> 97  * If you&#39;re using Microsoft Developer Studio 5.0 to define a</span>
<span class="line-removed"> 98  * function in a Win32 Cryptoki .dll, it might be defined by:</span>
<span class="line-removed"> 99  *</span>
<span class="line-removed">100  * #define CK_DEFINE_FUNCTION(returnType, name) \</span>
<span class="line-removed">101  *   returnType __declspec(dllexport) name</span>
<span class="line-removed">102  *</span>
<span class="line-removed">103  * If you&#39;re using an earlier version of Microsoft Developer</span>
<span class="line-removed">104  * Studio to define a function in a Win16 Cryptoki .dll, it</span>
<span class="line-removed">105  * might be defined by:</span>
<span class="line-removed">106  *</span>
<span class="line-removed">107  * #define CK_DEFINE_FUNCTION(returnType, name) \</span>
<span class="line-removed">108  *   returnType __export _far _pascal name</span>
<span class="line-removed">109  *</span>
<span class="line-removed">110  * In a UNIX environment, it might be defined by:</span>
<span class="line-removed">111  *</span>
<span class="line-removed">112  * #define CK_DEFINE_FUNCTION(returnType, name) \</span>
<span class="line-removed">113  *   returnType name</span>
<span class="line-removed">114  *</span>
<span class="line-removed">115  *</span>
<span class="line-removed">116  * 3. CK_DECLARE_FUNCTION(returnType, name): A macro which makes</span>
117  * an importable Cryptoki library function declaration out of a
118  * return type and a function name.  It should be used in the
119  * following fashion:
120  *
121  * extern CK_DECLARE_FUNCTION(CK_RV, C_Initialize)(
122  *   CK_VOID_PTR pReserved
123  * );
124  *
125  * If you&#39;re using Microsoft Developer Studio 5.0 to declare a
126  * function in a Win32 Cryptoki .dll, it might be defined by:
127  *
128  * #define CK_DECLARE_FUNCTION(returnType, name) \
129  *   returnType __declspec(dllimport) name
130  *
131  * If you&#39;re using an earlier version of Microsoft Developer
132  * Studio to declare a function in a Win16 Cryptoki .dll, it
133  * might be defined by:
134  *
135  * #define CK_DECLARE_FUNCTION(returnType, name) \
136  *   returnType __export _far _pascal name
137  *
138  * In a UNIX environment, it might be defined by:
139  *
140  * #define CK_DECLARE_FUNCTION(returnType, name) \
141  *   returnType name
142  *
143  *
<span class="line-modified">144  * 4. CK_DECLARE_FUNCTION_POINTER(returnType, name): A macro</span>
145  * which makes a Cryptoki API function pointer declaration or
146  * function pointer type declaration out of a return type and a
147  * function name.  It should be used in the following fashion:
148  *
149  * // Define funcPtr to be a pointer to a Cryptoki API function
150  * // taking arguments args and returning CK_RV.
151  * CK_DECLARE_FUNCTION_POINTER(CK_RV, funcPtr)(args);
152  *
153  * or
154  *
155  * // Define funcPtrType to be the type of a pointer to a
156  * // Cryptoki API function taking arguments args and returning
157  * // CK_RV, and then define funcPtr to be a variable of type
158  * // funcPtrType.
159  * typedef CK_DECLARE_FUNCTION_POINTER(CK_RV, funcPtrType)(args);
160  * funcPtrType funcPtr;
161  *
162  * If you&#39;re using Microsoft Developer Studio 5.0 to access
163  * functions in a Win32 Cryptoki .dll, in might be defined by:
164  *
165  * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
166  *   returnType __declspec(dllimport) (* name)
167  *
168  * If you&#39;re using an earlier version of Microsoft Developer
169  * Studio to access functions in a Win16 Cryptoki .dll, it might
170  * be defined by:
171  *
172  * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
173  *   returnType __export _far _pascal (* name)
174  *
175  * In a UNIX environment, it might be defined by:
176  *
177  * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
178  *   returnType (* name)
179  *
180  *
<span class="line-modified">181  * 5. CK_CALLBACK_FUNCTION(returnType, name): A macro which makes</span>
182  * a function pointer type for an application callback out of
183  * a return type for the callback and a name for the callback.
184  * It should be used in the following fashion:
185  *
186  * CK_CALLBACK_FUNCTION(CK_RV, myCallback)(args);
187  *
188  * to declare a function pointer, myCallback, to a callback
189  * which takes arguments args and returns a CK_RV.  It can also
190  * be used like this:
191  *
192  * typedef CK_CALLBACK_FUNCTION(CK_RV, myCallbackType)(args);
193  * myCallbackType myCallback;
194  *
195  * If you&#39;re using Microsoft Developer Studio 5.0 to do Win32
196  * Cryptoki development, it might be defined by:
197  *
198  * #define CK_CALLBACK_FUNCTION(returnType, name) \
199  *   returnType (* name)
200  *
201  * If you&#39;re using an earlier version of Microsoft Developer
202  * Studio to do Win16 development, it might be defined by:
203  *
204  * #define CK_CALLBACK_FUNCTION(returnType, name) \
205  *   returnType _far _pascal (* name)
206  *
207  * In a UNIX environment, it might be defined by:
208  *
209  * #define CK_CALLBACK_FUNCTION(returnType, name) \
210  *   returnType (* name)
211  *
212  *
<span class="line-modified">213  * 6. NULL_PTR: This macro is the value of a NULL pointer.</span>
214  *
215  * In any ANSI/ISO C environment (and in many others as well),
216  * this should best be defined by
217  *
218  * #ifndef NULL_PTR
219  * #define NULL_PTR 0
220  * #endif
221  */
222 
223 
224 /* All the various Cryptoki types and #define&#39;d values are in the
<span class="line-modified">225  * file pkcs11t.h. */</span>

226 #include &quot;pkcs11t.h&quot;
227 
228 #define __PASTE(x,y)      x##y
229 
230 
231 /* ==============================================================
232  * Define the &quot;extern&quot; form of all the entry points.
233  * ==============================================================
234  */
235 
236 #define CK_NEED_ARG_LIST  1
237 #define CK_PKCS11_FUNCTION_INFO(name) \
238   extern CK_DECLARE_FUNCTION(CK_RV, name)
239 
240 /* pkcs11f.h has all the information about the Cryptoki
<span class="line-modified">241  * function prototypes. */</span>

242 #include &quot;pkcs11f.h&quot;
243 
244 #undef CK_NEED_ARG_LIST
245 #undef CK_PKCS11_FUNCTION_INFO
246 
247 
248 /* ==============================================================
249  * Define the typedef form of all the entry points.  That is, for
250  * each Cryptoki function C_XXX, define a type CK_C_XXX which is
251  * a pointer to that kind of function.
252  * ==============================================================
253  */
254 
255 #define CK_NEED_ARG_LIST  1
256 #define CK_PKCS11_FUNCTION_INFO(name) \
257   typedef CK_DECLARE_FUNCTION_POINTER(CK_RV, __PASTE(CK_,name))
258 
259 /* pkcs11f.h has all the information about the Cryptoki
<span class="line-modified">260  * function prototypes. */</span>

261 #include &quot;pkcs11f.h&quot;
262 
263 #undef CK_NEED_ARG_LIST
264 #undef CK_PKCS11_FUNCTION_INFO
265 
266 
267 /* ==============================================================
268  * Define structed vector of entry points.  A CK_FUNCTION_LIST
269  * contains a CK_VERSION indicating a library&#39;s Cryptoki version
270  * and then a whole slew of function pointers to the routines in
271  * the library.  This type was declared, but not defined, in
272  * pkcs11t.h.
273  * ==============================================================
274  */
275 
276 #define CK_PKCS11_FUNCTION_INFO(name) \
277   __PASTE(CK_,name) name;
278 
279 struct CK_FUNCTION_LIST {
280 
281   CK_VERSION    version;  /* Cryptoki version */
282 
283 /* Pile all the function pointers into the CK_FUNCTION_LIST. */
284 /* pkcs11f.h has all the information about the Cryptoki
<span class="line-modified">285  * function prototypes. */</span>

286 #include &quot;pkcs11f.h&quot;
287 
288 };
289 
290 #undef CK_PKCS11_FUNCTION_INFO
291 
292 
293 #undef __PASTE
294 
295 #ifdef __cplusplus
296 }
297 #endif
298 
<span class="line-modified">299 #endif</span>

</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /* Copyright (c) OASIS Open 2016. All Rights Reserved./</span>
<span class="line-modified">  2  * /Distributed under the terms of the OASIS IPR Policy,</span>
<span class="line-modified">  3  * [http://www.oasis-open.org/policies-guidelines/ipr], AS-IS, WITHOUT ANY</span>
<span class="line-modified">  4  * IMPLIED OR EXPRESS WARRANTY; there is no warranty of MERCHANTABILITY, FITNESS FOR A</span>
<span class="line-modified">  5  * PARTICULAR PURPOSE or NONINFRINGEMENT of the rights of others.</span>
<span class="line-modified">  6  */</span>





  7 
<span class="line-modified">  8 /* Latest version of the specification:</span>
<span class="line-modified">  9  * http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/pkcs11-base-v2.40.html</span>


 10  */
 11 
 12 #ifndef _PKCS11_H_
 13 #define _PKCS11_H_ 1
 14 
 15 #ifdef __cplusplus
 16 extern &quot;C&quot; {
 17 #endif
 18 
 19 /* Before including this file (pkcs11.h) (or pkcs11t.h by
<span class="line-modified"> 20  * itself), 5 platform-specific macros must be defined.  These</span>
 21  * macros are described below, and typical definitions for them
 22  * are also given.  Be advised that these definitions can depend
 23  * on both the platform and the compiler used (and possibly also
 24  * on whether a Cryptoki library is linked statically or
 25  * dynamically).
 26  *
<span class="line-modified"> 27  * In addition to defining these 5 macros, the packing convention</span>
 28  * for Cryptoki structures should be set.  The Cryptoki
 29  * convention on packing is that structures should be 1-byte
 30  * aligned.
 31  *
 32  * If you&#39;re using Microsoft Developer Studio 5.0 to produce
 33  * Win32 stuff, this might be done by using the following
 34  * preprocessor directive before including pkcs11.h or pkcs11t.h:
 35  *
 36  * #pragma pack(push, cryptoki, 1)
 37  *
 38  * and using the following preprocessor directive after including
 39  * pkcs11.h or pkcs11t.h:
 40  *
 41  * #pragma pack(pop, cryptoki)
 42  *
 43  * If you&#39;re using an earlier version of Microsoft Developer
 44  * Studio to produce Win16 stuff, this might be done by using
 45  * the following preprocessor directive before including
 46  * pkcs11.h or pkcs11t.h:
 47  *
</pre>
<hr />
<pre>
 57  * 1. CK_PTR: The indirection string for making a pointer to an
 58  * object.  It can be used like this:
 59  *
 60  * typedef CK_BYTE CK_PTR CK_BYTE_PTR;
 61  *
 62  * If you&#39;re using Microsoft Developer Studio 5.0 to produce
 63  * Win32 stuff, it might be defined by:
 64  *
 65  * #define CK_PTR *
 66  *
 67  * If you&#39;re using an earlier version of Microsoft Developer
 68  * Studio to produce Win16 stuff, it might be defined by:
 69  *
 70  * #define CK_PTR far *
 71  *
 72  * In a typical UNIX environment, it might be defined by:
 73  *
 74  * #define CK_PTR *
 75  *
 76  *
<span class="line-modified"> 77  * 2. CK_DECLARE_FUNCTION(returnType, name): A macro which makes</span>
































 78  * an importable Cryptoki library function declaration out of a
 79  * return type and a function name.  It should be used in the
 80  * following fashion:
 81  *
 82  * extern CK_DECLARE_FUNCTION(CK_RV, C_Initialize)(
 83  *   CK_VOID_PTR pReserved
 84  * );
 85  *
 86  * If you&#39;re using Microsoft Developer Studio 5.0 to declare a
 87  * function in a Win32 Cryptoki .dll, it might be defined by:
 88  *
 89  * #define CK_DECLARE_FUNCTION(returnType, name) \
 90  *   returnType __declspec(dllimport) name
 91  *
 92  * If you&#39;re using an earlier version of Microsoft Developer
 93  * Studio to declare a function in a Win16 Cryptoki .dll, it
 94  * might be defined by:
 95  *
 96  * #define CK_DECLARE_FUNCTION(returnType, name) \
 97  *   returnType __export _far _pascal name
 98  *
 99  * In a UNIX environment, it might be defined by:
100  *
101  * #define CK_DECLARE_FUNCTION(returnType, name) \
102  *   returnType name
103  *
104  *
<span class="line-modified">105  * 3. CK_DECLARE_FUNCTION_POINTER(returnType, name): A macro</span>
106  * which makes a Cryptoki API function pointer declaration or
107  * function pointer type declaration out of a return type and a
108  * function name.  It should be used in the following fashion:
109  *
110  * // Define funcPtr to be a pointer to a Cryptoki API function
111  * // taking arguments args and returning CK_RV.
112  * CK_DECLARE_FUNCTION_POINTER(CK_RV, funcPtr)(args);
113  *
114  * or
115  *
116  * // Define funcPtrType to be the type of a pointer to a
117  * // Cryptoki API function taking arguments args and returning
118  * // CK_RV, and then define funcPtr to be a variable of type
119  * // funcPtrType.
120  * typedef CK_DECLARE_FUNCTION_POINTER(CK_RV, funcPtrType)(args);
121  * funcPtrType funcPtr;
122  *
123  * If you&#39;re using Microsoft Developer Studio 5.0 to access
124  * functions in a Win32 Cryptoki .dll, in might be defined by:
125  *
126  * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
127  *   returnType __declspec(dllimport) (* name)
128  *
129  * If you&#39;re using an earlier version of Microsoft Developer
130  * Studio to access functions in a Win16 Cryptoki .dll, it might
131  * be defined by:
132  *
133  * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
134  *   returnType __export _far _pascal (* name)
135  *
136  * In a UNIX environment, it might be defined by:
137  *
138  * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
139  *   returnType (* name)
140  *
141  *
<span class="line-modified">142  * 4. CK_CALLBACK_FUNCTION(returnType, name): A macro which makes</span>
143  * a function pointer type for an application callback out of
144  * a return type for the callback and a name for the callback.
145  * It should be used in the following fashion:
146  *
147  * CK_CALLBACK_FUNCTION(CK_RV, myCallback)(args);
148  *
149  * to declare a function pointer, myCallback, to a callback
150  * which takes arguments args and returns a CK_RV.  It can also
151  * be used like this:
152  *
153  * typedef CK_CALLBACK_FUNCTION(CK_RV, myCallbackType)(args);
154  * myCallbackType myCallback;
155  *
156  * If you&#39;re using Microsoft Developer Studio 5.0 to do Win32
157  * Cryptoki development, it might be defined by:
158  *
159  * #define CK_CALLBACK_FUNCTION(returnType, name) \
160  *   returnType (* name)
161  *
162  * If you&#39;re using an earlier version of Microsoft Developer
163  * Studio to do Win16 development, it might be defined by:
164  *
165  * #define CK_CALLBACK_FUNCTION(returnType, name) \
166  *   returnType _far _pascal (* name)
167  *
168  * In a UNIX environment, it might be defined by:
169  *
170  * #define CK_CALLBACK_FUNCTION(returnType, name) \
171  *   returnType (* name)
172  *
173  *
<span class="line-modified">174  * 5. NULL_PTR: This macro is the value of a NULL pointer.</span>
175  *
176  * In any ANSI/ISO C environment (and in many others as well),
177  * this should best be defined by
178  *
179  * #ifndef NULL_PTR
180  * #define NULL_PTR 0
181  * #endif
182  */
183 
184 
185 /* All the various Cryptoki types and #define&#39;d values are in the
<span class="line-modified">186  * file pkcs11t.h.</span>
<span class="line-added">187  */</span>
188 #include &quot;pkcs11t.h&quot;
189 
190 #define __PASTE(x,y)      x##y
191 
192 
193 /* ==============================================================
194  * Define the &quot;extern&quot; form of all the entry points.
195  * ==============================================================
196  */
197 
198 #define CK_NEED_ARG_LIST  1
199 #define CK_PKCS11_FUNCTION_INFO(name) \
200   extern CK_DECLARE_FUNCTION(CK_RV, name)
201 
202 /* pkcs11f.h has all the information about the Cryptoki
<span class="line-modified">203  * function prototypes.</span>
<span class="line-added">204  */</span>
205 #include &quot;pkcs11f.h&quot;
206 
207 #undef CK_NEED_ARG_LIST
208 #undef CK_PKCS11_FUNCTION_INFO
209 
210 
211 /* ==============================================================
212  * Define the typedef form of all the entry points.  That is, for
213  * each Cryptoki function C_XXX, define a type CK_C_XXX which is
214  * a pointer to that kind of function.
215  * ==============================================================
216  */
217 
218 #define CK_NEED_ARG_LIST  1
219 #define CK_PKCS11_FUNCTION_INFO(name) \
220   typedef CK_DECLARE_FUNCTION_POINTER(CK_RV, __PASTE(CK_,name))
221 
222 /* pkcs11f.h has all the information about the Cryptoki
<span class="line-modified">223  * function prototypes.</span>
<span class="line-added">224  */</span>
225 #include &quot;pkcs11f.h&quot;
226 
227 #undef CK_NEED_ARG_LIST
228 #undef CK_PKCS11_FUNCTION_INFO
229 
230 
231 /* ==============================================================
232  * Define structed vector of entry points.  A CK_FUNCTION_LIST
233  * contains a CK_VERSION indicating a library&#39;s Cryptoki version
234  * and then a whole slew of function pointers to the routines in
235  * the library.  This type was declared, but not defined, in
236  * pkcs11t.h.
237  * ==============================================================
238  */
239 
240 #define CK_PKCS11_FUNCTION_INFO(name) \
241   __PASTE(CK_,name) name;
242 
243 struct CK_FUNCTION_LIST {
244 
245   CK_VERSION    version;  /* Cryptoki version */
246 
247 /* Pile all the function pointers into the CK_FUNCTION_LIST. */
248 /* pkcs11f.h has all the information about the Cryptoki
<span class="line-modified">249  * function prototypes.</span>
<span class="line-added">250  */</span>
251 #include &quot;pkcs11f.h&quot;
252 
253 };
254 
255 #undef CK_PKCS11_FUNCTION_INFO
256 
257 
258 #undef __PASTE
259 
260 #ifdef __cplusplus
261 }
262 #endif
263 
<span class="line-modified">264 #endif /* _PKCS11_H_ */</span>
<span class="line-added">265 </span>
</pre>
</td>
</tr>
</table>
<center><a href="p11_util.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="pkcs11f.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
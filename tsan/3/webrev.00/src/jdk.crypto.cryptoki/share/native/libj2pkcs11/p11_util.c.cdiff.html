<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_util.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="p11_sign.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="pkcs11.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_util.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   */
  
  /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
   *
   * Redistribution and use in  source and binary forms, with or without
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   */
  
  /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
   *
   * Redistribution and use in  source and binary forms, with or without
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,20 ***</span>
  /* This function frees the specified CK_ATTRIBUTE array.
   *
   * @param attrPtr pointer to the to-be-freed CK_ATTRIBUTE array.
   * @param len the length of the array
   */
<span class="line-modified">! void freeCKAttributeArray(CK_ATTRIBUTE_PTR attrPtr, int len)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     int i;</span>
  
<span class="line-modified">!     for (i=0; i&lt;len; i++) {</span>
<span class="line-modified">!         if (attrPtr[i].pValue != NULL_PTR) {</span>
<span class="line-modified">!             free(attrPtr[i].pValue);</span>
          }
      }
<span class="line-modified">!     free(attrPtr);</span>
  }
  
  /*
   * the following functions convert Java arrays to PKCS#11 array pointers and
   * their array length and vice versa
<span class="line-new-header">--- 275,177 ---</span>
  /* This function frees the specified CK_ATTRIBUTE array.
   *
   * @param attrPtr pointer to the to-be-freed CK_ATTRIBUTE array.
   * @param len the length of the array
   */
<span class="line-modified">! void freeCKAttributeArray(CK_ATTRIBUTE_PTR attrPtr, int len) {</span>
<span class="line-modified">!     if (attrPtr != NULL) {</span>
<span class="line-modified">!         int i;</span>
<span class="line-added">+         for (i=0; i&lt;len; i++) {</span>
<span class="line-added">+             if (attrPtr[i].pValue != NULL_PTR) {</span>
<span class="line-added">+                 free(attrPtr[i].pValue);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         free(attrPtr);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* This function frees the specified CK_MECHANISM_PTR pointer and its</span>
<span class="line-added">+  * pParameter including mechanism-specific memory allocations.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * @param mechPtr pointer to the to-be-freed CK_MECHANISM structure.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ void freeCKMechanismPtr(CK_MECHANISM_PTR mechPtr) {</span>
<span class="line-added">+      void *tmp;</span>
<span class="line-added">+      CK_SSL3_MASTER_KEY_DERIVE_PARAMS *sslMkdTmp;</span>
<span class="line-added">+      CK_SSL3_KEY_MAT_PARAMS* sslKmTmp;</span>
<span class="line-added">+      CK_TLS12_MASTER_KEY_DERIVE_PARAMS *tlsMkdTmp;</span>
<span class="line-added">+      CK_TLS12_KEY_MAT_PARAMS* tlsKmTmp;</span>
<span class="line-added">+ </span>
<span class="line-added">+      if (mechPtr != NULL) {</span>
<span class="line-added">+          TRACE2(&quot;DEBUG freeCKMechanismPtr: free pMech %p (mech 0x%lX)\n&quot;,</span>
<span class="line-added">+                  mechPtr,  mechPtr-&gt;mechanism);</span>
<span class="line-added">+          if (mechPtr-&gt;pParameter != NULL) {</span>
<span class="line-added">+              tmp = mechPtr-&gt;pParameter;</span>
<span class="line-added">+              switch (mechPtr-&gt;mechanism) {</span>
<span class="line-added">+                  case CKM_AES_GCM:</span>
<span class="line-added">+                      if (mechPtr-&gt;ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {</span>
<span class="line-added">+                          TRACE0(&quot;[ GCM_PARAMS w/o ulIvBits ]\n&quot;);</span>
<span class="line-added">+                          free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)-&gt;pIv);</span>
<span class="line-added">+                          free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)-&gt;pAAD);</span>
<span class="line-added">+                      } else if (mechPtr-&gt;ulParameterLen == sizeof(CK_GCM_PARAMS)) {</span>
<span class="line-added">+                          TRACE0(&quot;[ GCM_PARAMS ]\n&quot;);</span>
<span class="line-added">+                          free(((CK_GCM_PARAMS*)tmp)-&gt;pIv);</span>
<span class="line-added">+                          free(((CK_GCM_PARAMS*)tmp)-&gt;pAAD);</span>
<span class="line-added">+                      }</span>
<span class="line-added">+                      break;</span>
<span class="line-added">+                  case CKM_AES_CCM:</span>
<span class="line-added">+                      TRACE0(&quot;[ CK_CCM_PARAMS ]\n&quot;);</span>
<span class="line-added">+                      free(((CK_CCM_PARAMS*)tmp)-&gt;pNonce);</span>
<span class="line-added">+                      free(((CK_CCM_PARAMS*)tmp)-&gt;pAAD);</span>
<span class="line-added">+                      break;</span>
<span class="line-added">+                  case CKM_TLS_PRF:</span>
<span class="line-added">+                  case CKM_NSS_TLS_PRF_GENERAL:</span>
<span class="line-added">+                      TRACE0(&quot;[ CK_TLS_PRF_PARAMS ]\n&quot;);</span>
<span class="line-added">+                      free(((CK_TLS_PRF_PARAMS*)tmp)-&gt;pSeed);</span>
<span class="line-added">+                      free(((CK_TLS_PRF_PARAMS*)tmp)-&gt;pLabel);</span>
<span class="line-added">+                      free(((CK_TLS_PRF_PARAMS*)tmp)-&gt;pulOutputLen);</span>
<span class="line-added">+                      free(((CK_TLS_PRF_PARAMS*)tmp)-&gt;pOutput);</span>
<span class="line-added">+                      break;</span>
<span class="line-added">+                  case CKM_SSL3_MASTER_KEY_DERIVE:</span>
<span class="line-added">+                  case CKM_TLS_MASTER_KEY_DERIVE:</span>
<span class="line-added">+                  case CKM_SSL3_MASTER_KEY_DERIVE_DH:</span>
<span class="line-added">+                  case CKM_TLS_MASTER_KEY_DERIVE_DH:</span>
<span class="line-added">+                      sslMkdTmp = tmp;</span>
<span class="line-added">+                      TRACE0(&quot;[ CK_SSL3_MASTER_KEY_DERIVE_PARAMS ]\n&quot;);</span>
<span class="line-added">+                      free(sslMkdTmp-&gt;RandomInfo.pClientRandom);</span>
<span class="line-added">+                      free(sslMkdTmp-&gt;RandomInfo.pServerRandom);</span>
<span class="line-added">+                      free(sslMkdTmp-&gt;pVersion);</span>
<span class="line-added">+                      break;</span>
<span class="line-added">+                  case CKM_SSL3_KEY_AND_MAC_DERIVE:</span>
<span class="line-added">+                  case CKM_TLS_KEY_AND_MAC_DERIVE:</span>
<span class="line-added">+                      sslKmTmp = tmp;</span>
<span class="line-added">+                      TRACE0(&quot;[ CK_SSL3_KEY_MAT_PARAMS ]\n&quot;);</span>
<span class="line-added">+                      free(sslKmTmp-&gt;RandomInfo.pClientRandom);</span>
<span class="line-added">+                      free(sslKmTmp-&gt;RandomInfo.pServerRandom);</span>
<span class="line-added">+                      if (sslKmTmp-&gt;pReturnedKeyMaterial != NULL) {</span>
<span class="line-added">+                          free(sslKmTmp-&gt;pReturnedKeyMaterial-&gt;pIVClient);</span>
<span class="line-added">+                          free(sslKmTmp-&gt;pReturnedKeyMaterial-&gt;pIVServer);</span>
<span class="line-added">+                          free(sslKmTmp-&gt;pReturnedKeyMaterial);</span>
<span class="line-added">+                      }</span>
<span class="line-added">+                      break;</span>
<span class="line-added">+                  case CKM_TLS12_MASTER_KEY_DERIVE:</span>
<span class="line-added">+                  case CKM_TLS12_MASTER_KEY_DERIVE_DH:</span>
<span class="line-added">+                      tlsMkdTmp = tmp;</span>
<span class="line-added">+                      TRACE0(&quot;[ CK_TLS12_MASTER_KEY_DERIVE_PARAMS ]\n&quot;);</span>
<span class="line-added">+                      free(tlsMkdTmp-&gt;RandomInfo.pClientRandom);</span>
<span class="line-added">+                      free(tlsMkdTmp-&gt;RandomInfo.pServerRandom);</span>
<span class="line-added">+                      free(tlsMkdTmp-&gt;pVersion);</span>
<span class="line-added">+                      break;</span>
<span class="line-added">+                  case CKM_TLS12_KEY_AND_MAC_DERIVE:</span>
<span class="line-added">+                      tlsKmTmp = tmp;</span>
<span class="line-added">+                      TRACE0(&quot;[ CK_TLS12_KEY_MAT_PARAMS ]\n&quot;);</span>
<span class="line-added">+                      free(tlsKmTmp-&gt;RandomInfo.pClientRandom);</span>
<span class="line-added">+                      free(tlsKmTmp-&gt;RandomInfo.pServerRandom);</span>
<span class="line-added">+                      if (tlsKmTmp-&gt;pReturnedKeyMaterial != NULL) {</span>
<span class="line-added">+                          free(tlsKmTmp-&gt;pReturnedKeyMaterial-&gt;pIVClient);</span>
<span class="line-added">+                          free(tlsKmTmp-&gt;pReturnedKeyMaterial-&gt;pIVServer);</span>
<span class="line-added">+                          free(tlsKmTmp-&gt;pReturnedKeyMaterial);</span>
<span class="line-added">+                      }</span>
<span class="line-added">+                      break;</span>
<span class="line-added">+                  case CKM_ECDH1_DERIVE:</span>
<span class="line-added">+                  case CKM_ECDH1_COFACTOR_DERIVE:</span>
<span class="line-added">+                      TRACE0(&quot;[ CK_ECDH1_DERIVE_PARAMS ]\n&quot;);</span>
<span class="line-added">+                      free(((CK_ECDH1_DERIVE_PARAMS *)tmp)-&gt;pSharedData);</span>
<span class="line-added">+                      free(((CK_ECDH1_DERIVE_PARAMS *)tmp)-&gt;pPublicData);</span>
<span class="line-added">+                      break;</span>
<span class="line-added">+                  case CKM_TLS_MAC:</span>
<span class="line-added">+                  case CKM_AES_CTR:</span>
<span class="line-added">+                  case CKM_RSA_PKCS_PSS:</span>
<span class="line-added">+                  case CKM_CAMELLIA_CTR:</span>
<span class="line-added">+                      // params do not contain pointers</span>
<span class="line-added">+                      break;</span>
<span class="line-added">+                  default:</span>
<span class="line-added">+                      // currently unsupported mechs by SunPKCS11 provider</span>
<span class="line-added">+                      // CKM_RSA_PKCS_OAEP, CKM_ECMQV_DERIVE,</span>
<span class="line-added">+                      // CKM_X9_42_*, CKM_KEA_DERIVE, CKM_RC2_*, CKM_RC5_*,</span>
<span class="line-added">+                      // CKM_SKIPJACK_*, CKM_KEY_WRAP_SET_OAEP, CKM_PKCS5_PBKD2,</span>
<span class="line-added">+                      // PBE mechs, WTLS mechs, CMS mechs,</span>
<span class="line-added">+                      // CKM_EXTRACT_KEY_FROM_KEY, CKM_OTP, CKM_KIP,</span>
<span class="line-added">+                      // CKM_DSA_PARAMETER_GEN?, CKM_GOSTR3410_*</span>
<span class="line-added">+                      // CK_any_CBC_ENCRYPT_DATA?</span>
<span class="line-added">+                      TRACE0(&quot;ERROR: UNSUPPORTED CK_MECHANISM\n&quot;);</span>
<span class="line-added">+                      break;</span>
<span class="line-added">+              }</span>
<span class="line-added">+              TRACE1(&quot;\t=&gt; freed param %p\n&quot;, tmp);</span>
<span class="line-added">+              free(tmp);</span>
<span class="line-added">+          } else {</span>
<span class="line-added">+              TRACE0(&quot;\t=&gt; param NULL\n&quot;);</span>
<span class="line-added">+          }</span>
<span class="line-added">+          free(mechPtr);</span>
<span class="line-added">+          TRACE0(&quot;FINISHED\n&quot;);</span>
<span class="line-added">+      }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! /* This function replaces the CK_GCM_PARAMS_NO_IVBITS structure associated</span>
<span class="line-modified">!  * with the specified CK_MECHANISM structure with CK_GCM_PARAMS</span>
<span class="line-modified">!  * structure.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * @param mechPtr pointer to the CK_MECHANISM structure containing</span>
<span class="line-added">+  * the to-be-converted CK_GCM_PARAMS_NO_IVBITS structure.</span>
<span class="line-added">+  * @return pointer to the CK_MECHANISM structure containing the</span>
<span class="line-added">+  * converted CK_GCM_PARAMS structure or NULL if no conversion took place.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ CK_MECHANISM_PTR updateGCMParams(JNIEnv *env, CK_MECHANISM_PTR mechPtr) {</span>
<span class="line-added">+     CK_GCM_PARAMS* pGcmParams2 = NULL;</span>
<span class="line-added">+     CK_GCM_PARAMS_NO_IVBITS* pParams = NULL;</span>
<span class="line-added">+     if ((mechPtr-&gt;mechanism == CKM_AES_GCM) &amp;&amp;</span>
<span class="line-added">+             (mechPtr-&gt;pParameter != NULL_PTR) &amp;&amp;</span>
<span class="line-added">+             (mechPtr-&gt;ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS))) {</span>
<span class="line-added">+         pGcmParams2 = calloc(1, sizeof(CK_GCM_PARAMS));</span>
<span class="line-added">+         if (pGcmParams2 == NULL) {</span>
<span class="line-added">+             throwOutOfMemoryError(env, 0);</span>
<span class="line-added">+             return NULL;</span>
          }
<span class="line-added">+         pParams = (CK_GCM_PARAMS_NO_IVBITS*) mechPtr-&gt;pParameter;</span>
<span class="line-added">+         pGcmParams2-&gt;pIv = pParams-&gt;pIv;</span>
<span class="line-added">+         pGcmParams2-&gt;ulIvLen = pParams-&gt;ulIvLen;</span>
<span class="line-added">+         pGcmParams2-&gt;ulIvBits = (pGcmParams2-&gt;ulIvLen &lt;&lt; 3);</span>
<span class="line-added">+         pGcmParams2-&gt;pAAD = pParams-&gt;pAAD;</span>
<span class="line-added">+         pGcmParams2-&gt;ulAADLen = pParams-&gt;ulAADLen;</span>
<span class="line-added">+         pGcmParams2-&gt;ulTagBits = pParams-&gt;ulTagBits;</span>
<span class="line-added">+         TRACE1(&quot;DEBUG updateGCMParams: pMech %p\n&quot;, mechPtr);</span>
<span class="line-added">+         TRACE2(&quot;\t=&gt; GCM param w/o ulIvBits %p =&gt; GCM param %p\n&quot;, pParams,</span>
<span class="line-added">+                 pGcmParams2);</span>
<span class="line-added">+         free(pParams);</span>
<span class="line-added">+         mechPtr-&gt;pParameter = pGcmParams2;</span>
<span class="line-added">+         mechPtr-&gt;ulParameterLen = sizeof(CK_GCM_PARAMS);</span>
<span class="line-added">+         return mechPtr;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         TRACE0(&quot;DEBUG updateGCMParams: no conversion done\n&quot;);</span>
      }
<span class="line-modified">!     return NULL;</span>
  }
  
  /*
   * the following functions convert Java arrays to PKCS#11 array pointers and
   * their array length and vice versa
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,22 ***</span>
          *ckpArray = NULL_PTR;
          *ckpLength = 0L;
          return;
      }
      *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified">!     jpTemp = (jboolean*) malloc((*ckpLength) * sizeof(jboolean));</span>
      if (jpTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return;
      }
      (*env)-&gt;GetBooleanArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
      if ((*env)-&gt;ExceptionCheck(env)) {
          free(jpTemp);
          return;
      }
  
<span class="line-modified">!     *ckpArray = (CK_BBOOL*) malloc ((*ckpLength) * sizeof(CK_BBOOL));</span>
      if (*ckpArray == NULL) {
          free(jpTemp);
          throwOutOfMemoryError(env, 0);
          return;
      }
<span class="line-new-header">--- 495,22 ---</span>
          *ckpArray = NULL_PTR;
          *ckpLength = 0L;
          return;
      }
      *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified">!     jpTemp = (jboolean*) calloc(*ckpLength, sizeof(jboolean));</span>
      if (jpTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return;
      }
      (*env)-&gt;GetBooleanArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
      if ((*env)-&gt;ExceptionCheck(env)) {
          free(jpTemp);
          return;
      }
  
<span class="line-modified">!     *ckpArray = (CK_BBOOL*) calloc (*ckpLength, sizeof(CK_BBOOL));</span>
      if (*ckpArray == NULL) {
          free(jpTemp);
          throwOutOfMemoryError(env, 0);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 380,11 ***</span>
          *ckpArray = NULL_PTR;
          *ckpLength = 0L;
          return;
      }
      *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified">!     jpTemp = (jbyte*) malloc((*ckpLength) * sizeof(jbyte));</span>
      if (jpTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return;
      }
      (*env)-&gt;GetByteArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
<span class="line-new-header">--- 537,11 ---</span>
          *ckpArray = NULL_PTR;
          *ckpLength = 0L;
          return;
      }
      *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified">!     jpTemp = (jbyte*) calloc(*ckpLength, sizeof(jbyte));</span>
      if (jpTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return;
      }
      (*env)-&gt;GetByteArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 395,11 ***</span>
  
      /* if CK_BYTE is the same size as jbyte, we save an additional copy */
      if (sizeof(CK_BYTE) == sizeof(jbyte)) {
          *ckpArray = (CK_BYTE_PTR) jpTemp;
      } else {
<span class="line-modified">!         *ckpArray = (CK_BYTE_PTR) malloc ((*ckpLength) * sizeof(CK_BYTE));</span>
          if (*ckpArray == NULL) {
              free(jpTemp);
              throwOutOfMemoryError(env, 0);
              return;
          }
<span class="line-new-header">--- 552,11 ---</span>
  
      /* if CK_BYTE is the same size as jbyte, we save an additional copy */
      if (sizeof(CK_BYTE) == sizeof(jbyte)) {
          *ckpArray = (CK_BYTE_PTR) jpTemp;
      } else {
<span class="line-modified">!         *ckpArray = (CK_BYTE_PTR) calloc (*ckpLength, sizeof(CK_BYTE));</span>
          if (*ckpArray == NULL) {
              free(jpTemp);
              throwOutOfMemoryError(env, 0);
              return;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,22 ***</span>
          *ckpArray = NULL_PTR;
          *ckpLength = 0L;
          return;
      }
      *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified">!     jTemp = (jlong*) malloc((*ckpLength) * sizeof(jlong));</span>
      if (jTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return;
      }
      (*env)-&gt;GetLongArrayRegion(env, jArray, 0, *ckpLength, jTemp);
      if ((*env)-&gt;ExceptionCheck(env)) {
          free(jTemp);
          return;
      }
  
<span class="line-modified">!     *ckpArray = (CK_ULONG_PTR) malloc (*ckpLength * sizeof(CK_ULONG));</span>
      if (*ckpArray == NULL) {
          free(jTemp);
          throwOutOfMemoryError(env, 0);
          return;
      }
<span class="line-new-header">--- 584,22 ---</span>
          *ckpArray = NULL_PTR;
          *ckpLength = 0L;
          return;
      }
      *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified">!     jTemp = (jlong*) calloc(*ckpLength, sizeof(jlong));</span>
      if (jTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return;
      }
      (*env)-&gt;GetLongArrayRegion(env, jArray, 0, *ckpLength, jTemp);
      if ((*env)-&gt;ExceptionCheck(env)) {
          free(jTemp);
          return;
      }
  
<span class="line-modified">!     *ckpArray = (CK_ULONG_PTR) calloc(*ckpLength, sizeof(CK_ULONG));</span>
      if (*ckpArray == NULL) {
          free(jTemp);
          throwOutOfMemoryError(env, 0);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 469,22 ***</span>
          *ckpArray = NULL_PTR;
          *ckpLength = 0L;
          return;
      }
      *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified">!     jpTemp = (jchar*) malloc((*ckpLength) * sizeof(jchar));</span>
      if (jpTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return;
      }
      (*env)-&gt;GetCharArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
      if ((*env)-&gt;ExceptionCheck(env)) {
          free(jpTemp);
          return;
      }
  
<span class="line-modified">!     *ckpArray = (CK_CHAR_PTR) malloc (*ckpLength * sizeof(CK_CHAR));</span>
      if (*ckpArray == NULL) {
          free(jpTemp);
          throwOutOfMemoryError(env, 0);
          return;
      }
<span class="line-new-header">--- 626,22 ---</span>
          *ckpArray = NULL_PTR;
          *ckpLength = 0L;
          return;
      }
      *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified">!     jpTemp = (jchar*) calloc(*ckpLength, sizeof(jchar));</span>
      if (jpTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return;
      }
      (*env)-&gt;GetCharArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
      if ((*env)-&gt;ExceptionCheck(env)) {
          free(jpTemp);
          return;
      }
  
<span class="line-modified">!     *ckpArray = (CK_CHAR_PTR) calloc (*ckpLength, sizeof(CK_CHAR));</span>
      if (*ckpArray == NULL) {
          free(jpTemp);
          throwOutOfMemoryError(env, 0);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 511,22 ***</span>
          *ckpArray = NULL_PTR;
          *ckpLength = 0L;
          return;
      }
      *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified">!     jTemp = (jchar*) malloc((*ckpLength) * sizeof(jchar));</span>
      if (jTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return;
      }
      (*env)-&gt;GetCharArrayRegion(env, jArray, 0, *ckpLength, jTemp);
      if ((*env)-&gt;ExceptionCheck(env)) {
          free(jTemp);
          return;
      }
  
<span class="line-modified">!     *ckpArray = (CK_UTF8CHAR_PTR) malloc (*ckpLength * sizeof(CK_UTF8CHAR));</span>
      if (*ckpArray == NULL) {
          free(jTemp);
          throwOutOfMemoryError(env, 0);
          return;
      }
<span class="line-new-header">--- 668,22 ---</span>
          *ckpArray = NULL_PTR;
          *ckpLength = 0L;
          return;
      }
      *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified">!     jTemp = (jchar*) calloc(*ckpLength, sizeof(jchar));</span>
      if (jTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return;
      }
      (*env)-&gt;GetCharArrayRegion(env, jArray, 0, *ckpLength, jTemp);
      if ((*env)-&gt;ExceptionCheck(env)) {
          free(jTemp);
          return;
      }
  
<span class="line-modified">!     *ckpArray = (CK_UTF8CHAR_PTR) calloc(*ckpLength, sizeof(CK_UTF8CHAR));</span>
      if (*ckpArray == NULL) {
          free(jTemp);
          throwOutOfMemoryError(env, 0);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 557,11 ***</span>
  
      pCharArray = (*env)-&gt;GetStringUTFChars(env, jArray, &amp;isCopy);
      if (pCharArray == NULL) { return; }
  
      *ckpLength = (CK_ULONG) strlen(pCharArray);
<span class="line-modified">!     *ckpArray = (CK_UTF8CHAR_PTR) malloc((*ckpLength + 1) * sizeof(CK_UTF8CHAR));</span>
      if (*ckpArray == NULL) {
          (*env)-&gt;ReleaseStringUTFChars(env, (jstring) jArray, pCharArray);
          throwOutOfMemoryError(env, 0);
          return;
      }
<span class="line-new-header">--- 714,11 ---</span>
  
      pCharArray = (*env)-&gt;GetStringUTFChars(env, jArray, &amp;isCopy);
      if (pCharArray == NULL) { return; }
  
      *ckpLength = (CK_ULONG) strlen(pCharArray);
<span class="line-modified">!     *ckpArray = (CK_UTF8CHAR_PTR) calloc(*ckpLength + 1, sizeof(CK_UTF8CHAR));</span>
      if (*ckpArray == NULL) {
          (*env)-&gt;ReleaseStringUTFChars(env, (jstring) jArray, pCharArray);
          throwOutOfMemoryError(env, 0);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 591,25 ***</span>
          *ckpLength = 0L;
          return;
      }
      jLength = (*env)-&gt;GetArrayLength(env, jArray);
      *ckpLength = jLongToCKULong(jLength);
<span class="line-modified">!     *ckpArray = (CK_ATTRIBUTE_PTR) malloc(*ckpLength * sizeof(CK_ATTRIBUTE));</span>
      if (*ckpArray == NULL) {
          throwOutOfMemoryError(env, 0);
          return;
      }
<span class="line-modified">!     TRACE1(&quot;, converting %d attributes&quot;, jLength);</span>
      for (i=0; i&lt;(*ckpLength); i++) {
<span class="line-modified">!         TRACE1(&quot;, getting %d. attribute&quot;, i);</span>
          jAttribute = (*env)-&gt;GetObjectArrayElement(env, jArray, i);
          if ((*env)-&gt;ExceptionCheck(env)) {
              freeCKAttributeArray(*ckpArray, i);
              return;
          }
<span class="line-modified">!         TRACE1(&quot;, jAttribute = %d&quot;, jAttribute);</span>
<span class="line-removed">-         TRACE1(&quot;, converting %d. attribute&quot;, i);</span>
          (*ckpArray)[i] = jAttributeToCKAttribute(env, jAttribute);
          if ((*env)-&gt;ExceptionCheck(env)) {
              freeCKAttributeArray(*ckpArray, i);
              return;
          }
<span class="line-new-header">--- 748,24 ---</span>
          *ckpLength = 0L;
          return;
      }
      jLength = (*env)-&gt;GetArrayLength(env, jArray);
      *ckpLength = jLongToCKULong(jLength);
<span class="line-modified">!     *ckpArray = (CK_ATTRIBUTE_PTR) calloc(*ckpLength, sizeof(CK_ATTRIBUTE));</span>
      if (*ckpArray == NULL) {
          throwOutOfMemoryError(env, 0);
          return;
      }
<span class="line-modified">!     TRACE1(&quot;, converting %lld attributes&quot;, (long long int) jLength);</span>
      for (i=0; i&lt;(*ckpLength); i++) {
<span class="line-modified">!         TRACE1(&quot;, getting %lu. attribute&quot;, i);</span>
          jAttribute = (*env)-&gt;GetObjectArrayElement(env, jArray, i);
          if ((*env)-&gt;ExceptionCheck(env)) {
              freeCKAttributeArray(*ckpArray, i);
              return;
          }
<span class="line-modified">!         TRACE1(&quot;, jAttribute , converting %lu. attribute&quot;, i);</span>
          (*ckpArray)[i] = jAttributeToCKAttribute(env, jAttribute);
          if ((*env)-&gt;ExceptionCheck(env)) {
              freeCKAttributeArray(*ckpArray, i);
              return;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 633,11 ***</span>
  
      /* if CK_BYTE is the same size as jbyte, we save an additional copy */
      if (sizeof(CK_BYTE) == sizeof(jbyte)) {
          jpTemp = (jbyte*) ckpArray;
      } else {
<span class="line-modified">!         jpTemp = (jbyte*) malloc((ckLength) * sizeof(jbyte));</span>
          if (jpTemp == NULL) {
              throwOutOfMemoryError(env, 0);
              return NULL;
          }
          for (i=0; i&lt;ckLength; i++) {
<span class="line-new-header">--- 789,11 ---</span>
  
      /* if CK_BYTE is the same size as jbyte, we save an additional copy */
      if (sizeof(CK_BYTE) == sizeof(jbyte)) {
          jpTemp = (jbyte*) ckpArray;
      } else {
<span class="line-modified">!         jpTemp = (jbyte*) calloc(ckLength, sizeof(jbyte));</span>
          if (jpTemp == NULL) {
              throwOutOfMemoryError(env, 0);
              return NULL;
          }
          for (i=0; i&lt;ckLength; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 667,11 ***</span>
  {
      CK_ULONG i;
      jlong* jpTemp;
      jlongArray jArray;
  
<span class="line-modified">!     jpTemp = (jlong*) malloc((ckLength) * sizeof(jlong));</span>
      if (jpTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return NULL;
      }
      for (i=0; i&lt;ckLength; i++) {
<span class="line-new-header">--- 823,11 ---</span>
  {
      CK_ULONG i;
      jlong* jpTemp;
      jlongArray jArray;
  
<span class="line-modified">!     jpTemp = (jlong*) calloc(ckLength, sizeof(jlong));</span>
      if (jpTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return NULL;
      }
      for (i=0; i&lt;ckLength; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 698,11 ***</span>
  {
      CK_ULONG i;
      jchar* jpTemp;
      jcharArray jArray;
  
<span class="line-modified">!     jpTemp = (jchar*) malloc(ckLength * sizeof(jchar));</span>
      if (jpTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return NULL;
      }
      for (i=0; i&lt;ckLength; i++) {
<span class="line-new-header">--- 854,11 ---</span>
  {
      CK_ULONG i;
      jchar* jpTemp;
      jcharArray jArray;
  
<span class="line-modified">!     jpTemp = (jchar*) calloc(ckLength, sizeof(jchar));</span>
      if (jpTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return NULL;
      }
      for (i=0; i&lt;ckLength; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 729,11 ***</span>
  {
      CK_ULONG i;
      jchar* jpTemp;
      jcharArray jArray;
  
<span class="line-modified">!     jpTemp = (jchar*) malloc(ckLength * sizeof(jchar));</span>
      if (jpTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return NULL;
      }
      for (i=0; i&lt;ckLength; i++) {
<span class="line-new-header">--- 885,11 ---</span>
  {
      CK_ULONG i;
      jchar* jpTemp;
      jcharArray jArray;
  
<span class="line-modified">!     jpTemp = (jchar*) calloc(ckLength, sizeof(jchar));</span>
      if (jpTemp == NULL) {
          throwOutOfMemoryError(env, 0);
          return NULL;
      }
      for (i=0; i&lt;ckLength; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 962,184 ***</span>
      return ckpValue ;
  }
  
  /*
   * converts a Java object into a pointer to CK-type or a CK-structure with the length in Bytes.
<span class="line-modified">!  * The memory of *ckpObjectPtr to be freed after use! This function is only used by</span>
<span class="line-removed">-  * jAttributeToCKAttribute by now.</span>
   *
   * @param env - used to call JNI funktions to get the Java classes and objects
   * @param jObject - the Java object to convert
<span class="line-modified">!  * @param ckpObjectPtr - the reference of the new pointer to the new CK-value or CK-structure</span>
<span class="line-modified">!  * @param ckpLength - the reference of the length in bytes of the new CK-value or CK-structure</span>
   */
<span class="line-modified">! void jObjectToPrimitiveCKObjectPtrPtr(JNIEnv *env, jobject jObject, CK_VOID_PTR *ckpObjectPtr, CK_ULONG *ckpLength)</span>
  {
      jclass jLongClass, jBooleanClass, jByteArrayClass, jCharArrayClass;
      jclass jByteClass, jDateClass, jCharacterClass, jIntegerClass;
      jclass jBooleanArrayClass, jIntArrayClass, jLongArrayClass;
      jclass jStringClass;
      jclass jObjectClass, jClassClass;
<span class="line-modified">!     CK_VOID_PTR ckpVoid = *ckpObjectPtr;</span>
      jmethodID jMethod;
      jobject jClassObject;
      jstring jClassNameString;
      char *classNameString, *exceptionMsgPrefix, *exceptionMsg;
  
<span class="line-modified">!     TRACE0(&quot;\nDEBUG: jObjectToPrimitiveCKObjectPtrPtr&quot;);</span>
      if (jObject == NULL) {
<span class="line-removed">-         *ckpObjectPtr = NULL;</span>
          *ckpLength = 0;
<span class="line-modified">!         return;</span>
      }
  
      jLongClass = (*env)-&gt;FindClass(env, &quot;java/lang/Long&quot;);
<span class="line-modified">!     if (jLongClass == NULL) { return; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jLongClass)) {
<span class="line-modified">!         *ckpObjectPtr = jLongObjectToCKULongPtr(env, jObject);</span>
          *ckpLength = sizeof(CK_ULONG);
<span class="line-modified">!         TRACE1(&quot;&lt;converted long value %X&gt;&quot;, *((CK_ULONG *) *ckpObjectPtr));</span>
<span class="line-modified">!         return;</span>
      }
  
      jBooleanClass = (*env)-&gt;FindClass(env, &quot;java/lang/Boolean&quot;);
<span class="line-modified">!     if (jBooleanClass == NULL) { return; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jBooleanClass)) {
<span class="line-modified">!         *ckpObjectPtr = jBooleanObjectToCKBBoolPtr(env, jObject);</span>
          *ckpLength = sizeof(CK_BBOOL);
          TRACE0(&quot; &lt;converted boolean value &quot;);
<span class="line-modified">!         TRACE0((*((CK_BBOOL *) *ckpObjectPtr) == TRUE) ? &quot;TRUE&gt;&quot; : &quot;FALSE&gt;&quot;);</span>
<span class="line-modified">!         return;</span>
      }
  
      jByteArrayClass = (*env)-&gt;FindClass(env, &quot;[B&quot;);
<span class="line-modified">!     if (jByteArrayClass == NULL) { return; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jByteArrayClass)) {
<span class="line-modified">!         jByteArrayToCKByteArray(env, jObject, (CK_BYTE_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">!         return;</span>
      }
  
      jCharArrayClass = (*env)-&gt;FindClass(env, &quot;[C&quot;);
<span class="line-modified">!     if (jCharArrayClass == NULL) { return; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jCharArrayClass)) {
<span class="line-modified">!         jCharArrayToCKUTF8CharArray(env, jObject, (CK_UTF8CHAR_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">!         return;</span>
      }
  
      jByteClass = (*env)-&gt;FindClass(env, &quot;java/lang/Byte&quot;);
<span class="line-modified">!     if (jByteClass == NULL) { return; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jByteClass)) {
<span class="line-modified">!         *ckpObjectPtr = jByteObjectToCKBytePtr(env, jObject);</span>
          *ckpLength = sizeof(CK_BYTE);
<span class="line-modified">!         TRACE1(&quot;&lt;converted byte value %X&gt;&quot;, *((CK_BYTE *) *ckpObjectPtr));</span>
<span class="line-modified">!         return;</span>
      }
  
      jDateClass = (*env)-&gt;FindClass(env, CLASS_DATE);
<span class="line-modified">!     if (jDateClass == NULL) { return; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jDateClass)) {
<span class="line-modified">!         *ckpObjectPtr = jDateObjectPtrToCKDatePtr(env, jObject);</span>
          *ckpLength = sizeof(CK_DATE);
<span class="line-modified">!         TRACE3(&quot;&lt;converted date value %.4s-%.2s-%.2s&gt;&quot;, (*((CK_DATE *) *ckpObjectPtr)).year, (*((CK_DATE *) *ckpObjectPtr)).month, (*((CK_DATE *) *ckpObjectPtr)).day);</span>
<span class="line-modified">!         return;</span>
      }
  
      jCharacterClass = (*env)-&gt;FindClass(env, &quot;java/lang/Character&quot;);
<span class="line-modified">!     if (jCharacterClass == NULL) { return; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jCharacterClass)) {
<span class="line-modified">!         *ckpObjectPtr = jCharObjectToCKCharPtr(env, jObject);</span>
          *ckpLength = sizeof(CK_UTF8CHAR);
<span class="line-modified">!         TRACE1(&quot;&lt;converted char value %c&gt;&quot;, *((CK_CHAR *) *ckpObjectPtr));</span>
<span class="line-modified">!         return;</span>
      }
  
      jIntegerClass = (*env)-&gt;FindClass(env, &quot;java/lang/Integer&quot;);
<span class="line-modified">!     if (jIntegerClass == NULL) { return; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jIntegerClass)) {
<span class="line-modified">!         *ckpObjectPtr = jIntegerObjectToCKULongPtr(env, jObject);</span>
          *ckpLength = sizeof(CK_ULONG);
<span class="line-modified">!         TRACE1(&quot;&lt;converted integer value %X&gt;&quot;, *((CK_ULONG *) *ckpObjectPtr));</span>
<span class="line-modified">!         return;</span>
      }
  
      jBooleanArrayClass = (*env)-&gt;FindClass(env, &quot;[Z&quot;);
<span class="line-modified">!     if (jBooleanArrayClass == NULL) { return; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jBooleanArrayClass)) {
<span class="line-modified">!         jBooleanArrayToCKBBoolArray(env, jObject, (CK_BBOOL**)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">!         return;</span>
      }
  
      jIntArrayClass = (*env)-&gt;FindClass(env, &quot;[I&quot;);
<span class="line-modified">!     if (jIntArrayClass == NULL) { return; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jIntArrayClass)) {
<span class="line-modified">!         jLongArrayToCKULongArray(env, jObject, (CK_ULONG_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">!         return;</span>
      }
  
      jLongArrayClass = (*env)-&gt;FindClass(env, &quot;[J&quot;);
<span class="line-modified">!     if (jLongArrayClass == NULL) { return; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jLongArrayClass)) {
<span class="line-modified">!         jLongArrayToCKULongArray(env, jObject, (CK_ULONG_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">!         return;</span>
      }
  
      jStringClass = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
<span class="line-modified">!     if (jStringClass == NULL) { return; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jStringClass)) {
<span class="line-modified">!         jStringToCKUTF8CharArray(env, jObject, (CK_UTF8CHAR_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">!         return;</span>
      }
  
      /* type of jObject unknown, throw PKCS11RuntimeException */
      jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Object&quot;);
<span class="line-modified">!     if (jObjectClass == NULL) { return; }</span>
      jMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;getClass&quot;, &quot;()Ljava/lang/Class;&quot;);
<span class="line-modified">!     if (jMethod == NULL) { return; }</span>
      jClassObject = (*env)-&gt;CallObjectMethod(env, jObject, jMethod);
      assert(jClassObject != 0);
      jClassClass = (*env)-&gt;FindClass(env, &quot;java/lang/Class&quot;);
<span class="line-modified">!     if (jClassClass == NULL) { return; }</span>
      jMethod = (*env)-&gt;GetMethodID(env, jClassClass, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;);
<span class="line-modified">!     if (jMethod == NULL) { return; }</span>
      jClassNameString = (jstring)
          (*env)-&gt;CallObjectMethod(env, jClassObject, jMethod);
      assert(jClassNameString != 0);
      classNameString = (char*)
          (*env)-&gt;GetStringUTFChars(env, jClassNameString, NULL);
<span class="line-modified">!     if (classNameString == NULL) { return; }</span>
      exceptionMsgPrefix = &quot;Java object of this class cannot be converted to native PKCS#11 type: &quot;;
      exceptionMsg = (char *)
<span class="line-modified">!         malloc((strlen(exceptionMsgPrefix) + strlen(classNameString) + 1));</span>
      if (exceptionMsg == NULL) {
          (*env)-&gt;ReleaseStringUTFChars(env, jClassNameString, classNameString);
          throwOutOfMemoryError(env, 0);
<span class="line-modified">!         return;</span>
      }
      strcpy(exceptionMsg, exceptionMsgPrefix);
      strcat(exceptionMsg, classNameString);
      (*env)-&gt;ReleaseStringUTFChars(env, jClassNameString, classNameString);
      throwPKCS11RuntimeException(env, exceptionMsg);
      free(exceptionMsg);
<span class="line-removed">-     *ckpObjectPtr = NULL;</span>
      *ckpLength = 0;
  
      TRACE0(&quot;FINISHED\n&quot;);
  }
  
  #ifdef P11_MEMORYDEBUG
  
  #undef malloc
  #undef free
  
  void *p11malloc(size_t c, char *file, int line) {
      void *p = malloc(c);
<span class="line-modified">!     printf(&quot;malloc\t%08x\t%d\t%s:%d\n&quot;, p, c, file, line); fflush(stdout);</span>
      return p;
  }
  
  void p11free(void *p, char *file, int line) {
<span class="line-modified">!     printf(&quot;free\t%08x\t\t%s:%d\n&quot;, p, file, line); fflush(stdout);</span>
      free(p);
  }
  
  #endif
  
<span class="line-new-header">--- 1118,193 ---</span>
      return ckpValue ;
  }
  
  /*
   * converts a Java object into a pointer to CK-type or a CK-structure with the length in Bytes.
<span class="line-modified">!  * The memory of the returned pointer MUST BE FREED BY CALLER!</span>
   *
   * @param env - used to call JNI funktions to get the Java classes and objects
   * @param jObject - the Java object to convert
<span class="line-modified">!  * @param ckpLength - pointer to the length (bytes) of the newly-allocated CK-value or CK-structure</span>
<span class="line-modified">!  * @return ckpObject - pointer to the newly-allocated CK-value or CK-structure</span>
   */
<span class="line-modified">! CK_VOID_PTR jObjectToPrimitiveCKObjectPtr(JNIEnv *env, jobject jObject, CK_ULONG *ckpLength)</span>
  {
      jclass jLongClass, jBooleanClass, jByteArrayClass, jCharArrayClass;
      jclass jByteClass, jDateClass, jCharacterClass, jIntegerClass;
      jclass jBooleanArrayClass, jIntArrayClass, jLongArrayClass;
      jclass jStringClass;
      jclass jObjectClass, jClassClass;
<span class="line-modified">!     CK_VOID_PTR ckpObject;</span>
      jmethodID jMethod;
      jobject jClassObject;
      jstring jClassNameString;
      char *classNameString, *exceptionMsgPrefix, *exceptionMsg;
  
<span class="line-modified">!     TRACE0(&quot;\nDEBUG: jObjectToPrimitiveCKObjectPtr&quot;);</span>
      if (jObject == NULL) {
          *ckpLength = 0;
<span class="line-modified">!         return NULL;</span>
      }
  
      jLongClass = (*env)-&gt;FindClass(env, &quot;java/lang/Long&quot;);
<span class="line-modified">!     if (jLongClass == NULL) { return NULL; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jLongClass)) {
<span class="line-modified">!         ckpObject = jLongObjectToCKULongPtr(env, jObject);</span>
          *ckpLength = sizeof(CK_ULONG);
<span class="line-modified">!         TRACE1(&quot;&lt;converted long value %lu&gt;&quot;, *((CK_ULONG *) ckpObject));</span>
<span class="line-modified">!         return ckpObject;</span>
      }
  
      jBooleanClass = (*env)-&gt;FindClass(env, &quot;java/lang/Boolean&quot;);
<span class="line-modified">!     if (jBooleanClass == NULL) { return NULL; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jBooleanClass)) {
<span class="line-modified">!         ckpObject = jBooleanObjectToCKBBoolPtr(env, jObject);</span>
          *ckpLength = sizeof(CK_BBOOL);
          TRACE0(&quot; &lt;converted boolean value &quot;);
<span class="line-modified">!         TRACE0((*((CK_BBOOL *) ckpObject) == TRUE) ? &quot;TRUE&gt;&quot; : &quot;FALSE&gt;&quot;);</span>
<span class="line-modified">!         return ckpObject;</span>
      }
  
      jByteArrayClass = (*env)-&gt;FindClass(env, &quot;[B&quot;);
<span class="line-modified">!     if (jByteArrayClass == NULL) { return NULL; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jByteArrayClass)) {
<span class="line-modified">!         jByteArrayToCKByteArray(env, jObject, (CK_BYTE_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">!         return ckpObject;</span>
      }
  
      jCharArrayClass = (*env)-&gt;FindClass(env, &quot;[C&quot;);
<span class="line-modified">!     if (jCharArrayClass == NULL) { return NULL; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jCharArrayClass)) {
<span class="line-modified">!         jCharArrayToCKUTF8CharArray(env, jObject, (CK_UTF8CHAR_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">!         return ckpObject;</span>
      }
  
      jByteClass = (*env)-&gt;FindClass(env, &quot;java/lang/Byte&quot;);
<span class="line-modified">!     if (jByteClass == NULL) { return NULL; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jByteClass)) {
<span class="line-modified">!         ckpObject = jByteObjectToCKBytePtr(env, jObject);</span>
          *ckpLength = sizeof(CK_BYTE);
<span class="line-modified">!         TRACE1(&quot;&lt;converted byte value %X&gt;&quot;, *((CK_BYTE *) ckpObject));</span>
<span class="line-modified">!         return ckpObject;</span>
      }
  
      jDateClass = (*env)-&gt;FindClass(env, CLASS_DATE);
<span class="line-modified">!     if (jDateClass == NULL) { return NULL; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jDateClass)) {
<span class="line-modified">!         ckpObject = jDateObjectToCKDatePtr(env, jObject);</span>
          *ckpLength = sizeof(CK_DATE);
<span class="line-modified">!         TRACE3(&quot;&lt;converted date value %.4s-%.2s-%.2s&gt;&quot;, ((CK_DATE *) ckpObject)-&gt;year,</span>
<span class="line-modified">!                 ((CK_DATE *) ckpObject)-&gt;month, ((CK_DATE *) ckpObject)-&gt;day);</span>
<span class="line-added">+         return ckpObject;</span>
      }
  
      jCharacterClass = (*env)-&gt;FindClass(env, &quot;java/lang/Character&quot;);
<span class="line-modified">!     if (jCharacterClass == NULL) { return NULL; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jCharacterClass)) {
<span class="line-modified">!         ckpObject = jCharObjectToCKCharPtr(env, jObject);</span>
          *ckpLength = sizeof(CK_UTF8CHAR);
<span class="line-modified">!         TRACE1(&quot;&lt;converted char value %c&gt;&quot;, *((CK_CHAR *) ckpObject));</span>
<span class="line-modified">!         return ckpObject;</span>
      }
  
      jIntegerClass = (*env)-&gt;FindClass(env, &quot;java/lang/Integer&quot;);
<span class="line-modified">!     if (jIntegerClass == NULL) { return NULL; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jIntegerClass)) {
<span class="line-modified">!         ckpObject = jIntegerObjectToCKULongPtr(env, jObject);</span>
          *ckpLength = sizeof(CK_ULONG);
<span class="line-modified">!         TRACE1(&quot;&lt;converted integer value %lu&gt;&quot;, *((CK_ULONG *) ckpObject));</span>
<span class="line-modified">!         return ckpObject;</span>
      }
  
      jBooleanArrayClass = (*env)-&gt;FindClass(env, &quot;[Z&quot;);
<span class="line-modified">!     if (jBooleanArrayClass == NULL) { return NULL; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jBooleanArrayClass)) {
<span class="line-modified">!         jBooleanArrayToCKBBoolArray(env, jObject, (CK_BBOOL**) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">!         return ckpObject;</span>
      }
  
      jIntArrayClass = (*env)-&gt;FindClass(env, &quot;[I&quot;);
<span class="line-modified">!     if (jIntArrayClass == NULL) { return NULL; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jIntArrayClass)) {
<span class="line-modified">!         jLongArrayToCKULongArray(env, jObject, (CK_ULONG_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">!         return ckpObject;</span>
      }
  
      jLongArrayClass = (*env)-&gt;FindClass(env, &quot;[J&quot;);
<span class="line-modified">!     if (jLongArrayClass == NULL) { return NULL; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jLongArrayClass)) {
<span class="line-modified">!         jLongArrayToCKULongArray(env, jObject, (CK_ULONG_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">!         return ckpObject;</span>
      }
  
      jStringClass = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
<span class="line-modified">!     if (jStringClass == NULL) { return NULL; }</span>
      if ((*env)-&gt;IsInstanceOf(env, jObject, jStringClass)) {
<span class="line-modified">!         jStringToCKUTF8CharArray(env, jObject, (CK_UTF8CHAR_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">!         return ckpObject;</span>
      }
  
      /* type of jObject unknown, throw PKCS11RuntimeException */
      jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Object&quot;);
<span class="line-modified">!     if (jObjectClass == NULL) { return NULL; }</span>
      jMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;getClass&quot;, &quot;()Ljava/lang/Class;&quot;);
<span class="line-modified">!     if (jMethod == NULL) { return NULL; }</span>
      jClassObject = (*env)-&gt;CallObjectMethod(env, jObject, jMethod);
      assert(jClassObject != 0);
      jClassClass = (*env)-&gt;FindClass(env, &quot;java/lang/Class&quot;);
<span class="line-modified">!     if (jClassClass == NULL) { return NULL; }</span>
      jMethod = (*env)-&gt;GetMethodID(env, jClassClass, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;);
<span class="line-modified">!     if (jMethod == NULL) { return NULL; }</span>
      jClassNameString = (jstring)
          (*env)-&gt;CallObjectMethod(env, jClassObject, jMethod);
      assert(jClassNameString != 0);
      classNameString = (char*)
          (*env)-&gt;GetStringUTFChars(env, jClassNameString, NULL);
<span class="line-modified">!     if (classNameString == NULL) { return NULL; }</span>
      exceptionMsgPrefix = &quot;Java object of this class cannot be converted to native PKCS#11 type: &quot;;
      exceptionMsg = (char *)
<span class="line-modified">!         malloc(strlen(exceptionMsgPrefix) + strlen(classNameString) + 1);</span>
      if (exceptionMsg == NULL) {
          (*env)-&gt;ReleaseStringUTFChars(env, jClassNameString, classNameString);
          throwOutOfMemoryError(env, 0);
<span class="line-modified">!         return NULL;</span>
      }
      strcpy(exceptionMsg, exceptionMsgPrefix);
      strcat(exceptionMsg, classNameString);
      (*env)-&gt;ReleaseStringUTFChars(env, jClassNameString, classNameString);
      throwPKCS11RuntimeException(env, exceptionMsg);
      free(exceptionMsg);
      *ckpLength = 0;
  
      TRACE0(&quot;FINISHED\n&quot;);
<span class="line-added">+     return NULL;</span>
  }
  
  #ifdef P11_MEMORYDEBUG
  
  #undef malloc
<span class="line-added">+ #undef calloc</span>
  #undef free
  
  void *p11malloc(size_t c, char *file, int line) {
      void *p = malloc(c);
<span class="line-modified">!     fprintf(stdout, &quot;malloc\t%08lX\t%lX\t%s:%d\n&quot;, ptr_to_jlong(p), c, file, line);</span>
<span class="line-added">+     fflush(stdout);</span>
<span class="line-added">+     return p;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void *p11calloc(size_t c, size_t s, char *file, int line) {</span>
<span class="line-added">+     void *p = calloc(c, s);</span>
<span class="line-added">+     fprintf(stdout, &quot;calloc\t%08lX\t%lX\t%lX\t%s:%d\n&quot;, ptr_to_jlong(p), c, s, file, line);</span>
<span class="line-added">+     fflush(stdout);</span>
      return p;
  }
  
  void p11free(void *p, char *file, int line) {
<span class="line-modified">!     fprintf(stdout, &quot;free\t%08lX\t\t%s:%d\n&quot;, ptr_to_jlong(p), file, line);</span>
<span class="line-added">+     fflush(stdout);</span>
      free(p);
  }
  
  #endif
  
</pre>
<center><a href="p11_sign.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="pkcs11.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
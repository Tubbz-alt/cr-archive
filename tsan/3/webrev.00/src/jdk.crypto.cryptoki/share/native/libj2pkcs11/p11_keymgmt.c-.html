<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_keymgmt.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 
   5 /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
   6  *
   7  * Redistribution and use in  source and binary forms, with or without
   8  * modification, are permitted  provided that the following conditions are met:
   9  *
  10  * 1. Redistributions of  source code must retain the above copyright notice,
  11  *    this list of conditions and the following disclaimer.
  12  *
  13  * 2. Redistributions in  binary form must reproduce the above copyright notice,
  14  *    this list of conditions and the following disclaimer in the documentation
  15  *    and/or other materials provided with the distribution.
  16  *
  17  * 3. The end-user documentation included with the redistribution, if any, must
  18  *    include the following acknowledgment:
  19  *
  20  *    &quot;This product includes software developed by IAIK of Graz University of
  21  *     Technology.&quot;
  22  *
  23  *    Alternately, this acknowledgment may appear in the software itself, if
  24  *    and wherever such third-party acknowledgments normally appear.
  25  *
  26  * 4. The names &quot;Graz University of Technology&quot; and &quot;IAIK of Graz University of
  27  *    Technology&quot; must not be used to endorse or promote products derived from
  28  *    this software without prior written permission.
  29  *
  30  * 5. Products derived from this software may not be called
  31  *    &quot;IAIK PKCS Wrapper&quot;, nor may &quot;IAIK&quot; appear in their name, without prior
  32  *    written permission of Graz University of Technology.
  33  *
  34  *  THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESSED OR IMPLIED
  35  *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  36  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  37  *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE LICENSOR BE
  38  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
  39  *  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  40  *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  41  *  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  42  *  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  43  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  44  *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  45  *  POSSIBILITY  OF SUCH DAMAGE.
  46  */
  47 
  48 #include &quot;pkcs11wrapper.h&quot;
  49 
  50 #include &lt;stdio.h&gt;
  51 #include &lt;stdlib.h&gt;
  52 #include &lt;string.h&gt;
  53 #include &lt;assert.h&gt;
  54 
  55 #include &quot;sun_security_pkcs11_wrapper_PKCS11.h&quot;
  56 
  57 #ifdef P11_ENABLE_GETNATIVEKEYINFO
  58 
  59 #define CK_ATTRIBUTES_TEMPLATE_LENGTH (CK_ULONG)61U
  60 
  61 static CK_ATTRIBUTE ckpAttributesTemplate[CK_ATTRIBUTES_TEMPLATE_LENGTH] = {
  62         {CKA_CLASS, 0, 0},
  63         {CKA_TOKEN, 0, 0},
  64         {CKA_PRIVATE, 0, 0},
  65         {CKA_LABEL, 0, 0},
  66         {CKA_APPLICATION, 0, 0},
  67         {CKA_VALUE, 0, 0},
  68         {CKA_OBJECT_ID, 0, 0},
  69         {CKA_CERTIFICATE_TYPE, 0, 0},
  70         {CKA_ISSUER, 0, 0},
  71         {CKA_SERIAL_NUMBER, 0, 0},
  72         {CKA_AC_ISSUER, 0, 0},
  73         {CKA_OWNER, 0, 0},
  74         {CKA_ATTR_TYPES, 0, 0},
  75         {CKA_TRUSTED, 0, 0},
  76         {CKA_KEY_TYPE, 0, 0},
  77         {CKA_SUBJECT, 0, 0},
  78         {CKA_ID, 0, 0},
  79         {CKA_SENSITIVE, 0, 0},
  80         {CKA_ENCRYPT, 0, 0},
  81         {CKA_DECRYPT, 0, 0},
  82         {CKA_WRAP, 0, 0},
  83         {CKA_UNWRAP, 0, 0},
  84         {CKA_SIGN, 0, 0},
  85         {CKA_SIGN_RECOVER, 0, 0},
  86         {CKA_VERIFY, 0, 0},
  87         {CKA_VERIFY_RECOVER, 0, 0},
  88         {CKA_DERIVE, 0, 0},
  89         {CKA_START_DATE, 0, 0},
  90         {CKA_END_DATE, 0, 0},
  91         {CKA_MODULUS, 0, 0},
  92         {CKA_MODULUS_BITS, 0, 0},
  93         {CKA_PUBLIC_EXPONENT, 0, 0},
  94         {CKA_PRIVATE_EXPONENT, 0, 0},
  95         {CKA_PRIME_1, 0, 0},
  96         {CKA_PRIME_2, 0, 0},
  97         {CKA_EXPONENT_1, 0, 0},
  98         {CKA_EXPONENT_2, 0, 0},
  99         {CKA_COEFFICIENT, 0, 0},
 100         {CKA_PRIME, 0, 0},
 101         {CKA_SUBPRIME, 0, 0},
 102         {CKA_BASE, 0, 0},
 103         {CKA_PRIME_BITS, 0, 0},
 104         {CKA_SUB_PRIME_BITS, 0, 0},
 105         {CKA_VALUE_BITS, 0, 0},
 106         {CKA_VALUE_LEN, 0, 0},
 107         {CKA_EXTRACTABLE, 0, 0},
 108         {CKA_LOCAL, 0, 0},
 109         {CKA_NEVER_EXTRACTABLE, 0, 0},
 110         {CKA_ALWAYS_SENSITIVE, 0, 0},
 111         {CKA_KEY_GEN_MECHANISM, 0, 0},
 112         {CKA_MODIFIABLE, 0, 0},
 113         {CKA_ECDSA_PARAMS, 0, 0},
 114         {CKA_EC_PARAMS, 0, 0},
 115         {CKA_EC_POINT, 0, 0},
 116         {CKA_SECONDARY_AUTH, 0, 0},
 117         {CKA_AUTH_PIN_FLAGS, 0, 0},
 118         {CKA_HW_FEATURE_TYPE, 0, 0},
 119         {CKA_RESET_ON_INIT, 0, 0},
 120         {CKA_HAS_RESET, 0, 0},
 121         {CKA_VENDOR_DEFINED, 0, 0},
 122         {CKA_NETSCAPE_DB, 0, 0},
 123 };
 124 
 125 /*
 126  * Class:     sun_security_pkcs11_wrapper_PKCS11
 127  * Method:    getNativeKeyInfo
 128  * Signature: (JJJLsun/security/pkcs11/wrapper/CK_MECHANISM;)[B
 129  * Parametermapping:                         *PKCS11*
 130  * @param   jlong         jSessionHandle     CK_SESSION_HANDLE hSession
 131  * @param   jlong         jKeyHandle         CK_OBJECT_HANDLE hObject
 132  * @param   jlong         jWrappingKeyHandle CK_OBJECT_HANDLE hObject
 133  * @param   jobject       jWrappingMech      CK_MECHANISM_PTR pMechanism
 134  * @return  jbyteArray    jNativeKeyInfo     -
 135  */
 136 JNIEXPORT jbyteArray JNICALL
 137 Java_sun_security_pkcs11_wrapper_PKCS11_getNativeKeyInfo
 138     (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong jKeyHandle,
 139     jlong jWrappingKeyHandle, jobject jWrappingMech)
 140 {
 141     jbyteArray returnValue = NULL;
 142     CK_SESSION_HANDLE ckSessionHandle = jLongToCKULong(jSessionHandle);
 143     CK_OBJECT_HANDLE ckObjectHandle = jLongToCKULong(jKeyHandle);
 144     CK_ATTRIBUTE_PTR ckpAttributes = NULL;
 145     CK_RV rv;
 146     jbyteArray nativeKeyInfoArray = NULL;
 147     jbyteArray nativeKeyInfoWrappedKeyArray = NULL;
 148     jbyte* nativeKeyInfoArrayRaw = NULL;
 149     jbyte* nativeKeyInfoWrappedKeyArrayRaw = NULL;
 150     unsigned int sensitiveAttributePosition = (unsigned int)-1;
 151     unsigned int i = 0U;
 152     unsigned long totalDataSize = 0UL, attributesCount = 0UL;
 153     unsigned long totalCkAttributesSize = 0UL, totalNativeKeyInfoArraySize = 0UL;
 154     jbyte* wrappedKeySizePtr = NULL;
 155     jbyte* nativeKeyInfoArrayRawCkAttributes = NULL;
 156     jbyte* nativeKeyInfoArrayRawCkAttributesPtr = NULL;
 157     jbyte* nativeKeyInfoArrayRawDataPtr = NULL;
 158     CK_MECHANISM ckMechanism;
 159     char iv[16] = {0x0};
 160     CK_ULONG ckWrappedKeyLength = 0U;
 161     jbyte* wrappedKeySizeWrappedKeyArrayPtr = NULL;
 162     CK_BYTE_PTR wrappedKeyBufferPtr = NULL;
 163     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 164     CK_OBJECT_CLASS class;
 165     CK_KEY_TYPE keyType;
 166     CK_BBOOL sensitive;
 167     CK_BBOOL netscapeAttributeValueNeeded = CK_FALSE;
 168     CK_ATTRIBUTE ckNetscapeAttributesTemplate[4];
 169     ckNetscapeAttributesTemplate[0].type = CKA_CLASS;
 170     ckNetscapeAttributesTemplate[1].type = CKA_KEY_TYPE;
 171     ckNetscapeAttributesTemplate[2].type = CKA_SENSITIVE;
 172     ckNetscapeAttributesTemplate[3].type = CKA_NETSCAPE_DB;
 173     ckNetscapeAttributesTemplate[0].pValue = &amp;class;
 174     ckNetscapeAttributesTemplate[1].pValue = &amp;keyType;
 175     ckNetscapeAttributesTemplate[2].pValue = &amp;sensitive;
 176     ckNetscapeAttributesTemplate[3].pValue = 0;
 177     ckNetscapeAttributesTemplate[0].ulValueLen = sizeof(class);
 178     ckNetscapeAttributesTemplate[1].ulValueLen = sizeof(keyType);
 179     ckNetscapeAttributesTemplate[2].ulValueLen = sizeof(sensitive);
 180     ckNetscapeAttributesTemplate[3].ulValueLen = 0;
 181 
 182     if (ckpFunctions == NULL) { goto cleanup; }
 183 
 184     // If key is private and of DSA or EC type, NSS may require CKA_NETSCAPE_DB
 185     // attribute to unwrap it.
 186     rv = (*ckpFunctions-&gt;C_GetAttributeValue)(ckSessionHandle, ckObjectHandle,
 187             ckNetscapeAttributesTemplate,
 188             sizeof(ckNetscapeAttributesTemplate)/sizeof(CK_ATTRIBUTE));
 189 
 190     if (rv == CKR_OK &amp;&amp; class == CKO_PRIVATE_KEY &amp;&amp;
 191             (keyType == CKK_EC || keyType == CKK_DSA) &amp;&amp;
 192             sensitive == CK_TRUE &amp;&amp;
 193             ckNetscapeAttributesTemplate[3].ulValueLen == CK_UNAVAILABLE_INFORMATION) {
 194         // We cannot set the attribute through C_SetAttributeValue here
 195         // because it might be read-only. However, we can add it to
 196         // the extracted buffer.
 197         netscapeAttributeValueNeeded = CK_TRUE;
 198         TRACE0(&quot;DEBUG: override CKA_NETSCAPE_DB attr value to TRUE\n&quot;);
 199     }
 200 
 201     ckpAttributes = (CK_ATTRIBUTE_PTR)malloc(
 202             CK_ATTRIBUTES_TEMPLATE_LENGTH * sizeof(CK_ATTRIBUTE));
 203     if (ckpAttributes == NULL) {
 204         throwOutOfMemoryError(env, 0);
 205         goto cleanup;
 206     }
 207     memcpy(ckpAttributes, ckpAttributesTemplate,
 208             CK_ATTRIBUTES_TEMPLATE_LENGTH * sizeof(CK_ATTRIBUTE));
 209 
 210     // Get sizes for value buffers
 211     // NOTE: may return an error code but length values are filled anyways
 212     (*ckpFunctions-&gt;C_GetAttributeValue)(ckSessionHandle, ckObjectHandle,
 213             ckpAttributes, CK_ATTRIBUTES_TEMPLATE_LENGTH);
 214 
 215     for (i = 0; i &lt; CK_ATTRIBUTES_TEMPLATE_LENGTH; i++) {
 216         if ((ckpAttributes+i)-&gt;ulValueLen != CK_UNAVAILABLE_INFORMATION) {
 217             totalDataSize += (ckpAttributes+i)-&gt;ulValueLen;
 218             if ((ckpAttributes+i)-&gt;type == CKA_SENSITIVE) {
 219                  sensitiveAttributePosition = attributesCount;
 220                  TRACE0(&quot;DEBUG: GetNativeKeyInfo key is sensitive&quot;);
 221             }
 222             attributesCount++;
 223         }
 224     }
 225 
 226     if (netscapeAttributeValueNeeded) {
 227         attributesCount++;
 228     }
 229 
 230     // Allocate a single buffer to hold valid attributes and attribute&#39;s values
 231     // Buffer structure: [ attributes-size, [ ... attributes ... ],
 232     //                   values-size, [ ... values ... ], wrapped-key-size,
 233     //                   [ ... wrapped-key ... ] ]
 234     //     * sizes are expressed in bytes and data type is unsigned long
 235     totalCkAttributesSize = attributesCount * sizeof(CK_ATTRIBUTE);
 236     TRACE1(&quot;DEBUG: GetNativeKeyInfo attributesCount = %lu\n&quot;, attributesCount);
 237     TRACE1(&quot;DEBUG: GetNativeKeyInfo sizeof CK_ATTRIBUTE = %zu\n&quot;, sizeof(CK_ATTRIBUTE));
 238     TRACE1(&quot;DEBUG: GetNativeKeyInfo totalCkAttributesSize = %lu\n&quot;, totalCkAttributesSize);
 239     TRACE1(&quot;DEBUG: GetNativeKeyInfo totalDataSize = %lu\n&quot;, totalDataSize);
 240 
 241     totalNativeKeyInfoArraySize =
 242             totalCkAttributesSize + sizeof(unsigned long) * 3 + totalDataSize;
 243 
 244     TRACE1(&quot;DEBUG: GetNativeKeyInfo totalNativeKeyInfoArraySize = %lu\n&quot;, totalNativeKeyInfoArraySize);
 245 
 246     nativeKeyInfoArray = (*env)-&gt;NewByteArray(env, totalNativeKeyInfoArraySize);
 247     if (nativeKeyInfoArray == NULL) {
 248         goto cleanup;
 249     }
 250 
 251     nativeKeyInfoArrayRaw = (*env)-&gt;GetByteArrayElements(env, nativeKeyInfoArray,
 252             NULL);
 253     if (nativeKeyInfoArrayRaw == NULL) {
 254         goto cleanup;
 255     }
 256 
 257     wrappedKeySizePtr = nativeKeyInfoArrayRaw +
 258             sizeof(unsigned long)*2 + totalCkAttributesSize + totalDataSize;
 259     memcpy(nativeKeyInfoArrayRaw, &amp;totalCkAttributesSize, sizeof(unsigned long));
 260 
 261     memcpy(nativeKeyInfoArrayRaw + sizeof(unsigned long) + totalCkAttributesSize,
 262         &amp;totalDataSize, sizeof(unsigned long));
 263 
 264     memset(wrappedKeySizePtr, 0, sizeof(unsigned long));
 265 
 266     nativeKeyInfoArrayRawCkAttributes = nativeKeyInfoArrayRaw +
 267             sizeof(unsigned long);
 268     nativeKeyInfoArrayRawCkAttributesPtr = nativeKeyInfoArrayRawCkAttributes;
 269     nativeKeyInfoArrayRawDataPtr = nativeKeyInfoArrayRaw +
 270             totalCkAttributesSize + sizeof(unsigned long) * 2;
 271 
 272     for (i = 0; i &lt; CK_ATTRIBUTES_TEMPLATE_LENGTH; i++) {
 273         if ((ckpAttributes+i)-&gt;ulValueLen != CK_UNAVAILABLE_INFORMATION) {
 274             (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).type =
 275                     (ckpAttributes+i)-&gt;type;
 276             (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).ulValueLen =
 277                     (ckpAttributes+i)-&gt;ulValueLen;
 278             if ((ckpAttributes+i)-&gt;ulValueLen != 0) {
 279                 (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).pValue =
 280                         nativeKeyInfoArrayRawDataPtr;
 281             } else {
 282                 (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).pValue = 0;
 283             }
 284             nativeKeyInfoArrayRawDataPtr +=
 285                     (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).ulValueLen;
 286             nativeKeyInfoArrayRawCkAttributesPtr += sizeof(CK_ATTRIBUTE);
 287         }
 288     }
 289 
 290     TRACE0(&quot;DEBUG: GetNativeKeyInfo finished prepping nativeKeyInfoArray\n&quot;);
 291 
 292     // Get attribute&#39;s values
 293     rv = (*ckpFunctions-&gt;C_GetAttributeValue)(ckSessionHandle, ckObjectHandle,
 294             (CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes,
 295             attributesCount);
 296     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
 297         goto cleanup;
 298     }
 299 
 300     TRACE0(&quot;DEBUG: GetNativeKeyInfo 1st C_GetAttributeValue call passed\n&quot;);
 301 
 302     if (netscapeAttributeValueNeeded) {
 303         (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).type = CKA_NETSCAPE_DB;
 304         // Value is not needed, public key is not used
 305     }
 306 
 307     if ((sensitiveAttributePosition != (unsigned int)-1) &amp;&amp;
 308         *(CK_BBOOL*)(((CK_ATTRIBUTE_PTR)(((CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes)
 309                 +sensitiveAttributePosition))-&gt;pValue) == CK_TRUE) {
 310         // Key is sensitive. Need to extract it wrapped.
 311         if (jWrappingKeyHandle != -1) {
 312 
 313             jMechanismToCKMechanism(env, jWrappingMech, &amp;ckMechanism);
 314             rv = (*ckpFunctions-&gt;C_WrapKey)(ckSessionHandle, &amp;ckMechanism,
 315                     jLongToCKULong(jWrappingKeyHandle), ckObjectHandle,
 316                     NULL_PTR, &amp;ckWrappedKeyLength);
 317             if (ckWrappedKeyLength != 0) {
 318                 // Allocate space for getting the wrapped key
 319                 nativeKeyInfoWrappedKeyArray = (*env)-&gt;NewByteArray(env,
 320                         totalNativeKeyInfoArraySize + ckWrappedKeyLength);
 321                 if (nativeKeyInfoWrappedKeyArray == NULL) {
 322                     goto cleanup;
 323                 }
 324                 nativeKeyInfoWrappedKeyArrayRaw =
 325                         (*env)-&gt;GetByteArrayElements(env,
 326                                 nativeKeyInfoWrappedKeyArray, NULL);
 327                 if (nativeKeyInfoWrappedKeyArrayRaw == NULL) {
 328                     goto cleanup;
 329                 }
 330                 memcpy(nativeKeyInfoWrappedKeyArrayRaw, nativeKeyInfoArrayRaw,
 331                         totalNativeKeyInfoArraySize);
 332                 wrappedKeySizeWrappedKeyArrayPtr =
 333                         nativeKeyInfoWrappedKeyArrayRaw +
 334                         sizeof(unsigned long)*2 + totalCkAttributesSize +
 335                         totalDataSize;
 336                 memcpy(wrappedKeySizeWrappedKeyArrayPtr, &amp;ckWrappedKeyLength, sizeof(unsigned long));
 337                 TRACE1(&quot;DEBUG: GetNativeKeyInfo 1st C_WrapKey wrappedKeyLength = %lu\n&quot;, ckWrappedKeyLength);
 338 
 339                 wrappedKeyBufferPtr =
 340                         (CK_BYTE_PTR) (wrappedKeySizeWrappedKeyArrayPtr +
 341                         sizeof(unsigned long));
 342                 rv = (*ckpFunctions-&gt;C_WrapKey)(ckSessionHandle, &amp;ckMechanism,
 343                         jLongToCKULong(jWrappingKeyHandle),ckObjectHandle,
 344                         wrappedKeyBufferPtr, &amp;ckWrappedKeyLength);
 345                 if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
 346                     goto cleanup;
 347                 }
 348                 memcpy(wrappedKeySizeWrappedKeyArrayPtr, &amp;ckWrappedKeyLength, sizeof(unsigned long));
 349                 TRACE1(&quot;DEBUG: GetNativeKeyInfo 2nd C_WrapKey wrappedKeyLength = %lu\n&quot;, ckWrappedKeyLength);
 350             } else {
 351                 goto cleanup;
 352             }
 353         } else {
 354             goto cleanup;
 355         }
 356         returnValue = nativeKeyInfoWrappedKeyArray;
 357     } else {
 358         returnValue = nativeKeyInfoArray;
 359     }
 360 
 361 cleanup:
 362     if (ckpAttributes != NULL) {
 363         free(ckpAttributes);
 364     }
 365 
 366     if (nativeKeyInfoArrayRaw != NULL) {
 367         (*env)-&gt;ReleaseByteArrayElements(env, nativeKeyInfoArray,
 368                 nativeKeyInfoArrayRaw, 0);
 369     }
 370 
 371     if (nativeKeyInfoWrappedKeyArrayRaw != NULL) {
 372         (*env)-&gt;ReleaseByteArrayElements(env, nativeKeyInfoWrappedKeyArray,
 373                 nativeKeyInfoWrappedKeyArrayRaw, 0);
 374     }
 375 
 376     if (nativeKeyInfoArray != NULL &amp;&amp; returnValue != nativeKeyInfoArray) {
 377         (*env)-&gt;DeleteLocalRef(env, nativeKeyInfoArray);
 378     }
 379 
 380     if (nativeKeyInfoWrappedKeyArray != NULL
 381             &amp;&amp; returnValue != nativeKeyInfoWrappedKeyArray) {
 382         (*env)-&gt;DeleteLocalRef(env, nativeKeyInfoWrappedKeyArray);
 383     }
 384 
 385     return returnValue;
 386 }
 387 #endif
 388 
 389 #ifdef P11_ENABLE_CREATENATIVEKEY
 390 /*
 391  * Class:     sun_security_pkcs11_wrapper_PKCS11
 392  * Method:    createNativeKey
 393  * Signature: (J[BJLsun/security/pkcs11/wrapper/CK_MECHANISM;)J
 394  * Parametermapping:                          *PKCS11*
 395  * @param   jlong         jSessionHandle      CK_SESSION_HANDLE hSession
 396  * @param   jbyteArray    jNativeKeyInfo      -
 397  * @param   jlong         jWrappingKeyHandle  CK_OBJECT_HANDLE hObject
 398  * @param   jobject       jWrappingMech       CK_MECHANISM_PTR pMechanism
 399  * @return  jlong         jKeyHandle          CK_OBJECT_HANDLE hObject
 400  */
 401 JNIEXPORT jlong JNICALL
 402 Java_sun_security_pkcs11_wrapper_PKCS11_createNativeKey
 403     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jNativeKeyInfo,
 404     jlong jWrappingKeyHandle, jobject jWrappingMech)
 405 {
 406     CK_OBJECT_HANDLE ckObjectHandle;
 407     CK_RV rv;
 408     CK_SESSION_HANDLE ckSessionHandle = jLongToCKULong(jSessionHandle);
 409     jbyte* nativeKeyInfoArrayRaw = NULL;
 410     jlong jObjectHandle = 0L;
 411     unsigned long totalCkAttributesSize = 0UL;
 412     unsigned long nativeKeyInfoCkAttributesCount = 0UL;
 413     jbyte* nativeKeyInfoArrayRawCkAttributes = NULL;
 414     jbyte* nativeKeyInfoArrayRawCkAttributesPtr = NULL;
 415     jbyte* nativeKeyInfoArrayRawDataPtr = NULL;
 416     unsigned long totalDataSize = 0UL;
 417     jbyte* wrappedKeySizePtr = NULL;
 418     unsigned int i = 0U;
 419     CK_MECHANISM ckMechanism;
 420     char iv[16] = {0x0};
 421     CK_ULONG ckWrappedKeyLength = 0UL;
 422     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 423 
 424     if (ckpFunctions == NULL) { goto cleanup; }
 425 
 426     nativeKeyInfoArrayRaw =
 427             (*env)-&gt;GetByteArrayElements(env, jNativeKeyInfo, NULL);
 428     if (nativeKeyInfoArrayRaw == NULL) {
 429         goto cleanup;
 430     }
 431 
 432     memcpy(&amp;totalCkAttributesSize, nativeKeyInfoArrayRaw, sizeof(unsigned long));
 433     TRACE1(&quot;DEBUG: createNativeKey totalCkAttributesSize = %lu\n&quot;, totalCkAttributesSize);
 434     nativeKeyInfoCkAttributesCount = totalCkAttributesSize/sizeof(CK_ATTRIBUTE);
 435     TRACE1(&quot;DEBUG: createNativeKey nativeKeyInfoCkAttributesCount = %lu\n&quot;, nativeKeyInfoCkAttributesCount);
 436 
 437     nativeKeyInfoArrayRawCkAttributes = nativeKeyInfoArrayRaw +
 438             sizeof(unsigned long);
 439     nativeKeyInfoArrayRawCkAttributesPtr = nativeKeyInfoArrayRawCkAttributes;
 440     nativeKeyInfoArrayRawDataPtr = nativeKeyInfoArrayRaw +
 441             totalCkAttributesSize + sizeof(unsigned long) * 2;
 442     memcpy(&amp;totalDataSize, (nativeKeyInfoArrayRaw + totalCkAttributesSize + sizeof(unsigned long)),
 443             sizeof(unsigned long));
 444     TRACE1(&quot;DEBUG: createNativeKey totalDataSize = %lu\n&quot;, totalDataSize);
 445 
 446     wrappedKeySizePtr = nativeKeyInfoArrayRaw +
 447             sizeof(unsigned long)*2 + totalCkAttributesSize + totalDataSize;
 448 
 449     memcpy(&amp;ckWrappedKeyLength, wrappedKeySizePtr, sizeof(unsigned long));
 450     TRACE1(&quot;DEBUG: createNativeKey wrappedKeyLength = %lu\n&quot;, ckWrappedKeyLength);
 451 
 452     for (i = 0; i &lt; nativeKeyInfoCkAttributesCount; i++) {
 453         if ((*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).ulValueLen
 454                 &gt; 0) {
 455             (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).pValue =
 456                     nativeKeyInfoArrayRawDataPtr;
 457         }
 458         nativeKeyInfoArrayRawDataPtr +=
 459                 (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).ulValueLen;
 460         nativeKeyInfoArrayRawCkAttributesPtr += sizeof(CK_ATTRIBUTE);
 461     }
 462 
 463     if (ckWrappedKeyLength == 0) {
 464         // Not a wrapped key
 465         rv = (*ckpFunctions-&gt;C_CreateObject)(ckSessionHandle,
 466                 (CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes,
 467                 jLongToCKULong(nativeKeyInfoCkAttributesCount), &amp;ckObjectHandle);
 468     } else {
 469         // Wrapped key
 470         jMechanismToCKMechanism(env, jWrappingMech, &amp;ckMechanism);
 471         rv = (*ckpFunctions-&gt;C_UnwrapKey)(ckSessionHandle, &amp;ckMechanism,
 472                 jLongToCKULong(jWrappingKeyHandle),
 473                 (CK_BYTE_PTR)(wrappedKeySizePtr + sizeof(unsigned long)),
 474                 ckWrappedKeyLength,
 475                 (CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes,
 476                 jLongToCKULong(nativeKeyInfoCkAttributesCount),
 477                 &amp;ckObjectHandle);
 478     }
 479     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
 480         goto cleanup;
 481     }
 482 
 483     jObjectHandle = ckULongToJLong(ckObjectHandle);
 484 
 485 cleanup:
 486 
 487     if (nativeKeyInfoArrayRaw != NULL) {
 488         (*env)-&gt;ReleaseByteArrayElements(env, jNativeKeyInfo,
 489                 nativeKeyInfoArrayRaw, JNI_ABORT);
 490     }
 491 
 492     return jObjectHandle;
 493 }
 494 #endif
 495 
 496 #ifdef P11_ENABLE_C_GENERATEKEY
 497 /*
 498  * Class:     sun_security_pkcs11_wrapper_PKCS11
 499  * Method:    C_GenerateKey
 500  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;)J
 501  * Parametermapping:                    *PKCS11*
 502  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 503  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
 504  * @param   jobjectArray jTemplate      CK_ATTRIBUTE_PTR pTemplate
 505  *                                      CK_ULONG ulCount
 506  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE_PTR phKey
 507  */
 508 JNIEXPORT jlong JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1GenerateKey
 509     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jobjectArray jTemplate)
 510 {
 511     CK_SESSION_HANDLE ckSessionHandle;
 512     CK_MECHANISM ckMechanism;
 513     CK_ATTRIBUTE_PTR ckpAttributes = NULL_PTR;
 514     CK_ULONG ckAttributesLength;
 515     CK_OBJECT_HANDLE ckKeyHandle = 0;
 516     jlong jKeyHandle = 0L;
 517     CK_RV rv;
 518 
 519     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 520     if (ckpFunctions == NULL) { return 0L; }
 521 
 522     ckSessionHandle = jLongToCKULong(jSessionHandle);
 523     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);
 524     if ((*env)-&gt;ExceptionCheck(env)) { return 0L ; }
 525 
 526     jAttributeArrayToCKAttributeArray(env, jTemplate, &amp;ckpAttributes, &amp;ckAttributesLength);
 527     if ((*env)-&gt;ExceptionCheck(env)) {
 528         if (ckMechanism.pParameter != NULL_PTR) {
 529             free(ckMechanism.pParameter);
 530         }
 531         return 0L;
 532     }
 533 
 534     rv = (*ckpFunctions-&gt;C_GenerateKey)(ckSessionHandle, &amp;ckMechanism, ckpAttributes, ckAttributesLength, &amp;ckKeyHandle);
 535 
 536     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
 537         jKeyHandle = ckULongToJLong(ckKeyHandle);
 538 
 539         /* cheack, if we must give a initialization vector back to Java */
 540         switch (ckMechanism.mechanism) {
 541         case CKM_PBE_MD2_DES_CBC:
 542         case CKM_PBE_MD5_DES_CBC:
 543         case CKM_PBE_MD5_CAST_CBC:
 544         case CKM_PBE_MD5_CAST3_CBC:
 545         case CKM_PBE_MD5_CAST128_CBC:
 546         /* case CKM_PBE_MD5_CAST5_CBC:  the same as CKM_PBE_MD5_CAST128_CBC */
 547         case CKM_PBE_SHA1_CAST128_CBC:
 548         /* case CKM_PBE_SHA1_CAST5_CBC: the same as CKM_PBE_SHA1_CAST128_CBC */
 549             /* we must copy back the initialization vector to the jMechanism object */
 550             copyBackPBEInitializationVector(env, &amp;ckMechanism, jMechanism);
 551             break;
 552         }
 553     }
 554 
 555     if (ckMechanism.pParameter != NULL_PTR) {
 556         free(ckMechanism.pParameter);
 557     }
 558     freeCKAttributeArray(ckpAttributes, ckAttributesLength);
 559 
 560     return jKeyHandle ;
 561 }
 562 #endif
 563 
 564 #ifdef P11_ENABLE_C_GENERATEKEYPAIR
 565 /*
 566  * Class:     sun_security_pkcs11_wrapper_PKCS11
 567  * Method:    C_GenerateKeyPair
 568  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;)[J
 569  * Parametermapping:                          *PKCS11*
 570  * @param   jlong jSessionHandle              CK_SESSION_HANDLE hSession
 571  * @param   jobject jMechanism                CK_MECHANISM_PTR pMechanism
 572  * @param   jobjectArray jPublicKeyTemplate   CK_ATTRIBUTE_PTR pPublicKeyTemplate
 573  *                                            CK_ULONG ulPublicKeyAttributeCount
 574  * @param   jobjectArray jPrivateKeyTemplate  CK_ATTRIBUTE_PTR pPrivateKeyTemplate
 575  *                                            CK_ULONG ulPrivateKeyAttributeCount
 576  * @return  jlongArray jKeyHandles            CK_OBJECT_HANDLE_PTR phPublicKey
 577  *                                            CK_OBJECT_HANDLE_PTR phPublicKey
 578  */
 579 JNIEXPORT jlongArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1GenerateKeyPair
 580     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism,
 581      jobjectArray jPublicKeyTemplate, jobjectArray jPrivateKeyTemplate)
 582 {
 583     CK_SESSION_HANDLE ckSessionHandle;
 584     CK_MECHANISM ckMechanism;
 585     CK_ATTRIBUTE_PTR ckpPublicKeyAttributes = NULL_PTR;
 586     CK_ATTRIBUTE_PTR ckpPrivateKeyAttributes = NULL_PTR;
 587     CK_ULONG ckPublicKeyAttributesLength;
 588     CK_ULONG ckPrivateKeyAttributesLength;
 589     CK_OBJECT_HANDLE_PTR ckpPublicKeyHandle;  /* pointer to Public Key */
 590     CK_OBJECT_HANDLE_PTR ckpPrivateKeyHandle; /* pointer to Private Key */
 591     CK_OBJECT_HANDLE_PTR ckpKeyHandles;     /* pointer to array with Public and Private Key */
 592     jlongArray jKeyHandles = NULL;
 593     CK_RV rv;
 594     int attempts;
 595     const int MAX_ATTEMPTS = 3;
 596 
 597     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 598     if (ckpFunctions == NULL) { return NULL; }
 599 
 600     ckSessionHandle = jLongToCKULong(jSessionHandle);
 601     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);
 602     if ((*env)-&gt;ExceptionCheck(env)) { return NULL; }
 603 
 604     ckpKeyHandles = (CK_OBJECT_HANDLE_PTR) malloc(2 * sizeof(CK_OBJECT_HANDLE));
 605     if (ckpKeyHandles == NULL) {
 606         if (ckMechanism.pParameter != NULL_PTR) {
 607             free(ckMechanism.pParameter);
 608         }
 609         throwOutOfMemoryError(env, 0);
 610         return NULL;
 611     }
 612     ckpPublicKeyHandle = ckpKeyHandles;   /* first element of array is Public Key */
 613     ckpPrivateKeyHandle = (ckpKeyHandles + 1);  /* second element of array is Private Key */
 614 
 615     jAttributeArrayToCKAttributeArray(env, jPublicKeyTemplate, &amp;ckpPublicKeyAttributes, &amp;ckPublicKeyAttributesLength);
 616     if ((*env)-&gt;ExceptionCheck(env)) {
 617         if (ckMechanism.pParameter != NULL_PTR) {
 618             free(ckMechanism.pParameter);
 619         }
 620         free(ckpKeyHandles);
 621         return NULL;
 622     }
 623 
 624     jAttributeArrayToCKAttributeArray(env, jPrivateKeyTemplate, &amp;ckpPrivateKeyAttributes, &amp;ckPrivateKeyAttributesLength);
 625     if ((*env)-&gt;ExceptionCheck(env)) {
 626         if (ckMechanism.pParameter != NULL_PTR) {
 627             free(ckMechanism.pParameter);
 628         }
 629         free(ckpKeyHandles);
 630         freeCKAttributeArray(ckpPublicKeyAttributes, ckPublicKeyAttributesLength);
 631         return NULL;
 632     }
 633 
 634     /*
 635      * Workaround for NSS bug 1012786:
 636      *
 637      * Key generation may fail with CKR_FUNCTION_FAILED error
 638      * if there is insufficient entropy to generate a random key.
 639      *
 640      * PKCS11 spec says the following about CKR_FUNCTION_FAILED error
 641      * (see section 11.1.1):
 642      *
 643      *      ... In any event, although the function call failed, the situation
 644      *      is not necessarily totally hopeless, as it is likely to be
 645      *      when CKR_GENERAL_ERROR is returned. Depending on what the root cause of
 646      *      the error actually was, it is possible that an attempt
 647      *      to make the exact same function call again would succeed.
 648      *
 649      * Call C_GenerateKeyPair() several times if CKR_FUNCTION_FAILED occurs.
 650      */
 651     for (attempts = 0; attempts &lt; MAX_ATTEMPTS; attempts++) {
 652         rv = (*ckpFunctions-&gt;C_GenerateKeyPair)(ckSessionHandle, &amp;ckMechanism,
 653                         ckpPublicKeyAttributes, ckPublicKeyAttributesLength,
 654                         ckpPrivateKeyAttributes, ckPrivateKeyAttributesLength,
 655                         ckpPublicKeyHandle, ckpPrivateKeyHandle);
 656         if (rv == CKR_FUNCTION_FAILED) {
 657             printDebug(&quot;C_1GenerateKeyPair(): C_GenerateKeyPair() failed \
 658                     with CKR_FUNCTION_FAILED error, try again\n&quot;);
 659         } else {
 660             break;
 661         }
 662     }
 663 
 664     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
 665         jKeyHandles = ckULongArrayToJLongArray(env, ckpKeyHandles, 2);
 666     }
 667 
 668     if(ckMechanism.pParameter != NULL_PTR) {
 669         free(ckMechanism.pParameter);
 670     }
 671     free(ckpKeyHandles);
 672     freeCKAttributeArray(ckpPublicKeyAttributes, ckPublicKeyAttributesLength);
 673     freeCKAttributeArray(ckpPrivateKeyAttributes, ckPrivateKeyAttributesLength);
 674 
 675     return jKeyHandles ;
 676 }
 677 #endif
 678 
 679 #ifdef P11_ENABLE_C_WRAPKEY
 680 /*
 681  * Class:     sun_security_pkcs11_wrapper_PKCS11
 682  * Method:    C_WrapKey
 683  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;JJ)[B
 684  * Parametermapping:                    *PKCS11*
 685  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 686  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
 687  * @param   jlong jWrappingKeyHandle    CK_OBJECT_HANDLE hWrappingKey
 688  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey
 689  * @return  jbyteArray jWrappedKey      CK_BYTE_PTR pWrappedKey
 690  *                                      CK_ULONG_PTR pulWrappedKeyLen
 691  */
 692 JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1WrapKey
 693     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jWrappingKeyHandle, jlong jKeyHandle)
 694 {
 695     CK_SESSION_HANDLE ckSessionHandle;
 696     CK_MECHANISM ckMechanism;
 697     CK_OBJECT_HANDLE ckWrappingKeyHandle;
 698     CK_OBJECT_HANDLE ckKeyHandle;
 699     jbyteArray jWrappedKey = NULL;
 700     CK_RV rv;
 701     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
 702     CK_BYTE_PTR ckpWrappedKey = BUF;
 703     CK_ULONG ckWrappedKeyLength = MAX_STACK_BUFFER_LEN;
 704 
 705     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 706     if (ckpFunctions == NULL) { return NULL; }
 707 
 708     ckSessionHandle = jLongToCKULong(jSessionHandle);
 709     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);
 710     if ((*env)-&gt;ExceptionCheck(env)) { return NULL; }
 711 
 712     ckWrappingKeyHandle = jLongToCKULong(jWrappingKeyHandle);
 713     ckKeyHandle = jLongToCKULong(jKeyHandle);
 714 
 715     rv = (*ckpFunctions-&gt;C_WrapKey)(ckSessionHandle, &amp;ckMechanism, ckWrappingKeyHandle, ckKeyHandle, ckpWrappedKey, &amp;ckWrappedKeyLength);
 716     if (rv == CKR_BUFFER_TOO_SMALL) {
 717         ckpWrappedKey = (CK_BYTE_PTR) malloc(ckWrappedKeyLength);
 718         if (ckpWrappedKey == NULL) {
 719             if (ckMechanism.pParameter != NULL_PTR) {
 720                 free(ckMechanism.pParameter);
 721             }
 722             throwOutOfMemoryError(env, 0);
 723             return NULL;
 724         }
 725 
 726         rv = (*ckpFunctions-&gt;C_WrapKey)(ckSessionHandle, &amp;ckMechanism, ckWrappingKeyHandle, ckKeyHandle, ckpWrappedKey, &amp;ckWrappedKeyLength);
 727     }
 728     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
 729         jWrappedKey = ckByteArrayToJByteArray(env, ckpWrappedKey, ckWrappedKeyLength);
 730     }
 731 
 732     if (ckpWrappedKey != BUF) { free(ckpWrappedKey); }
 733     if (ckMechanism.pParameter != NULL_PTR) {
 734         free(ckMechanism.pParameter);
 735     }
 736     return jWrappedKey ;
 737 }
 738 #endif
 739 
 740 #ifdef P11_ENABLE_C_UNWRAPKEY
 741 /*
 742  * Class:     sun_security_pkcs11_wrapper_PKCS11
 743  * Method:    C_UnwrapKey
 744  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J[B[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;)J
 745  * Parametermapping:                    *PKCS11*
 746  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 747  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
 748  * @param   jlong jUnwrappingKeyHandle  CK_OBJECT_HANDLE hUnwrappingKey
 749  * @param   jbyteArray jWrappedKey      CK_BYTE_PTR pWrappedKey
 750  *                                      CK_ULONG_PTR pulWrappedKeyLen
 751  * @param   jobjectArray jTemplate      CK_ATTRIBUTE_PTR pTemplate
 752  *                                      CK_ULONG ulCount
 753  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE_PTR phKey
 754  */
 755 JNIEXPORT jlong JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1UnwrapKey
 756     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jUnwrappingKeyHandle,
 757      jbyteArray jWrappedKey, jobjectArray jTemplate)
 758 {
 759     CK_SESSION_HANDLE ckSessionHandle;
 760     CK_MECHANISM ckMechanism;
 761     CK_OBJECT_HANDLE ckUnwrappingKeyHandle;
 762     CK_BYTE_PTR ckpWrappedKey = NULL_PTR;
 763     CK_ULONG ckWrappedKeyLength;
 764     CK_ATTRIBUTE_PTR ckpAttributes = NULL_PTR;
 765     CK_ULONG ckAttributesLength;
 766     CK_OBJECT_HANDLE ckKeyHandle = 0;
 767     jlong jKeyHandle = 0L;
 768     CK_RV rv;
 769 
 770     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 771     if (ckpFunctions == NULL) { return 0L; }
 772 
 773     ckSessionHandle = jLongToCKULong(jSessionHandle);
 774     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);
 775     if ((*env)-&gt;ExceptionCheck(env)) { return 0L; }
 776 
 777     ckUnwrappingKeyHandle = jLongToCKULong(jUnwrappingKeyHandle);
 778     jByteArrayToCKByteArray(env, jWrappedKey, &amp;ckpWrappedKey, &amp;ckWrappedKeyLength);
 779     if ((*env)-&gt;ExceptionCheck(env)) {
 780         if (ckMechanism.pParameter != NULL_PTR) {
 781             free(ckMechanism.pParameter);
 782         }
 783         return 0L;
 784     }
 785 
 786     jAttributeArrayToCKAttributeArray(env, jTemplate, &amp;ckpAttributes, &amp;ckAttributesLength);
 787     if ((*env)-&gt;ExceptionCheck(env)) {
 788         if (ckMechanism.pParameter != NULL_PTR) {
 789             free(ckMechanism.pParameter);
 790         }
 791         free(ckpWrappedKey);
 792         return 0L;
 793     }
 794 
 795 
 796     rv = (*ckpFunctions-&gt;C_UnwrapKey)(ckSessionHandle, &amp;ckMechanism, ckUnwrappingKeyHandle,
 797                  ckpWrappedKey, ckWrappedKeyLength,
 798                  ckpAttributes, ckAttributesLength, &amp;ckKeyHandle);
 799 
 800     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
 801         jKeyHandle = ckLongToJLong(ckKeyHandle);
 802 
 803 #if 0
 804         /* cheack, if we must give a initialization vector back to Java */
 805         if (ckMechanism.mechanism == CKM_KEY_WRAP_SET_OAEP) {
 806             /* we must copy back the unwrapped key info to the jMechanism object */
 807             copyBackSetUnwrappedKey(env, &amp;ckMechanism, jMechanism);
 808         }
 809 #endif
 810     }
 811 
 812     if (ckMechanism.pParameter != NULL_PTR) {
 813         free(ckMechanism.pParameter);
 814     }
 815     freeCKAttributeArray(ckpAttributes, ckAttributesLength);
 816     free(ckpWrappedKey);
 817 
 818     return jKeyHandle ;
 819 }
 820 #endif
 821 
 822 #ifdef P11_ENABLE_C_DERIVEKEY
 823 
 824 static void freeMasterKeyDeriveParams(CK_SSL3_RANDOM_DATA *RandomInfo, CK_VERSION_PTR pVersion) {
 825     if (RandomInfo-&gt;pClientRandom != NULL) {
 826         free(RandomInfo-&gt;pClientRandom);
 827     }
 828     if (RandomInfo-&gt;pServerRandom != NULL) {
 829         free(RandomInfo-&gt;pServerRandom);
 830     }
 831     if (pVersion != NULL) {
 832         free(pVersion);
 833     }
 834 }
 835 
 836 void ssl3FreeMasterKeyDeriveParams(CK_MECHANISM_PTR ckMechanism) {
 837     CK_SSL3_MASTER_KEY_DERIVE_PARAMS *params = (CK_SSL3_MASTER_KEY_DERIVE_PARAMS *) ckMechanism-&gt;pParameter;
 838     if (params == NULL) {
 839         return;
 840     }
 841     freeMasterKeyDeriveParams(&amp;(params-&gt;RandomInfo), params-&gt;pVersion);
 842 }
 843 
 844 void tls12FreeMasterKeyDeriveParams(CK_MECHANISM_PTR ckMechanism) {
 845     CK_TLS12_MASTER_KEY_DERIVE_PARAMS *params =
 846             (CK_TLS12_MASTER_KEY_DERIVE_PARAMS *)ckMechanism-&gt;pParameter;
 847     if (params == NULL) {
 848         return;
 849     }
 850     freeMasterKeyDeriveParams(&amp;(params-&gt;RandomInfo), params-&gt;pVersion);
 851 }
 852 
 853 void freeEcdh1DeriveParams(CK_MECHANISM_PTR ckMechanism) {
 854     CK_ECDH1_DERIVE_PARAMS *params =
 855             (CK_ECDH1_DERIVE_PARAMS *)ckMechanism-&gt;pParameter;
 856     if (params == NULL) {
 857         return;
 858     }
 859 
 860     if (params-&gt;pSharedData != NULL) {
 861         free(params-&gt;pSharedData);
 862     }
 863     if (params-&gt;pPublicData != NULL) {
 864         free(params-&gt;pPublicData);
 865     }
 866 }
 867 
 868 /*
 869  * Copy back the PRF output to Java.
 870  */
 871 void copyBackTLSPrfParams(JNIEnv *env, CK_MECHANISM *ckMechanism, jobject jMechanism)
 872 {
 873     jclass jMechanismClass, jTLSPrfParamsClass;
 874     CK_TLS_PRF_PARAMS *ckTLSPrfParams;
 875     jobject jTLSPrfParams;
 876     jfieldID fieldID;
 877     CK_MECHANISM_TYPE ckMechanismType;
 878     jlong jMechanismType;
 879     CK_BYTE_PTR output;
 880     jobject jOutput;
 881     jint jLength;
 882     jbyte* jBytes;
 883     int i;
 884 
 885     /* get mechanism */
 886     jMechanismClass = (*env)-&gt;FindClass(env, CLASS_MECHANISM);
 887     if (jMechanismClass == NULL) { return; }
 888     fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;mechanism&quot;, &quot;J&quot;);
 889     if (fieldID == NULL) { return; }
 890     jMechanismType = (*env)-&gt;GetLongField(env, jMechanism, fieldID);
 891     ckMechanismType = jLongToCKULong(jMechanismType);
 892     if (ckMechanismType != ckMechanism-&gt;mechanism) {
 893         /* we do not have maching types, this should not occur */
 894         return;
 895     }
 896 
 897     /* get the native CK_TLS_PRF_PARAMS */
 898     ckTLSPrfParams = (CK_TLS_PRF_PARAMS *) ckMechanism-&gt;pParameter;
 899     if (ckTLSPrfParams != NULL_PTR) {
 900         /* get the Java CK_TLS_PRF_PARAMS object (pParameter) */
 901         fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;pParameter&quot;, &quot;Ljava/lang/Object;&quot;);
 902         if (fieldID == NULL) { return; }
 903         jTLSPrfParams = (*env)-&gt;GetObjectField(env, jMechanism, fieldID);
 904 
 905         /* copy back the client IV */
 906         jTLSPrfParamsClass = (*env)-&gt;FindClass(env, CLASS_TLS_PRF_PARAMS);
 907         if (jTLSPrfParamsClass == NULL) { return; }
 908         fieldID = (*env)-&gt;GetFieldID(env, jTLSPrfParamsClass, &quot;pOutput&quot;, &quot;[B&quot;);
 909         if (fieldID == NULL) { return; }
 910         jOutput = (*env)-&gt;GetObjectField(env, jTLSPrfParams, fieldID);
 911         output = ckTLSPrfParams-&gt;pOutput;
 912 
 913         // Note: we assume that the token returned exactly as many bytes as we
 914         // requested. Anything else would not make sense.
 915         if (jOutput != NULL) {
 916             jLength = (*env)-&gt;GetArrayLength(env, jOutput);
 917             jBytes = (*env)-&gt;GetByteArrayElements(env, jOutput, NULL);
 918             if (jBytes == NULL) { return; }
 919 
 920             /* copy the bytes to the Java buffer */
 921             for (i=0; i &lt; jLength; i++) {
 922                 jBytes[i] = ckByteToJByte(output[i]);
 923             }
 924             /* copy back the Java buffer to the object */
 925             (*env)-&gt;ReleaseByteArrayElements(env, jOutput, jBytes, 0);
 926         }
 927 
 928         // free malloc&#39;d data
 929         free(ckTLSPrfParams-&gt;pSeed);
 930         free(ckTLSPrfParams-&gt;pLabel);
 931         free(ckTLSPrfParams-&gt;pulOutputLen);
 932         free(ckTLSPrfParams-&gt;pOutput);
 933     }
 934 }
 935 
 936 /*
 937  * Class:     sun_security_pkcs11_wrapper_PKCS11
 938  * Method:    C_DeriveKey
 939  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;)J
 940  * Parametermapping:                    *PKCS11*
 941  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 942  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
 943  * @param   jlong jBaseKeyHandle        CK_OBJECT_HANDLE hBaseKey
 944  * @param   jobjectArray jTemplate      CK_ATTRIBUTE_PTR pTemplate
 945  *                                      CK_ULONG ulCount
 946  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE_PTR phKey
 947  */
 948 JNIEXPORT jlong JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1DeriveKey
 949     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jBaseKeyHandle, jobjectArray jTemplate)
 950 {
 951     CK_SESSION_HANDLE ckSessionHandle;
 952     CK_MECHANISM ckMechanism;
 953     CK_OBJECT_HANDLE ckBaseKeyHandle;
 954     CK_ATTRIBUTE_PTR ckpAttributes = NULL_PTR;
 955     CK_ULONG ckAttributesLength;
 956     CK_OBJECT_HANDLE ckKeyHandle = 0;
 957     jlong jKeyHandle = 0L;
 958     CK_RV rv;
 959     CK_OBJECT_HANDLE_PTR phKey = &amp;ckKeyHandle;
 960 
 961     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 962     if (ckpFunctions == NULL) { return 0L; }
 963 
 964     ckSessionHandle = jLongToCKULong(jSessionHandle);
 965     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);
 966     if ((*env)-&gt;ExceptionCheck(env)) { return 0L; }
 967 
 968     ckBaseKeyHandle = jLongToCKULong(jBaseKeyHandle);
 969     jAttributeArrayToCKAttributeArray(env, jTemplate, &amp;ckpAttributes, &amp;ckAttributesLength);
 970     if ((*env)-&gt;ExceptionCheck(env)) {
 971         if (ckMechanism.pParameter != NULL_PTR) {
 972             free(ckMechanism.pParameter);
 973         }
 974         return 0L;
 975     }
 976 
 977     switch (ckMechanism.mechanism) {
 978     case CKM_SSL3_KEY_AND_MAC_DERIVE:
 979     case CKM_TLS_KEY_AND_MAC_DERIVE:
 980     case CKM_TLS12_KEY_AND_MAC_DERIVE:
 981     case CKM_TLS_PRF:
 982         // these mechanism do not return a key handle via phKey
 983         // set to NULL in case pedantic implementations check for it
 984         phKey = NULL;
 985         break;
 986     default:
 987         // empty
 988         break;
 989     }
 990 
 991     rv = (*ckpFunctions-&gt;C_DeriveKey)(ckSessionHandle, &amp;ckMechanism, ckBaseKeyHandle,
 992                  ckpAttributes, ckAttributesLength, phKey);
 993 
 994     jKeyHandle = ckLongToJLong(ckKeyHandle);
 995 
 996     freeCKAttributeArray(ckpAttributes, ckAttributesLength);
 997 
 998     switch (ckMechanism.mechanism) {
 999     case CKM_SSL3_MASTER_KEY_DERIVE:
1000     case CKM_TLS_MASTER_KEY_DERIVE:
1001         /* we must copy back the client version */
1002         ssl3CopyBackClientVersion(env, &amp;ckMechanism, jMechanism);
1003         ssl3FreeMasterKeyDeriveParams(&amp;ckMechanism);
1004         break;
1005     case CKM_TLS12_MASTER_KEY_DERIVE:
1006         tls12CopyBackClientVersion(env, &amp;ckMechanism, jMechanism);
1007         tls12FreeMasterKeyDeriveParams(&amp;ckMechanism);
1008         break;
1009     case CKM_SSL3_MASTER_KEY_DERIVE_DH:
1010     case CKM_TLS_MASTER_KEY_DERIVE_DH:
1011         ssl3FreeMasterKeyDeriveParams(&amp;ckMechanism);
1012         break;
1013     case CKM_TLS12_MASTER_KEY_DERIVE_DH:
1014         tls12FreeMasterKeyDeriveParams(&amp;ckMechanism);
1015         break;
1016     case CKM_SSL3_KEY_AND_MAC_DERIVE:
1017     case CKM_TLS_KEY_AND_MAC_DERIVE:
1018         /* we must copy back the unwrapped key info to the jMechanism object */
1019         ssl3CopyBackKeyMatParams(env, &amp;ckMechanism, jMechanism);
1020         break;
1021     case CKM_TLS12_KEY_AND_MAC_DERIVE:
1022         /* we must copy back the unwrapped key info to the jMechanism object */
1023         tls12CopyBackKeyMatParams(env, &amp;ckMechanism, jMechanism);
1024         break;
1025     case CKM_TLS_PRF:
1026         copyBackTLSPrfParams(env, &amp;ckMechanism, jMechanism);
1027         break;
1028     case CKM_ECDH1_DERIVE:
1029         freeEcdh1DeriveParams(&amp;ckMechanism);
1030         break;
1031     default:
1032         // empty
1033         break;
1034     }
1035 
1036     if (ckMechanism.pParameter != NULL_PTR) {
1037         free(ckMechanism.pParameter);
1038     }
1039     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return 0L ; }
1040 
1041     return jKeyHandle ;
1042 }
1043 
1044 static void copyBackClientVersion(JNIEnv *env, CK_MECHANISM *ckMechanism, jobject jMechanism,
1045         CK_VERSION *ckVersion, const char *class_master_key_derive_params)
1046 {
1047     jclass jMasterKeyDeriveParamsClass, jMechanismClass, jVersionClass;
1048     jobject jMasterKeyDeriveParams;
1049     jfieldID fieldID;
1050     CK_MECHANISM_TYPE ckMechanismType;
1051     jlong jMechanismType;
1052     jobject jVersion;
1053 
1054     /* get mechanism */
1055     jMechanismClass = (*env)-&gt;FindClass(env, CLASS_MECHANISM);
1056     if (jMechanismClass == NULL) { return; }
1057     fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;mechanism&quot;, &quot;J&quot;);
1058     if (fieldID == NULL) { return; }
1059     jMechanismType = (*env)-&gt;GetLongField(env, jMechanism, fieldID);
1060     ckMechanismType = jLongToCKULong(jMechanismType);
1061     if (ckMechanismType != ckMechanism-&gt;mechanism) {
1062         /* we do not have maching types, this should not occur */
1063         return;
1064     }
1065 
1066     if (ckVersion != NULL_PTR) {
1067       /* get the Java CK_SSL3_MASTER_KEY_DERIVE_PARAMS (pParameter) */
1068       fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;pParameter&quot;, &quot;Ljava/lang/Object;&quot;);
1069       if (fieldID == NULL) { return; }
1070 
1071       jMasterKeyDeriveParams = (*env)-&gt;GetObjectField(env, jMechanism, fieldID);
1072 
1073       /* get the Java CK_VERSION */
1074       jMasterKeyDeriveParamsClass = (*env)-&gt;FindClass(env, class_master_key_derive_params);
1075       if (jMasterKeyDeriveParamsClass == NULL) { return; }
1076       fieldID = (*env)-&gt;GetFieldID(env, jMasterKeyDeriveParamsClass,
1077               &quot;pVersion&quot;, &quot;L&quot;CLASS_VERSION&quot;;&quot;);
1078       if (fieldID == NULL) { return; }
1079       jVersion = (*env)-&gt;GetObjectField(env, jMasterKeyDeriveParams, fieldID);
1080 
1081       /* now copy back the version from the native structure to the Java structure */
1082 
1083       /* copy back the major version */
1084       jVersionClass = (*env)-&gt;FindClass(env, CLASS_VERSION);
1085       if (jVersionClass == NULL) { return; }
1086       fieldID = (*env)-&gt;GetFieldID(env, jVersionClass, &quot;major&quot;, &quot;B&quot;);
1087       if (fieldID == NULL) { return; }
1088       (*env)-&gt;SetByteField(env, jVersion, fieldID, ckByteToJByte(ckVersion-&gt;major));
1089 
1090       /* copy back the minor version */
1091       fieldID = (*env)-&gt;GetFieldID(env, jVersionClass, &quot;minor&quot;, &quot;B&quot;);
1092       if (fieldID == NULL) { return; }
1093       (*env)-&gt;SetByteField(env, jVersion, fieldID, ckByteToJByte(ckVersion-&gt;minor));
1094     }
1095 }
1096 
1097 /*
1098  * Copy back the client version information from the native
1099  * structure to the Java object. This is only used for
1100  * CKM_SSL3_MASTER_KEY_DERIVE and CKM_TLS_MASTER_KEY_DERIVE
1101  * mechanisms when used for deriving a key.
1102  *
1103  */
1104 void ssl3CopyBackClientVersion(JNIEnv *env, CK_MECHANISM *ckMechanism,
1105         jobject jMechanism)
1106 {
1107     CK_SSL3_MASTER_KEY_DERIVE_PARAMS *ckSSL3MasterKeyDeriveParams;
1108     ckSSL3MasterKeyDeriveParams =
1109             (CK_SSL3_MASTER_KEY_DERIVE_PARAMS *)ckMechanism-&gt;pParameter;
1110     if (ckSSL3MasterKeyDeriveParams != NULL_PTR) {
1111         copyBackClientVersion(env, ckMechanism, jMechanism,
1112                 ckSSL3MasterKeyDeriveParams-&gt;pVersion,
1113                 CLASS_SSL3_MASTER_KEY_DERIVE_PARAMS);
1114     }
1115 }
1116 
1117 /*
1118  * Copy back the client version information from the native
1119  * structure to the Java object. This is only used for
1120  * CKM_TLS12_MASTER_KEY_DERIVE mechanism when used for deriving a key.
1121  *
1122  */
1123 void tls12CopyBackClientVersion(JNIEnv *env, CK_MECHANISM *ckMechanism,
1124         jobject jMechanism)
1125 {
1126     CK_TLS12_MASTER_KEY_DERIVE_PARAMS *ckTLS12MasterKeyDeriveParams;
1127     ckTLS12MasterKeyDeriveParams =
1128             (CK_TLS12_MASTER_KEY_DERIVE_PARAMS *)ckMechanism-&gt;pParameter;
1129     if (ckTLS12MasterKeyDeriveParams != NULL_PTR) {
1130         copyBackClientVersion(env, ckMechanism, jMechanism,
1131                 ckTLS12MasterKeyDeriveParams-&gt;pVersion,
1132                 CLASS_TLS12_MASTER_KEY_DERIVE_PARAMS);
1133     }
1134 }
1135 
1136 static void copyBackKeyMatParams(JNIEnv *env, CK_MECHANISM *ckMechanism,
1137         jobject jMechanism, CK_SSL3_RANDOM_DATA *RandomInfo,
1138         CK_SSL3_KEY_MAT_OUT_PTR ckSSL3KeyMatOut, const char *class_key_mat_params)
1139 {
1140     jclass jMechanismClass, jKeyMatParamsClass, jSSL3KeyMatOutClass;
1141     jfieldID fieldID;
1142     CK_MECHANISM_TYPE ckMechanismType;
1143     jlong jMechanismType;
1144     CK_BYTE_PTR iv;
1145     jobject jKeyMatParam;
1146     jobject jSSL3KeyMatOut;
1147     jobject jIV;
1148     jint jLength;
1149     jbyte* jBytes;
1150     int i;
1151 
1152     /* get mechanism */
1153     jMechanismClass= (*env)-&gt;FindClass(env, CLASS_MECHANISM);
1154     if (jMechanismClass == NULL) { return; }
1155     fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;mechanism&quot;, &quot;J&quot;);
1156     if (fieldID == NULL) { return; }
1157     jMechanismType = (*env)-&gt;GetLongField(env, jMechanism, fieldID);
1158     ckMechanismType = jLongToCKULong(jMechanismType);
1159     if (ckMechanismType != ckMechanism-&gt;mechanism) {
1160         /* we do not have maching types, this should not occur */
1161         return;
1162     }
1163 
1164     // free malloc&#39;d data
1165     if (RandomInfo-&gt;pClientRandom != NULL) {
1166         free(RandomInfo-&gt;pClientRandom);
1167     }
1168     if (RandomInfo-&gt;pServerRandom != NULL) {
1169         free(RandomInfo-&gt;pServerRandom);
1170     }
1171 
1172     if (ckSSL3KeyMatOut != NULL_PTR) {
1173       /* get the Java params object (pParameter) */
1174       fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;pParameter&quot;,
1175               &quot;Ljava/lang/Object;&quot;);
1176       if (fieldID == NULL) { return; }
1177       jKeyMatParam = (*env)-&gt;GetObjectField(env, jMechanism, fieldID);
1178 
1179       /* get the Java CK_SSL3_KEY_MAT_OUT */
1180       jKeyMatParamsClass = (*env)-&gt;FindClass(env, class_key_mat_params);
1181       if (jKeyMatParamsClass == NULL) { return; }
1182       fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamsClass,
1183               &quot;pReturnedKeyMaterial&quot;, &quot;L&quot;CLASS_SSL3_KEY_MAT_OUT&quot;;&quot;);
1184       if (fieldID == NULL) { return; }
1185       jSSL3KeyMatOut = (*env)-&gt;GetObjectField(env, jKeyMatParam, fieldID);
1186 
1187       /* now copy back all the key handles and the initialization vectors */
1188       /* copy back client MAC secret handle */
1189       jSSL3KeyMatOutClass = (*env)-&gt;FindClass(env, CLASS_SSL3_KEY_MAT_OUT);
1190       if (jSSL3KeyMatOutClass == NULL) { return; }
1191       fieldID = (*env)-&gt;GetFieldID(env, jSSL3KeyMatOutClass,
1192               &quot;hClientMacSecret&quot;, &quot;J&quot;);
1193       if (fieldID == NULL) { return; }
1194       (*env)-&gt;SetLongField(env, jSSL3KeyMatOut, fieldID,
1195               ckULongToJLong(ckSSL3KeyMatOut-&gt;hClientMacSecret));
1196 
1197       /* copy back server MAC secret handle */
1198       fieldID = (*env)-&gt;GetFieldID(env, jSSL3KeyMatOutClass,
1199               &quot;hServerMacSecret&quot;, &quot;J&quot;);
1200       if (fieldID == NULL) { return; }
1201       (*env)-&gt;SetLongField(env, jSSL3KeyMatOut, fieldID,
1202               ckULongToJLong(ckSSL3KeyMatOut-&gt;hServerMacSecret));
1203 
1204       /* copy back client secret key handle */
1205       fieldID = (*env)-&gt;GetFieldID(env, jSSL3KeyMatOutClass, &quot;hClientKey&quot;, &quot;J&quot;);
1206       if (fieldID == NULL) { return; }
1207       (*env)-&gt;SetLongField(env, jSSL3KeyMatOut, fieldID,
1208               ckULongToJLong(ckSSL3KeyMatOut-&gt;hClientKey));
1209 
1210       /* copy back server secret key handle */
1211       fieldID = (*env)-&gt;GetFieldID(env, jSSL3KeyMatOutClass, &quot;hServerKey&quot;, &quot;J&quot;);
1212       if (fieldID == NULL) { return; }
1213       (*env)-&gt;SetLongField(env, jSSL3KeyMatOut, fieldID,
1214               ckULongToJLong(ckSSL3KeyMatOut-&gt;hServerKey));
1215 
1216       /* copy back the client IV */
1217       fieldID = (*env)-&gt;GetFieldID(env, jSSL3KeyMatOutClass, &quot;pIVClient&quot;, &quot;[B&quot;);
1218       if (fieldID == NULL) { return; }
1219       jIV = (*env)-&gt;GetObjectField(env, jSSL3KeyMatOut, fieldID);
1220       iv = ckSSL3KeyMatOut-&gt;pIVClient;
1221 
1222       if (jIV != NULL) {
1223         jLength = (*env)-&gt;GetArrayLength(env, jIV);
1224         jBytes = (*env)-&gt;GetByteArrayElements(env, jIV, NULL);
1225         if (jBytes == NULL) { return; }
1226         /* copy the bytes to the Java buffer */
1227         for (i=0; i &lt; jLength; i++) {
1228           jBytes[i] = ckByteToJByte(iv[i]);
1229         }
1230         /* copy back the Java buffer to the object */
1231         (*env)-&gt;ReleaseByteArrayElements(env, jIV, jBytes, 0);
1232       }
1233       // free malloc&#39;d data
1234       free(ckSSL3KeyMatOut-&gt;pIVClient);
1235 
1236       /* copy back the server IV */
1237       fieldID = (*env)-&gt;GetFieldID(env, jSSL3KeyMatOutClass, &quot;pIVServer&quot;, &quot;[B&quot;);
1238       if (fieldID == NULL) { return; }
1239       jIV = (*env)-&gt;GetObjectField(env, jSSL3KeyMatOut, fieldID);
1240       iv = ckSSL3KeyMatOut-&gt;pIVServer;
1241 
1242       if (jIV != NULL) {
1243         jLength = (*env)-&gt;GetArrayLength(env, jIV);
1244         jBytes = (*env)-&gt;GetByteArrayElements(env, jIV, NULL);
1245         if (jBytes == NULL) { return; }
1246         /* copy the bytes to the Java buffer */
1247         for (i=0; i &lt; jLength; i++) {
1248           jBytes[i] = ckByteToJByte(iv[i]);
1249         }
1250         /* copy back the Java buffer to the object */
1251         (*env)-&gt;ReleaseByteArrayElements(env, jIV, jBytes, 0);
1252       }
1253       // free malloc&#39;d data
1254       free(ckSSL3KeyMatOut-&gt;pIVServer);
1255       free(ckSSL3KeyMatOut);
1256     }
1257 }
1258 
1259 /*
1260  * Copy back the derived keys and initialization vectors from the native
1261  * structure to the Java object. This is only used for
1262  * CKM_SSL3_KEY_AND_MAC_DERIVE and CKM_TLS_KEY_AND_MAC_DERIVE mechanisms
1263  * when used for deriving a key.
1264  *
1265  */
1266 void ssl3CopyBackKeyMatParams(JNIEnv *env, CK_MECHANISM *ckMechanism,
1267         jobject jMechanism)
1268 {
1269     CK_SSL3_KEY_MAT_PARAMS *ckSSL3KeyMatParam;
1270     ckSSL3KeyMatParam = (CK_SSL3_KEY_MAT_PARAMS *)ckMechanism-&gt;pParameter;
1271     if (ckSSL3KeyMatParam != NULL_PTR) {
1272         copyBackKeyMatParams(env, ckMechanism, jMechanism,
1273                 &amp;(ckSSL3KeyMatParam-&gt;RandomInfo),
1274                 ckSSL3KeyMatParam-&gt;pReturnedKeyMaterial,
1275                 CLASS_SSL3_KEY_MAT_PARAMS);
1276     }
1277 }
1278 
1279 /*
1280  * Copy back the derived keys and initialization vectors from the native
1281  * structure to the Java object. This is only used for
1282  * CKM_TLS12_KEY_AND_MAC_DERIVE mechanism when used for deriving a key.
1283  *
1284  */
1285 void tls12CopyBackKeyMatParams(JNIEnv *env, CK_MECHANISM *ckMechanism,
1286         jobject jMechanism)
1287 {
1288     CK_TLS12_KEY_MAT_PARAMS *ckTLS12KeyMatParam;
1289     ckTLS12KeyMatParam = (CK_TLS12_KEY_MAT_PARAMS *) ckMechanism-&gt;pParameter;
1290     if (ckTLS12KeyMatParam != NULL_PTR) {
1291         copyBackKeyMatParams(env, ckMechanism, jMechanism,
1292                 &amp;(ckTLS12KeyMatParam-&gt;RandomInfo),
1293                 ckTLS12KeyMatParam-&gt;pReturnedKeyMaterial,
1294                 CLASS_TLS12_KEY_MAT_PARAMS);
1295     }
1296 }
1297 
1298 #endif
    </pre>
  </body>
</html>
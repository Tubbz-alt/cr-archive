<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_util.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 
   5 /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
   6  *
   7  * Redistribution and use in  source and binary forms, with or without
   8  * modification, are permitted  provided that the following conditions are met:
   9  *
  10  * 1. Redistributions of  source code must retain the above copyright notice,
  11  *    this list of conditions and the following disclaimer.
  12  *
  13  * 2. Redistributions in  binary form must reproduce the above copyright notice,
  14  *    this list of conditions and the following disclaimer in the documentation
  15  *    and/or other materials provided with the distribution.
  16  *
  17  * 3. The end-user documentation included with the redistribution, if any, must
  18  *    include the following acknowledgment:
  19  *
  20  *    &quot;This product includes software developed by IAIK of Graz University of
  21  *     Technology.&quot;
  22  *
  23  *    Alternately, this acknowledgment may appear in the software itself, if
  24  *    and wherever such third-party acknowledgments normally appear.
  25  *
  26  * 4. The names &quot;Graz University of Technology&quot; and &quot;IAIK of Graz University of
  27  *    Technology&quot; must not be used to endorse or promote products derived from
  28  *    this software without prior written permission.
  29  *
  30  * 5. Products derived from this software may not be called
  31  *    &quot;IAIK PKCS Wrapper&quot;, nor may &quot;IAIK&quot; appear in their name, without prior
  32  *    written permission of Graz University of Technology.
  33  *
  34  *  THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESSED OR IMPLIED
  35  *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  36  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  37  *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE LICENSOR BE
  38  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
  39  *  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  40  *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  41  *  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  42  *  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  43  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  44  *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  45  *  POSSIBILITY  OF SUCH DAMAGE.
  46  */
  47 
  48 #include &quot;pkcs11wrapper.h&quot;
  49 
  50 #include &lt;stdio.h&gt;
  51 #include &lt;stdlib.h&gt;
  52 #include &lt;string.h&gt;
  53 #include &lt;assert.h&gt;
  54 
  55 /* declare file private functions */
  56 
  57 ModuleData * getModuleEntry(JNIEnv *env, jobject pkcs11Implementation);
  58 int isModulePresent(JNIEnv *env, jobject pkcs11Implementation);
  59 void removeAllModuleEntries(JNIEnv *env);
  60 
  61 
  62 /* ************************************************************************** */
  63 /* Functions for keeping track of currently active and loaded modules         */
  64 /* ************************************************************************** */
  65 
  66 
  67 /*
  68  * Create a new object for locking.
  69  */
  70 jobject createLockObject(JNIEnv *env) {
  71     jclass jObjectClass;
  72     jobject jLockObject;
  73     jmethodID jConstructor;
  74 
  75     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Object&quot;);
  76     if (jObjectClass == NULL) { return NULL; }
  77     jConstructor = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
  78     if (jConstructor == NULL) { return NULL; }
  79     jLockObject = (*env)-&gt;NewObject(env, jObjectClass, jConstructor);
  80     if (jLockObject == NULL) { return NULL; }
  81     jLockObject = (*env)-&gt;NewGlobalRef(env, jLockObject);
  82 
  83     return jLockObject ;
  84 }
  85 
  86 /*
  87  * Create a new object for locking.
  88  */
  89 void destroyLockObject(JNIEnv *env, jobject jLockObject) {
  90     if (jLockObject != NULL) {
  91         (*env)-&gt;DeleteGlobalRef(env, jLockObject);
  92     }
  93 }
  94 
  95 /*
  96  * Add the given pkcs11Implementation object to the list of present modules.
  97  * Attach the given data to the entry. If the given pkcs11Implementation is
  98  * already in the lsit, just override its old module data with the new one.
  99  * None of the arguments can be NULL. If one of the arguments is NULL, this
 100  * function does nothing.
 101  */
 102 void putModuleEntry(JNIEnv *env, jobject pkcs11Implementation, ModuleData *moduleData) {
 103     if (pkcs11Implementation == NULL_PTR) {
 104         return ;
 105     }
 106     if (moduleData == NULL) {
 107         return ;
 108     }
 109     (*env)-&gt;SetLongField(env, pkcs11Implementation, pNativeDataID, ptr_to_jlong(moduleData));
 110 }
 111 
 112 
 113 /*
 114  * Get the module data of the entry for the given pkcs11Implementation. Returns
 115  * NULL, if the pkcs11Implementation is not in the list.
 116  */
 117 ModuleData * getModuleEntry(JNIEnv *env, jobject pkcs11Implementation) {
 118     jlong jData;
 119     if (pkcs11Implementation == NULL) {
 120         return NULL;
 121     }
 122     jData = (*env)-&gt;GetLongField(env, pkcs11Implementation, pNativeDataID);
 123     return (ModuleData*)jlong_to_ptr(jData);
 124 }
 125 
 126 CK_FUNCTION_LIST_PTR getFunctionList(JNIEnv *env, jobject pkcs11Implementation) {
 127     ModuleData *moduleData;
 128     CK_FUNCTION_LIST_PTR ckpFunctions;
 129 
 130     moduleData = getModuleEntry(env, pkcs11Implementation);
 131     if (moduleData == NULL) {
 132         throwDisconnectedRuntimeException(env);
 133         return NULL;
 134     }
 135     ckpFunctions = moduleData-&gt;ckFunctionListPtr;
 136     return ckpFunctions;
 137 }
 138 
 139 
 140 /*
 141  * Returns 1, if the given pkcs11Implementation is in the list.
 142  * 0, otherwise.
 143  */
 144 int isModulePresent(JNIEnv *env, jobject pkcs11Implementation) {
 145     int present;
 146 
 147     ModuleData *moduleData = getModuleEntry(env, pkcs11Implementation);
 148 
 149     present = (moduleData != NULL) ? 1 : 0;
 150 
 151     return present ;
 152 }
 153 
 154 
 155 /*
 156  * Removes the entry for the given pkcs11Implementation from the list. Returns
 157  * the module&#39;s data, after the node was removed. If this function returns NULL
 158  * the pkcs11Implementation was not in the list.
 159  */
 160 ModuleData * removeModuleEntry(JNIEnv *env, jobject pkcs11Implementation) {
 161     ModuleData *moduleData = getModuleEntry(env, pkcs11Implementation);
 162     if (moduleData == NULL) {
 163         return NULL;
 164     }
 165     (*env)-&gt;SetLongField(env, pkcs11Implementation, pNativeDataID, 0);
 166     return moduleData;
 167 }
 168 
 169 /*
 170  * Removes all present entries from the list of modules and frees all
 171  * associated resources. This function is used for clean-up.
 172  */
 173 void removeAllModuleEntries(JNIEnv *env) {
 174     /* XXX empty */
 175 }
 176 
 177 /* ************************************************************************** */
 178 /* Below there follow the helper functions to support conversions between     */
 179 /* Java and Cryptoki types                                                    */
 180 /* ************************************************************************** */
 181 
 182 /*
 183  * function to convert a PKCS#11 return value into a PKCS#11Exception
 184  *
 185  * This function generates a PKCS#11Exception with the returnValue as the errorcode
 186  * if the returnValue is not CKR_OK. The functin returns 0, if the returnValue is
 187  * CKR_OK. Otherwise, it returns the returnValue as a jLong.
 188  *
 189  * @param env - used to call JNI funktions and to get the Exception class
 190  * @param returnValue - of the PKCS#11 function
 191  */
 192 jlong ckAssertReturnValueOK(JNIEnv *env, CK_RV returnValue)
 193 {
 194     jclass jPKCS11ExceptionClass;
 195     jmethodID jConstructor;
 196     jthrowable jPKCS11Exception;
 197     jlong jErrorCode = 0L;
 198 
 199     if (returnValue != CKR_OK) {
 200         jErrorCode = ckULongToJLong(returnValue);
 201         jPKCS11ExceptionClass = (*env)-&gt;FindClass(env, CLASS_PKCS11EXCEPTION);
 202         if (jPKCS11ExceptionClass != NULL) {
 203             jConstructor = (*env)-&gt;GetMethodID(env, jPKCS11ExceptionClass, &quot;&lt;init&gt;&quot;, &quot;(J)V&quot;);
 204             if (jConstructor != NULL) {
 205                 jPKCS11Exception = (jthrowable) (*env)-&gt;NewObject(env, jPKCS11ExceptionClass, jConstructor, jErrorCode);
 206                 if (jPKCS11Exception != NULL) {
 207                     (*env)-&gt;Throw(env, jPKCS11Exception);
 208                 }
 209             }
 210         }
 211         (*env)-&gt;DeleteLocalRef(env, jPKCS11ExceptionClass);
 212     }
 213     return jErrorCode ;
 214 }
 215 
 216 
 217 /*
 218  * Throws a Java Exception by name
 219  */
 220 void throwByName(JNIEnv *env, const char *name, const char *msg)
 221 {
 222     jclass cls = (*env)-&gt;FindClass(env, name);
 223 
 224     if (cls != 0) /* Otherwise an exception has already been thrown */
 225         (*env)-&gt;ThrowNew(env, cls, msg);
 226 }
 227 
 228 /*
 229  * Throws java.lang.OutOfMemoryError
 230  */
 231 void throwOutOfMemoryError(JNIEnv *env, const char *msg)
 232 {
 233     throwByName(env, &quot;java/lang/OutOfMemoryError&quot;, msg);
 234 }
 235 
 236 /*
 237  * Throws java.lang.NullPointerException
 238  */
 239 void throwNullPointerException(JNIEnv *env, const char *msg)
 240 {
 241     throwByName(env, &quot;java/lang/NullPointerException&quot;, msg);
 242 }
 243 
 244 /*
 245  * Throws java.io.IOException
 246  */
 247 void throwIOException(JNIEnv *env, const char *msg)
 248 {
 249     throwByName(env, &quot;java/io/IOException&quot;, msg);
 250 }
 251 
 252 /*
 253  * This function simply throws a PKCS#11RuntimeException with the given
 254  * string as its message.
 255  *
 256  * @param env Used to call JNI funktions and to get the Exception class.
 257  * @param jmessage The message string of the Exception object.
 258  */
 259 void throwPKCS11RuntimeException(JNIEnv *env, const char *message)
 260 {
 261     throwByName(env, CLASS_PKCS11RUNTIMEEXCEPTION, message);
 262 }
 263 
 264 /*
 265  * This function simply throws a PKCS#11RuntimeException. The message says that
 266  * the object is not connected to the module.
 267  *
 268  * @param env Used to call JNI funktions and to get the Exception class.
 269  */
 270 void throwDisconnectedRuntimeException(JNIEnv *env)
 271 {
 272     throwPKCS11RuntimeException(env, &quot;This object is not connected to a module.&quot;);
 273 }
 274 
 275 /* This function frees the specified CK_ATTRIBUTE array.
 276  *
 277  * @param attrPtr pointer to the to-be-freed CK_ATTRIBUTE array.
 278  * @param len the length of the array
 279  */
<a name="2" id="anc2"></a><span class="line-modified"> 280 void freeCKAttributeArray(CK_ATTRIBUTE_PTR attrPtr, int len) {</span>
<span class="line-modified"> 281     if (attrPtr != NULL) {</span>
<span class="line-modified"> 282         int i;</span>
<span class="line-added"> 283         for (i=0; i&lt;len; i++) {</span>
<span class="line-added"> 284             if (attrPtr[i].pValue != NULL_PTR) {</span>
<span class="line-added"> 285                 free(attrPtr[i].pValue);</span>
<span class="line-added"> 286             }</span>
<span class="line-added"> 287         }</span>
<span class="line-added"> 288         free(attrPtr);</span>
<span class="line-added"> 289     }</span>
<span class="line-added"> 290 }</span>
<span class="line-added"> 291 </span>
<span class="line-added"> 292 /* This function frees the specified CK_MECHANISM_PTR pointer and its</span>
<span class="line-added"> 293  * pParameter including mechanism-specific memory allocations.</span>
<span class="line-added"> 294  *</span>
<span class="line-added"> 295  * @param mechPtr pointer to the to-be-freed CK_MECHANISM structure.</span>
<span class="line-added"> 296  */</span>
<span class="line-added"> 297 void freeCKMechanismPtr(CK_MECHANISM_PTR mechPtr) {</span>
<span class="line-added"> 298      void *tmp;</span>
<span class="line-added"> 299      CK_SSL3_MASTER_KEY_DERIVE_PARAMS *sslMkdTmp;</span>
<span class="line-added"> 300      CK_SSL3_KEY_MAT_PARAMS* sslKmTmp;</span>
<span class="line-added"> 301      CK_TLS12_MASTER_KEY_DERIVE_PARAMS *tlsMkdTmp;</span>
<span class="line-added"> 302      CK_TLS12_KEY_MAT_PARAMS* tlsKmTmp;</span>
<span class="line-added"> 303 </span>
<span class="line-added"> 304      if (mechPtr != NULL) {</span>
<span class="line-added"> 305          TRACE2(&quot;DEBUG freeCKMechanismPtr: free pMech %p (mech 0x%lX)\n&quot;,</span>
<span class="line-added"> 306                  mechPtr,  mechPtr-&gt;mechanism);</span>
<span class="line-added"> 307          if (mechPtr-&gt;pParameter != NULL) {</span>
<span class="line-added"> 308              tmp = mechPtr-&gt;pParameter;</span>
<span class="line-added"> 309              switch (mechPtr-&gt;mechanism) {</span>
<span class="line-added"> 310                  case CKM_AES_GCM:</span>
<span class="line-added"> 311                      if (mechPtr-&gt;ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {</span>
<span class="line-added"> 312                          TRACE0(&quot;[ GCM_PARAMS w/o ulIvBits ]\n&quot;);</span>
<span class="line-added"> 313                          free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)-&gt;pIv);</span>
<span class="line-added"> 314                          free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)-&gt;pAAD);</span>
<span class="line-added"> 315                      } else if (mechPtr-&gt;ulParameterLen == sizeof(CK_GCM_PARAMS)) {</span>
<span class="line-added"> 316                          TRACE0(&quot;[ GCM_PARAMS ]\n&quot;);</span>
<span class="line-added"> 317                          free(((CK_GCM_PARAMS*)tmp)-&gt;pIv);</span>
<span class="line-added"> 318                          free(((CK_GCM_PARAMS*)tmp)-&gt;pAAD);</span>
<span class="line-added"> 319                      }</span>
<span class="line-added"> 320                      break;</span>
<span class="line-added"> 321                  case CKM_AES_CCM:</span>
<span class="line-added"> 322                      TRACE0(&quot;[ CK_CCM_PARAMS ]\n&quot;);</span>
<span class="line-added"> 323                      free(((CK_CCM_PARAMS*)tmp)-&gt;pNonce);</span>
<span class="line-added"> 324                      free(((CK_CCM_PARAMS*)tmp)-&gt;pAAD);</span>
<span class="line-added"> 325                      break;</span>
<span class="line-added"> 326                  case CKM_TLS_PRF:</span>
<span class="line-added"> 327                  case CKM_NSS_TLS_PRF_GENERAL:</span>
<span class="line-added"> 328                      TRACE0(&quot;[ CK_TLS_PRF_PARAMS ]\n&quot;);</span>
<span class="line-added"> 329                      free(((CK_TLS_PRF_PARAMS*)tmp)-&gt;pSeed);</span>
<span class="line-added"> 330                      free(((CK_TLS_PRF_PARAMS*)tmp)-&gt;pLabel);</span>
<span class="line-added"> 331                      free(((CK_TLS_PRF_PARAMS*)tmp)-&gt;pulOutputLen);</span>
<span class="line-added"> 332                      free(((CK_TLS_PRF_PARAMS*)tmp)-&gt;pOutput);</span>
<span class="line-added"> 333                      break;</span>
<span class="line-added"> 334                  case CKM_SSL3_MASTER_KEY_DERIVE:</span>
<span class="line-added"> 335                  case CKM_TLS_MASTER_KEY_DERIVE:</span>
<span class="line-added"> 336                  case CKM_SSL3_MASTER_KEY_DERIVE_DH:</span>
<span class="line-added"> 337                  case CKM_TLS_MASTER_KEY_DERIVE_DH:</span>
<span class="line-added"> 338                      sslMkdTmp = tmp;</span>
<span class="line-added"> 339                      TRACE0(&quot;[ CK_SSL3_MASTER_KEY_DERIVE_PARAMS ]\n&quot;);</span>
<span class="line-added"> 340                      free(sslMkdTmp-&gt;RandomInfo.pClientRandom);</span>
<span class="line-added"> 341                      free(sslMkdTmp-&gt;RandomInfo.pServerRandom);</span>
<span class="line-added"> 342                      free(sslMkdTmp-&gt;pVersion);</span>
<span class="line-added"> 343                      break;</span>
<span class="line-added"> 344                  case CKM_SSL3_KEY_AND_MAC_DERIVE:</span>
<span class="line-added"> 345                  case CKM_TLS_KEY_AND_MAC_DERIVE:</span>
<span class="line-added"> 346                      sslKmTmp = tmp;</span>
<span class="line-added"> 347                      TRACE0(&quot;[ CK_SSL3_KEY_MAT_PARAMS ]\n&quot;);</span>
<span class="line-added"> 348                      free(sslKmTmp-&gt;RandomInfo.pClientRandom);</span>
<span class="line-added"> 349                      free(sslKmTmp-&gt;RandomInfo.pServerRandom);</span>
<span class="line-added"> 350                      if (sslKmTmp-&gt;pReturnedKeyMaterial != NULL) {</span>
<span class="line-added"> 351                          free(sslKmTmp-&gt;pReturnedKeyMaterial-&gt;pIVClient);</span>
<span class="line-added"> 352                          free(sslKmTmp-&gt;pReturnedKeyMaterial-&gt;pIVServer);</span>
<span class="line-added"> 353                          free(sslKmTmp-&gt;pReturnedKeyMaterial);</span>
<span class="line-added"> 354                      }</span>
<span class="line-added"> 355                      break;</span>
<span class="line-added"> 356                  case CKM_TLS12_MASTER_KEY_DERIVE:</span>
<span class="line-added"> 357                  case CKM_TLS12_MASTER_KEY_DERIVE_DH:</span>
<span class="line-added"> 358                      tlsMkdTmp = tmp;</span>
<span class="line-added"> 359                      TRACE0(&quot;[ CK_TLS12_MASTER_KEY_DERIVE_PARAMS ]\n&quot;);</span>
<span class="line-added"> 360                      free(tlsMkdTmp-&gt;RandomInfo.pClientRandom);</span>
<span class="line-added"> 361                      free(tlsMkdTmp-&gt;RandomInfo.pServerRandom);</span>
<span class="line-added"> 362                      free(tlsMkdTmp-&gt;pVersion);</span>
<span class="line-added"> 363                      break;</span>
<span class="line-added"> 364                  case CKM_TLS12_KEY_AND_MAC_DERIVE:</span>
<span class="line-added"> 365                      tlsKmTmp = tmp;</span>
<span class="line-added"> 366                      TRACE0(&quot;[ CK_TLS12_KEY_MAT_PARAMS ]\n&quot;);</span>
<span class="line-added"> 367                      free(tlsKmTmp-&gt;RandomInfo.pClientRandom);</span>
<span class="line-added"> 368                      free(tlsKmTmp-&gt;RandomInfo.pServerRandom);</span>
<span class="line-added"> 369                      if (tlsKmTmp-&gt;pReturnedKeyMaterial != NULL) {</span>
<span class="line-added"> 370                          free(tlsKmTmp-&gt;pReturnedKeyMaterial-&gt;pIVClient);</span>
<span class="line-added"> 371                          free(tlsKmTmp-&gt;pReturnedKeyMaterial-&gt;pIVServer);</span>
<span class="line-added"> 372                          free(tlsKmTmp-&gt;pReturnedKeyMaterial);</span>
<span class="line-added"> 373                      }</span>
<span class="line-added"> 374                      break;</span>
<span class="line-added"> 375                  case CKM_ECDH1_DERIVE:</span>
<span class="line-added"> 376                  case CKM_ECDH1_COFACTOR_DERIVE:</span>
<span class="line-added"> 377                      TRACE0(&quot;[ CK_ECDH1_DERIVE_PARAMS ]\n&quot;);</span>
<span class="line-added"> 378                      free(((CK_ECDH1_DERIVE_PARAMS *)tmp)-&gt;pSharedData);</span>
<span class="line-added"> 379                      free(((CK_ECDH1_DERIVE_PARAMS *)tmp)-&gt;pPublicData);</span>
<span class="line-added"> 380                      break;</span>
<span class="line-added"> 381                  case CKM_TLS_MAC:</span>
<span class="line-added"> 382                  case CKM_AES_CTR:</span>
<span class="line-added"> 383                  case CKM_RSA_PKCS_PSS:</span>
<span class="line-added"> 384                  case CKM_CAMELLIA_CTR:</span>
<span class="line-added"> 385                      // params do not contain pointers</span>
<span class="line-added"> 386                      break;</span>
<span class="line-added"> 387                  default:</span>
<span class="line-added"> 388                      // currently unsupported mechs by SunPKCS11 provider</span>
<span class="line-added"> 389                      // CKM_RSA_PKCS_OAEP, CKM_ECMQV_DERIVE,</span>
<span class="line-added"> 390                      // CKM_X9_42_*, CKM_KEA_DERIVE, CKM_RC2_*, CKM_RC5_*,</span>
<span class="line-added"> 391                      // CKM_SKIPJACK_*, CKM_KEY_WRAP_SET_OAEP, CKM_PKCS5_PBKD2,</span>
<span class="line-added"> 392                      // PBE mechs, WTLS mechs, CMS mechs,</span>
<span class="line-added"> 393                      // CKM_EXTRACT_KEY_FROM_KEY, CKM_OTP, CKM_KIP,</span>
<span class="line-added"> 394                      // CKM_DSA_PARAMETER_GEN?, CKM_GOSTR3410_*</span>
<span class="line-added"> 395                      // CK_any_CBC_ENCRYPT_DATA?</span>
<span class="line-added"> 396                      TRACE0(&quot;ERROR: UNSUPPORTED CK_MECHANISM\n&quot;);</span>
<span class="line-added"> 397                      break;</span>
<span class="line-added"> 398              }</span>
<span class="line-added"> 399              TRACE1(&quot;\t=&gt; freed param %p\n&quot;, tmp);</span>
<span class="line-added"> 400              free(tmp);</span>
<span class="line-added"> 401          } else {</span>
<span class="line-added"> 402              TRACE0(&quot;\t=&gt; param NULL\n&quot;);</span>
<span class="line-added"> 403          }</span>
<span class="line-added"> 404          free(mechPtr);</span>
<span class="line-added"> 405          TRACE0(&quot;FINISHED\n&quot;);</span>
<span class="line-added"> 406      }</span>
<span class="line-added"> 407 }</span>
 408 
<a name="3" id="anc3"></a><span class="line-modified"> 409 /* This function replaces the CK_GCM_PARAMS_NO_IVBITS structure associated</span>
<span class="line-modified"> 410  * with the specified CK_MECHANISM structure with CK_GCM_PARAMS</span>
<span class="line-modified"> 411  * structure.</span>
<span class="line-added"> 412  *</span>
<span class="line-added"> 413  * @param mechPtr pointer to the CK_MECHANISM structure containing</span>
<span class="line-added"> 414  * the to-be-converted CK_GCM_PARAMS_NO_IVBITS structure.</span>
<span class="line-added"> 415  * @return pointer to the CK_MECHANISM structure containing the</span>
<span class="line-added"> 416  * converted CK_GCM_PARAMS structure or NULL if no conversion took place.</span>
<span class="line-added"> 417  */</span>
<span class="line-added"> 418 CK_MECHANISM_PTR updateGCMParams(JNIEnv *env, CK_MECHANISM_PTR mechPtr) {</span>
<span class="line-added"> 419     CK_GCM_PARAMS* pGcmParams2 = NULL;</span>
<span class="line-added"> 420     CK_GCM_PARAMS_NO_IVBITS* pParams = NULL;</span>
<span class="line-added"> 421     if ((mechPtr-&gt;mechanism == CKM_AES_GCM) &amp;&amp;</span>
<span class="line-added"> 422             (mechPtr-&gt;pParameter != NULL_PTR) &amp;&amp;</span>
<span class="line-added"> 423             (mechPtr-&gt;ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS))) {</span>
<span class="line-added"> 424         pGcmParams2 = calloc(1, sizeof(CK_GCM_PARAMS));</span>
<span class="line-added"> 425         if (pGcmParams2 == NULL) {</span>
<span class="line-added"> 426             throwOutOfMemoryError(env, 0);</span>
<span class="line-added"> 427             return NULL;</span>
 428         }
<a name="4" id="anc4"></a><span class="line-added"> 429         pParams = (CK_GCM_PARAMS_NO_IVBITS*) mechPtr-&gt;pParameter;</span>
<span class="line-added"> 430         pGcmParams2-&gt;pIv = pParams-&gt;pIv;</span>
<span class="line-added"> 431         pGcmParams2-&gt;ulIvLen = pParams-&gt;ulIvLen;</span>
<span class="line-added"> 432         pGcmParams2-&gt;ulIvBits = (pGcmParams2-&gt;ulIvLen &lt;&lt; 3);</span>
<span class="line-added"> 433         pGcmParams2-&gt;pAAD = pParams-&gt;pAAD;</span>
<span class="line-added"> 434         pGcmParams2-&gt;ulAADLen = pParams-&gt;ulAADLen;</span>
<span class="line-added"> 435         pGcmParams2-&gt;ulTagBits = pParams-&gt;ulTagBits;</span>
<span class="line-added"> 436         TRACE1(&quot;DEBUG updateGCMParams: pMech %p\n&quot;, mechPtr);</span>
<span class="line-added"> 437         TRACE2(&quot;\t=&gt; GCM param w/o ulIvBits %p =&gt; GCM param %p\n&quot;, pParams,</span>
<span class="line-added"> 438                 pGcmParams2);</span>
<span class="line-added"> 439         free(pParams);</span>
<span class="line-added"> 440         mechPtr-&gt;pParameter = pGcmParams2;</span>
<span class="line-added"> 441         mechPtr-&gt;ulParameterLen = sizeof(CK_GCM_PARAMS);</span>
<span class="line-added"> 442         return mechPtr;</span>
<span class="line-added"> 443     } else {</span>
<span class="line-added"> 444         TRACE0(&quot;DEBUG updateGCMParams: no conversion done\n&quot;);</span>
 445     }
<a name="5" id="anc5"></a><span class="line-modified"> 446     return NULL;</span>
 447 }
 448 
 449 /*
 450  * the following functions convert Java arrays to PKCS#11 array pointers and
 451  * their array length and vice versa
 452  *
 453  * void j&lt;Type&gt;ArrayToCK&lt;Type&gt;Array(JNIEnv *env,
 454  *                                  const j&lt;Type&gt;Array jArray,
 455  *                                  CK_&lt;Type&gt;_PTR *ckpArray,
 456  *                                  CK_ULONG_PTR ckLength);
 457  *
 458  * j&lt;Type&gt;Array ck&lt;Type&gt;ArrayToJ&lt;Type&gt;Array(JNIEnv *env,
 459  *                                          const CK_&lt;Type&gt;_PTR ckpArray,
 460  *                                          CK_ULONG ckLength);
 461  *
 462  * PKCS#11 arrays consist always of a pointer to the beginning of the array and
 463  * the array length whereas Java arrays carry their array length.
 464  *
 465  * The Functions to convert a Java array to a PKCS#11 array are void functions.
 466  * Their arguments are the Java array object to convert, the reference to the
 467  * array pointer, where the new PKCS#11 array should be stored and the reference
 468  * to the array length where the PKCS#11 array length should be stored. These two
 469  * references must not be NULL_PTR.
 470  *
 471  * The functions first obtain the array length of the Java array and then allocate
 472  * the memory for the PKCS#11 array and set the array length. Then each element
 473  * gets converted depending on their type. After use the allocated memory of the
 474  * PKCS#11 array has to be explicitly freed.
 475  *
 476  * The Functions to convert a PKCS#11 array to a Java array get the PKCS#11 array
 477  * pointer and the array length and they return the new Java array object. The
 478  * Java array does not need to get freed after use.
 479  */
 480 
 481 /*
 482  * converts a jbooleanArray to a CK_BBOOL array. The allocated memory has to be freed after use!
 483  *
 484  * @param env - used to call JNI funktions to get the array informtaion
 485  * @param jArray - the Java array to convert
 486  * @param ckpArray - the reference, where the pointer to the new CK_BBOOL array will be stored
 487  * @param ckpLength - the reference, where the array length will be stored
 488  */
 489 void jBooleanArrayToCKBBoolArray(JNIEnv *env, const jbooleanArray jArray, CK_BBOOL **ckpArray, CK_ULONG_PTR ckpLength)
 490 {
 491     jboolean* jpTemp;
 492     CK_ULONG i;
 493 
 494     if(jArray == NULL) {
 495         *ckpArray = NULL_PTR;
 496         *ckpLength = 0L;
 497         return;
 498     }
 499     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<a name="6" id="anc6"></a><span class="line-modified"> 500     jpTemp = (jboolean*) calloc(*ckpLength, sizeof(jboolean));</span>
 501     if (jpTemp == NULL) {
 502         throwOutOfMemoryError(env, 0);
 503         return;
 504     }
 505     (*env)-&gt;GetBooleanArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
 506     if ((*env)-&gt;ExceptionCheck(env)) {
 507         free(jpTemp);
 508         return;
 509     }
 510 
<a name="7" id="anc7"></a><span class="line-modified"> 511     *ckpArray = (CK_BBOOL*) calloc (*ckpLength, sizeof(CK_BBOOL));</span>
 512     if (*ckpArray == NULL) {
 513         free(jpTemp);
 514         throwOutOfMemoryError(env, 0);
 515         return;
 516     }
 517     for (i=0; i&lt;(*ckpLength); i++) {
 518         (*ckpArray)[i] = jBooleanToCKBBool(jpTemp[i]);
 519     }
 520     free(jpTemp);
 521 }
 522 
 523 /*
 524  * converts a jbyteArray to a CK_BYTE array. The allocated memory has to be freed after use!
 525  *
 526  * @param env - used to call JNI funktions to get the array informtaion
 527  * @param jArray - the Java array to convert
 528  * @param ckpArray - the reference, where the pointer to the new CK_BYTE array will be stored
 529  * @param ckpLength - the reference, where the array length will be stored
 530  */
 531 void jByteArrayToCKByteArray(JNIEnv *env, const jbyteArray jArray, CK_BYTE_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 532 {
 533     jbyte* jpTemp;
 534     CK_ULONG i;
 535 
 536     if(jArray == NULL) {
 537         *ckpArray = NULL_PTR;
 538         *ckpLength = 0L;
 539         return;
 540     }
 541     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<a name="8" id="anc8"></a><span class="line-modified"> 542     jpTemp = (jbyte*) calloc(*ckpLength, sizeof(jbyte));</span>
 543     if (jpTemp == NULL) {
 544         throwOutOfMemoryError(env, 0);
 545         return;
 546     }
 547     (*env)-&gt;GetByteArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
 548     if ((*env)-&gt;ExceptionCheck(env)) {
 549         free(jpTemp);
 550         return;
 551     }
 552 
 553     /* if CK_BYTE is the same size as jbyte, we save an additional copy */
 554     if (sizeof(CK_BYTE) == sizeof(jbyte)) {
 555         *ckpArray = (CK_BYTE_PTR) jpTemp;
 556     } else {
<a name="9" id="anc9"></a><span class="line-modified"> 557         *ckpArray = (CK_BYTE_PTR) calloc (*ckpLength, sizeof(CK_BYTE));</span>
 558         if (*ckpArray == NULL) {
 559             free(jpTemp);
 560             throwOutOfMemoryError(env, 0);
 561             return;
 562         }
 563         for (i=0; i&lt;(*ckpLength); i++) {
 564             (*ckpArray)[i] = jByteToCKByte(jpTemp[i]);
 565         }
 566         free(jpTemp);
 567     }
 568 }
 569 
 570 /*
 571  * converts a jlongArray to a CK_ULONG array. The allocated memory has to be freed after use!
 572  *
 573  * @param env - used to call JNI funktions to get the array informtaion
 574  * @param jArray - the Java array to convert
 575  * @param ckpArray - the reference, where the pointer to the new CK_ULONG array will be stored
 576  * @param ckpLength - the reference, where the array length will be stored
 577  */
 578 void jLongArrayToCKULongArray(JNIEnv *env, const jlongArray jArray, CK_ULONG_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 579 {
 580     jlong* jTemp;
 581     CK_ULONG i;
 582 
 583     if(jArray == NULL) {
 584         *ckpArray = NULL_PTR;
 585         *ckpLength = 0L;
 586         return;
 587     }
 588     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<a name="10" id="anc10"></a><span class="line-modified"> 589     jTemp = (jlong*) calloc(*ckpLength, sizeof(jlong));</span>
 590     if (jTemp == NULL) {
 591         throwOutOfMemoryError(env, 0);
 592         return;
 593     }
 594     (*env)-&gt;GetLongArrayRegion(env, jArray, 0, *ckpLength, jTemp);
 595     if ((*env)-&gt;ExceptionCheck(env)) {
 596         free(jTemp);
 597         return;
 598     }
 599 
<a name="11" id="anc11"></a><span class="line-modified"> 600     *ckpArray = (CK_ULONG_PTR) calloc(*ckpLength, sizeof(CK_ULONG));</span>
 601     if (*ckpArray == NULL) {
 602         free(jTemp);
 603         throwOutOfMemoryError(env, 0);
 604         return;
 605     }
 606     for (i=0; i&lt;(*ckpLength); i++) {
 607         (*ckpArray)[i] = jLongToCKULong(jTemp[i]);
 608     }
 609     free(jTemp);
 610 }
 611 
 612 /*
 613  * converts a jcharArray to a CK_CHAR array. The allocated memory has to be freed after use!
 614  *
 615  * @param env - used to call JNI funktions to get the array informtaion
 616  * @param jArray - the Java array to convert
 617  * @param ckpArray - the reference, where the pointer to the new CK_CHAR array will be stored
 618  * @param ckpLength - the reference, where the array length will be stored
 619  */
 620 void jCharArrayToCKCharArray(JNIEnv *env, const jcharArray jArray, CK_CHAR_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 621 {
 622     jchar* jpTemp;
 623     CK_ULONG i;
 624 
 625     if(jArray == NULL) {
 626         *ckpArray = NULL_PTR;
 627         *ckpLength = 0L;
 628         return;
 629     }
 630     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<a name="12" id="anc12"></a><span class="line-modified"> 631     jpTemp = (jchar*) calloc(*ckpLength, sizeof(jchar));</span>
 632     if (jpTemp == NULL) {
 633         throwOutOfMemoryError(env, 0);
 634         return;
 635     }
 636     (*env)-&gt;GetCharArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
 637     if ((*env)-&gt;ExceptionCheck(env)) {
 638         free(jpTemp);
 639         return;
 640     }
 641 
<a name="13" id="anc13"></a><span class="line-modified"> 642     *ckpArray = (CK_CHAR_PTR) calloc (*ckpLength, sizeof(CK_CHAR));</span>
 643     if (*ckpArray == NULL) {
 644         free(jpTemp);
 645         throwOutOfMemoryError(env, 0);
 646         return;
 647     }
 648     for (i=0; i&lt;(*ckpLength); i++) {
 649         (*ckpArray)[i] = jCharToCKChar(jpTemp[i]);
 650     }
 651     free(jpTemp);
 652 }
 653 
 654 /*
 655  * converts a jcharArray to a CK_UTF8CHAR array. The allocated memory has to be freed after use!
 656  *
 657  * @param env - used to call JNI funktions to get the array informtaion
 658  * @param jArray - the Java array to convert
 659  * @param ckpArray - the reference, where the pointer to the new CK_UTF8CHAR array will be stored
 660  * @param ckpLength - the reference, where the array length will be stored
 661  */
 662 void jCharArrayToCKUTF8CharArray(JNIEnv *env, const jcharArray jArray, CK_UTF8CHAR_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 663 {
 664     jchar* jTemp;
 665     CK_ULONG i;
 666 
 667     if(jArray == NULL) {
 668         *ckpArray = NULL_PTR;
 669         *ckpLength = 0L;
 670         return;
 671     }
 672     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<a name="14" id="anc14"></a><span class="line-modified"> 673     jTemp = (jchar*) calloc(*ckpLength, sizeof(jchar));</span>
 674     if (jTemp == NULL) {
 675         throwOutOfMemoryError(env, 0);
 676         return;
 677     }
 678     (*env)-&gt;GetCharArrayRegion(env, jArray, 0, *ckpLength, jTemp);
 679     if ((*env)-&gt;ExceptionCheck(env)) {
 680         free(jTemp);
 681         return;
 682     }
 683 
<a name="15" id="anc15"></a><span class="line-modified"> 684     *ckpArray = (CK_UTF8CHAR_PTR) calloc(*ckpLength, sizeof(CK_UTF8CHAR));</span>
 685     if (*ckpArray == NULL) {
 686         free(jTemp);
 687         throwOutOfMemoryError(env, 0);
 688         return;
 689     }
 690     for (i=0; i&lt;(*ckpLength); i++) {
 691         (*ckpArray)[i] = jCharToCKUTF8Char(jTemp[i]);
 692     }
 693     free(jTemp);
 694 }
 695 
 696 /*
 697  * converts a jstring to a CK_CHAR array. The allocated memory has to be freed after use!
 698  *
 699  * @param env - used to call JNI funktions to get the array informtaion
 700  * @param jArray - the Java array to convert
 701  * @param ckpArray - the reference, where the pointer to the new CK_CHAR array will be stored
 702  * @param ckpLength - the reference, where the array length will be stored
 703  */
 704 void jStringToCKUTF8CharArray(JNIEnv *env, const jstring jArray, CK_UTF8CHAR_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 705 {
 706     const char* pCharArray;
 707     jboolean isCopy;
 708 
 709     if(jArray == NULL) {
 710         *ckpArray = NULL_PTR;
 711         *ckpLength = 0L;
 712         return;
 713     }
 714 
 715     pCharArray = (*env)-&gt;GetStringUTFChars(env, jArray, &amp;isCopy);
 716     if (pCharArray == NULL) { return; }
 717 
 718     *ckpLength = (CK_ULONG) strlen(pCharArray);
<a name="16" id="anc16"></a><span class="line-modified"> 719     *ckpArray = (CK_UTF8CHAR_PTR) calloc(*ckpLength + 1, sizeof(CK_UTF8CHAR));</span>
 720     if (*ckpArray == NULL) {
 721         (*env)-&gt;ReleaseStringUTFChars(env, (jstring) jArray, pCharArray);
 722         throwOutOfMemoryError(env, 0);
 723         return;
 724     }
 725     strcpy((char*)*ckpArray, pCharArray);
 726     (*env)-&gt;ReleaseStringUTFChars(env, (jstring) jArray, pCharArray);
 727 }
 728 
 729 /*
 730  * converts a jobjectArray with Java Attributes to a CK_ATTRIBUTE array. The allocated memory
 731  * has to be freed after use!
 732  *
 733  * @param env - used to call JNI funktions to get the array informtaion
 734  * @param jArray - the Java Attribute array (template) to convert
 735  * @param ckpArray - the reference, where the pointer to the new CK_ATTRIBUTE array will be
 736  *                   stored
 737  * @param ckpLength - the reference, where the array length will be stored
 738  */
 739 void jAttributeArrayToCKAttributeArray(JNIEnv *env, jobjectArray jArray, CK_ATTRIBUTE_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 740 {
 741     CK_ULONG i;
 742     jlong jLength;
 743     jobject jAttribute;
 744 
 745     TRACE0(&quot;\nDEBUG: jAttributeArrayToCKAttributeArray&quot;);
 746     if (jArray == NULL) {
 747         *ckpArray = NULL_PTR;
 748         *ckpLength = 0L;
 749         return;
 750     }
 751     jLength = (*env)-&gt;GetArrayLength(env, jArray);
 752     *ckpLength = jLongToCKULong(jLength);
<a name="17" id="anc17"></a><span class="line-modified"> 753     *ckpArray = (CK_ATTRIBUTE_PTR) calloc(*ckpLength, sizeof(CK_ATTRIBUTE));</span>
 754     if (*ckpArray == NULL) {
 755         throwOutOfMemoryError(env, 0);
 756         return;
 757     }
<a name="18" id="anc18"></a><span class="line-modified"> 758     TRACE1(&quot;, converting %lld attributes&quot;, (long long int) jLength);</span>
 759     for (i=0; i&lt;(*ckpLength); i++) {
<a name="19" id="anc19"></a><span class="line-modified"> 760         TRACE1(&quot;, getting %lu. attribute&quot;, i);</span>
 761         jAttribute = (*env)-&gt;GetObjectArrayElement(env, jArray, i);
 762         if ((*env)-&gt;ExceptionCheck(env)) {
 763             freeCKAttributeArray(*ckpArray, i);
 764             return;
 765         }
<a name="20" id="anc20"></a><span class="line-modified"> 766         TRACE1(&quot;, jAttribute , converting %lu. attribute&quot;, i);</span>

 767         (*ckpArray)[i] = jAttributeToCKAttribute(env, jAttribute);
 768         if ((*env)-&gt;ExceptionCheck(env)) {
 769             freeCKAttributeArray(*ckpArray, i);
 770             return;
 771         }
 772     }
 773     TRACE0(&quot;FINISHED\n&quot;);
 774 }
 775 
 776 /*
 777  * converts a CK_BYTE array and its length to a jbyteArray.
 778  *
 779  * @param env - used to call JNI funktions to create the new Java array
 780  * @param ckpArray - the pointer to the CK_BYTE array to convert
 781  * @param ckpLength - the length of the array to convert
 782  * @return - the new Java byte array or NULL if error occurred
 783  */
 784 jbyteArray ckByteArrayToJByteArray(JNIEnv *env, const CK_BYTE_PTR ckpArray, CK_ULONG ckLength)
 785 {
 786     CK_ULONG i;
 787     jbyte* jpTemp;
 788     jbyteArray jArray;
 789 
 790     /* if CK_BYTE is the same size as jbyte, we save an additional copy */
 791     if (sizeof(CK_BYTE) == sizeof(jbyte)) {
 792         jpTemp = (jbyte*) ckpArray;
 793     } else {
<a name="21" id="anc21"></a><span class="line-modified"> 794         jpTemp = (jbyte*) calloc(ckLength, sizeof(jbyte));</span>
 795         if (jpTemp == NULL) {
 796             throwOutOfMemoryError(env, 0);
 797             return NULL;
 798         }
 799         for (i=0; i&lt;ckLength; i++) {
 800             jpTemp[i] = ckByteToJByte(ckpArray[i]);
 801         }
 802     }
 803 
 804     jArray = (*env)-&gt;NewByteArray(env, ckULongToJSize(ckLength));
 805     if (jArray != NULL) {
 806         (*env)-&gt;SetByteArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 807     }
 808 
 809     if (sizeof(CK_BYTE) != sizeof(jbyte)) { free(jpTemp); }
 810 
 811     return jArray ;
 812 }
 813 
 814 /*
 815  * converts a CK_ULONG array and its length to a jlongArray.
 816  *
 817  * @param env - used to call JNI funktions to create the new Java array
 818  * @param ckpArray - the pointer to the CK_ULONG array to convert
 819  * @param ckpLength - the length of the array to convert
 820  * @return - the new Java long array
 821  */
 822 jlongArray ckULongArrayToJLongArray(JNIEnv *env, const CK_ULONG_PTR ckpArray, CK_ULONG ckLength)
 823 {
 824     CK_ULONG i;
 825     jlong* jpTemp;
 826     jlongArray jArray;
 827 
<a name="22" id="anc22"></a><span class="line-modified"> 828     jpTemp = (jlong*) calloc(ckLength, sizeof(jlong));</span>
 829     if (jpTemp == NULL) {
 830         throwOutOfMemoryError(env, 0);
 831         return NULL;
 832     }
 833     for (i=0; i&lt;ckLength; i++) {
 834         jpTemp[i] = ckLongToJLong(ckpArray[i]);
 835     }
 836     jArray = (*env)-&gt;NewLongArray(env, ckULongToJSize(ckLength));
 837     if (jArray != NULL) {
 838         (*env)-&gt;SetLongArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 839     }
 840     free(jpTemp);
 841 
 842     return jArray ;
 843 }
 844 
 845 /*
 846  * converts a CK_CHAR array and its length to a jcharArray.
 847  *
 848  * @param env - used to call JNI funktions to create the new Java array
 849  * @param ckpArray - the pointer to the CK_CHAR array to convert
 850  * @param ckpLength - the length of the array to convert
 851  * @return - the new Java char array
 852  */
 853 jcharArray ckCharArrayToJCharArray(JNIEnv *env, const CK_CHAR_PTR ckpArray, CK_ULONG ckLength)
 854 {
 855     CK_ULONG i;
 856     jchar* jpTemp;
 857     jcharArray jArray;
 858 
<a name="23" id="anc23"></a><span class="line-modified"> 859     jpTemp = (jchar*) calloc(ckLength, sizeof(jchar));</span>
 860     if (jpTemp == NULL) {
 861         throwOutOfMemoryError(env, 0);
 862         return NULL;
 863     }
 864     for (i=0; i&lt;ckLength; i++) {
 865         jpTemp[i] = ckCharToJChar(ckpArray[i]);
 866     }
 867     jArray = (*env)-&gt;NewCharArray(env, ckULongToJSize(ckLength));
 868     if (jArray != NULL) {
 869         (*env)-&gt;SetCharArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 870     }
 871     free(jpTemp);
 872 
 873     return jArray ;
 874 }
 875 
 876 /*
 877  * converts a CK_UTF8CHAR array and its length to a jcharArray.
 878  *
 879  * @param env - used to call JNI funktions to create the new Java array
 880  * @param ckpArray - the pointer to the CK_UTF8CHAR array to convert
 881  * @param ckpLength - the length of the array to convert
 882  * @return - the new Java char array
 883  */
 884 jcharArray ckUTF8CharArrayToJCharArray(JNIEnv *env, const CK_UTF8CHAR_PTR ckpArray, CK_ULONG ckLength)
 885 {
 886     CK_ULONG i;
 887     jchar* jpTemp;
 888     jcharArray jArray;
 889 
<a name="24" id="anc24"></a><span class="line-modified"> 890     jpTemp = (jchar*) calloc(ckLength, sizeof(jchar));</span>
 891     if (jpTemp == NULL) {
 892         throwOutOfMemoryError(env, 0);
 893         return NULL;
 894     }
 895     for (i=0; i&lt;ckLength; i++) {
 896         jpTemp[i] = ckUTF8CharToJChar(ckpArray[i]);
 897     }
 898     jArray = (*env)-&gt;NewCharArray(env, ckULongToJSize(ckLength));
 899     if (jArray != NULL) {
 900         (*env)-&gt;SetCharArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 901     }
 902     free(jpTemp);
 903 
 904     return jArray ;
 905 }
 906 
 907 /*
 908  * the following functions convert Java objects to PKCS#11 pointers and the
 909  * length in bytes and vice versa
 910  *
 911  * CK_&lt;Type&gt;_PTR j&lt;Object&gt;ToCK&lt;Type&gt;Ptr(JNIEnv *env, jobject jObject);
 912  *
 913  * jobject ck&lt;Type&gt;PtrToJ&lt;Object&gt;(JNIEnv *env, const CK_&lt;Type&gt;_PTR ckpValue);
 914  *
 915  * The functions that convert a Java object to a PKCS#11 pointer first allocate
 916  * the memory for the PKCS#11 pointer. Then they set each element corresponding
 917  * to the fields in the Java object to convert. After use the allocated memory of
 918  * the PKCS#11 pointer has to be explicitly freed.
 919  *
 920  * The functions to convert a PKCS#11 pointer to a Java object create a new Java
 921  * object first and than they set all fields in the object depending on the values
 922  * of the type or structure where the PKCS#11 pointer points to.
 923  */
 924 
 925 /*
 926  * converts a CK_BBOOL pointer to a Java boolean Object.
 927  *
 928  * @param env - used to call JNI funktions to create the new Java object
 929  * @param ckpValue - the pointer to the CK_BBOOL value
 930  * @return - the new Java boolean object with the boolean value
 931  */
 932 jobject ckBBoolPtrToJBooleanObject(JNIEnv *env, const CK_BBOOL *ckpValue)
 933 {
 934     jclass jValueObjectClass;
 935     jmethodID jConstructor;
 936     jobject jValueObject;
 937     jboolean jValue;
 938 
 939     jValueObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Boolean&quot;);
 940     if (jValueObjectClass == NULL) { return NULL; }
 941     jConstructor = (*env)-&gt;GetMethodID(env, jValueObjectClass, &quot;&lt;init&gt;&quot;, &quot;(Z)V&quot;);
 942     if (jConstructor == NULL) { return NULL; }
 943     jValue = ckBBoolToJBoolean(*ckpValue);
 944     jValueObject = (*env)-&gt;NewObject(env, jValueObjectClass, jConstructor, jValue);
 945 
 946     return jValueObject ;
 947 }
 948 
 949 /*
 950  * converts a CK_ULONG pointer to a Java long Object.
 951  *
 952  * @param env - used to call JNI funktions to create the new Java object
 953  * @param ckpValue - the pointer to the CK_ULONG value
 954  * @return - the new Java long object with the long value
 955  */
 956 jobject ckULongPtrToJLongObject(JNIEnv *env, const CK_ULONG_PTR ckpValue)
 957 {
 958     jclass jValueObjectClass;
 959     jmethodID jConstructor;
 960     jobject jValueObject;
 961     jlong jValue;
 962 
 963     jValueObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Long&quot;);
 964     if (jValueObjectClass == NULL) { return NULL; }
 965     jConstructor = (*env)-&gt;GetMethodID(env, jValueObjectClass, &quot;&lt;init&gt;&quot;, &quot;(J)V&quot;);
 966     if (jConstructor == NULL) { return NULL; }
 967     jValue = ckULongToJLong(*ckpValue);
 968     jValueObject = (*env)-&gt;NewObject(env, jValueObjectClass, jConstructor, jValue);
 969 
 970     return jValueObject ;
 971 }
 972 
 973 /*
 974  * converts a Java boolean object into a pointer to a CK_BBOOL value. The memory has to be
 975  * freed after use!
 976  *
 977  * @param env - used to call JNI funktions to get the value out of the Java object
 978  * @param jObject - the &quot;java/lang/Boolean&quot; object to convert
 979  * @return - the pointer to the new CK_BBOOL value
 980  */
 981 CK_BBOOL* jBooleanObjectToCKBBoolPtr(JNIEnv *env, jobject jObject)
 982 {
 983     jclass jObjectClass;
 984     jmethodID jValueMethod;
 985     jboolean jValue;
 986     CK_BBOOL *ckpValue;
 987 
 988     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Boolean&quot;);
 989     if (jObjectClass == NULL) { return NULL; }
 990     jValueMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;booleanValue&quot;, &quot;()Z&quot;);
 991     if (jValueMethod == NULL) { return NULL; }
 992     jValue = (*env)-&gt;CallBooleanMethod(env, jObject, jValueMethod);
 993     ckpValue = (CK_BBOOL *) malloc(sizeof(CK_BBOOL));
 994     if (ckpValue == NULL) {
 995         throwOutOfMemoryError(env, 0);
 996         return NULL;
 997     }
 998     *ckpValue = jBooleanToCKBBool(jValue);
 999 
1000     return ckpValue ;
1001 }
1002 
1003 /*
1004  * converts a Java byte object into a pointer to a CK_BYTE value. The memory has to be
1005  * freed after use!
1006  *
1007  * @param env - used to call JNI funktions to get the value out of the Java object
1008  * @param jObject - the &quot;java/lang/Byte&quot; object to convert
1009  * @return - the pointer to the new CK_BYTE value
1010  */
1011 CK_BYTE_PTR jByteObjectToCKBytePtr(JNIEnv *env, jobject jObject)
1012 {
1013     jclass jObjectClass;
1014     jmethodID jValueMethod;
1015     jbyte jValue;
1016     CK_BYTE_PTR ckpValue;
1017 
1018     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Byte&quot;);
1019     if (jObjectClass == NULL) { return NULL; }
1020     jValueMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;byteValue&quot;, &quot;()B&quot;);
1021     if (jValueMethod == NULL) { return NULL; }
1022     jValue = (*env)-&gt;CallByteMethod(env, jObject, jValueMethod);
1023     ckpValue = (CK_BYTE_PTR) malloc(sizeof(CK_BYTE));
1024     if (ckpValue == NULL) {
1025         throwOutOfMemoryError(env, 0);
1026         return NULL;
1027     }
1028     *ckpValue = jByteToCKByte(jValue);
1029     return ckpValue ;
1030 }
1031 
1032 /*
1033  * converts a Java integer object into a pointer to a CK_ULONG value. The memory has to be
1034  * freed after use!
1035  *
1036  * @param env - used to call JNI funktions to get the value out of the Java object
1037  * @param jObject - the &quot;java/lang/Integer&quot; object to convert
1038  * @return - the pointer to the new CK_ULONG value
1039  */
1040 CK_ULONG* jIntegerObjectToCKULongPtr(JNIEnv *env, jobject jObject)
1041 {
1042     jclass jObjectClass;
1043     jmethodID jValueMethod;
1044     jint jValue;
1045     CK_ULONG *ckpValue;
1046 
1047     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Integer&quot;);
1048     if (jObjectClass == NULL) { return NULL; }
1049     jValueMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;intValue&quot;, &quot;()I&quot;);
1050     if (jValueMethod == NULL) { return NULL; }
1051     jValue = (*env)-&gt;CallIntMethod(env, jObject, jValueMethod);
1052     ckpValue = (CK_ULONG *) malloc(sizeof(CK_ULONG));
1053     if (ckpValue == NULL) {
1054         throwOutOfMemoryError(env, 0);
1055         return NULL;
1056     }
1057     *ckpValue = jLongToCKLong(jValue);
1058     return ckpValue ;
1059 }
1060 
1061 /*
1062  * converts a Java long object into a pointer to a CK_ULONG value. The memory has to be
1063  * freed after use!
1064  *
1065  * @param env - used to call JNI funktions to get the value out of the Java object
1066  * @param jObject - the &quot;java/lang/Long&quot; object to convert
1067  * @return - the pointer to the new CK_ULONG value
1068  */
1069 CK_ULONG* jLongObjectToCKULongPtr(JNIEnv *env, jobject jObject)
1070 {
1071     jclass jObjectClass;
1072     jmethodID jValueMethod;
1073     jlong jValue;
1074     CK_ULONG *ckpValue;
1075 
1076     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Long&quot;);
1077     if (jObjectClass == NULL) { return NULL; }
1078     jValueMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;longValue&quot;, &quot;()J&quot;);
1079     if (jValueMethod == NULL) { return NULL; }
1080     jValue = (*env)-&gt;CallLongMethod(env, jObject, jValueMethod);
1081     ckpValue = (CK_ULONG *) malloc(sizeof(CK_ULONG));
1082     if (ckpValue == NULL) {
1083         throwOutOfMemoryError(env, 0);
1084         return NULL;
1085     }
1086     *ckpValue = jLongToCKULong(jValue);
1087 
1088     return ckpValue ;
1089 }
1090 
1091 /*
1092  * converts a Java char object into a pointer to a CK_CHAR value. The memory has to be
1093  * freed after use!
1094  *
1095  * @param env - used to call JNI funktions to get the value out of the Java object
1096  * @param jObject - the &quot;java/lang/Char&quot; object to convert
1097  * @return - the pointer to the new CK_CHAR value
1098  */
1099 CK_CHAR_PTR jCharObjectToCKCharPtr(JNIEnv *env, jobject jObject)
1100 {
1101     jclass jObjectClass;
1102     jmethodID jValueMethod;
1103     jchar jValue;
1104     CK_CHAR_PTR ckpValue;
1105 
1106     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Char&quot;);
1107     if (jObjectClass == NULL) { return NULL; }
1108     jValueMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;charValue&quot;, &quot;()C&quot;);
1109     if (jValueMethod == NULL) { return NULL; }
1110     jValue = (*env)-&gt;CallCharMethod(env, jObject, jValueMethod);
1111     ckpValue = (CK_CHAR_PTR) malloc(sizeof(CK_CHAR));
1112     if (ckpValue == NULL) {
1113         throwOutOfMemoryError(env, 0);
1114         return NULL;
1115     }
1116     *ckpValue = jCharToCKChar(jValue);
1117 
1118     return ckpValue ;
1119 }
1120 
1121 /*
1122  * converts a Java object into a pointer to CK-type or a CK-structure with the length in Bytes.
<a name="25" id="anc25"></a><span class="line-modified">1123  * The memory of the returned pointer MUST BE FREED BY CALLER!</span>

1124  *
1125  * @param env - used to call JNI funktions to get the Java classes and objects
1126  * @param jObject - the Java object to convert
<a name="26" id="anc26"></a><span class="line-modified">1127  * @param ckpLength - pointer to the length (bytes) of the newly-allocated CK-value or CK-structure</span>
<span class="line-modified">1128  * @return ckpObject - pointer to the newly-allocated CK-value or CK-structure</span>
1129  */
<a name="27" id="anc27"></a><span class="line-modified">1130 CK_VOID_PTR jObjectToPrimitiveCKObjectPtr(JNIEnv *env, jobject jObject, CK_ULONG *ckpLength)</span>
1131 {
1132     jclass jLongClass, jBooleanClass, jByteArrayClass, jCharArrayClass;
1133     jclass jByteClass, jDateClass, jCharacterClass, jIntegerClass;
1134     jclass jBooleanArrayClass, jIntArrayClass, jLongArrayClass;
1135     jclass jStringClass;
1136     jclass jObjectClass, jClassClass;
<a name="28" id="anc28"></a><span class="line-modified">1137     CK_VOID_PTR ckpObject;</span>
1138     jmethodID jMethod;
1139     jobject jClassObject;
1140     jstring jClassNameString;
1141     char *classNameString, *exceptionMsgPrefix, *exceptionMsg;
1142 
<a name="29" id="anc29"></a><span class="line-modified">1143     TRACE0(&quot;\nDEBUG: jObjectToPrimitiveCKObjectPtr&quot;);</span>
1144     if (jObject == NULL) {
<a name="30" id="anc30"></a>
1145         *ckpLength = 0;
<a name="31" id="anc31"></a><span class="line-modified">1146         return NULL;</span>
1147     }
1148 
1149     jLongClass = (*env)-&gt;FindClass(env, &quot;java/lang/Long&quot;);
<a name="32" id="anc32"></a><span class="line-modified">1150     if (jLongClass == NULL) { return NULL; }</span>
1151     if ((*env)-&gt;IsInstanceOf(env, jObject, jLongClass)) {
<a name="33" id="anc33"></a><span class="line-modified">1152         ckpObject = jLongObjectToCKULongPtr(env, jObject);</span>
1153         *ckpLength = sizeof(CK_ULONG);
<a name="34" id="anc34"></a><span class="line-modified">1154         TRACE1(&quot;&lt;converted long value %lu&gt;&quot;, *((CK_ULONG *) ckpObject));</span>
<span class="line-modified">1155         return ckpObject;</span>
1156     }
1157 
1158     jBooleanClass = (*env)-&gt;FindClass(env, &quot;java/lang/Boolean&quot;);
<a name="35" id="anc35"></a><span class="line-modified">1159     if (jBooleanClass == NULL) { return NULL; }</span>
1160     if ((*env)-&gt;IsInstanceOf(env, jObject, jBooleanClass)) {
<a name="36" id="anc36"></a><span class="line-modified">1161         ckpObject = jBooleanObjectToCKBBoolPtr(env, jObject);</span>
1162         *ckpLength = sizeof(CK_BBOOL);
1163         TRACE0(&quot; &lt;converted boolean value &quot;);
<a name="37" id="anc37"></a><span class="line-modified">1164         TRACE0((*((CK_BBOOL *) ckpObject) == TRUE) ? &quot;TRUE&gt;&quot; : &quot;FALSE&gt;&quot;);</span>
<span class="line-modified">1165         return ckpObject;</span>
1166     }
1167 
1168     jByteArrayClass = (*env)-&gt;FindClass(env, &quot;[B&quot;);
<a name="38" id="anc38"></a><span class="line-modified">1169     if (jByteArrayClass == NULL) { return NULL; }</span>
1170     if ((*env)-&gt;IsInstanceOf(env, jObject, jByteArrayClass)) {
<a name="39" id="anc39"></a><span class="line-modified">1171         jByteArrayToCKByteArray(env, jObject, (CK_BYTE_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">1172         return ckpObject;</span>
1173     }
1174 
1175     jCharArrayClass = (*env)-&gt;FindClass(env, &quot;[C&quot;);
<a name="40" id="anc40"></a><span class="line-modified">1176     if (jCharArrayClass == NULL) { return NULL; }</span>
1177     if ((*env)-&gt;IsInstanceOf(env, jObject, jCharArrayClass)) {
<a name="41" id="anc41"></a><span class="line-modified">1178         jCharArrayToCKUTF8CharArray(env, jObject, (CK_UTF8CHAR_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">1179         return ckpObject;</span>
1180     }
1181 
1182     jByteClass = (*env)-&gt;FindClass(env, &quot;java/lang/Byte&quot;);
<a name="42" id="anc42"></a><span class="line-modified">1183     if (jByteClass == NULL) { return NULL; }</span>
1184     if ((*env)-&gt;IsInstanceOf(env, jObject, jByteClass)) {
<a name="43" id="anc43"></a><span class="line-modified">1185         ckpObject = jByteObjectToCKBytePtr(env, jObject);</span>
1186         *ckpLength = sizeof(CK_BYTE);
<a name="44" id="anc44"></a><span class="line-modified">1187         TRACE1(&quot;&lt;converted byte value %X&gt;&quot;, *((CK_BYTE *) ckpObject));</span>
<span class="line-modified">1188         return ckpObject;</span>
1189     }
1190 
1191     jDateClass = (*env)-&gt;FindClass(env, CLASS_DATE);
<a name="45" id="anc45"></a><span class="line-modified">1192     if (jDateClass == NULL) { return NULL; }</span>
1193     if ((*env)-&gt;IsInstanceOf(env, jObject, jDateClass)) {
<a name="46" id="anc46"></a><span class="line-modified">1194         ckpObject = jDateObjectToCKDatePtr(env, jObject);</span>
1195         *ckpLength = sizeof(CK_DATE);
<a name="47" id="anc47"></a><span class="line-modified">1196         TRACE3(&quot;&lt;converted date value %.4s-%.2s-%.2s&gt;&quot;, ((CK_DATE *) ckpObject)-&gt;year,</span>
<span class="line-modified">1197                 ((CK_DATE *) ckpObject)-&gt;month, ((CK_DATE *) ckpObject)-&gt;day);</span>
<span class="line-added">1198         return ckpObject;</span>
1199     }
1200 
1201     jCharacterClass = (*env)-&gt;FindClass(env, &quot;java/lang/Character&quot;);
<a name="48" id="anc48"></a><span class="line-modified">1202     if (jCharacterClass == NULL) { return NULL; }</span>
1203     if ((*env)-&gt;IsInstanceOf(env, jObject, jCharacterClass)) {
<a name="49" id="anc49"></a><span class="line-modified">1204         ckpObject = jCharObjectToCKCharPtr(env, jObject);</span>
1205         *ckpLength = sizeof(CK_UTF8CHAR);
<a name="50" id="anc50"></a><span class="line-modified">1206         TRACE1(&quot;&lt;converted char value %c&gt;&quot;, *((CK_CHAR *) ckpObject));</span>
<span class="line-modified">1207         return ckpObject;</span>
1208     }
1209 
1210     jIntegerClass = (*env)-&gt;FindClass(env, &quot;java/lang/Integer&quot;);
<a name="51" id="anc51"></a><span class="line-modified">1211     if (jIntegerClass == NULL) { return NULL; }</span>
1212     if ((*env)-&gt;IsInstanceOf(env, jObject, jIntegerClass)) {
<a name="52" id="anc52"></a><span class="line-modified">1213         ckpObject = jIntegerObjectToCKULongPtr(env, jObject);</span>
1214         *ckpLength = sizeof(CK_ULONG);
<a name="53" id="anc53"></a><span class="line-modified">1215         TRACE1(&quot;&lt;converted integer value %lu&gt;&quot;, *((CK_ULONG *) ckpObject));</span>
<span class="line-modified">1216         return ckpObject;</span>
1217     }
1218 
1219     jBooleanArrayClass = (*env)-&gt;FindClass(env, &quot;[Z&quot;);
<a name="54" id="anc54"></a><span class="line-modified">1220     if (jBooleanArrayClass == NULL) { return NULL; }</span>
1221     if ((*env)-&gt;IsInstanceOf(env, jObject, jBooleanArrayClass)) {
<a name="55" id="anc55"></a><span class="line-modified">1222         jBooleanArrayToCKBBoolArray(env, jObject, (CK_BBOOL**) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">1223         return ckpObject;</span>
1224     }
1225 
1226     jIntArrayClass = (*env)-&gt;FindClass(env, &quot;[I&quot;);
<a name="56" id="anc56"></a><span class="line-modified">1227     if (jIntArrayClass == NULL) { return NULL; }</span>
1228     if ((*env)-&gt;IsInstanceOf(env, jObject, jIntArrayClass)) {
<a name="57" id="anc57"></a><span class="line-modified">1229         jLongArrayToCKULongArray(env, jObject, (CK_ULONG_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">1230         return ckpObject;</span>
1231     }
1232 
1233     jLongArrayClass = (*env)-&gt;FindClass(env, &quot;[J&quot;);
<a name="58" id="anc58"></a><span class="line-modified">1234     if (jLongArrayClass == NULL) { return NULL; }</span>
1235     if ((*env)-&gt;IsInstanceOf(env, jObject, jLongArrayClass)) {
<a name="59" id="anc59"></a><span class="line-modified">1236         jLongArrayToCKULongArray(env, jObject, (CK_ULONG_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">1237         return ckpObject;</span>
1238     }
1239 
1240     jStringClass = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
<a name="60" id="anc60"></a><span class="line-modified">1241     if (jStringClass == NULL) { return NULL; }</span>
1242     if ((*env)-&gt;IsInstanceOf(env, jObject, jStringClass)) {
<a name="61" id="anc61"></a><span class="line-modified">1243         jStringToCKUTF8CharArray(env, jObject, (CK_UTF8CHAR_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">1244         return ckpObject;</span>
1245     }
1246 
1247     /* type of jObject unknown, throw PKCS11RuntimeException */
1248     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Object&quot;);
<a name="62" id="anc62"></a><span class="line-modified">1249     if (jObjectClass == NULL) { return NULL; }</span>
1250     jMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;getClass&quot;, &quot;()Ljava/lang/Class;&quot;);
<a name="63" id="anc63"></a><span class="line-modified">1251     if (jMethod == NULL) { return NULL; }</span>
1252     jClassObject = (*env)-&gt;CallObjectMethod(env, jObject, jMethod);
1253     assert(jClassObject != 0);
1254     jClassClass = (*env)-&gt;FindClass(env, &quot;java/lang/Class&quot;);
<a name="64" id="anc64"></a><span class="line-modified">1255     if (jClassClass == NULL) { return NULL; }</span>
1256     jMethod = (*env)-&gt;GetMethodID(env, jClassClass, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;);
<a name="65" id="anc65"></a><span class="line-modified">1257     if (jMethod == NULL) { return NULL; }</span>
1258     jClassNameString = (jstring)
1259         (*env)-&gt;CallObjectMethod(env, jClassObject, jMethod);
1260     assert(jClassNameString != 0);
1261     classNameString = (char*)
1262         (*env)-&gt;GetStringUTFChars(env, jClassNameString, NULL);
<a name="66" id="anc66"></a><span class="line-modified">1263     if (classNameString == NULL) { return NULL; }</span>
1264     exceptionMsgPrefix = &quot;Java object of this class cannot be converted to native PKCS#11 type: &quot;;
1265     exceptionMsg = (char *)
<a name="67" id="anc67"></a><span class="line-modified">1266         malloc(strlen(exceptionMsgPrefix) + strlen(classNameString) + 1);</span>
1267     if (exceptionMsg == NULL) {
1268         (*env)-&gt;ReleaseStringUTFChars(env, jClassNameString, classNameString);
1269         throwOutOfMemoryError(env, 0);
<a name="68" id="anc68"></a><span class="line-modified">1270         return NULL;</span>
1271     }
1272     strcpy(exceptionMsg, exceptionMsgPrefix);
1273     strcat(exceptionMsg, classNameString);
1274     (*env)-&gt;ReleaseStringUTFChars(env, jClassNameString, classNameString);
1275     throwPKCS11RuntimeException(env, exceptionMsg);
1276     free(exceptionMsg);
<a name="69" id="anc69"></a>
1277     *ckpLength = 0;
1278 
1279     TRACE0(&quot;FINISHED\n&quot;);
<a name="70" id="anc70"></a><span class="line-added">1280     return NULL;</span>
1281 }
1282 
1283 #ifdef P11_MEMORYDEBUG
1284 
1285 #undef malloc
<a name="71" id="anc71"></a><span class="line-added">1286 #undef calloc</span>
1287 #undef free
1288 
1289 void *p11malloc(size_t c, char *file, int line) {
1290     void *p = malloc(c);
<a name="72" id="anc72"></a><span class="line-modified">1291     fprintf(stdout, &quot;malloc\t%08lX\t%lX\t%s:%d\n&quot;, ptr_to_jlong(p), c, file, line);</span>
<span class="line-added">1292     fflush(stdout);</span>
<span class="line-added">1293     return p;</span>
<span class="line-added">1294 }</span>
<span class="line-added">1295 </span>
<span class="line-added">1296 void *p11calloc(size_t c, size_t s, char *file, int line) {</span>
<span class="line-added">1297     void *p = calloc(c, s);</span>
<span class="line-added">1298     fprintf(stdout, &quot;calloc\t%08lX\t%lX\t%lX\t%s:%d\n&quot;, ptr_to_jlong(p), c, s, file, line);</span>
<span class="line-added">1299     fflush(stdout);</span>
1300     return p;
1301 }
1302 
1303 void p11free(void *p, char *file, int line) {
<a name="73" id="anc73"></a><span class="line-modified">1304     fprintf(stdout, &quot;free\t%08lX\t\t%s:%d\n&quot;, ptr_to_jlong(p), file, line);</span>
<span class="line-added">1305     fflush(stdout);</span>
1306     free(p);
1307 }
1308 
1309 #endif
1310 
1311 // prints a message to stdout if debug output is enabled
1312 void printDebug(const char *format, ...) {
1313     if (debug == JNI_TRUE) {
1314         va_list args;
1315         fprintf(stdout, &quot;sunpkcs11: &quot;);
1316         va_start(args, format);
1317         vfprintf(stdout, format, args);
1318         va_end(args);
1319         fflush(stdout);
1320     }
1321 }
1322 
<a name="74" id="anc74"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="74" type="hidden" />
</body>
</html>
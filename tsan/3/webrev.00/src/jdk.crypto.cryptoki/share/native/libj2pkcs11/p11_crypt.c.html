<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_crypt.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  */
  4 
  5 /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
  6  *
  7  * Redistribution and use in  source and binary forms, with or without
  8  * modification, are permitted  provided that the following conditions are met:
  9  *
 10  * 1. Redistributions of  source code must retain the above copyright notice,
 11  *    this list of conditions and the following disclaimer.
 12  *
 13  * 2. Redistributions in  binary form must reproduce the above copyright notice,
 14  *    this list of conditions and the following disclaimer in the documentation
 15  *    and/or other materials provided with the distribution.
 16  *
 17  * 3. The end-user documentation included with the redistribution, if any, must
 18  *    include the following acknowledgment:
 19  *
 20  *    &quot;This product includes software developed by IAIK of Graz University of
 21  *     Technology.&quot;
 22  *
 23  *    Alternately, this acknowledgment may appear in the software itself, if
 24  *    and wherever such third-party acknowledgments normally appear.
 25  *
 26  * 4. The names &quot;Graz University of Technology&quot; and &quot;IAIK of Graz University of
 27  *    Technology&quot; must not be used to endorse or promote products derived from
 28  *    this software without prior written permission.
 29  *
 30  * 5. Products derived from this software may not be called
 31  *    &quot;IAIK PKCS Wrapper&quot;, nor may &quot;IAIK&quot; appear in their name, without prior
 32  *    written permission of Graz University of Technology.
 33  *
 34  *  THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESSED OR IMPLIED
 35  *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 36  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 37  *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE LICENSOR BE
 38  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 39  *  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 40  *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 41  *  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 42  *  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 43  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 44  *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 45  *  POSSIBILITY  OF SUCH DAMAGE.
 46  * ===========================================================================
 47  */
 48 
 49 #include &quot;pkcs11wrapper.h&quot;
 50 
 51 #include &lt;stdio.h&gt;
 52 #include &lt;stdlib.h&gt;
 53 #include &lt;string.h&gt;
 54 #include &lt;assert.h&gt;
 55 
 56 #include &quot;sun_security_pkcs11_wrapper_PKCS11.h&quot;
 57 
 58 #ifdef P11_ENABLE_C_ENCRYPTINIT
 59 /*
 60  * Class:     sun_security_pkcs11_wrapper_PKCS11
 61  * Method:    C_EncryptInit
 62  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
 63  * Parametermapping:                    *PKCS11*
 64  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 65  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
 66  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey
 67  */
 68 JNIEXPORT void JNICALL
 69 Java_sun_security_pkcs11_wrapper_PKCS11_C_1EncryptInit
 70 (JNIEnv *env, jobject obj, jlong jSessionHandle,
 71  jobject jMechanism, jlong jKeyHandle)
 72 {
 73     CK_SESSION_HANDLE ckSessionHandle;
 74     CK_MECHANISM_PTR ckpMechanism = NULL;
 75     CK_MECHANISM_PTR ckpTemp;
 76     CK_OBJECT_HANDLE ckKeyHandle;
 77     CK_RV rv;
 78 
 79     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 80     if (ckpFunctions == NULL) { return; }
 81 
 82     ckSessionHandle = jLongToCKULong(jSessionHandle);
 83     ckKeyHandle = jLongToCKULong(jKeyHandle);
 84     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);
 85     TRACE1(&quot;DEBUG C_EncryptInit: created pMech = %p\n&quot;,
 86             ckpMechanism);
 87 
 88     if ((*env)-&gt;ExceptionCheck(env)) { return; }
 89 
 90     rv = (*ckpFunctions-&gt;C_EncryptInit)(ckSessionHandle, ckpMechanism,
 91                                         ckKeyHandle);
 92 
 93     if (ckpMechanism-&gt;mechanism == CKM_AES_GCM) {
 94         if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {
 95             // retry with CKM_GCM_PARAMS structure in pkcs11t.h
 96             TRACE0(&quot;DEBUG C_EncryptInit: retry with CK_GCM_PARAMS\n&quot;);
 97             ckpTemp = updateGCMParams(env, ckpMechanism);
 98             if (ckpTemp != NULL) { // only re-call if conversion succeeds
 99                 ckpMechanism = ckpTemp;
100                 rv = (*ckpFunctions-&gt;C_EncryptInit)(ckSessionHandle, ckpMechanism,
101                         ckKeyHandle);
102             }
103         }
104     }
105 
106     TRACE1(&quot;DEBUG C_EncryptInit: freed pMech = %p\n&quot;, ckpMechanism);
107     freeCKMechanismPtr(ckpMechanism);
108     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }
109 
110     TRACE0(&quot;FINISHED\n&quot;);
111 }
112 #endif
113 
114 #ifdef P11_ENABLE_C_ENCRYPT
115 /*
116  * Class:     sun_security_pkcs11_wrapper_PKCS11
117  * Method:    C_Encrypt
118  * Signature: (JJ[BIIJ[BII)I
119  * Parametermapping:                    *PKCS11*
120  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
121  * @param   jlong directIn              CK_BYTE_PTR pData
122  * @param   jbyteArray jData            CK_BYTE_PTR pData
123  *                                      CK_ULONG ulDataLen
124  * @param   jlong directOut             CK_BYTE_PTR pEncryptedData
125  * @return  jint encryptedDataLen       CK_BYTE_PTR pEncryptedData
126  *                                      CK_ULONG_PTR pulEncryptedDataLen
127  */
128 JNIEXPORT jint JNICALL
129 Java_sun_security_pkcs11_wrapper_PKCS11_C_1Encrypt
130 (JNIEnv *env, jobject obj, jlong jSessionHandle,
131  jlong directIn, jbyteArray jIn, jint jInOfs, jint jInLen,
132  jlong directOut, jbyteArray jOut, jint jOutOfs, jint jOutLen)
133 {
134     CK_SESSION_HANDLE ckSessionHandle;
135     CK_RV rv;
136 
137     CK_BYTE_PTR inBufP;
138     CK_BYTE_PTR outBufP;
139     CK_ULONG ckEncryptedLen = 0;
140 
141     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
142     if (ckpFunctions == NULL) { return 0; }
143 
144     ckSessionHandle = jLongToCKULong(jSessionHandle);
145 
146     if (directIn != 0) {
147       inBufP = (CK_BYTE_PTR) jlong_to_ptr(directIn);
148     } else {
149       inBufP = (*env)-&gt;GetPrimitiveArrayCritical(env, jIn, NULL);
150       if (inBufP == NULL) { return 0; }
151     }
152 
153     if (directOut != 0) {
154       outBufP = (CK_BYTE_PTR) jlong_to_ptr(directOut);
155     } else {
156       outBufP = (*env)-&gt;GetPrimitiveArrayCritical(env, jOut, NULL);
157       if (outBufP == NULL) {
158           goto cleanup;
159       }
160     }
161 
162     ckEncryptedLen = jOutLen;
163 
164     rv = (*ckpFunctions-&gt;C_Encrypt)(ckSessionHandle,
165                                     (CK_BYTE_PTR)(inBufP + jInOfs), jInLen,
166                                     (CK_BYTE_PTR)(outBufP + jOutOfs),
167                                     &amp;ckEncryptedLen);
168 
169     ckAssertReturnValueOK(env, rv);
170 
171 cleanup:
172     if (directIn == 0 &amp;&amp; inBufP != NULL) {
173         (*env)-&gt;ReleasePrimitiveArrayCritical(env, jIn, inBufP, JNI_ABORT);
174     }
175     if (directOut == 0 &amp;&amp; outBufP != NULL) {
176         (*env)-&gt;ReleasePrimitiveArrayCritical(env, jOut, outBufP, JNI_COMMIT);
177     }
178     return ckEncryptedLen;
179 }
180 #endif
181 
182 #ifdef P11_ENABLE_C_ENCRYPTUPDATE
183 /*
184  * Class:     sun_security_pkcs11_wrapper_PKCS11
185  * Method:    C_EncryptUpdate
186  * Signature: (J[BII[BII)I
187  * Parametermapping:                    *PKCS11*
188  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
189  * @param   jbyteArray jPart            CK_BYTE_PTR pPart
190  *                                      CK_ULONG ulPartLen
191  * @return  jbyteArray jEncryptedPart   CK_BYTE_PTR pEncryptedPart
192  *                                      CK_ULONG_PTR pulEncryptedPartLen
193  */
194 JNIEXPORT jint JNICALL
195 Java_sun_security_pkcs11_wrapper_PKCS11_C_1EncryptUpdate
196 (JNIEnv *env, jobject obj, jlong jSessionHandle,
197  jlong directIn, jbyteArray jIn, jint jInOfs, jint jInLen,
198  jlong directOut, jbyteArray jOut, jint jOutOfs, jint jOutLen)
199 {
200     CK_SESSION_HANDLE ckSessionHandle;
201     CK_RV rv;
202 
203     CK_BYTE_PTR inBufP;
204     CK_BYTE_PTR outBufP;
205     CK_ULONG ckEncryptedPartLen = 0;
206 
207     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
208     if (ckpFunctions == NULL) { return 0; }
209 
210     ckSessionHandle = jLongToCKULong(jSessionHandle);
211 
212     if (directIn != 0) {
213       inBufP = (CK_BYTE_PTR) jlong_to_ptr(directIn);
214     } else {
215       inBufP = (*env)-&gt;GetPrimitiveArrayCritical(env, jIn, NULL);
216       if (inBufP == NULL) { return 0; }
217     }
218 
219     if (directOut != 0) {
220       outBufP = (CK_BYTE_PTR) jlong_to_ptr(directOut);
221     } else {
222       outBufP = (*env)-&gt;GetPrimitiveArrayCritical(env, jOut, NULL);
223       if (outBufP == NULL) {
224           goto cleanup;
225       }
226     }
227 
228     ckEncryptedPartLen = jOutLen;
229 
230     rv = (*ckpFunctions-&gt;C_EncryptUpdate)(ckSessionHandle,
231                                           (CK_BYTE_PTR)(inBufP + jInOfs), jInLen,
232                                           (CK_BYTE_PTR)(outBufP + jOutOfs),
233                                           &amp;ckEncryptedPartLen);
234 
235     ckAssertReturnValueOK(env, rv);
236 
237 cleanup:
238     if (directIn == 0 &amp;&amp; inBufP != NULL) {
239         (*env)-&gt;ReleasePrimitiveArrayCritical(env, jIn, inBufP, JNI_ABORT);
240     }
241     if (directOut == 0 &amp;&amp; outBufP != NULL) {
242         (*env)-&gt;ReleasePrimitiveArrayCritical(env, jOut, outBufP, JNI_COMMIT);
243     }
244     return ckEncryptedPartLen;
245 }
246 #endif
247 
248 #ifdef P11_ENABLE_C_ENCRYPTFINAL
249 /*
250  * Class:     sun_security_pkcs11_wrapper_PKCS11
251  * Method:    C_EncryptFinal
252  * Signature: (J[BII)I
253  * Parametermapping:                        *PKCS11*
254  * @param   jlong jSessionHandle            CK_SESSION_HANDLE hSession
255  * @return  jbyteArray jLastEncryptedPart   CK_BYTE_PTR pLastEncryptedDataPart
256  *                                          CK_ULONG_PTR pulLastEncryptedDataPartLen
257  */
258 JNIEXPORT jint JNICALL
259 Java_sun_security_pkcs11_wrapper_PKCS11_C_1EncryptFinal
260 (JNIEnv *env, jobject obj, jlong jSessionHandle,
261  jlong directOut, jbyteArray jOut, jint jOutOfs, jint jOutLen)
262 {
263     CK_SESSION_HANDLE ckSessionHandle;
264     CK_RV rv;
265     CK_BYTE_PTR outBufP;
266     CK_ULONG ckLastEncryptedPartLen;
267 
268     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
269     if (ckpFunctions == NULL) { return 0; }
270 
271     ckSessionHandle = jLongToCKULong(jSessionHandle);
272 
273     if (directOut != 0) {
274       outBufP = (CK_BYTE_PTR) jlong_to_ptr(directOut);
275     } else {
276       outBufP = (*env)-&gt;GetPrimitiveArrayCritical(env, jOut, NULL);
277       if (outBufP == NULL) { return 0; }
278     }
279 
280     ckLastEncryptedPartLen = jOutLen;
281 
282     rv = (*ckpFunctions-&gt;C_EncryptFinal)(ckSessionHandle,
283                                          (CK_BYTE_PTR)(outBufP + jOutOfs),
284                                          &amp;ckLastEncryptedPartLen);
285 
286     if (directOut == 0) {
287         (*env)-&gt;ReleasePrimitiveArrayCritical(env, jOut, outBufP, JNI_COMMIT);
288     }
289 
290     ckAssertReturnValueOK(env, rv);
291 
292     return ckLastEncryptedPartLen;
293 }
294 #endif
295 
296 #ifdef P11_ENABLE_C_DECRYPTINIT
297 /*
298  * Class:     sun_security_pkcs11_wrapper_PKCS11
299  * Method:    C_DecryptInit
300  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
301  * Parametermapping:                    *PKCS11*
302  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
303  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
304  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey
305  */
306 JNIEXPORT void JNICALL
307 Java_sun_security_pkcs11_wrapper_PKCS11_C_1DecryptInit
308 (JNIEnv *env, jobject obj, jlong jSessionHandle,
309  jobject jMechanism, jlong jKeyHandle)
310 {
311     CK_SESSION_HANDLE ckSessionHandle;
312     CK_MECHANISM_PTR ckpMechanism = NULL;
313     CK_MECHANISM_PTR ckpTemp;
314     CK_OBJECT_HANDLE ckKeyHandle;
315     CK_RV rv;
316 
317     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
318     if (ckpFunctions == NULL) { return; }
319 
320     ckSessionHandle = jLongToCKULong(jSessionHandle);
321     ckKeyHandle = jLongToCKULong(jKeyHandle);
322     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);
323     TRACE1(&quot;DEBUG C_DecryptInit: created pMech = %p\n&quot;,
324             ckpMechanism);
325 
326     if ((*env)-&gt;ExceptionCheck(env)) { return; }
327 
328     rv = (*ckpFunctions-&gt;C_DecryptInit)(ckSessionHandle, ckpMechanism,
329                                         ckKeyHandle);
330 
331     if (ckpMechanism-&gt;mechanism == CKM_AES_GCM) {
332         if (rv == CKR_ARGUMENTS_BAD || rv == CKR_MECHANISM_PARAM_INVALID) {
333             // retry with CKM_GCM_PARAMS structure in pkcs11t.h
334             TRACE0(&quot;DEBUG C_DecryptInit: retry with CK_GCM_PARAMS\n&quot;);
335             ckpTemp = updateGCMParams(env, ckpMechanism);
336             if (ckpTemp != NULL) { // only re-call if conversion succeeds
337                 ckpMechanism = ckpTemp;
338                 rv = (*ckpFunctions-&gt;C_DecryptInit)(ckSessionHandle, ckpMechanism,
339                         ckKeyHandle);
340             }
341         }
342     }
343 
344     TRACE1(&quot;DEBUG C_DecryptInit: freed pMech = %p\n&quot;, ckpMechanism);
345     freeCKMechanismPtr(ckpMechanism);
346     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }
347 
348     TRACE0(&quot;FINISHED\n&quot;);
349 }
350 #endif
351 
352 #ifdef P11_ENABLE_C_DECRYPT
353 /*
354  * Class:     sun_security_pkcs11_wrapper_PKCS11
355  * Method:    C_Decrypt
356  * Signature: (JJ[BIIJ[BII)I
357  * Parametermapping:                    *PKCS11*
358  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
359  * @param   jbyteArray jEncryptedData   CK_BYTE_PTR pEncryptedData
360  *                                      CK_ULONG ulEncryptedDataLen
361  * @return  jbyteArray jData            CK_BYTE_PTR pData
362  *                                      CK_ULONG_PTR pulDataLen
363  */
364 JNIEXPORT jint JNICALL
365 Java_sun_security_pkcs11_wrapper_PKCS11_C_1Decrypt
366 (JNIEnv *env, jobject obj, jlong jSessionHandle,
367  jlong directIn, jbyteArray jIn, jint jInOfs, jint jInLen,
368  jlong directOut, jbyteArray jOut, jint jOutOfs, jint jOutLen)
369 {
370     CK_SESSION_HANDLE ckSessionHandle;
371     CK_RV rv;
372 
373     CK_BYTE_PTR inBufP;
374     CK_BYTE_PTR outBufP;
375     CK_ULONG ckOutLen = 0;
376 
377     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
378     if (ckpFunctions == NULL) { return 0; }
379 
380     ckSessionHandle = jLongToCKULong(jSessionHandle);
381 
382     if (directIn != 0) {
383       inBufP = (CK_BYTE_PTR) jlong_to_ptr(directIn);
384     } else {
385       inBufP = (*env)-&gt;GetPrimitiveArrayCritical(env, jIn, NULL);
386       if (inBufP == NULL) { return 0; }
387     }
388 
389     if (directOut != 0) {
390       outBufP = (CK_BYTE_PTR) jlong_to_ptr(directOut);
391     } else {
392       outBufP = (*env)-&gt;GetPrimitiveArrayCritical(env, jOut, NULL);
393       if (outBufP == NULL) {
394           goto cleanup;
395       }
396     }
397     ckOutLen = jOutLen;
398 
399     rv = (*ckpFunctions-&gt;C_Decrypt)(ckSessionHandle,
400                                     (CK_BYTE_PTR)(inBufP + jInOfs), jInLen,
401                                     (CK_BYTE_PTR)(outBufP + jOutOfs),
402                                     &amp;ckOutLen);
403 
404     ckAssertReturnValueOK(env, rv);
405 
406 cleanup:
407     if (directIn == 0 &amp;&amp; inBufP != NULL) {
408         (*env)-&gt;ReleasePrimitiveArrayCritical(env, jIn, inBufP, JNI_ABORT);
409     }
410     if (directOut == 0 &amp;&amp; outBufP != NULL) {
411         (*env)-&gt;ReleasePrimitiveArrayCritical(env, jOut, outBufP, JNI_COMMIT);
412     }
413     return ckOutLen;
414 }
415 #endif
416 
417 #ifdef P11_ENABLE_C_DECRYPTUPDATE
418 /*
419  * Class:     sun_security_pkcs11_wrapper_PKCS11
420  * Method:    C_DecryptUpdate
421  * Signature: (J[BII[BII)I
422  * Parametermapping:                    *PKCS11*
423  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
424  * @param   jbyteArray jEncryptedPart   CK_BYTE_PTR pEncryptedPart
425  *                                      CK_ULONG ulEncryptedPartLen
426  * @return  jbyteArray jPart            CK_BYTE_PTR pPart
427  *                                      CK_ULONG_PTR pulPartLen
428  */
429 JNIEXPORT jint JNICALL
430 Java_sun_security_pkcs11_wrapper_PKCS11_C_1DecryptUpdate
431 (JNIEnv *env, jobject obj, jlong jSessionHandle,
432  jlong directIn, jbyteArray jIn, jint jInOfs, jint jInLen,
433  jlong directOut, jbyteArray jOut, jint jOutOfs, jint jOutLen)
434 {
435     CK_SESSION_HANDLE ckSessionHandle;
436     CK_RV rv;
437 
438     CK_BYTE_PTR inBufP;
439     CK_BYTE_PTR outBufP;
440     CK_ULONG ckDecryptedPartLen = 0;
441 
442     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
443     if (ckpFunctions == NULL) { return 0; }
444 
445     ckSessionHandle = jLongToCKULong(jSessionHandle);
446 
447     if (directIn != 0) {
448       inBufP = (CK_BYTE_PTR) jlong_to_ptr(directIn);
449     } else {
450       inBufP = (*env)-&gt;GetPrimitiveArrayCritical(env, jIn, NULL);
451       if (inBufP == NULL) { return 0; }
452     }
453 
454     if (directOut != 0) {
455       outBufP = (CK_BYTE_PTR) jlong_to_ptr(directOut);
456     } else {
457       outBufP = (*env)-&gt;GetPrimitiveArrayCritical(env, jOut, NULL);
458       if (outBufP == NULL) {
459           goto cleanup;
460       }
461     }
462 
463     ckDecryptedPartLen = jOutLen;
464     rv = (*ckpFunctions-&gt;C_DecryptUpdate)(ckSessionHandle,
465                                           (CK_BYTE_PTR)(inBufP + jInOfs), jInLen,
466                                           (CK_BYTE_PTR)(outBufP + jOutOfs),
467                                           &amp;ckDecryptedPartLen);
468     ckAssertReturnValueOK(env, rv);
469 
470 cleanup:
471     if (directIn == 0 &amp;&amp; inBufP != NULL) {
472         (*env)-&gt;ReleasePrimitiveArrayCritical(env, jIn, inBufP, JNI_ABORT);
473     }
474     if (directOut == 0 &amp;&amp; outBufP != NULL) {
475         (*env)-&gt;ReleasePrimitiveArrayCritical(env, jOut, outBufP, JNI_COMMIT);
476     }
477     return ckDecryptedPartLen;
478 }
479 
480 #endif
481 
482 #ifdef P11_ENABLE_C_DECRYPTFINAL
483 /*
484  * Class:     sun_security_pkcs11_wrapper_PKCS11
485  * Method:    C_DecryptFinal
486  * Signature: (J[BII)I
487  * Parametermapping:                    *PKCS11*
488  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
489  * @return  jbyteArray jLastPart        CK_BYTE_PTR pLastPart
490  *                                      CK_ULONG_PTR pulLastPartLen
491  */
492 JNIEXPORT jint JNICALL
493 Java_sun_security_pkcs11_wrapper_PKCS11_C_1DecryptFinal
494 (JNIEnv *env, jobject obj, jlong jSessionHandle,
495  jlong directOut, jbyteArray jOut, jint jOutOfs, jint jOutLen)
496 {
497     CK_SESSION_HANDLE ckSessionHandle;
498     CK_RV rv;
499     CK_BYTE_PTR outBufP;
500     CK_ULONG ckLastPartLen;
501 
502     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
503     if (ckpFunctions == NULL) { return 0; }
504 
505     ckSessionHandle = jLongToCKULong(jSessionHandle);
506 
507     if (directOut != 0) {
508       outBufP = (CK_BYTE_PTR) jlong_to_ptr(directOut);
509     } else {
510       outBufP = (*env)-&gt;GetPrimitiveArrayCritical(env, jOut, NULL);
511       if (outBufP == NULL) { return 0; }
512     }
513 
514     ckLastPartLen = jOutLen;
515 
516     rv = (*ckpFunctions-&gt;C_DecryptFinal)(ckSessionHandle,
517                                          (CK_BYTE_PTR)(outBufP + jOutOfs),
518                                          &amp;ckLastPartLen);
519 
520     if (directOut == 0) {
521         (*env)-&gt;ReleasePrimitiveArrayCritical(env, jOut, outBufP, JNI_COMMIT);
522 
523     }
524 
525     ckAssertReturnValueOK(env, rv);
526 
527     return ckLastPartLen;
528 }
529 #endif
    </pre>
  </body>
</html>
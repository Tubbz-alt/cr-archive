<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_sign.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 
  5 /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
  6  *
  7  * Redistribution and use in  source and binary forms, with or without
  8  * modification, are permitted  provided that the following conditions are met:
  9  *
 10  * 1. Redistributions of  source code must retain the above copyright notice,
 11  *    this list of conditions and the following disclaimer.
 12  *
 13  * 2. Redistributions in  binary form must reproduce the above copyright notice,
 14  *    this list of conditions and the following disclaimer in the documentation
 15  *    and/or other materials provided with the distribution.
 16  *
 17  * 3. The end-user documentation included with the redistribution, if any, must
 18  *    include the following acknowledgment:
 19  *
 20  *    &quot;This product includes software developed by IAIK of Graz University of
 21  *     Technology.&quot;
 22  *
 23  *    Alternately, this acknowledgment may appear in the software itself, if
 24  *    and wherever such third-party acknowledgments normally appear.
 25  *
 26  * 4. The names &quot;Graz University of Technology&quot; and &quot;IAIK of Graz University of
 27  *    Technology&quot; must not be used to endorse or promote products derived from
 28  *    this software without prior written permission.
 29  *
 30  * 5. Products derived from this software may not be called
 31  *    &quot;IAIK PKCS Wrapper&quot;, nor may &quot;IAIK&quot; appear in their name, without prior
 32  *    written permission of Graz University of Technology.
 33  *
 34  *  THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESSED OR IMPLIED
 35  *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 36  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 37  *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE LICENSOR BE
 38  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 39  *  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 40  *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 41  *  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 42  *  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 43  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 44  *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 45  *  POSSIBILITY  OF SUCH DAMAGE.
 46  */
 47 
 48 #include &quot;pkcs11wrapper.h&quot;
 49 
 50 #include &lt;stdio.h&gt;
 51 #include &lt;stdlib.h&gt;
 52 #include &lt;string.h&gt;
 53 #include &lt;assert.h&gt;
 54 #include &quot;jlong.h&quot;
 55 
 56 #include &quot;sun_security_pkcs11_wrapper_PKCS11.h&quot;
 57 
 58 #ifdef P11_ENABLE_C_SIGNINIT
 59 /*
 60  * Class:     sun_security_pkcs11_wrapper_PKCS11
 61  * Method:    C_SignInit
 62  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
 63  * Parametermapping:                    *PKCS11*
 64  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 65  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<a name="2" id="anc2"></a><span class="line-modified"> 66  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
 67  */
 68 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignInit
 69     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
 70 {
 71     CK_SESSION_HANDLE ckSessionHandle;
<a name="3" id="anc3"></a><span class="line-modified"> 72     CK_MECHANISM ckMechanism;</span>
 73     CK_OBJECT_HANDLE ckKeyHandle;
 74     CK_RV rv;
 75 
 76     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 77     if (ckpFunctions == NULL) { return; }
 78 
<a name="4" id="anc4"></a>

 79     ckSessionHandle = jLongToCKULong(jSessionHandle);
<a name="5" id="anc5"></a><span class="line-modified"> 80     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>

 81     if ((*env)-&gt;ExceptionCheck(env)) { return; }
<a name="6" id="anc6"></a>
 82     ckKeyHandle = jLongToCKULong(jKeyHandle);
 83 
<a name="7" id="anc7"></a><span class="line-modified"> 84     rv = (*ckpFunctions-&gt;C_SignInit)(ckSessionHandle, &amp;ckMechanism, ckKeyHandle);</span>
 85 
<a name="8" id="anc8"></a><span class="line-modified"> 86     if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified"> 87         free(ckMechanism.pParameter);</span>




 88     }
<a name="9" id="anc9"></a><span class="line-modified"> 89 </span>
<span class="line-removed"> 90     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
 91 }
 92 #endif
 93 
 94 #ifdef P11_ENABLE_C_SIGN
 95 /*
 96  * Class:     sun_security_pkcs11_wrapper_PKCS11
 97  * Method:    C_Sign
<a name="10" id="anc10"></a><span class="line-modified"> 98  * Signature: (J[B)[B</span>
 99  * Parametermapping:                    *PKCS11*
100  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
101  * @param   jbyteArray jData            CK_BYTE_PTR pData
102  *                                      CK_ULONG ulDataLen
103  * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
104  *                                      CK_ULONG_PTR pulSignatureLen
105  */
106 JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1Sign
107     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jData)
108 {
109     CK_SESSION_HANDLE ckSessionHandle;
110     CK_BYTE_PTR ckpData = NULL_PTR;
<a name="11" id="anc11"></a><span class="line-removed">111     CK_BYTE_PTR ckpSignature;</span>
112     CK_ULONG ckDataLength;
<a name="12" id="anc12"></a><span class="line-modified">113     CK_ULONG ckSignatureLength = 0;</span>


114     jbyteArray jSignature = NULL;
115     CK_RV rv;
116 
117     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
118     if (ckpFunctions == NULL) { return NULL; }
119 
<a name="13" id="anc13"></a>

120     ckSessionHandle = jLongToCKULong(jSessionHandle);
121     jByteArrayToCKByteArray(env, jData, &amp;ckpData, &amp;ckDataLength);
<a name="14" id="anc14"></a><span class="line-modified">122     if ((*env)-&gt;ExceptionCheck(env)) { return NULL; }</span>
<span class="line-removed">123 </span>
<span class="line-removed">124     /* START standard code */</span>
<span class="line-removed">125 </span>
<span class="line-removed">126     /* first determine the length of the signature */</span>
<span class="line-removed">127     rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength, NULL_PTR, &amp;ckSignatureLength);</span>
<span class="line-removed">128     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {</span>
<span class="line-removed">129         free(ckpData);</span>
130         return NULL;
131     }
132 
<a name="15" id="anc15"></a><span class="line-modified">133     ckpSignature = (CK_BYTE_PTR) malloc(ckSignatureLength * sizeof(CK_BYTE));</span>
<span class="line-removed">134     if (ckpSignature == NULL) {</span>
<span class="line-removed">135         free(ckpData);</span>
<span class="line-removed">136         throwOutOfMemoryError(env, 0);</span>
<span class="line-removed">137         return NULL;</span>
<span class="line-removed">138     }</span>
139 
<a name="16" id="anc16"></a><span class="line-modified">140     /* now get the signature */</span>
<span class="line-modified">141     rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, &amp;ckSignatureLength);</span>
<span class="line-modified">142  /* END standard code */</span>
143 
<a name="17" id="anc17"></a>

144 
<a name="18" id="anc18"></a><span class="line-modified">145     /* START workaround code for operation abort bug in pkcs#11 of Datakey and iButton */</span>
<span class="line-removed">146 /*</span>
<span class="line-removed">147     ckpSignature = (CK_BYTE_PTR) malloc(256 * sizeof(CK_BYTE));</span>
<span class="line-removed">148     if (ckpSignature == NULL) {</span>
<span class="line-removed">149         free(ckpData);</span>
<span class="line-removed">150         throwOutOfMemoryError(env, 0);</span>
<span class="line-removed">151         return NULL;</span>
<span class="line-removed">152     }</span>
<span class="line-removed">153     rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, &amp;ckSignatureLength);</span>
154 
<a name="19" id="anc19"></a><span class="line-removed">155     if (rv == CKR_BUFFER_TOO_SMALL) {</span>
<span class="line-removed">156         free(ckpSignature);</span>
<span class="line-removed">157         ckpSignature = (CK_BYTE_PTR) malloc(ckSignatureLength * sizeof(CK_BYTE));</span>
<span class="line-removed">158         if (ckpSignature == NULL) {</span>
<span class="line-removed">159             free(ckpData);</span>
<span class="line-removed">160             throwOutOfMemoryError(env, 0);</span>
<span class="line-removed">161             return NULL;</span>
<span class="line-removed">162         }</span>
<span class="line-removed">163         rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, &amp;ckSignatureLength);</span>
<span class="line-removed">164     }</span>
<span class="line-removed">165  */</span>
<span class="line-removed">166     /* END workaround code */</span>
167     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
<a name="20" id="anc20"></a><span class="line-modified">168         jSignature = ckByteArrayToJByteArray(env, ckpSignature, ckSignatureLength);</span>

169     }
<a name="21" id="anc21"></a>
170     free(ckpData);
<a name="22" id="anc22"></a><span class="line-modified">171     free(ckpSignature);</span>
172 
<a name="23" id="anc23"></a><span class="line-modified">173     return jSignature ;</span>

174 }
175 #endif
176 
177 #ifdef P11_ENABLE_C_SIGNUPDATE
178 /*
179  * Class:     sun_security_pkcs11_wrapper_PKCS11
180  * Method:    C_SignUpdate
181  * Signature: (J[BII)V
182  * Parametermapping:                    *PKCS11*
183  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
184  * @param   jbyteArray jPart            CK_BYTE_PTR pPart
185  *                                      CK_ULONG ulPartLen
186  */
187 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignUpdate
188   (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong directIn, jbyteArray jIn, jint jInOfs, jint jInLen)
189 {
190     CK_SESSION_HANDLE ckSessionHandle;
191     CK_RV rv;
192     CK_BYTE_PTR bufP;
193     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
194     jsize bufLen;
195 
196     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
197     if (ckpFunctions == NULL) { return; }
198 
199     ckSessionHandle = jLongToCKULong(jSessionHandle);
200 
201     if (directIn != 0) {
202         rv = (*ckpFunctions-&gt;C_SignUpdate)(ckSessionHandle, (CK_BYTE_PTR) jlong_to_ptr(directIn), jInLen);
203         ckAssertReturnValueOK(env, rv);
204         return;
205     }
206 
207     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
208         bufLen = MAX_STACK_BUFFER_LEN;
209         bufP = BUF;
210     } else {
211         bufLen = min(MAX_HEAP_BUFFER_LEN, jInLen);
212         bufP = (CK_BYTE_PTR) malloc((size_t)bufLen);
213         if (bufP == NULL) {
214             throwOutOfMemoryError(env, 0);
215             return;
216         }
217     }
218 
219     while (jInLen &gt; 0) {
220         jsize chunkLen = min(bufLen, jInLen);
221         (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, chunkLen, (jbyte *)bufP);
222         if ((*env)-&gt;ExceptionCheck(env)) {
<a name="24" id="anc24"></a><span class="line-modified">223             if (bufP != BUF) { free(bufP); }</span>
<span class="line-removed">224             return;</span>
225         }
226         rv = (*ckpFunctions-&gt;C_SignUpdate)(ckSessionHandle, bufP, chunkLen);
227         if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
<a name="25" id="anc25"></a><span class="line-modified">228             if (bufP != BUF) {</span>
<span class="line-removed">229                 free(bufP);</span>
<span class="line-removed">230             }</span>
<span class="line-removed">231             return;</span>
232         }
233         jInOfs += chunkLen;
234         jInLen -= chunkLen;
235     }
236 
<a name="26" id="anc26"></a>
237     if (bufP != BUF) { free(bufP); }
<a name="27" id="anc27"></a>

238 }
239 #endif
240 
241 #ifdef P11_ENABLE_C_SIGNFINAL
242 /*
243  * Class:     sun_security_pkcs11_wrapper_PKCS11
244  * Method:    C_SignFinal
245  * Signature: (J)[B
246  * Parametermapping:                    *PKCS11*
247  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
248  * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
249  *                                      CK_ULONG_PTR pulSignatureLen
250  */
251 JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignFinal
252     (JNIEnv *env, jobject obj, jlong jSessionHandle, jint jExpectedLength)
253 {
254     CK_SESSION_HANDLE ckSessionHandle;
255     jbyteArray jSignature = NULL;
256     CK_RV rv;
257     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
258     CK_BYTE_PTR bufP = BUF;
259     CK_ULONG ckSignatureLength = MAX_STACK_BUFFER_LEN;
260 
261     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
262     if (ckpFunctions == NULL) { return NULL; }
263 
264     ckSessionHandle = jLongToCKULong(jSessionHandle);
265 
266     if ((jExpectedLength &gt; 0) &amp;&amp; ((CK_ULONG)jExpectedLength &lt; ckSignatureLength)) {
267         ckSignatureLength = jExpectedLength;
268     }
269 
270     rv = (*ckpFunctions-&gt;C_SignFinal)(ckSessionHandle, bufP, &amp;ckSignatureLength);
271     if (rv == CKR_BUFFER_TOO_SMALL) {
272         bufP = (CK_BYTE_PTR) malloc(ckSignatureLength);
273         if (bufP == NULL) {
274             throwOutOfMemoryError(env, 0);
275             return NULL;
276         }
277         rv = (*ckpFunctions-&gt;C_SignFinal)(ckSessionHandle, bufP, &amp;ckSignatureLength);
278     }
279     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
280         jSignature = ckByteArrayToJByteArray(env, bufP, ckSignatureLength);
281     }
282 
283     if (bufP != BUF) { free(bufP); }
284 
285     return jSignature;
286 }
287 #endif
288 
289 #ifdef P11_ENABLE_C_SIGNRECOVERINIT
290 /*
291  * Class:     sun_security_pkcs11_wrapper_PKCS11
292  * Method:    C_SignRecoverInit
293  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
294  * Parametermapping:                    *PKCS11*
295  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
296  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<a name="28" id="anc28"></a><span class="line-modified">297  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
298  */
299 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignRecoverInit
300     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
301 {
302     CK_SESSION_HANDLE ckSessionHandle;
<a name="29" id="anc29"></a><span class="line-modified">303     CK_MECHANISM ckMechanism;</span>
304     CK_OBJECT_HANDLE ckKeyHandle;
305     CK_RV rv;
306 
307     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
308     if (ckpFunctions == NULL) { return; }
309 
<a name="30" id="anc30"></a>

310     ckSessionHandle = jLongToCKULong(jSessionHandle);
<a name="31" id="anc31"></a><span class="line-modified">311     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
312     if ((*env)-&gt;ExceptionCheck(env)) { return; }
313 
314     ckKeyHandle = jLongToCKULong(jKeyHandle);
315 
<a name="32" id="anc32"></a><span class="line-modified">316     rv = (*ckpFunctions-&gt;C_SignRecoverInit)(ckSessionHandle, &amp;ckMechanism, ckKeyHandle);</span>
317 
<a name="33" id="anc33"></a><span class="line-modified">318     if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified">319         free(ckMechanism.pParameter);</span>




320     }
<a name="34" id="anc34"></a><span class="line-modified">321 </span>
<span class="line-removed">322     if(ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
323 }
324 #endif
325 
326 #ifdef P11_ENABLE_C_SIGNRECOVER
327 /*
328  * Class:     sun_security_pkcs11_wrapper_PKCS11
329  * Method:    C_SignRecover
330  * Signature: (J[BII[BII)I
331  * Parametermapping:                    *PKCS11*
332  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
333  * @param   jbyteArray jData            CK_BYTE_PTR pData
334  *                                      CK_ULONG ulDataLen
335  * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
336  *                                      CK_ULONG_PTR pulSignatureLen
337  */
338 JNIEXPORT jint JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignRecover
339   (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jIn, jint jInOfs, jint jInLen, jbyteArray jOut, jint jOutOfs, jint jOutLen)
340 {
341     CK_SESSION_HANDLE ckSessionHandle;
342     CK_RV rv;
343     CK_BYTE INBUF[MAX_STACK_BUFFER_LEN];
344     CK_BYTE OUTBUF[MAX_STACK_BUFFER_LEN];
345     CK_BYTE_PTR inBufP;
346     CK_BYTE_PTR outBufP = OUTBUF;
<a name="35" id="anc35"></a><span class="line-modified">347     CK_ULONG ckSignatureLength = MAX_STACK_BUFFER_LEN;</span>
348 
349     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
350     if (ckpFunctions == NULL) { return 0; }
351 
352     ckSessionHandle = jLongToCKULong(jSessionHandle);
353 
354     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
355         inBufP = INBUF;
<a name="36" id="anc36"></a>
356     } else {
357         inBufP = (CK_BYTE_PTR) malloc((size_t)jInLen);
358         if (inBufP == NULL) {
359             throwOutOfMemoryError(env, 0);
360             return 0;
361         }
<a name="37" id="anc37"></a>
362     }
363 
364     (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, jInLen, (jbyte *)inBufP);
365     if ((*env)-&gt;ExceptionCheck(env)) {
<a name="38" id="anc38"></a><span class="line-modified">366         if (inBufP != INBUF) { free(inBufP); }</span>
<span class="line-removed">367         return 0;</span>
368     }
<a name="39" id="anc39"></a>
369     rv = (*ckpFunctions-&gt;C_SignRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckSignatureLength);
370     /* re-alloc larger buffer if it fits into our Java buffer */
371     if ((rv == CKR_BUFFER_TOO_SMALL) &amp;&amp; (ckSignatureLength &lt;= jIntToCKULong(jOutLen))) {
372         outBufP = (CK_BYTE_PTR) malloc(ckSignatureLength);
373         if (outBufP == NULL) {
<a name="40" id="anc40"></a><span class="line-removed">374             if (inBufP != INBUF) {</span>
<span class="line-removed">375                 free(inBufP);</span>
<span class="line-removed">376             }</span>
377             throwOutOfMemoryError(env, 0);
<a name="41" id="anc41"></a><span class="line-modified">378             return 0;</span>
379         }
380         rv = (*ckpFunctions-&gt;C_SignRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckSignatureLength);
381     }
382     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
383         (*env)-&gt;SetByteArrayRegion(env, jOut, jOutOfs, ckSignatureLength, (jbyte *)outBufP);
384     }
<a name="42" id="anc42"></a><span class="line-modified">385 </span>
386     if (inBufP != INBUF) { free(inBufP); }
387     if (outBufP != OUTBUF) { free(outBufP); }
388 
389     return ckSignatureLength;
390 }
391 #endif
392 
393 #ifdef P11_ENABLE_C_VERIFYINIT
394 /*
395  * Class:     sun_security_pkcs11_wrapper_PKCS11
396  * Method:    C_VerifyInit
397  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
398  * Parametermapping:                    *PKCS11*
399  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
400  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<a name="43" id="anc43"></a><span class="line-modified">401  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
402  */
403 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyInit
404     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
405 {
406     CK_SESSION_HANDLE ckSessionHandle;
<a name="44" id="anc44"></a><span class="line-modified">407     CK_MECHANISM ckMechanism;</span>
408     CK_OBJECT_HANDLE ckKeyHandle;
409     CK_RV rv;
410 
411     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
412     if (ckpFunctions == NULL) { return; }
413 
<a name="45" id="anc45"></a>

414     ckSessionHandle = jLongToCKULong(jSessionHandle);
<a name="46" id="anc46"></a><span class="line-modified">415     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
<span class="line-modified">416     if ((*env)-&gt;ExceptionCheck(env)) { return; }</span>


417 
418     ckKeyHandle = jLongToCKULong(jKeyHandle);
419 
<a name="47" id="anc47"></a><span class="line-modified">420     rv = (*ckpFunctions-&gt;C_VerifyInit)(ckSessionHandle, &amp;ckMechanism, ckKeyHandle);</span>
421 
<a name="48" id="anc48"></a><span class="line-modified">422     if(ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified">423         free(ckMechanism.pParameter);</span>




424     }
<a name="49" id="anc49"></a><span class="line-modified">425 </span>
<span class="line-removed">426     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
427 }
428 #endif
429 
430 #ifdef P11_ENABLE_C_VERIFY
431 /*
432  * Class:     sun_security_pkcs11_wrapper_PKCS11
433  * Method:    C_Verify
434  * Signature: (J[B[B)V
435  * Parametermapping:                    *PKCS11*
436  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
437  * @param   jbyteArray jData            CK_BYTE_PTR pData
438  *                                      CK_ULONG ulDataLen
439  * @param   jbyteArray jSignature       CK_BYTE_PTR pSignature
440  *                                      CK_ULONG_PTR pulSignatureLen
441  */
442 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1Verify
443     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jData, jbyteArray jSignature)
444 {
445     CK_SESSION_HANDLE ckSessionHandle;
446     CK_BYTE_PTR ckpData = NULL_PTR;
447     CK_BYTE_PTR ckpSignature = NULL_PTR;
448     CK_ULONG ckDataLength;
449     CK_ULONG ckSignatureLength;
<a name="50" id="anc50"></a><span class="line-modified">450     CK_RV rv;</span>
451 
452     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
453     if (ckpFunctions == NULL) { return; }
454 
455     ckSessionHandle = jLongToCKULong(jSessionHandle);
<a name="51" id="anc51"></a>
456     jByteArrayToCKByteArray(env, jData, &amp;ckpData, &amp;ckDataLength);
<a name="52" id="anc52"></a><span class="line-modified">457     if ((*env)-&gt;ExceptionCheck(env)) { return; }</span>


458 
459     jByteArrayToCKByteArray(env, jSignature, &amp;ckpSignature, &amp;ckSignatureLength);
460     if ((*env)-&gt;ExceptionCheck(env)) {
<a name="53" id="anc53"></a><span class="line-modified">461         free(ckpData);</span>
<span class="line-removed">462         return;</span>
463     }
464 
465     /* verify the signature */
466     rv = (*ckpFunctions-&gt;C_Verify)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, ckSignatureLength);
467 
<a name="54" id="anc54"></a>
468     free(ckpData);
469     free(ckpSignature);
470 
<a name="55" id="anc55"></a><span class="line-modified">471     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
472 }
473 #endif
474 
475 #ifdef P11_ENABLE_C_VERIFYUPDATE
476 /*
477  * Class:     sun_security_pkcs11_wrapper_PKCS11
478  * Method:    C_VerifyUpdate
479  * Signature: (J[BII)V
480  * Parametermapping:                    *PKCS11*
481  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
482  * @param   jbyteArray jPart            CK_BYTE_PTR pPart
483  *                                      CK_ULONG ulPartLen
484  */
485 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyUpdate
486   (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong directIn, jbyteArray jIn, jint jInOfs, jint jInLen)
487 {
488     CK_SESSION_HANDLE ckSessionHandle;
489     CK_RV rv;
490     CK_BYTE_PTR bufP;
491     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
492     jsize bufLen;
493 
494     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
495     if (ckpFunctions == NULL) { return; }
496 
497     ckSessionHandle = jLongToCKULong(jSessionHandle);
498 
499     if (directIn != 0) {
500         rv = (*ckpFunctions-&gt;C_VerifyUpdate)(ckSessionHandle, (CK_BYTE_PTR)jlong_to_ptr(directIn), jInLen);
501         ckAssertReturnValueOK(env, rv);
502         return;
503     }
504 
505     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
506         bufLen = MAX_STACK_BUFFER_LEN;
507         bufP = BUF;
508     } else {
509         bufLen = min(MAX_HEAP_BUFFER_LEN, jInLen);
510         bufP = (CK_BYTE_PTR) malloc((size_t)bufLen);
511         if (bufP == NULL) {
512             throwOutOfMemoryError(env, 0);
<a name="56" id="anc56"></a><span class="line-modified">513             return;</span>
514         }
515     }
516 
517     while (jInLen &gt; 0) {
518         jsize chunkLen = min(bufLen, jInLen);
519         (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, chunkLen, (jbyte *)bufP);
520         if ((*env)-&gt;ExceptionCheck(env)) {
<a name="57" id="anc57"></a><span class="line-modified">521             if (bufP != BUF) { free(bufP); }</span>
<span class="line-removed">522             return;</span>
523         }
524 
525         rv = (*ckpFunctions-&gt;C_VerifyUpdate)(ckSessionHandle, bufP, chunkLen);
526         if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
<a name="58" id="anc58"></a><span class="line-modified">527             if (bufP != BUF) { free(bufP); }</span>
<span class="line-removed">528             return;</span>
529         }
530         jInOfs += chunkLen;
531         jInLen -= chunkLen;
532     }
533 
<a name="59" id="anc59"></a>
534     if (bufP != BUF) { free(bufP); }
535 }
536 #endif
537 
538 #ifdef P11_ENABLE_C_VERIFYFINAL
539 /*
540  * Class:     sun_security_pkcs11_wrapper_PKCS11
541  * Method:    C_VerifyFinal
542  * Signature: (J[B)V
543  * Parametermapping:                    *PKCS11*
544  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
545  * @param   jbyteArray jSignature       CK_BYTE_PTR pSignature
546  *                                      CK_ULONG ulSignatureLen
547  */
548 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyFinal
549     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jSignature)
550 {
551     CK_SESSION_HANDLE ckSessionHandle;
552     CK_BYTE_PTR ckpSignature = NULL_PTR;
553     CK_ULONG ckSignatureLength;
554     CK_RV rv;
555 
556     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
557     if (ckpFunctions == NULL) { return; }
558 
559     ckSessionHandle = jLongToCKULong(jSessionHandle);
560     jByteArrayToCKByteArray(env, jSignature, &amp;ckpSignature, &amp;ckSignatureLength);
<a name="60" id="anc60"></a><span class="line-modified">561     if ((*env)-&gt;ExceptionCheck(env)) { return; }</span>


562 
563     /* verify the signature */
564     rv = (*ckpFunctions-&gt;C_VerifyFinal)(ckSessionHandle, ckpSignature, ckSignatureLength);
565 
566     free(ckpSignature);
567 
<a name="61" id="anc61"></a><span class="line-modified">568     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
569 }
570 #endif
571 
572 #ifdef P11_ENABLE_C_VERIFYRECOVERINIT
573 /*
574  * Class:     sun_security_pkcs11_wrapper_PKCS11
575  * Method:    C_VerifyRecoverInit
576  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
577  * Parametermapping:                    *PKCS11*
578  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
579  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
580  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE hKey
581  */
582 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyRecoverInit
583     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
584 {
585     CK_SESSION_HANDLE ckSessionHandle;
<a name="62" id="anc62"></a><span class="line-modified">586     CK_MECHANISM ckMechanism;</span>
587     CK_OBJECT_HANDLE ckKeyHandle;
588     CK_RV rv;
589 
590     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
591     if (ckpFunctions == NULL) { return; }
592 
<a name="63" id="anc63"></a>

593     ckSessionHandle = jLongToCKULong(jSessionHandle);
<a name="64" id="anc64"></a><span class="line-modified">594     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
595     if ((*env)-&gt;ExceptionCheck(env)) { return; }
596 
597     ckKeyHandle = jLongToCKULong(jKeyHandle);
598 
<a name="65" id="anc65"></a><span class="line-modified">599     rv = (*ckpFunctions-&gt;C_VerifyRecoverInit)(ckSessionHandle, &amp;ckMechanism, ckKeyHandle);</span>
600 
<a name="66" id="anc66"></a><span class="line-modified">601     if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified">602         free(ckMechanism.pParameter);</span>




603     }
<a name="67" id="anc67"></a><span class="line-modified">604 </span>
<span class="line-removed">605     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
606 }
607 #endif
608 
609 #ifdef P11_ENABLE_C_VERIFYRECOVER
610 /*
611  * Class:     sun_security_pkcs11_wrapper_PKCS11
612  * Method:    C_VerifyRecover
613  * Signature: (J[BII[BII)I
614  * Parametermapping:                    *PKCS11*
615  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
616  * @param   jbyteArray jSignature       CK_BYTE_PTR pSignature
617  *                                      CK_ULONG ulSignatureLen
618  * @return  jbyteArray jData            CK_BYTE_PTR pData
619  *                                      CK_ULONG_PTR pulDataLen
620  */
621 JNIEXPORT jint JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyRecover
622   (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jIn, jint jInOfs, jint jInLen, jbyteArray jOut, jint jOutOfs, jint jOutLen)
623 {
624     CK_SESSION_HANDLE ckSessionHandle;
625     CK_RV rv;
626     CK_BYTE INBUF[MAX_STACK_BUFFER_LEN];
627     CK_BYTE OUTBUF[MAX_STACK_BUFFER_LEN];
628     CK_BYTE_PTR inBufP;
629     CK_BYTE_PTR outBufP = OUTBUF;
<a name="68" id="anc68"></a><span class="line-modified">630     CK_ULONG ckDataLength = MAX_STACK_BUFFER_LEN;</span>
631 
632     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
633     if (ckpFunctions == NULL) { return 0; }
634 
635     ckSessionHandle = jLongToCKULong(jSessionHandle);
636 
637     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
638         inBufP = INBUF;
<a name="69" id="anc69"></a>
639     } else {
640         inBufP = (CK_BYTE_PTR) malloc((size_t)jInLen);
641         if (inBufP == NULL) {
642             throwOutOfMemoryError(env, 0);
643             return 0;
644         }
<a name="70" id="anc70"></a>
645     }
646 
647     (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, jInLen, (jbyte *)inBufP);
648     if ((*env)-&gt;ExceptionCheck(env)) {
<a name="71" id="anc71"></a><span class="line-modified">649         if (inBufP != INBUF) { free(inBufP); }</span>
<span class="line-removed">650         return 0;</span>
651     }
652 
653     rv = (*ckpFunctions-&gt;C_VerifyRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckDataLength);
654 
655     /* re-alloc larger buffer if it fits into our Java buffer */
656     if ((rv == CKR_BUFFER_TOO_SMALL) &amp;&amp; (ckDataLength &lt;= jIntToCKULong(jOutLen))) {
657         outBufP = (CK_BYTE_PTR) malloc(ckDataLength);
658         if (outBufP == NULL) {
<a name="72" id="anc72"></a><span class="line-removed">659             if (inBufP != INBUF) { free(inBufP); }</span>
660             throwOutOfMemoryError(env, 0);
<a name="73" id="anc73"></a><span class="line-modified">661             return 0;</span>
662         }
663         rv = (*ckpFunctions-&gt;C_VerifyRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckDataLength);
664     }
665     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
666         (*env)-&gt;SetByteArrayRegion(env, jOut, jOutOfs, ckDataLength, (jbyte *)outBufP);
667     }
668 
<a name="74" id="anc74"></a>
669     if (inBufP != INBUF) { free(inBufP); }
670     if (outBufP != OUTBUF) { free(outBufP); }
671 
672     return ckDataLength;
673 }
674 #endif
<a name="75" id="anc75"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="75" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_sign.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="p11_sessmgmt.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="p11_util.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_sign.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.</span>
   */
  
  /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
   *
   * Redistribution and use in  source and binary forms, with or without
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   */
  
  /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
   *
   * Redistribution and use in  source and binary forms, with or without
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,43 ***</span>
   * Method:    C_SignInit
   * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
   * Parametermapping:                    *PKCS11*
   * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
   * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<span class="line-modified">!  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
   */
  JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignInit
      (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
  {
      CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">!     CK_MECHANISM ckMechanism;</span>
      CK_OBJECT_HANDLE ckKeyHandle;
      CK_RV rv;
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return; }
  
      ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">!     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
      if ((*env)-&gt;ExceptionCheck(env)) { return; }
      ckKeyHandle = jLongToCKULong(jKeyHandle);
  
<span class="line-modified">!     rv = (*ckpFunctions-&gt;C_SignInit)(ckSessionHandle, &amp;ckMechanism, ckKeyHandle);</span>
  
<span class="line-modified">!     if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified">!         free(ckMechanism.pParameter);</span>
      }
<span class="line-modified">! </span>
<span class="line-removed">-     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_SIGN
  /*
   * Class:     sun_security_pkcs11_wrapper_PKCS11
   * Method:    C_Sign
<span class="line-modified">!  * Signature: (J[B)[B</span>
   * Parametermapping:                    *PKCS11*
   * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
   * @param   jbyteArray jData            CK_BYTE_PTR pData
   *                                      CK_ULONG ulDataLen
   * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
<span class="line-new-header">--- 61,50 ---</span>
   * Method:    C_SignInit
   * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
   * Parametermapping:                    *PKCS11*
   * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
   * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<span class="line-modified">!  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
   */
  JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignInit
      (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
  {
      CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">!     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
      CK_OBJECT_HANDLE ckKeyHandle;
      CK_RV rv;
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return; }
  
<span class="line-added">+     TRACE0(&quot;DEBUG: C_SignInit\n&quot;);</span>
<span class="line-added">+ </span>
      ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">! </span>
<span class="line-added">+     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
      if ((*env)-&gt;ExceptionCheck(env)) { return; }
<span class="line-added">+ </span>
      ckKeyHandle = jLongToCKULong(jKeyHandle);
  
<span class="line-modified">!     rv = (*ckpFunctions-&gt;C_SignInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);</span>
  
<span class="line-modified">!     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK ||</span>
<span class="line-modified">!             (ckpMechanism-&gt;pParameter == NULL)) {</span>
<span class="line-added">+         freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         (*env)-&gt;SetLongField(env, jMechanism, mech_pHandleID, ptr_to_jlong(ckpMechanism));</span>
<span class="line-added">+         TRACE1(&quot;DEBUG C_SignInit: stored pMech = 0x%lX\n&quot;, ptr_to_jlong(ckpMechanism));</span>
      }
<span class="line-modified">!     TRACE0(&quot;FINISHED\n&quot;);</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_SIGN
  /*
   * Class:     sun_security_pkcs11_wrapper_PKCS11
   * Method:    C_Sign
<span class="line-modified">!  * Signature: (J[BI)[B</span>
   * Parametermapping:                    *PKCS11*
   * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
   * @param   jbyteArray jData            CK_BYTE_PTR pData
   *                                      CK_ULONG ulDataLen
   * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,73 ***</span>
  JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1Sign
      (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jData)
  {
      CK_SESSION_HANDLE ckSessionHandle;
      CK_BYTE_PTR ckpData = NULL_PTR;
<span class="line-removed">-     CK_BYTE_PTR ckpSignature;</span>
      CK_ULONG ckDataLength;
<span class="line-modified">!     CK_ULONG ckSignatureLength = 0;</span>
      jbyteArray jSignature = NULL;
      CK_RV rv;
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return NULL; }
  
      ckSessionHandle = jLongToCKULong(jSessionHandle);
      jByteArrayToCKByteArray(env, jData, &amp;ckpData, &amp;ckDataLength);
<span class="line-modified">!     if ((*env)-&gt;ExceptionCheck(env)) { return NULL; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* START standard code */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* first determine the length of the signature */</span>
<span class="line-removed">-     rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength, NULL_PTR, &amp;ckSignatureLength);</span>
<span class="line-removed">-     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {</span>
<span class="line-removed">-         free(ckpData);</span>
          return NULL;
      }
  
<span class="line-modified">!     ckpSignature = (CK_BYTE_PTR) malloc(ckSignatureLength * sizeof(CK_BYTE));</span>
<span class="line-removed">-     if (ckpSignature == NULL) {</span>
<span class="line-removed">-         free(ckpData);</span>
<span class="line-removed">-         throwOutOfMemoryError(env, 0);</span>
<span class="line-removed">-         return NULL;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     /* now get the signature */</span>
<span class="line-modified">!     rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, &amp;ckSignatureLength);</span>
<span class="line-modified">!  /* END standard code */</span>
  
  
<span class="line-modified">!     /* START workaround code for operation abort bug in pkcs#11 of Datakey and iButton */</span>
<span class="line-removed">- /*</span>
<span class="line-removed">-     ckpSignature = (CK_BYTE_PTR) malloc(256 * sizeof(CK_BYTE));</span>
<span class="line-removed">-     if (ckpSignature == NULL) {</span>
<span class="line-removed">-         free(ckpData);</span>
<span class="line-removed">-         throwOutOfMemoryError(env, 0);</span>
<span class="line-removed">-         return NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, &amp;ckSignatureLength);</span>
  
<span class="line-removed">-     if (rv == CKR_BUFFER_TOO_SMALL) {</span>
<span class="line-removed">-         free(ckpSignature);</span>
<span class="line-removed">-         ckpSignature = (CK_BYTE_PTR) malloc(ckSignatureLength * sizeof(CK_BYTE));</span>
<span class="line-removed">-         if (ckpSignature == NULL) {</span>
<span class="line-removed">-             free(ckpData);</span>
<span class="line-removed">-             throwOutOfMemoryError(env, 0);</span>
<span class="line-removed">-             return NULL;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, &amp;ckSignatureLength);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-  */</span>
<span class="line-removed">-     /* END workaround code */</span>
      if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
<span class="line-modified">!         jSignature = ckByteArrayToJByteArray(env, ckpSignature, ckSignatureLength);</span>
      }
      free(ckpData);
<span class="line-modified">!     free(ckpSignature);</span>
  
<span class="line-modified">!     return jSignature ;</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_SIGNUPDATE
  /*
<span class="line-new-header">--- 113,49 ---</span>
  JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1Sign
      (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jData)
  {
      CK_SESSION_HANDLE ckSessionHandle;
      CK_BYTE_PTR ckpData = NULL_PTR;
      CK_ULONG ckDataLength;
<span class="line-modified">!     CK_BYTE_PTR bufP;</span>
<span class="line-added">+     CK_ULONG ckSignatureLength;</span>
<span class="line-added">+     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];</span>
      jbyteArray jSignature = NULL;
      CK_RV rv;
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return NULL; }
  
<span class="line-added">+     TRACE0(&quot;DEBUG: C_Sign\n&quot;);</span>
<span class="line-added">+ </span>
      ckSessionHandle = jLongToCKULong(jSessionHandle);
      jByteArrayToCKByteArray(env, jData, &amp;ckpData, &amp;ckDataLength);
<span class="line-modified">!     if ((*env)-&gt;ExceptionCheck(env)) {</span>
          return NULL;
      }
  
<span class="line-modified">!     TRACE1(&quot;DEBUG C_Sign: data length = %lu\n&quot;, ckDataLength);</span>
  
<span class="line-modified">!     // unknown signature length</span>
<span class="line-modified">!     bufP = BUF;</span>
<span class="line-modified">!     ckSignatureLength = MAX_STACK_BUFFER_LEN;</span>
  
<span class="line-added">+     rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength,</span>
<span class="line-added">+         bufP, &amp;ckSignatureLength);</span>
  
<span class="line-modified">!     TRACE1(&quot;DEBUG C_Sign: ret rv=0x%lX\n&quot;, rv);</span>
  
      if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
<span class="line-modified">!         jSignature = ckByteArrayToJByteArray(env, bufP, ckSignatureLength);</span>
<span class="line-added">+         TRACE1(&quot;DEBUG C_Sign: signature length = %lu\n&quot;, ckSignatureLength);</span>
      }
<span class="line-added">+ </span>
      free(ckpData);
<span class="line-modified">!     if (bufP != BUF) { free(bufP); }</span>
  
<span class="line-modified">!     TRACE0(&quot;FINISHED\n&quot;);</span>
<span class="line-added">+     return jSignature;</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_SIGNUPDATE
  /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 218,25 ***</span>
  
      while (jInLen &gt; 0) {
          jsize chunkLen = min(bufLen, jInLen);
          (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, chunkLen, (jbyte *)bufP);
          if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">!             if (bufP != BUF) { free(bufP); }</span>
<span class="line-removed">-             return;</span>
          }
          rv = (*ckpFunctions-&gt;C_SignUpdate)(ckSessionHandle, bufP, chunkLen);
          if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
<span class="line-modified">!             if (bufP != BUF) {</span>
<span class="line-removed">-                 free(bufP);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return;</span>
          }
          jInOfs += chunkLen;
          jInLen -= chunkLen;
      }
  
      if (bufP != BUF) { free(bufP); }
  }
  #endif
  
  #ifdef P11_ENABLE_C_SIGNFINAL
  /*
<span class="line-new-header">--- 201,24 ---</span>
  
      while (jInLen &gt; 0) {
          jsize chunkLen = min(bufLen, jInLen);
          (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, chunkLen, (jbyte *)bufP);
          if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">!             goto cleanup;</span>
          }
          rv = (*ckpFunctions-&gt;C_SignUpdate)(ckSessionHandle, bufP, chunkLen);
          if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
<span class="line-modified">!             goto cleanup;</span>
          }
          jInOfs += chunkLen;
          jInLen -= chunkLen;
      }
  
<span class="line-added">+ cleanup:</span>
      if (bufP != BUF) { free(bufP); }
<span class="line-added">+ </span>
<span class="line-added">+     return;</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_SIGNFINAL
  /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 292,36 ***</span>
   * Method:    C_SignRecoverInit
   * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
   * Parametermapping:                    *PKCS11*
   * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
   * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<span class="line-modified">!  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
   */
  JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignRecoverInit
      (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
  {
      CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">!     CK_MECHANISM ckMechanism;</span>
      CK_OBJECT_HANDLE ckKeyHandle;
      CK_RV rv;
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return; }
  
      ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">!     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
      if ((*env)-&gt;ExceptionCheck(env)) { return; }
  
      ckKeyHandle = jLongToCKULong(jKeyHandle);
  
<span class="line-modified">!     rv = (*ckpFunctions-&gt;C_SignRecoverInit)(ckSessionHandle, &amp;ckMechanism, ckKeyHandle);</span>
  
<span class="line-modified">!     if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified">!         free(ckMechanism.pParameter);</span>
      }
<span class="line-modified">! </span>
<span class="line-removed">-     if(ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_SIGNRECOVER
  /*
<span class="line-new-header">--- 274,41 ---</span>
   * Method:    C_SignRecoverInit
   * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
   * Parametermapping:                    *PKCS11*
   * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
   * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<span class="line-modified">!  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
   */
  JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignRecoverInit
      (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
  {
      CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">!     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
      CK_OBJECT_HANDLE ckKeyHandle;
      CK_RV rv;
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return; }
  
<span class="line-added">+     TRACE0(&quot;DEBUG: C_SignRecoverInit\n&quot;);</span>
<span class="line-added">+ </span>
      ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">!     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
      if ((*env)-&gt;ExceptionCheck(env)) { return; }
  
      ckKeyHandle = jLongToCKULong(jKeyHandle);
  
<span class="line-modified">!     rv = (*ckpFunctions-&gt;C_SignRecoverInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);</span>
  
<span class="line-modified">!     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK ||</span>
<span class="line-modified">!             (ckpMechanism-&gt;pParameter == NULL)) {</span>
<span class="line-added">+         freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         (*env)-&gt;SetLongField(env, jMechanism, mech_pHandleID, ptr_to_jlong(ckpMechanism));</span>
<span class="line-added">+         TRACE1(&quot;DEBUG C_SignRecoverInit, stored pMech = 0x%lX\n&quot;, ptr_to_jlong(ckpMechanism));</span>
      }
<span class="line-modified">!     TRACE0(&quot;FINISHED\n&quot;);</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_SIGNRECOVER
  /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 342,49 ***</span>
      CK_RV rv;
      CK_BYTE INBUF[MAX_STACK_BUFFER_LEN];
      CK_BYTE OUTBUF[MAX_STACK_BUFFER_LEN];
      CK_BYTE_PTR inBufP;
      CK_BYTE_PTR outBufP = OUTBUF;
<span class="line-modified">!     CK_ULONG ckSignatureLength = MAX_STACK_BUFFER_LEN;</span>
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return 0; }
  
      ckSessionHandle = jLongToCKULong(jSessionHandle);
  
      if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
          inBufP = INBUF;
      } else {
          inBufP = (CK_BYTE_PTR) malloc((size_t)jInLen);
          if (inBufP == NULL) {
              throwOutOfMemoryError(env, 0);
              return 0;
          }
      }
  
      (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, jInLen, (jbyte *)inBufP);
      if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">!         if (inBufP != INBUF) { free(inBufP); }</span>
<span class="line-removed">-         return 0;</span>
      }
      rv = (*ckpFunctions-&gt;C_SignRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckSignatureLength);
      /* re-alloc larger buffer if it fits into our Java buffer */
      if ((rv == CKR_BUFFER_TOO_SMALL) &amp;&amp; (ckSignatureLength &lt;= jIntToCKULong(jOutLen))) {
          outBufP = (CK_BYTE_PTR) malloc(ckSignatureLength);
          if (outBufP == NULL) {
<span class="line-removed">-             if (inBufP != INBUF) {</span>
<span class="line-removed">-                 free(inBufP);</span>
<span class="line-removed">-             }</span>
              throwOutOfMemoryError(env, 0);
<span class="line-modified">!             return 0;</span>
          }
          rv = (*ckpFunctions-&gt;C_SignRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckSignatureLength);
      }
      if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
          (*env)-&gt;SetByteArrayRegion(env, jOut, jOutOfs, ckSignatureLength, (jbyte *)outBufP);
      }
<span class="line-modified">! </span>
      if (inBufP != INBUF) { free(inBufP); }
      if (outBufP != OUTBUF) { free(outBufP); }
  
      return ckSignatureLength;
  }
<span class="line-new-header">--- 329,48 ---</span>
      CK_RV rv;
      CK_BYTE INBUF[MAX_STACK_BUFFER_LEN];
      CK_BYTE OUTBUF[MAX_STACK_BUFFER_LEN];
      CK_BYTE_PTR inBufP;
      CK_BYTE_PTR outBufP = OUTBUF;
<span class="line-modified">!     CK_ULONG ckSignatureLength = 0;</span>
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return 0; }
  
      ckSessionHandle = jLongToCKULong(jSessionHandle);
  
      if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
          inBufP = INBUF;
<span class="line-added">+         ckSignatureLength = MAX_STACK_BUFFER_LEN;</span>
      } else {
          inBufP = (CK_BYTE_PTR) malloc((size_t)jInLen);
          if (inBufP == NULL) {
              throwOutOfMemoryError(env, 0);
              return 0;
          }
<span class="line-added">+         ckSignatureLength = jInLen;</span>
      }
  
      (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, jInLen, (jbyte *)inBufP);
      if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">!         goto cleanup;</span>
      }
<span class="line-added">+ </span>
      rv = (*ckpFunctions-&gt;C_SignRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckSignatureLength);
      /* re-alloc larger buffer if it fits into our Java buffer */
      if ((rv == CKR_BUFFER_TOO_SMALL) &amp;&amp; (ckSignatureLength &lt;= jIntToCKULong(jOutLen))) {
          outBufP = (CK_BYTE_PTR) malloc(ckSignatureLength);
          if (outBufP == NULL) {
              throwOutOfMemoryError(env, 0);
<span class="line-modified">!             goto cleanup;</span>
          }
          rv = (*ckpFunctions-&gt;C_SignRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckSignatureLength);
      }
      if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
          (*env)-&gt;SetByteArrayRegion(env, jOut, jOutOfs, ckSignatureLength, (jbyte *)outBufP);
      }
<span class="line-modified">! cleanup:</span>
      if (inBufP != INBUF) { free(inBufP); }
      if (outBufP != OUTBUF) { free(outBufP); }
  
      return ckSignatureLength;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 396,36 ***</span>
   * Method:    C_VerifyInit
   * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
   * Parametermapping:                    *PKCS11*
   * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
   * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<span class="line-modified">!  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
   */
  JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyInit
      (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
  {
      CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">!     CK_MECHANISM ckMechanism;</span>
      CK_OBJECT_HANDLE ckKeyHandle;
      CK_RV rv;
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return; }
  
      ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">!     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
<span class="line-modified">!     if ((*env)-&gt;ExceptionCheck(env)) { return; }</span>
  
      ckKeyHandle = jLongToCKULong(jKeyHandle);
  
<span class="line-modified">!     rv = (*ckpFunctions-&gt;C_VerifyInit)(ckSessionHandle, &amp;ckMechanism, ckKeyHandle);</span>
  
<span class="line-modified">!     if(ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified">!         free(ckMechanism.pParameter);</span>
      }
<span class="line-modified">! </span>
<span class="line-removed">-     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_VERIFY
  /*
<span class="line-new-header">--- 382,43 ---</span>
   * Method:    C_VerifyInit
   * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
   * Parametermapping:                    *PKCS11*
   * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
   * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<span class="line-modified">!  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
   */
  JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyInit
      (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
  {
      CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">!     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
      CK_OBJECT_HANDLE ckKeyHandle;
      CK_RV rv;
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return; }
  
<span class="line-added">+     TRACE0(&quot;DEBUG: C_VerifyInit\n&quot;);</span>
<span class="line-added">+ </span>
      ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">!     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
<span class="line-modified">!     if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
  
      ckKeyHandle = jLongToCKULong(jKeyHandle);
  
<span class="line-modified">!     rv = (*ckpFunctions-&gt;C_VerifyInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);</span>
  
<span class="line-modified">!     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK ||</span>
<span class="line-modified">!             (ckpMechanism-&gt;pParameter == NULL)) {</span>
<span class="line-added">+         freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         (*env)-&gt;SetLongField(env, jMechanism, mech_pHandleID, ptr_to_jlong(ckpMechanism));</span>
<span class="line-added">+         TRACE1(&quot;DEBUG C_VerifyInit: stored pMech = 0x%lX\n&quot;, ptr_to_jlong(ckpMechanism));</span>
      }
<span class="line-modified">!     TRACE0(&quot;FINISHED\n&quot;);</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_VERIFY
  /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 445,32 ***</span>
      CK_SESSION_HANDLE ckSessionHandle;
      CK_BYTE_PTR ckpData = NULL_PTR;
      CK_BYTE_PTR ckpSignature = NULL_PTR;
      CK_ULONG ckDataLength;
      CK_ULONG ckSignatureLength;
<span class="line-modified">!     CK_RV rv;</span>
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return; }
  
      ckSessionHandle = jLongToCKULong(jSessionHandle);
      jByteArrayToCKByteArray(env, jData, &amp;ckpData, &amp;ckDataLength);
<span class="line-modified">!     if ((*env)-&gt;ExceptionCheck(env)) { return; }</span>
  
      jByteArrayToCKByteArray(env, jSignature, &amp;ckpSignature, &amp;ckSignatureLength);
      if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">!         free(ckpData);</span>
<span class="line-removed">-         return;</span>
      }
  
      /* verify the signature */
      rv = (*ckpFunctions-&gt;C_Verify)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, ckSignatureLength);
  
      free(ckpData);
      free(ckpSignature);
  
<span class="line-modified">!     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_VERIFYUPDATE
  /*
<span class="line-new-header">--- 438,35 ---</span>
      CK_SESSION_HANDLE ckSessionHandle;
      CK_BYTE_PTR ckpData = NULL_PTR;
      CK_BYTE_PTR ckpSignature = NULL_PTR;
      CK_ULONG ckDataLength;
      CK_ULONG ckSignatureLength;
<span class="line-modified">!     CK_RV rv = 0;</span>
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return; }
  
      ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-added">+ </span>
      jByteArrayToCKByteArray(env, jData, &amp;ckpData, &amp;ckDataLength);
<span class="line-modified">!     if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
  
      jByteArrayToCKByteArray(env, jSignature, &amp;ckpSignature, &amp;ckSignatureLength);
      if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">!         goto cleanup;</span>
      }
  
      /* verify the signature */
      rv = (*ckpFunctions-&gt;C_Verify)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, ckSignatureLength);
  
<span class="line-added">+ cleanup:</span>
      free(ckpData);
      free(ckpSignature);
  
<span class="line-modified">!     ckAssertReturnValueOK(env, rv);</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_VERIFYUPDATE
  /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 508,31 ***</span>
      } else {
          bufLen = min(MAX_HEAP_BUFFER_LEN, jInLen);
          bufP = (CK_BYTE_PTR) malloc((size_t)bufLen);
          if (bufP == NULL) {
              throwOutOfMemoryError(env, 0);
<span class="line-modified">!             return;</span>
          }
      }
  
      while (jInLen &gt; 0) {
          jsize chunkLen = min(bufLen, jInLen);
          (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, chunkLen, (jbyte *)bufP);
          if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">!             if (bufP != BUF) { free(bufP); }</span>
<span class="line-removed">-             return;</span>
          }
  
          rv = (*ckpFunctions-&gt;C_VerifyUpdate)(ckSessionHandle, bufP, chunkLen);
          if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
<span class="line-modified">!             if (bufP != BUF) { free(bufP); }</span>
<span class="line-removed">-             return;</span>
          }
          jInOfs += chunkLen;
          jInLen -= chunkLen;
      }
  
      if (bufP != BUF) { free(bufP); }
  }
  #endif
  
  #ifdef P11_ENABLE_C_VERIFYFINAL
<span class="line-new-header">--- 504,30 ---</span>
      } else {
          bufLen = min(MAX_HEAP_BUFFER_LEN, jInLen);
          bufP = (CK_BYTE_PTR) malloc((size_t)bufLen);
          if (bufP == NULL) {
              throwOutOfMemoryError(env, 0);
<span class="line-modified">!             goto cleanup;</span>
          }
      }
  
      while (jInLen &gt; 0) {
          jsize chunkLen = min(bufLen, jInLen);
          (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, chunkLen, (jbyte *)bufP);
          if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">!             goto cleanup;</span>
          }
  
          rv = (*ckpFunctions-&gt;C_VerifyUpdate)(ckSessionHandle, bufP, chunkLen);
          if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
<span class="line-modified">!             goto cleanup;</span>
          }
          jInOfs += chunkLen;
          jInLen -= chunkLen;
      }
  
<span class="line-added">+ cleanup:</span>
      if (bufP != BUF) { free(bufP); }
  }
  #endif
  
  #ifdef P11_ENABLE_C_VERIFYFINAL
</pre>
<hr />
<pre>
<span class="line-old-header">*** 556,18 ***</span>
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return; }
  
      ckSessionHandle = jLongToCKULong(jSessionHandle);
      jByteArrayToCKByteArray(env, jSignature, &amp;ckpSignature, &amp;ckSignatureLength);
<span class="line-modified">!     if ((*env)-&gt;ExceptionCheck(env)) { return; }</span>
  
      /* verify the signature */
      rv = (*ckpFunctions-&gt;C_VerifyFinal)(ckSessionHandle, ckpSignature, ckSignatureLength);
  
      free(ckpSignature);
  
<span class="line-modified">!     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_VERIFYRECOVERINIT
  /*
<span class="line-new-header">--- 551,20 ---</span>
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return; }
  
      ckSessionHandle = jLongToCKULong(jSessionHandle);
      jByteArrayToCKByteArray(env, jSignature, &amp;ckpSignature, &amp;ckSignatureLength);
<span class="line-modified">!     if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
  
      /* verify the signature */
      rv = (*ckpFunctions-&gt;C_VerifyFinal)(ckSessionHandle, ckpSignature, ckSignatureLength);
  
      free(ckpSignature);
  
<span class="line-modified">!     ckAssertReturnValueOK(env, rv);</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_VERIFYRECOVERINIT
  /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 581,30 ***</span>
   */
  JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyRecoverInit
      (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
  {
      CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">!     CK_MECHANISM ckMechanism;</span>
      CK_OBJECT_HANDLE ckKeyHandle;
      CK_RV rv;
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return; }
  
      ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">!     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
      if ((*env)-&gt;ExceptionCheck(env)) { return; }
  
      ckKeyHandle = jLongToCKULong(jKeyHandle);
  
<span class="line-modified">!     rv = (*ckpFunctions-&gt;C_VerifyRecoverInit)(ckSessionHandle, &amp;ckMechanism, ckKeyHandle);</span>
  
<span class="line-modified">!     if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified">!         free(ckMechanism.pParameter);</span>
      }
<span class="line-modified">! </span>
<span class="line-removed">-     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_VERIFYRECOVER
  /*
<span class="line-new-header">--- 578,35 ---</span>
   */
  JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyRecoverInit
      (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
  {
      CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">!     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
      CK_OBJECT_HANDLE ckKeyHandle;
      CK_RV rv;
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return; }
  
<span class="line-added">+     TRACE0(&quot;DEBUG: C_VerifyRecoverInit\n&quot;);</span>
<span class="line-added">+ </span>
      ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">!     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
      if ((*env)-&gt;ExceptionCheck(env)) { return; }
  
      ckKeyHandle = jLongToCKULong(jKeyHandle);
  
<span class="line-modified">!     rv = (*ckpFunctions-&gt;C_VerifyRecoverInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);</span>
  
<span class="line-modified">!     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK ||</span>
<span class="line-modified">!             (ckpMechanism-&gt;pParameter == NULL)) {</span>
<span class="line-added">+         freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         (*env)-&gt;SetLongField(env, jMechanism, mech_pHandleID, ptr_to_jlong(ckpMechanism));</span>
<span class="line-added">+         TRACE1(&quot;DEBUG C_VerifyRecoverInit: stored pMech = 0x%lX\n&quot;, ptr_to_jlong(ckpMechanism));</span>
      }
<span class="line-modified">!     TRACE0(&quot;FINISHED\n&quot;);</span>
  }
  #endif
  
  #ifdef P11_ENABLE_C_VERIFYRECOVER
  /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 625,49 ***</span>
      CK_RV rv;
      CK_BYTE INBUF[MAX_STACK_BUFFER_LEN];
      CK_BYTE OUTBUF[MAX_STACK_BUFFER_LEN];
      CK_BYTE_PTR inBufP;
      CK_BYTE_PTR outBufP = OUTBUF;
<span class="line-modified">!     CK_ULONG ckDataLength = MAX_STACK_BUFFER_LEN;</span>
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return 0; }
  
      ckSessionHandle = jLongToCKULong(jSessionHandle);
  
      if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
          inBufP = INBUF;
      } else {
          inBufP = (CK_BYTE_PTR) malloc((size_t)jInLen);
          if (inBufP == NULL) {
              throwOutOfMemoryError(env, 0);
              return 0;
          }
      }
  
      (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, jInLen, (jbyte *)inBufP);
      if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">!         if (inBufP != INBUF) { free(inBufP); }</span>
<span class="line-removed">-         return 0;</span>
      }
  
      rv = (*ckpFunctions-&gt;C_VerifyRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckDataLength);
  
      /* re-alloc larger buffer if it fits into our Java buffer */
      if ((rv == CKR_BUFFER_TOO_SMALL) &amp;&amp; (ckDataLength &lt;= jIntToCKULong(jOutLen))) {
          outBufP = (CK_BYTE_PTR) malloc(ckDataLength);
          if (outBufP == NULL) {
<span class="line-removed">-             if (inBufP != INBUF) { free(inBufP); }</span>
              throwOutOfMemoryError(env, 0);
<span class="line-modified">!             return 0;</span>
          }
          rv = (*ckpFunctions-&gt;C_VerifyRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckDataLength);
      }
      if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
          (*env)-&gt;SetByteArrayRegion(env, jOut, jOutOfs, ckDataLength, (jbyte *)outBufP);
      }
  
      if (inBufP != INBUF) { free(inBufP); }
      if (outBufP != OUTBUF) { free(outBufP); }
  
      return ckDataLength;
  }
<span class="line-new-header">--- 627,50 ---</span>
      CK_RV rv;
      CK_BYTE INBUF[MAX_STACK_BUFFER_LEN];
      CK_BYTE OUTBUF[MAX_STACK_BUFFER_LEN];
      CK_BYTE_PTR inBufP;
      CK_BYTE_PTR outBufP = OUTBUF;
<span class="line-modified">!     CK_ULONG ckDataLength = 0;</span>
  
      CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
      if (ckpFunctions == NULL) { return 0; }
  
      ckSessionHandle = jLongToCKULong(jSessionHandle);
  
      if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
          inBufP = INBUF;
<span class="line-added">+         ckDataLength = MAX_STACK_BUFFER_LEN;</span>
      } else {
          inBufP = (CK_BYTE_PTR) malloc((size_t)jInLen);
          if (inBufP == NULL) {
              throwOutOfMemoryError(env, 0);
              return 0;
          }
<span class="line-added">+         ckDataLength = jInLen;</span>
      }
  
      (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, jInLen, (jbyte *)inBufP);
      if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">!         goto cleanup;</span>
      }
  
      rv = (*ckpFunctions-&gt;C_VerifyRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckDataLength);
  
      /* re-alloc larger buffer if it fits into our Java buffer */
      if ((rv == CKR_BUFFER_TOO_SMALL) &amp;&amp; (ckDataLength &lt;= jIntToCKULong(jOutLen))) {
          outBufP = (CK_BYTE_PTR) malloc(ckDataLength);
          if (outBufP == NULL) {
              throwOutOfMemoryError(env, 0);
<span class="line-modified">!             goto cleanup;</span>
          }
          rv = (*ckpFunctions-&gt;C_VerifyRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckDataLength);
      }
      if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
          (*env)-&gt;SetByteArrayRegion(env, jOut, jOutOfs, ckDataLength, (jbyte *)outBufP);
      }
  
<span class="line-added">+ cleanup:</span>
      if (inBufP != INBUF) { free(inBufP); }
      if (outBufP != OUTBUF) { free(outBufP); }
  
      return ckDataLength;
  }
</pre>
<center><a href="p11_sessmgmt.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="p11_util.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
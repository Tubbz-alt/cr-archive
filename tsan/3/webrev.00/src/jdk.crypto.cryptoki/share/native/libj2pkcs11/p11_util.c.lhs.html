<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_util.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 
   5 /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
   6  *
   7  * Redistribution and use in  source and binary forms, with or without
   8  * modification, are permitted  provided that the following conditions are met:
   9  *
  10  * 1. Redistributions of  source code must retain the above copyright notice,
  11  *    this list of conditions and the following disclaimer.
  12  *
  13  * 2. Redistributions in  binary form must reproduce the above copyright notice,
  14  *    this list of conditions and the following disclaimer in the documentation
  15  *    and/or other materials provided with the distribution.
  16  *
  17  * 3. The end-user documentation included with the redistribution, if any, must
  18  *    include the following acknowledgment:
  19  *
  20  *    &quot;This product includes software developed by IAIK of Graz University of
  21  *     Technology.&quot;
  22  *
  23  *    Alternately, this acknowledgment may appear in the software itself, if
  24  *    and wherever such third-party acknowledgments normally appear.
  25  *
  26  * 4. The names &quot;Graz University of Technology&quot; and &quot;IAIK of Graz University of
  27  *    Technology&quot; must not be used to endorse or promote products derived from
  28  *    this software without prior written permission.
  29  *
  30  * 5. Products derived from this software may not be called
  31  *    &quot;IAIK PKCS Wrapper&quot;, nor may &quot;IAIK&quot; appear in their name, without prior
  32  *    written permission of Graz University of Technology.
  33  *
  34  *  THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESSED OR IMPLIED
  35  *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  36  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  37  *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE LICENSOR BE
  38  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
  39  *  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  40  *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  41  *  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  42  *  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  43  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  44  *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  45  *  POSSIBILITY  OF SUCH DAMAGE.
  46  */
  47 
  48 #include &quot;pkcs11wrapper.h&quot;
  49 
  50 #include &lt;stdio.h&gt;
  51 #include &lt;stdlib.h&gt;
  52 #include &lt;string.h&gt;
  53 #include &lt;assert.h&gt;
  54 
  55 /* declare file private functions */
  56 
  57 ModuleData * getModuleEntry(JNIEnv *env, jobject pkcs11Implementation);
  58 int isModulePresent(JNIEnv *env, jobject pkcs11Implementation);
  59 void removeAllModuleEntries(JNIEnv *env);
  60 
  61 
  62 /* ************************************************************************** */
  63 /* Functions for keeping track of currently active and loaded modules         */
  64 /* ************************************************************************** */
  65 
  66 
  67 /*
  68  * Create a new object for locking.
  69  */
  70 jobject createLockObject(JNIEnv *env) {
  71     jclass jObjectClass;
  72     jobject jLockObject;
  73     jmethodID jConstructor;
  74 
  75     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Object&quot;);
  76     if (jObjectClass == NULL) { return NULL; }
  77     jConstructor = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
  78     if (jConstructor == NULL) { return NULL; }
  79     jLockObject = (*env)-&gt;NewObject(env, jObjectClass, jConstructor);
  80     if (jLockObject == NULL) { return NULL; }
  81     jLockObject = (*env)-&gt;NewGlobalRef(env, jLockObject);
  82 
  83     return jLockObject ;
  84 }
  85 
  86 /*
  87  * Create a new object for locking.
  88  */
  89 void destroyLockObject(JNIEnv *env, jobject jLockObject) {
  90     if (jLockObject != NULL) {
  91         (*env)-&gt;DeleteGlobalRef(env, jLockObject);
  92     }
  93 }
  94 
  95 /*
  96  * Add the given pkcs11Implementation object to the list of present modules.
  97  * Attach the given data to the entry. If the given pkcs11Implementation is
  98  * already in the lsit, just override its old module data with the new one.
  99  * None of the arguments can be NULL. If one of the arguments is NULL, this
 100  * function does nothing.
 101  */
 102 void putModuleEntry(JNIEnv *env, jobject pkcs11Implementation, ModuleData *moduleData) {
 103     if (pkcs11Implementation == NULL_PTR) {
 104         return ;
 105     }
 106     if (moduleData == NULL) {
 107         return ;
 108     }
 109     (*env)-&gt;SetLongField(env, pkcs11Implementation, pNativeDataID, ptr_to_jlong(moduleData));
 110 }
 111 
 112 
 113 /*
 114  * Get the module data of the entry for the given pkcs11Implementation. Returns
 115  * NULL, if the pkcs11Implementation is not in the list.
 116  */
 117 ModuleData * getModuleEntry(JNIEnv *env, jobject pkcs11Implementation) {
 118     jlong jData;
 119     if (pkcs11Implementation == NULL) {
 120         return NULL;
 121     }
 122     jData = (*env)-&gt;GetLongField(env, pkcs11Implementation, pNativeDataID);
 123     return (ModuleData*)jlong_to_ptr(jData);
 124 }
 125 
 126 CK_FUNCTION_LIST_PTR getFunctionList(JNIEnv *env, jobject pkcs11Implementation) {
 127     ModuleData *moduleData;
 128     CK_FUNCTION_LIST_PTR ckpFunctions;
 129 
 130     moduleData = getModuleEntry(env, pkcs11Implementation);
 131     if (moduleData == NULL) {
 132         throwDisconnectedRuntimeException(env);
 133         return NULL;
 134     }
 135     ckpFunctions = moduleData-&gt;ckFunctionListPtr;
 136     return ckpFunctions;
 137 }
 138 
 139 
 140 /*
 141  * Returns 1, if the given pkcs11Implementation is in the list.
 142  * 0, otherwise.
 143  */
 144 int isModulePresent(JNIEnv *env, jobject pkcs11Implementation) {
 145     int present;
 146 
 147     ModuleData *moduleData = getModuleEntry(env, pkcs11Implementation);
 148 
 149     present = (moduleData != NULL) ? 1 : 0;
 150 
 151     return present ;
 152 }
 153 
 154 
 155 /*
 156  * Removes the entry for the given pkcs11Implementation from the list. Returns
 157  * the module&#39;s data, after the node was removed. If this function returns NULL
 158  * the pkcs11Implementation was not in the list.
 159  */
 160 ModuleData * removeModuleEntry(JNIEnv *env, jobject pkcs11Implementation) {
 161     ModuleData *moduleData = getModuleEntry(env, pkcs11Implementation);
 162     if (moduleData == NULL) {
 163         return NULL;
 164     }
 165     (*env)-&gt;SetLongField(env, pkcs11Implementation, pNativeDataID, 0);
 166     return moduleData;
 167 }
 168 
 169 /*
 170  * Removes all present entries from the list of modules and frees all
 171  * associated resources. This function is used for clean-up.
 172  */
 173 void removeAllModuleEntries(JNIEnv *env) {
 174     /* XXX empty */
 175 }
 176 
 177 /* ************************************************************************** */
 178 /* Below there follow the helper functions to support conversions between     */
 179 /* Java and Cryptoki types                                                    */
 180 /* ************************************************************************** */
 181 
 182 /*
 183  * function to convert a PKCS#11 return value into a PKCS#11Exception
 184  *
 185  * This function generates a PKCS#11Exception with the returnValue as the errorcode
 186  * if the returnValue is not CKR_OK. The functin returns 0, if the returnValue is
 187  * CKR_OK. Otherwise, it returns the returnValue as a jLong.
 188  *
 189  * @param env - used to call JNI funktions and to get the Exception class
 190  * @param returnValue - of the PKCS#11 function
 191  */
 192 jlong ckAssertReturnValueOK(JNIEnv *env, CK_RV returnValue)
 193 {
 194     jclass jPKCS11ExceptionClass;
 195     jmethodID jConstructor;
 196     jthrowable jPKCS11Exception;
 197     jlong jErrorCode = 0L;
 198 
 199     if (returnValue != CKR_OK) {
 200         jErrorCode = ckULongToJLong(returnValue);
 201         jPKCS11ExceptionClass = (*env)-&gt;FindClass(env, CLASS_PKCS11EXCEPTION);
 202         if (jPKCS11ExceptionClass != NULL) {
 203             jConstructor = (*env)-&gt;GetMethodID(env, jPKCS11ExceptionClass, &quot;&lt;init&gt;&quot;, &quot;(J)V&quot;);
 204             if (jConstructor != NULL) {
 205                 jPKCS11Exception = (jthrowable) (*env)-&gt;NewObject(env, jPKCS11ExceptionClass, jConstructor, jErrorCode);
 206                 if (jPKCS11Exception != NULL) {
 207                     (*env)-&gt;Throw(env, jPKCS11Exception);
 208                 }
 209             }
 210         }
 211         (*env)-&gt;DeleteLocalRef(env, jPKCS11ExceptionClass);
 212     }
 213     return jErrorCode ;
 214 }
 215 
 216 
 217 /*
 218  * Throws a Java Exception by name
 219  */
 220 void throwByName(JNIEnv *env, const char *name, const char *msg)
 221 {
 222     jclass cls = (*env)-&gt;FindClass(env, name);
 223 
 224     if (cls != 0) /* Otherwise an exception has already been thrown */
 225         (*env)-&gt;ThrowNew(env, cls, msg);
 226 }
 227 
 228 /*
 229  * Throws java.lang.OutOfMemoryError
 230  */
 231 void throwOutOfMemoryError(JNIEnv *env, const char *msg)
 232 {
 233     throwByName(env, &quot;java/lang/OutOfMemoryError&quot;, msg);
 234 }
 235 
 236 /*
 237  * Throws java.lang.NullPointerException
 238  */
 239 void throwNullPointerException(JNIEnv *env, const char *msg)
 240 {
 241     throwByName(env, &quot;java/lang/NullPointerException&quot;, msg);
 242 }
 243 
 244 /*
 245  * Throws java.io.IOException
 246  */
 247 void throwIOException(JNIEnv *env, const char *msg)
 248 {
 249     throwByName(env, &quot;java/io/IOException&quot;, msg);
 250 }
 251 
 252 /*
 253  * This function simply throws a PKCS#11RuntimeException with the given
 254  * string as its message.
 255  *
 256  * @param env Used to call JNI funktions and to get the Exception class.
 257  * @param jmessage The message string of the Exception object.
 258  */
 259 void throwPKCS11RuntimeException(JNIEnv *env, const char *message)
 260 {
 261     throwByName(env, CLASS_PKCS11RUNTIMEEXCEPTION, message);
 262 }
 263 
 264 /*
 265  * This function simply throws a PKCS#11RuntimeException. The message says that
 266  * the object is not connected to the module.
 267  *
 268  * @param env Used to call JNI funktions and to get the Exception class.
 269  */
 270 void throwDisconnectedRuntimeException(JNIEnv *env)
 271 {
 272     throwPKCS11RuntimeException(env, &quot;This object is not connected to a module.&quot;);
 273 }
 274 
 275 /* This function frees the specified CK_ATTRIBUTE array.
 276  *
 277  * @param attrPtr pointer to the to-be-freed CK_ATTRIBUTE array.
 278  * @param len the length of the array
 279  */
<a name="2" id="anc2"></a><span class="line-modified"> 280 void freeCKAttributeArray(CK_ATTRIBUTE_PTR attrPtr, int len)</span>
<span class="line-modified"> 281 {</span>
<span class="line-modified"> 282     int i;</span>





























































































































 283 
<a name="3" id="anc3"></a><span class="line-modified"> 284     for (i=0; i&lt;len; i++) {</span>
<span class="line-modified"> 285         if (attrPtr[i].pValue != NULL_PTR) {</span>
<span class="line-modified"> 286             free(attrPtr[i].pValue);</span>
















 287         }
<a name="4" id="anc4"></a>















 288     }
<a name="5" id="anc5"></a><span class="line-modified"> 289     free(attrPtr);</span>
 290 }
 291 
 292 /*
 293  * the following functions convert Java arrays to PKCS#11 array pointers and
 294  * their array length and vice versa
 295  *
 296  * void j&lt;Type&gt;ArrayToCK&lt;Type&gt;Array(JNIEnv *env,
 297  *                                  const j&lt;Type&gt;Array jArray,
 298  *                                  CK_&lt;Type&gt;_PTR *ckpArray,
 299  *                                  CK_ULONG_PTR ckLength);
 300  *
 301  * j&lt;Type&gt;Array ck&lt;Type&gt;ArrayToJ&lt;Type&gt;Array(JNIEnv *env,
 302  *                                          const CK_&lt;Type&gt;_PTR ckpArray,
 303  *                                          CK_ULONG ckLength);
 304  *
 305  * PKCS#11 arrays consist always of a pointer to the beginning of the array and
 306  * the array length whereas Java arrays carry their array length.
 307  *
 308  * The Functions to convert a Java array to a PKCS#11 array are void functions.
 309  * Their arguments are the Java array object to convert, the reference to the
 310  * array pointer, where the new PKCS#11 array should be stored and the reference
 311  * to the array length where the PKCS#11 array length should be stored. These two
 312  * references must not be NULL_PTR.
 313  *
 314  * The functions first obtain the array length of the Java array and then allocate
 315  * the memory for the PKCS#11 array and set the array length. Then each element
 316  * gets converted depending on their type. After use the allocated memory of the
 317  * PKCS#11 array has to be explicitly freed.
 318  *
 319  * The Functions to convert a PKCS#11 array to a Java array get the PKCS#11 array
 320  * pointer and the array length and they return the new Java array object. The
 321  * Java array does not need to get freed after use.
 322  */
 323 
 324 /*
 325  * converts a jbooleanArray to a CK_BBOOL array. The allocated memory has to be freed after use!
 326  *
 327  * @param env - used to call JNI funktions to get the array informtaion
 328  * @param jArray - the Java array to convert
 329  * @param ckpArray - the reference, where the pointer to the new CK_BBOOL array will be stored
 330  * @param ckpLength - the reference, where the array length will be stored
 331  */
 332 void jBooleanArrayToCKBBoolArray(JNIEnv *env, const jbooleanArray jArray, CK_BBOOL **ckpArray, CK_ULONG_PTR ckpLength)
 333 {
 334     jboolean* jpTemp;
 335     CK_ULONG i;
 336 
 337     if(jArray == NULL) {
 338         *ckpArray = NULL_PTR;
 339         *ckpLength = 0L;
 340         return;
 341     }
 342     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<a name="6" id="anc6"></a><span class="line-modified"> 343     jpTemp = (jboolean*) malloc((*ckpLength) * sizeof(jboolean));</span>
 344     if (jpTemp == NULL) {
 345         throwOutOfMemoryError(env, 0);
 346         return;
 347     }
 348     (*env)-&gt;GetBooleanArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
 349     if ((*env)-&gt;ExceptionCheck(env)) {
 350         free(jpTemp);
 351         return;
 352     }
 353 
<a name="7" id="anc7"></a><span class="line-modified"> 354     *ckpArray = (CK_BBOOL*) malloc ((*ckpLength) * sizeof(CK_BBOOL));</span>
 355     if (*ckpArray == NULL) {
 356         free(jpTemp);
 357         throwOutOfMemoryError(env, 0);
 358         return;
 359     }
 360     for (i=0; i&lt;(*ckpLength); i++) {
 361         (*ckpArray)[i] = jBooleanToCKBBool(jpTemp[i]);
 362     }
 363     free(jpTemp);
 364 }
 365 
 366 /*
 367  * converts a jbyteArray to a CK_BYTE array. The allocated memory has to be freed after use!
 368  *
 369  * @param env - used to call JNI funktions to get the array informtaion
 370  * @param jArray - the Java array to convert
 371  * @param ckpArray - the reference, where the pointer to the new CK_BYTE array will be stored
 372  * @param ckpLength - the reference, where the array length will be stored
 373  */
 374 void jByteArrayToCKByteArray(JNIEnv *env, const jbyteArray jArray, CK_BYTE_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 375 {
 376     jbyte* jpTemp;
 377     CK_ULONG i;
 378 
 379     if(jArray == NULL) {
 380         *ckpArray = NULL_PTR;
 381         *ckpLength = 0L;
 382         return;
 383     }
 384     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<a name="8" id="anc8"></a><span class="line-modified"> 385     jpTemp = (jbyte*) malloc((*ckpLength) * sizeof(jbyte));</span>
 386     if (jpTemp == NULL) {
 387         throwOutOfMemoryError(env, 0);
 388         return;
 389     }
 390     (*env)-&gt;GetByteArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
 391     if ((*env)-&gt;ExceptionCheck(env)) {
 392         free(jpTemp);
 393         return;
 394     }
 395 
 396     /* if CK_BYTE is the same size as jbyte, we save an additional copy */
 397     if (sizeof(CK_BYTE) == sizeof(jbyte)) {
 398         *ckpArray = (CK_BYTE_PTR) jpTemp;
 399     } else {
<a name="9" id="anc9"></a><span class="line-modified"> 400         *ckpArray = (CK_BYTE_PTR) malloc ((*ckpLength) * sizeof(CK_BYTE));</span>
 401         if (*ckpArray == NULL) {
 402             free(jpTemp);
 403             throwOutOfMemoryError(env, 0);
 404             return;
 405         }
 406         for (i=0; i&lt;(*ckpLength); i++) {
 407             (*ckpArray)[i] = jByteToCKByte(jpTemp[i]);
 408         }
 409         free(jpTemp);
 410     }
 411 }
 412 
 413 /*
 414  * converts a jlongArray to a CK_ULONG array. The allocated memory has to be freed after use!
 415  *
 416  * @param env - used to call JNI funktions to get the array informtaion
 417  * @param jArray - the Java array to convert
 418  * @param ckpArray - the reference, where the pointer to the new CK_ULONG array will be stored
 419  * @param ckpLength - the reference, where the array length will be stored
 420  */
 421 void jLongArrayToCKULongArray(JNIEnv *env, const jlongArray jArray, CK_ULONG_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 422 {
 423     jlong* jTemp;
 424     CK_ULONG i;
 425 
 426     if(jArray == NULL) {
 427         *ckpArray = NULL_PTR;
 428         *ckpLength = 0L;
 429         return;
 430     }
 431     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<a name="10" id="anc10"></a><span class="line-modified"> 432     jTemp = (jlong*) malloc((*ckpLength) * sizeof(jlong));</span>
 433     if (jTemp == NULL) {
 434         throwOutOfMemoryError(env, 0);
 435         return;
 436     }
 437     (*env)-&gt;GetLongArrayRegion(env, jArray, 0, *ckpLength, jTemp);
 438     if ((*env)-&gt;ExceptionCheck(env)) {
 439         free(jTemp);
 440         return;
 441     }
 442 
<a name="11" id="anc11"></a><span class="line-modified"> 443     *ckpArray = (CK_ULONG_PTR) malloc (*ckpLength * sizeof(CK_ULONG));</span>
 444     if (*ckpArray == NULL) {
 445         free(jTemp);
 446         throwOutOfMemoryError(env, 0);
 447         return;
 448     }
 449     for (i=0; i&lt;(*ckpLength); i++) {
 450         (*ckpArray)[i] = jLongToCKULong(jTemp[i]);
 451     }
 452     free(jTemp);
 453 }
 454 
 455 /*
 456  * converts a jcharArray to a CK_CHAR array. The allocated memory has to be freed after use!
 457  *
 458  * @param env - used to call JNI funktions to get the array informtaion
 459  * @param jArray - the Java array to convert
 460  * @param ckpArray - the reference, where the pointer to the new CK_CHAR array will be stored
 461  * @param ckpLength - the reference, where the array length will be stored
 462  */
 463 void jCharArrayToCKCharArray(JNIEnv *env, const jcharArray jArray, CK_CHAR_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 464 {
 465     jchar* jpTemp;
 466     CK_ULONG i;
 467 
 468     if(jArray == NULL) {
 469         *ckpArray = NULL_PTR;
 470         *ckpLength = 0L;
 471         return;
 472     }
 473     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<a name="12" id="anc12"></a><span class="line-modified"> 474     jpTemp = (jchar*) malloc((*ckpLength) * sizeof(jchar));</span>
 475     if (jpTemp == NULL) {
 476         throwOutOfMemoryError(env, 0);
 477         return;
 478     }
 479     (*env)-&gt;GetCharArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
 480     if ((*env)-&gt;ExceptionCheck(env)) {
 481         free(jpTemp);
 482         return;
 483     }
 484 
<a name="13" id="anc13"></a><span class="line-modified"> 485     *ckpArray = (CK_CHAR_PTR) malloc (*ckpLength * sizeof(CK_CHAR));</span>
 486     if (*ckpArray == NULL) {
 487         free(jpTemp);
 488         throwOutOfMemoryError(env, 0);
 489         return;
 490     }
 491     for (i=0; i&lt;(*ckpLength); i++) {
 492         (*ckpArray)[i] = jCharToCKChar(jpTemp[i]);
 493     }
 494     free(jpTemp);
 495 }
 496 
 497 /*
 498  * converts a jcharArray to a CK_UTF8CHAR array. The allocated memory has to be freed after use!
 499  *
 500  * @param env - used to call JNI funktions to get the array informtaion
 501  * @param jArray - the Java array to convert
 502  * @param ckpArray - the reference, where the pointer to the new CK_UTF8CHAR array will be stored
 503  * @param ckpLength - the reference, where the array length will be stored
 504  */
 505 void jCharArrayToCKUTF8CharArray(JNIEnv *env, const jcharArray jArray, CK_UTF8CHAR_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 506 {
 507     jchar* jTemp;
 508     CK_ULONG i;
 509 
 510     if(jArray == NULL) {
 511         *ckpArray = NULL_PTR;
 512         *ckpLength = 0L;
 513         return;
 514     }
 515     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<a name="14" id="anc14"></a><span class="line-modified"> 516     jTemp = (jchar*) malloc((*ckpLength) * sizeof(jchar));</span>
 517     if (jTemp == NULL) {
 518         throwOutOfMemoryError(env, 0);
 519         return;
 520     }
 521     (*env)-&gt;GetCharArrayRegion(env, jArray, 0, *ckpLength, jTemp);
 522     if ((*env)-&gt;ExceptionCheck(env)) {
 523         free(jTemp);
 524         return;
 525     }
 526 
<a name="15" id="anc15"></a><span class="line-modified"> 527     *ckpArray = (CK_UTF8CHAR_PTR) malloc (*ckpLength * sizeof(CK_UTF8CHAR));</span>
 528     if (*ckpArray == NULL) {
 529         free(jTemp);
 530         throwOutOfMemoryError(env, 0);
 531         return;
 532     }
 533     for (i=0; i&lt;(*ckpLength); i++) {
 534         (*ckpArray)[i] = jCharToCKUTF8Char(jTemp[i]);
 535     }
 536     free(jTemp);
 537 }
 538 
 539 /*
 540  * converts a jstring to a CK_CHAR array. The allocated memory has to be freed after use!
 541  *
 542  * @param env - used to call JNI funktions to get the array informtaion
 543  * @param jArray - the Java array to convert
 544  * @param ckpArray - the reference, where the pointer to the new CK_CHAR array will be stored
 545  * @param ckpLength - the reference, where the array length will be stored
 546  */
 547 void jStringToCKUTF8CharArray(JNIEnv *env, const jstring jArray, CK_UTF8CHAR_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 548 {
 549     const char* pCharArray;
 550     jboolean isCopy;
 551 
 552     if(jArray == NULL) {
 553         *ckpArray = NULL_PTR;
 554         *ckpLength = 0L;
 555         return;
 556     }
 557 
 558     pCharArray = (*env)-&gt;GetStringUTFChars(env, jArray, &amp;isCopy);
 559     if (pCharArray == NULL) { return; }
 560 
 561     *ckpLength = (CK_ULONG) strlen(pCharArray);
<a name="16" id="anc16"></a><span class="line-modified"> 562     *ckpArray = (CK_UTF8CHAR_PTR) malloc((*ckpLength + 1) * sizeof(CK_UTF8CHAR));</span>
 563     if (*ckpArray == NULL) {
 564         (*env)-&gt;ReleaseStringUTFChars(env, (jstring) jArray, pCharArray);
 565         throwOutOfMemoryError(env, 0);
 566         return;
 567     }
 568     strcpy((char*)*ckpArray, pCharArray);
 569     (*env)-&gt;ReleaseStringUTFChars(env, (jstring) jArray, pCharArray);
 570 }
 571 
 572 /*
 573  * converts a jobjectArray with Java Attributes to a CK_ATTRIBUTE array. The allocated memory
 574  * has to be freed after use!
 575  *
 576  * @param env - used to call JNI funktions to get the array informtaion
 577  * @param jArray - the Java Attribute array (template) to convert
 578  * @param ckpArray - the reference, where the pointer to the new CK_ATTRIBUTE array will be
 579  *                   stored
 580  * @param ckpLength - the reference, where the array length will be stored
 581  */
 582 void jAttributeArrayToCKAttributeArray(JNIEnv *env, jobjectArray jArray, CK_ATTRIBUTE_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 583 {
 584     CK_ULONG i;
 585     jlong jLength;
 586     jobject jAttribute;
 587 
 588     TRACE0(&quot;\nDEBUG: jAttributeArrayToCKAttributeArray&quot;);
 589     if (jArray == NULL) {
 590         *ckpArray = NULL_PTR;
 591         *ckpLength = 0L;
 592         return;
 593     }
 594     jLength = (*env)-&gt;GetArrayLength(env, jArray);
 595     *ckpLength = jLongToCKULong(jLength);
<a name="17" id="anc17"></a><span class="line-modified"> 596     *ckpArray = (CK_ATTRIBUTE_PTR) malloc(*ckpLength * sizeof(CK_ATTRIBUTE));</span>
 597     if (*ckpArray == NULL) {
 598         throwOutOfMemoryError(env, 0);
 599         return;
 600     }
<a name="18" id="anc18"></a><span class="line-modified"> 601     TRACE1(&quot;, converting %d attributes&quot;, jLength);</span>
 602     for (i=0; i&lt;(*ckpLength); i++) {
<a name="19" id="anc19"></a><span class="line-modified"> 603         TRACE1(&quot;, getting %d. attribute&quot;, i);</span>
 604         jAttribute = (*env)-&gt;GetObjectArrayElement(env, jArray, i);
 605         if ((*env)-&gt;ExceptionCheck(env)) {
 606             freeCKAttributeArray(*ckpArray, i);
 607             return;
 608         }
<a name="20" id="anc20"></a><span class="line-modified"> 609         TRACE1(&quot;, jAttribute = %d&quot;, jAttribute);</span>
<span class="line-removed"> 610         TRACE1(&quot;, converting %d. attribute&quot;, i);</span>
 611         (*ckpArray)[i] = jAttributeToCKAttribute(env, jAttribute);
 612         if ((*env)-&gt;ExceptionCheck(env)) {
 613             freeCKAttributeArray(*ckpArray, i);
 614             return;
 615         }
 616     }
 617     TRACE0(&quot;FINISHED\n&quot;);
 618 }
 619 
 620 /*
 621  * converts a CK_BYTE array and its length to a jbyteArray.
 622  *
 623  * @param env - used to call JNI funktions to create the new Java array
 624  * @param ckpArray - the pointer to the CK_BYTE array to convert
 625  * @param ckpLength - the length of the array to convert
 626  * @return - the new Java byte array or NULL if error occurred
 627  */
 628 jbyteArray ckByteArrayToJByteArray(JNIEnv *env, const CK_BYTE_PTR ckpArray, CK_ULONG ckLength)
 629 {
 630     CK_ULONG i;
 631     jbyte* jpTemp;
 632     jbyteArray jArray;
 633 
 634     /* if CK_BYTE is the same size as jbyte, we save an additional copy */
 635     if (sizeof(CK_BYTE) == sizeof(jbyte)) {
 636         jpTemp = (jbyte*) ckpArray;
 637     } else {
<a name="21" id="anc21"></a><span class="line-modified"> 638         jpTemp = (jbyte*) malloc((ckLength) * sizeof(jbyte));</span>
 639         if (jpTemp == NULL) {
 640             throwOutOfMemoryError(env, 0);
 641             return NULL;
 642         }
 643         for (i=0; i&lt;ckLength; i++) {
 644             jpTemp[i] = ckByteToJByte(ckpArray[i]);
 645         }
 646     }
 647 
 648     jArray = (*env)-&gt;NewByteArray(env, ckULongToJSize(ckLength));
 649     if (jArray != NULL) {
 650         (*env)-&gt;SetByteArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 651     }
 652 
 653     if (sizeof(CK_BYTE) != sizeof(jbyte)) { free(jpTemp); }
 654 
 655     return jArray ;
 656 }
 657 
 658 /*
 659  * converts a CK_ULONG array and its length to a jlongArray.
 660  *
 661  * @param env - used to call JNI funktions to create the new Java array
 662  * @param ckpArray - the pointer to the CK_ULONG array to convert
 663  * @param ckpLength - the length of the array to convert
 664  * @return - the new Java long array
 665  */
 666 jlongArray ckULongArrayToJLongArray(JNIEnv *env, const CK_ULONG_PTR ckpArray, CK_ULONG ckLength)
 667 {
 668     CK_ULONG i;
 669     jlong* jpTemp;
 670     jlongArray jArray;
 671 
<a name="22" id="anc22"></a><span class="line-modified"> 672     jpTemp = (jlong*) malloc((ckLength) * sizeof(jlong));</span>
 673     if (jpTemp == NULL) {
 674         throwOutOfMemoryError(env, 0);
 675         return NULL;
 676     }
 677     for (i=0; i&lt;ckLength; i++) {
 678         jpTemp[i] = ckLongToJLong(ckpArray[i]);
 679     }
 680     jArray = (*env)-&gt;NewLongArray(env, ckULongToJSize(ckLength));
 681     if (jArray != NULL) {
 682         (*env)-&gt;SetLongArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 683     }
 684     free(jpTemp);
 685 
 686     return jArray ;
 687 }
 688 
 689 /*
 690  * converts a CK_CHAR array and its length to a jcharArray.
 691  *
 692  * @param env - used to call JNI funktions to create the new Java array
 693  * @param ckpArray - the pointer to the CK_CHAR array to convert
 694  * @param ckpLength - the length of the array to convert
 695  * @return - the new Java char array
 696  */
 697 jcharArray ckCharArrayToJCharArray(JNIEnv *env, const CK_CHAR_PTR ckpArray, CK_ULONG ckLength)
 698 {
 699     CK_ULONG i;
 700     jchar* jpTemp;
 701     jcharArray jArray;
 702 
<a name="23" id="anc23"></a><span class="line-modified"> 703     jpTemp = (jchar*) malloc(ckLength * sizeof(jchar));</span>
 704     if (jpTemp == NULL) {
 705         throwOutOfMemoryError(env, 0);
 706         return NULL;
 707     }
 708     for (i=0; i&lt;ckLength; i++) {
 709         jpTemp[i] = ckCharToJChar(ckpArray[i]);
 710     }
 711     jArray = (*env)-&gt;NewCharArray(env, ckULongToJSize(ckLength));
 712     if (jArray != NULL) {
 713         (*env)-&gt;SetCharArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 714     }
 715     free(jpTemp);
 716 
 717     return jArray ;
 718 }
 719 
 720 /*
 721  * converts a CK_UTF8CHAR array and its length to a jcharArray.
 722  *
 723  * @param env - used to call JNI funktions to create the new Java array
 724  * @param ckpArray - the pointer to the CK_UTF8CHAR array to convert
 725  * @param ckpLength - the length of the array to convert
 726  * @return - the new Java char array
 727  */
 728 jcharArray ckUTF8CharArrayToJCharArray(JNIEnv *env, const CK_UTF8CHAR_PTR ckpArray, CK_ULONG ckLength)
 729 {
 730     CK_ULONG i;
 731     jchar* jpTemp;
 732     jcharArray jArray;
 733 
<a name="24" id="anc24"></a><span class="line-modified"> 734     jpTemp = (jchar*) malloc(ckLength * sizeof(jchar));</span>
 735     if (jpTemp == NULL) {
 736         throwOutOfMemoryError(env, 0);
 737         return NULL;
 738     }
 739     for (i=0; i&lt;ckLength; i++) {
 740         jpTemp[i] = ckUTF8CharToJChar(ckpArray[i]);
 741     }
 742     jArray = (*env)-&gt;NewCharArray(env, ckULongToJSize(ckLength));
 743     if (jArray != NULL) {
 744         (*env)-&gt;SetCharArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 745     }
 746     free(jpTemp);
 747 
 748     return jArray ;
 749 }
 750 
 751 /*
 752  * the following functions convert Java objects to PKCS#11 pointers and the
 753  * length in bytes and vice versa
 754  *
 755  * CK_&lt;Type&gt;_PTR j&lt;Object&gt;ToCK&lt;Type&gt;Ptr(JNIEnv *env, jobject jObject);
 756  *
 757  * jobject ck&lt;Type&gt;PtrToJ&lt;Object&gt;(JNIEnv *env, const CK_&lt;Type&gt;_PTR ckpValue);
 758  *
 759  * The functions that convert a Java object to a PKCS#11 pointer first allocate
 760  * the memory for the PKCS#11 pointer. Then they set each element corresponding
 761  * to the fields in the Java object to convert. After use the allocated memory of
 762  * the PKCS#11 pointer has to be explicitly freed.
 763  *
 764  * The functions to convert a PKCS#11 pointer to a Java object create a new Java
 765  * object first and than they set all fields in the object depending on the values
 766  * of the type or structure where the PKCS#11 pointer points to.
 767  */
 768 
 769 /*
 770  * converts a CK_BBOOL pointer to a Java boolean Object.
 771  *
 772  * @param env - used to call JNI funktions to create the new Java object
 773  * @param ckpValue - the pointer to the CK_BBOOL value
 774  * @return - the new Java boolean object with the boolean value
 775  */
 776 jobject ckBBoolPtrToJBooleanObject(JNIEnv *env, const CK_BBOOL *ckpValue)
 777 {
 778     jclass jValueObjectClass;
 779     jmethodID jConstructor;
 780     jobject jValueObject;
 781     jboolean jValue;
 782 
 783     jValueObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Boolean&quot;);
 784     if (jValueObjectClass == NULL) { return NULL; }
 785     jConstructor = (*env)-&gt;GetMethodID(env, jValueObjectClass, &quot;&lt;init&gt;&quot;, &quot;(Z)V&quot;);
 786     if (jConstructor == NULL) { return NULL; }
 787     jValue = ckBBoolToJBoolean(*ckpValue);
 788     jValueObject = (*env)-&gt;NewObject(env, jValueObjectClass, jConstructor, jValue);
 789 
 790     return jValueObject ;
 791 }
 792 
 793 /*
 794  * converts a CK_ULONG pointer to a Java long Object.
 795  *
 796  * @param env - used to call JNI funktions to create the new Java object
 797  * @param ckpValue - the pointer to the CK_ULONG value
 798  * @return - the new Java long object with the long value
 799  */
 800 jobject ckULongPtrToJLongObject(JNIEnv *env, const CK_ULONG_PTR ckpValue)
 801 {
 802     jclass jValueObjectClass;
 803     jmethodID jConstructor;
 804     jobject jValueObject;
 805     jlong jValue;
 806 
 807     jValueObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Long&quot;);
 808     if (jValueObjectClass == NULL) { return NULL; }
 809     jConstructor = (*env)-&gt;GetMethodID(env, jValueObjectClass, &quot;&lt;init&gt;&quot;, &quot;(J)V&quot;);
 810     if (jConstructor == NULL) { return NULL; }
 811     jValue = ckULongToJLong(*ckpValue);
 812     jValueObject = (*env)-&gt;NewObject(env, jValueObjectClass, jConstructor, jValue);
 813 
 814     return jValueObject ;
 815 }
 816 
 817 /*
 818  * converts a Java boolean object into a pointer to a CK_BBOOL value. The memory has to be
 819  * freed after use!
 820  *
 821  * @param env - used to call JNI funktions to get the value out of the Java object
 822  * @param jObject - the &quot;java/lang/Boolean&quot; object to convert
 823  * @return - the pointer to the new CK_BBOOL value
 824  */
 825 CK_BBOOL* jBooleanObjectToCKBBoolPtr(JNIEnv *env, jobject jObject)
 826 {
 827     jclass jObjectClass;
 828     jmethodID jValueMethod;
 829     jboolean jValue;
 830     CK_BBOOL *ckpValue;
 831 
 832     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Boolean&quot;);
 833     if (jObjectClass == NULL) { return NULL; }
 834     jValueMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;booleanValue&quot;, &quot;()Z&quot;);
 835     if (jValueMethod == NULL) { return NULL; }
 836     jValue = (*env)-&gt;CallBooleanMethod(env, jObject, jValueMethod);
 837     ckpValue = (CK_BBOOL *) malloc(sizeof(CK_BBOOL));
 838     if (ckpValue == NULL) {
 839         throwOutOfMemoryError(env, 0);
 840         return NULL;
 841     }
 842     *ckpValue = jBooleanToCKBBool(jValue);
 843 
 844     return ckpValue ;
 845 }
 846 
 847 /*
 848  * converts a Java byte object into a pointer to a CK_BYTE value. The memory has to be
 849  * freed after use!
 850  *
 851  * @param env - used to call JNI funktions to get the value out of the Java object
 852  * @param jObject - the &quot;java/lang/Byte&quot; object to convert
 853  * @return - the pointer to the new CK_BYTE value
 854  */
 855 CK_BYTE_PTR jByteObjectToCKBytePtr(JNIEnv *env, jobject jObject)
 856 {
 857     jclass jObjectClass;
 858     jmethodID jValueMethod;
 859     jbyte jValue;
 860     CK_BYTE_PTR ckpValue;
 861 
 862     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Byte&quot;);
 863     if (jObjectClass == NULL) { return NULL; }
 864     jValueMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;byteValue&quot;, &quot;()B&quot;);
 865     if (jValueMethod == NULL) { return NULL; }
 866     jValue = (*env)-&gt;CallByteMethod(env, jObject, jValueMethod);
 867     ckpValue = (CK_BYTE_PTR) malloc(sizeof(CK_BYTE));
 868     if (ckpValue == NULL) {
 869         throwOutOfMemoryError(env, 0);
 870         return NULL;
 871     }
 872     *ckpValue = jByteToCKByte(jValue);
 873     return ckpValue ;
 874 }
 875 
 876 /*
 877  * converts a Java integer object into a pointer to a CK_ULONG value. The memory has to be
 878  * freed after use!
 879  *
 880  * @param env - used to call JNI funktions to get the value out of the Java object
 881  * @param jObject - the &quot;java/lang/Integer&quot; object to convert
 882  * @return - the pointer to the new CK_ULONG value
 883  */
 884 CK_ULONG* jIntegerObjectToCKULongPtr(JNIEnv *env, jobject jObject)
 885 {
 886     jclass jObjectClass;
 887     jmethodID jValueMethod;
 888     jint jValue;
 889     CK_ULONG *ckpValue;
 890 
 891     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Integer&quot;);
 892     if (jObjectClass == NULL) { return NULL; }
 893     jValueMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;intValue&quot;, &quot;()I&quot;);
 894     if (jValueMethod == NULL) { return NULL; }
 895     jValue = (*env)-&gt;CallIntMethod(env, jObject, jValueMethod);
 896     ckpValue = (CK_ULONG *) malloc(sizeof(CK_ULONG));
 897     if (ckpValue == NULL) {
 898         throwOutOfMemoryError(env, 0);
 899         return NULL;
 900     }
 901     *ckpValue = jLongToCKLong(jValue);
 902     return ckpValue ;
 903 }
 904 
 905 /*
 906  * converts a Java long object into a pointer to a CK_ULONG value. The memory has to be
 907  * freed after use!
 908  *
 909  * @param env - used to call JNI funktions to get the value out of the Java object
 910  * @param jObject - the &quot;java/lang/Long&quot; object to convert
 911  * @return - the pointer to the new CK_ULONG value
 912  */
 913 CK_ULONG* jLongObjectToCKULongPtr(JNIEnv *env, jobject jObject)
 914 {
 915     jclass jObjectClass;
 916     jmethodID jValueMethod;
 917     jlong jValue;
 918     CK_ULONG *ckpValue;
 919 
 920     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Long&quot;);
 921     if (jObjectClass == NULL) { return NULL; }
 922     jValueMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;longValue&quot;, &quot;()J&quot;);
 923     if (jValueMethod == NULL) { return NULL; }
 924     jValue = (*env)-&gt;CallLongMethod(env, jObject, jValueMethod);
 925     ckpValue = (CK_ULONG *) malloc(sizeof(CK_ULONG));
 926     if (ckpValue == NULL) {
 927         throwOutOfMemoryError(env, 0);
 928         return NULL;
 929     }
 930     *ckpValue = jLongToCKULong(jValue);
 931 
 932     return ckpValue ;
 933 }
 934 
 935 /*
 936  * converts a Java char object into a pointer to a CK_CHAR value. The memory has to be
 937  * freed after use!
 938  *
 939  * @param env - used to call JNI funktions to get the value out of the Java object
 940  * @param jObject - the &quot;java/lang/Char&quot; object to convert
 941  * @return - the pointer to the new CK_CHAR value
 942  */
 943 CK_CHAR_PTR jCharObjectToCKCharPtr(JNIEnv *env, jobject jObject)
 944 {
 945     jclass jObjectClass;
 946     jmethodID jValueMethod;
 947     jchar jValue;
 948     CK_CHAR_PTR ckpValue;
 949 
 950     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Char&quot;);
 951     if (jObjectClass == NULL) { return NULL; }
 952     jValueMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;charValue&quot;, &quot;()C&quot;);
 953     if (jValueMethod == NULL) { return NULL; }
 954     jValue = (*env)-&gt;CallCharMethod(env, jObject, jValueMethod);
 955     ckpValue = (CK_CHAR_PTR) malloc(sizeof(CK_CHAR));
 956     if (ckpValue == NULL) {
 957         throwOutOfMemoryError(env, 0);
 958         return NULL;
 959     }
 960     *ckpValue = jCharToCKChar(jValue);
 961 
 962     return ckpValue ;
 963 }
 964 
 965 /*
 966  * converts a Java object into a pointer to CK-type or a CK-structure with the length in Bytes.
<a name="25" id="anc25"></a><span class="line-modified"> 967  * The memory of *ckpObjectPtr to be freed after use! This function is only used by</span>
<span class="line-removed"> 968  * jAttributeToCKAttribute by now.</span>
 969  *
 970  * @param env - used to call JNI funktions to get the Java classes and objects
 971  * @param jObject - the Java object to convert
<a name="26" id="anc26"></a><span class="line-modified"> 972  * @param ckpObjectPtr - the reference of the new pointer to the new CK-value or CK-structure</span>
<span class="line-modified"> 973  * @param ckpLength - the reference of the length in bytes of the new CK-value or CK-structure</span>
 974  */
<a name="27" id="anc27"></a><span class="line-modified"> 975 void jObjectToPrimitiveCKObjectPtrPtr(JNIEnv *env, jobject jObject, CK_VOID_PTR *ckpObjectPtr, CK_ULONG *ckpLength)</span>
 976 {
 977     jclass jLongClass, jBooleanClass, jByteArrayClass, jCharArrayClass;
 978     jclass jByteClass, jDateClass, jCharacterClass, jIntegerClass;
 979     jclass jBooleanArrayClass, jIntArrayClass, jLongArrayClass;
 980     jclass jStringClass;
 981     jclass jObjectClass, jClassClass;
<a name="28" id="anc28"></a><span class="line-modified"> 982     CK_VOID_PTR ckpVoid = *ckpObjectPtr;</span>
 983     jmethodID jMethod;
 984     jobject jClassObject;
 985     jstring jClassNameString;
 986     char *classNameString, *exceptionMsgPrefix, *exceptionMsg;
 987 
<a name="29" id="anc29"></a><span class="line-modified"> 988     TRACE0(&quot;\nDEBUG: jObjectToPrimitiveCKObjectPtrPtr&quot;);</span>
 989     if (jObject == NULL) {
<a name="30" id="anc30"></a><span class="line-removed"> 990         *ckpObjectPtr = NULL;</span>
 991         *ckpLength = 0;
<a name="31" id="anc31"></a><span class="line-modified"> 992         return;</span>
 993     }
 994 
 995     jLongClass = (*env)-&gt;FindClass(env, &quot;java/lang/Long&quot;);
<a name="32" id="anc32"></a><span class="line-modified"> 996     if (jLongClass == NULL) { return; }</span>
 997     if ((*env)-&gt;IsInstanceOf(env, jObject, jLongClass)) {
<a name="33" id="anc33"></a><span class="line-modified"> 998         *ckpObjectPtr = jLongObjectToCKULongPtr(env, jObject);</span>
 999         *ckpLength = sizeof(CK_ULONG);
<a name="34" id="anc34"></a><span class="line-modified">1000         TRACE1(&quot;&lt;converted long value %X&gt;&quot;, *((CK_ULONG *) *ckpObjectPtr));</span>
<span class="line-modified">1001         return;</span>
1002     }
1003 
1004     jBooleanClass = (*env)-&gt;FindClass(env, &quot;java/lang/Boolean&quot;);
<a name="35" id="anc35"></a><span class="line-modified">1005     if (jBooleanClass == NULL) { return; }</span>
1006     if ((*env)-&gt;IsInstanceOf(env, jObject, jBooleanClass)) {
<a name="36" id="anc36"></a><span class="line-modified">1007         *ckpObjectPtr = jBooleanObjectToCKBBoolPtr(env, jObject);</span>
1008         *ckpLength = sizeof(CK_BBOOL);
1009         TRACE0(&quot; &lt;converted boolean value &quot;);
<a name="37" id="anc37"></a><span class="line-modified">1010         TRACE0((*((CK_BBOOL *) *ckpObjectPtr) == TRUE) ? &quot;TRUE&gt;&quot; : &quot;FALSE&gt;&quot;);</span>
<span class="line-modified">1011         return;</span>
1012     }
1013 
1014     jByteArrayClass = (*env)-&gt;FindClass(env, &quot;[B&quot;);
<a name="38" id="anc38"></a><span class="line-modified">1015     if (jByteArrayClass == NULL) { return; }</span>
1016     if ((*env)-&gt;IsInstanceOf(env, jObject, jByteArrayClass)) {
<a name="39" id="anc39"></a><span class="line-modified">1017         jByteArrayToCKByteArray(env, jObject, (CK_BYTE_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">1018         return;</span>
1019     }
1020 
1021     jCharArrayClass = (*env)-&gt;FindClass(env, &quot;[C&quot;);
<a name="40" id="anc40"></a><span class="line-modified">1022     if (jCharArrayClass == NULL) { return; }</span>
1023     if ((*env)-&gt;IsInstanceOf(env, jObject, jCharArrayClass)) {
<a name="41" id="anc41"></a><span class="line-modified">1024         jCharArrayToCKUTF8CharArray(env, jObject, (CK_UTF8CHAR_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">1025         return;</span>
1026     }
1027 
1028     jByteClass = (*env)-&gt;FindClass(env, &quot;java/lang/Byte&quot;);
<a name="42" id="anc42"></a><span class="line-modified">1029     if (jByteClass == NULL) { return; }</span>
1030     if ((*env)-&gt;IsInstanceOf(env, jObject, jByteClass)) {
<a name="43" id="anc43"></a><span class="line-modified">1031         *ckpObjectPtr = jByteObjectToCKBytePtr(env, jObject);</span>
1032         *ckpLength = sizeof(CK_BYTE);
<a name="44" id="anc44"></a><span class="line-modified">1033         TRACE1(&quot;&lt;converted byte value %X&gt;&quot;, *((CK_BYTE *) *ckpObjectPtr));</span>
<span class="line-modified">1034         return;</span>
1035     }
1036 
1037     jDateClass = (*env)-&gt;FindClass(env, CLASS_DATE);
<a name="45" id="anc45"></a><span class="line-modified">1038     if (jDateClass == NULL) { return; }</span>
1039     if ((*env)-&gt;IsInstanceOf(env, jObject, jDateClass)) {
<a name="46" id="anc46"></a><span class="line-modified">1040         *ckpObjectPtr = jDateObjectPtrToCKDatePtr(env, jObject);</span>
1041         *ckpLength = sizeof(CK_DATE);
<a name="47" id="anc47"></a><span class="line-modified">1042         TRACE3(&quot;&lt;converted date value %.4s-%.2s-%.2s&gt;&quot;, (*((CK_DATE *) *ckpObjectPtr)).year, (*((CK_DATE *) *ckpObjectPtr)).month, (*((CK_DATE *) *ckpObjectPtr)).day);</span>
<span class="line-modified">1043         return;</span>

1044     }
1045 
1046     jCharacterClass = (*env)-&gt;FindClass(env, &quot;java/lang/Character&quot;);
<a name="48" id="anc48"></a><span class="line-modified">1047     if (jCharacterClass == NULL) { return; }</span>
1048     if ((*env)-&gt;IsInstanceOf(env, jObject, jCharacterClass)) {
<a name="49" id="anc49"></a><span class="line-modified">1049         *ckpObjectPtr = jCharObjectToCKCharPtr(env, jObject);</span>
1050         *ckpLength = sizeof(CK_UTF8CHAR);
<a name="50" id="anc50"></a><span class="line-modified">1051         TRACE1(&quot;&lt;converted char value %c&gt;&quot;, *((CK_CHAR *) *ckpObjectPtr));</span>
<span class="line-modified">1052         return;</span>
1053     }
1054 
1055     jIntegerClass = (*env)-&gt;FindClass(env, &quot;java/lang/Integer&quot;);
<a name="51" id="anc51"></a><span class="line-modified">1056     if (jIntegerClass == NULL) { return; }</span>
1057     if ((*env)-&gt;IsInstanceOf(env, jObject, jIntegerClass)) {
<a name="52" id="anc52"></a><span class="line-modified">1058         *ckpObjectPtr = jIntegerObjectToCKULongPtr(env, jObject);</span>
1059         *ckpLength = sizeof(CK_ULONG);
<a name="53" id="anc53"></a><span class="line-modified">1060         TRACE1(&quot;&lt;converted integer value %X&gt;&quot;, *((CK_ULONG *) *ckpObjectPtr));</span>
<span class="line-modified">1061         return;</span>
1062     }
1063 
1064     jBooleanArrayClass = (*env)-&gt;FindClass(env, &quot;[Z&quot;);
<a name="54" id="anc54"></a><span class="line-modified">1065     if (jBooleanArrayClass == NULL) { return; }</span>
1066     if ((*env)-&gt;IsInstanceOf(env, jObject, jBooleanArrayClass)) {
<a name="55" id="anc55"></a><span class="line-modified">1067         jBooleanArrayToCKBBoolArray(env, jObject, (CK_BBOOL**)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">1068         return;</span>
1069     }
1070 
1071     jIntArrayClass = (*env)-&gt;FindClass(env, &quot;[I&quot;);
<a name="56" id="anc56"></a><span class="line-modified">1072     if (jIntArrayClass == NULL) { return; }</span>
1073     if ((*env)-&gt;IsInstanceOf(env, jObject, jIntArrayClass)) {
<a name="57" id="anc57"></a><span class="line-modified">1074         jLongArrayToCKULongArray(env, jObject, (CK_ULONG_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">1075         return;</span>
1076     }
1077 
1078     jLongArrayClass = (*env)-&gt;FindClass(env, &quot;[J&quot;);
<a name="58" id="anc58"></a><span class="line-modified">1079     if (jLongArrayClass == NULL) { return; }</span>
1080     if ((*env)-&gt;IsInstanceOf(env, jObject, jLongArrayClass)) {
<a name="59" id="anc59"></a><span class="line-modified">1081         jLongArrayToCKULongArray(env, jObject, (CK_ULONG_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">1082         return;</span>
1083     }
1084 
1085     jStringClass = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
<a name="60" id="anc60"></a><span class="line-modified">1086     if (jStringClass == NULL) { return; }</span>
1087     if ((*env)-&gt;IsInstanceOf(env, jObject, jStringClass)) {
<a name="61" id="anc61"></a><span class="line-modified">1088         jStringToCKUTF8CharArray(env, jObject, (CK_UTF8CHAR_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">1089         return;</span>
1090     }
1091 
1092     /* type of jObject unknown, throw PKCS11RuntimeException */
1093     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Object&quot;);
<a name="62" id="anc62"></a><span class="line-modified">1094     if (jObjectClass == NULL) { return; }</span>
1095     jMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;getClass&quot;, &quot;()Ljava/lang/Class;&quot;);
<a name="63" id="anc63"></a><span class="line-modified">1096     if (jMethod == NULL) { return; }</span>
1097     jClassObject = (*env)-&gt;CallObjectMethod(env, jObject, jMethod);
1098     assert(jClassObject != 0);
1099     jClassClass = (*env)-&gt;FindClass(env, &quot;java/lang/Class&quot;);
<a name="64" id="anc64"></a><span class="line-modified">1100     if (jClassClass == NULL) { return; }</span>
1101     jMethod = (*env)-&gt;GetMethodID(env, jClassClass, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;);
<a name="65" id="anc65"></a><span class="line-modified">1102     if (jMethod == NULL) { return; }</span>
1103     jClassNameString = (jstring)
1104         (*env)-&gt;CallObjectMethod(env, jClassObject, jMethod);
1105     assert(jClassNameString != 0);
1106     classNameString = (char*)
1107         (*env)-&gt;GetStringUTFChars(env, jClassNameString, NULL);
<a name="66" id="anc66"></a><span class="line-modified">1108     if (classNameString == NULL) { return; }</span>
1109     exceptionMsgPrefix = &quot;Java object of this class cannot be converted to native PKCS#11 type: &quot;;
1110     exceptionMsg = (char *)
<a name="67" id="anc67"></a><span class="line-modified">1111         malloc((strlen(exceptionMsgPrefix) + strlen(classNameString) + 1));</span>
1112     if (exceptionMsg == NULL) {
1113         (*env)-&gt;ReleaseStringUTFChars(env, jClassNameString, classNameString);
1114         throwOutOfMemoryError(env, 0);
<a name="68" id="anc68"></a><span class="line-modified">1115         return;</span>
1116     }
1117     strcpy(exceptionMsg, exceptionMsgPrefix);
1118     strcat(exceptionMsg, classNameString);
1119     (*env)-&gt;ReleaseStringUTFChars(env, jClassNameString, classNameString);
1120     throwPKCS11RuntimeException(env, exceptionMsg);
1121     free(exceptionMsg);
<a name="69" id="anc69"></a><span class="line-removed">1122     *ckpObjectPtr = NULL;</span>
1123     *ckpLength = 0;
1124 
1125     TRACE0(&quot;FINISHED\n&quot;);
<a name="70" id="anc70"></a>
1126 }
1127 
1128 #ifdef P11_MEMORYDEBUG
1129 
1130 #undef malloc
<a name="71" id="anc71"></a>
1131 #undef free
1132 
1133 void *p11malloc(size_t c, char *file, int line) {
1134     void *p = malloc(c);
<a name="72" id="anc72"></a><span class="line-modified">1135     printf(&quot;malloc\t%08x\t%d\t%s:%d\n&quot;, p, c, file, line); fflush(stdout);</span>








1136     return p;
1137 }
1138 
1139 void p11free(void *p, char *file, int line) {
<a name="73" id="anc73"></a><span class="line-modified">1140     printf(&quot;free\t%08x\t\t%s:%d\n&quot;, p, file, line); fflush(stdout);</span>

1141     free(p);
1142 }
1143 
1144 #endif
1145 
1146 // prints a message to stdout if debug output is enabled
1147 void printDebug(const char *format, ...) {
1148     if (debug == JNI_TRUE) {
1149         va_list args;
1150         fprintf(stdout, &quot;sunpkcs11: &quot;);
1151         va_start(args, format);
1152         vfprintf(stdout, format, args);
1153         va_end(args);
1154         fflush(stdout);
1155     }
1156 }
1157 
<a name="74" id="anc74"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="74" type="hidden" />
</body>
</html>
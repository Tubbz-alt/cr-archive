<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.crypto.cryptoki/share/native/libj2pkcs11/pkcs11.h</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* Copyright (c) OASIS Open 2016. All Rights Reserved./
  2  * /Distributed under the terms of the OASIS IPR Policy,
  3  * [http://www.oasis-open.org/policies-guidelines/ipr], AS-IS, WITHOUT ANY
  4  * IMPLIED OR EXPRESS WARRANTY; there is no warranty of MERCHANTABILITY, FITNESS FOR A
  5  * PARTICULAR PURPOSE or NONINFRINGEMENT of the rights of others.
  6  */
  7 
  8 /* Latest version of the specification:
  9  * http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/pkcs11-base-v2.40.html
 10  */
 11 
 12 #ifndef _PKCS11_H_
 13 #define _PKCS11_H_ 1
 14 
 15 #ifdef __cplusplus
 16 extern &quot;C&quot; {
 17 #endif
 18 
 19 /* Before including this file (pkcs11.h) (or pkcs11t.h by
 20  * itself), 5 platform-specific macros must be defined.  These
 21  * macros are described below, and typical definitions for them
 22  * are also given.  Be advised that these definitions can depend
 23  * on both the platform and the compiler used (and possibly also
 24  * on whether a Cryptoki library is linked statically or
 25  * dynamically).
 26  *
 27  * In addition to defining these 5 macros, the packing convention
 28  * for Cryptoki structures should be set.  The Cryptoki
 29  * convention on packing is that structures should be 1-byte
 30  * aligned.
 31  *
 32  * If you&#39;re using Microsoft Developer Studio 5.0 to produce
 33  * Win32 stuff, this might be done by using the following
 34  * preprocessor directive before including pkcs11.h or pkcs11t.h:
 35  *
 36  * #pragma pack(push, cryptoki, 1)
 37  *
 38  * and using the following preprocessor directive after including
 39  * pkcs11.h or pkcs11t.h:
 40  *
 41  * #pragma pack(pop, cryptoki)
 42  *
 43  * If you&#39;re using an earlier version of Microsoft Developer
 44  * Studio to produce Win16 stuff, this might be done by using
 45  * the following preprocessor directive before including
 46  * pkcs11.h or pkcs11t.h:
 47  *
 48  * #pragma pack(1)
 49  *
 50  * In a UNIX environment, you&#39;re on your own for this.  You might
 51  * not need to do (or be able to do!) anything.
 52  *
 53  *
 54  * Now for the macros:
 55  *
 56  *
 57  * 1. CK_PTR: The indirection string for making a pointer to an
 58  * object.  It can be used like this:
 59  *
 60  * typedef CK_BYTE CK_PTR CK_BYTE_PTR;
 61  *
 62  * If you&#39;re using Microsoft Developer Studio 5.0 to produce
 63  * Win32 stuff, it might be defined by:
 64  *
 65  * #define CK_PTR *
 66  *
 67  * If you&#39;re using an earlier version of Microsoft Developer
 68  * Studio to produce Win16 stuff, it might be defined by:
 69  *
 70  * #define CK_PTR far *
 71  *
 72  * In a typical UNIX environment, it might be defined by:
 73  *
 74  * #define CK_PTR *
 75  *
 76  *
 77  * 2. CK_DECLARE_FUNCTION(returnType, name): A macro which makes
 78  * an importable Cryptoki library function declaration out of a
 79  * return type and a function name.  It should be used in the
 80  * following fashion:
 81  *
 82  * extern CK_DECLARE_FUNCTION(CK_RV, C_Initialize)(
 83  *   CK_VOID_PTR pReserved
 84  * );
 85  *
 86  * If you&#39;re using Microsoft Developer Studio 5.0 to declare a
 87  * function in a Win32 Cryptoki .dll, it might be defined by:
 88  *
 89  * #define CK_DECLARE_FUNCTION(returnType, name) \
 90  *   returnType __declspec(dllimport) name
 91  *
 92  * If you&#39;re using an earlier version of Microsoft Developer
 93  * Studio to declare a function in a Win16 Cryptoki .dll, it
 94  * might be defined by:
 95  *
 96  * #define CK_DECLARE_FUNCTION(returnType, name) \
 97  *   returnType __export _far _pascal name
 98  *
 99  * In a UNIX environment, it might be defined by:
100  *
101  * #define CK_DECLARE_FUNCTION(returnType, name) \
102  *   returnType name
103  *
104  *
105  * 3. CK_DECLARE_FUNCTION_POINTER(returnType, name): A macro
106  * which makes a Cryptoki API function pointer declaration or
107  * function pointer type declaration out of a return type and a
108  * function name.  It should be used in the following fashion:
109  *
110  * // Define funcPtr to be a pointer to a Cryptoki API function
111  * // taking arguments args and returning CK_RV.
112  * CK_DECLARE_FUNCTION_POINTER(CK_RV, funcPtr)(args);
113  *
114  * or
115  *
116  * // Define funcPtrType to be the type of a pointer to a
117  * // Cryptoki API function taking arguments args and returning
118  * // CK_RV, and then define funcPtr to be a variable of type
119  * // funcPtrType.
120  * typedef CK_DECLARE_FUNCTION_POINTER(CK_RV, funcPtrType)(args);
121  * funcPtrType funcPtr;
122  *
123  * If you&#39;re using Microsoft Developer Studio 5.0 to access
124  * functions in a Win32 Cryptoki .dll, in might be defined by:
125  *
126  * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
127  *   returnType __declspec(dllimport) (* name)
128  *
129  * If you&#39;re using an earlier version of Microsoft Developer
130  * Studio to access functions in a Win16 Cryptoki .dll, it might
131  * be defined by:
132  *
133  * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
134  *   returnType __export _far _pascal (* name)
135  *
136  * In a UNIX environment, it might be defined by:
137  *
138  * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
139  *   returnType (* name)
140  *
141  *
142  * 4. CK_CALLBACK_FUNCTION(returnType, name): A macro which makes
143  * a function pointer type for an application callback out of
144  * a return type for the callback and a name for the callback.
145  * It should be used in the following fashion:
146  *
147  * CK_CALLBACK_FUNCTION(CK_RV, myCallback)(args);
148  *
149  * to declare a function pointer, myCallback, to a callback
150  * which takes arguments args and returns a CK_RV.  It can also
151  * be used like this:
152  *
153  * typedef CK_CALLBACK_FUNCTION(CK_RV, myCallbackType)(args);
154  * myCallbackType myCallback;
155  *
156  * If you&#39;re using Microsoft Developer Studio 5.0 to do Win32
157  * Cryptoki development, it might be defined by:
158  *
159  * #define CK_CALLBACK_FUNCTION(returnType, name) \
160  *   returnType (* name)
161  *
162  * If you&#39;re using an earlier version of Microsoft Developer
163  * Studio to do Win16 development, it might be defined by:
164  *
165  * #define CK_CALLBACK_FUNCTION(returnType, name) \
166  *   returnType _far _pascal (* name)
167  *
168  * In a UNIX environment, it might be defined by:
169  *
170  * #define CK_CALLBACK_FUNCTION(returnType, name) \
171  *   returnType (* name)
172  *
173  *
174  * 5. NULL_PTR: This macro is the value of a NULL pointer.
175  *
176  * In any ANSI/ISO C environment (and in many others as well),
177  * this should best be defined by
178  *
179  * #ifndef NULL_PTR
180  * #define NULL_PTR 0
181  * #endif
182  */
183 
184 
185 /* All the various Cryptoki types and #define&#39;d values are in the
186  * file pkcs11t.h.
187  */
188 #include &quot;pkcs11t.h&quot;
189 
190 #define __PASTE(x,y)      x##y
191 
192 
193 /* ==============================================================
194  * Define the &quot;extern&quot; form of all the entry points.
195  * ==============================================================
196  */
197 
198 #define CK_NEED_ARG_LIST  1
199 #define CK_PKCS11_FUNCTION_INFO(name) \
200   extern CK_DECLARE_FUNCTION(CK_RV, name)
201 
202 /* pkcs11f.h has all the information about the Cryptoki
203  * function prototypes.
204  */
205 #include &quot;pkcs11f.h&quot;
206 
207 #undef CK_NEED_ARG_LIST
208 #undef CK_PKCS11_FUNCTION_INFO
209 
210 
211 /* ==============================================================
212  * Define the typedef form of all the entry points.  That is, for
213  * each Cryptoki function C_XXX, define a type CK_C_XXX which is
214  * a pointer to that kind of function.
215  * ==============================================================
216  */
217 
218 #define CK_NEED_ARG_LIST  1
219 #define CK_PKCS11_FUNCTION_INFO(name) \
220   typedef CK_DECLARE_FUNCTION_POINTER(CK_RV, __PASTE(CK_,name))
221 
222 /* pkcs11f.h has all the information about the Cryptoki
223  * function prototypes.
224  */
225 #include &quot;pkcs11f.h&quot;
226 
227 #undef CK_NEED_ARG_LIST
228 #undef CK_PKCS11_FUNCTION_INFO
229 
230 
231 /* ==============================================================
232  * Define structed vector of entry points.  A CK_FUNCTION_LIST
233  * contains a CK_VERSION indicating a library&#39;s Cryptoki version
234  * and then a whole slew of function pointers to the routines in
235  * the library.  This type was declared, but not defined, in
236  * pkcs11t.h.
237  * ==============================================================
238  */
239 
240 #define CK_PKCS11_FUNCTION_INFO(name) \
241   __PASTE(CK_,name) name;
242 
243 struct CK_FUNCTION_LIST {
244 
245   CK_VERSION    version;  /* Cryptoki version */
246 
247 /* Pile all the function pointers into the CK_FUNCTION_LIST. */
248 /* pkcs11f.h has all the information about the Cryptoki
249  * function prototypes.
250  */
251 #include &quot;pkcs11f.h&quot;
252 
253 };
254 
255 #undef CK_PKCS11_FUNCTION_INFO
256 
257 
258 #undef __PASTE
259 
260 #ifdef __cplusplus
261 }
262 #endif
263 
264 #endif /* _PKCS11_H_ */
265 
    </pre>
  </body>
</html>
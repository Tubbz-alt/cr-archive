<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_sign.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 
  5 /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
  6  *
  7  * Redistribution and use in  source and binary forms, with or without
  8  * modification, are permitted  provided that the following conditions are met:
  9  *
 10  * 1. Redistributions of  source code must retain the above copyright notice,
 11  *    this list of conditions and the following disclaimer.
 12  *
 13  * 2. Redistributions in  binary form must reproduce the above copyright notice,
 14  *    this list of conditions and the following disclaimer in the documentation
 15  *    and/or other materials provided with the distribution.
 16  *
 17  * 3. The end-user documentation included with the redistribution, if any, must
 18  *    include the following acknowledgment:
 19  *
 20  *    &quot;This product includes software developed by IAIK of Graz University of
 21  *     Technology.&quot;
 22  *
 23  *    Alternately, this acknowledgment may appear in the software itself, if
 24  *    and wherever such third-party acknowledgments normally appear.
 25  *
 26  * 4. The names &quot;Graz University of Technology&quot; and &quot;IAIK of Graz University of
 27  *    Technology&quot; must not be used to endorse or promote products derived from
 28  *    this software without prior written permission.
 29  *
 30  * 5. Products derived from this software may not be called
 31  *    &quot;IAIK PKCS Wrapper&quot;, nor may &quot;IAIK&quot; appear in their name, without prior
 32  *    written permission of Graz University of Technology.
 33  *
 34  *  THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESSED OR IMPLIED
 35  *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 36  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 37  *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE LICENSOR BE
 38  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 39  *  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 40  *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 41  *  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 42  *  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 43  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 44  *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 45  *  POSSIBILITY  OF SUCH DAMAGE.
 46  */
 47 
 48 #include &quot;pkcs11wrapper.h&quot;
 49 
 50 #include &lt;stdio.h&gt;
 51 #include &lt;stdlib.h&gt;
 52 #include &lt;string.h&gt;
 53 #include &lt;assert.h&gt;
 54 #include &quot;jlong.h&quot;
 55 
 56 #include &quot;sun_security_pkcs11_wrapper_PKCS11.h&quot;
 57 
 58 #ifdef P11_ENABLE_C_SIGNINIT
 59 /*
 60  * Class:     sun_security_pkcs11_wrapper_PKCS11
 61  * Method:    C_SignInit
 62  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
 63  * Parametermapping:                    *PKCS11*
 64  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 65  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<a name="2" id="anc2"></a><span class="line-modified"> 66  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
 67  */
 68 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignInit
 69     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
 70 {
 71     CK_SESSION_HANDLE ckSessionHandle;
<a name="3" id="anc3"></a><span class="line-modified"> 72     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
 73     CK_OBJECT_HANDLE ckKeyHandle;
 74     CK_RV rv;
 75 
 76     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 77     if (ckpFunctions == NULL) { return; }
 78 
<a name="4" id="anc4"></a><span class="line-added"> 79     TRACE0(&quot;DEBUG: C_SignInit\n&quot;);</span>
<span class="line-added"> 80 </span>
 81     ckSessionHandle = jLongToCKULong(jSessionHandle);
<a name="5" id="anc5"></a><span class="line-modified"> 82 </span>
<span class="line-added"> 83     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
 84     if ((*env)-&gt;ExceptionCheck(env)) { return; }
<a name="6" id="anc6"></a><span class="line-added"> 85 </span>
 86     ckKeyHandle = jLongToCKULong(jKeyHandle);
 87 
<a name="7" id="anc7"></a><span class="line-modified"> 88     rv = (*ckpFunctions-&gt;C_SignInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);</span>
 89 
<a name="8" id="anc8"></a><span class="line-modified"> 90     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK ||</span>
<span class="line-modified"> 91             (ckpMechanism-&gt;pParameter == NULL)) {</span>
<span class="line-added"> 92         freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-added"> 93     } else {</span>
<span class="line-added"> 94         (*env)-&gt;SetLongField(env, jMechanism, mech_pHandleID, ptr_to_jlong(ckpMechanism));</span>
<span class="line-added"> 95         TRACE1(&quot;DEBUG C_SignInit: stored pMech = 0x%lX\n&quot;, ptr_to_jlong(ckpMechanism));</span>
 96     }
<a name="9" id="anc9"></a><span class="line-modified"> 97     TRACE0(&quot;FINISHED\n&quot;);</span>

 98 }
 99 #endif
100 
101 #ifdef P11_ENABLE_C_SIGN
102 /*
103  * Class:     sun_security_pkcs11_wrapper_PKCS11
104  * Method:    C_Sign
<a name="10" id="anc10"></a><span class="line-modified">105  * Signature: (J[BI)[B</span>
106  * Parametermapping:                    *PKCS11*
107  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
108  * @param   jbyteArray jData            CK_BYTE_PTR pData
109  *                                      CK_ULONG ulDataLen
110  * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
111  *                                      CK_ULONG_PTR pulSignatureLen
112  */
113 JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1Sign
114     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jData)
115 {
116     CK_SESSION_HANDLE ckSessionHandle;
117     CK_BYTE_PTR ckpData = NULL_PTR;
<a name="11" id="anc11"></a>
118     CK_ULONG ckDataLength;
<a name="12" id="anc12"></a><span class="line-modified">119     CK_BYTE_PTR bufP;</span>
<span class="line-added">120     CK_ULONG ckSignatureLength;</span>
<span class="line-added">121     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];</span>
122     jbyteArray jSignature = NULL;
123     CK_RV rv;
124 
125     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
126     if (ckpFunctions == NULL) { return NULL; }
127 
<a name="13" id="anc13"></a><span class="line-added">128     TRACE0(&quot;DEBUG: C_Sign\n&quot;);</span>
<span class="line-added">129 </span>
130     ckSessionHandle = jLongToCKULong(jSessionHandle);
131     jByteArrayToCKByteArray(env, jData, &amp;ckpData, &amp;ckDataLength);
<a name="14" id="anc14"></a><span class="line-modified">132     if ((*env)-&gt;ExceptionCheck(env)) {</span>







133         return NULL;
134     }
135 
<a name="15" id="anc15"></a><span class="line-modified">136     TRACE1(&quot;DEBUG C_Sign: data length = %lu\n&quot;, ckDataLength);</span>





137 
<a name="16" id="anc16"></a><span class="line-modified">138     // unknown signature length</span>
<span class="line-modified">139     bufP = BUF;</span>
<span class="line-modified">140     ckSignatureLength = MAX_STACK_BUFFER_LEN;</span>
141 
<a name="17" id="anc17"></a><span class="line-added">142     rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength,</span>
<span class="line-added">143         bufP, &amp;ckSignatureLength);</span>
144 
<a name="18" id="anc18"></a><span class="line-modified">145     TRACE1(&quot;DEBUG C_Sign: ret rv=0x%lX\n&quot;, rv);</span>








146 
<a name="19" id="anc19"></a>











147     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
<a name="20" id="anc20"></a><span class="line-modified">148         jSignature = ckByteArrayToJByteArray(env, bufP, ckSignatureLength);</span>
<span class="line-added">149         TRACE1(&quot;DEBUG C_Sign: signature length = %lu\n&quot;, ckSignatureLength);</span>
150     }
<a name="21" id="anc21"></a><span class="line-added">151 </span>
152     free(ckpData);
<a name="22" id="anc22"></a><span class="line-modified">153     if (bufP != BUF) { free(bufP); }</span>
154 
<a name="23" id="anc23"></a><span class="line-modified">155     TRACE0(&quot;FINISHED\n&quot;);</span>
<span class="line-added">156     return jSignature;</span>
157 }
158 #endif
159 
160 #ifdef P11_ENABLE_C_SIGNUPDATE
161 /*
162  * Class:     sun_security_pkcs11_wrapper_PKCS11
163  * Method:    C_SignUpdate
164  * Signature: (J[BII)V
165  * Parametermapping:                    *PKCS11*
166  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
167  * @param   jbyteArray jPart            CK_BYTE_PTR pPart
168  *                                      CK_ULONG ulPartLen
169  */
170 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignUpdate
171   (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong directIn, jbyteArray jIn, jint jInOfs, jint jInLen)
172 {
173     CK_SESSION_HANDLE ckSessionHandle;
174     CK_RV rv;
175     CK_BYTE_PTR bufP;
176     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
177     jsize bufLen;
178 
179     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
180     if (ckpFunctions == NULL) { return; }
181 
182     ckSessionHandle = jLongToCKULong(jSessionHandle);
183 
184     if (directIn != 0) {
185         rv = (*ckpFunctions-&gt;C_SignUpdate)(ckSessionHandle, (CK_BYTE_PTR) jlong_to_ptr(directIn), jInLen);
186         ckAssertReturnValueOK(env, rv);
187         return;
188     }
189 
190     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
191         bufLen = MAX_STACK_BUFFER_LEN;
192         bufP = BUF;
193     } else {
194         bufLen = min(MAX_HEAP_BUFFER_LEN, jInLen);
195         bufP = (CK_BYTE_PTR) malloc((size_t)bufLen);
196         if (bufP == NULL) {
197             throwOutOfMemoryError(env, 0);
198             return;
199         }
200     }
201 
202     while (jInLen &gt; 0) {
203         jsize chunkLen = min(bufLen, jInLen);
204         (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, chunkLen, (jbyte *)bufP);
205         if ((*env)-&gt;ExceptionCheck(env)) {
<a name="24" id="anc24"></a><span class="line-modified">206             goto cleanup;</span>

207         }
208         rv = (*ckpFunctions-&gt;C_SignUpdate)(ckSessionHandle, bufP, chunkLen);
209         if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
<a name="25" id="anc25"></a><span class="line-modified">210             goto cleanup;</span>



211         }
212         jInOfs += chunkLen;
213         jInLen -= chunkLen;
214     }
215 
<a name="26" id="anc26"></a><span class="line-added">216 cleanup:</span>
217     if (bufP != BUF) { free(bufP); }
<a name="27" id="anc27"></a><span class="line-added">218 </span>
<span class="line-added">219     return;</span>
220 }
221 #endif
222 
223 #ifdef P11_ENABLE_C_SIGNFINAL
224 /*
225  * Class:     sun_security_pkcs11_wrapper_PKCS11
226  * Method:    C_SignFinal
227  * Signature: (J)[B
228  * Parametermapping:                    *PKCS11*
229  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
230  * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
231  *                                      CK_ULONG_PTR pulSignatureLen
232  */
233 JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignFinal
234     (JNIEnv *env, jobject obj, jlong jSessionHandle, jint jExpectedLength)
235 {
236     CK_SESSION_HANDLE ckSessionHandle;
237     jbyteArray jSignature = NULL;
238     CK_RV rv;
239     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
240     CK_BYTE_PTR bufP = BUF;
241     CK_ULONG ckSignatureLength = MAX_STACK_BUFFER_LEN;
242 
243     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
244     if (ckpFunctions == NULL) { return NULL; }
245 
246     ckSessionHandle = jLongToCKULong(jSessionHandle);
247 
248     if ((jExpectedLength &gt; 0) &amp;&amp; ((CK_ULONG)jExpectedLength &lt; ckSignatureLength)) {
249         ckSignatureLength = jExpectedLength;
250     }
251 
252     rv = (*ckpFunctions-&gt;C_SignFinal)(ckSessionHandle, bufP, &amp;ckSignatureLength);
253     if (rv == CKR_BUFFER_TOO_SMALL) {
254         bufP = (CK_BYTE_PTR) malloc(ckSignatureLength);
255         if (bufP == NULL) {
256             throwOutOfMemoryError(env, 0);
257             return NULL;
258         }
259         rv = (*ckpFunctions-&gt;C_SignFinal)(ckSessionHandle, bufP, &amp;ckSignatureLength);
260     }
261     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
262         jSignature = ckByteArrayToJByteArray(env, bufP, ckSignatureLength);
263     }
264 
265     if (bufP != BUF) { free(bufP); }
266 
267     return jSignature;
268 }
269 #endif
270 
271 #ifdef P11_ENABLE_C_SIGNRECOVERINIT
272 /*
273  * Class:     sun_security_pkcs11_wrapper_PKCS11
274  * Method:    C_SignRecoverInit
275  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
276  * Parametermapping:                    *PKCS11*
277  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
278  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<a name="28" id="anc28"></a><span class="line-modified">279  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
280  */
281 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignRecoverInit
282     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
283 {
284     CK_SESSION_HANDLE ckSessionHandle;
<a name="29" id="anc29"></a><span class="line-modified">285     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
286     CK_OBJECT_HANDLE ckKeyHandle;
287     CK_RV rv;
288 
289     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
290     if (ckpFunctions == NULL) { return; }
291 
<a name="30" id="anc30"></a><span class="line-added">292     TRACE0(&quot;DEBUG: C_SignRecoverInit\n&quot;);</span>
<span class="line-added">293 </span>
294     ckSessionHandle = jLongToCKULong(jSessionHandle);
<a name="31" id="anc31"></a><span class="line-modified">295     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
296     if ((*env)-&gt;ExceptionCheck(env)) { return; }
297 
298     ckKeyHandle = jLongToCKULong(jKeyHandle);
299 
<a name="32" id="anc32"></a><span class="line-modified">300     rv = (*ckpFunctions-&gt;C_SignRecoverInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);</span>
301 
<a name="33" id="anc33"></a><span class="line-modified">302     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK ||</span>
<span class="line-modified">303             (ckpMechanism-&gt;pParameter == NULL)) {</span>
<span class="line-added">304         freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-added">305     } else {</span>
<span class="line-added">306         (*env)-&gt;SetLongField(env, jMechanism, mech_pHandleID, ptr_to_jlong(ckpMechanism));</span>
<span class="line-added">307         TRACE1(&quot;DEBUG C_SignRecoverInit, stored pMech = 0x%lX\n&quot;, ptr_to_jlong(ckpMechanism));</span>
308     }
<a name="34" id="anc34"></a><span class="line-modified">309     TRACE0(&quot;FINISHED\n&quot;);</span>

310 }
311 #endif
312 
313 #ifdef P11_ENABLE_C_SIGNRECOVER
314 /*
315  * Class:     sun_security_pkcs11_wrapper_PKCS11
316  * Method:    C_SignRecover
317  * Signature: (J[BII[BII)I
318  * Parametermapping:                    *PKCS11*
319  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
320  * @param   jbyteArray jData            CK_BYTE_PTR pData
321  *                                      CK_ULONG ulDataLen
322  * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
323  *                                      CK_ULONG_PTR pulSignatureLen
324  */
325 JNIEXPORT jint JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignRecover
326   (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jIn, jint jInOfs, jint jInLen, jbyteArray jOut, jint jOutOfs, jint jOutLen)
327 {
328     CK_SESSION_HANDLE ckSessionHandle;
329     CK_RV rv;
330     CK_BYTE INBUF[MAX_STACK_BUFFER_LEN];
331     CK_BYTE OUTBUF[MAX_STACK_BUFFER_LEN];
332     CK_BYTE_PTR inBufP;
333     CK_BYTE_PTR outBufP = OUTBUF;
<a name="35" id="anc35"></a><span class="line-modified">334     CK_ULONG ckSignatureLength = 0;</span>
335 
336     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
337     if (ckpFunctions == NULL) { return 0; }
338 
339     ckSessionHandle = jLongToCKULong(jSessionHandle);
340 
341     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
342         inBufP = INBUF;
<a name="36" id="anc36"></a><span class="line-added">343         ckSignatureLength = MAX_STACK_BUFFER_LEN;</span>
344     } else {
345         inBufP = (CK_BYTE_PTR) malloc((size_t)jInLen);
346         if (inBufP == NULL) {
347             throwOutOfMemoryError(env, 0);
348             return 0;
349         }
<a name="37" id="anc37"></a><span class="line-added">350         ckSignatureLength = jInLen;</span>
351     }
352 
353     (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, jInLen, (jbyte *)inBufP);
354     if ((*env)-&gt;ExceptionCheck(env)) {
<a name="38" id="anc38"></a><span class="line-modified">355         goto cleanup;</span>

356     }
<a name="39" id="anc39"></a><span class="line-added">357 </span>
358     rv = (*ckpFunctions-&gt;C_SignRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckSignatureLength);
359     /* re-alloc larger buffer if it fits into our Java buffer */
360     if ((rv == CKR_BUFFER_TOO_SMALL) &amp;&amp; (ckSignatureLength &lt;= jIntToCKULong(jOutLen))) {
361         outBufP = (CK_BYTE_PTR) malloc(ckSignatureLength);
362         if (outBufP == NULL) {
<a name="40" id="anc40"></a>


363             throwOutOfMemoryError(env, 0);
<a name="41" id="anc41"></a><span class="line-modified">364             goto cleanup;</span>
365         }
366         rv = (*ckpFunctions-&gt;C_SignRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckSignatureLength);
367     }
368     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
369         (*env)-&gt;SetByteArrayRegion(env, jOut, jOutOfs, ckSignatureLength, (jbyte *)outBufP);
370     }
<a name="42" id="anc42"></a><span class="line-modified">371 cleanup:</span>
372     if (inBufP != INBUF) { free(inBufP); }
373     if (outBufP != OUTBUF) { free(outBufP); }
374 
375     return ckSignatureLength;
376 }
377 #endif
378 
379 #ifdef P11_ENABLE_C_VERIFYINIT
380 /*
381  * Class:     sun_security_pkcs11_wrapper_PKCS11
382  * Method:    C_VerifyInit
383  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
384  * Parametermapping:                    *PKCS11*
385  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
386  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<a name="43" id="anc43"></a><span class="line-modified">387  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
388  */
389 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyInit
390     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
391 {
392     CK_SESSION_HANDLE ckSessionHandle;
<a name="44" id="anc44"></a><span class="line-modified">393     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
394     CK_OBJECT_HANDLE ckKeyHandle;
395     CK_RV rv;
396 
397     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
398     if (ckpFunctions == NULL) { return; }
399 
<a name="45" id="anc45"></a><span class="line-added">400     TRACE0(&quot;DEBUG: C_VerifyInit\n&quot;);</span>
<span class="line-added">401 </span>
402     ckSessionHandle = jLongToCKULong(jSessionHandle);
<a name="46" id="anc46"></a><span class="line-modified">403     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
<span class="line-modified">404     if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="line-added">405         return;</span>
<span class="line-added">406     }</span>
407 
408     ckKeyHandle = jLongToCKULong(jKeyHandle);
409 
<a name="47" id="anc47"></a><span class="line-modified">410     rv = (*ckpFunctions-&gt;C_VerifyInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);</span>
411 
<a name="48" id="anc48"></a><span class="line-modified">412     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK ||</span>
<span class="line-modified">413             (ckpMechanism-&gt;pParameter == NULL)) {</span>
<span class="line-added">414         freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-added">415     } else {</span>
<span class="line-added">416         (*env)-&gt;SetLongField(env, jMechanism, mech_pHandleID, ptr_to_jlong(ckpMechanism));</span>
<span class="line-added">417         TRACE1(&quot;DEBUG C_VerifyInit: stored pMech = 0x%lX\n&quot;, ptr_to_jlong(ckpMechanism));</span>
418     }
<a name="49" id="anc49"></a><span class="line-modified">419     TRACE0(&quot;FINISHED\n&quot;);</span>

420 }
421 #endif
422 
423 #ifdef P11_ENABLE_C_VERIFY
424 /*
425  * Class:     sun_security_pkcs11_wrapper_PKCS11
426  * Method:    C_Verify
427  * Signature: (J[B[B)V
428  * Parametermapping:                    *PKCS11*
429  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
430  * @param   jbyteArray jData            CK_BYTE_PTR pData
431  *                                      CK_ULONG ulDataLen
432  * @param   jbyteArray jSignature       CK_BYTE_PTR pSignature
433  *                                      CK_ULONG_PTR pulSignatureLen
434  */
435 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1Verify
436     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jData, jbyteArray jSignature)
437 {
438     CK_SESSION_HANDLE ckSessionHandle;
439     CK_BYTE_PTR ckpData = NULL_PTR;
440     CK_BYTE_PTR ckpSignature = NULL_PTR;
441     CK_ULONG ckDataLength;
442     CK_ULONG ckSignatureLength;
<a name="50" id="anc50"></a><span class="line-modified">443     CK_RV rv = 0;</span>
444 
445     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
446     if (ckpFunctions == NULL) { return; }
447 
448     ckSessionHandle = jLongToCKULong(jSessionHandle);
<a name="51" id="anc51"></a><span class="line-added">449 </span>
450     jByteArrayToCKByteArray(env, jData, &amp;ckpData, &amp;ckDataLength);
<a name="52" id="anc52"></a><span class="line-modified">451     if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="line-added">452         return;</span>
<span class="line-added">453     }</span>
454 
455     jByteArrayToCKByteArray(env, jSignature, &amp;ckpSignature, &amp;ckSignatureLength);
456     if ((*env)-&gt;ExceptionCheck(env)) {
<a name="53" id="anc53"></a><span class="line-modified">457         goto cleanup;</span>

458     }
459 
460     /* verify the signature */
461     rv = (*ckpFunctions-&gt;C_Verify)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, ckSignatureLength);
462 
<a name="54" id="anc54"></a><span class="line-added">463 cleanup:</span>
464     free(ckpData);
465     free(ckpSignature);
466 
<a name="55" id="anc55"></a><span class="line-modified">467     ckAssertReturnValueOK(env, rv);</span>
468 }
469 #endif
470 
471 #ifdef P11_ENABLE_C_VERIFYUPDATE
472 /*
473  * Class:     sun_security_pkcs11_wrapper_PKCS11
474  * Method:    C_VerifyUpdate
475  * Signature: (J[BII)V
476  * Parametermapping:                    *PKCS11*
477  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
478  * @param   jbyteArray jPart            CK_BYTE_PTR pPart
479  *                                      CK_ULONG ulPartLen
480  */
481 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyUpdate
482   (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong directIn, jbyteArray jIn, jint jInOfs, jint jInLen)
483 {
484     CK_SESSION_HANDLE ckSessionHandle;
485     CK_RV rv;
486     CK_BYTE_PTR bufP;
487     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
488     jsize bufLen;
489 
490     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
491     if (ckpFunctions == NULL) { return; }
492 
493     ckSessionHandle = jLongToCKULong(jSessionHandle);
494 
495     if (directIn != 0) {
496         rv = (*ckpFunctions-&gt;C_VerifyUpdate)(ckSessionHandle, (CK_BYTE_PTR)jlong_to_ptr(directIn), jInLen);
497         ckAssertReturnValueOK(env, rv);
498         return;
499     }
500 
501     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
502         bufLen = MAX_STACK_BUFFER_LEN;
503         bufP = BUF;
504     } else {
505         bufLen = min(MAX_HEAP_BUFFER_LEN, jInLen);
506         bufP = (CK_BYTE_PTR) malloc((size_t)bufLen);
507         if (bufP == NULL) {
508             throwOutOfMemoryError(env, 0);
<a name="56" id="anc56"></a><span class="line-modified">509             goto cleanup;</span>
510         }
511     }
512 
513     while (jInLen &gt; 0) {
514         jsize chunkLen = min(bufLen, jInLen);
515         (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, chunkLen, (jbyte *)bufP);
516         if ((*env)-&gt;ExceptionCheck(env)) {
<a name="57" id="anc57"></a><span class="line-modified">517             goto cleanup;</span>

518         }
519 
520         rv = (*ckpFunctions-&gt;C_VerifyUpdate)(ckSessionHandle, bufP, chunkLen);
521         if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
<a name="58" id="anc58"></a><span class="line-modified">522             goto cleanup;</span>

523         }
524         jInOfs += chunkLen;
525         jInLen -= chunkLen;
526     }
527 
<a name="59" id="anc59"></a><span class="line-added">528 cleanup:</span>
529     if (bufP != BUF) { free(bufP); }
530 }
531 #endif
532 
533 #ifdef P11_ENABLE_C_VERIFYFINAL
534 /*
535  * Class:     sun_security_pkcs11_wrapper_PKCS11
536  * Method:    C_VerifyFinal
537  * Signature: (J[B)V
538  * Parametermapping:                    *PKCS11*
539  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
540  * @param   jbyteArray jSignature       CK_BYTE_PTR pSignature
541  *                                      CK_ULONG ulSignatureLen
542  */
543 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyFinal
544     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jSignature)
545 {
546     CK_SESSION_HANDLE ckSessionHandle;
547     CK_BYTE_PTR ckpSignature = NULL_PTR;
548     CK_ULONG ckSignatureLength;
549     CK_RV rv;
550 
551     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
552     if (ckpFunctions == NULL) { return; }
553 
554     ckSessionHandle = jLongToCKULong(jSessionHandle);
555     jByteArrayToCKByteArray(env, jSignature, &amp;ckpSignature, &amp;ckSignatureLength);
<a name="60" id="anc60"></a><span class="line-modified">556     if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="line-added">557         return;</span>
<span class="line-added">558     }</span>
559 
560     /* verify the signature */
561     rv = (*ckpFunctions-&gt;C_VerifyFinal)(ckSessionHandle, ckpSignature, ckSignatureLength);
562 
563     free(ckpSignature);
564 
<a name="61" id="anc61"></a><span class="line-modified">565     ckAssertReturnValueOK(env, rv);</span>
566 }
567 #endif
568 
569 #ifdef P11_ENABLE_C_VERIFYRECOVERINIT
570 /*
571  * Class:     sun_security_pkcs11_wrapper_PKCS11
572  * Method:    C_VerifyRecoverInit
573  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
574  * Parametermapping:                    *PKCS11*
575  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
576  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
577  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE hKey
578  */
579 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyRecoverInit
580     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
581 {
582     CK_SESSION_HANDLE ckSessionHandle;
<a name="62" id="anc62"></a><span class="line-modified">583     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
584     CK_OBJECT_HANDLE ckKeyHandle;
585     CK_RV rv;
586 
587     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
588     if (ckpFunctions == NULL) { return; }
589 
<a name="63" id="anc63"></a><span class="line-added">590     TRACE0(&quot;DEBUG: C_VerifyRecoverInit\n&quot;);</span>
<span class="line-added">591 </span>
592     ckSessionHandle = jLongToCKULong(jSessionHandle);
<a name="64" id="anc64"></a><span class="line-modified">593     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
594     if ((*env)-&gt;ExceptionCheck(env)) { return; }
595 
596     ckKeyHandle = jLongToCKULong(jKeyHandle);
597 
<a name="65" id="anc65"></a><span class="line-modified">598     rv = (*ckpFunctions-&gt;C_VerifyRecoverInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);</span>
599 
<a name="66" id="anc66"></a><span class="line-modified">600     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK ||</span>
<span class="line-modified">601             (ckpMechanism-&gt;pParameter == NULL)) {</span>
<span class="line-added">602         freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-added">603     } else {</span>
<span class="line-added">604         (*env)-&gt;SetLongField(env, jMechanism, mech_pHandleID, ptr_to_jlong(ckpMechanism));</span>
<span class="line-added">605         TRACE1(&quot;DEBUG C_VerifyRecoverInit: stored pMech = 0x%lX\n&quot;, ptr_to_jlong(ckpMechanism));</span>
606     }
<a name="67" id="anc67"></a><span class="line-modified">607     TRACE0(&quot;FINISHED\n&quot;);</span>

608 }
609 #endif
610 
611 #ifdef P11_ENABLE_C_VERIFYRECOVER
612 /*
613  * Class:     sun_security_pkcs11_wrapper_PKCS11
614  * Method:    C_VerifyRecover
615  * Signature: (J[BII[BII)I
616  * Parametermapping:                    *PKCS11*
617  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
618  * @param   jbyteArray jSignature       CK_BYTE_PTR pSignature
619  *                                      CK_ULONG ulSignatureLen
620  * @return  jbyteArray jData            CK_BYTE_PTR pData
621  *                                      CK_ULONG_PTR pulDataLen
622  */
623 JNIEXPORT jint JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyRecover
624   (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jIn, jint jInOfs, jint jInLen, jbyteArray jOut, jint jOutOfs, jint jOutLen)
625 {
626     CK_SESSION_HANDLE ckSessionHandle;
627     CK_RV rv;
628     CK_BYTE INBUF[MAX_STACK_BUFFER_LEN];
629     CK_BYTE OUTBUF[MAX_STACK_BUFFER_LEN];
630     CK_BYTE_PTR inBufP;
631     CK_BYTE_PTR outBufP = OUTBUF;
<a name="68" id="anc68"></a><span class="line-modified">632     CK_ULONG ckDataLength = 0;</span>
633 
634     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
635     if (ckpFunctions == NULL) { return 0; }
636 
637     ckSessionHandle = jLongToCKULong(jSessionHandle);
638 
639     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
640         inBufP = INBUF;
<a name="69" id="anc69"></a><span class="line-added">641         ckDataLength = MAX_STACK_BUFFER_LEN;</span>
642     } else {
643         inBufP = (CK_BYTE_PTR) malloc((size_t)jInLen);
644         if (inBufP == NULL) {
645             throwOutOfMemoryError(env, 0);
646             return 0;
647         }
<a name="70" id="anc70"></a><span class="line-added">648         ckDataLength = jInLen;</span>
649     }
650 
651     (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, jInLen, (jbyte *)inBufP);
652     if ((*env)-&gt;ExceptionCheck(env)) {
<a name="71" id="anc71"></a><span class="line-modified">653         goto cleanup;</span>

654     }
655 
656     rv = (*ckpFunctions-&gt;C_VerifyRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckDataLength);
657 
658     /* re-alloc larger buffer if it fits into our Java buffer */
659     if ((rv == CKR_BUFFER_TOO_SMALL) &amp;&amp; (ckDataLength &lt;= jIntToCKULong(jOutLen))) {
660         outBufP = (CK_BYTE_PTR) malloc(ckDataLength);
661         if (outBufP == NULL) {
<a name="72" id="anc72"></a>
662             throwOutOfMemoryError(env, 0);
<a name="73" id="anc73"></a><span class="line-modified">663             goto cleanup;</span>
664         }
665         rv = (*ckpFunctions-&gt;C_VerifyRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckDataLength);
666     }
667     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
668         (*env)-&gt;SetByteArrayRegion(env, jOut, jOutOfs, ckDataLength, (jbyte *)outBufP);
669     }
670 
<a name="74" id="anc74"></a><span class="line-added">671 cleanup:</span>
672     if (inBufP != INBUF) { free(inBufP); }
673     if (outBufP != OUTBUF) { free(outBufP); }
674 
675     return ckDataLength;
676 }
677 #endif
<a name="75" id="anc75"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="75" type="hidden" />
</body>
</html>
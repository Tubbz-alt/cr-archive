diff a/src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_keymgmt.c b/src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_keymgmt.c
--- a/src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_keymgmt.c
+++ b/src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_keymgmt.c
@@ -153,11 +153,11 @@
     unsigned long totalCkAttributesSize = 0UL, totalNativeKeyInfoArraySize = 0UL;
     jbyte* wrappedKeySizePtr = NULL;
     jbyte* nativeKeyInfoArrayRawCkAttributes = NULL;
     jbyte* nativeKeyInfoArrayRawCkAttributesPtr = NULL;
     jbyte* nativeKeyInfoArrayRawDataPtr = NULL;
-    CK_MECHANISM ckMechanism;
+    CK_MECHANISM_PTR ckpMechanism = NULL;
     char iv[16] = {0x0};
     CK_ULONG ckWrappedKeyLength = 0U;
     jbyte* wrappedKeySizeWrappedKeyArrayPtr = NULL;
     CK_BYTE_PTR wrappedKeyBufferPtr = NULL;
     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
@@ -196,12 +196,12 @@
         // the extracted buffer.
         netscapeAttributeValueNeeded = CK_TRUE;
         TRACE0("DEBUG: override CKA_NETSCAPE_DB attr value to TRUE\n");
     }
 
-    ckpAttributes = (CK_ATTRIBUTE_PTR)malloc(
-            CK_ATTRIBUTES_TEMPLATE_LENGTH * sizeof(CK_ATTRIBUTE));
+    ckpAttributes = (CK_ATTRIBUTE_PTR) calloc(
+            CK_ATTRIBUTES_TEMPLATE_LENGTH, sizeof(CK_ATTRIBUTE));
     if (ckpAttributes == NULL) {
         throwOutOfMemoryError(env, 0);
         goto cleanup;
     }
     memcpy(ckpAttributes, ckpAttributesTemplate,
@@ -306,14 +306,14 @@
 
     if ((sensitiveAttributePosition != (unsigned int)-1) &&
         *(CK_BBOOL*)(((CK_ATTRIBUTE_PTR)(((CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes)
                 +sensitiveAttributePosition))->pValue) == CK_TRUE) {
         // Key is sensitive. Need to extract it wrapped.
-        if (jWrappingKeyHandle != -1) {
+        if (jWrappingKeyHandle != 0) {
 
-            jMechanismToCKMechanism(env, jWrappingMech, &ckMechanism);
-            rv = (*ckpFunctions->C_WrapKey)(ckSessionHandle, &ckMechanism,
+            ckpMechanism = jMechanismToCKMechanismPtr(env, jWrappingMech);
+            rv = (*ckpFunctions->C_WrapKey)(ckSessionHandle, ckpMechanism,
                     jLongToCKULong(jWrappingKeyHandle), ckObjectHandle,
                     NULL_PTR, &ckWrappedKeyLength);
             if (ckWrappedKeyLength != 0) {
                 // Allocate space for getting the wrapped key
                 nativeKeyInfoWrappedKeyArray = (*env)->NewByteArray(env,
@@ -337,11 +337,11 @@
                 TRACE1("DEBUG: GetNativeKeyInfo 1st C_WrapKey wrappedKeyLength = %lu\n", ckWrappedKeyLength);
 
                 wrappedKeyBufferPtr =
                         (CK_BYTE_PTR) (wrappedKeySizeWrappedKeyArrayPtr +
                         sizeof(unsigned long));
-                rv = (*ckpFunctions->C_WrapKey)(ckSessionHandle, &ckMechanism,
+                rv = (*ckpFunctions->C_WrapKey)(ckSessionHandle, ckpMechanism,
                         jLongToCKULong(jWrappingKeyHandle),ckObjectHandle,
                         wrappedKeyBufferPtr, &ckWrappedKeyLength);
                 if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
                     goto cleanup;
                 }
@@ -349,10 +349,11 @@
                 TRACE1("DEBUG: GetNativeKeyInfo 2nd C_WrapKey wrappedKeyLength = %lu\n", ckWrappedKeyLength);
             } else {
                 goto cleanup;
             }
         } else {
+            ckAssertReturnValueOK(env, CKR_KEY_HANDLE_INVALID);
             goto cleanup;
         }
         returnValue = nativeKeyInfoWrappedKeyArray;
     } else {
         returnValue = nativeKeyInfoArray;
@@ -379,10 +380,11 @@
 
     if (nativeKeyInfoWrappedKeyArray != NULL
             && returnValue != nativeKeyInfoWrappedKeyArray) {
         (*env)->DeleteLocalRef(env, nativeKeyInfoWrappedKeyArray);
     }
+    freeCKMechanismPtr(ckpMechanism);
 
     return returnValue;
 }
 #endif
 
@@ -414,11 +416,11 @@
     jbyte* nativeKeyInfoArrayRawCkAttributesPtr = NULL;
     jbyte* nativeKeyInfoArrayRawDataPtr = NULL;
     unsigned long totalDataSize = 0UL;
     jbyte* wrappedKeySizePtr = NULL;
     unsigned int i = 0U;
-    CK_MECHANISM ckMechanism;
+    CK_MECHANISM_PTR ckpMechanism = NULL;
     char iv[16] = {0x0};
     CK_ULONG ckWrappedKeyLength = 0UL;
     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 
     if (ckpFunctions == NULL) { goto cleanup; }
@@ -465,12 +467,12 @@
         rv = (*ckpFunctions->C_CreateObject)(ckSessionHandle,
                 (CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes,
                 jLongToCKULong(nativeKeyInfoCkAttributesCount), &ckObjectHandle);
     } else {
         // Wrapped key
-        jMechanismToCKMechanism(env, jWrappingMech, &ckMechanism);
-        rv = (*ckpFunctions->C_UnwrapKey)(ckSessionHandle, &ckMechanism,
+        ckpMechanism = jMechanismToCKMechanismPtr(env, jWrappingMech);
+        rv = (*ckpFunctions->C_UnwrapKey)(ckSessionHandle, ckpMechanism,
                 jLongToCKULong(jWrappingKeyHandle),
                 (CK_BYTE_PTR)(wrappedKeySizePtr + sizeof(unsigned long)),
                 ckWrappedKeyLength,
                 (CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes,
                 jLongToCKULong(nativeKeyInfoCkAttributesCount),
@@ -487,10 +489,11 @@
     if (nativeKeyInfoArrayRaw != NULL) {
         (*env)->ReleaseByteArrayElements(env, jNativeKeyInfo,
                 nativeKeyInfoArrayRaw, JNI_ABORT);
     }
 
+    freeCKMechanismPtr(ckpMechanism);
     return jObjectHandle;
 }
 #endif
 
 #ifdef P11_ENABLE_C_GENERATEKEY
@@ -507,56 +510,51 @@
  */
 JNIEXPORT jlong JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1GenerateKey
     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jobjectArray jTemplate)
 {
     CK_SESSION_HANDLE ckSessionHandle;
-    CK_MECHANISM ckMechanism;
+    CK_MECHANISM_PTR ckpMechanism = NULL;
     CK_ATTRIBUTE_PTR ckpAttributes = NULL_PTR;
-    CK_ULONG ckAttributesLength;
+    CK_ULONG ckAttributesLength = 0;
     CK_OBJECT_HANDLE ckKeyHandle = 0;
     jlong jKeyHandle = 0L;
     CK_RV rv;
 
     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
     if (ckpFunctions == NULL) { return 0L; }
 
     ckSessionHandle = jLongToCKULong(jSessionHandle);
-    jMechanismToCKMechanism(env, jMechanism, &ckMechanism);
+    ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);
     if ((*env)->ExceptionCheck(env)) { return 0L ; }
 
     jAttributeArrayToCKAttributeArray(env, jTemplate, &ckpAttributes, &ckAttributesLength);
     if ((*env)->ExceptionCheck(env)) {
-        if (ckMechanism.pParameter != NULL_PTR) {
-            free(ckMechanism.pParameter);
-        }
-        return 0L;
+        goto cleanup;
     }
 
-    rv = (*ckpFunctions->C_GenerateKey)(ckSessionHandle, &ckMechanism, ckpAttributes, ckAttributesLength, &ckKeyHandle);
+    rv = (*ckpFunctions->C_GenerateKey)(ckSessionHandle, ckpMechanism, ckpAttributes, ckAttributesLength, &ckKeyHandle);
 
     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
         jKeyHandle = ckULongToJLong(ckKeyHandle);
 
         /* cheack, if we must give a initialization vector back to Java */
-        switch (ckMechanism.mechanism) {
+        switch (ckpMechanism->mechanism) {
         case CKM_PBE_MD2_DES_CBC:
         case CKM_PBE_MD5_DES_CBC:
         case CKM_PBE_MD5_CAST_CBC:
         case CKM_PBE_MD5_CAST3_CBC:
         case CKM_PBE_MD5_CAST128_CBC:
         /* case CKM_PBE_MD5_CAST5_CBC:  the same as CKM_PBE_MD5_CAST128_CBC */
         case CKM_PBE_SHA1_CAST128_CBC:
         /* case CKM_PBE_SHA1_CAST5_CBC: the same as CKM_PBE_SHA1_CAST128_CBC */
             /* we must copy back the initialization vector to the jMechanism object */
-            copyBackPBEInitializationVector(env, &ckMechanism, jMechanism);
+            copyBackPBEInitializationVector(env, ckpMechanism, jMechanism);
             break;
         }
     }
-
-    if (ckMechanism.pParameter != NULL_PTR) {
-        free(ckMechanism.pParameter);
-    }
+cleanup:
+    freeCKMechanismPtr(ckpMechanism);
     freeCKAttributeArray(ckpAttributes, ckAttributesLength);
 
     return jKeyHandle ;
 }
 #endif
@@ -579,58 +577,46 @@
 JNIEXPORT jlongArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1GenerateKeyPair
     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism,
      jobjectArray jPublicKeyTemplate, jobjectArray jPrivateKeyTemplate)
 {
     CK_SESSION_HANDLE ckSessionHandle;
-    CK_MECHANISM ckMechanism;
+    CK_MECHANISM_PTR ckpMechanism = NULL;
     CK_ATTRIBUTE_PTR ckpPublicKeyAttributes = NULL_PTR;
     CK_ATTRIBUTE_PTR ckpPrivateKeyAttributes = NULL_PTR;
-    CK_ULONG ckPublicKeyAttributesLength;
-    CK_ULONG ckPrivateKeyAttributesLength;
+    CK_ULONG ckPublicKeyAttributesLength = 0;
+    CK_ULONG ckPrivateKeyAttributesLength = 0;
     CK_OBJECT_HANDLE_PTR ckpPublicKeyHandle;  /* pointer to Public Key */
     CK_OBJECT_HANDLE_PTR ckpPrivateKeyHandle; /* pointer to Private Key */
-    CK_OBJECT_HANDLE_PTR ckpKeyHandles;     /* pointer to array with Public and Private Key */
+    CK_OBJECT_HANDLE_PTR ckpKeyHandles = NULL; /* pointer to array with Public and Private Key */
     jlongArray jKeyHandles = NULL;
     CK_RV rv;
     int attempts;
     const int MAX_ATTEMPTS = 3;
 
     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
     if (ckpFunctions == NULL) { return NULL; }
 
     ckSessionHandle = jLongToCKULong(jSessionHandle);
-    jMechanismToCKMechanism(env, jMechanism, &ckMechanism);
+    ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);
     if ((*env)->ExceptionCheck(env)) { return NULL; }
 
-    ckpKeyHandles = (CK_OBJECT_HANDLE_PTR) malloc(2 * sizeof(CK_OBJECT_HANDLE));
+    ckpKeyHandles = (CK_OBJECT_HANDLE_PTR) calloc(2, sizeof(CK_OBJECT_HANDLE));
     if (ckpKeyHandles == NULL) {
-        if (ckMechanism.pParameter != NULL_PTR) {
-            free(ckMechanism.pParameter);
-        }
         throwOutOfMemoryError(env, 0);
-        return NULL;
+        goto cleanup;
     }
     ckpPublicKeyHandle = ckpKeyHandles;   /* first element of array is Public Key */
     ckpPrivateKeyHandle = (ckpKeyHandles + 1);  /* second element of array is Private Key */
 
     jAttributeArrayToCKAttributeArray(env, jPublicKeyTemplate, &ckpPublicKeyAttributes, &ckPublicKeyAttributesLength);
     if ((*env)->ExceptionCheck(env)) {
-        if (ckMechanism.pParameter != NULL_PTR) {
-            free(ckMechanism.pParameter);
-        }
-        free(ckpKeyHandles);
-        return NULL;
+        goto cleanup;
     }
 
     jAttributeArrayToCKAttributeArray(env, jPrivateKeyTemplate, &ckpPrivateKeyAttributes, &ckPrivateKeyAttributesLength);
     if ((*env)->ExceptionCheck(env)) {
-        if (ckMechanism.pParameter != NULL_PTR) {
-            free(ckMechanism.pParameter);
-        }
-        free(ckpKeyHandles);
-        freeCKAttributeArray(ckpPublicKeyAttributes, ckPublicKeyAttributesLength);
-        return NULL;
+        goto cleanup;
     }
 
     /*
      * Workaround for NSS bug 1012786:
      *
@@ -647,11 +633,11 @@
      *      to make the exact same function call again would succeed.
      *
      * Call C_GenerateKeyPair() several times if CKR_FUNCTION_FAILED occurs.
      */
     for (attempts = 0; attempts < MAX_ATTEMPTS; attempts++) {
-        rv = (*ckpFunctions->C_GenerateKeyPair)(ckSessionHandle, &ckMechanism,
+        rv = (*ckpFunctions->C_GenerateKeyPair)(ckSessionHandle, ckpMechanism,
                         ckpPublicKeyAttributes, ckPublicKeyAttributesLength,
                         ckpPrivateKeyAttributes, ckPrivateKeyAttributesLength,
                         ckpPublicKeyHandle, ckpPrivateKeyHandle);
         if (rv == CKR_FUNCTION_FAILED) {
             printDebug("C_1GenerateKeyPair(): C_GenerateKeyPair() failed \
@@ -663,17 +649,15 @@
 
     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
         jKeyHandles = ckULongArrayToJLongArray(env, ckpKeyHandles, 2);
     }
 
-    if(ckMechanism.pParameter != NULL_PTR) {
-        free(ckMechanism.pParameter);
-    }
+cleanup:
+    freeCKMechanismPtr(ckpMechanism);
     free(ckpKeyHandles);
     freeCKAttributeArray(ckpPublicKeyAttributes, ckPublicKeyAttributesLength);
     freeCKAttributeArray(ckpPrivateKeyAttributes, ckPrivateKeyAttributesLength);
-
     return jKeyHandles ;
 }
 #endif
 
 #ifdef P11_ENABLE_C_WRAPKEY
@@ -691,11 +675,11 @@
  */
 JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1WrapKey
     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jWrappingKeyHandle, jlong jKeyHandle)
 {
     CK_SESSION_HANDLE ckSessionHandle;
-    CK_MECHANISM ckMechanism;
+    CK_MECHANISM_PTR ckpMechanism = NULL;
     CK_OBJECT_HANDLE ckWrappingKeyHandle;
     CK_OBJECT_HANDLE ckKeyHandle;
     jbyteArray jWrappedKey = NULL;
     CK_RV rv;
     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
@@ -704,37 +688,35 @@
 
     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
     if (ckpFunctions == NULL) { return NULL; }
 
     ckSessionHandle = jLongToCKULong(jSessionHandle);
-    jMechanismToCKMechanism(env, jMechanism, &ckMechanism);
+    ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);
     if ((*env)->ExceptionCheck(env)) { return NULL; }
 
     ckWrappingKeyHandle = jLongToCKULong(jWrappingKeyHandle);
     ckKeyHandle = jLongToCKULong(jKeyHandle);
 
-    rv = (*ckpFunctions->C_WrapKey)(ckSessionHandle, &ckMechanism, ckWrappingKeyHandle, ckKeyHandle, ckpWrappedKey, &ckWrappedKeyLength);
+    rv = (*ckpFunctions->C_WrapKey)(ckSessionHandle, ckpMechanism, ckWrappingKeyHandle, ckKeyHandle, ckpWrappedKey, &ckWrappedKeyLength);
     if (rv == CKR_BUFFER_TOO_SMALL) {
-        ckpWrappedKey = (CK_BYTE_PTR) malloc(ckWrappedKeyLength);
+        ckpWrappedKey = (CK_BYTE_PTR)
+                calloc(ckWrappedKeyLength, sizeof(CK_BYTE));
         if (ckpWrappedKey == NULL) {
-            if (ckMechanism.pParameter != NULL_PTR) {
-                free(ckMechanism.pParameter);
-            }
             throwOutOfMemoryError(env, 0);
-            return NULL;
+            goto cleanup;
         }
 
-        rv = (*ckpFunctions->C_WrapKey)(ckSessionHandle, &ckMechanism, ckWrappingKeyHandle, ckKeyHandle, ckpWrappedKey, &ckWrappedKeyLength);
+        rv = (*ckpFunctions->C_WrapKey)(ckSessionHandle, ckpMechanism, ckWrappingKeyHandle, ckKeyHandle, ckpWrappedKey, &ckWrappedKeyLength);
     }
     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
         jWrappedKey = ckByteArrayToJByteArray(env, ckpWrappedKey, ckWrappedKeyLength);
     }
 
+cleanup:
     if (ckpWrappedKey != BUF) { free(ckpWrappedKey); }
-    if (ckMechanism.pParameter != NULL_PTR) {
-        free(ckMechanism.pParameter);
-    }
+    freeCKMechanismPtr(ckpMechanism);
+
     return jWrappedKey ;
 }
 #endif
 
 #ifdef P11_ENABLE_C_UNWRAPKEY
@@ -755,122 +737,69 @@
 JNIEXPORT jlong JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1UnwrapKey
     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jUnwrappingKeyHandle,
      jbyteArray jWrappedKey, jobjectArray jTemplate)
 {
     CK_SESSION_HANDLE ckSessionHandle;
-    CK_MECHANISM ckMechanism;
+    CK_MECHANISM_PTR ckpMechanism = NULL;
     CK_OBJECT_HANDLE ckUnwrappingKeyHandle;
     CK_BYTE_PTR ckpWrappedKey = NULL_PTR;
     CK_ULONG ckWrappedKeyLength;
     CK_ATTRIBUTE_PTR ckpAttributes = NULL_PTR;
-    CK_ULONG ckAttributesLength;
+    CK_ULONG ckAttributesLength = 0;
     CK_OBJECT_HANDLE ckKeyHandle = 0;
     jlong jKeyHandle = 0L;
     CK_RV rv;
 
     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
     if (ckpFunctions == NULL) { return 0L; }
 
     ckSessionHandle = jLongToCKULong(jSessionHandle);
-    jMechanismToCKMechanism(env, jMechanism, &ckMechanism);
+    ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);
     if ((*env)->ExceptionCheck(env)) { return 0L; }
 
     ckUnwrappingKeyHandle = jLongToCKULong(jUnwrappingKeyHandle);
     jByteArrayToCKByteArray(env, jWrappedKey, &ckpWrappedKey, &ckWrappedKeyLength);
     if ((*env)->ExceptionCheck(env)) {
-        if (ckMechanism.pParameter != NULL_PTR) {
-            free(ckMechanism.pParameter);
-        }
-        return 0L;
+        goto cleanup;
     }
 
     jAttributeArrayToCKAttributeArray(env, jTemplate, &ckpAttributes, &ckAttributesLength);
     if ((*env)->ExceptionCheck(env)) {
-        if (ckMechanism.pParameter != NULL_PTR) {
-            free(ckMechanism.pParameter);
-        }
-        free(ckpWrappedKey);
-        return 0L;
+        goto cleanup;
     }
 
 
-    rv = (*ckpFunctions->C_UnwrapKey)(ckSessionHandle, &ckMechanism, ckUnwrappingKeyHandle,
+    rv = (*ckpFunctions->C_UnwrapKey)(ckSessionHandle, ckpMechanism, ckUnwrappingKeyHandle,
                  ckpWrappedKey, ckWrappedKeyLength,
                  ckpAttributes, ckAttributesLength, &ckKeyHandle);
 
     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
         jKeyHandle = ckLongToJLong(ckKeyHandle);
 
 #if 0
         /* cheack, if we must give a initialization vector back to Java */
-        if (ckMechanism.mechanism == CKM_KEY_WRAP_SET_OAEP) {
+        if (ckpMechanism->mechanism == CKM_KEY_WRAP_SET_OAEP) {
             /* we must copy back the unwrapped key info to the jMechanism object */
-            copyBackSetUnwrappedKey(env, &ckMechanism, jMechanism);
+            copyBackSetUnwrappedKey(env, ckpMechanism, jMechanism);
         }
 #endif
     }
-
-    if (ckMechanism.pParameter != NULL_PTR) {
-        free(ckMechanism.pParameter);
-    }
+cleanup:
+    freeCKMechanismPtr(ckpMechanism);
     freeCKAttributeArray(ckpAttributes, ckAttributesLength);
     free(ckpWrappedKey);
 
     return jKeyHandle ;
 }
 #endif
 
 #ifdef P11_ENABLE_C_DERIVEKEY
 
-static void freeMasterKeyDeriveParams(CK_SSL3_RANDOM_DATA *RandomInfo, CK_VERSION_PTR pVersion) {
-    if (RandomInfo->pClientRandom != NULL) {
-        free(RandomInfo->pClientRandom);
-    }
-    if (RandomInfo->pServerRandom != NULL) {
-        free(RandomInfo->pServerRandom);
-    }
-    if (pVersion != NULL) {
-        free(pVersion);
-    }
-}
-
-void ssl3FreeMasterKeyDeriveParams(CK_MECHANISM_PTR ckMechanism) {
-    CK_SSL3_MASTER_KEY_DERIVE_PARAMS *params = (CK_SSL3_MASTER_KEY_DERIVE_PARAMS *) ckMechanism->pParameter;
-    if (params == NULL) {
-        return;
-    }
-    freeMasterKeyDeriveParams(&(params->RandomInfo), params->pVersion);
-}
-
-void tls12FreeMasterKeyDeriveParams(CK_MECHANISM_PTR ckMechanism) {
-    CK_TLS12_MASTER_KEY_DERIVE_PARAMS *params =
-            (CK_TLS12_MASTER_KEY_DERIVE_PARAMS *)ckMechanism->pParameter;
-    if (params == NULL) {
-        return;
-    }
-    freeMasterKeyDeriveParams(&(params->RandomInfo), params->pVersion);
-}
-
-void freeEcdh1DeriveParams(CK_MECHANISM_PTR ckMechanism) {
-    CK_ECDH1_DERIVE_PARAMS *params =
-            (CK_ECDH1_DERIVE_PARAMS *)ckMechanism->pParameter;
-    if (params == NULL) {
-        return;
-    }
-
-    if (params->pSharedData != NULL) {
-        free(params->pSharedData);
-    }
-    if (params->pPublicData != NULL) {
-        free(params->pPublicData);
-    }
-}
-
 /*
  * Copy back the PRF output to Java.
  */
-void copyBackTLSPrfParams(JNIEnv *env, CK_MECHANISM *ckMechanism, jobject jMechanism)
+void copyBackTLSPrfParams(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism, jobject jMechanism)
 {
     jclass jMechanismClass, jTLSPrfParamsClass;
     CK_TLS_PRF_PARAMS *ckTLSPrfParams;
     jobject jTLSPrfParams;
     jfieldID fieldID;
@@ -887,17 +816,17 @@
     if (jMechanismClass == NULL) { return; }
     fieldID = (*env)->GetFieldID(env, jMechanismClass, "mechanism", "J");
     if (fieldID == NULL) { return; }
     jMechanismType = (*env)->GetLongField(env, jMechanism, fieldID);
     ckMechanismType = jLongToCKULong(jMechanismType);
-    if (ckMechanismType != ckMechanism->mechanism) {
+    if (ckMechanismType != ckpMechanism->mechanism) {
         /* we do not have maching types, this should not occur */
         return;
     }
 
     /* get the native CK_TLS_PRF_PARAMS */
-    ckTLSPrfParams = (CK_TLS_PRF_PARAMS *) ckMechanism->pParameter;
+    ckTLSPrfParams = (CK_TLS_PRF_PARAMS *) ckpMechanism->pParameter;
     if (ckTLSPrfParams != NULL_PTR) {
         /* get the Java CK_TLS_PRF_PARAMS object (pParameter) */
         fieldID = (*env)->GetFieldID(env, jMechanismClass, "pParameter", "Ljava/lang/Object;");
         if (fieldID == NULL) { return; }
         jTLSPrfParams = (*env)->GetObjectField(env, jMechanism, fieldID);
@@ -922,16 +851,10 @@
                 jBytes[i] = ckByteToJByte(output[i]);
             }
             /* copy back the Java buffer to the object */
             (*env)->ReleaseByteArrayElements(env, jOutput, jBytes, 0);
         }
-
-        // free malloc'd data
-        free(ckTLSPrfParams->pSeed);
-        free(ckTLSPrfParams->pLabel);
-        free(ckTLSPrfParams->pulOutputLen);
-        free(ckTLSPrfParams->pOutput);
     }
 }
 
 /*
  * Class:     sun_security_pkcs11_wrapper_PKCS11
@@ -947,36 +870,33 @@
  */
 JNIEXPORT jlong JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1DeriveKey
     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jBaseKeyHandle, jobjectArray jTemplate)
 {
     CK_SESSION_HANDLE ckSessionHandle;
-    CK_MECHANISM ckMechanism;
+    CK_MECHANISM_PTR ckpMechanism = NULL;
     CK_OBJECT_HANDLE ckBaseKeyHandle;
     CK_ATTRIBUTE_PTR ckpAttributes = NULL_PTR;
-    CK_ULONG ckAttributesLength;
+    CK_ULONG ckAttributesLength = 0;
     CK_OBJECT_HANDLE ckKeyHandle = 0;
     jlong jKeyHandle = 0L;
     CK_RV rv;
     CK_OBJECT_HANDLE_PTR phKey = &ckKeyHandle;
 
     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
     if (ckpFunctions == NULL) { return 0L; }
 
     ckSessionHandle = jLongToCKULong(jSessionHandle);
-    jMechanismToCKMechanism(env, jMechanism, &ckMechanism);
+    ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);
     if ((*env)->ExceptionCheck(env)) { return 0L; }
 
     ckBaseKeyHandle = jLongToCKULong(jBaseKeyHandle);
     jAttributeArrayToCKAttributeArray(env, jTemplate, &ckpAttributes, &ckAttributesLength);
     if ((*env)->ExceptionCheck(env)) {
-        if (ckMechanism.pParameter != NULL_PTR) {
-            free(ckMechanism.pParameter);
-        }
-        return 0L;
+        goto cleanup;
     }
 
-    switch (ckMechanism.mechanism) {
+    switch (ckpMechanism->mechanism) {
     case CKM_SSL3_KEY_AND_MAC_DERIVE:
     case CKM_TLS_KEY_AND_MAC_DERIVE:
     case CKM_TLS12_KEY_AND_MAC_DERIVE:
     case CKM_TLS_PRF:
         // these mechanism do not return a key handle via phKey
@@ -986,64 +906,52 @@
     default:
         // empty
         break;
     }
 
-    rv = (*ckpFunctions->C_DeriveKey)(ckSessionHandle, &ckMechanism, ckBaseKeyHandle,
+    rv = (*ckpFunctions->C_DeriveKey)(ckSessionHandle, ckpMechanism, ckBaseKeyHandle,
                  ckpAttributes, ckAttributesLength, phKey);
 
     jKeyHandle = ckLongToJLong(ckKeyHandle);
 
-    freeCKAttributeArray(ckpAttributes, ckAttributesLength);
-
-    switch (ckMechanism.mechanism) {
+    switch (ckpMechanism->mechanism) {
     case CKM_SSL3_MASTER_KEY_DERIVE:
     case CKM_TLS_MASTER_KEY_DERIVE:
         /* we must copy back the client version */
-        ssl3CopyBackClientVersion(env, &ckMechanism, jMechanism);
-        ssl3FreeMasterKeyDeriveParams(&ckMechanism);
+        ssl3CopyBackClientVersion(env, ckpMechanism, jMechanism);
         break;
     case CKM_TLS12_MASTER_KEY_DERIVE:
-        tls12CopyBackClientVersion(env, &ckMechanism, jMechanism);
-        tls12FreeMasterKeyDeriveParams(&ckMechanism);
-        break;
-    case CKM_SSL3_MASTER_KEY_DERIVE_DH:
-    case CKM_TLS_MASTER_KEY_DERIVE_DH:
-        ssl3FreeMasterKeyDeriveParams(&ckMechanism);
-        break;
-    case CKM_TLS12_MASTER_KEY_DERIVE_DH:
-        tls12FreeMasterKeyDeriveParams(&ckMechanism);
+        tls12CopyBackClientVersion(env, ckpMechanism, jMechanism);
         break;
     case CKM_SSL3_KEY_AND_MAC_DERIVE:
     case CKM_TLS_KEY_AND_MAC_DERIVE:
         /* we must copy back the unwrapped key info to the jMechanism object */
-        ssl3CopyBackKeyMatParams(env, &ckMechanism, jMechanism);
+        ssl3CopyBackKeyMatParams(env, ckpMechanism, jMechanism);
         break;
     case CKM_TLS12_KEY_AND_MAC_DERIVE:
         /* we must copy back the unwrapped key info to the jMechanism object */
-        tls12CopyBackKeyMatParams(env, &ckMechanism, jMechanism);
+        tls12CopyBackKeyMatParams(env, ckpMechanism, jMechanism);
         break;
     case CKM_TLS_PRF:
-        copyBackTLSPrfParams(env, &ckMechanism, jMechanism);
-        break;
-    case CKM_ECDH1_DERIVE:
-        freeEcdh1DeriveParams(&ckMechanism);
+        copyBackTLSPrfParams(env, ckpMechanism, jMechanism);
         break;
     default:
         // empty
         break;
     }
-
-    if (ckMechanism.pParameter != NULL_PTR) {
-        free(ckMechanism.pParameter);
+    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
+        jKeyHandle =0L;
     }
-    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return 0L ; }
+
+cleanup:
+    freeCKMechanismPtr(ckpMechanism);
+    freeCKAttributeArray(ckpAttributes, ckAttributesLength);
 
     return jKeyHandle ;
 }
 
-static void copyBackClientVersion(JNIEnv *env, CK_MECHANISM *ckMechanism, jobject jMechanism,
+static void copyBackClientVersion(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism, jobject jMechanism,
         CK_VERSION *ckVersion, const char *class_master_key_derive_params)
 {
     jclass jMasterKeyDeriveParamsClass, jMechanismClass, jVersionClass;
     jobject jMasterKeyDeriveParams;
     jfieldID fieldID;
@@ -1056,11 +964,11 @@
     if (jMechanismClass == NULL) { return; }
     fieldID = (*env)->GetFieldID(env, jMechanismClass, "mechanism", "J");
     if (fieldID == NULL) { return; }
     jMechanismType = (*env)->GetLongField(env, jMechanism, fieldID);
     ckMechanismType = jLongToCKULong(jMechanismType);
-    if (ckMechanismType != ckMechanism->mechanism) {
+    if (ckMechanismType != ckpMechanism->mechanism) {
         /* we do not have maching types, this should not occur */
         return;
     }
 
     if (ckVersion != NULL_PTR) {
@@ -1099,18 +1007,18 @@
  * structure to the Java object. This is only used for
  * CKM_SSL3_MASTER_KEY_DERIVE and CKM_TLS_MASTER_KEY_DERIVE
  * mechanisms when used for deriving a key.
  *
  */
-void ssl3CopyBackClientVersion(JNIEnv *env, CK_MECHANISM *ckMechanism,
+void ssl3CopyBackClientVersion(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism,
         jobject jMechanism)
 {
     CK_SSL3_MASTER_KEY_DERIVE_PARAMS *ckSSL3MasterKeyDeriveParams;
     ckSSL3MasterKeyDeriveParams =
-            (CK_SSL3_MASTER_KEY_DERIVE_PARAMS *)ckMechanism->pParameter;
+            (CK_SSL3_MASTER_KEY_DERIVE_PARAMS *)ckpMechanism->pParameter;
     if (ckSSL3MasterKeyDeriveParams != NULL_PTR) {
-        copyBackClientVersion(env, ckMechanism, jMechanism,
+        copyBackClientVersion(env, ckpMechanism, jMechanism,
                 ckSSL3MasterKeyDeriveParams->pVersion,
                 CLASS_SSL3_MASTER_KEY_DERIVE_PARAMS);
     }
 }
 
@@ -1118,24 +1026,24 @@
  * Copy back the client version information from the native
  * structure to the Java object. This is only used for
  * CKM_TLS12_MASTER_KEY_DERIVE mechanism when used for deriving a key.
  *
  */
-void tls12CopyBackClientVersion(JNIEnv *env, CK_MECHANISM *ckMechanism,
+void tls12CopyBackClientVersion(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism,
         jobject jMechanism)
 {
     CK_TLS12_MASTER_KEY_DERIVE_PARAMS *ckTLS12MasterKeyDeriveParams;
     ckTLS12MasterKeyDeriveParams =
-            (CK_TLS12_MASTER_KEY_DERIVE_PARAMS *)ckMechanism->pParameter;
+            (CK_TLS12_MASTER_KEY_DERIVE_PARAMS *)ckpMechanism->pParameter;
     if (ckTLS12MasterKeyDeriveParams != NULL_PTR) {
-        copyBackClientVersion(env, ckMechanism, jMechanism,
+        copyBackClientVersion(env, ckpMechanism, jMechanism,
                 ckTLS12MasterKeyDeriveParams->pVersion,
                 CLASS_TLS12_MASTER_KEY_DERIVE_PARAMS);
     }
 }
 
-static void copyBackKeyMatParams(JNIEnv *env, CK_MECHANISM *ckMechanism,
+static void copyBackKeyMatParams(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism,
         jobject jMechanism, CK_SSL3_RANDOM_DATA *RandomInfo,
         CK_SSL3_KEY_MAT_OUT_PTR ckSSL3KeyMatOut, const char *class_key_mat_params)
 {
     jclass jMechanismClass, jKeyMatParamsClass, jSSL3KeyMatOutClass;
     jfieldID fieldID;
@@ -1154,23 +1062,15 @@
     if (jMechanismClass == NULL) { return; }
     fieldID = (*env)->GetFieldID(env, jMechanismClass, "mechanism", "J");
     if (fieldID == NULL) { return; }
     jMechanismType = (*env)->GetLongField(env, jMechanism, fieldID);
     ckMechanismType = jLongToCKULong(jMechanismType);
-    if (ckMechanismType != ckMechanism->mechanism) {
+    if (ckMechanismType != ckpMechanism->mechanism) {
         /* we do not have maching types, this should not occur */
         return;
     }
 
-    // free malloc'd data
-    if (RandomInfo->pClientRandom != NULL) {
-        free(RandomInfo->pClientRandom);
-    }
-    if (RandomInfo->pServerRandom != NULL) {
-        free(RandomInfo->pServerRandom);
-    }
-
     if (ckSSL3KeyMatOut != NULL_PTR) {
       /* get the Java params object (pParameter) */
       fieldID = (*env)->GetFieldID(env, jMechanismClass, "pParameter",
               "Ljava/lang/Object;");
       if (fieldID == NULL) { return; }
@@ -1228,12 +1128,10 @@
           jBytes[i] = ckByteToJByte(iv[i]);
         }
         /* copy back the Java buffer to the object */
         (*env)->ReleaseByteArrayElements(env, jIV, jBytes, 0);
       }
-      // free malloc'd data
-      free(ckSSL3KeyMatOut->pIVClient);
 
       /* copy back the server IV */
       fieldID = (*env)->GetFieldID(env, jSSL3KeyMatOutClass, "pIVServer", "[B");
       if (fieldID == NULL) { return; }
       jIV = (*env)->GetObjectField(env, jSSL3KeyMatOut, fieldID);
@@ -1248,30 +1146,27 @@
           jBytes[i] = ckByteToJByte(iv[i]);
         }
         /* copy back the Java buffer to the object */
         (*env)->ReleaseByteArrayElements(env, jIV, jBytes, 0);
       }
-      // free malloc'd data
-      free(ckSSL3KeyMatOut->pIVServer);
-      free(ckSSL3KeyMatOut);
     }
 }
 
 /*
  * Copy back the derived keys and initialization vectors from the native
  * structure to the Java object. This is only used for
  * CKM_SSL3_KEY_AND_MAC_DERIVE and CKM_TLS_KEY_AND_MAC_DERIVE mechanisms
  * when used for deriving a key.
  *
  */
-void ssl3CopyBackKeyMatParams(JNIEnv *env, CK_MECHANISM *ckMechanism,
+void ssl3CopyBackKeyMatParams(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism,
         jobject jMechanism)
 {
     CK_SSL3_KEY_MAT_PARAMS *ckSSL3KeyMatParam;
-    ckSSL3KeyMatParam = (CK_SSL3_KEY_MAT_PARAMS *)ckMechanism->pParameter;
+    ckSSL3KeyMatParam = (CK_SSL3_KEY_MAT_PARAMS *)ckpMechanism->pParameter;
     if (ckSSL3KeyMatParam != NULL_PTR) {
-        copyBackKeyMatParams(env, ckMechanism, jMechanism,
+        copyBackKeyMatParams(env, ckpMechanism, jMechanism,
                 &(ckSSL3KeyMatParam->RandomInfo),
                 ckSSL3KeyMatParam->pReturnedKeyMaterial,
                 CLASS_SSL3_KEY_MAT_PARAMS);
     }
 }
@@ -1280,17 +1175,17 @@
  * Copy back the derived keys and initialization vectors from the native
  * structure to the Java object. This is only used for
  * CKM_TLS12_KEY_AND_MAC_DERIVE mechanism when used for deriving a key.
  *
  */
-void tls12CopyBackKeyMatParams(JNIEnv *env, CK_MECHANISM *ckMechanism,
+void tls12CopyBackKeyMatParams(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism,
         jobject jMechanism)
 {
     CK_TLS12_KEY_MAT_PARAMS *ckTLS12KeyMatParam;
-    ckTLS12KeyMatParam = (CK_TLS12_KEY_MAT_PARAMS *) ckMechanism->pParameter;
+    ckTLS12KeyMatParam = (CK_TLS12_KEY_MAT_PARAMS *)ckpMechanism->pParameter;
     if (ckTLS12KeyMatParam != NULL_PTR) {
-        copyBackKeyMatParams(env, ckMechanism, jMechanism,
+        copyBackKeyMatParams(env, ckpMechanism, jMechanism,
                 &(ckTLS12KeyMatParam->RandomInfo),
                 ckTLS12KeyMatParam->pReturnedKeyMaterial,
                 CLASS_TLS12_KEY_MAT_PARAMS);
     }
 }

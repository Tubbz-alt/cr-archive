<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_convert.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 
   5 /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
   6  *
   7  * Redistribution and use in  source and binary forms, with or without
   8  * modification, are permitted  provided that the following conditions are met:
   9  *
  10  * 1. Redistributions of  source code must retain the above copyright notice,
  11  *    this list of conditions and the following disclaimer.
  12  *
  13  * 2. Redistributions in  binary form must reproduce the above copyright notice,
  14  *    this list of conditions and the following disclaimer in the documentation
  15  *    and/or other materials provided with the distribution.
  16  *
  17  * 3. The end-user documentation included with the redistribution, if any, must
  18  *    include the following acknowledgment:
  19  *
  20  *    &quot;This product includes software developed by IAIK of Graz University of
  21  *     Technology.&quot;
  22  *
  23  *    Alternately, this acknowledgment may appear in the software itself, if
  24  *    and wherever such third-party acknowledgments normally appear.
  25  *
  26  * 4. The names &quot;Graz University of Technology&quot; and &quot;IAIK of Graz University of
  27  *    Technology&quot; must not be used to endorse or promote products derived from
  28  *    this software without prior written permission.
  29  *
  30  * 5. Products derived from this software may not be called
  31  *    &quot;IAIK PKCS Wrapper&quot;, nor may &quot;IAIK&quot; appear in their name, without prior
  32  *    written permission of Graz University of Technology.
  33  *
  34  *  THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESSED OR IMPLIED
  35  *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  36  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  37  *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE LICENSOR BE
  38  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
  39  *  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  40  *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  41  *  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  42  *  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  43  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  44  *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  45  *  POSSIBILITY  OF SUCH DAMAGE.
  46  */
  47 
  48 /*
  49  * pkcs11wrapper.c
  50  * 18.05.2001
  51  *
  52  * This is the implementation of the native functions of the Java to PKCS#11 interface.
  53  * All function use some helper functions to convert the JNI types to PKCS#11 types.
  54  *
  55  * @author Karl Scheibelhofer &lt;Karl.Scheibelhofer@iaik.at&gt;
  56  * @author Martin Schlaeffer &lt;schlaeff@sbox.tugraz.at&gt;
  57  */
  58 
  59 
  60 #include &quot;pkcs11wrapper.h&quot;
  61 
  62 #include &lt;stdio.h&gt;
  63 #include &lt;stdlib.h&gt;
  64 #include &lt;string.h&gt;
  65 #include &lt;assert.h&gt;
  66 
  67 #include &quot;sun_security_pkcs11_wrapper_PKCS11.h&quot;
  68 
  69 /* declare file private functions */
  70 
  71 void jMechanismParameterToCKMechanismParameterSlow(JNIEnv *env, jobject jParam, CK_VOID_PTR *ckpParamPtr, CK_ULONG *ckpLength);
  72 
  73 
  74 /*
  75  * converts a pointer to a CK_DATE structure into a Java CK_DATE Object.
  76  *
  77  * @param env - used to call JNI funktions to create the new Java object
  78  * @param ckpValue - the pointer to the CK_DATE structure
  79  * @return - the new Java CK_DATE object
  80  */
  81 jobject ckDatePtrToJDateObject(JNIEnv *env, const CK_DATE *ckpDate)
  82 {
  83     jclass jDateClass;
  84     jmethodID jCtrId;
  85     jobject jDateObject;
  86     jcharArray jYear;
  87     jcharArray jMonth;
  88     jcharArray jDay;
  89 
  90     /* load CK_DATE class */
  91     jDateClass = (*env)-&gt;FindClass(env, CLASS_DATE);
  92     if (jDateClass == NULL) { return NULL; }
  93 
  94     /* load CK_DATE constructor */
  95     jCtrId = (*env)-&gt;GetMethodID(env, jDateClass, &quot;&lt;init&gt;&quot;, &quot;([C[C[C)V&quot;);
  96     if (jCtrId == NULL) { return NULL; }
  97 
  98     /* prep all fields */
  99     jYear = ckCharArrayToJCharArray(env, (CK_CHAR_PTR)(ckpDate-&gt;year), 4);
 100     if (jYear == NULL) { return NULL; }
 101     jMonth = ckCharArrayToJCharArray(env, (CK_CHAR_PTR)(ckpDate-&gt;month), 2);
 102     if (jMonth == NULL) { return NULL; }
 103     jDay = ckCharArrayToJCharArray(env, (CK_CHAR_PTR)(ckpDate-&gt;day), 2);
 104     if (jDay == NULL) { return NULL; }
 105 
 106     /* create new CK_DATE object */
 107     jDateObject =
 108       (*env)-&gt;NewObject(env, jDateClass, jCtrId, jYear, jMonth, jDay);
 109     if (jDateObject == NULL) { return NULL; }
 110 
 111     /* free local references */
 112     (*env)-&gt;DeleteLocalRef(env, jDateClass);
 113     (*env)-&gt;DeleteLocalRef(env, jYear);
 114     (*env)-&gt;DeleteLocalRef(env, jMonth);
 115     (*env)-&gt;DeleteLocalRef(env, jDay);
 116 
 117     return jDateObject ;
 118 }
 119 
 120 /*
 121  * converts a pointer to a CK_VERSION structure into a Java CK_VERSION Object.
 122  *
 123  * @param env - used to call JNI funktions to create the new Java object
 124  * @param ckpVersion - the pointer to the CK_VERSION structure
 125  * @return - the new Java CK_VERSION object
 126  */
 127 jobject ckVersionPtrToJVersion(JNIEnv *env, const CK_VERSION_PTR ckpVersion)
 128 {
 129     jclass jVersionClass;
 130     jmethodID jCtrId;
 131     jobject jVersionObject;
 132     jint jMajor;
 133     jint jMinor;
 134 
 135     /* load CK_VERSION class */
 136     jVersionClass = (*env)-&gt;FindClass(env, CLASS_VERSION);
 137     if (jVersionClass == NULL) { return NULL; }
 138 
 139     /* load CK_VERSION constructor */
 140     jCtrId = (*env)-&gt;GetMethodID(env, jVersionClass, &quot;&lt;init&gt;&quot;, &quot;(II)V&quot;);
 141     if (jCtrId == NULL) { return NULL; }
 142 
 143     /* prep both fields */
 144     jMajor = ckpVersion-&gt;major;
 145     jMinor = ckpVersion-&gt;minor;
 146 
 147     /* create new CK_VERSION object */
 148     jVersionObject =
 149       (*env)-&gt;NewObject(env, jVersionClass, jCtrId, jMajor, jMinor);
 150     if (jVersionObject == NULL) { return NULL; }
 151 
 152     /* free local references */
 153     (*env)-&gt;DeleteLocalRef(env, jVersionClass);
 154 
 155     return jVersionObject ;
 156 }
 157 
 158 /*
 159  * converts a pointer to a CK_SESSION_INFO structure into a Java CK_SESSION_INFO Object.
 160  *
 161  * @param env - used to call JNI funktions to create the new Java object
 162  * @param ckpSessionInfo - the pointer to the CK_SESSION_INFO structure
 163  * @return - the new Java CK_SESSION_INFO object
 164  */
 165 jobject ckSessionInfoPtrToJSessionInfo(JNIEnv *env, const CK_SESSION_INFO_PTR ckpSessionInfo)
 166 {
 167     jclass jSessionInfoClass;
 168     jmethodID jCtrId;
 169     jobject jSessionInfoObject;
 170     jlong jSlotID;
 171     jlong jState;
 172     jlong jFlags;
 173     jlong jDeviceError;
 174 
 175     /* load CK_SESSION_INFO class */
 176     jSessionInfoClass = (*env)-&gt;FindClass(env, CLASS_SESSION_INFO);
 177     if (jSessionInfoClass == NULL) { return NULL; }
 178 
 179     /* load CK_SESSION_INFO constructor */
 180     jCtrId = (*env)-&gt;GetMethodID(env, jSessionInfoClass, &quot;&lt;init&gt;&quot;, &quot;(JJJJ)V&quot;);
 181     if (jCtrId == NULL) { return NULL; }
 182 
 183     /* prep all fields */
 184     jSlotID = ckULongToJLong(ckpSessionInfo-&gt;slotID);
 185     jState = ckULongToJLong(ckpSessionInfo-&gt;state);
 186     jFlags = ckULongToJLong(ckpSessionInfo-&gt;flags);
 187     jDeviceError = ckULongToJLong(ckpSessionInfo-&gt;ulDeviceError);
 188 
 189     /* create new CK_SESSION_INFO object */
 190     jSessionInfoObject =
 191       (*env)-&gt;NewObject(env, jSessionInfoClass, jCtrId, jSlotID, jState,
 192                         jFlags, jDeviceError);
 193     if (jSessionInfoObject == NULL) { return NULL; }
 194 
 195     /* free local references */
 196     (*env)-&gt;DeleteLocalRef(env, jSessionInfoClass);
 197 
 198     return jSessionInfoObject ;
 199 }
 200 
 201 /*
 202  * converts a pointer to a CK_ATTRIBUTE structure into a Java CK_ATTRIBUTE Object.
 203  *
 204  * @param env - used to call JNI funktions to create the new Java object
 205  * @param ckpAttribute - the pointer to the CK_ATTRIBUTE structure
 206  * @return - the new Java CK_ATTRIBUTE object
 207  */
 208 jobject ckAttributePtrToJAttribute(JNIEnv *env, const CK_ATTRIBUTE_PTR ckpAttribute)
 209 {
 210     jclass jAttributeClass;
 211     jmethodID jCtrId;
 212     jobject jAttributeObject;
 213     jlong jType;
 214     jobject jPValue = NULL;
 215 
 216     jAttributeClass = (*env)-&gt;FindClass(env, CLASS_ATTRIBUTE);
 217     if (jAttributeClass == NULL) { return NULL; }
 218 
 219     /* load CK_INFO constructor */
 220     jCtrId = (*env)-&gt;GetMethodID(env, jAttributeClass, &quot;&lt;init&gt;&quot;, &quot;(JLjava/lang/Object;)V&quot;);
 221     if (jCtrId == NULL) { return NULL; }
 222 
 223     /* prep both fields */
 224     jType = ckULongToJLong(ckpAttribute-&gt;type);
 225     jPValue = ckAttributeValueToJObject(env, ckpAttribute);
 226     if ((*env)-&gt;ExceptionCheck(env)) { return NULL; }
 227 
 228     /* create new CK_ATTRIBUTE object */
 229     jAttributeObject =
 230       (*env)-&gt;NewObject(env, jAttributeClass, jCtrId, jType, jPValue);
 231     if (jAttributeObject == NULL) { return NULL; }
 232 
 233     /* free local references */
 234     (*env)-&gt;DeleteLocalRef(env, jAttributeClass);
 235     (*env)-&gt;DeleteLocalRef(env, jPValue);
 236 
 237     return jAttributeObject;
 238 }
 239 
 240 
 241 /*
 242  * converts a Java CK_VERSION object into a pointer to a CK_VERSION structure
 243  *
 244  * @param env - used to call JNI funktions to get the values out of the Java object
 245  * @param jVersion - the Java CK_VERSION object to convert
 246  * @return - the pointer to the new CK_VERSION structure
 247  */
 248 CK_VERSION_PTR jVersionToCKVersionPtr(JNIEnv *env, jobject jVersion)
 249 {
 250     CK_VERSION_PTR ckpVersion;
 251     jclass jVersionClass;
 252     jfieldID jFieldID;
 253     jbyte jMajor, jMinor;
 254 
 255     if (jVersion == NULL) {
 256         return NULL;
 257     }
 258 
 259     /* get CK_VERSION class */
 260     jVersionClass = (*env)-&gt;GetObjectClass(env, jVersion);
 261     if (jVersionClass == NULL) { return NULL; }
 262 
 263     /* get Major */
 264     jFieldID = (*env)-&gt;GetFieldID(env, jVersionClass, &quot;major&quot;, &quot;B&quot;);
 265     if (jFieldID == NULL) { return NULL; }
 266     jMajor = (*env)-&gt;GetByteField(env, jVersion, jFieldID);
 267 
 268     /* get Minor */
 269     jFieldID = (*env)-&gt;GetFieldID(env, jVersionClass, &quot;minor&quot;, &quot;B&quot;);
 270     if (jFieldID == NULL) { return NULL; }
 271     jMinor = (*env)-&gt;GetByteField(env, jVersion, jFieldID);
 272 
 273     /* allocate memory for CK_VERSION pointer */
 274     ckpVersion = (CK_VERSION_PTR) malloc(sizeof(CK_VERSION));
 275     if (ckpVersion == NULL) {
 276         throwOutOfMemoryError(env, 0);
 277         return NULL;
 278     }
 279     ckpVersion-&gt;major = jByteToCKByte(jMajor);
 280     ckpVersion-&gt;minor = jByteToCKByte(jMinor);
 281 
 282     return ckpVersion ;
 283 }
 284 
 285 
 286 /*
 287  * converts a Java CK_DATE object into a pointer to a CK_DATE structure
 288  *
 289  * @param env - used to call JNI funktions to get the values out of the Java object
 290  * @param jVersion - the Java CK_DATE object to convert
 291  * @return - the pointer to the new CK_DATE structure
 292  */
 293 CK_DATE * jDateObjectPtrToCKDatePtr(JNIEnv *env, jobject jDate)
 294 {
 295     CK_DATE * ckpDate;
 296     CK_ULONG ckLength;
 297     jclass jDateClass;
 298     jfieldID jFieldID;
 299     jobject jYear, jMonth, jDay;
 300     jchar *jTempChars;
 301     CK_ULONG i;
 302 
 303     if (jDate == NULL) {
 304         return NULL;
 305     }
 306 
 307     /* get CK_DATE class */
 308     jDateClass = (*env)-&gt;FindClass(env, CLASS_DATE);
 309     if (jDateClass == NULL) { return NULL; }
 310 
 311     /* get Year */
 312     jFieldID = (*env)-&gt;GetFieldID(env, jDateClass, &quot;year&quot;, &quot;[C&quot;);
 313     if (jFieldID == NULL) { return NULL; }
 314     jYear = (*env)-&gt;GetObjectField(env, jDate, jFieldID);
 315 
 316     /* get Month */
 317     jFieldID = (*env)-&gt;GetFieldID(env, jDateClass, &quot;month&quot;, &quot;[C&quot;);
 318     if (jFieldID == NULL) { return NULL; }
 319     jMonth = (*env)-&gt;GetObjectField(env, jDate, jFieldID);
 320 
 321     /* get Day */
 322     jFieldID = (*env)-&gt;GetFieldID(env, jDateClass, &quot;day&quot;, &quot;[C&quot;);
 323     if (jFieldID == NULL) { return NULL; }
 324     jDay = (*env)-&gt;GetObjectField(env, jDate, jFieldID);
 325 
 326     /* allocate memory for CK_DATE pointer */
 327     ckpDate = (CK_DATE *) malloc(sizeof(CK_DATE));
 328     if (ckpDate == NULL) {
 329         throwOutOfMemoryError(env, 0);
 330         return NULL;
 331     }
 332 
 333     if (jYear == NULL) {
 334         ckpDate-&gt;year[0] = 0;
 335         ckpDate-&gt;year[1] = 0;
 336         ckpDate-&gt;year[2] = 0;
 337         ckpDate-&gt;year[3] = 0;
 338     } else {
 339         ckLength = (*env)-&gt;GetArrayLength(env, jYear);
 340         jTempChars = (jchar*) malloc((ckLength) * sizeof(jchar));
 341         if (jTempChars == NULL) {
 342             free(ckpDate);
 343             throwOutOfMemoryError(env, 0);
 344             return NULL;
 345         }
 346         (*env)-&gt;GetCharArrayRegion(env, jYear, 0, ckLength, jTempChars);
 347         if ((*env)-&gt;ExceptionCheck(env)) {
 348             free(ckpDate);
 349             free(jTempChars);
 350             return NULL;
 351         }
 352 
 353         for (i = 0; (i &lt; ckLength) &amp;&amp; (i &lt; 4) ; i++) {
 354             ckpDate-&gt;year[i] = jCharToCKChar(jTempChars[i]);
 355         }
 356         free(jTempChars);
 357     }
 358 
 359     if (jMonth == NULL) {
 360         ckpDate-&gt;month[0] = 0;
 361         ckpDate-&gt;month[1] = 0;
 362     } else {
 363         ckLength = (*env)-&gt;GetArrayLength(env, jMonth);
 364         jTempChars = (jchar*) malloc((ckLength) * sizeof(jchar));
 365         if (jTempChars == NULL) {
 366             free(ckpDate);
 367             throwOutOfMemoryError(env, 0);
 368             return NULL;
 369         }
 370         (*env)-&gt;GetCharArrayRegion(env, jMonth, 0, ckLength, jTempChars);
 371         if ((*env)-&gt;ExceptionCheck(env)) {
 372             free(ckpDate);
 373             free(jTempChars);
 374             return NULL;
 375         }
 376 
 377         for (i = 0; (i &lt; ckLength) &amp;&amp; (i &lt; 2) ; i++) {
 378             ckpDate-&gt;month[i] = jCharToCKChar(jTempChars[i]);
 379         }
 380         free(jTempChars);
 381     }
 382 
 383     if (jDay == NULL) {
 384         ckpDate-&gt;day[0] = 0;
 385         ckpDate-&gt;day[1] = 0;
 386     } else {
 387         ckLength = (*env)-&gt;GetArrayLength(env, jDay);
 388         jTempChars = (jchar*) malloc((ckLength) * sizeof(jchar));
 389         if (jTempChars == NULL) {
 390             free(ckpDate);
 391             throwOutOfMemoryError(env, 0);
 392             return NULL;
 393         }
 394         (*env)-&gt;GetCharArrayRegion(env, jDay, 0, ckLength, jTempChars);
 395         if ((*env)-&gt;ExceptionCheck(env)) {
 396             free(ckpDate);
 397             free(jTempChars);
 398             return NULL;
 399         }
 400 
 401         for (i = 0; (i &lt; ckLength) &amp;&amp; (i &lt; 2) ; i++) {
 402             ckpDate-&gt;day[i] = jCharToCKChar(jTempChars[i]);
 403         }
 404         free(jTempChars);
 405     }
 406 
 407     return ckpDate ;
 408 }
 409 
 410 
 411 /*
 412  * converts a Java CK_ATTRIBUTE object into a CK_ATTRIBUTE structure
 413  *
 414  * @param env - used to call JNI funktions to get the values out of the Java object
 415  * @param jAttribute - the Java CK_ATTRIBUTE object to convert
 416  * @return - the new CK_ATTRIBUTE structure
 417  */
 418 CK_ATTRIBUTE jAttributeToCKAttribute(JNIEnv *env, jobject jAttribute)
 419 {
 420     CK_ATTRIBUTE ckAttribute;
 421     jclass jAttributeClass;
 422     jfieldID jFieldID;
 423     jlong jType;
 424     jobject jPValue;
 425     memset(&amp;ckAttribute, 0, sizeof(CK_ATTRIBUTE));
 426 
 427     // TBD: what if jAttribute == NULL?!
 428 
 429     TRACE0(&quot;\nDEBUG: jAttributeToCKAttribute&quot;);
 430     /* get CK_ATTRIBUTE class */
 431     TRACE0(&quot;, getting attribute object class&quot;);
 432     jAttributeClass = (*env)-&gt;GetObjectClass(env, jAttribute);
 433     if (jAttributeClass == NULL) { return ckAttribute; }
 434 
 435     /* get type */
 436     TRACE0(&quot;, getting type field&quot;);
 437     jFieldID = (*env)-&gt;GetFieldID(env, jAttributeClass, &quot;type&quot;, &quot;J&quot;);
 438     if (jFieldID == NULL) { return ckAttribute; }
 439     jType = (*env)-&gt;GetLongField(env, jAttribute, jFieldID);
 440     TRACE1(&quot;, type=0x%X&quot;, jType);
 441 
 442     /* get pValue */
 443     TRACE0(&quot;, getting pValue field&quot;);
 444     jFieldID = (*env)-&gt;GetFieldID(env, jAttributeClass, &quot;pValue&quot;, &quot;Ljava/lang/Object;&quot;);
 445     if (jFieldID == NULL) { return ckAttribute; }
 446     jPValue = (*env)-&gt;GetObjectField(env, jAttribute, jFieldID);
 447     TRACE1(&quot;, pValue=%p&quot;, jPValue);
 448 
 449     ckAttribute.type = jLongToCKULong(jType);
 450     TRACE0(&quot;, converting pValue to primitive object&quot;);
 451 
 452     /* convert the Java pValue object to a CK-type pValue pointer */
 453     jObjectToPrimitiveCKObjectPtrPtr(env, jPValue, &amp;(ckAttribute.pValue), &amp;(ckAttribute.ulValueLen));
 454 
 455     TRACE0(&quot;\nFINISHED\n&quot;);
 456 
 457     return ckAttribute ;
 458 }
 459 
 460 void masterKeyDeriveParamToCKMasterKeyDeriveParam(JNIEnv *env, jobject jParam,
 461         jclass masterKeyDeriveParamClass,
 462         CK_VERSION_PTR* cKMasterKeyDeriveParamVersion,
 463         CK_SSL3_RANDOM_DATA* cKMasterKeyDeriveParamRandomInfo) {
 464     jfieldID fieldID;
 465     jclass jSsl3RandomDataClass;
 466     jobject jRandomInfo, jRIClientRandom, jRIServerRandom, jVersion;
 467 
 468     /* get RandomInfo */
 469     fieldID = (*env)-&gt;GetFieldID(env, masterKeyDeriveParamClass, &quot;RandomInfo&quot;,
 470             &quot;Lsun/security/pkcs11/wrapper/CK_SSL3_RANDOM_DATA;&quot;);
 471     if (fieldID == NULL) { return; }
 472     jRandomInfo = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 473 
 474     /* get pClientRandom and ulClientRandomLength out of RandomInfo */
 475     jSsl3RandomDataClass = (*env)-&gt;FindClass(env, CLASS_SSL3_RANDOM_DATA);
 476     if (jSsl3RandomDataClass == NULL) { return; }
 477     fieldID = (*env)-&gt;GetFieldID(env, jSsl3RandomDataClass, &quot;pClientRandom&quot;, &quot;[B&quot;);
 478     if (fieldID == NULL) { return; }
 479     jRIClientRandom = (*env)-&gt;GetObjectField(env, jRandomInfo, fieldID);
 480 
 481     /* get pServerRandom and ulServerRandomLength out of RandomInfo */
 482     fieldID = (*env)-&gt;GetFieldID(env, jSsl3RandomDataClass, &quot;pServerRandom&quot;, &quot;[B&quot;);
 483     if (fieldID == NULL) { return; }
 484     jRIServerRandom = (*env)-&gt;GetObjectField(env, jRandomInfo, fieldID);
 485 
 486     /* get pVersion */
 487     fieldID = (*env)-&gt;GetFieldID(env, masterKeyDeriveParamClass, &quot;pVersion&quot;,
 488             &quot;Lsun/security/pkcs11/wrapper/CK_VERSION;&quot;);
 489     if (fieldID == NULL) { return; }
 490     jVersion = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 491 
 492     /* populate java values */
 493     *cKMasterKeyDeriveParamVersion = jVersionToCKVersionPtr(env, jVersion);
 494     if ((*env)-&gt;ExceptionCheck(env)) { return; }
 495     jByteArrayToCKByteArray(env, jRIClientRandom,
 496             &amp;(cKMasterKeyDeriveParamRandomInfo-&gt;pClientRandom),
 497             &amp;(cKMasterKeyDeriveParamRandomInfo-&gt;ulClientRandomLen));
 498     if ((*env)-&gt;ExceptionCheck(env)) {
 499         free(*cKMasterKeyDeriveParamVersion);
 500         return;
 501     }
 502     jByteArrayToCKByteArray(env, jRIServerRandom,
 503             &amp;(cKMasterKeyDeriveParamRandomInfo-&gt;pServerRandom),
 504             &amp;(cKMasterKeyDeriveParamRandomInfo-&gt;ulServerRandomLen));
 505     if ((*env)-&gt;ExceptionCheck(env)) {
 506         free(*cKMasterKeyDeriveParamVersion);
 507         free(cKMasterKeyDeriveParamRandomInfo-&gt;pClientRandom);
 508         return;
 509     }
 510 }
 511 
 512 /*
 513  * converts the Java CK_SSL3_MASTER_KEY_DERIVE_PARAMS object to a
 514  * CK_SSL3_MASTER_KEY_DERIVE_PARAMS structure
 515  *
 516  * @param env - used to call JNI functions to get the Java classes and objects
 517  * @param jParam - the Java CK_SSL3_MASTER_KEY_DERIVE_PARAMS object to convert
 518  * @return - the new CK_SSL3_MASTER_KEY_DERIVE_PARAMS structure
 519  */
 520 CK_SSL3_MASTER_KEY_DERIVE_PARAMS
 521 jSsl3MasterKeyDeriveParamToCKSsl3MasterKeyDeriveParam(JNIEnv *env,
 522         jobject jParam)
 523 {
 524     CK_SSL3_MASTER_KEY_DERIVE_PARAMS ckParam;
 525     jclass jSsl3MasterKeyDeriveParamsClass;
 526     memset(&amp;ckParam, 0, sizeof(CK_SSL3_MASTER_KEY_DERIVE_PARAMS));
 527     jSsl3MasterKeyDeriveParamsClass =
 528             (*env)-&gt;FindClass(env, CLASS_SSL3_MASTER_KEY_DERIVE_PARAMS);
 529     if (jSsl3MasterKeyDeriveParamsClass == NULL) { return ckParam; }
 530     masterKeyDeriveParamToCKMasterKeyDeriveParam(env, jParam,
 531             jSsl3MasterKeyDeriveParamsClass,
 532             &amp;ckParam.pVersion, &amp;ckParam.RandomInfo);
 533     return ckParam;
 534 }
 535 
 536 /*
 537  * converts the Java CK_TLS12_MASTER_KEY_DERIVE_PARAMS object to a
 538  * CK_TLS12_MASTER_KEY_DERIVE_PARAMS structure
 539  *
 540  * @param env - used to call JNI functions to get the Java classes and objects
 541  * @param jParam - the Java CK_TLS12_MASTER_KEY_DERIVE_PARAMS object to convert
 542  * @return - the new CK_TLS12_MASTER_KEY_DERIVE_PARAMS structure
 543  */
 544 CK_TLS12_MASTER_KEY_DERIVE_PARAMS
 545 jTls12MasterKeyDeriveParamToCKTls12MasterKeyDeriveParam(JNIEnv *env,
 546         jobject jParam)
 547 {
 548     CK_TLS12_MASTER_KEY_DERIVE_PARAMS ckParam;
 549     jclass jTls12MasterKeyDeriveParamsClass;
 550     jfieldID fieldID;
 551     memset(&amp;ckParam, 0, sizeof(CK_TLS12_MASTER_KEY_DERIVE_PARAMS));
 552     jTls12MasterKeyDeriveParamsClass =
 553             (*env)-&gt;FindClass(env, CLASS_TLS12_MASTER_KEY_DERIVE_PARAMS);
 554     if (jTls12MasterKeyDeriveParamsClass == NULL) { return ckParam; }
 555     masterKeyDeriveParamToCKMasterKeyDeriveParam(env, jParam,
 556             jTls12MasterKeyDeriveParamsClass, &amp;ckParam.pVersion,
 557             &amp;ckParam.RandomInfo);
 558     fieldID = (*env)-&gt;GetFieldID(env,
 559             jTls12MasterKeyDeriveParamsClass, &quot;prfHashMechanism&quot;, &quot;J&quot;);
 560     if (fieldID != NULL) {
 561         jlong prfHashMechanism =
 562                 (*env)-&gt;GetLongField(env, jParam, fieldID);
 563         ckParam.prfHashMechanism = (CK_MECHANISM_TYPE)prfHashMechanism;
 564     }
 565     return ckParam;
 566 }
 567 
 568 /*
 569  * converts the Java CK_TLS_PRF_PARAMS object to a CK_TLS_PRF_PARAMS structure
 570  */
 571 CK_TLS_PRF_PARAMS jTlsPrfParamsToCKTlsPrfParam(JNIEnv *env, jobject jParam)
 572 {
 573     jclass jTlsPrfParamsClass;
 574     CK_TLS_PRF_PARAMS ckParam;
 575     jfieldID fieldID;
 576     jobject jSeed, jLabel, jOutput;
 577     memset(&amp;ckParam, 0, sizeof(CK_TLS_PRF_PARAMS));
 578 
 579     // TBD: what if jParam == NULL?!
 580 
 581     /* get pSeed */
 582     jTlsPrfParamsClass = (*env)-&gt;FindClass(env, CLASS_TLS_PRF_PARAMS);
 583     if (jTlsPrfParamsClass == NULL) { return ckParam; }
 584     fieldID = (*env)-&gt;GetFieldID(env, jTlsPrfParamsClass, &quot;pSeed&quot;, &quot;[B&quot;);
 585     if (fieldID == NULL) { return ckParam; }
 586     jSeed = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 587 
 588     /* get pLabel */
 589     fieldID = (*env)-&gt;GetFieldID(env, jTlsPrfParamsClass, &quot;pLabel&quot;, &quot;[B&quot;);
 590     if (fieldID == NULL) { return ckParam; }
 591     jLabel = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 592 
 593     /* get pOutput */
 594     fieldID = (*env)-&gt;GetFieldID(env, jTlsPrfParamsClass, &quot;pOutput&quot;, &quot;[B&quot;);
 595     if (fieldID == NULL) { return ckParam; }
 596     jOutput = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 597 
 598     /* populate java values */
 599     jByteArrayToCKByteArray(env, jSeed, &amp;(ckParam.pSeed), &amp;(ckParam.ulSeedLen));
 600     if ((*env)-&gt;ExceptionCheck(env)) { return ckParam; }
 601     jByteArrayToCKByteArray(env, jLabel, &amp;(ckParam.pLabel), &amp;(ckParam.ulLabelLen));
 602     if ((*env)-&gt;ExceptionCheck(env)) {
 603         free(ckParam.pSeed);
 604         return ckParam;
 605     }
 606     ckParam.pulOutputLen = malloc(sizeof(CK_ULONG));
 607     if (ckParam.pulOutputLen == NULL) {
 608         free(ckParam.pSeed);
 609         free(ckParam.pLabel);
 610         throwOutOfMemoryError(env, 0);
 611         return ckParam;
 612     }
 613     jByteArrayToCKByteArray(env, jOutput, &amp;(ckParam.pOutput), ckParam.pulOutputLen);
 614     if ((*env)-&gt;ExceptionCheck(env)) {
 615         free(ckParam.pSeed);
 616         free(ckParam.pLabel);
 617         free(ckParam.pulOutputLen);
 618         return ckParam;
 619     }
 620 
 621     return ckParam ;
 622 }
 623 
 624 /*
 625  * converts the Java CK_TLS_MAC_PARAMS object to a CK_TLS_MAC_PARAMS structure
 626  */
 627 CK_TLS_MAC_PARAMS jTlsMacParamsToCKTlsMacParam(JNIEnv *env, jobject jParam)
 628 {
 629     jclass jTlsMacParamsClass;
 630     CK_TLS_MAC_PARAMS ckParam;
 631     jfieldID fieldID;
 632     jlong jPrfMechanism, jUlMacLength, jUlServerOrClient;
 633     memset(&amp;ckParam, 0, sizeof(CK_TLS_MAC_PARAMS));
 634 
 635     jTlsMacParamsClass = (*env)-&gt;FindClass(env, CLASS_TLS_MAC_PARAMS);
 636     if (jTlsMacParamsClass == NULL) { return ckParam; }
 637 
 638     /* get prfMechanism */
 639     fieldID = (*env)-&gt;GetFieldID(env, jTlsMacParamsClass, &quot;prfMechanism&quot;, &quot;J&quot;);
 640     if (fieldID == NULL) { return ckParam; }
 641     jPrfMechanism = (*env)-&gt;GetLongField(env, jParam, fieldID);
 642 
 643     /* get ulMacLength */
 644     fieldID = (*env)-&gt;GetFieldID(env, jTlsMacParamsClass, &quot;ulMacLength&quot;, &quot;J&quot;);
 645     if (fieldID == NULL) { return ckParam; }
 646     jUlMacLength = (*env)-&gt;GetLongField(env, jParam, fieldID);
 647 
 648     /* get ulServerOrClient */
 649     fieldID = (*env)-&gt;GetFieldID(env, jTlsMacParamsClass, &quot;ulServerOrClient&quot;, &quot;J&quot;);
 650     if (fieldID == NULL) { return ckParam; }
 651     jUlServerOrClient = (*env)-&gt;GetLongField(env, jParam, fieldID);
 652 
 653     /* populate java values */
 654     ckParam.prfMechanism = jLongToCKULong(jPrfMechanism);
 655     ckParam.ulMacLength = jLongToCKULong(jUlMacLength);
 656     ckParam.ulServerOrClient = jLongToCKULong(jUlServerOrClient);
 657 
 658     return ckParam;
 659 }
 660 
 661 void keyMatParamToCKKeyMatParam(JNIEnv *env, jobject jParam,
 662         jclass jKeyMatParamClass,
 663         CK_ULONG* cKKeyMatParamUlMacSizeInBits,
 664         CK_ULONG* cKKeyMatParamUlKeySizeInBits,
 665         CK_ULONG* cKKeyMatParamUlIVSizeInBits,
 666         CK_BBOOL* cKKeyMatParamBIsExport,
 667         CK_SSL3_RANDOM_DATA* cKKeyMatParamRandomInfo,
 668         CK_SSL3_KEY_MAT_OUT_PTR* cKKeyMatParamPReturnedKeyMaterial)
 669 {
 670     jclass jSsl3RandomDataClass, jSsl3KeyMatOutClass;
 671     jfieldID fieldID;
 672     jlong jMacSizeInBits, jKeySizeInBits, jIVSizeInBits;
 673     jboolean jIsExport;
 674     jobject jRandomInfo, jRIClientRandom, jRIServerRandom;
 675     jobject jReturnedKeyMaterial, jRMIvClient, jRMIvServer;
 676     CK_ULONG ckTemp;
 677 
 678     /* get ulMacSizeInBits */
 679     fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamClass, &quot;ulMacSizeInBits&quot;, &quot;J&quot;);
 680     if (fieldID == NULL) { return; }
 681     jMacSizeInBits = (*env)-&gt;GetLongField(env, jParam, fieldID);
 682 
 683     /* get ulKeySizeInBits */
 684     fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamClass, &quot;ulKeySizeInBits&quot;, &quot;J&quot;);
 685     if (fieldID == NULL) { return; }
 686     jKeySizeInBits = (*env)-&gt;GetLongField(env, jParam, fieldID);
 687 
 688     /* get ulIVSizeInBits */
 689     fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamClass, &quot;ulIVSizeInBits&quot;, &quot;J&quot;);
 690     if (fieldID == NULL) { return; }
 691     jIVSizeInBits = (*env)-&gt;GetLongField(env, jParam, fieldID);
 692 
 693     /* get bIsExport */
 694     fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamClass, &quot;bIsExport&quot;, &quot;Z&quot;);
 695     if (fieldID == NULL) { return; }
 696     jIsExport = (*env)-&gt;GetBooleanField(env, jParam, fieldID);
 697 
 698     /* get RandomInfo */
 699     jSsl3RandomDataClass = (*env)-&gt;FindClass(env, CLASS_SSL3_RANDOM_DATA);
 700     if (jSsl3RandomDataClass == NULL) { return; }
 701     fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamClass, &quot;RandomInfo&quot;,
 702             &quot;Lsun/security/pkcs11/wrapper/CK_SSL3_RANDOM_DATA;&quot;);
 703     if (fieldID == NULL) { return; }
 704     jRandomInfo = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 705 
 706     /* get pClientRandom and ulClientRandomLength out of RandomInfo */
 707     fieldID = (*env)-&gt;GetFieldID(env, jSsl3RandomDataClass, &quot;pClientRandom&quot;, &quot;[B&quot;);
 708     if (fieldID == NULL) { return; }
 709     jRIClientRandom = (*env)-&gt;GetObjectField(env, jRandomInfo, fieldID);
 710 
 711     /* get pServerRandom and ulServerRandomLength out of RandomInfo */
 712     fieldID = (*env)-&gt;GetFieldID(env, jSsl3RandomDataClass, &quot;pServerRandom&quot;, &quot;[B&quot;);
 713     if (fieldID == NULL) { return; }
 714     jRIServerRandom = (*env)-&gt;GetObjectField(env, jRandomInfo, fieldID);
 715 
 716     /* get pReturnedKeyMaterial */
 717     jSsl3KeyMatOutClass = (*env)-&gt;FindClass(env, CLASS_SSL3_KEY_MAT_OUT);
 718     if (jSsl3KeyMatOutClass == NULL) { return; }
 719     fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamClass, &quot;pReturnedKeyMaterial&quot;,
 720             &quot;Lsun/security/pkcs11/wrapper/CK_SSL3_KEY_MAT_OUT;&quot;);
 721     if (fieldID == NULL) { return; }
 722     jReturnedKeyMaterial = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 723 
 724     /* get pIVClient out of pReturnedKeyMaterial */
 725     fieldID = (*env)-&gt;GetFieldID(env, jSsl3KeyMatOutClass, &quot;pIVClient&quot;, &quot;[B&quot;);
 726     if (fieldID == NULL) { return; }
 727     jRMIvClient = (*env)-&gt;GetObjectField(env, jReturnedKeyMaterial, fieldID);
 728 
 729     /* get pIVServer out of pReturnedKeyMaterial */
 730     fieldID = (*env)-&gt;GetFieldID(env, jSsl3KeyMatOutClass, &quot;pIVServer&quot;, &quot;[B&quot;);
 731     if (fieldID == NULL) { return; }
 732     jRMIvServer = (*env)-&gt;GetObjectField(env, jReturnedKeyMaterial, fieldID);
 733 
 734     /* populate java values */
 735     *cKKeyMatParamUlMacSizeInBits = jLongToCKULong(jMacSizeInBits);
 736     *cKKeyMatParamUlKeySizeInBits = jLongToCKULong(jKeySizeInBits);
 737     *cKKeyMatParamUlIVSizeInBits = jLongToCKULong(jIVSizeInBits);
 738     *cKKeyMatParamBIsExport = jBooleanToCKBBool(jIsExport);
 739     jByteArrayToCKByteArray(env, jRIClientRandom,
 740             &amp;(cKKeyMatParamRandomInfo-&gt;pClientRandom),
 741             &amp;(cKKeyMatParamRandomInfo-&gt;ulClientRandomLen));
 742     if ((*env)-&gt;ExceptionCheck(env)) { return; }
 743     jByteArrayToCKByteArray(env, jRIServerRandom,
 744             &amp;(cKKeyMatParamRandomInfo-&gt;pServerRandom),
 745             &amp;(cKKeyMatParamRandomInfo-&gt;ulServerRandomLen));
 746     if ((*env)-&gt;ExceptionCheck(env)) {
 747         free(cKKeyMatParamRandomInfo-&gt;pClientRandom);
 748         return;
 749     }
 750     /* allocate memory for pRetrunedKeyMaterial */
 751     *cKKeyMatParamPReturnedKeyMaterial =
 752             (CK_SSL3_KEY_MAT_OUT_PTR)malloc(sizeof(CK_SSL3_KEY_MAT_OUT));
 753     if (*cKKeyMatParamPReturnedKeyMaterial == NULL) {
 754         free(cKKeyMatParamRandomInfo-&gt;pClientRandom);
 755         free(cKKeyMatParamRandomInfo-&gt;pServerRandom);
 756         throwOutOfMemoryError(env, 0);
 757         return;
 758     }
 759 
 760     // the handles are output params only, no need to fetch them from Java
 761     (*cKKeyMatParamPReturnedKeyMaterial)-&gt;hClientMacSecret = 0;
 762     (*cKKeyMatParamPReturnedKeyMaterial)-&gt;hServerMacSecret = 0;
 763     (*cKKeyMatParamPReturnedKeyMaterial)-&gt;hClientKey = 0;
 764     (*cKKeyMatParamPReturnedKeyMaterial)-&gt;hServerKey = 0;
 765 
 766     jByteArrayToCKByteArray(env, jRMIvClient,
 767             &amp;((*cKKeyMatParamPReturnedKeyMaterial)-&gt;pIVClient), &amp;ckTemp);
 768     if ((*env)-&gt;ExceptionCheck(env)) {
 769         free(cKKeyMatParamRandomInfo-&gt;pClientRandom);
 770         free(cKKeyMatParamRandomInfo-&gt;pServerRandom);
 771         free((*cKKeyMatParamPReturnedKeyMaterial));
 772         return;
 773     }
 774     jByteArrayToCKByteArray(env, jRMIvServer,
 775             &amp;((*cKKeyMatParamPReturnedKeyMaterial)-&gt;pIVServer), &amp;ckTemp);
 776     if ((*env)-&gt;ExceptionCheck(env)) {
 777         free(cKKeyMatParamRandomInfo-&gt;pClientRandom);
 778         free(cKKeyMatParamRandomInfo-&gt;pServerRandom);
 779         free((*cKKeyMatParamPReturnedKeyMaterial)-&gt;pIVClient);
 780         free((*cKKeyMatParamPReturnedKeyMaterial));
 781         return;
 782     }
 783 
 784     return;
 785 }
 786 /*
 787  * converts the Java CK_SSL3_KEY_MAT_PARAMS object to a
 788  * CK_SSL3_KEY_MAT_PARAMS structure
 789  *
 790  * @param env - used to call JNI funktions to get the Java classes and objects
 791  * @param jParam - the Java CK_SSL3_KEY_MAT_PARAMS object to convert
 792  * @return - the new CK_SSL3_KEY_MAT_PARAMS structure
 793  */
 794 CK_SSL3_KEY_MAT_PARAMS
 795 jSsl3KeyMatParamToCKSsl3KeyMatParam(JNIEnv *env, jobject jParam)
 796 {
 797     CK_SSL3_KEY_MAT_PARAMS ckParam;
 798     jclass jSsl3KeyMatParamsClass;
 799     memset(&amp;ckParam, 0, sizeof(CK_SSL3_KEY_MAT_PARAMS));
 800     jSsl3KeyMatParamsClass = (*env)-&gt;FindClass(env,
 801             CLASS_SSL3_KEY_MAT_PARAMS);
 802     if (jSsl3KeyMatParamsClass == NULL) { return ckParam; }
 803     keyMatParamToCKKeyMatParam(env, jParam, jSsl3KeyMatParamsClass,
 804             &amp;ckParam.ulMacSizeInBits, &amp;ckParam.ulKeySizeInBits,
 805             &amp;ckParam.ulIVSizeInBits, &amp;ckParam.bIsExport,
 806             &amp;ckParam.RandomInfo, &amp;ckParam.pReturnedKeyMaterial);
 807     return ckParam;
 808 }
 809 
 810 /*
 811  * converts the Java CK_TLS12_KEY_MAT_PARAMS object to a
 812  * CK_TLS12_KEY_MAT_PARAMS structure
 813  *
 814  * @param env - used to call JNI functions to get the Java classes and objects
 815  * @param jParam - the Java CK_TLS12_KEY_MAT_PARAMS object to convert
 816  * @return - the new CK_TLS12_KEY_MAT_PARAMS structure
 817  */
 818 CK_TLS12_KEY_MAT_PARAMS jTls12KeyMatParamToCKTls12KeyMatParam(JNIEnv *env,
 819         jobject jParam)
 820 {
 821     CK_TLS12_KEY_MAT_PARAMS ckParam;
 822     jclass jTls12KeyMatParamsClass;
 823     jfieldID fieldID;
 824     memset(&amp;ckParam, 0, sizeof(CK_TLS12_KEY_MAT_PARAMS));
 825     jTls12KeyMatParamsClass = (*env)-&gt;FindClass(env,
 826             CLASS_TLS12_KEY_MAT_PARAMS);
 827     if (jTls12KeyMatParamsClass == NULL) { return ckParam; }
 828     keyMatParamToCKKeyMatParam(env, jParam, jTls12KeyMatParamsClass,
 829             &amp;ckParam.ulMacSizeInBits, &amp;ckParam.ulKeySizeInBits,
 830             &amp;ckParam.ulIVSizeInBits, &amp;ckParam.bIsExport,
 831             &amp;ckParam.RandomInfo, &amp;ckParam.pReturnedKeyMaterial);
 832     fieldID = (*env)-&gt;GetFieldID(env, jTls12KeyMatParamsClass,
 833             &quot;prfHashMechanism&quot;, &quot;J&quot;);
 834     if (fieldID != NULL) {
 835         jlong prfHashMechanism = (*env)-&gt;GetLongField(env, jParam, fieldID);
 836         ckParam.prfHashMechanism = (CK_MECHANISM_TYPE)prfHashMechanism;
 837     }
 838     return ckParam;
 839 }
 840 
 841 /*
 842  * converts the Java CK_AES_CTR_PARAMS object to a CK_AES_CTR_PARAMS structure
 843  *
 844  * @param env - used to call JNI funktions to get the Java classes and objects
 845  * @param jParam - the Java CK_AES_CTR_PARAMS object to convert
 846  * @param ckpParam - pointer to the new CK_AES_CTR_PARAMS structure
 847  */
 848 void jAesCtrParamsToCKAesCtrParam(JNIEnv *env, jobject jParam,
 849                                   CK_AES_CTR_PARAMS_PTR ckpParam) {
 850     jclass jAesCtrParamsClass;
 851     jfieldID fieldID;
 852     jlong jCounterBits;
 853     jobject jCb;
 854     CK_BYTE_PTR ckBytes;
 855     CK_ULONG ckTemp;
 856 
 857     /* get ulCounterBits */
 858     jAesCtrParamsClass = (*env)-&gt;FindClass(env, CLASS_AES_CTR_PARAMS);
 859     if (jAesCtrParamsClass == NULL) { return; }
 860     fieldID = (*env)-&gt;GetFieldID(env, jAesCtrParamsClass, &quot;ulCounterBits&quot;, &quot;J&quot;);
 861     if (fieldID == NULL) { return; }
 862     jCounterBits = (*env)-&gt;GetLongField(env, jParam, fieldID);
 863 
 864     /* get cb */
 865     fieldID = (*env)-&gt;GetFieldID(env, jAesCtrParamsClass, &quot;cb&quot;, &quot;[B&quot;);
 866     if (fieldID == NULL) { return; }
 867     jCb = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 868 
 869     /* populate java values */
 870     ckpParam-&gt;ulCounterBits = jLongToCKULong(jCounterBits);
 871     jByteArrayToCKByteArray(env, jCb, &amp;ckBytes, &amp;ckTemp);
 872     if ((*env)-&gt;ExceptionCheck(env)) { return; }
 873     if (ckTemp != 16) {
 874         TRACE1(&quot;ERROR: WRONG CTR IV LENGTH %d&quot;, ckTemp);
 875     } else {
 876         memcpy(ckpParam-&gt;cb, ckBytes, ckTemp);
 877         free(ckBytes);
 878     }
 879 }
 880 
 881 /*
 882  * converts a Java CK_MECHANISM object into a CK_MECHANISM structure
 883  *
 884  * @param env - used to call JNI funktions to get the values out of the Java object
 885  * @param jMechanism - the Java CK_MECHANISM object to convert
 886  * @return - the new CK_MECHANISM structure
 887  */
 888 void jMechanismToCKMechanism(JNIEnv *env, jobject jMechanism, CK_MECHANISM_PTR ckMechanismPtr)
 889 {
 890     jlong jMechanismType = (*env)-&gt;GetLongField(env, jMechanism, mech_mechanismID);
 891     jobject jParameter = (*env)-&gt;GetObjectField(env, jMechanism, mech_pParameterID);
 892 
 893     (*ckMechanismPtr).mechanism = jLongToCKULong(jMechanismType);
 894 
 895     /* convert the specific Java mechanism parameter object to a pointer to a CK-type mechanism
 896      * structure
 897      */
 898     if (jParameter == NULL) {
 899         (*ckMechanismPtr).pParameter = NULL;
 900         (*ckMechanismPtr).ulParameterLen = 0;
 901     } else {
 902         jMechanismParameterToCKMechanismParameter(env, jParameter, &amp;(*ckMechanismPtr).pParameter, &amp;(*ckMechanismPtr).ulParameterLen);
 903     }
 904 }
 905 
 906 /*
 907  * the following functions convert Attribute and Mechanism value pointers
 908  *
 909  * jobject ckAttributeValueToJObject(JNIEnv *env,
 910  *                                   const CK_ATTRIBUTE_PTR ckpAttribute);
 911  *
 912  * void jObjectToPrimitiveCKObjectPtrPtr(JNIEnv *env,
 913  *                                       jobject jObject,
 914  *                                       CK_VOID_PTR *ckpObjectPtr,
 915  *                                       CK_ULONG *pLength);
 916  *
 917  * void jMechanismParameterToCKMechanismParameter(JNIEnv *env,
 918  *                                                jobject jParam,
 919  *                                                CK_VOID_PTR *ckpParamPtr,
 920  *                                                CK_ULONG *ckpLength);
 921  *
 922  * These functions are used if a PKCS#11 mechanism or attribute structure gets
 923  * convertet to a Java attribute or mechanism object or vice versa.
 924  *
 925  * ckAttributeValueToJObject converts a PKCS#11 attribute value pointer to a Java
 926  * object depending on the type of the Attribute. A PKCS#11 attribute value can
 927  * be a CK_ULONG, CK_BYTE[], CK_CHAR[], big integer, CK_BBOOL, CK_UTF8CHAR[],
 928  * CK_DATE or CK_FLAGS that gets converted to a corresponding Java object.
 929  *
 930  * jObjectToPrimitiveCKObjectPtrPtr is used by jAttributeToCKAttributePtr for
 931  * converting the Java attribute value to a PKCS#11 attribute value pointer.
 932  * For now only primitive datatypes and arrays of primitive datatypes can get
 933  * converted. Otherwise this function throws a PKCS#11Exception with the
 934  * errorcode CKR_VENDOR_DEFINED.
 935  *
 936  * jMechanismParameterToCKMechanismParameter converts a Java mechanism parameter
 937  * to a PKCS#11 mechanism parameter. First this function determines what mechanism
 938  * parameter the Java object is, then it allocates the memory for the new PKCS#11
 939  * structure and calls the corresponding function to convert the Java object to
 940  * a PKCS#11 mechanism parameter structure.
 941  */
 942 
 943 /*
 944  * converts the pValue of a CK_ATTRIBUTE structure into a Java Object by checking the type
 945  * of the attribute.
 946  *
 947  * @param env - used to call JNI funktions to create the new Java object
 948  * @param ckpAttribute - the pointer to the CK_ATTRIBUTE structure that contains the type
 949  *                       and the pValue to convert
 950  * @return - the new Java object of the CK-type pValue
 951  */
 952 jobject ckAttributeValueToJObject(JNIEnv *env, const CK_ATTRIBUTE_PTR ckpAttribute)
 953 {
 954     jint jValueLength;
 955     jobject jValueObject = NULL;
 956 
 957     jValueLength = ckULongToJInt(ckpAttribute-&gt;ulValueLen);
 958 
 959     if ((jValueLength &lt;= 0) || (ckpAttribute-&gt;pValue == NULL)) {
 960         return NULL ;
 961     }
 962 
 963     switch(ckpAttribute-&gt;type) {
 964         case CKA_CLASS:
 965             /* value CK_OBJECT_CLASS, defacto a CK_ULONG */
 966         case CKA_KEY_TYPE:
 967             /* value CK_KEY_TYPE, defacto a CK_ULONG */
 968         case CKA_CERTIFICATE_TYPE:
 969             /* value CK_CERTIFICATE_TYPE, defacto a CK_ULONG */
 970         case CKA_HW_FEATURE_TYPE:
 971             /* value CK_HW_FEATURE_TYPE, defacto a CK_ULONG */
 972         case CKA_MODULUS_BITS:
 973         case CKA_VALUE_BITS:
 974         case CKA_VALUE_LEN:
 975         case CKA_KEY_GEN_MECHANISM:
 976         case CKA_PRIME_BITS:
 977         case CKA_SUB_PRIME_BITS:
 978             /* value CK_ULONG */
 979             jValueObject = ckULongPtrToJLongObject(env, (CK_ULONG*) ckpAttribute-&gt;pValue);
 980             break;
 981 
 982             /* can be CK_BYTE[],CK_CHAR[] or big integer; defacto always CK_BYTE[] */
 983         case CKA_VALUE:
 984         case CKA_OBJECT_ID:
 985         case CKA_SUBJECT:
 986         case CKA_ID:
 987         case CKA_ISSUER:
 988         case CKA_SERIAL_NUMBER:
 989         case CKA_OWNER:
 990         case CKA_AC_ISSUER:
 991         case CKA_ATTR_TYPES:
 992         case CKA_ECDSA_PARAMS:
 993             /* CKA_EC_PARAMS is the same, these two are equivalent */
 994         case CKA_EC_POINT:
 995         case CKA_PRIVATE_EXPONENT:
 996         case CKA_PRIME_1:
 997         case CKA_PRIME_2:
 998         case CKA_EXPONENT_1:
 999         case CKA_EXPONENT_2:
1000         case CKA_COEFFICIENT:
1001             /* value CK_BYTE[] */
1002             jValueObject = ckByteArrayToJByteArray(env, (CK_BYTE*) ckpAttribute-&gt;pValue, jValueLength);
1003             break;
1004 
1005         case CKA_RESET_ON_INIT:
1006         case CKA_HAS_RESET:
1007         case CKA_TOKEN:
1008         case CKA_PRIVATE:
1009         case CKA_MODIFIABLE:
1010         case CKA_DERIVE:
1011         case CKA_LOCAL:
1012         case CKA_ENCRYPT:
1013         case CKA_VERIFY:
1014         case CKA_VERIFY_RECOVER:
1015         case CKA_WRAP:
1016         case CKA_SENSITIVE:
1017         case CKA_SECONDARY_AUTH:
1018         case CKA_DECRYPT:
1019         case CKA_SIGN:
1020         case CKA_SIGN_RECOVER:
1021         case CKA_UNWRAP:
1022         case CKA_EXTRACTABLE:
1023         case CKA_ALWAYS_SENSITIVE:
1024         case CKA_NEVER_EXTRACTABLE:
1025         case CKA_TRUSTED:
1026             /* value CK_BBOOL */
1027             jValueObject = ckBBoolPtrToJBooleanObject(env, (CK_BBOOL*) ckpAttribute-&gt;pValue);
1028             break;
1029 
1030         case CKA_LABEL:
1031         case CKA_APPLICATION:
1032             /* value RFC 2279 (UTF-8) string */
1033             jValueObject = ckUTF8CharArrayToJCharArray(env, (CK_UTF8CHAR*) ckpAttribute-&gt;pValue, jValueLength);
1034             break;
1035 
1036         case CKA_START_DATE:
1037         case CKA_END_DATE:
1038             /* value CK_DATE */
1039             jValueObject = ckDatePtrToJDateObject(env, (CK_DATE*) ckpAttribute-&gt;pValue);
1040             break;
1041 
1042         case CKA_MODULUS:
1043         case CKA_PUBLIC_EXPONENT:
1044         case CKA_PRIME:
1045         case CKA_SUBPRIME:
1046         case CKA_BASE:
1047             /* value big integer, i.e. CK_BYTE[] */
1048             jValueObject = ckByteArrayToJByteArray(env, (CK_BYTE*) ckpAttribute-&gt;pValue, jValueLength);
1049             break;
1050 
1051         case CKA_AUTH_PIN_FLAGS:
1052             jValueObject = ckULongPtrToJLongObject(env, (CK_ULONG*) ckpAttribute-&gt;pValue);
1053             /* value FLAGS, defacto a CK_ULONG */
1054             break;
1055 
1056         case CKA_VENDOR_DEFINED:
1057             /* we make a CK_BYTE[] out of this */
1058             jValueObject = ckByteArrayToJByteArray(env, (CK_BYTE*) ckpAttribute-&gt;pValue, jValueLength);
1059             break;
1060 
1061         // Netscape trust attributes
1062         case CKA_NETSCAPE_TRUST_SERVER_AUTH:
1063         case CKA_NETSCAPE_TRUST_CLIENT_AUTH:
1064         case CKA_NETSCAPE_TRUST_CODE_SIGNING:
1065         case CKA_NETSCAPE_TRUST_EMAIL_PROTECTION:
1066             /* value CK_ULONG */
1067             jValueObject = ckULongPtrToJLongObject(env, (CK_ULONG*) ckpAttribute-&gt;pValue);
1068             break;
1069 
1070         default:
1071             /* we make a CK_BYTE[] out of this */
1072             jValueObject = ckByteArrayToJByteArray(env, (CK_BYTE*) ckpAttribute-&gt;pValue, jValueLength);
1073             break;
1074     }
1075 
1076     return jValueObject ;
1077 }
1078 
1079 /*
1080  * the following functions convert a Java mechanism parameter object to a PKCS#11
1081  * mechanism parameter structure
1082  *
1083  * CK_&lt;Param&gt;_PARAMS j&lt;Param&gt;ParamToCK&lt;Param&gt;Param(JNIEnv *env,
1084  *                                                 jobject jParam);
1085  *
1086  * These functions get a Java object, that must be the right Java mechanism
1087  * object and they return the new PKCS#11 mechanism parameter structure.
1088  * Every field of the Java object is retrieved, gets converted to a corresponding
1089  * PKCS#11 type and is set in the new PKCS#11 structure.
1090  */
1091 
1092 /*
1093  * converts the given Java mechanism parameter to a CK mechanism parameter structure
1094  * and store the length in bytes in the length variable.
1095  * The memory of *ckpParamPtr has to be freed after use!
1096  *
1097  * @param env - used to call JNI funktions to get the Java classes and objects
1098  * @param jParam - the Java mechanism parameter object to convert
1099  * @param ckpParamPtr - the reference of the new pointer to the new CK mechanism parameter
1100  *                      structure
1101  * @param ckpLength - the reference of the length in bytes of the new CK mechanism parameter
1102  *                    structure
1103  */
1104 void jMechanismParameterToCKMechanismParameter(JNIEnv *env, jobject jParam, CK_VOID_PTR *ckpParamPtr, CK_ULONG *ckpLength)
1105 {
1106     if (jParam == NULL) {
1107         *ckpParamPtr = NULL;
1108         *ckpLength = 0;
1109     } else if ((*env)-&gt;IsInstanceOf(env, jParam, jByteArrayClass)) {
1110         jByteArrayToCKByteArray(env, jParam, (CK_BYTE_PTR *)ckpParamPtr, ckpLength);
1111     } else if ((*env)-&gt;IsInstanceOf(env, jParam, jLongClass)) {
1112         *ckpParamPtr = jLongObjectToCKULongPtr(env, jParam);
1113         *ckpLength = sizeof(CK_ULONG);
1114     } else {
1115         TRACE0(&quot;\nSLOW PATH jMechanismParameterToCKMechanismParameter\n&quot;);
1116         jMechanismParameterToCKMechanismParameterSlow(env, jParam, ckpParamPtr, ckpLength);
1117     }
1118 }
1119 
1120 void jMechanismParameterToCKMechanismParameterSlow(JNIEnv *env, jobject jParam, CK_VOID_PTR *ckpParamPtr, CK_ULONG *ckpLength)
1121 {
1122     /* get all Java mechanism parameter classes */
1123     jclass jVersionClass, jSsl3MasterKeyDeriveParamsClass;
1124     jclass jTls12MasterKeyDeriveParamsClass, jSsl3KeyMatParamsClass;
1125     jclass jTls12KeyMatParamsClass;
1126     jclass jTlsPrfParamsClass, jTlsMacParamsClass, jAesCtrParamsClass;
1127     jclass jRsaPkcsOaepParamsClass;
1128     jclass jPbeParamsClass, jPkcs5Pbkd2ParamsClass, jRsaPkcsPssParamsClass;
1129     jclass jEcdh1DeriveParamsClass, jEcdh2DeriveParamsClass;
1130     jclass jX942Dh1DeriveParamsClass, jX942Dh2DeriveParamsClass;
1131     TRACE0(&quot;\nDEBUG: jMechanismParameterToCKMechanismParameter&quot;);
1132 
1133     /* most common cases, i.e. NULL/byte[]/long, are already handled by
1134      * jMechanismParameterToCKMechanismParameter before calling this method.
1135      */
1136     jVersionClass = (*env)-&gt;FindClass(env, CLASS_VERSION);
1137     if (jVersionClass == NULL) { return; }
1138     if ((*env)-&gt;IsInstanceOf(env, jParam, jVersionClass)) {
1139         /*
1140          * CK_VERSION used by CKM_SSL3_PRE_MASTER_KEY_GEN
1141          */
1142         CK_VERSION_PTR ckpParam;
1143 
1144         /* convert jParameter to CKParameter */
1145         ckpParam = jVersionToCKVersionPtr(env, jParam);
1146 
1147         /* get length and pointer of parameter */
1148         *ckpLength = sizeof(CK_VERSION);
1149         *ckpParamPtr = ckpParam;
1150         return;
1151     }
1152 
1153     jSsl3MasterKeyDeriveParamsClass = (*env)-&gt;FindClass(env, CLASS_SSL3_MASTER_KEY_DERIVE_PARAMS);
1154     if (jSsl3MasterKeyDeriveParamsClass == NULL) { return; }
1155     if ((*env)-&gt;IsInstanceOf(env, jParam, jSsl3MasterKeyDeriveParamsClass)) {
1156         /*
1157          * CK_SSL3_MASTER_KEY_DERIVE_PARAMS
1158          */
1159         CK_SSL3_MASTER_KEY_DERIVE_PARAMS_PTR ckpParam;
1160 
1161         ckpParam = (CK_SSL3_MASTER_KEY_DERIVE_PARAMS_PTR) malloc(sizeof(CK_SSL3_MASTER_KEY_DERIVE_PARAMS));
1162         if (ckpParam == NULL) {
1163             throwOutOfMemoryError(env, 0);
1164             return;
1165         }
1166 
1167         /* convert jParameter to CKParameter */
1168         *ckpParam = jSsl3MasterKeyDeriveParamToCKSsl3MasterKeyDeriveParam(env, jParam);
1169         if ((*env)-&gt;ExceptionCheck(env)) {
1170             free(ckpParam);
1171             return;
1172         }
1173 
1174         /* get length and pointer of parameter */
1175         *ckpLength = sizeof(CK_SSL3_MASTER_KEY_DERIVE_PARAMS);
1176         *ckpParamPtr = ckpParam;
1177         return;
1178     }
1179 
1180     jSsl3KeyMatParamsClass = (*env)-&gt;FindClass(env, CLASS_SSL3_KEY_MAT_PARAMS);
1181     if (jSsl3KeyMatParamsClass == NULL) { return; }
1182     if ((*env)-&gt;IsInstanceOf(env, jParam, jSsl3KeyMatParamsClass)) {
1183         /*
1184          * CK_SSL3_KEY_MAT_PARAMS
1185          */
1186         CK_SSL3_KEY_MAT_PARAMS_PTR ckpParam;
1187 
1188         ckpParam = (CK_SSL3_KEY_MAT_PARAMS_PTR) malloc(sizeof(CK_SSL3_KEY_MAT_PARAMS));
1189         if (ckpParam == NULL) {
1190             throwOutOfMemoryError(env, 0);
1191             return;
1192         }
1193 
1194         /* convert jParameter to CKParameter */
1195         *ckpParam = jSsl3KeyMatParamToCKSsl3KeyMatParam(env, jParam);
1196         if ((*env)-&gt;ExceptionCheck(env)) {
1197             free(ckpParam);
1198             return;
1199         }
1200 
1201         /* get length and pointer of parameter */
1202         *ckpLength = sizeof(CK_SSL3_KEY_MAT_PARAMS);
1203         *ckpParamPtr = ckpParam;
1204         return;
1205     }
1206 
1207     jTls12KeyMatParamsClass = (*env)-&gt;FindClass(env, CLASS_TLS12_KEY_MAT_PARAMS);
1208     if (jTls12KeyMatParamsClass == NULL) { return; }
1209     if ((*env)-&gt;IsInstanceOf(env, jParam, jTls12KeyMatParamsClass)) {
1210         /*
1211          * CK_TLS12_KEY_MAT_PARAMS
1212          */
1213         CK_TLS12_KEY_MAT_PARAMS_PTR ckpParam;
1214 
1215         ckpParam = (CK_TLS12_KEY_MAT_PARAMS_PTR) malloc(sizeof(CK_TLS12_KEY_MAT_PARAMS));
1216         if (ckpParam == NULL) {
1217             throwOutOfMemoryError(env, 0);
1218             return;
1219         }
1220 
1221         /* convert jParameter to CKParameter */
1222         *ckpParam = jTls12KeyMatParamToCKTls12KeyMatParam(env, jParam);
1223         if ((*env)-&gt;ExceptionCheck(env)) {
1224             free(ckpParam);
1225             return;
1226         }
1227 
1228         /* get length and pointer of parameter */
1229         *ckpLength = sizeof(CK_TLS12_KEY_MAT_PARAMS);
1230         *ckpParamPtr = ckpParam;
1231         return;
1232     }
1233 
1234     jTls12MasterKeyDeriveParamsClass =
1235             (*env)-&gt;FindClass(env, CLASS_TLS12_MASTER_KEY_DERIVE_PARAMS);
1236     if (jTls12MasterKeyDeriveParamsClass == NULL) { return; }
1237     if ((*env)-&gt;IsInstanceOf(env, jParam, jTls12MasterKeyDeriveParamsClass)) {
1238         /*
1239          * CK_TLS12_MASTER_KEY_DERIVE_PARAMS
1240          */
1241         CK_TLS12_MASTER_KEY_DERIVE_PARAMS_PTR ckpParam;
1242 
1243         ckpParam = (CK_TLS12_MASTER_KEY_DERIVE_PARAMS_PTR)malloc(
1244                 sizeof(CK_TLS12_MASTER_KEY_DERIVE_PARAMS));
1245         if (ckpParam == NULL) {
1246             throwOutOfMemoryError(env, 0);
1247             return;
1248         }
1249 
1250         /* convert jParameter to CKParameter */
1251         *ckpParam = jTls12MasterKeyDeriveParamToCKTls12MasterKeyDeriveParam(env, jParam);
1252         if ((*env)-&gt;ExceptionCheck(env)) {
1253             free(ckpParam);
1254             return;
1255         }
1256 
1257         /* get length and pointer of parameter */
1258         *ckpLength = sizeof(CK_TLS12_MASTER_KEY_DERIVE_PARAMS);
1259         *ckpParamPtr = ckpParam;
1260         return;
1261     }
1262 
1263     jTlsPrfParamsClass = (*env)-&gt;FindClass(env, CLASS_TLS_PRF_PARAMS);
1264     if (jTlsPrfParamsClass == NULL) { return; }
1265     if ((*env)-&gt;IsInstanceOf(env, jParam, jTlsPrfParamsClass)) {
1266         /*
1267          * CK_TLS_PRF_PARAMS
1268          */
1269         CK_TLS_PRF_PARAMS_PTR ckpParam;
1270 
1271         ckpParam = (CK_TLS_PRF_PARAMS_PTR) malloc(sizeof(CK_TLS_PRF_PARAMS));
1272         if (ckpParam == NULL) {
1273             throwOutOfMemoryError(env, 0);
1274             return;
1275         }
1276 
1277         /* convert jParameter to CKParameter */
1278         *ckpParam = jTlsPrfParamsToCKTlsPrfParam(env, jParam);
1279         if ((*env)-&gt;ExceptionCheck(env)) {
1280             free(ckpParam);
1281             return;
1282         }
1283 
1284         /* get length and pointer of parameter */
1285         *ckpLength = sizeof(CK_TLS_PRF_PARAMS);
1286         *ckpParamPtr = ckpParam;
1287         return;
1288     }
1289 
1290     jTlsMacParamsClass = (*env)-&gt;FindClass(env, CLASS_TLS_MAC_PARAMS);
1291     if (jTlsMacParamsClass == NULL) { return; }
1292     if ((*env)-&gt;IsInstanceOf(env, jParam, jTlsMacParamsClass)) {
1293         CK_TLS_MAC_PARAMS_PTR ckpParam;
1294 
1295         ckpParam = (CK_TLS_MAC_PARAMS_PTR) malloc(sizeof(CK_TLS_MAC_PARAMS));
1296         if (ckpParam == NULL) {
1297             throwOutOfMemoryError(env, 0);
1298             return;
1299         }
1300 
1301         /* convert jParameter to CKParameter */
1302         *ckpParam = jTlsMacParamsToCKTlsMacParam(env, jParam);
1303         if ((*env)-&gt;ExceptionCheck(env)) {
1304             free(ckpParam);
1305             return;
1306         }
1307 
1308         /* get length and pointer of parameter */
1309         *ckpLength = sizeof(CK_TLS_MAC_PARAMS);
1310         *ckpParamPtr = ckpParam;
1311         return;
1312     }
1313 
1314     jAesCtrParamsClass = (*env)-&gt;FindClass(env, CLASS_AES_CTR_PARAMS);
1315     if (jAesCtrParamsClass == NULL) { return; }
1316     if ((*env)-&gt;IsInstanceOf(env, jParam, jAesCtrParamsClass)) {
1317         /*
1318          * CK_AES_CTR_PARAMS
1319          */
1320         CK_AES_CTR_PARAMS_PTR ckpParam;
1321 
1322         ckpParam = (CK_AES_CTR_PARAMS_PTR) malloc(sizeof(CK_AES_CTR_PARAMS));
1323         if (ckpParam == NULL) {
1324             throwOutOfMemoryError(env, 0);
1325             return;
1326         }
1327 
1328         /* convert jParameter to CKParameter */
1329         jAesCtrParamsToCKAesCtrParam(env, jParam, ckpParam);
1330         if ((*env)-&gt;ExceptionCheck(env)) {
1331             free(ckpParam);
1332             return;
1333         }
1334 
1335         /* get length and pointer of parameter */
1336         *ckpLength = sizeof(CK_AES_CTR_PARAMS);
1337         *ckpParamPtr = ckpParam;
1338         return;
1339     }
1340 
1341     jRsaPkcsOaepParamsClass = (*env)-&gt;FindClass(env, CLASS_RSA_PKCS_OAEP_PARAMS);
1342     if (jRsaPkcsOaepParamsClass == NULL) { return; }
1343     if ((*env)-&gt;IsInstanceOf(env, jParam, jRsaPkcsOaepParamsClass)) {
1344         /*
1345          * CK_RSA_PKCS_OAEP_PARAMS
1346          */
1347         CK_RSA_PKCS_OAEP_PARAMS_PTR ckpParam;
1348 
1349         ckpParam = (CK_RSA_PKCS_OAEP_PARAMS_PTR) malloc(sizeof(CK_RSA_PKCS_OAEP_PARAMS));
1350         if (ckpParam == NULL) {
1351             throwOutOfMemoryError(env, 0);
1352             return;
1353         }
1354 
1355         /* convert jParameter to CKParameter */
1356         *ckpParam = jRsaPkcsOaepParamToCKRsaPkcsOaepParam(env, jParam);
1357         if ((*env)-&gt;ExceptionCheck(env)) {
1358             free(ckpParam);
1359             return;
1360         }
1361 
1362         /* get length and pointer of parameter */
1363         *ckpLength = sizeof(CK_RSA_PKCS_OAEP_PARAMS);
1364         *ckpParamPtr = ckpParam;
1365         return;
1366     }
1367 
1368     jPbeParamsClass = (*env)-&gt;FindClass(env, CLASS_PBE_PARAMS);
1369     if (jPbeParamsClass == NULL) { return; }
1370     if ((*env)-&gt;IsInstanceOf(env, jParam, jPbeParamsClass)) {
1371         /*
1372          * CK_PBE_PARAMS
1373          */
1374         CK_PBE_PARAMS_PTR ckpParam;
1375 
1376         ckpParam = (CK_PBE_PARAMS_PTR) malloc(sizeof(CK_PBE_PARAMS));
1377         if (ckpParam == NULL) {
1378             throwOutOfMemoryError(env, 0);
1379             return;
1380         }
1381 
1382         /* convert jParameter to CKParameter */
1383         *ckpParam = jPbeParamToCKPbeParam(env, jParam);
1384         if ((*env)-&gt;ExceptionCheck(env)) {
1385             free(ckpParam);
1386             return;
1387         }
1388 
1389         /* get length and pointer of parameter */
1390         *ckpLength = sizeof(CK_PBE_PARAMS);
1391         *ckpParamPtr = ckpParam;
1392         return;
1393     }
1394 
1395     jPkcs5Pbkd2ParamsClass = (*env)-&gt;FindClass(env, CLASS_PKCS5_PBKD2_PARAMS);
1396     if (jPkcs5Pbkd2ParamsClass == NULL) { return; }
1397     if ((*env)-&gt;IsInstanceOf(env, jParam, jPkcs5Pbkd2ParamsClass)) {
1398         /*
1399          * CK_PKCS5_PBKD2_PARAMS
1400          */
1401         CK_PKCS5_PBKD2_PARAMS_PTR ckpParam;
1402 
1403         ckpParam = (CK_PKCS5_PBKD2_PARAMS_PTR) malloc(sizeof(CK_PKCS5_PBKD2_PARAMS));
1404         if (ckpParam == NULL) {
1405             throwOutOfMemoryError(env, 0);
1406             return;
1407         }
1408 
1409         /* convert jParameter to CKParameter */
1410         *ckpParam = jPkcs5Pbkd2ParamToCKPkcs5Pbkd2Param(env, jParam);
1411         if ((*env)-&gt;ExceptionCheck(env)) {
1412             free(ckpParam);
1413             return;
1414         }
1415 
1416         /* get length and pointer of parameter */
1417         *ckpLength = sizeof(CK_PKCS5_PBKD2_PARAMS);
1418         *ckpParamPtr = ckpParam;
1419         return;
1420     }
1421 
1422     jRsaPkcsPssParamsClass = (*env)-&gt;FindClass(env, CLASS_RSA_PKCS_PSS_PARAMS);
1423     if (jRsaPkcsPssParamsClass == NULL) { return; }
1424     if ((*env)-&gt;IsInstanceOf(env, jParam, jRsaPkcsPssParamsClass)) {
1425         /*
1426          * CK_RSA_PKCS_PSS_PARAMS
1427          */
1428         CK_RSA_PKCS_PSS_PARAMS_PTR ckpParam;
1429 
1430         ckpParam = (CK_RSA_PKCS_PSS_PARAMS_PTR) malloc(sizeof(CK_RSA_PKCS_PSS_PARAMS));
1431         if (ckpParam == NULL) {
1432             throwOutOfMemoryError(env, 0);
1433             return;
1434         }
1435 
1436         /* convert jParameter to CKParameter */
1437         *ckpParam = jRsaPkcsPssParamToCKRsaPkcsPssParam(env, jParam);
1438         if ((*env)-&gt;ExceptionCheck(env)) {
1439             free(ckpParam);
1440             return;
1441         }
1442 
1443         /* get length and pointer of parameter */
1444         *ckpLength = sizeof(CK_RSA_PKCS_PSS_PARAMS);
1445         *ckpParamPtr = ckpParam;
1446         return;
1447     }
1448 
1449     jEcdh1DeriveParamsClass = (*env)-&gt;FindClass(env, CLASS_ECDH1_DERIVE_PARAMS);
1450     if (jEcdh1DeriveParamsClass == NULL) { return; }
1451     if ((*env)-&gt;IsInstanceOf(env, jParam, jEcdh1DeriveParamsClass)) {
1452         /*
1453          * CK_ECDH1_DERIVE_PARAMS
1454          */
1455         CK_ECDH1_DERIVE_PARAMS_PTR ckpParam;
1456 
1457         ckpParam = (CK_ECDH1_DERIVE_PARAMS_PTR) malloc(sizeof(CK_ECDH1_DERIVE_PARAMS));
1458         if (ckpParam == NULL) {
1459             throwOutOfMemoryError(env, 0);
1460             return;
1461         }
1462 
1463         /* convert jParameter to CKParameter */
1464         *ckpParam = jEcdh1DeriveParamToCKEcdh1DeriveParam(env, jParam);
1465         if ((*env)-&gt;ExceptionCheck(env)) {
1466             free(ckpParam);
1467             return;
1468         }
1469 
1470         /* get length and pointer of parameter */
1471         *ckpLength = sizeof(CK_ECDH1_DERIVE_PARAMS);
1472         *ckpParamPtr = ckpParam;
1473         return;
1474     }
1475 
1476     jEcdh2DeriveParamsClass = (*env)-&gt;FindClass(env, CLASS_ECDH2_DERIVE_PARAMS);
1477     if (jEcdh2DeriveParamsClass == NULL) { return; }
1478     if ((*env)-&gt;IsInstanceOf(env, jParam, jEcdh2DeriveParamsClass)) {
1479         /*
1480          * CK_ECDH2_DERIVE_PARAMS
1481          */
1482         CK_ECDH2_DERIVE_PARAMS_PTR ckpParam;
1483 
1484         ckpParam = (CK_ECDH2_DERIVE_PARAMS_PTR) malloc(sizeof(CK_ECDH2_DERIVE_PARAMS));
1485         if (ckpParam == NULL) {
1486             throwOutOfMemoryError(env, 0);
1487             return;
1488         }
1489 
1490         /* convert jParameter to CKParameter */
1491         *ckpParam = jEcdh2DeriveParamToCKEcdh2DeriveParam(env, jParam);
1492         if ((*env)-&gt;ExceptionCheck(env)) {
1493             free(ckpParam);
1494             return;
1495         }
1496 
1497         /* get length and pointer of parameter */
1498         *ckpLength = sizeof(CK_ECDH2_DERIVE_PARAMS);
1499         *ckpParamPtr = ckpParam;
1500         return;
1501     }
1502 
1503     jX942Dh1DeriveParamsClass = (*env)-&gt;FindClass(env, CLASS_X9_42_DH1_DERIVE_PARAMS);
1504     if (jX942Dh1DeriveParamsClass == NULL) { return; }
1505     if ((*env)-&gt;IsInstanceOf(env, jParam, jX942Dh1DeriveParamsClass)) {
1506         /*
1507          * CK_X9_42_DH1_DERIVE_PARAMS
1508          */
1509         CK_X9_42_DH1_DERIVE_PARAMS_PTR ckpParam;
1510 
1511         ckpParam = (CK_X9_42_DH1_DERIVE_PARAMS_PTR) malloc(sizeof(CK_X9_42_DH1_DERIVE_PARAMS));
1512         if (ckpParam == NULL) {
1513             throwOutOfMemoryError(env, 0);
1514             return;
1515         }
1516 
1517         /* convert jParameter to CKParameter */
1518         *ckpParam = jX942Dh1DeriveParamToCKX942Dh1DeriveParam(env, jParam);
1519         if ((*env)-&gt;ExceptionCheck(env)) {
1520             free(ckpParam);
1521             return;
1522         }
1523 
1524         /* get length and pointer of parameter */
1525         *ckpLength = sizeof(CK_X9_42_DH1_DERIVE_PARAMS);
1526         *ckpParamPtr = ckpParam;
1527         return;
1528     }
1529 
1530     jX942Dh2DeriveParamsClass = (*env)-&gt;FindClass(env, CLASS_X9_42_DH2_DERIVE_PARAMS);
1531     if (jX942Dh2DeriveParamsClass == NULL) { return; }
1532     if ((*env)-&gt;IsInstanceOf(env, jParam, jX942Dh2DeriveParamsClass)) {
1533         /*
1534          * CK_X9_42_DH2_DERIVE_PARAMS
1535          */
1536         CK_X9_42_DH2_DERIVE_PARAMS_PTR ckpParam;
1537 
1538         ckpParam = (CK_X9_42_DH2_DERIVE_PARAMS_PTR) malloc(sizeof(CK_X9_42_DH2_DERIVE_PARAMS));
1539         if (ckpParam == NULL) {
1540             throwOutOfMemoryError(env, 0);
1541             return;
1542         }
1543 
1544         /* convert jParameter to CKParameter */
1545         *ckpParam = jX942Dh2DeriveParamToCKX942Dh2DeriveParam(env, jParam);
1546         if ((*env)-&gt;ExceptionCheck(env)) {
1547             free(ckpParam);
1548             return;
1549         }
1550 
1551         /* get length and pointer of parameter */
1552         *ckpLength = sizeof(CK_X9_42_DH2_DERIVE_PARAMS);
1553         *ckpParamPtr = ckpParam;
1554         return;
1555     }
1556 
1557     /* if everything faild up to here */
1558     /* try if the parameter is a primitive Java type */
1559     jObjectToPrimitiveCKObjectPtrPtr(env, jParam, ckpParamPtr, ckpLength);
1560     /* *ckpParamPtr = jObjectToCKVoidPtr(jParam); */
1561     /* *ckpLength = 1; */
1562 
1563     TRACE0(&quot;FINISHED\n&quot;);
1564 }
1565 
1566 
1567 /* the mechanism parameter convertion functions: */
1568 
1569 /*
1570  * converts the Java CK_RSA_PKCS_OAEP_PARAMS object to a CK_RSA_PKCS_OAEP_PARAMS structure
1571  *
1572  * @param env - used to call JNI funktions to get the Java classes and objects
1573  * @param jParam - the Java CK_RSA_PKCS_OAEP_PARAMS object to convert
1574  * @return - the new CK_RSA_PKCS_OAEP_PARAMS structure
1575  */
1576 CK_RSA_PKCS_OAEP_PARAMS jRsaPkcsOaepParamToCKRsaPkcsOaepParam(JNIEnv *env, jobject jParam)
1577 {
1578     jclass jRsaPkcsOaepParamsClass;
1579     CK_RSA_PKCS_OAEP_PARAMS ckParam;
1580     jfieldID fieldID;
1581     jlong jHashAlg, jMgf, jSource;
1582     jobject jSourceData;
1583     CK_BYTE_PTR ckpByte;
1584     memset(&amp;ckParam, 0, sizeof(CK_RSA_PKCS_OAEP_PARAMS));
1585 
1586     /* get hashAlg */
1587     jRsaPkcsOaepParamsClass = (*env)-&gt;FindClass(env, CLASS_RSA_PKCS_OAEP_PARAMS);
1588     if (jRsaPkcsOaepParamsClass == NULL) { return ckParam; }
1589     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsOaepParamsClass, &quot;hashAlg&quot;, &quot;J&quot;);
1590     if (fieldID == NULL) { return ckParam; }
1591     jHashAlg = (*env)-&gt;GetLongField(env, jParam, fieldID);
1592 
1593     /* get mgf */
1594     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsOaepParamsClass, &quot;mgf&quot;, &quot;J&quot;);
1595     if (fieldID == NULL) { return ckParam; }
1596     jMgf = (*env)-&gt;GetLongField(env, jParam, fieldID);
1597 
1598     /* get source */
1599     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsOaepParamsClass, &quot;source&quot;, &quot;J&quot;);
1600     if (fieldID == NULL) { return ckParam; }
1601     jSource = (*env)-&gt;GetLongField(env, jParam, fieldID);
1602 
1603     /* get sourceData and sourceDataLength */
1604     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsOaepParamsClass, &quot;pSourceData&quot;, &quot;[B&quot;);
1605     if (fieldID == NULL) { return ckParam; }
1606     jSourceData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1607 
1608     /* populate java values */
1609     ckParam.hashAlg = jLongToCKULong(jHashAlg);
1610     ckParam.mgf = jLongToCKULong(jMgf);
1611     ckParam.source = jLongToCKULong(jSource);
1612     jByteArrayToCKByteArray(env, jSourceData, &amp; ckpByte, &amp;(ckParam.ulSourceDataLen));
1613     if ((*env)-&gt;ExceptionCheck(env)) { return ckParam; }
1614     ckParam.pSourceData = (CK_VOID_PTR) ckpByte;
1615 
1616     return ckParam ;
1617 }
1618 
1619 /*
1620  * converts the Java CK_PBE_PARAMS object to a CK_PBE_PARAMS structure
1621  *
1622  * @param env - used to call JNI funktions to get the Java classes and objects
1623  * @param jParam - the Java CK_PBE_PARAMS object to convert
1624  * @return - the new CK_PBE_PARAMS structure
1625  */
1626 CK_PBE_PARAMS jPbeParamToCKPbeParam(JNIEnv *env, jobject jParam)
1627 {
1628     jclass jPbeParamsClass;
1629     CK_PBE_PARAMS ckParam;
1630     jfieldID fieldID;
1631     jlong jIteration;
1632     jobject jInitVector, jPassword, jSalt;
1633     CK_ULONG ckTemp;
1634     memset(&amp;ckParam, 0, sizeof(CK_PBE_PARAMS));
1635 
1636     /* get pInitVector */
1637     jPbeParamsClass = (*env)-&gt;FindClass(env, CLASS_PBE_PARAMS);
1638     if (jPbeParamsClass == NULL) { return ckParam; }
1639     fieldID = (*env)-&gt;GetFieldID(env, jPbeParamsClass, &quot;pInitVector&quot;, &quot;[C&quot;);
1640     if (fieldID == NULL) { return ckParam; }
1641     jInitVector = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1642 
1643     /* get pPassword and ulPasswordLength */
1644     fieldID = (*env)-&gt;GetFieldID(env, jPbeParamsClass, &quot;pPassword&quot;, &quot;[C&quot;);
1645     if (fieldID == NULL) { return ckParam; }
1646     jPassword = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1647 
1648     /* get pSalt and ulSaltLength */
1649     fieldID = (*env)-&gt;GetFieldID(env, jPbeParamsClass, &quot;pSalt&quot;, &quot;[C&quot;);
1650     if (fieldID == NULL) { return ckParam; }
1651     jSalt = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1652 
1653     /* get ulIteration */
1654     fieldID = (*env)-&gt;GetFieldID(env, jPbeParamsClass, &quot;ulIteration&quot;, &quot;J&quot;);
1655     if (fieldID == NULL) { return ckParam; }
1656     jIteration = (*env)-&gt;GetLongField(env, jParam, fieldID);
1657 
1658     /* populate java values */
1659     ckParam.ulIteration = jLongToCKULong(jIteration);
1660     jCharArrayToCKCharArray(env, jInitVector, &amp;(ckParam.pInitVector), &amp;ckTemp);
1661     if ((*env)-&gt;ExceptionCheck(env)) { return ckParam; }
1662     jCharArrayToCKCharArray(env, jPassword, &amp;(ckParam.pPassword), &amp;(ckParam.ulPasswordLen));
1663     if ((*env)-&gt;ExceptionCheck(env)) {
1664         free(ckParam.pInitVector);
1665         return ckParam;
1666     }
1667     jCharArrayToCKCharArray(env, jSalt, &amp;(ckParam.pSalt), &amp;(ckParam.ulSaltLen));
1668     if ((*env)-&gt;ExceptionCheck(env)) {
1669         free(ckParam.pInitVector);
1670         free(ckParam.pPassword);
1671         return ckParam;
1672     }
1673 
1674     return ckParam ;
1675 }
1676 
1677 /*
1678  * Copy back the initialization vector from the native structure to the
1679  * Java object. This is only used for CKM_PBE_* mechanisms and their
1680  * CK_PBE_PARAMS parameters.
1681  *
1682  */
1683 void copyBackPBEInitializationVector(JNIEnv *env, CK_MECHANISM *ckMechanism, jobject jMechanism)
1684 {
1685     jclass jMechanismClass, jPbeParamsClass;
1686     CK_PBE_PARAMS *ckParam;
1687     jfieldID fieldID;
1688     CK_MECHANISM_TYPE ckMechanismType;
1689     jlong jMechanismType;
1690     jobject jParameter;
1691     jobject jInitVector;
1692     jint jInitVectorLength;
1693     CK_CHAR_PTR initVector;
1694     int i;
1695     jchar* jInitVectorChars;
1696 
1697     /* get mechanism */
1698     jMechanismClass = (*env)-&gt;FindClass(env, CLASS_MECHANISM);
1699     if (jMechanismClass == NULL) { return; }
1700     fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;mechanism&quot;, &quot;J&quot;);
1701     if (fieldID == NULL) { return; }
1702     jMechanismType = (*env)-&gt;GetLongField(env, jMechanism, fieldID);
1703     ckMechanismType = jLongToCKULong(jMechanismType);
1704     if (ckMechanismType != ckMechanism-&gt;mechanism) {
1705         /* we do not have maching types, this should not occur */
1706         return;
1707     }
1708 
1709     jPbeParamsClass = (*env)-&gt;FindClass(env, CLASS_PBE_PARAMS);
1710     if (jPbeParamsClass == NULL) { return; }
1711     ckParam = (CK_PBE_PARAMS *) ckMechanism-&gt;pParameter;
1712     if (ckParam != NULL_PTR) {
1713         initVector = ckParam-&gt;pInitVector;
1714         if (initVector != NULL_PTR) {
1715             /* get pParameter */
1716             fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;pParameter&quot;, &quot;Ljava/lang/Object;&quot;);
1717             if (fieldID == NULL) { return; }
1718             jParameter = (*env)-&gt;GetObjectField(env, jMechanism, fieldID);
1719             fieldID = (*env)-&gt;GetFieldID(env, jPbeParamsClass, &quot;pInitVektor&quot;, &quot;[C&quot;);
1720             if (fieldID == NULL) { return; }
1721             jInitVector = (*env)-&gt;GetObjectField(env, jParameter, fieldID);
1722 
1723             if (jInitVector != NULL) {
1724                 jInitVectorLength = (*env)-&gt;GetArrayLength(env, jInitVector);
1725                 jInitVectorChars = (*env)-&gt;GetCharArrayElements(env, jInitVector, NULL);
1726                 if (jInitVectorChars == NULL) { return; }
1727 
1728                 /* copy the chars to the Java buffer */
1729                 for (i=0; i &lt; jInitVectorLength; i++) {
1730                     jInitVectorChars[i] = ckCharToJChar(initVector[i]);
1731                 }
1732                 /* copy back the Java buffer to the object */
1733                 (*env)-&gt;ReleaseCharArrayElements(env, jInitVector, jInitVectorChars, 0);
1734             }
1735         }
1736     }
1737 }
1738 
1739 /*
1740  * converts the Java CK_PKCS5_PBKD2_PARAMS object to a CK_PKCS5_PBKD2_PARAMS structure
1741  *
1742  * @param env - used to call JNI funktions to get the Java classes and objects
1743  * @param jParam - the Java CK_PKCS5_PBKD2_PARAMS object to convert
1744  * @return - the new CK_PKCS5_PBKD2_PARAMS structure
1745  */
1746 CK_PKCS5_PBKD2_PARAMS jPkcs5Pbkd2ParamToCKPkcs5Pbkd2Param(JNIEnv *env, jobject jParam)
1747 {
1748     jclass jPkcs5Pbkd2ParamsClass;
1749     CK_PKCS5_PBKD2_PARAMS ckParam;
1750     jfieldID fieldID;
1751     jlong jSaltSource, jIteration, jPrf;
1752     jobject jSaltSourceData, jPrfData;
1753     memset(&amp;ckParam, 0, sizeof(CK_PKCS5_PBKD2_PARAMS));
1754 
1755     /* get saltSource */
1756     jPkcs5Pbkd2ParamsClass = (*env)-&gt;FindClass(env, CLASS_PKCS5_PBKD2_PARAMS);
1757     if (jPkcs5Pbkd2ParamsClass == NULL) { return ckParam; }
1758     fieldID = (*env)-&gt;GetFieldID(env, jPkcs5Pbkd2ParamsClass, &quot;saltSource&quot;, &quot;J&quot;);
1759     if (fieldID == NULL) { return ckParam; }
1760     jSaltSource = (*env)-&gt;GetLongField(env, jParam, fieldID);
1761 
1762     /* get pSaltSourceData */
1763     fieldID = (*env)-&gt;GetFieldID(env, jPkcs5Pbkd2ParamsClass, &quot;pSaltSourceData&quot;, &quot;[B&quot;);
1764     if (fieldID == NULL) { return ckParam; }
1765     jSaltSourceData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1766 
1767     /* get iterations */
1768     fieldID = (*env)-&gt;GetFieldID(env, jPkcs5Pbkd2ParamsClass, &quot;iterations&quot;, &quot;J&quot;);
1769     if (fieldID == NULL) { return ckParam; }
1770     jIteration = (*env)-&gt;GetLongField(env, jParam, fieldID);
1771 
1772     /* get prf */
1773     fieldID = (*env)-&gt;GetFieldID(env, jPkcs5Pbkd2ParamsClass, &quot;prf&quot;, &quot;J&quot;);
1774     if (fieldID == NULL) { return ckParam; }
1775     jPrf = (*env)-&gt;GetLongField(env, jParam, fieldID);
1776 
1777     /* get pPrfData and ulPrfDataLength in byte */
1778     fieldID = (*env)-&gt;GetFieldID(env, jPkcs5Pbkd2ParamsClass, &quot;pPrfData&quot;, &quot;[B&quot;);
1779     if (fieldID == NULL) { return ckParam; }
1780     jPrfData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1781 
1782     /* populate java values */
1783     ckParam.saltSource = jLongToCKULong(jSaltSource);
1784     jByteArrayToCKByteArray(env, jSaltSourceData, (CK_BYTE_PTR *) &amp;(ckParam.pSaltSourceData), &amp;(ckParam.ulSaltSourceDataLen));
1785     if ((*env)-&gt;ExceptionCheck(env)) { return ckParam; }
1786     ckParam.iterations = jLongToCKULong(jIteration);
1787     ckParam.prf = jLongToCKULong(jPrf);
1788     jByteArrayToCKByteArray(env, jPrfData, (CK_BYTE_PTR *) &amp;(ckParam.pPrfData), &amp;(ckParam.ulPrfDataLen));
1789     if ((*env)-&gt;ExceptionCheck(env)) {
1790         free(ckParam.pSaltSourceData);
1791         return ckParam;
1792     }
1793 
1794     return ckParam ;
1795 }
1796 
1797 /*
1798  * converts the Java CK_RSA_PKCS_PSS_PARAMS object to a CK_RSA_PKCS_PSS_PARAMS structure
1799  *
1800  * @param env - used to call JNI funktions to get the Java classes and objects
1801  * @param jParam - the Java CK_RSA_PKCS_PSS_PARAMS object to convert
1802  * @return - the new CK_RSA_PKCS_PSS_PARAMS structure
1803  */
1804 CK_RSA_PKCS_PSS_PARAMS jRsaPkcsPssParamToCKRsaPkcsPssParam(JNIEnv *env, jobject jParam)
1805 {
1806     jclass jRsaPkcsPssParamsClass;
1807     CK_RSA_PKCS_PSS_PARAMS ckParam;
1808     jfieldID fieldID;
1809     jlong jHashAlg, jMgf, jSLen;
1810     memset(&amp;ckParam, 0, sizeof(CK_RSA_PKCS_PSS_PARAMS));
1811 
1812     /* get hashAlg */
1813     jRsaPkcsPssParamsClass = (*env)-&gt;FindClass(env, CLASS_RSA_PKCS_PSS_PARAMS);
1814     if (jRsaPkcsPssParamsClass == NULL) { return ckParam; }
1815     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsPssParamsClass, &quot;hashAlg&quot;, &quot;J&quot;);
1816     if (fieldID == NULL) { return ckParam; }
1817     jHashAlg = (*env)-&gt;GetLongField(env, jParam, fieldID);
1818 
1819     /* get mgf */
1820     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsPssParamsClass, &quot;mgf&quot;, &quot;J&quot;);
1821     if (fieldID == NULL) { return ckParam; }
1822     jMgf = (*env)-&gt;GetLongField(env, jParam, fieldID);
1823 
1824     /* get sLen */
1825     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsPssParamsClass, &quot;sLen&quot;, &quot;J&quot;);
1826     if (fieldID == NULL) { return ckParam; }
1827     jSLen = (*env)-&gt;GetLongField(env, jParam, fieldID);
1828 
1829     /* populate java values */
1830     ckParam.hashAlg = jLongToCKULong(jHashAlg);
1831     ckParam.mgf = jLongToCKULong(jMgf);
1832     ckParam.sLen = jLongToCKULong(jSLen);
1833 
1834     return ckParam ;
1835 }
1836 
1837 /*
1838  * converts the Java CK_ECDH1_DERIVE_PARAMS object to a CK_ECDH1_DERIVE_PARAMS structure
1839  *
1840  * @param env - used to call JNI funktions to get the Java classes and objects
1841  * @param jParam - the Java CK_ECDH1_DERIVE_PARAMS object to convert
1842  * @return - the new CK_ECDH1_DERIVE_PARAMS structure
1843  */
1844 CK_ECDH1_DERIVE_PARAMS jEcdh1DeriveParamToCKEcdh1DeriveParam(JNIEnv *env, jobject jParam)
1845 {
1846     jclass jEcdh1DeriveParamsClass;
1847     CK_ECDH1_DERIVE_PARAMS ckParam;
1848     jfieldID fieldID;
1849     jlong jLong;
1850     jobject jSharedData, jPublicData;
1851     memset(&amp;ckParam, 0, sizeof(CK_ECDH1_DERIVE_PARAMS));
1852 
1853     /* get kdf */
1854     jEcdh1DeriveParamsClass = (*env)-&gt;FindClass(env, CLASS_ECDH1_DERIVE_PARAMS);
1855     if (jEcdh1DeriveParamsClass == NULL) { return ckParam; }
1856     fieldID = (*env)-&gt;GetFieldID(env, jEcdh1DeriveParamsClass, &quot;kdf&quot;, &quot;J&quot;);
1857     if (fieldID == NULL) { return ckParam; }
1858     jLong = (*env)-&gt;GetLongField(env, jParam, fieldID);
1859     ckParam.kdf = jLongToCKULong(jLong);
1860 
1861     /* get pSharedData and ulSharedDataLen */
1862     fieldID = (*env)-&gt;GetFieldID(env, jEcdh1DeriveParamsClass, &quot;pSharedData&quot;, &quot;[B&quot;);
1863     if (fieldID == NULL) { return ckParam; }
1864     jSharedData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1865 
1866     /* get pPublicData and ulPublicDataLen */
1867     fieldID = (*env)-&gt;GetFieldID(env, jEcdh1DeriveParamsClass, &quot;pPublicData&quot;, &quot;[B&quot;);
1868     if (fieldID == NULL) { return ckParam; }
1869     jPublicData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1870 
1871     /* populate java values */
1872     ckParam.kdf = jLongToCKULong(jLong);
1873     jByteArrayToCKByteArray(env, jSharedData, &amp;(ckParam.pSharedData), &amp;(ckParam.ulSharedDataLen));
1874     if ((*env)-&gt;ExceptionCheck(env)) { return ckParam; }
1875     jByteArrayToCKByteArray(env, jPublicData, &amp;(ckParam.pPublicData), &amp;(ckParam.ulPublicDataLen));
1876     if ((*env)-&gt;ExceptionCheck(env)) {
1877         free(ckParam.pSharedData);
1878         return ckParam;
1879     }
1880 
1881     return ckParam ;
1882 }
1883 
1884 /*
1885  * converts the Java CK_ECDH2_DERIVE_PARAMS object to a CK_ECDH2_DERIVE_PARAMS structure
1886  *
1887  * @param env - used to call JNI funktions to get the Java classes and objects
1888  * @param jParam - the Java CK_ECDH2_DERIVE_PARAMS object to convert
1889  * @return - the new CK_ECDH2_DERIVE_PARAMS structure
1890  */
1891 CK_ECDH2_DERIVE_PARAMS jEcdh2DeriveParamToCKEcdh2DeriveParam(JNIEnv *env, jobject jParam)
1892 {
1893     jclass jEcdh2DeriveParamsClass;
1894     CK_ECDH2_DERIVE_PARAMS ckParam;
1895     jfieldID fieldID;
1896     jlong jKdf, jPrivateDataLen, jPrivateData;
1897     jobject jSharedData, jPublicData, jPublicData2;
1898     memset(&amp;ckParam, 0, sizeof(CK_ECDH2_DERIVE_PARAMS));
1899 
1900     /* get kdf */
1901     jEcdh2DeriveParamsClass = (*env)-&gt;FindClass(env, CLASS_ECDH2_DERIVE_PARAMS);
1902     if (jEcdh2DeriveParamsClass == NULL) { return ckParam; }
1903     fieldID = (*env)-&gt;GetFieldID(env, jEcdh2DeriveParamsClass, &quot;kdf&quot;, &quot;J&quot;);
1904     if (fieldID == NULL) { return ckParam; }
1905     jKdf = (*env)-&gt;GetLongField(env, jParam, fieldID);
1906 
1907     /* get pSharedData and ulSharedDataLen */
1908     fieldID = (*env)-&gt;GetFieldID(env, jEcdh2DeriveParamsClass, &quot;pSharedData&quot;, &quot;[B&quot;);
1909     if (fieldID == NULL) { return ckParam; }
1910     jSharedData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1911 
1912     /* get pPublicData and ulPublicDataLen */
1913     fieldID = (*env)-&gt;GetFieldID(env, jEcdh2DeriveParamsClass, &quot;pPublicData&quot;, &quot;[B&quot;);
1914     if (fieldID == NULL) { return ckParam; }
1915     jPublicData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1916 
1917     /* get ulPrivateDataLen */
1918     fieldID = (*env)-&gt;GetFieldID(env, jEcdh2DeriveParamsClass, &quot;ulPrivateDataLen&quot;, &quot;J&quot;);
1919     if (fieldID == NULL) { return ckParam; }
1920     jPrivateDataLen = (*env)-&gt;GetLongField(env, jParam, fieldID);
1921 
1922     /* get hPrivateData */
1923     fieldID = (*env)-&gt;GetFieldID(env, jEcdh2DeriveParamsClass, &quot;hPrivateData&quot;, &quot;J&quot;);
1924     if (fieldID == NULL) { return ckParam; }
1925     jPrivateData = (*env)-&gt;GetLongField(env, jParam, fieldID);
1926 
1927     /* get pPublicData2 and ulPublicDataLen2 */
1928     fieldID = (*env)-&gt;GetFieldID(env, jEcdh2DeriveParamsClass, &quot;pPublicData2&quot;, &quot;[B&quot;);
1929     if (fieldID == NULL) { return ckParam; }
1930     jPublicData2 = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1931 
1932     /* populate java values */
1933     ckParam.kdf = jLongToCKULong(jKdf);
1934     jByteArrayToCKByteArray(env, jSharedData, &amp;(ckParam.pSharedData), &amp;(ckParam.ulSharedDataLen));
1935     if ((*env)-&gt;ExceptionCheck(env)) { return ckParam; }
1936     jByteArrayToCKByteArray(env, jPublicData, &amp;(ckParam.pPublicData), &amp;(ckParam.ulPublicDataLen));
1937     if ((*env)-&gt;ExceptionCheck(env)) {
1938         free(ckParam.pSharedData);
1939         return ckParam;
1940     }
1941     ckParam.ulPrivateDataLen = jLongToCKULong(jPrivateDataLen);
1942     ckParam.hPrivateData = jLongToCKULong(jPrivateData);
1943     jByteArrayToCKByteArray(env, jPublicData2, &amp;(ckParam.pPublicData2), &amp;(ckParam.ulPublicDataLen2));
1944     if ((*env)-&gt;ExceptionCheck(env)) {
1945         free(ckParam.pSharedData);
1946         free(ckParam.pPublicData);
1947         return ckParam;
1948     }
1949     return ckParam ;
1950 }
1951 
1952 /*
1953  * converts the Java CK_X9_42_DH1_DERIVE_PARAMS object to a CK_X9_42_DH1_DERIVE_PARAMS structure
1954  *
1955  * @param env - used to call JNI funktions to get the Java classes and objects
1956  * @param jParam - the Java CK_X9_42_DH1_DERIVE_PARAMS object to convert
1957  * @return - the new CK_X9_42_DH1_DERIVE_PARAMS structure
1958  */
1959 CK_X9_42_DH1_DERIVE_PARAMS jX942Dh1DeriveParamToCKX942Dh1DeriveParam(JNIEnv *env, jobject jParam)
1960 {
1961     jclass jX942Dh1DeriveParamsClass;
1962     CK_X9_42_DH1_DERIVE_PARAMS ckParam;
1963     jfieldID fieldID;
1964     jlong jKdf;
1965     jobject jOtherInfo, jPublicData;
1966     memset(&amp;ckParam, 0, sizeof(CK_X9_42_DH1_DERIVE_PARAMS));
1967 
1968     /* get kdf */
1969     jX942Dh1DeriveParamsClass = (*env)-&gt;FindClass(env, CLASS_X9_42_DH1_DERIVE_PARAMS);
1970     if (jX942Dh1DeriveParamsClass == NULL) { return ckParam; }
1971     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh1DeriveParamsClass, &quot;kdf&quot;, &quot;J&quot;);
1972     if (fieldID == NULL) { return ckParam; }
1973     jKdf = (*env)-&gt;GetLongField(env, jParam, fieldID);
1974 
1975     /* get pOtherInfo and ulOtherInfoLen */
1976     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh1DeriveParamsClass, &quot;pOtherInfo&quot;, &quot;[B&quot;);
1977     if (fieldID == NULL) { return ckParam; }
1978     jOtherInfo = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1979 
1980     /* get pPublicData and ulPublicDataLen */
1981     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh1DeriveParamsClass, &quot;pPublicData&quot;, &quot;[B&quot;);
1982     if (fieldID == NULL) { return ckParam; }
1983     jPublicData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1984 
1985     /* populate java values */
1986     ckParam.kdf = jLongToCKULong(jKdf);
1987     jByteArrayToCKByteArray(env, jOtherInfo, &amp;(ckParam.pOtherInfo), &amp;(ckParam.ulOtherInfoLen));
1988     if ((*env)-&gt;ExceptionCheck(env)) { return ckParam; }
1989     jByteArrayToCKByteArray(env, jPublicData, &amp;(ckParam.pPublicData), &amp;(ckParam.ulPublicDataLen));
1990     if ((*env)-&gt;ExceptionCheck(env)) {
1991         free(ckParam.pOtherInfo);
1992         return ckParam;
1993     }
1994 
1995     return ckParam ;
1996 }
1997 
1998 /*
1999  * converts the Java CK_X9_42_DH2_DERIVE_PARAMS object to a CK_X9_42_DH2_DERIVE_PARAMS structure
2000  *
2001  * @param env - used to call JNI funktions to get the Java classes and objects
2002  * @param jParam - the Java CK_X9_42_DH2_DERIVE_PARAMS object to convert
2003  * @return - the new CK_X9_42_DH2_DERIVE_PARAMS structure
2004  */
2005 CK_X9_42_DH2_DERIVE_PARAMS jX942Dh2DeriveParamToCKX942Dh2DeriveParam(JNIEnv *env, jobject jParam)
2006 {
2007     jclass jX942Dh2DeriveParamsClass;
2008     CK_X9_42_DH2_DERIVE_PARAMS ckParam;
2009     jfieldID fieldID;
2010     jlong jKdf, jPrivateDataLen, jPrivateData;
2011     jobject jOtherInfo, jPublicData, jPublicData2;
2012     memset(&amp;ckParam, 0, sizeof(CK_X9_42_DH2_DERIVE_PARAMS));
2013 
2014     /* get kdf */
2015     jX942Dh2DeriveParamsClass = (*env)-&gt;FindClass(env, CLASS_X9_42_DH2_DERIVE_PARAMS);
2016     if (jX942Dh2DeriveParamsClass == NULL) { return ckParam; }
2017     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh2DeriveParamsClass, &quot;kdf&quot;, &quot;J&quot;);
2018     if (fieldID == NULL) { return ckParam; }
2019     jKdf = (*env)-&gt;GetLongField(env, jParam, fieldID);
2020 
2021     /* get pOtherInfo and ulOtherInfoLen */
2022     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh2DeriveParamsClass, &quot;pOtherInfo&quot;, &quot;[B&quot;);
2023     if (fieldID == NULL) { return ckParam; }
2024     jOtherInfo = (*env)-&gt;GetObjectField(env, jParam, fieldID);
2025 
2026     /* get pPublicData and ulPublicDataLen */
2027     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh2DeriveParamsClass, &quot;pPublicData&quot;, &quot;[B&quot;);
2028     if (fieldID == NULL) { return ckParam; }
2029     jPublicData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
2030 
2031     /* get ulPrivateDataLen */
2032     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh2DeriveParamsClass, &quot;ulPrivateDataLen&quot;, &quot;J&quot;);
2033     if (fieldID == NULL) { return ckParam; }
2034     jPrivateDataLen = (*env)-&gt;GetLongField(env, jParam, fieldID);
2035 
2036     /* get hPrivateData */
2037     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh2DeriveParamsClass, &quot;hPrivateData&quot;, &quot;J&quot;);
2038     if (fieldID == NULL) { return ckParam; }
2039     jPrivateData = (*env)-&gt;GetLongField(env, jParam, fieldID);
2040 
2041     /* get pPublicData2 and ulPublicDataLen2 */
2042     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh2DeriveParamsClass, &quot;pPublicData2&quot;, &quot;[B&quot;);
2043     if (fieldID == NULL) { return ckParam; }
2044     jPublicData2 = (*env)-&gt;GetObjectField(env, jParam, fieldID);
2045 
2046     /* populate java values */
2047     ckParam.kdf = jLongToCKULong(jKdf);
2048     jByteArrayToCKByteArray(env, jOtherInfo, &amp;(ckParam.pOtherInfo), &amp;(ckParam.ulOtherInfoLen));
2049     if ((*env)-&gt;ExceptionCheck(env)) { return ckParam; }
2050     jByteArrayToCKByteArray(env, jPublicData, &amp;(ckParam.pPublicData), &amp;(ckParam.ulPublicDataLen));
2051     if ((*env)-&gt;ExceptionCheck(env)) {
2052         free(ckParam.pOtherInfo);
2053         return ckParam;
2054     }
2055     ckParam.ulPrivateDataLen = jLongToCKULong(jPrivateDataLen);
2056     ckParam.hPrivateData = jLongToCKULong(jPrivateData);
2057     jByteArrayToCKByteArray(env, jPublicData2, &amp;(ckParam.pPublicData2), &amp;(ckParam.ulPublicDataLen2));
2058     if ((*env)-&gt;ExceptionCheck(env)) {
2059         free(ckParam.pOtherInfo);
2060         free(ckParam.pPublicData);
2061         return ckParam;
2062     }
2063 
2064     return ckParam ;
2065 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_sign.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="p11_sessmgmt.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="p11_util.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_sign.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 
  5 /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
  6  *
  7  * Redistribution and use in  source and binary forms, with or without
  8  * modification, are permitted  provided that the following conditions are met:
  9  *
 10  * 1. Redistributions of  source code must retain the above copyright notice,
 11  *    this list of conditions and the following disclaimer.
 12  *
 13  * 2. Redistributions in  binary form must reproduce the above copyright notice,
 14  *    this list of conditions and the following disclaimer in the documentation
 15  *    and/or other materials provided with the distribution.
 16  *
 17  * 3. The end-user documentation included with the redistribution, if any, must
 18  *    include the following acknowledgment:
 19  *
 20  *    &quot;This product includes software developed by IAIK of Graz University of
 21  *     Technology.&quot;
 22  *
</pre>
<hr />
<pre>
 46  */
 47 
 48 #include &quot;pkcs11wrapper.h&quot;
 49 
 50 #include &lt;stdio.h&gt;
 51 #include &lt;stdlib.h&gt;
 52 #include &lt;string.h&gt;
 53 #include &lt;assert.h&gt;
 54 #include &quot;jlong.h&quot;
 55 
 56 #include &quot;sun_security_pkcs11_wrapper_PKCS11.h&quot;
 57 
 58 #ifdef P11_ENABLE_C_SIGNINIT
 59 /*
 60  * Class:     sun_security_pkcs11_wrapper_PKCS11
 61  * Method:    C_SignInit
 62  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
 63  * Parametermapping:                    *PKCS11*
 64  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 65  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<span class="line-modified"> 66  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
 67  */
 68 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignInit
 69     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
 70 {
 71     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified"> 72     CK_MECHANISM ckMechanism;</span>
 73     CK_OBJECT_HANDLE ckKeyHandle;
 74     CK_RV rv;
 75 
 76     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 77     if (ckpFunctions == NULL) { return; }
 78 


 79     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified"> 80     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>

 81     if ((*env)-&gt;ExceptionCheck(env)) { return; }

 82     ckKeyHandle = jLongToCKULong(jKeyHandle);
 83 
<span class="line-modified"> 84     rv = (*ckpFunctions-&gt;C_SignInit)(ckSessionHandle, &amp;ckMechanism, ckKeyHandle);</span>
 85 
<span class="line-modified"> 86     if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified"> 87         free(ckMechanism.pParameter);</span>




 88     }
<span class="line-modified"> 89 </span>
<span class="line-removed"> 90     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
 91 }
 92 #endif
 93 
 94 #ifdef P11_ENABLE_C_SIGN
 95 /*
 96  * Class:     sun_security_pkcs11_wrapper_PKCS11
 97  * Method:    C_Sign
<span class="line-modified"> 98  * Signature: (J[B)[B</span>
 99  * Parametermapping:                    *PKCS11*
100  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
101  * @param   jbyteArray jData            CK_BYTE_PTR pData
102  *                                      CK_ULONG ulDataLen
103  * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
104  *                                      CK_ULONG_PTR pulSignatureLen
105  */
106 JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1Sign
107     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jData)
108 {
109     CK_SESSION_HANDLE ckSessionHandle;
110     CK_BYTE_PTR ckpData = NULL_PTR;
<span class="line-removed">111     CK_BYTE_PTR ckpSignature;</span>
112     CK_ULONG ckDataLength;
<span class="line-modified">113     CK_ULONG ckSignatureLength = 0;</span>


114     jbyteArray jSignature = NULL;
115     CK_RV rv;
116 
117     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
118     if (ckpFunctions == NULL) { return NULL; }
119 


120     ckSessionHandle = jLongToCKULong(jSessionHandle);
121     jByteArrayToCKByteArray(env, jData, &amp;ckpData, &amp;ckDataLength);
<span class="line-modified">122     if ((*env)-&gt;ExceptionCheck(env)) { return NULL; }</span>
<span class="line-removed">123 </span>
<span class="line-removed">124     /* START standard code */</span>
<span class="line-removed">125 </span>
<span class="line-removed">126     /* first determine the length of the signature */</span>
<span class="line-removed">127     rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength, NULL_PTR, &amp;ckSignatureLength);</span>
<span class="line-removed">128     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {</span>
<span class="line-removed">129         free(ckpData);</span>
130         return NULL;
131     }
132 
<span class="line-modified">133     ckpSignature = (CK_BYTE_PTR) malloc(ckSignatureLength * sizeof(CK_BYTE));</span>
<span class="line-removed">134     if (ckpSignature == NULL) {</span>
<span class="line-removed">135         free(ckpData);</span>
<span class="line-removed">136         throwOutOfMemoryError(env, 0);</span>
<span class="line-removed">137         return NULL;</span>
<span class="line-removed">138     }</span>
139 
<span class="line-modified">140     /* now get the signature */</span>
<span class="line-modified">141     rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, &amp;ckSignatureLength);</span>
<span class="line-modified">142  /* END standard code */</span>
143 


144 
<span class="line-modified">145     /* START workaround code for operation abort bug in pkcs#11 of Datakey and iButton */</span>
<span class="line-removed">146 /*</span>
<span class="line-removed">147     ckpSignature = (CK_BYTE_PTR) malloc(256 * sizeof(CK_BYTE));</span>
<span class="line-removed">148     if (ckpSignature == NULL) {</span>
<span class="line-removed">149         free(ckpData);</span>
<span class="line-removed">150         throwOutOfMemoryError(env, 0);</span>
<span class="line-removed">151         return NULL;</span>
<span class="line-removed">152     }</span>
<span class="line-removed">153     rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, &amp;ckSignatureLength);</span>
154 
<span class="line-removed">155     if (rv == CKR_BUFFER_TOO_SMALL) {</span>
<span class="line-removed">156         free(ckpSignature);</span>
<span class="line-removed">157         ckpSignature = (CK_BYTE_PTR) malloc(ckSignatureLength * sizeof(CK_BYTE));</span>
<span class="line-removed">158         if (ckpSignature == NULL) {</span>
<span class="line-removed">159             free(ckpData);</span>
<span class="line-removed">160             throwOutOfMemoryError(env, 0);</span>
<span class="line-removed">161             return NULL;</span>
<span class="line-removed">162         }</span>
<span class="line-removed">163         rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, &amp;ckSignatureLength);</span>
<span class="line-removed">164     }</span>
<span class="line-removed">165  */</span>
<span class="line-removed">166     /* END workaround code */</span>
167     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
<span class="line-modified">168         jSignature = ckByteArrayToJByteArray(env, ckpSignature, ckSignatureLength);</span>

169     }

170     free(ckpData);
<span class="line-modified">171     free(ckpSignature);</span>
172 
<span class="line-modified">173     return jSignature ;</span>

174 }
175 #endif
176 
177 #ifdef P11_ENABLE_C_SIGNUPDATE
178 /*
179  * Class:     sun_security_pkcs11_wrapper_PKCS11
180  * Method:    C_SignUpdate
181  * Signature: (J[BII)V
182  * Parametermapping:                    *PKCS11*
183  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
184  * @param   jbyteArray jPart            CK_BYTE_PTR pPart
185  *                                      CK_ULONG ulPartLen
186  */
187 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignUpdate
188   (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong directIn, jbyteArray jIn, jint jInOfs, jint jInLen)
189 {
190     CK_SESSION_HANDLE ckSessionHandle;
191     CK_RV rv;
192     CK_BYTE_PTR bufP;
193     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
</pre>
<hr />
<pre>
203         ckAssertReturnValueOK(env, rv);
204         return;
205     }
206 
207     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
208         bufLen = MAX_STACK_BUFFER_LEN;
209         bufP = BUF;
210     } else {
211         bufLen = min(MAX_HEAP_BUFFER_LEN, jInLen);
212         bufP = (CK_BYTE_PTR) malloc((size_t)bufLen);
213         if (bufP == NULL) {
214             throwOutOfMemoryError(env, 0);
215             return;
216         }
217     }
218 
219     while (jInLen &gt; 0) {
220         jsize chunkLen = min(bufLen, jInLen);
221         (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, chunkLen, (jbyte *)bufP);
222         if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">223             if (bufP != BUF) { free(bufP); }</span>
<span class="line-removed">224             return;</span>
225         }
226         rv = (*ckpFunctions-&gt;C_SignUpdate)(ckSessionHandle, bufP, chunkLen);
227         if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
<span class="line-modified">228             if (bufP != BUF) {</span>
<span class="line-removed">229                 free(bufP);</span>
<span class="line-removed">230             }</span>
<span class="line-removed">231             return;</span>
232         }
233         jInOfs += chunkLen;
234         jInLen -= chunkLen;
235     }
236 

237     if (bufP != BUF) { free(bufP); }


238 }
239 #endif
240 
241 #ifdef P11_ENABLE_C_SIGNFINAL
242 /*
243  * Class:     sun_security_pkcs11_wrapper_PKCS11
244  * Method:    C_SignFinal
245  * Signature: (J)[B
246  * Parametermapping:                    *PKCS11*
247  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
248  * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
249  *                                      CK_ULONG_PTR pulSignatureLen
250  */
251 JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignFinal
252     (JNIEnv *env, jobject obj, jlong jSessionHandle, jint jExpectedLength)
253 {
254     CK_SESSION_HANDLE ckSessionHandle;
255     jbyteArray jSignature = NULL;
256     CK_RV rv;
257     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
</pre>
<hr />
<pre>
277         rv = (*ckpFunctions-&gt;C_SignFinal)(ckSessionHandle, bufP, &amp;ckSignatureLength);
278     }
279     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
280         jSignature = ckByteArrayToJByteArray(env, bufP, ckSignatureLength);
281     }
282 
283     if (bufP != BUF) { free(bufP); }
284 
285     return jSignature;
286 }
287 #endif
288 
289 #ifdef P11_ENABLE_C_SIGNRECOVERINIT
290 /*
291  * Class:     sun_security_pkcs11_wrapper_PKCS11
292  * Method:    C_SignRecoverInit
293  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
294  * Parametermapping:                    *PKCS11*
295  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
296  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<span class="line-modified">297  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
298  */
299 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignRecoverInit
300     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
301 {
302     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">303     CK_MECHANISM ckMechanism;</span>
304     CK_OBJECT_HANDLE ckKeyHandle;
305     CK_RV rv;
306 
307     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
308     if (ckpFunctions == NULL) { return; }
309 


310     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">311     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
312     if ((*env)-&gt;ExceptionCheck(env)) { return; }
313 
314     ckKeyHandle = jLongToCKULong(jKeyHandle);
315 
<span class="line-modified">316     rv = (*ckpFunctions-&gt;C_SignRecoverInit)(ckSessionHandle, &amp;ckMechanism, ckKeyHandle);</span>
317 
<span class="line-modified">318     if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified">319         free(ckMechanism.pParameter);</span>




320     }
<span class="line-modified">321 </span>
<span class="line-removed">322     if(ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
323 }
324 #endif
325 
326 #ifdef P11_ENABLE_C_SIGNRECOVER
327 /*
328  * Class:     sun_security_pkcs11_wrapper_PKCS11
329  * Method:    C_SignRecover
330  * Signature: (J[BII[BII)I
331  * Parametermapping:                    *PKCS11*
332  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
333  * @param   jbyteArray jData            CK_BYTE_PTR pData
334  *                                      CK_ULONG ulDataLen
335  * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
336  *                                      CK_ULONG_PTR pulSignatureLen
337  */
338 JNIEXPORT jint JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignRecover
339   (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jIn, jint jInOfs, jint jInLen, jbyteArray jOut, jint jOutOfs, jint jOutLen)
340 {
341     CK_SESSION_HANDLE ckSessionHandle;
342     CK_RV rv;
343     CK_BYTE INBUF[MAX_STACK_BUFFER_LEN];
344     CK_BYTE OUTBUF[MAX_STACK_BUFFER_LEN];
345     CK_BYTE_PTR inBufP;
346     CK_BYTE_PTR outBufP = OUTBUF;
<span class="line-modified">347     CK_ULONG ckSignatureLength = MAX_STACK_BUFFER_LEN;</span>
348 
349     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
350     if (ckpFunctions == NULL) { return 0; }
351 
352     ckSessionHandle = jLongToCKULong(jSessionHandle);
353 
354     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
355         inBufP = INBUF;

356     } else {
357         inBufP = (CK_BYTE_PTR) malloc((size_t)jInLen);
358         if (inBufP == NULL) {
359             throwOutOfMemoryError(env, 0);
360             return 0;
361         }

362     }
363 
364     (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, jInLen, (jbyte *)inBufP);
365     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">366         if (inBufP != INBUF) { free(inBufP); }</span>
<span class="line-removed">367         return 0;</span>
368     }

369     rv = (*ckpFunctions-&gt;C_SignRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckSignatureLength);
370     /* re-alloc larger buffer if it fits into our Java buffer */
371     if ((rv == CKR_BUFFER_TOO_SMALL) &amp;&amp; (ckSignatureLength &lt;= jIntToCKULong(jOutLen))) {
372         outBufP = (CK_BYTE_PTR) malloc(ckSignatureLength);
373         if (outBufP == NULL) {
<span class="line-removed">374             if (inBufP != INBUF) {</span>
<span class="line-removed">375                 free(inBufP);</span>
<span class="line-removed">376             }</span>
377             throwOutOfMemoryError(env, 0);
<span class="line-modified">378             return 0;</span>
379         }
380         rv = (*ckpFunctions-&gt;C_SignRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckSignatureLength);
381     }
382     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
383         (*env)-&gt;SetByteArrayRegion(env, jOut, jOutOfs, ckSignatureLength, (jbyte *)outBufP);
384     }
<span class="line-modified">385 </span>
386     if (inBufP != INBUF) { free(inBufP); }
387     if (outBufP != OUTBUF) { free(outBufP); }
388 
389     return ckSignatureLength;
390 }
391 #endif
392 
393 #ifdef P11_ENABLE_C_VERIFYINIT
394 /*
395  * Class:     sun_security_pkcs11_wrapper_PKCS11
396  * Method:    C_VerifyInit
397  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
398  * Parametermapping:                    *PKCS11*
399  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
400  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<span class="line-modified">401  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
402  */
403 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyInit
404     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
405 {
406     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">407     CK_MECHANISM ckMechanism;</span>
408     CK_OBJECT_HANDLE ckKeyHandle;
409     CK_RV rv;
410 
411     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
412     if (ckpFunctions == NULL) { return; }
413 


414     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">415     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
<span class="line-modified">416     if ((*env)-&gt;ExceptionCheck(env)) { return; }</span>


417 
418     ckKeyHandle = jLongToCKULong(jKeyHandle);
419 
<span class="line-modified">420     rv = (*ckpFunctions-&gt;C_VerifyInit)(ckSessionHandle, &amp;ckMechanism, ckKeyHandle);</span>
421 
<span class="line-modified">422     if(ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified">423         free(ckMechanism.pParameter);</span>




424     }
<span class="line-modified">425 </span>
<span class="line-removed">426     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
427 }
428 #endif
429 
430 #ifdef P11_ENABLE_C_VERIFY
431 /*
432  * Class:     sun_security_pkcs11_wrapper_PKCS11
433  * Method:    C_Verify
434  * Signature: (J[B[B)V
435  * Parametermapping:                    *PKCS11*
436  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
437  * @param   jbyteArray jData            CK_BYTE_PTR pData
438  *                                      CK_ULONG ulDataLen
439  * @param   jbyteArray jSignature       CK_BYTE_PTR pSignature
440  *                                      CK_ULONG_PTR pulSignatureLen
441  */
442 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1Verify
443     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jData, jbyteArray jSignature)
444 {
445     CK_SESSION_HANDLE ckSessionHandle;
446     CK_BYTE_PTR ckpData = NULL_PTR;
447     CK_BYTE_PTR ckpSignature = NULL_PTR;
448     CK_ULONG ckDataLength;
449     CK_ULONG ckSignatureLength;
<span class="line-modified">450     CK_RV rv;</span>
451 
452     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
453     if (ckpFunctions == NULL) { return; }
454 
455     ckSessionHandle = jLongToCKULong(jSessionHandle);

456     jByteArrayToCKByteArray(env, jData, &amp;ckpData, &amp;ckDataLength);
<span class="line-modified">457     if ((*env)-&gt;ExceptionCheck(env)) { return; }</span>


458 
459     jByteArrayToCKByteArray(env, jSignature, &amp;ckpSignature, &amp;ckSignatureLength);
460     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">461         free(ckpData);</span>
<span class="line-removed">462         return;</span>
463     }
464 
465     /* verify the signature */
466     rv = (*ckpFunctions-&gt;C_Verify)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, ckSignatureLength);
467 

468     free(ckpData);
469     free(ckpSignature);
470 
<span class="line-modified">471     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
472 }
473 #endif
474 
475 #ifdef P11_ENABLE_C_VERIFYUPDATE
476 /*
477  * Class:     sun_security_pkcs11_wrapper_PKCS11
478  * Method:    C_VerifyUpdate
479  * Signature: (J[BII)V
480  * Parametermapping:                    *PKCS11*
481  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
482  * @param   jbyteArray jPart            CK_BYTE_PTR pPart
483  *                                      CK_ULONG ulPartLen
484  */
485 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyUpdate
486   (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong directIn, jbyteArray jIn, jint jInOfs, jint jInLen)
487 {
488     CK_SESSION_HANDLE ckSessionHandle;
489     CK_RV rv;
490     CK_BYTE_PTR bufP;
491     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
</pre>
<hr />
<pre>
493 
494     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
495     if (ckpFunctions == NULL) { return; }
496 
497     ckSessionHandle = jLongToCKULong(jSessionHandle);
498 
499     if (directIn != 0) {
500         rv = (*ckpFunctions-&gt;C_VerifyUpdate)(ckSessionHandle, (CK_BYTE_PTR)jlong_to_ptr(directIn), jInLen);
501         ckAssertReturnValueOK(env, rv);
502         return;
503     }
504 
505     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
506         bufLen = MAX_STACK_BUFFER_LEN;
507         bufP = BUF;
508     } else {
509         bufLen = min(MAX_HEAP_BUFFER_LEN, jInLen);
510         bufP = (CK_BYTE_PTR) malloc((size_t)bufLen);
511         if (bufP == NULL) {
512             throwOutOfMemoryError(env, 0);
<span class="line-modified">513             return;</span>
514         }
515     }
516 
517     while (jInLen &gt; 0) {
518         jsize chunkLen = min(bufLen, jInLen);
519         (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, chunkLen, (jbyte *)bufP);
520         if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">521             if (bufP != BUF) { free(bufP); }</span>
<span class="line-removed">522             return;</span>
523         }
524 
525         rv = (*ckpFunctions-&gt;C_VerifyUpdate)(ckSessionHandle, bufP, chunkLen);
526         if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
<span class="line-modified">527             if (bufP != BUF) { free(bufP); }</span>
<span class="line-removed">528             return;</span>
529         }
530         jInOfs += chunkLen;
531         jInLen -= chunkLen;
532     }
533 

534     if (bufP != BUF) { free(bufP); }
535 }
536 #endif
537 
538 #ifdef P11_ENABLE_C_VERIFYFINAL
539 /*
540  * Class:     sun_security_pkcs11_wrapper_PKCS11
541  * Method:    C_VerifyFinal
542  * Signature: (J[B)V
543  * Parametermapping:                    *PKCS11*
544  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
545  * @param   jbyteArray jSignature       CK_BYTE_PTR pSignature
546  *                                      CK_ULONG ulSignatureLen
547  */
548 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyFinal
549     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jSignature)
550 {
551     CK_SESSION_HANDLE ckSessionHandle;
552     CK_BYTE_PTR ckpSignature = NULL_PTR;
553     CK_ULONG ckSignatureLength;
554     CK_RV rv;
555 
556     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
557     if (ckpFunctions == NULL) { return; }
558 
559     ckSessionHandle = jLongToCKULong(jSessionHandle);
560     jByteArrayToCKByteArray(env, jSignature, &amp;ckpSignature, &amp;ckSignatureLength);
<span class="line-modified">561     if ((*env)-&gt;ExceptionCheck(env)) { return; }</span>


562 
563     /* verify the signature */
564     rv = (*ckpFunctions-&gt;C_VerifyFinal)(ckSessionHandle, ckpSignature, ckSignatureLength);
565 
566     free(ckpSignature);
567 
<span class="line-modified">568     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
569 }
570 #endif
571 
572 #ifdef P11_ENABLE_C_VERIFYRECOVERINIT
573 /*
574  * Class:     sun_security_pkcs11_wrapper_PKCS11
575  * Method:    C_VerifyRecoverInit
576  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
577  * Parametermapping:                    *PKCS11*
578  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
579  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
580  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE hKey
581  */
582 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyRecoverInit
583     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
584 {
585     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">586     CK_MECHANISM ckMechanism;</span>
587     CK_OBJECT_HANDLE ckKeyHandle;
588     CK_RV rv;
589 
590     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
591     if (ckpFunctions == NULL) { return; }
592 


593     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">594     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
595     if ((*env)-&gt;ExceptionCheck(env)) { return; }
596 
597     ckKeyHandle = jLongToCKULong(jKeyHandle);
598 
<span class="line-modified">599     rv = (*ckpFunctions-&gt;C_VerifyRecoverInit)(ckSessionHandle, &amp;ckMechanism, ckKeyHandle);</span>
600 
<span class="line-modified">601     if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified">602         free(ckMechanism.pParameter);</span>




603     }
<span class="line-modified">604 </span>
<span class="line-removed">605     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }</span>
606 }
607 #endif
608 
609 #ifdef P11_ENABLE_C_VERIFYRECOVER
610 /*
611  * Class:     sun_security_pkcs11_wrapper_PKCS11
612  * Method:    C_VerifyRecover
613  * Signature: (J[BII[BII)I
614  * Parametermapping:                    *PKCS11*
615  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
616  * @param   jbyteArray jSignature       CK_BYTE_PTR pSignature
617  *                                      CK_ULONG ulSignatureLen
618  * @return  jbyteArray jData            CK_BYTE_PTR pData
619  *                                      CK_ULONG_PTR pulDataLen
620  */
621 JNIEXPORT jint JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyRecover
622   (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jIn, jint jInOfs, jint jInLen, jbyteArray jOut, jint jOutOfs, jint jOutLen)
623 {
624     CK_SESSION_HANDLE ckSessionHandle;
625     CK_RV rv;
626     CK_BYTE INBUF[MAX_STACK_BUFFER_LEN];
627     CK_BYTE OUTBUF[MAX_STACK_BUFFER_LEN];
628     CK_BYTE_PTR inBufP;
629     CK_BYTE_PTR outBufP = OUTBUF;
<span class="line-modified">630     CK_ULONG ckDataLength = MAX_STACK_BUFFER_LEN;</span>
631 
632     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
633     if (ckpFunctions == NULL) { return 0; }
634 
635     ckSessionHandle = jLongToCKULong(jSessionHandle);
636 
637     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
638         inBufP = INBUF;

639     } else {
640         inBufP = (CK_BYTE_PTR) malloc((size_t)jInLen);
641         if (inBufP == NULL) {
642             throwOutOfMemoryError(env, 0);
643             return 0;
644         }

645     }
646 
647     (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, jInLen, (jbyte *)inBufP);
648     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">649         if (inBufP != INBUF) { free(inBufP); }</span>
<span class="line-removed">650         return 0;</span>
651     }
652 
653     rv = (*ckpFunctions-&gt;C_VerifyRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckDataLength);
654 
655     /* re-alloc larger buffer if it fits into our Java buffer */
656     if ((rv == CKR_BUFFER_TOO_SMALL) &amp;&amp; (ckDataLength &lt;= jIntToCKULong(jOutLen))) {
657         outBufP = (CK_BYTE_PTR) malloc(ckDataLength);
658         if (outBufP == NULL) {
<span class="line-removed">659             if (inBufP != INBUF) { free(inBufP); }</span>
660             throwOutOfMemoryError(env, 0);
<span class="line-modified">661             return 0;</span>
662         }
663         rv = (*ckpFunctions-&gt;C_VerifyRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckDataLength);
664     }
665     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
666         (*env)-&gt;SetByteArrayRegion(env, jOut, jOutOfs, ckDataLength, (jbyte *)outBufP);
667     }
668 

669     if (inBufP != INBUF) { free(inBufP); }
670     if (outBufP != OUTBUF) { free(outBufP); }
671 
672     return ckDataLength;
673 }
674 #endif
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 
  5 /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
  6  *
  7  * Redistribution and use in  source and binary forms, with or without
  8  * modification, are permitted  provided that the following conditions are met:
  9  *
 10  * 1. Redistributions of  source code must retain the above copyright notice,
 11  *    this list of conditions and the following disclaimer.
 12  *
 13  * 2. Redistributions in  binary form must reproduce the above copyright notice,
 14  *    this list of conditions and the following disclaimer in the documentation
 15  *    and/or other materials provided with the distribution.
 16  *
 17  * 3. The end-user documentation included with the redistribution, if any, must
 18  *    include the following acknowledgment:
 19  *
 20  *    &quot;This product includes software developed by IAIK of Graz University of
 21  *     Technology.&quot;
 22  *
</pre>
<hr />
<pre>
 46  */
 47 
 48 #include &quot;pkcs11wrapper.h&quot;
 49 
 50 #include &lt;stdio.h&gt;
 51 #include &lt;stdlib.h&gt;
 52 #include &lt;string.h&gt;
 53 #include &lt;assert.h&gt;
 54 #include &quot;jlong.h&quot;
 55 
 56 #include &quot;sun_security_pkcs11_wrapper_PKCS11.h&quot;
 57 
 58 #ifdef P11_ENABLE_C_SIGNINIT
 59 /*
 60  * Class:     sun_security_pkcs11_wrapper_PKCS11
 61  * Method:    C_SignInit
 62  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
 63  * Parametermapping:                    *PKCS11*
 64  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 65  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<span class="line-modified"> 66  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
 67  */
 68 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignInit
 69     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
 70 {
 71     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified"> 72     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
 73     CK_OBJECT_HANDLE ckKeyHandle;
 74     CK_RV rv;
 75 
 76     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 77     if (ckpFunctions == NULL) { return; }
 78 
<span class="line-added"> 79     TRACE0(&quot;DEBUG: C_SignInit\n&quot;);</span>
<span class="line-added"> 80 </span>
 81     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified"> 82 </span>
<span class="line-added"> 83     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
 84     if ((*env)-&gt;ExceptionCheck(env)) { return; }
<span class="line-added"> 85 </span>
 86     ckKeyHandle = jLongToCKULong(jKeyHandle);
 87 
<span class="line-modified"> 88     rv = (*ckpFunctions-&gt;C_SignInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);</span>
 89 
<span class="line-modified"> 90     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK ||</span>
<span class="line-modified"> 91             (ckpMechanism-&gt;pParameter == NULL)) {</span>
<span class="line-added"> 92         freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-added"> 93     } else {</span>
<span class="line-added"> 94         (*env)-&gt;SetLongField(env, jMechanism, mech_pHandleID, ptr_to_jlong(ckpMechanism));</span>
<span class="line-added"> 95         TRACE1(&quot;DEBUG C_SignInit: stored pMech = 0x%lX\n&quot;, ptr_to_jlong(ckpMechanism));</span>
 96     }
<span class="line-modified"> 97     TRACE0(&quot;FINISHED\n&quot;);</span>

 98 }
 99 #endif
100 
101 #ifdef P11_ENABLE_C_SIGN
102 /*
103  * Class:     sun_security_pkcs11_wrapper_PKCS11
104  * Method:    C_Sign
<span class="line-modified">105  * Signature: (J[BI)[B</span>
106  * Parametermapping:                    *PKCS11*
107  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
108  * @param   jbyteArray jData            CK_BYTE_PTR pData
109  *                                      CK_ULONG ulDataLen
110  * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
111  *                                      CK_ULONG_PTR pulSignatureLen
112  */
113 JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1Sign
114     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jData)
115 {
116     CK_SESSION_HANDLE ckSessionHandle;
117     CK_BYTE_PTR ckpData = NULL_PTR;

118     CK_ULONG ckDataLength;
<span class="line-modified">119     CK_BYTE_PTR bufP;</span>
<span class="line-added">120     CK_ULONG ckSignatureLength;</span>
<span class="line-added">121     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];</span>
122     jbyteArray jSignature = NULL;
123     CK_RV rv;
124 
125     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
126     if (ckpFunctions == NULL) { return NULL; }
127 
<span class="line-added">128     TRACE0(&quot;DEBUG: C_Sign\n&quot;);</span>
<span class="line-added">129 </span>
130     ckSessionHandle = jLongToCKULong(jSessionHandle);
131     jByteArrayToCKByteArray(env, jData, &amp;ckpData, &amp;ckDataLength);
<span class="line-modified">132     if ((*env)-&gt;ExceptionCheck(env)) {</span>







133         return NULL;
134     }
135 
<span class="line-modified">136     TRACE1(&quot;DEBUG C_Sign: data length = %lu\n&quot;, ckDataLength);</span>





137 
<span class="line-modified">138     // unknown signature length</span>
<span class="line-modified">139     bufP = BUF;</span>
<span class="line-modified">140     ckSignatureLength = MAX_STACK_BUFFER_LEN;</span>
141 
<span class="line-added">142     rv = (*ckpFunctions-&gt;C_Sign)(ckSessionHandle, ckpData, ckDataLength,</span>
<span class="line-added">143         bufP, &amp;ckSignatureLength);</span>
144 
<span class="line-modified">145     TRACE1(&quot;DEBUG C_Sign: ret rv=0x%lX\n&quot;, rv);</span>








146 












147     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
<span class="line-modified">148         jSignature = ckByteArrayToJByteArray(env, bufP, ckSignatureLength);</span>
<span class="line-added">149         TRACE1(&quot;DEBUG C_Sign: signature length = %lu\n&quot;, ckSignatureLength);</span>
150     }
<span class="line-added">151 </span>
152     free(ckpData);
<span class="line-modified">153     if (bufP != BUF) { free(bufP); }</span>
154 
<span class="line-modified">155     TRACE0(&quot;FINISHED\n&quot;);</span>
<span class="line-added">156     return jSignature;</span>
157 }
158 #endif
159 
160 #ifdef P11_ENABLE_C_SIGNUPDATE
161 /*
162  * Class:     sun_security_pkcs11_wrapper_PKCS11
163  * Method:    C_SignUpdate
164  * Signature: (J[BII)V
165  * Parametermapping:                    *PKCS11*
166  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
167  * @param   jbyteArray jPart            CK_BYTE_PTR pPart
168  *                                      CK_ULONG ulPartLen
169  */
170 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignUpdate
171   (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong directIn, jbyteArray jIn, jint jInOfs, jint jInLen)
172 {
173     CK_SESSION_HANDLE ckSessionHandle;
174     CK_RV rv;
175     CK_BYTE_PTR bufP;
176     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
</pre>
<hr />
<pre>
186         ckAssertReturnValueOK(env, rv);
187         return;
188     }
189 
190     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
191         bufLen = MAX_STACK_BUFFER_LEN;
192         bufP = BUF;
193     } else {
194         bufLen = min(MAX_HEAP_BUFFER_LEN, jInLen);
195         bufP = (CK_BYTE_PTR) malloc((size_t)bufLen);
196         if (bufP == NULL) {
197             throwOutOfMemoryError(env, 0);
198             return;
199         }
200     }
201 
202     while (jInLen &gt; 0) {
203         jsize chunkLen = min(bufLen, jInLen);
204         (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, chunkLen, (jbyte *)bufP);
205         if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">206             goto cleanup;</span>

207         }
208         rv = (*ckpFunctions-&gt;C_SignUpdate)(ckSessionHandle, bufP, chunkLen);
209         if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
<span class="line-modified">210             goto cleanup;</span>



211         }
212         jInOfs += chunkLen;
213         jInLen -= chunkLen;
214     }
215 
<span class="line-added">216 cleanup:</span>
217     if (bufP != BUF) { free(bufP); }
<span class="line-added">218 </span>
<span class="line-added">219     return;</span>
220 }
221 #endif
222 
223 #ifdef P11_ENABLE_C_SIGNFINAL
224 /*
225  * Class:     sun_security_pkcs11_wrapper_PKCS11
226  * Method:    C_SignFinal
227  * Signature: (J)[B
228  * Parametermapping:                    *PKCS11*
229  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
230  * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
231  *                                      CK_ULONG_PTR pulSignatureLen
232  */
233 JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignFinal
234     (JNIEnv *env, jobject obj, jlong jSessionHandle, jint jExpectedLength)
235 {
236     CK_SESSION_HANDLE ckSessionHandle;
237     jbyteArray jSignature = NULL;
238     CK_RV rv;
239     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
</pre>
<hr />
<pre>
259         rv = (*ckpFunctions-&gt;C_SignFinal)(ckSessionHandle, bufP, &amp;ckSignatureLength);
260     }
261     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
262         jSignature = ckByteArrayToJByteArray(env, bufP, ckSignatureLength);
263     }
264 
265     if (bufP != BUF) { free(bufP); }
266 
267     return jSignature;
268 }
269 #endif
270 
271 #ifdef P11_ENABLE_C_SIGNRECOVERINIT
272 /*
273  * Class:     sun_security_pkcs11_wrapper_PKCS11
274  * Method:    C_SignRecoverInit
275  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
276  * Parametermapping:                    *PKCS11*
277  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
278  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<span class="line-modified">279  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
280  */
281 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignRecoverInit
282     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
283 {
284     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">285     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
286     CK_OBJECT_HANDLE ckKeyHandle;
287     CK_RV rv;
288 
289     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
290     if (ckpFunctions == NULL) { return; }
291 
<span class="line-added">292     TRACE0(&quot;DEBUG: C_SignRecoverInit\n&quot;);</span>
<span class="line-added">293 </span>
294     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">295     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
296     if ((*env)-&gt;ExceptionCheck(env)) { return; }
297 
298     ckKeyHandle = jLongToCKULong(jKeyHandle);
299 
<span class="line-modified">300     rv = (*ckpFunctions-&gt;C_SignRecoverInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);</span>
301 
<span class="line-modified">302     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK ||</span>
<span class="line-modified">303             (ckpMechanism-&gt;pParameter == NULL)) {</span>
<span class="line-added">304         freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-added">305     } else {</span>
<span class="line-added">306         (*env)-&gt;SetLongField(env, jMechanism, mech_pHandleID, ptr_to_jlong(ckpMechanism));</span>
<span class="line-added">307         TRACE1(&quot;DEBUG C_SignRecoverInit, stored pMech = 0x%lX\n&quot;, ptr_to_jlong(ckpMechanism));</span>
308     }
<span class="line-modified">309     TRACE0(&quot;FINISHED\n&quot;);</span>

310 }
311 #endif
312 
313 #ifdef P11_ENABLE_C_SIGNRECOVER
314 /*
315  * Class:     sun_security_pkcs11_wrapper_PKCS11
316  * Method:    C_SignRecover
317  * Signature: (J[BII[BII)I
318  * Parametermapping:                    *PKCS11*
319  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
320  * @param   jbyteArray jData            CK_BYTE_PTR pData
321  *                                      CK_ULONG ulDataLen
322  * @return  jbyteArray jSignature       CK_BYTE_PTR pSignature
323  *                                      CK_ULONG_PTR pulSignatureLen
324  */
325 JNIEXPORT jint JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1SignRecover
326   (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jIn, jint jInOfs, jint jInLen, jbyteArray jOut, jint jOutOfs, jint jOutLen)
327 {
328     CK_SESSION_HANDLE ckSessionHandle;
329     CK_RV rv;
330     CK_BYTE INBUF[MAX_STACK_BUFFER_LEN];
331     CK_BYTE OUTBUF[MAX_STACK_BUFFER_LEN];
332     CK_BYTE_PTR inBufP;
333     CK_BYTE_PTR outBufP = OUTBUF;
<span class="line-modified">334     CK_ULONG ckSignatureLength = 0;</span>
335 
336     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
337     if (ckpFunctions == NULL) { return 0; }
338 
339     ckSessionHandle = jLongToCKULong(jSessionHandle);
340 
341     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
342         inBufP = INBUF;
<span class="line-added">343         ckSignatureLength = MAX_STACK_BUFFER_LEN;</span>
344     } else {
345         inBufP = (CK_BYTE_PTR) malloc((size_t)jInLen);
346         if (inBufP == NULL) {
347             throwOutOfMemoryError(env, 0);
348             return 0;
349         }
<span class="line-added">350         ckSignatureLength = jInLen;</span>
351     }
352 
353     (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, jInLen, (jbyte *)inBufP);
354     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">355         goto cleanup;</span>

356     }
<span class="line-added">357 </span>
358     rv = (*ckpFunctions-&gt;C_SignRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckSignatureLength);
359     /* re-alloc larger buffer if it fits into our Java buffer */
360     if ((rv == CKR_BUFFER_TOO_SMALL) &amp;&amp; (ckSignatureLength &lt;= jIntToCKULong(jOutLen))) {
361         outBufP = (CK_BYTE_PTR) malloc(ckSignatureLength);
362         if (outBufP == NULL) {



363             throwOutOfMemoryError(env, 0);
<span class="line-modified">364             goto cleanup;</span>
365         }
366         rv = (*ckpFunctions-&gt;C_SignRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckSignatureLength);
367     }
368     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
369         (*env)-&gt;SetByteArrayRegion(env, jOut, jOutOfs, ckSignatureLength, (jbyte *)outBufP);
370     }
<span class="line-modified">371 cleanup:</span>
372     if (inBufP != INBUF) { free(inBufP); }
373     if (outBufP != OUTBUF) { free(outBufP); }
374 
375     return ckSignatureLength;
376 }
377 #endif
378 
379 #ifdef P11_ENABLE_C_VERIFYINIT
380 /*
381  * Class:     sun_security_pkcs11_wrapper_PKCS11
382  * Method:    C_VerifyInit
383  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
384  * Parametermapping:                    *PKCS11*
385  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
386  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
<span class="line-modified">387  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey</span>
388  */
389 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyInit
390     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
391 {
392     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">393     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
394     CK_OBJECT_HANDLE ckKeyHandle;
395     CK_RV rv;
396 
397     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
398     if (ckpFunctions == NULL) { return; }
399 
<span class="line-added">400     TRACE0(&quot;DEBUG: C_VerifyInit\n&quot;);</span>
<span class="line-added">401 </span>
402     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">403     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
<span class="line-modified">404     if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="line-added">405         return;</span>
<span class="line-added">406     }</span>
407 
408     ckKeyHandle = jLongToCKULong(jKeyHandle);
409 
<span class="line-modified">410     rv = (*ckpFunctions-&gt;C_VerifyInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);</span>
411 
<span class="line-modified">412     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK ||</span>
<span class="line-modified">413             (ckpMechanism-&gt;pParameter == NULL)) {</span>
<span class="line-added">414         freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-added">415     } else {</span>
<span class="line-added">416         (*env)-&gt;SetLongField(env, jMechanism, mech_pHandleID, ptr_to_jlong(ckpMechanism));</span>
<span class="line-added">417         TRACE1(&quot;DEBUG C_VerifyInit: stored pMech = 0x%lX\n&quot;, ptr_to_jlong(ckpMechanism));</span>
418     }
<span class="line-modified">419     TRACE0(&quot;FINISHED\n&quot;);</span>

420 }
421 #endif
422 
423 #ifdef P11_ENABLE_C_VERIFY
424 /*
425  * Class:     sun_security_pkcs11_wrapper_PKCS11
426  * Method:    C_Verify
427  * Signature: (J[B[B)V
428  * Parametermapping:                    *PKCS11*
429  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
430  * @param   jbyteArray jData            CK_BYTE_PTR pData
431  *                                      CK_ULONG ulDataLen
432  * @param   jbyteArray jSignature       CK_BYTE_PTR pSignature
433  *                                      CK_ULONG_PTR pulSignatureLen
434  */
435 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1Verify
436     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jData, jbyteArray jSignature)
437 {
438     CK_SESSION_HANDLE ckSessionHandle;
439     CK_BYTE_PTR ckpData = NULL_PTR;
440     CK_BYTE_PTR ckpSignature = NULL_PTR;
441     CK_ULONG ckDataLength;
442     CK_ULONG ckSignatureLength;
<span class="line-modified">443     CK_RV rv = 0;</span>
444 
445     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
446     if (ckpFunctions == NULL) { return; }
447 
448     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-added">449 </span>
450     jByteArrayToCKByteArray(env, jData, &amp;ckpData, &amp;ckDataLength);
<span class="line-modified">451     if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="line-added">452         return;</span>
<span class="line-added">453     }</span>
454 
455     jByteArrayToCKByteArray(env, jSignature, &amp;ckpSignature, &amp;ckSignatureLength);
456     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">457         goto cleanup;</span>

458     }
459 
460     /* verify the signature */
461     rv = (*ckpFunctions-&gt;C_Verify)(ckSessionHandle, ckpData, ckDataLength, ckpSignature, ckSignatureLength);
462 
<span class="line-added">463 cleanup:</span>
464     free(ckpData);
465     free(ckpSignature);
466 
<span class="line-modified">467     ckAssertReturnValueOK(env, rv);</span>
468 }
469 #endif
470 
471 #ifdef P11_ENABLE_C_VERIFYUPDATE
472 /*
473  * Class:     sun_security_pkcs11_wrapper_PKCS11
474  * Method:    C_VerifyUpdate
475  * Signature: (J[BII)V
476  * Parametermapping:                    *PKCS11*
477  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
478  * @param   jbyteArray jPart            CK_BYTE_PTR pPart
479  *                                      CK_ULONG ulPartLen
480  */
481 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyUpdate
482   (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong directIn, jbyteArray jIn, jint jInOfs, jint jInLen)
483 {
484     CK_SESSION_HANDLE ckSessionHandle;
485     CK_RV rv;
486     CK_BYTE_PTR bufP;
487     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
</pre>
<hr />
<pre>
489 
490     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
491     if (ckpFunctions == NULL) { return; }
492 
493     ckSessionHandle = jLongToCKULong(jSessionHandle);
494 
495     if (directIn != 0) {
496         rv = (*ckpFunctions-&gt;C_VerifyUpdate)(ckSessionHandle, (CK_BYTE_PTR)jlong_to_ptr(directIn), jInLen);
497         ckAssertReturnValueOK(env, rv);
498         return;
499     }
500 
501     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
502         bufLen = MAX_STACK_BUFFER_LEN;
503         bufP = BUF;
504     } else {
505         bufLen = min(MAX_HEAP_BUFFER_LEN, jInLen);
506         bufP = (CK_BYTE_PTR) malloc((size_t)bufLen);
507         if (bufP == NULL) {
508             throwOutOfMemoryError(env, 0);
<span class="line-modified">509             goto cleanup;</span>
510         }
511     }
512 
513     while (jInLen &gt; 0) {
514         jsize chunkLen = min(bufLen, jInLen);
515         (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, chunkLen, (jbyte *)bufP);
516         if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">517             goto cleanup;</span>

518         }
519 
520         rv = (*ckpFunctions-&gt;C_VerifyUpdate)(ckSessionHandle, bufP, chunkLen);
521         if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
<span class="line-modified">522             goto cleanup;</span>

523         }
524         jInOfs += chunkLen;
525         jInLen -= chunkLen;
526     }
527 
<span class="line-added">528 cleanup:</span>
529     if (bufP != BUF) { free(bufP); }
530 }
531 #endif
532 
533 #ifdef P11_ENABLE_C_VERIFYFINAL
534 /*
535  * Class:     sun_security_pkcs11_wrapper_PKCS11
536  * Method:    C_VerifyFinal
537  * Signature: (J[B)V
538  * Parametermapping:                    *PKCS11*
539  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
540  * @param   jbyteArray jSignature       CK_BYTE_PTR pSignature
541  *                                      CK_ULONG ulSignatureLen
542  */
543 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyFinal
544     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jSignature)
545 {
546     CK_SESSION_HANDLE ckSessionHandle;
547     CK_BYTE_PTR ckpSignature = NULL_PTR;
548     CK_ULONG ckSignatureLength;
549     CK_RV rv;
550 
551     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
552     if (ckpFunctions == NULL) { return; }
553 
554     ckSessionHandle = jLongToCKULong(jSessionHandle);
555     jByteArrayToCKByteArray(env, jSignature, &amp;ckpSignature, &amp;ckSignatureLength);
<span class="line-modified">556     if ((*env)-&gt;ExceptionCheck(env)) {</span>
<span class="line-added">557         return;</span>
<span class="line-added">558     }</span>
559 
560     /* verify the signature */
561     rv = (*ckpFunctions-&gt;C_VerifyFinal)(ckSessionHandle, ckpSignature, ckSignatureLength);
562 
563     free(ckpSignature);
564 
<span class="line-modified">565     ckAssertReturnValueOK(env, rv);</span>
566 }
567 #endif
568 
569 #ifdef P11_ENABLE_C_VERIFYRECOVERINIT
570 /*
571  * Class:     sun_security_pkcs11_wrapper_PKCS11
572  * Method:    C_VerifyRecoverInit
573  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J)V
574  * Parametermapping:                    *PKCS11*
575  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
576  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
577  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE hKey
578  */
579 JNIEXPORT void JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyRecoverInit
580     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jKeyHandle)
581 {
582     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified">583     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
584     CK_OBJECT_HANDLE ckKeyHandle;
585     CK_RV rv;
586 
587     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
588     if (ckpFunctions == NULL) { return; }
589 
<span class="line-added">590     TRACE0(&quot;DEBUG: C_VerifyRecoverInit\n&quot;);</span>
<span class="line-added">591 </span>
592     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified">593     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
594     if ((*env)-&gt;ExceptionCheck(env)) { return; }
595 
596     ckKeyHandle = jLongToCKULong(jKeyHandle);
597 
<span class="line-modified">598     rv = (*ckpFunctions-&gt;C_VerifyRecoverInit)(ckSessionHandle, ckpMechanism, ckKeyHandle);</span>
599 
<span class="line-modified">600     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK ||</span>
<span class="line-modified">601             (ckpMechanism-&gt;pParameter == NULL)) {</span>
<span class="line-added">602         freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-added">603     } else {</span>
<span class="line-added">604         (*env)-&gt;SetLongField(env, jMechanism, mech_pHandleID, ptr_to_jlong(ckpMechanism));</span>
<span class="line-added">605         TRACE1(&quot;DEBUG C_VerifyRecoverInit: stored pMech = 0x%lX\n&quot;, ptr_to_jlong(ckpMechanism));</span>
606     }
<span class="line-modified">607     TRACE0(&quot;FINISHED\n&quot;);</span>

608 }
609 #endif
610 
611 #ifdef P11_ENABLE_C_VERIFYRECOVER
612 /*
613  * Class:     sun_security_pkcs11_wrapper_PKCS11
614  * Method:    C_VerifyRecover
615  * Signature: (J[BII[BII)I
616  * Parametermapping:                    *PKCS11*
617  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
618  * @param   jbyteArray jSignature       CK_BYTE_PTR pSignature
619  *                                      CK_ULONG ulSignatureLen
620  * @return  jbyteArray jData            CK_BYTE_PTR pData
621  *                                      CK_ULONG_PTR pulDataLen
622  */
623 JNIEXPORT jint JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1VerifyRecover
624   (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jIn, jint jInOfs, jint jInLen, jbyteArray jOut, jint jOutOfs, jint jOutLen)
625 {
626     CK_SESSION_HANDLE ckSessionHandle;
627     CK_RV rv;
628     CK_BYTE INBUF[MAX_STACK_BUFFER_LEN];
629     CK_BYTE OUTBUF[MAX_STACK_BUFFER_LEN];
630     CK_BYTE_PTR inBufP;
631     CK_BYTE_PTR outBufP = OUTBUF;
<span class="line-modified">632     CK_ULONG ckDataLength = 0;</span>
633 
634     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
635     if (ckpFunctions == NULL) { return 0; }
636 
637     ckSessionHandle = jLongToCKULong(jSessionHandle);
638 
639     if (jInLen &lt;= MAX_STACK_BUFFER_LEN) {
640         inBufP = INBUF;
<span class="line-added">641         ckDataLength = MAX_STACK_BUFFER_LEN;</span>
642     } else {
643         inBufP = (CK_BYTE_PTR) malloc((size_t)jInLen);
644         if (inBufP == NULL) {
645             throwOutOfMemoryError(env, 0);
646             return 0;
647         }
<span class="line-added">648         ckDataLength = jInLen;</span>
649     }
650 
651     (*env)-&gt;GetByteArrayRegion(env, jIn, jInOfs, jInLen, (jbyte *)inBufP);
652     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified">653         goto cleanup;</span>

654     }
655 
656     rv = (*ckpFunctions-&gt;C_VerifyRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckDataLength);
657 
658     /* re-alloc larger buffer if it fits into our Java buffer */
659     if ((rv == CKR_BUFFER_TOO_SMALL) &amp;&amp; (ckDataLength &lt;= jIntToCKULong(jOutLen))) {
660         outBufP = (CK_BYTE_PTR) malloc(ckDataLength);
661         if (outBufP == NULL) {

662             throwOutOfMemoryError(env, 0);
<span class="line-modified">663             goto cleanup;</span>
664         }
665         rv = (*ckpFunctions-&gt;C_VerifyRecover)(ckSessionHandle, inBufP, jInLen, outBufP, &amp;ckDataLength);
666     }
667     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
668         (*env)-&gt;SetByteArrayRegion(env, jOut, jOutOfs, ckDataLength, (jbyte *)outBufP);
669     }
670 
<span class="line-added">671 cleanup:</span>
672     if (inBufP != INBUF) { free(inBufP); }
673     if (outBufP != OUTBUF) { free(outBufP); }
674 
675     return ckDataLength;
676 }
677 #endif
</pre>
</td>
</tr>
</table>
<center><a href="p11_sessmgmt.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="p11_util.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
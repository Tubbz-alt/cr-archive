<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_convert.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 
   5 /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
   6  *
   7  * Redistribution and use in  source and binary forms, with or without
   8  * modification, are permitted  provided that the following conditions are met:
   9  *
  10  * 1. Redistributions of  source code must retain the above copyright notice,
  11  *    this list of conditions and the following disclaimer.
  12  *
  13  * 2. Redistributions in  binary form must reproduce the above copyright notice,
  14  *    this list of conditions and the following disclaimer in the documentation
  15  *    and/or other materials provided with the distribution.
  16  *
  17  * 3. The end-user documentation included with the redistribution, if any, must
  18  *    include the following acknowledgment:
  19  *
  20  *    &quot;This product includes software developed by IAIK of Graz University of
  21  *     Technology.&quot;
  22  *
  23  *    Alternately, this acknowledgment may appear in the software itself, if
  24  *    and wherever such third-party acknowledgments normally appear.
  25  *
  26  * 4. The names &quot;Graz University of Technology&quot; and &quot;IAIK of Graz University of
  27  *    Technology&quot; must not be used to endorse or promote products derived from
  28  *    this software without prior written permission.
  29  *
  30  * 5. Products derived from this software may not be called
  31  *    &quot;IAIK PKCS Wrapper&quot;, nor may &quot;IAIK&quot; appear in their name, without prior
  32  *    written permission of Graz University of Technology.
  33  *
  34  *  THIS SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ANY EXPRESSED OR IMPLIED
  35  *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  36  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  37  *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE LICENSOR BE
  38  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
  39  *  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  40  *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  41  *  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  42  *  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  43  *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  44  *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  45  *  POSSIBILITY  OF SUCH DAMAGE.
  46  */
  47 
  48 /*
  49  * pkcs11wrapper.c
  50  * 18.05.2001
  51  *
  52  * This is the implementation of the native functions of the Java to PKCS#11 interface.
  53  * All function use some helper functions to convert the JNI types to PKCS#11 types.
  54  *
  55  * @author Karl Scheibelhofer &lt;Karl.Scheibelhofer@iaik.at&gt;
  56  * @author Martin Schlaeffer &lt;schlaeff@sbox.tugraz.at&gt;
  57  */
  58 
  59 
  60 #include &quot;pkcs11wrapper.h&quot;
  61 
  62 #include &lt;stdio.h&gt;
  63 #include &lt;stdlib.h&gt;
  64 #include &lt;string.h&gt;
  65 #include &lt;assert.h&gt;
  66 
  67 #include &quot;sun_security_pkcs11_wrapper_PKCS11.h&quot;
  68 
  69 /* declare file private functions */
  70 
  71 CK_VOID_PTR jMechParamToCKMechParamPtrSlow(JNIEnv *env, jobject jParam,
  72         CK_MECHANISM_TYPE ckMech, CK_ULONG *ckpLength);
  73 
  74 
  75 /*
  76  * converts a CK_DATE pointer into a Java CK_DATE Object.
  77  *
  78  * @param env - used to call JNI funktions to create the new Java object
  79  * @param ckpValue - the pointer to the CK_DATE structure
  80  * @return - the new Java CK_DATE object
  81  */
  82 jobject ckDatePtrToJDateObject(JNIEnv *env, const CK_DATE *ckpDate)
  83 {
  84     jclass jDateClass;
  85     jmethodID jCtrId;
  86     jobject jDateObject;
  87     jcharArray jYear;
  88     jcharArray jMonth;
  89     jcharArray jDay;
  90 
  91     /* load CK_DATE class */
  92     jDateClass = (*env)-&gt;FindClass(env, CLASS_DATE);
  93     if (jDateClass == NULL) { return NULL; }
  94 
  95     /* load CK_DATE constructor */
  96     jCtrId = (*env)-&gt;GetMethodID(env, jDateClass, &quot;&lt;init&gt;&quot;, &quot;([C[C[C)V&quot;);
  97     if (jCtrId == NULL) { return NULL; }
  98 
  99     /* prep all fields */
 100     jYear = ckCharArrayToJCharArray(env, (CK_CHAR_PTR)(ckpDate-&gt;year), 4);
 101     if (jYear == NULL) { return NULL; }
 102     jMonth = ckCharArrayToJCharArray(env, (CK_CHAR_PTR)(ckpDate-&gt;month), 2);
 103     if (jMonth == NULL) { return NULL; }
 104     jDay = ckCharArrayToJCharArray(env, (CK_CHAR_PTR)(ckpDate-&gt;day), 2);
 105     if (jDay == NULL) { return NULL; }
 106 
 107     /* create new CK_DATE object */
 108     jDateObject =
 109       (*env)-&gt;NewObject(env, jDateClass, jCtrId, jYear, jMonth, jDay);
 110     if (jDateObject == NULL) { return NULL; }
 111 
 112     /* free local references */
 113     (*env)-&gt;DeleteLocalRef(env, jDateClass);
 114     (*env)-&gt;DeleteLocalRef(env, jYear);
 115     (*env)-&gt;DeleteLocalRef(env, jMonth);
 116     (*env)-&gt;DeleteLocalRef(env, jDay);
 117 
 118     return jDateObject ;
 119 }
 120 
 121 /*
 122  * converts a CK_VERSION pointer into a Java CK_VERSION Object.
 123  *
 124  * @param env - used to call JNI funktions to create the new Java object
 125  * @param ckpVersion - the pointer to the CK_VERSION structure
 126  * @return the new Java CK_VERSION object
 127  */
 128 jobject ckVersionPtrToJVersion(JNIEnv *env, const CK_VERSION_PTR ckpVersion)
 129 {
 130     jclass jVersionClass;
 131     jmethodID jCtrId;
 132     jobject jVersionObject;
 133     jint jMajor;
 134     jint jMinor;
 135 
 136     /* load CK_VERSION class */
 137     jVersionClass = (*env)-&gt;FindClass(env, CLASS_VERSION);
 138     if (jVersionClass == NULL) { return NULL; }
 139 
 140     /* load CK_VERSION constructor */
 141     jCtrId = (*env)-&gt;GetMethodID(env, jVersionClass, &quot;&lt;init&gt;&quot;, &quot;(II)V&quot;);
 142     if (jCtrId == NULL) { return NULL; }
 143 
 144     /* prep both fields */
 145     jMajor = ckpVersion-&gt;major;
 146     jMinor = ckpVersion-&gt;minor;
 147 
 148     /* create new CK_VERSION object */
 149     jVersionObject =
 150       (*env)-&gt;NewObject(env, jVersionClass, jCtrId, jMajor, jMinor);
 151     if (jVersionObject == NULL) { return NULL; }
 152 
 153     /* free local references */
 154     (*env)-&gt;DeleteLocalRef(env, jVersionClass);
 155 
 156     return jVersionObject ;
 157 }
 158 
 159 /*
 160  * converts a CK_SESSION_INFO pointer into a Java CK_SESSION_INFO Object.
 161  *
 162  * @param env - used to call JNI funktions to create the new Java object
 163  * @param ckpSessionInfo - the pointer to the CK_SESSION_INFO structure
 164  * @return the new Java CK_SESSION_INFO object
 165  */
 166 jobject ckSessionInfoPtrToJSessionInfo(JNIEnv *env, const CK_SESSION_INFO_PTR ckpSessionInfo)
 167 {
 168     jclass jSessionInfoClass;
 169     jmethodID jCtrId;
 170     jobject jSessionInfoObject;
 171     jlong jSlotID;
 172     jlong jState;
 173     jlong jFlags;
 174     jlong jDeviceError;
 175 
 176     /* load CK_SESSION_INFO class */
 177     jSessionInfoClass = (*env)-&gt;FindClass(env, CLASS_SESSION_INFO);
 178     if (jSessionInfoClass == NULL) { return NULL; }
 179 
 180     /* load CK_SESSION_INFO constructor */
 181     jCtrId = (*env)-&gt;GetMethodID(env, jSessionInfoClass, &quot;&lt;init&gt;&quot;, &quot;(JJJJ)V&quot;);
 182     if (jCtrId == NULL) { return NULL; }
 183 
 184     /* prep all fields */
 185     jSlotID = ckULongToJLong(ckpSessionInfo-&gt;slotID);
 186     jState = ckULongToJLong(ckpSessionInfo-&gt;state);
 187     jFlags = ckULongToJLong(ckpSessionInfo-&gt;flags);
 188     jDeviceError = ckULongToJLong(ckpSessionInfo-&gt;ulDeviceError);
 189 
 190     /* create new CK_SESSION_INFO object */
 191     jSessionInfoObject =
 192       (*env)-&gt;NewObject(env, jSessionInfoClass, jCtrId, jSlotID, jState,
 193                         jFlags, jDeviceError);
 194     if (jSessionInfoObject == NULL) { return NULL; }
 195 
 196     /* free local references */
 197     (*env)-&gt;DeleteLocalRef(env, jSessionInfoClass);
 198 
 199     return jSessionInfoObject ;
 200 }
 201 
 202 /*
 203  * converts a CK_ATTRIBUTE pointer into a Java CK_ATTRIBUTE Object.
 204  *
 205  * @param env - used to call JNI funktions to create the new Java object
 206  * @param ckpAttribute - the pointer to the CK_ATTRIBUTE structure
 207  * @return the new Java CK_ATTRIBUTE object
 208  */
 209 jobject ckAttributePtrToJAttribute(JNIEnv *env, const CK_ATTRIBUTE_PTR ckpAttribute)
 210 {
 211     jclass jAttributeClass;
 212     jmethodID jCtrId;
 213     jobject jAttributeObject;
 214     jlong jType;
 215     jobject jPValue = NULL;
 216 
 217     jAttributeClass = (*env)-&gt;FindClass(env, CLASS_ATTRIBUTE);
 218     if (jAttributeClass == NULL) { return NULL; }
 219 
 220     /* load CK_INFO constructor */
 221     jCtrId = (*env)-&gt;GetMethodID(env, jAttributeClass, &quot;&lt;init&gt;&quot;, &quot;(JLjava/lang/Object;)V&quot;);
 222     if (jCtrId == NULL) { return NULL; }
 223 
 224     /* prep both fields */
 225     jType = ckULongToJLong(ckpAttribute-&gt;type);
 226     jPValue = ckAttributeValueToJObject(env, ckpAttribute);
 227     if ((*env)-&gt;ExceptionCheck(env)) { return NULL; }
 228 
 229     /* create new CK_ATTRIBUTE object */
 230     jAttributeObject =
 231       (*env)-&gt;NewObject(env, jAttributeClass, jCtrId, jType, jPValue);
 232     if (jAttributeObject == NULL) { return NULL; }
 233 
 234     /* free local references */
 235     (*env)-&gt;DeleteLocalRef(env, jAttributeClass);
 236     (*env)-&gt;DeleteLocalRef(env, jPValue);
 237 
 238     return jAttributeObject;
 239 }
 240 
 241 
 242 /*
 243  * converts a Java CK_VERSION object into a CK_VERSION pointer
 244  *
 245  * @param env - used to call JNI funktions to get the values out of the Java object
 246  * @param jVersion - the Java CK_VERSION object to convert
 247  * @return pointer to the new CK_VERSION structure
 248  */
 249 CK_VERSION_PTR
 250 jVersionToCKVersionPtr(JNIEnv *env, jobject jVersion)
 251 {
 252     CK_VERSION_PTR ckpVersion;
 253     jclass jVersionClass;
 254     jfieldID jFieldID;
 255     jbyte jMajor, jMinor;
 256 
 257     if (jVersion == NULL) {
 258         return NULL;
 259     }
 260 
 261     // retrieve java values
 262     jVersionClass = (*env)-&gt;GetObjectClass(env, jVersion);
 263     if (jVersionClass == NULL) { return NULL; }
 264     jFieldID = (*env)-&gt;GetFieldID(env, jVersionClass, &quot;major&quot;, &quot;B&quot;);
 265     if (jFieldID == NULL) { return NULL; }
 266     jMajor = (*env)-&gt;GetByteField(env, jVersion, jFieldID);
 267     jFieldID = (*env)-&gt;GetFieldID(env, jVersionClass, &quot;minor&quot;, &quot;B&quot;);
 268     if (jFieldID == NULL) { return NULL; }
 269     jMinor = (*env)-&gt;GetByteField(env, jVersion, jFieldID);
 270 
 271     // allocate memory for CK_VERSION pointer
 272     ckpVersion = (CK_VERSION_PTR) calloc(1, sizeof(CK_VERSION));
 273     if (ckpVersion == NULL) {
 274         throwOutOfMemoryError(env, 0);
 275         return NULL;
 276     }
 277 
 278     // populate using java values
 279     ckpVersion-&gt;major = jByteToCKByte(jMajor);
 280     ckpVersion-&gt;minor = jByteToCKByte(jMinor);
 281 
 282     return ckpVersion;
 283 }
 284 
 285 
 286 /*
 287  * converts a Java CK_DATE object into a CK_DATE pointer
 288  *
 289  * @param env - used to call JNI functions to get the values out of the Java object
 290  * @param jDate - the Java CK_DATE object to convert
 291  * @return pointer to the new CK_DATE structure
 292  */
 293 CK_DATE * jDateObjectToCKDatePtr(JNIEnv *env, jobject jDate)
 294 {
 295     CK_DATE * ckpDate = NULL;
 296     CK_ULONG ckLength;
 297     jclass jDateClass;
 298     jfieldID jFieldID;
 299     jobject jYear, jMonth, jDay;
 300     jchar *jTempChars = NULL;
 301     CK_ULONG i;
 302 
 303     if (jDate == NULL) {
 304         return NULL;
 305     }
 306 
 307     // retrieve java values
 308     jDateClass = (*env)-&gt;FindClass(env, CLASS_DATE);
 309     if (jDateClass == NULL) { return NULL; }
 310     jFieldID = (*env)-&gt;GetFieldID(env, jDateClass, &quot;year&quot;, &quot;[C&quot;);
 311     if (jFieldID == NULL) { return NULL; }
 312     jYear = (*env)-&gt;GetObjectField(env, jDate, jFieldID);
 313     jFieldID = (*env)-&gt;GetFieldID(env, jDateClass, &quot;month&quot;, &quot;[C&quot;);
 314     if (jFieldID == NULL) { return NULL; }
 315     jMonth = (*env)-&gt;GetObjectField(env, jDate, jFieldID);
 316     jFieldID = (*env)-&gt;GetFieldID(env, jDateClass, &quot;day&quot;, &quot;[C&quot;);
 317     if (jFieldID == NULL) { return NULL; }
 318     jDay = (*env)-&gt;GetObjectField(env, jDate, jFieldID);
 319 
 320     // allocate memory for CK_DATE pointer
 321     ckpDate = (CK_DATE *) calloc(1, sizeof(CK_DATE));
 322     if (ckpDate == NULL) {
 323         throwOutOfMemoryError(env, 0);
 324         return NULL;
 325     }
 326 
 327     // populate using java values
 328     if (jYear == NULL) {
 329         ckpDate-&gt;year[0] = 0;
 330         ckpDate-&gt;year[1] = 0;
 331         ckpDate-&gt;year[2] = 0;
 332         ckpDate-&gt;year[3] = 0;
 333     } else {
 334         ckLength = (*env)-&gt;GetArrayLength(env, jYear);
 335         jTempChars = (jchar*) calloc(ckLength, sizeof(jchar));
 336         if (jTempChars == NULL) {
 337             throwOutOfMemoryError(env, 0);
 338             goto cleanup;
 339         }
 340         (*env)-&gt;GetCharArrayRegion(env, jYear, 0, ckLength, jTempChars);
 341         if ((*env)-&gt;ExceptionCheck(env)) {
 342             goto cleanup;
 343         }
 344 
 345         for (i = 0; (i &lt; ckLength) &amp;&amp; (i &lt; 4) ; i++) {
 346             ckpDate-&gt;year[i] = jCharToCKChar(jTempChars[i]);
 347         }
 348         free(jTempChars);
 349     }
 350 
 351     if (jMonth == NULL) {
 352         ckpDate-&gt;month[0] = 0;
 353         ckpDate-&gt;month[1] = 0;
 354     } else {
 355         ckLength = (*env)-&gt;GetArrayLength(env, jMonth);
 356         jTempChars = (jchar*) calloc(ckLength, sizeof(jchar));
 357         if (jTempChars == NULL) {
 358             throwOutOfMemoryError(env, 0);
 359             goto cleanup;
 360         }
 361         (*env)-&gt;GetCharArrayRegion(env, jMonth, 0, ckLength, jTempChars);
 362         if ((*env)-&gt;ExceptionCheck(env)) {
 363             goto cleanup;
 364         }
 365 
 366         for (i = 0; (i &lt; ckLength) &amp;&amp; (i &lt; 2) ; i++) {
 367             ckpDate-&gt;month[i] = jCharToCKChar(jTempChars[i]);
 368         }
 369         free(jTempChars);
 370     }
 371 
 372     if (jDay == NULL) {
 373         ckpDate-&gt;day[0] = 0;
 374         ckpDate-&gt;day[1] = 0;
 375     } else {
 376         ckLength = (*env)-&gt;GetArrayLength(env, jDay);
 377         jTempChars = (jchar*) calloc(ckLength, sizeof(jchar));
 378         if (jTempChars == NULL) {
 379             throwOutOfMemoryError(env, 0);
 380             goto cleanup;
 381         }
 382         (*env)-&gt;GetCharArrayRegion(env, jDay, 0, ckLength, jTempChars);
 383         if ((*env)-&gt;ExceptionCheck(env)) {
 384             goto cleanup;
 385         }
 386 
 387         for (i = 0; (i &lt; ckLength) &amp;&amp; (i &lt; 2) ; i++) {
 388             ckpDate-&gt;day[i] = jCharToCKChar(jTempChars[i]);
 389         }
 390         free(jTempChars);
 391     }
 392 
 393     return ckpDate;
 394 cleanup:
 395     free(jTempChars);
 396     free(ckpDate);
 397     return NULL;
 398 }
 399 
 400 
 401 /*
 402  * converts a Java CK_ATTRIBUTE object into a CK_ATTRIBUTE structure
 403  *
 404  * @param env - used to call JNI funktions to get the values out of the Java object
 405  * @param jAttribute - the Java CK_ATTRIBUTE object to convert
 406  * @return the new CK_ATTRIBUTE structure
 407  */
 408 CK_ATTRIBUTE jAttributeToCKAttribute(JNIEnv *env, jobject jAttribute)
 409 {
 410     CK_ATTRIBUTE ckAttribute;
 411     jclass jAttributeClass;
 412     jfieldID jFieldID;
 413     jlong jType;
 414     jobject jPValue;
 415 
 416     memset(&amp;ckAttribute, 0, sizeof(CK_ATTRIBUTE));
 417 
 418     // TBD: what if jAttribute == NULL?!
 419     TRACE0(&quot;\nDEBUG: jAttributeToCKAttribute&quot;);
 420 
 421     /* get CK_ATTRIBUTE class */
 422     TRACE0(&quot;, getting attribute object class&quot;);
 423     jAttributeClass = (*env)-&gt;GetObjectClass(env, jAttribute);
 424     if (jAttributeClass == NULL) { return ckAttribute; }
 425 
 426     /* get type */
 427     TRACE0(&quot;, getting type field&quot;);
 428     jFieldID = (*env)-&gt;GetFieldID(env, jAttributeClass, &quot;type&quot;, &quot;J&quot;);
 429     if (jFieldID == NULL) { return ckAttribute; }
 430     jType = (*env)-&gt;GetLongField(env, jAttribute, jFieldID);
 431     TRACE1(&quot;, type=0x%lX&quot;, jType);
 432 
 433     /* get pValue */
 434     TRACE0(&quot;, getting pValue field&quot;);
 435     jFieldID = (*env)-&gt;GetFieldID(env, jAttributeClass, &quot;pValue&quot;, &quot;Ljava/lang/Object;&quot;);
 436     if (jFieldID == NULL) { return ckAttribute; }
 437     jPValue = (*env)-&gt;GetObjectField(env, jAttribute, jFieldID);
 438     TRACE1(&quot;, pValue=%p&quot;, jPValue);
 439 
 440     ckAttribute.type = jLongToCKULong(jType);
 441     TRACE0(&quot;, converting pValue to primitive object&quot;);
 442 
 443     /* convert the Java pValue object to a CK-type pValue pointer */
 444     ckAttribute.pValue = jObjectToPrimitiveCKObjectPtr(env, jPValue, &amp;(ckAttribute.ulValueLen));
 445 
 446     TRACE0(&quot;\nDEBUG: jAttributeToCKAttribute FINISHED\n&quot;);
 447 
 448     return ckAttribute ;
 449 }
 450 
 451 void masterKeyDeriveParamToCKMasterKeyDeriveParam(JNIEnv *env, jobject jParam,
 452         jclass masterKeyDeriveParamClass,
 453         CK_VERSION_PTR* cKMasterKeyDeriveParamVersion,
 454         CK_SSL3_RANDOM_DATA* cKMasterKeyDeriveParamRandomInfo) {
 455     jfieldID fieldID;
 456     jclass jSsl3RandomDataClass;
 457     jobject jRandomInfo, jRIClientRandom, jRIServerRandom, jVersion;
 458 
 459     // retrieve java values
 460     fieldID = (*env)-&gt;GetFieldID(env, masterKeyDeriveParamClass, &quot;RandomInfo&quot;,
 461             &quot;Lsun/security/pkcs11/wrapper/CK_SSL3_RANDOM_DATA;&quot;);
 462     if (fieldID == NULL) { return; }
 463     jRandomInfo = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 464     jSsl3RandomDataClass = (*env)-&gt;FindClass(env, CLASS_SSL3_RANDOM_DATA);
 465     if (jSsl3RandomDataClass == NULL) { return; }
 466     fieldID = (*env)-&gt;GetFieldID(env, jSsl3RandomDataClass, &quot;pClientRandom&quot;, &quot;[B&quot;);
 467     if (fieldID == NULL) { return; }
 468     jRIClientRandom = (*env)-&gt;GetObjectField(env, jRandomInfo, fieldID);
 469     fieldID = (*env)-&gt;GetFieldID(env, jSsl3RandomDataClass, &quot;pServerRandom&quot;, &quot;[B&quot;);
 470     if (fieldID == NULL) { return; }
 471     jRIServerRandom = (*env)-&gt;GetObjectField(env, jRandomInfo, fieldID);
 472     fieldID = (*env)-&gt;GetFieldID(env, masterKeyDeriveParamClass, &quot;pVersion&quot;,
 473             &quot;Lsun/security/pkcs11/wrapper/CK_VERSION;&quot;);
 474     if (fieldID == NULL) { return; }
 475     jVersion = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 476 
 477     // populate using java values
 478     *cKMasterKeyDeriveParamVersion = jVersionToCKVersionPtr(env, jVersion);
 479     if ((*env)-&gt;ExceptionCheck(env)) { return; }
 480     jByteArrayToCKByteArray(env, jRIClientRandom,
 481             &amp;(cKMasterKeyDeriveParamRandomInfo-&gt;pClientRandom),
 482             &amp;(cKMasterKeyDeriveParamRandomInfo-&gt;ulClientRandomLen));
 483     if ((*env)-&gt;ExceptionCheck(env)) {
 484         goto cleanup;
 485     }
 486     jByteArrayToCKByteArray(env, jRIServerRandom,
 487             &amp;(cKMasterKeyDeriveParamRandomInfo-&gt;pServerRandom),
 488             &amp;(cKMasterKeyDeriveParamRandomInfo-&gt;ulServerRandomLen));
 489     if ((*env)-&gt;ExceptionCheck(env)) {
 490         goto cleanup;
 491     }
 492     return;
 493 cleanup:
 494     free(*cKMasterKeyDeriveParamVersion);
 495     free(cKMasterKeyDeriveParamRandomInfo-&gt;pClientRandom);
 496     cKMasterKeyDeriveParamRandomInfo-&gt;ulClientRandomLen = 0L;
 497     free(cKMasterKeyDeriveParamRandomInfo-&gt;pServerRandom);
 498     cKMasterKeyDeriveParamRandomInfo-&gt;ulServerRandomLen = 0L;
 499     // explicitly set to NULL to ensure no double free possible
 500     *cKMasterKeyDeriveParamVersion = NULL;
 501     cKMasterKeyDeriveParamRandomInfo-&gt;pClientRandom = NULL;
 502     cKMasterKeyDeriveParamRandomInfo-&gt;pServerRandom = NULL;
 503 }
 504 
 505 /*
 506  * converts the Java CK_SSL3_MASTER_KEY_DERIVE_PARAMS object to a
 507  * CK_SSL3_MASTER_KEY_DERIVE_PARAMS pointer
 508  *
 509  * @param env - used to call JNI functions to get the Java classes and objects
 510  * @param jParam - the Java CK_SSL3_MASTER_KEY_DERIVE_PARAMS object to convert
 511  * @param pLength - length of the allocated memory of the returned pointer
 512  * @return pointer to the new CK_SSL3_MASTER_KEY_DERIVE_PARAMS structure
 513  */
 514 CK_SSL3_MASTER_KEY_DERIVE_PARAMS_PTR
 515 jSsl3MasterKeyDeriveParamToCKSsl3MasterKeyDeriveParamPtr(JNIEnv *env,
 516         jobject jParam, CK_ULONG *pLength)
 517 {
 518     CK_SSL3_MASTER_KEY_DERIVE_PARAMS_PTR ckParamPtr;
 519     jclass jSsl3MasterKeyDeriveParamsClass;
 520 
 521     if (pLength != NULL) {
 522         *pLength = 0L;
 523     }
 524 
 525     // allocate memory for CK_SSL3_MASTER_KEY_DERIVE_PARAMS pointer
 526     ckParamPtr = calloc(1, sizeof(CK_SSL3_MASTER_KEY_DERIVE_PARAMS));
 527     if (ckParamPtr == NULL) {
 528         throwOutOfMemoryError(env, 0);
 529         return NULL;
 530     }
 531 
 532     // retrieve and populate using java values
 533     jSsl3MasterKeyDeriveParamsClass =
 534             (*env)-&gt;FindClass(env, CLASS_SSL3_MASTER_KEY_DERIVE_PARAMS);
 535     if (jSsl3MasterKeyDeriveParamsClass == NULL) {
 536         goto cleanup;
 537     }
 538     masterKeyDeriveParamToCKMasterKeyDeriveParam(env, jParam,
 539             jSsl3MasterKeyDeriveParamsClass,
 540             &amp;(ckParamPtr-&gt;pVersion), &amp;(ckParamPtr-&gt;RandomInfo));
 541     if ((*env)-&gt;ExceptionCheck(env)) {
 542         goto cleanup;
 543     }
 544 
 545     if (pLength != NULL) {
 546         *pLength = sizeof(CK_SSL3_MASTER_KEY_DERIVE_PARAMS);
 547     }
 548     return ckParamPtr;
 549 cleanup:
 550     free(ckParamPtr);
 551     return NULL;
 552 }
 553 
 554 /*
 555  * converts the Java CK_TLS12_MASTER_KEY_DERIVE_PARAMS object to a
 556  * CK_TLS12_MASTER_KEY_DERIVE_PARAMS pointer
 557  *
 558  * @param env - used to call JNI functions to get the Java classes and objects
 559  * @param jParam - the Java CK_TLS12_MASTER_KEY_DERIVE_PARAMS object to convert
 560  * @param pLength - length of the allocated memory of the returned pointer
 561  * @return pointer to the new CK_TLS12_MASTER_KEY_DERIVE_PARAMS structure
 562  */
 563 CK_TLS12_MASTER_KEY_DERIVE_PARAMS_PTR
 564 jTls12MasterKeyDeriveParamToCKTls12MasterKeyDeriveParamPtr(JNIEnv *env,
 565         jobject jParam, CK_ULONG *pLength)
 566 {
 567     CK_TLS12_MASTER_KEY_DERIVE_PARAMS_PTR ckParamPtr;
 568     jclass jTls12MasterKeyDeriveParamsClass;
 569     jfieldID fieldID;
 570     jlong prfHashMechanism;
 571 
 572     if (pLength != NULL) {
 573         *pLength = 0L;
 574     }
 575 
 576     // retrieve java values
 577     jTls12MasterKeyDeriveParamsClass =
 578         (*env)-&gt;FindClass(env, CLASS_TLS12_MASTER_KEY_DERIVE_PARAMS);
 579     if (jTls12MasterKeyDeriveParamsClass == NULL) { return NULL; }
 580     fieldID = (*env)-&gt;GetFieldID(env,
 581             jTls12MasterKeyDeriveParamsClass, &quot;prfHashMechanism&quot;, &quot;J&quot;);
 582     if (fieldID == NULL) { return NULL; }
 583     prfHashMechanism = (*env)-&gt;GetLongField(env, jParam, fieldID);
 584 
 585     // allocate memory for CK_TLS12_MASTER_KEY_DERIVE_PARAMS pointer
 586     ckParamPtr = calloc(1, sizeof(CK_TLS12_MASTER_KEY_DERIVE_PARAMS));
 587     if (ckParamPtr == NULL) {
 588         throwOutOfMemoryError(env, 0);
 589         return NULL;
 590     }
 591 
 592     // populate using java values
 593     masterKeyDeriveParamToCKMasterKeyDeriveParam(env, jParam,
 594             jTls12MasterKeyDeriveParamsClass, &amp;ckParamPtr-&gt;pVersion,
 595             &amp;ckParamPtr-&gt;RandomInfo);
 596     if ((*env)-&gt;ExceptionCheck(env)) {
 597         goto cleanup;
 598     }
 599 
 600     ckParamPtr-&gt;prfHashMechanism = (CK_MECHANISM_TYPE) prfHashMechanism;
 601 
 602     if (pLength != NULL) {
 603         *pLength = sizeof(CK_TLS12_MASTER_KEY_DERIVE_PARAMS);
 604     }
 605     return ckParamPtr;
 606 cleanup:
 607     free(ckParamPtr);
 608     return NULL;
 609 }
 610 
 611 /*
 612  * converts the Java CK_TLS_PRF_PARAMS object to a CK_TLS_PRF_PARAMS pointer
 613  *
 614  * @param env - used to call JNI functions to get the Java classes and objects
 615  * @param jParam - the Java CK_TLS_PRF_PARAMS object to convert
 616  * @param pLength - length of the allocated memory of the returned pointer
 617  * @return pointer to the new CK_TLS_PRF_PARAMS structure
 618  */
 619 CK_TLS_PRF_PARAMS_PTR
 620 jTlsPrfParamsToCKTlsPrfParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
 621 {
 622     CK_TLS_PRF_PARAMS_PTR ckParamPtr;
 623     jclass jTlsPrfParamsClass;
 624     jfieldID fieldID;
 625     jobject jSeed, jLabel, jOutput;
 626 
 627     if (pLength != NULL) {
 628         *pLength = 0;
 629     }
 630 
 631     // retrieve java values
 632     jTlsPrfParamsClass = (*env)-&gt;FindClass(env, CLASS_TLS_PRF_PARAMS);
 633     if (jTlsPrfParamsClass == NULL) { return NULL; }
 634     fieldID = (*env)-&gt;GetFieldID(env, jTlsPrfParamsClass, &quot;pSeed&quot;, &quot;[B&quot;);
 635     if (fieldID == NULL) { return NULL; }
 636     jSeed = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 637     fieldID = (*env)-&gt;GetFieldID(env, jTlsPrfParamsClass, &quot;pLabel&quot;, &quot;[B&quot;);
 638     if (fieldID == NULL) { return NULL; }
 639     jLabel = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 640     fieldID = (*env)-&gt;GetFieldID(env, jTlsPrfParamsClass, &quot;pOutput&quot;, &quot;[B&quot;);
 641     if (fieldID == NULL) { return NULL; }
 642     jOutput = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 643 
 644     // allocate memory for CK_TLS_PRF_PARAMS pointer
 645     ckParamPtr = calloc(1, sizeof(CK_TLS_PRF_PARAMS));
 646     if (ckParamPtr == NULL) {
 647         throwOutOfMemoryError(env, 0);
 648         return NULL;
 649     }
 650 
 651     // populate using java values
 652     jByteArrayToCKByteArray(env, jSeed, &amp;(ckParamPtr-&gt;pSeed), &amp;(ckParamPtr-&gt;ulSeedLen));
 653     if ((*env)-&gt;ExceptionCheck(env)) {
 654         goto cleanup;
 655     }
 656     jByteArrayToCKByteArray(env, jLabel, &amp;(ckParamPtr-&gt;pLabel), &amp;(ckParamPtr-&gt;ulLabelLen));
 657     if ((*env)-&gt;ExceptionCheck(env)) {
 658         goto cleanup;
 659     }
 660     ckParamPtr-&gt;pulOutputLen = calloc(1, sizeof(CK_ULONG));
 661     if (ckParamPtr-&gt;pulOutputLen == NULL) {
 662         goto cleanup;
 663     }
 664     jByteArrayToCKByteArray(env, jOutput, &amp;(ckParamPtr-&gt;pOutput), ckParamPtr-&gt;pulOutputLen);
 665     if ((*env)-&gt;ExceptionCheck(env)) {
 666         goto cleanup;
 667     }
 668 
 669     if (pLength != NULL) {
 670         *pLength = sizeof(CK_TLS_PRF_PARAMS);
 671     }
 672     return ckParamPtr;
 673 cleanup:
 674     free(ckParamPtr-&gt;pSeed);
 675     free(ckParamPtr-&gt;pLabel);
 676     free(ckParamPtr-&gt;pOutput);
 677     free(ckParamPtr-&gt;pulOutputLen);
 678     free(ckParamPtr);
 679     return NULL;
 680 }
 681 
 682 /*
 683  * converts the Java CK_TLS_MAC_PARAMS object to a CK_TLS_MAC_PARAMS pointer
 684  *
 685  * @param env - used to call JNI functions to get the Java classes and objects
 686  * @param jParam - the Java CK_TLS_MAC_PARAMS object to convert
 687  * @param pLength - length of the allocated memory of the returned pointer
 688  * @return pointer to the new CK_TLS_MAC_PARAMS structure
 689  */
 690 
 691 CK_TLS_MAC_PARAMS_PTR
 692 jTlsMacParamsToCKTlsMacParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
 693 {
 694     CK_TLS_MAC_PARAMS_PTR ckParamPtr;
 695     jclass jTlsMacParamsClass;
 696     jfieldID fieldID;
 697     jlong jPrfMechanism, jUlMacLength, jUlServerOrClient;
 698 
 699     if (pLength != NULL) {
 700         *pLength = 0L;
 701     }
 702 
 703     // retrieve java values
 704     jTlsMacParamsClass = (*env)-&gt;FindClass(env, CLASS_TLS_MAC_PARAMS);
 705     if (jTlsMacParamsClass == NULL) { return NULL; }
 706     fieldID = (*env)-&gt;GetFieldID(env, jTlsMacParamsClass, &quot;prfMechanism&quot;, &quot;J&quot;);
 707     if (fieldID == NULL) { return NULL; }
 708     jPrfMechanism = (*env)-&gt;GetLongField(env, jParam, fieldID);
 709     fieldID = (*env)-&gt;GetFieldID(env, jTlsMacParamsClass, &quot;ulMacLength&quot;, &quot;J&quot;);
 710     if (fieldID == NULL) { return NULL; }
 711     jUlMacLength = (*env)-&gt;GetLongField(env, jParam, fieldID);
 712     fieldID = (*env)-&gt;GetFieldID(env, jTlsMacParamsClass, &quot;ulServerOrClient&quot;, &quot;J&quot;);
 713     if (fieldID == NULL) { return NULL; }
 714     jUlServerOrClient = (*env)-&gt;GetLongField(env, jParam, fieldID);
 715 
 716     // allocate memory for CK_TLS_MAC_PARAMS pointer
 717     ckParamPtr = calloc(1, sizeof(CK_TLS_MAC_PARAMS));
 718     if (ckParamPtr == NULL) {
 719         throwOutOfMemoryError(env, 0);
 720         return NULL;
 721     }
 722 
 723     // populate using java values
 724     ckParamPtr-&gt;prfHashMechanism = jLongToCKULong(jPrfMechanism);
 725     ckParamPtr-&gt;ulMacLength = jLongToCKULong(jUlMacLength);
 726     ckParamPtr-&gt;ulServerOrClient = jLongToCKULong(jUlServerOrClient);
 727 
 728     if (pLength != NULL) {
 729         *pLength = sizeof(CK_TLS_MAC_PARAMS);
 730     }
 731     return ckParamPtr;
 732 }
 733 
 734 void keyMatParamToCKKeyMatParam(JNIEnv *env, jobject jParam,
 735         jclass jKeyMatParamClass,
 736         CK_ULONG* cKKeyMatParamUlMacSizeInBits,
 737         CK_ULONG* cKKeyMatParamUlKeySizeInBits,
 738         CK_ULONG* cKKeyMatParamUlIVSizeInBits,
 739         CK_BBOOL* cKKeyMatParamBIsExport,
 740         CK_SSL3_RANDOM_DATA* cKKeyMatParamRandomInfo,
 741         CK_SSL3_KEY_MAT_OUT_PTR* cKKeyMatParamPReturnedKeyMaterial)
 742 {
 743     jclass jSsl3RandomDataClass, jSsl3KeyMatOutClass;
 744     jfieldID fieldID;
 745     jlong jMacSizeInBits, jKeySizeInBits, jIVSizeInBits;
 746     jboolean jIsExport;
 747     jobject jRandomInfo, jRIClientRandom, jRIServerRandom;
 748     jobject jReturnedKeyMaterial, jRMIvClient, jRMIvServer;
 749     CK_ULONG ckTemp;
 750 
 751     // the pointer arguments should already be initialized by caller
 752 
 753     // retrieve java values
 754     fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamClass, &quot;ulMacSizeInBits&quot;, &quot;J&quot;);
 755     if (fieldID == NULL) { return; }
 756     jMacSizeInBits = (*env)-&gt;GetLongField(env, jParam, fieldID);
 757     fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamClass, &quot;ulKeySizeInBits&quot;, &quot;J&quot;);
 758     if (fieldID == NULL) { return; }
 759     jKeySizeInBits = (*env)-&gt;GetLongField(env, jParam, fieldID);
 760     fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamClass, &quot;ulIVSizeInBits&quot;, &quot;J&quot;);
 761     if (fieldID == NULL) { return; }
 762     jIVSizeInBits = (*env)-&gt;GetLongField(env, jParam, fieldID);
 763     fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamClass, &quot;bIsExport&quot;, &quot;Z&quot;);
 764     if (fieldID == NULL) { return; }
 765     jIsExport = (*env)-&gt;GetBooleanField(env, jParam, fieldID);
 766     jSsl3RandomDataClass = (*env)-&gt;FindClass(env, CLASS_SSL3_RANDOM_DATA);
 767     if (jSsl3RandomDataClass == NULL) { return; }
 768     fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamClass, &quot;RandomInfo&quot;,
 769             &quot;Lsun/security/pkcs11/wrapper/CK_SSL3_RANDOM_DATA;&quot;);
 770     if (fieldID == NULL) { return; }
 771     jRandomInfo = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 772     fieldID = (*env)-&gt;GetFieldID(env, jSsl3RandomDataClass, &quot;pClientRandom&quot;, &quot;[B&quot;);
 773     if (fieldID == NULL) { return; }
 774     jRIClientRandom = (*env)-&gt;GetObjectField(env, jRandomInfo, fieldID);
 775     fieldID = (*env)-&gt;GetFieldID(env, jSsl3RandomDataClass, &quot;pServerRandom&quot;, &quot;[B&quot;);
 776     if (fieldID == NULL) { return; }
 777     jRIServerRandom = (*env)-&gt;GetObjectField(env, jRandomInfo, fieldID);
 778     jSsl3KeyMatOutClass = (*env)-&gt;FindClass(env, CLASS_SSL3_KEY_MAT_OUT);
 779     if (jSsl3KeyMatOutClass == NULL) { return; }
 780     fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamClass, &quot;pReturnedKeyMaterial&quot;,
 781             &quot;Lsun/security/pkcs11/wrapper/CK_SSL3_KEY_MAT_OUT;&quot;);
 782     if (fieldID == NULL) { return; }
 783     jReturnedKeyMaterial = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 784     fieldID = (*env)-&gt;GetFieldID(env, jSsl3KeyMatOutClass, &quot;pIVClient&quot;, &quot;[B&quot;);
 785     if (fieldID == NULL) { return; }
 786     jRMIvClient = (*env)-&gt;GetObjectField(env, jReturnedKeyMaterial, fieldID);
 787     fieldID = (*env)-&gt;GetFieldID(env, jSsl3KeyMatOutClass, &quot;pIVServer&quot;, &quot;[B&quot;);
 788     if (fieldID == NULL) { return; }
 789     jRMIvServer = (*env)-&gt;GetObjectField(env, jReturnedKeyMaterial, fieldID);
 790 
 791     // populate the specified pointers using java values
 792     *cKKeyMatParamUlMacSizeInBits = jLongToCKULong(jMacSizeInBits);
 793     *cKKeyMatParamUlKeySizeInBits = jLongToCKULong(jKeySizeInBits);
 794     *cKKeyMatParamUlIVSizeInBits = jLongToCKULong(jIVSizeInBits);
 795     *cKKeyMatParamBIsExport = jBooleanToCKBBool(jIsExport);
 796     jByteArrayToCKByteArray(env, jRIClientRandom,
 797             &amp;(cKKeyMatParamRandomInfo-&gt;pClientRandom),
 798             &amp;(cKKeyMatParamRandomInfo-&gt;ulClientRandomLen));
 799     if ((*env)-&gt;ExceptionCheck(env)) {
 800         // just return as no memory allocation yet
 801         return;
 802     }
 803     jByteArrayToCKByteArray(env, jRIServerRandom,
 804             &amp;(cKKeyMatParamRandomInfo-&gt;pServerRandom),
 805             &amp;(cKKeyMatParamRandomInfo-&gt;ulServerRandomLen));
 806     if ((*env)-&gt;ExceptionCheck(env)) {
 807         goto cleanup;
 808     }
 809     /* allocate memory for pReturnedKeyMaterial */
 810     *cKKeyMatParamPReturnedKeyMaterial =
 811             (CK_SSL3_KEY_MAT_OUT_PTR) calloc(1, sizeof(CK_SSL3_KEY_MAT_OUT));
 812     if (*cKKeyMatParamPReturnedKeyMaterial == NULL) {
 813         throwOutOfMemoryError(env, 0);
 814         goto cleanup;
 815     }
 816 
 817     // the handles are output params only, no need to fetch them from Java
 818     (*cKKeyMatParamPReturnedKeyMaterial)-&gt;hClientMacSecret = 0;
 819     (*cKKeyMatParamPReturnedKeyMaterial)-&gt;hServerMacSecret = 0;
 820     (*cKKeyMatParamPReturnedKeyMaterial)-&gt;hClientKey = 0;
 821     (*cKKeyMatParamPReturnedKeyMaterial)-&gt;hServerKey = 0;
 822 
 823     jByteArrayToCKByteArray(env, jRMIvClient,
 824             &amp;((*cKKeyMatParamPReturnedKeyMaterial)-&gt;pIVClient), &amp;ckTemp);
 825     if ((*env)-&gt;ExceptionCheck(env)) {
 826         goto cleanup;
 827     }
 828     jByteArrayToCKByteArray(env, jRMIvServer,
 829             &amp;((*cKKeyMatParamPReturnedKeyMaterial)-&gt;pIVServer), &amp;ckTemp);
 830     if ((*env)-&gt;ExceptionCheck(env)) {
 831         goto cleanup;
 832     }
 833 
 834     return;
 835 cleanup:
 836     free(cKKeyMatParamRandomInfo-&gt;pClientRandom);
 837     free(cKKeyMatParamRandomInfo-&gt;pServerRandom);
 838     if ((*cKKeyMatParamPReturnedKeyMaterial) != NULL) {
 839         free((*cKKeyMatParamPReturnedKeyMaterial)-&gt;pIVClient);
 840         free(*cKKeyMatParamPReturnedKeyMaterial);
 841     }
 842     // explicitly set to NULL to ensure no double free possible
 843     cKKeyMatParamRandomInfo-&gt;pClientRandom = NULL;
 844     cKKeyMatParamRandomInfo-&gt;pServerRandom = NULL;
 845     *cKKeyMatParamPReturnedKeyMaterial = NULL;
 846     return;
 847 }
 848 /*
 849  * converts the Java CK_SSL3_KEY_MAT_PARAMS object to a
 850  * CK_SSL3_KEY_MAT_PARAMS pointer
 851  *
 852  * @param env - used to call JNI funktions to get the Java classes and objects
 853  * @param jParam - the Java CK_SSL3_KEY_MAT_PARAMS object to convert
 854  * @param pLength - length of the allocated memory of the returned pointer
 855  * @return pointer to the new CK_SSL3_KEY_MAT_PARAMS structure
 856  */
 857 CK_SSL3_KEY_MAT_PARAMS_PTR
 858 jSsl3KeyMatParamToCKSsl3KeyMatParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
 859 {
 860     CK_SSL3_KEY_MAT_PARAMS_PTR ckParamPtr;
 861     jclass jSsl3KeyMatParamsClass;
 862 
 863     if (pLength != NULL) {
 864         *pLength = 0;
 865     }
 866 
 867     // allocate memory for CK_SSL3_KEY_MAT_PARAMS pointer
 868     ckParamPtr = calloc(1, sizeof(CK_SSL3_KEY_MAT_PARAMS));
 869     if (ckParamPtr == NULL) {
 870         throwOutOfMemoryError(env, 0);
 871         return NULL;
 872     }
 873 
 874     // retrieve and  populate using java values
 875     jSsl3KeyMatParamsClass = (*env)-&gt;FindClass(env,
 876             CLASS_SSL3_KEY_MAT_PARAMS);
 877     if (jSsl3KeyMatParamsClass == NULL) {
 878         goto cleanup;
 879     }
 880     keyMatParamToCKKeyMatParam(env, jParam, jSsl3KeyMatParamsClass,
 881             &amp;(ckParamPtr-&gt;ulMacSizeInBits), &amp;(ckParamPtr-&gt;ulKeySizeInBits),
 882             &amp;(ckParamPtr-&gt;ulIVSizeInBits), &amp;(ckParamPtr-&gt;bIsExport),
 883             &amp;(ckParamPtr-&gt;RandomInfo), &amp;(ckParamPtr-&gt;pReturnedKeyMaterial));
 884     if ((*env)-&gt;ExceptionCheck(env)) {
 885         goto cleanup;
 886     }
 887 
 888     if (pLength != NULL) {
 889         *pLength = sizeof(CK_SSL3_KEY_MAT_PARAMS);
 890     }
 891     return ckParamPtr;
 892 cleanup:
 893     free(ckParamPtr);
 894     return NULL;
 895 }
 896 
 897 /*
 898  * converts the Java CK_TLS12_KEY_MAT_PARAMS object to a
 899  * CK_TLS12_KEY_MAT_PARAMS pointer
 900  *
 901  * @param env - used to call JNI functions to get the Java classes and objects
 902  * @param jParam - the Java CK_TLS12_KEY_MAT_PARAMS object to convert
 903  * @param pLength - length of the allocated memory of the returned pointer
 904  * @return pointer to the new CK_TLS12_KEY_MAT_PARAMS structure
 905  */
 906 CK_TLS12_KEY_MAT_PARAMS_PTR jTls12KeyMatParamToCKTls12KeyMatParamPtr(JNIEnv *env,
 907         jobject jParam, CK_ULONG *pLength)
 908 {
 909     CK_TLS12_KEY_MAT_PARAMS_PTR ckParamPtr;
 910     jclass jTls12KeyMatParamsClass;
 911     jfieldID fieldID;
 912     jlong prfHashMechanism;
 913 
 914     if (pLength != NULL) {
 915         *pLength = 0;
 916     }
 917 
 918     // retrieve java values
 919     jTls12KeyMatParamsClass = (*env)-&gt;FindClass(env,
 920             CLASS_TLS12_KEY_MAT_PARAMS);
 921     if (jTls12KeyMatParamsClass == NULL) { return NULL; }
 922     fieldID = (*env)-&gt;GetFieldID(env, jTls12KeyMatParamsClass,
 923             &quot;prfHashMechanism&quot;, &quot;J&quot;);
 924     if (fieldID == NULL) { return NULL; }
 925     prfHashMechanism = (*env)-&gt;GetLongField(env, jParam, fieldID);
 926 
 927     // allocate memory for CK_TLS12_KEY_MAT_PARAMS pointer
 928     ckParamPtr = calloc(1, sizeof(CK_TLS12_KEY_MAT_PARAMS));
 929     if (ckParamPtr == NULL) {
 930         throwOutOfMemoryError(env, 0);
 931         return NULL;
 932     }
 933 
 934     // populate using java values
 935     keyMatParamToCKKeyMatParam(env, jParam, jTls12KeyMatParamsClass,
 936             &amp;(ckParamPtr-&gt;ulMacSizeInBits), &amp;(ckParamPtr-&gt;ulKeySizeInBits),
 937             &amp;(ckParamPtr-&gt;ulIVSizeInBits), &amp;(ckParamPtr-&gt;bIsExport),
 938             &amp;(ckParamPtr-&gt;RandomInfo), &amp;(ckParamPtr-&gt;pReturnedKeyMaterial));
 939     if ((*env)-&gt;ExceptionCheck(env)) {
 940         goto cleanup;
 941     }
 942     ckParamPtr-&gt;prfHashMechanism = (CK_MECHANISM_TYPE)prfHashMechanism;
 943 
 944     if (pLength != NULL) {
 945         *pLength = sizeof(CK_TLS12_KEY_MAT_PARAMS);
 946     }
 947     return ckParamPtr;
 948 cleanup:
 949     free(ckParamPtr);
 950     return NULL;
 951 }
 952 
 953 /*
 954  * converts the Java CK_AES_CTR_PARAMS object to a CK_AES_CTR_PARAMS pointer
 955  *
 956  * @param env - used to call JNI funktions to get the Java classes and objects
 957  * @param jParam - the Java CK_AES_CTR_PARAMS object to convert
 958  * @param pLength - length of the allocated memory of the returned pointer
 959  * @return pointer to the new CK_AES_CTR_PARAMS structure
 960  */
 961 CK_AES_CTR_PARAMS_PTR
 962 jAesCtrParamsToCKAesCtrParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
 963 {
 964     CK_AES_CTR_PARAMS_PTR ckParamPtr;
 965     jclass jAesCtrParamsClass;
 966     jfieldID fieldID;
 967     jlong jCounterBits;
 968     jobject jCb;
 969     CK_BYTE_PTR ckBytes = NULL;
 970     CK_ULONG ckTemp;
 971 
 972     if (pLength != NULL) {
 973         *pLength = 0L;
 974     }
 975 
 976     // retrieve java values
 977     jAesCtrParamsClass = (*env)-&gt;FindClass(env, CLASS_AES_CTR_PARAMS);
 978     if (jAesCtrParamsClass == NULL) { return NULL; }
 979     if (!(*env)-&gt;IsInstanceOf(env, jParam, jAesCtrParamsClass)) {
 980         return NULL;
 981     }
 982     fieldID = (*env)-&gt;GetFieldID(env, jAesCtrParamsClass, &quot;ulCounterBits&quot;, &quot;J&quot;);
 983     if (fieldID == NULL) { return NULL; }
 984     jCounterBits = (*env)-&gt;GetLongField(env, jParam, fieldID);
 985     fieldID = (*env)-&gt;GetFieldID(env, jAesCtrParamsClass, &quot;cb&quot;, &quot;[B&quot;);
 986     if (fieldID == NULL) { return NULL; }
 987     jCb = (*env)-&gt;GetObjectField(env, jParam, fieldID);
 988 
 989     // allocate memory for CK_AES_CTR_PARAMS pointer
 990     ckParamPtr = calloc(1, sizeof(CK_AES_CTR_PARAMS));
 991     if (ckParamPtr == NULL) {
 992         throwOutOfMemoryError(env, 0);
 993         return NULL;
 994     }
 995 
 996     // populate using java values
 997     jByteArrayToCKByteArray(env, jCb, &amp;ckBytes, &amp;ckTemp);
 998     if ((*env)-&gt;ExceptionCheck(env) || ckTemp != 16) {
 999         goto cleanup;
1000     }
1001     memcpy(ckParamPtr-&gt;cb, ckBytes, ckTemp);
1002     free(ckBytes);
1003 
1004     ckParamPtr-&gt;ulCounterBits = jLongToCKULong(jCounterBits);
1005 
1006     if (pLength != NULL) {
1007         *pLength = sizeof(CK_AES_CTR_PARAMS);
1008     }
1009     return ckParamPtr;
1010 cleanup:
1011     free(ckBytes);
1012     free(ckParamPtr);
1013     return NULL;
1014 }
1015 
1016 /*
1017  * converts the Java CK_GCM_PARAMS object to a CK_GCM_PARAMS_NO_IVBITS pointer
1018  * Note: Need to try NSS definition first to avoid SIGSEGV.
1019  *
1020  * @param env - used to call JNI funktions to get the Java classes and objects
1021  * @param jParam - the Java CK_GCM_PARAMS object to convert
1022  * @param pLength - length of the allocated memory of the returned pointer
1023  * @return pointer to the new CK_GCM_PARAMS_NO_IVBITS structure
1024  */
1025 CK_GCM_PARAMS_NO_IVBITS_PTR
1026 jGCMParamsToCKGCMParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
1027 {
1028     CK_GCM_PARAMS_NO_IVBITS_PTR ckParamPtr;
1029     jclass jGcmParamsClass;
1030     jfieldID fieldID;
1031     jobject jIv, jAad;
1032     jlong jTagLen;
1033 
1034     TRACE0(&quot;DEBUG jGCMParamsToCKGCMParam is called\n&quot;);
1035 
1036     if (pLength != NULL) {
1037         *pLength = 0L;
1038     }
1039 
1040     // retrieve java values
1041     jGcmParamsClass = (*env)-&gt;FindClass(env, CLASS_GCM_PARAMS);
1042     if (jGcmParamsClass == NULL) { return NULL; }
1043     if (!(*env)-&gt;IsInstanceOf(env, jParam, jGcmParamsClass)) {
1044         return NULL;
1045     }
1046     fieldID = (*env)-&gt;GetFieldID(env, jGcmParamsClass, &quot;iv&quot;, &quot;[B&quot;);
1047     if (fieldID == NULL) { return NULL; }
1048     jIv = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1049     fieldID = (*env)-&gt;GetFieldID(env, jGcmParamsClass, &quot;aad&quot;, &quot;[B&quot;);
1050     if (fieldID == NULL) { return NULL; }
1051     jAad = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1052     fieldID = (*env)-&gt;GetFieldID(env, jGcmParamsClass, &quot;tagBits&quot;, &quot;J&quot;);
1053     if (fieldID == NULL) { return NULL; }
1054     jTagLen = (*env)-&gt;GetLongField(env, jParam, fieldID);
1055 
1056     // allocate memory for CK_GCM_PARAMS_NO_IVBITS pointer
1057     ckParamPtr = calloc(1, sizeof(CK_GCM_PARAMS_NO_IVBITS));
1058     if (ckParamPtr == NULL) {
1059         throwOutOfMemoryError(env, 0);
1060         return NULL;
1061     }
1062 
1063     // populate using java values
1064     jByteArrayToCKByteArray(env, jIv, &amp;(ckParamPtr-&gt;pIv), &amp;(ckParamPtr-&gt;ulIvLen));
1065     if ((*env)-&gt;ExceptionCheck(env)) {
1066         goto cleanup;
1067     }
1068 
1069     jByteArrayToCKByteArray(env, jAad, &amp;(ckParamPtr-&gt;pAAD), &amp;(ckParamPtr-&gt;ulAADLen));
1070     if ((*env)-&gt;ExceptionCheck(env)) {
1071         goto cleanup;
1072     }
1073 
1074     ckParamPtr-&gt;ulTagBits = jLongToCKULong(jTagLen);
1075 
1076     if (pLength != NULL) {
1077         *pLength = sizeof(CK_GCM_PARAMS_NO_IVBITS);
1078     }
1079     TRACE1(&quot;Created inner GCM_PARAMS PTR w/o ulIvBits %p\n&quot;, ckParamPtr);
1080     return ckParamPtr;
1081 cleanup:
1082     free(ckParamPtr-&gt;pIv);
1083     free(ckParamPtr-&gt;pAAD);
1084     free(ckParamPtr);
1085     return NULL;
1086 }
1087 
1088 /*
1089  * converts the Java CK_CCM_PARAMS object to a CK_CCM_PARAMS pointer
1090  *
1091  * @param env - used to call JNI functions to get the Java classes and objects
1092  * @param jParam - the Java CK_CCM_PARAMS object to convert
1093  * @param pLength - length of the allocated memory of the returned pointer
1094  * @return pointer to the new CK_CCM_PARAMS structure
1095  */
1096 CK_CCM_PARAMS_PTR
1097 jCCMParamsToCKCCMParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
1098 {
1099     CK_CCM_PARAMS_PTR ckParamPtr;
1100     jclass jCcmParamsClass;
1101     jfieldID fieldID;
1102     jobject jNonce, jAad;
1103     jlong jDataLen, jMacLen;
1104 
1105     if (pLength != NULL) {
1106         *pLength = 0;
1107     }
1108 
1109     // retrieve java values
1110     jCcmParamsClass = (*env)-&gt;FindClass(env, CLASS_CCM_PARAMS);
1111     if (jCcmParamsClass == NULL) { return NULL; }
1112     if (!(*env)-&gt;IsInstanceOf(env, jParam, jCcmParamsClass)) {
1113         return NULL;
1114     }
1115     fieldID = (*env)-&gt;GetFieldID(env, jCcmParamsClass, &quot;dataLen&quot;, &quot;J&quot;);
1116     if (fieldID == NULL) { return NULL; }
1117     jDataLen = (*env)-&gt;GetLongField(env, jParam, fieldID);
1118     fieldID = (*env)-&gt;GetFieldID(env, jCcmParamsClass, &quot;nonce&quot;, &quot;[B&quot;);
1119     if (fieldID == NULL) { return NULL; }
1120     jNonce = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1121     fieldID = (*env)-&gt;GetFieldID(env, jCcmParamsClass, &quot;aad&quot;, &quot;[B&quot;);
1122     if (fieldID == NULL) { return NULL; }
1123     jAad = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1124     fieldID = (*env)-&gt;GetFieldID(env, jCcmParamsClass, &quot;macLen&quot;, &quot;J&quot;);
1125     if (fieldID == NULL) { return NULL; }
1126     jMacLen = (*env)-&gt;GetLongField(env, jParam, fieldID);
1127 
1128     // allocate memory for CK_CCM_PARAMS pointer
1129     ckParamPtr = calloc(1, sizeof(CK_CCM_PARAMS));
1130     if (ckParamPtr == NULL) {
1131         throwOutOfMemoryError(env, 0);
1132         return NULL;
1133     }
1134 
1135     // populate using java values
1136     ckParamPtr-&gt;ulDataLen = jLongToCKULong(jDataLen);
1137     jByteArrayToCKByteArray(env, jNonce, &amp;(ckParamPtr-&gt;pNonce),
1138             &amp;(ckParamPtr-&gt;ulNonceLen));
1139     if ((*env)-&gt;ExceptionCheck(env)) {
1140         goto cleanup;
1141     }
1142 
1143     jByteArrayToCKByteArray(env, jAad, &amp;(ckParamPtr-&gt;pAAD),
1144             &amp;(ckParamPtr-&gt;ulAADLen));
1145     if ((*env)-&gt;ExceptionCheck(env)) {
1146         goto cleanup;
1147     }
1148 
1149     ckParamPtr-&gt;ulMACLen = jLongToCKULong(jMacLen);
1150 
1151     if (pLength != NULL) {
1152         *pLength = sizeof(CK_CCM_PARAMS);
1153     }
1154     return ckParamPtr;
1155 cleanup:
1156     free(ckParamPtr-&gt;pNonce);
1157     free(ckParamPtr-&gt;pAAD);
1158     free(ckParamPtr);
1159     return NULL;
1160 }
1161 
1162 /*
1163  * converts a Java CK_MECHANISM object into a CK_MECHANISM pointer
1164  * pointer.
1165  *
1166  * @param env - used to call JNI funktions to get the values out of the Java object
1167  * @param jMech - the Java CK_MECHANISM object to convert
1168  * @return pointer to the new CK_MECHANISM structure
1169  */
1170 CK_MECHANISM_PTR jMechanismToCKMechanismPtr(JNIEnv *env, jobject jMech)
1171 {
1172     CK_MECHANISM_PTR ckpMech;
1173     jlong jMechType = (*env)-&gt;GetLongField(env, jMech, mech_mechanismID);
1174     jobject jParam = (*env)-&gt;GetObjectField(env, jMech, mech_pParameterID);
1175 
1176     /* allocate memory for CK_MECHANISM_PTR */
1177     ckpMech =  (CK_MECHANISM_PTR) calloc(1, sizeof(CK_MECHANISM));
1178     if (ckpMech == NULL) {
1179         throwOutOfMemoryError(env, 0);
1180         return NULL;
1181     }
1182     TRACE1(&quot;DEBUG jMechanismToCKMechanismPtr: allocated mech %p\n&quot;, ckpMech);
1183 
1184     ckpMech-&gt;mechanism = jLongToCKULong(jMechType);
1185 
1186     /* convert the specific Java mechanism parameter object to a pointer to a
1187      *  CK-type mechanism structure
1188      */
1189     if (jParam == NULL) {
1190         ckpMech-&gt;pParameter = NULL;
1191         ckpMech-&gt;ulParameterLen = 0;
1192     } else {
1193         ckpMech-&gt;pParameter = jMechParamToCKMechParamPtr(env, jParam,
1194             ckpMech-&gt;mechanism, &amp;(ckpMech-&gt;ulParameterLen));
1195     }
1196     return ckpMech;
1197 }
1198 
1199 /*
1200  * converts the pValue of a CK_ATTRIBUTE structure into a Java Object by
1201  * checking the type of the attribute. A PKCS#11 attribute value can
1202  * be a CK_ULONG, CK_BYTE[], CK_CHAR[], big integer, CK_BBOOL, CK_UTF8CHAR[],
1203  * CK_DATE or CK_FLAGS that gets converted to a corresponding Java object.
1204  *
1205  * @param env - used to call JNI functions to create the new Java object
1206  * @param ckpAttribute - the pointer to the CK_ATTRIBUTE structure that contains the type
1207  *                       and the pValue to convert
1208  * @return the new Java object of the CK-type pValue
1209  */
1210 jobject ckAttributeValueToJObject(JNIEnv *env, const CK_ATTRIBUTE_PTR ckpAttribute)
1211 {
1212     jint jValueLength;
1213     jobject jValueObject = NULL;
1214 
1215     jValueLength = ckULongToJInt(ckpAttribute-&gt;ulValueLen);
1216 
1217     if ((jValueLength &lt;= 0) || (ckpAttribute-&gt;pValue == NULL)) {
1218         return NULL ;
1219     }
1220 
1221     switch(ckpAttribute-&gt;type) {
1222         case CKA_CLASS:
1223             /* value CK_OBJECT_CLASS, defacto a CK_ULONG */
1224         case CKA_KEY_TYPE:
1225             /* value CK_KEY_TYPE, defacto a CK_ULONG */
1226         case CKA_CERTIFICATE_TYPE:
1227             /* value CK_CERTIFICATE_TYPE, defacto a CK_ULONG */
1228         case CKA_HW_FEATURE_TYPE:
1229             /* value CK_HW_FEATURE_TYPE, defacto a CK_ULONG */
1230         case CKA_MODULUS_BITS:
1231         case CKA_VALUE_BITS:
1232         case CKA_VALUE_LEN:
1233         case CKA_KEY_GEN_MECHANISM:
1234         case CKA_PRIME_BITS:
1235         case CKA_SUB_PRIME_BITS:
1236             /* value CK_ULONG */
1237             jValueObject = ckULongPtrToJLongObject(env, (CK_ULONG*) ckpAttribute-&gt;pValue);
1238             break;
1239 
1240             /* can be CK_BYTE[],CK_CHAR[] or big integer; defacto always CK_BYTE[] */
1241         case CKA_VALUE:
1242         case CKA_OBJECT_ID:
1243         case CKA_SUBJECT:
1244         case CKA_ID:
1245         case CKA_ISSUER:
1246         case CKA_SERIAL_NUMBER:
1247         case CKA_OWNER:
1248         case CKA_AC_ISSUER:
1249         case CKA_ATTR_TYPES:
1250         case CKA_ECDSA_PARAMS:
1251             /* CKA_EC_PARAMS is the same, these two are equivalent */
1252         case CKA_EC_POINT:
1253         case CKA_PRIVATE_EXPONENT:
1254         case CKA_PRIME_1:
1255         case CKA_PRIME_2:
1256         case CKA_EXPONENT_1:
1257         case CKA_EXPONENT_2:
1258         case CKA_COEFFICIENT:
1259             /* value CK_BYTE[] */
1260             jValueObject = ckByteArrayToJByteArray(env, (CK_BYTE*) ckpAttribute-&gt;pValue, jValueLength);
1261             break;
1262 
1263         case CKA_RESET_ON_INIT:
1264         case CKA_HAS_RESET:
1265         case CKA_TOKEN:
1266         case CKA_PRIVATE:
1267         case CKA_MODIFIABLE:
1268         case CKA_DERIVE:
1269         case CKA_LOCAL:
1270         case CKA_ENCRYPT:
1271         case CKA_VERIFY:
1272         case CKA_VERIFY_RECOVER:
1273         case CKA_WRAP:
1274         case CKA_SENSITIVE:
1275         case CKA_SECONDARY_AUTH:
1276         case CKA_DECRYPT:
1277         case CKA_SIGN:
1278         case CKA_SIGN_RECOVER:
1279         case CKA_UNWRAP:
1280         case CKA_EXTRACTABLE:
1281         case CKA_ALWAYS_SENSITIVE:
1282         case CKA_NEVER_EXTRACTABLE:
1283         case CKA_TRUSTED:
1284             /* value CK_BBOOL */
1285             jValueObject = ckBBoolPtrToJBooleanObject(env, (CK_BBOOL*) ckpAttribute-&gt;pValue);
1286             break;
1287 
1288         case CKA_LABEL:
1289         case CKA_APPLICATION:
1290             /* value RFC 2279 (UTF-8) string */
1291             jValueObject = ckUTF8CharArrayToJCharArray(env, (CK_UTF8CHAR*) ckpAttribute-&gt;pValue, jValueLength);
1292             break;
1293 
1294         case CKA_START_DATE:
1295         case CKA_END_DATE:
1296             /* value CK_DATE */
1297             jValueObject = ckDatePtrToJDateObject(env, (CK_DATE*) ckpAttribute-&gt;pValue);
1298             break;
1299 
1300         case CKA_MODULUS:
1301         case CKA_PUBLIC_EXPONENT:
1302         case CKA_PRIME:
1303         case CKA_SUBPRIME:
1304         case CKA_BASE:
1305             /* value big integer, i.e. CK_BYTE[] */
1306             jValueObject = ckByteArrayToJByteArray(env, (CK_BYTE*) ckpAttribute-&gt;pValue, jValueLength);
1307             break;
1308 
1309         case CKA_AUTH_PIN_FLAGS:
1310             jValueObject = ckULongPtrToJLongObject(env, (CK_ULONG*) ckpAttribute-&gt;pValue);
1311             /* value FLAGS, defacto a CK_ULONG */
1312             break;
1313 
1314         case CKA_VENDOR_DEFINED:
1315             /* we make a CK_BYTE[] out of this */
1316             jValueObject = ckByteArrayToJByteArray(env, (CK_BYTE*) ckpAttribute-&gt;pValue, jValueLength);
1317             break;
1318 
1319         // Netscape trust attributes
1320         case CKA_NETSCAPE_TRUST_SERVER_AUTH:
1321         case CKA_NETSCAPE_TRUST_CLIENT_AUTH:
1322         case CKA_NETSCAPE_TRUST_CODE_SIGNING:
1323         case CKA_NETSCAPE_TRUST_EMAIL_PROTECTION:
1324             /* value CK_ULONG */
1325             jValueObject = ckULongPtrToJLongObject(env, (CK_ULONG*) ckpAttribute-&gt;pValue);
1326             break;
1327 
1328         default:
1329             /* we make a CK_BYTE[] out of this */
1330             jValueObject = ckByteArrayToJByteArray(env, (CK_BYTE*) ckpAttribute-&gt;pValue, jValueLength);
1331             break;
1332     }
1333 
1334     return jValueObject ;
1335 }
1336 
1337 /*
1338  * the following functions convert a Java mechanism parameter object to a PKCS#11
1339  * mechanism parameter structure
1340  *
1341  * CK_&lt;Param&gt;_PARAMS j&lt;Param&gt;ParamToCK&lt;Param&gt;Param(JNIEnv *env,
1342  *                                                 jobject jParam);
1343  *
1344  * These functions get a Java object, that must be the right Java mechanism
1345  * object and they return the new PKCS#11 mechanism parameter structure.
1346  * Every field of the Java object is retrieved, gets converted to a corresponding
1347  * PKCS#11 type and is set in the new PKCS#11 structure.
1348  */
1349 
1350 /*
1351  * converts the given Java mechanism parameter to a CK mechanism parameter
1352  * pointer and store the length in bytes in the length variable.
1353  *
1354  * @param env - used to call JNI funktions to get the Java classes and objects
1355  * @param jParam - the Java mechanism parameter object to convert
1356  * @param ckMech - the PKCS#11 mechanism type
1357  * @param ckpLength - the reference of the length in bytes of the new CK mechanism parameter
1358  *                    structure
1359  * @return pointer to the new CK mechanism parameter structure
1360  */
1361 CK_VOID_PTR jMechParamToCKMechParamPtr(JNIEnv *env, jobject jParam,
1362         CK_MECHANISM_TYPE ckMech, CK_ULONG *ckpLength)
1363 {
1364     CK_VOID_PTR ckpParamPtr;
1365     if (jParam == NULL) {
1366         ckpParamPtr = NULL;
1367         *ckpLength = 0;
1368     } else if ((*env)-&gt;IsInstanceOf(env, jParam, jByteArrayClass)) {
1369         jByteArrayToCKByteArray(env, jParam, (CK_BYTE_PTR *) &amp;ckpParamPtr, ckpLength);
1370     } else if ((*env)-&gt;IsInstanceOf(env, jParam, jLongClass)) {
1371         ckpParamPtr = jLongObjectToCKULongPtr(env, jParam);
1372         *ckpLength = sizeof(CK_ULONG);
1373     } else {
1374         ckpParamPtr = jMechParamToCKMechParamPtrSlow(env, jParam, ckMech, ckpLength);
1375     }
1376     return ckpParamPtr;
1377 }
1378 
1379 CK_VOID_PTR jMechParamToCKMechParamPtrSlow(JNIEnv *env, jobject jParam,
1380         CK_MECHANISM_TYPE ckMech, CK_ULONG *ckpLength)
1381 {
1382     CK_VOID_PTR ckpParamPtr = NULL;
1383 
1384     /*
1385      * Most common cases, i.e. NULL/byte[]/long, are already handled by
1386      * jMechParamToCKMechParam before calling this method.
1387      */
1388     TRACE1(&quot;\nDEBUG: jMechParamToCKMechParamPtrSlow, mech=0x%lX\n&quot;, ckMech);
1389 
1390     switch (ckMech) {
1391         case CKM_SSL3_PRE_MASTER_KEY_GEN:
1392         case CKM_TLS_PRE_MASTER_KEY_GEN:
1393             ckpParamPtr = jVersionToCKVersionPtr(env, jParam);
1394             if (ckpParamPtr != NULL) {
1395                 *ckpLength = sizeof(CK_VERSION);
1396             } else {
1397                 *ckpLength = 0;
1398             }
1399             break;
1400         case CKM_SSL3_MASTER_KEY_DERIVE:
1401         case CKM_TLS_MASTER_KEY_DERIVE:
1402         case CKM_SSL3_MASTER_KEY_DERIVE_DH:
1403         case CKM_TLS_MASTER_KEY_DERIVE_DH:
1404             ckpParamPtr = jSsl3MasterKeyDeriveParamToCKSsl3MasterKeyDeriveParamPtr(env, jParam,
1405                     ckpLength);
1406             break;
1407         case CKM_SSL3_KEY_AND_MAC_DERIVE:
1408         case CKM_TLS_KEY_AND_MAC_DERIVE:
1409             ckpParamPtr = jSsl3KeyMatParamToCKSsl3KeyMatParamPtr(env, jParam,
1410                     ckpLength);
1411             break;
1412         case CKM_TLS12_KEY_AND_MAC_DERIVE:
1413             ckpParamPtr = jTls12KeyMatParamToCKTls12KeyMatParamPtr(env, jParam,
1414                     ckpLength);
1415             break;
1416         case CKM_TLS12_MASTER_KEY_DERIVE:
1417         case CKM_TLS12_MASTER_KEY_DERIVE_DH:
1418             ckpParamPtr = jTls12MasterKeyDeriveParamToCKTls12MasterKeyDeriveParamPtr(env, jParam,
1419                     ckpLength);
1420             break;
1421         case CKM_TLS_PRF:
1422         case CKM_NSS_TLS_PRF_GENERAL:
1423             ckpParamPtr = jTlsPrfParamsToCKTlsPrfParamPtr(env, jParam,
1424                     ckpLength);
1425             break;
1426         case CKM_TLS_MAC:
1427             ckpParamPtr = jTlsMacParamsToCKTlsMacParamPtr(env, jParam,
1428                     ckpLength);
1429             break;
1430         case CKM_AES_CTR:
1431             ckpParamPtr = jAesCtrParamsToCKAesCtrParamPtr(env, jParam,
1432                     ckpLength);
1433             break;
1434         case CKM_AES_GCM:
1435             ckpParamPtr = jGCMParamsToCKGCMParamPtr(env, jParam, ckpLength);
1436             break;
1437         case CKM_AES_CCM:
1438             ckpParamPtr = jCCMParamsToCKCCMParamPtr(env, jParam, ckpLength);
1439             break;
1440         case CKM_RSA_PKCS_OAEP:
1441             ckpParamPtr = jRsaPkcsOaepParamToCKRsaPkcsOaepParamPtr(env, jParam, ckpLength);
1442             break;
1443         case CKM_PBE_SHA1_DES3_EDE_CBC:
1444         case CKM_PBE_SHA1_DES2_EDE_CBC:
1445         case CKM_PBA_SHA1_WITH_SHA1_HMAC:
1446             ckpParamPtr = jPbeParamToCKPbeParamPtr(env, jParam, ckpLength);
1447             break;
1448         case CKM_PKCS5_PBKD2:
1449             ckpParamPtr = jPkcs5Pbkd2ParamToCKPkcs5Pbkd2ParamPtr(env, jParam, ckpLength);
1450             break;
1451         case CKM_RSA_PKCS_PSS:
1452         case CKM_SHA1_RSA_PKCS_PSS:
1453         case CKM_SHA256_RSA_PKCS_PSS:
1454         case CKM_SHA384_RSA_PKCS_PSS:
1455         case CKM_SHA512_RSA_PKCS_PSS:
1456         case CKM_SHA224_RSA_PKCS_PSS:
1457             ckpParamPtr = jRsaPkcsPssParamToCKRsaPkcsPssParamPtr(env, jParam, ckpLength);
1458             break;
1459         case CKM_ECDH1_DERIVE:
1460         case CKM_ECDH1_COFACTOR_DERIVE:
1461             ckpParamPtr = jEcdh1DeriveParamToCKEcdh1DeriveParamPtr(env, jParam, ckpLength);
1462             break;
1463         case CKM_ECMQV_DERIVE:
1464             ckpParamPtr = jEcdh2DeriveParamToCKEcdh2DeriveParamPtr(env, jParam, ckpLength);
1465             break;
1466         case CKM_X9_42_DH_DERIVE:
1467             ckpParamPtr = jX942Dh1DeriveParamToCKX942Dh1DeriveParamPtr(env, jParam, ckpLength);
1468             break;
1469         case CKM_X9_42_DH_HYBRID_DERIVE:
1470         case CKM_X9_42_MQV_DERIVE:
1471             ckpParamPtr = jX942Dh2DeriveParamToCKX942Dh2DeriveParamPtr(env, jParam, ckpLength);
1472             break;
1473         // defined by pkcs11.h but we don&#39;t support
1474         case CKM_KEA_DERIVE: // CK_KEA_DERIVE_PARAMS
1475         case CKM_RC2_CBC: // CK_RC2_CBC_PARAMS
1476         case CKM_RC2_MAC_GENERAL: // CK_RC2_MAC_GENERAL_PARAMS
1477         case CKM_RC5_ECB: // CK_RC5_PARAMS
1478         case CKM_RC5_MAC: // CK_RC5_PARAMS
1479         case CKM_RC5_CBC: // CK_RC5_CBC_PARAMS
1480         case CKM_RC5_MAC_GENERAL: // CK_RC5_MAC_GENERAL_PARAMS
1481         case CKM_SKIPJACK_PRIVATE_WRAP: // CK_SKIPJACK_PRIVATE_WRAP_PARAMS
1482         case CKM_SKIPJACK_RELAYX: // CK_SKIPJACK_RELAYX_PARAMS
1483         case CKM_KEY_WRAP_SET_OAEP: // CK_KEY_WRAP_SET_OAEP_PARAMS
1484             throwPKCS11RuntimeException(env, &quot;No parameter support for this mchanism&quot;);
1485             break;
1486         default:
1487             /* if everything faild up to here */
1488             /* try if the parameter is a primitive Java type */
1489             ckpParamPtr = jObjectToPrimitiveCKObjectPtr(env, jParam, ckpLength);
1490             /* *ckpParamPtr = jObjectToCKVoidPtr(jParam); */
1491             /* *ckpLength = 1; */
1492     }
1493     TRACE0(&quot;\nDEBUG: jMechParamToCKMechParamPtrSlow FINISHED\n&quot;);
1494 
1495     if ((*env)-&gt;ExceptionCheck(env)) {
1496         return NULL;
1497     }
1498 
1499     return ckpParamPtr;
1500 }
1501 
1502 /*
1503  * converts the Java CK_RSA_PKCS_OAEP_PARAMS object to a
1504  * CK_RSA_PKCS_OAEP_PARAMS pointer
1505  *
1506  * @param env - used to call JNI funktions to get the Java classes and objects
1507  * @param jParam - the Java CK_RSA_PKCS_OAEP_PARAMS object to convert
1508  * @param pLength - length of the allocated memory of the returned pointer
1509  * @return pointer to the new CK_RSA_PKCS_OAEP_PARAMS structure
1510  */
1511 CK_RSA_PKCS_OAEP_PARAMS_PTR
1512 jRsaPkcsOaepParamToCKRsaPkcsOaepParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
1513 {
1514     CK_RSA_PKCS_OAEP_PARAMS_PTR ckParamPtr;
1515     jclass jRsaPkcsOaepParamsClass;
1516     jfieldID fieldID;
1517     jlong jHashAlg, jMgf, jSource;
1518     jobject jSourceData;
1519 
1520     if (pLength!= NULL) {
1521         *pLength = 0L;
1522     }
1523 
1524     // retrieve java values
1525     jRsaPkcsOaepParamsClass = (*env)-&gt;FindClass(env, CLASS_RSA_PKCS_OAEP_PARAMS);
1526     if (jRsaPkcsOaepParamsClass == NULL) { return NULL; }
1527     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsOaepParamsClass, &quot;hashAlg&quot;, &quot;J&quot;);
1528     if (fieldID == NULL) { return NULL; }
1529     jHashAlg = (*env)-&gt;GetLongField(env, jParam, fieldID);
1530     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsOaepParamsClass, &quot;mgf&quot;, &quot;J&quot;);
1531     if (fieldID == NULL) { return NULL; }
1532     jMgf = (*env)-&gt;GetLongField(env, jParam, fieldID);
1533     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsOaepParamsClass, &quot;source&quot;, &quot;J&quot;);
1534     if (fieldID == NULL) { return NULL; }
1535     jSource = (*env)-&gt;GetLongField(env, jParam, fieldID);
1536     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsOaepParamsClass, &quot;pSourceData&quot;, &quot;[B&quot;);
1537     if (fieldID == NULL) { return NULL; }
1538     jSourceData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1539 
1540     // allocate memory for CK_RSA_PKCS_OAEP_PARAMS pointer
1541     ckParamPtr = calloc(1, sizeof(CK_RSA_PKCS_OAEP_PARAMS));
1542     if (ckParamPtr == NULL) {
1543         throwOutOfMemoryError(env, 0);
1544         return NULL;
1545     }
1546 
1547     // populate using java values
1548     ckParamPtr-&gt;hashAlg = jLongToCKULong(jHashAlg);
1549     ckParamPtr-&gt;mgf = jLongToCKULong(jMgf);
1550     ckParamPtr-&gt;source = jLongToCKULong(jSource);
1551     jByteArrayToCKByteArray(env, jSourceData, (CK_BYTE_PTR*) &amp;(ckParamPtr-&gt;pSourceData),
1552             &amp;(ckParamPtr-&gt;ulSourceDataLen));
1553     if ((*env)-&gt;ExceptionCheck(env)) {
1554         free(ckParamPtr);
1555         return NULL;
1556     }
1557 
1558     if (pLength!= NULL) {
1559         *pLength = sizeof(CK_RSA_PKCS_OAEP_PARAMS);
1560     }
1561     return ckParamPtr;
1562 }
1563 
1564 /*
1565  * converts the Java CK_PBE_PARAMS object to a CK_PBE_PARAMS pointer
1566  *
1567  * @param env - used to call JNI funktions to get the Java classes and objects
1568  * @param jParam - the Java CK_PBE_PARAMS object to convert
1569  * @param pLength - length of the allocated memory of the returned pointer
1570  * @return pointer to the new CK_PBE_PARAMS structure
1571  */
1572 CK_PBE_PARAMS_PTR
1573 jPbeParamToCKPbeParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
1574 {
1575     CK_PBE_PARAMS_PTR ckParamPtr;
1576     jclass jPbeParamsClass;
1577     jfieldID fieldID;
1578     jlong jIteration;
1579     jobject jInitVector, jPassword, jSalt;
1580     CK_ULONG ckTemp;
1581 
1582     if (pLength != NULL) {
1583         *pLength = 0;
1584     }
1585 
1586     // retrieve java values
1587     jPbeParamsClass = (*env)-&gt;FindClass(env, CLASS_PBE_PARAMS);
1588     if (jPbeParamsClass == NULL) { return NULL; }
1589     fieldID = (*env)-&gt;GetFieldID(env, jPbeParamsClass, &quot;pInitVector&quot;, &quot;[C&quot;);
1590     if (fieldID == NULL) { return NULL; }
1591     jInitVector = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1592     fieldID = (*env)-&gt;GetFieldID(env, jPbeParamsClass, &quot;pPassword&quot;, &quot;[C&quot;);
1593     if (fieldID == NULL) { return NULL; }
1594     jPassword = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1595     fieldID = (*env)-&gt;GetFieldID(env, jPbeParamsClass, &quot;pSalt&quot;, &quot;[C&quot;);
1596     if (fieldID == NULL) { return NULL; }
1597     jSalt = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1598     fieldID = (*env)-&gt;GetFieldID(env, jPbeParamsClass, &quot;ulIteration&quot;, &quot;J&quot;);
1599     if (fieldID == NULL) { return NULL; }
1600     jIteration = (*env)-&gt;GetLongField(env, jParam, fieldID);
1601 
1602     // allocate memory for CK_PBE_PARAMS pointer
1603     ckParamPtr = calloc(1, sizeof(CK_PBE_PARAMS));
1604     if (ckParamPtr == NULL) {
1605         throwOutOfMemoryError(env, 0);
1606         return NULL;
1607     }
1608 
1609     // populate using java values
1610     ckParamPtr-&gt;ulIteration = jLongToCKULong(jIteration);
1611     jCharArrayToCKCharArray(env, jInitVector, &amp;(ckParamPtr-&gt;pInitVector), &amp;ckTemp);
1612     if ((*env)-&gt;ExceptionCheck(env)) {
1613         goto cleanup;
1614     }
1615     jCharArrayToCKCharArray(env, jPassword, &amp;(ckParamPtr-&gt;pPassword), &amp;(ckParamPtr-&gt;ulPasswordLen));
1616     if ((*env)-&gt;ExceptionCheck(env)) {
1617         goto cleanup;
1618     }
1619     jCharArrayToCKCharArray(env, jSalt, &amp;(ckParamPtr-&gt;pSalt), &amp;(ckParamPtr-&gt;ulSaltLen));
1620     if ((*env)-&gt;ExceptionCheck(env)) {
1621         goto cleanup;
1622     }
1623 
1624     if (pLength != NULL) {
1625         *pLength = sizeof(CK_PBE_PARAMS);
1626     }
1627     return ckParamPtr;
1628 cleanup:
1629     free(ckParamPtr-&gt;pInitVector);
1630     free(ckParamPtr-&gt;pPassword);
1631     free(ckParamPtr-&gt;pSalt);
1632     free(ckParamPtr);
1633     return NULL;
1634 }
1635 
1636 /*
1637  * Copy back the initialization vector from the native structure to the
1638  * Java object. This is only used for CKM_PBE_* mechanisms and their
1639  * CK_PBE_PARAMS parameters.
1640  *
1641  */
1642 void copyBackPBEInitializationVector(JNIEnv *env, CK_MECHANISM *ckMechanism, jobject jMechanism)
1643 {
1644     jclass jMechanismClass, jPbeParamsClass;
1645     CK_PBE_PARAMS *ckParam;
1646     jfieldID fieldID;
1647     CK_MECHANISM_TYPE ckMechanismType;
1648     jlong jMechanismType;
1649     jobject jParameter;
1650     jobject jInitVector;
1651     jint jInitVectorLength;
1652     CK_CHAR_PTR initVector;
1653     int i;
1654     jchar* jInitVectorChars;
1655 
1656     /* get mechanism */
1657     jMechanismClass = (*env)-&gt;FindClass(env, CLASS_MECHANISM);
1658     if (jMechanismClass == NULL) { return; }
1659     fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;mechanism&quot;, &quot;J&quot;);
1660     if (fieldID == NULL) { return; }
1661     jMechanismType = (*env)-&gt;GetLongField(env, jMechanism, fieldID);
1662     ckMechanismType = jLongToCKULong(jMechanismType);
1663     if (ckMechanismType != ckMechanism-&gt;mechanism) {
1664         /* we do not have matching types, this should not occur */
1665         return;
1666     }
1667 
1668     jPbeParamsClass = (*env)-&gt;FindClass(env, CLASS_PBE_PARAMS);
1669     if (jPbeParamsClass == NULL) { return; }
1670     ckParam = (CK_PBE_PARAMS *) ckMechanism-&gt;pParameter;
1671     if (ckParam != NULL_PTR) {
1672         initVector = ckParam-&gt;pInitVector;
1673         if (initVector != NULL_PTR) {
1674             /* get pParameter */
1675             fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;pParameter&quot;, &quot;Ljava/lang/Object;&quot;);
1676             if (fieldID == NULL) { return; }
1677             jParameter = (*env)-&gt;GetObjectField(env, jMechanism, fieldID);
1678             fieldID = (*env)-&gt;GetFieldID(env, jPbeParamsClass, &quot;pInitVektor&quot;, &quot;[C&quot;);
1679             if (fieldID == NULL) { return; }
1680             jInitVector = (*env)-&gt;GetObjectField(env, jParameter, fieldID);
1681 
1682             if (jInitVector != NULL) {
1683                 jInitVectorLength = (*env)-&gt;GetArrayLength(env, jInitVector);
1684                 jInitVectorChars = (*env)-&gt;GetCharArrayElements(env, jInitVector, NULL);
1685                 if (jInitVectorChars == NULL) { return; }
1686 
1687                 /* copy the chars to the Java buffer */
1688                 for (i=0; i &lt; jInitVectorLength; i++) {
1689                     jInitVectorChars[i] = ckCharToJChar(initVector[i]);
1690                 }
1691                 /* copy back the Java buffer to the object */
1692                 (*env)-&gt;ReleaseCharArrayElements(env, jInitVector, jInitVectorChars, 0);
1693             }
1694         }
1695     }
1696 }
1697 
1698 /*
1699  * converts the Java CK_PKCS5_PBKD2_PARAMS object to a CK_PKCS5_PBKD2_PARAMS
1700  * pointer
1701  *
1702  * @param env - used to call JNI funktions to get the Java classes and objects
1703  * @param jParam - the Java CK_PKCS5_PBKD2_PARAMS object to convert
1704  * @param pLength - length of the allocated memory of the returned pointer
1705  * @return pointer to the new CK_PKCS5_PBKD2_PARAMS structure
1706  */
1707 CK_PKCS5_PBKD2_PARAMS_PTR
1708 jPkcs5Pbkd2ParamToCKPkcs5Pbkd2ParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
1709 {
1710     CK_PKCS5_PBKD2_PARAMS_PTR ckParamPtr;
1711     jclass jPkcs5Pbkd2ParamsClass;
1712     jfieldID fieldID;
1713     jlong jSaltSource, jIteration, jPrf;
1714     jobject jSaltSourceData, jPrfData;
1715 
1716     if (pLength != NULL) {
1717         *pLength = 0L;
1718     }
1719 
1720     // retrieve java values
1721     jPkcs5Pbkd2ParamsClass = (*env)-&gt;FindClass(env, CLASS_PKCS5_PBKD2_PARAMS);
1722     if (jPkcs5Pbkd2ParamsClass == NULL) { return NULL; }
1723     fieldID = (*env)-&gt;GetFieldID(env, jPkcs5Pbkd2ParamsClass, &quot;saltSource&quot;, &quot;J&quot;);
1724     if (fieldID == NULL) { return NULL; }
1725     jSaltSource = (*env)-&gt;GetLongField(env, jParam, fieldID);
1726     fieldID = (*env)-&gt;GetFieldID(env, jPkcs5Pbkd2ParamsClass, &quot;pSaltSourceData&quot;, &quot;[B&quot;);
1727     if (fieldID == NULL) { return NULL; }
1728     jSaltSourceData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1729     fieldID = (*env)-&gt;GetFieldID(env, jPkcs5Pbkd2ParamsClass, &quot;iterations&quot;, &quot;J&quot;);
1730     if (fieldID == NULL) { return NULL; }
1731     jIteration = (*env)-&gt;GetLongField(env, jParam, fieldID);
1732     fieldID = (*env)-&gt;GetFieldID(env, jPkcs5Pbkd2ParamsClass, &quot;prf&quot;, &quot;J&quot;);
1733     if (fieldID == NULL) { return NULL; }
1734     jPrf = (*env)-&gt;GetLongField(env, jParam, fieldID);
1735     fieldID = (*env)-&gt;GetFieldID(env, jPkcs5Pbkd2ParamsClass, &quot;pPrfData&quot;, &quot;[B&quot;);
1736     if (fieldID == NULL) { return NULL; }
1737     jPrfData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1738 
1739     // allocate memory for CK_PKCS5_PBKD2_PARAMS pointer
1740     ckParamPtr = calloc(1, sizeof(CK_PKCS5_PBKD2_PARAMS));
1741     if (ckParamPtr == NULL) {
1742         throwOutOfMemoryError(env, 0);
1743         return NULL;
1744     }
1745 
1746     // populate using java values
1747     ckParamPtr-&gt;saltSource = jLongToCKULong(jSaltSource);
1748     jByteArrayToCKByteArray(env, jSaltSourceData, (CK_BYTE_PTR *)
1749             &amp;(ckParamPtr-&gt;pSaltSourceData), &amp;(ckParamPtr-&gt;ulSaltSourceDataLen));
1750     if ((*env)-&gt;ExceptionCheck(env)) {
1751         goto cleanup;
1752     }
1753     ckParamPtr-&gt;iterations = jLongToCKULong(jIteration);
1754     ckParamPtr-&gt;prf = jLongToCKULong(jPrf);
1755     jByteArrayToCKByteArray(env, jPrfData, (CK_BYTE_PTR *)
1756             &amp;(ckParamPtr-&gt;pPrfData), &amp;(ckParamPtr-&gt;ulPrfDataLen));
1757     if ((*env)-&gt;ExceptionCheck(env)) {
1758         goto cleanup;
1759     }
1760 
1761     if (pLength != NULL) {
1762         *pLength = sizeof(CK_PKCS5_PBKD2_PARAMS);
1763     }
1764     return ckParamPtr;
1765 cleanup:
1766     free(ckParamPtr-&gt;pSaltSourceData);
1767     free(ckParamPtr-&gt;pPrfData);
1768     free(ckParamPtr);
1769     return NULL;
1770 
1771 }
1772 
1773 /*
1774  * converts the Java CK_RSA_PKCS_PSS_PARAMS object to a CK_RSA_PKCS_PSS_PARAMS
1775  * pointer
1776  *
1777  * @param env - used to call JNI funktions to get the Java classes and objects
1778  * @param jParam - the Java CK_RSA_PKCS_PSS_PARAMS object to convert
1779  * @param pLength - length of the allocated memory of the returned pointer
1780  * @return pointer to the new CK_RSA_PKCS_PSS_PARAMS structure
1781  */
1782 CK_RSA_PKCS_PSS_PARAMS_PTR
1783 jRsaPkcsPssParamToCKRsaPkcsPssParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
1784 {
1785     CK_RSA_PKCS_PSS_PARAMS_PTR ckParamPtr;
1786     jclass jRsaPkcsPssParamsClass;
1787     jfieldID fieldID;
1788     jlong jHashAlg, jMgf, jSLen;
1789 
1790     if (pLength != NULL) {
1791         *pLength = 0;
1792     }
1793 
1794     // retrieve java values
1795     jRsaPkcsPssParamsClass = (*env)-&gt;FindClass(env, CLASS_RSA_PKCS_PSS_PARAMS);
1796     if (jRsaPkcsPssParamsClass == NULL) { return NULL; }
1797     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsPssParamsClass, &quot;hashAlg&quot;, &quot;J&quot;);
1798     if (fieldID == NULL) { return NULL; }
1799     jHashAlg = (*env)-&gt;GetLongField(env, jParam, fieldID);
1800     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsPssParamsClass, &quot;mgf&quot;, &quot;J&quot;);
1801     if (fieldID == NULL) { return NULL; }
1802     jMgf = (*env)-&gt;GetLongField(env, jParam, fieldID);
1803     fieldID = (*env)-&gt;GetFieldID(env, jRsaPkcsPssParamsClass, &quot;sLen&quot;, &quot;J&quot;);
1804     if (fieldID == NULL) { return NULL; }
1805     jSLen = (*env)-&gt;GetLongField(env, jParam, fieldID);
1806 
1807     // allocate memory for CK_RSA_PKCS_PSS_PARAMS pointer
1808     ckParamPtr = calloc(1, sizeof(CK_RSA_PKCS_PSS_PARAMS));
1809     if (ckParamPtr == NULL) {
1810         throwOutOfMemoryError(env, 0);
1811         return NULL;
1812     }
1813 
1814     // populate using java values
1815     ckParamPtr-&gt;hashAlg = jLongToCKULong(jHashAlg);
1816     ckParamPtr-&gt;mgf = jLongToCKULong(jMgf);
1817     ckParamPtr-&gt;sLen = jLongToCKULong(jSLen);
1818     TRACE1(&quot;DEBUG: jRsaPkcsPssParamToCKRsaPkcsPssParam, hashAlg=0x%lX\n&quot;, ckParamPtr-&gt;hashAlg);
1819     TRACE1(&quot;DEBUG: jRsaPkcsPssParamToCKRsaPkcsPssParam, mgf=0x%lX\n&quot;, ckParamPtr-&gt;mgf);
1820     TRACE1(&quot;DEBUG: jRsaPkcsPssParamToCKRsaPkcsPssParam, sLen=%lu\n&quot;, ckParamPtr-&gt;sLen);
1821 
1822     if (pLength != NULL) {
1823         *pLength = sizeof(CK_RSA_PKCS_PSS_PARAMS);
1824     }
1825     return ckParamPtr;
1826 
1827 }
1828 
1829 /*
1830  * converts the Java CK_ECDH1_DERIVE_PARAMS object to a CK_ECDH1_DERIVE_PARAMS
1831  * pointer
1832  *
1833  * @param env - used to call JNI funktions to get the Java classes and objects
1834  * @param jParam - the Java CK_ECDH1_DERIVE_PARAMS object to convert
1835  * @param pLength - length of the allocated memory of the returned pointer
1836  * @retur pointer to nthe new CK_ECDH1_DERIVE_PARAMS structure
1837  */
1838 CK_ECDH1_DERIVE_PARAMS_PTR
1839 jEcdh1DeriveParamToCKEcdh1DeriveParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
1840 {
1841     CK_ECDH1_DERIVE_PARAMS_PTR ckParamPtr;
1842     jclass jEcdh1DeriveParamsClass;
1843     jfieldID fieldID;
1844     jlong jLong;
1845     jobject jSharedData, jPublicData;
1846 
1847     if (pLength != NULL) {
1848         *pLength = 0;
1849     }
1850 
1851     // retrieve java values
1852     jEcdh1DeriveParamsClass = (*env)-&gt;FindClass(env, CLASS_ECDH1_DERIVE_PARAMS);
1853     if (jEcdh1DeriveParamsClass == NULL) { return NULL; }
1854     fieldID = (*env)-&gt;GetFieldID(env, jEcdh1DeriveParamsClass, &quot;kdf&quot;, &quot;J&quot;);
1855     if (fieldID == NULL) { return NULL; }
1856     jLong = (*env)-&gt;GetLongField(env, jParam, fieldID);
1857     fieldID = (*env)-&gt;GetFieldID(env, jEcdh1DeriveParamsClass, &quot;pSharedData&quot;, &quot;[B&quot;);
1858     if (fieldID == NULL) { return NULL; }
1859     jSharedData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1860     fieldID = (*env)-&gt;GetFieldID(env, jEcdh1DeriveParamsClass, &quot;pPublicData&quot;, &quot;[B&quot;);
1861     if (fieldID == NULL) { return NULL; }
1862     jPublicData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1863 
1864     // allocate memory for CK_ECDH1_DERIVE_PARAMS pointer
1865     ckParamPtr = calloc(1, sizeof(CK_ECDH1_DERIVE_PARAMS));
1866     if (ckParamPtr == NULL) {
1867         throwOutOfMemoryError(env, 0);
1868         return NULL;
1869     }
1870 
1871     // populate using java values
1872     ckParamPtr-&gt;kdf = jLongToCKULong(jLong);
1873     jByteArrayToCKByteArray(env, jSharedData, &amp;(ckParamPtr-&gt;pSharedData),
1874             &amp;(ckParamPtr-&gt;ulSharedDataLen));
1875     if ((*env)-&gt;ExceptionCheck(env)) {
1876         goto cleanup;
1877     }
1878     jByteArrayToCKByteArray(env, jPublicData, &amp;(ckParamPtr-&gt;pPublicData),
1879             &amp;(ckParamPtr-&gt;ulPublicDataLen));
1880     if ((*env)-&gt;ExceptionCheck(env)) {
1881         goto cleanup;
1882     }
1883 
1884     if (pLength != NULL) {
1885         *pLength = sizeof(CK_ECDH1_DERIVE_PARAMS);
1886     }
1887     return ckParamPtr;
1888 cleanup:
1889     free(ckParamPtr-&gt;pSharedData);
1890     free(ckParamPtr-&gt;pPublicData);
1891     free(ckParamPtr);
1892     return NULL;
1893 }
1894 
1895 /*
1896  * converts the Java CK_ECDH2_DERIVE_PARAMS object to a CK_ECDH2_DERIVE_PARAMS
1897  * pointer
1898  *
1899  * @param env - used to call JNI funktions to get the Java classes and objects
1900  * @param jParam - the Java CK_ECDH2_DERIVE_PARAMS object to convert
1901  * @param pLength - length of the allocated memory of the returned pointer
1902  * @return pointer to the new CK_ECDH2_DERIVE_PARAMS structure
1903  */
1904 CK_ECDH2_DERIVE_PARAMS_PTR
1905 jEcdh2DeriveParamToCKEcdh2DeriveParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
1906 {
1907     CK_ECDH2_DERIVE_PARAMS_PTR ckParamPtr;
1908     jclass jEcdh2DeriveParamsClass;
1909     jfieldID fieldID;
1910     jlong jKdf, jPrivateDataLen, jPrivateData;
1911     jobject jSharedData, jPublicData, jPublicData2;
1912 
1913     // retrieve java values
1914     jEcdh2DeriveParamsClass = (*env)-&gt;FindClass(env, CLASS_ECDH2_DERIVE_PARAMS);
1915     if (jEcdh2DeriveParamsClass == NULL) { return NULL; }
1916     fieldID = (*env)-&gt;GetFieldID(env, jEcdh2DeriveParamsClass, &quot;kdf&quot;, &quot;J&quot;);
1917     if (fieldID == NULL) { return NULL; }
1918     jKdf = (*env)-&gt;GetLongField(env, jParam, fieldID);
1919     fieldID = (*env)-&gt;GetFieldID(env, jEcdh2DeriveParamsClass, &quot;pSharedData&quot;, &quot;[B&quot;);
1920     if (fieldID == NULL) { return NULL; }
1921     jSharedData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1922     fieldID = (*env)-&gt;GetFieldID(env, jEcdh2DeriveParamsClass, &quot;pPublicData&quot;, &quot;[B&quot;);
1923     if (fieldID == NULL) { return NULL; }
1924     jPublicData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1925     fieldID = (*env)-&gt;GetFieldID(env, jEcdh2DeriveParamsClass, &quot;ulPrivateDataLen&quot;, &quot;J&quot;);
1926     if (fieldID == NULL) { return NULL; }
1927     jPrivateDataLen = (*env)-&gt;GetLongField(env, jParam, fieldID);
1928     fieldID = (*env)-&gt;GetFieldID(env, jEcdh2DeriveParamsClass, &quot;hPrivateData&quot;, &quot;J&quot;);
1929     if (fieldID == NULL) { return NULL; }
1930     jPrivateData = (*env)-&gt;GetLongField(env, jParam, fieldID);
1931     fieldID = (*env)-&gt;GetFieldID(env, jEcdh2DeriveParamsClass, &quot;pPublicData2&quot;, &quot;[B&quot;);
1932     if (fieldID == NULL) { return NULL; }
1933     jPublicData2 = (*env)-&gt;GetObjectField(env, jParam, fieldID);
1934 
1935     // allocate memory for CK_ECDH2_DERIVE_PARAMS pointer
1936     ckParamPtr = calloc(1, sizeof(CK_ECDH2_DERIVE_PARAMS));
1937     if (ckParamPtr == NULL) {
1938         throwOutOfMemoryError(env, 0);
1939         return NULL;
1940     }
1941 
1942     // populate using java values
1943     ckParamPtr-&gt;kdf = jLongToCKULong(jKdf);
1944     jByteArrayToCKByteArray(env, jSharedData, &amp;(ckParamPtr-&gt;pSharedData),
1945             &amp;(ckParamPtr-&gt;ulSharedDataLen));
1946     if ((*env)-&gt;ExceptionCheck(env)) {
1947         goto cleanup;
1948     }
1949     jByteArrayToCKByteArray(env, jPublicData, &amp;(ckParamPtr-&gt;pPublicData),
1950             &amp;(ckParamPtr-&gt;ulPublicDataLen));
1951     if ((*env)-&gt;ExceptionCheck(env)) {
1952         goto cleanup;
1953     }
1954     ckParamPtr-&gt;ulPrivateDataLen = jLongToCKULong(jPrivateDataLen);
1955     ckParamPtr-&gt;hPrivateData = jLongToCKULong(jPrivateData);
1956     jByteArrayToCKByteArray(env, jPublicData2, &amp;(ckParamPtr-&gt;pPublicData2),
1957             &amp;(ckParamPtr-&gt;ulPublicDataLen2));
1958     if ((*env)-&gt;ExceptionCheck(env)) {
1959         goto cleanup;
1960     }
1961 
1962     if (pLength != NULL) {
1963         *pLength = sizeof(CK_ECDH2_DERIVE_PARAMS);
1964     }
1965     return ckParamPtr;
1966 cleanup:
1967     free(ckParamPtr-&gt;pSharedData);
1968     free(ckParamPtr-&gt;pPublicData);
1969     free(ckParamPtr-&gt;pPublicData2);
1970     free(ckParamPtr);
1971     return NULL;
1972 }
1973 
1974 /*
1975  * converts the Java CK_X9_42_DH1_DERIVE_PARAMS object to a
1976  * CK_X9_42_DH1_DERIVE_PARAMS pointer
1977  *
1978  * @param env - used to call JNI funktions to get the Java classes and objects
1979  * @param jParam - the Java CK_X9_42_DH1_DERIVE_PARAMS object to convert
1980  * @param pLength - length of the allocated memory of the returned pointer
1981  * @return pointer to the new CK_X9_42_DH1_DERIVE_PARAMS structure
1982  */
1983 CK_X9_42_DH1_DERIVE_PARAMS_PTR
1984 jX942Dh1DeriveParamToCKX942Dh1DeriveParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
1985 {
1986     CK_X9_42_DH1_DERIVE_PARAMS_PTR ckParamPtr;
1987     jclass jX942Dh1DeriveParamsClass;
1988     jfieldID fieldID;
1989     jlong jKdf;
1990     jobject jOtherInfo, jPublicData;
1991 
1992     if (pLength != NULL) {
1993         *pLength = 0;
1994     }
1995 
1996     // retrieve java values
1997     jX942Dh1DeriveParamsClass = (*env)-&gt;FindClass(env, CLASS_X9_42_DH1_DERIVE_PARAMS);
1998     if (jX942Dh1DeriveParamsClass == NULL) { return NULL; }
1999     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh1DeriveParamsClass, &quot;kdf&quot;, &quot;J&quot;);
2000     if (fieldID == NULL) { return NULL; }
2001     jKdf = (*env)-&gt;GetLongField(env, jParam, fieldID);
2002     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh1DeriveParamsClass, &quot;pOtherInfo&quot;, &quot;[B&quot;);
2003     if (fieldID == NULL) { return NULL; }
2004     jOtherInfo = (*env)-&gt;GetObjectField(env, jParam, fieldID);
2005     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh1DeriveParamsClass, &quot;pPublicData&quot;, &quot;[B&quot;);
2006     if (fieldID == NULL) { return NULL; }
2007     jPublicData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
2008 
2009     // allocate memory for CK_X9_42_DH1_DERIVE_PARAMS pointer
2010     ckParamPtr = calloc(1, sizeof(CK_X9_42_DH1_DERIVE_PARAMS));
2011     if (ckParamPtr == NULL) {
2012         throwOutOfMemoryError(env, 0);
2013         return NULL;
2014     }
2015 
2016     // populate using java values
2017     ckParamPtr-&gt;kdf = jLongToCKULong(jKdf);
2018     jByteArrayToCKByteArray(env, jOtherInfo, &amp;(ckParamPtr-&gt;pOtherInfo),
2019             &amp;(ckParamPtr-&gt;ulOtherInfoLen));
2020     if ((*env)-&gt;ExceptionCheck(env)) {
2021         goto cleanup;
2022     }
2023     jByteArrayToCKByteArray(env, jPublicData, &amp;(ckParamPtr-&gt;pPublicData),
2024             &amp;(ckParamPtr-&gt;ulPublicDataLen));
2025     if ((*env)-&gt;ExceptionCheck(env)) {
2026         goto cleanup;
2027     }
2028 
2029     if (pLength != NULL) {
2030         *pLength = sizeof(CK_X9_42_DH1_DERIVE_PARAMS);
2031     }
2032     return ckParamPtr;
2033 cleanup:
2034     free(ckParamPtr-&gt;pOtherInfo);
2035     free(ckParamPtr-&gt;pPublicData);
2036     free(ckParamPtr);
2037     return NULL;
2038 }
2039 
2040 /*
2041  * converts the Java CK_X9_42_DH2_DERIVE_PARAMS object to a
2042  * CK_X9_42_DH2_DERIVE_PARAMS pointer
2043  *
2044  * @param env - used to call JNI funktions to get the Java classes and objects
2045  * @param jParam - the Java CK_X9_42_DH2_DERIVE_PARAMS object to convert
2046  * @param pLength - length of the allocated memory of the returned pointer
2047  * @return pointer to the new CK_X9_42_DH2_DERIVE_PARAMS structure
2048  */
2049 CK_X9_42_DH2_DERIVE_PARAMS_PTR
2050 jX942Dh2DeriveParamToCKX942Dh2DeriveParamPtr(JNIEnv *env, jobject jParam, CK_ULONG *pLength)
2051 {
2052     CK_X9_42_DH2_DERIVE_PARAMS_PTR ckParamPtr;
2053     jclass jX942Dh2DeriveParamsClass;
2054     jfieldID fieldID;
2055     jlong jKdf, jPrivateDataLen, jPrivateData;
2056     jobject jOtherInfo, jPublicData, jPublicData2;
2057 
2058     if (pLength != NULL) {
2059         *pLength = 0L;
2060     }
2061 
2062     // retrieve java values
2063     jX942Dh2DeriveParamsClass = (*env)-&gt;FindClass(env, CLASS_X9_42_DH2_DERIVE_PARAMS);
2064     if (jX942Dh2DeriveParamsClass == NULL) { return NULL; }
2065     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh2DeriveParamsClass, &quot;kdf&quot;, &quot;J&quot;);
2066     if (fieldID == NULL) { return NULL; }
2067     jKdf = (*env)-&gt;GetLongField(env, jParam, fieldID);
2068     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh2DeriveParamsClass, &quot;pOtherInfo&quot;, &quot;[B&quot;);
2069     if (fieldID == NULL) { return NULL; }
2070     jOtherInfo = (*env)-&gt;GetObjectField(env, jParam, fieldID);
2071     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh2DeriveParamsClass, &quot;pPublicData&quot;, &quot;[B&quot;);
2072     if (fieldID == NULL) { return NULL; }
2073     jPublicData = (*env)-&gt;GetObjectField(env, jParam, fieldID);
2074     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh2DeriveParamsClass, &quot;ulPrivateDataLen&quot;, &quot;J&quot;);
2075     if (fieldID == NULL) { return NULL; }
2076     jPrivateDataLen = (*env)-&gt;GetLongField(env, jParam, fieldID);
2077     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh2DeriveParamsClass, &quot;hPrivateData&quot;, &quot;J&quot;);
2078     if (fieldID == NULL) { return NULL; }
2079     jPrivateData = (*env)-&gt;GetLongField(env, jParam, fieldID);
2080     fieldID = (*env)-&gt;GetFieldID(env, jX942Dh2DeriveParamsClass, &quot;pPublicData2&quot;, &quot;[B&quot;);
2081     if (fieldID == NULL) { return NULL; }
2082     jPublicData2 = (*env)-&gt;GetObjectField(env, jParam, fieldID);
2083 
2084     // allocate memory for CK_DATE pointer
2085     ckParamPtr = calloc(1, sizeof(CK_X9_42_DH2_DERIVE_PARAMS));
2086     if (ckParamPtr == NULL) {
2087         throwOutOfMemoryError(env, 0);
2088         return NULL;
2089     }
2090 
2091     // populate using java values
2092     ckParamPtr-&gt;kdf = jLongToCKULong(jKdf);
2093     jByteArrayToCKByteArray(env, jOtherInfo, &amp;(ckParamPtr-&gt;pOtherInfo),
2094             &amp;(ckParamPtr-&gt;ulOtherInfoLen));
2095     if ((*env)-&gt;ExceptionCheck(env)) {
2096         goto cleanup;
2097     }
2098     jByteArrayToCKByteArray(env, jPublicData, &amp;(ckParamPtr-&gt;pPublicData),
2099             &amp;(ckParamPtr-&gt;ulPublicDataLen));
2100     if ((*env)-&gt;ExceptionCheck(env)) {
2101         goto cleanup;
2102     }
2103     ckParamPtr-&gt;ulPrivateDataLen = jLongToCKULong(jPrivateDataLen);
2104     ckParamPtr-&gt;hPrivateData = jLongToCKULong(jPrivateData);
2105     jByteArrayToCKByteArray(env, jPublicData2, &amp;(ckParamPtr-&gt;pPublicData2),
2106             &amp;(ckParamPtr-&gt;ulPublicDataLen2));
2107     if ((*env)-&gt;ExceptionCheck(env)) {
2108         goto cleanup;
2109     }
2110 
2111     if (pLength != NULL) {
2112         *pLength = sizeof(CK_X9_42_DH2_DERIVE_PARAMS);
2113     }
2114     return ckParamPtr;
2115 cleanup:
2116     free(ckParamPtr-&gt;pOtherInfo);
2117     free(ckParamPtr-&gt;pPublicData);
2118     free(ckParamPtr-&gt;pPublicData2);
2119     free(ckParamPtr);
2120     return NULL;
2121 }
    </pre>
  </body>
</html>
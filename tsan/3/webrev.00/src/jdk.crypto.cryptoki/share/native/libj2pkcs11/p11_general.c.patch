diff a/src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_general.c b/src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_general.c
--- a/src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_general.c
+++ b/src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_general.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  */
 
 /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
  *
  * Redistribution and use in  source and binary forms, with or without
@@ -49,10 +49,11 @@
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
+#include "jlong.h"
 
 #include "sun_security_pkcs11_wrapper_PKCS11.h"
 
 /* declare file private functions */
 
@@ -65,10 +66,11 @@
 /* define variables */
 
 jfieldID pNativeDataID;
 jfieldID mech_mechanismID;
 jfieldID mech_pParameterID;
+jfieldID mech_pHandleID;
 
 jclass jByteArrayClass;
 jclass jLongClass;
 
 JavaVM* jvm = NULL;
@@ -82,10 +84,27 @@
 
 /* ************************************************************************** */
 /* The native implementation of the methods of the PKCS11Implementation class */
 /* ************************************************************************** */
 
+/*
+ * This method is used to do free the memory allocated for CK_MECHANISM structure.
+ *
+ * Class:     sun_security_pkcs11_wrapper_PKCS11
+ * Method:    freeMechanism
+ * Signature: (J)J
+ */
+JNIEXPORT jlong JNICALL
+Java_sun_security_pkcs11_wrapper_PKCS11_freeMechanism
+(JNIEnv *env, jclass thisClass, jlong ckpMechanism) {
+    if (ckpMechanism != 0L) {
+        freeCKMechanismPtr(jlong_to_ptr(ckpMechanism));
+        TRACE1("DEBUG PKCS11_freeMechanism: free pMech = %lld\n", (long long int) ckpMechanism);
+    }
+    return 0L;
+}
+
 /*
  * This method is used to do static initialization. This method is static and
  * synchronized. Summary: use this method like a static initialization block.
  *
  * Class:     sun_security_pkcs11_wrapper_PKCS11
@@ -113,22 +132,26 @@
 }
 
 void prefetchFields(JNIEnv *env, jclass thisClass) {
     jclass tmpClass;
 
-    /* PKCS11 */
+    /* PKCS11 - pNativeData */
     pNativeDataID = (*env)->GetFieldID(env, thisClass, "pNativeData", "J");
     if (pNativeDataID == NULL) { return; }
 
-    /* CK_MECHANISM */
+    /* CK_MECHANISM - mechanism, pParameter, pHandle */
     tmpClass = (*env)->FindClass(env, CLASS_MECHANISM);
     if (tmpClass == NULL) { return; }
     mech_mechanismID = (*env)->GetFieldID(env, tmpClass, "mechanism", "J");
     if (mech_mechanismID == NULL) { return; }
     mech_pParameterID = (*env)->GetFieldID(env, tmpClass, "pParameter",
                                            "Ljava/lang/Object;");
     if (mech_pParameterID == NULL) { return; }
+    mech_pHandleID = (*env)->GetFieldID(env, tmpClass, "pHandle", "J");
+    if (mech_pHandleID == NULL) { return; }
+
+    /* java classes for primitive types - byte[], long */
     jByteArrayClass = fetchClass(env, "[B");
     if (jByteArrayClass == NULL) { return; }
     jLongClass = fetchClass(env, "java/lang/Long");
 }
 
@@ -207,11 +230,14 @@
 
     rv = (*ckpFunctions->C_Initialize)(ckpInitArgs);
 
     free(ckpInitArgs);
 
-    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return; }
+    if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
+      TRACE1("DEBUG: C_Initialize had a bad return value %lu \n", (unsigned long) rv);
+      return;
+    }
 
     TRACE0("FINISHED\n");
 }
 #endif
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_keymgmt.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="p11_general.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="p11_mutex.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_keymgmt.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 138     (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong jKeyHandle,
 139     jlong jWrappingKeyHandle, jobject jWrappingMech)
 140 {
 141     jbyteArray returnValue = NULL;
 142     CK_SESSION_HANDLE ckSessionHandle = jLongToCKULong(jSessionHandle);
 143     CK_OBJECT_HANDLE ckObjectHandle = jLongToCKULong(jKeyHandle);
 144     CK_ATTRIBUTE_PTR ckpAttributes = NULL;
 145     CK_RV rv;
 146     jbyteArray nativeKeyInfoArray = NULL;
 147     jbyteArray nativeKeyInfoWrappedKeyArray = NULL;
 148     jbyte* nativeKeyInfoArrayRaw = NULL;
 149     jbyte* nativeKeyInfoWrappedKeyArrayRaw = NULL;
 150     unsigned int sensitiveAttributePosition = (unsigned int)-1;
 151     unsigned int i = 0U;
 152     unsigned long totalDataSize = 0UL, attributesCount = 0UL;
 153     unsigned long totalCkAttributesSize = 0UL, totalNativeKeyInfoArraySize = 0UL;
 154     jbyte* wrappedKeySizePtr = NULL;
 155     jbyte* nativeKeyInfoArrayRawCkAttributes = NULL;
 156     jbyte* nativeKeyInfoArrayRawCkAttributesPtr = NULL;
 157     jbyte* nativeKeyInfoArrayRawDataPtr = NULL;
<span class="line-modified"> 158     CK_MECHANISM ckMechanism;</span>
 159     char iv[16] = {0x0};
 160     CK_ULONG ckWrappedKeyLength = 0U;
 161     jbyte* wrappedKeySizeWrappedKeyArrayPtr = NULL;
 162     CK_BYTE_PTR wrappedKeyBufferPtr = NULL;
 163     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 164     CK_OBJECT_CLASS class;
 165     CK_KEY_TYPE keyType;
 166     CK_BBOOL sensitive;
 167     CK_BBOOL netscapeAttributeValueNeeded = CK_FALSE;
 168     CK_ATTRIBUTE ckNetscapeAttributesTemplate[4];
 169     ckNetscapeAttributesTemplate[0].type = CKA_CLASS;
 170     ckNetscapeAttributesTemplate[1].type = CKA_KEY_TYPE;
 171     ckNetscapeAttributesTemplate[2].type = CKA_SENSITIVE;
 172     ckNetscapeAttributesTemplate[3].type = CKA_NETSCAPE_DB;
 173     ckNetscapeAttributesTemplate[0].pValue = &amp;class;
 174     ckNetscapeAttributesTemplate[1].pValue = &amp;keyType;
 175     ckNetscapeAttributesTemplate[2].pValue = &amp;sensitive;
 176     ckNetscapeAttributesTemplate[3].pValue = 0;
 177     ckNetscapeAttributesTemplate[0].ulValueLen = sizeof(class);
 178     ckNetscapeAttributesTemplate[1].ulValueLen = sizeof(keyType);
</pre>
<hr />
<pre>
 181 
 182     if (ckpFunctions == NULL) { goto cleanup; }
 183 
 184     // If key is private and of DSA or EC type, NSS may require CKA_NETSCAPE_DB
 185     // attribute to unwrap it.
 186     rv = (*ckpFunctions-&gt;C_GetAttributeValue)(ckSessionHandle, ckObjectHandle,
 187             ckNetscapeAttributesTemplate,
 188             sizeof(ckNetscapeAttributesTemplate)/sizeof(CK_ATTRIBUTE));
 189 
 190     if (rv == CKR_OK &amp;&amp; class == CKO_PRIVATE_KEY &amp;&amp;
 191             (keyType == CKK_EC || keyType == CKK_DSA) &amp;&amp;
 192             sensitive == CK_TRUE &amp;&amp;
 193             ckNetscapeAttributesTemplate[3].ulValueLen == CK_UNAVAILABLE_INFORMATION) {
 194         // We cannot set the attribute through C_SetAttributeValue here
 195         // because it might be read-only. However, we can add it to
 196         // the extracted buffer.
 197         netscapeAttributeValueNeeded = CK_TRUE;
 198         TRACE0(&quot;DEBUG: override CKA_NETSCAPE_DB attr value to TRUE\n&quot;);
 199     }
 200 
<span class="line-modified"> 201     ckpAttributes = (CK_ATTRIBUTE_PTR)malloc(</span>
<span class="line-modified"> 202             CK_ATTRIBUTES_TEMPLATE_LENGTH * sizeof(CK_ATTRIBUTE));</span>
 203     if (ckpAttributes == NULL) {
 204         throwOutOfMemoryError(env, 0);
 205         goto cleanup;
 206     }
 207     memcpy(ckpAttributes, ckpAttributesTemplate,
 208             CK_ATTRIBUTES_TEMPLATE_LENGTH * sizeof(CK_ATTRIBUTE));
 209 
 210     // Get sizes for value buffers
 211     // NOTE: may return an error code but length values are filled anyways
 212     (*ckpFunctions-&gt;C_GetAttributeValue)(ckSessionHandle, ckObjectHandle,
 213             ckpAttributes, CK_ATTRIBUTES_TEMPLATE_LENGTH);
 214 
 215     for (i = 0; i &lt; CK_ATTRIBUTES_TEMPLATE_LENGTH; i++) {
 216         if ((ckpAttributes+i)-&gt;ulValueLen != CK_UNAVAILABLE_INFORMATION) {
 217             totalDataSize += (ckpAttributes+i)-&gt;ulValueLen;
 218             if ((ckpAttributes+i)-&gt;type == CKA_SENSITIVE) {
 219                  sensitiveAttributePosition = attributesCount;
 220                  TRACE0(&quot;DEBUG: GetNativeKeyInfo key is sensitive&quot;);
 221             }
 222             attributesCount++;
</pre>
<hr />
<pre>
 291 
 292     // Get attribute&#39;s values
 293     rv = (*ckpFunctions-&gt;C_GetAttributeValue)(ckSessionHandle, ckObjectHandle,
 294             (CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes,
 295             attributesCount);
 296     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
 297         goto cleanup;
 298     }
 299 
 300     TRACE0(&quot;DEBUG: GetNativeKeyInfo 1st C_GetAttributeValue call passed\n&quot;);
 301 
 302     if (netscapeAttributeValueNeeded) {
 303         (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).type = CKA_NETSCAPE_DB;
 304         // Value is not needed, public key is not used
 305     }
 306 
 307     if ((sensitiveAttributePosition != (unsigned int)-1) &amp;&amp;
 308         *(CK_BBOOL*)(((CK_ATTRIBUTE_PTR)(((CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes)
 309                 +sensitiveAttributePosition))-&gt;pValue) == CK_TRUE) {
 310         // Key is sensitive. Need to extract it wrapped.
<span class="line-modified"> 311         if (jWrappingKeyHandle != -1) {</span>
 312 
<span class="line-modified"> 313             jMechanismToCKMechanism(env, jWrappingMech, &amp;ckMechanism);</span>
<span class="line-modified"> 314             rv = (*ckpFunctions-&gt;C_WrapKey)(ckSessionHandle, &amp;ckMechanism,</span>
 315                     jLongToCKULong(jWrappingKeyHandle), ckObjectHandle,
 316                     NULL_PTR, &amp;ckWrappedKeyLength);
 317             if (ckWrappedKeyLength != 0) {
 318                 // Allocate space for getting the wrapped key
 319                 nativeKeyInfoWrappedKeyArray = (*env)-&gt;NewByteArray(env,
 320                         totalNativeKeyInfoArraySize + ckWrappedKeyLength);
 321                 if (nativeKeyInfoWrappedKeyArray == NULL) {
 322                     goto cleanup;
 323                 }
 324                 nativeKeyInfoWrappedKeyArrayRaw =
 325                         (*env)-&gt;GetByteArrayElements(env,
 326                                 nativeKeyInfoWrappedKeyArray, NULL);
 327                 if (nativeKeyInfoWrappedKeyArrayRaw == NULL) {
 328                     goto cleanup;
 329                 }
 330                 memcpy(nativeKeyInfoWrappedKeyArrayRaw, nativeKeyInfoArrayRaw,
 331                         totalNativeKeyInfoArraySize);
 332                 wrappedKeySizeWrappedKeyArrayPtr =
 333                         nativeKeyInfoWrappedKeyArrayRaw +
 334                         sizeof(unsigned long)*2 + totalCkAttributesSize +
 335                         totalDataSize;
 336                 memcpy(wrappedKeySizeWrappedKeyArrayPtr, &amp;ckWrappedKeyLength, sizeof(unsigned long));
 337                 TRACE1(&quot;DEBUG: GetNativeKeyInfo 1st C_WrapKey wrappedKeyLength = %lu\n&quot;, ckWrappedKeyLength);
 338 
 339                 wrappedKeyBufferPtr =
 340                         (CK_BYTE_PTR) (wrappedKeySizeWrappedKeyArrayPtr +
 341                         sizeof(unsigned long));
<span class="line-modified"> 342                 rv = (*ckpFunctions-&gt;C_WrapKey)(ckSessionHandle, &amp;ckMechanism,</span>
 343                         jLongToCKULong(jWrappingKeyHandle),ckObjectHandle,
 344                         wrappedKeyBufferPtr, &amp;ckWrappedKeyLength);
 345                 if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
 346                     goto cleanup;
 347                 }
 348                 memcpy(wrappedKeySizeWrappedKeyArrayPtr, &amp;ckWrappedKeyLength, sizeof(unsigned long));
 349                 TRACE1(&quot;DEBUG: GetNativeKeyInfo 2nd C_WrapKey wrappedKeyLength = %lu\n&quot;, ckWrappedKeyLength);
 350             } else {
 351                 goto cleanup;
 352             }
 353         } else {

 354             goto cleanup;
 355         }
 356         returnValue = nativeKeyInfoWrappedKeyArray;
 357     } else {
 358         returnValue = nativeKeyInfoArray;
 359     }
 360 
 361 cleanup:
 362     if (ckpAttributes != NULL) {
 363         free(ckpAttributes);
 364     }
 365 
 366     if (nativeKeyInfoArrayRaw != NULL) {
 367         (*env)-&gt;ReleaseByteArrayElements(env, nativeKeyInfoArray,
 368                 nativeKeyInfoArrayRaw, 0);
 369     }
 370 
 371     if (nativeKeyInfoWrappedKeyArrayRaw != NULL) {
 372         (*env)-&gt;ReleaseByteArrayElements(env, nativeKeyInfoWrappedKeyArray,
 373                 nativeKeyInfoWrappedKeyArrayRaw, 0);
 374     }
 375 
 376     if (nativeKeyInfoArray != NULL &amp;&amp; returnValue != nativeKeyInfoArray) {
 377         (*env)-&gt;DeleteLocalRef(env, nativeKeyInfoArray);
 378     }
 379 
 380     if (nativeKeyInfoWrappedKeyArray != NULL
 381             &amp;&amp; returnValue != nativeKeyInfoWrappedKeyArray) {
 382         (*env)-&gt;DeleteLocalRef(env, nativeKeyInfoWrappedKeyArray);
 383     }

 384 
 385     return returnValue;
 386 }
 387 #endif
 388 
 389 #ifdef P11_ENABLE_CREATENATIVEKEY
 390 /*
 391  * Class:     sun_security_pkcs11_wrapper_PKCS11
 392  * Method:    createNativeKey
 393  * Signature: (J[BJLsun/security/pkcs11/wrapper/CK_MECHANISM;)J
 394  * Parametermapping:                          *PKCS11*
 395  * @param   jlong         jSessionHandle      CK_SESSION_HANDLE hSession
 396  * @param   jbyteArray    jNativeKeyInfo      -
 397  * @param   jlong         jWrappingKeyHandle  CK_OBJECT_HANDLE hObject
 398  * @param   jobject       jWrappingMech       CK_MECHANISM_PTR pMechanism
 399  * @return  jlong         jKeyHandle          CK_OBJECT_HANDLE hObject
 400  */
 401 JNIEXPORT jlong JNICALL
 402 Java_sun_security_pkcs11_wrapper_PKCS11_createNativeKey
 403     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jNativeKeyInfo,
 404     jlong jWrappingKeyHandle, jobject jWrappingMech)
 405 {
 406     CK_OBJECT_HANDLE ckObjectHandle;
 407     CK_RV rv;
 408     CK_SESSION_HANDLE ckSessionHandle = jLongToCKULong(jSessionHandle);
 409     jbyte* nativeKeyInfoArrayRaw = NULL;
 410     jlong jObjectHandle = 0L;
 411     unsigned long totalCkAttributesSize = 0UL;
 412     unsigned long nativeKeyInfoCkAttributesCount = 0UL;
 413     jbyte* nativeKeyInfoArrayRawCkAttributes = NULL;
 414     jbyte* nativeKeyInfoArrayRawCkAttributesPtr = NULL;
 415     jbyte* nativeKeyInfoArrayRawDataPtr = NULL;
 416     unsigned long totalDataSize = 0UL;
 417     jbyte* wrappedKeySizePtr = NULL;
 418     unsigned int i = 0U;
<span class="line-modified"> 419     CK_MECHANISM ckMechanism;</span>
 420     char iv[16] = {0x0};
 421     CK_ULONG ckWrappedKeyLength = 0UL;
 422     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 423 
 424     if (ckpFunctions == NULL) { goto cleanup; }
 425 
 426     nativeKeyInfoArrayRaw =
 427             (*env)-&gt;GetByteArrayElements(env, jNativeKeyInfo, NULL);
 428     if (nativeKeyInfoArrayRaw == NULL) {
 429         goto cleanup;
 430     }
 431 
 432     memcpy(&amp;totalCkAttributesSize, nativeKeyInfoArrayRaw, sizeof(unsigned long));
 433     TRACE1(&quot;DEBUG: createNativeKey totalCkAttributesSize = %lu\n&quot;, totalCkAttributesSize);
 434     nativeKeyInfoCkAttributesCount = totalCkAttributesSize/sizeof(CK_ATTRIBUTE);
 435     TRACE1(&quot;DEBUG: createNativeKey nativeKeyInfoCkAttributesCount = %lu\n&quot;, nativeKeyInfoCkAttributesCount);
 436 
 437     nativeKeyInfoArrayRawCkAttributes = nativeKeyInfoArrayRaw +
 438             sizeof(unsigned long);
 439     nativeKeyInfoArrayRawCkAttributesPtr = nativeKeyInfoArrayRawCkAttributes;
</pre>
<hr />
<pre>
 450     TRACE1(&quot;DEBUG: createNativeKey wrappedKeyLength = %lu\n&quot;, ckWrappedKeyLength);
 451 
 452     for (i = 0; i &lt; nativeKeyInfoCkAttributesCount; i++) {
 453         if ((*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).ulValueLen
 454                 &gt; 0) {
 455             (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).pValue =
 456                     nativeKeyInfoArrayRawDataPtr;
 457         }
 458         nativeKeyInfoArrayRawDataPtr +=
 459                 (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).ulValueLen;
 460         nativeKeyInfoArrayRawCkAttributesPtr += sizeof(CK_ATTRIBUTE);
 461     }
 462 
 463     if (ckWrappedKeyLength == 0) {
 464         // Not a wrapped key
 465         rv = (*ckpFunctions-&gt;C_CreateObject)(ckSessionHandle,
 466                 (CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes,
 467                 jLongToCKULong(nativeKeyInfoCkAttributesCount), &amp;ckObjectHandle);
 468     } else {
 469         // Wrapped key
<span class="line-modified"> 470         jMechanismToCKMechanism(env, jWrappingMech, &amp;ckMechanism);</span>
<span class="line-modified"> 471         rv = (*ckpFunctions-&gt;C_UnwrapKey)(ckSessionHandle, &amp;ckMechanism,</span>
 472                 jLongToCKULong(jWrappingKeyHandle),
 473                 (CK_BYTE_PTR)(wrappedKeySizePtr + sizeof(unsigned long)),
 474                 ckWrappedKeyLength,
 475                 (CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes,
 476                 jLongToCKULong(nativeKeyInfoCkAttributesCount),
 477                 &amp;ckObjectHandle);
 478     }
 479     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
 480         goto cleanup;
 481     }
 482 
 483     jObjectHandle = ckULongToJLong(ckObjectHandle);
 484 
 485 cleanup:
 486 
 487     if (nativeKeyInfoArrayRaw != NULL) {
 488         (*env)-&gt;ReleaseByteArrayElements(env, jNativeKeyInfo,
 489                 nativeKeyInfoArrayRaw, JNI_ABORT);
 490     }
 491 

 492     return jObjectHandle;
 493 }
 494 #endif
 495 
 496 #ifdef P11_ENABLE_C_GENERATEKEY
 497 /*
 498  * Class:     sun_security_pkcs11_wrapper_PKCS11
 499  * Method:    C_GenerateKey
 500  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;)J
 501  * Parametermapping:                    *PKCS11*
 502  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 503  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
 504  * @param   jobjectArray jTemplate      CK_ATTRIBUTE_PTR pTemplate
 505  *                                      CK_ULONG ulCount
 506  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE_PTR phKey
 507  */
 508 JNIEXPORT jlong JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1GenerateKey
 509     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jobjectArray jTemplate)
 510 {
 511     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified"> 512     CK_MECHANISM ckMechanism;</span>
 513     CK_ATTRIBUTE_PTR ckpAttributes = NULL_PTR;
<span class="line-modified"> 514     CK_ULONG ckAttributesLength;</span>
 515     CK_OBJECT_HANDLE ckKeyHandle = 0;
 516     jlong jKeyHandle = 0L;
 517     CK_RV rv;
 518 
 519     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 520     if (ckpFunctions == NULL) { return 0L; }
 521 
 522     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified"> 523     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
 524     if ((*env)-&gt;ExceptionCheck(env)) { return 0L ; }
 525 
 526     jAttributeArrayToCKAttributeArray(env, jTemplate, &amp;ckpAttributes, &amp;ckAttributesLength);
 527     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 528         if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-removed"> 529             free(ckMechanism.pParameter);</span>
<span class="line-removed"> 530         }</span>
<span class="line-removed"> 531         return 0L;</span>
 532     }
 533 
<span class="line-modified"> 534     rv = (*ckpFunctions-&gt;C_GenerateKey)(ckSessionHandle, &amp;ckMechanism, ckpAttributes, ckAttributesLength, &amp;ckKeyHandle);</span>
 535 
 536     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
 537         jKeyHandle = ckULongToJLong(ckKeyHandle);
 538 
 539         /* cheack, if we must give a initialization vector back to Java */
<span class="line-modified"> 540         switch (ckMechanism.mechanism) {</span>
 541         case CKM_PBE_MD2_DES_CBC:
 542         case CKM_PBE_MD5_DES_CBC:
 543         case CKM_PBE_MD5_CAST_CBC:
 544         case CKM_PBE_MD5_CAST3_CBC:
 545         case CKM_PBE_MD5_CAST128_CBC:
 546         /* case CKM_PBE_MD5_CAST5_CBC:  the same as CKM_PBE_MD5_CAST128_CBC */
 547         case CKM_PBE_SHA1_CAST128_CBC:
 548         /* case CKM_PBE_SHA1_CAST5_CBC: the same as CKM_PBE_SHA1_CAST128_CBC */
 549             /* we must copy back the initialization vector to the jMechanism object */
<span class="line-modified"> 550             copyBackPBEInitializationVector(env, &amp;ckMechanism, jMechanism);</span>
 551             break;
 552         }
 553     }
<span class="line-modified"> 554 </span>
<span class="line-modified"> 555     if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-removed"> 556         free(ckMechanism.pParameter);</span>
<span class="line-removed"> 557     }</span>
 558     freeCKAttributeArray(ckpAttributes, ckAttributesLength);
 559 
 560     return jKeyHandle ;
 561 }
 562 #endif
 563 
 564 #ifdef P11_ENABLE_C_GENERATEKEYPAIR
 565 /*
 566  * Class:     sun_security_pkcs11_wrapper_PKCS11
 567  * Method:    C_GenerateKeyPair
 568  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;)[J
 569  * Parametermapping:                          *PKCS11*
 570  * @param   jlong jSessionHandle              CK_SESSION_HANDLE hSession
 571  * @param   jobject jMechanism                CK_MECHANISM_PTR pMechanism
 572  * @param   jobjectArray jPublicKeyTemplate   CK_ATTRIBUTE_PTR pPublicKeyTemplate
 573  *                                            CK_ULONG ulPublicKeyAttributeCount
 574  * @param   jobjectArray jPrivateKeyTemplate  CK_ATTRIBUTE_PTR pPrivateKeyTemplate
 575  *                                            CK_ULONG ulPrivateKeyAttributeCount
 576  * @return  jlongArray jKeyHandles            CK_OBJECT_HANDLE_PTR phPublicKey
 577  *                                            CK_OBJECT_HANDLE_PTR phPublicKey
 578  */
 579 JNIEXPORT jlongArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1GenerateKeyPair
 580     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism,
 581      jobjectArray jPublicKeyTemplate, jobjectArray jPrivateKeyTemplate)
 582 {
 583     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified"> 584     CK_MECHANISM ckMechanism;</span>
 585     CK_ATTRIBUTE_PTR ckpPublicKeyAttributes = NULL_PTR;
 586     CK_ATTRIBUTE_PTR ckpPrivateKeyAttributes = NULL_PTR;
<span class="line-modified"> 587     CK_ULONG ckPublicKeyAttributesLength;</span>
<span class="line-modified"> 588     CK_ULONG ckPrivateKeyAttributesLength;</span>
 589     CK_OBJECT_HANDLE_PTR ckpPublicKeyHandle;  /* pointer to Public Key */
 590     CK_OBJECT_HANDLE_PTR ckpPrivateKeyHandle; /* pointer to Private Key */
<span class="line-modified"> 591     CK_OBJECT_HANDLE_PTR ckpKeyHandles;     /* pointer to array with Public and Private Key */</span>
 592     jlongArray jKeyHandles = NULL;
 593     CK_RV rv;
 594     int attempts;
 595     const int MAX_ATTEMPTS = 3;
 596 
 597     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 598     if (ckpFunctions == NULL) { return NULL; }
 599 
 600     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified"> 601     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
 602     if ((*env)-&gt;ExceptionCheck(env)) { return NULL; }
 603 
<span class="line-modified"> 604     ckpKeyHandles = (CK_OBJECT_HANDLE_PTR) malloc(2 * sizeof(CK_OBJECT_HANDLE));</span>
 605     if (ckpKeyHandles == NULL) {
<span class="line-removed"> 606         if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-removed"> 607             free(ckMechanism.pParameter);</span>
<span class="line-removed"> 608         }</span>
 609         throwOutOfMemoryError(env, 0);
<span class="line-modified"> 610         return NULL;</span>
 611     }
 612     ckpPublicKeyHandle = ckpKeyHandles;   /* first element of array is Public Key */
 613     ckpPrivateKeyHandle = (ckpKeyHandles + 1);  /* second element of array is Private Key */
 614 
 615     jAttributeArrayToCKAttributeArray(env, jPublicKeyTemplate, &amp;ckpPublicKeyAttributes, &amp;ckPublicKeyAttributesLength);
 616     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 617         if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-removed"> 618             free(ckMechanism.pParameter);</span>
<span class="line-removed"> 619         }</span>
<span class="line-removed"> 620         free(ckpKeyHandles);</span>
<span class="line-removed"> 621         return NULL;</span>
 622     }
 623 
 624     jAttributeArrayToCKAttributeArray(env, jPrivateKeyTemplate, &amp;ckpPrivateKeyAttributes, &amp;ckPrivateKeyAttributesLength);
 625     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 626         if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-removed"> 627             free(ckMechanism.pParameter);</span>
<span class="line-removed"> 628         }</span>
<span class="line-removed"> 629         free(ckpKeyHandles);</span>
<span class="line-removed"> 630         freeCKAttributeArray(ckpPublicKeyAttributes, ckPublicKeyAttributesLength);</span>
<span class="line-removed"> 631         return NULL;</span>
 632     }
 633 
 634     /*
 635      * Workaround for NSS bug 1012786:
 636      *
 637      * Key generation may fail with CKR_FUNCTION_FAILED error
 638      * if there is insufficient entropy to generate a random key.
 639      *
 640      * PKCS11 spec says the following about CKR_FUNCTION_FAILED error
 641      * (see section 11.1.1):
 642      *
 643      *      ... In any event, although the function call failed, the situation
 644      *      is not necessarily totally hopeless, as it is likely to be
 645      *      when CKR_GENERAL_ERROR is returned. Depending on what the root cause of
 646      *      the error actually was, it is possible that an attempt
 647      *      to make the exact same function call again would succeed.
 648      *
 649      * Call C_GenerateKeyPair() several times if CKR_FUNCTION_FAILED occurs.
 650      */
 651     for (attempts = 0; attempts &lt; MAX_ATTEMPTS; attempts++) {
<span class="line-modified"> 652         rv = (*ckpFunctions-&gt;C_GenerateKeyPair)(ckSessionHandle, &amp;ckMechanism,</span>
 653                         ckpPublicKeyAttributes, ckPublicKeyAttributesLength,
 654                         ckpPrivateKeyAttributes, ckPrivateKeyAttributesLength,
 655                         ckpPublicKeyHandle, ckpPrivateKeyHandle);
 656         if (rv == CKR_FUNCTION_FAILED) {
 657             printDebug(&quot;C_1GenerateKeyPair(): C_GenerateKeyPair() failed \
 658                     with CKR_FUNCTION_FAILED error, try again\n&quot;);
 659         } else {
 660             break;
 661         }
 662     }
 663 
 664     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
 665         jKeyHandles = ckULongArrayToJLongArray(env, ckpKeyHandles, 2);
 666     }
 667 
<span class="line-modified"> 668     if(ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified"> 669         free(ckMechanism.pParameter);</span>
<span class="line-removed"> 670     }</span>
 671     free(ckpKeyHandles);
 672     freeCKAttributeArray(ckpPublicKeyAttributes, ckPublicKeyAttributesLength);
 673     freeCKAttributeArray(ckpPrivateKeyAttributes, ckPrivateKeyAttributesLength);
<span class="line-removed"> 674 </span>
 675     return jKeyHandles ;
 676 }
 677 #endif
 678 
 679 #ifdef P11_ENABLE_C_WRAPKEY
 680 /*
 681  * Class:     sun_security_pkcs11_wrapper_PKCS11
 682  * Method:    C_WrapKey
 683  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;JJ)[B
 684  * Parametermapping:                    *PKCS11*
 685  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 686  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
 687  * @param   jlong jWrappingKeyHandle    CK_OBJECT_HANDLE hWrappingKey
 688  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey
 689  * @return  jbyteArray jWrappedKey      CK_BYTE_PTR pWrappedKey
 690  *                                      CK_ULONG_PTR pulWrappedKeyLen
 691  */
 692 JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1WrapKey
 693     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jWrappingKeyHandle, jlong jKeyHandle)
 694 {
 695     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified"> 696     CK_MECHANISM ckMechanism;</span>
 697     CK_OBJECT_HANDLE ckWrappingKeyHandle;
 698     CK_OBJECT_HANDLE ckKeyHandle;
 699     jbyteArray jWrappedKey = NULL;
 700     CK_RV rv;
 701     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
 702     CK_BYTE_PTR ckpWrappedKey = BUF;
 703     CK_ULONG ckWrappedKeyLength = MAX_STACK_BUFFER_LEN;
 704 
 705     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 706     if (ckpFunctions == NULL) { return NULL; }
 707 
 708     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified"> 709     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
 710     if ((*env)-&gt;ExceptionCheck(env)) { return NULL; }
 711 
 712     ckWrappingKeyHandle = jLongToCKULong(jWrappingKeyHandle);
 713     ckKeyHandle = jLongToCKULong(jKeyHandle);
 714 
<span class="line-modified"> 715     rv = (*ckpFunctions-&gt;C_WrapKey)(ckSessionHandle, &amp;ckMechanism, ckWrappingKeyHandle, ckKeyHandle, ckpWrappedKey, &amp;ckWrappedKeyLength);</span>
 716     if (rv == CKR_BUFFER_TOO_SMALL) {
<span class="line-modified"> 717         ckpWrappedKey = (CK_BYTE_PTR) malloc(ckWrappedKeyLength);</span>

 718         if (ckpWrappedKey == NULL) {
<span class="line-removed"> 719             if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-removed"> 720                 free(ckMechanism.pParameter);</span>
<span class="line-removed"> 721             }</span>
 722             throwOutOfMemoryError(env, 0);
<span class="line-modified"> 723             return NULL;</span>
 724         }
 725 
<span class="line-modified"> 726         rv = (*ckpFunctions-&gt;C_WrapKey)(ckSessionHandle, &amp;ckMechanism, ckWrappingKeyHandle, ckKeyHandle, ckpWrappedKey, &amp;ckWrappedKeyLength);</span>
 727     }
 728     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
 729         jWrappedKey = ckByteArrayToJByteArray(env, ckpWrappedKey, ckWrappedKeyLength);
 730     }
 731 

 732     if (ckpWrappedKey != BUF) { free(ckpWrappedKey); }
<span class="line-modified"> 733     if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-modified"> 734         free(ckMechanism.pParameter);</span>
<span class="line-removed"> 735     }</span>
 736     return jWrappedKey ;
 737 }
 738 #endif
 739 
 740 #ifdef P11_ENABLE_C_UNWRAPKEY
 741 /*
 742  * Class:     sun_security_pkcs11_wrapper_PKCS11
 743  * Method:    C_UnwrapKey
 744  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J[B[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;)J
 745  * Parametermapping:                    *PKCS11*
 746  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 747  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
 748  * @param   jlong jUnwrappingKeyHandle  CK_OBJECT_HANDLE hUnwrappingKey
 749  * @param   jbyteArray jWrappedKey      CK_BYTE_PTR pWrappedKey
 750  *                                      CK_ULONG_PTR pulWrappedKeyLen
 751  * @param   jobjectArray jTemplate      CK_ATTRIBUTE_PTR pTemplate
 752  *                                      CK_ULONG ulCount
 753  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE_PTR phKey
 754  */
 755 JNIEXPORT jlong JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1UnwrapKey
 756     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jUnwrappingKeyHandle,
 757      jbyteArray jWrappedKey, jobjectArray jTemplate)
 758 {
 759     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified"> 760     CK_MECHANISM ckMechanism;</span>
 761     CK_OBJECT_HANDLE ckUnwrappingKeyHandle;
 762     CK_BYTE_PTR ckpWrappedKey = NULL_PTR;
 763     CK_ULONG ckWrappedKeyLength;
 764     CK_ATTRIBUTE_PTR ckpAttributes = NULL_PTR;
<span class="line-modified"> 765     CK_ULONG ckAttributesLength;</span>
 766     CK_OBJECT_HANDLE ckKeyHandle = 0;
 767     jlong jKeyHandle = 0L;
 768     CK_RV rv;
 769 
 770     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 771     if (ckpFunctions == NULL) { return 0L; }
 772 
 773     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified"> 774     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
 775     if ((*env)-&gt;ExceptionCheck(env)) { return 0L; }
 776 
 777     ckUnwrappingKeyHandle = jLongToCKULong(jUnwrappingKeyHandle);
 778     jByteArrayToCKByteArray(env, jWrappedKey, &amp;ckpWrappedKey, &amp;ckWrappedKeyLength);
 779     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 780         if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-removed"> 781             free(ckMechanism.pParameter);</span>
<span class="line-removed"> 782         }</span>
<span class="line-removed"> 783         return 0L;</span>
 784     }
 785 
 786     jAttributeArrayToCKAttributeArray(env, jTemplate, &amp;ckpAttributes, &amp;ckAttributesLength);
 787     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 788         if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-removed"> 789             free(ckMechanism.pParameter);</span>
<span class="line-removed"> 790         }</span>
<span class="line-removed"> 791         free(ckpWrappedKey);</span>
<span class="line-removed"> 792         return 0L;</span>
 793     }
 794 
 795 
<span class="line-modified"> 796     rv = (*ckpFunctions-&gt;C_UnwrapKey)(ckSessionHandle, &amp;ckMechanism, ckUnwrappingKeyHandle,</span>
 797                  ckpWrappedKey, ckWrappedKeyLength,
 798                  ckpAttributes, ckAttributesLength, &amp;ckKeyHandle);
 799 
 800     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
 801         jKeyHandle = ckLongToJLong(ckKeyHandle);
 802 
 803 #if 0
 804         /* cheack, if we must give a initialization vector back to Java */
<span class="line-modified"> 805         if (ckMechanism.mechanism == CKM_KEY_WRAP_SET_OAEP) {</span>
 806             /* we must copy back the unwrapped key info to the jMechanism object */
<span class="line-modified"> 807             copyBackSetUnwrappedKey(env, &amp;ckMechanism, jMechanism);</span>
 808         }
 809 #endif
 810     }
<span class="line-modified"> 811 </span>
<span class="line-modified"> 812     if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-removed"> 813         free(ckMechanism.pParameter);</span>
<span class="line-removed"> 814     }</span>
 815     freeCKAttributeArray(ckpAttributes, ckAttributesLength);
 816     free(ckpWrappedKey);
 817 
 818     return jKeyHandle ;
 819 }
 820 #endif
 821 
 822 #ifdef P11_ENABLE_C_DERIVEKEY
 823 
<span class="line-removed"> 824 static void freeMasterKeyDeriveParams(CK_SSL3_RANDOM_DATA *RandomInfo, CK_VERSION_PTR pVersion) {</span>
<span class="line-removed"> 825     if (RandomInfo-&gt;pClientRandom != NULL) {</span>
<span class="line-removed"> 826         free(RandomInfo-&gt;pClientRandom);</span>
<span class="line-removed"> 827     }</span>
<span class="line-removed"> 828     if (RandomInfo-&gt;pServerRandom != NULL) {</span>
<span class="line-removed"> 829         free(RandomInfo-&gt;pServerRandom);</span>
<span class="line-removed"> 830     }</span>
<span class="line-removed"> 831     if (pVersion != NULL) {</span>
<span class="line-removed"> 832         free(pVersion);</span>
<span class="line-removed"> 833     }</span>
<span class="line-removed"> 834 }</span>
<span class="line-removed"> 835 </span>
<span class="line-removed"> 836 void ssl3FreeMasterKeyDeriveParams(CK_MECHANISM_PTR ckMechanism) {</span>
<span class="line-removed"> 837     CK_SSL3_MASTER_KEY_DERIVE_PARAMS *params = (CK_SSL3_MASTER_KEY_DERIVE_PARAMS *) ckMechanism-&gt;pParameter;</span>
<span class="line-removed"> 838     if (params == NULL) {</span>
<span class="line-removed"> 839         return;</span>
<span class="line-removed"> 840     }</span>
<span class="line-removed"> 841     freeMasterKeyDeriveParams(&amp;(params-&gt;RandomInfo), params-&gt;pVersion);</span>
<span class="line-removed"> 842 }</span>
<span class="line-removed"> 843 </span>
<span class="line-removed"> 844 void tls12FreeMasterKeyDeriveParams(CK_MECHANISM_PTR ckMechanism) {</span>
<span class="line-removed"> 845     CK_TLS12_MASTER_KEY_DERIVE_PARAMS *params =</span>
<span class="line-removed"> 846             (CK_TLS12_MASTER_KEY_DERIVE_PARAMS *)ckMechanism-&gt;pParameter;</span>
<span class="line-removed"> 847     if (params == NULL) {</span>
<span class="line-removed"> 848         return;</span>
<span class="line-removed"> 849     }</span>
<span class="line-removed"> 850     freeMasterKeyDeriveParams(&amp;(params-&gt;RandomInfo), params-&gt;pVersion);</span>
<span class="line-removed"> 851 }</span>
<span class="line-removed"> 852 </span>
<span class="line-removed"> 853 void freeEcdh1DeriveParams(CK_MECHANISM_PTR ckMechanism) {</span>
<span class="line-removed"> 854     CK_ECDH1_DERIVE_PARAMS *params =</span>
<span class="line-removed"> 855             (CK_ECDH1_DERIVE_PARAMS *)ckMechanism-&gt;pParameter;</span>
<span class="line-removed"> 856     if (params == NULL) {</span>
<span class="line-removed"> 857         return;</span>
<span class="line-removed"> 858     }</span>
<span class="line-removed"> 859 </span>
<span class="line-removed"> 860     if (params-&gt;pSharedData != NULL) {</span>
<span class="line-removed"> 861         free(params-&gt;pSharedData);</span>
<span class="line-removed"> 862     }</span>
<span class="line-removed"> 863     if (params-&gt;pPublicData != NULL) {</span>
<span class="line-removed"> 864         free(params-&gt;pPublicData);</span>
<span class="line-removed"> 865     }</span>
<span class="line-removed"> 866 }</span>
<span class="line-removed"> 867 </span>
 868 /*
 869  * Copy back the PRF output to Java.
 870  */
<span class="line-modified"> 871 void copyBackTLSPrfParams(JNIEnv *env, CK_MECHANISM *ckMechanism, jobject jMechanism)</span>
 872 {
 873     jclass jMechanismClass, jTLSPrfParamsClass;
 874     CK_TLS_PRF_PARAMS *ckTLSPrfParams;
 875     jobject jTLSPrfParams;
 876     jfieldID fieldID;
 877     CK_MECHANISM_TYPE ckMechanismType;
 878     jlong jMechanismType;
 879     CK_BYTE_PTR output;
 880     jobject jOutput;
 881     jint jLength;
 882     jbyte* jBytes;
 883     int i;
 884 
 885     /* get mechanism */
 886     jMechanismClass = (*env)-&gt;FindClass(env, CLASS_MECHANISM);
 887     if (jMechanismClass == NULL) { return; }
 888     fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;mechanism&quot;, &quot;J&quot;);
 889     if (fieldID == NULL) { return; }
 890     jMechanismType = (*env)-&gt;GetLongField(env, jMechanism, fieldID);
 891     ckMechanismType = jLongToCKULong(jMechanismType);
<span class="line-modified"> 892     if (ckMechanismType != ckMechanism-&gt;mechanism) {</span>
 893         /* we do not have maching types, this should not occur */
 894         return;
 895     }
 896 
 897     /* get the native CK_TLS_PRF_PARAMS */
<span class="line-modified"> 898     ckTLSPrfParams = (CK_TLS_PRF_PARAMS *) ckMechanism-&gt;pParameter;</span>
 899     if (ckTLSPrfParams != NULL_PTR) {
 900         /* get the Java CK_TLS_PRF_PARAMS object (pParameter) */
 901         fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;pParameter&quot;, &quot;Ljava/lang/Object;&quot;);
 902         if (fieldID == NULL) { return; }
 903         jTLSPrfParams = (*env)-&gt;GetObjectField(env, jMechanism, fieldID);
 904 
 905         /* copy back the client IV */
 906         jTLSPrfParamsClass = (*env)-&gt;FindClass(env, CLASS_TLS_PRF_PARAMS);
 907         if (jTLSPrfParamsClass == NULL) { return; }
 908         fieldID = (*env)-&gt;GetFieldID(env, jTLSPrfParamsClass, &quot;pOutput&quot;, &quot;[B&quot;);
 909         if (fieldID == NULL) { return; }
 910         jOutput = (*env)-&gt;GetObjectField(env, jTLSPrfParams, fieldID);
 911         output = ckTLSPrfParams-&gt;pOutput;
 912 
 913         // Note: we assume that the token returned exactly as many bytes as we
 914         // requested. Anything else would not make sense.
 915         if (jOutput != NULL) {
 916             jLength = (*env)-&gt;GetArrayLength(env, jOutput);
 917             jBytes = (*env)-&gt;GetByteArrayElements(env, jOutput, NULL);
 918             if (jBytes == NULL) { return; }
 919 
 920             /* copy the bytes to the Java buffer */
 921             for (i=0; i &lt; jLength; i++) {
 922                 jBytes[i] = ckByteToJByte(output[i]);
 923             }
 924             /* copy back the Java buffer to the object */
 925             (*env)-&gt;ReleaseByteArrayElements(env, jOutput, jBytes, 0);
 926         }
<span class="line-removed"> 927 </span>
<span class="line-removed"> 928         // free malloc&#39;d data</span>
<span class="line-removed"> 929         free(ckTLSPrfParams-&gt;pSeed);</span>
<span class="line-removed"> 930         free(ckTLSPrfParams-&gt;pLabel);</span>
<span class="line-removed"> 931         free(ckTLSPrfParams-&gt;pulOutputLen);</span>
<span class="line-removed"> 932         free(ckTLSPrfParams-&gt;pOutput);</span>
 933     }
 934 }
 935 
 936 /*
 937  * Class:     sun_security_pkcs11_wrapper_PKCS11
 938  * Method:    C_DeriveKey
 939  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;)J
 940  * Parametermapping:                    *PKCS11*
 941  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 942  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
 943  * @param   jlong jBaseKeyHandle        CK_OBJECT_HANDLE hBaseKey
 944  * @param   jobjectArray jTemplate      CK_ATTRIBUTE_PTR pTemplate
 945  *                                      CK_ULONG ulCount
 946  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE_PTR phKey
 947  */
 948 JNIEXPORT jlong JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1DeriveKey
 949     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jBaseKeyHandle, jobjectArray jTemplate)
 950 {
 951     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified"> 952     CK_MECHANISM ckMechanism;</span>
 953     CK_OBJECT_HANDLE ckBaseKeyHandle;
 954     CK_ATTRIBUTE_PTR ckpAttributes = NULL_PTR;
<span class="line-modified"> 955     CK_ULONG ckAttributesLength;</span>
 956     CK_OBJECT_HANDLE ckKeyHandle = 0;
 957     jlong jKeyHandle = 0L;
 958     CK_RV rv;
 959     CK_OBJECT_HANDLE_PTR phKey = &amp;ckKeyHandle;
 960 
 961     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 962     if (ckpFunctions == NULL) { return 0L; }
 963 
 964     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified"> 965     jMechanismToCKMechanism(env, jMechanism, &amp;ckMechanism);</span>
 966     if ((*env)-&gt;ExceptionCheck(env)) { return 0L; }
 967 
 968     ckBaseKeyHandle = jLongToCKULong(jBaseKeyHandle);
 969     jAttributeArrayToCKAttributeArray(env, jTemplate, &amp;ckpAttributes, &amp;ckAttributesLength);
 970     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 971         if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-removed"> 972             free(ckMechanism.pParameter);</span>
<span class="line-removed"> 973         }</span>
<span class="line-removed"> 974         return 0L;</span>
 975     }
 976 
<span class="line-modified"> 977     switch (ckMechanism.mechanism) {</span>
 978     case CKM_SSL3_KEY_AND_MAC_DERIVE:
 979     case CKM_TLS_KEY_AND_MAC_DERIVE:
 980     case CKM_TLS12_KEY_AND_MAC_DERIVE:
 981     case CKM_TLS_PRF:
 982         // these mechanism do not return a key handle via phKey
 983         // set to NULL in case pedantic implementations check for it
 984         phKey = NULL;
 985         break;
 986     default:
 987         // empty
 988         break;
 989     }
 990 
<span class="line-modified"> 991     rv = (*ckpFunctions-&gt;C_DeriveKey)(ckSessionHandle, &amp;ckMechanism, ckBaseKeyHandle,</span>
 992                  ckpAttributes, ckAttributesLength, phKey);
 993 
 994     jKeyHandle = ckLongToJLong(ckKeyHandle);
 995 
<span class="line-modified"> 996     freeCKAttributeArray(ckpAttributes, ckAttributesLength);</span>
<span class="line-removed"> 997 </span>
<span class="line-removed"> 998     switch (ckMechanism.mechanism) {</span>
 999     case CKM_SSL3_MASTER_KEY_DERIVE:
1000     case CKM_TLS_MASTER_KEY_DERIVE:
1001         /* we must copy back the client version */
<span class="line-modified">1002         ssl3CopyBackClientVersion(env, &amp;ckMechanism, jMechanism);</span>
<span class="line-removed">1003         ssl3FreeMasterKeyDeriveParams(&amp;ckMechanism);</span>
1004         break;
1005     case CKM_TLS12_MASTER_KEY_DERIVE:
<span class="line-modified">1006         tls12CopyBackClientVersion(env, &amp;ckMechanism, jMechanism);</span>
<span class="line-removed">1007         tls12FreeMasterKeyDeriveParams(&amp;ckMechanism);</span>
<span class="line-removed">1008         break;</span>
<span class="line-removed">1009     case CKM_SSL3_MASTER_KEY_DERIVE_DH:</span>
<span class="line-removed">1010     case CKM_TLS_MASTER_KEY_DERIVE_DH:</span>
<span class="line-removed">1011         ssl3FreeMasterKeyDeriveParams(&amp;ckMechanism);</span>
<span class="line-removed">1012         break;</span>
<span class="line-removed">1013     case CKM_TLS12_MASTER_KEY_DERIVE_DH:</span>
<span class="line-removed">1014         tls12FreeMasterKeyDeriveParams(&amp;ckMechanism);</span>
1015         break;
1016     case CKM_SSL3_KEY_AND_MAC_DERIVE:
1017     case CKM_TLS_KEY_AND_MAC_DERIVE:
1018         /* we must copy back the unwrapped key info to the jMechanism object */
<span class="line-modified">1019         ssl3CopyBackKeyMatParams(env, &amp;ckMechanism, jMechanism);</span>
1020         break;
1021     case CKM_TLS12_KEY_AND_MAC_DERIVE:
1022         /* we must copy back the unwrapped key info to the jMechanism object */
<span class="line-modified">1023         tls12CopyBackKeyMatParams(env, &amp;ckMechanism, jMechanism);</span>
1024         break;
1025     case CKM_TLS_PRF:
<span class="line-modified">1026         copyBackTLSPrfParams(env, &amp;ckMechanism, jMechanism);</span>
<span class="line-removed">1027         break;</span>
<span class="line-removed">1028     case CKM_ECDH1_DERIVE:</span>
<span class="line-removed">1029         freeEcdh1DeriveParams(&amp;ckMechanism);</span>
1030         break;
1031     default:
1032         // empty
1033         break;
1034     }
<span class="line-modified">1035 </span>
<span class="line-modified">1036     if (ckMechanism.pParameter != NULL_PTR) {</span>
<span class="line-removed">1037         free(ckMechanism.pParameter);</span>
1038     }
<span class="line-modified">1039     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) { return 0L ; }</span>



1040 
1041     return jKeyHandle ;
1042 }
1043 
<span class="line-modified">1044 static void copyBackClientVersion(JNIEnv *env, CK_MECHANISM *ckMechanism, jobject jMechanism,</span>
1045         CK_VERSION *ckVersion, const char *class_master_key_derive_params)
1046 {
1047     jclass jMasterKeyDeriveParamsClass, jMechanismClass, jVersionClass;
1048     jobject jMasterKeyDeriveParams;
1049     jfieldID fieldID;
1050     CK_MECHANISM_TYPE ckMechanismType;
1051     jlong jMechanismType;
1052     jobject jVersion;
1053 
1054     /* get mechanism */
1055     jMechanismClass = (*env)-&gt;FindClass(env, CLASS_MECHANISM);
1056     if (jMechanismClass == NULL) { return; }
1057     fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;mechanism&quot;, &quot;J&quot;);
1058     if (fieldID == NULL) { return; }
1059     jMechanismType = (*env)-&gt;GetLongField(env, jMechanism, fieldID);
1060     ckMechanismType = jLongToCKULong(jMechanismType);
<span class="line-modified">1061     if (ckMechanismType != ckMechanism-&gt;mechanism) {</span>
1062         /* we do not have maching types, this should not occur */
1063         return;
1064     }
1065 
1066     if (ckVersion != NULL_PTR) {
1067       /* get the Java CK_SSL3_MASTER_KEY_DERIVE_PARAMS (pParameter) */
1068       fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;pParameter&quot;, &quot;Ljava/lang/Object;&quot;);
1069       if (fieldID == NULL) { return; }
1070 
1071       jMasterKeyDeriveParams = (*env)-&gt;GetObjectField(env, jMechanism, fieldID);
1072 
1073       /* get the Java CK_VERSION */
1074       jMasterKeyDeriveParamsClass = (*env)-&gt;FindClass(env, class_master_key_derive_params);
1075       if (jMasterKeyDeriveParamsClass == NULL) { return; }
1076       fieldID = (*env)-&gt;GetFieldID(env, jMasterKeyDeriveParamsClass,
1077               &quot;pVersion&quot;, &quot;L&quot;CLASS_VERSION&quot;;&quot;);
1078       if (fieldID == NULL) { return; }
1079       jVersion = (*env)-&gt;GetObjectField(env, jMasterKeyDeriveParams, fieldID);
1080 
1081       /* now copy back the version from the native structure to the Java structure */
</pre>
<hr />
<pre>
1084       jVersionClass = (*env)-&gt;FindClass(env, CLASS_VERSION);
1085       if (jVersionClass == NULL) { return; }
1086       fieldID = (*env)-&gt;GetFieldID(env, jVersionClass, &quot;major&quot;, &quot;B&quot;);
1087       if (fieldID == NULL) { return; }
1088       (*env)-&gt;SetByteField(env, jVersion, fieldID, ckByteToJByte(ckVersion-&gt;major));
1089 
1090       /* copy back the minor version */
1091       fieldID = (*env)-&gt;GetFieldID(env, jVersionClass, &quot;minor&quot;, &quot;B&quot;);
1092       if (fieldID == NULL) { return; }
1093       (*env)-&gt;SetByteField(env, jVersion, fieldID, ckByteToJByte(ckVersion-&gt;minor));
1094     }
1095 }
1096 
1097 /*
1098  * Copy back the client version information from the native
1099  * structure to the Java object. This is only used for
1100  * CKM_SSL3_MASTER_KEY_DERIVE and CKM_TLS_MASTER_KEY_DERIVE
1101  * mechanisms when used for deriving a key.
1102  *
1103  */
<span class="line-modified">1104 void ssl3CopyBackClientVersion(JNIEnv *env, CK_MECHANISM *ckMechanism,</span>
1105         jobject jMechanism)
1106 {
1107     CK_SSL3_MASTER_KEY_DERIVE_PARAMS *ckSSL3MasterKeyDeriveParams;
1108     ckSSL3MasterKeyDeriveParams =
<span class="line-modified">1109             (CK_SSL3_MASTER_KEY_DERIVE_PARAMS *)ckMechanism-&gt;pParameter;</span>
1110     if (ckSSL3MasterKeyDeriveParams != NULL_PTR) {
<span class="line-modified">1111         copyBackClientVersion(env, ckMechanism, jMechanism,</span>
1112                 ckSSL3MasterKeyDeriveParams-&gt;pVersion,
1113                 CLASS_SSL3_MASTER_KEY_DERIVE_PARAMS);
1114     }
1115 }
1116 
1117 /*
1118  * Copy back the client version information from the native
1119  * structure to the Java object. This is only used for
1120  * CKM_TLS12_MASTER_KEY_DERIVE mechanism when used for deriving a key.
1121  *
1122  */
<span class="line-modified">1123 void tls12CopyBackClientVersion(JNIEnv *env, CK_MECHANISM *ckMechanism,</span>
1124         jobject jMechanism)
1125 {
1126     CK_TLS12_MASTER_KEY_DERIVE_PARAMS *ckTLS12MasterKeyDeriveParams;
1127     ckTLS12MasterKeyDeriveParams =
<span class="line-modified">1128             (CK_TLS12_MASTER_KEY_DERIVE_PARAMS *)ckMechanism-&gt;pParameter;</span>
1129     if (ckTLS12MasterKeyDeriveParams != NULL_PTR) {
<span class="line-modified">1130         copyBackClientVersion(env, ckMechanism, jMechanism,</span>
1131                 ckTLS12MasterKeyDeriveParams-&gt;pVersion,
1132                 CLASS_TLS12_MASTER_KEY_DERIVE_PARAMS);
1133     }
1134 }
1135 
<span class="line-modified">1136 static void copyBackKeyMatParams(JNIEnv *env, CK_MECHANISM *ckMechanism,</span>
1137         jobject jMechanism, CK_SSL3_RANDOM_DATA *RandomInfo,
1138         CK_SSL3_KEY_MAT_OUT_PTR ckSSL3KeyMatOut, const char *class_key_mat_params)
1139 {
1140     jclass jMechanismClass, jKeyMatParamsClass, jSSL3KeyMatOutClass;
1141     jfieldID fieldID;
1142     CK_MECHANISM_TYPE ckMechanismType;
1143     jlong jMechanismType;
1144     CK_BYTE_PTR iv;
1145     jobject jKeyMatParam;
1146     jobject jSSL3KeyMatOut;
1147     jobject jIV;
1148     jint jLength;
1149     jbyte* jBytes;
1150     int i;
1151 
1152     /* get mechanism */
1153     jMechanismClass= (*env)-&gt;FindClass(env, CLASS_MECHANISM);
1154     if (jMechanismClass == NULL) { return; }
1155     fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;mechanism&quot;, &quot;J&quot;);
1156     if (fieldID == NULL) { return; }
1157     jMechanismType = (*env)-&gt;GetLongField(env, jMechanism, fieldID);
1158     ckMechanismType = jLongToCKULong(jMechanismType);
<span class="line-modified">1159     if (ckMechanismType != ckMechanism-&gt;mechanism) {</span>
1160         /* we do not have maching types, this should not occur */
1161         return;
1162     }
1163 
<span class="line-removed">1164     // free malloc&#39;d data</span>
<span class="line-removed">1165     if (RandomInfo-&gt;pClientRandom != NULL) {</span>
<span class="line-removed">1166         free(RandomInfo-&gt;pClientRandom);</span>
<span class="line-removed">1167     }</span>
<span class="line-removed">1168     if (RandomInfo-&gt;pServerRandom != NULL) {</span>
<span class="line-removed">1169         free(RandomInfo-&gt;pServerRandom);</span>
<span class="line-removed">1170     }</span>
<span class="line-removed">1171 </span>
1172     if (ckSSL3KeyMatOut != NULL_PTR) {
1173       /* get the Java params object (pParameter) */
1174       fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;pParameter&quot;,
1175               &quot;Ljava/lang/Object;&quot;);
1176       if (fieldID == NULL) { return; }
1177       jKeyMatParam = (*env)-&gt;GetObjectField(env, jMechanism, fieldID);
1178 
1179       /* get the Java CK_SSL3_KEY_MAT_OUT */
1180       jKeyMatParamsClass = (*env)-&gt;FindClass(env, class_key_mat_params);
1181       if (jKeyMatParamsClass == NULL) { return; }
1182       fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamsClass,
1183               &quot;pReturnedKeyMaterial&quot;, &quot;L&quot;CLASS_SSL3_KEY_MAT_OUT&quot;;&quot;);
1184       if (fieldID == NULL) { return; }
1185       jSSL3KeyMatOut = (*env)-&gt;GetObjectField(env, jKeyMatParam, fieldID);
1186 
1187       /* now copy back all the key handles and the initialization vectors */
1188       /* copy back client MAC secret handle */
1189       jSSL3KeyMatOutClass = (*env)-&gt;FindClass(env, CLASS_SSL3_KEY_MAT_OUT);
1190       if (jSSL3KeyMatOutClass == NULL) { return; }
1191       fieldID = (*env)-&gt;GetFieldID(env, jSSL3KeyMatOutClass,
</pre>
<hr />
<pre>
1213       (*env)-&gt;SetLongField(env, jSSL3KeyMatOut, fieldID,
1214               ckULongToJLong(ckSSL3KeyMatOut-&gt;hServerKey));
1215 
1216       /* copy back the client IV */
1217       fieldID = (*env)-&gt;GetFieldID(env, jSSL3KeyMatOutClass, &quot;pIVClient&quot;, &quot;[B&quot;);
1218       if (fieldID == NULL) { return; }
1219       jIV = (*env)-&gt;GetObjectField(env, jSSL3KeyMatOut, fieldID);
1220       iv = ckSSL3KeyMatOut-&gt;pIVClient;
1221 
1222       if (jIV != NULL) {
1223         jLength = (*env)-&gt;GetArrayLength(env, jIV);
1224         jBytes = (*env)-&gt;GetByteArrayElements(env, jIV, NULL);
1225         if (jBytes == NULL) { return; }
1226         /* copy the bytes to the Java buffer */
1227         for (i=0; i &lt; jLength; i++) {
1228           jBytes[i] = ckByteToJByte(iv[i]);
1229         }
1230         /* copy back the Java buffer to the object */
1231         (*env)-&gt;ReleaseByteArrayElements(env, jIV, jBytes, 0);
1232       }
<span class="line-removed">1233       // free malloc&#39;d data</span>
<span class="line-removed">1234       free(ckSSL3KeyMatOut-&gt;pIVClient);</span>
1235 
1236       /* copy back the server IV */
1237       fieldID = (*env)-&gt;GetFieldID(env, jSSL3KeyMatOutClass, &quot;pIVServer&quot;, &quot;[B&quot;);
1238       if (fieldID == NULL) { return; }
1239       jIV = (*env)-&gt;GetObjectField(env, jSSL3KeyMatOut, fieldID);
1240       iv = ckSSL3KeyMatOut-&gt;pIVServer;
1241 
1242       if (jIV != NULL) {
1243         jLength = (*env)-&gt;GetArrayLength(env, jIV);
1244         jBytes = (*env)-&gt;GetByteArrayElements(env, jIV, NULL);
1245         if (jBytes == NULL) { return; }
1246         /* copy the bytes to the Java buffer */
1247         for (i=0; i &lt; jLength; i++) {
1248           jBytes[i] = ckByteToJByte(iv[i]);
1249         }
1250         /* copy back the Java buffer to the object */
1251         (*env)-&gt;ReleaseByteArrayElements(env, jIV, jBytes, 0);
1252       }
<span class="line-removed">1253       // free malloc&#39;d data</span>
<span class="line-removed">1254       free(ckSSL3KeyMatOut-&gt;pIVServer);</span>
<span class="line-removed">1255       free(ckSSL3KeyMatOut);</span>
1256     }
1257 }
1258 
1259 /*
1260  * Copy back the derived keys and initialization vectors from the native
1261  * structure to the Java object. This is only used for
1262  * CKM_SSL3_KEY_AND_MAC_DERIVE and CKM_TLS_KEY_AND_MAC_DERIVE mechanisms
1263  * when used for deriving a key.
1264  *
1265  */
<span class="line-modified">1266 void ssl3CopyBackKeyMatParams(JNIEnv *env, CK_MECHANISM *ckMechanism,</span>
1267         jobject jMechanism)
1268 {
1269     CK_SSL3_KEY_MAT_PARAMS *ckSSL3KeyMatParam;
<span class="line-modified">1270     ckSSL3KeyMatParam = (CK_SSL3_KEY_MAT_PARAMS *)ckMechanism-&gt;pParameter;</span>
1271     if (ckSSL3KeyMatParam != NULL_PTR) {
<span class="line-modified">1272         copyBackKeyMatParams(env, ckMechanism, jMechanism,</span>
1273                 &amp;(ckSSL3KeyMatParam-&gt;RandomInfo),
1274                 ckSSL3KeyMatParam-&gt;pReturnedKeyMaterial,
1275                 CLASS_SSL3_KEY_MAT_PARAMS);
1276     }
1277 }
1278 
1279 /*
1280  * Copy back the derived keys and initialization vectors from the native
1281  * structure to the Java object. This is only used for
1282  * CKM_TLS12_KEY_AND_MAC_DERIVE mechanism when used for deriving a key.
1283  *
1284  */
<span class="line-modified">1285 void tls12CopyBackKeyMatParams(JNIEnv *env, CK_MECHANISM *ckMechanism,</span>
1286         jobject jMechanism)
1287 {
1288     CK_TLS12_KEY_MAT_PARAMS *ckTLS12KeyMatParam;
<span class="line-modified">1289     ckTLS12KeyMatParam = (CK_TLS12_KEY_MAT_PARAMS *) ckMechanism-&gt;pParameter;</span>
1290     if (ckTLS12KeyMatParam != NULL_PTR) {
<span class="line-modified">1291         copyBackKeyMatParams(env, ckMechanism, jMechanism,</span>
1292                 &amp;(ckTLS12KeyMatParam-&gt;RandomInfo),
1293                 ckTLS12KeyMatParam-&gt;pReturnedKeyMaterial,
1294                 CLASS_TLS12_KEY_MAT_PARAMS);
1295     }
1296 }
1297 
1298 #endif
</pre>
</td>
<td>
<hr />
<pre>
 138     (JNIEnv *env, jobject obj, jlong jSessionHandle, jlong jKeyHandle,
 139     jlong jWrappingKeyHandle, jobject jWrappingMech)
 140 {
 141     jbyteArray returnValue = NULL;
 142     CK_SESSION_HANDLE ckSessionHandle = jLongToCKULong(jSessionHandle);
 143     CK_OBJECT_HANDLE ckObjectHandle = jLongToCKULong(jKeyHandle);
 144     CK_ATTRIBUTE_PTR ckpAttributes = NULL;
 145     CK_RV rv;
 146     jbyteArray nativeKeyInfoArray = NULL;
 147     jbyteArray nativeKeyInfoWrappedKeyArray = NULL;
 148     jbyte* nativeKeyInfoArrayRaw = NULL;
 149     jbyte* nativeKeyInfoWrappedKeyArrayRaw = NULL;
 150     unsigned int sensitiveAttributePosition = (unsigned int)-1;
 151     unsigned int i = 0U;
 152     unsigned long totalDataSize = 0UL, attributesCount = 0UL;
 153     unsigned long totalCkAttributesSize = 0UL, totalNativeKeyInfoArraySize = 0UL;
 154     jbyte* wrappedKeySizePtr = NULL;
 155     jbyte* nativeKeyInfoArrayRawCkAttributes = NULL;
 156     jbyte* nativeKeyInfoArrayRawCkAttributesPtr = NULL;
 157     jbyte* nativeKeyInfoArrayRawDataPtr = NULL;
<span class="line-modified"> 158     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
 159     char iv[16] = {0x0};
 160     CK_ULONG ckWrappedKeyLength = 0U;
 161     jbyte* wrappedKeySizeWrappedKeyArrayPtr = NULL;
 162     CK_BYTE_PTR wrappedKeyBufferPtr = NULL;
 163     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 164     CK_OBJECT_CLASS class;
 165     CK_KEY_TYPE keyType;
 166     CK_BBOOL sensitive;
 167     CK_BBOOL netscapeAttributeValueNeeded = CK_FALSE;
 168     CK_ATTRIBUTE ckNetscapeAttributesTemplate[4];
 169     ckNetscapeAttributesTemplate[0].type = CKA_CLASS;
 170     ckNetscapeAttributesTemplate[1].type = CKA_KEY_TYPE;
 171     ckNetscapeAttributesTemplate[2].type = CKA_SENSITIVE;
 172     ckNetscapeAttributesTemplate[3].type = CKA_NETSCAPE_DB;
 173     ckNetscapeAttributesTemplate[0].pValue = &amp;class;
 174     ckNetscapeAttributesTemplate[1].pValue = &amp;keyType;
 175     ckNetscapeAttributesTemplate[2].pValue = &amp;sensitive;
 176     ckNetscapeAttributesTemplate[3].pValue = 0;
 177     ckNetscapeAttributesTemplate[0].ulValueLen = sizeof(class);
 178     ckNetscapeAttributesTemplate[1].ulValueLen = sizeof(keyType);
</pre>
<hr />
<pre>
 181 
 182     if (ckpFunctions == NULL) { goto cleanup; }
 183 
 184     // If key is private and of DSA or EC type, NSS may require CKA_NETSCAPE_DB
 185     // attribute to unwrap it.
 186     rv = (*ckpFunctions-&gt;C_GetAttributeValue)(ckSessionHandle, ckObjectHandle,
 187             ckNetscapeAttributesTemplate,
 188             sizeof(ckNetscapeAttributesTemplate)/sizeof(CK_ATTRIBUTE));
 189 
 190     if (rv == CKR_OK &amp;&amp; class == CKO_PRIVATE_KEY &amp;&amp;
 191             (keyType == CKK_EC || keyType == CKK_DSA) &amp;&amp;
 192             sensitive == CK_TRUE &amp;&amp;
 193             ckNetscapeAttributesTemplate[3].ulValueLen == CK_UNAVAILABLE_INFORMATION) {
 194         // We cannot set the attribute through C_SetAttributeValue here
 195         // because it might be read-only. However, we can add it to
 196         // the extracted buffer.
 197         netscapeAttributeValueNeeded = CK_TRUE;
 198         TRACE0(&quot;DEBUG: override CKA_NETSCAPE_DB attr value to TRUE\n&quot;);
 199     }
 200 
<span class="line-modified"> 201     ckpAttributes = (CK_ATTRIBUTE_PTR) calloc(</span>
<span class="line-modified"> 202             CK_ATTRIBUTES_TEMPLATE_LENGTH, sizeof(CK_ATTRIBUTE));</span>
 203     if (ckpAttributes == NULL) {
 204         throwOutOfMemoryError(env, 0);
 205         goto cleanup;
 206     }
 207     memcpy(ckpAttributes, ckpAttributesTemplate,
 208             CK_ATTRIBUTES_TEMPLATE_LENGTH * sizeof(CK_ATTRIBUTE));
 209 
 210     // Get sizes for value buffers
 211     // NOTE: may return an error code but length values are filled anyways
 212     (*ckpFunctions-&gt;C_GetAttributeValue)(ckSessionHandle, ckObjectHandle,
 213             ckpAttributes, CK_ATTRIBUTES_TEMPLATE_LENGTH);
 214 
 215     for (i = 0; i &lt; CK_ATTRIBUTES_TEMPLATE_LENGTH; i++) {
 216         if ((ckpAttributes+i)-&gt;ulValueLen != CK_UNAVAILABLE_INFORMATION) {
 217             totalDataSize += (ckpAttributes+i)-&gt;ulValueLen;
 218             if ((ckpAttributes+i)-&gt;type == CKA_SENSITIVE) {
 219                  sensitiveAttributePosition = attributesCount;
 220                  TRACE0(&quot;DEBUG: GetNativeKeyInfo key is sensitive&quot;);
 221             }
 222             attributesCount++;
</pre>
<hr />
<pre>
 291 
 292     // Get attribute&#39;s values
 293     rv = (*ckpFunctions-&gt;C_GetAttributeValue)(ckSessionHandle, ckObjectHandle,
 294             (CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes,
 295             attributesCount);
 296     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
 297         goto cleanup;
 298     }
 299 
 300     TRACE0(&quot;DEBUG: GetNativeKeyInfo 1st C_GetAttributeValue call passed\n&quot;);
 301 
 302     if (netscapeAttributeValueNeeded) {
 303         (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).type = CKA_NETSCAPE_DB;
 304         // Value is not needed, public key is not used
 305     }
 306 
 307     if ((sensitiveAttributePosition != (unsigned int)-1) &amp;&amp;
 308         *(CK_BBOOL*)(((CK_ATTRIBUTE_PTR)(((CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes)
 309                 +sensitiveAttributePosition))-&gt;pValue) == CK_TRUE) {
 310         // Key is sensitive. Need to extract it wrapped.
<span class="line-modified"> 311         if (jWrappingKeyHandle != 0) {</span>
 312 
<span class="line-modified"> 313             ckpMechanism = jMechanismToCKMechanismPtr(env, jWrappingMech);</span>
<span class="line-modified"> 314             rv = (*ckpFunctions-&gt;C_WrapKey)(ckSessionHandle, ckpMechanism,</span>
 315                     jLongToCKULong(jWrappingKeyHandle), ckObjectHandle,
 316                     NULL_PTR, &amp;ckWrappedKeyLength);
 317             if (ckWrappedKeyLength != 0) {
 318                 // Allocate space for getting the wrapped key
 319                 nativeKeyInfoWrappedKeyArray = (*env)-&gt;NewByteArray(env,
 320                         totalNativeKeyInfoArraySize + ckWrappedKeyLength);
 321                 if (nativeKeyInfoWrappedKeyArray == NULL) {
 322                     goto cleanup;
 323                 }
 324                 nativeKeyInfoWrappedKeyArrayRaw =
 325                         (*env)-&gt;GetByteArrayElements(env,
 326                                 nativeKeyInfoWrappedKeyArray, NULL);
 327                 if (nativeKeyInfoWrappedKeyArrayRaw == NULL) {
 328                     goto cleanup;
 329                 }
 330                 memcpy(nativeKeyInfoWrappedKeyArrayRaw, nativeKeyInfoArrayRaw,
 331                         totalNativeKeyInfoArraySize);
 332                 wrappedKeySizeWrappedKeyArrayPtr =
 333                         nativeKeyInfoWrappedKeyArrayRaw +
 334                         sizeof(unsigned long)*2 + totalCkAttributesSize +
 335                         totalDataSize;
 336                 memcpy(wrappedKeySizeWrappedKeyArrayPtr, &amp;ckWrappedKeyLength, sizeof(unsigned long));
 337                 TRACE1(&quot;DEBUG: GetNativeKeyInfo 1st C_WrapKey wrappedKeyLength = %lu\n&quot;, ckWrappedKeyLength);
 338 
 339                 wrappedKeyBufferPtr =
 340                         (CK_BYTE_PTR) (wrappedKeySizeWrappedKeyArrayPtr +
 341                         sizeof(unsigned long));
<span class="line-modified"> 342                 rv = (*ckpFunctions-&gt;C_WrapKey)(ckSessionHandle, ckpMechanism,</span>
 343                         jLongToCKULong(jWrappingKeyHandle),ckObjectHandle,
 344                         wrappedKeyBufferPtr, &amp;ckWrappedKeyLength);
 345                 if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
 346                     goto cleanup;
 347                 }
 348                 memcpy(wrappedKeySizeWrappedKeyArrayPtr, &amp;ckWrappedKeyLength, sizeof(unsigned long));
 349                 TRACE1(&quot;DEBUG: GetNativeKeyInfo 2nd C_WrapKey wrappedKeyLength = %lu\n&quot;, ckWrappedKeyLength);
 350             } else {
 351                 goto cleanup;
 352             }
 353         } else {
<span class="line-added"> 354             ckAssertReturnValueOK(env, CKR_KEY_HANDLE_INVALID);</span>
 355             goto cleanup;
 356         }
 357         returnValue = nativeKeyInfoWrappedKeyArray;
 358     } else {
 359         returnValue = nativeKeyInfoArray;
 360     }
 361 
 362 cleanup:
 363     if (ckpAttributes != NULL) {
 364         free(ckpAttributes);
 365     }
 366 
 367     if (nativeKeyInfoArrayRaw != NULL) {
 368         (*env)-&gt;ReleaseByteArrayElements(env, nativeKeyInfoArray,
 369                 nativeKeyInfoArrayRaw, 0);
 370     }
 371 
 372     if (nativeKeyInfoWrappedKeyArrayRaw != NULL) {
 373         (*env)-&gt;ReleaseByteArrayElements(env, nativeKeyInfoWrappedKeyArray,
 374                 nativeKeyInfoWrappedKeyArrayRaw, 0);
 375     }
 376 
 377     if (nativeKeyInfoArray != NULL &amp;&amp; returnValue != nativeKeyInfoArray) {
 378         (*env)-&gt;DeleteLocalRef(env, nativeKeyInfoArray);
 379     }
 380 
 381     if (nativeKeyInfoWrappedKeyArray != NULL
 382             &amp;&amp; returnValue != nativeKeyInfoWrappedKeyArray) {
 383         (*env)-&gt;DeleteLocalRef(env, nativeKeyInfoWrappedKeyArray);
 384     }
<span class="line-added"> 385     freeCKMechanismPtr(ckpMechanism);</span>
 386 
 387     return returnValue;
 388 }
 389 #endif
 390 
 391 #ifdef P11_ENABLE_CREATENATIVEKEY
 392 /*
 393  * Class:     sun_security_pkcs11_wrapper_PKCS11
 394  * Method:    createNativeKey
 395  * Signature: (J[BJLsun/security/pkcs11/wrapper/CK_MECHANISM;)J
 396  * Parametermapping:                          *PKCS11*
 397  * @param   jlong         jSessionHandle      CK_SESSION_HANDLE hSession
 398  * @param   jbyteArray    jNativeKeyInfo      -
 399  * @param   jlong         jWrappingKeyHandle  CK_OBJECT_HANDLE hObject
 400  * @param   jobject       jWrappingMech       CK_MECHANISM_PTR pMechanism
 401  * @return  jlong         jKeyHandle          CK_OBJECT_HANDLE hObject
 402  */
 403 JNIEXPORT jlong JNICALL
 404 Java_sun_security_pkcs11_wrapper_PKCS11_createNativeKey
 405     (JNIEnv *env, jobject obj, jlong jSessionHandle, jbyteArray jNativeKeyInfo,
 406     jlong jWrappingKeyHandle, jobject jWrappingMech)
 407 {
 408     CK_OBJECT_HANDLE ckObjectHandle;
 409     CK_RV rv;
 410     CK_SESSION_HANDLE ckSessionHandle = jLongToCKULong(jSessionHandle);
 411     jbyte* nativeKeyInfoArrayRaw = NULL;
 412     jlong jObjectHandle = 0L;
 413     unsigned long totalCkAttributesSize = 0UL;
 414     unsigned long nativeKeyInfoCkAttributesCount = 0UL;
 415     jbyte* nativeKeyInfoArrayRawCkAttributes = NULL;
 416     jbyte* nativeKeyInfoArrayRawCkAttributesPtr = NULL;
 417     jbyte* nativeKeyInfoArrayRawDataPtr = NULL;
 418     unsigned long totalDataSize = 0UL;
 419     jbyte* wrappedKeySizePtr = NULL;
 420     unsigned int i = 0U;
<span class="line-modified"> 421     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
 422     char iv[16] = {0x0};
 423     CK_ULONG ckWrappedKeyLength = 0UL;
 424     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 425 
 426     if (ckpFunctions == NULL) { goto cleanup; }
 427 
 428     nativeKeyInfoArrayRaw =
 429             (*env)-&gt;GetByteArrayElements(env, jNativeKeyInfo, NULL);
 430     if (nativeKeyInfoArrayRaw == NULL) {
 431         goto cleanup;
 432     }
 433 
 434     memcpy(&amp;totalCkAttributesSize, nativeKeyInfoArrayRaw, sizeof(unsigned long));
 435     TRACE1(&quot;DEBUG: createNativeKey totalCkAttributesSize = %lu\n&quot;, totalCkAttributesSize);
 436     nativeKeyInfoCkAttributesCount = totalCkAttributesSize/sizeof(CK_ATTRIBUTE);
 437     TRACE1(&quot;DEBUG: createNativeKey nativeKeyInfoCkAttributesCount = %lu\n&quot;, nativeKeyInfoCkAttributesCount);
 438 
 439     nativeKeyInfoArrayRawCkAttributes = nativeKeyInfoArrayRaw +
 440             sizeof(unsigned long);
 441     nativeKeyInfoArrayRawCkAttributesPtr = nativeKeyInfoArrayRawCkAttributes;
</pre>
<hr />
<pre>
 452     TRACE1(&quot;DEBUG: createNativeKey wrappedKeyLength = %lu\n&quot;, ckWrappedKeyLength);
 453 
 454     for (i = 0; i &lt; nativeKeyInfoCkAttributesCount; i++) {
 455         if ((*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).ulValueLen
 456                 &gt; 0) {
 457             (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).pValue =
 458                     nativeKeyInfoArrayRawDataPtr;
 459         }
 460         nativeKeyInfoArrayRawDataPtr +=
 461                 (*(CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributesPtr).ulValueLen;
 462         nativeKeyInfoArrayRawCkAttributesPtr += sizeof(CK_ATTRIBUTE);
 463     }
 464 
 465     if (ckWrappedKeyLength == 0) {
 466         // Not a wrapped key
 467         rv = (*ckpFunctions-&gt;C_CreateObject)(ckSessionHandle,
 468                 (CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes,
 469                 jLongToCKULong(nativeKeyInfoCkAttributesCount), &amp;ckObjectHandle);
 470     } else {
 471         // Wrapped key
<span class="line-modified"> 472         ckpMechanism = jMechanismToCKMechanismPtr(env, jWrappingMech);</span>
<span class="line-modified"> 473         rv = (*ckpFunctions-&gt;C_UnwrapKey)(ckSessionHandle, ckpMechanism,</span>
 474                 jLongToCKULong(jWrappingKeyHandle),
 475                 (CK_BYTE_PTR)(wrappedKeySizePtr + sizeof(unsigned long)),
 476                 ckWrappedKeyLength,
 477                 (CK_ATTRIBUTE_PTR)nativeKeyInfoArrayRawCkAttributes,
 478                 jLongToCKULong(nativeKeyInfoCkAttributesCount),
 479                 &amp;ckObjectHandle);
 480     }
 481     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {
 482         goto cleanup;
 483     }
 484 
 485     jObjectHandle = ckULongToJLong(ckObjectHandle);
 486 
 487 cleanup:
 488 
 489     if (nativeKeyInfoArrayRaw != NULL) {
 490         (*env)-&gt;ReleaseByteArrayElements(env, jNativeKeyInfo,
 491                 nativeKeyInfoArrayRaw, JNI_ABORT);
 492     }
 493 
<span class="line-added"> 494     freeCKMechanismPtr(ckpMechanism);</span>
 495     return jObjectHandle;
 496 }
 497 #endif
 498 
 499 #ifdef P11_ENABLE_C_GENERATEKEY
 500 /*
 501  * Class:     sun_security_pkcs11_wrapper_PKCS11
 502  * Method:    C_GenerateKey
 503  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;)J
 504  * Parametermapping:                    *PKCS11*
 505  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 506  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
 507  * @param   jobjectArray jTemplate      CK_ATTRIBUTE_PTR pTemplate
 508  *                                      CK_ULONG ulCount
 509  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE_PTR phKey
 510  */
 511 JNIEXPORT jlong JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1GenerateKey
 512     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jobjectArray jTemplate)
 513 {
 514     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified"> 515     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
 516     CK_ATTRIBUTE_PTR ckpAttributes = NULL_PTR;
<span class="line-modified"> 517     CK_ULONG ckAttributesLength = 0;</span>
 518     CK_OBJECT_HANDLE ckKeyHandle = 0;
 519     jlong jKeyHandle = 0L;
 520     CK_RV rv;
 521 
 522     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 523     if (ckpFunctions == NULL) { return 0L; }
 524 
 525     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified"> 526     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
 527     if ((*env)-&gt;ExceptionCheck(env)) { return 0L ; }
 528 
 529     jAttributeArrayToCKAttributeArray(env, jTemplate, &amp;ckpAttributes, &amp;ckAttributesLength);
 530     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 531         goto cleanup;</span>



 532     }
 533 
<span class="line-modified"> 534     rv = (*ckpFunctions-&gt;C_GenerateKey)(ckSessionHandle, ckpMechanism, ckpAttributes, ckAttributesLength, &amp;ckKeyHandle);</span>
 535 
 536     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
 537         jKeyHandle = ckULongToJLong(ckKeyHandle);
 538 
 539         /* cheack, if we must give a initialization vector back to Java */
<span class="line-modified"> 540         switch (ckpMechanism-&gt;mechanism) {</span>
 541         case CKM_PBE_MD2_DES_CBC:
 542         case CKM_PBE_MD5_DES_CBC:
 543         case CKM_PBE_MD5_CAST_CBC:
 544         case CKM_PBE_MD5_CAST3_CBC:
 545         case CKM_PBE_MD5_CAST128_CBC:
 546         /* case CKM_PBE_MD5_CAST5_CBC:  the same as CKM_PBE_MD5_CAST128_CBC */
 547         case CKM_PBE_SHA1_CAST128_CBC:
 548         /* case CKM_PBE_SHA1_CAST5_CBC: the same as CKM_PBE_SHA1_CAST128_CBC */
 549             /* we must copy back the initialization vector to the jMechanism object */
<span class="line-modified"> 550             copyBackPBEInitializationVector(env, ckpMechanism, jMechanism);</span>
 551             break;
 552         }
 553     }
<span class="line-modified"> 554 cleanup:</span>
<span class="line-modified"> 555     freeCKMechanismPtr(ckpMechanism);</span>


 556     freeCKAttributeArray(ckpAttributes, ckAttributesLength);
 557 
 558     return jKeyHandle ;
 559 }
 560 #endif
 561 
 562 #ifdef P11_ENABLE_C_GENERATEKEYPAIR
 563 /*
 564  * Class:     sun_security_pkcs11_wrapper_PKCS11
 565  * Method:    C_GenerateKeyPair
 566  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;)[J
 567  * Parametermapping:                          *PKCS11*
 568  * @param   jlong jSessionHandle              CK_SESSION_HANDLE hSession
 569  * @param   jobject jMechanism                CK_MECHANISM_PTR pMechanism
 570  * @param   jobjectArray jPublicKeyTemplate   CK_ATTRIBUTE_PTR pPublicKeyTemplate
 571  *                                            CK_ULONG ulPublicKeyAttributeCount
 572  * @param   jobjectArray jPrivateKeyTemplate  CK_ATTRIBUTE_PTR pPrivateKeyTemplate
 573  *                                            CK_ULONG ulPrivateKeyAttributeCount
 574  * @return  jlongArray jKeyHandles            CK_OBJECT_HANDLE_PTR phPublicKey
 575  *                                            CK_OBJECT_HANDLE_PTR phPublicKey
 576  */
 577 JNIEXPORT jlongArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1GenerateKeyPair
 578     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism,
 579      jobjectArray jPublicKeyTemplate, jobjectArray jPrivateKeyTemplate)
 580 {
 581     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified"> 582     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
 583     CK_ATTRIBUTE_PTR ckpPublicKeyAttributes = NULL_PTR;
 584     CK_ATTRIBUTE_PTR ckpPrivateKeyAttributes = NULL_PTR;
<span class="line-modified"> 585     CK_ULONG ckPublicKeyAttributesLength = 0;</span>
<span class="line-modified"> 586     CK_ULONG ckPrivateKeyAttributesLength = 0;</span>
 587     CK_OBJECT_HANDLE_PTR ckpPublicKeyHandle;  /* pointer to Public Key */
 588     CK_OBJECT_HANDLE_PTR ckpPrivateKeyHandle; /* pointer to Private Key */
<span class="line-modified"> 589     CK_OBJECT_HANDLE_PTR ckpKeyHandles = NULL; /* pointer to array with Public and Private Key */</span>
 590     jlongArray jKeyHandles = NULL;
 591     CK_RV rv;
 592     int attempts;
 593     const int MAX_ATTEMPTS = 3;
 594 
 595     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 596     if (ckpFunctions == NULL) { return NULL; }
 597 
 598     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified"> 599     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
 600     if ((*env)-&gt;ExceptionCheck(env)) { return NULL; }
 601 
<span class="line-modified"> 602     ckpKeyHandles = (CK_OBJECT_HANDLE_PTR) calloc(2, sizeof(CK_OBJECT_HANDLE));</span>
 603     if (ckpKeyHandles == NULL) {



 604         throwOutOfMemoryError(env, 0);
<span class="line-modified"> 605         goto cleanup;</span>
 606     }
 607     ckpPublicKeyHandle = ckpKeyHandles;   /* first element of array is Public Key */
 608     ckpPrivateKeyHandle = (ckpKeyHandles + 1);  /* second element of array is Private Key */
 609 
 610     jAttributeArrayToCKAttributeArray(env, jPublicKeyTemplate, &amp;ckpPublicKeyAttributes, &amp;ckPublicKeyAttributesLength);
 611     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 612         goto cleanup;</span>




 613     }
 614 
 615     jAttributeArrayToCKAttributeArray(env, jPrivateKeyTemplate, &amp;ckpPrivateKeyAttributes, &amp;ckPrivateKeyAttributesLength);
 616     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 617         goto cleanup;</span>





 618     }
 619 
 620     /*
 621      * Workaround for NSS bug 1012786:
 622      *
 623      * Key generation may fail with CKR_FUNCTION_FAILED error
 624      * if there is insufficient entropy to generate a random key.
 625      *
 626      * PKCS11 spec says the following about CKR_FUNCTION_FAILED error
 627      * (see section 11.1.1):
 628      *
 629      *      ... In any event, although the function call failed, the situation
 630      *      is not necessarily totally hopeless, as it is likely to be
 631      *      when CKR_GENERAL_ERROR is returned. Depending on what the root cause of
 632      *      the error actually was, it is possible that an attempt
 633      *      to make the exact same function call again would succeed.
 634      *
 635      * Call C_GenerateKeyPair() several times if CKR_FUNCTION_FAILED occurs.
 636      */
 637     for (attempts = 0; attempts &lt; MAX_ATTEMPTS; attempts++) {
<span class="line-modified"> 638         rv = (*ckpFunctions-&gt;C_GenerateKeyPair)(ckSessionHandle, ckpMechanism,</span>
 639                         ckpPublicKeyAttributes, ckPublicKeyAttributesLength,
 640                         ckpPrivateKeyAttributes, ckPrivateKeyAttributesLength,
 641                         ckpPublicKeyHandle, ckpPrivateKeyHandle);
 642         if (rv == CKR_FUNCTION_FAILED) {
 643             printDebug(&quot;C_1GenerateKeyPair(): C_GenerateKeyPair() failed \
 644                     with CKR_FUNCTION_FAILED error, try again\n&quot;);
 645         } else {
 646             break;
 647         }
 648     }
 649 
 650     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
 651         jKeyHandles = ckULongArrayToJLongArray(env, ckpKeyHandles, 2);
 652     }
 653 
<span class="line-modified"> 654 cleanup:</span>
<span class="line-modified"> 655     freeCKMechanismPtr(ckpMechanism);</span>

 656     free(ckpKeyHandles);
 657     freeCKAttributeArray(ckpPublicKeyAttributes, ckPublicKeyAttributesLength);
 658     freeCKAttributeArray(ckpPrivateKeyAttributes, ckPrivateKeyAttributesLength);

 659     return jKeyHandles ;
 660 }
 661 #endif
 662 
 663 #ifdef P11_ENABLE_C_WRAPKEY
 664 /*
 665  * Class:     sun_security_pkcs11_wrapper_PKCS11
 666  * Method:    C_WrapKey
 667  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;JJ)[B
 668  * Parametermapping:                    *PKCS11*
 669  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 670  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
 671  * @param   jlong jWrappingKeyHandle    CK_OBJECT_HANDLE hWrappingKey
 672  * @param   jlong jKeyHandle            CK_OBJECT_HANDLE hKey
 673  * @return  jbyteArray jWrappedKey      CK_BYTE_PTR pWrappedKey
 674  *                                      CK_ULONG_PTR pulWrappedKeyLen
 675  */
 676 JNIEXPORT jbyteArray JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1WrapKey
 677     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jWrappingKeyHandle, jlong jKeyHandle)
 678 {
 679     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified"> 680     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
 681     CK_OBJECT_HANDLE ckWrappingKeyHandle;
 682     CK_OBJECT_HANDLE ckKeyHandle;
 683     jbyteArray jWrappedKey = NULL;
 684     CK_RV rv;
 685     CK_BYTE BUF[MAX_STACK_BUFFER_LEN];
 686     CK_BYTE_PTR ckpWrappedKey = BUF;
 687     CK_ULONG ckWrappedKeyLength = MAX_STACK_BUFFER_LEN;
 688 
 689     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 690     if (ckpFunctions == NULL) { return NULL; }
 691 
 692     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified"> 693     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
 694     if ((*env)-&gt;ExceptionCheck(env)) { return NULL; }
 695 
 696     ckWrappingKeyHandle = jLongToCKULong(jWrappingKeyHandle);
 697     ckKeyHandle = jLongToCKULong(jKeyHandle);
 698 
<span class="line-modified"> 699     rv = (*ckpFunctions-&gt;C_WrapKey)(ckSessionHandle, ckpMechanism, ckWrappingKeyHandle, ckKeyHandle, ckpWrappedKey, &amp;ckWrappedKeyLength);</span>
 700     if (rv == CKR_BUFFER_TOO_SMALL) {
<span class="line-modified"> 701         ckpWrappedKey = (CK_BYTE_PTR)</span>
<span class="line-added"> 702                 calloc(ckWrappedKeyLength, sizeof(CK_BYTE));</span>
 703         if (ckpWrappedKey == NULL) {



 704             throwOutOfMemoryError(env, 0);
<span class="line-modified"> 705             goto cleanup;</span>
 706         }
 707 
<span class="line-modified"> 708         rv = (*ckpFunctions-&gt;C_WrapKey)(ckSessionHandle, ckpMechanism, ckWrappingKeyHandle, ckKeyHandle, ckpWrappedKey, &amp;ckWrappedKeyLength);</span>
 709     }
 710     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
 711         jWrappedKey = ckByteArrayToJByteArray(env, ckpWrappedKey, ckWrappedKeyLength);
 712     }
 713 
<span class="line-added"> 714 cleanup:</span>
 715     if (ckpWrappedKey != BUF) { free(ckpWrappedKey); }
<span class="line-modified"> 716     freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-modified"> 717 </span>

 718     return jWrappedKey ;
 719 }
 720 #endif
 721 
 722 #ifdef P11_ENABLE_C_UNWRAPKEY
 723 /*
 724  * Class:     sun_security_pkcs11_wrapper_PKCS11
 725  * Method:    C_UnwrapKey
 726  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J[B[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;)J
 727  * Parametermapping:                    *PKCS11*
 728  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 729  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
 730  * @param   jlong jUnwrappingKeyHandle  CK_OBJECT_HANDLE hUnwrappingKey
 731  * @param   jbyteArray jWrappedKey      CK_BYTE_PTR pWrappedKey
 732  *                                      CK_ULONG_PTR pulWrappedKeyLen
 733  * @param   jobjectArray jTemplate      CK_ATTRIBUTE_PTR pTemplate
 734  *                                      CK_ULONG ulCount
 735  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE_PTR phKey
 736  */
 737 JNIEXPORT jlong JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1UnwrapKey
 738     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jUnwrappingKeyHandle,
 739      jbyteArray jWrappedKey, jobjectArray jTemplate)
 740 {
 741     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified"> 742     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
 743     CK_OBJECT_HANDLE ckUnwrappingKeyHandle;
 744     CK_BYTE_PTR ckpWrappedKey = NULL_PTR;
 745     CK_ULONG ckWrappedKeyLength;
 746     CK_ATTRIBUTE_PTR ckpAttributes = NULL_PTR;
<span class="line-modified"> 747     CK_ULONG ckAttributesLength = 0;</span>
 748     CK_OBJECT_HANDLE ckKeyHandle = 0;
 749     jlong jKeyHandle = 0L;
 750     CK_RV rv;
 751 
 752     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 753     if (ckpFunctions == NULL) { return 0L; }
 754 
 755     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified"> 756     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
 757     if ((*env)-&gt;ExceptionCheck(env)) { return 0L; }
 758 
 759     ckUnwrappingKeyHandle = jLongToCKULong(jUnwrappingKeyHandle);
 760     jByteArrayToCKByteArray(env, jWrappedKey, &amp;ckpWrappedKey, &amp;ckWrappedKeyLength);
 761     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 762         goto cleanup;</span>



 763     }
 764 
 765     jAttributeArrayToCKAttributeArray(env, jTemplate, &amp;ckpAttributes, &amp;ckAttributesLength);
 766     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 767         goto cleanup;</span>




 768     }
 769 
 770 
<span class="line-modified"> 771     rv = (*ckpFunctions-&gt;C_UnwrapKey)(ckSessionHandle, ckpMechanism, ckUnwrappingKeyHandle,</span>
 772                  ckpWrappedKey, ckWrappedKeyLength,
 773                  ckpAttributes, ckAttributesLength, &amp;ckKeyHandle);
 774 
 775     if (ckAssertReturnValueOK(env, rv) == CK_ASSERT_OK) {
 776         jKeyHandle = ckLongToJLong(ckKeyHandle);
 777 
 778 #if 0
 779         /* cheack, if we must give a initialization vector back to Java */
<span class="line-modified"> 780         if (ckpMechanism-&gt;mechanism == CKM_KEY_WRAP_SET_OAEP) {</span>
 781             /* we must copy back the unwrapped key info to the jMechanism object */
<span class="line-modified"> 782             copyBackSetUnwrappedKey(env, ckpMechanism, jMechanism);</span>
 783         }
 784 #endif
 785     }
<span class="line-modified"> 786 cleanup:</span>
<span class="line-modified"> 787     freeCKMechanismPtr(ckpMechanism);</span>


 788     freeCKAttributeArray(ckpAttributes, ckAttributesLength);
 789     free(ckpWrappedKey);
 790 
 791     return jKeyHandle ;
 792 }
 793 #endif
 794 
 795 #ifdef P11_ENABLE_C_DERIVEKEY
 796 












































 797 /*
 798  * Copy back the PRF output to Java.
 799  */
<span class="line-modified"> 800 void copyBackTLSPrfParams(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism, jobject jMechanism)</span>
 801 {
 802     jclass jMechanismClass, jTLSPrfParamsClass;
 803     CK_TLS_PRF_PARAMS *ckTLSPrfParams;
 804     jobject jTLSPrfParams;
 805     jfieldID fieldID;
 806     CK_MECHANISM_TYPE ckMechanismType;
 807     jlong jMechanismType;
 808     CK_BYTE_PTR output;
 809     jobject jOutput;
 810     jint jLength;
 811     jbyte* jBytes;
 812     int i;
 813 
 814     /* get mechanism */
 815     jMechanismClass = (*env)-&gt;FindClass(env, CLASS_MECHANISM);
 816     if (jMechanismClass == NULL) { return; }
 817     fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;mechanism&quot;, &quot;J&quot;);
 818     if (fieldID == NULL) { return; }
 819     jMechanismType = (*env)-&gt;GetLongField(env, jMechanism, fieldID);
 820     ckMechanismType = jLongToCKULong(jMechanismType);
<span class="line-modified"> 821     if (ckMechanismType != ckpMechanism-&gt;mechanism) {</span>
 822         /* we do not have maching types, this should not occur */
 823         return;
 824     }
 825 
 826     /* get the native CK_TLS_PRF_PARAMS */
<span class="line-modified"> 827     ckTLSPrfParams = (CK_TLS_PRF_PARAMS *) ckpMechanism-&gt;pParameter;</span>
 828     if (ckTLSPrfParams != NULL_PTR) {
 829         /* get the Java CK_TLS_PRF_PARAMS object (pParameter) */
 830         fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;pParameter&quot;, &quot;Ljava/lang/Object;&quot;);
 831         if (fieldID == NULL) { return; }
 832         jTLSPrfParams = (*env)-&gt;GetObjectField(env, jMechanism, fieldID);
 833 
 834         /* copy back the client IV */
 835         jTLSPrfParamsClass = (*env)-&gt;FindClass(env, CLASS_TLS_PRF_PARAMS);
 836         if (jTLSPrfParamsClass == NULL) { return; }
 837         fieldID = (*env)-&gt;GetFieldID(env, jTLSPrfParamsClass, &quot;pOutput&quot;, &quot;[B&quot;);
 838         if (fieldID == NULL) { return; }
 839         jOutput = (*env)-&gt;GetObjectField(env, jTLSPrfParams, fieldID);
 840         output = ckTLSPrfParams-&gt;pOutput;
 841 
 842         // Note: we assume that the token returned exactly as many bytes as we
 843         // requested. Anything else would not make sense.
 844         if (jOutput != NULL) {
 845             jLength = (*env)-&gt;GetArrayLength(env, jOutput);
 846             jBytes = (*env)-&gt;GetByteArrayElements(env, jOutput, NULL);
 847             if (jBytes == NULL) { return; }
 848 
 849             /* copy the bytes to the Java buffer */
 850             for (i=0; i &lt; jLength; i++) {
 851                 jBytes[i] = ckByteToJByte(output[i]);
 852             }
 853             /* copy back the Java buffer to the object */
 854             (*env)-&gt;ReleaseByteArrayElements(env, jOutput, jBytes, 0);
 855         }






 856     }
 857 }
 858 
 859 /*
 860  * Class:     sun_security_pkcs11_wrapper_PKCS11
 861  * Method:    C_DeriveKey
 862  * Signature: (JLsun/security/pkcs11/wrapper/CK_MECHANISM;J[Lsun/security/pkcs11/wrapper/CK_ATTRIBUTE;)J
 863  * Parametermapping:                    *PKCS11*
 864  * @param   jlong jSessionHandle        CK_SESSION_HANDLE hSession
 865  * @param   jobject jMechanism          CK_MECHANISM_PTR pMechanism
 866  * @param   jlong jBaseKeyHandle        CK_OBJECT_HANDLE hBaseKey
 867  * @param   jobjectArray jTemplate      CK_ATTRIBUTE_PTR pTemplate
 868  *                                      CK_ULONG ulCount
 869  * @return  jlong jKeyHandle            CK_OBJECT_HANDLE_PTR phKey
 870  */
 871 JNIEXPORT jlong JNICALL Java_sun_security_pkcs11_wrapper_PKCS11_C_1DeriveKey
 872     (JNIEnv *env, jobject obj, jlong jSessionHandle, jobject jMechanism, jlong jBaseKeyHandle, jobjectArray jTemplate)
 873 {
 874     CK_SESSION_HANDLE ckSessionHandle;
<span class="line-modified"> 875     CK_MECHANISM_PTR ckpMechanism = NULL;</span>
 876     CK_OBJECT_HANDLE ckBaseKeyHandle;
 877     CK_ATTRIBUTE_PTR ckpAttributes = NULL_PTR;
<span class="line-modified"> 878     CK_ULONG ckAttributesLength = 0;</span>
 879     CK_OBJECT_HANDLE ckKeyHandle = 0;
 880     jlong jKeyHandle = 0L;
 881     CK_RV rv;
 882     CK_OBJECT_HANDLE_PTR phKey = &amp;ckKeyHandle;
 883 
 884     CK_FUNCTION_LIST_PTR ckpFunctions = getFunctionList(env, obj);
 885     if (ckpFunctions == NULL) { return 0L; }
 886 
 887     ckSessionHandle = jLongToCKULong(jSessionHandle);
<span class="line-modified"> 888     ckpMechanism = jMechanismToCKMechanismPtr(env, jMechanism);</span>
 889     if ((*env)-&gt;ExceptionCheck(env)) { return 0L; }
 890 
 891     ckBaseKeyHandle = jLongToCKULong(jBaseKeyHandle);
 892     jAttributeArrayToCKAttributeArray(env, jTemplate, &amp;ckpAttributes, &amp;ckAttributesLength);
 893     if ((*env)-&gt;ExceptionCheck(env)) {
<span class="line-modified"> 894         goto cleanup;</span>



 895     }
 896 
<span class="line-modified"> 897     switch (ckpMechanism-&gt;mechanism) {</span>
 898     case CKM_SSL3_KEY_AND_MAC_DERIVE:
 899     case CKM_TLS_KEY_AND_MAC_DERIVE:
 900     case CKM_TLS12_KEY_AND_MAC_DERIVE:
 901     case CKM_TLS_PRF:
 902         // these mechanism do not return a key handle via phKey
 903         // set to NULL in case pedantic implementations check for it
 904         phKey = NULL;
 905         break;
 906     default:
 907         // empty
 908         break;
 909     }
 910 
<span class="line-modified"> 911     rv = (*ckpFunctions-&gt;C_DeriveKey)(ckSessionHandle, ckpMechanism, ckBaseKeyHandle,</span>
 912                  ckpAttributes, ckAttributesLength, phKey);
 913 
 914     jKeyHandle = ckLongToJLong(ckKeyHandle);
 915 
<span class="line-modified"> 916     switch (ckpMechanism-&gt;mechanism) {</span>


 917     case CKM_SSL3_MASTER_KEY_DERIVE:
 918     case CKM_TLS_MASTER_KEY_DERIVE:
 919         /* we must copy back the client version */
<span class="line-modified"> 920         ssl3CopyBackClientVersion(env, ckpMechanism, jMechanism);</span>

 921         break;
 922     case CKM_TLS12_MASTER_KEY_DERIVE:
<span class="line-modified"> 923         tls12CopyBackClientVersion(env, ckpMechanism, jMechanism);</span>








 924         break;
 925     case CKM_SSL3_KEY_AND_MAC_DERIVE:
 926     case CKM_TLS_KEY_AND_MAC_DERIVE:
 927         /* we must copy back the unwrapped key info to the jMechanism object */
<span class="line-modified"> 928         ssl3CopyBackKeyMatParams(env, ckpMechanism, jMechanism);</span>
 929         break;
 930     case CKM_TLS12_KEY_AND_MAC_DERIVE:
 931         /* we must copy back the unwrapped key info to the jMechanism object */
<span class="line-modified"> 932         tls12CopyBackKeyMatParams(env, ckpMechanism, jMechanism);</span>
 933         break;
 934     case CKM_TLS_PRF:
<span class="line-modified"> 935         copyBackTLSPrfParams(env, ckpMechanism, jMechanism);</span>



 936         break;
 937     default:
 938         // empty
 939         break;
 940     }
<span class="line-modified"> 941     if (ckAssertReturnValueOK(env, rv) != CK_ASSERT_OK) {</span>
<span class="line-modified"> 942         jKeyHandle =0L;</span>

 943     }
<span class="line-modified"> 944 </span>
<span class="line-added"> 945 cleanup:</span>
<span class="line-added"> 946     freeCKMechanismPtr(ckpMechanism);</span>
<span class="line-added"> 947     freeCKAttributeArray(ckpAttributes, ckAttributesLength);</span>
 948 
 949     return jKeyHandle ;
 950 }
 951 
<span class="line-modified"> 952 static void copyBackClientVersion(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism, jobject jMechanism,</span>
 953         CK_VERSION *ckVersion, const char *class_master_key_derive_params)
 954 {
 955     jclass jMasterKeyDeriveParamsClass, jMechanismClass, jVersionClass;
 956     jobject jMasterKeyDeriveParams;
 957     jfieldID fieldID;
 958     CK_MECHANISM_TYPE ckMechanismType;
 959     jlong jMechanismType;
 960     jobject jVersion;
 961 
 962     /* get mechanism */
 963     jMechanismClass = (*env)-&gt;FindClass(env, CLASS_MECHANISM);
 964     if (jMechanismClass == NULL) { return; }
 965     fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;mechanism&quot;, &quot;J&quot;);
 966     if (fieldID == NULL) { return; }
 967     jMechanismType = (*env)-&gt;GetLongField(env, jMechanism, fieldID);
 968     ckMechanismType = jLongToCKULong(jMechanismType);
<span class="line-modified"> 969     if (ckMechanismType != ckpMechanism-&gt;mechanism) {</span>
 970         /* we do not have maching types, this should not occur */
 971         return;
 972     }
 973 
 974     if (ckVersion != NULL_PTR) {
 975       /* get the Java CK_SSL3_MASTER_KEY_DERIVE_PARAMS (pParameter) */
 976       fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;pParameter&quot;, &quot;Ljava/lang/Object;&quot;);
 977       if (fieldID == NULL) { return; }
 978 
 979       jMasterKeyDeriveParams = (*env)-&gt;GetObjectField(env, jMechanism, fieldID);
 980 
 981       /* get the Java CK_VERSION */
 982       jMasterKeyDeriveParamsClass = (*env)-&gt;FindClass(env, class_master_key_derive_params);
 983       if (jMasterKeyDeriveParamsClass == NULL) { return; }
 984       fieldID = (*env)-&gt;GetFieldID(env, jMasterKeyDeriveParamsClass,
 985               &quot;pVersion&quot;, &quot;L&quot;CLASS_VERSION&quot;;&quot;);
 986       if (fieldID == NULL) { return; }
 987       jVersion = (*env)-&gt;GetObjectField(env, jMasterKeyDeriveParams, fieldID);
 988 
 989       /* now copy back the version from the native structure to the Java structure */
</pre>
<hr />
<pre>
 992       jVersionClass = (*env)-&gt;FindClass(env, CLASS_VERSION);
 993       if (jVersionClass == NULL) { return; }
 994       fieldID = (*env)-&gt;GetFieldID(env, jVersionClass, &quot;major&quot;, &quot;B&quot;);
 995       if (fieldID == NULL) { return; }
 996       (*env)-&gt;SetByteField(env, jVersion, fieldID, ckByteToJByte(ckVersion-&gt;major));
 997 
 998       /* copy back the minor version */
 999       fieldID = (*env)-&gt;GetFieldID(env, jVersionClass, &quot;minor&quot;, &quot;B&quot;);
1000       if (fieldID == NULL) { return; }
1001       (*env)-&gt;SetByteField(env, jVersion, fieldID, ckByteToJByte(ckVersion-&gt;minor));
1002     }
1003 }
1004 
1005 /*
1006  * Copy back the client version information from the native
1007  * structure to the Java object. This is only used for
1008  * CKM_SSL3_MASTER_KEY_DERIVE and CKM_TLS_MASTER_KEY_DERIVE
1009  * mechanisms when used for deriving a key.
1010  *
1011  */
<span class="line-modified">1012 void ssl3CopyBackClientVersion(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism,</span>
1013         jobject jMechanism)
1014 {
1015     CK_SSL3_MASTER_KEY_DERIVE_PARAMS *ckSSL3MasterKeyDeriveParams;
1016     ckSSL3MasterKeyDeriveParams =
<span class="line-modified">1017             (CK_SSL3_MASTER_KEY_DERIVE_PARAMS *)ckpMechanism-&gt;pParameter;</span>
1018     if (ckSSL3MasterKeyDeriveParams != NULL_PTR) {
<span class="line-modified">1019         copyBackClientVersion(env, ckpMechanism, jMechanism,</span>
1020                 ckSSL3MasterKeyDeriveParams-&gt;pVersion,
1021                 CLASS_SSL3_MASTER_KEY_DERIVE_PARAMS);
1022     }
1023 }
1024 
1025 /*
1026  * Copy back the client version information from the native
1027  * structure to the Java object. This is only used for
1028  * CKM_TLS12_MASTER_KEY_DERIVE mechanism when used for deriving a key.
1029  *
1030  */
<span class="line-modified">1031 void tls12CopyBackClientVersion(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism,</span>
1032         jobject jMechanism)
1033 {
1034     CK_TLS12_MASTER_KEY_DERIVE_PARAMS *ckTLS12MasterKeyDeriveParams;
1035     ckTLS12MasterKeyDeriveParams =
<span class="line-modified">1036             (CK_TLS12_MASTER_KEY_DERIVE_PARAMS *)ckpMechanism-&gt;pParameter;</span>
1037     if (ckTLS12MasterKeyDeriveParams != NULL_PTR) {
<span class="line-modified">1038         copyBackClientVersion(env, ckpMechanism, jMechanism,</span>
1039                 ckTLS12MasterKeyDeriveParams-&gt;pVersion,
1040                 CLASS_TLS12_MASTER_KEY_DERIVE_PARAMS);
1041     }
1042 }
1043 
<span class="line-modified">1044 static void copyBackKeyMatParams(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism,</span>
1045         jobject jMechanism, CK_SSL3_RANDOM_DATA *RandomInfo,
1046         CK_SSL3_KEY_MAT_OUT_PTR ckSSL3KeyMatOut, const char *class_key_mat_params)
1047 {
1048     jclass jMechanismClass, jKeyMatParamsClass, jSSL3KeyMatOutClass;
1049     jfieldID fieldID;
1050     CK_MECHANISM_TYPE ckMechanismType;
1051     jlong jMechanismType;
1052     CK_BYTE_PTR iv;
1053     jobject jKeyMatParam;
1054     jobject jSSL3KeyMatOut;
1055     jobject jIV;
1056     jint jLength;
1057     jbyte* jBytes;
1058     int i;
1059 
1060     /* get mechanism */
1061     jMechanismClass= (*env)-&gt;FindClass(env, CLASS_MECHANISM);
1062     if (jMechanismClass == NULL) { return; }
1063     fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;mechanism&quot;, &quot;J&quot;);
1064     if (fieldID == NULL) { return; }
1065     jMechanismType = (*env)-&gt;GetLongField(env, jMechanism, fieldID);
1066     ckMechanismType = jLongToCKULong(jMechanismType);
<span class="line-modified">1067     if (ckMechanismType != ckpMechanism-&gt;mechanism) {</span>
1068         /* we do not have maching types, this should not occur */
1069         return;
1070     }
1071 








1072     if (ckSSL3KeyMatOut != NULL_PTR) {
1073       /* get the Java params object (pParameter) */
1074       fieldID = (*env)-&gt;GetFieldID(env, jMechanismClass, &quot;pParameter&quot;,
1075               &quot;Ljava/lang/Object;&quot;);
1076       if (fieldID == NULL) { return; }
1077       jKeyMatParam = (*env)-&gt;GetObjectField(env, jMechanism, fieldID);
1078 
1079       /* get the Java CK_SSL3_KEY_MAT_OUT */
1080       jKeyMatParamsClass = (*env)-&gt;FindClass(env, class_key_mat_params);
1081       if (jKeyMatParamsClass == NULL) { return; }
1082       fieldID = (*env)-&gt;GetFieldID(env, jKeyMatParamsClass,
1083               &quot;pReturnedKeyMaterial&quot;, &quot;L&quot;CLASS_SSL3_KEY_MAT_OUT&quot;;&quot;);
1084       if (fieldID == NULL) { return; }
1085       jSSL3KeyMatOut = (*env)-&gt;GetObjectField(env, jKeyMatParam, fieldID);
1086 
1087       /* now copy back all the key handles and the initialization vectors */
1088       /* copy back client MAC secret handle */
1089       jSSL3KeyMatOutClass = (*env)-&gt;FindClass(env, CLASS_SSL3_KEY_MAT_OUT);
1090       if (jSSL3KeyMatOutClass == NULL) { return; }
1091       fieldID = (*env)-&gt;GetFieldID(env, jSSL3KeyMatOutClass,
</pre>
<hr />
<pre>
1113       (*env)-&gt;SetLongField(env, jSSL3KeyMatOut, fieldID,
1114               ckULongToJLong(ckSSL3KeyMatOut-&gt;hServerKey));
1115 
1116       /* copy back the client IV */
1117       fieldID = (*env)-&gt;GetFieldID(env, jSSL3KeyMatOutClass, &quot;pIVClient&quot;, &quot;[B&quot;);
1118       if (fieldID == NULL) { return; }
1119       jIV = (*env)-&gt;GetObjectField(env, jSSL3KeyMatOut, fieldID);
1120       iv = ckSSL3KeyMatOut-&gt;pIVClient;
1121 
1122       if (jIV != NULL) {
1123         jLength = (*env)-&gt;GetArrayLength(env, jIV);
1124         jBytes = (*env)-&gt;GetByteArrayElements(env, jIV, NULL);
1125         if (jBytes == NULL) { return; }
1126         /* copy the bytes to the Java buffer */
1127         for (i=0; i &lt; jLength; i++) {
1128           jBytes[i] = ckByteToJByte(iv[i]);
1129         }
1130         /* copy back the Java buffer to the object */
1131         (*env)-&gt;ReleaseByteArrayElements(env, jIV, jBytes, 0);
1132       }


1133 
1134       /* copy back the server IV */
1135       fieldID = (*env)-&gt;GetFieldID(env, jSSL3KeyMatOutClass, &quot;pIVServer&quot;, &quot;[B&quot;);
1136       if (fieldID == NULL) { return; }
1137       jIV = (*env)-&gt;GetObjectField(env, jSSL3KeyMatOut, fieldID);
1138       iv = ckSSL3KeyMatOut-&gt;pIVServer;
1139 
1140       if (jIV != NULL) {
1141         jLength = (*env)-&gt;GetArrayLength(env, jIV);
1142         jBytes = (*env)-&gt;GetByteArrayElements(env, jIV, NULL);
1143         if (jBytes == NULL) { return; }
1144         /* copy the bytes to the Java buffer */
1145         for (i=0; i &lt; jLength; i++) {
1146           jBytes[i] = ckByteToJByte(iv[i]);
1147         }
1148         /* copy back the Java buffer to the object */
1149         (*env)-&gt;ReleaseByteArrayElements(env, jIV, jBytes, 0);
1150       }



1151     }
1152 }
1153 
1154 /*
1155  * Copy back the derived keys and initialization vectors from the native
1156  * structure to the Java object. This is only used for
1157  * CKM_SSL3_KEY_AND_MAC_DERIVE and CKM_TLS_KEY_AND_MAC_DERIVE mechanisms
1158  * when used for deriving a key.
1159  *
1160  */
<span class="line-modified">1161 void ssl3CopyBackKeyMatParams(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism,</span>
1162         jobject jMechanism)
1163 {
1164     CK_SSL3_KEY_MAT_PARAMS *ckSSL3KeyMatParam;
<span class="line-modified">1165     ckSSL3KeyMatParam = (CK_SSL3_KEY_MAT_PARAMS *)ckpMechanism-&gt;pParameter;</span>
1166     if (ckSSL3KeyMatParam != NULL_PTR) {
<span class="line-modified">1167         copyBackKeyMatParams(env, ckpMechanism, jMechanism,</span>
1168                 &amp;(ckSSL3KeyMatParam-&gt;RandomInfo),
1169                 ckSSL3KeyMatParam-&gt;pReturnedKeyMaterial,
1170                 CLASS_SSL3_KEY_MAT_PARAMS);
1171     }
1172 }
1173 
1174 /*
1175  * Copy back the derived keys and initialization vectors from the native
1176  * structure to the Java object. This is only used for
1177  * CKM_TLS12_KEY_AND_MAC_DERIVE mechanism when used for deriving a key.
1178  *
1179  */
<span class="line-modified">1180 void tls12CopyBackKeyMatParams(JNIEnv *env, CK_MECHANISM_PTR ckpMechanism,</span>
1181         jobject jMechanism)
1182 {
1183     CK_TLS12_KEY_MAT_PARAMS *ckTLS12KeyMatParam;
<span class="line-modified">1184     ckTLS12KeyMatParam = (CK_TLS12_KEY_MAT_PARAMS *)ckpMechanism-&gt;pParameter;</span>
1185     if (ckTLS12KeyMatParam != NULL_PTR) {
<span class="line-modified">1186         copyBackKeyMatParams(env, ckpMechanism, jMechanism,</span>
1187                 &amp;(ckTLS12KeyMatParam-&gt;RandomInfo),
1188                 ckTLS12KeyMatParam-&gt;pReturnedKeyMaterial,
1189                 CLASS_TLS12_KEY_MAT_PARAMS);
1190     }
1191 }
1192 
1193 #endif
</pre>
</td>
</tr>
</table>
<center><a href="p11_general.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="p11_mutex.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
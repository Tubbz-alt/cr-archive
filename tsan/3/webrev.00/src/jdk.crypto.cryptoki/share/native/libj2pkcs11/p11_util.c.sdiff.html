<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_util.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="p11_sign.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="pkcs11.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.cryptoki/share/native/libj2pkcs11/p11_util.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 
   5 /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
   6  *
   7  * Redistribution and use in  source and binary forms, with or without
   8  * modification, are permitted  provided that the following conditions are met:
   9  *
  10  * 1. Redistributions of  source code must retain the above copyright notice,
  11  *    this list of conditions and the following disclaimer.
  12  *
  13  * 2. Redistributions in  binary form must reproduce the above copyright notice,
  14  *    this list of conditions and the following disclaimer in the documentation
  15  *    and/or other materials provided with the distribution.
  16  *
  17  * 3. The end-user documentation included with the redistribution, if any, must
  18  *    include the following acknowledgment:
  19  *
  20  *    &quot;This product includes software developed by IAIK of Graz University of
  21  *     Technology.&quot;
  22  *
</pre>
<hr />
<pre>
 260 {
 261     throwByName(env, CLASS_PKCS11RUNTIMEEXCEPTION, message);
 262 }
 263 
 264 /*
 265  * This function simply throws a PKCS#11RuntimeException. The message says that
 266  * the object is not connected to the module.
 267  *
 268  * @param env Used to call JNI funktions and to get the Exception class.
 269  */
 270 void throwDisconnectedRuntimeException(JNIEnv *env)
 271 {
 272     throwPKCS11RuntimeException(env, &quot;This object is not connected to a module.&quot;);
 273 }
 274 
 275 /* This function frees the specified CK_ATTRIBUTE array.
 276  *
 277  * @param attrPtr pointer to the to-be-freed CK_ATTRIBUTE array.
 278  * @param len the length of the array
 279  */
<span class="line-modified"> 280 void freeCKAttributeArray(CK_ATTRIBUTE_PTR attrPtr, int len)</span>
<span class="line-modified"> 281 {</span>
<span class="line-modified"> 282     int i;</span>





























































































































 283 
<span class="line-modified"> 284     for (i=0; i&lt;len; i++) {</span>
<span class="line-modified"> 285         if (attrPtr[i].pValue != NULL_PTR) {</span>
<span class="line-modified"> 286             free(attrPtr[i].pValue);</span>
















 287         }
















 288     }
<span class="line-modified"> 289     free(attrPtr);</span>
 290 }
 291 
 292 /*
 293  * the following functions convert Java arrays to PKCS#11 array pointers and
 294  * their array length and vice versa
 295  *
 296  * void j&lt;Type&gt;ArrayToCK&lt;Type&gt;Array(JNIEnv *env,
 297  *                                  const j&lt;Type&gt;Array jArray,
 298  *                                  CK_&lt;Type&gt;_PTR *ckpArray,
 299  *                                  CK_ULONG_PTR ckLength);
 300  *
 301  * j&lt;Type&gt;Array ck&lt;Type&gt;ArrayToJ&lt;Type&gt;Array(JNIEnv *env,
 302  *                                          const CK_&lt;Type&gt;_PTR ckpArray,
 303  *                                          CK_ULONG ckLength);
 304  *
 305  * PKCS#11 arrays consist always of a pointer to the beginning of the array and
 306  * the array length whereas Java arrays carry their array length.
 307  *
 308  * The Functions to convert a Java array to a PKCS#11 array are void functions.
 309  * Their arguments are the Java array object to convert, the reference to the
</pre>
<hr />
<pre>
 323 
 324 /*
 325  * converts a jbooleanArray to a CK_BBOOL array. The allocated memory has to be freed after use!
 326  *
 327  * @param env - used to call JNI funktions to get the array informtaion
 328  * @param jArray - the Java array to convert
 329  * @param ckpArray - the reference, where the pointer to the new CK_BBOOL array will be stored
 330  * @param ckpLength - the reference, where the array length will be stored
 331  */
 332 void jBooleanArrayToCKBBoolArray(JNIEnv *env, const jbooleanArray jArray, CK_BBOOL **ckpArray, CK_ULONG_PTR ckpLength)
 333 {
 334     jboolean* jpTemp;
 335     CK_ULONG i;
 336 
 337     if(jArray == NULL) {
 338         *ckpArray = NULL_PTR;
 339         *ckpLength = 0L;
 340         return;
 341     }
 342     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified"> 343     jpTemp = (jboolean*) malloc((*ckpLength) * sizeof(jboolean));</span>
 344     if (jpTemp == NULL) {
 345         throwOutOfMemoryError(env, 0);
 346         return;
 347     }
 348     (*env)-&gt;GetBooleanArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
 349     if ((*env)-&gt;ExceptionCheck(env)) {
 350         free(jpTemp);
 351         return;
 352     }
 353 
<span class="line-modified"> 354     *ckpArray = (CK_BBOOL*) malloc ((*ckpLength) * sizeof(CK_BBOOL));</span>
 355     if (*ckpArray == NULL) {
 356         free(jpTemp);
 357         throwOutOfMemoryError(env, 0);
 358         return;
 359     }
 360     for (i=0; i&lt;(*ckpLength); i++) {
 361         (*ckpArray)[i] = jBooleanToCKBBool(jpTemp[i]);
 362     }
 363     free(jpTemp);
 364 }
 365 
 366 /*
 367  * converts a jbyteArray to a CK_BYTE array. The allocated memory has to be freed after use!
 368  *
 369  * @param env - used to call JNI funktions to get the array informtaion
 370  * @param jArray - the Java array to convert
 371  * @param ckpArray - the reference, where the pointer to the new CK_BYTE array will be stored
 372  * @param ckpLength - the reference, where the array length will be stored
 373  */
 374 void jByteArrayToCKByteArray(JNIEnv *env, const jbyteArray jArray, CK_BYTE_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 375 {
 376     jbyte* jpTemp;
 377     CK_ULONG i;
 378 
 379     if(jArray == NULL) {
 380         *ckpArray = NULL_PTR;
 381         *ckpLength = 0L;
 382         return;
 383     }
 384     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified"> 385     jpTemp = (jbyte*) malloc((*ckpLength) * sizeof(jbyte));</span>
 386     if (jpTemp == NULL) {
 387         throwOutOfMemoryError(env, 0);
 388         return;
 389     }
 390     (*env)-&gt;GetByteArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
 391     if ((*env)-&gt;ExceptionCheck(env)) {
 392         free(jpTemp);
 393         return;
 394     }
 395 
 396     /* if CK_BYTE is the same size as jbyte, we save an additional copy */
 397     if (sizeof(CK_BYTE) == sizeof(jbyte)) {
 398         *ckpArray = (CK_BYTE_PTR) jpTemp;
 399     } else {
<span class="line-modified"> 400         *ckpArray = (CK_BYTE_PTR) malloc ((*ckpLength) * sizeof(CK_BYTE));</span>
 401         if (*ckpArray == NULL) {
 402             free(jpTemp);
 403             throwOutOfMemoryError(env, 0);
 404             return;
 405         }
 406         for (i=0; i&lt;(*ckpLength); i++) {
 407             (*ckpArray)[i] = jByteToCKByte(jpTemp[i]);
 408         }
 409         free(jpTemp);
 410     }
 411 }
 412 
 413 /*
 414  * converts a jlongArray to a CK_ULONG array. The allocated memory has to be freed after use!
 415  *
 416  * @param env - used to call JNI funktions to get the array informtaion
 417  * @param jArray - the Java array to convert
 418  * @param ckpArray - the reference, where the pointer to the new CK_ULONG array will be stored
 419  * @param ckpLength - the reference, where the array length will be stored
 420  */
 421 void jLongArrayToCKULongArray(JNIEnv *env, const jlongArray jArray, CK_ULONG_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 422 {
 423     jlong* jTemp;
 424     CK_ULONG i;
 425 
 426     if(jArray == NULL) {
 427         *ckpArray = NULL_PTR;
 428         *ckpLength = 0L;
 429         return;
 430     }
 431     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified"> 432     jTemp = (jlong*) malloc((*ckpLength) * sizeof(jlong));</span>
 433     if (jTemp == NULL) {
 434         throwOutOfMemoryError(env, 0);
 435         return;
 436     }
 437     (*env)-&gt;GetLongArrayRegion(env, jArray, 0, *ckpLength, jTemp);
 438     if ((*env)-&gt;ExceptionCheck(env)) {
 439         free(jTemp);
 440         return;
 441     }
 442 
<span class="line-modified"> 443     *ckpArray = (CK_ULONG_PTR) malloc (*ckpLength * sizeof(CK_ULONG));</span>
 444     if (*ckpArray == NULL) {
 445         free(jTemp);
 446         throwOutOfMemoryError(env, 0);
 447         return;
 448     }
 449     for (i=0; i&lt;(*ckpLength); i++) {
 450         (*ckpArray)[i] = jLongToCKULong(jTemp[i]);
 451     }
 452     free(jTemp);
 453 }
 454 
 455 /*
 456  * converts a jcharArray to a CK_CHAR array. The allocated memory has to be freed after use!
 457  *
 458  * @param env - used to call JNI funktions to get the array informtaion
 459  * @param jArray - the Java array to convert
 460  * @param ckpArray - the reference, where the pointer to the new CK_CHAR array will be stored
 461  * @param ckpLength - the reference, where the array length will be stored
 462  */
 463 void jCharArrayToCKCharArray(JNIEnv *env, const jcharArray jArray, CK_CHAR_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 464 {
 465     jchar* jpTemp;
 466     CK_ULONG i;
 467 
 468     if(jArray == NULL) {
 469         *ckpArray = NULL_PTR;
 470         *ckpLength = 0L;
 471         return;
 472     }
 473     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified"> 474     jpTemp = (jchar*) malloc((*ckpLength) * sizeof(jchar));</span>
 475     if (jpTemp == NULL) {
 476         throwOutOfMemoryError(env, 0);
 477         return;
 478     }
 479     (*env)-&gt;GetCharArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
 480     if ((*env)-&gt;ExceptionCheck(env)) {
 481         free(jpTemp);
 482         return;
 483     }
 484 
<span class="line-modified"> 485     *ckpArray = (CK_CHAR_PTR) malloc (*ckpLength * sizeof(CK_CHAR));</span>
 486     if (*ckpArray == NULL) {
 487         free(jpTemp);
 488         throwOutOfMemoryError(env, 0);
 489         return;
 490     }
 491     for (i=0; i&lt;(*ckpLength); i++) {
 492         (*ckpArray)[i] = jCharToCKChar(jpTemp[i]);
 493     }
 494     free(jpTemp);
 495 }
 496 
 497 /*
 498  * converts a jcharArray to a CK_UTF8CHAR array. The allocated memory has to be freed after use!
 499  *
 500  * @param env - used to call JNI funktions to get the array informtaion
 501  * @param jArray - the Java array to convert
 502  * @param ckpArray - the reference, where the pointer to the new CK_UTF8CHAR array will be stored
 503  * @param ckpLength - the reference, where the array length will be stored
 504  */
 505 void jCharArrayToCKUTF8CharArray(JNIEnv *env, const jcharArray jArray, CK_UTF8CHAR_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 506 {
 507     jchar* jTemp;
 508     CK_ULONG i;
 509 
 510     if(jArray == NULL) {
 511         *ckpArray = NULL_PTR;
 512         *ckpLength = 0L;
 513         return;
 514     }
 515     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified"> 516     jTemp = (jchar*) malloc((*ckpLength) * sizeof(jchar));</span>
 517     if (jTemp == NULL) {
 518         throwOutOfMemoryError(env, 0);
 519         return;
 520     }
 521     (*env)-&gt;GetCharArrayRegion(env, jArray, 0, *ckpLength, jTemp);
 522     if ((*env)-&gt;ExceptionCheck(env)) {
 523         free(jTemp);
 524         return;
 525     }
 526 
<span class="line-modified"> 527     *ckpArray = (CK_UTF8CHAR_PTR) malloc (*ckpLength * sizeof(CK_UTF8CHAR));</span>
 528     if (*ckpArray == NULL) {
 529         free(jTemp);
 530         throwOutOfMemoryError(env, 0);
 531         return;
 532     }
 533     for (i=0; i&lt;(*ckpLength); i++) {
 534         (*ckpArray)[i] = jCharToCKUTF8Char(jTemp[i]);
 535     }
 536     free(jTemp);
 537 }
 538 
 539 /*
 540  * converts a jstring to a CK_CHAR array. The allocated memory has to be freed after use!
 541  *
 542  * @param env - used to call JNI funktions to get the array informtaion
 543  * @param jArray - the Java array to convert
 544  * @param ckpArray - the reference, where the pointer to the new CK_CHAR array will be stored
 545  * @param ckpLength - the reference, where the array length will be stored
 546  */
 547 void jStringToCKUTF8CharArray(JNIEnv *env, const jstring jArray, CK_UTF8CHAR_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 548 {
 549     const char* pCharArray;
 550     jboolean isCopy;
 551 
 552     if(jArray == NULL) {
 553         *ckpArray = NULL_PTR;
 554         *ckpLength = 0L;
 555         return;
 556     }
 557 
 558     pCharArray = (*env)-&gt;GetStringUTFChars(env, jArray, &amp;isCopy);
 559     if (pCharArray == NULL) { return; }
 560 
 561     *ckpLength = (CK_ULONG) strlen(pCharArray);
<span class="line-modified"> 562     *ckpArray = (CK_UTF8CHAR_PTR) malloc((*ckpLength + 1) * sizeof(CK_UTF8CHAR));</span>
 563     if (*ckpArray == NULL) {
 564         (*env)-&gt;ReleaseStringUTFChars(env, (jstring) jArray, pCharArray);
 565         throwOutOfMemoryError(env, 0);
 566         return;
 567     }
 568     strcpy((char*)*ckpArray, pCharArray);
 569     (*env)-&gt;ReleaseStringUTFChars(env, (jstring) jArray, pCharArray);
 570 }
 571 
 572 /*
 573  * converts a jobjectArray with Java Attributes to a CK_ATTRIBUTE array. The allocated memory
 574  * has to be freed after use!
 575  *
 576  * @param env - used to call JNI funktions to get the array informtaion
 577  * @param jArray - the Java Attribute array (template) to convert
 578  * @param ckpArray - the reference, where the pointer to the new CK_ATTRIBUTE array will be
 579  *                   stored
 580  * @param ckpLength - the reference, where the array length will be stored
 581  */
 582 void jAttributeArrayToCKAttributeArray(JNIEnv *env, jobjectArray jArray, CK_ATTRIBUTE_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 583 {
 584     CK_ULONG i;
 585     jlong jLength;
 586     jobject jAttribute;
 587 
 588     TRACE0(&quot;\nDEBUG: jAttributeArrayToCKAttributeArray&quot;);
 589     if (jArray == NULL) {
 590         *ckpArray = NULL_PTR;
 591         *ckpLength = 0L;
 592         return;
 593     }
 594     jLength = (*env)-&gt;GetArrayLength(env, jArray);
 595     *ckpLength = jLongToCKULong(jLength);
<span class="line-modified"> 596     *ckpArray = (CK_ATTRIBUTE_PTR) malloc(*ckpLength * sizeof(CK_ATTRIBUTE));</span>
 597     if (*ckpArray == NULL) {
 598         throwOutOfMemoryError(env, 0);
 599         return;
 600     }
<span class="line-modified"> 601     TRACE1(&quot;, converting %d attributes&quot;, jLength);</span>
 602     for (i=0; i&lt;(*ckpLength); i++) {
<span class="line-modified"> 603         TRACE1(&quot;, getting %d. attribute&quot;, i);</span>
 604         jAttribute = (*env)-&gt;GetObjectArrayElement(env, jArray, i);
 605         if ((*env)-&gt;ExceptionCheck(env)) {
 606             freeCKAttributeArray(*ckpArray, i);
 607             return;
 608         }
<span class="line-modified"> 609         TRACE1(&quot;, jAttribute = %d&quot;, jAttribute);</span>
<span class="line-removed"> 610         TRACE1(&quot;, converting %d. attribute&quot;, i);</span>
 611         (*ckpArray)[i] = jAttributeToCKAttribute(env, jAttribute);
 612         if ((*env)-&gt;ExceptionCheck(env)) {
 613             freeCKAttributeArray(*ckpArray, i);
 614             return;
 615         }
 616     }
 617     TRACE0(&quot;FINISHED\n&quot;);
 618 }
 619 
 620 /*
 621  * converts a CK_BYTE array and its length to a jbyteArray.
 622  *
 623  * @param env - used to call JNI funktions to create the new Java array
 624  * @param ckpArray - the pointer to the CK_BYTE array to convert
 625  * @param ckpLength - the length of the array to convert
 626  * @return - the new Java byte array or NULL if error occurred
 627  */
 628 jbyteArray ckByteArrayToJByteArray(JNIEnv *env, const CK_BYTE_PTR ckpArray, CK_ULONG ckLength)
 629 {
 630     CK_ULONG i;
 631     jbyte* jpTemp;
 632     jbyteArray jArray;
 633 
 634     /* if CK_BYTE is the same size as jbyte, we save an additional copy */
 635     if (sizeof(CK_BYTE) == sizeof(jbyte)) {
 636         jpTemp = (jbyte*) ckpArray;
 637     } else {
<span class="line-modified"> 638         jpTemp = (jbyte*) malloc((ckLength) * sizeof(jbyte));</span>
 639         if (jpTemp == NULL) {
 640             throwOutOfMemoryError(env, 0);
 641             return NULL;
 642         }
 643         for (i=0; i&lt;ckLength; i++) {
 644             jpTemp[i] = ckByteToJByte(ckpArray[i]);
 645         }
 646     }
 647 
 648     jArray = (*env)-&gt;NewByteArray(env, ckULongToJSize(ckLength));
 649     if (jArray != NULL) {
 650         (*env)-&gt;SetByteArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 651     }
 652 
 653     if (sizeof(CK_BYTE) != sizeof(jbyte)) { free(jpTemp); }
 654 
 655     return jArray ;
 656 }
 657 
 658 /*
 659  * converts a CK_ULONG array and its length to a jlongArray.
 660  *
 661  * @param env - used to call JNI funktions to create the new Java array
 662  * @param ckpArray - the pointer to the CK_ULONG array to convert
 663  * @param ckpLength - the length of the array to convert
 664  * @return - the new Java long array
 665  */
 666 jlongArray ckULongArrayToJLongArray(JNIEnv *env, const CK_ULONG_PTR ckpArray, CK_ULONG ckLength)
 667 {
 668     CK_ULONG i;
 669     jlong* jpTemp;
 670     jlongArray jArray;
 671 
<span class="line-modified"> 672     jpTemp = (jlong*) malloc((ckLength) * sizeof(jlong));</span>
 673     if (jpTemp == NULL) {
 674         throwOutOfMemoryError(env, 0);
 675         return NULL;
 676     }
 677     for (i=0; i&lt;ckLength; i++) {
 678         jpTemp[i] = ckLongToJLong(ckpArray[i]);
 679     }
 680     jArray = (*env)-&gt;NewLongArray(env, ckULongToJSize(ckLength));
 681     if (jArray != NULL) {
 682         (*env)-&gt;SetLongArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 683     }
 684     free(jpTemp);
 685 
 686     return jArray ;
 687 }
 688 
 689 /*
 690  * converts a CK_CHAR array and its length to a jcharArray.
 691  *
 692  * @param env - used to call JNI funktions to create the new Java array
 693  * @param ckpArray - the pointer to the CK_CHAR array to convert
 694  * @param ckpLength - the length of the array to convert
 695  * @return - the new Java char array
 696  */
 697 jcharArray ckCharArrayToJCharArray(JNIEnv *env, const CK_CHAR_PTR ckpArray, CK_ULONG ckLength)
 698 {
 699     CK_ULONG i;
 700     jchar* jpTemp;
 701     jcharArray jArray;
 702 
<span class="line-modified"> 703     jpTemp = (jchar*) malloc(ckLength * sizeof(jchar));</span>
 704     if (jpTemp == NULL) {
 705         throwOutOfMemoryError(env, 0);
 706         return NULL;
 707     }
 708     for (i=0; i&lt;ckLength; i++) {
 709         jpTemp[i] = ckCharToJChar(ckpArray[i]);
 710     }
 711     jArray = (*env)-&gt;NewCharArray(env, ckULongToJSize(ckLength));
 712     if (jArray != NULL) {
 713         (*env)-&gt;SetCharArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 714     }
 715     free(jpTemp);
 716 
 717     return jArray ;
 718 }
 719 
 720 /*
 721  * converts a CK_UTF8CHAR array and its length to a jcharArray.
 722  *
 723  * @param env - used to call JNI funktions to create the new Java array
 724  * @param ckpArray - the pointer to the CK_UTF8CHAR array to convert
 725  * @param ckpLength - the length of the array to convert
 726  * @return - the new Java char array
 727  */
 728 jcharArray ckUTF8CharArrayToJCharArray(JNIEnv *env, const CK_UTF8CHAR_PTR ckpArray, CK_ULONG ckLength)
 729 {
 730     CK_ULONG i;
 731     jchar* jpTemp;
 732     jcharArray jArray;
 733 
<span class="line-modified"> 734     jpTemp = (jchar*) malloc(ckLength * sizeof(jchar));</span>
 735     if (jpTemp == NULL) {
 736         throwOutOfMemoryError(env, 0);
 737         return NULL;
 738     }
 739     for (i=0; i&lt;ckLength; i++) {
 740         jpTemp[i] = ckUTF8CharToJChar(ckpArray[i]);
 741     }
 742     jArray = (*env)-&gt;NewCharArray(env, ckULongToJSize(ckLength));
 743     if (jArray != NULL) {
 744         (*env)-&gt;SetCharArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 745     }
 746     free(jpTemp);
 747 
 748     return jArray ;
 749 }
 750 
 751 /*
 752  * the following functions convert Java objects to PKCS#11 pointers and the
 753  * length in bytes and vice versa
 754  *
</pre>
<hr />
<pre>
 947     jchar jValue;
 948     CK_CHAR_PTR ckpValue;
 949 
 950     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Char&quot;);
 951     if (jObjectClass == NULL) { return NULL; }
 952     jValueMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;charValue&quot;, &quot;()C&quot;);
 953     if (jValueMethod == NULL) { return NULL; }
 954     jValue = (*env)-&gt;CallCharMethod(env, jObject, jValueMethod);
 955     ckpValue = (CK_CHAR_PTR) malloc(sizeof(CK_CHAR));
 956     if (ckpValue == NULL) {
 957         throwOutOfMemoryError(env, 0);
 958         return NULL;
 959     }
 960     *ckpValue = jCharToCKChar(jValue);
 961 
 962     return ckpValue ;
 963 }
 964 
 965 /*
 966  * converts a Java object into a pointer to CK-type or a CK-structure with the length in Bytes.
<span class="line-modified"> 967  * The memory of *ckpObjectPtr to be freed after use! This function is only used by</span>
<span class="line-removed"> 968  * jAttributeToCKAttribute by now.</span>
 969  *
 970  * @param env - used to call JNI funktions to get the Java classes and objects
 971  * @param jObject - the Java object to convert
<span class="line-modified"> 972  * @param ckpObjectPtr - the reference of the new pointer to the new CK-value or CK-structure</span>
<span class="line-modified"> 973  * @param ckpLength - the reference of the length in bytes of the new CK-value or CK-structure</span>
 974  */
<span class="line-modified"> 975 void jObjectToPrimitiveCKObjectPtrPtr(JNIEnv *env, jobject jObject, CK_VOID_PTR *ckpObjectPtr, CK_ULONG *ckpLength)</span>
 976 {
 977     jclass jLongClass, jBooleanClass, jByteArrayClass, jCharArrayClass;
 978     jclass jByteClass, jDateClass, jCharacterClass, jIntegerClass;
 979     jclass jBooleanArrayClass, jIntArrayClass, jLongArrayClass;
 980     jclass jStringClass;
 981     jclass jObjectClass, jClassClass;
<span class="line-modified"> 982     CK_VOID_PTR ckpVoid = *ckpObjectPtr;</span>
 983     jmethodID jMethod;
 984     jobject jClassObject;
 985     jstring jClassNameString;
 986     char *classNameString, *exceptionMsgPrefix, *exceptionMsg;
 987 
<span class="line-modified"> 988     TRACE0(&quot;\nDEBUG: jObjectToPrimitiveCKObjectPtrPtr&quot;);</span>
 989     if (jObject == NULL) {
<span class="line-removed"> 990         *ckpObjectPtr = NULL;</span>
 991         *ckpLength = 0;
<span class="line-modified"> 992         return;</span>
 993     }
 994 
 995     jLongClass = (*env)-&gt;FindClass(env, &quot;java/lang/Long&quot;);
<span class="line-modified"> 996     if (jLongClass == NULL) { return; }</span>
 997     if ((*env)-&gt;IsInstanceOf(env, jObject, jLongClass)) {
<span class="line-modified"> 998         *ckpObjectPtr = jLongObjectToCKULongPtr(env, jObject);</span>
 999         *ckpLength = sizeof(CK_ULONG);
<span class="line-modified">1000         TRACE1(&quot;&lt;converted long value %X&gt;&quot;, *((CK_ULONG *) *ckpObjectPtr));</span>
<span class="line-modified">1001         return;</span>
1002     }
1003 
1004     jBooleanClass = (*env)-&gt;FindClass(env, &quot;java/lang/Boolean&quot;);
<span class="line-modified">1005     if (jBooleanClass == NULL) { return; }</span>
1006     if ((*env)-&gt;IsInstanceOf(env, jObject, jBooleanClass)) {
<span class="line-modified">1007         *ckpObjectPtr = jBooleanObjectToCKBBoolPtr(env, jObject);</span>
1008         *ckpLength = sizeof(CK_BBOOL);
1009         TRACE0(&quot; &lt;converted boolean value &quot;);
<span class="line-modified">1010         TRACE0((*((CK_BBOOL *) *ckpObjectPtr) == TRUE) ? &quot;TRUE&gt;&quot; : &quot;FALSE&gt;&quot;);</span>
<span class="line-modified">1011         return;</span>
1012     }
1013 
1014     jByteArrayClass = (*env)-&gt;FindClass(env, &quot;[B&quot;);
<span class="line-modified">1015     if (jByteArrayClass == NULL) { return; }</span>
1016     if ((*env)-&gt;IsInstanceOf(env, jObject, jByteArrayClass)) {
<span class="line-modified">1017         jByteArrayToCKByteArray(env, jObject, (CK_BYTE_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">1018         return;</span>
1019     }
1020 
1021     jCharArrayClass = (*env)-&gt;FindClass(env, &quot;[C&quot;);
<span class="line-modified">1022     if (jCharArrayClass == NULL) { return; }</span>
1023     if ((*env)-&gt;IsInstanceOf(env, jObject, jCharArrayClass)) {
<span class="line-modified">1024         jCharArrayToCKUTF8CharArray(env, jObject, (CK_UTF8CHAR_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">1025         return;</span>
1026     }
1027 
1028     jByteClass = (*env)-&gt;FindClass(env, &quot;java/lang/Byte&quot;);
<span class="line-modified">1029     if (jByteClass == NULL) { return; }</span>
1030     if ((*env)-&gt;IsInstanceOf(env, jObject, jByteClass)) {
<span class="line-modified">1031         *ckpObjectPtr = jByteObjectToCKBytePtr(env, jObject);</span>
1032         *ckpLength = sizeof(CK_BYTE);
<span class="line-modified">1033         TRACE1(&quot;&lt;converted byte value %X&gt;&quot;, *((CK_BYTE *) *ckpObjectPtr));</span>
<span class="line-modified">1034         return;</span>
1035     }
1036 
1037     jDateClass = (*env)-&gt;FindClass(env, CLASS_DATE);
<span class="line-modified">1038     if (jDateClass == NULL) { return; }</span>
1039     if ((*env)-&gt;IsInstanceOf(env, jObject, jDateClass)) {
<span class="line-modified">1040         *ckpObjectPtr = jDateObjectPtrToCKDatePtr(env, jObject);</span>
1041         *ckpLength = sizeof(CK_DATE);
<span class="line-modified">1042         TRACE3(&quot;&lt;converted date value %.4s-%.2s-%.2s&gt;&quot;, (*((CK_DATE *) *ckpObjectPtr)).year, (*((CK_DATE *) *ckpObjectPtr)).month, (*((CK_DATE *) *ckpObjectPtr)).day);</span>
<span class="line-modified">1043         return;</span>

1044     }
1045 
1046     jCharacterClass = (*env)-&gt;FindClass(env, &quot;java/lang/Character&quot;);
<span class="line-modified">1047     if (jCharacterClass == NULL) { return; }</span>
1048     if ((*env)-&gt;IsInstanceOf(env, jObject, jCharacterClass)) {
<span class="line-modified">1049         *ckpObjectPtr = jCharObjectToCKCharPtr(env, jObject);</span>
1050         *ckpLength = sizeof(CK_UTF8CHAR);
<span class="line-modified">1051         TRACE1(&quot;&lt;converted char value %c&gt;&quot;, *((CK_CHAR *) *ckpObjectPtr));</span>
<span class="line-modified">1052         return;</span>
1053     }
1054 
1055     jIntegerClass = (*env)-&gt;FindClass(env, &quot;java/lang/Integer&quot;);
<span class="line-modified">1056     if (jIntegerClass == NULL) { return; }</span>
1057     if ((*env)-&gt;IsInstanceOf(env, jObject, jIntegerClass)) {
<span class="line-modified">1058         *ckpObjectPtr = jIntegerObjectToCKULongPtr(env, jObject);</span>
1059         *ckpLength = sizeof(CK_ULONG);
<span class="line-modified">1060         TRACE1(&quot;&lt;converted integer value %X&gt;&quot;, *((CK_ULONG *) *ckpObjectPtr));</span>
<span class="line-modified">1061         return;</span>
1062     }
1063 
1064     jBooleanArrayClass = (*env)-&gt;FindClass(env, &quot;[Z&quot;);
<span class="line-modified">1065     if (jBooleanArrayClass == NULL) { return; }</span>
1066     if ((*env)-&gt;IsInstanceOf(env, jObject, jBooleanArrayClass)) {
<span class="line-modified">1067         jBooleanArrayToCKBBoolArray(env, jObject, (CK_BBOOL**)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">1068         return;</span>
1069     }
1070 
1071     jIntArrayClass = (*env)-&gt;FindClass(env, &quot;[I&quot;);
<span class="line-modified">1072     if (jIntArrayClass == NULL) { return; }</span>
1073     if ((*env)-&gt;IsInstanceOf(env, jObject, jIntArrayClass)) {
<span class="line-modified">1074         jLongArrayToCKULongArray(env, jObject, (CK_ULONG_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">1075         return;</span>
1076     }
1077 
1078     jLongArrayClass = (*env)-&gt;FindClass(env, &quot;[J&quot;);
<span class="line-modified">1079     if (jLongArrayClass == NULL) { return; }</span>
1080     if ((*env)-&gt;IsInstanceOf(env, jObject, jLongArrayClass)) {
<span class="line-modified">1081         jLongArrayToCKULongArray(env, jObject, (CK_ULONG_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">1082         return;</span>
1083     }
1084 
1085     jStringClass = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
<span class="line-modified">1086     if (jStringClass == NULL) { return; }</span>
1087     if ((*env)-&gt;IsInstanceOf(env, jObject, jStringClass)) {
<span class="line-modified">1088         jStringToCKUTF8CharArray(env, jObject, (CK_UTF8CHAR_PTR*)ckpObjectPtr, ckpLength);</span>
<span class="line-modified">1089         return;</span>
1090     }
1091 
1092     /* type of jObject unknown, throw PKCS11RuntimeException */
1093     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Object&quot;);
<span class="line-modified">1094     if (jObjectClass == NULL) { return; }</span>
1095     jMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;getClass&quot;, &quot;()Ljava/lang/Class;&quot;);
<span class="line-modified">1096     if (jMethod == NULL) { return; }</span>
1097     jClassObject = (*env)-&gt;CallObjectMethod(env, jObject, jMethod);
1098     assert(jClassObject != 0);
1099     jClassClass = (*env)-&gt;FindClass(env, &quot;java/lang/Class&quot;);
<span class="line-modified">1100     if (jClassClass == NULL) { return; }</span>
1101     jMethod = (*env)-&gt;GetMethodID(env, jClassClass, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;);
<span class="line-modified">1102     if (jMethod == NULL) { return; }</span>
1103     jClassNameString = (jstring)
1104         (*env)-&gt;CallObjectMethod(env, jClassObject, jMethod);
1105     assert(jClassNameString != 0);
1106     classNameString = (char*)
1107         (*env)-&gt;GetStringUTFChars(env, jClassNameString, NULL);
<span class="line-modified">1108     if (classNameString == NULL) { return; }</span>
1109     exceptionMsgPrefix = &quot;Java object of this class cannot be converted to native PKCS#11 type: &quot;;
1110     exceptionMsg = (char *)
<span class="line-modified">1111         malloc((strlen(exceptionMsgPrefix) + strlen(classNameString) + 1));</span>
1112     if (exceptionMsg == NULL) {
1113         (*env)-&gt;ReleaseStringUTFChars(env, jClassNameString, classNameString);
1114         throwOutOfMemoryError(env, 0);
<span class="line-modified">1115         return;</span>
1116     }
1117     strcpy(exceptionMsg, exceptionMsgPrefix);
1118     strcat(exceptionMsg, classNameString);
1119     (*env)-&gt;ReleaseStringUTFChars(env, jClassNameString, classNameString);
1120     throwPKCS11RuntimeException(env, exceptionMsg);
1121     free(exceptionMsg);
<span class="line-removed">1122     *ckpObjectPtr = NULL;</span>
1123     *ckpLength = 0;
1124 
1125     TRACE0(&quot;FINISHED\n&quot;);

1126 }
1127 
1128 #ifdef P11_MEMORYDEBUG
1129 
1130 #undef malloc

1131 #undef free
1132 
1133 void *p11malloc(size_t c, char *file, int line) {
1134     void *p = malloc(c);
<span class="line-modified">1135     printf(&quot;malloc\t%08x\t%d\t%s:%d\n&quot;, p, c, file, line); fflush(stdout);</span>








1136     return p;
1137 }
1138 
1139 void p11free(void *p, char *file, int line) {
<span class="line-modified">1140     printf(&quot;free\t%08x\t\t%s:%d\n&quot;, p, file, line); fflush(stdout);</span>

1141     free(p);
1142 }
1143 
1144 #endif
1145 
1146 // prints a message to stdout if debug output is enabled
1147 void printDebug(const char *format, ...) {
1148     if (debug == JNI_TRUE) {
1149         va_list args;
1150         fprintf(stdout, &quot;sunpkcs11: &quot;);
1151         va_start(args, format);
1152         vfprintf(stdout, format, args);
1153         va_end(args);
1154         fflush(stdout);
1155     }
1156 }
1157 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 
   5 /* Copyright  (c) 2002 Graz University of Technology. All rights reserved.
   6  *
   7  * Redistribution and use in  source and binary forms, with or without
   8  * modification, are permitted  provided that the following conditions are met:
   9  *
  10  * 1. Redistributions of  source code must retain the above copyright notice,
  11  *    this list of conditions and the following disclaimer.
  12  *
  13  * 2. Redistributions in  binary form must reproduce the above copyright notice,
  14  *    this list of conditions and the following disclaimer in the documentation
  15  *    and/or other materials provided with the distribution.
  16  *
  17  * 3. The end-user documentation included with the redistribution, if any, must
  18  *    include the following acknowledgment:
  19  *
  20  *    &quot;This product includes software developed by IAIK of Graz University of
  21  *     Technology.&quot;
  22  *
</pre>
<hr />
<pre>
 260 {
 261     throwByName(env, CLASS_PKCS11RUNTIMEEXCEPTION, message);
 262 }
 263 
 264 /*
 265  * This function simply throws a PKCS#11RuntimeException. The message says that
 266  * the object is not connected to the module.
 267  *
 268  * @param env Used to call JNI funktions and to get the Exception class.
 269  */
 270 void throwDisconnectedRuntimeException(JNIEnv *env)
 271 {
 272     throwPKCS11RuntimeException(env, &quot;This object is not connected to a module.&quot;);
 273 }
 274 
 275 /* This function frees the specified CK_ATTRIBUTE array.
 276  *
 277  * @param attrPtr pointer to the to-be-freed CK_ATTRIBUTE array.
 278  * @param len the length of the array
 279  */
<span class="line-modified"> 280 void freeCKAttributeArray(CK_ATTRIBUTE_PTR attrPtr, int len) {</span>
<span class="line-modified"> 281     if (attrPtr != NULL) {</span>
<span class="line-modified"> 282         int i;</span>
<span class="line-added"> 283         for (i=0; i&lt;len; i++) {</span>
<span class="line-added"> 284             if (attrPtr[i].pValue != NULL_PTR) {</span>
<span class="line-added"> 285                 free(attrPtr[i].pValue);</span>
<span class="line-added"> 286             }</span>
<span class="line-added"> 287         }</span>
<span class="line-added"> 288         free(attrPtr);</span>
<span class="line-added"> 289     }</span>
<span class="line-added"> 290 }</span>
<span class="line-added"> 291 </span>
<span class="line-added"> 292 /* This function frees the specified CK_MECHANISM_PTR pointer and its</span>
<span class="line-added"> 293  * pParameter including mechanism-specific memory allocations.</span>
<span class="line-added"> 294  *</span>
<span class="line-added"> 295  * @param mechPtr pointer to the to-be-freed CK_MECHANISM structure.</span>
<span class="line-added"> 296  */</span>
<span class="line-added"> 297 void freeCKMechanismPtr(CK_MECHANISM_PTR mechPtr) {</span>
<span class="line-added"> 298      void *tmp;</span>
<span class="line-added"> 299      CK_SSL3_MASTER_KEY_DERIVE_PARAMS *sslMkdTmp;</span>
<span class="line-added"> 300      CK_SSL3_KEY_MAT_PARAMS* sslKmTmp;</span>
<span class="line-added"> 301      CK_TLS12_MASTER_KEY_DERIVE_PARAMS *tlsMkdTmp;</span>
<span class="line-added"> 302      CK_TLS12_KEY_MAT_PARAMS* tlsKmTmp;</span>
<span class="line-added"> 303 </span>
<span class="line-added"> 304      if (mechPtr != NULL) {</span>
<span class="line-added"> 305          TRACE2(&quot;DEBUG freeCKMechanismPtr: free pMech %p (mech 0x%lX)\n&quot;,</span>
<span class="line-added"> 306                  mechPtr,  mechPtr-&gt;mechanism);</span>
<span class="line-added"> 307          if (mechPtr-&gt;pParameter != NULL) {</span>
<span class="line-added"> 308              tmp = mechPtr-&gt;pParameter;</span>
<span class="line-added"> 309              switch (mechPtr-&gt;mechanism) {</span>
<span class="line-added"> 310                  case CKM_AES_GCM:</span>
<span class="line-added"> 311                      if (mechPtr-&gt;ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS)) {</span>
<span class="line-added"> 312                          TRACE0(&quot;[ GCM_PARAMS w/o ulIvBits ]\n&quot;);</span>
<span class="line-added"> 313                          free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)-&gt;pIv);</span>
<span class="line-added"> 314                          free(((CK_GCM_PARAMS_NO_IVBITS*)tmp)-&gt;pAAD);</span>
<span class="line-added"> 315                      } else if (mechPtr-&gt;ulParameterLen == sizeof(CK_GCM_PARAMS)) {</span>
<span class="line-added"> 316                          TRACE0(&quot;[ GCM_PARAMS ]\n&quot;);</span>
<span class="line-added"> 317                          free(((CK_GCM_PARAMS*)tmp)-&gt;pIv);</span>
<span class="line-added"> 318                          free(((CK_GCM_PARAMS*)tmp)-&gt;pAAD);</span>
<span class="line-added"> 319                      }</span>
<span class="line-added"> 320                      break;</span>
<span class="line-added"> 321                  case CKM_AES_CCM:</span>
<span class="line-added"> 322                      TRACE0(&quot;[ CK_CCM_PARAMS ]\n&quot;);</span>
<span class="line-added"> 323                      free(((CK_CCM_PARAMS*)tmp)-&gt;pNonce);</span>
<span class="line-added"> 324                      free(((CK_CCM_PARAMS*)tmp)-&gt;pAAD);</span>
<span class="line-added"> 325                      break;</span>
<span class="line-added"> 326                  case CKM_TLS_PRF:</span>
<span class="line-added"> 327                  case CKM_NSS_TLS_PRF_GENERAL:</span>
<span class="line-added"> 328                      TRACE0(&quot;[ CK_TLS_PRF_PARAMS ]\n&quot;);</span>
<span class="line-added"> 329                      free(((CK_TLS_PRF_PARAMS*)tmp)-&gt;pSeed);</span>
<span class="line-added"> 330                      free(((CK_TLS_PRF_PARAMS*)tmp)-&gt;pLabel);</span>
<span class="line-added"> 331                      free(((CK_TLS_PRF_PARAMS*)tmp)-&gt;pulOutputLen);</span>
<span class="line-added"> 332                      free(((CK_TLS_PRF_PARAMS*)tmp)-&gt;pOutput);</span>
<span class="line-added"> 333                      break;</span>
<span class="line-added"> 334                  case CKM_SSL3_MASTER_KEY_DERIVE:</span>
<span class="line-added"> 335                  case CKM_TLS_MASTER_KEY_DERIVE:</span>
<span class="line-added"> 336                  case CKM_SSL3_MASTER_KEY_DERIVE_DH:</span>
<span class="line-added"> 337                  case CKM_TLS_MASTER_KEY_DERIVE_DH:</span>
<span class="line-added"> 338                      sslMkdTmp = tmp;</span>
<span class="line-added"> 339                      TRACE0(&quot;[ CK_SSL3_MASTER_KEY_DERIVE_PARAMS ]\n&quot;);</span>
<span class="line-added"> 340                      free(sslMkdTmp-&gt;RandomInfo.pClientRandom);</span>
<span class="line-added"> 341                      free(sslMkdTmp-&gt;RandomInfo.pServerRandom);</span>
<span class="line-added"> 342                      free(sslMkdTmp-&gt;pVersion);</span>
<span class="line-added"> 343                      break;</span>
<span class="line-added"> 344                  case CKM_SSL3_KEY_AND_MAC_DERIVE:</span>
<span class="line-added"> 345                  case CKM_TLS_KEY_AND_MAC_DERIVE:</span>
<span class="line-added"> 346                      sslKmTmp = tmp;</span>
<span class="line-added"> 347                      TRACE0(&quot;[ CK_SSL3_KEY_MAT_PARAMS ]\n&quot;);</span>
<span class="line-added"> 348                      free(sslKmTmp-&gt;RandomInfo.pClientRandom);</span>
<span class="line-added"> 349                      free(sslKmTmp-&gt;RandomInfo.pServerRandom);</span>
<span class="line-added"> 350                      if (sslKmTmp-&gt;pReturnedKeyMaterial != NULL) {</span>
<span class="line-added"> 351                          free(sslKmTmp-&gt;pReturnedKeyMaterial-&gt;pIVClient);</span>
<span class="line-added"> 352                          free(sslKmTmp-&gt;pReturnedKeyMaterial-&gt;pIVServer);</span>
<span class="line-added"> 353                          free(sslKmTmp-&gt;pReturnedKeyMaterial);</span>
<span class="line-added"> 354                      }</span>
<span class="line-added"> 355                      break;</span>
<span class="line-added"> 356                  case CKM_TLS12_MASTER_KEY_DERIVE:</span>
<span class="line-added"> 357                  case CKM_TLS12_MASTER_KEY_DERIVE_DH:</span>
<span class="line-added"> 358                      tlsMkdTmp = tmp;</span>
<span class="line-added"> 359                      TRACE0(&quot;[ CK_TLS12_MASTER_KEY_DERIVE_PARAMS ]\n&quot;);</span>
<span class="line-added"> 360                      free(tlsMkdTmp-&gt;RandomInfo.pClientRandom);</span>
<span class="line-added"> 361                      free(tlsMkdTmp-&gt;RandomInfo.pServerRandom);</span>
<span class="line-added"> 362                      free(tlsMkdTmp-&gt;pVersion);</span>
<span class="line-added"> 363                      break;</span>
<span class="line-added"> 364                  case CKM_TLS12_KEY_AND_MAC_DERIVE:</span>
<span class="line-added"> 365                      tlsKmTmp = tmp;</span>
<span class="line-added"> 366                      TRACE0(&quot;[ CK_TLS12_KEY_MAT_PARAMS ]\n&quot;);</span>
<span class="line-added"> 367                      free(tlsKmTmp-&gt;RandomInfo.pClientRandom);</span>
<span class="line-added"> 368                      free(tlsKmTmp-&gt;RandomInfo.pServerRandom);</span>
<span class="line-added"> 369                      if (tlsKmTmp-&gt;pReturnedKeyMaterial != NULL) {</span>
<span class="line-added"> 370                          free(tlsKmTmp-&gt;pReturnedKeyMaterial-&gt;pIVClient);</span>
<span class="line-added"> 371                          free(tlsKmTmp-&gt;pReturnedKeyMaterial-&gt;pIVServer);</span>
<span class="line-added"> 372                          free(tlsKmTmp-&gt;pReturnedKeyMaterial);</span>
<span class="line-added"> 373                      }</span>
<span class="line-added"> 374                      break;</span>
<span class="line-added"> 375                  case CKM_ECDH1_DERIVE:</span>
<span class="line-added"> 376                  case CKM_ECDH1_COFACTOR_DERIVE:</span>
<span class="line-added"> 377                      TRACE0(&quot;[ CK_ECDH1_DERIVE_PARAMS ]\n&quot;);</span>
<span class="line-added"> 378                      free(((CK_ECDH1_DERIVE_PARAMS *)tmp)-&gt;pSharedData);</span>
<span class="line-added"> 379                      free(((CK_ECDH1_DERIVE_PARAMS *)tmp)-&gt;pPublicData);</span>
<span class="line-added"> 380                      break;</span>
<span class="line-added"> 381                  case CKM_TLS_MAC:</span>
<span class="line-added"> 382                  case CKM_AES_CTR:</span>
<span class="line-added"> 383                  case CKM_RSA_PKCS_PSS:</span>
<span class="line-added"> 384                  case CKM_CAMELLIA_CTR:</span>
<span class="line-added"> 385                      // params do not contain pointers</span>
<span class="line-added"> 386                      break;</span>
<span class="line-added"> 387                  default:</span>
<span class="line-added"> 388                      // currently unsupported mechs by SunPKCS11 provider</span>
<span class="line-added"> 389                      // CKM_RSA_PKCS_OAEP, CKM_ECMQV_DERIVE,</span>
<span class="line-added"> 390                      // CKM_X9_42_*, CKM_KEA_DERIVE, CKM_RC2_*, CKM_RC5_*,</span>
<span class="line-added"> 391                      // CKM_SKIPJACK_*, CKM_KEY_WRAP_SET_OAEP, CKM_PKCS5_PBKD2,</span>
<span class="line-added"> 392                      // PBE mechs, WTLS mechs, CMS mechs,</span>
<span class="line-added"> 393                      // CKM_EXTRACT_KEY_FROM_KEY, CKM_OTP, CKM_KIP,</span>
<span class="line-added"> 394                      // CKM_DSA_PARAMETER_GEN?, CKM_GOSTR3410_*</span>
<span class="line-added"> 395                      // CK_any_CBC_ENCRYPT_DATA?</span>
<span class="line-added"> 396                      TRACE0(&quot;ERROR: UNSUPPORTED CK_MECHANISM\n&quot;);</span>
<span class="line-added"> 397                      break;</span>
<span class="line-added"> 398              }</span>
<span class="line-added"> 399              TRACE1(&quot;\t=&gt; freed param %p\n&quot;, tmp);</span>
<span class="line-added"> 400              free(tmp);</span>
<span class="line-added"> 401          } else {</span>
<span class="line-added"> 402              TRACE0(&quot;\t=&gt; param NULL\n&quot;);</span>
<span class="line-added"> 403          }</span>
<span class="line-added"> 404          free(mechPtr);</span>
<span class="line-added"> 405          TRACE0(&quot;FINISHED\n&quot;);</span>
<span class="line-added"> 406      }</span>
<span class="line-added"> 407 }</span>
 408 
<span class="line-modified"> 409 /* This function replaces the CK_GCM_PARAMS_NO_IVBITS structure associated</span>
<span class="line-modified"> 410  * with the specified CK_MECHANISM structure with CK_GCM_PARAMS</span>
<span class="line-modified"> 411  * structure.</span>
<span class="line-added"> 412  *</span>
<span class="line-added"> 413  * @param mechPtr pointer to the CK_MECHANISM structure containing</span>
<span class="line-added"> 414  * the to-be-converted CK_GCM_PARAMS_NO_IVBITS structure.</span>
<span class="line-added"> 415  * @return pointer to the CK_MECHANISM structure containing the</span>
<span class="line-added"> 416  * converted CK_GCM_PARAMS structure or NULL if no conversion took place.</span>
<span class="line-added"> 417  */</span>
<span class="line-added"> 418 CK_MECHANISM_PTR updateGCMParams(JNIEnv *env, CK_MECHANISM_PTR mechPtr) {</span>
<span class="line-added"> 419     CK_GCM_PARAMS* pGcmParams2 = NULL;</span>
<span class="line-added"> 420     CK_GCM_PARAMS_NO_IVBITS* pParams = NULL;</span>
<span class="line-added"> 421     if ((mechPtr-&gt;mechanism == CKM_AES_GCM) &amp;&amp;</span>
<span class="line-added"> 422             (mechPtr-&gt;pParameter != NULL_PTR) &amp;&amp;</span>
<span class="line-added"> 423             (mechPtr-&gt;ulParameterLen == sizeof(CK_GCM_PARAMS_NO_IVBITS))) {</span>
<span class="line-added"> 424         pGcmParams2 = calloc(1, sizeof(CK_GCM_PARAMS));</span>
<span class="line-added"> 425         if (pGcmParams2 == NULL) {</span>
<span class="line-added"> 426             throwOutOfMemoryError(env, 0);</span>
<span class="line-added"> 427             return NULL;</span>
 428         }
<span class="line-added"> 429         pParams = (CK_GCM_PARAMS_NO_IVBITS*) mechPtr-&gt;pParameter;</span>
<span class="line-added"> 430         pGcmParams2-&gt;pIv = pParams-&gt;pIv;</span>
<span class="line-added"> 431         pGcmParams2-&gt;ulIvLen = pParams-&gt;ulIvLen;</span>
<span class="line-added"> 432         pGcmParams2-&gt;ulIvBits = (pGcmParams2-&gt;ulIvLen &lt;&lt; 3);</span>
<span class="line-added"> 433         pGcmParams2-&gt;pAAD = pParams-&gt;pAAD;</span>
<span class="line-added"> 434         pGcmParams2-&gt;ulAADLen = pParams-&gt;ulAADLen;</span>
<span class="line-added"> 435         pGcmParams2-&gt;ulTagBits = pParams-&gt;ulTagBits;</span>
<span class="line-added"> 436         TRACE1(&quot;DEBUG updateGCMParams: pMech %p\n&quot;, mechPtr);</span>
<span class="line-added"> 437         TRACE2(&quot;\t=&gt; GCM param w/o ulIvBits %p =&gt; GCM param %p\n&quot;, pParams,</span>
<span class="line-added"> 438                 pGcmParams2);</span>
<span class="line-added"> 439         free(pParams);</span>
<span class="line-added"> 440         mechPtr-&gt;pParameter = pGcmParams2;</span>
<span class="line-added"> 441         mechPtr-&gt;ulParameterLen = sizeof(CK_GCM_PARAMS);</span>
<span class="line-added"> 442         return mechPtr;</span>
<span class="line-added"> 443     } else {</span>
<span class="line-added"> 444         TRACE0(&quot;DEBUG updateGCMParams: no conversion done\n&quot;);</span>
 445     }
<span class="line-modified"> 446     return NULL;</span>
 447 }
 448 
 449 /*
 450  * the following functions convert Java arrays to PKCS#11 array pointers and
 451  * their array length and vice versa
 452  *
 453  * void j&lt;Type&gt;ArrayToCK&lt;Type&gt;Array(JNIEnv *env,
 454  *                                  const j&lt;Type&gt;Array jArray,
 455  *                                  CK_&lt;Type&gt;_PTR *ckpArray,
 456  *                                  CK_ULONG_PTR ckLength);
 457  *
 458  * j&lt;Type&gt;Array ck&lt;Type&gt;ArrayToJ&lt;Type&gt;Array(JNIEnv *env,
 459  *                                          const CK_&lt;Type&gt;_PTR ckpArray,
 460  *                                          CK_ULONG ckLength);
 461  *
 462  * PKCS#11 arrays consist always of a pointer to the beginning of the array and
 463  * the array length whereas Java arrays carry their array length.
 464  *
 465  * The Functions to convert a Java array to a PKCS#11 array are void functions.
 466  * Their arguments are the Java array object to convert, the reference to the
</pre>
<hr />
<pre>
 480 
 481 /*
 482  * converts a jbooleanArray to a CK_BBOOL array. The allocated memory has to be freed after use!
 483  *
 484  * @param env - used to call JNI funktions to get the array informtaion
 485  * @param jArray - the Java array to convert
 486  * @param ckpArray - the reference, where the pointer to the new CK_BBOOL array will be stored
 487  * @param ckpLength - the reference, where the array length will be stored
 488  */
 489 void jBooleanArrayToCKBBoolArray(JNIEnv *env, const jbooleanArray jArray, CK_BBOOL **ckpArray, CK_ULONG_PTR ckpLength)
 490 {
 491     jboolean* jpTemp;
 492     CK_ULONG i;
 493 
 494     if(jArray == NULL) {
 495         *ckpArray = NULL_PTR;
 496         *ckpLength = 0L;
 497         return;
 498     }
 499     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified"> 500     jpTemp = (jboolean*) calloc(*ckpLength, sizeof(jboolean));</span>
 501     if (jpTemp == NULL) {
 502         throwOutOfMemoryError(env, 0);
 503         return;
 504     }
 505     (*env)-&gt;GetBooleanArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
 506     if ((*env)-&gt;ExceptionCheck(env)) {
 507         free(jpTemp);
 508         return;
 509     }
 510 
<span class="line-modified"> 511     *ckpArray = (CK_BBOOL*) calloc (*ckpLength, sizeof(CK_BBOOL));</span>
 512     if (*ckpArray == NULL) {
 513         free(jpTemp);
 514         throwOutOfMemoryError(env, 0);
 515         return;
 516     }
 517     for (i=0; i&lt;(*ckpLength); i++) {
 518         (*ckpArray)[i] = jBooleanToCKBBool(jpTemp[i]);
 519     }
 520     free(jpTemp);
 521 }
 522 
 523 /*
 524  * converts a jbyteArray to a CK_BYTE array. The allocated memory has to be freed after use!
 525  *
 526  * @param env - used to call JNI funktions to get the array informtaion
 527  * @param jArray - the Java array to convert
 528  * @param ckpArray - the reference, where the pointer to the new CK_BYTE array will be stored
 529  * @param ckpLength - the reference, where the array length will be stored
 530  */
 531 void jByteArrayToCKByteArray(JNIEnv *env, const jbyteArray jArray, CK_BYTE_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 532 {
 533     jbyte* jpTemp;
 534     CK_ULONG i;
 535 
 536     if(jArray == NULL) {
 537         *ckpArray = NULL_PTR;
 538         *ckpLength = 0L;
 539         return;
 540     }
 541     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified"> 542     jpTemp = (jbyte*) calloc(*ckpLength, sizeof(jbyte));</span>
 543     if (jpTemp == NULL) {
 544         throwOutOfMemoryError(env, 0);
 545         return;
 546     }
 547     (*env)-&gt;GetByteArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
 548     if ((*env)-&gt;ExceptionCheck(env)) {
 549         free(jpTemp);
 550         return;
 551     }
 552 
 553     /* if CK_BYTE is the same size as jbyte, we save an additional copy */
 554     if (sizeof(CK_BYTE) == sizeof(jbyte)) {
 555         *ckpArray = (CK_BYTE_PTR) jpTemp;
 556     } else {
<span class="line-modified"> 557         *ckpArray = (CK_BYTE_PTR) calloc (*ckpLength, sizeof(CK_BYTE));</span>
 558         if (*ckpArray == NULL) {
 559             free(jpTemp);
 560             throwOutOfMemoryError(env, 0);
 561             return;
 562         }
 563         for (i=0; i&lt;(*ckpLength); i++) {
 564             (*ckpArray)[i] = jByteToCKByte(jpTemp[i]);
 565         }
 566         free(jpTemp);
 567     }
 568 }
 569 
 570 /*
 571  * converts a jlongArray to a CK_ULONG array. The allocated memory has to be freed after use!
 572  *
 573  * @param env - used to call JNI funktions to get the array informtaion
 574  * @param jArray - the Java array to convert
 575  * @param ckpArray - the reference, where the pointer to the new CK_ULONG array will be stored
 576  * @param ckpLength - the reference, where the array length will be stored
 577  */
 578 void jLongArrayToCKULongArray(JNIEnv *env, const jlongArray jArray, CK_ULONG_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 579 {
 580     jlong* jTemp;
 581     CK_ULONG i;
 582 
 583     if(jArray == NULL) {
 584         *ckpArray = NULL_PTR;
 585         *ckpLength = 0L;
 586         return;
 587     }
 588     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified"> 589     jTemp = (jlong*) calloc(*ckpLength, sizeof(jlong));</span>
 590     if (jTemp == NULL) {
 591         throwOutOfMemoryError(env, 0);
 592         return;
 593     }
 594     (*env)-&gt;GetLongArrayRegion(env, jArray, 0, *ckpLength, jTemp);
 595     if ((*env)-&gt;ExceptionCheck(env)) {
 596         free(jTemp);
 597         return;
 598     }
 599 
<span class="line-modified"> 600     *ckpArray = (CK_ULONG_PTR) calloc(*ckpLength, sizeof(CK_ULONG));</span>
 601     if (*ckpArray == NULL) {
 602         free(jTemp);
 603         throwOutOfMemoryError(env, 0);
 604         return;
 605     }
 606     for (i=0; i&lt;(*ckpLength); i++) {
 607         (*ckpArray)[i] = jLongToCKULong(jTemp[i]);
 608     }
 609     free(jTemp);
 610 }
 611 
 612 /*
 613  * converts a jcharArray to a CK_CHAR array. The allocated memory has to be freed after use!
 614  *
 615  * @param env - used to call JNI funktions to get the array informtaion
 616  * @param jArray - the Java array to convert
 617  * @param ckpArray - the reference, where the pointer to the new CK_CHAR array will be stored
 618  * @param ckpLength - the reference, where the array length will be stored
 619  */
 620 void jCharArrayToCKCharArray(JNIEnv *env, const jcharArray jArray, CK_CHAR_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 621 {
 622     jchar* jpTemp;
 623     CK_ULONG i;
 624 
 625     if(jArray == NULL) {
 626         *ckpArray = NULL_PTR;
 627         *ckpLength = 0L;
 628         return;
 629     }
 630     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified"> 631     jpTemp = (jchar*) calloc(*ckpLength, sizeof(jchar));</span>
 632     if (jpTemp == NULL) {
 633         throwOutOfMemoryError(env, 0);
 634         return;
 635     }
 636     (*env)-&gt;GetCharArrayRegion(env, jArray, 0, *ckpLength, jpTemp);
 637     if ((*env)-&gt;ExceptionCheck(env)) {
 638         free(jpTemp);
 639         return;
 640     }
 641 
<span class="line-modified"> 642     *ckpArray = (CK_CHAR_PTR) calloc (*ckpLength, sizeof(CK_CHAR));</span>
 643     if (*ckpArray == NULL) {
 644         free(jpTemp);
 645         throwOutOfMemoryError(env, 0);
 646         return;
 647     }
 648     for (i=0; i&lt;(*ckpLength); i++) {
 649         (*ckpArray)[i] = jCharToCKChar(jpTemp[i]);
 650     }
 651     free(jpTemp);
 652 }
 653 
 654 /*
 655  * converts a jcharArray to a CK_UTF8CHAR array. The allocated memory has to be freed after use!
 656  *
 657  * @param env - used to call JNI funktions to get the array informtaion
 658  * @param jArray - the Java array to convert
 659  * @param ckpArray - the reference, where the pointer to the new CK_UTF8CHAR array will be stored
 660  * @param ckpLength - the reference, where the array length will be stored
 661  */
 662 void jCharArrayToCKUTF8CharArray(JNIEnv *env, const jcharArray jArray, CK_UTF8CHAR_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 663 {
 664     jchar* jTemp;
 665     CK_ULONG i;
 666 
 667     if(jArray == NULL) {
 668         *ckpArray = NULL_PTR;
 669         *ckpLength = 0L;
 670         return;
 671     }
 672     *ckpLength = (*env)-&gt;GetArrayLength(env, jArray);
<span class="line-modified"> 673     jTemp = (jchar*) calloc(*ckpLength, sizeof(jchar));</span>
 674     if (jTemp == NULL) {
 675         throwOutOfMemoryError(env, 0);
 676         return;
 677     }
 678     (*env)-&gt;GetCharArrayRegion(env, jArray, 0, *ckpLength, jTemp);
 679     if ((*env)-&gt;ExceptionCheck(env)) {
 680         free(jTemp);
 681         return;
 682     }
 683 
<span class="line-modified"> 684     *ckpArray = (CK_UTF8CHAR_PTR) calloc(*ckpLength, sizeof(CK_UTF8CHAR));</span>
 685     if (*ckpArray == NULL) {
 686         free(jTemp);
 687         throwOutOfMemoryError(env, 0);
 688         return;
 689     }
 690     for (i=0; i&lt;(*ckpLength); i++) {
 691         (*ckpArray)[i] = jCharToCKUTF8Char(jTemp[i]);
 692     }
 693     free(jTemp);
 694 }
 695 
 696 /*
 697  * converts a jstring to a CK_CHAR array. The allocated memory has to be freed after use!
 698  *
 699  * @param env - used to call JNI funktions to get the array informtaion
 700  * @param jArray - the Java array to convert
 701  * @param ckpArray - the reference, where the pointer to the new CK_CHAR array will be stored
 702  * @param ckpLength - the reference, where the array length will be stored
 703  */
 704 void jStringToCKUTF8CharArray(JNIEnv *env, const jstring jArray, CK_UTF8CHAR_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 705 {
 706     const char* pCharArray;
 707     jboolean isCopy;
 708 
 709     if(jArray == NULL) {
 710         *ckpArray = NULL_PTR;
 711         *ckpLength = 0L;
 712         return;
 713     }
 714 
 715     pCharArray = (*env)-&gt;GetStringUTFChars(env, jArray, &amp;isCopy);
 716     if (pCharArray == NULL) { return; }
 717 
 718     *ckpLength = (CK_ULONG) strlen(pCharArray);
<span class="line-modified"> 719     *ckpArray = (CK_UTF8CHAR_PTR) calloc(*ckpLength + 1, sizeof(CK_UTF8CHAR));</span>
 720     if (*ckpArray == NULL) {
 721         (*env)-&gt;ReleaseStringUTFChars(env, (jstring) jArray, pCharArray);
 722         throwOutOfMemoryError(env, 0);
 723         return;
 724     }
 725     strcpy((char*)*ckpArray, pCharArray);
 726     (*env)-&gt;ReleaseStringUTFChars(env, (jstring) jArray, pCharArray);
 727 }
 728 
 729 /*
 730  * converts a jobjectArray with Java Attributes to a CK_ATTRIBUTE array. The allocated memory
 731  * has to be freed after use!
 732  *
 733  * @param env - used to call JNI funktions to get the array informtaion
 734  * @param jArray - the Java Attribute array (template) to convert
 735  * @param ckpArray - the reference, where the pointer to the new CK_ATTRIBUTE array will be
 736  *                   stored
 737  * @param ckpLength - the reference, where the array length will be stored
 738  */
 739 void jAttributeArrayToCKAttributeArray(JNIEnv *env, jobjectArray jArray, CK_ATTRIBUTE_PTR *ckpArray, CK_ULONG_PTR ckpLength)
 740 {
 741     CK_ULONG i;
 742     jlong jLength;
 743     jobject jAttribute;
 744 
 745     TRACE0(&quot;\nDEBUG: jAttributeArrayToCKAttributeArray&quot;);
 746     if (jArray == NULL) {
 747         *ckpArray = NULL_PTR;
 748         *ckpLength = 0L;
 749         return;
 750     }
 751     jLength = (*env)-&gt;GetArrayLength(env, jArray);
 752     *ckpLength = jLongToCKULong(jLength);
<span class="line-modified"> 753     *ckpArray = (CK_ATTRIBUTE_PTR) calloc(*ckpLength, sizeof(CK_ATTRIBUTE));</span>
 754     if (*ckpArray == NULL) {
 755         throwOutOfMemoryError(env, 0);
 756         return;
 757     }
<span class="line-modified"> 758     TRACE1(&quot;, converting %lld attributes&quot;, (long long int) jLength);</span>
 759     for (i=0; i&lt;(*ckpLength); i++) {
<span class="line-modified"> 760         TRACE1(&quot;, getting %lu. attribute&quot;, i);</span>
 761         jAttribute = (*env)-&gt;GetObjectArrayElement(env, jArray, i);
 762         if ((*env)-&gt;ExceptionCheck(env)) {
 763             freeCKAttributeArray(*ckpArray, i);
 764             return;
 765         }
<span class="line-modified"> 766         TRACE1(&quot;, jAttribute , converting %lu. attribute&quot;, i);</span>

 767         (*ckpArray)[i] = jAttributeToCKAttribute(env, jAttribute);
 768         if ((*env)-&gt;ExceptionCheck(env)) {
 769             freeCKAttributeArray(*ckpArray, i);
 770             return;
 771         }
 772     }
 773     TRACE0(&quot;FINISHED\n&quot;);
 774 }
 775 
 776 /*
 777  * converts a CK_BYTE array and its length to a jbyteArray.
 778  *
 779  * @param env - used to call JNI funktions to create the new Java array
 780  * @param ckpArray - the pointer to the CK_BYTE array to convert
 781  * @param ckpLength - the length of the array to convert
 782  * @return - the new Java byte array or NULL if error occurred
 783  */
 784 jbyteArray ckByteArrayToJByteArray(JNIEnv *env, const CK_BYTE_PTR ckpArray, CK_ULONG ckLength)
 785 {
 786     CK_ULONG i;
 787     jbyte* jpTemp;
 788     jbyteArray jArray;
 789 
 790     /* if CK_BYTE is the same size as jbyte, we save an additional copy */
 791     if (sizeof(CK_BYTE) == sizeof(jbyte)) {
 792         jpTemp = (jbyte*) ckpArray;
 793     } else {
<span class="line-modified"> 794         jpTemp = (jbyte*) calloc(ckLength, sizeof(jbyte));</span>
 795         if (jpTemp == NULL) {
 796             throwOutOfMemoryError(env, 0);
 797             return NULL;
 798         }
 799         for (i=0; i&lt;ckLength; i++) {
 800             jpTemp[i] = ckByteToJByte(ckpArray[i]);
 801         }
 802     }
 803 
 804     jArray = (*env)-&gt;NewByteArray(env, ckULongToJSize(ckLength));
 805     if (jArray != NULL) {
 806         (*env)-&gt;SetByteArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 807     }
 808 
 809     if (sizeof(CK_BYTE) != sizeof(jbyte)) { free(jpTemp); }
 810 
 811     return jArray ;
 812 }
 813 
 814 /*
 815  * converts a CK_ULONG array and its length to a jlongArray.
 816  *
 817  * @param env - used to call JNI funktions to create the new Java array
 818  * @param ckpArray - the pointer to the CK_ULONG array to convert
 819  * @param ckpLength - the length of the array to convert
 820  * @return - the new Java long array
 821  */
 822 jlongArray ckULongArrayToJLongArray(JNIEnv *env, const CK_ULONG_PTR ckpArray, CK_ULONG ckLength)
 823 {
 824     CK_ULONG i;
 825     jlong* jpTemp;
 826     jlongArray jArray;
 827 
<span class="line-modified"> 828     jpTemp = (jlong*) calloc(ckLength, sizeof(jlong));</span>
 829     if (jpTemp == NULL) {
 830         throwOutOfMemoryError(env, 0);
 831         return NULL;
 832     }
 833     for (i=0; i&lt;ckLength; i++) {
 834         jpTemp[i] = ckLongToJLong(ckpArray[i]);
 835     }
 836     jArray = (*env)-&gt;NewLongArray(env, ckULongToJSize(ckLength));
 837     if (jArray != NULL) {
 838         (*env)-&gt;SetLongArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 839     }
 840     free(jpTemp);
 841 
 842     return jArray ;
 843 }
 844 
 845 /*
 846  * converts a CK_CHAR array and its length to a jcharArray.
 847  *
 848  * @param env - used to call JNI funktions to create the new Java array
 849  * @param ckpArray - the pointer to the CK_CHAR array to convert
 850  * @param ckpLength - the length of the array to convert
 851  * @return - the new Java char array
 852  */
 853 jcharArray ckCharArrayToJCharArray(JNIEnv *env, const CK_CHAR_PTR ckpArray, CK_ULONG ckLength)
 854 {
 855     CK_ULONG i;
 856     jchar* jpTemp;
 857     jcharArray jArray;
 858 
<span class="line-modified"> 859     jpTemp = (jchar*) calloc(ckLength, sizeof(jchar));</span>
 860     if (jpTemp == NULL) {
 861         throwOutOfMemoryError(env, 0);
 862         return NULL;
 863     }
 864     for (i=0; i&lt;ckLength; i++) {
 865         jpTemp[i] = ckCharToJChar(ckpArray[i]);
 866     }
 867     jArray = (*env)-&gt;NewCharArray(env, ckULongToJSize(ckLength));
 868     if (jArray != NULL) {
 869         (*env)-&gt;SetCharArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 870     }
 871     free(jpTemp);
 872 
 873     return jArray ;
 874 }
 875 
 876 /*
 877  * converts a CK_UTF8CHAR array and its length to a jcharArray.
 878  *
 879  * @param env - used to call JNI funktions to create the new Java array
 880  * @param ckpArray - the pointer to the CK_UTF8CHAR array to convert
 881  * @param ckpLength - the length of the array to convert
 882  * @return - the new Java char array
 883  */
 884 jcharArray ckUTF8CharArrayToJCharArray(JNIEnv *env, const CK_UTF8CHAR_PTR ckpArray, CK_ULONG ckLength)
 885 {
 886     CK_ULONG i;
 887     jchar* jpTemp;
 888     jcharArray jArray;
 889 
<span class="line-modified"> 890     jpTemp = (jchar*) calloc(ckLength, sizeof(jchar));</span>
 891     if (jpTemp == NULL) {
 892         throwOutOfMemoryError(env, 0);
 893         return NULL;
 894     }
 895     for (i=0; i&lt;ckLength; i++) {
 896         jpTemp[i] = ckUTF8CharToJChar(ckpArray[i]);
 897     }
 898     jArray = (*env)-&gt;NewCharArray(env, ckULongToJSize(ckLength));
 899     if (jArray != NULL) {
 900         (*env)-&gt;SetCharArrayRegion(env, jArray, 0, ckULongToJSize(ckLength), jpTemp);
 901     }
 902     free(jpTemp);
 903 
 904     return jArray ;
 905 }
 906 
 907 /*
 908  * the following functions convert Java objects to PKCS#11 pointers and the
 909  * length in bytes and vice versa
 910  *
</pre>
<hr />
<pre>
1103     jchar jValue;
1104     CK_CHAR_PTR ckpValue;
1105 
1106     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Char&quot;);
1107     if (jObjectClass == NULL) { return NULL; }
1108     jValueMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;charValue&quot;, &quot;()C&quot;);
1109     if (jValueMethod == NULL) { return NULL; }
1110     jValue = (*env)-&gt;CallCharMethod(env, jObject, jValueMethod);
1111     ckpValue = (CK_CHAR_PTR) malloc(sizeof(CK_CHAR));
1112     if (ckpValue == NULL) {
1113         throwOutOfMemoryError(env, 0);
1114         return NULL;
1115     }
1116     *ckpValue = jCharToCKChar(jValue);
1117 
1118     return ckpValue ;
1119 }
1120 
1121 /*
1122  * converts a Java object into a pointer to CK-type or a CK-structure with the length in Bytes.
<span class="line-modified">1123  * The memory of the returned pointer MUST BE FREED BY CALLER!</span>

1124  *
1125  * @param env - used to call JNI funktions to get the Java classes and objects
1126  * @param jObject - the Java object to convert
<span class="line-modified">1127  * @param ckpLength - pointer to the length (bytes) of the newly-allocated CK-value or CK-structure</span>
<span class="line-modified">1128  * @return ckpObject - pointer to the newly-allocated CK-value or CK-structure</span>
1129  */
<span class="line-modified">1130 CK_VOID_PTR jObjectToPrimitiveCKObjectPtr(JNIEnv *env, jobject jObject, CK_ULONG *ckpLength)</span>
1131 {
1132     jclass jLongClass, jBooleanClass, jByteArrayClass, jCharArrayClass;
1133     jclass jByteClass, jDateClass, jCharacterClass, jIntegerClass;
1134     jclass jBooleanArrayClass, jIntArrayClass, jLongArrayClass;
1135     jclass jStringClass;
1136     jclass jObjectClass, jClassClass;
<span class="line-modified">1137     CK_VOID_PTR ckpObject;</span>
1138     jmethodID jMethod;
1139     jobject jClassObject;
1140     jstring jClassNameString;
1141     char *classNameString, *exceptionMsgPrefix, *exceptionMsg;
1142 
<span class="line-modified">1143     TRACE0(&quot;\nDEBUG: jObjectToPrimitiveCKObjectPtr&quot;);</span>
1144     if (jObject == NULL) {

1145         *ckpLength = 0;
<span class="line-modified">1146         return NULL;</span>
1147     }
1148 
1149     jLongClass = (*env)-&gt;FindClass(env, &quot;java/lang/Long&quot;);
<span class="line-modified">1150     if (jLongClass == NULL) { return NULL; }</span>
1151     if ((*env)-&gt;IsInstanceOf(env, jObject, jLongClass)) {
<span class="line-modified">1152         ckpObject = jLongObjectToCKULongPtr(env, jObject);</span>
1153         *ckpLength = sizeof(CK_ULONG);
<span class="line-modified">1154         TRACE1(&quot;&lt;converted long value %lu&gt;&quot;, *((CK_ULONG *) ckpObject));</span>
<span class="line-modified">1155         return ckpObject;</span>
1156     }
1157 
1158     jBooleanClass = (*env)-&gt;FindClass(env, &quot;java/lang/Boolean&quot;);
<span class="line-modified">1159     if (jBooleanClass == NULL) { return NULL; }</span>
1160     if ((*env)-&gt;IsInstanceOf(env, jObject, jBooleanClass)) {
<span class="line-modified">1161         ckpObject = jBooleanObjectToCKBBoolPtr(env, jObject);</span>
1162         *ckpLength = sizeof(CK_BBOOL);
1163         TRACE0(&quot; &lt;converted boolean value &quot;);
<span class="line-modified">1164         TRACE0((*((CK_BBOOL *) ckpObject) == TRUE) ? &quot;TRUE&gt;&quot; : &quot;FALSE&gt;&quot;);</span>
<span class="line-modified">1165         return ckpObject;</span>
1166     }
1167 
1168     jByteArrayClass = (*env)-&gt;FindClass(env, &quot;[B&quot;);
<span class="line-modified">1169     if (jByteArrayClass == NULL) { return NULL; }</span>
1170     if ((*env)-&gt;IsInstanceOf(env, jObject, jByteArrayClass)) {
<span class="line-modified">1171         jByteArrayToCKByteArray(env, jObject, (CK_BYTE_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">1172         return ckpObject;</span>
1173     }
1174 
1175     jCharArrayClass = (*env)-&gt;FindClass(env, &quot;[C&quot;);
<span class="line-modified">1176     if (jCharArrayClass == NULL) { return NULL; }</span>
1177     if ((*env)-&gt;IsInstanceOf(env, jObject, jCharArrayClass)) {
<span class="line-modified">1178         jCharArrayToCKUTF8CharArray(env, jObject, (CK_UTF8CHAR_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">1179         return ckpObject;</span>
1180     }
1181 
1182     jByteClass = (*env)-&gt;FindClass(env, &quot;java/lang/Byte&quot;);
<span class="line-modified">1183     if (jByteClass == NULL) { return NULL; }</span>
1184     if ((*env)-&gt;IsInstanceOf(env, jObject, jByteClass)) {
<span class="line-modified">1185         ckpObject = jByteObjectToCKBytePtr(env, jObject);</span>
1186         *ckpLength = sizeof(CK_BYTE);
<span class="line-modified">1187         TRACE1(&quot;&lt;converted byte value %X&gt;&quot;, *((CK_BYTE *) ckpObject));</span>
<span class="line-modified">1188         return ckpObject;</span>
1189     }
1190 
1191     jDateClass = (*env)-&gt;FindClass(env, CLASS_DATE);
<span class="line-modified">1192     if (jDateClass == NULL) { return NULL; }</span>
1193     if ((*env)-&gt;IsInstanceOf(env, jObject, jDateClass)) {
<span class="line-modified">1194         ckpObject = jDateObjectToCKDatePtr(env, jObject);</span>
1195         *ckpLength = sizeof(CK_DATE);
<span class="line-modified">1196         TRACE3(&quot;&lt;converted date value %.4s-%.2s-%.2s&gt;&quot;, ((CK_DATE *) ckpObject)-&gt;year,</span>
<span class="line-modified">1197                 ((CK_DATE *) ckpObject)-&gt;month, ((CK_DATE *) ckpObject)-&gt;day);</span>
<span class="line-added">1198         return ckpObject;</span>
1199     }
1200 
1201     jCharacterClass = (*env)-&gt;FindClass(env, &quot;java/lang/Character&quot;);
<span class="line-modified">1202     if (jCharacterClass == NULL) { return NULL; }</span>
1203     if ((*env)-&gt;IsInstanceOf(env, jObject, jCharacterClass)) {
<span class="line-modified">1204         ckpObject = jCharObjectToCKCharPtr(env, jObject);</span>
1205         *ckpLength = sizeof(CK_UTF8CHAR);
<span class="line-modified">1206         TRACE1(&quot;&lt;converted char value %c&gt;&quot;, *((CK_CHAR *) ckpObject));</span>
<span class="line-modified">1207         return ckpObject;</span>
1208     }
1209 
1210     jIntegerClass = (*env)-&gt;FindClass(env, &quot;java/lang/Integer&quot;);
<span class="line-modified">1211     if (jIntegerClass == NULL) { return NULL; }</span>
1212     if ((*env)-&gt;IsInstanceOf(env, jObject, jIntegerClass)) {
<span class="line-modified">1213         ckpObject = jIntegerObjectToCKULongPtr(env, jObject);</span>
1214         *ckpLength = sizeof(CK_ULONG);
<span class="line-modified">1215         TRACE1(&quot;&lt;converted integer value %lu&gt;&quot;, *((CK_ULONG *) ckpObject));</span>
<span class="line-modified">1216         return ckpObject;</span>
1217     }
1218 
1219     jBooleanArrayClass = (*env)-&gt;FindClass(env, &quot;[Z&quot;);
<span class="line-modified">1220     if (jBooleanArrayClass == NULL) { return NULL; }</span>
1221     if ((*env)-&gt;IsInstanceOf(env, jObject, jBooleanArrayClass)) {
<span class="line-modified">1222         jBooleanArrayToCKBBoolArray(env, jObject, (CK_BBOOL**) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">1223         return ckpObject;</span>
1224     }
1225 
1226     jIntArrayClass = (*env)-&gt;FindClass(env, &quot;[I&quot;);
<span class="line-modified">1227     if (jIntArrayClass == NULL) { return NULL; }</span>
1228     if ((*env)-&gt;IsInstanceOf(env, jObject, jIntArrayClass)) {
<span class="line-modified">1229         jLongArrayToCKULongArray(env, jObject, (CK_ULONG_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">1230         return ckpObject;</span>
1231     }
1232 
1233     jLongArrayClass = (*env)-&gt;FindClass(env, &quot;[J&quot;);
<span class="line-modified">1234     if (jLongArrayClass == NULL) { return NULL; }</span>
1235     if ((*env)-&gt;IsInstanceOf(env, jObject, jLongArrayClass)) {
<span class="line-modified">1236         jLongArrayToCKULongArray(env, jObject, (CK_ULONG_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">1237         return ckpObject;</span>
1238     }
1239 
1240     jStringClass = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
<span class="line-modified">1241     if (jStringClass == NULL) { return NULL; }</span>
1242     if ((*env)-&gt;IsInstanceOf(env, jObject, jStringClass)) {
<span class="line-modified">1243         jStringToCKUTF8CharArray(env, jObject, (CK_UTF8CHAR_PTR*) &amp;ckpObject, ckpLength);</span>
<span class="line-modified">1244         return ckpObject;</span>
1245     }
1246 
1247     /* type of jObject unknown, throw PKCS11RuntimeException */
1248     jObjectClass = (*env)-&gt;FindClass(env, &quot;java/lang/Object&quot;);
<span class="line-modified">1249     if (jObjectClass == NULL) { return NULL; }</span>
1250     jMethod = (*env)-&gt;GetMethodID(env, jObjectClass, &quot;getClass&quot;, &quot;()Ljava/lang/Class;&quot;);
<span class="line-modified">1251     if (jMethod == NULL) { return NULL; }</span>
1252     jClassObject = (*env)-&gt;CallObjectMethod(env, jObject, jMethod);
1253     assert(jClassObject != 0);
1254     jClassClass = (*env)-&gt;FindClass(env, &quot;java/lang/Class&quot;);
<span class="line-modified">1255     if (jClassClass == NULL) { return NULL; }</span>
1256     jMethod = (*env)-&gt;GetMethodID(env, jClassClass, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;);
<span class="line-modified">1257     if (jMethod == NULL) { return NULL; }</span>
1258     jClassNameString = (jstring)
1259         (*env)-&gt;CallObjectMethod(env, jClassObject, jMethod);
1260     assert(jClassNameString != 0);
1261     classNameString = (char*)
1262         (*env)-&gt;GetStringUTFChars(env, jClassNameString, NULL);
<span class="line-modified">1263     if (classNameString == NULL) { return NULL; }</span>
1264     exceptionMsgPrefix = &quot;Java object of this class cannot be converted to native PKCS#11 type: &quot;;
1265     exceptionMsg = (char *)
<span class="line-modified">1266         malloc(strlen(exceptionMsgPrefix) + strlen(classNameString) + 1);</span>
1267     if (exceptionMsg == NULL) {
1268         (*env)-&gt;ReleaseStringUTFChars(env, jClassNameString, classNameString);
1269         throwOutOfMemoryError(env, 0);
<span class="line-modified">1270         return NULL;</span>
1271     }
1272     strcpy(exceptionMsg, exceptionMsgPrefix);
1273     strcat(exceptionMsg, classNameString);
1274     (*env)-&gt;ReleaseStringUTFChars(env, jClassNameString, classNameString);
1275     throwPKCS11RuntimeException(env, exceptionMsg);
1276     free(exceptionMsg);

1277     *ckpLength = 0;
1278 
1279     TRACE0(&quot;FINISHED\n&quot;);
<span class="line-added">1280     return NULL;</span>
1281 }
1282 
1283 #ifdef P11_MEMORYDEBUG
1284 
1285 #undef malloc
<span class="line-added">1286 #undef calloc</span>
1287 #undef free
1288 
1289 void *p11malloc(size_t c, char *file, int line) {
1290     void *p = malloc(c);
<span class="line-modified">1291     fprintf(stdout, &quot;malloc\t%08lX\t%lX\t%s:%d\n&quot;, ptr_to_jlong(p), c, file, line);</span>
<span class="line-added">1292     fflush(stdout);</span>
<span class="line-added">1293     return p;</span>
<span class="line-added">1294 }</span>
<span class="line-added">1295 </span>
<span class="line-added">1296 void *p11calloc(size_t c, size_t s, char *file, int line) {</span>
<span class="line-added">1297     void *p = calloc(c, s);</span>
<span class="line-added">1298     fprintf(stdout, &quot;calloc\t%08lX\t%lX\t%lX\t%s:%d\n&quot;, ptr_to_jlong(p), c, s, file, line);</span>
<span class="line-added">1299     fflush(stdout);</span>
1300     return p;
1301 }
1302 
1303 void p11free(void *p, char *file, int line) {
<span class="line-modified">1304     fprintf(stdout, &quot;free\t%08lX\t\t%s:%d\n&quot;, ptr_to_jlong(p), file, line);</span>
<span class="line-added">1305     fflush(stdout);</span>
1306     free(p);
1307 }
1308 
1309 #endif
1310 
1311 // prints a message to stdout if debug output is enabled
1312 void printDebug(const char *format, ...) {
1313     if (debug == JNI_TRUE) {
1314         va_list args;
1315         fprintf(stdout, &quot;sunpkcs11: &quot;);
1316         va_start(args, format);
1317         vfprintf(stdout, format, args);
1318         va_end(args);
1319         fflush(stdout);
1320     }
1321 }
1322 
</pre>
</td>
</tr>
</table>
<center><a href="p11_sign.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="pkcs11.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
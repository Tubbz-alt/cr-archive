<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/P11Key.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="P11Digest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="P11KeyStore.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/P11Key.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1120             return w;
1121         }
1122         public ECParameterSpec getParams() {
1123             fetchValues();
1124             return params;
1125         }
1126         public String toString() {
1127             fetchValues();
1128             return super.toString()
1129                 + &quot;\n  public x coord: &quot; + w.getAffineX()
1130                 + &quot;\n  public y coord: &quot; + w.getAffineY()
1131                 + &quot;\n  parameters: &quot; + params;
1132         }
1133     }
1134 }
1135 
1136 final class NativeKeyHolder {
1137 
1138     private static long nativeKeyWrapperKeyID = 0;
1139     private static CK_MECHANISM nativeKeyWrapperMechanism = null;


1140 
1141     private final P11Key p11Key;
1142     private final byte[] nativeKeyInfo;

1143 
1144     // destroyed and recreated when refCount toggles to 1
1145     private long keyID;
1146 
<span class="line-removed">1147     private boolean isTokenObject;</span>
<span class="line-removed">1148 </span>
1149     // phantom reference notification clean up for session keys
1150     private SessionKeyRef ref;
1151 
1152     private int refCount;
1153 


























































1154     NativeKeyHolder(P11Key p11Key, long keyID, Session keySession,
1155             boolean extractKeyInfo, boolean isTokenObject) {
1156         this.p11Key = p11Key;
1157         this.keyID = keyID;
1158         this.refCount = -1;
1159         byte[] ki = null;
1160         if (isTokenObject) {
1161             this.ref = null;
1162         } else {
<span class="line-removed">1163             this.ref = new SessionKeyRef(p11Key, keyID, keySession);</span>
<span class="line-removed">1164 </span>
1165             // Try extracting key info, if any error, disable it
1166             Token token = p11Key.token;
1167             if (extractKeyInfo) {
1168                 try {
<span class="line-modified">1169                     if (p11Key.sensitive &amp;&amp; nativeKeyWrapperKeyID == 0) {</span>

1170                         synchronized(NativeKeyHolder.class) {
<span class="line-modified">1171                             // Create a global wrapping/unwrapping key</span>
<span class="line-modified">1172                             CK_ATTRIBUTE[] wrappingAttributes = token.getAttributes</span>
<span class="line-modified">1173                                 (O_GENERATE, CKO_SECRET_KEY, CKK_AES, new CK_ATTRIBUTE[] {</span>
<span class="line-modified">1174                                     new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),</span>
<span class="line-modified">1175                                     new CK_ATTRIBUTE(CKA_VALUE_LEN, 256 &gt;&gt; 3),</span>
<span class="line-modified">1176                                 });</span>
<span class="line-modified">1177                             Session wrappingSession = null;</span>
<span class="line-modified">1178                             try {</span>
<span class="line-modified">1179                                 wrappingSession = token.getObjSession();</span>
<span class="line-modified">1180                                 nativeKeyWrapperKeyID = token.p11.C_GenerateKey</span>
<span class="line-removed">1181                                     (wrappingSession.id(),</span>
<span class="line-removed">1182                                     new CK_MECHANISM(CKM_AES_KEY_GEN),</span>
<span class="line-removed">1183                                     wrappingAttributes);</span>
<span class="line-removed">1184                                 byte[] iv = new byte[16];</span>
<span class="line-removed">1185                                 JCAUtil.getSecureRandom().nextBytes(iv);</span>
<span class="line-removed">1186                                 nativeKeyWrapperMechanism = new CK_MECHANISM</span>
<span class="line-removed">1187                                     (CKM_AES_CBC_PAD, iv);</span>
<span class="line-removed">1188                             } catch (PKCS11Exception e) {</span>
<span class="line-removed">1189                                 // best effort</span>
<span class="line-removed">1190                             } finally {</span>
<span class="line-removed">1191                                 token.releaseSession(wrappingSession);</span>
1192                             }
1193                         }
1194                     }
1195                     Session opSession = null;
1196                     try {
1197                         opSession = token.getOpSession();
1198                         ki = p11Key.token.p11.getNativeKeyInfo(opSession.id(),
<span class="line-modified">1199                             keyID, nativeKeyWrapperKeyID, nativeKeyWrapperMechanism);</span>

1200                     } catch (PKCS11Exception e) {
1201                         // best effort
1202                     } finally {
1203                         token.releaseSession(opSession);
1204                     }
1205                 } catch (PKCS11Exception e) {
1206                     // best effort
1207                 }
1208             }


1209         }
1210         this.nativeKeyInfo = ((ki == null || ki.length == 0)? null : ki);
1211     }
1212 
1213     long getKeyID() throws ProviderException {
1214         if (this.nativeKeyInfo != null) {
1215             synchronized(this.nativeKeyInfo) {
1216                 if (this.refCount == -1) {
1217                     this.refCount = 0;
1218                 }
1219                 int cnt = (this.refCount)++;
1220                 if (keyID == 0) {
1221                     if (cnt != 0) {
1222                         throw new RuntimeException(
1223                                 &quot;Error: null keyID with non-zero refCount &quot; + cnt);
1224                     }
<span class="line-removed">1225                     if (this.ref != null)  {</span>
<span class="line-removed">1226                         throw new RuntimeException(</span>
<span class="line-removed">1227                                 &quot;Error: null keyID with non-null session ref&quot;);</span>
<span class="line-removed">1228                     }</span>
1229                     Token token = p11Key.token;
1230                     // Create keyID using nativeKeyInfo
1231                     Session session = null;
1232                     try {
1233                         session = token.getObjSession();
1234                         this.keyID = token.p11.createNativeKey(session.id(),
<span class="line-modified">1235                                 nativeKeyInfo, nativeKeyWrapperKeyID, nativeKeyWrapperMechanism);</span>
<span class="line-modified">1236                         this.ref = new SessionKeyRef(p11Key, this.keyID, session);</span>

1237                     } catch (PKCS11Exception e) {
1238                         this.refCount--;
1239                         throw new ProviderException(&quot;Error recreating native key&quot;, e);
1240                     } finally {
1241                         token.releaseSession(session);
1242                     }
1243                 } else {
1244                     if (cnt &lt; 0) {
1245                         throw new RuntimeException(&quot;ERROR: negative refCount&quot;);
1246                     }
1247                 }
1248             }
1249         }
1250         return keyID;
1251     }
1252 
1253     void releaseKeyID() {
1254         if (this.nativeKeyInfo != null) {
1255             synchronized(this.nativeKeyInfo) {
1256                 if (this.refCount == -1) {
1257                     throw new RuntimeException(&quot;Error: miss match getKeyID call&quot;);
1258                 }
1259                 int cnt = --(this.refCount);
1260                 if (cnt == 0) {
1261                     // destroy
1262                     if (this.keyID == 0) {
1263                         throw new RuntimeException(&quot;ERROR: null keyID can&#39;t be destroyed&quot;);
1264                     }
1265 
<span class="line-removed">1266                     if (this.ref == null) {</span>
<span class="line-removed">1267                         throw new RuntimeException(&quot;ERROR: null session ref can&#39;t be disposed&quot;);</span>
<span class="line-removed">1268                     }</span>
1269                     // destroy
1270                     this.keyID = 0;
<span class="line-modified">1271                     this.ref = this.ref.dispose();</span>
1272                 } else {
1273                     if (cnt &lt; 0) {
1274                         // should never happen as we start count at 1 and pair get/release calls
1275                         throw new RuntimeException(&quot;wrong refCount value: &quot; + cnt);
1276                     }
1277                 }
1278             }
1279         }
1280     }
1281 }
1282 
1283 /*
1284  * NOTE: Must use PhantomReference here and not WeakReference
1285  * otherwise the key maybe cleared before other objects which
1286  * still use these keys during finalization such as SSLSocket.
1287  */
<span class="line-modified">1288 final class SessionKeyRef extends PhantomReference&lt;P11Key&gt;</span>
<span class="line-removed">1289     implements Comparable&lt;SessionKeyRef&gt; {</span>
1290     private static ReferenceQueue&lt;P11Key&gt; refQueue =
1291         new ReferenceQueue&lt;P11Key&gt;();
<span class="line-modified">1292     private static Set&lt;SessionKeyRef&gt; refList =</span>
<span class="line-modified">1293         Collections.synchronizedSortedSet(new TreeSet&lt;SessionKeyRef&gt;());</span>
1294 
1295     static ReferenceQueue&lt;P11Key&gt; referenceQueue() {
1296         return refQueue;
1297     }
1298 
1299     private static void drainRefQueueBounded() {
1300         while (true) {
1301             SessionKeyRef next = (SessionKeyRef) refQueue.poll();
1302             if (next == null) {
1303                 break;
1304             }
1305             next.dispose();
1306         }
1307     }
1308 
1309     // handle to the native key and the session it is generated under
<span class="line-modified">1310     private final long keyID;</span>
<span class="line-modified">1311     private final Session session;</span>

1312 
<span class="line-modified">1313     SessionKeyRef(P11Key p11Key, long keyID, Session session) {</span>

1314         super(p11Key, refQueue);
1315         if (session == null) {
1316             throw new ProviderException(&quot;key must be associated with a session&quot;);
1317         }
<span class="line-modified">1318         this.keyID = keyID;</span>
<span class="line-modified">1319         this.session = session;</span>
<span class="line-removed">1320         this.session.addObject();</span>
1321 
<span class="line-modified">1322         refList.add(this);</span>
1323         drainRefQueueBounded();
1324     }
1325 
<span class="line-modified">1326     SessionKeyRef dispose() {</span>
<span class="line-modified">1327         Token token = session.token;</span>
<span class="line-modified">1328         // If the token is still valid, try to remove the key object</span>
<span class="line-modified">1329         if (token.isValid()) {</span>
<span class="line-modified">1330             Session s = null;</span>
<span class="line-modified">1331             try {</span>
<span class="line-modified">1332                 s = token.getOpSession();</span>
<span class="line-modified">1333                 token.p11.C_DestroyObject(s.id(), keyID);</span>
<span class="line-modified">1334             } catch (PKCS11Exception e) {</span>
<span class="line-modified">1335                 // best effort</span>
<span class="line-modified">1336             } finally {</span>
<span class="line-modified">1337                 token.releaseSession(s);</span>














1338             }



1339         }
<span class="line-modified">1340         refList.remove(this);</span>
<span class="line-modified">1341         this.clear();</span>
<span class="line-removed">1342         session.removeObject();</span>
<span class="line-removed">1343         return null;</span>
1344     }
1345 
<span class="line-modified">1346     public int compareTo(SessionKeyRef other) {</span>
<span class="line-modified">1347         if (this.keyID == other.keyID) {</span>
<span class="line-modified">1348             return 0;</span>
<span class="line-modified">1349         } else {</span>
<span class="line-modified">1350             return (this.keyID &lt; other.keyID) ? -1 : 1;</span>




1351         }


1352     }
1353 }
</pre>
</td>
<td>
<hr />
<pre>
1120             return w;
1121         }
1122         public ECParameterSpec getParams() {
1123             fetchValues();
1124             return params;
1125         }
1126         public String toString() {
1127             fetchValues();
1128             return super.toString()
1129                 + &quot;\n  public x coord: &quot; + w.getAffineX()
1130                 + &quot;\n  public y coord: &quot; + w.getAffineY()
1131                 + &quot;\n  parameters: &quot; + params;
1132         }
1133     }
1134 }
1135 
1136 final class NativeKeyHolder {
1137 
1138     private static long nativeKeyWrapperKeyID = 0;
1139     private static CK_MECHANISM nativeKeyWrapperMechanism = null;
<span class="line-added">1140     private static long nativeKeyWrapperRefCount = 0;</span>
<span class="line-added">1141     private static Session nativeKeyWrapperSession = null;</span>
1142 
1143     private final P11Key p11Key;
1144     private final byte[] nativeKeyInfo;
<span class="line-added">1145     private boolean wrapperKeyUsed;</span>
1146 
1147     // destroyed and recreated when refCount toggles to 1
1148     private long keyID;
1149 


1150     // phantom reference notification clean up for session keys
1151     private SessionKeyRef ref;
1152 
1153     private int refCount;
1154 
<span class="line-added">1155     private static void createNativeKeyWrapper(Token token)</span>
<span class="line-added">1156             throws PKCS11Exception {</span>
<span class="line-added">1157         assert(nativeKeyWrapperKeyID == 0);</span>
<span class="line-added">1158         assert(nativeKeyWrapperRefCount == 0);</span>
<span class="line-added">1159         assert(nativeKeyWrapperSession == null);</span>
<span class="line-added">1160         // Create a global wrapping/unwrapping key</span>
<span class="line-added">1161         CK_ATTRIBUTE[] wrappingAttributes = token.getAttributes(O_GENERATE,</span>
<span class="line-added">1162                         CKO_SECRET_KEY, CKK_AES, new CK_ATTRIBUTE[] {</span>
<span class="line-added">1163                                 new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),</span>
<span class="line-added">1164                                 new CK_ATTRIBUTE(CKA_VALUE_LEN, 256 &gt;&gt; 3)});</span>
<span class="line-added">1165         Session s = null;</span>
<span class="line-added">1166         try {</span>
<span class="line-added">1167             s = token.getObjSession();</span>
<span class="line-added">1168             nativeKeyWrapperKeyID = token.p11.C_GenerateKey(</span>
<span class="line-added">1169                     s.id(), new CK_MECHANISM(CKM_AES_KEY_GEN),</span>
<span class="line-added">1170                     wrappingAttributes);</span>
<span class="line-added">1171             nativeKeyWrapperSession = s;</span>
<span class="line-added">1172             nativeKeyWrapperSession.addObject();</span>
<span class="line-added">1173             byte[] iv = new byte[16];</span>
<span class="line-added">1174             JCAUtil.getSecureRandom().nextBytes(iv);</span>
<span class="line-added">1175             nativeKeyWrapperMechanism = new CK_MECHANISM(CKM_AES_CBC_PAD, iv);</span>
<span class="line-added">1176         } catch (PKCS11Exception e) {</span>
<span class="line-added">1177             // best effort</span>
<span class="line-added">1178         } finally {</span>
<span class="line-added">1179             token.releaseSession(s);</span>
<span class="line-added">1180         }</span>
<span class="line-added">1181     }</span>
<span class="line-added">1182 </span>
<span class="line-added">1183     private static void deleteNativeKeyWrapper() {</span>
<span class="line-added">1184         Token token = nativeKeyWrapperSession.token;</span>
<span class="line-added">1185         if (token.isValid()) {</span>
<span class="line-added">1186             Session s = null;</span>
<span class="line-added">1187             try {</span>
<span class="line-added">1188                 s = token.getOpSession();</span>
<span class="line-added">1189                 token.p11.C_DestroyObject(s.id(), nativeKeyWrapperKeyID);</span>
<span class="line-added">1190                 nativeKeyWrapperSession.removeObject();</span>
<span class="line-added">1191             } catch (PKCS11Exception e) {</span>
<span class="line-added">1192                 // best effort</span>
<span class="line-added">1193             } finally {</span>
<span class="line-added">1194                 token.releaseSession(s);</span>
<span class="line-added">1195             }</span>
<span class="line-added">1196         }</span>
<span class="line-added">1197         nativeKeyWrapperKeyID = 0;</span>
<span class="line-added">1198         nativeKeyWrapperMechanism = null;</span>
<span class="line-added">1199         nativeKeyWrapperSession = null;</span>
<span class="line-added">1200     }</span>
<span class="line-added">1201 </span>
<span class="line-added">1202     static void decWrapperKeyRef() {</span>
<span class="line-added">1203         synchronized(NativeKeyHolder.class) {</span>
<span class="line-added">1204             assert(nativeKeyWrapperKeyID != 0);</span>
<span class="line-added">1205             assert(nativeKeyWrapperRefCount &gt; 0);</span>
<span class="line-added">1206             nativeKeyWrapperRefCount--;</span>
<span class="line-added">1207             if (nativeKeyWrapperRefCount == 0) {</span>
<span class="line-added">1208                 deleteNativeKeyWrapper();</span>
<span class="line-added">1209             }</span>
<span class="line-added">1210         }</span>
<span class="line-added">1211     }</span>
<span class="line-added">1212 </span>
1213     NativeKeyHolder(P11Key p11Key, long keyID, Session keySession,
1214             boolean extractKeyInfo, boolean isTokenObject) {
1215         this.p11Key = p11Key;
1216         this.keyID = keyID;
1217         this.refCount = -1;
1218         byte[] ki = null;
1219         if (isTokenObject) {
1220             this.ref = null;
1221         } else {


1222             // Try extracting key info, if any error, disable it
1223             Token token = p11Key.token;
1224             if (extractKeyInfo) {
1225                 try {
<span class="line-modified">1226                     if (p11Key.sensitive) {</span>
<span class="line-added">1227                         // p11Key native key information has to be wrapped</span>
1228                         synchronized(NativeKeyHolder.class) {
<span class="line-modified">1229                             if (nativeKeyWrapperKeyID == 0) {</span>
<span class="line-modified">1230                                 createNativeKeyWrapper(token);</span>
<span class="line-modified">1231                             }</span>
<span class="line-modified">1232                             // If a wrapper-key was successfully created or</span>
<span class="line-modified">1233                             // already exists, increment its reference</span>
<span class="line-modified">1234                             // counter to keep it alive while native key</span>
<span class="line-modified">1235                             // information is being held.</span>
<span class="line-modified">1236                             if (nativeKeyWrapperKeyID != 0) {</span>
<span class="line-modified">1237                                 nativeKeyWrapperRefCount++;</span>
<span class="line-modified">1238                                 wrapperKeyUsed = true;</span>











1239                             }
1240                         }
1241                     }
1242                     Session opSession = null;
1243                     try {
1244                         opSession = token.getOpSession();
1245                         ki = p11Key.token.p11.getNativeKeyInfo(opSession.id(),
<span class="line-modified">1246                                 keyID, nativeKeyWrapperKeyID,</span>
<span class="line-added">1247                                 nativeKeyWrapperMechanism);</span>
1248                     } catch (PKCS11Exception e) {
1249                         // best effort
1250                     } finally {
1251                         token.releaseSession(opSession);
1252                     }
1253                 } catch (PKCS11Exception e) {
1254                     // best effort
1255                 }
1256             }
<span class="line-added">1257             this.ref = new SessionKeyRef(p11Key, keyID, wrapperKeyUsed,</span>
<span class="line-added">1258                     keySession);</span>
1259         }
1260         this.nativeKeyInfo = ((ki == null || ki.length == 0)? null : ki);
1261     }
1262 
1263     long getKeyID() throws ProviderException {
1264         if (this.nativeKeyInfo != null) {
1265             synchronized(this.nativeKeyInfo) {
1266                 if (this.refCount == -1) {
1267                     this.refCount = 0;
1268                 }
1269                 int cnt = (this.refCount)++;
1270                 if (keyID == 0) {
1271                     if (cnt != 0) {
1272                         throw new RuntimeException(
1273                                 &quot;Error: null keyID with non-zero refCount &quot; + cnt);
1274                     }




1275                     Token token = p11Key.token;
1276                     // Create keyID using nativeKeyInfo
1277                     Session session = null;
1278                     try {
1279                         session = token.getObjSession();
1280                         this.keyID = token.p11.createNativeKey(session.id(),
<span class="line-modified">1281                                 nativeKeyInfo, nativeKeyWrapperKeyID,</span>
<span class="line-modified">1282                                 nativeKeyWrapperMechanism);</span>
<span class="line-added">1283                         this.ref.registerNativeKey(this.keyID, session);</span>
1284                     } catch (PKCS11Exception e) {
1285                         this.refCount--;
1286                         throw new ProviderException(&quot;Error recreating native key&quot;, e);
1287                     } finally {
1288                         token.releaseSession(session);
1289                     }
1290                 } else {
1291                     if (cnt &lt; 0) {
1292                         throw new RuntimeException(&quot;ERROR: negative refCount&quot;);
1293                     }
1294                 }
1295             }
1296         }
1297         return keyID;
1298     }
1299 
1300     void releaseKeyID() {
1301         if (this.nativeKeyInfo != null) {
1302             synchronized(this.nativeKeyInfo) {
1303                 if (this.refCount == -1) {
1304                     throw new RuntimeException(&quot;Error: miss match getKeyID call&quot;);
1305                 }
1306                 int cnt = --(this.refCount);
1307                 if (cnt == 0) {
1308                     // destroy
1309                     if (this.keyID == 0) {
1310                         throw new RuntimeException(&quot;ERROR: null keyID can&#39;t be destroyed&quot;);
1311                     }
1312 



1313                     // destroy
1314                     this.keyID = 0;
<span class="line-modified">1315                     this.ref.removeNativeKey();</span>
1316                 } else {
1317                     if (cnt &lt; 0) {
1318                         // should never happen as we start count at 1 and pair get/release calls
1319                         throw new RuntimeException(&quot;wrong refCount value: &quot; + cnt);
1320                     }
1321                 }
1322             }
1323         }
1324     }
1325 }
1326 
1327 /*
1328  * NOTE: Must use PhantomReference here and not WeakReference
1329  * otherwise the key maybe cleared before other objects which
1330  * still use these keys during finalization such as SSLSocket.
1331  */
<span class="line-modified">1332 final class SessionKeyRef extends PhantomReference&lt;P11Key&gt; {</span>

1333     private static ReferenceQueue&lt;P11Key&gt; refQueue =
1334         new ReferenceQueue&lt;P11Key&gt;();
<span class="line-modified">1335     private static Set&lt;SessionKeyRef&gt; refSet =</span>
<span class="line-modified">1336         Collections.synchronizedSet(new HashSet&lt;SessionKeyRef&gt;());</span>
1337 
1338     static ReferenceQueue&lt;P11Key&gt; referenceQueue() {
1339         return refQueue;
1340     }
1341 
1342     private static void drainRefQueueBounded() {
1343         while (true) {
1344             SessionKeyRef next = (SessionKeyRef) refQueue.poll();
1345             if (next == null) {
1346                 break;
1347             }
1348             next.dispose();
1349         }
1350     }
1351 
1352     // handle to the native key and the session it is generated under
<span class="line-modified">1353     private long keyID;</span>
<span class="line-modified">1354     private Session session;</span>
<span class="line-added">1355     private boolean wrapperKeyUsed;</span>
1356 
<span class="line-modified">1357     SessionKeyRef(P11Key p11Key, long keyID, boolean wrapperKeyUsed,</span>
<span class="line-added">1358             Session session) {</span>
1359         super(p11Key, refQueue);
1360         if (session == null) {
1361             throw new ProviderException(&quot;key must be associated with a session&quot;);
1362         }
<span class="line-modified">1363         registerNativeKey(keyID, session);</span>
<span class="line-modified">1364         this.wrapperKeyUsed = wrapperKeyUsed;</span>

1365 
<span class="line-modified">1366         refSet.add(this);</span>
1367         drainRefQueueBounded();
1368     }
1369 
<span class="line-modified">1370     void registerNativeKey(long newKeyID, Session newSession) {</span>
<span class="line-modified">1371         assert(newKeyID != 0);</span>
<span class="line-modified">1372         assert(newSession != null);</span>
<span class="line-modified">1373         updateNativeKey(newKeyID, newSession);</span>
<span class="line-modified">1374     }</span>
<span class="line-modified">1375 </span>
<span class="line-modified">1376     void removeNativeKey() {</span>
<span class="line-modified">1377         assert(session != null);</span>
<span class="line-modified">1378         updateNativeKey(0, null);</span>
<span class="line-modified">1379     }</span>
<span class="line-modified">1380 </span>
<span class="line-modified">1381     private void updateNativeKey(long newKeyID, Session newSession) {</span>
<span class="line-added">1382         if (newKeyID == 0) {</span>
<span class="line-added">1383             assert(newSession == null);</span>
<span class="line-added">1384             Token token = session.token;</span>
<span class="line-added">1385             // If the token is still valid, try to remove the key object</span>
<span class="line-added">1386             if (token.isValid()) {</span>
<span class="line-added">1387                 Session s = null;</span>
<span class="line-added">1388                 try {</span>
<span class="line-added">1389                     s = token.getOpSession();</span>
<span class="line-added">1390                     token.p11.C_DestroyObject(s.id(), this.keyID);</span>
<span class="line-added">1391                 } catch (PKCS11Exception e) {</span>
<span class="line-added">1392                     // best effort</span>
<span class="line-added">1393                 } finally {</span>
<span class="line-added">1394                     token.releaseSession(s);</span>
<span class="line-added">1395                 }</span>
1396             }
<span class="line-added">1397             session.removeObject();</span>
<span class="line-added">1398         } else {</span>
<span class="line-added">1399             newSession.addObject();</span>
1400         }
<span class="line-modified">1401         keyID = newKeyID;</span>
<span class="line-modified">1402         session = newSession;</span>


1403     }
1404 
<span class="line-modified">1405     // Called when the GC disposes a p11Key</span>
<span class="line-modified">1406     void dispose() {</span>
<span class="line-modified">1407         if (wrapperKeyUsed) {</span>
<span class="line-modified">1408             // Wrapper-key no longer needed for</span>
<span class="line-modified">1409             // p11Key native key information</span>
<span class="line-added">1410             NativeKeyHolder.decWrapperKeyRef();</span>
<span class="line-added">1411         }</span>
<span class="line-added">1412         if (keyID != 0) {</span>
<span class="line-added">1413             removeNativeKey();</span>
1414         }
<span class="line-added">1415         refSet.remove(this);</span>
<span class="line-added">1416         this.clear();</span>
1417     }
1418 }
</pre>
</td>
</tr>
</table>
<center><a href="P11Digest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="P11KeyStore.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
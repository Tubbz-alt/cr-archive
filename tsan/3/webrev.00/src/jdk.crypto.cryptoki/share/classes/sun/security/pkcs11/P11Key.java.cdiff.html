<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/P11Key.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="P11Digest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="P11KeyStore.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/P11Key.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1135,79 ***</span>
  
  final class NativeKeyHolder {
  
      private static long nativeKeyWrapperKeyID = 0;
      private static CK_MECHANISM nativeKeyWrapperMechanism = null;
  
      private final P11Key p11Key;
      private final byte[] nativeKeyInfo;
  
      // destroyed and recreated when refCount toggles to 1
      private long keyID;
  
<span class="line-removed">-     private boolean isTokenObject;</span>
<span class="line-removed">- </span>
      // phantom reference notification clean up for session keys
      private SessionKeyRef ref;
  
      private int refCount;
  
      NativeKeyHolder(P11Key p11Key, long keyID, Session keySession,
              boolean extractKeyInfo, boolean isTokenObject) {
          this.p11Key = p11Key;
          this.keyID = keyID;
          this.refCount = -1;
          byte[] ki = null;
          if (isTokenObject) {
              this.ref = null;
          } else {
<span class="line-removed">-             this.ref = new SessionKeyRef(p11Key, keyID, keySession);</span>
<span class="line-removed">- </span>
              // Try extracting key info, if any error, disable it
              Token token = p11Key.token;
              if (extractKeyInfo) {
                  try {
<span class="line-modified">!                     if (p11Key.sensitive &amp;&amp; nativeKeyWrapperKeyID == 0) {</span>
                          synchronized(NativeKeyHolder.class) {
<span class="line-modified">!                             // Create a global wrapping/unwrapping key</span>
<span class="line-modified">!                             CK_ATTRIBUTE[] wrappingAttributes = token.getAttributes</span>
<span class="line-modified">!                                 (O_GENERATE, CKO_SECRET_KEY, CKK_AES, new CK_ATTRIBUTE[] {</span>
<span class="line-modified">!                                     new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),</span>
<span class="line-modified">!                                     new CK_ATTRIBUTE(CKA_VALUE_LEN, 256 &gt;&gt; 3),</span>
<span class="line-modified">!                                 });</span>
<span class="line-modified">!                             Session wrappingSession = null;</span>
<span class="line-modified">!                             try {</span>
<span class="line-modified">!                                 wrappingSession = token.getObjSession();</span>
<span class="line-modified">!                                 nativeKeyWrapperKeyID = token.p11.C_GenerateKey</span>
<span class="line-removed">-                                     (wrappingSession.id(),</span>
<span class="line-removed">-                                     new CK_MECHANISM(CKM_AES_KEY_GEN),</span>
<span class="line-removed">-                                     wrappingAttributes);</span>
<span class="line-removed">-                                 byte[] iv = new byte[16];</span>
<span class="line-removed">-                                 JCAUtil.getSecureRandom().nextBytes(iv);</span>
<span class="line-removed">-                                 nativeKeyWrapperMechanism = new CK_MECHANISM</span>
<span class="line-removed">-                                     (CKM_AES_CBC_PAD, iv);</span>
<span class="line-removed">-                             } catch (PKCS11Exception e) {</span>
<span class="line-removed">-                                 // best effort</span>
<span class="line-removed">-                             } finally {</span>
<span class="line-removed">-                                 token.releaseSession(wrappingSession);</span>
                              }
                          }
                      }
                      Session opSession = null;
                      try {
                          opSession = token.getOpSession();
                          ki = p11Key.token.p11.getNativeKeyInfo(opSession.id(),
<span class="line-modified">!                             keyID, nativeKeyWrapperKeyID, nativeKeyWrapperMechanism);</span>
                      } catch (PKCS11Exception e) {
                          // best effort
                      } finally {
                          token.releaseSession(opSession);
                      }
                  } catch (PKCS11Exception e) {
                      // best effort
                  }
              }
          }
          this.nativeKeyInfo = ((ki == null || ki.length == 0)? null : ki);
      }
  
      long getKeyID() throws ProviderException {
<span class="line-new-header">--- 1135,129 ---</span>
  
  final class NativeKeyHolder {
  
      private static long nativeKeyWrapperKeyID = 0;
      private static CK_MECHANISM nativeKeyWrapperMechanism = null;
<span class="line-added">+     private static long nativeKeyWrapperRefCount = 0;</span>
<span class="line-added">+     private static Session nativeKeyWrapperSession = null;</span>
  
      private final P11Key p11Key;
      private final byte[] nativeKeyInfo;
<span class="line-added">+     private boolean wrapperKeyUsed;</span>
  
      // destroyed and recreated when refCount toggles to 1
      private long keyID;
  
      // phantom reference notification clean up for session keys
      private SessionKeyRef ref;
  
      private int refCount;
  
<span class="line-added">+     private static void createNativeKeyWrapper(Token token)</span>
<span class="line-added">+             throws PKCS11Exception {</span>
<span class="line-added">+         assert(nativeKeyWrapperKeyID == 0);</span>
<span class="line-added">+         assert(nativeKeyWrapperRefCount == 0);</span>
<span class="line-added">+         assert(nativeKeyWrapperSession == null);</span>
<span class="line-added">+         // Create a global wrapping/unwrapping key</span>
<span class="line-added">+         CK_ATTRIBUTE[] wrappingAttributes = token.getAttributes(O_GENERATE,</span>
<span class="line-added">+                         CKO_SECRET_KEY, CKK_AES, new CK_ATTRIBUTE[] {</span>
<span class="line-added">+                                 new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),</span>
<span class="line-added">+                                 new CK_ATTRIBUTE(CKA_VALUE_LEN, 256 &gt;&gt; 3)});</span>
<span class="line-added">+         Session s = null;</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             s = token.getObjSession();</span>
<span class="line-added">+             nativeKeyWrapperKeyID = token.p11.C_GenerateKey(</span>
<span class="line-added">+                     s.id(), new CK_MECHANISM(CKM_AES_KEY_GEN),</span>
<span class="line-added">+                     wrappingAttributes);</span>
<span class="line-added">+             nativeKeyWrapperSession = s;</span>
<span class="line-added">+             nativeKeyWrapperSession.addObject();</span>
<span class="line-added">+             byte[] iv = new byte[16];</span>
<span class="line-added">+             JCAUtil.getSecureRandom().nextBytes(iv);</span>
<span class="line-added">+             nativeKeyWrapperMechanism = new CK_MECHANISM(CKM_AES_CBC_PAD, iv);</span>
<span class="line-added">+         } catch (PKCS11Exception e) {</span>
<span class="line-added">+             // best effort</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             token.releaseSession(s);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static void deleteNativeKeyWrapper() {</span>
<span class="line-added">+         Token token = nativeKeyWrapperSession.token;</span>
<span class="line-added">+         if (token.isValid()) {</span>
<span class="line-added">+             Session s = null;</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 s = token.getOpSession();</span>
<span class="line-added">+                 token.p11.C_DestroyObject(s.id(), nativeKeyWrapperKeyID);</span>
<span class="line-added">+                 nativeKeyWrapperSession.removeObject();</span>
<span class="line-added">+             } catch (PKCS11Exception e) {</span>
<span class="line-added">+                 // best effort</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 token.releaseSession(s);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         nativeKeyWrapperKeyID = 0;</span>
<span class="line-added">+         nativeKeyWrapperMechanism = null;</span>
<span class="line-added">+         nativeKeyWrapperSession = null;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     static void decWrapperKeyRef() {</span>
<span class="line-added">+         synchronized(NativeKeyHolder.class) {</span>
<span class="line-added">+             assert(nativeKeyWrapperKeyID != 0);</span>
<span class="line-added">+             assert(nativeKeyWrapperRefCount &gt; 0);</span>
<span class="line-added">+             nativeKeyWrapperRefCount--;</span>
<span class="line-added">+             if (nativeKeyWrapperRefCount == 0) {</span>
<span class="line-added">+                 deleteNativeKeyWrapper();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      NativeKeyHolder(P11Key p11Key, long keyID, Session keySession,
              boolean extractKeyInfo, boolean isTokenObject) {
          this.p11Key = p11Key;
          this.keyID = keyID;
          this.refCount = -1;
          byte[] ki = null;
          if (isTokenObject) {
              this.ref = null;
          } else {
              // Try extracting key info, if any error, disable it
              Token token = p11Key.token;
              if (extractKeyInfo) {
                  try {
<span class="line-modified">!                     if (p11Key.sensitive) {</span>
<span class="line-added">+                         // p11Key native key information has to be wrapped</span>
                          synchronized(NativeKeyHolder.class) {
<span class="line-modified">!                             if (nativeKeyWrapperKeyID == 0) {</span>
<span class="line-modified">!                                 createNativeKeyWrapper(token);</span>
<span class="line-modified">!                             }</span>
<span class="line-modified">!                             // If a wrapper-key was successfully created or</span>
<span class="line-modified">!                             // already exists, increment its reference</span>
<span class="line-modified">!                             // counter to keep it alive while native key</span>
<span class="line-modified">!                             // information is being held.</span>
<span class="line-modified">!                             if (nativeKeyWrapperKeyID != 0) {</span>
<span class="line-modified">!                                 nativeKeyWrapperRefCount++;</span>
<span class="line-modified">!                                 wrapperKeyUsed = true;</span>
                              }
                          }
                      }
                      Session opSession = null;
                      try {
                          opSession = token.getOpSession();
                          ki = p11Key.token.p11.getNativeKeyInfo(opSession.id(),
<span class="line-modified">!                                 keyID, nativeKeyWrapperKeyID,</span>
<span class="line-added">+                                 nativeKeyWrapperMechanism);</span>
                      } catch (PKCS11Exception e) {
                          // best effort
                      } finally {
                          token.releaseSession(opSession);
                      }
                  } catch (PKCS11Exception e) {
                      // best effort
                  }
              }
<span class="line-added">+             this.ref = new SessionKeyRef(p11Key, keyID, wrapperKeyUsed,</span>
<span class="line-added">+                     keySession);</span>
          }
          this.nativeKeyInfo = ((ki == null || ki.length == 0)? null : ki);
      }
  
      long getKeyID() throws ProviderException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1220,22 ***</span>
                  if (keyID == 0) {
                      if (cnt != 0) {
                          throw new RuntimeException(
                                  &quot;Error: null keyID with non-zero refCount &quot; + cnt);
                      }
<span class="line-removed">-                     if (this.ref != null)  {</span>
<span class="line-removed">-                         throw new RuntimeException(</span>
<span class="line-removed">-                                 &quot;Error: null keyID with non-null session ref&quot;);</span>
<span class="line-removed">-                     }</span>
                      Token token = p11Key.token;
                      // Create keyID using nativeKeyInfo
                      Session session = null;
                      try {
                          session = token.getObjSession();
                          this.keyID = token.p11.createNativeKey(session.id(),
<span class="line-modified">!                                 nativeKeyInfo, nativeKeyWrapperKeyID, nativeKeyWrapperMechanism);</span>
<span class="line-modified">!                         this.ref = new SessionKeyRef(p11Key, this.keyID, session);</span>
                      } catch (PKCS11Exception e) {
                          this.refCount--;
                          throw new ProviderException(&quot;Error recreating native key&quot;, e);
                      } finally {
                          token.releaseSession(session);
<span class="line-new-header">--- 1270,19 ---</span>
                  if (keyID == 0) {
                      if (cnt != 0) {
                          throw new RuntimeException(
                                  &quot;Error: null keyID with non-zero refCount &quot; + cnt);
                      }
                      Token token = p11Key.token;
                      // Create keyID using nativeKeyInfo
                      Session session = null;
                      try {
                          session = token.getObjSession();
                          this.keyID = token.p11.createNativeKey(session.id(),
<span class="line-modified">!                                 nativeKeyInfo, nativeKeyWrapperKeyID,</span>
<span class="line-modified">!                                 nativeKeyWrapperMechanism);</span>
<span class="line-added">+                         this.ref.registerNativeKey(this.keyID, session);</span>
                      } catch (PKCS11Exception e) {
                          this.refCount--;
                          throw new ProviderException(&quot;Error recreating native key&quot;, e);
                      } finally {
                          token.releaseSession(session);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1261,16 ***</span>
                      // destroy
                      if (this.keyID == 0) {
                          throw new RuntimeException(&quot;ERROR: null keyID can&#39;t be destroyed&quot;);
                      }
  
<span class="line-removed">-                     if (this.ref == null) {</span>
<span class="line-removed">-                         throw new RuntimeException(&quot;ERROR: null session ref can&#39;t be disposed&quot;);</span>
<span class="line-removed">-                     }</span>
                      // destroy
                      this.keyID = 0;
<span class="line-modified">!                     this.ref = this.ref.dispose();</span>
                  } else {
                      if (cnt &lt; 0) {
                          // should never happen as we start count at 1 and pair get/release calls
                          throw new RuntimeException(&quot;wrong refCount value: &quot; + cnt);
                      }
<span class="line-new-header">--- 1308,13 ---</span>
                      // destroy
                      if (this.keyID == 0) {
                          throw new RuntimeException(&quot;ERROR: null keyID can&#39;t be destroyed&quot;);
                      }
  
                      // destroy
                      this.keyID = 0;
<span class="line-modified">!                     this.ref.removeNativeKey();</span>
                  } else {
                      if (cnt &lt; 0) {
                          // should never happen as we start count at 1 and pair get/release calls
                          throw new RuntimeException(&quot;wrong refCount value: &quot; + cnt);
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1283,16 ***</span>
  /*
   * NOTE: Must use PhantomReference here and not WeakReference
   * otherwise the key maybe cleared before other objects which
   * still use these keys during finalization such as SSLSocket.
   */
<span class="line-modified">! final class SessionKeyRef extends PhantomReference&lt;P11Key&gt;</span>
<span class="line-removed">-     implements Comparable&lt;SessionKeyRef&gt; {</span>
      private static ReferenceQueue&lt;P11Key&gt; refQueue =
          new ReferenceQueue&lt;P11Key&gt;();
<span class="line-modified">!     private static Set&lt;SessionKeyRef&gt; refList =</span>
<span class="line-modified">!         Collections.synchronizedSortedSet(new TreeSet&lt;SessionKeyRef&gt;());</span>
  
      static ReferenceQueue&lt;P11Key&gt; referenceQueue() {
          return refQueue;
      }
  
<span class="line-new-header">--- 1327,15 ---</span>
  /*
   * NOTE: Must use PhantomReference here and not WeakReference
   * otherwise the key maybe cleared before other objects which
   * still use these keys during finalization such as SSLSocket.
   */
<span class="line-modified">! final class SessionKeyRef extends PhantomReference&lt;P11Key&gt; {</span>
      private static ReferenceQueue&lt;P11Key&gt; refQueue =
          new ReferenceQueue&lt;P11Key&gt;();
<span class="line-modified">!     private static Set&lt;SessionKeyRef&gt; refSet =</span>
<span class="line-modified">!         Collections.synchronizedSet(new HashSet&lt;SessionKeyRef&gt;());</span>
  
      static ReferenceQueue&lt;P11Key&gt; referenceQueue() {
          return refQueue;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1305,49 ***</span>
              next.dispose();
          }
      }
  
      // handle to the native key and the session it is generated under
<span class="line-modified">!     private final long keyID;</span>
<span class="line-modified">!     private final Session session;</span>
  
<span class="line-modified">!     SessionKeyRef(P11Key p11Key, long keyID, Session session) {</span>
          super(p11Key, refQueue);
          if (session == null) {
              throw new ProviderException(&quot;key must be associated with a session&quot;);
          }
<span class="line-modified">!         this.keyID = keyID;</span>
<span class="line-modified">!         this.session = session;</span>
<span class="line-removed">-         this.session.addObject();</span>
  
<span class="line-modified">!         refList.add(this);</span>
          drainRefQueueBounded();
      }
  
<span class="line-modified">!     SessionKeyRef dispose() {</span>
<span class="line-modified">!         Token token = session.token;</span>
<span class="line-modified">!         // If the token is still valid, try to remove the key object</span>
<span class="line-modified">!         if (token.isValid()) {</span>
<span class="line-modified">!             Session s = null;</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 s = token.getOpSession();</span>
<span class="line-modified">!                 token.p11.C_DestroyObject(s.id(), keyID);</span>
<span class="line-modified">!             } catch (PKCS11Exception e) {</span>
<span class="line-modified">!                 // best effort</span>
<span class="line-modified">!             } finally {</span>
<span class="line-modified">!                 token.releaseSession(s);</span>
              }
          }
<span class="line-modified">!         refList.remove(this);</span>
<span class="line-modified">!         this.clear();</span>
<span class="line-removed">-         session.removeObject();</span>
<span class="line-removed">-         return null;</span>
      }
  
<span class="line-modified">!     public int compareTo(SessionKeyRef other) {</span>
<span class="line-modified">!         if (this.keyID == other.keyID) {</span>
<span class="line-modified">!             return 0;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             return (this.keyID &lt; other.keyID) ? -1 : 1;</span>
          }
      }
  }
<span class="line-new-header">--- 1348,71 ---</span>
              next.dispose();
          }
      }
  
      // handle to the native key and the session it is generated under
<span class="line-modified">!     private long keyID;</span>
<span class="line-modified">!     private Session session;</span>
<span class="line-added">+     private boolean wrapperKeyUsed;</span>
  
<span class="line-modified">!     SessionKeyRef(P11Key p11Key, long keyID, boolean wrapperKeyUsed,</span>
<span class="line-added">+             Session session) {</span>
          super(p11Key, refQueue);
          if (session == null) {
              throw new ProviderException(&quot;key must be associated with a session&quot;);
          }
<span class="line-modified">!         registerNativeKey(keyID, session);</span>
<span class="line-modified">!         this.wrapperKeyUsed = wrapperKeyUsed;</span>
  
<span class="line-modified">!         refSet.add(this);</span>
          drainRefQueueBounded();
      }
  
<span class="line-modified">!     void registerNativeKey(long newKeyID, Session newSession) {</span>
<span class="line-modified">!         assert(newKeyID != 0);</span>
<span class="line-modified">!         assert(newSession != null);</span>
<span class="line-modified">!         updateNativeKey(newKeyID, newSession);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     void removeNativeKey() {</span>
<span class="line-modified">!         assert(session != null);</span>
<span class="line-modified">!         updateNativeKey(0, null);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private void updateNativeKey(long newKeyID, Session newSession) {</span>
<span class="line-added">+         if (newKeyID == 0) {</span>
<span class="line-added">+             assert(newSession == null);</span>
<span class="line-added">+             Token token = session.token;</span>
<span class="line-added">+             // If the token is still valid, try to remove the key object</span>
<span class="line-added">+             if (token.isValid()) {</span>
<span class="line-added">+                 Session s = null;</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     s = token.getOpSession();</span>
<span class="line-added">+                     token.p11.C_DestroyObject(s.id(), this.keyID);</span>
<span class="line-added">+                 } catch (PKCS11Exception e) {</span>
<span class="line-added">+                     // best effort</span>
<span class="line-added">+                 } finally {</span>
<span class="line-added">+                     token.releaseSession(s);</span>
<span class="line-added">+                 }</span>
              }
<span class="line-added">+             session.removeObject();</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             newSession.addObject();</span>
          }
<span class="line-modified">!         keyID = newKeyID;</span>
<span class="line-modified">!         session = newSession;</span>
      }
  
<span class="line-modified">!     // Called when the GC disposes a p11Key</span>
<span class="line-modified">!     void dispose() {</span>
<span class="line-modified">!         if (wrapperKeyUsed) {</span>
<span class="line-modified">!             // Wrapper-key no longer needed for</span>
<span class="line-modified">!             // p11Key native key information</span>
<span class="line-added">+             NativeKeyHolder.decWrapperKeyRef();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (keyID != 0) {</span>
<span class="line-added">+             removeNativeKey();</span>
          }
<span class="line-added">+         refSet.remove(this);</span>
<span class="line-added">+         this.clear();</span>
      }
  }
</pre>
<center><a href="P11Digest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="P11KeyStore.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
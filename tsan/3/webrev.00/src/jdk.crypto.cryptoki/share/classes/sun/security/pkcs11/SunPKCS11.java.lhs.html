<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/SunPKCS11.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.pkcs11;
  27 
  28 import java.io.*;
  29 import java.util.*;
  30 
  31 import java.security.*;
  32 import java.security.interfaces.*;
  33 
  34 import javax.crypto.interfaces.*;
  35 
  36 import javax.security.auth.Subject;
  37 import javax.security.auth.login.LoginException;
  38 import javax.security.auth.login.FailedLoginException;
  39 import javax.security.auth.callback.Callback;
  40 import javax.security.auth.callback.CallbackHandler;
  41 import javax.security.auth.callback.ConfirmationCallback;
  42 import javax.security.auth.callback.PasswordCallback;
  43 import javax.security.auth.callback.TextOutputCallback;
  44 
  45 import sun.security.util.Debug;
  46 import sun.security.util.ResourcesMgr;
  47 import static sun.security.util.SecurityConstants.PROVIDER_VER;
  48 
  49 import sun.security.pkcs11.Secmod.*;
  50 
  51 import sun.security.pkcs11.wrapper.*;
  52 import static sun.security.pkcs11.wrapper.PKCS11Constants.*;
  53 
  54 /**
  55  * PKCS#11 provider main class.
  56  *
  57  * @author  Andreas Sterbenz
  58  * @since   1.5
  59  */
  60 public final class SunPKCS11 extends AuthProvider {
  61 
  62     private static final long serialVersionUID = -1354835039035306505L;
  63 
  64     static final Debug debug = Debug.getInstance(&quot;sunpkcs11&quot;);
<a name="2" id="anc2"></a><span class="line-removed">  65 </span>
  66     // the PKCS11 object through which we make the native calls
  67     final PKCS11 p11;
  68 
  69     // configuration information
  70     final Config config;
  71 
  72     // id of the PKCS#11 slot we are using
  73     final long slotID;
  74 
  75     private CallbackHandler pHandler;
  76     private final Object LOCK_HANDLER = new Object();
  77 
  78     final boolean removable;
  79 
  80     final Secmod.Module nssModule;
  81 
  82     final boolean nssUseSecmodTrust;
  83 
  84     private volatile Token token;
  85 
  86     private TokenPoller poller;
  87 
  88     Token getToken() {
  89         return token;
  90     }
  91 
  92     public SunPKCS11() {
  93         super(&quot;SunPKCS11&quot;, PROVIDER_VER,
  94             &quot;Unconfigured and unusable PKCS11 provider&quot;);
  95         p11 = null;
  96         config = null;
  97         slotID = 0;
  98         pHandler = null;
  99         removable = false;
 100         nssModule = null;
 101         nssUseSecmodTrust = false;
 102         token = null;
 103         poller = null;
 104     }
 105 
 106     @Override
 107     public Provider configure(String configArg) throws InvalidParameterException {
 108         final String newConfigName = checkNull(configArg);
 109         try {
 110             return AccessController.doPrivileged(new PrivilegedExceptionAction&lt;&gt;() {
 111                 @Override
 112                 public SunPKCS11 run() throws Exception {
 113                     return new SunPKCS11(new Config(newConfigName));
 114                 }
 115             });
 116         } catch (PrivilegedActionException pae) {
 117             InvalidParameterException ipe =
 118                 new InvalidParameterException(&quot;Error configuring SunPKCS11 provider&quot;);
 119             throw (InvalidParameterException) ipe.initCause(pae.getException());
 120         }
 121     }
 122 
 123     @Override
 124     public boolean isConfigured() {
 125         return (config != null);
 126     }
 127 
 128     private static &lt;T&gt; T checkNull(T obj) {
 129         if (obj == null) {
 130             throw new NullPointerException();
 131         }
 132         return obj;
 133     }
 134 
 135     // Used by Secmod
 136     SunPKCS11(Config c) {
 137         super(&quot;SunPKCS11-&quot; + c.getName(), PROVIDER_VER, c.getDescription());
 138         this.config = c;
 139 
 140         if (debug != null) {
 141             System.out.println(&quot;SunPKCS11 loading &quot; + config.getFileName());
 142         }
 143 
 144         String library = config.getLibrary();
 145         String functionList = config.getFunctionList();
 146         long slotID = config.getSlotID();
 147         int slotListIndex = config.getSlotListIndex();
 148 
 149         boolean useSecmod = config.getNssUseSecmod();
 150         boolean nssUseSecmodTrust = config.getNssUseSecmodTrust();
 151         Secmod.Module nssModule = null;
 152 
 153         //
 154         // Initialization via Secmod. The way this works is as follows:
 155         // SunPKCS11 is either in normal mode or in NSS Secmod mode.
 156         // Secmod is activated by specifying one or more of the following
 157         // options in the config file:
 158         // nssUseSecmod, nssSecmodDirectory, nssLibrary, nssModule
 159         //
 160         // XXX add more explanation here
 161         //
 162         // If we are in Secmod mode and configured to use either the
 163         // nssKeyStore or the nssTrustAnchors module, we automatically
 164         // switch to using the NSS trust attributes for trusted certs
 165         // (KeyStore).
 166         //
 167 
 168         if (useSecmod) {
 169             // note: Config ensures library/slot/slotListIndex not specified
 170             // in secmod mode.
 171             Secmod secmod = Secmod.getInstance();
 172             DbMode nssDbMode = config.getNssDbMode();
 173             try {
 174                 String nssLibraryDirectory = config.getNssLibraryDirectory();
 175                 String nssSecmodDirectory = config.getNssSecmodDirectory();
 176                 boolean nssOptimizeSpace = config.getNssOptimizeSpace();
 177 
 178                 if (secmod.isInitialized()) {
 179                     if (nssSecmodDirectory != null) {
 180                         String s = secmod.getConfigDir();
 181                         if ((s != null) &amp;&amp;
 182                                 (s.equals(nssSecmodDirectory) == false)) {
 183                             throw new ProviderException(&quot;Secmod directory &quot;
 184                                 + nssSecmodDirectory
 185                                 + &quot; invalid, NSS already initialized with &quot;
 186                                 + s);
 187                         }
 188                     }
 189                     if (nssLibraryDirectory != null) {
 190                         String s = secmod.getLibDir();
 191                         if ((s != null) &amp;&amp;
 192                                 (s.equals(nssLibraryDirectory) == false)) {
 193                             throw new ProviderException(&quot;NSS library directory &quot;
 194                                 + nssLibraryDirectory
 195                                 + &quot; invalid, NSS already initialized with &quot;
 196                                 + s);
 197                         }
 198                     }
 199                 } else {
 200                     if (nssDbMode != DbMode.NO_DB) {
 201                         if (nssSecmodDirectory == null) {
 202                             throw new ProviderException(
 203                                 &quot;Secmod not initialized and &quot;
 204                                  + &quot;nssSecmodDirectory not specified&quot;);
 205                         }
 206                     } else {
 207                         if (nssSecmodDirectory != null) {
 208                             throw new ProviderException(
 209                                 &quot;nssSecmodDirectory must not be &quot;
 210                                 + &quot;specified in noDb mode&quot;);
 211                         }
 212                     }
 213                     secmod.initialize(nssDbMode, nssSecmodDirectory,
 214                         nssLibraryDirectory, nssOptimizeSpace);
 215                 }
 216             } catch (IOException e) {
 217                 // XXX which exception to throw
 218                 throw new ProviderException(&quot;Could not initialize NSS&quot;, e);
 219             }
 220             List&lt;Secmod.Module&gt; modules = secmod.getModules();
 221             if (config.getShowInfo()) {
 222                 System.out.println(&quot;NSS modules: &quot; + modules);
 223             }
 224 
 225             String moduleName = config.getNssModule();
 226             if (moduleName == null) {
 227                 nssModule = secmod.getModule(ModuleType.FIPS);
 228                 if (nssModule != null) {
 229                     moduleName = &quot;fips&quot;;
 230                 } else {
 231                     moduleName = (nssDbMode == DbMode.NO_DB) ?
 232                         &quot;crypto&quot; : &quot;keystore&quot;;
 233                 }
 234             }
 235             if (moduleName.equals(&quot;fips&quot;)) {
 236                 nssModule = secmod.getModule(ModuleType.FIPS);
 237                 nssUseSecmodTrust = true;
 238                 functionList = &quot;FC_GetFunctionList&quot;;
 239             } else if (moduleName.equals(&quot;keystore&quot;)) {
 240                 nssModule = secmod.getModule(ModuleType.KEYSTORE);
 241                 nssUseSecmodTrust = true;
 242             } else if (moduleName.equals(&quot;crypto&quot;)) {
 243                 nssModule = secmod.getModule(ModuleType.CRYPTO);
 244             } else if (moduleName.equals(&quot;trustanchors&quot;)) {
 245                 // XXX should the option be called trustanchor or trustanchors??
 246                 nssModule = secmod.getModule(ModuleType.TRUSTANCHOR);
 247                 nssUseSecmodTrust = true;
 248             } else if (moduleName.startsWith(&quot;external-&quot;)) {
 249                 int moduleIndex;
 250                 try {
 251                     moduleIndex = Integer.parseInt
 252                             (moduleName.substring(&quot;external-&quot;.length()));
 253                 } catch (NumberFormatException e) {
 254                     moduleIndex = -1;
 255                 }
 256                 if (moduleIndex &lt; 1) {
 257                     throw new ProviderException
 258                             (&quot;Invalid external module: &quot; + moduleName);
 259                 }
 260                 int k = 0;
 261                 for (Secmod.Module module : modules) {
 262                     if (module.getType() == ModuleType.EXTERNAL) {
 263                         if (++k == moduleIndex) {
 264                             nssModule = module;
 265                             break;
 266                         }
 267                     }
 268                 }
 269                 if (nssModule == null) {
 270                     throw new ProviderException(&quot;Invalid module &quot; + moduleName
 271                         + &quot;: only &quot; + k + &quot; external NSS modules available&quot;);
 272                 }
 273             } else {
 274                 throw new ProviderException(
 275                     &quot;Unknown NSS module: &quot; + moduleName);
 276             }
 277             if (nssModule == null) {
 278                 throw new ProviderException(
 279                     &quot;NSS module not available: &quot; + moduleName);
 280             }
 281             if (nssModule.hasInitializedProvider()) {
 282                 throw new ProviderException(&quot;Secmod module already configured&quot;);
 283             }
 284             library = nssModule.libraryName;
 285             slotListIndex = nssModule.slot;
 286         }
 287         this.nssUseSecmodTrust = nssUseSecmodTrust;
 288         this.nssModule = nssModule;
 289 
 290         File libraryFile = new File(library);
 291         // if the filename is a simple filename without path
 292         // (e.g. &quot;libpkcs11.so&quot;), it may refer to a library somewhere on the
 293         // OS library search path. Omit the test for file existance as that
 294         // only looks in the current directory.
 295         if (libraryFile.getName().equals(library) == false) {
 296             if (new File(library).isFile() == false) {
 297                 String msg = &quot;Library &quot; + library + &quot; does not exist&quot;;
 298                 if (config.getHandleStartupErrors() == Config.ERR_HALT) {
 299                     throw new ProviderException(msg);
 300                 } else {
 301                     throw new UnsupportedOperationException(msg);
 302                 }
 303             }
 304         }
 305 
 306         try {
 307             if (debug != null) {
 308                 debug.println(&quot;Initializing PKCS#11 library &quot; + library);
 309             }
 310             CK_C_INITIALIZE_ARGS initArgs = new CK_C_INITIALIZE_ARGS();
 311             String nssArgs = config.getNssArgs();
 312             if (nssArgs != null) {
 313                 initArgs.pReserved = nssArgs;
 314             }
 315             // request multithreaded access first
 316             initArgs.flags = CKF_OS_LOCKING_OK;
 317             PKCS11 tmpPKCS11;
 318             try {
 319                 tmpPKCS11 = PKCS11.getInstance(
 320                     library, functionList, initArgs,
 321                     config.getOmitInitialize());
 322             } catch (PKCS11Exception e) {
 323                 if (debug != null) {
 324                     debug.println(&quot;Multi-threaded initialization failed: &quot; + e);
 325                 }
 326                 if (config.getAllowSingleThreadedModules() == false) {
 327                     throw e;
 328                 }
 329                 // fall back to single threaded access
 330                 if (nssArgs == null) {
 331                     // if possible, use null initArgs for better compatibility
 332                     initArgs = null;
 333                 } else {
 334                     initArgs.flags = 0;
 335                 }
 336                 tmpPKCS11 = PKCS11.getInstance(library,
 337                     functionList, initArgs, config.getOmitInitialize());
 338             }
 339             p11 = tmpPKCS11;
 340 
 341             CK_INFO p11Info = p11.C_GetInfo();
 342             if (p11Info.cryptokiVersion.major &lt; 2) {
 343                 throw new ProviderException(&quot;Only PKCS#11 v2.0 and later &quot;
 344                 + &quot;supported, library version is v&quot; + p11Info.cryptokiVersion);
 345             }
 346             boolean showInfo = config.getShowInfo();
 347             if (showInfo) {
 348                 System.out.println(&quot;Information for provider &quot; + getName());
 349                 System.out.println(&quot;Library info:&quot;);
 350                 System.out.println(p11Info);
 351             }
 352 
 353             if ((slotID &lt; 0) || showInfo) {
 354                 long[] slots = p11.C_GetSlotList(false);
 355                 if (showInfo) {
 356                     System.out.println(&quot;All slots: &quot; + toString(slots));
 357                     slots = p11.C_GetSlotList(true);
 358                     System.out.println(&quot;Slots with tokens: &quot; + toString(slots));
 359                 }
 360                 if (slotID &lt; 0) {
 361                     if ((slotListIndex &lt; 0)
 362                             || (slotListIndex &gt;= slots.length)) {
 363                         throw new ProviderException(&quot;slotListIndex is &quot;
 364                             + slotListIndex
 365                             + &quot; but token only has &quot; + slots.length + &quot; slots&quot;);
 366                     }
 367                     slotID = slots[slotListIndex];
 368                 }
 369             }
 370             this.slotID = slotID;
 371             CK_SLOT_INFO slotInfo = p11.C_GetSlotInfo(slotID);
 372             removable = (slotInfo.flags &amp; CKF_REMOVABLE_DEVICE) != 0;
 373             initToken(slotInfo);
 374             if (nssModule != null) {
 375                 nssModule.setProvider(this);
 376             }
 377         } catch (Exception e) {
 378             if (config.getHandleStartupErrors() == Config.ERR_IGNORE_ALL) {
 379                 throw new UnsupportedOperationException
 380                         (&quot;Initialization failed&quot;, e);
 381             } else {
 382                 throw new ProviderException
 383                         (&quot;Initialization failed&quot;, e);
 384             }
 385         }
 386     }
 387 
 388     private static String toString(long[] longs) {
 389         if (longs.length == 0) {
 390             return &quot;(none)&quot;;
 391         }
 392         StringBuilder sb = new StringBuilder();
 393         sb.append(longs[0]);
 394         for (int i = 1; i &lt; longs.length; i++) {
 395             sb.append(&quot;, &quot;);
 396             sb.append(longs[i]);
 397         }
 398         return sb.toString();
 399     }
 400 
 401     public boolean equals(Object obj) {
 402         return this == obj;
 403     }
 404 
 405     public int hashCode() {
 406         return System.identityHashCode(this);
 407     }
 408 
 409     private static String[] s(String ...aliases) {
 410         return aliases;
 411     }
 412 
 413     private static final class Descriptor {
 414         final String type;
 415         final String algorithm;
 416         final String className;
 417         final String[] aliases;
 418         final int[] mechanisms;
 419 
 420         private Descriptor(String type, String algorithm, String className,
 421                 String[] aliases, int[] mechanisms) {
 422             this.type = type;
 423             this.algorithm = algorithm;
 424             this.className = className;
 425             this.aliases = aliases;
 426             this.mechanisms = mechanisms;
 427         }
 428         private P11Service service(Token token, int mechanism) {
 429             return new P11Service
 430                 (token, type, algorithm, className, aliases, mechanism);
 431         }
 432         public String toString() {
 433             return type + &quot;.&quot; + algorithm;
 434         }
 435     }
 436 
 437     // Map from mechanism to List of Descriptors that should be
 438     // registered if the mechanism is supported
 439     private final static Map&lt;Integer,List&lt;Descriptor&gt;&gt; descriptors =
 440         new HashMap&lt;Integer,List&lt;Descriptor&gt;&gt;();
 441 
 442     private static int[] m(long m1) {
 443         return new int[] {(int)m1};
 444     }
 445 
 446     private static int[] m(long m1, long m2) {
 447         return new int[] {(int)m1, (int)m2};
 448     }
 449 
 450     private static int[] m(long m1, long m2, long m3) {
 451         return new int[] {(int)m1, (int)m2, (int)m3};
 452     }
 453 
 454     private static int[] m(long m1, long m2, long m3, long m4) {
 455         return new int[] {(int)m1, (int)m2, (int)m3, (int)m4};
 456     }
 457 
 458     private static void d(String type, String algorithm, String className,
 459             int[] m) {
 460         register(new Descriptor(type, algorithm, className, null, m));
 461     }
 462 
 463     private static void d(String type, String algorithm, String className,
 464             String[] aliases, int[] m) {
 465         register(new Descriptor(type, algorithm, className, aliases, m));
 466     }
 467 
 468     private static void register(Descriptor d) {
 469         for (int i = 0; i &lt; d.mechanisms.length; i++) {
 470             int m = d.mechanisms[i];
 471             Integer key = Integer.valueOf(m);
 472             List&lt;Descriptor&gt; list = descriptors.get(key);
 473             if (list == null) {
 474                 list = new ArrayList&lt;Descriptor&gt;();
 475                 descriptors.put(key, list);
 476             }
 477             list.add(d);
 478         }
 479     }
 480 
 481     private final static String MD  = &quot;MessageDigest&quot;;
 482 
 483     private final static String SIG = &quot;Signature&quot;;
 484 
 485     private final static String KPG = &quot;KeyPairGenerator&quot;;
 486 
 487     private final static String KG  = &quot;KeyGenerator&quot;;
 488 
 489     private final static String AGP = &quot;AlgorithmParameters&quot;;
 490 
 491     private final static String KF  = &quot;KeyFactory&quot;;
 492 
 493     private final static String SKF = &quot;SecretKeyFactory&quot;;
 494 
 495     private final static String CIP = &quot;Cipher&quot;;
 496 
 497     private final static String MAC = &quot;Mac&quot;;
 498 
 499     private final static String KA  = &quot;KeyAgreement&quot;;
 500 
 501     private final static String KS  = &quot;KeyStore&quot;;
 502 
 503     private final static String SR  = &quot;SecureRandom&quot;;
 504 
 505     static {
 506         // names of all the implementation classes
 507         // use local variables, only used here
 508         String P11Digest           = &quot;sun.security.pkcs11.P11Digest&quot;;
 509         String P11MAC              = &quot;sun.security.pkcs11.P11MAC&quot;;
 510         String P11KeyPairGenerator = &quot;sun.security.pkcs11.P11KeyPairGenerator&quot;;
 511         String P11KeyGenerator     = &quot;sun.security.pkcs11.P11KeyGenerator&quot;;
 512         String P11RSAKeyFactory    = &quot;sun.security.pkcs11.P11RSAKeyFactory&quot;;
 513         String P11DSAKeyFactory    = &quot;sun.security.pkcs11.P11DSAKeyFactory&quot;;
 514         String P11DHKeyFactory     = &quot;sun.security.pkcs11.P11DHKeyFactory&quot;;
 515         String P11KeyAgreement     = &quot;sun.security.pkcs11.P11KeyAgreement&quot;;
 516         String P11SecretKeyFactory = &quot;sun.security.pkcs11.P11SecretKeyFactory&quot;;
 517         String P11Cipher           = &quot;sun.security.pkcs11.P11Cipher&quot;;
 518         String P11RSACipher        = &quot;sun.security.pkcs11.P11RSACipher&quot;;
<a name="3" id="anc3"></a>
 519         String P11Signature        = &quot;sun.security.pkcs11.P11Signature&quot;;
<a name="4" id="anc4"></a>
 520 
 521         // XXX register all aliases
 522 
 523         d(MD, &quot;MD2&quot;,            P11Digest,
 524                 m(CKM_MD2));
 525         d(MD, &quot;MD5&quot;,            P11Digest,
 526                 m(CKM_MD5));
 527         d(MD, &quot;SHA1&quot;,           P11Digest,
 528                 s(&quot;SHA&quot;, &quot;SHA-1&quot;, &quot;1.3.14.3.2.26&quot;, &quot;OID.1.3.14.3.2.26&quot;),
 529                 m(CKM_SHA_1));
 530 
 531         d(MD, &quot;SHA-224&quot;,        P11Digest,
 532                 s(&quot;2.16.840.1.101.3.4.2.4&quot;, &quot;OID.2.16.840.1.101.3.4.2.4&quot;),
 533                 m(CKM_SHA224));
 534         d(MD, &quot;SHA-256&quot;,        P11Digest,
 535                 s(&quot;2.16.840.1.101.3.4.2.1&quot;, &quot;OID.2.16.840.1.101.3.4.2.1&quot;),
 536                 m(CKM_SHA256));
 537         d(MD, &quot;SHA-384&quot;,        P11Digest,
 538                 s(&quot;2.16.840.1.101.3.4.2.2&quot;, &quot;OID.2.16.840.1.101.3.4.2.2&quot;),
 539                 m(CKM_SHA384));
 540         d(MD, &quot;SHA-512&quot;,        P11Digest,
 541                 s(&quot;2.16.840.1.101.3.4.2.3&quot;, &quot;OID.2.16.840.1.101.3.4.2.3&quot;),
 542                 m(CKM_SHA512));
<a name="5" id="anc5"></a>





 543 
 544         d(MAC, &quot;HmacMD5&quot;,       P11MAC,
 545                 m(CKM_MD5_HMAC));
 546         d(MAC, &quot;HmacSHA1&quot;,      P11MAC,
 547                 s(&quot;1.2.840.113549.2.7&quot;, &quot;OID.1.2.840.113549.2.7&quot;),
 548                 m(CKM_SHA_1_HMAC));
 549         d(MAC, &quot;HmacSHA224&quot;,    P11MAC,
 550                 s(&quot;1.2.840.113549.2.8&quot;, &quot;OID.1.2.840.113549.2.8&quot;),
 551                 m(CKM_SHA224_HMAC));
 552         d(MAC, &quot;HmacSHA256&quot;,    P11MAC,
 553                 s(&quot;1.2.840.113549.2.9&quot;, &quot;OID.1.2.840.113549.2.9&quot;),
 554                 m(CKM_SHA256_HMAC));
 555         d(MAC, &quot;HmacSHA384&quot;,    P11MAC,
 556                 s(&quot;1.2.840.113549.2.10&quot;, &quot;OID.1.2.840.113549.2.10&quot;),
 557                 m(CKM_SHA384_HMAC));
 558         d(MAC, &quot;HmacSHA512&quot;,    P11MAC,
 559                 s(&quot;1.2.840.113549.2.11&quot;, &quot;OID.1.2.840.113549.2.11&quot;),
 560                 m(CKM_SHA512_HMAC));
<a name="6" id="anc6"></a>






 561         d(MAC, &quot;SslMacMD5&quot;,     P11MAC,
 562                 m(CKM_SSL3_MD5_MAC));
 563         d(MAC, &quot;SslMacSHA1&quot;,    P11MAC,
 564                 m(CKM_SSL3_SHA1_MAC));
 565 
 566         d(KPG, &quot;RSA&quot;,           P11KeyPairGenerator,
<a name="7" id="anc7"></a>
 567                 m(CKM_RSA_PKCS_KEY_PAIR_GEN));
<a name="8" id="anc8"></a>
 568         d(KPG, &quot;DSA&quot;,           P11KeyPairGenerator,
 569                 s(&quot;1.3.14.3.2.12&quot;, &quot;1.2.840.10040.4.1&quot;, &quot;OID.1.2.840.10040.4.1&quot;),
 570                 m(CKM_DSA_KEY_PAIR_GEN));
 571         d(KPG, &quot;DH&quot;,            P11KeyPairGenerator,    s(&quot;DiffieHellman&quot;),
 572                 m(CKM_DH_PKCS_KEY_PAIR_GEN));
 573         d(KPG, &quot;EC&quot;,            P11KeyPairGenerator,
 574                 m(CKM_EC_KEY_PAIR_GEN));
 575 
 576         d(KG,  &quot;ARCFOUR&quot;,       P11KeyGenerator,        s(&quot;RC4&quot;),
 577                 m(CKM_RC4_KEY_GEN));
 578         d(KG,  &quot;DES&quot;,           P11KeyGenerator,
 579                 m(CKM_DES_KEY_GEN));
 580         d(KG,  &quot;DESede&quot;,        P11KeyGenerator,
 581                 m(CKM_DES3_KEY_GEN, CKM_DES2_KEY_GEN));
 582         d(KG,  &quot;AES&quot;,           P11KeyGenerator,
 583                 m(CKM_AES_KEY_GEN));
 584         d(KG,  &quot;Blowfish&quot;,      P11KeyGenerator,
 585                 m(CKM_BLOWFISH_KEY_GEN));
 586 
 587         // register (Secret)KeyFactories if there are any mechanisms
 588         // for a particular algorithm that we support
 589         d(KF, &quot;RSA&quot;,            P11RSAKeyFactory,
<a name="9" id="anc9"></a>
 590                 m(CKM_RSA_PKCS_KEY_PAIR_GEN, CKM_RSA_PKCS, CKM_RSA_X_509));
 591         d(KF, &quot;DSA&quot;,            P11DSAKeyFactory,
 592                 s(&quot;1.3.14.3.2.12&quot;, &quot;1.2.840.10040.4.1&quot;, &quot;OID.1.2.840.10040.4.1&quot;),
 593                 m(CKM_DSA_KEY_PAIR_GEN, CKM_DSA, CKM_DSA_SHA1));
 594         d(KF, &quot;DH&quot;,             P11DHKeyFactory,        s(&quot;DiffieHellman&quot;),
 595                 m(CKM_DH_PKCS_KEY_PAIR_GEN, CKM_DH_PKCS_DERIVE));
 596         d(KF, &quot;EC&quot;,             P11DHKeyFactory,
 597                 m(CKM_EC_KEY_PAIR_GEN, CKM_ECDH1_DERIVE,
 598                     CKM_ECDSA, CKM_ECDSA_SHA1));
 599 
 600         // AlgorithmParameters for EC.
 601         // Only needed until we have an EC implementation in the SUN provider.
 602         d(AGP, &quot;EC&quot;,            &quot;sun.security.util.ECParameters&quot;,
<a name="10" id="anc10"></a><span class="line-modified"> 603                                                 s(&quot;1.2.840.10045.2.1&quot;),</span>
 604                 m(CKM_EC_KEY_PAIR_GEN, CKM_ECDH1_DERIVE,
 605                     CKM_ECDSA, CKM_ECDSA_SHA1));
 606 
<a name="11" id="anc11"></a>



 607         d(KA, &quot;DH&quot;,             P11KeyAgreement,        s(&quot;DiffieHellman&quot;),
 608                 m(CKM_DH_PKCS_DERIVE));
 609         d(KA, &quot;ECDH&quot;,           &quot;sun.security.pkcs11.P11ECDHKeyAgreement&quot;,
 610                 m(CKM_ECDH1_DERIVE));
 611 
 612         d(SKF, &quot;ARCFOUR&quot;,       P11SecretKeyFactory,    s(&quot;RC4&quot;),
 613                 m(CKM_RC4));
 614         d(SKF, &quot;DES&quot;,           P11SecretKeyFactory,
 615                 m(CKM_DES_CBC));
 616         d(SKF, &quot;DESede&quot;,        P11SecretKeyFactory,
 617                 m(CKM_DES3_CBC));
 618         d(SKF, &quot;AES&quot;,           P11SecretKeyFactory,
 619                 s(&quot;2.16.840.1.101.3.4.1&quot;, &quot;OID.2.16.840.1.101.3.4.1&quot;),
 620                 m(CKM_AES_CBC));
 621         d(SKF, &quot;Blowfish&quot;,      P11SecretKeyFactory,
 622                 m(CKM_BLOWFISH_CBC));
 623 
 624         // XXX attributes for Ciphers (supported modes, padding)
 625         d(CIP, &quot;ARCFOUR&quot;,                       P11Cipher,      s(&quot;RC4&quot;),
 626                 m(CKM_RC4));
 627         d(CIP, &quot;DES/CBC/NoPadding&quot;,             P11Cipher,
 628                 m(CKM_DES_CBC));
 629         d(CIP, &quot;DES/CBC/PKCS5Padding&quot;,          P11Cipher,
 630                 m(CKM_DES_CBC_PAD, CKM_DES_CBC));
 631         d(CIP, &quot;DES/ECB/NoPadding&quot;,             P11Cipher,
 632                 m(CKM_DES_ECB));
 633         d(CIP, &quot;DES/ECB/PKCS5Padding&quot;,          P11Cipher,      s(&quot;DES&quot;),
 634                 m(CKM_DES_ECB));
 635 
 636         d(CIP, &quot;DESede/CBC/NoPadding&quot;,          P11Cipher,
 637                 m(CKM_DES3_CBC));
 638         d(CIP, &quot;DESede/CBC/PKCS5Padding&quot;,       P11Cipher,
 639                 m(CKM_DES3_CBC_PAD, CKM_DES3_CBC));
 640         d(CIP, &quot;DESede/ECB/NoPadding&quot;,          P11Cipher,
 641                 m(CKM_DES3_ECB));
 642         d(CIP, &quot;DESede/ECB/PKCS5Padding&quot;,       P11Cipher,      s(&quot;DESede&quot;),
 643                 m(CKM_DES3_ECB));
 644         d(CIP, &quot;AES/CBC/NoPadding&quot;,             P11Cipher,
 645                 m(CKM_AES_CBC));
 646         d(CIP, &quot;AES_128/CBC/NoPadding&quot;,          P11Cipher,
 647                 s(&quot;2.16.840.1.101.3.4.1.2&quot;, &quot;OID.2.16.840.1.101.3.4.1.2&quot;),
 648                 m(CKM_AES_CBC));
 649         d(CIP, &quot;AES_192/CBC/NoPadding&quot;,          P11Cipher,
 650                 s(&quot;2.16.840.1.101.3.4.1.22&quot;, &quot;OID.2.16.840.1.101.3.4.1.22&quot;),
 651                 m(CKM_AES_CBC));
 652         d(CIP, &quot;AES_256/CBC/NoPadding&quot;,          P11Cipher,
 653                 s(&quot;2.16.840.1.101.3.4.1.42&quot;, &quot;OID.2.16.840.1.101.3.4.1.42&quot;),
 654                 m(CKM_AES_CBC));
 655         d(CIP, &quot;AES/CBC/PKCS5Padding&quot;,          P11Cipher,
 656                 m(CKM_AES_CBC_PAD, CKM_AES_CBC));
 657         d(CIP, &quot;AES/ECB/NoPadding&quot;,             P11Cipher,
 658                 m(CKM_AES_ECB));
 659         d(CIP, &quot;AES_128/ECB/NoPadding&quot;,          P11Cipher,
 660                 s(&quot;2.16.840.1.101.3.4.1.1&quot;, &quot;OID.2.16.840.1.101.3.4.1.1&quot;),
 661                 m(CKM_AES_ECB));
 662         d(CIP, &quot;AES_192/ECB/NoPadding&quot;,          P11Cipher,
 663                 s(&quot;2.16.840.1.101.3.4.1.21&quot;, &quot;OID.2.16.840.1.101.3.4.1.21&quot;),
 664                 m(CKM_AES_ECB));
 665         d(CIP, &quot;AES_256/ECB/NoPadding&quot;,          P11Cipher,
 666                 s(&quot;2.16.840.1.101.3.4.1.41&quot;, &quot;OID.2.16.840.1.101.3.4.1.41&quot;),
 667                 m(CKM_AES_ECB));
 668         d(CIP, &quot;AES/ECB/PKCS5Padding&quot;,          P11Cipher,      s(&quot;AES&quot;),
 669                 m(CKM_AES_ECB));
 670         d(CIP, &quot;AES/CTR/NoPadding&quot;,             P11Cipher,
 671                 m(CKM_AES_CTR));
<a name="12" id="anc12"></a>












 672         d(CIP, &quot;Blowfish/CBC/NoPadding&quot;,        P11Cipher,
 673                 m(CKM_BLOWFISH_CBC));
 674         d(CIP, &quot;Blowfish/CBC/PKCS5Padding&quot;,     P11Cipher,
 675                 m(CKM_BLOWFISH_CBC));
 676 
<a name="13" id="anc13"></a><span class="line-removed"> 677         // XXX RSA_X_509, RSA_OAEP not yet supported</span>
 678         d(CIP, &quot;RSA/ECB/PKCS1Padding&quot;,          P11RSACipher,   s(&quot;RSA&quot;),
 679                 m(CKM_RSA_PKCS));
 680         d(CIP, &quot;RSA/ECB/NoPadding&quot;,             P11RSACipher,
 681                 m(CKM_RSA_X_509));
 682 
 683         d(SIG, &quot;RawDSA&quot;,        P11Signature,   s(&quot;NONEwithDSA&quot;),
 684                 m(CKM_DSA));
 685         d(SIG, &quot;DSA&quot;,           P11Signature,
 686                 s(&quot;SHA1withDSA&quot;, &quot;1.3.14.3.2.13&quot;, &quot;1.3.14.3.2.27&quot;,
 687                   &quot;1.2.840.10040.4.3&quot;, &quot;OID.1.2.840.10040.4.3&quot;),
 688                 m(CKM_DSA_SHA1, CKM_DSA));
<a name="14" id="anc14"></a>











 689         d(SIG, &quot;RawDSAinP1363Format&quot;,   P11Signature,
 690                 s(&quot;NONEwithDSAinP1363Format&quot;),
 691                 m(CKM_DSA));
 692         d(SIG, &quot;DSAinP1363Format&quot;,      P11Signature,
 693                 s(&quot;SHA1withDSAinP1363Format&quot;),
 694                 m(CKM_DSA_SHA1, CKM_DSA));
<a name="15" id="anc15"></a>
 695         d(SIG, &quot;NONEwithECDSA&quot;, P11Signature,
 696                 m(CKM_ECDSA));
 697         d(SIG, &quot;SHA1withECDSA&quot;, P11Signature,
 698                 s(&quot;ECDSA&quot;, &quot;1.2.840.10045.4.1&quot;, &quot;OID.1.2.840.10045.4.1&quot;),
 699                 m(CKM_ECDSA_SHA1, CKM_ECDSA));
 700         d(SIG, &quot;SHA224withECDSA&quot;,       P11Signature,
 701                 s(&quot;1.2.840.10045.4.3.1&quot;, &quot;OID.1.2.840.10045.4.3.1&quot;),
 702                 m(CKM_ECDSA));
 703         d(SIG, &quot;SHA256withECDSA&quot;,       P11Signature,
 704                 s(&quot;1.2.840.10045.4.3.2&quot;, &quot;OID.1.2.840.10045.4.3.2&quot;),
 705                 m(CKM_ECDSA));
 706         d(SIG, &quot;SHA384withECDSA&quot;,       P11Signature,
 707                 s(&quot;1.2.840.10045.4.3.3&quot;, &quot;OID.1.2.840.10045.4.3.3&quot;),
 708                 m(CKM_ECDSA));
 709         d(SIG, &quot;SHA512withECDSA&quot;,       P11Signature,
 710                 s(&quot;1.2.840.10045.4.3.4&quot;, &quot;OID.1.2.840.10045.4.3.4&quot;),
 711                 m(CKM_ECDSA));
 712         d(SIG, &quot;NONEwithECDSAinP1363Format&quot;,   P11Signature,
 713                 m(CKM_ECDSA));
 714         d(SIG, &quot;SHA1withECDSAinP1363Format&quot;,   P11Signature,
 715                 m(CKM_ECDSA_SHA1, CKM_ECDSA));
 716         d(SIG, &quot;SHA224withECDSAinP1363Format&quot;, P11Signature,
 717                 m(CKM_ECDSA));
 718         d(SIG, &quot;SHA256withECDSAinP1363Format&quot;, P11Signature,
 719                 m(CKM_ECDSA));
 720         d(SIG, &quot;SHA384withECDSAinP1363Format&quot;, P11Signature,
 721                 m(CKM_ECDSA));
 722         d(SIG, &quot;SHA512withECDSAinP1363Format&quot;, P11Signature,
 723                 m(CKM_ECDSA));
 724         d(SIG, &quot;MD2withRSA&quot;,    P11Signature,
 725                 s(&quot;1.2.840.113549.1.1.2&quot;, &quot;OID.1.2.840.113549.1.1.2&quot;),
 726                 m(CKM_MD2_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
 727         d(SIG, &quot;MD5withRSA&quot;,    P11Signature,
 728                 s(&quot;1.2.840.113549.1.1.4&quot;, &quot;OID.1.2.840.113549.1.1.4&quot;),
 729                 m(CKM_MD5_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
 730         d(SIG, &quot;SHA1withRSA&quot;,   P11Signature,
 731                 s(&quot;1.2.840.113549.1.1.5&quot;, &quot;OID.1.2.840.113549.1.1.5&quot;,
 732                   &quot;1.3.14.3.2.29&quot;),
 733                 m(CKM_SHA1_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
 734         d(SIG, &quot;SHA224withRSA&quot;, P11Signature,
 735                 s(&quot;1.2.840.113549.1.1.14&quot;, &quot;OID.1.2.840.113549.1.1.14&quot;),
 736                 m(CKM_SHA224_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
 737         d(SIG, &quot;SHA256withRSA&quot;, P11Signature,
 738                 s(&quot;1.2.840.113549.1.1.11&quot;, &quot;OID.1.2.840.113549.1.1.11&quot;),
 739                 m(CKM_SHA256_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
 740         d(SIG, &quot;SHA384withRSA&quot;, P11Signature,
 741                 s(&quot;1.2.840.113549.1.1.12&quot;, &quot;OID.1.2.840.113549.1.1.12&quot;),
 742                 m(CKM_SHA384_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
 743         d(SIG, &quot;SHA512withRSA&quot;, P11Signature,
 744                 s(&quot;1.2.840.113549.1.1.13&quot;, &quot;OID.1.2.840.113549.1.1.13&quot;),
 745                 m(CKM_SHA512_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
<a name="16" id="anc16"></a>












 746 
 747         d(KG, &quot;SunTlsRsaPremasterSecret&quot;,
 748                     &quot;sun.security.pkcs11.P11TlsRsaPremasterSecretGenerator&quot;,
 749                     s(&quot;SunTls12RsaPremasterSecret&quot;),
 750                 m(CKM_SSL3_PRE_MASTER_KEY_GEN, CKM_TLS_PRE_MASTER_KEY_GEN));
 751         d(KG, &quot;SunTlsMasterSecret&quot;,
 752                     &quot;sun.security.pkcs11.P11TlsMasterSecretGenerator&quot;,
 753                 m(CKM_SSL3_MASTER_KEY_DERIVE, CKM_TLS_MASTER_KEY_DERIVE,
 754                     CKM_SSL3_MASTER_KEY_DERIVE_DH,
 755                     CKM_TLS_MASTER_KEY_DERIVE_DH));
 756         d(KG, &quot;SunTls12MasterSecret&quot;,
 757                 &quot;sun.security.pkcs11.P11TlsMasterSecretGenerator&quot;,
 758             m(CKM_TLS12_MASTER_KEY_DERIVE, CKM_TLS12_MASTER_KEY_DERIVE_DH));
 759         d(KG, &quot;SunTlsKeyMaterial&quot;,
 760                     &quot;sun.security.pkcs11.P11TlsKeyMaterialGenerator&quot;,
 761                 m(CKM_SSL3_KEY_AND_MAC_DERIVE, CKM_TLS_KEY_AND_MAC_DERIVE));
 762         d(KG, &quot;SunTls12KeyMaterial&quot;,
 763                 &quot;sun.security.pkcs11.P11TlsKeyMaterialGenerator&quot;,
 764             m(CKM_TLS12_KEY_AND_MAC_DERIVE));
 765         d(KG, &quot;SunTlsPrf&quot;, &quot;sun.security.pkcs11.P11TlsPrfGenerator&quot;,
 766                 m(CKM_TLS_PRF, CKM_NSS_TLS_PRF_GENERAL));
 767         d(KG, &quot;SunTls12Prf&quot;, &quot;sun.security.pkcs11.P11TlsPrfGenerator&quot;,
 768                 m(CKM_TLS_MAC));
 769     }
 770 
 771     // background thread that periodically checks for token insertion
 772     // if no token is present. We need to do that in a separate thread because
 773     // the insertion check may block for quite a long time on some tokens.
 774     private static class TokenPoller implements Runnable {
 775         private final SunPKCS11 provider;
 776         private volatile boolean enabled;
 777         private TokenPoller(SunPKCS11 provider) {
 778             this.provider = provider;
 779             enabled = true;
 780         }
 781         public void run() {
 782             int interval = provider.config.getInsertionCheckInterval();
 783             while (enabled) {
 784                 try {
 785                     Thread.sleep(interval);
 786                 } catch (InterruptedException e) {
 787                     break;
 788                 }
 789                 if (enabled == false) {
 790                     break;
 791                 }
 792                 try {
 793                     provider.initToken(null);
 794                 } catch (PKCS11Exception e) {
 795                     // ignore
 796                 }
 797             }
 798         }
 799         void disable() {
 800             enabled = false;
 801         }
 802     }
 803 
 804     // create the poller thread, if not already active
 805     private void createPoller() {
 806         if (poller != null) {
 807             return;
 808         }
 809         final TokenPoller poller = new TokenPoller(this);
 810         Thread t = new Thread(null, poller, &quot;Poller &quot; + getName(), 0, false);
 811         t.setContextClassLoader(null);
 812         t.setDaemon(true);
 813         t.setPriority(Thread.MIN_PRIORITY);
 814         t.start();
 815         this.poller = poller;
 816     }
 817 
 818     // destroy the poller thread, if active
 819     private void destroyPoller() {
 820         if (poller != null) {
 821             poller.disable();
 822             poller = null;
 823         }
 824     }
 825 
 826     private boolean hasValidToken() {
 827         /* Commented out to work with Solaris softtoken impl which
 828            returns 0-value flags, e.g. both REMOVABLE_DEVICE and
 829            TOKEN_PRESENT are false, when it can&#39;t access the token.
 830         if (removable == false) {
 831             return true;
 832         }
 833         */
 834         Token token = this.token;
 835         return (token != null) &amp;&amp; token.isValid();
 836     }
 837 
 838     // destroy the token. Called if we detect that it has been removed
 839     synchronized void uninitToken(Token token) {
 840         if (this.token != token) {
 841             // mismatch, our token must already be destroyed
 842             return;
 843         }
 844         destroyPoller();
 845         this.token = null;
 846         // unregister all algorithms
 847         AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
 848             public Object run() {
 849                 clear();
 850                 return null;
 851             }
 852         });
 853         createPoller();
 854     }
 855 
<a name="17" id="anc17"></a>


















 856     // test if a token is present and initialize this provider for it if so.
 857     // does nothing if no token is found
 858     // called from constructor and by poller
 859     private void initToken(CK_SLOT_INFO slotInfo) throws PKCS11Exception {
 860         if (slotInfo == null) {
 861             slotInfo = p11.C_GetSlotInfo(slotID);
 862         }
 863         if (removable &amp;&amp; (slotInfo.flags &amp; CKF_TOKEN_PRESENT) == 0) {
 864             createPoller();
 865             return;
 866         }
 867         destroyPoller();
 868         boolean showInfo = config.getShowInfo();
 869         if (showInfo) {
 870             System.out.println(&quot;Slot info for slot &quot; + slotID + &quot;:&quot;);
 871             System.out.println(slotInfo);
 872         }
 873         final Token token = new Token(this);
 874         if (showInfo) {
 875             System.out.println
 876                 (&quot;Token info for token in slot &quot; + slotID + &quot;:&quot;);
 877             System.out.println(token.tokenInfo);
 878         }
 879         long[] supportedMechanisms = p11.C_GetMechanismList(slotID);
 880 
 881         // Create a map from the various Descriptors to the &quot;most
 882         // preferred&quot; mechanism that was defined during the
 883         // static initialization.  For example, DES/CBC/PKCS5Padding
 884         // could be mapped to CKM_DES_CBC_PAD or CKM_DES_CBC.  Prefer
 885         // the earliest entry.  When asked for &quot;DES/CBC/PKCS5Padding&quot;, we
 886         // return a CKM_DES_CBC_PAD.
 887         final Map&lt;Descriptor,Integer&gt; supportedAlgs =
 888                                         new HashMap&lt;Descriptor,Integer&gt;();
<a name="18" id="anc18"></a>
 889         for (int i = 0; i &lt; supportedMechanisms.length; i++) {
 890             long longMech = supportedMechanisms[i];
<a name="19" id="anc19"></a><span class="line-modified"> 891             boolean isEnabled = config.isEnabled(longMech);</span>
 892             if (showInfo) {
<a name="20" id="anc20"></a><span class="line-removed"> 893                 CK_MECHANISM_INFO mechInfo =</span>
<span class="line-removed"> 894                         p11.C_GetMechanismInfo(slotID, longMech);</span>
 895                 System.out.println(&quot;Mechanism &quot; +
<a name="21" id="anc21"></a><span class="line-modified"> 896                         Functions.getMechanismName(longMech) + &quot;:&quot;);</span>
<span class="line-modified"> 897                 if (isEnabled == false) {</span>





 898                     System.out.println(&quot;DISABLED in configuration&quot;);
 899                 }
<a name="22" id="anc22"></a><span class="line-modified"> 900                 System.out.println(mechInfo);</span>
 901             }
<a name="23" id="anc23"></a><span class="line-modified"> 902             if (isEnabled == false) {</span>



 903                 continue;
 904             }
<a name="24" id="anc24"></a>
 905             // we do not know of mechs with the upper 32 bits set
 906             if (longMech &gt;&gt;&gt; 32 != 0) {
<a name="25" id="anc25"></a>


 907                 continue;
 908             }
 909             int mech = (int)longMech;
 910             Integer integerMech = Integer.valueOf(mech);
 911             List&lt;Descriptor&gt; ds = descriptors.get(integerMech);
 912             if (ds == null) {
 913                 continue;
 914             }
 915             for (Descriptor d : ds) {
 916                 Integer oldMech = supportedAlgs.get(d);
 917                 if (oldMech == null) {
 918                     supportedAlgs.put(d, integerMech);
 919                     continue;
 920                 }
 921                 // See if there is something &quot;more preferred&quot;
 922                 // than what we currently have in the supportedAlgs
 923                 // map.
 924                 int intOldMech = oldMech.intValue();
 925                 for (int j = 0; j &lt; d.mechanisms.length; j++) {
 926                     int nextMech = d.mechanisms[j];
 927                     if (mech == nextMech) {
 928                         supportedAlgs.put(d, integerMech);
 929                         break;
 930                     } else if (intOldMech == nextMech) {
 931                         break;
 932                     }
 933                 }
 934             }
 935 
 936         }
 937 
 938         // register algorithms in provider
 939         AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
 940             public Object run() {
 941                 for (Map.Entry&lt;Descriptor,Integer&gt; entry
 942                         : supportedAlgs.entrySet()) {
 943                     Descriptor d = entry.getKey();
 944                     int mechanism = entry.getValue().intValue();
 945                     Service s = d.service(token, mechanism);
 946                     putService(s);
 947                 }
 948                 if (((token.tokenInfo.flags &amp; CKF_RNG) != 0)
 949                         &amp;&amp; config.isEnabled(PCKM_SECURERANDOM)
 950                         &amp;&amp; !token.sessionManager.lowMaxSessions()) {
 951                     // do not register SecureRandom if the token does
 952                     // not support many sessions. if we did, we might
 953                     // run out of sessions in the middle of a
 954                     // nextBytes() call where we cannot fail over.
 955                     putService(new P11Service(token, SR, &quot;PKCS11&quot;,
 956                         &quot;sun.security.pkcs11.P11SecureRandom&quot;, null,
 957                         PCKM_SECURERANDOM));
 958                 }
 959                 if (config.isEnabled(PCKM_KEYSTORE)) {
 960                     putService(new P11Service(token, KS, &quot;PKCS11&quot;,
 961                         &quot;sun.security.pkcs11.P11KeyStore&quot;,
 962                         s(&quot;PKCS11-&quot; + config.getName()),
 963                         PCKM_KEYSTORE));
 964                 }
 965                 return null;
 966             }
 967         });
 968 
 969         this.token = token;
 970     }
 971 
 972     private static final class P11Service extends Service {
 973 
 974         private final Token token;
 975 
 976         private final long mechanism;
 977 
 978         P11Service(Token token, String type, String algorithm,
 979                 String className, String[] al, long mechanism) {
 980             super(token.provider, type, algorithm, className, toList(al),
 981                     type.equals(SR) ? Map.of(&quot;ThreadSafe&quot;, &quot;true&quot;) : null);
 982             this.token = token;
 983             this.mechanism = mechanism &amp; 0xFFFFFFFFL;
 984         }
 985 
 986         private static List&lt;String&gt; toList(String[] aliases) {
 987             return (aliases == null) ? null : Arrays.asList(aliases);
 988         }
 989 
 990         public Object newInstance(Object param)
 991                 throws NoSuchAlgorithmException {
 992             if (token.isValid() == false) {
 993                 throw new NoSuchAlgorithmException(&quot;Token has been removed&quot;);
 994             }
 995             try {
 996                 return newInstance0(param);
 997             } catch (PKCS11Exception e) {
 998                 throw new NoSuchAlgorithmException(e);
 999             }
1000         }
1001 
1002         public Object newInstance0(Object param) throws
1003                 PKCS11Exception, NoSuchAlgorithmException {
1004             String algorithm = getAlgorithm();
1005             String type = getType();
1006             if (type == MD) {
1007                 return new P11Digest(token, algorithm, mechanism);
1008             } else if (type == CIP) {
1009                 if (algorithm.startsWith(&quot;RSA&quot;)) {
1010                     return new P11RSACipher(token, algorithm, mechanism);
<a name="26" id="anc26"></a>

1011                 } else {
1012                     return new P11Cipher(token, algorithm, mechanism);
1013                 }
1014             } else if (type == SIG) {
<a name="27" id="anc27"></a><span class="line-modified">1015                 return new P11Signature(token, algorithm, mechanism);</span>




1016             } else if (type == MAC) {
1017                 return new P11Mac(token, algorithm, mechanism);
1018             } else if (type == KPG) {
1019                 return new P11KeyPairGenerator(token, algorithm, mechanism);
1020             } else if (type == KA) {
1021                 if (algorithm.equals(&quot;ECDH&quot;)) {
1022                     return new P11ECDHKeyAgreement(token, algorithm, mechanism);
1023                 } else {
1024                     return new P11KeyAgreement(token, algorithm, mechanism);
1025                 }
1026             } else if (type == KF) {
1027                 return token.getKeyFactory(algorithm);
1028             } else if (type == SKF) {
1029                 return new P11SecretKeyFactory(token, algorithm);
1030             } else if (type == KG) {
1031                 // reference equality
1032                 if (algorithm == &quot;SunTlsRsaPremasterSecret&quot;) {
1033                     return new P11TlsRsaPremasterSecretGenerator(
1034                         token, algorithm, mechanism);
1035                 } else if (algorithm == &quot;SunTlsMasterSecret&quot;
1036                         || algorithm == &quot;SunTls12MasterSecret&quot;) {
1037                     return new P11TlsMasterSecretGenerator(
1038                         token, algorithm, mechanism);
1039                 } else if (algorithm == &quot;SunTlsKeyMaterial&quot;
1040                         || algorithm == &quot;SunTls12KeyMaterial&quot;) {
1041                     return new P11TlsKeyMaterialGenerator(
1042                         token, algorithm, mechanism);
1043                 } else if (algorithm == &quot;SunTlsPrf&quot;
1044                         || algorithm == &quot;SunTls12Prf&quot;) {
1045                     return new P11TlsPrfGenerator(token, algorithm, mechanism);
1046                 } else {
1047                     return new P11KeyGenerator(token, algorithm, mechanism);
1048                 }
1049             } else if (type == SR) {
1050                 return token.getRandom();
1051             } else if (type == KS) {
1052                 return token.getKeyStore();
1053             } else if (type == AGP) {
<a name="28" id="anc28"></a><span class="line-modified">1054                 return new sun.security.util.ECParameters();</span>







1055             } else {
1056                 throw new NoSuchAlgorithmException(&quot;Unknown type: &quot; + type);
1057             }
1058         }
1059 
1060         public boolean supportsParameter(Object param) {
1061             if ((param == null) || (token.isValid() == false)) {
1062                 return false;
1063             }
1064             if (param instanceof Key == false) {
1065                 throw new InvalidParameterException(&quot;Parameter must be a Key&quot;);
1066             }
1067             String algorithm = getAlgorithm();
1068             String type = getType();
1069             Key key = (Key)param;
1070             String keyAlgorithm = key.getAlgorithm();
1071             // RSA signatures and cipher
1072             if (((type == CIP) &amp;&amp; algorithm.startsWith(&quot;RSA&quot;))
<a name="29" id="anc29"></a><span class="line-modified">1073                     || (type == SIG) &amp;&amp; algorithm.endsWith(&quot;RSA&quot;)) {</span>
1074                 if (keyAlgorithm.equals(&quot;RSA&quot;) == false) {
1075                     return false;
1076                 }
1077                 return isLocalKey(key)
1078                         || (key instanceof RSAPrivateKey)
1079                         || (key instanceof RSAPublicKey);
1080             }
1081             // EC
1082             if (((type == KA) &amp;&amp; algorithm.equals(&quot;ECDH&quot;))
1083                     || ((type == SIG) &amp;&amp; algorithm.contains(&quot;ECDSA&quot;))) {
1084                 if (keyAlgorithm.equals(&quot;EC&quot;) == false) {
1085                     return false;
1086                 }
1087                 return isLocalKey(key)
1088                         || (key instanceof ECPrivateKey)
1089                         || (key instanceof ECPublicKey);
1090             }
1091             // DSA signatures
1092             if ((type == SIG) &amp;&amp; algorithm.contains(&quot;DSA&quot;) &amp;&amp;
1093                     !algorithm.contains(&quot;ECDSA&quot;)) {
1094                 if (keyAlgorithm.equals(&quot;DSA&quot;) == false) {
1095                     return false;
1096                 }
1097                 return isLocalKey(key)
1098                         || (key instanceof DSAPrivateKey)
1099                         || (key instanceof DSAPublicKey);
1100             }
1101             // MACs and symmetric ciphers
1102             if ((type == CIP) || (type == MAC)) {
1103                 // do not check algorithm name, mismatch is unlikely anyway
1104                 return isLocalKey(key) || &quot;RAW&quot;.equals(key.getFormat());
1105             }
1106             // DH key agreement
1107             if (type == KA) {
1108                 if (keyAlgorithm.equals(&quot;DH&quot;) == false) {
1109                     return false;
1110                 }
1111                 return isLocalKey(key)
1112                         || (key instanceof DHPrivateKey)
1113                         || (key instanceof DHPublicKey);
1114             }
1115             // should not reach here,
1116             // unknown engine type or algorithm
1117             throw new AssertionError
1118                 (&quot;SunPKCS11 error: &quot; + type + &quot;, &quot; + algorithm);
1119         }
1120 
1121         private boolean isLocalKey(Key key) {
1122             return (key instanceof P11Key) &amp;&amp; (((P11Key)key).token == token);
1123         }
1124 
1125         public String toString() {
1126             return super.toString() +
1127                 &quot; (&quot; + Functions.getMechanismName(mechanism) + &quot;)&quot;;
1128         }
1129 
1130     }
1131 
1132     /**
1133      * Log in to this provider.
1134      *
1135      * &lt;p&gt; If the token expects a PIN to be supplied by the caller,
1136      * the &lt;code&gt;handler&lt;/code&gt; implementation must support
1137      * a &lt;code&gt;PasswordCallback&lt;/code&gt;.
1138      *
1139      * &lt;p&gt; To determine if the token supports a protected authentication path,
1140      * the CK_TOKEN_INFO flag, CKF_PROTECTED_AUTHENTICATION_PATH, is consulted.
1141      *
1142      * @param subject this parameter is ignored
1143      * @param handler the &lt;code&gt;CallbackHandler&lt;/code&gt; used by
1144      *  this provider to communicate with the caller
1145      *
1146      * @throws IllegalStateException if the provider requires configuration
1147      * and Provider.configure has not been called
1148      * @throws LoginException if the login operation fails
1149      * @throws SecurityException if the does not pass a security check for
1150      *  &lt;code&gt;SecurityPermission(&quot;authProvider.&lt;i&gt;name&lt;/i&gt;&quot;)&lt;/code&gt;,
1151      *  where &lt;i&gt;name&lt;/i&gt; is the value returned by
1152      *  this provider&#39;s &lt;code&gt;getName&lt;/code&gt; method
1153      */
1154     public void login(Subject subject, CallbackHandler handler)
1155         throws LoginException {
1156 
1157         if (!isConfigured()) {
1158             throw new IllegalStateException(&quot;Configuration is required&quot;);
1159         }
1160 
1161         // security check
1162         SecurityManager sm = System.getSecurityManager();
1163         if (sm != null) {
1164             if (debug != null) {
1165                 debug.println(&quot;checking login permission&quot;);
1166             }
1167             sm.checkPermission(new SecurityPermission
1168                         (&quot;authProvider.&quot; + this.getName()));
1169         }
1170 
1171         if (hasValidToken() == false) {
1172             throw new LoginException(&quot;No token present&quot;);
1173         }
1174 
1175         // see if a login is required
1176 
1177         if ((token.tokenInfo.flags &amp; CKF_LOGIN_REQUIRED) == 0) {
1178             if (debug != null) {
1179                 debug.println(&quot;login operation not required for token - &quot; +
1180                                 &quot;ignoring login request&quot;);
1181             }
1182             return;
1183         }
1184 
1185         // see if user already logged in
1186 
1187         try {
1188             if (token.isLoggedInNow(null)) {
1189                 // user already logged in
1190                 if (debug != null) {
1191                     debug.println(&quot;user already logged in&quot;);
1192                 }
1193                 return;
1194             }
1195         } catch (PKCS11Exception e) {
1196             // ignore - fall thru and attempt login
1197         }
1198 
1199         // get the pin if necessary
1200 
1201         char[] pin = null;
1202         if ((token.tokenInfo.flags &amp; CKF_PROTECTED_AUTHENTICATION_PATH) == 0) {
1203 
1204             // get password
1205 
1206             CallbackHandler myHandler = getCallbackHandler(handler);
1207             if (myHandler == null) {
1208                 throw new LoginException
1209                         (&quot;no password provided, and no callback handler &quot; +
1210                         &quot;available for retrieving password&quot;);
1211             }
1212 
1213             java.text.MessageFormat form = new java.text.MessageFormat
1214                         (ResourcesMgr.getString
1215                         (&quot;PKCS11.Token.providerName.Password.&quot;));
1216             Object[] source = { getName() };
1217 
1218             PasswordCallback pcall = new PasswordCallback(form.format(source),
1219                                                         false);
1220             Callback[] callbacks = { pcall };
1221             try {
1222                 myHandler.handle(callbacks);
1223             } catch (Exception e) {
1224                 LoginException le = new LoginException
1225                         (&quot;Unable to perform password callback&quot;);
1226                 le.initCause(e);
1227                 throw le;
1228             }
1229 
1230             pin = pcall.getPassword();
1231             pcall.clearPassword();
1232             if (pin == null) {
1233                 if (debug != null) {
1234                     debug.println(&quot;caller passed NULL pin&quot;);
1235                 }
1236             }
1237         }
1238 
1239         // perform token login
1240 
1241         Session session = null;
1242         try {
1243             session = token.getOpSession();
1244 
1245             // pin is NULL if using CKF_PROTECTED_AUTHENTICATION_PATH
1246             p11.C_Login(session.id(), CKU_USER, pin);
1247             if (debug != null) {
1248                 debug.println(&quot;login succeeded&quot;);
1249             }
1250         } catch (PKCS11Exception pe) {
1251             if (pe.getErrorCode() == CKR_USER_ALREADY_LOGGED_IN) {
1252                 // let this one go
1253                 if (debug != null) {
1254                     debug.println(&quot;user already logged in&quot;);
1255                 }
1256                 return;
1257             } else if (pe.getErrorCode() == CKR_PIN_INCORRECT) {
1258                 FailedLoginException fle = new FailedLoginException();
1259                 fle.initCause(pe);
1260                 throw fle;
1261             } else {
1262                 LoginException le = new LoginException();
1263                 le.initCause(pe);
1264                 throw le;
1265             }
1266         } finally {
1267             token.releaseSession(session);
1268             if (pin != null) {
1269                 Arrays.fill(pin, &#39; &#39;);
1270             }
1271         }
1272 
1273         // we do not store the PIN in the subject for now
1274     }
1275 
1276     /**
1277      * Log out from this provider
1278      *
1279      * @throws IllegalStateException if the provider requires configuration
1280      * and Provider.configure has not been called
1281      * @throws LoginException if the logout operation fails
1282      * @throws SecurityException if the does not pass a security check for
1283      *  &lt;code&gt;SecurityPermission(&quot;authProvider.&lt;i&gt;name&lt;/i&gt;&quot;)&lt;/code&gt;,
1284      *  where &lt;i&gt;name&lt;/i&gt; is the value returned by
1285      *  this provider&#39;s &lt;code&gt;getName&lt;/code&gt; method
1286      */
1287     public void logout() throws LoginException {
1288 
1289         if (!isConfigured()) {
1290             throw new IllegalStateException(&quot;Configuration is required&quot;);
1291         }
1292 
1293         // security check
1294         SecurityManager sm = System.getSecurityManager();
1295         if (sm != null) {
1296             sm.checkPermission
1297                 (new SecurityPermission(&quot;authProvider.&quot; + this.getName()));
1298         }
1299 
1300         if (hasValidToken() == false) {
1301             // app may call logout for cleanup, allow
1302             return;
1303         }
1304 
1305         if ((token.tokenInfo.flags &amp; CKF_LOGIN_REQUIRED) == 0) {
1306             if (debug != null) {
1307                 debug.println(&quot;logout operation not required for token - &quot; +
1308                                 &quot;ignoring logout request&quot;);
1309             }
1310             return;
1311         }
1312 
1313         try {
1314             if (token.isLoggedInNow(null) == false) {
1315                 if (debug != null) {
1316                     debug.println(&quot;user not logged in&quot;);
1317                 }
1318                 return;
1319             }
1320         } catch (PKCS11Exception e) {
1321             // ignore
1322         }
1323 
1324         // perform token logout
1325 
1326         Session session = null;
1327         try {
1328             session = token.getOpSession();
1329             p11.C_Logout(session.id());
1330             if (debug != null) {
1331                 debug.println(&quot;logout succeeded&quot;);
1332             }
1333         } catch (PKCS11Exception pe) {
1334             if (pe.getErrorCode() == CKR_USER_NOT_LOGGED_IN) {
1335                 // let this one go
1336                 if (debug != null) {
1337                     debug.println(&quot;user not logged in&quot;);
1338                 }
1339                 return;
1340             }
1341             LoginException le = new LoginException();
1342             le.initCause(pe);
1343             throw le;
1344         } finally {
1345             token.releaseSession(session);
1346         }
1347     }
1348 
1349     /**
1350      * Set a &lt;code&gt;CallbackHandler&lt;/code&gt;
1351      *
1352      * &lt;p&gt; The provider uses this handler if one is not passed to the
1353      * &lt;code&gt;login&lt;/code&gt; method.  The provider also uses this handler
1354      * if it invokes &lt;code&gt;login&lt;/code&gt; on behalf of callers.
1355      * In either case if a handler is not set via this method,
1356      * the provider queries the
1357      * &lt;i&gt;auth.login.defaultCallbackHandler&lt;/i&gt; security property
1358      * for the fully qualified class name of a default handler implementation.
1359      * If the security property is not set,
1360      * the provider is assumed to have alternative means
1361      * for obtaining authentication information.
1362      *
1363      * @param handler a &lt;code&gt;CallbackHandler&lt;/code&gt; for obtaining
1364      *          authentication information, which may be &lt;code&gt;null&lt;/code&gt;
1365      *
1366      * @throws IllegalStateException if the provider requires configuration
1367      * and Provider.configure has not been called
1368      * @throws SecurityException if the caller does not pass a
1369      *  security check for
1370      *  &lt;code&gt;SecurityPermission(&quot;authProvider.&lt;i&gt;name&lt;/i&gt;&quot;)&lt;/code&gt;,
1371      *  where &lt;i&gt;name&lt;/i&gt; is the value returned by
1372      *  this provider&#39;s &lt;code&gt;getName&lt;/code&gt; method
1373      */
1374     public void setCallbackHandler(CallbackHandler handler) {
1375 
1376         if (!isConfigured()) {
1377             throw new IllegalStateException(&quot;Configuration is required&quot;);
1378         }
1379 
1380         // security check
1381         SecurityManager sm = System.getSecurityManager();
1382         if (sm != null) {
1383             sm.checkPermission
1384                 (new SecurityPermission(&quot;authProvider.&quot; + this.getName()));
1385         }
1386 
1387         synchronized (LOCK_HANDLER) {
1388             pHandler = handler;
1389         }
1390     }
1391 
1392     private CallbackHandler getCallbackHandler(CallbackHandler handler) {
1393 
1394         // get default handler if necessary
1395 
1396         if (handler != null) {
1397             return handler;
1398         }
1399 
1400         if (debug != null) {
1401             debug.println(&quot;getting provider callback handler&quot;);
1402         }
1403 
1404         synchronized (LOCK_HANDLER) {
1405             // see if handler was set via setCallbackHandler
1406             if (pHandler != null) {
1407                 return pHandler;
1408             }
1409 
1410             try {
1411                 if (debug != null) {
1412                     debug.println(&quot;getting default callback handler&quot;);
1413                 }
1414 
1415                 CallbackHandler myHandler = AccessController.doPrivileged
1416                     (new PrivilegedExceptionAction&lt;CallbackHandler&gt;() {
1417                     public CallbackHandler run() throws Exception {
1418 
1419                         String defaultHandler =
1420                                 java.security.Security.getProperty
1421                                 (&quot;auth.login.defaultCallbackHandler&quot;);
1422 
1423                         if (defaultHandler == null ||
1424                             defaultHandler.length() == 0) {
1425 
1426                             // ok
1427                             if (debug != null) {
1428                                 debug.println(&quot;no default handler set&quot;);
1429                             }
1430                             return null;
1431                         }
1432 
1433                         Class&lt;?&gt; c = Class.forName
1434                                    (defaultHandler,
1435                                    true,
1436                                    Thread.currentThread().getContextClassLoader());
1437                         if (!javax.security.auth.callback.CallbackHandler.class.isAssignableFrom(c)) {
1438                             // not the right subtype
1439                             if (debug != null) {
1440                                 debug.println(&quot;default handler &quot; + defaultHandler +
1441                                               &quot; is not a CallbackHandler&quot;);
1442                             }
1443                             return null;
1444                         }
1445                         @SuppressWarnings(&quot;deprecation&quot;)
1446                         Object result = c.newInstance();
1447                         return (CallbackHandler)result;
1448                     }
1449                 });
1450                 // save it
1451                 pHandler = myHandler;
1452                 return myHandler;
1453 
1454             } catch (PrivilegedActionException pae) {
1455                 // ok
1456                 if (debug != null) {
1457                     debug.println(&quot;Unable to load default callback handler&quot;);
1458                     pae.printStackTrace();
1459                 }
1460             }
1461         }
1462         return null;
1463     }
1464 
1465     private Object writeReplace() throws ObjectStreamException {
1466         return new SunPKCS11Rep(this);
1467     }
1468 
1469     /**
1470      * Serialized representation of the SunPKCS11 provider.
1471      */
1472     private static class SunPKCS11Rep implements Serializable {
1473 
1474         static final long serialVersionUID = -2896606995897745419L;
1475 
1476         private final String providerName;
1477 
1478         private final String configName;
1479 
1480         SunPKCS11Rep(SunPKCS11 provider) throws NotSerializableException {
1481             providerName = provider.getName();
1482             configName = provider.config.getFileName();
1483             if (Security.getProvider(providerName) != provider) {
1484                 throw new NotSerializableException(&quot;Only SunPKCS11 providers &quot;
1485                     + &quot;installed in java.security.Security can be serialized&quot;);
1486             }
1487         }
1488 
1489         private Object readResolve() throws ObjectStreamException {
1490             SunPKCS11 p = (SunPKCS11)Security.getProvider(providerName);
1491             if ((p == null) || (p.config.getFileName().equals(configName) == false)) {
1492                 throw new NotSerializableException(&quot;Could not find &quot;
1493                         + providerName + &quot; in installed providers&quot;);
1494             }
1495             return p;
1496         }
1497     }
1498 }
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/SunPKCS11.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.pkcs11;
  27 
  28 import java.io.*;
  29 import java.util.*;
  30 
  31 import java.security.*;
  32 import java.security.interfaces.*;
  33 
  34 import javax.crypto.interfaces.*;
  35 
  36 import javax.security.auth.Subject;
  37 import javax.security.auth.login.LoginException;
  38 import javax.security.auth.login.FailedLoginException;
  39 import javax.security.auth.callback.Callback;
  40 import javax.security.auth.callback.CallbackHandler;
  41 import javax.security.auth.callback.ConfirmationCallback;
  42 import javax.security.auth.callback.PasswordCallback;
  43 import javax.security.auth.callback.TextOutputCallback;
  44 
  45 import sun.security.util.Debug;
  46 import sun.security.util.ResourcesMgr;
  47 import static sun.security.util.SecurityConstants.PROVIDER_VER;
  48 
  49 import sun.security.pkcs11.Secmod.*;
  50 
  51 import sun.security.pkcs11.wrapper.*;
  52 import static sun.security.pkcs11.wrapper.PKCS11Constants.*;
  53 
  54 /**
  55  * PKCS#11 provider main class.
  56  *
  57  * @author  Andreas Sterbenz
  58  * @since   1.5
  59  */
  60 public final class SunPKCS11 extends AuthProvider {
  61 
  62     private static final long serialVersionUID = -1354835039035306505L;
  63 
  64     static final Debug debug = Debug.getInstance(&quot;sunpkcs11&quot;);
  65     // the PKCS11 object through which we make the native calls
  66     final PKCS11 p11;
  67 
  68     // configuration information
  69     final Config config;
  70 
  71     // id of the PKCS#11 slot we are using
  72     final long slotID;
  73 
  74     private CallbackHandler pHandler;
  75     private final Object LOCK_HANDLER = new Object();
  76 
  77     final boolean removable;
  78 
  79     final Secmod.Module nssModule;
  80 
  81     final boolean nssUseSecmodTrust;
  82 
  83     private volatile Token token;
  84 
  85     private TokenPoller poller;
  86 
  87     Token getToken() {
  88         return token;
  89     }
  90 
  91     public SunPKCS11() {
  92         super(&quot;SunPKCS11&quot;, PROVIDER_VER,
  93             &quot;Unconfigured and unusable PKCS11 provider&quot;);
  94         p11 = null;
  95         config = null;
  96         slotID = 0;
  97         pHandler = null;
  98         removable = false;
  99         nssModule = null;
 100         nssUseSecmodTrust = false;
 101         token = null;
 102         poller = null;
 103     }
 104 
 105     @Override
 106     public Provider configure(String configArg) throws InvalidParameterException {
 107         final String newConfigName = checkNull(configArg);
 108         try {
 109             return AccessController.doPrivileged(new PrivilegedExceptionAction&lt;&gt;() {
 110                 @Override
 111                 public SunPKCS11 run() throws Exception {
 112                     return new SunPKCS11(new Config(newConfigName));
 113                 }
 114             });
 115         } catch (PrivilegedActionException pae) {
 116             InvalidParameterException ipe =
 117                 new InvalidParameterException(&quot;Error configuring SunPKCS11 provider&quot;);
 118             throw (InvalidParameterException) ipe.initCause(pae.getException());
 119         }
 120     }
 121 
 122     @Override
 123     public boolean isConfigured() {
 124         return (config != null);
 125     }
 126 
 127     private static &lt;T&gt; T checkNull(T obj) {
 128         if (obj == null) {
 129             throw new NullPointerException();
 130         }
 131         return obj;
 132     }
 133 
 134     // Used by Secmod
 135     SunPKCS11(Config c) {
 136         super(&quot;SunPKCS11-&quot; + c.getName(), PROVIDER_VER, c.getDescription());
 137         this.config = c;
 138 
 139         if (debug != null) {
 140             System.out.println(&quot;SunPKCS11 loading &quot; + config.getFileName());
 141         }
 142 
 143         String library = config.getLibrary();
 144         String functionList = config.getFunctionList();
 145         long slotID = config.getSlotID();
 146         int slotListIndex = config.getSlotListIndex();
 147 
 148         boolean useSecmod = config.getNssUseSecmod();
 149         boolean nssUseSecmodTrust = config.getNssUseSecmodTrust();
 150         Secmod.Module nssModule = null;
 151 
 152         //
 153         // Initialization via Secmod. The way this works is as follows:
 154         // SunPKCS11 is either in normal mode or in NSS Secmod mode.
 155         // Secmod is activated by specifying one or more of the following
 156         // options in the config file:
 157         // nssUseSecmod, nssSecmodDirectory, nssLibrary, nssModule
 158         //
 159         // XXX add more explanation here
 160         //
 161         // If we are in Secmod mode and configured to use either the
 162         // nssKeyStore or the nssTrustAnchors module, we automatically
 163         // switch to using the NSS trust attributes for trusted certs
 164         // (KeyStore).
 165         //
 166 
 167         if (useSecmod) {
 168             // note: Config ensures library/slot/slotListIndex not specified
 169             // in secmod mode.
 170             Secmod secmod = Secmod.getInstance();
 171             DbMode nssDbMode = config.getNssDbMode();
 172             try {
 173                 String nssLibraryDirectory = config.getNssLibraryDirectory();
 174                 String nssSecmodDirectory = config.getNssSecmodDirectory();
 175                 boolean nssOptimizeSpace = config.getNssOptimizeSpace();
 176 
 177                 if (secmod.isInitialized()) {
 178                     if (nssSecmodDirectory != null) {
 179                         String s = secmod.getConfigDir();
 180                         if ((s != null) &amp;&amp;
 181                                 (s.equals(nssSecmodDirectory) == false)) {
 182                             throw new ProviderException(&quot;Secmod directory &quot;
 183                                 + nssSecmodDirectory
 184                                 + &quot; invalid, NSS already initialized with &quot;
 185                                 + s);
 186                         }
 187                     }
 188                     if (nssLibraryDirectory != null) {
 189                         String s = secmod.getLibDir();
 190                         if ((s != null) &amp;&amp;
 191                                 (s.equals(nssLibraryDirectory) == false)) {
 192                             throw new ProviderException(&quot;NSS library directory &quot;
 193                                 + nssLibraryDirectory
 194                                 + &quot; invalid, NSS already initialized with &quot;
 195                                 + s);
 196                         }
 197                     }
 198                 } else {
 199                     if (nssDbMode != DbMode.NO_DB) {
 200                         if (nssSecmodDirectory == null) {
 201                             throw new ProviderException(
 202                                 &quot;Secmod not initialized and &quot;
 203                                  + &quot;nssSecmodDirectory not specified&quot;);
 204                         }
 205                     } else {
 206                         if (nssSecmodDirectory != null) {
 207                             throw new ProviderException(
 208                                 &quot;nssSecmodDirectory must not be &quot;
 209                                 + &quot;specified in noDb mode&quot;);
 210                         }
 211                     }
 212                     secmod.initialize(nssDbMode, nssSecmodDirectory,
 213                         nssLibraryDirectory, nssOptimizeSpace);
 214                 }
 215             } catch (IOException e) {
 216                 // XXX which exception to throw
 217                 throw new ProviderException(&quot;Could not initialize NSS&quot;, e);
 218             }
 219             List&lt;Secmod.Module&gt; modules = secmod.getModules();
 220             if (config.getShowInfo()) {
 221                 System.out.println(&quot;NSS modules: &quot; + modules);
 222             }
 223 
 224             String moduleName = config.getNssModule();
 225             if (moduleName == null) {
 226                 nssModule = secmod.getModule(ModuleType.FIPS);
 227                 if (nssModule != null) {
 228                     moduleName = &quot;fips&quot;;
 229                 } else {
 230                     moduleName = (nssDbMode == DbMode.NO_DB) ?
 231                         &quot;crypto&quot; : &quot;keystore&quot;;
 232                 }
 233             }
 234             if (moduleName.equals(&quot;fips&quot;)) {
 235                 nssModule = secmod.getModule(ModuleType.FIPS);
 236                 nssUseSecmodTrust = true;
 237                 functionList = &quot;FC_GetFunctionList&quot;;
 238             } else if (moduleName.equals(&quot;keystore&quot;)) {
 239                 nssModule = secmod.getModule(ModuleType.KEYSTORE);
 240                 nssUseSecmodTrust = true;
 241             } else if (moduleName.equals(&quot;crypto&quot;)) {
 242                 nssModule = secmod.getModule(ModuleType.CRYPTO);
 243             } else if (moduleName.equals(&quot;trustanchors&quot;)) {
 244                 // XXX should the option be called trustanchor or trustanchors??
 245                 nssModule = secmod.getModule(ModuleType.TRUSTANCHOR);
 246                 nssUseSecmodTrust = true;
 247             } else if (moduleName.startsWith(&quot;external-&quot;)) {
 248                 int moduleIndex;
 249                 try {
 250                     moduleIndex = Integer.parseInt
 251                             (moduleName.substring(&quot;external-&quot;.length()));
 252                 } catch (NumberFormatException e) {
 253                     moduleIndex = -1;
 254                 }
 255                 if (moduleIndex &lt; 1) {
 256                     throw new ProviderException
 257                             (&quot;Invalid external module: &quot; + moduleName);
 258                 }
 259                 int k = 0;
 260                 for (Secmod.Module module : modules) {
 261                     if (module.getType() == ModuleType.EXTERNAL) {
 262                         if (++k == moduleIndex) {
 263                             nssModule = module;
 264                             break;
 265                         }
 266                     }
 267                 }
 268                 if (nssModule == null) {
 269                     throw new ProviderException(&quot;Invalid module &quot; + moduleName
 270                         + &quot;: only &quot; + k + &quot; external NSS modules available&quot;);
 271                 }
 272             } else {
 273                 throw new ProviderException(
 274                     &quot;Unknown NSS module: &quot; + moduleName);
 275             }
 276             if (nssModule == null) {
 277                 throw new ProviderException(
 278                     &quot;NSS module not available: &quot; + moduleName);
 279             }
 280             if (nssModule.hasInitializedProvider()) {
 281                 throw new ProviderException(&quot;Secmod module already configured&quot;);
 282             }
 283             library = nssModule.libraryName;
 284             slotListIndex = nssModule.slot;
 285         }
 286         this.nssUseSecmodTrust = nssUseSecmodTrust;
 287         this.nssModule = nssModule;
 288 
 289         File libraryFile = new File(library);
 290         // if the filename is a simple filename without path
 291         // (e.g. &quot;libpkcs11.so&quot;), it may refer to a library somewhere on the
 292         // OS library search path. Omit the test for file existance as that
 293         // only looks in the current directory.
 294         if (libraryFile.getName().equals(library) == false) {
 295             if (new File(library).isFile() == false) {
 296                 String msg = &quot;Library &quot; + library + &quot; does not exist&quot;;
 297                 if (config.getHandleStartupErrors() == Config.ERR_HALT) {
 298                     throw new ProviderException(msg);
 299                 } else {
 300                     throw new UnsupportedOperationException(msg);
 301                 }
 302             }
 303         }
 304 
 305         try {
 306             if (debug != null) {
 307                 debug.println(&quot;Initializing PKCS#11 library &quot; + library);
 308             }
 309             CK_C_INITIALIZE_ARGS initArgs = new CK_C_INITIALIZE_ARGS();
 310             String nssArgs = config.getNssArgs();
 311             if (nssArgs != null) {
 312                 initArgs.pReserved = nssArgs;
 313             }
 314             // request multithreaded access first
 315             initArgs.flags = CKF_OS_LOCKING_OK;
 316             PKCS11 tmpPKCS11;
 317             try {
 318                 tmpPKCS11 = PKCS11.getInstance(
 319                     library, functionList, initArgs,
 320                     config.getOmitInitialize());
 321             } catch (PKCS11Exception e) {
 322                 if (debug != null) {
 323                     debug.println(&quot;Multi-threaded initialization failed: &quot; + e);
 324                 }
 325                 if (config.getAllowSingleThreadedModules() == false) {
 326                     throw e;
 327                 }
 328                 // fall back to single threaded access
 329                 if (nssArgs == null) {
 330                     // if possible, use null initArgs for better compatibility
 331                     initArgs = null;
 332                 } else {
 333                     initArgs.flags = 0;
 334                 }
 335                 tmpPKCS11 = PKCS11.getInstance(library,
 336                     functionList, initArgs, config.getOmitInitialize());
 337             }
 338             p11 = tmpPKCS11;
 339 
 340             CK_INFO p11Info = p11.C_GetInfo();
 341             if (p11Info.cryptokiVersion.major &lt; 2) {
 342                 throw new ProviderException(&quot;Only PKCS#11 v2.0 and later &quot;
 343                 + &quot;supported, library version is v&quot; + p11Info.cryptokiVersion);
 344             }
 345             boolean showInfo = config.getShowInfo();
 346             if (showInfo) {
 347                 System.out.println(&quot;Information for provider &quot; + getName());
 348                 System.out.println(&quot;Library info:&quot;);
 349                 System.out.println(p11Info);
 350             }
 351 
 352             if ((slotID &lt; 0) || showInfo) {
 353                 long[] slots = p11.C_GetSlotList(false);
 354                 if (showInfo) {
 355                     System.out.println(&quot;All slots: &quot; + toString(slots));
 356                     slots = p11.C_GetSlotList(true);
 357                     System.out.println(&quot;Slots with tokens: &quot; + toString(slots));
 358                 }
 359                 if (slotID &lt; 0) {
 360                     if ((slotListIndex &lt; 0)
 361                             || (slotListIndex &gt;= slots.length)) {
 362                         throw new ProviderException(&quot;slotListIndex is &quot;
 363                             + slotListIndex
 364                             + &quot; but token only has &quot; + slots.length + &quot; slots&quot;);
 365                     }
 366                     slotID = slots[slotListIndex];
 367                 }
 368             }
 369             this.slotID = slotID;
 370             CK_SLOT_INFO slotInfo = p11.C_GetSlotInfo(slotID);
 371             removable = (slotInfo.flags &amp; CKF_REMOVABLE_DEVICE) != 0;
 372             initToken(slotInfo);
 373             if (nssModule != null) {
 374                 nssModule.setProvider(this);
 375             }
 376         } catch (Exception e) {
 377             if (config.getHandleStartupErrors() == Config.ERR_IGNORE_ALL) {
 378                 throw new UnsupportedOperationException
 379                         (&quot;Initialization failed&quot;, e);
 380             } else {
 381                 throw new ProviderException
 382                         (&quot;Initialization failed&quot;, e);
 383             }
 384         }
 385     }
 386 
 387     private static String toString(long[] longs) {
 388         if (longs.length == 0) {
 389             return &quot;(none)&quot;;
 390         }
 391         StringBuilder sb = new StringBuilder();
 392         sb.append(longs[0]);
 393         for (int i = 1; i &lt; longs.length; i++) {
 394             sb.append(&quot;, &quot;);
 395             sb.append(longs[i]);
 396         }
 397         return sb.toString();
 398     }
 399 
 400     public boolean equals(Object obj) {
 401         return this == obj;
 402     }
 403 
 404     public int hashCode() {
 405         return System.identityHashCode(this);
 406     }
 407 
 408     private static String[] s(String ...aliases) {
 409         return aliases;
 410     }
 411 
 412     private static final class Descriptor {
 413         final String type;
 414         final String algorithm;
 415         final String className;
 416         final String[] aliases;
 417         final int[] mechanisms;
 418 
 419         private Descriptor(String type, String algorithm, String className,
 420                 String[] aliases, int[] mechanisms) {
 421             this.type = type;
 422             this.algorithm = algorithm;
 423             this.className = className;
 424             this.aliases = aliases;
 425             this.mechanisms = mechanisms;
 426         }
 427         private P11Service service(Token token, int mechanism) {
 428             return new P11Service
 429                 (token, type, algorithm, className, aliases, mechanism);
 430         }
 431         public String toString() {
 432             return type + &quot;.&quot; + algorithm;
 433         }
 434     }
 435 
 436     // Map from mechanism to List of Descriptors that should be
 437     // registered if the mechanism is supported
 438     private final static Map&lt;Integer,List&lt;Descriptor&gt;&gt; descriptors =
 439         new HashMap&lt;Integer,List&lt;Descriptor&gt;&gt;();
 440 
 441     private static int[] m(long m1) {
 442         return new int[] {(int)m1};
 443     }
 444 
 445     private static int[] m(long m1, long m2) {
 446         return new int[] {(int)m1, (int)m2};
 447     }
 448 
 449     private static int[] m(long m1, long m2, long m3) {
 450         return new int[] {(int)m1, (int)m2, (int)m3};
 451     }
 452 
 453     private static int[] m(long m1, long m2, long m3, long m4) {
 454         return new int[] {(int)m1, (int)m2, (int)m3, (int)m4};
 455     }
 456 
 457     private static void d(String type, String algorithm, String className,
 458             int[] m) {
 459         register(new Descriptor(type, algorithm, className, null, m));
 460     }
 461 
 462     private static void d(String type, String algorithm, String className,
 463             String[] aliases, int[] m) {
 464         register(new Descriptor(type, algorithm, className, aliases, m));
 465     }
 466 
 467     private static void register(Descriptor d) {
 468         for (int i = 0; i &lt; d.mechanisms.length; i++) {
 469             int m = d.mechanisms[i];
 470             Integer key = Integer.valueOf(m);
 471             List&lt;Descriptor&gt; list = descriptors.get(key);
 472             if (list == null) {
 473                 list = new ArrayList&lt;Descriptor&gt;();
 474                 descriptors.put(key, list);
 475             }
 476             list.add(d);
 477         }
 478     }
 479 
 480     private final static String MD  = &quot;MessageDigest&quot;;
 481 
 482     private final static String SIG = &quot;Signature&quot;;
 483 
 484     private final static String KPG = &quot;KeyPairGenerator&quot;;
 485 
 486     private final static String KG  = &quot;KeyGenerator&quot;;
 487 
 488     private final static String AGP = &quot;AlgorithmParameters&quot;;
 489 
 490     private final static String KF  = &quot;KeyFactory&quot;;
 491 
 492     private final static String SKF = &quot;SecretKeyFactory&quot;;
 493 
 494     private final static String CIP = &quot;Cipher&quot;;
 495 
 496     private final static String MAC = &quot;Mac&quot;;
 497 
 498     private final static String KA  = &quot;KeyAgreement&quot;;
 499 
 500     private final static String KS  = &quot;KeyStore&quot;;
 501 
 502     private final static String SR  = &quot;SecureRandom&quot;;
 503 
 504     static {
 505         // names of all the implementation classes
 506         // use local variables, only used here
 507         String P11Digest           = &quot;sun.security.pkcs11.P11Digest&quot;;
 508         String P11MAC              = &quot;sun.security.pkcs11.P11MAC&quot;;
 509         String P11KeyPairGenerator = &quot;sun.security.pkcs11.P11KeyPairGenerator&quot;;
 510         String P11KeyGenerator     = &quot;sun.security.pkcs11.P11KeyGenerator&quot;;
 511         String P11RSAKeyFactory    = &quot;sun.security.pkcs11.P11RSAKeyFactory&quot;;
 512         String P11DSAKeyFactory    = &quot;sun.security.pkcs11.P11DSAKeyFactory&quot;;
 513         String P11DHKeyFactory     = &quot;sun.security.pkcs11.P11DHKeyFactory&quot;;
 514         String P11KeyAgreement     = &quot;sun.security.pkcs11.P11KeyAgreement&quot;;
 515         String P11SecretKeyFactory = &quot;sun.security.pkcs11.P11SecretKeyFactory&quot;;
 516         String P11Cipher           = &quot;sun.security.pkcs11.P11Cipher&quot;;
 517         String P11RSACipher        = &quot;sun.security.pkcs11.P11RSACipher&quot;;
 518         String P11AEADCipher       = &quot;sun.security.pkcs11.P11AEADCipher&quot;;
 519         String P11Signature        = &quot;sun.security.pkcs11.P11Signature&quot;;
 520         String P11PSSSignature     = &quot;sun.security.pkcs11.P11PSSSignature&quot;;
 521 
 522         // XXX register all aliases
 523 
 524         d(MD, &quot;MD2&quot;,            P11Digest,
 525                 m(CKM_MD2));
 526         d(MD, &quot;MD5&quot;,            P11Digest,
 527                 m(CKM_MD5));
 528         d(MD, &quot;SHA1&quot;,           P11Digest,
 529                 s(&quot;SHA&quot;, &quot;SHA-1&quot;, &quot;1.3.14.3.2.26&quot;, &quot;OID.1.3.14.3.2.26&quot;),
 530                 m(CKM_SHA_1));
 531 
 532         d(MD, &quot;SHA-224&quot;,        P11Digest,
 533                 s(&quot;2.16.840.1.101.3.4.2.4&quot;, &quot;OID.2.16.840.1.101.3.4.2.4&quot;),
 534                 m(CKM_SHA224));
 535         d(MD, &quot;SHA-256&quot;,        P11Digest,
 536                 s(&quot;2.16.840.1.101.3.4.2.1&quot;, &quot;OID.2.16.840.1.101.3.4.2.1&quot;),
 537                 m(CKM_SHA256));
 538         d(MD, &quot;SHA-384&quot;,        P11Digest,
 539                 s(&quot;2.16.840.1.101.3.4.2.2&quot;, &quot;OID.2.16.840.1.101.3.4.2.2&quot;),
 540                 m(CKM_SHA384));
 541         d(MD, &quot;SHA-512&quot;,        P11Digest,
 542                 s(&quot;2.16.840.1.101.3.4.2.3&quot;, &quot;OID.2.16.840.1.101.3.4.2.3&quot;),
 543                 m(CKM_SHA512));
 544         d(MD, &quot;SHA-512/224&quot;,        P11Digest,
 545                 s(&quot;2.16.840.1.101.3.4.2.5&quot;, &quot;OID.2.16.840.1.101.3.4.2.5&quot;),
 546                 m(CKM_SHA512_224));
 547         d(MD, &quot;SHA-512/256&quot;,        P11Digest,
 548                 s(&quot;2.16.840.1.101.3.4.2.6&quot;, &quot;OID.2.16.840.1.101.3.4.2.6&quot;),
 549                 m(CKM_SHA512_256));
 550 
 551         d(MAC, &quot;HmacMD5&quot;,       P11MAC,
 552                 m(CKM_MD5_HMAC));
 553         d(MAC, &quot;HmacSHA1&quot;,      P11MAC,
 554                 s(&quot;1.2.840.113549.2.7&quot;, &quot;OID.1.2.840.113549.2.7&quot;),
 555                 m(CKM_SHA_1_HMAC));
 556         d(MAC, &quot;HmacSHA224&quot;,    P11MAC,
 557                 s(&quot;1.2.840.113549.2.8&quot;, &quot;OID.1.2.840.113549.2.8&quot;),
 558                 m(CKM_SHA224_HMAC));
 559         d(MAC, &quot;HmacSHA256&quot;,    P11MAC,
 560                 s(&quot;1.2.840.113549.2.9&quot;, &quot;OID.1.2.840.113549.2.9&quot;),
 561                 m(CKM_SHA256_HMAC));
 562         d(MAC, &quot;HmacSHA384&quot;,    P11MAC,
 563                 s(&quot;1.2.840.113549.2.10&quot;, &quot;OID.1.2.840.113549.2.10&quot;),
 564                 m(CKM_SHA384_HMAC));
 565         d(MAC, &quot;HmacSHA512&quot;,    P11MAC,
 566                 s(&quot;1.2.840.113549.2.11&quot;, &quot;OID.1.2.840.113549.2.11&quot;),
 567                 m(CKM_SHA512_HMAC));
 568         d(MAC, &quot;HmacSHA512/224&quot;,    P11MAC,
 569                 s(&quot;1.2.840.113549.2.12&quot;, &quot;OID.1.2.840.113549.2.12&quot;),
 570                 m(CKM_SHA512_224_HMAC));
 571         d(MAC, &quot;HmacSHA512/256&quot;,    P11MAC,
 572                 s(&quot;1.2.840.113549.2.13&quot;, &quot;OID.1.2.840.113549.2.13&quot;),
 573                 m(CKM_SHA512_256_HMAC));
 574 
 575         d(MAC, &quot;SslMacMD5&quot;,     P11MAC,
 576                 m(CKM_SSL3_MD5_MAC));
 577         d(MAC, &quot;SslMacSHA1&quot;,    P11MAC,
 578                 m(CKM_SSL3_SHA1_MAC));
 579 
 580         d(KPG, &quot;RSA&quot;,           P11KeyPairGenerator,
 581                 s(&quot;1.2.840.113549.1.1&quot;, &quot;OID.1.2.840.113549.1.1&quot;),
 582                 m(CKM_RSA_PKCS_KEY_PAIR_GEN));
 583 
 584         d(KPG, &quot;DSA&quot;,           P11KeyPairGenerator,
 585                 s(&quot;1.3.14.3.2.12&quot;, &quot;1.2.840.10040.4.1&quot;, &quot;OID.1.2.840.10040.4.1&quot;),
 586                 m(CKM_DSA_KEY_PAIR_GEN));
 587         d(KPG, &quot;DH&quot;,            P11KeyPairGenerator,    s(&quot;DiffieHellman&quot;),
 588                 m(CKM_DH_PKCS_KEY_PAIR_GEN));
 589         d(KPG, &quot;EC&quot;,            P11KeyPairGenerator,
 590                 m(CKM_EC_KEY_PAIR_GEN));
 591 
 592         d(KG,  &quot;ARCFOUR&quot;,       P11KeyGenerator,        s(&quot;RC4&quot;),
 593                 m(CKM_RC4_KEY_GEN));
 594         d(KG,  &quot;DES&quot;,           P11KeyGenerator,
 595                 m(CKM_DES_KEY_GEN));
 596         d(KG,  &quot;DESede&quot;,        P11KeyGenerator,
 597                 m(CKM_DES3_KEY_GEN, CKM_DES2_KEY_GEN));
 598         d(KG,  &quot;AES&quot;,           P11KeyGenerator,
 599                 m(CKM_AES_KEY_GEN));
 600         d(KG,  &quot;Blowfish&quot;,      P11KeyGenerator,
 601                 m(CKM_BLOWFISH_KEY_GEN));
 602 
 603         // register (Secret)KeyFactories if there are any mechanisms
 604         // for a particular algorithm that we support
 605         d(KF, &quot;RSA&quot;,            P11RSAKeyFactory,
 606                 s(&quot;1.2.840.113549.1.1&quot;, &quot;OID.1.2.840.113549.1.1&quot;),
 607                 m(CKM_RSA_PKCS_KEY_PAIR_GEN, CKM_RSA_PKCS, CKM_RSA_X_509));
 608         d(KF, &quot;DSA&quot;,            P11DSAKeyFactory,
 609                 s(&quot;1.3.14.3.2.12&quot;, &quot;1.2.840.10040.4.1&quot;, &quot;OID.1.2.840.10040.4.1&quot;),
 610                 m(CKM_DSA_KEY_PAIR_GEN, CKM_DSA, CKM_DSA_SHA1));
 611         d(KF, &quot;DH&quot;,             P11DHKeyFactory,        s(&quot;DiffieHellman&quot;),
 612                 m(CKM_DH_PKCS_KEY_PAIR_GEN, CKM_DH_PKCS_DERIVE));
 613         d(KF, &quot;EC&quot;,             P11DHKeyFactory,
 614                 m(CKM_EC_KEY_PAIR_GEN, CKM_ECDH1_DERIVE,
 615                     CKM_ECDSA, CKM_ECDSA_SHA1));
 616 
 617         // AlgorithmParameters for EC.
 618         // Only needed until we have an EC implementation in the SUN provider.
 619         d(AGP, &quot;EC&quot;,            &quot;sun.security.util.ECParameters&quot;,
 620                 s(&quot;1.2.840.10045.2.1&quot;),
 621                 m(CKM_EC_KEY_PAIR_GEN, CKM_ECDH1_DERIVE,
 622                     CKM_ECDSA, CKM_ECDSA_SHA1));
 623 
 624 
 625         d(AGP, &quot;GCM&quot;,            &quot;sun.security.util.GCMParameters&quot;,
 626                 m(CKM_AES_GCM));
 627 
 628         d(KA, &quot;DH&quot;,             P11KeyAgreement,        s(&quot;DiffieHellman&quot;),
 629                 m(CKM_DH_PKCS_DERIVE));
 630         d(KA, &quot;ECDH&quot;,           &quot;sun.security.pkcs11.P11ECDHKeyAgreement&quot;,
 631                 m(CKM_ECDH1_DERIVE));
 632 
 633         d(SKF, &quot;ARCFOUR&quot;,       P11SecretKeyFactory,    s(&quot;RC4&quot;),
 634                 m(CKM_RC4));
 635         d(SKF, &quot;DES&quot;,           P11SecretKeyFactory,
 636                 m(CKM_DES_CBC));
 637         d(SKF, &quot;DESede&quot;,        P11SecretKeyFactory,
 638                 m(CKM_DES3_CBC));
 639         d(SKF, &quot;AES&quot;,           P11SecretKeyFactory,
 640                 s(&quot;2.16.840.1.101.3.4.1&quot;, &quot;OID.2.16.840.1.101.3.4.1&quot;),
 641                 m(CKM_AES_CBC));
 642         d(SKF, &quot;Blowfish&quot;,      P11SecretKeyFactory,
 643                 m(CKM_BLOWFISH_CBC));
 644 
 645         // XXX attributes for Ciphers (supported modes, padding)
 646         d(CIP, &quot;ARCFOUR&quot;,                       P11Cipher,      s(&quot;RC4&quot;),
 647                 m(CKM_RC4));
 648         d(CIP, &quot;DES/CBC/NoPadding&quot;,             P11Cipher,
 649                 m(CKM_DES_CBC));
 650         d(CIP, &quot;DES/CBC/PKCS5Padding&quot;,          P11Cipher,
 651                 m(CKM_DES_CBC_PAD, CKM_DES_CBC));
 652         d(CIP, &quot;DES/ECB/NoPadding&quot;,             P11Cipher,
 653                 m(CKM_DES_ECB));
 654         d(CIP, &quot;DES/ECB/PKCS5Padding&quot;,          P11Cipher,      s(&quot;DES&quot;),
 655                 m(CKM_DES_ECB));
 656 
 657         d(CIP, &quot;DESede/CBC/NoPadding&quot;,          P11Cipher,
 658                 m(CKM_DES3_CBC));
 659         d(CIP, &quot;DESede/CBC/PKCS5Padding&quot;,       P11Cipher,
 660                 m(CKM_DES3_CBC_PAD, CKM_DES3_CBC));
 661         d(CIP, &quot;DESede/ECB/NoPadding&quot;,          P11Cipher,
 662                 m(CKM_DES3_ECB));
 663         d(CIP, &quot;DESede/ECB/PKCS5Padding&quot;,       P11Cipher,      s(&quot;DESede&quot;),
 664                 m(CKM_DES3_ECB));
 665         d(CIP, &quot;AES/CBC/NoPadding&quot;,             P11Cipher,
 666                 m(CKM_AES_CBC));
 667         d(CIP, &quot;AES_128/CBC/NoPadding&quot;,          P11Cipher,
 668                 s(&quot;2.16.840.1.101.3.4.1.2&quot;, &quot;OID.2.16.840.1.101.3.4.1.2&quot;),
 669                 m(CKM_AES_CBC));
 670         d(CIP, &quot;AES_192/CBC/NoPadding&quot;,          P11Cipher,
 671                 s(&quot;2.16.840.1.101.3.4.1.22&quot;, &quot;OID.2.16.840.1.101.3.4.1.22&quot;),
 672                 m(CKM_AES_CBC));
 673         d(CIP, &quot;AES_256/CBC/NoPadding&quot;,          P11Cipher,
 674                 s(&quot;2.16.840.1.101.3.4.1.42&quot;, &quot;OID.2.16.840.1.101.3.4.1.42&quot;),
 675                 m(CKM_AES_CBC));
 676         d(CIP, &quot;AES/CBC/PKCS5Padding&quot;,          P11Cipher,
 677                 m(CKM_AES_CBC_PAD, CKM_AES_CBC));
 678         d(CIP, &quot;AES/ECB/NoPadding&quot;,             P11Cipher,
 679                 m(CKM_AES_ECB));
 680         d(CIP, &quot;AES_128/ECB/NoPadding&quot;,          P11Cipher,
 681                 s(&quot;2.16.840.1.101.3.4.1.1&quot;, &quot;OID.2.16.840.1.101.3.4.1.1&quot;),
 682                 m(CKM_AES_ECB));
 683         d(CIP, &quot;AES_192/ECB/NoPadding&quot;,          P11Cipher,
 684                 s(&quot;2.16.840.1.101.3.4.1.21&quot;, &quot;OID.2.16.840.1.101.3.4.1.21&quot;),
 685                 m(CKM_AES_ECB));
 686         d(CIP, &quot;AES_256/ECB/NoPadding&quot;,          P11Cipher,
 687                 s(&quot;2.16.840.1.101.3.4.1.41&quot;, &quot;OID.2.16.840.1.101.3.4.1.41&quot;),
 688                 m(CKM_AES_ECB));
 689         d(CIP, &quot;AES/ECB/PKCS5Padding&quot;,          P11Cipher,      s(&quot;AES&quot;),
 690                 m(CKM_AES_ECB));
 691         d(CIP, &quot;AES/CTR/NoPadding&quot;,             P11Cipher,
 692                 m(CKM_AES_CTR));
 693 
 694         d(CIP, &quot;AES/GCM/NoPadding&quot;,             P11AEADCipher,
 695                 m(CKM_AES_GCM));
 696         d(CIP, &quot;AES_128/GCM/NoPadding&quot;,          P11AEADCipher,
 697                 s(&quot;2.16.840.1.101.3.4.1.6&quot;, &quot;OID.2.16.840.1.101.3.4.1.6&quot;),
 698                 m(CKM_AES_GCM));
 699         d(CIP, &quot;AES_192/GCM/NoPadding&quot;,          P11AEADCipher,
 700                 s(&quot;2.16.840.1.101.3.4.1.26&quot;, &quot;OID.2.16.840.1.101.3.4.1.26&quot;),
 701                 m(CKM_AES_GCM));
 702         d(CIP, &quot;AES_256/GCM/NoPadding&quot;,          P11AEADCipher,
 703                 s(&quot;2.16.840.1.101.3.4.1.46&quot;, &quot;OID.2.16.840.1.101.3.4.1.46&quot;),
 704                 m(CKM_AES_GCM));
 705 
 706         d(CIP, &quot;Blowfish/CBC/NoPadding&quot;,        P11Cipher,
 707                 m(CKM_BLOWFISH_CBC));
 708         d(CIP, &quot;Blowfish/CBC/PKCS5Padding&quot;,     P11Cipher,
 709                 m(CKM_BLOWFISH_CBC));
 710 
 711         d(CIP, &quot;RSA/ECB/PKCS1Padding&quot;,          P11RSACipher,   s(&quot;RSA&quot;),
 712                 m(CKM_RSA_PKCS));
 713         d(CIP, &quot;RSA/ECB/NoPadding&quot;,             P11RSACipher,
 714                 m(CKM_RSA_X_509));
 715 
 716         d(SIG, &quot;RawDSA&quot;,        P11Signature,   s(&quot;NONEwithDSA&quot;),
 717                 m(CKM_DSA));
 718         d(SIG, &quot;DSA&quot;,           P11Signature,
 719                 s(&quot;SHA1withDSA&quot;, &quot;1.3.14.3.2.13&quot;, &quot;1.3.14.3.2.27&quot;,
 720                   &quot;1.2.840.10040.4.3&quot;, &quot;OID.1.2.840.10040.4.3&quot;),
 721                 m(CKM_DSA_SHA1, CKM_DSA));
 722         d(SIG, &quot;SHA224withDSA&quot;, P11Signature,
 723                 s(&quot;2.16.840.1.101.3.4.3.1&quot;, &quot;OID.2.16.840.1.101.3.4.3.1&quot;),
 724                 m(CKM_DSA_SHA224));
 725         d(SIG, &quot;SHA256withDSA&quot;, P11Signature,
 726                 s(&quot;2.16.840.1.101.3.4.3.2&quot;, &quot;OID.2.16.840.1.101.3.4.3.2&quot;),
 727                 m(CKM_DSA_SHA256));
 728         d(SIG, &quot;SHA384withDSA&quot;, P11Signature,
 729                 s(&quot;2.16.840.1.101.3.4.3.3&quot;, &quot;OID.2.16.840.1.101.3.4.3.3&quot;),
 730                 m(CKM_DSA_SHA384));
 731         d(SIG, &quot;SHA512withDSA&quot;, P11Signature,
 732                 s(&quot;2.16.840.1.101.3.4.3.4&quot;, &quot;OID.2.16.840.1.101.3.4.3.4&quot;),
 733                 m(CKM_DSA_SHA512));
 734         d(SIG, &quot;RawDSAinP1363Format&quot;,   P11Signature,
 735                 s(&quot;NONEwithDSAinP1363Format&quot;),
 736                 m(CKM_DSA));
 737         d(SIG, &quot;DSAinP1363Format&quot;,      P11Signature,
 738                 s(&quot;SHA1withDSAinP1363Format&quot;),
 739                 m(CKM_DSA_SHA1, CKM_DSA));
 740 
 741         d(SIG, &quot;NONEwithECDSA&quot;, P11Signature,
 742                 m(CKM_ECDSA));
 743         d(SIG, &quot;SHA1withECDSA&quot;, P11Signature,
 744                 s(&quot;ECDSA&quot;, &quot;1.2.840.10045.4.1&quot;, &quot;OID.1.2.840.10045.4.1&quot;),
 745                 m(CKM_ECDSA_SHA1, CKM_ECDSA));
 746         d(SIG, &quot;SHA224withECDSA&quot;,       P11Signature,
 747                 s(&quot;1.2.840.10045.4.3.1&quot;, &quot;OID.1.2.840.10045.4.3.1&quot;),
 748                 m(CKM_ECDSA));
 749         d(SIG, &quot;SHA256withECDSA&quot;,       P11Signature,
 750                 s(&quot;1.2.840.10045.4.3.2&quot;, &quot;OID.1.2.840.10045.4.3.2&quot;),
 751                 m(CKM_ECDSA));
 752         d(SIG, &quot;SHA384withECDSA&quot;,       P11Signature,
 753                 s(&quot;1.2.840.10045.4.3.3&quot;, &quot;OID.1.2.840.10045.4.3.3&quot;),
 754                 m(CKM_ECDSA));
 755         d(SIG, &quot;SHA512withECDSA&quot;,       P11Signature,
 756                 s(&quot;1.2.840.10045.4.3.4&quot;, &quot;OID.1.2.840.10045.4.3.4&quot;),
 757                 m(CKM_ECDSA));
 758         d(SIG, &quot;NONEwithECDSAinP1363Format&quot;,   P11Signature,
 759                 m(CKM_ECDSA));
 760         d(SIG, &quot;SHA1withECDSAinP1363Format&quot;,   P11Signature,
 761                 m(CKM_ECDSA_SHA1, CKM_ECDSA));
 762         d(SIG, &quot;SHA224withECDSAinP1363Format&quot;, P11Signature,
 763                 m(CKM_ECDSA));
 764         d(SIG, &quot;SHA256withECDSAinP1363Format&quot;, P11Signature,
 765                 m(CKM_ECDSA));
 766         d(SIG, &quot;SHA384withECDSAinP1363Format&quot;, P11Signature,
 767                 m(CKM_ECDSA));
 768         d(SIG, &quot;SHA512withECDSAinP1363Format&quot;, P11Signature,
 769                 m(CKM_ECDSA));
 770         d(SIG, &quot;MD2withRSA&quot;,    P11Signature,
 771                 s(&quot;1.2.840.113549.1.1.2&quot;, &quot;OID.1.2.840.113549.1.1.2&quot;),
 772                 m(CKM_MD2_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
 773         d(SIG, &quot;MD5withRSA&quot;,    P11Signature,
 774                 s(&quot;1.2.840.113549.1.1.4&quot;, &quot;OID.1.2.840.113549.1.1.4&quot;),
 775                 m(CKM_MD5_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
 776         d(SIG, &quot;SHA1withRSA&quot;,   P11Signature,
 777                 s(&quot;1.2.840.113549.1.1.5&quot;, &quot;OID.1.2.840.113549.1.1.5&quot;,
 778                   &quot;1.3.14.3.2.29&quot;),
 779                 m(CKM_SHA1_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
 780         d(SIG, &quot;SHA224withRSA&quot;, P11Signature,
 781                 s(&quot;1.2.840.113549.1.1.14&quot;, &quot;OID.1.2.840.113549.1.1.14&quot;),
 782                 m(CKM_SHA224_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
 783         d(SIG, &quot;SHA256withRSA&quot;, P11Signature,
 784                 s(&quot;1.2.840.113549.1.1.11&quot;, &quot;OID.1.2.840.113549.1.1.11&quot;),
 785                 m(CKM_SHA256_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
 786         d(SIG, &quot;SHA384withRSA&quot;, P11Signature,
 787                 s(&quot;1.2.840.113549.1.1.12&quot;, &quot;OID.1.2.840.113549.1.1.12&quot;),
 788                 m(CKM_SHA384_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
 789         d(SIG, &quot;SHA512withRSA&quot;, P11Signature,
 790                 s(&quot;1.2.840.113549.1.1.13&quot;, &quot;OID.1.2.840.113549.1.1.13&quot;),
 791                 m(CKM_SHA512_RSA_PKCS, CKM_RSA_PKCS, CKM_RSA_X_509));
 792         d(SIG, &quot;RSASSA-PSS&quot;, P11PSSSignature,
 793                 s(&quot;1.2.840.113549.1.1.10&quot;, &quot;OID.1.2.840.113549.1.1.10&quot;),
 794                 m(CKM_RSA_PKCS_PSS));
 795         d(SIG, &quot;SHA1withRSASSA-PSS&quot;, P11PSSSignature,
 796                 m(CKM_SHA1_RSA_PKCS_PSS));
 797         d(SIG, &quot;SHA224withRSASSA-PSS&quot;, P11PSSSignature,
 798                 m(CKM_SHA224_RSA_PKCS_PSS));
 799         d(SIG, &quot;SHA256withRSASSA-PSS&quot;, P11PSSSignature,
 800                 m(CKM_SHA256_RSA_PKCS_PSS));
 801         d(SIG, &quot;SHA384withRSASSA-PSS&quot;, P11PSSSignature,
 802                 m(CKM_SHA384_RSA_PKCS_PSS));
 803         d(SIG, &quot;SHA512withRSASSA-PSS&quot;, P11PSSSignature,
 804                 m(CKM_SHA512_RSA_PKCS_PSS));
 805 
 806         d(KG, &quot;SunTlsRsaPremasterSecret&quot;,
 807                     &quot;sun.security.pkcs11.P11TlsRsaPremasterSecretGenerator&quot;,
 808                     s(&quot;SunTls12RsaPremasterSecret&quot;),
 809                 m(CKM_SSL3_PRE_MASTER_KEY_GEN, CKM_TLS_PRE_MASTER_KEY_GEN));
 810         d(KG, &quot;SunTlsMasterSecret&quot;,
 811                     &quot;sun.security.pkcs11.P11TlsMasterSecretGenerator&quot;,
 812                 m(CKM_SSL3_MASTER_KEY_DERIVE, CKM_TLS_MASTER_KEY_DERIVE,
 813                     CKM_SSL3_MASTER_KEY_DERIVE_DH,
 814                     CKM_TLS_MASTER_KEY_DERIVE_DH));
 815         d(KG, &quot;SunTls12MasterSecret&quot;,
 816                 &quot;sun.security.pkcs11.P11TlsMasterSecretGenerator&quot;,
 817             m(CKM_TLS12_MASTER_KEY_DERIVE, CKM_TLS12_MASTER_KEY_DERIVE_DH));
 818         d(KG, &quot;SunTlsKeyMaterial&quot;,
 819                     &quot;sun.security.pkcs11.P11TlsKeyMaterialGenerator&quot;,
 820                 m(CKM_SSL3_KEY_AND_MAC_DERIVE, CKM_TLS_KEY_AND_MAC_DERIVE));
 821         d(KG, &quot;SunTls12KeyMaterial&quot;,
 822                 &quot;sun.security.pkcs11.P11TlsKeyMaterialGenerator&quot;,
 823             m(CKM_TLS12_KEY_AND_MAC_DERIVE));
 824         d(KG, &quot;SunTlsPrf&quot;, &quot;sun.security.pkcs11.P11TlsPrfGenerator&quot;,
 825                 m(CKM_TLS_PRF, CKM_NSS_TLS_PRF_GENERAL));
 826         d(KG, &quot;SunTls12Prf&quot;, &quot;sun.security.pkcs11.P11TlsPrfGenerator&quot;,
 827                 m(CKM_TLS_MAC));
 828     }
 829 
 830     // background thread that periodically checks for token insertion
 831     // if no token is present. We need to do that in a separate thread because
 832     // the insertion check may block for quite a long time on some tokens.
 833     private static class TokenPoller implements Runnable {
 834         private final SunPKCS11 provider;
 835         private volatile boolean enabled;
 836         private TokenPoller(SunPKCS11 provider) {
 837             this.provider = provider;
 838             enabled = true;
 839         }
 840         public void run() {
 841             int interval = provider.config.getInsertionCheckInterval();
 842             while (enabled) {
 843                 try {
 844                     Thread.sleep(interval);
 845                 } catch (InterruptedException e) {
 846                     break;
 847                 }
 848                 if (enabled == false) {
 849                     break;
 850                 }
 851                 try {
 852                     provider.initToken(null);
 853                 } catch (PKCS11Exception e) {
 854                     // ignore
 855                 }
 856             }
 857         }
 858         void disable() {
 859             enabled = false;
 860         }
 861     }
 862 
 863     // create the poller thread, if not already active
 864     private void createPoller() {
 865         if (poller != null) {
 866             return;
 867         }
 868         final TokenPoller poller = new TokenPoller(this);
 869         Thread t = new Thread(null, poller, &quot;Poller &quot; + getName(), 0, false);
 870         t.setContextClassLoader(null);
 871         t.setDaemon(true);
 872         t.setPriority(Thread.MIN_PRIORITY);
 873         t.start();
 874         this.poller = poller;
 875     }
 876 
 877     // destroy the poller thread, if active
 878     private void destroyPoller() {
 879         if (poller != null) {
 880             poller.disable();
 881             poller = null;
 882         }
 883     }
 884 
 885     private boolean hasValidToken() {
 886         /* Commented out to work with Solaris softtoken impl which
 887            returns 0-value flags, e.g. both REMOVABLE_DEVICE and
 888            TOKEN_PRESENT are false, when it can&#39;t access the token.
 889         if (removable == false) {
 890             return true;
 891         }
 892         */
 893         Token token = this.token;
 894         return (token != null) &amp;&amp; token.isValid();
 895     }
 896 
 897     // destroy the token. Called if we detect that it has been removed
 898     synchronized void uninitToken(Token token) {
 899         if (this.token != token) {
 900             // mismatch, our token must already be destroyed
 901             return;
 902         }
 903         destroyPoller();
 904         this.token = null;
 905         // unregister all algorithms
 906         AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
 907             public Object run() {
 908                 clear();
 909                 return null;
 910             }
 911         });
 912         createPoller();
 913     }
 914 
 915     private static boolean isLegacy(CK_MECHANISM_INFO mechInfo)
 916             throws PKCS11Exception {
 917         // assume full support if no mech info available
 918         // For vendor-specific mechanisms, often no mech info is provided
 919         boolean partialSupport = false;
 920 
 921         if (mechInfo != null) {
 922             if ((mechInfo.flags &amp; CKF_DECRYPT) != 0) {
 923                 // non-legacy cipher mechs should support encryption
 924                 partialSupport |= ((mechInfo.flags &amp; CKF_ENCRYPT) == 0);
 925             }
 926             if ((mechInfo.flags &amp; CKF_VERIFY) != 0) {
 927                 // non-legacy signature mechs should support signing
 928                 partialSupport |= ((mechInfo.flags &amp; CKF_SIGN) == 0);
 929             }
 930         }
 931         return partialSupport;
 932     }
 933 
 934     // test if a token is present and initialize this provider for it if so.
 935     // does nothing if no token is found
 936     // called from constructor and by poller
 937     private void initToken(CK_SLOT_INFO slotInfo) throws PKCS11Exception {
 938         if (slotInfo == null) {
 939             slotInfo = p11.C_GetSlotInfo(slotID);
 940         }
 941         if (removable &amp;&amp; (slotInfo.flags &amp; CKF_TOKEN_PRESENT) == 0) {
 942             createPoller();
 943             return;
 944         }
 945         destroyPoller();
 946         boolean showInfo = config.getShowInfo();
 947         if (showInfo) {
 948             System.out.println(&quot;Slot info for slot &quot; + slotID + &quot;:&quot;);
 949             System.out.println(slotInfo);
 950         }
 951         final Token token = new Token(this);
 952         if (showInfo) {
 953             System.out.println
 954                 (&quot;Token info for token in slot &quot; + slotID + &quot;:&quot;);
 955             System.out.println(token.tokenInfo);
 956         }
 957         long[] supportedMechanisms = p11.C_GetMechanismList(slotID);
 958 
 959         // Create a map from the various Descriptors to the &quot;most
 960         // preferred&quot; mechanism that was defined during the
 961         // static initialization.  For example, DES/CBC/PKCS5Padding
 962         // could be mapped to CKM_DES_CBC_PAD or CKM_DES_CBC.  Prefer
 963         // the earliest entry.  When asked for &quot;DES/CBC/PKCS5Padding&quot;, we
 964         // return a CKM_DES_CBC_PAD.
 965         final Map&lt;Descriptor,Integer&gt; supportedAlgs =
 966                                         new HashMap&lt;Descriptor,Integer&gt;();
 967 
 968         for (int i = 0; i &lt; supportedMechanisms.length; i++) {
 969             long longMech = supportedMechanisms[i];
 970             CK_MECHANISM_INFO mechInfo = token.getMechanismInfo(longMech);
 971             if (showInfo) {
 972                 System.out.println(&quot;Mechanism &quot; +
 973                     Functions.getMechanismName(longMech) + &quot;:&quot;);
 974                 System.out.println(mechInfo == null?
 975                     (Constants.INDENT + &quot;info n/a&quot;) :
 976                     mechInfo);
 977             }
 978             if (!config.isEnabled(longMech)) {
 979                 if (showInfo) {
 980                     System.out.println(&quot;DISABLED in configuration&quot;);
 981                 }
 982                 continue;
 983             }
 984             if (isLegacy(mechInfo)) {
 985                 if (showInfo) {
 986                     System.out.println(&quot;DISABLED due to legacy&quot;);
 987                 }
 988                 continue;
 989             }
 990 
 991             // we do not know of mechs with the upper 32 bits set
 992             if (longMech &gt;&gt;&gt; 32 != 0) {
 993                 if (showInfo) {
 994                     System.out.println(&quot;DISABLED due to unknown mech value&quot;);
 995                 }
 996                 continue;
 997             }
 998             int mech = (int)longMech;
 999             Integer integerMech = Integer.valueOf(mech);
1000             List&lt;Descriptor&gt; ds = descriptors.get(integerMech);
1001             if (ds == null) {
1002                 continue;
1003             }
1004             for (Descriptor d : ds) {
1005                 Integer oldMech = supportedAlgs.get(d);
1006                 if (oldMech == null) {
1007                     supportedAlgs.put(d, integerMech);
1008                     continue;
1009                 }
1010                 // See if there is something &quot;more preferred&quot;
1011                 // than what we currently have in the supportedAlgs
1012                 // map.
1013                 int intOldMech = oldMech.intValue();
1014                 for (int j = 0; j &lt; d.mechanisms.length; j++) {
1015                     int nextMech = d.mechanisms[j];
1016                     if (mech == nextMech) {
1017                         supportedAlgs.put(d, integerMech);
1018                         break;
1019                     } else if (intOldMech == nextMech) {
1020                         break;
1021                     }
1022                 }
1023             }
1024 
1025         }
1026 
1027         // register algorithms in provider
1028         AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
1029             public Object run() {
1030                 for (Map.Entry&lt;Descriptor,Integer&gt; entry
1031                         : supportedAlgs.entrySet()) {
1032                     Descriptor d = entry.getKey();
1033                     int mechanism = entry.getValue().intValue();
1034                     Service s = d.service(token, mechanism);
1035                     putService(s);
1036                 }
1037                 if (((token.tokenInfo.flags &amp; CKF_RNG) != 0)
1038                         &amp;&amp; config.isEnabled(PCKM_SECURERANDOM)
1039                         &amp;&amp; !token.sessionManager.lowMaxSessions()) {
1040                     // do not register SecureRandom if the token does
1041                     // not support many sessions. if we did, we might
1042                     // run out of sessions in the middle of a
1043                     // nextBytes() call where we cannot fail over.
1044                     putService(new P11Service(token, SR, &quot;PKCS11&quot;,
1045                         &quot;sun.security.pkcs11.P11SecureRandom&quot;, null,
1046                         PCKM_SECURERANDOM));
1047                 }
1048                 if (config.isEnabled(PCKM_KEYSTORE)) {
1049                     putService(new P11Service(token, KS, &quot;PKCS11&quot;,
1050                         &quot;sun.security.pkcs11.P11KeyStore&quot;,
1051                         s(&quot;PKCS11-&quot; + config.getName()),
1052                         PCKM_KEYSTORE));
1053                 }
1054                 return null;
1055             }
1056         });
1057 
1058         this.token = token;
1059     }
1060 
1061     private static final class P11Service extends Service {
1062 
1063         private final Token token;
1064 
1065         private final long mechanism;
1066 
1067         P11Service(Token token, String type, String algorithm,
1068                 String className, String[] al, long mechanism) {
1069             super(token.provider, type, algorithm, className, toList(al),
1070                     type.equals(SR) ? Map.of(&quot;ThreadSafe&quot;, &quot;true&quot;) : null);
1071             this.token = token;
1072             this.mechanism = mechanism &amp; 0xFFFFFFFFL;
1073         }
1074 
1075         private static List&lt;String&gt; toList(String[] aliases) {
1076             return (aliases == null) ? null : Arrays.asList(aliases);
1077         }
1078 
1079         public Object newInstance(Object param)
1080                 throws NoSuchAlgorithmException {
1081             if (token.isValid() == false) {
1082                 throw new NoSuchAlgorithmException(&quot;Token has been removed&quot;);
1083             }
1084             try {
1085                 return newInstance0(param);
1086             } catch (PKCS11Exception e) {
1087                 throw new NoSuchAlgorithmException(e);
1088             }
1089         }
1090 
1091         public Object newInstance0(Object param) throws
1092                 PKCS11Exception, NoSuchAlgorithmException {
1093             String algorithm = getAlgorithm();
1094             String type = getType();
1095             if (type == MD) {
1096                 return new P11Digest(token, algorithm, mechanism);
1097             } else if (type == CIP) {
1098                 if (algorithm.startsWith(&quot;RSA&quot;)) {
1099                     return new P11RSACipher(token, algorithm, mechanism);
1100                 } else if (algorithm.endsWith(&quot;GCM/NoPadding&quot;)) {
1101                     return new P11AEADCipher(token, algorithm, mechanism);
1102                 } else {
1103                     return new P11Cipher(token, algorithm, mechanism);
1104                 }
1105             } else if (type == SIG) {
1106                 if (algorithm.indexOf(&quot;RSASSA-PSS&quot;) != -1) {
1107                     return new P11PSSSignature(token, algorithm, mechanism);
1108                 } else {
1109                     return new P11Signature(token, algorithm, mechanism);
1110                 }
1111             } else if (type == MAC) {
1112                 return new P11Mac(token, algorithm, mechanism);
1113             } else if (type == KPG) {
1114                 return new P11KeyPairGenerator(token, algorithm, mechanism);
1115             } else if (type == KA) {
1116                 if (algorithm.equals(&quot;ECDH&quot;)) {
1117                     return new P11ECDHKeyAgreement(token, algorithm, mechanism);
1118                 } else {
1119                     return new P11KeyAgreement(token, algorithm, mechanism);
1120                 }
1121             } else if (type == KF) {
1122                 return token.getKeyFactory(algorithm);
1123             } else if (type == SKF) {
1124                 return new P11SecretKeyFactory(token, algorithm);
1125             } else if (type == KG) {
1126                 // reference equality
1127                 if (algorithm == &quot;SunTlsRsaPremasterSecret&quot;) {
1128                     return new P11TlsRsaPremasterSecretGenerator(
1129                         token, algorithm, mechanism);
1130                 } else if (algorithm == &quot;SunTlsMasterSecret&quot;
1131                         || algorithm == &quot;SunTls12MasterSecret&quot;) {
1132                     return new P11TlsMasterSecretGenerator(
1133                         token, algorithm, mechanism);
1134                 } else if (algorithm == &quot;SunTlsKeyMaterial&quot;
1135                         || algorithm == &quot;SunTls12KeyMaterial&quot;) {
1136                     return new P11TlsKeyMaterialGenerator(
1137                         token, algorithm, mechanism);
1138                 } else if (algorithm == &quot;SunTlsPrf&quot;
1139                         || algorithm == &quot;SunTls12Prf&quot;) {
1140                     return new P11TlsPrfGenerator(token, algorithm, mechanism);
1141                 } else {
1142                     return new P11KeyGenerator(token, algorithm, mechanism);
1143                 }
1144             } else if (type == SR) {
1145                 return token.getRandom();
1146             } else if (type == KS) {
1147                 return token.getKeyStore();
1148             } else if (type == AGP) {
1149                 if (algorithm == &quot;EC&quot;) {
1150                     return new sun.security.util.ECParameters();
1151                 } else if (algorithm == &quot;GCM&quot;) {
1152                     return new sun.security.util.GCMParameters();
1153                 } else {
1154                     throw new NoSuchAlgorithmException(&quot;Unsupported algorithm: &quot;
1155                             + algorithm);
1156                 }
1157             } else {
1158                 throw new NoSuchAlgorithmException(&quot;Unknown type: &quot; + type);
1159             }
1160         }
1161 
1162         public boolean supportsParameter(Object param) {
1163             if ((param == null) || (token.isValid() == false)) {
1164                 return false;
1165             }
1166             if (param instanceof Key == false) {
1167                 throw new InvalidParameterException(&quot;Parameter must be a Key&quot;);
1168             }
1169             String algorithm = getAlgorithm();
1170             String type = getType();
1171             Key key = (Key)param;
1172             String keyAlgorithm = key.getAlgorithm();
1173             // RSA signatures and cipher
1174             if (((type == CIP) &amp;&amp; algorithm.startsWith(&quot;RSA&quot;))
1175                     || (type == SIG) &amp;&amp; (algorithm.indexOf(&quot;RSA&quot;) != -1)) {
1176                 if (keyAlgorithm.equals(&quot;RSA&quot;) == false) {
1177                     return false;
1178                 }
1179                 return isLocalKey(key)
1180                         || (key instanceof RSAPrivateKey)
1181                         || (key instanceof RSAPublicKey);
1182             }
1183             // EC
1184             if (((type == KA) &amp;&amp; algorithm.equals(&quot;ECDH&quot;))
1185                     || ((type == SIG) &amp;&amp; algorithm.contains(&quot;ECDSA&quot;))) {
1186                 if (keyAlgorithm.equals(&quot;EC&quot;) == false) {
1187                     return false;
1188                 }
1189                 return isLocalKey(key)
1190                         || (key instanceof ECPrivateKey)
1191                         || (key instanceof ECPublicKey);
1192             }
1193             // DSA signatures
1194             if ((type == SIG) &amp;&amp; algorithm.contains(&quot;DSA&quot;) &amp;&amp;
1195                     !algorithm.contains(&quot;ECDSA&quot;)) {
1196                 if (keyAlgorithm.equals(&quot;DSA&quot;) == false) {
1197                     return false;
1198                 }
1199                 return isLocalKey(key)
1200                         || (key instanceof DSAPrivateKey)
1201                         || (key instanceof DSAPublicKey);
1202             }
1203             // MACs and symmetric ciphers
1204             if ((type == CIP) || (type == MAC)) {
1205                 // do not check algorithm name, mismatch is unlikely anyway
1206                 return isLocalKey(key) || &quot;RAW&quot;.equals(key.getFormat());
1207             }
1208             // DH key agreement
1209             if (type == KA) {
1210                 if (keyAlgorithm.equals(&quot;DH&quot;) == false) {
1211                     return false;
1212                 }
1213                 return isLocalKey(key)
1214                         || (key instanceof DHPrivateKey)
1215                         || (key instanceof DHPublicKey);
1216             }
1217             // should not reach here,
1218             // unknown engine type or algorithm
1219             throw new AssertionError
1220                 (&quot;SunPKCS11 error: &quot; + type + &quot;, &quot; + algorithm);
1221         }
1222 
1223         private boolean isLocalKey(Key key) {
1224             return (key instanceof P11Key) &amp;&amp; (((P11Key)key).token == token);
1225         }
1226 
1227         public String toString() {
1228             return super.toString() +
1229                 &quot; (&quot; + Functions.getMechanismName(mechanism) + &quot;)&quot;;
1230         }
1231 
1232     }
1233 
1234     /**
1235      * Log in to this provider.
1236      *
1237      * &lt;p&gt; If the token expects a PIN to be supplied by the caller,
1238      * the &lt;code&gt;handler&lt;/code&gt; implementation must support
1239      * a &lt;code&gt;PasswordCallback&lt;/code&gt;.
1240      *
1241      * &lt;p&gt; To determine if the token supports a protected authentication path,
1242      * the CK_TOKEN_INFO flag, CKF_PROTECTED_AUTHENTICATION_PATH, is consulted.
1243      *
1244      * @param subject this parameter is ignored
1245      * @param handler the &lt;code&gt;CallbackHandler&lt;/code&gt; used by
1246      *  this provider to communicate with the caller
1247      *
1248      * @throws IllegalStateException if the provider requires configuration
1249      * and Provider.configure has not been called
1250      * @throws LoginException if the login operation fails
1251      * @throws SecurityException if the does not pass a security check for
1252      *  &lt;code&gt;SecurityPermission(&quot;authProvider.&lt;i&gt;name&lt;/i&gt;&quot;)&lt;/code&gt;,
1253      *  where &lt;i&gt;name&lt;/i&gt; is the value returned by
1254      *  this provider&#39;s &lt;code&gt;getName&lt;/code&gt; method
1255      */
1256     public void login(Subject subject, CallbackHandler handler)
1257         throws LoginException {
1258 
1259         if (!isConfigured()) {
1260             throw new IllegalStateException(&quot;Configuration is required&quot;);
1261         }
1262 
1263         // security check
1264         SecurityManager sm = System.getSecurityManager();
1265         if (sm != null) {
1266             if (debug != null) {
1267                 debug.println(&quot;checking login permission&quot;);
1268             }
1269             sm.checkPermission(new SecurityPermission
1270                         (&quot;authProvider.&quot; + this.getName()));
1271         }
1272 
1273         if (hasValidToken() == false) {
1274             throw new LoginException(&quot;No token present&quot;);
1275         }
1276 
1277         // see if a login is required
1278 
1279         if ((token.tokenInfo.flags &amp; CKF_LOGIN_REQUIRED) == 0) {
1280             if (debug != null) {
1281                 debug.println(&quot;login operation not required for token - &quot; +
1282                                 &quot;ignoring login request&quot;);
1283             }
1284             return;
1285         }
1286 
1287         // see if user already logged in
1288 
1289         try {
1290             if (token.isLoggedInNow(null)) {
1291                 // user already logged in
1292                 if (debug != null) {
1293                     debug.println(&quot;user already logged in&quot;);
1294                 }
1295                 return;
1296             }
1297         } catch (PKCS11Exception e) {
1298             // ignore - fall thru and attempt login
1299         }
1300 
1301         // get the pin if necessary
1302 
1303         char[] pin = null;
1304         if ((token.tokenInfo.flags &amp; CKF_PROTECTED_AUTHENTICATION_PATH) == 0) {
1305 
1306             // get password
1307 
1308             CallbackHandler myHandler = getCallbackHandler(handler);
1309             if (myHandler == null) {
1310                 throw new LoginException
1311                         (&quot;no password provided, and no callback handler &quot; +
1312                         &quot;available for retrieving password&quot;);
1313             }
1314 
1315             java.text.MessageFormat form = new java.text.MessageFormat
1316                         (ResourcesMgr.getString
1317                         (&quot;PKCS11.Token.providerName.Password.&quot;));
1318             Object[] source = { getName() };
1319 
1320             PasswordCallback pcall = new PasswordCallback(form.format(source),
1321                                                         false);
1322             Callback[] callbacks = { pcall };
1323             try {
1324                 myHandler.handle(callbacks);
1325             } catch (Exception e) {
1326                 LoginException le = new LoginException
1327                         (&quot;Unable to perform password callback&quot;);
1328                 le.initCause(e);
1329                 throw le;
1330             }
1331 
1332             pin = pcall.getPassword();
1333             pcall.clearPassword();
1334             if (pin == null) {
1335                 if (debug != null) {
1336                     debug.println(&quot;caller passed NULL pin&quot;);
1337                 }
1338             }
1339         }
1340 
1341         // perform token login
1342 
1343         Session session = null;
1344         try {
1345             session = token.getOpSession();
1346 
1347             // pin is NULL if using CKF_PROTECTED_AUTHENTICATION_PATH
1348             p11.C_Login(session.id(), CKU_USER, pin);
1349             if (debug != null) {
1350                 debug.println(&quot;login succeeded&quot;);
1351             }
1352         } catch (PKCS11Exception pe) {
1353             if (pe.getErrorCode() == CKR_USER_ALREADY_LOGGED_IN) {
1354                 // let this one go
1355                 if (debug != null) {
1356                     debug.println(&quot;user already logged in&quot;);
1357                 }
1358                 return;
1359             } else if (pe.getErrorCode() == CKR_PIN_INCORRECT) {
1360                 FailedLoginException fle = new FailedLoginException();
1361                 fle.initCause(pe);
1362                 throw fle;
1363             } else {
1364                 LoginException le = new LoginException();
1365                 le.initCause(pe);
1366                 throw le;
1367             }
1368         } finally {
1369             token.releaseSession(session);
1370             if (pin != null) {
1371                 Arrays.fill(pin, &#39; &#39;);
1372             }
1373         }
1374 
1375         // we do not store the PIN in the subject for now
1376     }
1377 
1378     /**
1379      * Log out from this provider
1380      *
1381      * @throws IllegalStateException if the provider requires configuration
1382      * and Provider.configure has not been called
1383      * @throws LoginException if the logout operation fails
1384      * @throws SecurityException if the does not pass a security check for
1385      *  &lt;code&gt;SecurityPermission(&quot;authProvider.&lt;i&gt;name&lt;/i&gt;&quot;)&lt;/code&gt;,
1386      *  where &lt;i&gt;name&lt;/i&gt; is the value returned by
1387      *  this provider&#39;s &lt;code&gt;getName&lt;/code&gt; method
1388      */
1389     public void logout() throws LoginException {
1390 
1391         if (!isConfigured()) {
1392             throw new IllegalStateException(&quot;Configuration is required&quot;);
1393         }
1394 
1395         // security check
1396         SecurityManager sm = System.getSecurityManager();
1397         if (sm != null) {
1398             sm.checkPermission
1399                 (new SecurityPermission(&quot;authProvider.&quot; + this.getName()));
1400         }
1401 
1402         if (hasValidToken() == false) {
1403             // app may call logout for cleanup, allow
1404             return;
1405         }
1406 
1407         if ((token.tokenInfo.flags &amp; CKF_LOGIN_REQUIRED) == 0) {
1408             if (debug != null) {
1409                 debug.println(&quot;logout operation not required for token - &quot; +
1410                                 &quot;ignoring logout request&quot;);
1411             }
1412             return;
1413         }
1414 
1415         try {
1416             if (token.isLoggedInNow(null) == false) {
1417                 if (debug != null) {
1418                     debug.println(&quot;user not logged in&quot;);
1419                 }
1420                 return;
1421             }
1422         } catch (PKCS11Exception e) {
1423             // ignore
1424         }
1425 
1426         // perform token logout
1427 
1428         Session session = null;
1429         try {
1430             session = token.getOpSession();
1431             p11.C_Logout(session.id());
1432             if (debug != null) {
1433                 debug.println(&quot;logout succeeded&quot;);
1434             }
1435         } catch (PKCS11Exception pe) {
1436             if (pe.getErrorCode() == CKR_USER_NOT_LOGGED_IN) {
1437                 // let this one go
1438                 if (debug != null) {
1439                     debug.println(&quot;user not logged in&quot;);
1440                 }
1441                 return;
1442             }
1443             LoginException le = new LoginException();
1444             le.initCause(pe);
1445             throw le;
1446         } finally {
1447             token.releaseSession(session);
1448         }
1449     }
1450 
1451     /**
1452      * Set a &lt;code&gt;CallbackHandler&lt;/code&gt;
1453      *
1454      * &lt;p&gt; The provider uses this handler if one is not passed to the
1455      * &lt;code&gt;login&lt;/code&gt; method.  The provider also uses this handler
1456      * if it invokes &lt;code&gt;login&lt;/code&gt; on behalf of callers.
1457      * In either case if a handler is not set via this method,
1458      * the provider queries the
1459      * &lt;i&gt;auth.login.defaultCallbackHandler&lt;/i&gt; security property
1460      * for the fully qualified class name of a default handler implementation.
1461      * If the security property is not set,
1462      * the provider is assumed to have alternative means
1463      * for obtaining authentication information.
1464      *
1465      * @param handler a &lt;code&gt;CallbackHandler&lt;/code&gt; for obtaining
1466      *          authentication information, which may be &lt;code&gt;null&lt;/code&gt;
1467      *
1468      * @throws IllegalStateException if the provider requires configuration
1469      * and Provider.configure has not been called
1470      * @throws SecurityException if the caller does not pass a
1471      *  security check for
1472      *  &lt;code&gt;SecurityPermission(&quot;authProvider.&lt;i&gt;name&lt;/i&gt;&quot;)&lt;/code&gt;,
1473      *  where &lt;i&gt;name&lt;/i&gt; is the value returned by
1474      *  this provider&#39;s &lt;code&gt;getName&lt;/code&gt; method
1475      */
1476     public void setCallbackHandler(CallbackHandler handler) {
1477 
1478         if (!isConfigured()) {
1479             throw new IllegalStateException(&quot;Configuration is required&quot;);
1480         }
1481 
1482         // security check
1483         SecurityManager sm = System.getSecurityManager();
1484         if (sm != null) {
1485             sm.checkPermission
1486                 (new SecurityPermission(&quot;authProvider.&quot; + this.getName()));
1487         }
1488 
1489         synchronized (LOCK_HANDLER) {
1490             pHandler = handler;
1491         }
1492     }
1493 
1494     private CallbackHandler getCallbackHandler(CallbackHandler handler) {
1495 
1496         // get default handler if necessary
1497 
1498         if (handler != null) {
1499             return handler;
1500         }
1501 
1502         if (debug != null) {
1503             debug.println(&quot;getting provider callback handler&quot;);
1504         }
1505 
1506         synchronized (LOCK_HANDLER) {
1507             // see if handler was set via setCallbackHandler
1508             if (pHandler != null) {
1509                 return pHandler;
1510             }
1511 
1512             try {
1513                 if (debug != null) {
1514                     debug.println(&quot;getting default callback handler&quot;);
1515                 }
1516 
1517                 CallbackHandler myHandler = AccessController.doPrivileged
1518                     (new PrivilegedExceptionAction&lt;CallbackHandler&gt;() {
1519                     public CallbackHandler run() throws Exception {
1520 
1521                         String defaultHandler =
1522                                 java.security.Security.getProperty
1523                                 (&quot;auth.login.defaultCallbackHandler&quot;);
1524 
1525                         if (defaultHandler == null ||
1526                             defaultHandler.length() == 0) {
1527 
1528                             // ok
1529                             if (debug != null) {
1530                                 debug.println(&quot;no default handler set&quot;);
1531                             }
1532                             return null;
1533                         }
1534 
1535                         Class&lt;?&gt; c = Class.forName
1536                                    (defaultHandler,
1537                                    true,
1538                                    Thread.currentThread().getContextClassLoader());
1539                         if (!javax.security.auth.callback.CallbackHandler.class.isAssignableFrom(c)) {
1540                             // not the right subtype
1541                             if (debug != null) {
1542                                 debug.println(&quot;default handler &quot; + defaultHandler +
1543                                               &quot; is not a CallbackHandler&quot;);
1544                             }
1545                             return null;
1546                         }
1547                         @SuppressWarnings(&quot;deprecation&quot;)
1548                         Object result = c.newInstance();
1549                         return (CallbackHandler)result;
1550                     }
1551                 });
1552                 // save it
1553                 pHandler = myHandler;
1554                 return myHandler;
1555 
1556             } catch (PrivilegedActionException pae) {
1557                 // ok
1558                 if (debug != null) {
1559                     debug.println(&quot;Unable to load default callback handler&quot;);
1560                     pae.printStackTrace();
1561                 }
1562             }
1563         }
1564         return null;
1565     }
1566 
1567     private Object writeReplace() throws ObjectStreamException {
1568         return new SunPKCS11Rep(this);
1569     }
1570 
1571     /**
1572      * Serialized representation of the SunPKCS11 provider.
1573      */
1574     private static class SunPKCS11Rep implements Serializable {
1575 
1576         static final long serialVersionUID = -2896606995897745419L;
1577 
1578         private final String providerName;
1579 
1580         private final String configName;
1581 
1582         SunPKCS11Rep(SunPKCS11 provider) throws NotSerializableException {
1583             providerName = provider.getName();
1584             configName = provider.config.getFileName();
1585             if (Security.getProvider(providerName) != provider) {
1586                 throw new NotSerializableException(&quot;Only SunPKCS11 providers &quot;
1587                     + &quot;installed in java.security.Security can be serialized&quot;);
1588             }
1589         }
1590 
1591         private Object readResolve() throws ObjectStreamException {
1592             SunPKCS11 p = (SunPKCS11)Security.getProvider(providerName);
1593             if ((p == null) || (p.config.getFileName().equals(configName) == false)) {
1594                 throw new NotSerializableException(&quot;Could not find &quot;
1595                         + providerName + &quot; in installed providers&quot;);
1596             }
1597             return p;
1598         }
1599     }
1600 }
    </pre>
  </body>
</html>
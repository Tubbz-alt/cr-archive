<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/P11KeyStore.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.pkcs11;
  27 
  28 import java.math.BigInteger;
  29 
  30 import java.io.InputStream;
  31 import java.io.OutputStream;
  32 import java.io.IOException;
  33 import java.io.ByteArrayInputStream;
<a name="1" id="anc1"></a><span class="line-modified">  34 import java.io.UnsupportedEncodingException;</span>

  35 
  36 import java.util.Arrays;
  37 import java.util.Collections;
  38 import java.util.Date;
  39 import java.util.Enumeration;
  40 import java.util.ArrayList;
  41 import java.util.HashSet;
  42 import java.util.HashMap;
  43 import java.util.Set;
  44 
  45 import java.security.*;
  46 import java.security.KeyStore.*;
  47 
  48 import java.security.cert.Certificate;
  49 import java.security.cert.X509Certificate;
  50 import java.security.cert.CertificateFactory;
  51 import java.security.cert.CertificateException;
  52 
  53 import java.security.interfaces.*;
  54 import java.security.spec.*;
  55 
  56 import javax.crypto.SecretKey;
  57 import javax.crypto.interfaces.*;
  58 
  59 import javax.security.auth.x500.X500Principal;
  60 import javax.security.auth.login.LoginException;
  61 import javax.security.auth.callback.Callback;
  62 import javax.security.auth.callback.PasswordCallback;
  63 import javax.security.auth.callback.CallbackHandler;
  64 import javax.security.auth.callback.UnsupportedCallbackException;
  65 
  66 import sun.security.util.Debug;
  67 import sun.security.util.DerValue;
  68 import sun.security.util.ECUtil;
  69 
  70 import sun.security.pkcs11.Secmod.*;
  71 import static sun.security.pkcs11.P11Util.*;
  72 
  73 import sun.security.pkcs11.wrapper.*;
  74 import static sun.security.pkcs11.wrapper.PKCS11Constants.*;
  75 
  76 import sun.security.rsa.RSAKeyFactory;
  77 
  78 final class P11KeyStore extends KeyStoreSpi {
  79 
  80     private static final CK_ATTRIBUTE ATTR_CLASS_CERT =
  81                         new CK_ATTRIBUTE(CKA_CLASS, CKO_CERTIFICATE);
  82     private static final CK_ATTRIBUTE ATTR_CLASS_PKEY =
  83                         new CK_ATTRIBUTE(CKA_CLASS, CKO_PRIVATE_KEY);
  84     private static final CK_ATTRIBUTE ATTR_CLASS_SKEY =
  85                         new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY);
  86 
  87     private static final CK_ATTRIBUTE ATTR_X509_CERT_TYPE =
  88                         new CK_ATTRIBUTE(CKA_CERTIFICATE_TYPE, CKC_X_509);
  89 
  90     private static final CK_ATTRIBUTE ATTR_TOKEN_TRUE =
  91                         new CK_ATTRIBUTE(CKA_TOKEN, true);
  92 
  93     // XXX for testing purposes only
  94     //  - NSS doesn&#39;t support persistent secret keys
  95     //    (key type gets mangled if secret key is a token key)
  96     //  - if debug is turned on, then this is set to false
  97     private static CK_ATTRIBUTE ATTR_SKEY_TOKEN_TRUE = ATTR_TOKEN_TRUE;
  98 
  99     private static final CK_ATTRIBUTE ATTR_TRUSTED_TRUE =
 100                         new CK_ATTRIBUTE(CKA_TRUSTED, true);
 101     private static final CK_ATTRIBUTE ATTR_PRIVATE_TRUE =
 102                         new CK_ATTRIBUTE(CKA_PRIVATE, true);
 103 
 104     private static final long NO_HANDLE = -1;
 105     private static final long FINDOBJECTS_MAX = 100;
 106     private static final String ALIAS_SEP = &quot;/&quot;;
 107 
 108     private static final boolean NSS_TEST = false;
 109     private static final Debug debug =
 110                         Debug.getInstance(&quot;pkcs11keystore&quot;);
 111     private static boolean CKA_TRUSTED_SUPPORTED = true;
 112 
 113     private final Token token;
 114 
 115     // If multiple certs are found to share the same CKA_LABEL
 116     // at load time (NSS-style keystore), then the keystore is read
 117     // and the unique keystore aliases are mapped to the entries.
 118     // However, write capabilities are disabled.
 119     private boolean writeDisabled = false;
 120 
 121     // Map of unique keystore aliases to entries in the token
 122     private HashMap&lt;String, AliasInfo&gt; aliasMap;
 123 
 124     // whether to use NSS Secmod info for trust attributes
 125     private final boolean useSecmodTrust;
 126 
 127     // if useSecmodTrust == true, which type of trust we are interested in
 128     private Secmod.TrustType nssTrustType;
 129 
 130     /**
 131      * The underlying token may contain multiple certs belonging to the
 132      * same &quot;personality&quot; (for example, a signing cert and encryption cert),
 133      * all sharing the same CKA_LABEL.  These must be resolved
 134      * into unique keystore aliases.
 135      *
 136      * In addition, private keys and certs may not have a CKA_LABEL.
 137      * It is assumed that a private key and corresponding certificate
 138      * share the same CKA_ID, and that the CKA_ID is unique across the token.
 139      * The CKA_ID may not be human-readable.
 140      * These pairs must be resolved into unique keystore aliases.
 141      *
 142      * Furthermore, secret keys are assumed to have a CKA_LABEL
 143      * unique across the entire token.
 144      *
 145      * When the KeyStore is loaded, instances of this class are
 146      * created to represent the private keys/secret keys/certs
 147      * that reside on the token.
 148      */
 149     private static class AliasInfo {
 150 
 151         // CKA_CLASS - entry type
 152         private CK_ATTRIBUTE type = null;
 153 
 154         // CKA_LABEL of cert and secret key
 155         private String label = null;
 156 
 157         // CKA_ID of the private key/cert pair
 158         private byte[] id = null;
 159 
 160         // CKA_TRUSTED - true if cert is trusted
 161         private boolean trusted = false;
 162 
 163         // either end-entity cert or trusted cert depending on &#39;type&#39;
 164         private X509Certificate cert = null;
 165 
 166         // chain
 167         private X509Certificate[] chain = null;
 168 
 169         // true if CKA_ID for private key and cert match up
 170         private boolean matched = false;
 171 
 172         // SecretKeyEntry
 173         public AliasInfo(String label) {
 174             this.type = ATTR_CLASS_SKEY;
 175             this.label = label;
 176         }
 177 
 178         // PrivateKeyEntry
 179         public AliasInfo(String label,
 180                         byte[] id,
 181                         boolean trusted,
 182                         X509Certificate cert) {
 183             this.type = ATTR_CLASS_PKEY;
 184             this.label = label;
 185             this.id = id;
 186             this.trusted = trusted;
 187             this.cert = cert;
 188         }
 189 
 190         public String toString() {
 191             StringBuilder sb = new StringBuilder();
 192             if (type == ATTR_CLASS_PKEY) {
 193                 sb.append(&quot;\ttype=[private key]\n&quot;);
 194             } else if (type == ATTR_CLASS_SKEY) {
 195                 sb.append(&quot;\ttype=[secret key]\n&quot;);
 196             } else if (type == ATTR_CLASS_CERT) {
 197                 sb.append(&quot;\ttype=[trusted cert]\n&quot;);
 198             }
 199             sb.append(&quot;\tlabel=[&quot; + label + &quot;]\n&quot;);
 200             if (id == null) {
 201                 sb.append(&quot;\tid=[null]\n&quot;);
 202             } else {
 203                 sb.append(&quot;\tid=&quot; + P11KeyStore.getID(id) + &quot;\n&quot;);
 204             }
 205             sb.append(&quot;\ttrusted=[&quot; + trusted + &quot;]\n&quot;);
 206             sb.append(&quot;\tmatched=[&quot; + matched + &quot;]\n&quot;);
 207             if (cert == null) {
 208                 sb.append(&quot;\tcert=[null]\n&quot;);
 209             } else {
 210                 sb.append(&quot;\tcert=[\tsubject: &quot; +
 211                         cert.getSubjectX500Principal() +
 212                         &quot;\n\t\tissuer: &quot; +
 213                         cert.getIssuerX500Principal() +
 214                         &quot;\n\t\tserialNum: &quot; +
 215                         cert.getSerialNumber().toString() +
 216                         &quot;]&quot;);
 217             }
 218             return sb.toString();
 219         }
 220     }
 221 
 222     /**
 223      * callback handler for passing password to Provider.login method
 224      */
 225     private static class PasswordCallbackHandler implements CallbackHandler {
 226 
 227         private char[] password;
 228 
 229         private PasswordCallbackHandler(char[] password) {
 230             if (password != null) {
 231                 this.password = password.clone();
 232             }
 233         }
 234 
 235         public void handle(Callback[] callbacks)
 236                 throws IOException, UnsupportedCallbackException {
 237             if (!(callbacks[0] instanceof PasswordCallback)) {
 238                 throw new UnsupportedCallbackException(callbacks[0]);
 239             }
 240             PasswordCallback pc = (PasswordCallback)callbacks[0];
 241             pc.setPassword(password);  // this clones the password if not null
 242         }
 243 
 244         @SuppressWarnings(&quot;deprecation&quot;)
 245         protected void finalize() throws Throwable {
 246             if (password != null) {
 247                 Arrays.fill(password, &#39; &#39;);
 248             }
 249             super.finalize();
 250         }
 251     }
 252 
 253     /**
 254      * getTokenObject return value.
 255      *
 256      * if object is not found, type is set to null.
 257      * otherwise, type is set to the requested type.
 258      */
 259     private static class THandle {
 260         private final long handle;              // token object handle
 261         private final CK_ATTRIBUTE type;        // CKA_CLASS
 262 
 263         private THandle(long handle, CK_ATTRIBUTE type) {
 264             this.handle = handle;
 265             this.type = type;
 266         }
 267     }
 268 
 269     P11KeyStore(Token token) {
 270         this.token = token;
 271         this.useSecmodTrust = token.provider.nssUseSecmodTrust;
 272     }
 273 
 274     /**
 275      * Returns the key associated with the given alias.
 276      * The key must have been associated with
 277      * the alias by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;,
 278      * or by a call to &lt;code&gt;setEntry&lt;/code&gt; with a
 279      * &lt;code&gt;PrivateKeyEntry&lt;/code&gt; or &lt;code&gt;SecretKeyEntry&lt;/code&gt;.
 280      *
 281      * @param alias the alias name
 282      * @param password the password, which must be &lt;code&gt;null&lt;/code&gt;
 283      *
 284      * @return the requested key, or null if the given alias does not exist
 285      * or does not identify a key-related entry.
 286      *
 287      * @exception NoSuchAlgorithmException if the algorithm for recovering the
 288      * key cannot be found
 289      * @exception UnrecoverableKeyException if the key cannot be recovered
 290      */
 291     public synchronized Key engineGetKey(String alias, char[] password)
 292                 throws NoSuchAlgorithmException, UnrecoverableKeyException {
 293 
 294         token.ensureValid();
 295         if (password != null &amp;&amp; !token.config.getKeyStoreCompatibilityMode()) {
 296             throw new NoSuchAlgorithmException(&quot;password must be null&quot;);
 297         }
 298 
 299         AliasInfo aliasInfo = aliasMap.get(alias);
 300         if (aliasInfo == null || aliasInfo.type == ATTR_CLASS_CERT) {
 301             return null;
 302         }
 303 
 304         Session session = null;
 305         try {
 306             session = token.getOpSession();
 307 
 308             if (aliasInfo.type == ATTR_CLASS_PKEY) {
 309                 THandle h = getTokenObject(session,
 310                                         aliasInfo.type,
 311                                         aliasInfo.id,
 312                                         null);
 313                 if (h.type == ATTR_CLASS_PKEY) {
 314                     return loadPkey(session, h.handle);
 315                 }
 316             } else {
 317                 THandle h = getTokenObject(session,
 318                                         ATTR_CLASS_SKEY,
 319                                         null,
 320                                         alias);
 321                 if (h.type == ATTR_CLASS_SKEY) {
 322                     return loadSkey(session, h.handle);
 323                 }
 324             }
 325 
 326             // did not find anything
 327             return null;
 328         } catch (PKCS11Exception | KeyStoreException e) {
 329             throw new ProviderException(e);
 330         } finally {
 331             token.releaseSession(session);
 332         }
 333     }
 334 
 335     /**
 336      * Returns the certificate chain associated with the given alias.
 337      * The certificate chain must have been associated with the alias
 338      * by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;,
 339      * or by a call to &lt;code&gt;setEntry&lt;/code&gt; with a
 340      * &lt;code&gt;PrivateKeyEntry&lt;/code&gt;.
 341      *
 342      * @param alias the alias name
 343      *
 344      * @return the certificate chain (ordered with the user&#39;s certificate first
 345      * and the root certificate authority last), or null if the given alias
 346      * does not exist or does not contain a certificate chain
 347      */
 348     public synchronized Certificate[] engineGetCertificateChain(String alias) {
 349 
 350         token.ensureValid();
 351 
 352         AliasInfo aliasInfo = aliasMap.get(alias);
 353         if (aliasInfo == null || aliasInfo.type != ATTR_CLASS_PKEY) {
 354             return null;
 355         }
 356         return aliasInfo.chain;
 357     }
 358 
 359     /**
 360      * Returns the certificate associated with the given alias.
 361      *
 362      * &lt;p&gt; If the given alias name identifies an entry
 363      * created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;,
 364      * or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a
 365      * &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;,
 366      * then the trusted certificate contained in that entry is returned.
 367      *
 368      * &lt;p&gt; If the given alias name identifies an entry
 369      * created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;,
 370      * or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a
 371      * &lt;code&gt;PrivateKeyEntry&lt;/code&gt;,
 372      * then the first element of the certificate chain in that entry
 373      * (if a chain exists) is returned.
 374      *
 375      * @param alias the alias name
 376      *
 377      * @return the certificate, or null if the given alias does not exist or
 378      * does not contain a certificate.
 379      */
 380     public synchronized Certificate engineGetCertificate(String alias) {
 381         token.ensureValid();
 382 
 383         AliasInfo aliasInfo = aliasMap.get(alias);
 384         if (aliasInfo == null) {
 385             return null;
 386         }
 387         return aliasInfo.cert;
 388     }
 389 
 390     /**
 391      * Returns the creation date of the entry identified by the given alias.
 392      *
 393      * @param alias the alias name
 394      *
 395      * @return the creation date of this entry, or null if the given alias does
 396      * not exist
 397      */
 398     public Date engineGetCreationDate(String alias) {
 399         token.ensureValid();
 400         throw new ProviderException(new UnsupportedOperationException());
 401     }
 402 
 403     /**
 404      * Assigns the given key to the given alias, protecting it with the given
 405      * password.
 406      *
 407      * &lt;p&gt;If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
 408      * it must be accompanied by a certificate chain certifying the
 409      * corresponding public key.
 410      *
 411      * &lt;p&gt;If the given alias already exists, the keystore information
 412      * associated with it is overridden by the given key (and possibly
 413      * certificate chain).
 414      *
 415      * @param alias the alias name
 416      * @param key the key to be associated with the alias
 417      * @param password the password to protect the key
 418      * @param chain the certificate chain for the corresponding public
 419      * key (only required if the given key is of type
 420      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
 421      *
 422      * @exception KeyStoreException if the given key cannot be protected, or
 423      * this operation fails for some other reason
 424      */
 425     public synchronized void engineSetKeyEntry(String alias, Key key,
 426                                    char[] password,
 427                                    Certificate[] chain)
 428                 throws KeyStoreException {
 429 
 430         token.ensureValid();
 431         checkWrite();
 432 
 433         if (!(key instanceof PrivateKey) &amp;&amp; !(key instanceof SecretKey)) {
 434             throw new KeyStoreException(&quot;key must be PrivateKey or SecretKey&quot;);
 435         } else if (key instanceof PrivateKey &amp;&amp; chain == null) {
 436             throw new KeyStoreException
 437                 (&quot;PrivateKey must be accompanied by non-null chain&quot;);
 438         } else if (key instanceof SecretKey &amp;&amp; chain != null) {
 439             throw new KeyStoreException
 440                 (&quot;SecretKey must be accompanied by null chain&quot;);
 441         } else if (password != null &amp;&amp;
 442                     !token.config.getKeyStoreCompatibilityMode()) {
 443             throw new KeyStoreException(&quot;Password must be null&quot;);
 444         }
 445 
 446         KeyStore.Entry entry = null;
 447         try {
 448             if (key instanceof PrivateKey) {
 449                 entry = new KeyStore.PrivateKeyEntry((PrivateKey)key, chain);
 450             } else if (key instanceof SecretKey) {
 451                 entry = new KeyStore.SecretKeyEntry((SecretKey)key);
 452             }
 453         } catch (NullPointerException | IllegalArgumentException e) {
 454             throw new KeyStoreException(e);
 455         }
 456         engineSetEntry(alias, entry, new KeyStore.PasswordProtection(password));
 457     }
 458 
 459     /**
 460      * Assigns the given key (that has already been protected) to the given
 461      * alias.
 462      *
 463      * &lt;p&gt;If the protected key is of type
 464      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
 465      * it must be accompanied by a certificate chain certifying the
 466      * corresponding public key.
 467      *
 468      * &lt;p&gt;If the given alias already exists, the keystore information
 469      * associated with it is overridden by the given key (and possibly
 470      * certificate chain).
 471      *
 472      * @param alias the alias name
 473      * @param key the key (in protected format) to be associated with the alias
 474      * @param chain the certificate chain for the corresponding public
 475      * key (only useful if the protected key is of type
 476      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
 477      *
 478      * @exception KeyStoreException if this operation fails.
 479      */
 480     public void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain)
 481                 throws KeyStoreException {
 482         token.ensureValid();
 483         throw new ProviderException(new UnsupportedOperationException());
 484     }
 485 
 486     /**
 487      * Assigns the given certificate to the given alias.
 488      *
 489      * &lt;p&gt; If the given alias identifies an existing entry
 490      * created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;,
 491      * or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a
 492      * &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;,
 493      * the trusted certificate in the existing entry
 494      * is overridden by the given certificate.
 495      *
 496      * @param alias the alias name
 497      * @param cert the certificate
 498      *
 499      * @exception KeyStoreException if the given alias already exists and does
 500      * not identify an entry containing a trusted certificate,
 501      * or this operation fails for some other reason.
 502      */
 503     public synchronized void engineSetCertificateEntry
 504         (String alias, Certificate cert) throws KeyStoreException {
 505 
 506         token.ensureValid();
 507         checkWrite();
 508 
 509         if (cert == null) {
 510             throw new KeyStoreException(&quot;invalid null certificate&quot;);
 511         }
 512 
 513         KeyStore.Entry entry = null;
 514         entry = new KeyStore.TrustedCertificateEntry(cert);
 515         engineSetEntry(alias, entry, null);
 516     }
 517 
 518     /**
 519      * Deletes the entry identified by the given alias from this keystore.
 520      *
 521      * @param alias the alias name
 522      *
 523      * @exception KeyStoreException if the entry cannot be removed.
 524      */
 525     public synchronized void engineDeleteEntry(String alias)
 526                 throws KeyStoreException {
 527         token.ensureValid();
 528 
 529         if (token.isWriteProtected()) {
 530             throw new KeyStoreException(&quot;token write-protected&quot;);
 531         }
 532         checkWrite();
 533         deleteEntry(alias);
 534     }
 535 
 536     /**
 537      * XXX - not sure whether to keep this
 538      */
 539     private boolean deleteEntry(String alias) throws KeyStoreException {
 540         AliasInfo aliasInfo = aliasMap.get(alias);
 541         if (aliasInfo != null) {
 542 
 543             aliasMap.remove(alias);
 544 
 545             try {
 546                 if (aliasInfo.type == ATTR_CLASS_CERT) {
 547                     // trusted certificate entry
 548                     return destroyCert(aliasInfo.id);
 549                 } else if (aliasInfo.type == ATTR_CLASS_PKEY) {
 550                     // private key entry
 551                     return destroyPkey(aliasInfo.id) &amp;&amp;
 552                                 destroyChain(aliasInfo.id);
 553                 } else if (aliasInfo.type == ATTR_CLASS_SKEY) {
 554                     // secret key entry
 555                     return destroySkey(alias);
 556                 } else {
 557                     throw new KeyStoreException(&quot;unexpected entry type&quot;);
 558                 }
 559             } catch (PKCS11Exception | CertificateException e) {
 560                 throw new KeyStoreException(e);
 561             }
 562         }
 563         return false;
 564     }
 565 
 566     /**
 567      * Lists all the alias names of this keystore.
 568      *
 569      * @return enumeration of the alias names
 570      */
 571     public synchronized Enumeration&lt;String&gt; engineAliases() {
 572         token.ensureValid();
 573 
 574         // don&#39;t want returned enumeration to iterate off actual keySet -
 575         // otherwise applications that iterate and modify the keystore
 576         // may run into concurrent modification problems
 577         return Collections.enumeration(new HashSet&lt;String&gt;(aliasMap.keySet()));
 578     }
 579 
 580     /**
 581      * Checks if the given alias exists in this keystore.
 582      *
 583      * @param alias the alias name
 584      *
 585      * @return true if the alias exists, false otherwise
 586      */
 587     public synchronized boolean engineContainsAlias(String alias) {
 588         token.ensureValid();
 589         return aliasMap.containsKey(alias);
 590     }
 591 
 592     /**
 593      * Retrieves the number of entries in this keystore.
 594      *
 595      * @return the number of entries in this keystore
 596      */
 597     public synchronized int engineSize() {
 598         token.ensureValid();
 599         return aliasMap.size();
 600     }
 601 
 602     /**
 603      * Returns true if the entry identified by the given alias
 604      * was created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;,
 605      * or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a
 606      * &lt;code&gt;PrivateKeyEntry&lt;/code&gt; or a &lt;code&gt;SecretKeyEntry&lt;/code&gt;.
 607      *
 608      * @param alias the alias for the keystore entry to be checked
 609      *
 610      * @return true if the entry identified by the given alias is a
 611      * key-related, false otherwise.
 612      */
 613     public synchronized boolean engineIsKeyEntry(String alias) {
 614         token.ensureValid();
 615 
 616         AliasInfo aliasInfo = aliasMap.get(alias);
 617         if (aliasInfo == null || aliasInfo.type == ATTR_CLASS_CERT) {
 618             return false;
 619         }
 620         return true;
 621     }
 622 
 623     /**
 624      * Returns true if the entry identified by the given alias
 625      * was created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;,
 626      * or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a
 627      * &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;.
 628      *
 629      * @param alias the alias for the keystore entry to be checked
 630      *
 631      * @return true if the entry identified by the given alias contains a
 632      * trusted certificate, false otherwise.
 633      */
 634     public synchronized boolean engineIsCertificateEntry(String alias) {
 635         token.ensureValid();
 636 
 637         AliasInfo aliasInfo = aliasMap.get(alias);
 638         if (aliasInfo == null || aliasInfo.type != ATTR_CLASS_CERT) {
 639             return false;
 640         }
 641         return true;
 642     }
 643 
 644     /**
 645      * Returns the (alias) name of the first keystore entry whose certificate
 646      * matches the given certificate.
 647      *
 648      * &lt;p&gt;This method attempts to match the given certificate with each
 649      * keystore entry. If the entry being considered was
 650      * created by a call to &lt;code&gt;setCertificateEntry&lt;/code&gt;,
 651      * or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a
 652      * &lt;code&gt;TrustedCertificateEntry&lt;/code&gt;,
 653      * then the given certificate is compared to that entry&#39;s certificate.
 654      *
 655      * &lt;p&gt; If the entry being considered was
 656      * created by a call to &lt;code&gt;setKeyEntry&lt;/code&gt;,
 657      * or created by a call to &lt;code&gt;setEntry&lt;/code&gt; with a
 658      * &lt;code&gt;PrivateKeyEntry&lt;/code&gt;,
 659      * then the given certificate is compared to the first
 660      * element of that entry&#39;s certificate chain.
 661      *
 662      * @param cert the certificate to match with.
 663      *
 664      * @return the alias name of the first entry with matching certificate,
 665      * or null if no such entry exists in this keystore.
 666      */
 667     public synchronized String engineGetCertificateAlias(Certificate cert) {
 668         token.ensureValid();
 669         Enumeration&lt;String&gt; e = engineAliases();
 670         while (e.hasMoreElements()) {
 671             String alias = e.nextElement();
 672             Certificate tokenCert = engineGetCertificate(alias);
 673             if (tokenCert != null &amp;&amp; tokenCert.equals(cert)) {
 674                 return alias;
 675             }
 676         }
 677         return null;
 678     }
 679 
 680     /**
 681      * engineStore currently is a No-op.
 682      * Entries are stored to the token during engineSetEntry
 683      *
 684      * @param stream this must be &lt;code&gt;null&lt;/code&gt;
 685      * @param password this must be &lt;code&gt;null&lt;/code&gt;
 686      */
 687     public synchronized void engineStore(OutputStream stream, char[] password)
 688         throws IOException, NoSuchAlgorithmException, CertificateException {
 689         token.ensureValid();
 690         if (stream != null &amp;&amp; !token.config.getKeyStoreCompatibilityMode()) {
 691             throw new IOException(&quot;output stream must be null&quot;);
 692         }
 693 
 694         if (password != null &amp;&amp; !token.config.getKeyStoreCompatibilityMode()) {
 695             throw new IOException(&quot;password must be null&quot;);
 696         }
 697     }
 698 
 699     /**
 700      * engineStore currently is a No-op.
 701      * Entries are stored to the token during engineSetEntry
 702      *
 703      * @param param this must be &lt;code&gt;null&lt;/code&gt;
 704      *
 705      * @exception IllegalArgumentException if the given
 706      *          &lt;code&gt;KeyStore.LoadStoreParameter&lt;/code&gt;
 707      *          input is not &lt;code&gt;null&lt;/code&gt;
 708      */
 709     public synchronized void engineStore(KeyStore.LoadStoreParameter param)
 710         throws IOException, NoSuchAlgorithmException, CertificateException {
 711         token.ensureValid();
 712         if (param != null) {
 713             throw new IllegalArgumentException
 714                 (&quot;LoadStoreParameter must be null&quot;);
 715         }
 716     }
 717 
 718     /**
 719      * Loads the keystore.
 720      *
 721      * @param stream the input stream, which must be &lt;code&gt;null&lt;/code&gt;
 722      * @param password the password used to unlock the keystore,
 723      *          or &lt;code&gt;null&lt;/code&gt; if the token supports a
 724      *          CKF_PROTECTED_AUTHENTICATION_PATH
 725      *
 726      * @exception IOException if the given &lt;code&gt;stream&lt;/code&gt; is not
 727      *          &lt;code&gt;null&lt;/code&gt;, if the token supports a
 728      *          CKF_PROTECTED_AUTHENTICATION_PATH and a non-null
 729      *          password is given, of if the token login operation failed
 730      */
 731     public synchronized void engineLoad(InputStream stream, char[] password)
 732         throws IOException, NoSuchAlgorithmException, CertificateException {
 733 
 734         token.ensureValid();
 735 
 736         if (NSS_TEST) {
 737             ATTR_SKEY_TOKEN_TRUE = new CK_ATTRIBUTE(CKA_TOKEN, false);
 738         }
 739 
 740         if (stream != null &amp;&amp; !token.config.getKeyStoreCompatibilityMode()) {
 741             throw new IOException(&quot;input stream must be null&quot;);
 742         }
 743 
 744         if (useSecmodTrust) {
 745             nssTrustType = Secmod.TrustType.ALL;
 746         }
 747 
 748         try {
 749             if (password == null) {
 750                 login(null);
 751             } else {
 752                 login(new PasswordCallbackHandler(password));
 753             }
 754         } catch(LoginException e) {
 755             Throwable cause = e.getCause();
 756             if (cause instanceof PKCS11Exception) {
 757                 PKCS11Exception pe = (PKCS11Exception) cause;
 758                 if (pe.getErrorCode() == CKR_PIN_INCORRECT) {
 759                     // if password is wrong, the cause of the IOException
 760                     // should be an UnrecoverableKeyException
 761                     throw new IOException(&quot;load failed&quot;,
 762                             new UnrecoverableKeyException().initCause(e));
 763                 }
 764             }
 765             throw new IOException(&quot;load failed&quot;, e);
 766         }
 767 
 768         try {
 769             if (mapLabels() == true) {
 770                 // CKA_LABELs are shared by multiple certs
 771                 writeDisabled = true;
 772             }
 773             if (debug != null) {
 774                 dumpTokenMap();
 775                 debug.println(&quot;P11KeyStore load. Entry count: &quot; +
 776                         aliasMap.size());
 777             }
 778         } catch (KeyStoreException | PKCS11Exception e) {
 779             throw new IOException(&quot;load failed&quot;, e);
 780         }
 781     }
 782 
 783     /**
 784      * Loads the keystore using the given
 785      * &lt;code&gt;KeyStore.LoadStoreParameter&lt;/code&gt;.
 786      *
 787      * &lt;p&gt; The &lt;code&gt;LoadStoreParameter.getProtectionParameter()&lt;/code&gt;
 788      * method is expected to return a &lt;code&gt;KeyStore.PasswordProtection&lt;/code&gt;
 789      * object.  The password is retrieved from that object and used
 790      * to unlock the PKCS#11 token.
 791      *
 792      * &lt;p&gt; If the token supports a CKF_PROTECTED_AUTHENTICATION_PATH
 793      * then the provided password must be &lt;code&gt;null&lt;/code&gt;.
 794      *
 795      * @param param the &lt;code&gt;KeyStore.LoadStoreParameter&lt;/code&gt;
 796      *
 797      * @exception IllegalArgumentException if the given
 798      *          &lt;code&gt;KeyStore.LoadStoreParameter&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
 799      *          or if that parameter returns a &lt;code&gt;null&lt;/code&gt;
 800      *          &lt;code&gt;ProtectionParameter&lt;/code&gt; object.
 801      *          input is not recognized
 802      * @exception IOException if the token supports a
 803      *          CKF_PROTECTED_AUTHENTICATION_PATH and the provided password
 804      *          is non-null, or if the token login operation fails
 805      */
 806     public synchronized void engineLoad(KeyStore.LoadStoreParameter param)
 807                 throws IOException, NoSuchAlgorithmException,
 808                 CertificateException {
 809 
 810         token.ensureValid();
 811 
 812         if (NSS_TEST) {
 813             ATTR_SKEY_TOKEN_TRUE = new CK_ATTRIBUTE(CKA_TOKEN, false);
 814         }
 815 
 816         // if caller wants to pass a NULL password,
 817         // force it to pass a non-NULL PasswordProtection that returns
 818         // a NULL password
 819 
 820         if (param == null) {
 821             throw new IllegalArgumentException
 822                         (&quot;invalid null LoadStoreParameter&quot;);
 823         }
 824         if (useSecmodTrust) {
 825             if (param instanceof Secmod.KeyStoreLoadParameter) {
 826                 nssTrustType = ((Secmod.KeyStoreLoadParameter)param).getTrustType();
 827             } else {
 828                 nssTrustType = Secmod.TrustType.ALL;
 829             }
 830         }
 831 
 832         CallbackHandler handler;
 833         KeyStore.ProtectionParameter pp = param.getProtectionParameter();
 834         if (pp instanceof PasswordProtection) {
 835             char[] password = ((PasswordProtection)pp).getPassword();
 836             if (password == null) {
 837                 handler = null;
 838             } else {
 839                 handler = new PasswordCallbackHandler(password);
 840             }
 841         } else if (pp instanceof CallbackHandlerProtection) {
 842             handler = ((CallbackHandlerProtection)pp).getCallbackHandler();
 843         } else {
 844             throw new IllegalArgumentException
 845                         (&quot;ProtectionParameter must be either &quot; +
 846                         &quot;PasswordProtection or CallbackHandlerProtection&quot;);
 847         }
 848 
 849         try {
 850             login(handler);
 851             if (mapLabels() == true) {
 852                 // CKA_LABELs are shared by multiple certs
 853                 writeDisabled = true;
 854             }
 855             if (debug != null) {
 856                 dumpTokenMap();
 857             }
 858         } catch (LoginException | KeyStoreException | PKCS11Exception e) {
 859             throw new IOException(&quot;load failed&quot;, e);
 860         }
 861     }
 862 
 863     private void login(CallbackHandler handler) throws LoginException {
 864         if ((token.tokenInfo.flags &amp; CKF_PROTECTED_AUTHENTICATION_PATH) == 0) {
 865             token.provider.login(null, handler);
 866         } else {
 867             // token supports protected authentication path
 868             // (external pin-pad, for example)
 869             if (handler != null &amp;&amp;
 870                 !token.config.getKeyStoreCompatibilityMode()) {
 871                 throw new LoginException(&quot;can not specify password if token &quot; +
 872                                 &quot;supports protected authentication path&quot;);
 873             }
 874 
 875             // must rely on application-set or default handler
 876             // if one is necessary
 877             token.provider.login(null, null);
 878         }
 879     }
 880 
 881     /**
 882      * Get a &lt;code&gt;KeyStore.Entry&lt;/code&gt; for the specified alias
 883      *
 884      * @param alias get the &lt;code&gt;KeyStore.Entry&lt;/code&gt; for this alias
 885      * @param protParam this must be &lt;code&gt;null&lt;/code&gt;
 886      *
 887      * @return the &lt;code&gt;KeyStore.Entry&lt;/code&gt; for the specified alias,
 888      *          or &lt;code&gt;null&lt;/code&gt; if there is no such entry
 889      *
 890      * @exception KeyStoreException if the operation failed
 891      * @exception NoSuchAlgorithmException if the algorithm for recovering the
 892      *          entry cannot be found
 893      * @exception UnrecoverableEntryException if the specified
 894      *          &lt;code&gt;protParam&lt;/code&gt; were insufficient or invalid
 895      *
 896      * @since 1.5
 897      */
 898     public synchronized KeyStore.Entry engineGetEntry(String alias,
 899                         KeyStore.ProtectionParameter protParam)
 900                 throws KeyStoreException, NoSuchAlgorithmException,
 901                 UnrecoverableEntryException {
 902 
 903         token.ensureValid();
 904 
 905         if (protParam != null &amp;&amp;
 906             protParam instanceof KeyStore.PasswordProtection &amp;&amp;
 907             ((KeyStore.PasswordProtection)protParam).getPassword() != null &amp;&amp;
 908             !token.config.getKeyStoreCompatibilityMode()) {
 909             throw new KeyStoreException(&quot;ProtectionParameter must be null&quot;);
 910         }
 911 
 912         AliasInfo aliasInfo = aliasMap.get(alias);
 913         if (aliasInfo == null) {
 914             if (debug != null) {
 915                 debug.println(&quot;engineGetEntry did not find alias [&quot; +
 916                         alias +
 917                         &quot;] in map&quot;);
 918             }
 919             return null;
 920         }
 921 
 922         Session session = null;
 923         try {
 924             session = token.getOpSession();
 925 
 926             if (aliasInfo.type == ATTR_CLASS_CERT) {
 927                 // trusted certificate entry
 928                 if (debug != null) {
 929                     debug.println(&quot;engineGetEntry found trusted cert entry&quot;);
 930                 }
 931                 return new KeyStore.TrustedCertificateEntry(aliasInfo.cert);
 932             } else if (aliasInfo.type == ATTR_CLASS_SKEY) {
 933                 // secret key entry
 934                 if (debug != null) {
 935                     debug.println(&quot;engineGetEntry found secret key entry&quot;);
 936                 }
 937 
 938                 THandle h = getTokenObject
 939                         (session, ATTR_CLASS_SKEY, null, aliasInfo.label);
 940                 if (h.type != ATTR_CLASS_SKEY) {
 941                     throw new KeyStoreException
 942                         (&quot;expected but could not find secret key&quot;);
 943                 } else {
 944                     SecretKey skey = loadSkey(session, h.handle);
 945                     return new KeyStore.SecretKeyEntry(skey);
 946                 }
 947             } else {
 948                 // private key entry
 949                 if (debug != null) {
 950                     debug.println(&quot;engineGetEntry found private key entry&quot;);
 951                 }
 952 
 953                 THandle h = getTokenObject
 954                         (session, ATTR_CLASS_PKEY, aliasInfo.id, null);
 955                 if (h.type != ATTR_CLASS_PKEY) {
 956                     throw new KeyStoreException
 957                         (&quot;expected but could not find private key&quot;);
 958                 } else {
 959                     PrivateKey pkey = loadPkey(session, h.handle);
 960                     Certificate[] chain = aliasInfo.chain;
 961                     if ((pkey != null) &amp;&amp; (chain != null)) {
 962                         return new KeyStore.PrivateKeyEntry(pkey, chain);
 963                     } else {
 964                         if (debug != null) {
 965                             debug.println
 966                                 (&quot;engineGetEntry got null cert chain or private key&quot;);
 967                         }
 968                     }
 969                 }
 970             }
 971             return null;
 972         } catch (PKCS11Exception pe) {
 973             throw new KeyStoreException(pe);
 974         } finally {
 975             token.releaseSession(session);
 976         }
 977     }
 978 
 979     /**
 980      * Save a &lt;code&gt;KeyStore.Entry&lt;/code&gt; under the specified alias.
 981      *
 982      * &lt;p&gt; If an entry already exists for the specified alias,
 983      * it is overridden.
 984      *
 985      * &lt;p&gt; This KeyStore implementation only supports the standard
 986      * entry types, and only supports X509Certificates in
 987      * TrustedCertificateEntries.  Also, this implementation does not support
 988      * protecting entries using a different password
 989      * from the one used for token login.
 990      *
 991      * &lt;p&gt; Entries are immediately stored on the token.
 992      *
 993      * @param alias save the &lt;code&gt;KeyStore.Entry&lt;/code&gt; under this alias
 994      * @param entry the &lt;code&gt;Entry&lt;/code&gt; to save
 995      * @param protParam this must be &lt;code&gt;null&lt;/code&gt;
 996      *
 997      * @exception KeyStoreException if this operation fails
 998      *
 999      * @since 1.5
1000      */
1001     public synchronized void engineSetEntry(String alias, KeyStore.Entry entry,
1002                         KeyStore.ProtectionParameter protParam)
1003                 throws KeyStoreException {
1004 
1005         token.ensureValid();
1006         checkWrite();
1007 
1008         if (protParam != null &amp;&amp;
1009             protParam instanceof KeyStore.PasswordProtection &amp;&amp;
1010             ((KeyStore.PasswordProtection)protParam).getPassword() != null &amp;&amp;
1011             !token.config.getKeyStoreCompatibilityMode()) {
1012             throw new KeyStoreException(new UnsupportedOperationException
1013                                 (&quot;ProtectionParameter must be null&quot;));
1014         }
1015 
1016         if (token.isWriteProtected()) {
1017             throw new KeyStoreException(&quot;token write-protected&quot;);
1018         }
1019 
1020         if (entry instanceof KeyStore.TrustedCertificateEntry) {
1021 
1022             if (useSecmodTrust == false) {
1023                 // PKCS #11 does not allow app to modify trusted certs -
1024                 throw new KeyStoreException(new UnsupportedOperationException
1025                                     (&quot;trusted certificates may only be set by &quot; +
1026                                     &quot;token initialization application&quot;));
1027             }
1028             Secmod.Module module = token.provider.nssModule;
1029             if ((module.type != ModuleType.KEYSTORE) &amp;&amp; (module.type != ModuleType.FIPS)) {
1030                 // XXX allow TRUSTANCHOR module
1031                 throw new KeyStoreException(&quot;Trusted certificates can only be &quot;
1032                     + &quot;added to the NSS KeyStore module&quot;);
1033             }
1034             Certificate cert = ((TrustedCertificateEntry)entry).getTrustedCertificate();
1035             if (cert instanceof X509Certificate == false) {
1036                 throw new KeyStoreException(&quot;Certificate must be an X509Certificate&quot;);
1037             }
1038             X509Certificate xcert = (X509Certificate)cert;
1039             AliasInfo info = aliasMap.get(alias);
1040             if (info != null) {
1041                 // XXX try to update
1042                 deleteEntry(alias);
1043             }
1044             try {
1045                 storeCert(alias, xcert);
1046                 module.setTrust(token, xcert);
1047                 mapLabels();
1048             } catch (PKCS11Exception | CertificateException e) {
1049                 throw new KeyStoreException(e);
1050             }
1051 
1052         } else {
1053 
1054             if (entry instanceof KeyStore.PrivateKeyEntry) {
1055 
1056                 PrivateKey key =
1057                         ((KeyStore.PrivateKeyEntry)entry).getPrivateKey();
1058                 if (!(key instanceof P11Key) &amp;&amp;
1059                     !(key instanceof RSAPrivateKey) &amp;&amp;
1060                     !(key instanceof DSAPrivateKey) &amp;&amp;
1061                     !(key instanceof DHPrivateKey) &amp;&amp;
1062                     !(key instanceof ECPrivateKey)) {
1063                     throw new KeyStoreException(&quot;unsupported key type: &quot; +
1064                                                 key.getClass().getName());
1065                 }
1066 
1067                 // only support X509Certificate chains
1068                 Certificate[] chain =
1069                     ((KeyStore.PrivateKeyEntry)entry).getCertificateChain();
1070                 if (!(chain instanceof X509Certificate[])) {
1071                     throw new KeyStoreException
1072                         (new UnsupportedOperationException
1073                                 (&quot;unsupported certificate array type: &quot; +
1074                                 chain.getClass().getName()));
1075                 }
1076 
1077                 try {
1078                     boolean updatedAlias = false;
1079                     Set&lt;String&gt; aliases = aliasMap.keySet();
1080                     for (String oldAlias : aliases) {
1081 
1082                         // see if there&#39;s an existing entry with the same info
1083 
1084                         AliasInfo aliasInfo = aliasMap.get(oldAlias);
1085                         if (aliasInfo.type == ATTR_CLASS_PKEY &amp;&amp;
1086                             aliasInfo.cert.getPublicKey().equals
1087                                         (chain[0].getPublicKey())) {
1088 
1089                             // found existing entry -
1090                             // caller is renaming entry or updating cert chain
1091                             //
1092                             // set new CKA_LABEL/CKA_ID
1093                             // and update certs if necessary
1094 
1095                             updatePkey(alias,
1096                                         aliasInfo.id,
1097                                         (X509Certificate[])chain,
1098                                         !aliasInfo.cert.equals(chain[0]));
1099                             updatedAlias = true;
1100                             break;
1101                         }
1102                     }
1103 
1104                     if (!updatedAlias) {
1105                         // caller adding new entry
1106                         engineDeleteEntry(alias);
1107                         storePkey(alias, (KeyStore.PrivateKeyEntry)entry);
1108                     }
1109 
1110                 } catch (PKCS11Exception | CertificateException pe) {
1111                     throw new KeyStoreException(pe);
1112                 }
1113 
1114             } else if (entry instanceof KeyStore.SecretKeyEntry) {
1115 
1116                 KeyStore.SecretKeyEntry ske = (KeyStore.SecretKeyEntry)entry;
1117                 SecretKey skey = ske.getSecretKey();
1118 
1119                 try {
1120                     // first check if the key already exists
1121                     AliasInfo aliasInfo = aliasMap.get(alias);
1122 
1123                     if (aliasInfo != null) {
1124                         engineDeleteEntry(alias);
1125                     }
1126                     storeSkey(alias, ske);
1127 
1128                 } catch (PKCS11Exception pe) {
1129                     throw new KeyStoreException(pe);
1130                 }
1131 
1132             } else {
1133                 throw new KeyStoreException(new UnsupportedOperationException
1134                     (&quot;unsupported entry type: &quot; + entry.getClass().getName()));
1135             }
1136 
1137             try {
1138 
1139                 // XXX  NSS does not write out the CKA_ID we pass to them
1140                 //
1141                 // therefore we must re-map labels
1142                 // (can not simply update aliasMap)
1143 
1144                 mapLabels();
1145                 if (debug != null) {
1146                     dumpTokenMap();
1147                 }
1148             } catch (PKCS11Exception | CertificateException pe) {
1149                 throw new KeyStoreException(pe);
1150             }
1151         }
1152 
1153         if (debug != null) {
1154             debug.println
1155                 (&quot;engineSetEntry added new entry for [&quot; +
1156                 alias +
1157                 &quot;] to token&quot;);
1158         }
1159     }
1160 
1161     /**
1162      * Determines if the keystore &lt;code&gt;Entry&lt;/code&gt; for the specified
1163      * &lt;code&gt;alias&lt;/code&gt; is an instance or subclass of the specified
1164      * &lt;code&gt;entryClass&lt;/code&gt;.
1165      *
1166      * @param alias the alias name
1167      * @param entryClass the entry class
1168      *
1169      * @return true if the keystore &lt;code&gt;Entry&lt;/code&gt; for the specified
1170      *          &lt;code&gt;alias&lt;/code&gt; is an instance or subclass of the
1171      *          specified &lt;code&gt;entryClass&lt;/code&gt;, false otherwise
1172      */
1173     public synchronized boolean engineEntryInstanceOf
1174                 (String alias, Class&lt;? extends KeyStore.Entry&gt; entryClass) {
1175         token.ensureValid();
1176         return super.engineEntryInstanceOf(alias, entryClass);
1177     }
1178 
1179     private X509Certificate loadCert(Session session, long oHandle)
1180                 throws PKCS11Exception, CertificateException {
1181 
1182         CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[]
1183                         { new CK_ATTRIBUTE(CKA_VALUE) };
1184         token.p11.C_GetAttributeValue(session.id(), oHandle, attrs);
1185 
1186         byte[] bytes = attrs[0].getByteArray();
1187         if (bytes == null) {
1188             throw new CertificateException
1189                         (&quot;unexpectedly retrieved null byte array&quot;);
1190         }
1191         CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
1192         return (X509Certificate)cf.generateCertificate
1193                         (new ByteArrayInputStream(bytes));
1194     }
1195 
1196     private X509Certificate[] loadChain(Session session,
1197                                         X509Certificate endCert)
1198                 throws PKCS11Exception, CertificateException {
1199 
1200         ArrayList&lt;X509Certificate&gt; lChain = null;
1201 
1202         if (endCert.getSubjectX500Principal().equals
1203             (endCert.getIssuerX500Principal())) {
1204             // self signed
1205             return new X509Certificate[] { endCert };
1206         } else {
1207             lChain = new ArrayList&lt;X509Certificate&gt;();
1208             lChain.add(endCert);
1209         }
1210 
1211         // try loading remaining certs in chain by following
1212         // issuer-&gt;subject links
1213 
1214         X509Certificate next = endCert;
1215         while (true) {
1216             CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
1217                         ATTR_TOKEN_TRUE,
1218                         ATTR_CLASS_CERT,
1219                         new CK_ATTRIBUTE(CKA_SUBJECT,
1220                                 next.getIssuerX500Principal().getEncoded()) };
1221             long[] ch = findObjects(session, attrs);
1222 
1223             if (ch == null || ch.length == 0) {
1224                 // done
1225                 break;
1226             } else {
1227                 // if more than one found, use first
1228                 if (debug != null &amp;&amp; ch.length &gt; 1) {
1229                     debug.println(&quot;engineGetEntry found &quot; +
1230                                 ch.length +
1231                                 &quot; certificate entries for subject [&quot; +
1232                                 next.getIssuerX500Principal().toString() +
1233                                 &quot;] in token - using first entry&quot;);
1234                 }
1235 
1236                 next = loadCert(session, ch[0]);
1237                 lChain.add(next);
1238                 if (next.getSubjectX500Principal().equals
1239                     (next.getIssuerX500Principal())) {
1240                     // self signed
1241                     break;
1242                 }
1243             }
1244         }
1245 
1246         return lChain.toArray(new X509Certificate[lChain.size()]);
1247     }
1248 
1249     private SecretKey loadSkey(Session session, long oHandle)
1250                 throws PKCS11Exception {
1251 
1252         CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
1253                         new CK_ATTRIBUTE(CKA_KEY_TYPE) };
1254         token.p11.C_GetAttributeValue(session.id(), oHandle, attrs);
1255         long kType = attrs[0].getLong();
1256 
1257         String keyType = null;
1258         int keyLength = -1;
1259 
1260         // XXX NSS mangles the stored key type for secret key token objects
1261 
1262         if (kType == CKK_DES || kType == CKK_DES3) {
1263             if (kType == CKK_DES) {
1264                 keyType = &quot;DES&quot;;
1265                 keyLength = 64;
1266             } else if (kType == CKK_DES3) {
1267                 keyType = &quot;DESede&quot;;
1268                 keyLength = 192;
1269             }
1270         } else {
1271             if (kType == CKK_AES) {
1272                 keyType = &quot;AES&quot;;
1273             } else if (kType == CKK_BLOWFISH) {
1274                 keyType = &quot;Blowfish&quot;;
1275             } else if (kType == CKK_RC4) {
1276                 keyType = &quot;ARCFOUR&quot;;
1277             } else {
1278                 if (debug != null) {
1279                     debug.println(&quot;unknown key type [&quot; +
1280                                 kType +
1281                                 &quot;] - using &#39;Generic Secret&#39;&quot;);
1282                 }
1283                 keyType = &quot;Generic Secret&quot;;
1284             }
1285 
1286             // XXX NSS problem CKR_ATTRIBUTE_TYPE_INVALID?
1287             if (NSS_TEST) {
1288                 keyLength = 128;
1289             } else {
1290                 attrs = new CK_ATTRIBUTE[] { new CK_ATTRIBUTE(CKA_VALUE_LEN) };
1291                 token.p11.C_GetAttributeValue(session.id(), oHandle, attrs);
1292                 keyLength = (int)attrs[0].getLong();
1293             }
1294         }
1295 
1296         return P11Key.secretKey(session, oHandle, keyType, keyLength, null);
1297     }
1298 
1299     private PrivateKey loadPkey(Session session, long oHandle)
1300         throws PKCS11Exception, KeyStoreException {
1301 
1302         CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
1303                         new CK_ATTRIBUTE(CKA_KEY_TYPE) };
1304         token.p11.C_GetAttributeValue(session.id(), oHandle, attrs);
1305         long kType = attrs[0].getLong();
1306         String keyType = null;
1307         int keyLength = 0;
1308 
1309         if (kType == CKK_RSA) {
1310 
1311             keyType = &quot;RSA&quot;;
1312 
1313             attrs = new CK_ATTRIBUTE[] { new CK_ATTRIBUTE(CKA_MODULUS) };
1314             token.p11.C_GetAttributeValue(session.id(), oHandle, attrs);
1315             BigInteger modulus = attrs[0].getBigInteger();
1316             keyLength = modulus.bitLength();
1317 
1318             // This check will combine our &quot;don&#39;t care&quot; values here
1319             // with the system-wide min/max values.
1320             try {
1321                 RSAKeyFactory.checkKeyLengths(keyLength, null,
1322                     -1, Integer.MAX_VALUE);
1323             } catch (InvalidKeyException e) {
1324                 throw new KeyStoreException(e.getMessage());
1325             }
1326 
1327             return P11Key.privateKey(session,
1328                                 oHandle,
1329                                 keyType,
1330                                 keyLength,
1331                                 null);
1332 
1333         } else if (kType == CKK_DSA) {
1334 
1335             keyType = &quot;DSA&quot;;
1336 
1337             attrs = new CK_ATTRIBUTE[] { new CK_ATTRIBUTE(CKA_PRIME) };
1338             token.p11.C_GetAttributeValue(session.id(), oHandle, attrs);
1339             BigInteger prime = attrs[0].getBigInteger();
1340             keyLength = prime.bitLength();
1341 
1342             return P11Key.privateKey(session,
1343                                 oHandle,
1344                                 keyType,
1345                                 keyLength,
1346                                 null);
1347 
1348         } else if (kType == CKK_DH) {
1349 
1350             keyType = &quot;DH&quot;;
1351 
1352             attrs = new CK_ATTRIBUTE[] { new CK_ATTRIBUTE(CKA_PRIME) };
1353             token.p11.C_GetAttributeValue(session.id(), oHandle, attrs);
1354             BigInteger prime = attrs[0].getBigInteger();
1355             keyLength = prime.bitLength();
1356 
1357             return P11Key.privateKey(session,
1358                                 oHandle,
1359                                 keyType,
1360                                 keyLength,
1361                                 null);
1362 
1363         } else if (kType == CKK_EC) {
1364 
1365             attrs = new CK_ATTRIBUTE[] {
1366                 new CK_ATTRIBUTE(CKA_EC_PARAMS),
1367             };
1368             token.p11.C_GetAttributeValue(session.id(), oHandle, attrs);
1369             byte[] encodedParams = attrs[0].getByteArray();
1370             try {
1371                 ECParameterSpec params =
1372                     ECUtil.getECParameterSpec(null, encodedParams);
1373                 keyLength = params.getCurve().getField().getFieldSize();
1374             } catch (IOException e) {
1375                 // we do not want to accept key with unsupported parameters
1376                 throw new KeyStoreException(&quot;Unsupported parameters&quot;, e);
1377             }
1378 
1379             return P11Key.privateKey(session, oHandle, &quot;EC&quot;, keyLength, null);
1380 
1381         } else {
1382             if (debug != null) {
1383                 debug.println(&quot;unknown key type [&quot; + kType + &quot;]&quot;);
1384             }
1385             throw new KeyStoreException(&quot;unknown key type&quot;);
1386         }
1387     }
1388 
1389 
1390     /**
1391      * XXX  On ibutton, when you C_SetAttribute(CKA_ID) for a private key
1392      *      it not only changes the CKA_ID of the private key,
1393      *      it changes the CKA_ID of the corresponding cert too.
1394      *      And vice versa.
1395      *
1396      * XXX  On ibutton, CKR_DEVICE_ERROR if you C_SetAttribute(CKA_ID)
1397      *      for a private key, and then try to delete the corresponding cert.
1398      *      So this code reverses the order.
1399      *      After the cert is first destroyed (if necessary),
1400      *      then the CKA_ID of the private key can be changed successfully.
1401      *
1402      * @param replaceCert if true, then caller is updating alias info for
1403      *                  existing cert (only update CKA_ID/CKA_LABEL).
1404      *                  if false, then caller is updating cert chain
1405      *                  (delete old end cert and add new chain).
1406      */
1407     private void updatePkey(String alias,
1408                         byte[] cka_id,
1409                         X509Certificate[] chain,
1410                         boolean replaceCert) throws
1411                 KeyStoreException, CertificateException, PKCS11Exception {
1412 
1413         // XXX
1414         //
1415         // always set replaceCert to true
1416         //
1417         // NSS does not allow resetting of CKA_LABEL on an existing cert
1418         // (C_SetAttribute call succeeds, but is ignored)
1419 
1420         replaceCert = true;
1421 
1422         Session session = null;
1423         try {
1424             session = token.getOpSession();
1425 
1426             // first get private key object handle and hang onto it
1427 
1428             THandle h = getTokenObject(session, ATTR_CLASS_PKEY, cka_id, null);
1429             long pKeyHandle;
1430             if (h.type == ATTR_CLASS_PKEY) {
1431                 pKeyHandle = h.handle;
1432             } else {
1433                 throw new KeyStoreException
1434                         (&quot;expected but could not find private key &quot; +
1435                         &quot;with CKA_ID &quot; +
1436                         getID(cka_id));
1437             }
1438 
1439             // next find existing end entity cert
1440 
1441             h = getTokenObject(session, ATTR_CLASS_CERT, cka_id, null);
1442             if (h.type != ATTR_CLASS_CERT) {
1443                 throw new KeyStoreException
1444                         (&quot;expected but could not find certificate &quot; +
1445                         &quot;with CKA_ID &quot; +
1446                         getID(cka_id));
1447             } else {
1448                 if (replaceCert) {
1449                     // replacing existing cert and chain
1450                     destroyChain(cka_id);
1451                 } else {
1452                     // renaming alias for existing cert
1453                     CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
1454                         new CK_ATTRIBUTE(CKA_LABEL, alias),
1455                         new CK_ATTRIBUTE(CKA_ID, alias) };
1456                     token.p11.C_SetAttributeValue
1457                         (session.id(), h.handle, attrs);
1458                 }
1459             }
1460 
1461             // add new chain
1462 
1463             if (replaceCert) {
1464                 // add all certs in chain
1465                 storeChain(alias, chain);
1466             } else {
1467                 // already updated alias info for existing end cert -
1468                 // just update CA certs
1469                 storeCaCerts(chain, 1);
1470             }
1471 
1472             // finally update CKA_ID for private key
1473             //
1474             // ibutton may have already done this (that is ok)
1475 
1476             CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
1477                                 new CK_ATTRIBUTE(CKA_ID, alias) };
1478             token.p11.C_SetAttributeValue(session.id(), pKeyHandle, attrs);
1479 
1480             if (debug != null) {
1481                 debug.println(&quot;updatePkey set new alias [&quot; +
1482                                 alias +
1483                                 &quot;] for private key entry&quot;);
1484             }
1485         } finally {
1486             token.releaseSession(session);
1487         }
1488     }
1489 
1490     // retrieves the native key handle and either update it directly or make a copy
1491     private void updateP11Pkey(String alias, CK_ATTRIBUTE attribute, P11Key key)
1492                 throws PKCS11Exception {
1493 
1494         // if token key, update alias.
1495         // if session key, convert to token key.
1496 
1497         Session session = null;
1498         long keyID = key.getKeyID();
1499         try {
1500             session = token.getOpSession();
1501             if (key.tokenObject == true) {
1502                 // token key - set new CKA_ID
1503 
1504                 CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
1505                                 new CK_ATTRIBUTE(CKA_ID, alias) };
1506                 token.p11.C_SetAttributeValue
1507                                 (session.id(), keyID, attrs);
1508                 if (debug != null) {
1509                     debug.println(&quot;updateP11Pkey set new alias [&quot; +
1510                                 alias +
1511                                 &quot;] for key entry&quot;);
1512                 }
1513             } else {
1514                 // session key - convert to token key and set CKA_ID
1515 
1516                 CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
1517                     ATTR_TOKEN_TRUE,
1518                     new CK_ATTRIBUTE(CKA_ID, alias),
1519                 };
1520                 if (attribute != null) {
1521                     attrs = addAttribute(attrs, attribute);
1522                 }
1523                 // creates a new token key with the desired CKA_ID
1524                 token.p11.C_CopyObject(session.id(), keyID, attrs);
1525                 if (debug != null) {
1526                     debug.println(&quot;updateP11Pkey copied private session key &quot; +
1527                                 &quot;for [&quot; +
1528                                 alias +
1529                                 &quot;] to token entry&quot;);
1530                 }
1531             }
1532         } finally {
1533             token.releaseSession(session);
1534             key.releaseKeyID();
1535         }
1536     }
1537 
1538     private void storeCert(String alias, X509Certificate cert)
1539                 throws PKCS11Exception, CertificateException {
1540 
1541         ArrayList&lt;CK_ATTRIBUTE&gt; attrList = new ArrayList&lt;CK_ATTRIBUTE&gt;();
1542         attrList.add(ATTR_TOKEN_TRUE);
1543         attrList.add(ATTR_CLASS_CERT);
1544         attrList.add(ATTR_X509_CERT_TYPE);
1545         attrList.add(new CK_ATTRIBUTE(CKA_SUBJECT,
1546                                 cert.getSubjectX500Principal().getEncoded()));
1547         attrList.add(new CK_ATTRIBUTE(CKA_ISSUER,
1548                                 cert.getIssuerX500Principal().getEncoded()));
1549         attrList.add(new CK_ATTRIBUTE(CKA_SERIAL_NUMBER,
1550                                 cert.getSerialNumber().toByteArray()));
1551         attrList.add(new CK_ATTRIBUTE(CKA_VALUE, cert.getEncoded()));
1552 
1553         if (alias != null) {
1554             attrList.add(new CK_ATTRIBUTE(CKA_LABEL, alias));
1555             attrList.add(new CK_ATTRIBUTE(CKA_ID, alias));
1556         } else {
1557             // ibutton requires something to be set
1558             // - alias must be unique
1559             attrList.add(new CK_ATTRIBUTE(CKA_ID,
1560                         getID(cert.getSubjectX500Principal().getName
1561                                         (X500Principal.CANONICAL), cert)));
1562         }
1563 
1564         Session session = null;
1565         try {
1566             session = token.getOpSession();
1567             token.p11.C_CreateObject(session.id(),
1568                         attrList.toArray(new CK_ATTRIBUTE[attrList.size()]));
1569         } finally {
1570             token.releaseSession(session);
1571         }
1572     }
1573 
1574     private void storeChain(String alias, X509Certificate[] chain)
1575                 throws PKCS11Exception, CertificateException {
1576 
1577         // add new chain
1578         //
1579         // end cert has CKA_LABEL and CKA_ID set to alias.
1580         // other certs in chain have neither set.
1581 
1582         storeCert(alias, chain[0]);
1583         storeCaCerts(chain, 1);
1584     }
1585 
1586     private void storeCaCerts(X509Certificate[] chain, int start)
1587                 throws PKCS11Exception, CertificateException {
1588 
1589         // do not add duplicate CA cert if already in token
1590         //
1591         // XXX   ibutton stores duplicate CA certs, NSS does not
1592 
1593         Session session = null;
1594         HashSet&lt;X509Certificate&gt; cacerts = new HashSet&lt;X509Certificate&gt;();
1595         try {
1596             session = token.getOpSession();
1597             CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
1598                         ATTR_TOKEN_TRUE,
1599                         ATTR_CLASS_CERT };
1600             long[] handles = findObjects(session, attrs);
1601 
1602             // load certs currently on the token
1603             for (long handle : handles) {
1604                 cacerts.add(loadCert(session, handle));
1605             }
1606         } finally {
1607             token.releaseSession(session);
1608         }
1609 
1610         for (int i = start; i &lt; chain.length; i++) {
1611             if (!cacerts.contains(chain[i])) {
1612                 storeCert(null, chain[i]);
1613             } else if (debug != null) {
1614                 debug.println(&quot;ignoring duplicate CA cert for [&quot; +
1615                         chain[i].getSubjectX500Principal() +
1616                         &quot;]&quot;);
1617             }
1618         }
1619     }
1620 
1621     private void storeSkey(String alias, KeyStore.SecretKeyEntry ske)
1622                 throws PKCS11Exception, KeyStoreException {
1623 
1624         SecretKey skey = ske.getSecretKey();
1625         // No need to specify CKA_CLASS, CKA_KEY_TYPE, CKA_VALUE since
1626         // they are handled in P11SecretKeyFactory.createKey() method.
1627         CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
1628             ATTR_SKEY_TOKEN_TRUE,
1629             ATTR_PRIVATE_TRUE,
1630             new CK_ATTRIBUTE(CKA_LABEL, alias),
1631         };
1632         try {
1633             P11SecretKeyFactory.convertKey(token, skey, null, attrs);
1634         } catch (InvalidKeyException ike) {
1635             // re-throw KeyStoreException to match javadoc
1636             throw new KeyStoreException(&quot;Cannot convert to PKCS11 keys&quot;, ike);
1637         }
1638 
1639         // update global alias map
1640         aliasMap.put(alias, new AliasInfo(alias));
1641 
1642         if (debug != null) {
1643             debug.println(&quot;storeSkey created token secret key for [&quot; +
1644                           alias + &quot;]&quot;);
1645         }
1646     }
1647 
1648     private static CK_ATTRIBUTE[] addAttribute(CK_ATTRIBUTE[] attrs, CK_ATTRIBUTE attr) {
1649         int n = attrs.length;
1650         CK_ATTRIBUTE[] newAttrs = new CK_ATTRIBUTE[n + 1];
1651         System.arraycopy(attrs, 0, newAttrs, 0, n);
1652         newAttrs[n] = attr;
1653         return newAttrs;
1654     }
1655 
1656     private void storePkey(String alias, KeyStore.PrivateKeyEntry pke)
1657         throws PKCS11Exception, CertificateException, KeyStoreException  {
1658 
1659         PrivateKey key = pke.getPrivateKey();
1660         CK_ATTRIBUTE[] attrs = null;
1661 
1662         // If the key is a token object on this token, update it instead
1663         // of creating a duplicate key object.
1664         // Otherwise, treat a P11Key like any other key, if it is extractable.
1665         if (key instanceof P11Key) {
1666             P11Key p11Key = (P11Key)key;
1667             if (p11Key.tokenObject &amp;&amp; (p11Key.token == this.token)) {
1668                 updateP11Pkey(alias, null, p11Key);
1669                 storeChain(alias, (X509Certificate[])pke.getCertificateChain());
1670                 return;
1671             }
1672         }
1673 
1674         boolean useNDB = token.config.getNssNetscapeDbWorkaround();
1675         PublicKey publicKey = pke.getCertificate().getPublicKey();
1676 
1677         if (key instanceof RSAPrivateKey) {
1678 
1679             X509Certificate cert = (X509Certificate)pke.getCertificate();
1680             attrs = getRsaPrivKeyAttrs
1681                 (alias, (RSAPrivateKey)key, cert.getSubjectX500Principal());
1682 
1683         } else if (key instanceof DSAPrivateKey) {
1684 
1685             DSAPrivateKey dsaKey = (DSAPrivateKey)key;
1686 
1687             CK_ATTRIBUTE[] idAttrs = getIdAttributes(key, publicKey, false, useNDB);
1688             if (idAttrs[0] == null) {
1689                 idAttrs[0] = new CK_ATTRIBUTE(CKA_ID, alias);
1690             }
1691 
1692             attrs = new CK_ATTRIBUTE[] {
1693                 ATTR_TOKEN_TRUE,
1694                 ATTR_CLASS_PKEY,
1695                 ATTR_PRIVATE_TRUE,
1696                 new CK_ATTRIBUTE(CKA_KEY_TYPE, CKK_DSA),
1697                 idAttrs[0],
1698                 new CK_ATTRIBUTE(CKA_PRIME, dsaKey.getParams().getP()),
1699                 new CK_ATTRIBUTE(CKA_SUBPRIME, dsaKey.getParams().getQ()),
1700                 new CK_ATTRIBUTE(CKA_BASE, dsaKey.getParams().getG()),
1701                 new CK_ATTRIBUTE(CKA_VALUE, dsaKey.getX()),
1702             };
1703             if (idAttrs[1] != null) {
1704                 attrs = addAttribute(attrs, idAttrs[1]);
1705             }
1706 
1707             attrs = token.getAttributes
1708                 (TemplateManager.O_IMPORT, CKO_PRIVATE_KEY, CKK_DSA, attrs);
1709 
1710             if (debug != null) {
1711                 debug.println(&quot;storePkey created DSA template&quot;);
1712             }
1713 
1714         } else if (key instanceof DHPrivateKey) {
1715 
1716             DHPrivateKey dhKey = (DHPrivateKey)key;
1717 
1718             CK_ATTRIBUTE[] idAttrs = getIdAttributes(key, publicKey, false, useNDB);
1719             if (idAttrs[0] == null) {
1720                 idAttrs[0] = new CK_ATTRIBUTE(CKA_ID, alias);
1721             }
1722 
1723             attrs = new CK_ATTRIBUTE[] {
1724                 ATTR_TOKEN_TRUE,
1725                 ATTR_CLASS_PKEY,
1726                 ATTR_PRIVATE_TRUE,
1727                 new CK_ATTRIBUTE(CKA_KEY_TYPE, CKK_DH),
1728                 idAttrs[0],
1729                 new CK_ATTRIBUTE(CKA_PRIME, dhKey.getParams().getP()),
1730                 new CK_ATTRIBUTE(CKA_BASE, dhKey.getParams().getG()),
1731                 new CK_ATTRIBUTE(CKA_VALUE, dhKey.getX()),
1732             };
1733             if (idAttrs[1] != null) {
1734                 attrs = addAttribute(attrs, idAttrs[1]);
1735             }
1736 
1737             attrs = token.getAttributes
1738                 (TemplateManager.O_IMPORT, CKO_PRIVATE_KEY, CKK_DH, attrs);
1739 
1740         } else if (key instanceof ECPrivateKey) {
1741 
1742             ECPrivateKey ecKey = (ECPrivateKey)key;
1743 
1744             CK_ATTRIBUTE[] idAttrs = getIdAttributes(key, publicKey, false, useNDB);
1745             if (idAttrs[0] == null) {
1746                 idAttrs[0] = new CK_ATTRIBUTE(CKA_ID, alias);
1747             }
1748 
1749             byte[] encodedParams =
1750                 ECUtil.encodeECParameterSpec(null, ecKey.getParams());
1751             attrs = new CK_ATTRIBUTE[] {
1752                 ATTR_TOKEN_TRUE,
1753                 ATTR_CLASS_PKEY,
1754                 ATTR_PRIVATE_TRUE,
1755                 new CK_ATTRIBUTE(CKA_KEY_TYPE, CKK_EC),
1756                 idAttrs[0],
1757                 new CK_ATTRIBUTE(CKA_VALUE, ecKey.getS()),
1758                 new CK_ATTRIBUTE(CKA_EC_PARAMS, encodedParams),
1759             };
1760             if (idAttrs[1] != null) {
1761                 attrs = addAttribute(attrs, idAttrs[1]);
1762             }
1763 
1764             attrs = token.getAttributes
1765                 (TemplateManager.O_IMPORT, CKO_PRIVATE_KEY, CKK_EC, attrs);
1766 
1767             if (debug != null) {
1768                 debug.println(&quot;storePkey created EC template&quot;);
1769             }
1770 
1771         } else if (key instanceof P11Key) {
1772             // sensitive/non-extractable P11Key
1773             P11Key p11Key = (P11Key)key;
1774             if (p11Key.token != this.token) {
1775                 throw new KeyStoreException
1776                     (&quot;Cannot move sensitive keys across tokens&quot;);
1777             }
1778             CK_ATTRIBUTE netscapeDB = null;
1779             if (useNDB) {
1780                 // Note that this currently fails due to an NSS bug.
1781                 // They do not allow the CKA_NETSCAPE_DB attribute to be
1782                 // specified during C_CopyObject() and fail with
1783                 // CKR_ATTRIBUTE_READ_ONLY.
1784                 // But if we did not specify it, they would fail with
1785                 // CKA_TEMPLATE_INCOMPLETE, so leave this code in here.
1786                 CK_ATTRIBUTE[] idAttrs = getIdAttributes(key, publicKey, false, true);
1787                 netscapeDB = idAttrs[1];
1788             }
1789             // Update the key object.
1790             updateP11Pkey(alias, netscapeDB, p11Key);
1791             storeChain(alias, (X509Certificate[])pke.getCertificateChain());
1792             return;
1793 
1794         } else {
1795             throw new KeyStoreException(&quot;unsupported key type: &quot; + key);
1796         }
1797 
1798         Session session = null;
1799         try {
1800             session = token.getOpSession();
1801 
1802             // create private key entry
1803             token.p11.C_CreateObject(session.id(), attrs);
1804             if (debug != null) {
1805                 debug.println(&quot;storePkey created token key for [&quot; +
1806                                 alias +
1807                                 &quot;]&quot;);
1808             }
1809         } finally {
1810             token.releaseSession(session);
1811         }
1812 
1813         storeChain(alias, (X509Certificate[])pke.getCertificateChain());
1814     }
1815 
1816     private CK_ATTRIBUTE[] getRsaPrivKeyAttrs(String alias,
1817                                 RSAPrivateKey key,
1818                                 X500Principal subject) throws PKCS11Exception {
1819 
1820         // subject is currently ignored - could be used to set CKA_SUBJECT
1821 
1822         CK_ATTRIBUTE[] attrs = null;
1823         if (key instanceof RSAPrivateCrtKey) {
1824 
1825             if (debug != null) {
1826                 debug.println(&quot;creating RSAPrivateCrtKey attrs&quot;);
1827             }
1828 
1829             RSAPrivateCrtKey rsaKey = (RSAPrivateCrtKey)key;
1830 
1831             attrs = new CK_ATTRIBUTE[] {
1832                 ATTR_TOKEN_TRUE,
1833                 ATTR_CLASS_PKEY,
1834                 ATTR_PRIVATE_TRUE,
1835                 new CK_ATTRIBUTE(CKA_KEY_TYPE, CKK_RSA),
1836                 new CK_ATTRIBUTE(CKA_ID, alias),
1837                 new CK_ATTRIBUTE(CKA_MODULUS,
1838                                 rsaKey.getModulus()),
1839                 new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT,
1840                                 rsaKey.getPrivateExponent()),
1841                 new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT,
1842                                 rsaKey.getPublicExponent()),
1843                 new CK_ATTRIBUTE(CKA_PRIME_1,
1844                                 rsaKey.getPrimeP()),
1845                 new CK_ATTRIBUTE(CKA_PRIME_2,
1846                                 rsaKey.getPrimeQ()),
1847                 new CK_ATTRIBUTE(CKA_EXPONENT_1,
1848                                 rsaKey.getPrimeExponentP()),
1849                 new CK_ATTRIBUTE(CKA_EXPONENT_2,
1850                                 rsaKey.getPrimeExponentQ()),
1851                 new CK_ATTRIBUTE(CKA_COEFFICIENT,
1852                                 rsaKey.getCrtCoefficient()) };
1853             attrs = token.getAttributes
1854                 (TemplateManager.O_IMPORT, CKO_PRIVATE_KEY, CKK_RSA, attrs);
1855 
1856         } else {
1857 
1858             if (debug != null) {
1859                 debug.println(&quot;creating RSAPrivateKey attrs&quot;);
1860             }
1861 
1862             RSAPrivateKey rsaKey = key;
1863 
1864             attrs = new CK_ATTRIBUTE[] {
1865                 ATTR_TOKEN_TRUE,
1866                 ATTR_CLASS_PKEY,
1867                 ATTR_PRIVATE_TRUE,
1868                 new CK_ATTRIBUTE(CKA_KEY_TYPE, CKK_RSA),
1869                 new CK_ATTRIBUTE(CKA_ID, alias),
1870                 new CK_ATTRIBUTE(CKA_MODULUS,
1871                                 rsaKey.getModulus()),
1872                 new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT,
1873                                 rsaKey.getPrivateExponent()) };
1874             attrs = token.getAttributes
1875                 (TemplateManager.O_IMPORT, CKO_PRIVATE_KEY, CKK_RSA, attrs);
1876         }
1877 
1878         return attrs;
1879     }
1880 
1881     /**
1882      * Compute the CKA_ID and/or CKA_NETSCAPE_DB attributes that should be
1883      * used for this private key. It uses the same algorithm to calculate the
1884      * values as NSS. The public and private keys MUST match for the result to
1885      * be correct.
1886      *
1887      * It returns a 2 element array with CKA_ID at index 0 and CKA_NETSCAPE_DB
1888      * at index 1. The boolean flags determine what is to be calculated.
1889      * If false or if we could not calculate the value, that element is null.
1890      *
1891      * NOTE that we currently do not use the CKA_ID value calculated by this
1892      * method.
1893      */
1894     private CK_ATTRIBUTE[] getIdAttributes(PrivateKey privateKey,
1895             PublicKey publicKey, boolean id, boolean netscapeDb) {
1896         CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[2];
1897         if ((id || netscapeDb) == false) {
1898             return attrs;
1899         }
1900         String alg = privateKey.getAlgorithm();
1901         if (alg.equals(&quot;RSA&quot;) &amp;&amp; (publicKey instanceof RSAPublicKey)) {
1902             if (id) {
1903                 BigInteger n = ((RSAPublicKey)publicKey).getModulus();
1904                 attrs[0] = new CK_ATTRIBUTE(CKA_ID, sha1(getMagnitude(n)));
1905             }
1906             // CKA_NETSCAPE_DB not needed for RSA public keys
1907         } else if (alg.equals(&quot;DSA&quot;) &amp;&amp; (publicKey instanceof DSAPublicKey)) {
1908             BigInteger y = ((DSAPublicKey)publicKey).getY();
1909             if (id) {
1910                 attrs[0] = new CK_ATTRIBUTE(CKA_ID, sha1(getMagnitude(y)));
1911             }
1912             if (netscapeDb) {
1913                 attrs[1] = new CK_ATTRIBUTE(CKA_NETSCAPE_DB, y);
1914             }
1915         } else if (alg.equals(&quot;DH&quot;) &amp;&amp; (publicKey instanceof DHPublicKey)) {
1916             BigInteger y = ((DHPublicKey)publicKey).getY();
1917             if (id) {
1918                 attrs[0] = new CK_ATTRIBUTE(CKA_ID, sha1(getMagnitude(y)));
1919             }
1920             if (netscapeDb) {
1921                 attrs[1] = new CK_ATTRIBUTE(CKA_NETSCAPE_DB, y);
1922             }
1923         } else if (alg.equals(&quot;EC&quot;) &amp;&amp; (publicKey instanceof ECPublicKey)) {
1924             ECPublicKey ecPub = (ECPublicKey)publicKey;
1925             ECPoint point = ecPub.getW();
1926             ECParameterSpec params = ecPub.getParams();
1927             byte[] encodedPoint = ECUtil.encodePoint(point, params.getCurve());
1928             if (id) {
1929                 attrs[0] = new CK_ATTRIBUTE(CKA_ID, sha1(encodedPoint));
1930             }
1931             if (netscapeDb) {
1932                 attrs[1] = new CK_ATTRIBUTE(CKA_NETSCAPE_DB, encodedPoint);
1933             }
1934         } else {
1935             throw new RuntimeException(&quot;Unknown key algorithm &quot; + alg);
1936         }
1937         return attrs;
1938     }
1939 
1940     /**
1941      * return true if cert destroyed
1942      */
1943     private boolean destroyCert(byte[] cka_id)
1944                 throws PKCS11Exception, KeyStoreException {
1945         Session session = null;
1946         try {
1947             session = token.getOpSession();
1948             THandle h = getTokenObject(session, ATTR_CLASS_CERT, cka_id, null);
1949             if (h.type != ATTR_CLASS_CERT) {
1950                 return false;
1951             }
1952 
1953             token.p11.C_DestroyObject(session.id(), h.handle);
1954             if (debug != null) {
1955                 debug.println(&quot;destroyCert destroyed cert with CKA_ID [&quot; +
1956                                                 getID(cka_id) +
1957                                                 &quot;]&quot;);
1958             }
1959             return true;
1960         } finally {
1961             token.releaseSession(session);
1962         }
1963     }
1964 
1965     /**
1966      * return true if chain destroyed
1967      */
1968     private boolean destroyChain(byte[] cka_id)
1969         throws PKCS11Exception, CertificateException, KeyStoreException {
1970 
1971         Session session = null;
1972         try {
1973             session = token.getOpSession();
1974 
1975             THandle h = getTokenObject(session, ATTR_CLASS_CERT, cka_id, null);
1976             if (h.type != ATTR_CLASS_CERT) {
1977                 if (debug != null) {
1978                     debug.println(&quot;destroyChain could not find &quot; +
1979                         &quot;end entity cert with CKA_ID [0x&quot; +
1980                         Functions.toHexString(cka_id) +
1981                         &quot;]&quot;);
1982                 }
1983                 return false;
1984             }
1985 
1986             X509Certificate endCert = loadCert(session, h.handle);
1987             token.p11.C_DestroyObject(session.id(), h.handle);
1988             if (debug != null) {
1989                 debug.println(&quot;destroyChain destroyed end entity cert &quot; +
1990                         &quot;with CKA_ID [&quot; +
1991                         getID(cka_id) +
1992                         &quot;]&quot;);
1993             }
1994 
1995             // build chain following issuer-&gt;subject links
1996 
1997             X509Certificate next = endCert;
1998             while (true) {
1999 
2000                 if (next.getSubjectX500Principal().equals
2001                     (next.getIssuerX500Principal())) {
2002                     // self signed - done
2003                     break;
2004                 }
2005 
2006                 CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
2007                         ATTR_TOKEN_TRUE,
2008                         ATTR_CLASS_CERT,
2009                         new CK_ATTRIBUTE(CKA_SUBJECT,
2010                                   next.getIssuerX500Principal().getEncoded()) };
2011                 long[] ch = findObjects(session, attrs);
2012 
2013                 if (ch == null || ch.length == 0) {
2014                     // done
2015                     break;
2016                 } else {
2017                     // if more than one found, use first
2018                     if (debug != null &amp;&amp; ch.length &gt; 1) {
2019                         debug.println(&quot;destroyChain found &quot; +
2020                                 ch.length +
2021                                 &quot; certificate entries for subject [&quot; +
2022                                 next.getIssuerX500Principal() +
2023                                 &quot;] in token - using first entry&quot;);
2024                     }
2025 
2026                     next = loadCert(session, ch[0]);
2027 
2028                     // only delete if not part of any other chain
2029 
2030                     attrs = new CK_ATTRIBUTE[] {
2031                         ATTR_TOKEN_TRUE,
2032                         ATTR_CLASS_CERT,
2033                         new CK_ATTRIBUTE(CKA_ISSUER,
2034                                 next.getSubjectX500Principal().getEncoded()) };
2035                     long[] issuers = findObjects(session, attrs);
2036 
2037                     boolean destroyIt = false;
2038                     if (issuers == null || issuers.length == 0) {
2039                         // no other certs with this issuer -
2040                         // destroy it
2041                         destroyIt = true;
2042                     } else if (issuers.length == 1) {
2043                         X509Certificate iCert = loadCert(session, issuers[0]);
2044                         if (next.equals(iCert)) {
2045                             // only cert with issuer is itself (self-signed) -
2046                             // destroy it
2047                             destroyIt = true;
2048                         }
2049                     }
2050 
2051                     if (destroyIt) {
2052                         token.p11.C_DestroyObject(session.id(), ch[0]);
2053                         if (debug != null) {
2054                             debug.println
2055                                 (&quot;destroyChain destroyed cert in chain &quot; +
2056                                 &quot;with subject [&quot; +
2057                                 next.getSubjectX500Principal() + &quot;]&quot;);
2058                         }
2059                     } else {
2060                         if (debug != null) {
2061                             debug.println(&quot;destroyChain did not destroy &quot; +
2062                                 &quot;shared cert in chain with subject [&quot; +
2063                                 next.getSubjectX500Principal() + &quot;]&quot;);
2064                         }
2065                     }
2066                 }
2067             }
2068 
2069             return true;
2070 
2071         } finally {
2072             token.releaseSession(session);
2073         }
2074     }
2075 
2076     /**
2077      * return true if secret key destroyed
2078      */
2079     private boolean destroySkey(String alias)
2080                 throws PKCS11Exception, KeyStoreException {
2081         Session session = null;
2082         try {
2083             session = token.getOpSession();
2084 
2085             THandle h = getTokenObject(session, ATTR_CLASS_SKEY, null, alias);
2086             if (h.type != ATTR_CLASS_SKEY) {
2087                 if (debug != null) {
2088                     debug.println(&quot;destroySkey did not find secret key &quot; +
2089                         &quot;with CKA_LABEL [&quot; +
2090                         alias +
2091                         &quot;]&quot;);
2092                 }
2093                 return false;
2094             }
2095             token.p11.C_DestroyObject(session.id(), h.handle);
2096             return true;
2097         } finally {
2098             token.releaseSession(session);
2099         }
2100     }
2101 
2102     /**
2103      * return true if private key destroyed
2104      */
2105     private boolean destroyPkey(byte[] cka_id)
2106                 throws PKCS11Exception, KeyStoreException {
2107         Session session = null;
2108         try {
2109             session = token.getOpSession();
2110 
2111             THandle h = getTokenObject(session, ATTR_CLASS_PKEY, cka_id, null);
2112             if (h.type != ATTR_CLASS_PKEY) {
2113                 if (debug != null) {
2114                     debug.println
2115                         (&quot;destroyPkey did not find private key with CKA_ID [&quot; +
2116                         getID(cka_id) +
2117                         &quot;]&quot;);
2118                 }
2119                 return false;
2120             }
2121             token.p11.C_DestroyObject(session.id(), h.handle);
2122             return true;
2123         } finally {
2124             token.releaseSession(session);
2125         }
2126     }
2127 
2128     /**
2129      * build [alias + issuer + serialNumber] string from a cert
2130      */
2131     private String getID(String alias, X509Certificate cert) {
2132         X500Principal issuer = cert.getIssuerX500Principal();
2133         BigInteger serialNum = cert.getSerialNumber();
2134 
2135         return alias +
2136                 ALIAS_SEP +
2137                 issuer.getName(X500Principal.CANONICAL) +
2138                 ALIAS_SEP +
2139                 serialNum.toString();
2140     }
2141 
2142     /**
2143      * build CKA_ID string from bytes
2144      */
2145     private static String getID(byte[] bytes) {
2146         boolean printable = true;
2147         for (int i = 0; i &lt; bytes.length; i++) {
2148             if (!DerValue.isPrintableStringChar((char)bytes[i])) {
2149                 printable = false;
2150                 break;
2151             }
2152         }
2153 
2154         if (!printable) {
2155             return &quot;0x&quot; + Functions.toHexString(bytes);
2156         } else {
<a name="2" id="anc2"></a><span class="line-modified">2157             try {</span>
<span class="line-removed">2158                 return new String(bytes, &quot;UTF-8&quot;);</span>
<span class="line-removed">2159             } catch (UnsupportedEncodingException uee) {</span>
<span class="line-removed">2160                 return &quot;0x&quot; + Functions.toHexString(bytes);</span>
<span class="line-removed">2161             }</span>
2162         }
2163     }
2164 
2165     /**
2166      * find an object on the token
2167      *
2168      * @param type either ATTR_CLASS_CERT, ATTR_CLASS_PKEY, or ATTR_CLASS_SKEY
2169      * @param cka_id the CKA_ID if type is ATTR_CLASS_CERT or ATTR_CLASS_PKEY
2170      * @param cka_label the CKA_LABEL if type is ATTR_CLASS_SKEY
2171      */
2172     private THandle getTokenObject(Session session,
2173                                 CK_ATTRIBUTE type,
2174                                 byte[] cka_id,
2175                                 String cka_label)
2176                 throws PKCS11Exception, KeyStoreException {
2177 
2178         CK_ATTRIBUTE[] attrs;
2179         if (type == ATTR_CLASS_SKEY) {
2180             attrs = new CK_ATTRIBUTE[] {
2181                         ATTR_SKEY_TOKEN_TRUE,
2182                         new CK_ATTRIBUTE(CKA_LABEL, cka_label),
2183                         type };
2184         } else {
2185             attrs = new CK_ATTRIBUTE[] {
2186                         ATTR_TOKEN_TRUE,
2187                         new CK_ATTRIBUTE(CKA_ID, cka_id),
2188                         type };
2189         }
2190         long[] h = findObjects(session, attrs);
2191         if (h.length == 0) {
2192             if (debug != null) {
2193                 if (type == ATTR_CLASS_SKEY) {
2194                     debug.println(&quot;getTokenObject did not find secret key &quot; +
2195                                 &quot;with CKA_LABEL [&quot; +
2196                                 cka_label +
2197                                 &quot;]&quot;);
2198                 } else if (type == ATTR_CLASS_CERT) {
2199                     debug.println
2200                         (&quot;getTokenObject did not find cert with CKA_ID [&quot; +
2201                         getID(cka_id) +
2202                         &quot;]&quot;);
2203                 } else {
2204                     debug.println(&quot;getTokenObject did not find private key &quot; +
2205                         &quot;with CKA_ID [&quot; +
2206                         getID(cka_id) +
2207                         &quot;]&quot;);
2208                 }
2209             }
2210         } else if (h.length == 1) {
2211 
2212             // found object handle - return it
2213             return new THandle(h[0], type);
2214 
2215         } else {
2216 
2217             // found multiple object handles -
2218             // see if token ignored CKA_LABEL during search (e.g. NSS)
2219 
2220             if (type == ATTR_CLASS_SKEY) {
2221 
2222                 ArrayList&lt;THandle&gt; list = new ArrayList&lt;THandle&gt;(h.length);
2223                 for (int i = 0; i &lt; h.length; i++) {
2224 
2225                     CK_ATTRIBUTE[] label = new CK_ATTRIBUTE[]
2226                                         { new CK_ATTRIBUTE(CKA_LABEL) };
2227                     token.p11.C_GetAttributeValue(session.id(), h[i], label);
2228                     if (label[0].pValue != null &amp;&amp;
2229                         cka_label.equals(new String(label[0].getCharArray()))) {
2230                         list.add(new THandle(h[i], ATTR_CLASS_SKEY));
2231                     }
2232                 }
2233                 if (list.size() == 1) {
2234                     // yes, there was only one CKA_LABEL that matched
2235                     return list.get(0);
2236                 } else {
2237                     throw new KeyStoreException(&quot;invalid KeyStore state: &quot; +
2238                         &quot;found &quot; +
2239                         list.size() +
2240                         &quot; secret keys sharing CKA_LABEL [&quot; +
2241                         cka_label +
2242                         &quot;]&quot;);
2243                 }
2244             } else if (type == ATTR_CLASS_CERT) {
2245                 throw new KeyStoreException(&quot;invalid KeyStore state: &quot; +
2246                         &quot;found &quot; +
2247                         h.length +
2248                         &quot; certificates sharing CKA_ID &quot; +
2249                         getID(cka_id));
2250             } else {
2251                 throw new KeyStoreException(&quot;invalid KeyStore state: &quot; +
2252                         &quot;found &quot; +
2253                         h.length +
2254                         &quot; private keys sharing CKA_ID &quot; +
2255                         getID(cka_id));
2256             }
2257         }
2258         return new THandle(NO_HANDLE, null);
2259     }
2260 
2261     /**
2262      * Create a mapping of all key pairs, trusted certs, and secret keys
2263      * on the token into logical KeyStore entries unambiguously
2264      * accessible via an alias.
2265      *
2266      * If the token is removed, the map may contain stale values.
2267      * KeyStore.load should be called to re-create the map.
2268      *
2269      * Assume all private keys and matching certs share a unique CKA_ID.
2270      *
2271      * Assume all secret keys have a unique CKA_LABEL.
2272      *
2273      * @return true if multiple certs found sharing the same CKA_LABEL
2274      *          (if so, write capabilities are disabled)
2275      */
2276     private boolean mapLabels() throws
2277                 PKCS11Exception, CertificateException, KeyStoreException {
2278 
2279         CK_ATTRIBUTE[] trustedAttr = new CK_ATTRIBUTE[] {
2280                                 new CK_ATTRIBUTE(CKA_TRUSTED) };
2281 
2282         Session session = null;
2283         try {
2284             session = token.getOpSession();
2285 
2286             // get all private key CKA_IDs
2287 
2288             ArrayList&lt;byte[]&gt; pkeyIDs = new ArrayList&lt;byte[]&gt;();
2289             CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
2290                 ATTR_TOKEN_TRUE,
2291                 ATTR_CLASS_PKEY,
2292             };
2293             long[] handles = findObjects(session, attrs);
2294 
2295             for (long handle : handles) {
2296                 attrs = new CK_ATTRIBUTE[] { new CK_ATTRIBUTE(CKA_ID) };
2297                 token.p11.C_GetAttributeValue(session.id(), handle, attrs);
2298 
2299                 if (attrs[0].pValue != null) {
2300                     pkeyIDs.add(attrs[0].getByteArray());
2301                 }
2302             }
2303 
2304             // Get all certificates
2305             //
2306             // If cert does not have a CKA_LABEL nor CKA_ID, it is ignored.
2307             //
2308             // Get the CKA_LABEL for each cert
2309             // (if the cert does not have a CKA_LABEL, use the CKA_ID).
2310             //
2311             // Map each cert to the its CKA_LABEL
2312             // (multiple certs may be mapped to a single CKA_LABEL)
2313 
2314             HashMap&lt;String, HashSet&lt;AliasInfo&gt;&gt; certMap =
2315                                 new HashMap&lt;String, HashSet&lt;AliasInfo&gt;&gt;();
2316 
2317             attrs = new CK_ATTRIBUTE[] {
2318                 ATTR_TOKEN_TRUE,
2319                 ATTR_CLASS_CERT,
2320             };
2321             handles = findObjects(session, attrs);
2322 
2323             for (long handle : handles) {
2324                 attrs = new CK_ATTRIBUTE[] { new CK_ATTRIBUTE(CKA_LABEL) };
2325 
2326                 String cka_label = null;
2327                 byte[] cka_id = null;
2328                 try {
2329                     token.p11.C_GetAttributeValue(session.id(), handle, attrs);
2330                     if (attrs[0].pValue != null) {
2331                         // there is a CKA_LABEL
2332                         cka_label = new String(attrs[0].getCharArray());
2333                     }
2334                 } catch (PKCS11Exception pe) {
2335                     if (pe.getErrorCode() != CKR_ATTRIBUTE_TYPE_INVALID) {
2336                         throw pe;
2337                     }
2338 
2339                     // GetAttributeValue for CKA_LABEL not supported
2340                     //
2341                     // XXX SCA1000
2342                 }
2343 
2344                 // get CKA_ID
2345 
2346                 attrs = new CK_ATTRIBUTE[] { new CK_ATTRIBUTE(CKA_ID) };
2347                 token.p11.C_GetAttributeValue(session.id(), handle, attrs);
2348                 if (attrs[0].pValue == null) {
2349                     if (cka_label == null) {
2350                         // no cka_label nor cka_id - ignore
2351                         continue;
2352                     }
2353                 } else {
2354                     if (cka_label == null) {
2355                         // use CKA_ID as CKA_LABEL
2356                         cka_label = getID(attrs[0].getByteArray());
2357                     }
2358                     cka_id = attrs[0].getByteArray();
2359                 }
2360 
2361                 X509Certificate cert = loadCert(session, handle);
2362 
2363                 // get CKA_TRUSTED
2364 
2365                 boolean cka_trusted = false;
2366 
2367                 if (useSecmodTrust) {
2368                     cka_trusted = Secmod.getInstance().isTrusted(cert, nssTrustType);
2369                 } else {
2370                     if (CKA_TRUSTED_SUPPORTED) {
2371                         try {
2372                             token.p11.C_GetAttributeValue
2373                                     (session.id(), handle, trustedAttr);
2374                             cka_trusted = trustedAttr[0].getBoolean();
2375                         } catch (PKCS11Exception pe) {
2376                             if (pe.getErrorCode() == CKR_ATTRIBUTE_TYPE_INVALID) {
2377                                 // XXX  NSS, ibutton, sca1000
2378                                 CKA_TRUSTED_SUPPORTED = false;
2379                                 if (debug != null) {
2380                                     debug.println
2381                                             (&quot;CKA_TRUSTED attribute not supported&quot;);
2382                                 }
2383                             }
2384                         }
2385                     }
2386                 }
2387 
2388                 HashSet&lt;AliasInfo&gt; infoSet = certMap.get(cka_label);
2389                 if (infoSet == null) {
2390                     infoSet = new HashSet&lt;AliasInfo&gt;(2);
2391                     certMap.put(cka_label, infoSet);
2392                 }
2393 
2394                 // initially create private key entry AliasInfo entries -
2395                 // these entries will get resolved into their true
2396                 // entry types later
2397 
2398                 infoSet.add(new AliasInfo
2399                                 (cka_label,
2400                                 cka_id,
2401                                 cka_trusted,
2402                                 cert));
2403             }
2404 
2405             // create list secret key CKA_LABELS -
2406             // if there are duplicates (either between secret keys,
2407             // or between a secret key and another object),
2408             // throw an exception
2409             HashMap&lt;String, AliasInfo&gt; sKeyMap =
2410                     new HashMap&lt;String, AliasInfo&gt;();
2411 
2412             attrs = new CK_ATTRIBUTE[] {
2413                 ATTR_SKEY_TOKEN_TRUE,
2414                 ATTR_CLASS_SKEY,
2415             };
2416             handles = findObjects(session, attrs);
2417 
2418             for (long handle : handles) {
2419                 attrs = new CK_ATTRIBUTE[] { new CK_ATTRIBUTE(CKA_LABEL) };
2420                 token.p11.C_GetAttributeValue(session.id(), handle, attrs);
2421                 if (attrs[0].pValue != null) {
2422 
2423                     // there is a CKA_LABEL
2424                     String cka_label = new String(attrs[0].getCharArray());
2425                     if (sKeyMap.get(cka_label) == null) {
2426                         sKeyMap.put(cka_label, new AliasInfo(cka_label));
2427                     } else {
2428                         throw new KeyStoreException(&quot;invalid KeyStore state: &quot; +
2429                                 &quot;found multiple secret keys sharing same &quot; +
2430                                 &quot;CKA_LABEL [&quot; +
2431                                 cka_label +
2432                                 &quot;]&quot;);
2433                     }
2434                 }
2435             }
2436 
2437             // update global aliasMap with alias mappings
2438             ArrayList&lt;AliasInfo&gt; matchedCerts =
2439                                 mapPrivateKeys(pkeyIDs, certMap);
2440             boolean sharedLabel = mapCerts(matchedCerts, certMap);
2441             mapSecretKeys(sKeyMap);
2442 
2443             return sharedLabel;
2444 
2445         } finally {
2446             token.releaseSession(session);
2447         }
2448     }
2449 
2450     /**
2451      * for each private key CKA_ID, find corresponding cert with same CKA_ID.
2452      * if found cert, see if cert CKA_LABEL is unique.
2453      *     if CKA_LABEL unique, map private key/cert alias to that CKA_LABEL.
2454      *     if CKA_LABEL not unique, map private key/cert alias to:
2455      *                   CKA_LABEL + ALIAS_SEP + ISSUER + ALIAS_SEP + SERIAL
2456      * if cert not found, ignore private key
2457      * (don&#39;t support private key entries without a cert chain yet)
2458      *
2459      * @return a list of AliasInfo entries that represents all matches
2460      */
2461     private ArrayList&lt;AliasInfo&gt; mapPrivateKeys(ArrayList&lt;byte[]&gt; pkeyIDs,
2462                         HashMap&lt;String, HashSet&lt;AliasInfo&gt;&gt; certMap)
2463                 throws PKCS11Exception, CertificateException {
2464 
2465         // reset global alias map
2466         aliasMap = new HashMap&lt;String, AliasInfo&gt;();
2467 
2468         // list of matched certs that we will return
2469         ArrayList&lt;AliasInfo&gt; matchedCerts = new ArrayList&lt;AliasInfo&gt;();
2470 
2471         for (byte[] pkeyID : pkeyIDs) {
2472 
2473             // try to find a matching CKA_ID in a certificate
2474 
2475             boolean foundMatch = false;
2476             Set&lt;String&gt; certLabels = certMap.keySet();
2477             for (String certLabel : certLabels) {
2478 
2479                 // get cert CKA_IDs (if present) for each cert
2480 
2481                 HashSet&lt;AliasInfo&gt; infoSet = certMap.get(certLabel);
2482                 for (AliasInfo aliasInfo : infoSet) {
2483                     if (Arrays.equals(pkeyID, aliasInfo.id)) {
2484 
2485                         // found private key with matching cert
2486 
2487                         if (infoSet.size() == 1) {
2488                             // unique CKA_LABEL - use certLabel as alias
2489                             aliasInfo.matched = true;
2490                             aliasMap.put(certLabel, aliasInfo);
2491                         } else {
2492                             // create new alias
2493                             aliasInfo.matched = true;
2494                             aliasMap.put(getID(certLabel, aliasInfo.cert),
2495                                         aliasInfo);
2496                         }
2497                         matchedCerts.add(aliasInfo);
2498                         foundMatch = true;
2499                         break;
2500                     }
2501                 }
2502                 if (foundMatch) {
2503                     break;
2504                 }
2505             }
2506 
2507             if (!foundMatch) {
2508                 if (debug != null) {
2509                     debug.println
2510                         (&quot;did not find match for private key with CKA_ID [&quot; +
2511                         getID(pkeyID) +
2512                         &quot;] (ignoring entry)&quot;);
2513                 }
2514             }
2515         }
2516 
2517         return matchedCerts;
2518     }
2519 
2520     /**
2521      * for each cert not matched with a private key but is CKA_TRUSTED:
2522      *     if CKA_LABEL unique, map cert to CKA_LABEL.
2523      *     if CKA_LABEL not unique, map cert to [label+issuer+serialNum]
2524      *
2525      * if CKA_TRUSTED not supported, treat all certs not part of a chain
2526      * as trusted
2527      *
2528      * @return true if multiple certs found sharing the same CKA_LABEL
2529      */
2530     private boolean mapCerts(ArrayList&lt;AliasInfo&gt; matchedCerts,
2531                         HashMap&lt;String, HashSet&lt;AliasInfo&gt;&gt; certMap)
2532                 throws PKCS11Exception, CertificateException {
2533 
2534         // load all cert chains
2535         for (AliasInfo aliasInfo : matchedCerts) {
2536             Session session = null;
2537             try {
2538                 session = token.getOpSession();
2539                 aliasInfo.chain = loadChain(session, aliasInfo.cert);
2540             } finally {
2541                 token.releaseSession(session);
2542             }
2543         }
2544 
2545         // find all certs in certMap not part of a cert chain
2546         // - these are trusted
2547 
2548         boolean sharedLabel = false;
2549 
2550         Set&lt;String&gt; certLabels = certMap.keySet();
2551         for (String certLabel : certLabels) {
2552             HashSet&lt;AliasInfo&gt; infoSet = certMap.get(certLabel);
2553             for (AliasInfo aliasInfo : infoSet) {
2554 
2555                 if (aliasInfo.matched == true) {
2556                     // already found a private key match for this cert -
2557                     // just continue
2558                     aliasInfo.trusted = false;
2559                     continue;
2560                 }
2561 
2562                 // cert in this aliasInfo is not matched yet
2563                 //
2564                 // if CKA_TRUSTED_SUPPORTED == true,
2565                 // then check if cert is trusted
2566 
2567                 if (CKA_TRUSTED_SUPPORTED) {
2568                     if (aliasInfo.trusted) {
2569                         // trusted certificate
2570                         if (mapTrustedCert
2571                                 (certLabel, aliasInfo, infoSet) == true) {
2572                             sharedLabel = true;
2573                         }
2574                     }
2575                     continue;
2576                 }
2577 
2578                 // CKA_TRUSTED_SUPPORTED == false
2579                 //
2580                 // XXX treat all certs not part of a chain as trusted
2581                 // XXX
2582                 // XXX Unsupported
2583                 //
2584                 // boolean partOfChain = false;
2585                 // for (AliasInfo matchedInfo : matchedCerts) {
2586                 //     for (int i = 0; i &lt; matchedInfo.chain.length; i++) {
2587                 //      if (matchedInfo.chain[i].equals(aliasInfo.cert)) {
2588                 //          partOfChain = true;
2589                 //          break;
2590                 //      }
2591                 //     }
2592                 //     if (partOfChain) {
2593                 //      break;
2594                 //     }
2595                 // }
2596                 //
2597                 // if (!partOfChain) {
2598                 //     if (mapTrustedCert(certLabel,aliasInfo,infoSet) == true){
2599                 //      sharedLabel = true;
2600                 //     }
2601                 // } else {
2602                 //    if (debug != null) {
2603                 //      debug.println(&quot;ignoring unmatched/untrusted cert &quot; +
2604                 //          &quot;that is part of cert chain - cert subject is [&quot; +
2605                 //          aliasInfo.cert.getSubjectX500Principal().getName
2606                 //                              (X500Principal.CANONICAL) +
2607                 //          &quot;]&quot;);
2608                 //     }
2609                 // }
2610             }
2611         }
2612 
2613         return sharedLabel;
2614     }
2615 
2616     private boolean mapTrustedCert(String certLabel,
2617                                 AliasInfo aliasInfo,
2618                                 HashSet&lt;AliasInfo&gt; infoSet) {
2619 
2620         boolean sharedLabel = false;
2621 
2622         aliasInfo.type = ATTR_CLASS_CERT;
2623         aliasInfo.trusted = true;
2624         if (infoSet.size() == 1) {
2625             // unique CKA_LABEL - use certLabel as alias
2626             aliasMap.put(certLabel, aliasInfo);
2627         } else {
2628             // create new alias
2629             sharedLabel = true;
2630             aliasMap.put(getID(certLabel, aliasInfo.cert), aliasInfo);
2631         }
2632 
2633         return sharedLabel;
2634     }
2635 
2636     /**
2637      * If the secret key shares a CKA_LABEL with another entry,
2638      * throw an exception
2639      */
2640     private void mapSecretKeys(HashMap&lt;String, AliasInfo&gt; sKeyMap)
2641                 throws KeyStoreException {
2642         for (String label : sKeyMap.keySet()) {
2643             if (aliasMap.containsKey(label)) {
2644                 throw new KeyStoreException(&quot;invalid KeyStore state: &quot; +
2645                         &quot;found secret key sharing CKA_LABEL [&quot; +
2646                         label +
2647                         &quot;] with another token object&quot;);
2648             }
2649         }
2650         aliasMap.putAll(sKeyMap);
2651     }
2652 
2653     private void dumpTokenMap() {
2654         Set&lt;String&gt; aliases = aliasMap.keySet();
2655         System.out.println(&quot;Token Alias Map:&quot;);
2656         if (aliases.isEmpty()) {
2657             System.out.println(&quot;  [empty]&quot;);
2658         } else {
2659             for (String s : aliases) {
2660                 System.out.println(&quot;  &quot; + s + aliasMap.get(s));
2661             }
2662         }
2663     }
2664 
2665     private void checkWrite() throws KeyStoreException {
2666         if (writeDisabled) {
2667             throw new KeyStoreException
2668                 (&quot;This PKCS11KeyStore does not support write capabilities&quot;);
2669         }
2670     }
2671 
2672     private final static long[] LONG0 = new long[0];
2673 
2674     private static long[] findObjects(Session session, CK_ATTRIBUTE[] attrs)
2675             throws PKCS11Exception {
2676         Token token = session.token;
2677         long[] handles = LONG0;
2678         token.p11.C_FindObjectsInit(session.id(), attrs);
2679         while (true) {
2680             long[] h = token.p11.C_FindObjects(session.id(), FINDOBJECTS_MAX);
2681             if (h.length == 0) {
2682                 break;
2683             }
2684             handles = P11Util.concat(handles, h);
2685         }
2686         token.p11.C_FindObjectsFinal(session.id());
2687         return handles;
2688     }
2689 
2690 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
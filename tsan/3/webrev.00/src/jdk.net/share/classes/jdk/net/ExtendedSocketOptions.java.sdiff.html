<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.net/share/classes/jdk/net/ExtendedSocketOptions.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../macosx/classes/jdk/net/MacOSXSocketOptions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NetworkPermission.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.net/share/classes/jdk/net/ExtendedSocketOptions.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 47 
 48     private static class ExtSocketOption&lt;T&gt; implements SocketOption&lt;T&gt; {
 49         private final String name;
 50         private final Class&lt;T&gt; type;
 51         ExtSocketOption(String name, Class&lt;T&gt; type) {
 52             this.name = name;
 53             this.type = type;
 54         }
 55         @Override public String name() { return name; }
 56         @Override public Class&lt;T&gt; type() { return type; }
 57         @Override public String toString() { return name; }
 58     }
 59 
 60     private ExtendedSocketOptions() { }
 61 
 62     /**
 63      * Service level properties. When a security manager is installed,
 64      * setting or getting this option requires a {@link NetworkPermission}
 65      * {@code (&quot;setOption.SO_FLOW_SLA&quot;)} or {@code &quot;getOption.SO_FLOW_SLA&quot;}
 66      * respectively.


 67      */


 68     public static final SocketOption&lt;SocketFlow&gt; SO_FLOW_SLA = new
 69         ExtSocketOption&lt;SocketFlow&gt;(&quot;SO_FLOW_SLA&quot;, SocketFlow.class);
 70 
 71     /**
 72      * Disable Delayed Acknowledgements.
 73      *
 74      * &lt;p&gt;
 75      * This socket option can be used to reduce or disable delayed
 76      * acknowledgments (ACKs). When {@code TCP_QUICKACK} is enabled, ACKs are
 77      * sent immediately, rather than delayed if needed in accordance to normal
 78      * TCP operation. This option is not permanent, it only enables a switch to
 79      * or from {@code TCP_QUICKACK} mode. Subsequent operations of the TCP
 80      * protocol will once again disable/enable {@code TCP_QUICKACK} mode
 81      * depending on internal protocol processing and factors such as delayed ACK
 82      * timeouts occurring and data transfer, therefore this option needs to be
 83      * set with {@code setOption} after each operation of TCP on a given socket.
 84      *
 85      * &lt;p&gt;
 86      * The value of this socket option is a {@code Boolean} that represents
 87      * whether the option is enabled or disabled. The socket option is specific
</pre>
<hr />
<pre>
175     static Set&lt;SocketOption&lt;?&gt;&gt; options() {
176         Set&lt;SocketOption&lt;?&gt;&gt; options = new HashSet&lt;&gt;();
177         if (flowSupported) {
178             options.add(SO_FLOW_SLA);
179         }
180         if (quickAckSupported) {
181             options.add(TCP_QUICKACK);
182         }
183         if (keepAliveOptSupported) {
184             options.addAll(Set.of(TCP_KEEPCOUNT, TCP_KEEPIDLE, TCP_KEEPINTERVAL));
185         }
186         return Collections.unmodifiableSet(options);
187     }
188 
189     static {
190         // Registers the extended socket options with the base module.
191         sun.net.ext.ExtendedSocketOptions.register(
192                 new sun.net.ext.ExtendedSocketOptions(extendedOptions) {
193 
194             @Override

195             public void setOption(FileDescriptor fd,
196                                   SocketOption&lt;?&gt; option,
197                                   Object value)
198                 throws SocketException
199             {
200                 SecurityManager sm = System.getSecurityManager();
201                 if (sm != null)
202                     sm.checkPermission(new NetworkPermission(&quot;setOption.&quot; + option.name()));
203 
204                 if (fd == null || !fd.valid())
205                     throw new SocketException(&quot;socket closed&quot;);
206 
207                 if (option == SO_FLOW_SLA) {
208                     assert flowSupported;
209                     SocketFlow flow = checkValueType(value, SocketFlow.class);
210                     setFlowOption(fd, flow);
211                 } else if (option == TCP_QUICKACK) {
212                     setQuickAckOption(fd, (boolean) value);
213                 } else if (option == TCP_KEEPCOUNT) {
214                     setTcpkeepAliveProbes(fd, (Integer) value);
215                 } else if (option == TCP_KEEPIDLE) {
216                     setTcpKeepAliveTime(fd, (Integer) value);
217                 } else if (option == TCP_KEEPINTERVAL) {
218                     setTcpKeepAliveIntvl(fd, (Integer) value);
219                 } else {
220                     throw new InternalError(&quot;Unexpected option &quot; + option);
221                 }
222             }
223 
224             @Override

225             public Object getOption(FileDescriptor fd,
226                                     SocketOption&lt;?&gt; option)
227                 throws SocketException
228             {
229                 SecurityManager sm = System.getSecurityManager();
230                 if (sm != null)
231                     sm.checkPermission(new NetworkPermission(&quot;getOption.&quot; + option.name()));
232 
233                 if (fd == null || !fd.valid())
234                     throw new SocketException(&quot;socket closed&quot;);
235 
236                 if (option == SO_FLOW_SLA) {
237                     assert flowSupported;
238                     SocketFlow flow = SocketFlow.create();
239                     getFlowOption(fd, flow);
240                     return flow;
241                 } else if (option == TCP_QUICKACK) {
242                     return getQuickAckOption(fd);
243                 } else if (option == TCP_KEEPCOUNT) {
244                     return getTcpkeepAliveProbes(fd);
</pre>
<hr />
<pre>
248                     return getTcpKeepAliveIntvl(fd);
249                 } else {
250                     throw new InternalError(&quot;Unexpected option &quot; + option);
251                 }
252             }
253         });
254     }
255 
256     @SuppressWarnings(&quot;unchecked&quot;)
257     private static &lt;T&gt; T checkValueType(Object value, Class&lt;T&gt; type) {
258         if (!type.isAssignableFrom(value.getClass())) {
259             String s = &quot;Found: &quot; + value.getClass() + &quot;, Expected: &quot; + type;
260             throw new IllegalArgumentException(s);
261         }
262         return (T) value;
263     }
264 
265     private static final JavaIOFileDescriptorAccess fdAccess =
266             SharedSecrets.getJavaIOFileDescriptorAccess();
267 

268     private static void setFlowOption(FileDescriptor fd, SocketFlow f)
269         throws SocketException
270     {
271         int status = platformSocketOptions.setFlowOption(fdAccess.get(fd),
272                                                          f.priority(),
273                                                          f.bandwidth());
274         f.status(status);  // augment the given flow with the status
275     }
276 

277     private static void getFlowOption(FileDescriptor fd, SocketFlow f)
278             throws SocketException {
279         int status = platformSocketOptions.getFlowOption(fdAccess.get(fd), f);
280         f.status(status);  // augment the given flow with the status
281     }
282 
283     private static void setQuickAckOption(FileDescriptor fd, boolean enable)
284             throws SocketException {
285         platformSocketOptions.setQuickAck(fdAccess.get(fd), enable);
286     }
287 
288     private static Object getQuickAckOption(FileDescriptor fd)
289             throws SocketException {
290         return platformSocketOptions.getQuickAck(fdAccess.get(fd));
291     }
292 
293     private static void setTcpkeepAliveProbes(FileDescriptor fd, int value)
294             throws SocketException {
295         platformSocketOptions.setTcpkeepAliveProbes(fdAccess.get(fd), value);
296     }
</pre>
<hr />
<pre>
345                 return newInstance(&quot;jdk.net.LinuxSocketOptions&quot;);
346             } else if (osname.startsWith(&quot;Mac&quot;)) {
347                 return newInstance(&quot;jdk.net.MacOSXSocketOptions&quot;);
348             } else {
349                 return new PlatformSocketOptions();
350             }
351         }
352 
353         private static final PlatformSocketOptions instance = create();
354 
355         static PlatformSocketOptions get() {
356             return instance;
357         }
358 
359         int setFlowOption(int fd, int priority, long bandwidth)
360             throws SocketException
361         {
362             throw new UnsupportedOperationException(&quot;unsupported socket option&quot;);
363         }
364 

365         int getFlowOption(int fd, SocketFlow f) throws SocketException {
366             throw new UnsupportedOperationException(&quot;unsupported socket option&quot;);
367         }
368 
369         boolean flowSupported() {
370             return false;
371         }
372 
373         void setQuickAck(int fd, boolean on) throws SocketException {
374             throw new UnsupportedOperationException(&quot;unsupported TCP_QUICKACK option&quot;);
375         }
376 
377         boolean getQuickAck(int fd) throws SocketException {
378             throw new UnsupportedOperationException(&quot;unsupported TCP_QUICKACK option&quot;);
379         }
380 
381         boolean quickAckSupported() {
382             return false;
383         }
384 
</pre>
</td>
<td>
<hr />
<pre>
 47 
 48     private static class ExtSocketOption&lt;T&gt; implements SocketOption&lt;T&gt; {
 49         private final String name;
 50         private final Class&lt;T&gt; type;
 51         ExtSocketOption(String name, Class&lt;T&gt; type) {
 52             this.name = name;
 53             this.type = type;
 54         }
 55         @Override public String name() { return name; }
 56         @Override public Class&lt;T&gt; type() { return type; }
 57         @Override public String toString() { return name; }
 58     }
 59 
 60     private ExtendedSocketOptions() { }
 61 
 62     /**
 63      * Service level properties. When a security manager is installed,
 64      * setting or getting this option requires a {@link NetworkPermission}
 65      * {@code (&quot;setOption.SO_FLOW_SLA&quot;)} or {@code &quot;getOption.SO_FLOW_SLA&quot;}
 66      * respectively.
<span class="line-added"> 67      * @deprecated This is supported only on Solaris. Due to deprecation</span>
<span class="line-added"> 68      * of Solaris port, this option is also deprecated.</span>
 69      */
<span class="line-added"> 70     @Deprecated(since=&quot;14&quot;, forRemoval=true)</span>
<span class="line-added"> 71     @SuppressWarnings(&quot;removal&quot;)</span>
 72     public static final SocketOption&lt;SocketFlow&gt; SO_FLOW_SLA = new
 73         ExtSocketOption&lt;SocketFlow&gt;(&quot;SO_FLOW_SLA&quot;, SocketFlow.class);
 74 
 75     /**
 76      * Disable Delayed Acknowledgements.
 77      *
 78      * &lt;p&gt;
 79      * This socket option can be used to reduce or disable delayed
 80      * acknowledgments (ACKs). When {@code TCP_QUICKACK} is enabled, ACKs are
 81      * sent immediately, rather than delayed if needed in accordance to normal
 82      * TCP operation. This option is not permanent, it only enables a switch to
 83      * or from {@code TCP_QUICKACK} mode. Subsequent operations of the TCP
 84      * protocol will once again disable/enable {@code TCP_QUICKACK} mode
 85      * depending on internal protocol processing and factors such as delayed ACK
 86      * timeouts occurring and data transfer, therefore this option needs to be
 87      * set with {@code setOption} after each operation of TCP on a given socket.
 88      *
 89      * &lt;p&gt;
 90      * The value of this socket option is a {@code Boolean} that represents
 91      * whether the option is enabled or disabled. The socket option is specific
</pre>
<hr />
<pre>
179     static Set&lt;SocketOption&lt;?&gt;&gt; options() {
180         Set&lt;SocketOption&lt;?&gt;&gt; options = new HashSet&lt;&gt;();
181         if (flowSupported) {
182             options.add(SO_FLOW_SLA);
183         }
184         if (quickAckSupported) {
185             options.add(TCP_QUICKACK);
186         }
187         if (keepAliveOptSupported) {
188             options.addAll(Set.of(TCP_KEEPCOUNT, TCP_KEEPIDLE, TCP_KEEPINTERVAL));
189         }
190         return Collections.unmodifiableSet(options);
191     }
192 
193     static {
194         // Registers the extended socket options with the base module.
195         sun.net.ext.ExtendedSocketOptions.register(
196                 new sun.net.ext.ExtendedSocketOptions(extendedOptions) {
197 
198             @Override
<span class="line-added">199             @SuppressWarnings(&quot;removal&quot;)</span>
200             public void setOption(FileDescriptor fd,
201                                   SocketOption&lt;?&gt; option,
202                                   Object value)
203                 throws SocketException
204             {
205                 SecurityManager sm = System.getSecurityManager();
206                 if (sm != null)
207                     sm.checkPermission(new NetworkPermission(&quot;setOption.&quot; + option.name()));
208 
209                 if (fd == null || !fd.valid())
210                     throw new SocketException(&quot;socket closed&quot;);
211 
212                 if (option == SO_FLOW_SLA) {
213                     assert flowSupported;
214                     SocketFlow flow = checkValueType(value, SocketFlow.class);
215                     setFlowOption(fd, flow);
216                 } else if (option == TCP_QUICKACK) {
217                     setQuickAckOption(fd, (boolean) value);
218                 } else if (option == TCP_KEEPCOUNT) {
219                     setTcpkeepAliveProbes(fd, (Integer) value);
220                 } else if (option == TCP_KEEPIDLE) {
221                     setTcpKeepAliveTime(fd, (Integer) value);
222                 } else if (option == TCP_KEEPINTERVAL) {
223                     setTcpKeepAliveIntvl(fd, (Integer) value);
224                 } else {
225                     throw new InternalError(&quot;Unexpected option &quot; + option);
226                 }
227             }
228 
229             @Override
<span class="line-added">230             @SuppressWarnings(&quot;removal&quot;)</span>
231             public Object getOption(FileDescriptor fd,
232                                     SocketOption&lt;?&gt; option)
233                 throws SocketException
234             {
235                 SecurityManager sm = System.getSecurityManager();
236                 if (sm != null)
237                     sm.checkPermission(new NetworkPermission(&quot;getOption.&quot; + option.name()));
238 
239                 if (fd == null || !fd.valid())
240                     throw new SocketException(&quot;socket closed&quot;);
241 
242                 if (option == SO_FLOW_SLA) {
243                     assert flowSupported;
244                     SocketFlow flow = SocketFlow.create();
245                     getFlowOption(fd, flow);
246                     return flow;
247                 } else if (option == TCP_QUICKACK) {
248                     return getQuickAckOption(fd);
249                 } else if (option == TCP_KEEPCOUNT) {
250                     return getTcpkeepAliveProbes(fd);
</pre>
<hr />
<pre>
254                     return getTcpKeepAliveIntvl(fd);
255                 } else {
256                     throw new InternalError(&quot;Unexpected option &quot; + option);
257                 }
258             }
259         });
260     }
261 
262     @SuppressWarnings(&quot;unchecked&quot;)
263     private static &lt;T&gt; T checkValueType(Object value, Class&lt;T&gt; type) {
264         if (!type.isAssignableFrom(value.getClass())) {
265             String s = &quot;Found: &quot; + value.getClass() + &quot;, Expected: &quot; + type;
266             throw new IllegalArgumentException(s);
267         }
268         return (T) value;
269     }
270 
271     private static final JavaIOFileDescriptorAccess fdAccess =
272             SharedSecrets.getJavaIOFileDescriptorAccess();
273 
<span class="line-added">274     @SuppressWarnings(&quot;removal&quot;)</span>
275     private static void setFlowOption(FileDescriptor fd, SocketFlow f)
276         throws SocketException
277     {
278         int status = platformSocketOptions.setFlowOption(fdAccess.get(fd),
279                                                          f.priority(),
280                                                          f.bandwidth());
281         f.status(status);  // augment the given flow with the status
282     }
283 
<span class="line-added">284     @SuppressWarnings(&quot;removal&quot;)</span>
285     private static void getFlowOption(FileDescriptor fd, SocketFlow f)
286             throws SocketException {
287         int status = platformSocketOptions.getFlowOption(fdAccess.get(fd), f);
288         f.status(status);  // augment the given flow with the status
289     }
290 
291     private static void setQuickAckOption(FileDescriptor fd, boolean enable)
292             throws SocketException {
293         platformSocketOptions.setQuickAck(fdAccess.get(fd), enable);
294     }
295 
296     private static Object getQuickAckOption(FileDescriptor fd)
297             throws SocketException {
298         return platformSocketOptions.getQuickAck(fdAccess.get(fd));
299     }
300 
301     private static void setTcpkeepAliveProbes(FileDescriptor fd, int value)
302             throws SocketException {
303         platformSocketOptions.setTcpkeepAliveProbes(fdAccess.get(fd), value);
304     }
</pre>
<hr />
<pre>
353                 return newInstance(&quot;jdk.net.LinuxSocketOptions&quot;);
354             } else if (osname.startsWith(&quot;Mac&quot;)) {
355                 return newInstance(&quot;jdk.net.MacOSXSocketOptions&quot;);
356             } else {
357                 return new PlatformSocketOptions();
358             }
359         }
360 
361         private static final PlatformSocketOptions instance = create();
362 
363         static PlatformSocketOptions get() {
364             return instance;
365         }
366 
367         int setFlowOption(int fd, int priority, long bandwidth)
368             throws SocketException
369         {
370             throw new UnsupportedOperationException(&quot;unsupported socket option&quot;);
371         }
372 
<span class="line-added">373         @SuppressWarnings(&quot;removal&quot;)</span>
374         int getFlowOption(int fd, SocketFlow f) throws SocketException {
375             throw new UnsupportedOperationException(&quot;unsupported socket option&quot;);
376         }
377 
378         boolean flowSupported() {
379             return false;
380         }
381 
382         void setQuickAck(int fd, boolean on) throws SocketException {
383             throw new UnsupportedOperationException(&quot;unsupported TCP_QUICKACK option&quot;);
384         }
385 
386         boolean getQuickAck(int fd) throws SocketException {
387             throw new UnsupportedOperationException(&quot;unsupported TCP_QUICKACK option&quot;);
388         }
389 
390         boolean quickAckSupported() {
391             return false;
392         }
393 
</pre>
</td>
</tr>
</table>
<center><a href="../../../../macosx/classes/jdk/net/MacOSXSocketOptions.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NetworkPermission.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
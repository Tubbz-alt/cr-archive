<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.accessibility/windows/native/common/AccessBridgeDebug.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * A class to manage AccessBridge debugging
 28  */
 29 
 30 #include &quot;AccessBridgeDebug.h&quot;
 31 #include &lt;stdarg.h&gt;
 32 #include &lt;stdio.h&gt;
 33 #include &lt;windows.h&gt;
 34 #include &lt;cstdlib&gt;
 35 #include &lt;chrono&gt;
 36 #include &lt;cstring&gt;
 37 
 38 #ifdef __cplusplus
 39 extern &quot;C&quot; {
 40 #endif
 41 
 42 static FILE* logFP = nullptr;
 43 
 44 void initializeFileLogger(char * fileName) {
 45     auto var = &quot;JAVA_ACCESSBRIDGE_LOGDIR&quot;;
 46     const auto envfilePath = getenv(var);
 47     if (envfilePath != nullptr &amp;&amp; fileName != nullptr) {
 48         auto envFilePathLength = strlen(envfilePath);
 49         auto fileNameLength = strlen(fileName);
 50         auto filePathSize = envFilePathLength + 1 + fileNameLength + 5; //1 for &quot;/&quot;, 5 for &quot;.log&quot; and 0;
 51         auto filePath = new char[filePathSize];
 52         memset(filePath, 0, filePathSize*sizeof(char));
 53         memcpy(filePath, envfilePath, envFilePathLength*sizeof(char));
 54         filePath[envFilePathLength] = &#39;/&#39;;
 55         memcpy(filePath + envFilePathLength + 1, fileName, fileNameLength*sizeof(char));
 56         memcpy(filePath + envFilePathLength + 1 + fileNameLength, &quot;.log&quot;, 4*sizeof(char));
 57 
 58         logFP = fopen(filePath, &quot;w&quot;);
 59         if (logFP == nullptr) {
 60             printf(&quot;\n%s\n&quot;, filePath);
 61             PrintDebugString(&quot;Could not open file %s&quot;, filePath);
 62         }
 63 
 64         delete [] filePath;
 65     }
 66 }
 67 
 68 void finalizeFileLogger() {
 69     if (logFP) {
 70         fclose(logFP);
 71         logFP = nullptr;
 72     }
 73 }
 74 
 75 auto getTimeStamp() -&gt; long long {
 76     using namespace std::chrono;
 77     auto timeNow = duration_cast&lt;milliseconds&gt;(steady_clock::now().time_since_epoch());
 78 
 79     return timeNow.count();
 80 }
 81 
 82 /**
 83  * print a GetLastError message
 84  */
 85 char *printError(char *msg) {
 86     LPVOID lpMsgBuf = nullptr;
 87     static char retbuf[256] = {0};
 88 
 89     if (msg != nullptr) {
 90         strncpy((char *)retbuf, msg, sizeof(retbuf));
 91         // if msg text is &gt;= 256 ensure buffer is null terminated
 92         retbuf[255] = &#39;\0&#39;;
 93     }
 94     if (!FormatMessage(
 95                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
 96                        FORMAT_MESSAGE_FROM_SYSTEM |
 97                        FORMAT_MESSAGE_IGNORE_INSERTS,
 98                        nullptr,
 99                        GetLastError(),
100                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
101                        (LPTSTR) &amp;lpMsgBuf,
102                        0,
103                        nullptr))
104         {
105             PrintDebugString(&quot;  %s: FormatMessage failed&quot;, msg);
106         } else {
107             PrintDebugString(&quot;  %s: %s&quot;, msg, (char *)lpMsgBuf);
108         }
109     if (lpMsgBuf != nullptr) {
110         strncat((char *)retbuf, &quot;: &quot;, sizeof(retbuf) - strlen(retbuf) - 1);
111         strncat((char *)retbuf, (char *)lpMsgBuf, sizeof(retbuf) - strlen(retbuf) - 1);
112         LocalFree(lpMsgBuf);
113     }
114     return (char *)retbuf;
115 }
116 
117 
118     /**
119      * Send debugging info to the appropriate place
120      */
121     void PrintDebugString(char *msg, ...) {
122 #ifdef DEBUGGING_ON
123         char buf[1024] = {0};
124         va_list argprt;
125 
126         va_start(argprt, msg);     // set up argptr
127         vsprintf(buf, msg, argprt);
128 #ifdef SEND_TO_OUTPUT_DEBUG_STRING
129         OutputDebugString(buf);
130 #endif
131 #ifdef SEND_TO_CONSOLE
132         printf(buf);
133         printf(&quot;\r\n&quot;);
134 #endif
135 #endif
136         if (logFP) {
137             fprintf(logFP, &quot;[%llu] &quot;, getTimeStamp());
138             va_list args;
139             va_start(args, msg);
140             vfprintf(logFP, msg, args);
141             va_end(args);
142             fprintf(logFP, &quot;\r\n&quot;);
143         }
144     }
145 
146     /**
147      * Send Java debugging info to the appropriate place
148      */
149     void PrintJavaDebugString2(char *msg, ...) {
150 #ifdef JAVA_DEBUGGING_ON
151         char buf[1024] = {0};
152         va_list argprt;
153 
154         va_start(argprt, msg);     // set up argptr
155         vsprintf(buf, msg, argprt);
156 #ifdef SEND_TO_OUTPUT_DEBUG_STRING
157         OutputDebugString(buf);
158 #endif
159 #ifdef SEND_TO_CONSOLE
160         printf(buf);
161         printf(&quot;\r\n&quot;);
162 #endif
163 #endif
164         if (logFP) {
165             fprintf(logFP, &quot;[%llu] &quot;, getTimeStamp());
166             va_list args;
167             va_start(args, msg);
168             vfprintf(logFP, msg, args);
169             va_end(args);
170             fprintf(logFP, &quot;\r\n&quot;);
171         }
172     }
173     /**
174      * Wide version of the method to send debugging info to the appropriate place
175      */
176     void wPrintDebugString(wchar_t *msg, ...) {
177 #ifdef DEBUGGING_ON
178         char buf[1024] = {0};
179         char charmsg[256];
180         va_list argprt;
181 
182         va_start(argprt, msg);          // set up argptr
183         sprintf(charmsg, &quot;%ls&quot;, msg);  // convert format string to multi-byte
184         vsprintf(buf, charmsg, argprt);
185 #ifdef SEND_TO_OUTPUT_DEBUG_STRING
186         OutputDebugString(buf);
187 #endif
188 #ifdef SEND_TO_CONSOLE
189         printf(buf);
190         printf(&quot;\r\n&quot;);
191 #endif
192 #endif
193         if (logFP) {
194             fprintf(logFP, &quot;[%llu] &quot;, getTimeStamp());
195             va_list args;
196             va_start(args, msg);
197             vfwprintf(logFP, msg, args);
198             va_end(args);
199             fprintf(logFP, &quot;\r\n&quot;);
200         }
201     }
202 
203     /**
204      * Wide version of the method to send Java debugging info to the appropriate place
205      */
206     void wPrintJavaDebugString(wchar_t *msg, ...) {
207 #ifdef JAVA_DEBUGGING_ON
208         char buf[1024] = {0};
209         char charmsg[256] = {0};
210         va_list argprt;
211 
212         va_start(argprt, msg);          // set up argptr
213         sprintf(charmsg, &quot;%ls&quot;, msg);  // convert format string to multi-byte
214         vsprintf(buf, charmsg, argprt);
215 #ifdef SEND_TO_OUTPUT_DEBUG_STRING
216         OutputDebugString(buf);
217 #endif
218 #ifdef SEND_TO_CONSOLE
219         printf(buf);
220         printf(&quot;\r\n&quot;);
221 #endif
222 #endif
223         if (logFP) {
224             fprintf(logFP, &quot;[%llu] &quot;, getTimeStamp());
225             va_list args;
226             va_start(args, msg);
227             vfwprintf(logFP, msg, args);
228             va_end(args);
229             fprintf(logFP, &quot;\r\n&quot;);
230         }
231     }
232 #ifdef __cplusplus
233 }
234 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.accessibility/windows/native/common/AccessBridgeDebug.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * A class to manage AccessBridge debugging
 28  */
 29 
 30 #include &quot;AccessBridgeDebug.h&quot;
 31 #include &lt;stdarg.h&gt;
 32 #include &lt;stdio.h&gt;
 33 #include &lt;windows.h&gt;
 34 #include &lt;cstdlib&gt;
 35 #include &lt;chrono&gt;
 36 #include &lt;cstring&gt;
 37 
 38 #ifdef __cplusplus
 39 extern &quot;C&quot; {
 40 #endif
 41 
 42 static FILE* logFP = nullptr;
 43 
<a name="2" id="anc2"></a><span class="line-modified"> 44 void initializeFileLogger(char * suffix) {</span>
<span class="line-modified"> 45     auto var = &quot;JAVA_ACCESSBRIDGE_LOGFILE&quot;;</span>
 46     const auto envfilePath = getenv(var);
<a name="3" id="anc3"></a><span class="line-modified"> 47     if (envfilePath != nullptr) {</span>
<span class="line-modified"> 48         auto ext = const_cast&lt;char*&gt;(strrchr(envfilePath, &#39;.&#39;));</span>
<span class="line-modified"> 49         auto filePath = static_cast&lt;char*&gt;(nullptr);</span>
<span class="line-modified"> 50         auto len = strlen(envfilePath);</span>
<span class="line-modified"> 51         auto suffixlen = suffix != nullptr ? strlen(suffix) : (decltype(strlen(nullptr)))0;</span>
<span class="line-modified"> 52 </span>
<span class="line-modified"> 53         if (ext == nullptr) {</span>
<span class="line-modified"> 54             filePath = new char[len + suffixlen + 5];</span>
<span class="line-modified"> 55             memset(filePath, 0, len + suffixlen + 5);</span>
<span class="line-modified"> 56             memcpy(filePath, envfilePath, len);</span>
<span class="line-removed"> 57             memcpy(filePath + len, suffix, suffixlen);</span>
<span class="line-removed"> 58             memcpy(filePath + len + suffixlen, &quot;.log&quot;, 4);</span>
<span class="line-removed"> 59         } else {</span>
<span class="line-removed"> 60             auto extLen = strlen(ext);</span>
<span class="line-removed"> 61 </span>
<span class="line-removed"> 62             filePath = new char[len + suffixlen + 1];</span>
<span class="line-removed"> 63             memset(filePath, 0, len + suffixlen + 1);</span>
<span class="line-removed"> 64             memcpy(filePath, envfilePath, len - extLen);</span>
<span class="line-removed"> 65             memcpy(filePath + len - extLen, suffix, suffixlen);</span>
<span class="line-removed"> 66             memcpy(filePath + len + suffixlen - extLen, ext, extLen);</span>
<span class="line-removed"> 67         }</span>
 68 
 69         logFP = fopen(filePath, &quot;w&quot;);
 70         if (logFP == nullptr) {
<a name="4" id="anc4"></a><span class="line-modified"> 71             PrintDebugString(&quot;couldnot open file %s&quot;, filePath);</span>

 72         }
 73 
 74         delete [] filePath;
 75     }
 76 }
 77 
 78 void finalizeFileLogger() {
 79     if (logFP) {
 80         fclose(logFP);
 81         logFP = nullptr;
 82     }
 83 }
 84 
 85 auto getTimeStamp() -&gt; long long {
 86     using namespace std::chrono;
 87     auto timeNow = duration_cast&lt;milliseconds&gt;(steady_clock::now().time_since_epoch());
 88 
 89     return timeNow.count();
 90 }
 91 
 92 /**
 93  * print a GetLastError message
 94  */
 95 char *printError(char *msg) {
 96     LPVOID lpMsgBuf = nullptr;
 97     static char retbuf[256] = {0};
 98 
 99     if (msg != nullptr) {
100         strncpy((char *)retbuf, msg, sizeof(retbuf));
101         // if msg text is &gt;= 256 ensure buffer is null terminated
102         retbuf[255] = &#39;\0&#39;;
103     }
104     if (!FormatMessage(
105                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
106                        FORMAT_MESSAGE_FROM_SYSTEM |
107                        FORMAT_MESSAGE_IGNORE_INSERTS,
108                        nullptr,
109                        GetLastError(),
110                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
111                        (LPTSTR) &amp;lpMsgBuf,
112                        0,
113                        nullptr))
114         {
115             PrintDebugString(&quot;  %s: FormatMessage failed&quot;, msg);
116         } else {
117             PrintDebugString(&quot;  %s: %s&quot;, msg, (char *)lpMsgBuf);
118         }
119     if (lpMsgBuf != nullptr) {
120         strncat((char *)retbuf, &quot;: &quot;, sizeof(retbuf) - strlen(retbuf) - 1);
121         strncat((char *)retbuf, (char *)lpMsgBuf, sizeof(retbuf) - strlen(retbuf) - 1);
122         LocalFree(lpMsgBuf);
123     }
124     return (char *)retbuf;
125 }
126 
127 
128     /**
129      * Send debugging info to the appropriate place
130      */
131     void PrintDebugString(char *msg, ...) {
132 #ifdef DEBUGGING_ON
133         char buf[1024] = {0};
134         va_list argprt;
135 
136         va_start(argprt, msg);     // set up argptr
137         vsprintf(buf, msg, argprt);
138 #ifdef SEND_TO_OUTPUT_DEBUG_STRING
139         OutputDebugString(buf);
140 #endif
141 #ifdef SEND_TO_CONSOLE
142         printf(buf);
143         printf(&quot;\r\n&quot;);
144 #endif
145 #endif
146         if (logFP) {
<a name="5" id="anc5"></a><span class="line-modified">147             fprintf(logFP, &quot;[%lldu] &quot;, getTimeStamp());</span>
148             va_list args;
149             va_start(args, msg);
150             vfprintf(logFP, msg, args);
151             va_end(args);
152             fprintf(logFP, &quot;\r\n&quot;);
153         }
154     }
155 
156     /**
157      * Send Java debugging info to the appropriate place
158      */
159     void PrintJavaDebugString2(char *msg, ...) {
160 #ifdef JAVA_DEBUGGING_ON
161         char buf[1024] = {0};
162         va_list argprt;
163 
164         va_start(argprt, msg);     // set up argptr
165         vsprintf(buf, msg, argprt);
166 #ifdef SEND_TO_OUTPUT_DEBUG_STRING
167         OutputDebugString(buf);
168 #endif
169 #ifdef SEND_TO_CONSOLE
170         printf(buf);
171         printf(&quot;\r\n&quot;);
172 #endif
173 #endif
174         if (logFP) {
175             fprintf(logFP, &quot;[%llu] &quot;, getTimeStamp());
176             va_list args;
177             va_start(args, msg);
178             vfprintf(logFP, msg, args);
179             va_end(args);
180             fprintf(logFP, &quot;\r\n&quot;);
181         }
182     }
183     /**
184      * Wide version of the method to send debugging info to the appropriate place
185      */
186     void wPrintDebugString(wchar_t *msg, ...) {
187 #ifdef DEBUGGING_ON
188         char buf[1024] = {0};
189         char charmsg[256];
190         va_list argprt;
191 
192         va_start(argprt, msg);          // set up argptr
193         sprintf(charmsg, &quot;%ls&quot;, msg);  // convert format string to multi-byte
194         vsprintf(buf, charmsg, argprt);
195 #ifdef SEND_TO_OUTPUT_DEBUG_STRING
196         OutputDebugString(buf);
197 #endif
198 #ifdef SEND_TO_CONSOLE
199         printf(buf);
200         printf(&quot;\r\n&quot;);
201 #endif
202 #endif
203         if (logFP) {
204             fprintf(logFP, &quot;[%llu] &quot;, getTimeStamp());
205             va_list args;
206             va_start(args, msg);
207             vfwprintf(logFP, msg, args);
208             va_end(args);
209             fprintf(logFP, &quot;\r\n&quot;);
210         }
211     }
212 
213     /**
214      * Wide version of the method to send Java debugging info to the appropriate place
215      */
216     void wPrintJavaDebugString(wchar_t *msg, ...) {
217 #ifdef JAVA_DEBUGGING_ON
218         char buf[1024] = {0};
219         char charmsg[256] = {0};
220         va_list argprt;
221 
222         va_start(argprt, msg);          // set up argptr
223         sprintf(charmsg, &quot;%ls&quot;, msg);  // convert format string to multi-byte
224         vsprintf(buf, charmsg, argprt);
225 #ifdef SEND_TO_OUTPUT_DEBUG_STRING
226         OutputDebugString(buf);
227 #endif
228 #ifdef SEND_TO_CONSOLE
229         printf(buf);
230         printf(&quot;\r\n&quot;);
231 #endif
232 #endif
233         if (logFP) {
234             fprintf(logFP, &quot;[%llu] &quot;, getTimeStamp());
235             va_list args;
236             va_start(args, msg);
237             vfwprintf(logFP, msg, args);
238             va_end(args);
239             fprintf(logFP, &quot;\r\n&quot;);
240         }
241     }
242 #ifdef __cplusplus
243 }
244 #endif
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
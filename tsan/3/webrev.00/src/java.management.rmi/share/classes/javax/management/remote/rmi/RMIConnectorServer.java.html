<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.management.rmi/share/classes/javax/management/remote/rmi/RMIConnectorServer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.management.remote.rmi;
 27 
 28 
 29 import com.sun.jmx.remote.security.MBeanServerFileAccessController;
 30 import com.sun.jmx.remote.util.ClassLogger;
 31 import com.sun.jmx.remote.util.EnvHelp;
 32 
 33 import java.io.ByteArrayOutputStream;
 34 import java.io.IOException;
 35 import java.io.ObjectInputFilter;
 36 import java.io.ObjectOutputStream;
 37 import java.net.MalformedURLException;
 38 import java.rmi.server.RMIClientSocketFactory;
 39 import java.rmi.server.RMIServerSocketFactory;
 40 import java.util.Collections;
 41 import java.util.HashMap;
 42 import java.util.HashSet;
 43 import java.util.Hashtable;
 44 import java.util.Map;
 45 import java.util.Set;
 46 
 47 import javax.management.InstanceNotFoundException;
 48 import javax.management.MBeanServer;
 49 import javax.management.remote.JMXAuthenticator;
 50 
 51 import javax.management.remote.JMXConnectionNotification;
 52 import javax.management.remote.JMXConnector;
 53 import javax.management.remote.JMXConnectorServer;
 54 import javax.management.remote.JMXServiceURL;
 55 import javax.management.remote.MBeanServerForwarder;
 56 
 57 import javax.naming.InitialContext;
 58 import javax.naming.NamingException;
 59 
 60 /**
 61  * &lt;p&gt;A JMX API connector server that creates RMI-based connections
 62  * from remote clients.  Usually, such connector servers are made
 63  * using {@link javax.management.remote.JMXConnectorServerFactory
 64  * JMXConnectorServerFactory}.  However, specialized applications can
 65  * use this class directly, for example with an {@link RMIServerImpl}
 66  * object.&lt;/p&gt;
 67  *
 68  * @since 1.5
 69  */
 70 public class RMIConnectorServer extends JMXConnectorServer {
 71     /**
 72      * &lt;p&gt;Name of the attribute that specifies whether the {@link
 73      * RMIServer} stub that represents an RMI connector server should
 74      * override an existing stub at the same address.  The value
 75      * associated with this attribute, if any, should be a string that
 76      * is equal, ignoring case, to &lt;code&gt;&quot;true&quot;&lt;/code&gt; or
 77      * &lt;code&gt;&quot;false&quot;&lt;/code&gt;.  The default value is false.&lt;/p&gt;
 78      */
 79     public static final String JNDI_REBIND_ATTRIBUTE =
 80         &quot;jmx.remote.jndi.rebind&quot;;
 81 
 82     /**
 83      * &lt;p&gt;Name of the attribute that specifies the {@link
 84      * RMIClientSocketFactory} for the RMI objects created in
 85      * conjunction with this connector. The value associated with this
 86      * attribute must be of type &lt;code&gt;RMIClientSocketFactory&lt;/code&gt; and can
 87      * only be specified in the &lt;code&gt;Map&lt;/code&gt; argument supplied when
 88      * creating a connector server.&lt;/p&gt;
 89      */
 90     public static final String RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE =
 91         &quot;jmx.remote.rmi.client.socket.factory&quot;;
 92 
 93     /**
 94      * &lt;p&gt;Name of the attribute that specifies the {@link
 95      * RMIServerSocketFactory} for the RMI objects created in
 96      * conjunction with this connector. The value associated with this
 97      * attribute must be of type &lt;code&gt;RMIServerSocketFactory&lt;/code&gt; and can
 98      * only be specified in the &lt;code&gt;Map&lt;/code&gt; argument supplied when
 99      * creating a connector server.&lt;/p&gt;
100      */
101     public static final String RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE =
102         &quot;jmx.remote.rmi.server.socket.factory&quot;;
103 
104     /**
105     * Name of the attribute that specifies an
106     * {@link ObjectInputFilter} pattern string to filter classes acceptable
107     * for {@link RMIServer#newClient(java.lang.Object) RMIServer.newClient()}
108     * remote method call.
109     * &lt;p&gt;
110     * The filter pattern must be in same format as used in
111     * {@link java.io.ObjectInputFilter.Config#createFilter}
112     * &lt;p&gt;
113     * This list of classes allowed by filter should correspond to the
114     * transitive closure of the credentials class (or classes) used by the
115     * installed {@linkplain JMXAuthenticator} associated with the
116     * {@linkplain RMIServer} implementation.
117     * If the attribute is not set then any class is deemed acceptable.
118     * @see ObjectInputFilter
119     */
120     public static final String CREDENTIALS_FILTER_PATTERN =
121         &quot;jmx.remote.rmi.server.credentials.filter.pattern&quot;;
122 
123     /**
124      * This attribute defines a pattern from which to create a
125      * {@link java.io.ObjectInputFilter} that will be used when deserializing
126      * objects sent to the {@code JMXConnectorServer} by any client.
127      * &lt;p&gt;
128      * The filter will be called for any class found in the serialized
129      * stream sent to server by client, including all JMX defined classes
130      * (such as {@link javax.management.ObjectName}), all method parameters,
131      * and, if present in the stream, all classes transitively referred by
132      * the serial form of any deserialized object.
133      * The pattern must be in same format as used in
134      * {@link java.io.ObjectInputFilter.Config#createFilter}.
135      * It may define a white list of permitted classes, a black list of
136      * rejected classes, a maximum depth for the deserialized objects,
137      * etc.
138      * &lt;p&gt;
139      * To be functional, the filter should allow at least all the
140      * concrete types in the transitive closure of all objects that
141      * might get serialized when serializing all JMX classes referred
142      * as parameters in the {@link
143      * javax.management.remote.rmi.RMIConnection} interface,
144      * plus all classes that a {@link javax.management.remote.rmi.RMIConnector client}
145      * might need to transmit wrapped in {@linkplain java.rmi.MarshalledObject
146      * marshalled objects} in order to interoperate with the MBeans registered
147      * in the {@code MBeanServer}. That would potentially include all the
148      * concrete {@linkplain javax.management.openmbean  JMX OpenTypes} and the
149      * classes they use in their serial form.
150      * &lt;p&gt;
151      * Care must be taken when defining such a filter, as defining
152      * a white list too restrictive or a too wide a black list may
153      * prevent legitimate clients from interoperating with the
154      * {@code JMXConnectorServer}.
155      */
156     public static final String SERIAL_FILTER_PATTERN =
157        &quot;jmx.remote.rmi.server.serial.filter.pattern&quot;;
158 
159     /**
160      * &lt;p&gt;Makes an &lt;code&gt;RMIConnectorServer&lt;/code&gt;.
161      * This is equivalent to calling {@link #RMIConnectorServer(
162      * JMXServiceURL,Map,RMIServerImpl,MBeanServer)
163      * RMIConnectorServer(directoryURL,environment,null,null)}&lt;/p&gt;
164      *
165      * @param url the URL defining how to create the connector server.
166      * Cannot be null.
167      *
168      * @param environment attributes governing the creation and
169      * storing of the RMI object.  Can be null, which is equivalent to
170      * an empty Map.
171      *
172      * @exception IllegalArgumentException if &lt;code&gt;url&lt;/code&gt; is null.
173      *
174      * @exception MalformedURLException if &lt;code&gt;url&lt;/code&gt; does not
175      * conform to the syntax for an RMI connector, or if its protocol
176      * is not recognized by this implementation. Only &quot;rmi&quot; is valid when
177      * this constructor is used.
178      *
179      * @exception IOException if the connector server cannot be created
180      * for some reason or if it is inevitable that its {@link #start()
181      * start} method will fail.
182      */
183     public RMIConnectorServer(JMXServiceURL url, Map&lt;String,?&gt; environment)
184             throws IOException {
185         this(url, environment, (MBeanServer) null);
186     }
187 
188     /**
189      * &lt;p&gt;Makes an &lt;code&gt;RMIConnectorServer&lt;/code&gt; for the given MBean
190      * server.
191      * This is equivalent to calling {@link #RMIConnectorServer(
192      * JMXServiceURL,Map,RMIServerImpl,MBeanServer)
193      * RMIConnectorServer(directoryURL,environment,null,mbeanServer)}&lt;/p&gt;
194      *
195      * @param url the URL defining how to create the connector server.
196      * Cannot be null.
197      *
198      * @param environment attributes governing the creation and
199      * storing of the RMI object.  Can be null, which is equivalent to
200      * an empty Map.
201      *
202      * @param mbeanServer the MBean server to which the new connector
203      * server is attached, or null if it will be attached by being
204      * registered as an MBean in the MBean server.
205      *
206      * @exception IllegalArgumentException if &lt;code&gt;url&lt;/code&gt; is null.
207      *
208      * @exception MalformedURLException if &lt;code&gt;url&lt;/code&gt; does not
209      * conform to the syntax for an RMI connector, or if its protocol
210      * is not recognized by this implementation. Only &quot;rmi&quot; is valid
211      * when this constructor is used.
212      *
213      * @exception IOException if the connector server cannot be created
214      * for some reason or if it is inevitable that its {@link #start()
215      * start} method will fail.
216      */
217     public RMIConnectorServer(JMXServiceURL url, Map&lt;String,?&gt; environment,
218                               MBeanServer mbeanServer)
219             throws IOException {
220         this(url, environment, (RMIServerImpl) null, mbeanServer);
221     }
222 
223     /**
224      * &lt;p&gt;Makes an &lt;code&gt;RMIConnectorServer&lt;/code&gt; for the given MBean
225      * server.&lt;/p&gt;
226      *
227      * @param url the URL defining how to create the connector server.
228      * Cannot be null.
229      *
230      * @param environment attributes governing the creation and
231      * storing of the RMI object.  Can be null, which is equivalent to
232      * an empty Map.
233      *
234      * @param rmiServerImpl An implementation of the RMIServer interface,
235      *  consistent with the protocol type specified in &lt;var&gt;url&lt;/var&gt;.
236      *  If this parameter is non null, the protocol type specified by
237      *  &lt;var&gt;url&lt;/var&gt; is not constrained, and is assumed to be valid.
238      *  Otherwise, only &quot;rmi&quot; will be recognized.
239      *
240      * @param mbeanServer the MBean server to which the new connector
241      * server is attached, or null if it will be attached by being
242      * registered as an MBean in the MBean server.
243      *
244      * @exception IllegalArgumentException if &lt;code&gt;url&lt;/code&gt; is null.
245      *
246      * @exception MalformedURLException if &lt;code&gt;url&lt;/code&gt; does not
247      * conform to the syntax for an RMI connector, or if its protocol
248      * is not recognized by this implementation. Only &quot;rmi&quot; is recognized
249      * when &lt;var&gt;rmiServerImpl&lt;/var&gt; is null.
250      *
251      * @exception IOException if the connector server cannot be created
252      * for some reason or if it is inevitable that its {@link #start()
253      * start} method will fail.
254      *
255      * @see #start
256      */
257     public RMIConnectorServer(JMXServiceURL url, Map&lt;String,?&gt; environment,
258                               RMIServerImpl rmiServerImpl,
259                               MBeanServer mbeanServer)
260             throws IOException {
261         super(mbeanServer);
262 
263         if (url == null) throw new
264             IllegalArgumentException(&quot;Null JMXServiceURL&quot;);
265         if (rmiServerImpl == null) {
266             final String prt = url.getProtocol();
267             if (prt == null || !(prt.equals(&quot;rmi&quot;))) {
268                 final String msg = &quot;Invalid protocol type: &quot; + prt;
269                 throw new MalformedURLException(msg);
270             }
271             final String urlPath = url.getURLPath();
272             if (!urlPath.isEmpty()
273                 &amp;&amp; !urlPath.equals(&quot;/&quot;)
274                 &amp;&amp; !urlPath.startsWith(&quot;/jndi/&quot;)) {
275                 final String msg = &quot;URL path must be empty or start with &quot; +
276                     &quot;/jndi/&quot;;
277                 throw new MalformedURLException(msg);
278             }
279         }
280 
281         if (environment == null)
282             this.attributes = Collections.emptyMap();
283         else {
284             EnvHelp.checkAttributes(environment);
285             this.attributes = Collections.unmodifiableMap(environment);
286         }
287 
288         this.address = url;
289         this.rmiServerImpl = rmiServerImpl;
290     }
291 
292     /**
293      * &lt;p&gt;Returns a client stub for this connector server.  A client
294      * stub is a serializable object whose {@link
295      * JMXConnector#connect(Map) connect} method can be used to make
296      * one new connection to this connector server.&lt;/p&gt;
297      *
298      * @param env client connection parameters of the same sort that
299      * could be provided to {@link JMXConnector#connect(Map)
300      * JMXConnector.connect(Map)}.  Can be null, which is equivalent
301      * to an empty map.
302      *
303      * @return a client stub that can be used to make a new connection
304      * to this connector server.
305      *
306      * @exception UnsupportedOperationException if this connector
307      * server does not support the generation of client stubs.
308      *
309      * @exception IllegalStateException if the JMXConnectorServer is
310      * not started (see {@link #isActive()}).
311      *
312      * @exception IOException if a communications problem means that a
313      * stub cannot be created.
314      **/
315     public JMXConnector toJMXConnector(Map&lt;String,?&gt; env) throws IOException {
316         // The serialized for of rmiServerImpl is automatically
317         // a RMI server stub.
318         if (!isActive()) throw new
319             IllegalStateException(&quot;Connector is not active&quot;);
320 
321         // Merge maps
322         Map&lt;String, Object&gt; usemap = new HashMap&lt;String, Object&gt;(
323                 (this.attributes==null)?Collections.&lt;String, Object&gt;emptyMap():
324                     this.attributes);
325 
326         if (env != null) {
327             EnvHelp.checkAttributes(env);
328             usemap.putAll(env);
329         }
330 
331         usemap = EnvHelp.filterAttributes(usemap);
332 
333         final RMIServer stub=(RMIServer)rmiServerImpl.toStub();
334 
335         return new RMIConnector(stub, usemap);
336     }
337 
338     /**
339      * &lt;p&gt;Activates the connector server, that is starts listening for
340      * client connections.  Calling this method when the connector
341      * server is already active has no effect.  Calling this method
342      * when the connector server has been stopped will generate an
343      * &lt;code&gt;IOException&lt;/code&gt;.&lt;/p&gt;
344      *
345      * &lt;p&gt;The behavior of this method when called for the first time
346      * depends on the parameters that were supplied at construction,
347      * as described below.&lt;/p&gt;
348      *
349      * &lt;p&gt;First, an object of a subclass of {@link RMIServerImpl} is
350      * required, to export the connector server through RMI:&lt;/p&gt;
351      *
352      * &lt;ul&gt;
353      *
354      * &lt;li&gt;If an &lt;code&gt;RMIServerImpl&lt;/code&gt; was supplied to the
355      * constructor, it is used.
356      *
357      * &lt;li&gt;Otherwise, if the &lt;code&gt;JMXServiceURL&lt;/code&gt;
358      * was null, or its protocol part was &lt;code&gt;rmi&lt;/code&gt;, an object
359      * of type {@link RMIJRMPServerImpl} is created.
360      *
361      * &lt;li&gt;Otherwise, the implementation can create an
362      * implementation-specific {@link RMIServerImpl} or it can throw
363      * {@link MalformedURLException}.
364      *
365      * &lt;/ul&gt;
366      *
367      * &lt;p&gt;If the given address includes a JNDI directory URL as
368      * specified in the package documentation for {@link
369      * javax.management.remote.rmi}, then this
370      * &lt;code&gt;RMIConnectorServer&lt;/code&gt; will bootstrap by binding the
371      * &lt;code&gt;RMIServerImpl&lt;/code&gt; to the given address.&lt;/p&gt;
372      *
373      * &lt;p&gt;If the URL path part of the &lt;code&gt;JMXServiceURL&lt;/code&gt; was
374      * empty or a single slash (&lt;code&gt;/&lt;/code&gt;), then the RMI object
375      * will not be bound to a directory.  Instead, a reference to it
376      * will be encoded in the URL path of the RMIConnectorServer
377      * address (returned by {@link #getAddress()}).  The encodings for
378      * &lt;code&gt;rmi&lt;/code&gt; are described in the package documentation for
379      * {@link javax.management.remote.rmi}.&lt;/p&gt;
380      *
381      * &lt;p&gt;The behavior when the URL path is neither empty nor a JNDI
382      * directory URL, or when the protocol is not &lt;code&gt;rmi&lt;/code&gt;,
383      * is implementation defined, and may include throwing
384      * {@link MalformedURLException} when the connector server is created
385      * or when it is started.&lt;/p&gt;
386      *
387      * @exception IllegalStateException if the connector server has
388      * not been attached to an MBean server.
389      * @exception IOException if the connector server cannot be
390      * started.
391      */
392     public synchronized void start() throws IOException {
393         final boolean tracing = logger.traceOn();
394 
395         if (state == STARTED) {
396             if (tracing) logger.trace(&quot;start&quot;, &quot;already started&quot;);
397             return;
398         } else if (state == STOPPED) {
399             if (tracing) logger.trace(&quot;start&quot;, &quot;already stopped&quot;);
400             throw new IOException(&quot;The server has been stopped.&quot;);
401         }
402 
403         if (getMBeanServer() == null)
404             throw new IllegalStateException(&quot;This connector server is not &quot; +
405                                             &quot;attached to an MBean server&quot;);
406 
407         // Check the internal access file property to see
408         // if an MBeanServerForwarder is to be provided
409         //
410         if (attributes != null) {
411             // Check if access file property is specified
412             //
413             String accessFile =
414                 (String) attributes.get(&quot;jmx.remote.x.access.file&quot;);
415             if (accessFile != null) {
416                 // Access file property specified, create an instance
417                 // of the MBeanServerFileAccessController class
418                 //
419                 MBeanServerForwarder mbsf;
420                 try {
421                     mbsf = new MBeanServerFileAccessController(accessFile);
422                 } catch (IOException e) {
423                     throw EnvHelp.initCause(
424                         new IllegalArgumentException(e.getMessage()), e);
425                 }
426                 // Set the MBeanServerForwarder
427                 //
428                 setMBeanServerForwarder(mbsf);
429             }
430         }
431 
432         try {
433             if (tracing) logger.trace(&quot;start&quot;, &quot;setting default class loader&quot;);
434             defaultClassLoader = EnvHelp.resolveServerClassLoader(
435                     attributes, getMBeanServer());
436         } catch (InstanceNotFoundException infc) {
437             IllegalArgumentException x = new
438                 IllegalArgumentException(&quot;ClassLoader not found: &quot;+infc);
439             throw EnvHelp.initCause(x,infc);
440         }
441 
442         if (tracing) logger.trace(&quot;start&quot;, &quot;setting RMIServer object&quot;);
443         final RMIServerImpl rmiServer;
444 
445         if (rmiServerImpl != null)
446             rmiServer = rmiServerImpl;
447         else
448             rmiServer = newServer();
449 
450         rmiServer.setMBeanServer(getMBeanServer());
451         rmiServer.setDefaultClassLoader(defaultClassLoader);
452         rmiServer.setRMIConnectorServer(this);
453         rmiServer.export();
454 
455         try {
456             if (tracing) logger.trace(&quot;start&quot;, &quot;getting RMIServer object to export&quot;);
457             final RMIServer objref = objectToBind(rmiServer, attributes);
458 
459             if (address != null &amp;&amp; address.getURLPath().startsWith(&quot;/jndi/&quot;)) {
460                 final String jndiUrl = address.getURLPath().substring(6);
461 
462                 if (tracing)
463                     logger.trace(&quot;start&quot;, &quot;Using external directory: &quot; + jndiUrl);
464 
465                 String stringBoolean = (String) attributes.get(JNDI_REBIND_ATTRIBUTE);
466                 final boolean rebind = EnvHelp.computeBooleanFromString( stringBoolean );
467 
468                 if (tracing)
469                     logger.trace(&quot;start&quot;, JNDI_REBIND_ATTRIBUTE + &quot;=&quot; + rebind);
470 
471                 try {
472                     if (tracing) logger.trace(&quot;start&quot;, &quot;binding to &quot; + jndiUrl);
473 
474                     final Hashtable&lt;?, ?&gt; usemap = EnvHelp.mapToHashtable(attributes);
475 
476                     bind(jndiUrl, usemap, objref, rebind);
477 
478                     boundJndiUrl = jndiUrl;
479                 } catch (NamingException e) {
480                     // fit e in the nested exception if we are on 1.4
481                     throw newIOException(&quot;Cannot bind to URL [&quot;+jndiUrl+&quot;]: &quot;
482                                          + e, e);
483                 }
484             } else {
485                 // if jndiURL is null, we must encode the stub into the URL.
486                 if (tracing) logger.trace(&quot;start&quot;, &quot;Encoding URL&quot;);
487 
488                 encodeStubInAddress(objref, attributes);
489 
490                 if (tracing) logger.trace(&quot;start&quot;, &quot;Encoded URL: &quot; + this.address);
491             }
492         } catch (Exception e) {
493             try {
494                 rmiServer.close();
495             } catch (Exception x) {
496                 // OK: we are already throwing another exception
497             }
498             if (e instanceof RuntimeException)
499                 throw (RuntimeException) e;
500             else if (e instanceof IOException)
501                 throw (IOException) e;
502             else
503                 throw newIOException(&quot;Got unexpected exception while &quot; +
504                                      &quot;starting the connector server: &quot;
505                                      + e, e);
506         }
507 
508         rmiServerImpl = rmiServer;
509 
510         synchronized(openedServers) {
511             openedServers.add(this);
512         }
513 
514         state = STARTED;
515 
516         if (tracing) {
517             logger.trace(&quot;start&quot;, &quot;Connector Server Address = &quot; + address);
518             logger.trace(&quot;start&quot;, &quot;started.&quot;);
519         }
520     }
521 
522     /**
523      * &lt;p&gt;Deactivates the connector server, that is, stops listening for
524      * client connections.  Calling this method will also close all
525      * client connections that were made by this server.  After this
526      * method returns, whether normally or with an exception, the
527      * connector server will not create any new client
528      * connections.&lt;/p&gt;
529      *
530      * &lt;p&gt;Once a connector server has been stopped, it cannot be started
531      * again.&lt;/p&gt;
532      *
533      * &lt;p&gt;Calling this method when the connector server has already
534      * been stopped has no effect.  Calling this method when the
535      * connector server has not yet been started will disable the
536      * connector server object permanently.&lt;/p&gt;
537      *
538      * &lt;p&gt;If closing a client connection produces an exception, that
539      * exception is not thrown from this method.  A {@link
540      * JMXConnectionNotification} is emitted from this MBean with the
541      * connection ID of the connection that could not be closed.&lt;/p&gt;
542      *
543      * &lt;p&gt;Closing a connector server is a potentially slow operation.
544      * For example, if a client machine with an open connection has
545      * crashed, the close operation might have to wait for a network
546      * protocol timeout.  Callers that do not want to block in a close
547      * operation should do it in a separate thread.&lt;/p&gt;
548      *
549      * &lt;p&gt;This method calls the method {@link RMIServerImpl#close()
550      * close} on the connector server&#39;s &lt;code&gt;RMIServerImpl&lt;/code&gt;
551      * object.&lt;/p&gt;
552      *
553      * &lt;p&gt;If the &lt;code&gt;RMIServerImpl&lt;/code&gt; was bound to a JNDI
554      * directory by the {@link #start() start} method, it is unbound
555      * from the directory by this method.&lt;/p&gt;
556      *
557      * @exception IOException if the server cannot be closed cleanly,
558      * or if the &lt;code&gt;RMIServerImpl&lt;/code&gt; cannot be unbound from the
559      * directory.  When this exception is thrown, the server has
560      * already attempted to close all client connections, if
561      * appropriate; to call {@link RMIServerImpl#close()}; and to
562      * unbind the &lt;code&gt;RMIServerImpl&lt;/code&gt; from its directory, if
563      * appropriate.  All client connections are closed except possibly
564      * those that generated exceptions when the server attempted to
565      * close them.
566      */
567     public void stop() throws IOException {
568         final boolean tracing = logger.traceOn();
569 
570         synchronized (this) {
571             if (state == STOPPED) {
572                 if (tracing) logger.trace(&quot;stop&quot;,&quot;already stopped.&quot;);
573                 return;
574             } else if (state == CREATED) {
575                 if (tracing) logger.trace(&quot;stop&quot;,&quot;not started yet.&quot;);
576             }
577 
578             if (tracing) logger.trace(&quot;stop&quot;, &quot;stopping.&quot;);
579             state = STOPPED;
580         }
581 
582         synchronized(openedServers) {
583             openedServers.remove(this);
584         }
585 
586         IOException exception = null;
587 
588         // rmiServerImpl can be null if stop() called without start()
589         if (rmiServerImpl != null) {
590             try {
591                 if (tracing) logger.trace(&quot;stop&quot;, &quot;closing RMI server.&quot;);
592                 rmiServerImpl.close();
593             } catch (IOException e) {
594                 if (tracing) logger.trace(&quot;stop&quot;, &quot;failed to close RMI server: &quot; + e);
595                 if (logger.debugOn()) logger.debug(&quot;stop&quot;,e);
596                 exception = e;
597             }
598         }
599 
600         if (boundJndiUrl != null) {
601             try {
602                 if (tracing)
603                     logger.trace(&quot;stop&quot;,
604                           &quot;unbind from external directory: &quot; + boundJndiUrl);
605 
606                 final Hashtable&lt;?, ?&gt; usemap = EnvHelp.mapToHashtable(attributes);
607 
608                 InitialContext ctx =
609                     new InitialContext(usemap);
610 
611                 ctx.unbind(boundJndiUrl);
612 
613                 ctx.close();
614             } catch (NamingException e) {
615                 if (tracing) logger.trace(&quot;stop&quot;, &quot;failed to unbind RMI server: &quot;+e);
616                 if (logger.debugOn()) logger.debug(&quot;stop&quot;,e);
617                 // fit e in as the nested exception if we are on 1.4
618                 if (exception == null)
619                     exception = newIOException(&quot;Cannot bind to URL: &quot; + e, e);
620             }
621         }
622 
623         if (exception != null) throw exception;
624 
625         if (tracing) logger.trace(&quot;stop&quot;, &quot;stopped&quot;);
626     }
627 
628     public synchronized boolean isActive() {
629         return (state == STARTED);
630     }
631 
632     public JMXServiceURL getAddress() {
633         if (!isActive())
634             return null;
635         return address;
636     }
637 
638     public Map&lt;String,?&gt; getAttributes() {
639         Map&lt;String, ?&gt; map = EnvHelp.filterAttributes(attributes);
640         return Collections.unmodifiableMap(map);
641     }
642 
643     @Override
644     public synchronized
645         void setMBeanServerForwarder(MBeanServerForwarder mbsf) {
646         super.setMBeanServerForwarder(mbsf);
647         if (rmiServerImpl != null)
648             rmiServerImpl.setMBeanServer(getMBeanServer());
649     }
650 
651     /* We repeat the definitions of connection{Opened,Closed,Failed}
652        here so that they are accessible to other classes in this package
653        even though they have protected access.  */
654 
655     @Override
656     protected void connectionOpened(String connectionId, String message,
657                                     Object userData) {
658         super.connectionOpened(connectionId, message, userData);
659     }
660 
661     @Override
662     protected void connectionClosed(String connectionId, String message,
663                                     Object userData) {
664         super.connectionClosed(connectionId, message, userData);
665     }
666 
667     @Override
668     protected void connectionFailed(String connectionId, String message,
669                                     Object userData) {
670         super.connectionFailed(connectionId, message, userData);
671     }
672 
673     /**
674      * Bind a stub to a registry.
675      * @param jndiUrl URL of the stub in the registry, extracted
676      *        from the &lt;code&gt;JMXServiceURL&lt;/code&gt;.
677      * @param attributes A Hashtable containing environment parameters,
678      *        built from the Map specified at this object creation.
679      * @param rmiServer The object to bind in the registry
680      * @param rebind true if the object must be rebound.
681      **/
682     void bind(String jndiUrl, Hashtable&lt;?, ?&gt; attributes,
683               RMIServer rmiServer, boolean rebind)
684         throws NamingException, MalformedURLException {
685         // if jndiURL is not null, we nust bind the stub to a
686         // directory.
687         InitialContext ctx =
688             new InitialContext(attributes);
689 
690         if (rebind)
691             ctx.rebind(jndiUrl, rmiServer);
692         else
693             ctx.bind(jndiUrl, rmiServer);
694         ctx.close();
695     }
696 
697     /**
698      * Creates a new RMIServerImpl.
699      **/
700     RMIServerImpl newServer() throws IOException {
701         final int port;
702         if (address == null)
703             port = 0;
704         else
705             port = address.getPort();
706 
707         return newJRMPServer(attributes, port);
708     }
709 
710     /**
711      * Encode a stub into the JMXServiceURL.
712      * @param rmiServer The stub object to encode in the URL
713      * @param attributes A Map containing environment parameters,
714      *        built from the Map specified at this object creation.
715      **/
716     private void encodeStubInAddress(
717             RMIServer rmiServer, Map&lt;String, ?&gt; attributes)
718             throws IOException {
719 
720         final String protocol, host;
721         final int port;
722 
723         if (address == null) {
724             protocol = &quot;rmi&quot;;
725             host = null; // will default to local host name
726             port = 0;
727         } else {
728             protocol = address.getProtocol();
729             host = (address.getHost().isEmpty()) ? null : address.getHost();
730             port = address.getPort();
731         }
732 
733         final String urlPath = encodeStub(rmiServer, attributes);
734 
735         address = new JMXServiceURL(protocol, host, port, urlPath);
736     }
737 
738     /**
739      * Returns the IOR of the given rmiServer.
740      **/
741     static String encodeStub(
742             RMIServer rmiServer, Map&lt;String, ?&gt; env) throws IOException {
743         return &quot;/stub/&quot; + encodeJRMPStub(rmiServer, env);
744     }
745 
746     static String encodeJRMPStub(
747             RMIServer rmiServer, Map&lt;String, ?&gt; env)
748             throws IOException {
749         ByteArrayOutputStream bout = new ByteArrayOutputStream();
750         ObjectOutputStream oout = new ObjectOutputStream(bout);
751         oout.writeObject(rmiServer);
752         oout.close();
753         byte[] bytes = bout.toByteArray();
754         return byteArrayToBase64(bytes);
755     }
756 
757     /**
758      * Object that we will bind to the registry.
759      * This object is a stub connected to our RMIServerImpl.
760      **/
761     private static RMIServer objectToBind(
762             RMIServerImpl rmiServer, Map&lt;String, ?&gt; env)
763         throws IOException {
764         return (RMIServer)rmiServer.toStub();
765     }
766 
767     private static RMIServerImpl newJRMPServer(Map&lt;String, ?&gt; env, int port)
768             throws IOException {
769         RMIClientSocketFactory csf = (RMIClientSocketFactory)
770             env.get(RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE);
771         RMIServerSocketFactory ssf = (RMIServerSocketFactory)
772             env.get(RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE);
773         return new RMIJRMPServerImpl(port, csf, ssf, env);
774     }
775 
776     private static String byteArrayToBase64(byte[] a) {
777         int aLen = a.length;
778         int numFullGroups = aLen/3;
779         int numBytesInPartialGroup = aLen - 3*numFullGroups;
780         int resultLen = 4*((aLen + 2)/3);
781         final StringBuilder result = new StringBuilder(resultLen);
782 
783         // Translate all full groups from byte array elements to Base64
784         int inCursor = 0;
785         for (int i=0; i&lt;numFullGroups; i++) {
786             int byte0 = a[inCursor++] &amp; 0xff;
787             int byte1 = a[inCursor++] &amp; 0xff;
788             int byte2 = a[inCursor++] &amp; 0xff;
789             result.append(intToAlpha[byte0 &gt;&gt; 2]);
790             result.append(intToAlpha[(byte0 &lt;&lt; 4)&amp;0x3f | (byte1 &gt;&gt; 4)]);
791             result.append(intToAlpha[(byte1 &lt;&lt; 2)&amp;0x3f | (byte2 &gt;&gt; 6)]);
792             result.append(intToAlpha[byte2 &amp; 0x3f]);
793         }
794 
795         // Translate partial group if present
796         if (numBytesInPartialGroup != 0) {
797             int byte0 = a[inCursor++] &amp; 0xff;
798             result.append(intToAlpha[byte0 &gt;&gt; 2]);
799             if (numBytesInPartialGroup == 1) {
800                 result.append(intToAlpha[(byte0 &lt;&lt; 4) &amp; 0x3f]);
801                 result.append(&quot;==&quot;);
802             } else {
803                 // assert numBytesInPartialGroup == 2;
804                 int byte1 = a[inCursor++] &amp; 0xff;
805                 result.append(intToAlpha[(byte0 &lt;&lt; 4)&amp;0x3f | (byte1 &gt;&gt; 4)]);
806                 result.append(intToAlpha[(byte1 &lt;&lt; 2)&amp;0x3f]);
807                 result.append(&#39;=&#39;);
808             }
809         }
810         // assert inCursor == a.length;
811         // assert result.length() == resultLen;
812         return result.toString();
813     }
814 
815     /**
816      * This array is a lookup table that translates 6-bit positive integer
817      * index values into their &quot;Base64 Alphabet&quot; equivalents as specified
818      * in Table 1 of RFC 2045.
819      */
820     private static final char intToAlpha[] = {
821         &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;,
822         &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;,
823         &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;,
824         &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;,
825         &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;+&#39;, &#39;/&#39;
826     };
827 
828     /**
829      * Construct a new IOException with a nested exception.
830      * The nested exception is set only if JDK {@literal &gt;= 1.4}
831      */
832     private static IOException newIOException(String message,
833                                               Throwable cause) {
834         final IOException x = new IOException(message);
835         return EnvHelp.initCause(x,cause);
836     }
837 
838 
839     // Private variables
840     // -----------------
841 
842     private static ClassLogger logger =
843         new ClassLogger(&quot;javax.management.remote.rmi&quot;, &quot;RMIConnectorServer&quot;);
844 
845     private JMXServiceURL address;
846     private RMIServerImpl rmiServerImpl;
847     private final Map&lt;String, ?&gt; attributes;
848     private ClassLoader defaultClassLoader = null;
849 
850     private String boundJndiUrl;
851 
852     // state
853     private static final int CREATED = 0;
854     private static final int STARTED = 1;
855     private static final int STOPPED = 2;
856 
857     private int state = CREATED;
858     private final static Set&lt;RMIConnectorServer&gt; openedServers =
859             new HashSet&lt;RMIConnectorServer&gt;();
860 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/transforms/implementations/TransformBase64Decode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.transforms.implementations;
 24 
 25 import java.io.IOException;
 26 import java.io.OutputStream;
<a name="1" id="anc1"></a>
 27 
 28 import javax.xml.parsers.ParserConfigurationException;
 29 
 30 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 31 import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
 32 import com.sun.org.apache.xml.internal.security.transforms.Transform;
 33 import com.sun.org.apache.xml.internal.security.transforms.TransformSpi;
 34 import com.sun.org.apache.xml.internal.security.transforms.TransformationException;
 35 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
 36 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 37 import org.w3c.dom.Document;
 38 import org.w3c.dom.Element;
 39 import org.w3c.dom.Node;
 40 import org.w3c.dom.Text;
 41 import org.xml.sax.SAXException;
 42 
 43 import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 44 
 45 /**
 46  * Implements the {@code http://www.w3.org/2000/09/xmldsig#base64} decoding
 47  * transform.
 48  *
 49  * &lt;p&gt;The normative specification for base64 decoding transforms is
 50  * &lt;A HREF=&quot;http://www.w3.org/TR/2001/CR-xmldsig-core-20010419/#ref-MIME&quot;&gt;[MIME]&lt;/A&gt;.
 51  * The base64 Transform element has no content. The input
 52  * is decoded by the algorithms. This transform is useful if an
 53  * application needs to sign the raw data associated with the encoded
 54  * content of an element. &lt;/p&gt;
 55  *
 56  * &lt;p&gt;This transform requires an octet stream for input.
 57  * If an XPath node-set (or sufficiently functional alternative) is
 58  * given as input, then it is converted to an octet stream by
 59  * performing operations LOGically equivalent to 1) applying an XPath
 60  * transform with expression self::text(), then 2) taking the string-value
 61  * of the node-set. Thus, if an XML element is identified by a barename
 62  * XPointer in the Reference URI, and its content consists solely of base64
 63  * encoded character data, then this transform automatically strips away the
 64  * start and end tags of the identified element and any of its descendant
 65  * elements as well as any descendant comments and processing instructions.
 66  * The output of this transform is an octet stream.&lt;/p&gt;
 67  *
 68  */
 69 public class TransformBase64Decode extends TransformSpi {
 70 
 71     /** Field implementedTransformURI */
 72     public static final String implementedTransformURI =
 73         Transforms.TRANSFORM_BASE64_DECODE;
 74 
 75     /**
 76      * Method engineGetURI
 77      *
 78      * {@inheritDoc}
 79      */
 80     protected String engineGetURI() {
 81         return TransformBase64Decode.implementedTransformURI;
 82     }
 83 
 84     /**
 85      * Method enginePerformTransform
 86      *
 87      * @param input
 88      * @return {@link XMLSignatureInput} as the result of transformation
 89      * {@inheritDoc}
 90      * @throws CanonicalizationException
 91      * @throws IOException
 92      * @throws TransformationException
 93      */
 94     protected XMLSignatureInput enginePerformTransform(
 95         XMLSignatureInput input, Transform transformObject
 96     ) throws IOException, CanonicalizationException, TransformationException {
 97         return enginePerformTransform(input, null, transformObject);
 98     }
 99 
100     protected XMLSignatureInput enginePerformTransform(
101         XMLSignatureInput input, OutputStream os, Transform transformObject
102     ) throws IOException, CanonicalizationException, TransformationException {
103         if (input.isElement()) {
104             Node el = input.getSubNode();
105             if (input.getSubNode().getNodeType() == Node.TEXT_NODE) {
106                 el = el.getParentNode();
107             }
108             StringBuilder sb = new StringBuilder();
109             traverseElement((Element)el, sb);
110             if (os == null) {
<a name="2" id="anc2"></a><span class="line-modified">111                 byte[] decodedBytes = XMLUtils.decode(sb.toString());</span>
112                 XMLSignatureInput output = new XMLSignatureInput(decodedBytes);
113                 output.setSecureValidation(secureValidation);
114                 return output;
115             }
<a name="3" id="anc3"></a><span class="line-modified">116             byte[] bytes = XMLUtils.decode(sb.toString());</span>
117             os.write(bytes);
118             XMLSignatureInput output = new XMLSignatureInput((byte[])null);
119             output.setSecureValidation(secureValidation);
120             output.setOutputStream(os);
121             return output;
122         }
123 
124         if (input.isOctetStream() || input.isNodeSet()) {
125             if (os == null) {
126                 byte[] base64Bytes = input.getBytes();
<a name="4" id="anc4"></a><span class="line-modified">127                 byte[] decodedBytes = XMLUtils.decode(base64Bytes);</span>
128                 XMLSignatureInput output = new XMLSignatureInput(decodedBytes);
129                 output.setSecureValidation(secureValidation);
130                 return output;
131             }
132             if (input.isByteArray() || input.isNodeSet()) {
<a name="5" id="anc5"></a><span class="line-modified">133                 byte[] bytes = XMLUtils.decode(input.getBytes());</span>
134                 os.write(bytes);
135             } else {
136                 byte[] inputBytes = JavaUtils.getBytesFromStream(input.getOctetStreamReal());
<a name="6" id="anc6"></a><span class="line-modified">137                 byte[] bytes = XMLUtils.decode(inputBytes);</span>
138                 os.write(bytes);
139             }
140             XMLSignatureInput output = new XMLSignatureInput((byte[])null);
141             output.setSecureValidation(secureValidation);
142             output.setOutputStream(os);
143             return output;
144         }
145 
146         try {
147             //Exceptional case there is current not text case testing this(Before it was a
148             //a common case).
149             Document doc =
<a name="7" id="anc7"></a><span class="line-modified">150                 XMLUtils.read(input.getOctetStream(), secureValidation);</span>
151 
152             Element rootNode = doc.getDocumentElement();
153             StringBuilder sb = new StringBuilder();
154             traverseElement(rootNode, sb);
<a name="8" id="anc8"></a><span class="line-modified">155             byte[] decodedBytes = XMLUtils.decode(sb.toString());</span>
156             XMLSignatureInput output = new XMLSignatureInput(decodedBytes);
157             output.setSecureValidation(secureValidation);
158             return output;
159         } catch (ParserConfigurationException e) {
160             throw new TransformationException(e, &quot;c14n.Canonicalizer.Exception&quot;);
161         } catch (SAXException e) {
162             throw new TransformationException(e, &quot;SAX exception&quot;);
163         }
164     }
165 
166     void traverseElement(Element node, StringBuilder sb) {
167         Node sibling = node.getFirstChild();
168         while (sibling != null) {
169             switch (sibling.getNodeType()) {
170             case Node.ELEMENT_NODE:
171                 traverseElement((Element)sibling, sb);
172                 break;
173             case Node.TEXT_NODE:
174                 sb.append(((Text)sibling).getData());
175             }
176             sibling = sibling.getNextSibling();
177         }
178     }
179 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/Reference.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Manifest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="SignedInfo.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/Reference.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.signature;
 24 
 25 import java.io.IOException;
 26 import java.io.OutputStream;
 27 import java.security.AccessController;
 28 import java.security.PrivilegedAction;
<span class="line-removed"> 29 import java.util.Base64;</span>
 30 import java.util.HashSet;
 31 import java.util.Iterator;
 32 import java.util.Set;
 33 
 34 import com.sun.org.apache.xml.internal.security.algorithms.Algorithm;
 35 import com.sun.org.apache.xml.internal.security.algorithms.MessageDigestAlgorithm;
 36 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 37 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
 38 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 39 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceData;
 40 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceNodeSetData;
 41 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceOctetStreamData;
 42 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceSubTreeData;
 43 import com.sun.org.apache.xml.internal.security.transforms.InvalidTransformException;
 44 import com.sun.org.apache.xml.internal.security.transforms.Transform;
 45 import com.sun.org.apache.xml.internal.security.transforms.TransformationException;
 46 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
 47 import com.sun.org.apache.xml.internal.security.transforms.params.InclusiveNamespaces;
 48 import com.sun.org.apache.xml.internal.security.utils.Constants;
 49 import com.sun.org.apache.xml.internal.security.utils.DigesterOutputStream;
</pre>
<hr />
<pre>
379     public boolean typeIsReferenceToManifest() {
380         if (Reference.MANIFEST_URI.equals(this.getType())) {
381             return true;
382         }
383 
384         return false;
385     }
386 
387     /**
388      * Method setDigestValueElement
389      *
390      * @param digestValue
391      */
392     private void setDigestValueElement(byte[] digestValue) {
393         Node n = digestValueElement.getFirstChild();
394         while (n != null) {
395             digestValueElement.removeChild(n);
396             n = n.getNextSibling();
397         }
398 
<span class="line-modified">399         String base64codedValue = Base64.getMimeEncoder().encodeToString(digestValue);</span>
400         Text t = createText(base64codedValue);
401 
402         digestValueElement.appendChild(t);
403     }
404 
405     /**
406      * Method generateDigestValue
407      *
408      * @throws ReferenceNotInitializedException
409      * @throws XMLSignatureException
410      */
411     public void generateDigestValue()
412         throws XMLSignatureException, ReferenceNotInitializedException {
413         this.setDigestValueElement(this.calculateDigest(false));
414     }
415 
416     /**
417      * Returns the XMLSignatureInput which is created by de-referencing the URI attribute.
418      * @return the XMLSignatureInput of the source of this reference
419      * @throws ReferenceNotInitializedException If the resolver found any
</pre>
<hr />
<pre>
706             throw new ReferenceNotInitializedException(ex);
707         }
708     }
709 
710 
711     /**
712      * Method calculateDigest
713      *
714      * @param validating true if validating the reference
715      * @return reference Calculate the digest of this reference.
716      * @throws ReferenceNotInitializedException
717      * @throws XMLSignatureException
718      */
719     private byte[] calculateDigest(boolean validating)
720         throws ReferenceNotInitializedException, XMLSignatureException {
721         XMLSignatureInput input = this.getContentsBeforeTransformation();
722         if (input.isPreCalculatedDigest()) {
723             return getPreCalculatedDigest(input);
724         }
725 


726         MessageDigestAlgorithm mda = this.getMessageDigestAlgorithm();
727         mda.reset();
728 
729         try (DigesterOutputStream diOs = new DigesterOutputStream(mda);
730             OutputStream os = new UnsyncBufferedOutputStream(diOs)) {
<span class="line-modified">731             XMLSignatureInput output = this.dereferenceURIandPerformTransforms(os);</span>



732             // if signing and c14n11 property == true explicitly add
733             // C14N11 transform if needed
734             if (Reference.useC14N11 &amp;&amp; !validating &amp;&amp; !output.isOutputStreamSet()
735                 &amp;&amp; !output.isOctetStream()) {
736                 if (transforms == null) {
737                     transforms = new Transforms(getDocument());
738                     transforms.setSecureValidation(secureValidation);
739                     getElement().insertBefore(transforms.getElement(), digestMethodElem);
740                 }
741                 transforms.addTransform(Transforms.TRANSFORM_C14N11_OMIT_COMMENTS);
742                 output.updateOutputStream(os, true);
743             } else {
744                 output.updateOutputStream(os);
745             }
746             os.flush();
747 
748             if (output.getOctetStreamReal() != null) {
749                 output.getOctetStreamReal().close();
750             }
751 
</pre>
<hr />
<pre>
755             return diOs.getDigestValue();
756         } catch (XMLSecurityException ex) {
757             throw new ReferenceNotInitializedException(ex);
758         } catch (IOException ex) {
759             throw new ReferenceNotInitializedException(ex);
760         }
761     }
762 
763     /**
764      * Get the pre-calculated digest value from the XMLSignatureInput.
765      *
766      * @param input XMLSignature
767      * @return a pre-calculated digest value.
768      * @throws ReferenceNotInitializedException if there is an error decoding digest value
769      * in Base64. Properly encoded pre-calculated digest value must be set.
770      */
771     private byte[] getPreCalculatedDigest(XMLSignatureInput input)
772             throws ReferenceNotInitializedException {
773         LOG.debug(&quot;Verifying element with pre-calculated digest&quot;);
774         String preCalculatedDigest = input.getPreCalculatedDigest();
<span class="line-modified">775         return Base64.getMimeDecoder().decode(preCalculatedDigest);</span>
776     }
777 
778     /**
779      * Returns the digest value.
780      *
781      * @return the digest value.
782      * @throws XMLSecurityException if the Reference does not contain a DigestValue element
783      */
784     public byte[] getDigestValue() throws XMLSecurityException {
785         if (digestValueElement == null) {
786             // The required element is not in the XML!
787             Object[] exArgs ={ Constants._TAG_DIGESTVALUE, Constants.SignatureSpecNS };
788             throw new XMLSecurityException(
789                 &quot;signature.Verification.NoSignatureElement&quot;, exArgs
790             );
791         }
<span class="line-modified">792         String content = XMLUtils.getFullTextChildrenFromElement(digestValueElement);</span>
<span class="line-modified">793         return Base64.getMimeDecoder().decode(content);</span>
794     }
795 
796 
797     /**
798      * Tests reference validation is success or false
799      *
800      * @return true if reference validation is success, otherwise false
801      * @throws ReferenceNotInitializedException
802      * @throws XMLSecurityException
803      */
804     public boolean verify()
805         throws ReferenceNotInitializedException, XMLSecurityException {
806         byte[] elemDig = this.getDigestValue();
807         byte[] calcDig = this.calculateDigest(true);
808         boolean equal = MessageDigestAlgorithm.isEqual(elemDig, calcDig);
809 
810         if (!equal) {
811             LOG.warn(&quot;Verification failed for URI \&quot;&quot; + this.getURI() + &quot;\&quot;&quot;);
<span class="line-modified">812             LOG.warn(&quot;Expected Digest: &quot; + Base64.getMimeEncoder().encodeToString(elemDig));</span>
<span class="line-modified">813             LOG.warn(&quot;Actual Digest: &quot; + Base64.getMimeEncoder().encodeToString(calcDig));</span>
814         } else {
815             LOG.debug(&quot;Verification successful for URI \&quot;{}\&quot;&quot;, this.getURI());
816         }
817 
818         return equal;
819     }
820 
821     /**
822      * Method getBaseLocalName
823      * {@inheritDoc}
824      */
825     public String getBaseLocalName() {
826         return Constants._TAG_REFERENCE;
827     }
828 }
</pre>
</td>
<td>
<hr />
<pre>
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.signature;
 24 
 25 import java.io.IOException;
 26 import java.io.OutputStream;
 27 import java.security.AccessController;
 28 import java.security.PrivilegedAction;

 29 import java.util.HashSet;
 30 import java.util.Iterator;
 31 import java.util.Set;
 32 
 33 import com.sun.org.apache.xml.internal.security.algorithms.Algorithm;
 34 import com.sun.org.apache.xml.internal.security.algorithms.MessageDigestAlgorithm;
 35 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 36 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
 37 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 38 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceData;
 39 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceNodeSetData;
 40 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceOctetStreamData;
 41 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceSubTreeData;
 42 import com.sun.org.apache.xml.internal.security.transforms.InvalidTransformException;
 43 import com.sun.org.apache.xml.internal.security.transforms.Transform;
 44 import com.sun.org.apache.xml.internal.security.transforms.TransformationException;
 45 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
 46 import com.sun.org.apache.xml.internal.security.transforms.params.InclusiveNamespaces;
 47 import com.sun.org.apache.xml.internal.security.utils.Constants;
 48 import com.sun.org.apache.xml.internal.security.utils.DigesterOutputStream;
</pre>
<hr />
<pre>
378     public boolean typeIsReferenceToManifest() {
379         if (Reference.MANIFEST_URI.equals(this.getType())) {
380             return true;
381         }
382 
383         return false;
384     }
385 
386     /**
387      * Method setDigestValueElement
388      *
389      * @param digestValue
390      */
391     private void setDigestValueElement(byte[] digestValue) {
392         Node n = digestValueElement.getFirstChild();
393         while (n != null) {
394             digestValueElement.removeChild(n);
395             n = n.getNextSibling();
396         }
397 
<span class="line-modified">398         String base64codedValue = XMLUtils.encodeToString(digestValue);</span>
399         Text t = createText(base64codedValue);
400 
401         digestValueElement.appendChild(t);
402     }
403 
404     /**
405      * Method generateDigestValue
406      *
407      * @throws ReferenceNotInitializedException
408      * @throws XMLSignatureException
409      */
410     public void generateDigestValue()
411         throws XMLSignatureException, ReferenceNotInitializedException {
412         this.setDigestValueElement(this.calculateDigest(false));
413     }
414 
415     /**
416      * Returns the XMLSignatureInput which is created by de-referencing the URI attribute.
417      * @return the XMLSignatureInput of the source of this reference
418      * @throws ReferenceNotInitializedException If the resolver found any
</pre>
<hr />
<pre>
705             throw new ReferenceNotInitializedException(ex);
706         }
707     }
708 
709 
710     /**
711      * Method calculateDigest
712      *
713      * @param validating true if validating the reference
714      * @return reference Calculate the digest of this reference.
715      * @throws ReferenceNotInitializedException
716      * @throws XMLSignatureException
717      */
718     private byte[] calculateDigest(boolean validating)
719         throws ReferenceNotInitializedException, XMLSignatureException {
720         XMLSignatureInput input = this.getContentsBeforeTransformation();
721         if (input.isPreCalculatedDigest()) {
722             return getPreCalculatedDigest(input);
723         }
724 
<span class="line-added">725         cacheDereferencedElement(input);</span>
<span class="line-added">726 </span>
727         MessageDigestAlgorithm mda = this.getMessageDigestAlgorithm();
728         mda.reset();
729 
730         try (DigesterOutputStream diOs = new DigesterOutputStream(mda);
731             OutputStream os = new UnsyncBufferedOutputStream(diOs)) {
<span class="line-modified">732 </span>
<span class="line-added">733             XMLSignatureInput output = this.getContentsAfterTransformation(input, os);</span>
<span class="line-added">734             this.transformsOutput = output;</span>
<span class="line-added">735 </span>
736             // if signing and c14n11 property == true explicitly add
737             // C14N11 transform if needed
738             if (Reference.useC14N11 &amp;&amp; !validating &amp;&amp; !output.isOutputStreamSet()
739                 &amp;&amp; !output.isOctetStream()) {
740                 if (transforms == null) {
741                     transforms = new Transforms(getDocument());
742                     transforms.setSecureValidation(secureValidation);
743                     getElement().insertBefore(transforms.getElement(), digestMethodElem);
744                 }
745                 transforms.addTransform(Transforms.TRANSFORM_C14N11_OMIT_COMMENTS);
746                 output.updateOutputStream(os, true);
747             } else {
748                 output.updateOutputStream(os);
749             }
750             os.flush();
751 
752             if (output.getOctetStreamReal() != null) {
753                 output.getOctetStreamReal().close();
754             }
755 
</pre>
<hr />
<pre>
759             return diOs.getDigestValue();
760         } catch (XMLSecurityException ex) {
761             throw new ReferenceNotInitializedException(ex);
762         } catch (IOException ex) {
763             throw new ReferenceNotInitializedException(ex);
764         }
765     }
766 
767     /**
768      * Get the pre-calculated digest value from the XMLSignatureInput.
769      *
770      * @param input XMLSignature
771      * @return a pre-calculated digest value.
772      * @throws ReferenceNotInitializedException if there is an error decoding digest value
773      * in Base64. Properly encoded pre-calculated digest value must be set.
774      */
775     private byte[] getPreCalculatedDigest(XMLSignatureInput input)
776             throws ReferenceNotInitializedException {
777         LOG.debug(&quot;Verifying element with pre-calculated digest&quot;);
778         String preCalculatedDigest = input.getPreCalculatedDigest();
<span class="line-modified">779         return XMLUtils.decode(preCalculatedDigest);</span>
780     }
781 
782     /**
783      * Returns the digest value.
784      *
785      * @return the digest value.
786      * @throws XMLSecurityException if the Reference does not contain a DigestValue element
787      */
788     public byte[] getDigestValue() throws XMLSecurityException {
789         if (digestValueElement == null) {
790             // The required element is not in the XML!
791             Object[] exArgs ={ Constants._TAG_DIGESTVALUE, Constants.SignatureSpecNS };
792             throw new XMLSecurityException(
793                 &quot;signature.Verification.NoSignatureElement&quot;, exArgs
794             );
795         }
<span class="line-modified">796         String content = XMLUtils.getFullTextChildrenFromNode(digestValueElement);</span>
<span class="line-modified">797         return XMLUtils.decode(content);</span>
798     }
799 
800 
801     /**
802      * Tests reference validation is success or false
803      *
804      * @return true if reference validation is success, otherwise false
805      * @throws ReferenceNotInitializedException
806      * @throws XMLSecurityException
807      */
808     public boolean verify()
809         throws ReferenceNotInitializedException, XMLSecurityException {
810         byte[] elemDig = this.getDigestValue();
811         byte[] calcDig = this.calculateDigest(true);
812         boolean equal = MessageDigestAlgorithm.isEqual(elemDig, calcDig);
813 
814         if (!equal) {
815             LOG.warn(&quot;Verification failed for URI \&quot;&quot; + this.getURI() + &quot;\&quot;&quot;);
<span class="line-modified">816             LOG.warn(&quot;Expected Digest: &quot; + XMLUtils.encodeToString(elemDig));</span>
<span class="line-modified">817             LOG.warn(&quot;Actual Digest: &quot; + XMLUtils.encodeToString(calcDig));</span>
818         } else {
819             LOG.debug(&quot;Verification successful for URI \&quot;{}\&quot;&quot;, this.getURI());
820         }
821 
822         return equal;
823     }
824 
825     /**
826      * Method getBaseLocalName
827      * {@inheritDoc}
828      */
829     public String getBaseLocalName() {
830         return Constants._TAG_REFERENCE;
831     }
832 }
</pre>
</td>
</tr>
</table>
<center><a href="Manifest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="SignedInfo.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
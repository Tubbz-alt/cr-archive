<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/utils/resolver/ResourceResolver.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.utils.resolver;
 24 
 25 import java.util.ArrayList;
 26 import java.util.List;
 27 import java.util.Map;
 28 
 29 import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
 30 import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 31 import com.sun.org.apache.xml.internal.security.utils.resolver.implementations.ResolverDirectHTTP;
 32 import com.sun.org.apache.xml.internal.security.utils.resolver.implementations.ResolverFragment;
 33 import com.sun.org.apache.xml.internal.security.utils.resolver.implementations.ResolverLocalFilesystem;
 34 import com.sun.org.apache.xml.internal.security.utils.resolver.implementations.ResolverXPointer;
 35 import org.w3c.dom.Attr;
 36 
 37 /**
 38  * During reference validation, we have to retrieve resources from somewhere.
 39  * This is done by retrieving a Resolver. The resolver needs two arguments: The
 40  * URI in which the link to the new resource is defined and the baseURI of the
 41  * file/entity in which the URI occurs (the baseURI is the same as the SystemId).
 42  */
 43 public class ResourceResolver {
 44 
 45     private static final com.sun.org.slf4j.internal.Logger LOG =
 46         com.sun.org.slf4j.internal.LoggerFactory.getLogger(ResourceResolver.class);
 47 
 48     /** these are the system-wide resolvers */
 49     private static final List&lt;ResourceResolver&gt; resolverList = new ArrayList&lt;&gt;();
 50 
 51     /** Field resolverSpi */
 52     private final ResourceResolverSpi resolverSpi;
 53 
 54     /**
 55      * Constructor ResourceResolver
 56      *
 57      * @param resourceResolver
 58      */
 59     public ResourceResolver(ResourceResolverSpi resourceResolver) {
 60         this.resolverSpi = resourceResolver;
 61     }
 62 
 63     /**
 64      * Method getInstance
 65      *
 66      * @param uriAttr
 67      * @param baseURI
 68      * @param secureValidation
 69      * @return the instance
 70      *
 71      * @throws ResourceResolverException
 72      */
 73     public static final ResourceResolver getInstance(
 74         Attr uriAttr, String baseURI, boolean secureValidation
 75     ) throws ResourceResolverException {
 76         ResourceResolverContext context = new ResourceResolverContext(uriAttr, baseURI, secureValidation);
 77         return internalGetInstance(context);
 78     }
 79 
 80     private static &lt;N&gt; ResourceResolver internalGetInstance(ResourceResolverContext context)
 81             throws ResourceResolverException {
 82         synchronized (resolverList) {
 83             for (ResourceResolver resolver : resolverList) {
 84                 ResourceResolver resolverTmp = resolver;
 85                 if (!resolver.resolverSpi.engineIsThreadSafe()) {
 86                     try {
 87                         @SuppressWarnings(&quot;deprecation&quot;)
 88                         ResourceResolver tmp =
 89                             new ResourceResolver(resolver.resolverSpi.getClass().newInstance());
 90                         resolverTmp = tmp;
 91                     } catch (InstantiationException e) {
 92                         throw new ResourceResolverException(e, context.uriToResolve, context.baseUri, &quot;&quot;);
 93                     } catch (IllegalAccessException e) {
 94                         throw new ResourceResolverException(e, context.uriToResolve, context.baseUri, &quot;&quot;);
 95                     }
 96                 }
 97 
 98                 LOG.debug(&quot;check resolvability by class {}&quot;, resolverTmp.getClass().getName());
 99 
<a name="1" id="anc1"></a><span class="line-modified">100                 if (resolverTmp.canResolve(context)) {</span>
101                     // Check to see whether the Resolver is allowed
102                     if (context.secureValidation
103                         &amp;&amp; (resolverTmp.resolverSpi instanceof ResolverLocalFilesystem
104                             || resolverTmp.resolverSpi instanceof ResolverDirectHTTP)) {
105                         Object exArgs[] = { resolverTmp.resolverSpi.getClass().getName() };
106                         throw new ResourceResolverException(
107                             &quot;signature.Reference.ForbiddenResolver&quot;, exArgs, context.uriToResolve, context.baseUri
108                         );
109                     }
110                     return resolverTmp;
111                 }
112             }
113         }
114 
115         Object exArgs[] = { context.uriToResolve != null
116                 ? context.uriToResolve : &quot;null&quot;, context.baseUri };
117 
118         throw new ResourceResolverException(&quot;utils.resolver.noClass&quot;, exArgs, context.uriToResolve, context.baseUri);
119     }
120 
121     /**
122      * Method getInstance
123      *
124      * @param uri
125      * @param baseURI
126      * @param individualResolvers
127      * @return the instance
128      *
129      * @throws ResourceResolverException
130      */
131     public static ResourceResolver getInstance(
132         Attr uri, String baseURI, List&lt;ResourceResolver&gt; individualResolvers
133     ) throws ResourceResolverException {
134         return getInstance(uri, baseURI, individualResolvers, true);
135     }
136 
137     /**
138      * Method getInstance
139      *
140      * @param uri
141      * @param baseURI
142      * @param individualResolvers
143      * @param secureValidation
144      * @return the instance
145      *
146      * @throws ResourceResolverException
147      */
148     public static ResourceResolver getInstance(
149         Attr uri, String baseURI, List&lt;ResourceResolver&gt; individualResolvers, boolean secureValidation
150     ) throws ResourceResolverException {
151         LOG.debug(
152             &quot;I was asked to create a ResourceResolver and got {}&quot;,
153             (individualResolvers == null ? 0 : individualResolvers.size())
154         );
155 
156         ResourceResolverContext context = new ResourceResolverContext(uri, baseURI, secureValidation);
157 
158         // first check the individual Resolvers
159         if (individualResolvers != null) {
160             for (int i = 0; i &lt; individualResolvers.size(); i++) {
161                 ResourceResolver resolver = individualResolvers.get(i);
162 
163                 if (resolver != null) {
164                     String currentClass = resolver.resolverSpi.getClass().getName();
165                     LOG.debug(&quot;check resolvability by class {}&quot;, currentClass);
166 
167                     if (resolver.canResolve(context)) {
168                         return resolver;
169                     }
170                 }
171             }
172         }
173 
174         return internalGetInstance(context);
175     }
176 
177     /**
178      * Registers a ResourceResolverSpi class. This method LOGs a warning if
179      * the class cannot be registered.
180      *
181      * @param className the name of the ResourceResolverSpi class to be registered
182      * @throws SecurityException if a security manager is installed and the
183      *    caller does not have permission to register a resource resolver
184      */
185     @SuppressWarnings(&quot;unchecked&quot;)
186     public static void register(String className) {
187         JavaUtils.checkRegisterPermission();
188         try {
189             Class&lt;ResourceResolverSpi&gt; resourceResolverClass =
190                 (Class&lt;ResourceResolverSpi&gt;)
191                 ClassLoaderUtils.loadClass(className, ResourceResolver.class);
192             register(resourceResolverClass, false);
193         } catch (ClassNotFoundException e) {
194             LOG.warn(&quot;Error loading resolver &quot; + className + &quot; disabling it&quot;);
195         }
196     }
197 
198     /**
199      * Registers a ResourceResolverSpi class at the beginning of the provider
200      * list. This method LOGs a warning if the class cannot be registered.
201      *
202      * @param className the name of the ResourceResolverSpi class to be registered
203      * @throws SecurityException if a security manager is installed and the
204      *    caller does not have permission to register a resource resolver
205      */
206     @SuppressWarnings(&quot;unchecked&quot;)
207     public static void registerAtStart(String className) {
208         JavaUtils.checkRegisterPermission();
209         try {
210             Class&lt;ResourceResolverSpi&gt; resourceResolverClass =
211                 (Class&lt;ResourceResolverSpi&gt;)
212                 ClassLoaderUtils.loadClass(className, ResourceResolver.class);
213             register(resourceResolverClass, true);
214         } catch (ClassNotFoundException e) {
215             LOG.warn(&quot;Error loading resolver &quot; + className + &quot; disabling it&quot;);
216         }
217     }
218 
219     /**
220      * Registers a ResourceResolverSpi class. This method LOGs a warning if the class
221      * cannot be registered.
222      * @param className
223      * @param start
224      * @throws SecurityException if a security manager is installed and the
225      *    caller does not have permission to register a resource resolver
226      */
227     public static void register(Class&lt;? extends ResourceResolverSpi&gt; className, boolean start) {
228         JavaUtils.checkRegisterPermission();
229         try {
230             @SuppressWarnings(&quot;deprecation&quot;)
231             ResourceResolverSpi resourceResolverSpi = className.newInstance();
232             register(resourceResolverSpi, start);
233         } catch (IllegalAccessException e) {
234             LOG.warn(&quot;Error loading resolver &quot; + className + &quot; disabling it&quot;);
235         } catch (InstantiationException e) {
236             LOG.warn(&quot;Error loading resolver &quot; + className + &quot; disabling it&quot;);
237         }
238     }
239 
240     /**
241      * Registers a ResourceResolverSpi instance. This method LOGs a warning if the class
242      * cannot be registered.
243      * @param resourceResolverSpi
244      * @param start
245      * @throws SecurityException if a security manager is installed and the
246      *    caller does not have permission to register a resource resolver
247      */
248     public static void register(ResourceResolverSpi resourceResolverSpi, boolean start) {
249         JavaUtils.checkRegisterPermission();
250         synchronized(resolverList) {
251             if (start) {
252                 resolverList.add(0, new ResourceResolver(resourceResolverSpi));
253             } else {
254                 resolverList.add(new ResourceResolver(resourceResolverSpi));
255             }
256         }
257         LOG.debug(&quot;Registered resolver: {}&quot;, resourceResolverSpi.toString());
258     }
259 
260     /**
261      * This method registers the default resolvers.
262      */
263     public static void registerDefaultResolvers() {
264         synchronized(resolverList) {
265             resolverList.add(new ResourceResolver(new ResolverFragment()));
266             resolverList.add(new ResourceResolver(new ResolverLocalFilesystem()));
267             resolverList.add(new ResourceResolver(new ResolverXPointer()));
268             resolverList.add(new ResourceResolver(new ResolverDirectHTTP()));
269         }
270     }
271 
272     /**
273      * Method resolve
274      *
275      * @param uri
276      * @param baseURI
277      * @return the resource
278      *
279      * @throws ResourceResolverException
280      */
281     public XMLSignatureInput resolve(Attr uri, String baseURI, boolean secureValidation)
282         throws ResourceResolverException {
283         ResourceResolverContext context = new ResourceResolverContext(uri, baseURI, secureValidation);
284         return resolverSpi.engineResolveURI(context);
285     }
286 
287     /**
288      * Method setProperty
289      *
290      * @param key
291      * @param value
292      */
293     public void setProperty(String key, String value) {
294         resolverSpi.engineSetProperty(key, value);
295     }
296 
297     /**
298      * Method getProperty
299      *
300      * @param key
301      * @return the value of the property
302      */
303     public String getProperty(String key) {
304         return resolverSpi.engineGetProperty(key);
305     }
306 
307     /**
308      * Method addProperties
309      *
310      * @param properties
311      */
312     public void addProperties(Map&lt;String, String&gt; properties) {
313         resolverSpi.engineAddProperies(properties);
314     }
315 
316     /**
317      * Method getPropertyKeys
318      *
319      * @return all property keys.
320      */
321     public String[] getPropertyKeys() {
322         return resolverSpi.engineGetPropertyKeys();
323     }
324 
325     /**
326      * Method understandsProperty
327      *
328      * @param propertyToTest
329      * @return true if the resolver understands the property
330      */
331     public boolean understandsProperty(String propertyToTest) {
332         return resolverSpi.understandsProperty(propertyToTest);
333     }
334 
335     /**
336      * Method canResolve
337      *
338      * @param uri
339      * @param baseURI
340      * @return true if it can resolve the uri
341      */
342     private boolean canResolve(ResourceResolverContext context) {
343         return this.resolverSpi.engineCanResolveURI(context);
344     }
345 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/XMLSignatureInput.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.signature;
 24 
 25 import java.io.ByteArrayInputStream;
 26 import java.io.ByteArrayOutputStream;
 27 import java.io.IOException;
 28 import java.io.InputStream;
 29 import java.io.OutputStream;
 30 import java.nio.charset.StandardCharsets;
 31 import java.util.ArrayList;
 32 import java.util.LinkedHashSet;
 33 import java.util.List;
 34 import java.util.Set;
 35 
 36 import javax.xml.parsers.ParserConfigurationException;
 37 
 38 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 39 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer11_OmitComments;
 40 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315OmitComments;
 41 import com.sun.org.apache.xml.internal.security.c14n.implementations.CanonicalizerBase;
 42 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityRuntimeException;
 43 import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 44 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 45 import org.w3c.dom.Document;
 46 import org.w3c.dom.Node;
 47 import org.xml.sax.SAXException;
 48 
 49 /**
 50  * Class XMLSignatureInput
 51  *
 52  * $todo$ check whether an XMLSignatureInput can be _both_, octet stream _and_ node set?
 53  */
 54 public class XMLSignatureInput {
 55     /*
 56      * The XMLSignature Input can be either:
 57      *   A byteArray like with/or without InputStream.
 58      *   Or a nodeSet like defined either:
 59      *       * as a collection of nodes
 60      *       * or as subnode excluding or not comments and excluding or
 61      *         not other nodes.
 62      */
 63 
 64     /**
 65      * Some InputStreams do not support the {@link java.io.InputStream#reset}
 66      * method, so we read it in completely and work on our Proxy.
 67      */
 68     private InputStream inputOctetStreamProxy;
 69     /**
 70      * The original NodeSet for this XMLSignatureInput
 71      */
 72     private Set&lt;Node&gt; inputNodeSet;
 73     /**
 74      * The original Element
 75      */
 76     private Node subNode;
 77     /**
 78      * Exclude Node *for enveloped transformations*
 79      */
 80     private Node excludeNode;
 81     /**
 82      *
 83      */
 84     private boolean excludeComments = false;
 85 
 86     private boolean isNodeSet = false;
 87     /**
 88      * A cached bytes
 89      */
 90     private byte[] bytes;
 91     private boolean secureValidation;
 92 
 93     /**
 94      * Some Transforms may require explicit MIME type, charset (IANA registered
 95      * &quot;character set&quot;), or other such information concerning the data they are
 96      * receiving from an earlier Transform or the source data, although no
 97      * Transform algorithm specified in this document needs such explicit
 98      * information. Such data characteristics are provided as parameters to the
 99      * Transform algorithm and should be described in the specification for the
100      * algorithm.
101      */
102     private String mimeType;
103 
104     /**
105      * Field sourceURI
106      */
107     private String sourceURI;
108 
109     /**
110      * Node Filter list.
111      */
112     private List&lt;NodeFilter&gt; nodeFilters = new ArrayList&lt;&gt;();
113 
114     private boolean needsToBeExpanded = false;
115     private OutputStream outputStream;
116 
117     /**
118      * Pre-calculated digest value of the object in base64.
119      */
120     private String preCalculatedDigest;
121 
122     /**
123      * Construct a XMLSignatureInput from an octet array.
124      * &lt;p&gt;
125      * This is a comfort method, which internally converts the byte[] array into
126      * an InputStream
127      * &lt;p&gt;NOTE: no defensive copy&lt;/p&gt;
128      * @param inputOctets an octet array which including XML document or node
129      */
130     public XMLSignatureInput(byte[] inputOctets) {
131         // NO defensive copy
132         this.bytes = inputOctets;
133     }
134 
135     /**
136      * Constructs a {@code XMLSignatureInput} from an octet stream. The
137      * stream is directly read.
138      *
139      * @param inputOctetStream
140      */
141     public XMLSignatureInput(InputStream inputOctetStream)  {
142         this.inputOctetStreamProxy = inputOctetStream;
143     }
144 
145     /**
146      * Construct a XMLSignatureInput from a subtree rooted by rootNode. This
147      * method included the node and &lt;I&gt;all&lt;/I&gt; his descendants in the output.
148      *
149      * @param rootNode
150      */
151     public XMLSignatureInput(Node rootNode) {
152         this.subNode = rootNode;
153     }
154 
155     /**
156      * Constructor XMLSignatureInput
157      *
158      * @param inputNodeSet
159      */
160     public XMLSignatureInput(Set&lt;Node&gt; inputNodeSet) {
161         this.inputNodeSet = inputNodeSet;
162     }
163 
164     /**
165      * Construct a {@code XMLSignatureInput} from a known digest value in Base64.
166      * This makes it possible to compare the element digest with the provided digest value.
167      * @param preCalculatedDigest digest value in base64.
168      */
169     public XMLSignatureInput(String preCalculatedDigest) {
170         this.preCalculatedDigest = preCalculatedDigest;
171     }
172 
173     /**
174      * Check if the structure needs to be expanded.
175      * @return true if so.
176      */
177     public boolean isNeedsToBeExpanded() {
178         return needsToBeExpanded;
179     }
180 
181     /**
182      * Set if the structure needs to be expanded.
183      * @param needsToBeExpanded true if so.
184      */
185     public void setNeedsToBeExpanded(boolean needsToBeExpanded) {
186         this.needsToBeExpanded = needsToBeExpanded;
187     }
188 
189     /**
190      * Returns the node set from input which was specified as the parameter of
191      * {@link XMLSignatureInput} constructor
192      *
193      * @return the node set
194      * @throws SAXException
195      * @throws IOException
196      * @throws ParserConfigurationException
197      * @throws CanonicalizationException
198      */
199     public Set&lt;Node&gt; getNodeSet() throws CanonicalizationException, ParserConfigurationException,
200         IOException, SAXException {
201         return getNodeSet(false);
202     }
203 
204     /**
205      * Get the Input NodeSet.
206      * @return the Input NodeSet.
207      */
208     public Set&lt;Node&gt; getInputNodeSet() {
209         return inputNodeSet;
210     }
211 
212     /**
213      * Returns the node set from input which was specified as the parameter of
214      * {@link XMLSignatureInput} constructor
215      * @param circumvent
216      *
217      * @return the node set
218      * @throws SAXException
219      * @throws IOException
220      * @throws ParserConfigurationException
221      * @throws CanonicalizationException
222      */
223     public Set&lt;Node&gt; getNodeSet(boolean circumvent) throws ParserConfigurationException,
224         IOException, SAXException, CanonicalizationException {
225         if (inputNodeSet != null) {
226             return inputNodeSet;
227         }
228         if (inputOctetStreamProxy == null &amp;&amp; subNode != null) {
229             if (circumvent) {
230                 XMLUtils.circumventBug2650(XMLUtils.getOwnerDocument(subNode));
231             }
232             inputNodeSet = new LinkedHashSet&lt;Node&gt;();
233             XMLUtils.getSet(subNode, inputNodeSet, excludeNode, excludeComments);
234             return inputNodeSet;
235         } else if (isOctetStream()) {
236             convertToNodes();
237             Set&lt;Node&gt; result = new LinkedHashSet&lt;Node&gt;();
238             XMLUtils.getSet(subNode, result, null, false);
239             return result;
240         }
241 
242         throw new RuntimeException(&quot;getNodeSet() called but no input data present&quot;);
243     }
244 
245     /**
246      * Returns the Octet stream(byte Stream) from input which was specified as
247      * the parameter of {@link XMLSignatureInput} constructor
248      *
249      * @return the Octet stream(byte Stream) from input which was specified as
250      * the parameter of {@link XMLSignatureInput} constructor
251      * @throws IOException
252      */
253     public InputStream getOctetStream() throws IOException  {
254         if (inputOctetStreamProxy != null) {
255             return inputOctetStreamProxy;
256         }
257 
258         if (bytes != null) {
259             inputOctetStreamProxy = new ByteArrayInputStream(bytes);
260             return inputOctetStreamProxy;
261         }
262 
263         return null;
264     }
265 
266     /**
267      * @return real octet stream
268      */
269     public InputStream getOctetStreamReal() {
270         return inputOctetStreamProxy;
271     }
272 
273     /**
274      * Returns the byte array from input which was specified as the parameter of
275      * {@link XMLSignatureInput} constructor
276      *
277      * @return the byte[] from input which was specified as the parameter of
278      * {@link XMLSignatureInput} constructor
279      *
280      * @throws CanonicalizationException
281      * @throws IOException
282      */
283     public byte[] getBytes() throws IOException, CanonicalizationException {
284         byte[] inputBytes = getBytesFromInputStream();
285         if (inputBytes != null) {
286             return inputBytes;
287         }
288         Canonicalizer20010315OmitComments c14nizer = new Canonicalizer20010315OmitComments();
289         bytes = c14nizer.engineCanonicalize(this);
290         return bytes;
291     }
292 
293     /**
294      * Determines if the object has been set up with a Node set
295      *
296      * @return true if the object has been set up with a Node set
297      */
298     public boolean isNodeSet() {
299         return inputOctetStreamProxy == null &amp;&amp; inputNodeSet != null || isNodeSet;
300     }
301 
302     /**
303      * Determines if the object has been set up with an Element
304      *
305      * @return true if the object has been set up with an Element
306      */
307     public boolean isElement() {
308         return inputOctetStreamProxy == null &amp;&amp; subNode != null
309             &amp;&amp; inputNodeSet == null &amp;&amp; !isNodeSet;
310     }
311 
312     /**
313      * Determines if the object has been set up with an octet stream
314      *
315      * @return true if the object has been set up with an octet stream
316      */
317     public boolean isOctetStream() {
318         return (inputOctetStreamProxy != null || bytes != null)
319           &amp;&amp; inputNodeSet == null &amp;&amp; subNode == null;
320     }
321 
322     /**
323      * Determines if {@link #setOutputStream} has been called with a
324      * non-null OutputStream.
325      *
326      * @return true if {@link #setOutputStream} has been called with a
327      * non-null OutputStream
328      */
329     public boolean isOutputStreamSet() {
330         return outputStream != null;
331     }
332 
333     /**
334      * Determines if the object has been set up with a ByteArray
335      *
336      * @return true is the object has been set up with an octet stream
337      */
338     public boolean isByteArray() {
339         return bytes != null &amp;&amp; this.inputNodeSet == null &amp;&amp; subNode == null;
340     }
341 
342     /**
343      * Determines if the object has been set up with a pre-calculated digest.
344      * @return
345      */
346     public boolean isPreCalculatedDigest() {
347         return preCalculatedDigest != null;
348     }
349 
350     /**
351      * Is the object correctly set up?
352      *
353      * @return true if the object has been set up correctly
354      */
355     public boolean isInitialized() {
356         return isOctetStream() || isNodeSet();
357     }
358 
359     /**
360      * Returns mimeType
361      *
362      * @return mimeType
363      */
364     public String getMIMEType() {
365         return mimeType;
366     }
367 
368     /**
369      * Sets mimeType
370      *
371      * @param mimeType
372      */
373     public void setMIMEType(String mimeType) {
374         this.mimeType = mimeType;
375     }
376 
377     /**
378      * Return SourceURI
379      *
380      * @return SourceURI
381      */
382     public String getSourceURI() {
383         return sourceURI;
384     }
385 
386     /**
387      * Sets SourceURI
388      *
389      * @param sourceURI
390      */
391     public void setSourceURI(String sourceURI) {
392         this.sourceURI = sourceURI;
393     }
394 
395     /**
396      * Method toString
397      * {@inheritDoc}
398      */
399     public String toString() {
400         if (isNodeSet()) {
401             return &quot;XMLSignatureInput/NodeSet/&quot; + inputNodeSet.size()
402                    + &quot; nodes/&quot; + getSourceURI();
403         }
404         if (isElement()) {
405             return &quot;XMLSignatureInput/Element/&quot; + subNode
406                 + &quot; exclude &quot;+ excludeNode + &quot; comments:&quot;
407                 + excludeComments +&quot;/&quot; + getSourceURI();
408         }
409         try {
410             return &quot;XMLSignatureInput/OctetStream/&quot; + getBytes().length
411                    + &quot; octets/&quot; + getSourceURI();
412         } catch (IOException iex) {
413             return &quot;XMLSignatureInput/OctetStream//&quot; + getSourceURI();
414         } catch (CanonicalizationException cex) {
415             return &quot;XMLSignatureInput/OctetStream//&quot; + getSourceURI();
416         }
417     }
418 
419     /**
420      * Method getHTMLRepresentation
421      *
422      * @throws XMLSignatureException
423      * @return The HTML representation for this XMLSignature
424      */
425     public String getHTMLRepresentation() throws XMLSignatureException {
426         XMLSignatureInputDebugger db = new XMLSignatureInputDebugger(this);
427         return db.getHTMLRepresentation();
428     }
429 
430     /**
431      * Method getHTMLRepresentation
432      *
433      * @param inclusiveNamespaces
434      * @throws XMLSignatureException
435      * @return The HTML representation for this XMLSignature
436      */
437     public String getHTMLRepresentation(Set&lt;String&gt; inclusiveNamespaces)
438        throws XMLSignatureException {
439         XMLSignatureInputDebugger db =
440             new XMLSignatureInputDebugger(this, inclusiveNamespaces);
441         return db.getHTMLRepresentation();
442     }
443 
444     /**
445      * Gets the exclude node of this XMLSignatureInput
446      * @return Returns the excludeNode.
447      */
448     public Node getExcludeNode() {
449         return excludeNode;
450     }
451 
452     /**
453      * Sets the exclude node of this XMLSignatureInput
454      * @param excludeNode The excludeNode to set.
455      */
456     public void setExcludeNode(Node excludeNode) {
457         this.excludeNode = excludeNode;
458     }
459 
460     /**
461      * Gets the node of this XMLSignatureInput
462      * @return The excludeNode set.
463      */
464     public Node getSubNode() {
465         return subNode;
466     }
467 
468     /**
469      * @return Returns the excludeComments.
470      */
471     public boolean isExcludeComments() {
472         return excludeComments;
473     }
474 
475     /**
476      * @param excludeComments The excludeComments to set.
477      */
478     public void setExcludeComments(boolean excludeComments) {
479         this.excludeComments = excludeComments;
480     }
481 
482     /**
483      * @param diOs
484      * @throws IOException
485      * @throws CanonicalizationException
486      */
487     public void updateOutputStream(OutputStream diOs)
488         throws CanonicalizationException, IOException {
489         updateOutputStream(diOs, false);
490     }
491 
492     public void updateOutputStream(OutputStream diOs, boolean c14n11)
493         throws CanonicalizationException, IOException {
494         if (diOs == outputStream) {
495             return;
496         }
497         if (bytes != null) {
498             diOs.write(bytes);
499         } else if (inputOctetStreamProxy == null) {
500             CanonicalizerBase c14nizer = null;
501             if (c14n11) {
502                 c14nizer = new Canonicalizer11_OmitComments();
503             } else {
504                 c14nizer = new Canonicalizer20010315OmitComments();
505             }
506             c14nizer.setWriter(diOs);
507             c14nizer.engineCanonicalize(this);
508         } else {
509             byte[] buffer = new byte[4 * 1024];
510             int bytesread = 0;
511             try {
512                 while ((bytesread = inputOctetStreamProxy.read(buffer)) != -1) {
513                     diOs.write(buffer, 0, bytesread);
514                 }
515             } catch (IOException ex) {
516                 inputOctetStreamProxy.close();
517                 throw ex;
518             }
519         }
520     }
521 
522     /**
523      * @param os
524      */
525     public void setOutputStream(OutputStream os) {
526         outputStream = os;
527     }
528 
529     private byte[] getBytesFromInputStream() throws IOException {
530         if (bytes != null) {
531             return bytes;
532         }
533         if (inputOctetStreamProxy == null) {
534             return null;
535         }
536         try {
537             bytes = JavaUtils.getBytesFromStream(inputOctetStreamProxy);
538         } finally {
539             inputOctetStreamProxy.close();
540         }
541         return bytes;
542     }
543 
544     /**
545      * @param filter
546      */
547     public void addNodeFilter(NodeFilter filter) {
548         if (isOctetStream()) {
549             try {
550                 convertToNodes();
551             } catch (Exception e) {
552                 throw new XMLSecurityRuntimeException(
553                     &quot;signature.XMLSignatureInput.nodesetReference&quot;, e
554                 );
555             }
556         }
557         nodeFilters.add(filter);
558     }
559 
560     /**
561      * @return the node filters
562      */
563     public List&lt;NodeFilter&gt; getNodeFilters() {
564         return nodeFilters;
565     }
566 
567     /**
568      * @param b
569      */
570     public void setNodeSet(boolean b) {
571         isNodeSet = b;
572     }
573 
574     void convertToNodes() throws CanonicalizationException,
575         ParserConfigurationException, IOException, SAXException {
576         // select all nodes, also the comments.
577         try {
578             Document doc = XMLUtils.read(this.getOctetStream(), secureValidation);
579             this.subNode = doc;
580         } catch (SAXException ex) {
581             byte[] result = null;
582             // if a not-wellformed nodeset exists, put a container around it...
583             try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
584 
585                 baos.write(&quot;&lt;container&gt;&quot;.getBytes(StandardCharsets.UTF_8));
586                 baos.write(this.getBytes());
587                 baos.write(&quot;&lt;/container&gt;&quot;.getBytes(StandardCharsets.UTF_8));
588 
589                 result = baos.toByteArray();
590             }
591             try (InputStream is = new ByteArrayInputStream(result)) {
592                 Document document = XMLUtils.read(is, secureValidation);
593                 this.subNode = document.getDocumentElement().getFirstChild().getFirstChild();
594             }
595         } finally {
596             if (this.inputOctetStreamProxy != null) {
597                 this.inputOctetStreamProxy.close();
598             }
599             this.inputOctetStreamProxy = null;
600             this.bytes = null;
601         }
602     }
603 
604     public boolean isSecureValidation() {
605         return secureValidation;
606     }
607 
608     public void setSecureValidation(boolean secureValidation) {
609         this.secureValidation = secureValidation;
610     }
611 
612     public String getPreCalculatedDigest() {
613         return preCalculatedDigest;
614     }
615 }
    </pre>
  </body>
</html>
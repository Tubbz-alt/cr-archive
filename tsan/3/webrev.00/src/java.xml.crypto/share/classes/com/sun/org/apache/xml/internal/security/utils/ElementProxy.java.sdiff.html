<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/utils/ElementProxy.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Constants.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="Signature11ElementProxy.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/utils/ElementProxy.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.utils;
 24 
 25 import java.math.BigInteger;
 26 import java.util.concurrent.ConcurrentHashMap;
<span class="line-removed"> 27 import java.util.Base64;</span>
 28 import java.util.Map;
 29 
 30 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 31 import org.w3c.dom.Attr;
 32 import org.w3c.dom.Document;
 33 import org.w3c.dom.Element;
 34 import org.w3c.dom.Node;
 35 import org.w3c.dom.NodeList;
 36 import org.w3c.dom.Text;
 37 
 38 /**
 39  * This is the base class to all Objects which have a direct 1:1 mapping to an
 40  * Element in a particular namespace.
 41  */
 42 public abstract class ElementProxy {
 43 
 44     protected static final com.sun.org.slf4j.internal.Logger LOG =
 45         com.sun.org.slf4j.internal.LoggerFactory.getLogger(ElementProxy.class);
 46 
 47     /**
</pre>
<hr />
<pre>
250 
251         if(!expectedNamespaceUri.equals(actualNamespaceUri)
252             &amp;&amp; !expectedLocalName.equals(actualLocalName)) {
253             Object exArgs[] = { actualNamespaceUri + &quot;:&quot; + actualLocalName,
254                                 expectedNamespaceUri + &quot;:&quot; + expectedLocalName};
255             throw new XMLSecurityException(&quot;xml.WrongElement&quot;, exArgs);
256         }
257     }
258 
259     /**
260      * Method addBigIntegerElement
261      *
262      * @param bi
263      * @param localname
264      */
265     public void addBigIntegerElement(BigInteger bi, String localname) {
266         if (bi != null) {
267             Element e = XMLUtils.createElementInSignatureSpace(getDocument(), localname);
268 
269             byte[] bytes = XMLUtils.getBytes(bi, bi.bitLength());
<span class="line-modified">270             String encodedInt = Base64.getMimeEncoder().encodeToString(bytes);</span>
271 
272             Document doc = e.getOwnerDocument();
273             Text text = doc.createTextNode(encodedInt);
274 
275             e.appendChild(text);
276 
277             appendSelf(e);
278             addReturnToSelf();
279         }
280     }
281 
282     protected void addReturnToSelf() {
283         XMLUtils.addReturnToElement(getElement());
284     }
285 
286     /**
287      * Method addBase64Element
288      *
289      * @param bytes
290      * @param localname
291      */
292     public void addBase64Element(byte[] bytes, String localname) {
293         if (bytes != null) {
294             Element el = XMLUtils.createElementInSignatureSpace(getDocument(), localname);
<span class="line-modified">295             Text text = getDocument().createTextNode(Base64.getMimeEncoder().encodeToString(bytes));</span>
296 
297             el.appendChild(text);
298 
299             appendSelf(el);
300             if (!XMLUtils.ignoreLineBreaks()) {
301                 appendSelf(createText(&quot;\n&quot;));
302             }
303         }
304     }
305 
306     /**
307      * Method addTextElement
308      *
309      * @param text
310      * @param localname
311      */
312     public void addTextElement(String text, String localname) {
313         Element e = XMLUtils.createElementInSignatureSpace(getDocument(), localname);
314         Text t = createText(text);
315 
316         appendOther(e, t);
317         appendSelf(e);
318         addReturnToSelf();
319     }
320 
321     /**
322      * Method addBase64Text
323      *
324      * @param bytes
325      */
326     public void addBase64Text(byte[] bytes) {
327         if (bytes != null) {
328             Text t = XMLUtils.ignoreLineBreaks()
<span class="line-modified">329                 ? createText(Base64.getMimeEncoder().encodeToString(bytes))</span>
<span class="line-modified">330                 : createText(&quot;\n&quot; + Base64.getMimeEncoder().encodeToString(bytes) + &quot;\n&quot;);</span>
331             appendSelf(t);
332         }
333     }
334 
335     protected void appendSelf(ElementProxy toAppend) {
336         getElement().appendChild(toAppend.getElement());
337     }
338 
339     protected void appendSelf(Node toAppend) {
340         getElement().appendChild(toAppend);
341     }
342 
343     protected void appendOther(Element parent, Node toAppend) {
344         parent.appendChild(toAppend);
345     }
346 
347     /**
348      * Method addText
349      *
350      * @param text
351      */
352     public void addText(String text) {
353         if (text != null) {
354             Text t = createText(text);
355 
356             appendSelf(t);
357         }
358     }
359 
360     /**
361      * Method getVal
362      *
363      * @param localname
364      * @param namespace
365      * @return The biginteger contained in the given element
366      */
367     public BigInteger getBigIntegerFromChildElement(
368         String localname, String namespace
369     ) {
<span class="line-modified">370         return new BigInteger(1, Base64.getMimeDecoder().decode(</span>
<span class="line-modified">371             XMLUtils.selectNodeText(</span>
<span class="line-modified">372                 getFirstChild(), namespace, localname, 0</span>
<span class="line-modified">373             ).getNodeValue()</span>
<span class="line-modified">374         ));</span>
375     }
376 
377     /**
378      * Method getTextFromChildElement
379      *
380      * @param localname
381      * @param namespace
382      * @return the Text of the textNode
383      */
384     public String getTextFromChildElement(String localname, String namespace) {
385         return XMLUtils.selectNode(
386                 getFirstChild(),
387                 namespace,
388                 localname,
389                 0).getTextContent();
390     }
391 
392     /**
393      * Method getBytesFromTextChild
394      *
395      * @return The base64 bytes from the text children of this element
396      * @throws XMLSecurityException
397      */
398     public byte[] getBytesFromTextChild() throws XMLSecurityException {
<span class="line-modified">399         return Base64.getMimeDecoder().decode(getTextFromTextChild());</span>
400     }
401 
402     /**
403      * Method getTextFromTextChild
404      *
405      * @return the Text obtained by concatenating all the text nodes of this
406      *    element
407      */
408     public String getTextFromTextChild() {
<span class="line-modified">409         return XMLUtils.getFullTextChildrenFromElement(getElement());</span>
410     }
411 
412     /**
413      * Method length
414      *
415      * @param namespace
416      * @param localname
417      * @return the number of elements {namespace}:localname under this element
418      */
419     public int length(String namespace, String localname) {
420         int number = 0;
421         Node sibling = getFirstChild();
422         while (sibling != null) {
423             if (localname.equals(sibling.getLocalName())
424                 &amp;&amp; namespace.equals(sibling.getNamespaceURI())) {
425                 number++;
426             }
427             sibling = sibling.getNextSibling();
428         }
429         return number;
</pre>
<hr />
<pre>
481      */
482     public static void setDefaultPrefix(String namespace, String prefix)
483         throws XMLSecurityException {
484         JavaUtils.checkRegisterPermission();
485         setNamespacePrefix(namespace, prefix);
486     }
487 
488     private static void setNamespacePrefix(String namespace, String prefix)
489         throws XMLSecurityException {
490         if (prefixMappings.containsValue(prefix)) {
491             String storedPrefix = prefixMappings.get(namespace);
492             if (!storedPrefix.equals(prefix)) {
493                 Object exArgs[] = { prefix, namespace, storedPrefix };
494 
495                 throw new XMLSecurityException(&quot;prefix.AlreadyAssigned&quot;, exArgs);
496             }
497         }
498 
499         if (Constants.SignatureSpecNS.equals(namespace)) {
500             XMLUtils.setDsPrefix(prefix);
<span class="line-modified">501         }</span>
<span class="line-modified">502         if (EncryptionConstants.EncryptionSpecNS.equals(namespace)) {</span>

503             XMLUtils.setXencPrefix(prefix);
504         }
505         prefixMappings.put(namespace, prefix);
506     }
507 
508     /**
509      * This method registers the default prefixes.
510      */
511     public static void registerDefaultPrefixes() throws XMLSecurityException {
512         setNamespacePrefix(&quot;http://www.w3.org/2000/09/xmldsig#&quot;, &quot;ds&quot;);
513         setNamespacePrefix(&quot;http://www.w3.org/2001/04/xmlenc#&quot;, &quot;xenc&quot;);
514         setNamespacePrefix(&quot;http://www.w3.org/2009/xmlenc11#&quot;, &quot;xenc11&quot;);
515         setNamespacePrefix(&quot;http://www.xmlsecurity.org/experimental#&quot;, &quot;experimental&quot;);
516         setNamespacePrefix(&quot;http://www.w3.org/2002/04/xmldsig-filter2&quot;, &quot;dsig-xpath-old&quot;);
517         setNamespacePrefix(&quot;http://www.w3.org/2002/06/xmldsig-filter2&quot;, &quot;dsig-xpath&quot;);
518         setNamespacePrefix(&quot;http://www.w3.org/2001/10/xml-exc-c14n#&quot;, &quot;ec&quot;);
519         setNamespacePrefix(
520             &quot;http://www.nue.et-inf.uni-siegen.de/~geuer-pollmann/#xpathFilter&quot;, &quot;xx&quot;
521         );

522     }
523 
524     /**
525      * Method getDefaultPrefix
526      *
527      * @param namespace
528      * @return the default prefix bind to this element.
529      */
530     public static String getDefaultPrefix(String namespace) {
531         return prefixMappings.get(namespace);
532     }
533 
534     /**
535      * New value for the wrapped XML element that this object is a proxy for.
536      *
537      * @param elem  New element
538      *
539      * @see #getElement()
540      */
541     protected void setElement(Element elem) {
</pre>
</td>
<td>
<hr />
<pre>
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.utils;
 24 
 25 import java.math.BigInteger;
 26 import java.util.concurrent.ConcurrentHashMap;

 27 import java.util.Map;
 28 
 29 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 30 import org.w3c.dom.Attr;
 31 import org.w3c.dom.Document;
 32 import org.w3c.dom.Element;
 33 import org.w3c.dom.Node;
 34 import org.w3c.dom.NodeList;
 35 import org.w3c.dom.Text;
 36 
 37 /**
 38  * This is the base class to all Objects which have a direct 1:1 mapping to an
 39  * Element in a particular namespace.
 40  */
 41 public abstract class ElementProxy {
 42 
 43     protected static final com.sun.org.slf4j.internal.Logger LOG =
 44         com.sun.org.slf4j.internal.LoggerFactory.getLogger(ElementProxy.class);
 45 
 46     /**
</pre>
<hr />
<pre>
249 
250         if(!expectedNamespaceUri.equals(actualNamespaceUri)
251             &amp;&amp; !expectedLocalName.equals(actualLocalName)) {
252             Object exArgs[] = { actualNamespaceUri + &quot;:&quot; + actualLocalName,
253                                 expectedNamespaceUri + &quot;:&quot; + expectedLocalName};
254             throw new XMLSecurityException(&quot;xml.WrongElement&quot;, exArgs);
255         }
256     }
257 
258     /**
259      * Method addBigIntegerElement
260      *
261      * @param bi
262      * @param localname
263      */
264     public void addBigIntegerElement(BigInteger bi, String localname) {
265         if (bi != null) {
266             Element e = XMLUtils.createElementInSignatureSpace(getDocument(), localname);
267 
268             byte[] bytes = XMLUtils.getBytes(bi, bi.bitLength());
<span class="line-modified">269             String encodedInt = XMLUtils.encodeToString(bytes);</span>
270 
271             Document doc = e.getOwnerDocument();
272             Text text = doc.createTextNode(encodedInt);
273 
274             e.appendChild(text);
275 
276             appendSelf(e);
277             addReturnToSelf();
278         }
279     }
280 
281     protected void addReturnToSelf() {
282         XMLUtils.addReturnToElement(getElement());
283     }
284 
285     /**
286      * Method addBase64Element
287      *
288      * @param bytes
289      * @param localname
290      */
291     public void addBase64Element(byte[] bytes, String localname) {
292         if (bytes != null) {
293             Element el = XMLUtils.createElementInSignatureSpace(getDocument(), localname);
<span class="line-modified">294             Text text = getDocument().createTextNode(XMLUtils.encodeToString(bytes));</span>
295 
296             el.appendChild(text);
297 
298             appendSelf(el);
299             if (!XMLUtils.ignoreLineBreaks()) {
300                 appendSelf(createText(&quot;\n&quot;));
301             }
302         }
303     }
304 
305     /**
306      * Method addTextElement
307      *
308      * @param text
309      * @param localname
310      */
311     public void addTextElement(String text, String localname) {
312         Element e = XMLUtils.createElementInSignatureSpace(getDocument(), localname);
313         Text t = createText(text);
314 
315         appendOther(e, t);
316         appendSelf(e);
317         addReturnToSelf();
318     }
319 
320     /**
321      * Method addBase64Text
322      *
323      * @param bytes
324      */
325     public void addBase64Text(byte[] bytes) {
326         if (bytes != null) {
327             Text t = XMLUtils.ignoreLineBreaks()
<span class="line-modified">328                 ? createText(XMLUtils.encodeToString(bytes))</span>
<span class="line-modified">329                 : createText(&quot;\n&quot; + XMLUtils.encodeToString(bytes) + &quot;\n&quot;);</span>
330             appendSelf(t);
331         }
332     }
333 
334     protected void appendSelf(ElementProxy toAppend) {
335         getElement().appendChild(toAppend.getElement());
336     }
337 
338     protected void appendSelf(Node toAppend) {
339         getElement().appendChild(toAppend);
340     }
341 
342     protected void appendOther(Element parent, Node toAppend) {
343         parent.appendChild(toAppend);
344     }
345 
346     /**
347      * Method addText
348      *
349      * @param text
350      */
351     public void addText(String text) {
352         if (text != null) {
353             Text t = createText(text);
354 
355             appendSelf(t);
356         }
357     }
358 
359     /**
360      * Method getVal
361      *
362      * @param localname
363      * @param namespace
364      * @return The biginteger contained in the given element
365      */
366     public BigInteger getBigIntegerFromChildElement(
367         String localname, String namespace
368     ) {
<span class="line-modified">369         Node n = XMLUtils.selectNode(getFirstChild(), namespace, localname, 0);</span>
<span class="line-modified">370         if (n != null) {</span>
<span class="line-modified">371             return new BigInteger(1, XMLUtils.decode(XMLUtils.getFullTextChildrenFromNode(n)));</span>
<span class="line-modified">372         }</span>
<span class="line-modified">373         return null;</span>
374     }
375 
376     /**
377      * Method getTextFromChildElement
378      *
379      * @param localname
380      * @param namespace
381      * @return the Text of the textNode
382      */
383     public String getTextFromChildElement(String localname, String namespace) {
384         return XMLUtils.selectNode(
385                 getFirstChild(),
386                 namespace,
387                 localname,
388                 0).getTextContent();
389     }
390 
391     /**
392      * Method getBytesFromTextChild
393      *
394      * @return The base64 bytes from the text children of this element
395      * @throws XMLSecurityException
396      */
397     public byte[] getBytesFromTextChild() throws XMLSecurityException {
<span class="line-modified">398         return XMLUtils.decode(getTextFromTextChild());</span>
399     }
400 
401     /**
402      * Method getTextFromTextChild
403      *
404      * @return the Text obtained by concatenating all the text nodes of this
405      *    element
406      */
407     public String getTextFromTextChild() {
<span class="line-modified">408         return XMLUtils.getFullTextChildrenFromNode(getElement());</span>
409     }
410 
411     /**
412      * Method length
413      *
414      * @param namespace
415      * @param localname
416      * @return the number of elements {namespace}:localname under this element
417      */
418     public int length(String namespace, String localname) {
419         int number = 0;
420         Node sibling = getFirstChild();
421         while (sibling != null) {
422             if (localname.equals(sibling.getLocalName())
423                 &amp;&amp; namespace.equals(sibling.getNamespaceURI())) {
424                 number++;
425             }
426             sibling = sibling.getNextSibling();
427         }
428         return number;
</pre>
<hr />
<pre>
480      */
481     public static void setDefaultPrefix(String namespace, String prefix)
482         throws XMLSecurityException {
483         JavaUtils.checkRegisterPermission();
484         setNamespacePrefix(namespace, prefix);
485     }
486 
487     private static void setNamespacePrefix(String namespace, String prefix)
488         throws XMLSecurityException {
489         if (prefixMappings.containsValue(prefix)) {
490             String storedPrefix = prefixMappings.get(namespace);
491             if (!storedPrefix.equals(prefix)) {
492                 Object exArgs[] = { prefix, namespace, storedPrefix };
493 
494                 throw new XMLSecurityException(&quot;prefix.AlreadyAssigned&quot;, exArgs);
495             }
496         }
497 
498         if (Constants.SignatureSpecNS.equals(namespace)) {
499             XMLUtils.setDsPrefix(prefix);
<span class="line-modified">500         } else if (Constants.SignatureSpec11NS.equals(namespace)) {</span>
<span class="line-modified">501             XMLUtils.setDs11Prefix(prefix);</span>
<span class="line-added">502         } else if (EncryptionConstants.EncryptionSpecNS.equals(namespace)) {</span>
503             XMLUtils.setXencPrefix(prefix);
504         }
505         prefixMappings.put(namespace, prefix);
506     }
507 
508     /**
509      * This method registers the default prefixes.
510      */
511     public static void registerDefaultPrefixes() throws XMLSecurityException {
512         setNamespacePrefix(&quot;http://www.w3.org/2000/09/xmldsig#&quot;, &quot;ds&quot;);
513         setNamespacePrefix(&quot;http://www.w3.org/2001/04/xmlenc#&quot;, &quot;xenc&quot;);
514         setNamespacePrefix(&quot;http://www.w3.org/2009/xmlenc11#&quot;, &quot;xenc11&quot;);
515         setNamespacePrefix(&quot;http://www.xmlsecurity.org/experimental#&quot;, &quot;experimental&quot;);
516         setNamespacePrefix(&quot;http://www.w3.org/2002/04/xmldsig-filter2&quot;, &quot;dsig-xpath-old&quot;);
517         setNamespacePrefix(&quot;http://www.w3.org/2002/06/xmldsig-filter2&quot;, &quot;dsig-xpath&quot;);
518         setNamespacePrefix(&quot;http://www.w3.org/2001/10/xml-exc-c14n#&quot;, &quot;ec&quot;);
519         setNamespacePrefix(
520             &quot;http://www.nue.et-inf.uni-siegen.de/~geuer-pollmann/#xpathFilter&quot;, &quot;xx&quot;
521         );
<span class="line-added">522         setNamespacePrefix(&quot;http://www.w3.org/2009/xmldsig11#&quot;, &quot;dsig11&quot;);</span>
523     }
524 
525     /**
526      * Method getDefaultPrefix
527      *
528      * @param namespace
529      * @return the default prefix bind to this element.
530      */
531     public static String getDefaultPrefix(String namespace) {
532         return prefixMappings.get(namespace);
533     }
534 
535     /**
536      * New value for the wrapped XML element that this object is a proxy for.
537      *
538      * @param elem  New element
539      *
540      * @see #getElement()
541      */
542     protected void setElement(Element elem) {
</pre>
</td>
</tr>
</table>
<center><a href="Constants.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="Signature11ElementProxy.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
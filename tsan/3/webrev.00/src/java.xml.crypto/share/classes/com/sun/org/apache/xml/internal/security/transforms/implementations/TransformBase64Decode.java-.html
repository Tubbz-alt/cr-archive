<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/transforms/implementations/TransformBase64Decode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.transforms.implementations;
 24 
 25 import java.io.IOException;
 26 import java.io.OutputStream;
 27 import java.util.Base64;
 28 
 29 import javax.xml.parsers.ParserConfigurationException;
 30 
 31 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 32 import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
 33 import com.sun.org.apache.xml.internal.security.transforms.Transform;
 34 import com.sun.org.apache.xml.internal.security.transforms.TransformSpi;
 35 import com.sun.org.apache.xml.internal.security.transforms.TransformationException;
 36 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
 37 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 38 import org.w3c.dom.Document;
 39 import org.w3c.dom.Element;
 40 import org.w3c.dom.Node;
 41 import org.w3c.dom.Text;
 42 import org.xml.sax.SAXException;
 43 
 44 import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 45 
 46 /**
 47  * Implements the {@code http://www.w3.org/2000/09/xmldsig#base64} decoding
 48  * transform.
 49  *
 50  * &lt;p&gt;The normative specification for base64 decoding transforms is
 51  * &lt;A HREF=&quot;http://www.w3.org/TR/2001/CR-xmldsig-core-20010419/#ref-MIME&quot;&gt;[MIME]&lt;/A&gt;.
 52  * The base64 Transform element has no content. The input
 53  * is decoded by the algorithms. This transform is useful if an
 54  * application needs to sign the raw data associated with the encoded
 55  * content of an element. &lt;/p&gt;
 56  *
 57  * &lt;p&gt;This transform requires an octet stream for input.
 58  * If an XPath node-set (or sufficiently functional alternative) is
 59  * given as input, then it is converted to an octet stream by
 60  * performing operations LOGically equivalent to 1) applying an XPath
 61  * transform with expression self::text(), then 2) taking the string-value
 62  * of the node-set. Thus, if an XML element is identified by a barename
 63  * XPointer in the Reference URI, and its content consists solely of base64
 64  * encoded character data, then this transform automatically strips away the
 65  * start and end tags of the identified element and any of its descendant
 66  * elements as well as any descendant comments and processing instructions.
 67  * The output of this transform is an octet stream.&lt;/p&gt;
 68  *
 69  */
 70 public class TransformBase64Decode extends TransformSpi {
 71 
 72     /** Field implementedTransformURI */
 73     public static final String implementedTransformURI =
 74         Transforms.TRANSFORM_BASE64_DECODE;
 75 
 76     /**
 77      * Method engineGetURI
 78      *
 79      * {@inheritDoc}
 80      */
 81     protected String engineGetURI() {
 82         return TransformBase64Decode.implementedTransformURI;
 83     }
 84 
 85     /**
 86      * Method enginePerformTransform
 87      *
 88      * @param input
 89      * @return {@link XMLSignatureInput} as the result of transformation
 90      * {@inheritDoc}
 91      * @throws CanonicalizationException
 92      * @throws IOException
 93      * @throws TransformationException
 94      */
 95     protected XMLSignatureInput enginePerformTransform(
 96         XMLSignatureInput input, Transform transformObject
 97     ) throws IOException, CanonicalizationException, TransformationException {
 98         return enginePerformTransform(input, null, transformObject);
 99     }
100 
101     protected XMLSignatureInput enginePerformTransform(
102         XMLSignatureInput input, OutputStream os, Transform transformObject
103     ) throws IOException, CanonicalizationException, TransformationException {
104         if (input.isElement()) {
105             Node el = input.getSubNode();
106             if (input.getSubNode().getNodeType() == Node.TEXT_NODE) {
107                 el = el.getParentNode();
108             }
109             StringBuilder sb = new StringBuilder();
110             traverseElement((Element)el, sb);
111             if (os == null) {
112                 byte[] decodedBytes = Base64.getMimeDecoder().decode(sb.toString());
113                 XMLSignatureInput output = new XMLSignatureInput(decodedBytes);
114                 output.setSecureValidation(secureValidation);
115                 return output;
116             }
117             byte[] bytes = Base64.getMimeDecoder().decode(sb.toString());
118             os.write(bytes);
119             XMLSignatureInput output = new XMLSignatureInput((byte[])null);
120             output.setSecureValidation(secureValidation);
121             output.setOutputStream(os);
122             return output;
123         }
124 
125         if (input.isOctetStream() || input.isNodeSet()) {
126             if (os == null) {
127                 byte[] base64Bytes = input.getBytes();
128                 byte[] decodedBytes = Base64.getMimeDecoder().decode(base64Bytes);
129                 XMLSignatureInput output = new XMLSignatureInput(decodedBytes);
130                 output.setSecureValidation(secureValidation);
131                 return output;
132             }
133             if (input.isByteArray() || input.isNodeSet()) {
134                 byte[] bytes = Base64.getMimeDecoder().decode(input.getBytes());
135                 os.write(bytes);
136             } else {
137                 byte[] inputBytes = JavaUtils.getBytesFromStream(input.getOctetStreamReal());
138                 byte[] bytes = Base64.getMimeDecoder().decode(inputBytes);
139                 os.write(bytes);
140             }
141             XMLSignatureInput output = new XMLSignatureInput((byte[])null);
142             output.setSecureValidation(secureValidation);
143             output.setOutputStream(os);
144             return output;
145         }
146 
147         try {
148             //Exceptional case there is current not text case testing this(Before it was a
149             //a common case).
150             Document doc =
151                 XMLUtils.createDocumentBuilder(false, secureValidation).parse(input.getOctetStream());
152 
153             Element rootNode = doc.getDocumentElement();
154             StringBuilder sb = new StringBuilder();
155             traverseElement(rootNode, sb);
156             byte[] decodedBytes = Base64.getMimeDecoder().decode(sb.toString());
157             XMLSignatureInput output = new XMLSignatureInput(decodedBytes);
158             output.setSecureValidation(secureValidation);
159             return output;
160         } catch (ParserConfigurationException e) {
161             throw new TransformationException(e, &quot;c14n.Canonicalizer.Exception&quot;);
162         } catch (SAXException e) {
163             throw new TransformationException(e, &quot;SAX exception&quot;);
164         }
165     }
166 
167     void traverseElement(Element node, StringBuilder sb) {
168         Node sibling = node.getFirstChild();
169         while (sibling != null) {
170             switch (sibling.getNodeType()) {
171             case Node.ELEMENT_NODE:
172                 traverseElement((Element)sibling, sb);
173                 break;
174             case Node.TEXT_NODE:
175                 sb.append(((Text)sibling).getData());
176             }
177             sibling = sibling.getNextSibling();
178         }
179     }
180 }
    </pre>
  </body>
</html>
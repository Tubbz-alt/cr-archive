<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/keys/keyresolver/KeyResolver.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.keys.keyresolver;
 24 
 25 import java.security.PublicKey;
 26 import java.security.cert.X509Certificate;
 27 import java.util.ArrayList;
 28 import java.util.Iterator;
 29 import java.util.List;
 30 import java.util.concurrent.CopyOnWriteArrayList;
 31 
 32 import javax.crypto.SecretKey;
 33 
 34 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.DEREncodedKeyValueResolver;
 35 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.DSAKeyValueResolver;
 36 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.ECKeyValueResolver;
 37 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.KeyInfoReferenceResolver;
 38 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.RSAKeyValueResolver;
 39 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.RetrievalMethodResolver;
 40 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.X509CertificateResolver;
 41 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.X509DigestResolver;
 42 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.X509IssuerSerialResolver;
 43 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.X509SKIResolver;
 44 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.X509SubjectNameResolver;
 45 import com.sun.org.apache.xml.internal.security.keys.storage.StorageResolver;
 46 import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 47 import org.w3c.dom.Element;
 48 import org.w3c.dom.Node;
 49 
 50 /**
 51  * KeyResolver is factory class for subclass of KeyResolverSpi that
 52  * represent child element of KeyInfo.
 53  */
 54 public class KeyResolver {
 55 
 56     private static final com.sun.org.slf4j.internal.Logger LOG =
 57         com.sun.org.slf4j.internal.LoggerFactory.getLogger(KeyResolver.class);
 58 
 59     /** Field resolverVector */
 60     private static List&lt;KeyResolver&gt; resolverVector = new CopyOnWriteArrayList&lt;KeyResolver&gt;();
 61 
 62     /** Field resolverSpi */
 63     private final KeyResolverSpi resolverSpi;
 64 
 65     /**
 66      * Constructor.
 67      *
 68      * @param keyResolverSpi a KeyResolverSpi instance
 69      */
 70     private KeyResolver(KeyResolverSpi keyResolverSpi) {
 71         resolverSpi = keyResolverSpi;
 72     }
 73 
 74     /**
 75      * Method length
 76      *
 77      * @return the length of resolvers registered
 78      */
 79     public static int length() {
 80         return resolverVector.size();
 81     }
 82 
 83     /**
 84      * Method getX509Certificate
 85      *
 86      * @param element
 87      * @param baseURI
 88      * @param storage
 89      * @return The certificate represented by the element.
 90      *
 91      * @throws KeyResolverException
 92      */
 93     public static final X509Certificate getX509Certificate(
 94         Element element, String baseURI, StorageResolver storage
 95     ) throws KeyResolverException {
 96         for (KeyResolver resolver : resolverVector) {
 97             if (resolver == null) {
 98                 Object exArgs[] = {
 99                                    element != null
100                                        &amp;&amp; element.getNodeType() == Node.ELEMENT_NODE
101                                        ? element.getTagName() : &quot;null&quot;
102                 };
103 
104                 throw new KeyResolverException(&quot;utils.resolver.noClass&quot;, exArgs);
105             }
106             LOG.debug(&quot;check resolvability by class {}&quot;, resolver.getClass());
107 
108             X509Certificate cert = resolver.resolveX509Certificate(element, baseURI, storage);
109             if (cert != null) {
110                 return cert;
111             }
112         }
113 
114         Object exArgs[] = {
115                            element != null &amp;&amp; element.getNodeType() == Node.ELEMENT_NODE
116                            ? element.getTagName() : &quot;null&quot;
117                           };
118 
119         throw new KeyResolverException(&quot;utils.resolver.noClass&quot;, exArgs);
120     }
121 
122     /**
123      * Method getPublicKey
124      *
125      * @param element
126      * @param baseURI
127      * @param storage
128      * @return the public key contained in the element
129      *
130      * @throws KeyResolverException
131      */
132     public static final PublicKey getPublicKey(
133         Element element, String baseURI, StorageResolver storage
134     ) throws KeyResolverException {
135         for (KeyResolver resolver : resolverVector) {
136             if (resolver == null) {
137                 Object exArgs[] = {
138                                    element != null
139                                        &amp;&amp; element.getNodeType() == Node.ELEMENT_NODE
140                                        ? element.getTagName() : &quot;null&quot;
141                 };
142 
143                 throw new KeyResolverException(&quot;utils.resolver.noClass&quot;, exArgs);
144             }
145             LOG.debug(&quot;check resolvability by class {}&quot;, resolver.getClass());
146 
147             PublicKey cert = resolver.resolvePublicKey(element, baseURI, storage);
148             if (cert != null) {
149                 return cert;
150             }
151         }
152 
153         Object exArgs[] = {
154                            element != null &amp;&amp; element.getNodeType() == Node.ELEMENT_NODE
155                            ? element.getTagName() : &quot;null&quot;
156                           };
157 
158         throw new KeyResolverException(&quot;utils.resolver.noClass&quot;, exArgs);
159     }
160 
161     /**
162      * This method is used for registering {@link KeyResolverSpi}s which are
163      * available to &lt;I&gt;all&lt;/I&gt; {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} objects. This means that
164      * personalized {@link KeyResolverSpi}s should only be registered directly
165      * to the {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} using
166      * {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo#registerInternalKeyResolver}.
167      * Please note that this method will create a new copy of the underlying array, as the
168      * underlying collection is a CopyOnWriteArrayList.
169      *
170      * @param className
171      * @param globalResolver Whether the KeyResolverSpi is a global resolver or not
172      * @throws InstantiationException
173      * @throws IllegalAccessException
174      * @throws ClassNotFoundException
175      * @throws SecurityException if a security manager is installed and the
176      *    caller does not have permission to register the key resolver
177      */
178     public static void register(String className, boolean globalResolver)
179         throws ClassNotFoundException, IllegalAccessException, InstantiationException {
180         JavaUtils.checkRegisterPermission();
181         @SuppressWarnings(&quot;deprecation&quot;)
182         KeyResolverSpi keyResolverSpi =
183             (KeyResolverSpi) ClassLoaderUtils.loadClass(className, KeyResolver.class).newInstance();
184         keyResolverSpi.setGlobalResolver(globalResolver);
185         register(keyResolverSpi, false);
186     }
187 
188     /**
189      * This method is used for registering {@link KeyResolverSpi}s which are
190      * available to &lt;I&gt;all&lt;/I&gt; {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} objects. This means that
191      * personalized {@link KeyResolverSpi}s should only be registered directly
192      * to the {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} using
193      * {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo#registerInternalKeyResolver}.
194      * Please note that this method will create a new copy of the underlying array, as the
195      * underlying collection is a CopyOnWriteArrayList.
196      *
197      * @param className
198      * @param globalResolver Whether the KeyResolverSpi is a global resolver or not
199      * @throws SecurityException if a security manager is installed and the
200      *    caller does not have permission to register the key resolver
201      */
202     public static void registerAtStart(String className, boolean globalResolver) {
203         JavaUtils.checkRegisterPermission();
204         KeyResolverSpi keyResolverSpi = null;
205         Exception ex = null;
206         try {
207             @SuppressWarnings(&quot;deprecation&quot;)
208             KeyResolverSpi tmp = (KeyResolverSpi) ClassLoaderUtils.loadClass(className, KeyResolver.class).newInstance();
209             keyResolverSpi = tmp;
210             keyResolverSpi.setGlobalResolver(globalResolver);
211             register(keyResolverSpi, true);
212         } catch (ClassNotFoundException e) {
213             ex = e;
214         } catch (IllegalAccessException e) {
215             ex = e;
216         } catch (InstantiationException e) {
217             ex = e;
218         }
219 
220         if (ex != null) {
221             throw (IllegalArgumentException) new
222             IllegalArgumentException(&quot;Invalid KeyResolver class name&quot;).initCause(ex);
223         }
224     }
225 
226     /**
227      * This method is used for registering {@link KeyResolverSpi}s which are
228      * available to &lt;I&gt;all&lt;/I&gt; {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} objects. This means that
229      * personalized {@link KeyResolverSpi}s should only be registered directly
230      * to the {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} using
231      * {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo#registerInternalKeyResolver}.
232      * Please note that this method will create a new copy of the underlying array, as the
233      * underlying collection is a CopyOnWriteArrayList.
234      *
235      * @param keyResolverSpi a KeyResolverSpi instance to register
236      * @param start whether to register the KeyResolverSpi at the start of the list or not
237      * @throws SecurityException if a security manager is installed and the
238      *    caller does not have permission to register the key resolver
239      */
240     public static void register(
241         KeyResolverSpi keyResolverSpi,
242         boolean start
243     ) {
244         JavaUtils.checkRegisterPermission();
245         KeyResolver resolver = new KeyResolver(keyResolverSpi);
246         if (start) {
247             resolverVector.add(0, resolver);
248         } else {
249             resolverVector.add(resolver);
250         }
251     }
252 
253     /**
254      * This method is used for registering {@link KeyResolverSpi}s which are
255      * available to &lt;I&gt;all&lt;/I&gt; {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} objects. This means that
256      * personalized {@link KeyResolverSpi}s should only be registered directly
257      * to the {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} using
258      * {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo#registerInternalKeyResolver}.
259      * The KeyResolverSpi instances are not registered as a global resolver.
260      *
261      *
262      * @param classNames
263      * @throws InstantiationException
264      * @throws IllegalAccessException
265      * @throws ClassNotFoundException
266      * @throws SecurityException if a security manager is installed and the
267      *    caller does not have permission to register the key resolver
268      */
269     public static void registerClassNames(List&lt;String&gt; classNames)
270         throws ClassNotFoundException, IllegalAccessException, InstantiationException {
271         JavaUtils.checkRegisterPermission();
272         List&lt;KeyResolver&gt; keyResolverList = new ArrayList&lt;&gt;(classNames.size());
273         for (String className : classNames) {
274             @SuppressWarnings(&quot;deprecation&quot;)
275             KeyResolverSpi keyResolverSpi =
276                 (KeyResolverSpi)ClassLoaderUtils.loadClass(className, KeyResolver.class).newInstance();
277             keyResolverSpi.setGlobalResolver(false);
278             keyResolverList.add(new KeyResolver(keyResolverSpi));
279         }
280         resolverVector.addAll(keyResolverList);
281     }
282 
283     /**
284      * This method registers the default resolvers.
285      */
286     public static void registerDefaultResolvers() {
287 
288         List&lt;KeyResolver&gt; keyResolverList = new ArrayList&lt;&gt;();
289         keyResolverList.add(new KeyResolver(new RSAKeyValueResolver()));
290         keyResolverList.add(new KeyResolver(new DSAKeyValueResolver()));
291         keyResolverList.add(new KeyResolver(new X509CertificateResolver()));
292         keyResolverList.add(new KeyResolver(new X509SKIResolver()));
293         keyResolverList.add(new KeyResolver(new RetrievalMethodResolver()));
294         keyResolverList.add(new KeyResolver(new X509SubjectNameResolver()));
295         keyResolverList.add(new KeyResolver(new X509IssuerSerialResolver()));
296         keyResolverList.add(new KeyResolver(new DEREncodedKeyValueResolver()));
297         keyResolverList.add(new KeyResolver(new KeyInfoReferenceResolver()));
298         keyResolverList.add(new KeyResolver(new X509DigestResolver()));
299         keyResolverList.add(new KeyResolver(new ECKeyValueResolver()));
300 
301         resolverVector.addAll(keyResolverList);
302     }
303 
304     /**
305      * Method resolvePublicKey
306      *
307      * @param element
308      * @param baseURI
309      * @param storage
310      * @return resolved public key from the registered from the elements
311      *
312      * @throws KeyResolverException
313      */
314     public PublicKey resolvePublicKey(
315         Element element, String baseURI, StorageResolver storage
316     ) throws KeyResolverException {
317         return resolverSpi.engineLookupAndResolvePublicKey(element, baseURI, storage);
318     }
319 
320     /**
321      * Method resolveX509Certificate
322      *
323      * @param element
324      * @param baseURI
325      * @param storage
326      * @return resolved X509certificate key from the registered from the elements
327      *
328      * @throws KeyResolverException
329      */
330     public X509Certificate resolveX509Certificate(
331         Element element, String baseURI, StorageResolver storage
332     ) throws KeyResolverException {
333         return resolverSpi.engineLookupResolveX509Certificate(element, baseURI, storage);
334     }
335 
336     /**
337      * @param element
338      * @param baseURI
339      * @param storage
340      * @return resolved SecretKey key from the registered from the elements
341      * @throws KeyResolverException
342      */
343     public SecretKey resolveSecretKey(
344         Element element, String baseURI, StorageResolver storage
345     ) throws KeyResolverException {
346         return resolverSpi.engineLookupAndResolveSecretKey(element, baseURI, storage);
347     }
348 
349     /**
350      * Method setProperty
351      *
352      * @param key
353      * @param value
354      */
355     public void setProperty(String key, String value) {
356         resolverSpi.engineSetProperty(key, value);
357     }
358 
359     /**
360      * Method getProperty
361      *
362      * @param key
363      * @return the property set for this resolver
364      */
365     public String getProperty(String key) {
366         return resolverSpi.engineGetProperty(key);
367     }
368 
369 
370     /**
371      * Method understandsProperty
372      *
373      * @param propertyToTest
374      * @return true if the resolver understands property propertyToTest
375      */
376     public boolean understandsProperty(String propertyToTest) {
377         return resolverSpi.understandsProperty(propertyToTest);
378     }
379 
380 
381     /**
382      * Method resolverClassName
383      *
384      * @return the name of the resolver.
385      */
386     public String resolverClassName() {
387         return resolverSpi.getClass().getName();
388     }
389 
390     /**
391      * Iterate over the KeyResolverSpi instances
392      */
393     static class ResolverIterator implements Iterator&lt;KeyResolverSpi&gt; {
394         List&lt;KeyResolver&gt; res;
395         Iterator&lt;KeyResolver&gt; it;
396 
397         public ResolverIterator(List&lt;KeyResolver&gt; list) {
398             res = list;
399             it = res.iterator();
400         }
401 
402         public boolean hasNext() {
403             return it.hasNext();
404         }
405 
406         public KeyResolverSpi next() {
407             KeyResolver resolver = it.next();
408             if (resolver == null) {
409                 throw new RuntimeException(&quot;utils.resolver.noClass&quot;);
410             }
411 
412             return resolver.resolverSpi;
413         }
414 
415         public void remove() {
416             throw new UnsupportedOperationException(&quot;Can&#39;t remove resolvers using the iterator&quot;);
417         }
418     }
419 
420     public static Iterator&lt;KeyResolverSpi&gt; iterator() {
421         return new ResolverIterator(resolverVector);
422     }
423 }
    </pre>
  </body>
</html>
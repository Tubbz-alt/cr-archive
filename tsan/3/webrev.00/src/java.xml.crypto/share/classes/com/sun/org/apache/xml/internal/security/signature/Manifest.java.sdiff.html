<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/Manifest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../resource/config.xml.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="Reference.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/Manifest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.signature;
 24 
 25 import java.io.IOException;


 26 import java.util.ArrayList;

 27 import java.util.HashMap;
 28 import java.util.Iterator;
 29 import java.util.List;
 30 import java.util.Map;
 31 import java.util.Set;
 32 
 33 import javax.xml.parsers.ParserConfigurationException;
 34 
 35 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 36 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
 37 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 38 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
 39 import com.sun.org.apache.xml.internal.security.utils.Constants;
 40 import com.sun.org.apache.xml.internal.security.utils.I18n;
 41 import com.sun.org.apache.xml.internal.security.utils.SignatureElementProxy;
 42 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 43 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;
 44 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverSpi;
 45 import org.w3c.dom.Attr;
 46 import org.w3c.dom.DOMException;
 47 import org.w3c.dom.Document;
 48 import org.w3c.dom.Element;
 49 import org.w3c.dom.Node;
 50 import org.xml.sax.SAXException;
 51 
 52 /**
 53  * Handles {@code &amp;lt;ds:Manifest&amp;gt;} elements.
 54  * &lt;p&gt; This element holds the {@code Reference} elements&lt;/p&gt;
 55  */
 56 public class Manifest extends SignatureElementProxy {
 57 
 58     /**
<span class="line-modified"> 59      * The maximum number of references per Manifest, if secure validation is enabled.</span>
 60      */
 61     public static final int MAXIMUM_REFERENCE_COUNT = 30;
 62 
 63     private static final com.sun.org.slf4j.internal.Logger LOG =
 64         com.sun.org.slf4j.internal.LoggerFactory.getLogger(Manifest.class);
 65 





 66     /** Field references */
 67     private List&lt;Reference&gt; references;
 68     private Element[] referencesEl;
 69 
 70     /** Field verificationResults[] */
<span class="line-modified"> 71     private boolean[] verificationResults;</span>
 72 
 73     /** Field resolverProperties */
 74     private Map&lt;String, String&gt; resolverProperties;
 75 
 76     /** Field perManifestResolvers */
 77     private List&lt;ResourceResolver&gt; perManifestResolvers;
 78 
 79     private boolean secureValidation;
 80 
 81     /**
 82      * Constructs {@link Manifest}
 83      *
 84      * @param doc the {@link Document} in which {@code XMLsignature} is placed
 85      */
 86     public Manifest(Document doc) {
 87         super(doc);
 88 
 89         addReturnToSelf();
 90 
 91         this.references = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
118         Attr attr = element.getAttributeNodeNS(null, &quot;Id&quot;);
119         if (attr != null) {
120             element.setIdAttributeNode(attr, true);
121         }
122         this.secureValidation = secureValidation;
123 
124         // check out Reference children
125         this.referencesEl =
126             XMLUtils.selectDsNodes(
127                 getFirstChild(), Constants._TAG_REFERENCE
128             );
129         int le = this.referencesEl.length;
130         if (le == 0) {
131             // At least one Reference must be present. Bad.
132             Object exArgs[] = { Constants._TAG_REFERENCE, Constants._TAG_MANIFEST };
133 
134             throw new DOMException(DOMException.WRONG_DOCUMENT_ERR,
135                                    I18n.translate(&quot;xml.WrongContent&quot;, exArgs));
136         }
137 
<span class="line-modified">138         if (secureValidation &amp;&amp; le &gt; MAXIMUM_REFERENCE_COUNT) {</span>
<span class="line-modified">139             Object exArgs[] = { le, MAXIMUM_REFERENCE_COUNT };</span>
140 
141             throw new XMLSecurityException(&quot;signature.tooManyReferences&quot;, exArgs);
142         }
143 
144         // create List
145         this.references = new ArrayList&lt;&gt;(le);
146 
147         for (int i = 0; i &lt; le; i++) {
148             Element refElem = referencesEl[i];
149             Attr refAttr = refElem.getAttributeNodeNS(null, &quot;Id&quot;);
150             if (refAttr != null) {
151                 refElem.setIdAttributeNode(refAttr, true);
152             }
153             this.references.add(null);
154         }
155     }
156 
157     /**
158      * This {@code addDocument} method is used to add a new resource to the
159      * signed info. A {@link com.sun.org.apache.xml.internal.security.signature.Reference} is built
</pre>
<hr />
<pre>
300      * because of an uninitialized {@link XMLSignatureInput}
301      * @see com.sun.org.apache.xml.internal.security.signature.Reference#verify
302      * @see com.sun.org.apache.xml.internal.security.signature.SignedInfo#verify(boolean)
303      * @see com.sun.org.apache.xml.internal.security.signature.MissingResourceFailureException
304      * @throws XMLSecurityException
305      */
306     public boolean verifyReferences(boolean followManifests)
307         throws MissingResourceFailureException, XMLSecurityException {
308         if (referencesEl == null) {
309             this.referencesEl =
310                 XMLUtils.selectDsNodes(
311                     getFirstChild(), Constants._TAG_REFERENCE
312                 );
313         }
314         LOG.debug(&quot;verify {} References&quot;, referencesEl.length);
315         LOG.debug(&quot;I am {} requested to follow nested Manifests&quot;, (followManifests
316             ? &quot;&quot; : &quot;not&quot;));
317         if (referencesEl.length == 0) {
318             throw new XMLSecurityException(&quot;empty&quot;, new Object[]{&quot;References are empty&quot;});
319         }
<span class="line-modified">320         if (secureValidation &amp;&amp; referencesEl.length &gt; MAXIMUM_REFERENCE_COUNT) {</span>
<span class="line-modified">321             Object exArgs[] = { referencesEl.length, MAXIMUM_REFERENCE_COUNT };</span>
322 
323             throw new XMLSecurityException(&quot;signature.tooManyReferences&quot;, exArgs);
324         }
325 
<span class="line-modified">326         this.verificationResults = new boolean[referencesEl.length];</span>
327         boolean verify = true;
328         for (int i = 0; i &lt; this.referencesEl.length; i++) {
329             Reference currentRef =
330                 new Reference(referencesEl[i], this.baseURI, this, secureValidation);
331 
332             this.references.set(i, currentRef);
333 
334             // if only one item does not verify, the whole verification fails
335             try {
336                 boolean currentRefVerified = currentRef.verify();
337 
<span class="line-removed">338                 this.setVerificationResult(i, currentRefVerified);</span>
<span class="line-removed">339 </span>
340                 if (!currentRefVerified) {
341                     verify = false;
342                 }
343                 LOG.debug(&quot;The Reference has Type {}&quot;, currentRef.getType());
344 


345                 // was verification successful till now and do we want to verify the Manifest?
346                 if (verify &amp;&amp; followManifests &amp;&amp; currentRef.typeIsReferenceToManifest()) {
347                     LOG.debug(&quot;We have to follow a nested Manifest&quot;);
348 
349                     try {
350                         XMLSignatureInput signedManifestNodes =
351                             currentRef.dereferenceURIandPerformTransforms(null);
352                         Set&lt;Node&gt; nl = signedManifestNodes.getNodeSet();
353                         Manifest referencedManifest = null;
354                         Iterator&lt;Node&gt; nlIterator = nl.iterator();
355 
356                         while (nlIterator.hasNext()) {
357                             Node n = nlIterator.next();
358 
359                             if (n.getNodeType() == Node.ELEMENT_NODE
360                                 &amp;&amp; ((Element) n).getNamespaceURI().equals(Constants.SignatureSpecNS)
361                                 &amp;&amp; ((Element) n).getLocalName().equals(Constants._TAG_MANIFEST)
362                             ) {
363                                 try {
364                                     referencedManifest =
</pre>
<hr />
<pre>
376                         if (referencedManifest == null) {
377                             // The Reference stated that it points to a ds:Manifest
378                             // but we did not find a ds:Manifest in the signed area
379                             throw new MissingResourceFailureException(currentRef, &quot;empty&quot;,
380                                                                       new Object[]{&quot;No Manifest found&quot;});
381                         }
382 
383                         referencedManifest.perManifestResolvers = this.perManifestResolvers;
384                         referencedManifest.resolverProperties = this.resolverProperties;
385 
386                         boolean referencedManifestValid =
387                             referencedManifest.verifyReferences(followManifests);
388 
389                         if (!referencedManifestValid) {
390                             verify = false;
391 
392                             LOG.warn(&quot;The nested Manifest was invalid (bad)&quot;);
393                         } else {
394                             LOG.debug(&quot;The nested Manifest was valid (good)&quot;);
395                         }


396                     } catch (IOException ex) {
397                         throw new ReferenceNotInitializedException(ex);
398                     } catch (ParserConfigurationException ex) {
399                         throw new ReferenceNotInitializedException(ex);
400                     } catch (SAXException ex) {
401                         throw new ReferenceNotInitializedException(ex);
402                     }
403                 }


404             } catch (ReferenceNotInitializedException ex) {
405                 Object exArgs[] = { currentRef.getURI() };
406 
407                 throw new MissingResourceFailureException(
408                     ex, currentRef, &quot;signature.Verification.Reference.NoInput&quot;, exArgs
409                 );
410             }
411         }
412 
413         return verify;
414     }
415 
<span class="line-removed">416     /**</span>
<span class="line-removed">417      * Method setVerificationResult</span>
<span class="line-removed">418      *</span>
<span class="line-removed">419      * @param index</span>
<span class="line-removed">420      * @param verify</span>
<span class="line-removed">421      */</span>
<span class="line-removed">422     private void setVerificationResult(int index, boolean verify) {</span>
<span class="line-removed">423         if (this.verificationResults == null) {</span>
<span class="line-removed">424             this.verificationResults = new boolean[this.getLength()];</span>
<span class="line-removed">425         }</span>
<span class="line-removed">426 </span>
<span class="line-removed">427         this.verificationResults[index] = verify;</span>
<span class="line-removed">428     }</span>
<span class="line-removed">429 </span>
430     /**
431      * After verifying a {@link Manifest} or a {@link SignedInfo} using the
432      * {@link Manifest#verifyReferences()} or {@link SignedInfo#verify()} methods,
433      * the individual results can be retrieved with this method.
434      *
435      * @param index an index of into a {@link Manifest} or a {@link SignedInfo}
436      * @return the results of reference validation at the specified index
437      * @throws XMLSecurityException
438      */
439     public boolean getVerificationResult(int index) throws XMLSecurityException {
440         if (index &lt; 0 || index &gt; this.getLength() - 1) {
441             Object exArgs[] = { Integer.toString(index), Integer.toString(this.getLength()) };
442             Exception e =
443                 new IndexOutOfBoundsException(
444                     I18n.translate(&quot;signature.Verification.IndexOutOfBounds&quot;, exArgs)
445                 );
446 
447             throw new XMLSecurityException(e);
448         }
449 
450         if (this.verificationResults == null) {
451             try {
452                 this.verifyReferences();
453             } catch (Exception ex) {
454                 throw new XMLSecurityException(ex);
455             }
456         }
457 
<span class="line-modified">458         return this.verificationResults[index];</span>










459     }
460 
461     /**
462      * Adds Resource Resolver for retrieving resources at specified {@code URI} attribute
463      * in {@code reference} element
464      *
<span class="line-modified">465      * @param resolver {@link ResourceResolver} can provide the implemenatin subclass of</span>
466      * {@link ResourceResolverSpi} for retrieving resource.
467      */
468     public void addResourceResolver(ResourceResolver resolver) {
469         if (resolver == null) {
470             return;
471         }
472         if (perManifestResolvers == null) {
473             perManifestResolvers = new ArrayList&lt;&gt;();
474         }
475         this.perManifestResolvers.add(resolver);
476     }
477 
478     /**
479      * Adds Resource Resolver for retrieving resources at specified {@code URI} attribute
480      * in {@code reference} element
481      *
482      * @param resolverSpi the implementation subclass of {@link ResourceResolverSpi} for
483      * retrieving the resource.
484      */
485     public void addResourceResolver(ResourceResolverSpi resolverSpi) {
</pre>
</td>
<td>
<hr />
<pre>
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.signature;
 24 
 25 import java.io.IOException;
<span class="line-added"> 26 import java.security.AccessController;</span>
<span class="line-added"> 27 import java.security.PrivilegedAction;</span>
 28 import java.util.ArrayList;
<span class="line-added"> 29 import java.util.Collections;</span>
 30 import java.util.HashMap;
 31 import java.util.Iterator;
 32 import java.util.List;
 33 import java.util.Map;
 34 import java.util.Set;
 35 
 36 import javax.xml.parsers.ParserConfigurationException;
 37 
 38 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 39 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
 40 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 41 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
 42 import com.sun.org.apache.xml.internal.security.utils.Constants;
 43 import com.sun.org.apache.xml.internal.security.utils.I18n;
 44 import com.sun.org.apache.xml.internal.security.utils.SignatureElementProxy;
 45 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 46 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;
 47 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverSpi;
 48 import org.w3c.dom.Attr;
 49 import org.w3c.dom.DOMException;
 50 import org.w3c.dom.Document;
 51 import org.w3c.dom.Element;
 52 import org.w3c.dom.Node;
 53 import org.xml.sax.SAXException;
 54 
 55 /**
 56  * Handles {@code &amp;lt;ds:Manifest&amp;gt;} elements.
 57  * &lt;p&gt; This element holds the {@code Reference} elements&lt;/p&gt;
 58  */
 59 public class Manifest extends SignatureElementProxy {
 60 
 61     /**
<span class="line-modified"> 62      * The default maximum number of references per Manifest, if secure validation is enabled.</span>
 63      */
 64     public static final int MAXIMUM_REFERENCE_COUNT = 30;
 65 
 66     private static final com.sun.org.slf4j.internal.Logger LOG =
 67         com.sun.org.slf4j.internal.LoggerFactory.getLogger(Manifest.class);
 68 
<span class="line-added"> 69     private static Integer referenceCount =</span>
<span class="line-added"> 70         AccessController.doPrivileged(</span>
<span class="line-added"> 71             (PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.parseInt(System.getProperty(&quot;com.sun.org.apache.xml.internal.security.maxReferences&quot;,</span>
<span class="line-added"> 72                                                                 Integer.toString(MAXIMUM_REFERENCE_COUNT))));</span>
<span class="line-added"> 73 </span>
 74     /** Field references */
 75     private List&lt;Reference&gt; references;
 76     private Element[] referencesEl;
 77 
 78     /** Field verificationResults[] */
<span class="line-modified"> 79     private List&lt;VerifiedReference&gt; verificationResults;</span>
 80 
 81     /** Field resolverProperties */
 82     private Map&lt;String, String&gt; resolverProperties;
 83 
 84     /** Field perManifestResolvers */
 85     private List&lt;ResourceResolver&gt; perManifestResolvers;
 86 
 87     private boolean secureValidation;
 88 
 89     /**
 90      * Constructs {@link Manifest}
 91      *
 92      * @param doc the {@link Document} in which {@code XMLsignature} is placed
 93      */
 94     public Manifest(Document doc) {
 95         super(doc);
 96 
 97         addReturnToSelf();
 98 
 99         this.references = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
126         Attr attr = element.getAttributeNodeNS(null, &quot;Id&quot;);
127         if (attr != null) {
128             element.setIdAttributeNode(attr, true);
129         }
130         this.secureValidation = secureValidation;
131 
132         // check out Reference children
133         this.referencesEl =
134             XMLUtils.selectDsNodes(
135                 getFirstChild(), Constants._TAG_REFERENCE
136             );
137         int le = this.referencesEl.length;
138         if (le == 0) {
139             // At least one Reference must be present. Bad.
140             Object exArgs[] = { Constants._TAG_REFERENCE, Constants._TAG_MANIFEST };
141 
142             throw new DOMException(DOMException.WRONG_DOCUMENT_ERR,
143                                    I18n.translate(&quot;xml.WrongContent&quot;, exArgs));
144         }
145 
<span class="line-modified">146         if (secureValidation &amp;&amp; le &gt; referenceCount) {</span>
<span class="line-modified">147             Object exArgs[] = { le, referenceCount };</span>
148 
149             throw new XMLSecurityException(&quot;signature.tooManyReferences&quot;, exArgs);
150         }
151 
152         // create List
153         this.references = new ArrayList&lt;&gt;(le);
154 
155         for (int i = 0; i &lt; le; i++) {
156             Element refElem = referencesEl[i];
157             Attr refAttr = refElem.getAttributeNodeNS(null, &quot;Id&quot;);
158             if (refAttr != null) {
159                 refElem.setIdAttributeNode(refAttr, true);
160             }
161             this.references.add(null);
162         }
163     }
164 
165     /**
166      * This {@code addDocument} method is used to add a new resource to the
167      * signed info. A {@link com.sun.org.apache.xml.internal.security.signature.Reference} is built
</pre>
<hr />
<pre>
308      * because of an uninitialized {@link XMLSignatureInput}
309      * @see com.sun.org.apache.xml.internal.security.signature.Reference#verify
310      * @see com.sun.org.apache.xml.internal.security.signature.SignedInfo#verify(boolean)
311      * @see com.sun.org.apache.xml.internal.security.signature.MissingResourceFailureException
312      * @throws XMLSecurityException
313      */
314     public boolean verifyReferences(boolean followManifests)
315         throws MissingResourceFailureException, XMLSecurityException {
316         if (referencesEl == null) {
317             this.referencesEl =
318                 XMLUtils.selectDsNodes(
319                     getFirstChild(), Constants._TAG_REFERENCE
320                 );
321         }
322         LOG.debug(&quot;verify {} References&quot;, referencesEl.length);
323         LOG.debug(&quot;I am {} requested to follow nested Manifests&quot;, (followManifests
324             ? &quot;&quot; : &quot;not&quot;));
325         if (referencesEl.length == 0) {
326             throw new XMLSecurityException(&quot;empty&quot;, new Object[]{&quot;References are empty&quot;});
327         }
<span class="line-modified">328         if (secureValidation &amp;&amp; referencesEl.length &gt; referenceCount) {</span>
<span class="line-modified">329             Object exArgs[] = { referencesEl.length, referenceCount };</span>
330 
331             throw new XMLSecurityException(&quot;signature.tooManyReferences&quot;, exArgs);
332         }
333 
<span class="line-modified">334         this.verificationResults = new ArrayList&lt;&gt;(referencesEl.length);</span>
335         boolean verify = true;
336         for (int i = 0; i &lt; this.referencesEl.length; i++) {
337             Reference currentRef =
338                 new Reference(referencesEl[i], this.baseURI, this, secureValidation);
339 
340             this.references.set(i, currentRef);
341 
342             // if only one item does not verify, the whole verification fails
343             try {
344                 boolean currentRefVerified = currentRef.verify();
345 


346                 if (!currentRefVerified) {
347                     verify = false;
348                 }
349                 LOG.debug(&quot;The Reference has Type {}&quot;, currentRef.getType());
350 
<span class="line-added">351                 List&lt;VerifiedReference&gt; manifestReferences = Collections.emptyList();</span>
<span class="line-added">352 </span>
353                 // was verification successful till now and do we want to verify the Manifest?
354                 if (verify &amp;&amp; followManifests &amp;&amp; currentRef.typeIsReferenceToManifest()) {
355                     LOG.debug(&quot;We have to follow a nested Manifest&quot;);
356 
357                     try {
358                         XMLSignatureInput signedManifestNodes =
359                             currentRef.dereferenceURIandPerformTransforms(null);
360                         Set&lt;Node&gt; nl = signedManifestNodes.getNodeSet();
361                         Manifest referencedManifest = null;
362                         Iterator&lt;Node&gt; nlIterator = nl.iterator();
363 
364                         while (nlIterator.hasNext()) {
365                             Node n = nlIterator.next();
366 
367                             if (n.getNodeType() == Node.ELEMENT_NODE
368                                 &amp;&amp; ((Element) n).getNamespaceURI().equals(Constants.SignatureSpecNS)
369                                 &amp;&amp; ((Element) n).getLocalName().equals(Constants._TAG_MANIFEST)
370                             ) {
371                                 try {
372                                     referencedManifest =
</pre>
<hr />
<pre>
384                         if (referencedManifest == null) {
385                             // The Reference stated that it points to a ds:Manifest
386                             // but we did not find a ds:Manifest in the signed area
387                             throw new MissingResourceFailureException(currentRef, &quot;empty&quot;,
388                                                                       new Object[]{&quot;No Manifest found&quot;});
389                         }
390 
391                         referencedManifest.perManifestResolvers = this.perManifestResolvers;
392                         referencedManifest.resolverProperties = this.resolverProperties;
393 
394                         boolean referencedManifestValid =
395                             referencedManifest.verifyReferences(followManifests);
396 
397                         if (!referencedManifestValid) {
398                             verify = false;
399 
400                             LOG.warn(&quot;The nested Manifest was invalid (bad)&quot;);
401                         } else {
402                             LOG.debug(&quot;The nested Manifest was valid (good)&quot;);
403                         }
<span class="line-added">404 </span>
<span class="line-added">405                         manifestReferences = referencedManifest.getVerificationResults();</span>
406                     } catch (IOException ex) {
407                         throw new ReferenceNotInitializedException(ex);
408                     } catch (ParserConfigurationException ex) {
409                         throw new ReferenceNotInitializedException(ex);
410                     } catch (SAXException ex) {
411                         throw new ReferenceNotInitializedException(ex);
412                     }
413                 }
<span class="line-added">414 </span>
<span class="line-added">415                 verificationResults.add(new VerifiedReference(currentRefVerified, currentRef.getURI(), manifestReferences));</span>
416             } catch (ReferenceNotInitializedException ex) {
417                 Object exArgs[] = { currentRef.getURI() };
418 
419                 throw new MissingResourceFailureException(
420                     ex, currentRef, &quot;signature.Verification.Reference.NoInput&quot;, exArgs
421                 );
422             }
423         }
424 
425         return verify;
426     }
427 














428     /**
429      * After verifying a {@link Manifest} or a {@link SignedInfo} using the
430      * {@link Manifest#verifyReferences()} or {@link SignedInfo#verify()} methods,
431      * the individual results can be retrieved with this method.
432      *
433      * @param index an index of into a {@link Manifest} or a {@link SignedInfo}
434      * @return the results of reference validation at the specified index
435      * @throws XMLSecurityException
436      */
437     public boolean getVerificationResult(int index) throws XMLSecurityException {
438         if (index &lt; 0 || index &gt; this.getLength() - 1) {
439             Object exArgs[] = { Integer.toString(index), Integer.toString(this.getLength()) };
440             Exception e =
441                 new IndexOutOfBoundsException(
442                     I18n.translate(&quot;signature.Verification.IndexOutOfBounds&quot;, exArgs)
443                 );
444 
445             throw new XMLSecurityException(e);
446         }
447 
448         if (this.verificationResults == null) {
449             try {
450                 this.verifyReferences();
451             } catch (Exception ex) {
452                 throw new XMLSecurityException(ex);
453             }
454         }
455 
<span class="line-modified">456         return ((ArrayList&lt;VerifiedReference&gt;)verificationResults).get(index).isValid();</span>
<span class="line-added">457     }</span>
<span class="line-added">458 </span>
<span class="line-added">459     /**</span>
<span class="line-added">460      * Get the list of verification result objects</span>
<span class="line-added">461      */</span>
<span class="line-added">462     public List&lt;VerifiedReference&gt; getVerificationResults() {</span>
<span class="line-added">463         if (verificationResults == null) {</span>
<span class="line-added">464             return Collections.emptyList();</span>
<span class="line-added">465         }</span>
<span class="line-added">466         return Collections.unmodifiableList(verificationResults);</span>
467     }
468 
469     /**
470      * Adds Resource Resolver for retrieving resources at specified {@code URI} attribute
471      * in {@code reference} element
472      *
<span class="line-modified">473      * @param resolver {@link ResourceResolver} can provide the implementation subclass of</span>
474      * {@link ResourceResolverSpi} for retrieving resource.
475      */
476     public void addResourceResolver(ResourceResolver resolver) {
477         if (resolver == null) {
478             return;
479         }
480         if (perManifestResolvers == null) {
481             perManifestResolvers = new ArrayList&lt;&gt;();
482         }
483         this.perManifestResolvers.add(resolver);
484     }
485 
486     /**
487      * Adds Resource Resolver for retrieving resources at specified {@code URI} attribute
488      * in {@code reference} element
489      *
490      * @param resolverSpi the implementation subclass of {@link ResourceResolverSpi} for
491      * retrieving the resource.
492      */
493     public void addResourceResolver(ResourceResolverSpi resolverSpi) {
</pre>
</td>
</tr>
</table>
<center><a href="../resource/config.xml.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="Reference.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
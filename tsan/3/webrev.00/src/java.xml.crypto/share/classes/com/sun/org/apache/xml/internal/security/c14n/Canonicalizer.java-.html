<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/c14n/Canonicalizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.c14n;
 24 
 25 import java.io.ByteArrayInputStream;
 26 import java.io.InputStream;
 27 import java.io.OutputStream;
 28 import java.nio.charset.StandardCharsets;
 29 import java.util.Map;
 30 import java.util.Set;
 31 import java.util.concurrent.ConcurrentHashMap;
 32 
 33 import javax.xml.parsers.DocumentBuilder;
 34 
 35 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer11_OmitComments;
 36 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer11_WithComments;
 37 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315ExclOmitComments;
 38 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315ExclWithComments;
 39 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315OmitComments;
 40 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315WithComments;
 41 import com.sun.org.apache.xml.internal.security.c14n.implementations.CanonicalizerPhysical;
 42 import com.sun.org.apache.xml.internal.security.exceptions.AlgorithmAlreadyRegisteredException;
 43 import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 44 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 45 import org.w3c.dom.Document;
 46 import org.w3c.dom.Node;
 47 import org.w3c.dom.NodeList;
 48 import org.xml.sax.InputSource;
 49 
 50 /**
 51  *
 52  */
 53 public class Canonicalizer {
 54 
 55     /** The output encoding of canonicalized data */
 56     public static final String ENCODING = StandardCharsets.UTF_8.name();
 57 
 58     /**
 59      * XPath Expression for selecting every node and continuous comments joined
 60      * in only one node
 61      */
 62     public static final String XPATH_C14N_WITH_COMMENTS_SINGLE_NODE =
 63         &quot;(.//. | .//@* | .//namespace::*)&quot;;
 64 
 65     /**
 66      * The URL defined in XML-SEC Rec for inclusive c14n &lt;b&gt;without&lt;/b&gt; comments.
 67      */
 68     public static final String ALGO_ID_C14N_OMIT_COMMENTS =
 69         &quot;http://www.w3.org/TR/2001/REC-xml-c14n-20010315&quot;;
 70     /**
 71      * The URL defined in XML-SEC Rec for inclusive c14n &lt;b&gt;with&lt;/b&gt; comments.
 72      */
 73     public static final String ALGO_ID_C14N_WITH_COMMENTS =
 74         ALGO_ID_C14N_OMIT_COMMENTS + &quot;#WithComments&quot;;
 75     /**
 76      * The URL defined in XML-SEC Rec for exclusive c14n &lt;b&gt;without&lt;/b&gt; comments.
 77      */
 78     public static final String ALGO_ID_C14N_EXCL_OMIT_COMMENTS =
 79         &quot;http://www.w3.org/2001/10/xml-exc-c14n#&quot;;
 80     /**
 81      * The URL defined in XML-SEC Rec for exclusive c14n &lt;b&gt;with&lt;/b&gt; comments.
 82      */
 83     public static final String ALGO_ID_C14N_EXCL_WITH_COMMENTS =
 84         ALGO_ID_C14N_EXCL_OMIT_COMMENTS + &quot;WithComments&quot;;
 85     /**
 86      * The URI for inclusive c14n 1.1 &lt;b&gt;without&lt;/b&gt; comments.
 87      */
 88     public static final String ALGO_ID_C14N11_OMIT_COMMENTS =
 89         &quot;http://www.w3.org/2006/12/xml-c14n11&quot;;
 90     /**
 91      * The URI for inclusive c14n 1.1 &lt;b&gt;with&lt;/b&gt; comments.
 92      */
 93     public static final String ALGO_ID_C14N11_WITH_COMMENTS =
 94         ALGO_ID_C14N11_OMIT_COMMENTS + &quot;#WithComments&quot;;
 95     /**
 96      * Non-standard algorithm to serialize the physical representation for XML Encryption
 97      */
 98     public static final String ALGO_ID_C14N_PHYSICAL =
 99         &quot;http://santuario.apache.org/c14n/physical&quot;;
100 
101     private static Map&lt;String, Class&lt;? extends CanonicalizerSpi&gt;&gt; canonicalizerHash =
102         new ConcurrentHashMap&lt;String, Class&lt;? extends CanonicalizerSpi&gt;&gt;();
103 
104     private final CanonicalizerSpi canonicalizerSpi;
105     private boolean secureValidation;
106 
107     /**
108      * Constructor Canonicalizer
109      *
110      * @param algorithmURI
111      * @throws InvalidCanonicalizerException
112      */
113     private Canonicalizer(String algorithmURI) throws InvalidCanonicalizerException {
114         try {
115             Class&lt;? extends CanonicalizerSpi&gt; implementingClass =
116                 canonicalizerHash.get(algorithmURI);
117 
118             @SuppressWarnings(&quot;deprecation&quot;)
119             CanonicalizerSpi tmp = implementingClass.newInstance();
120             canonicalizerSpi = tmp;
121             canonicalizerSpi.reset = true;
122         } catch (Exception e) {
123             Object exArgs[] = { algorithmURI };
124             throw new InvalidCanonicalizerException(
125                 e, &quot;signature.Canonicalizer.UnknownCanonicalizer&quot;, exArgs
126             );
127         }
128     }
129 
130     /**
131      * Method getInstance
132      *
133      * @param algorithmURI
134      * @return a Canonicalizer instance ready for the job
135      * @throws InvalidCanonicalizerException
136      */
137     public static final Canonicalizer getInstance(String algorithmURI)
138         throws InvalidCanonicalizerException {
139         return new Canonicalizer(algorithmURI);
140     }
141 
142     /**
143      * Method register
144      *
145      * @param algorithmURI
146      * @param implementingClass
147      * @throws AlgorithmAlreadyRegisteredException
148      * @throws SecurityException if a security manager is installed and the
149      *    caller does not have permission to register the canonicalizer
150      */
151     @SuppressWarnings(&quot;unchecked&quot;)
152     public static void register(String algorithmURI, String implementingClass)
153         throws AlgorithmAlreadyRegisteredException, ClassNotFoundException {
154         JavaUtils.checkRegisterPermission();
155         // check whether URI is already registered
156         Class&lt;? extends CanonicalizerSpi&gt; registeredClass =
157             canonicalizerHash.get(algorithmURI);
158 
159         if (registeredClass != null)  {
160             Object exArgs[] = { algorithmURI, registeredClass };
161             throw new AlgorithmAlreadyRegisteredException(&quot;algorithm.alreadyRegistered&quot;, exArgs);
162         }
163 
164         canonicalizerHash.put(
165             algorithmURI, (Class&lt;? extends CanonicalizerSpi&gt;)
166             ClassLoaderUtils.loadClass(implementingClass, Canonicalizer.class)
167         );
168     }
169 
170     /**
171      * Method register
172      *
173      * @param algorithmURI
174      * @param implementingClass
175      * @throws AlgorithmAlreadyRegisteredException
176      * @throws SecurityException if a security manager is installed and the
177      *    caller does not have permission to register the canonicalizer
178      */
179     public static void register(String algorithmURI, Class&lt;? extends CanonicalizerSpi&gt; implementingClass)
180         throws AlgorithmAlreadyRegisteredException, ClassNotFoundException {
181         JavaUtils.checkRegisterPermission();
182         // check whether URI is already registered
183         Class&lt;? extends CanonicalizerSpi&gt; registeredClass = canonicalizerHash.get(algorithmURI);
184 
185         if (registeredClass != null)  {
186             Object exArgs[] = { algorithmURI, registeredClass };
187             throw new AlgorithmAlreadyRegisteredException(&quot;algorithm.alreadyRegistered&quot;, exArgs);
188         }
189 
190         canonicalizerHash.put(algorithmURI, implementingClass);
191     }
192 
193     /**
194      * This method registers the default algorithms.
195      */
196     public static void registerDefaultAlgorithms() {
197         canonicalizerHash.put(
198             Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS,
199             Canonicalizer20010315OmitComments.class
200         );
201         canonicalizerHash.put(
202             Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS,
203             Canonicalizer20010315WithComments.class
204         );
205         canonicalizerHash.put(
206             Canonicalizer.ALGO_ID_C14N_EXCL_OMIT_COMMENTS,
207             Canonicalizer20010315ExclOmitComments.class
208         );
209         canonicalizerHash.put(
210             Canonicalizer.ALGO_ID_C14N_EXCL_WITH_COMMENTS,
211             Canonicalizer20010315ExclWithComments.class
212         );
213         canonicalizerHash.put(
214             Canonicalizer.ALGO_ID_C14N11_OMIT_COMMENTS,
215             Canonicalizer11_OmitComments.class
216         );
217         canonicalizerHash.put(
218             Canonicalizer.ALGO_ID_C14N11_WITH_COMMENTS,
219             Canonicalizer11_WithComments.class
220         );
221         canonicalizerHash.put(
222             Canonicalizer.ALGO_ID_C14N_PHYSICAL,
223             CanonicalizerPhysical.class
224         );
225     }
226 
227     /**
228      * Method getURI
229      *
230      * @return the URI defined for this c14n instance.
231      */
232     public final String getURI() {
233         return canonicalizerSpi.engineGetURI();
234     }
235 
236     /**
237      * Method getIncludeComments
238      *
239      * @return true if the c14n respect the comments.
240      */
241     public boolean getIncludeComments() {
242         return canonicalizerSpi.engineGetIncludeComments();
243     }
244 
245     /**
246      * This method tries to canonicalize the given bytes. It&#39;s possible to even
247      * canonicalize non-wellformed sequences if they are well-formed after being
248      * wrapped with a {@code &amp;gt;a&amp;lt;...&amp;gt;/a&amp;lt;}.
249      *
250      * @param inputBytes
251      * @return the result of the canonicalization.
252      * @throws CanonicalizationException
253      * @throws java.io.IOException
254      * @throws javax.xml.parsers.ParserConfigurationException
255      * @throws org.xml.sax.SAXException
256      */
257     public byte[] canonicalize(byte[] inputBytes)
258         throws javax.xml.parsers.ParserConfigurationException,
259         java.io.IOException, org.xml.sax.SAXException, CanonicalizationException {
260         Document document = null;
261         try (InputStream bais = new ByteArrayInputStream(inputBytes)) {
262             InputSource in = new InputSource(bais);
263 
264             // needs to validate for ID attribute normalization
265             DocumentBuilder db = XMLUtils.createDocumentBuilder(true, secureValidation);
266 
267             /*
268              * for some of the test vectors from the specification,
269              * there has to be a validating parser for ID attributes, default
270              * attribute values, NMTOKENS, etc.
271              * Unfortunately, the test vectors do use different DTDs or
272              * even no DTD. So Xerces 1.3.1 fires many warnings about using
273              * ErrorHandlers.
274              *
275              * Text from the spec:
276              *
277              * The input octet stream MUST contain a well-formed XML document,
278              * but the input need not be validated. However, the attribute
279              * value normalization and entity reference resolution MUST be
280              * performed in accordance with the behaviors of a validating
281              * XML processor. As well, nodes for default attributes (declared
282              * in the ATTLIST with an AttValue but not specified) are created
283              * in each element. Thus, the declarations in the document type
284              * declaration are used to help create the canonical form, even
285              * though the document type declaration is not retained in the
286              * canonical form.
287              */
288             db.setErrorHandler(new com.sun.org.apache.xml.internal.security.utils.IgnoreAllErrorHandler());
289 
290             document = db.parse(in);
291         }
292         return this.canonicalizeSubtree(document);
293     }
294 
295     /**
296      * Canonicalizes the subtree rooted by {@code node}.
297      *
298      * @param node The node to canonicalize
299      * @return the result of the c14n.
300      *
301      * @throws CanonicalizationException
302      */
303     public byte[] canonicalizeSubtree(Node node) throws CanonicalizationException {
304         canonicalizerSpi.secureValidation = secureValidation;
305         return canonicalizerSpi.engineCanonicalizeSubTree(node);
306     }
307 
308     /**
309      * Canonicalizes the subtree rooted by {@code node}.
310      *
311      * @param node
312      * @param inclusiveNamespaces
313      * @return the result of the c14n.
314      * @throws CanonicalizationException
315      */
316     public byte[] canonicalizeSubtree(Node node, String inclusiveNamespaces)
317         throws CanonicalizationException {
318         canonicalizerSpi.secureValidation = secureValidation;
319         return canonicalizerSpi.engineCanonicalizeSubTree(node, inclusiveNamespaces);
320     }
321 
322     /**
323      * Canonicalizes the subtree rooted by {@code node}.
324      *
325      * @param node
326      * @param inclusiveNamespaces
327      * @return the result of the c14n.
328      * @throws CanonicalizationException
329      */
330     public byte[] canonicalizeSubtree(Node node, String inclusiveNamespaces, boolean propagateDefaultNamespace)
331             throws CanonicalizationException {
332         canonicalizerSpi.secureValidation = secureValidation;
333         return canonicalizerSpi.engineCanonicalizeSubTree(node, inclusiveNamespaces, propagateDefaultNamespace);
334     }
335 
336     /**
337      * Canonicalizes an XPath node set. The {@code xpathNodeSet} is treated
338      * as a list of XPath nodes, not as a list of subtrees.
339      *
340      * @param xpathNodeSet
341      * @return the result of the c14n.
342      * @throws CanonicalizationException
343      */
344     public byte[] canonicalizeXPathNodeSet(NodeList xpathNodeSet)
345         throws CanonicalizationException {
346         canonicalizerSpi.secureValidation = secureValidation;
347         return canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet);
348     }
349 
350     /**
351      * Canonicalizes an XPath node set. The {@code xpathNodeSet} is treated
352      * as a list of XPath nodes, not as a list of subtrees.
353      *
354      * @param xpathNodeSet
355      * @param inclusiveNamespaces
356      * @return the result of the c14n.
357      * @throws CanonicalizationException
358      */
359     public byte[] canonicalizeXPathNodeSet(
360         NodeList xpathNodeSet, String inclusiveNamespaces
361     ) throws CanonicalizationException {
362         canonicalizerSpi.secureValidation = secureValidation;
363         return
364             canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet, inclusiveNamespaces);
365     }
366 
367     /**
368      * Canonicalizes an XPath node set.
369      *
370      * @param xpathNodeSet
371      * @return the result of the c14n.
372      * @throws CanonicalizationException
373      */
374     public byte[] canonicalizeXPathNodeSet(Set&lt;Node&gt; xpathNodeSet)
375         throws CanonicalizationException {
376         canonicalizerSpi.secureValidation = secureValidation;
377         return canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet);
378     }
379 
380     /**
381      * Canonicalizes an XPath node set.
382      *
383      * @param xpathNodeSet
384      * @param inclusiveNamespaces
385      * @return the result of the c14n.
386      * @throws CanonicalizationException
387      */
388     public byte[] canonicalizeXPathNodeSet(
389         Set&lt;Node&gt; xpathNodeSet, String inclusiveNamespaces
390     ) throws CanonicalizationException {
391         canonicalizerSpi.secureValidation = secureValidation;
392         return
393             canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet, inclusiveNamespaces);
394     }
395 
396     /**
397      * Sets the writer where the canonicalization ends.  ByteArrayOutputStream
398      * if none is set.
399      * @param os
400      */
401     public void setWriter(OutputStream os) {
402         canonicalizerSpi.setWriter(os);
403     }
404 
405     /**
406      * Returns the name of the implementing {@link CanonicalizerSpi} class
407      *
408      * @return the name of the implementing {@link CanonicalizerSpi} class
409      */
410     public String getImplementingCanonicalizerClass() {
411         return canonicalizerSpi.getClass().getName();
412     }
413 
414     /**
415      * Set the canonicalizer behaviour to not reset.
416      */
417     public void notReset() {
418         canonicalizerSpi.reset = false;
419     }
420 
421     public boolean isSecureValidation() {
422         return secureValidation;
423     }
424 
425     public void setSecureValidation(boolean secureValidation) {
426         this.secureValidation = secureValidation;
427     }
428 
429 }
    </pre>
  </body>
</html>
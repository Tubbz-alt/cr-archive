<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/utils/XMLUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WeakObjectPool.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="resolver/ResourceResolver.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/utils/XMLUtils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   6  * Licensed to the Apache Software Foundation (ASF) under one
   7  * or more contributor license agreements. See the NOTICE file
   8  * distributed with this work for additional information
   9  * regarding copyright ownership. The ASF licenses this file
  10  * to you under the Apache License, Version 2.0 (the
  11  * &quot;License&quot;); you may not use this file except in compliance
  12  * with the License. You may obtain a copy of the License at
  13  *
  14  * http://www.apache.org/licenses/LICENSE-2.0
  15  *
  16  * Unless required by applicable law or agreed to in writing,
  17  * software distributed under the License is distributed on an
  18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  19  * KIND, either express or implied. See the License for the
  20  * specific language governing permissions and limitations
  21  * under the License.
  22  */
  23 package com.sun.org.apache.xml.internal.security.utils;
  24 
  25 import java.io.IOException;

  26 import java.io.OutputStream;
  27 import java.math.BigInteger;
  28 import java.security.AccessController;
  29 import java.security.PrivilegedAction;
  30 import java.util.ArrayList;
  31 import java.util.Base64;

  32 import java.util.HashSet;
  33 import java.util.Iterator;
  34 import java.util.List;


  35 import java.util.Set;


  36 
  37 import javax.xml.parsers.DocumentBuilder;
  38 import javax.xml.parsers.DocumentBuilderFactory;
  39 import javax.xml.parsers.ParserConfigurationException;
  40 
  41 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
  42 import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
  43 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
  44 import org.w3c.dom.Attr;
  45 import org.w3c.dom.Document;
  46 import org.w3c.dom.Element;
  47 import org.w3c.dom.NamedNodeMap;
  48 import org.w3c.dom.Node;
  49 import org.w3c.dom.NodeList;
  50 import org.w3c.dom.Text;


  51 
  52 /**
  53  * DOM and XML accessibility and comfort functions.
  54  *
  55  */
  56 public final class XMLUtils {
  57 
  58     private static boolean ignoreLineBreaks =
  59         AccessController.doPrivileged(
  60             (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;com.sun.org.apache.xml.internal.security.ignoreLineBreaks&quot;));



  61 
  62     private static volatile String dsPrefix = &quot;ds&quot;;
  63     private static volatile String ds11Prefix = &quot;dsig11&quot;;
  64     private static volatile String xencPrefix = &quot;xenc&quot;;
  65     private static volatile String xenc11Prefix = &quot;xenc11&quot;;
  66 
  67     private static final com.sun.org.slf4j.internal.Logger LOG =
  68         com.sun.org.slf4j.internal.LoggerFactory.getLogger(XMLUtils.class);
  69 





  70 
  71     /**
  72      * Constructor XMLUtils
  73      *
  74      */
  75     private XMLUtils() {
  76         // we don&#39;t allow instantiation
  77     }
  78 
  79     /**
  80      * Set the prefix for the digital signature namespace
  81      * @param prefix the new prefix for the digital signature namespace
  82      * @throws SecurityException if a security manager is installed and the
  83      *    caller does not have permission to set the prefix
  84      */
  85     public static void setDsPrefix(String prefix) {
  86         JavaUtils.checkRegisterPermission();
  87         dsPrefix = prefix;
  88     }
  89 
</pre>
<hr />
<pre>
 130 
 131     /**
 132      * @param rootNode
 133      * @param result
 134      * @param exclude
 135      * @param com whether comments or not
 136      */
 137     public static void getSet(Node rootNode, Set&lt;Node&gt; result, Node exclude, boolean com) {
 138         if (exclude != null &amp;&amp; isDescendantOrSelf(exclude, rootNode)) {
 139             return;
 140         }
 141         getSetRec(rootNode, result, exclude, com);
 142     }
 143 
 144     @SuppressWarnings(&quot;fallthrough&quot;)
 145     private static void getSetRec(final Node rootNode, final Set&lt;Node&gt; result,
 146                                 final Node exclude, final boolean com) {
 147         if (rootNode == exclude) {
 148             return;
 149         }
<span class="line-modified"> 150         switch (rootNode.getNodeType()) {</span>
 151         case Node.ELEMENT_NODE:
 152             result.add(rootNode);
 153             Element el = (Element)rootNode;
 154             if (el.hasAttributes()) {
 155                 NamedNodeMap nl = el.getAttributes();
 156                 int length = nl.getLength();
 157                 for (int i = 0; i &lt; length; i++) {
 158                     result.add(nl.item(i));
 159                 }
 160             }
 161             //no return keep working
 162         case Node.DOCUMENT_NODE:
 163             for (Node r = rootNode.getFirstChild(); r != null; r = r.getNextSibling()) {
 164                 if (r.getNodeType() == Node.TEXT_NODE) {
 165                     result.add(r);
 166                     while (r != null &amp;&amp; r.getNodeType() == Node.TEXT_NODE) {
 167                         r = r.getNextSibling();
 168                     }
 169                     if (r == null) {
 170                         return;
 171                     }
 172                 }
 173                 getSetRec(r, result, exclude, com);
 174             }
<span class="line-modified"> 175             return;</span>
 176         case Node.COMMENT_NODE:
 177             if (com) {
 178                 result.add(rootNode);
 179             }
<span class="line-modified"> 180             return;</span>
 181         case Node.DOCUMENT_TYPE_NODE:
<span class="line-modified"> 182             return;</span>
 183         default:
 184             result.add(rootNode);
 185         }
 186     }
 187 
<span class="line-removed"> 188 </span>
 189     /**
 190      * Outputs a DOM tree to an {@link OutputStream}.
 191      *
 192      * @param contextNode root node of the DOM tree
 193      * @param os the {@link OutputStream}
 194      */
 195     public static void outputDOM(Node contextNode, OutputStream os) {
 196         XMLUtils.outputDOM(contextNode, os, false);
 197     }
 198 
 199     /**
 200      * Outputs a DOM tree to an {@link OutputStream}. &lt;I&gt;If an Exception is
 201      * thrown during execution, it&#39;s StackTrace is output to System.out, but the
 202      * Exception is not re-thrown.&lt;/I&gt;
 203      *
 204      * @param contextNode root node of the DOM tree
 205      * @param os the {@link OutputStream}
 206      * @param addPreamble
 207      */
 208     public static void outputDOM(Node contextNode, OutputStream os, boolean addPreamble) {
</pre>
<hr />
<pre>
 237      * @param contextNode
 238      * @param os
 239      */
 240     public static void outputDOMc14nWithComments(Node contextNode, OutputStream os) {
 241         try {
 242             os.write(Canonicalizer.getInstance(
 243                 Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS).canonicalizeSubtree(contextNode)
 244             );
 245         } catch (IOException ex) {
 246             LOG.debug(ex.getMessage(), ex);
 247             // throw new RuntimeException(ex.getMessage());
 248         } catch (InvalidCanonicalizerException ex) {
 249             LOG.debug(ex.getMessage(), ex);
 250             // throw new RuntimeException(ex.getMessage());
 251         } catch (CanonicalizationException ex) {
 252             LOG.debug(ex.getMessage(), ex);
 253             // throw new RuntimeException(ex.getMessage());
 254         }
 255     }
 256 





 257     /**
<span class="line-modified"> 258      * Method getFullTextChildrenFromElement</span>
 259      *
<span class="line-modified"> 260      * @param element</span>
 261      * @return the string of children
 262      */
<span class="line-modified"> 263     public static String getFullTextChildrenFromElement(Element element) {</span>
 264         StringBuilder sb = new StringBuilder();
 265 
<span class="line-modified"> 266         Node child = element.getFirstChild();</span>
 267         while (child != null) {
 268             if (child.getNodeType() == Node.TEXT_NODE) {
 269                 sb.append(((Text)child).getData());
 270             }
 271             child = child.getNextSibling();
 272         }
 273 
 274         return sb.toString();
 275     }
 276 
 277     /**
 278      * Creates an Element in the XML Signature specification namespace.
 279      *
 280      * @param doc the factory Document
 281      * @param elementName the local name of the Element
 282      * @return the Element
 283      */
 284     public static Element createElementInSignatureSpace(Document doc, String elementName) {
 285         if (doc == null) {
 286             throw new RuntimeException(&quot;Document is null&quot;);
</pre>
<hr />
<pre>
 665             return null;
 666         }
 667         n = n.getFirstChild();
 668         while (n != null &amp;&amp; n.getNodeType() != Node.TEXT_NODE) {
 669             n = n.getNextSibling();
 670         }
 671         return (Text)n;
 672     }
 673 
 674     /**
 675      * @param sibling
 676      * @param uri
 677      * @param nodeName
 678      * @param number
 679      * @return nodes with the constrain
 680      */
 681     public static Element selectNode(Node sibling, String uri, String nodeName, int number) {
 682         while (sibling != null) {
 683             if (sibling.getNamespaceURI() != null &amp;&amp; sibling.getNamespaceURI().equals(uri)
 684                 &amp;&amp; sibling.getLocalName().equals(nodeName)) {
<span class="line-modified"> 685                 if (number == 0){</span>
 686                     return (Element)sibling;
 687                 }
 688                 number--;
 689             }
 690             sibling = sibling.getNextSibling();
 691         }
 692         return null;
 693     }
 694 
 695     /**
 696      * @param sibling
 697      * @param nodeName
 698      * @return nodes with the constrain
 699      */
 700     public static Element[] selectDsNodes(Node sibling, String nodeName) {
 701         return selectNodes(sibling, Constants.SignatureSpecNS, nodeName);
 702     }
 703 
 704     /**
 705      * @param sibling
</pre>
<hr />
<pre>
 938             // no child, this node is done.
 939             if (startNode == null) {
 940                 // close node processing, get sibling
 941                 startNode = processedNode.getNextSibling();
 942             }
 943 
 944             // no more siblings, get parent, all children
 945             // of parent are processed.
 946             while (startNode == null) {
 947                 processedNode = processedNode.getParentNode();
 948                 if (processedNode == startParent) {
 949                     return true;
 950                 }
 951                 // close parent node processing (processed node now)
 952                 startNode = processedNode.getNextSibling();
 953             }
 954         }
 955         return true;
 956     }
 957 
<span class="line-modified"> 958     public static DocumentBuilder createDocumentBuilder(boolean validating)</span>
<span class="line-modified"> 959             throws ParserConfigurationException {</span>





















































































 960         return createDocumentBuilder(validating, true);
 961     }
 962 
<span class="line-modified"> 963     // The current implementation does not throw a ParserConfigurationException.</span>
<span class="line-modified"> 964     // Kept here in case we create the DocumentBuilder inline again.</span>


 965     public static DocumentBuilder createDocumentBuilder(
 966         boolean validating, boolean disAllowDocTypeDeclarations
 967     ) throws ParserConfigurationException {
 968         DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();
<span class="line-modified"> 969         dfactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);</span>
 970         if (disAllowDocTypeDeclarations) {
 971             dfactory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
 972         }
 973         dfactory.setValidating(validating);
 974         dfactory.setNamespaceAware(true);
 975         return dfactory.newDocumentBuilder();
 976     }
 977 








 978     /**
 979      * Returns a byte-array representation of a {@code {@link BigInteger}}.
 980      * No sign-bit is output.
 981      *
 982      * &lt;b&gt;N.B.:&lt;/B&gt; {@code {@link BigInteger}}&#39;s toByteArray
 983      * returns eventually longer arrays because of the leading sign-bit.
 984      *
 985      * @param big {@code BigInteger} to be converted
 986      * @param bitlen {@code int} the desired length in bits of the representation
 987      * @return a byte array with {@code bitlen} bits of {@code big}
 988      */
 989     public static byte[] getBytes(BigInteger big, int bitlen) {
 990 
 991         //round bitlen
 992         bitlen = ((bitlen + 7) &gt;&gt; 3) &lt;&lt; 3;
 993 
 994         if (bitlen &lt; big.bitLength()) {
 995             throw new IllegalArgumentException(I18n.translate(&quot;utils.Base64.IllegalBitlength&quot;));
 996         }
 997 
</pre>
<hr />
<pre>
1002             return bigBytes;
1003         }
1004 
1005         // some copying needed
1006         int startSrc = 0;    // no need to skip anything
1007         int bigLen = bigBytes.length;    //valid length of the string
1008 
1009         if (big.bitLength() % 8 == 0) {    // correct values
1010             startSrc = 1;    // skip sign bit
1011 
1012             bigLen--;    // valid length of the string
1013         }
1014 
1015         int startDst = bitlen / 8 - bigLen;    //pad with leading nulls
1016         byte[] resizedBytes = new byte[bitlen / 8];
1017 
1018         System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, bigLen);
1019 
1020         return resizedBytes;
1021     }




























































1022 }
</pre>
</td>
<td>
<hr />
<pre>
   6  * Licensed to the Apache Software Foundation (ASF) under one
   7  * or more contributor license agreements. See the NOTICE file
   8  * distributed with this work for additional information
   9  * regarding copyright ownership. The ASF licenses this file
  10  * to you under the Apache License, Version 2.0 (the
  11  * &quot;License&quot;); you may not use this file except in compliance
  12  * with the License. You may obtain a copy of the License at
  13  *
  14  * http://www.apache.org/licenses/LICENSE-2.0
  15  *
  16  * Unless required by applicable law or agreed to in writing,
  17  * software distributed under the License is distributed on an
  18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  19  * KIND, either express or implied. See the License for the
  20  * specific language governing permissions and limitations
  21  * under the License.
  22  */
  23 package com.sun.org.apache.xml.internal.security.utils;
  24 
  25 import java.io.IOException;
<span class="line-added">  26 import java.io.InputStream;</span>
  27 import java.io.OutputStream;
  28 import java.math.BigInteger;
  29 import java.security.AccessController;
  30 import java.security.PrivilegedAction;
  31 import java.util.ArrayList;
  32 import java.util.Base64;
<span class="line-added">  33 import java.util.Collections;</span>
  34 import java.util.HashSet;
  35 import java.util.Iterator;
  36 import java.util.List;
<span class="line-added">  37 import java.util.Map;</span>
<span class="line-added">  38 import java.util.Queue;</span>
  39 import java.util.Set;
<span class="line-added">  40 import java.util.WeakHashMap;</span>
<span class="line-added">  41 import java.util.concurrent.ArrayBlockingQueue;</span>
  42 
  43 import javax.xml.parsers.DocumentBuilder;
  44 import javax.xml.parsers.DocumentBuilderFactory;
  45 import javax.xml.parsers.ParserConfigurationException;
  46 
  47 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
  48 import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
  49 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
  50 import org.w3c.dom.Attr;
  51 import org.w3c.dom.Document;
  52 import org.w3c.dom.Element;
  53 import org.w3c.dom.NamedNodeMap;
  54 import org.w3c.dom.Node;
  55 import org.w3c.dom.NodeList;
  56 import org.w3c.dom.Text;
<span class="line-added">  57 import org.xml.sax.InputSource;</span>
<span class="line-added">  58 import org.xml.sax.SAXException;</span>
  59 
  60 /**
  61  * DOM and XML accessibility and comfort functions.
  62  *
  63  */
  64 public final class XMLUtils {
  65 
  66     private static boolean ignoreLineBreaks =
  67         AccessController.doPrivileged(
  68             (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;com.sun.org.apache.xml.internal.security.ignoreLineBreaks&quot;));
<span class="line-added">  69     private static int parserPoolSize =</span>
<span class="line-added">  70         AccessController.doPrivileged(</span>
<span class="line-added">  71             (PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.getInteger(&quot;com.sun.org.apache.xml.internal.security.parser.pool-size&quot;, 20));</span>
  72 
  73     private static volatile String dsPrefix = &quot;ds&quot;;
  74     private static volatile String ds11Prefix = &quot;dsig11&quot;;
  75     private static volatile String xencPrefix = &quot;xenc&quot;;
  76     private static volatile String xenc11Prefix = &quot;xenc11&quot;;
  77 
  78     private static final com.sun.org.slf4j.internal.Logger LOG =
  79         com.sun.org.slf4j.internal.LoggerFactory.getLogger(XMLUtils.class);
  80 
<span class="line-added">  81     private static final Map&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt; DOCUMENT_BUILDERS =</span>
<span class="line-added">  82         Collections.synchronizedMap(new WeakHashMap&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt;());</span>
<span class="line-added">  83 </span>
<span class="line-added">  84     private static final Map&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt; DOCUMENT_BUILDERS_DISALLOW_DOCTYPE =</span>
<span class="line-added">  85         Collections.synchronizedMap(new WeakHashMap&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt;());</span>
  86 
  87     /**
  88      * Constructor XMLUtils
  89      *
  90      */
  91     private XMLUtils() {
  92         // we don&#39;t allow instantiation
  93     }
  94 
  95     /**
  96      * Set the prefix for the digital signature namespace
  97      * @param prefix the new prefix for the digital signature namespace
  98      * @throws SecurityException if a security manager is installed and the
  99      *    caller does not have permission to set the prefix
 100      */
 101     public static void setDsPrefix(String prefix) {
 102         JavaUtils.checkRegisterPermission();
 103         dsPrefix = prefix;
 104     }
 105 
</pre>
<hr />
<pre>
 146 
 147     /**
 148      * @param rootNode
 149      * @param result
 150      * @param exclude
 151      * @param com whether comments or not
 152      */
 153     public static void getSet(Node rootNode, Set&lt;Node&gt; result, Node exclude, boolean com) {
 154         if (exclude != null &amp;&amp; isDescendantOrSelf(exclude, rootNode)) {
 155             return;
 156         }
 157         getSetRec(rootNode, result, exclude, com);
 158     }
 159 
 160     @SuppressWarnings(&quot;fallthrough&quot;)
 161     private static void getSetRec(final Node rootNode, final Set&lt;Node&gt; result,
 162                                 final Node exclude, final boolean com) {
 163         if (rootNode == exclude) {
 164             return;
 165         }
<span class="line-modified"> 166         switch (rootNode.getNodeType()) { //NOPMD</span>
 167         case Node.ELEMENT_NODE:
 168             result.add(rootNode);
 169             Element el = (Element)rootNode;
 170             if (el.hasAttributes()) {
 171                 NamedNodeMap nl = el.getAttributes();
 172                 int length = nl.getLength();
 173                 for (int i = 0; i &lt; length; i++) {
 174                     result.add(nl.item(i));
 175                 }
 176             }
 177             //no return keep working
 178         case Node.DOCUMENT_NODE:
 179             for (Node r = rootNode.getFirstChild(); r != null; r = r.getNextSibling()) {
 180                 if (r.getNodeType() == Node.TEXT_NODE) {
 181                     result.add(r);
 182                     while (r != null &amp;&amp; r.getNodeType() == Node.TEXT_NODE) {
 183                         r = r.getNextSibling();
 184                     }
 185                     if (r == null) {
 186                         return;
 187                     }
 188                 }
 189                 getSetRec(r, result, exclude, com);
 190             }
<span class="line-modified"> 191             break;</span>
 192         case Node.COMMENT_NODE:
 193             if (com) {
 194                 result.add(rootNode);
 195             }
<span class="line-modified"> 196             break;</span>
 197         case Node.DOCUMENT_TYPE_NODE:
<span class="line-modified"> 198             break;</span>
 199         default:
 200             result.add(rootNode);
 201         }
 202     }
 203 

 204     /**
 205      * Outputs a DOM tree to an {@link OutputStream}.
 206      *
 207      * @param contextNode root node of the DOM tree
 208      * @param os the {@link OutputStream}
 209      */
 210     public static void outputDOM(Node contextNode, OutputStream os) {
 211         XMLUtils.outputDOM(contextNode, os, false);
 212     }
 213 
 214     /**
 215      * Outputs a DOM tree to an {@link OutputStream}. &lt;I&gt;If an Exception is
 216      * thrown during execution, it&#39;s StackTrace is output to System.out, but the
 217      * Exception is not re-thrown.&lt;/I&gt;
 218      *
 219      * @param contextNode root node of the DOM tree
 220      * @param os the {@link OutputStream}
 221      * @param addPreamble
 222      */
 223     public static void outputDOM(Node contextNode, OutputStream os, boolean addPreamble) {
</pre>
<hr />
<pre>
 252      * @param contextNode
 253      * @param os
 254      */
 255     public static void outputDOMc14nWithComments(Node contextNode, OutputStream os) {
 256         try {
 257             os.write(Canonicalizer.getInstance(
 258                 Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS).canonicalizeSubtree(contextNode)
 259             );
 260         } catch (IOException ex) {
 261             LOG.debug(ex.getMessage(), ex);
 262             // throw new RuntimeException(ex.getMessage());
 263         } catch (InvalidCanonicalizerException ex) {
 264             LOG.debug(ex.getMessage(), ex);
 265             // throw new RuntimeException(ex.getMessage());
 266         } catch (CanonicalizationException ex) {
 267             LOG.debug(ex.getMessage(), ex);
 268             // throw new RuntimeException(ex.getMessage());
 269         }
 270     }
 271 
<span class="line-added"> 272     @Deprecated</span>
<span class="line-added"> 273     public static String getFullTextChildrenFromElement(Element element) {</span>
<span class="line-added"> 274         return getFullTextChildrenFromNode(element);</span>
<span class="line-added"> 275     }</span>
<span class="line-added"> 276 </span>
 277     /**
<span class="line-modified"> 278      * Method getFullTextChildrenFromNode</span>
 279      *
<span class="line-modified"> 280      * @param node</span>
 281      * @return the string of children
 282      */
<span class="line-modified"> 283     public static String getFullTextChildrenFromNode(Node node) {</span>
 284         StringBuilder sb = new StringBuilder();
 285 
<span class="line-modified"> 286         Node child = node.getFirstChild();</span>
 287         while (child != null) {
 288             if (child.getNodeType() == Node.TEXT_NODE) {
 289                 sb.append(((Text)child).getData());
 290             }
 291             child = child.getNextSibling();
 292         }
 293 
 294         return sb.toString();
 295     }
 296 
 297     /**
 298      * Creates an Element in the XML Signature specification namespace.
 299      *
 300      * @param doc the factory Document
 301      * @param elementName the local name of the Element
 302      * @return the Element
 303      */
 304     public static Element createElementInSignatureSpace(Document doc, String elementName) {
 305         if (doc == null) {
 306             throw new RuntimeException(&quot;Document is null&quot;);
</pre>
<hr />
<pre>
 685             return null;
 686         }
 687         n = n.getFirstChild();
 688         while (n != null &amp;&amp; n.getNodeType() != Node.TEXT_NODE) {
 689             n = n.getNextSibling();
 690         }
 691         return (Text)n;
 692     }
 693 
 694     /**
 695      * @param sibling
 696      * @param uri
 697      * @param nodeName
 698      * @param number
 699      * @return nodes with the constrain
 700      */
 701     public static Element selectNode(Node sibling, String uri, String nodeName, int number) {
 702         while (sibling != null) {
 703             if (sibling.getNamespaceURI() != null &amp;&amp; sibling.getNamespaceURI().equals(uri)
 704                 &amp;&amp; sibling.getLocalName().equals(nodeName)) {
<span class="line-modified"> 705                 if (number == 0) {</span>
 706                     return (Element)sibling;
 707                 }
 708                 number--;
 709             }
 710             sibling = sibling.getNextSibling();
 711         }
 712         return null;
 713     }
 714 
 715     /**
 716      * @param sibling
 717      * @param nodeName
 718      * @return nodes with the constrain
 719      */
 720     public static Element[] selectDsNodes(Node sibling, String nodeName) {
 721         return selectNodes(sibling, Constants.SignatureSpecNS, nodeName);
 722     }
 723 
 724     /**
 725      * @param sibling
</pre>
<hr />
<pre>
 958             // no child, this node is done.
 959             if (startNode == null) {
 960                 // close node processing, get sibling
 961                 startNode = processedNode.getNextSibling();
 962             }
 963 
 964             // no more siblings, get parent, all children
 965             // of parent are processed.
 966             while (startNode == null) {
 967                 processedNode = processedNode.getParentNode();
 968                 if (processedNode == startParent) {
 969                     return true;
 970                 }
 971                 // close parent node processing (processed node now)
 972                 startNode = processedNode.getNextSibling();
 973             }
 974         }
 975         return true;
 976     }
 977 
<span class="line-modified"> 978     public static Document newDocument() throws ParserConfigurationException {</span>
<span class="line-modified"> 979         ClassLoader loader = getContextClassLoader();</span>
<span class="line-added"> 980         if (loader == null) {</span>
<span class="line-added"> 981             loader = getClassLoader(XMLUtils.class);</span>
<span class="line-added"> 982         }</span>
<span class="line-added"> 983         // If the ClassLoader is null then just create a DocumentBuilder and use it</span>
<span class="line-added"> 984         if (loader == null) {</span>
<span class="line-added"> 985             DocumentBuilder documentBuilder = buildDocumentBuilder(true);</span>
<span class="line-added"> 986             return documentBuilder.newDocument();</span>
<span class="line-added"> 987         }</span>
<span class="line-added"> 988 </span>
<span class="line-added"> 989         Queue&lt;DocumentBuilder&gt; queue = getDocumentBuilderQueue(true, loader);</span>
<span class="line-added"> 990         DocumentBuilder documentBuilder = getDocumentBuilder(true, queue);</span>
<span class="line-added"> 991         Document doc = documentBuilder.newDocument();</span>
<span class="line-added"> 992         repoolDocumentBuilder(documentBuilder, queue);</span>
<span class="line-added"> 993         return doc;</span>
<span class="line-added"> 994     }</span>
<span class="line-added"> 995 </span>
<span class="line-added"> 996     public static Document read(InputStream inputStream) throws ParserConfigurationException, SAXException, IOException {</span>
<span class="line-added"> 997         return read(inputStream, true);</span>
<span class="line-added"> 998     }</span>
<span class="line-added"> 999 </span>
<span class="line-added">1000     public static Document read(InputStream inputStream, boolean disAllowDocTypeDeclarations) throws ParserConfigurationException, SAXException, IOException {</span>
<span class="line-added">1001         ClassLoader loader = getContextClassLoader();</span>
<span class="line-added">1002         if (loader == null) {</span>
<span class="line-added">1003             loader = getClassLoader(XMLUtils.class);</span>
<span class="line-added">1004         }</span>
<span class="line-added">1005         // If the ClassLoader is null then just create a DocumentBuilder and use it</span>
<span class="line-added">1006         if (loader == null) {</span>
<span class="line-added">1007             DocumentBuilder documentBuilder = buildDocumentBuilder(disAllowDocTypeDeclarations);</span>
<span class="line-added">1008             return documentBuilder.parse(inputStream);</span>
<span class="line-added">1009         }</span>
<span class="line-added">1010 </span>
<span class="line-added">1011         Queue&lt;DocumentBuilder&gt; queue = getDocumentBuilderQueue(disAllowDocTypeDeclarations, loader);</span>
<span class="line-added">1012         DocumentBuilder documentBuilder = getDocumentBuilder(disAllowDocTypeDeclarations, queue);</span>
<span class="line-added">1013         Document doc = documentBuilder.parse(inputStream);</span>
<span class="line-added">1014         repoolDocumentBuilder(documentBuilder, queue);</span>
<span class="line-added">1015         return doc;</span>
<span class="line-added">1016     }</span>
<span class="line-added">1017 </span>
<span class="line-added">1018     public static Document read(String uri, boolean disAllowDocTypeDeclarations)</span>
<span class="line-added">1019         throws ParserConfigurationException, SAXException, IOException {</span>
<span class="line-added">1020         ClassLoader loader = getContextClassLoader();</span>
<span class="line-added">1021         if (loader == null) {</span>
<span class="line-added">1022             loader = getClassLoader(XMLUtils.class);</span>
<span class="line-added">1023         }</span>
<span class="line-added">1024         // If the ClassLoader is null then just create a DocumentBuilder and use it</span>
<span class="line-added">1025         if (loader == null) {</span>
<span class="line-added">1026             DocumentBuilder documentBuilder = buildDocumentBuilder(disAllowDocTypeDeclarations);</span>
<span class="line-added">1027             return documentBuilder.parse(uri);</span>
<span class="line-added">1028         }</span>
<span class="line-added">1029 </span>
<span class="line-added">1030         Queue&lt;DocumentBuilder&gt; queue = getDocumentBuilderQueue(disAllowDocTypeDeclarations, loader);</span>
<span class="line-added">1031         DocumentBuilder documentBuilder = getDocumentBuilder(disAllowDocTypeDeclarations, queue);</span>
<span class="line-added">1032         Document doc = documentBuilder.parse(uri);</span>
<span class="line-added">1033         repoolDocumentBuilder(documentBuilder, queue);</span>
<span class="line-added">1034         return doc;</span>
<span class="line-added">1035     }</span>
<span class="line-added">1036 </span>
<span class="line-added">1037     public static Document read(InputSource inputSource) throws ParserConfigurationException, SAXException, IOException {</span>
<span class="line-added">1038         return read(inputSource, true);</span>
<span class="line-added">1039     }</span>
<span class="line-added">1040 </span>
<span class="line-added">1041     public static Document read(InputSource inputSource, boolean disAllowDocTypeDeclarations)</span>
<span class="line-added">1042         throws ParserConfigurationException, SAXException, IOException {</span>
<span class="line-added">1043         ClassLoader loader = getContextClassLoader();</span>
<span class="line-added">1044         if (loader == null) {</span>
<span class="line-added">1045             loader = getClassLoader(XMLUtils.class);</span>
<span class="line-added">1046         }</span>
<span class="line-added">1047         // If the ClassLoader is null then just create a DocumentBuilder and use it</span>
<span class="line-added">1048         if (loader == null) {</span>
<span class="line-added">1049             DocumentBuilder documentBuilder = buildDocumentBuilder(disAllowDocTypeDeclarations);</span>
<span class="line-added">1050             return documentBuilder.parse(inputSource);</span>
<span class="line-added">1051         }</span>
<span class="line-added">1052 </span>
<span class="line-added">1053         Queue&lt;DocumentBuilder&gt; queue = getDocumentBuilderQueue(disAllowDocTypeDeclarations, loader);</span>
<span class="line-added">1054         DocumentBuilder documentBuilder = getDocumentBuilder(disAllowDocTypeDeclarations, queue);</span>
<span class="line-added">1055         Document doc = documentBuilder.parse(inputSource);</span>
<span class="line-added">1056         repoolDocumentBuilder(documentBuilder, queue);</span>
<span class="line-added">1057         return doc;</span>
<span class="line-added">1058     }</span>
<span class="line-added">1059 </span>
<span class="line-added">1060     /**</span>
<span class="line-added">1061      * @deprecated Use XMLUtils.read instead to directly read a document.</span>
<span class="line-added">1062      */</span>
<span class="line-added">1063     @Deprecated</span>
<span class="line-added">1064     public static DocumentBuilder createDocumentBuilder(boolean validating) throws ParserConfigurationException {</span>
1065         return createDocumentBuilder(validating, true);
1066     }
1067 
<span class="line-modified">1068     /**</span>
<span class="line-modified">1069      * @deprecated Use XMLUtils.read instead to directly read a document.</span>
<span class="line-added">1070      */</span>
<span class="line-added">1071     @Deprecated</span>
1072     public static DocumentBuilder createDocumentBuilder(
1073         boolean validating, boolean disAllowDocTypeDeclarations
1074     ) throws ParserConfigurationException {
1075         DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();
<span class="line-modified">1076         dfactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE);</span>
1077         if (disAllowDocTypeDeclarations) {
1078             dfactory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
1079         }
1080         dfactory.setValidating(validating);
1081         dfactory.setNamespaceAware(true);
1082         return dfactory.newDocumentBuilder();
1083     }
1084 
<span class="line-added">1085     /**</span>
<span class="line-added">1086      * @deprecated This method has no effect in Santuario 2.1.4</span>
<span class="line-added">1087      */</span>
<span class="line-added">1088     @Deprecated</span>
<span class="line-added">1089     public static boolean repoolDocumentBuilder(DocumentBuilder db) {</span>
<span class="line-added">1090         return true;</span>
<span class="line-added">1091     }</span>
<span class="line-added">1092 </span>
1093     /**
1094      * Returns a byte-array representation of a {@code {@link BigInteger}}.
1095      * No sign-bit is output.
1096      *
1097      * &lt;b&gt;N.B.:&lt;/B&gt; {@code {@link BigInteger}}&#39;s toByteArray
1098      * returns eventually longer arrays because of the leading sign-bit.
1099      *
1100      * @param big {@code BigInteger} to be converted
1101      * @param bitlen {@code int} the desired length in bits of the representation
1102      * @return a byte array with {@code bitlen} bits of {@code big}
1103      */
1104     public static byte[] getBytes(BigInteger big, int bitlen) {
1105 
1106         //round bitlen
1107         bitlen = ((bitlen + 7) &gt;&gt; 3) &lt;&lt; 3;
1108 
1109         if (bitlen &lt; big.bitLength()) {
1110             throw new IllegalArgumentException(I18n.translate(&quot;utils.Base64.IllegalBitlength&quot;));
1111         }
1112 
</pre>
<hr />
<pre>
1117             return bigBytes;
1118         }
1119 
1120         // some copying needed
1121         int startSrc = 0;    // no need to skip anything
1122         int bigLen = bigBytes.length;    //valid length of the string
1123 
1124         if (big.bitLength() % 8 == 0) {    // correct values
1125             startSrc = 1;    // skip sign bit
1126 
1127             bigLen--;    // valid length of the string
1128         }
1129 
1130         int startDst = bitlen / 8 - bigLen;    //pad with leading nulls
1131         byte[] resizedBytes = new byte[bitlen / 8];
1132 
1133         System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, bigLen);
1134 
1135         return resizedBytes;
1136     }
<span class="line-added">1137 </span>
<span class="line-added">1138     private static Queue&lt;DocumentBuilder&gt; getDocumentBuilderQueue(boolean disAllowDocTypeDeclarations, ClassLoader loader) throws ParserConfigurationException {</span>
<span class="line-added">1139         Map&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt; docBuilderCache =</span>
<span class="line-added">1140             disAllowDocTypeDeclarations ? DOCUMENT_BUILDERS_DISALLOW_DOCTYPE : DOCUMENT_BUILDERS;</span>
<span class="line-added">1141         Queue&lt;DocumentBuilder&gt; queue = docBuilderCache.get(loader);</span>
<span class="line-added">1142         if (queue == null) {</span>
<span class="line-added">1143             queue = new ArrayBlockingQueue&lt;&gt;(parserPoolSize);</span>
<span class="line-added">1144             docBuilderCache.put(loader, queue);</span>
<span class="line-added">1145         }</span>
<span class="line-added">1146 </span>
<span class="line-added">1147         return queue;</span>
<span class="line-added">1148     }</span>
<span class="line-added">1149 </span>
<span class="line-added">1150     private static DocumentBuilder getDocumentBuilder(boolean disAllowDocTypeDeclarations, Queue&lt;DocumentBuilder&gt; queue) throws ParserConfigurationException {</span>
<span class="line-added">1151         DocumentBuilder db = queue.poll();</span>
<span class="line-added">1152         if (db == null) {</span>
<span class="line-added">1153             db = buildDocumentBuilder(disAllowDocTypeDeclarations);</span>
<span class="line-added">1154         }</span>
<span class="line-added">1155         return db;</span>
<span class="line-added">1156     }</span>
<span class="line-added">1157 </span>
<span class="line-added">1158     private static DocumentBuilder buildDocumentBuilder(boolean disAllowDocTypeDeclarations) throws ParserConfigurationException {</span>
<span class="line-added">1159         DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();</span>
<span class="line-added">1160         f.setNamespaceAware(true);</span>
<span class="line-added">1161         f.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);</span>
<span class="line-added">1162         f.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, disAllowDocTypeDeclarations);</span>
<span class="line-added">1163         return f.newDocumentBuilder();</span>
<span class="line-added">1164     }</span>
<span class="line-added">1165 </span>
<span class="line-added">1166     private static void repoolDocumentBuilder(DocumentBuilder db, Queue&lt;DocumentBuilder&gt; queue) {</span>
<span class="line-added">1167         if (queue != null) {</span>
<span class="line-added">1168             db.reset();</span>
<span class="line-added">1169             queue.offer(db);</span>
<span class="line-added">1170         }</span>
<span class="line-added">1171     }</span>
<span class="line-added">1172 </span>
<span class="line-added">1173     private static ClassLoader getContextClassLoader() {</span>
<span class="line-added">1174         final SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">1175         if (sm != null) {</span>
<span class="line-added">1176             return AccessController.doPrivileged(new PrivilegedAction&lt;ClassLoader&gt;() {</span>
<span class="line-added">1177                 public ClassLoader run() {</span>
<span class="line-added">1178                     return Thread.currentThread().getContextClassLoader();</span>
<span class="line-added">1179                 }</span>
<span class="line-added">1180             });</span>
<span class="line-added">1181         }</span>
<span class="line-added">1182         return Thread.currentThread().getContextClassLoader();</span>
<span class="line-added">1183     }</span>
<span class="line-added">1184 </span>
<span class="line-added">1185     private static ClassLoader getClassLoader(final Class&lt;?&gt; clazz) {</span>
<span class="line-added">1186         final SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">1187         if (sm != null) {</span>
<span class="line-added">1188             return AccessController.doPrivileged(new PrivilegedAction&lt;ClassLoader&gt;() {</span>
<span class="line-added">1189                 public ClassLoader run() {</span>
<span class="line-added">1190                     return clazz.getClassLoader();</span>
<span class="line-added">1191                 }</span>
<span class="line-added">1192             });</span>
<span class="line-added">1193         }</span>
<span class="line-added">1194         return clazz.getClassLoader();</span>
<span class="line-added">1195     }</span>
<span class="line-added">1196 </span>
1197 }
</pre>
</td>
</tr>
</table>
<center><a href="WeakObjectPool.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="resolver/ResourceResolver.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
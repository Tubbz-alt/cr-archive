<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/Manifest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.signature;
 24 
 25 import java.io.IOException;
 26 import java.util.ArrayList;
 27 import java.util.HashMap;
 28 import java.util.Iterator;
 29 import java.util.List;
 30 import java.util.Map;
 31 import java.util.Set;
 32 
 33 import javax.xml.parsers.ParserConfigurationException;
 34 
 35 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 36 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
 37 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 38 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
 39 import com.sun.org.apache.xml.internal.security.utils.Constants;
 40 import com.sun.org.apache.xml.internal.security.utils.I18n;
 41 import com.sun.org.apache.xml.internal.security.utils.SignatureElementProxy;
 42 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 43 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;
 44 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverSpi;
 45 import org.w3c.dom.Attr;
 46 import org.w3c.dom.DOMException;
 47 import org.w3c.dom.Document;
 48 import org.w3c.dom.Element;
 49 import org.w3c.dom.Node;
 50 import org.xml.sax.SAXException;
 51 
 52 /**
 53  * Handles {@code &amp;lt;ds:Manifest&amp;gt;} elements.
 54  * &lt;p&gt; This element holds the {@code Reference} elements&lt;/p&gt;
 55  */
 56 public class Manifest extends SignatureElementProxy {
 57 
 58     /**
 59      * The maximum number of references per Manifest, if secure validation is enabled.
 60      */
 61     public static final int MAXIMUM_REFERENCE_COUNT = 30;
 62 
 63     private static final com.sun.org.slf4j.internal.Logger LOG =
 64         com.sun.org.slf4j.internal.LoggerFactory.getLogger(Manifest.class);
 65 
 66     /** Field references */
 67     private List&lt;Reference&gt; references;
 68     private Element[] referencesEl;
 69 
 70     /** Field verificationResults[] */
 71     private boolean[] verificationResults;
 72 
 73     /** Field resolverProperties */
 74     private Map&lt;String, String&gt; resolverProperties;
 75 
 76     /** Field perManifestResolvers */
 77     private List&lt;ResourceResolver&gt; perManifestResolvers;
 78 
 79     private boolean secureValidation;
 80 
 81     /**
 82      * Constructs {@link Manifest}
 83      *
 84      * @param doc the {@link Document} in which {@code XMLsignature} is placed
 85      */
 86     public Manifest(Document doc) {
 87         super(doc);
 88 
 89         addReturnToSelf();
 90 
 91         this.references = new ArrayList&lt;&gt;();
 92     }
 93 
 94     /**
 95      * Constructor Manifest
 96      *
 97      * @param element
 98      * @param baseURI
 99      * @throws XMLSecurityException
100      */
101     public Manifest(Element element, String baseURI) throws XMLSecurityException {
102         this(element, baseURI, true);
103 
104     }
105     /**
106      * Constructor Manifest
107      *
108      * @param element
109      * @param baseURI
110      * @param secureValidation
111      * @throws XMLSecurityException
112      */
113     public Manifest(
114         Element element, String baseURI, boolean secureValidation
115     ) throws XMLSecurityException {
116         super(element, baseURI);
117 
118         Attr attr = element.getAttributeNodeNS(null, &quot;Id&quot;);
119         if (attr != null) {
120             element.setIdAttributeNode(attr, true);
121         }
122         this.secureValidation = secureValidation;
123 
124         // check out Reference children
125         this.referencesEl =
126             XMLUtils.selectDsNodes(
127                 getFirstChild(), Constants._TAG_REFERENCE
128             );
129         int le = this.referencesEl.length;
130         if (le == 0) {
131             // At least one Reference must be present. Bad.
132             Object exArgs[] = { Constants._TAG_REFERENCE, Constants._TAG_MANIFEST };
133 
134             throw new DOMException(DOMException.WRONG_DOCUMENT_ERR,
135                                    I18n.translate(&quot;xml.WrongContent&quot;, exArgs));
136         }
137 
138         if (secureValidation &amp;&amp; le &gt; MAXIMUM_REFERENCE_COUNT) {
139             Object exArgs[] = { le, MAXIMUM_REFERENCE_COUNT };
140 
141             throw new XMLSecurityException(&quot;signature.tooManyReferences&quot;, exArgs);
142         }
143 
144         // create List
145         this.references = new ArrayList&lt;&gt;(le);
146 
147         for (int i = 0; i &lt; le; i++) {
148             Element refElem = referencesEl[i];
149             Attr refAttr = refElem.getAttributeNodeNS(null, &quot;Id&quot;);
150             if (refAttr != null) {
151                 refElem.setIdAttributeNode(refAttr, true);
152             }
153             this.references.add(null);
154         }
155     }
156 
157     /**
158      * This {@code addDocument} method is used to add a new resource to the
159      * signed info. A {@link com.sun.org.apache.xml.internal.security.signature.Reference} is built
160      * from the supplied values.
161      *
162      * @param baseURI the URI of the resource where the XML instance was stored
163      * @param referenceURI {@code URI} attribute in {@code Reference} for specifying
164      * where data is
165      * @param transforms com.sun.org.apache.xml.internal.security.signature.Transforms object with an ordered
166      * list of transformations to be performed.
167      * @param digestURI The digest algorithm URI to be used.
168      * @param referenceId
169      * @param referenceType
170      * @throws XMLSignatureException
171      */
172     public void addDocument(
173         String baseURI, String referenceURI, Transforms transforms,
174         String digestURI, String referenceId, String referenceType
175     ) throws XMLSignatureException {
176         // the this.doc is handed implicitly by the this.getOwnerDocument()
177         Reference ref =
178             new Reference(getDocument(), baseURI, referenceURI, this, transforms, digestURI);
179 
180         if (referenceId != null) {
181             ref.setId(referenceId);
182         }
183 
184         if (referenceType != null) {
185             ref.setType(referenceType);
186         }
187 
188         // add Reference object to our cache vector
189         this.references.add(ref);
190 
191         // add the Element of the Reference object to the Manifest/SignedInfo
192         appendSelf(ref);
193         addReturnToSelf();
194     }
195 
196     /**
197      * The calculation of the DigestValues in the References must be after the
198      * References are already added to the document and during the signing
199      * process. This ensures that all necessary data is in place.
200      *
201      * @throws ReferenceNotInitializedException
202      * @throws XMLSignatureException
203      */
204     public void generateDigestValues()
205         throws XMLSignatureException, ReferenceNotInitializedException {
206         for (int i = 0; i &lt; this.getLength(); i++) {
207             // update the cached Reference object, the Element content is automatically updated
208             Reference currentRef = this.references.get(i);
209             currentRef.generateDigestValue();
210         }
211     }
212 
213     /**
214      * Return the nonnegative number of added references.
215      *
216      * @return the number of references
217      */
218     public int getLength() {
219         return this.references.size();
220     }
221 
222     /**
223      * Return the &lt;i&gt;i&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt; reference. Valid {@code i}
224      * values are 0 to {@code {link@ getSize}-1}.
225      *
226      * @param i Index of the requested {@link Reference}
227      * @return the &lt;i&gt;i&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt; reference
228      * @throws XMLSecurityException
229      */
230     public Reference item(int i) throws XMLSecurityException {
231         if (this.references.get(i) == null) {
232             // not yet constructed, so _we_ have to
233             Reference ref =
234                 new Reference(referencesEl[i], this.baseURI, this, secureValidation);
235 
236             this.references.set(i, ref);
237         }
238 
239         return this.references.get(i);
240     }
241 
242     /**
243      * Sets the {@code Id} attribute
244      *
245      * @param Id the {@code Id} attribute in {@code ds:Manifest}
246      */
247     public void setId(String Id) {
248         if (Id != null) {
249             setLocalIdAttribute(Constants._ATT_ID, Id);
250         }
251     }
252 
253     /**
254      * Returns the {@code Id} attribute
255      *
256      * @return the {@code Id} attribute in {@code ds:Manifest}
257      */
258     public String getId() {
259         return getLocalAttribute(Constants._ATT_ID);
260     }
261 
262     /**
263      * Used to do a &lt;A HREF=&quot;http://www.w3.org/TR/xmldsig-core/#def-ValidationReference&quot;&gt;reference
264      * validation&lt;/A&gt; of all enclosed references using the {@link Reference#verify} method.
265      *
266      * &lt;p&gt;This step loops through all {@link Reference}s and does verify the hash
267      * values. If one or more verifications fail, the method returns
268      * {@code false}. If &lt;i&gt;all&lt;/i&gt; verifications are successful,
269      * it returns {@code true}. The results of the individual reference
270      * validations are available by using the {@link #getVerificationResult(int)} method
271      *
272      * @return true if all References verify, false if one or more do not verify.
273      * @throws MissingResourceFailureException if a {@link Reference} does not verify
274      * (throws a {@link com.sun.org.apache.xml.internal.security.signature.ReferenceNotInitializedException}
275      * because of an uninitialized {@link XMLSignatureInput}
276      * @see com.sun.org.apache.xml.internal.security.signature.Reference#verify
277      * @see com.sun.org.apache.xml.internal.security.signature.SignedInfo#verify()
278      * @see com.sun.org.apache.xml.internal.security.signature.MissingResourceFailureException
279      * @throws XMLSecurityException
280      */
281     public boolean verifyReferences()
282         throws MissingResourceFailureException, XMLSecurityException {
283         return this.verifyReferences(false);
284     }
285 
286     /**
287      * Used to do a &lt;A HREF=&quot;http://www.w3.org/TR/xmldsig-core/#def-ValidationReference&quot;&gt;reference
288      * validation&lt;/A&gt; of all enclosed references using the {@link Reference#verify} method.
289      *
290      * &lt;p&gt;This step loops through all {@link Reference}s and does verify the hash
291      * values. If one or more verifications fail, the method returns
292      * {@code false}. If &lt;i&gt;all&lt;/i&gt; verifications are successful,
293      * it returns {@code true}. The results of the individual reference
294      * validations are available by using the {@link #getVerificationResult(int)} method
295      *
296      * @param followManifests
297      * @return true if all References verify, false if one or more do not verify.
298      * @throws MissingResourceFailureException if a {@link Reference} does not verify
299      * (throws a {@link com.sun.org.apache.xml.internal.security.signature.ReferenceNotInitializedException}
300      * because of an uninitialized {@link XMLSignatureInput}
301      * @see com.sun.org.apache.xml.internal.security.signature.Reference#verify
302      * @see com.sun.org.apache.xml.internal.security.signature.SignedInfo#verify(boolean)
303      * @see com.sun.org.apache.xml.internal.security.signature.MissingResourceFailureException
304      * @throws XMLSecurityException
305      */
306     public boolean verifyReferences(boolean followManifests)
307         throws MissingResourceFailureException, XMLSecurityException {
308         if (referencesEl == null) {
309             this.referencesEl =
310                 XMLUtils.selectDsNodes(
311                     getFirstChild(), Constants._TAG_REFERENCE
312                 );
313         }
314         LOG.debug(&quot;verify {} References&quot;, referencesEl.length);
315         LOG.debug(&quot;I am {} requested to follow nested Manifests&quot;, (followManifests
316             ? &quot;&quot; : &quot;not&quot;));
317         if (referencesEl.length == 0) {
318             throw new XMLSecurityException(&quot;empty&quot;, new Object[]{&quot;References are empty&quot;});
319         }
320         if (secureValidation &amp;&amp; referencesEl.length &gt; MAXIMUM_REFERENCE_COUNT) {
321             Object exArgs[] = { referencesEl.length, MAXIMUM_REFERENCE_COUNT };
322 
323             throw new XMLSecurityException(&quot;signature.tooManyReferences&quot;, exArgs);
324         }
325 
326         this.verificationResults = new boolean[referencesEl.length];
327         boolean verify = true;
328         for (int i = 0; i &lt; this.referencesEl.length; i++) {
329             Reference currentRef =
330                 new Reference(referencesEl[i], this.baseURI, this, secureValidation);
331 
332             this.references.set(i, currentRef);
333 
334             // if only one item does not verify, the whole verification fails
335             try {
336                 boolean currentRefVerified = currentRef.verify();
337 
338                 this.setVerificationResult(i, currentRefVerified);
339 
340                 if (!currentRefVerified) {
341                     verify = false;
342                 }
343                 LOG.debug(&quot;The Reference has Type {}&quot;, currentRef.getType());
344 
345                 // was verification successful till now and do we want to verify the Manifest?
346                 if (verify &amp;&amp; followManifests &amp;&amp; currentRef.typeIsReferenceToManifest()) {
347                     LOG.debug(&quot;We have to follow a nested Manifest&quot;);
348 
349                     try {
350                         XMLSignatureInput signedManifestNodes =
351                             currentRef.dereferenceURIandPerformTransforms(null);
352                         Set&lt;Node&gt; nl = signedManifestNodes.getNodeSet();
353                         Manifest referencedManifest = null;
354                         Iterator&lt;Node&gt; nlIterator = nl.iterator();
355 
356                         while (nlIterator.hasNext()) {
357                             Node n = nlIterator.next();
358 
359                             if (n.getNodeType() == Node.ELEMENT_NODE
360                                 &amp;&amp; ((Element) n).getNamespaceURI().equals(Constants.SignatureSpecNS)
361                                 &amp;&amp; ((Element) n).getLocalName().equals(Constants._TAG_MANIFEST)
362                             ) {
363                                 try {
364                                     referencedManifest =
365                                         new Manifest(
366                                              (Element)n, signedManifestNodes.getSourceURI(), secureValidation
367                                         );
368                                     break;
369                                 } catch (XMLSecurityException ex) {
370                                     LOG.debug(ex.getMessage(), ex);
371                                     // Hm, seems not to be a ds:Manifest
372                                 }
373                             }
374                         }
375 
376                         if (referencedManifest == null) {
377                             // The Reference stated that it points to a ds:Manifest
378                             // but we did not find a ds:Manifest in the signed area
379                             throw new MissingResourceFailureException(currentRef, &quot;empty&quot;,
380                                                                       new Object[]{&quot;No Manifest found&quot;});
381                         }
382 
383                         referencedManifest.perManifestResolvers = this.perManifestResolvers;
384                         referencedManifest.resolverProperties = this.resolverProperties;
385 
386                         boolean referencedManifestValid =
387                             referencedManifest.verifyReferences(followManifests);
388 
389                         if (!referencedManifestValid) {
390                             verify = false;
391 
392                             LOG.warn(&quot;The nested Manifest was invalid (bad)&quot;);
393                         } else {
394                             LOG.debug(&quot;The nested Manifest was valid (good)&quot;);
395                         }
396                     } catch (IOException ex) {
397                         throw new ReferenceNotInitializedException(ex);
398                     } catch (ParserConfigurationException ex) {
399                         throw new ReferenceNotInitializedException(ex);
400                     } catch (SAXException ex) {
401                         throw new ReferenceNotInitializedException(ex);
402                     }
403                 }
404             } catch (ReferenceNotInitializedException ex) {
405                 Object exArgs[] = { currentRef.getURI() };
406 
407                 throw new MissingResourceFailureException(
408                     ex, currentRef, &quot;signature.Verification.Reference.NoInput&quot;, exArgs
409                 );
410             }
411         }
412 
413         return verify;
414     }
415 
416     /**
417      * Method setVerificationResult
418      *
419      * @param index
420      * @param verify
421      */
422     private void setVerificationResult(int index, boolean verify) {
423         if (this.verificationResults == null) {
424             this.verificationResults = new boolean[this.getLength()];
425         }
426 
427         this.verificationResults[index] = verify;
428     }
429 
430     /**
431      * After verifying a {@link Manifest} or a {@link SignedInfo} using the
432      * {@link Manifest#verifyReferences()} or {@link SignedInfo#verify()} methods,
433      * the individual results can be retrieved with this method.
434      *
435      * @param index an index of into a {@link Manifest} or a {@link SignedInfo}
436      * @return the results of reference validation at the specified index
437      * @throws XMLSecurityException
438      */
439     public boolean getVerificationResult(int index) throws XMLSecurityException {
440         if (index &lt; 0 || index &gt; this.getLength() - 1) {
441             Object exArgs[] = { Integer.toString(index), Integer.toString(this.getLength()) };
442             Exception e =
443                 new IndexOutOfBoundsException(
444                     I18n.translate(&quot;signature.Verification.IndexOutOfBounds&quot;, exArgs)
445                 );
446 
447             throw new XMLSecurityException(e);
448         }
449 
450         if (this.verificationResults == null) {
451             try {
452                 this.verifyReferences();
453             } catch (Exception ex) {
454                 throw new XMLSecurityException(ex);
455             }
456         }
457 
458         return this.verificationResults[index];
459     }
460 
461     /**
462      * Adds Resource Resolver for retrieving resources at specified {@code URI} attribute
463      * in {@code reference} element
464      *
465      * @param resolver {@link ResourceResolver} can provide the implemenatin subclass of
466      * {@link ResourceResolverSpi} for retrieving resource.
467      */
468     public void addResourceResolver(ResourceResolver resolver) {
469         if (resolver == null) {
470             return;
471         }
472         if (perManifestResolvers == null) {
473             perManifestResolvers = new ArrayList&lt;&gt;();
474         }
475         this.perManifestResolvers.add(resolver);
476     }
477 
478     /**
479      * Adds Resource Resolver for retrieving resources at specified {@code URI} attribute
480      * in {@code reference} element
481      *
482      * @param resolverSpi the implementation subclass of {@link ResourceResolverSpi} for
483      * retrieving the resource.
484      */
485     public void addResourceResolver(ResourceResolverSpi resolverSpi) {
486         if (resolverSpi == null) {
487             return;
488         }
489         if (perManifestResolvers == null) {
490             perManifestResolvers = new ArrayList&lt;&gt;();
491         }
492         perManifestResolvers.add(new ResourceResolver(resolverSpi));
493     }
494 
495     /**
496      * Get the Per-Manifest Resolver List
497      * @return the per-manifest Resolver List
498      */
499     public List&lt;ResourceResolver&gt; getPerManifestResolvers() {
500         return perManifestResolvers;
501     }
502 
503     /**
504      * Get the resolver property map
505      * @return the resolver property map
506      */
507     public Map&lt;String, String&gt; getResolverProperties() {
508         return resolverProperties;
509     }
510 
511     /**
512      * Used to pass parameters like proxy servers etc to the ResourceResolver
513      * implementation.
514      *
515      * @param key the key
516      * @param value the value
517      */
518     public void setResolverProperty(String key, String value) {
519         if (resolverProperties == null) {
520             resolverProperties = new HashMap&lt;&gt;(10);
521         }
522         this.resolverProperties.put(key, value);
523     }
524 
525     /**
526      * Returns the value at specified key
527      *
528      * @param key the key
529      * @return the value
530      */
531     public String getResolverProperty(String key) {
532         return this.resolverProperties.get(key);
533     }
534 
535     /**
536      * Method getSignedContentItem
537      *
538      * @param i
539      * @return The signed content of the i reference.
540      *
541      * @throws XMLSignatureException
542      */
543     public byte[] getSignedContentItem(int i) throws XMLSignatureException {
544         try {
545             return this.getReferencedContentAfterTransformsItem(i).getBytes();
546         } catch (IOException ex) {
547             throw new XMLSignatureException(ex);
548         } catch (CanonicalizationException ex) {
549             throw new XMLSignatureException(ex);
550         } catch (InvalidCanonicalizerException ex) {
551             throw new XMLSignatureException(ex);
552         } catch (XMLSecurityException ex) {
553             throw new XMLSignatureException(ex);
554         }
555     }
556 
557     /**
558      * Method getReferencedContentPriorTransformsItem
559      *
560      * @param i
561      * @return The contents before transformation of the reference i.
562      * @throws XMLSecurityException
563      */
564     public XMLSignatureInput getReferencedContentBeforeTransformsItem(int i)
565         throws XMLSecurityException {
566         return this.item(i).getContentsBeforeTransformation();
567     }
568 
569     /**
570      * Method getReferencedContentAfterTransformsItem
571      *
572      * @param i
573      * @return The contents after transformation of the reference i.
574      * @throws XMLSecurityException
575      */
576     public XMLSignatureInput getReferencedContentAfterTransformsItem(int i)
577         throws XMLSecurityException {
578         return this.item(i).getContentsAfterTransformation();
579     }
580 
581     /**
582      * Method getSignedContentLength
583      *
584      * @return The number of references contained in this reference.
585      */
586     public int getSignedContentLength() {
587         return this.getLength();
588     }
589 
590     /**
591      * Method getBaseLocalName
592      *
593      * {@inheritDoc}
594      */
595     public String getBaseLocalName() {
596         return Constants._TAG_MANIFEST;
597     }
598 
599     public boolean isSecureValidation() {
600         return secureValidation;
601     }
602 }
    </pre>
  </body>
</html>
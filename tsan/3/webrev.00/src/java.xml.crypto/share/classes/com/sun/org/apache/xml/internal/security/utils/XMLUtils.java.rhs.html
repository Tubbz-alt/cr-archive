<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/utils/XMLUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * reserved comment block
   3  * DO NOT REMOVE OR ALTER!
   4  */
   5 /**
   6  * Licensed to the Apache Software Foundation (ASF) under one
   7  * or more contributor license agreements. See the NOTICE file
   8  * distributed with this work for additional information
   9  * regarding copyright ownership. The ASF licenses this file
  10  * to you under the Apache License, Version 2.0 (the
  11  * &quot;License&quot;); you may not use this file except in compliance
  12  * with the License. You may obtain a copy of the License at
  13  *
  14  * http://www.apache.org/licenses/LICENSE-2.0
  15  *
  16  * Unless required by applicable law or agreed to in writing,
  17  * software distributed under the License is distributed on an
  18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  19  * KIND, either express or implied. See the License for the
  20  * specific language governing permissions and limitations
  21  * under the License.
  22  */
  23 package com.sun.org.apache.xml.internal.security.utils;
  24 
  25 import java.io.IOException;
<a name="1" id="anc1"></a><span class="line-added">  26 import java.io.InputStream;</span>
  27 import java.io.OutputStream;
  28 import java.math.BigInteger;
  29 import java.security.AccessController;
  30 import java.security.PrivilegedAction;
  31 import java.util.ArrayList;
  32 import java.util.Base64;
<a name="2" id="anc2"></a><span class="line-added">  33 import java.util.Collections;</span>
  34 import java.util.HashSet;
  35 import java.util.Iterator;
  36 import java.util.List;
<a name="3" id="anc3"></a><span class="line-added">  37 import java.util.Map;</span>
<span class="line-added">  38 import java.util.Queue;</span>
  39 import java.util.Set;
<a name="4" id="anc4"></a><span class="line-added">  40 import java.util.WeakHashMap;</span>
<span class="line-added">  41 import java.util.concurrent.ArrayBlockingQueue;</span>
  42 
  43 import javax.xml.parsers.DocumentBuilder;
  44 import javax.xml.parsers.DocumentBuilderFactory;
  45 import javax.xml.parsers.ParserConfigurationException;
  46 
  47 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
  48 import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
  49 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
  50 import org.w3c.dom.Attr;
  51 import org.w3c.dom.Document;
  52 import org.w3c.dom.Element;
  53 import org.w3c.dom.NamedNodeMap;
  54 import org.w3c.dom.Node;
  55 import org.w3c.dom.NodeList;
  56 import org.w3c.dom.Text;
<a name="5" id="anc5"></a><span class="line-added">  57 import org.xml.sax.InputSource;</span>
<span class="line-added">  58 import org.xml.sax.SAXException;</span>
  59 
  60 /**
  61  * DOM and XML accessibility and comfort functions.
  62  *
  63  */
  64 public final class XMLUtils {
  65 
  66     private static boolean ignoreLineBreaks =
  67         AccessController.doPrivileged(
  68             (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;com.sun.org.apache.xml.internal.security.ignoreLineBreaks&quot;));
<a name="6" id="anc6"></a><span class="line-added">  69     private static int parserPoolSize =</span>
<span class="line-added">  70         AccessController.doPrivileged(</span>
<span class="line-added">  71             (PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.getInteger(&quot;com.sun.org.apache.xml.internal.security.parser.pool-size&quot;, 20));</span>
  72 
  73     private static volatile String dsPrefix = &quot;ds&quot;;
  74     private static volatile String ds11Prefix = &quot;dsig11&quot;;
  75     private static volatile String xencPrefix = &quot;xenc&quot;;
  76     private static volatile String xenc11Prefix = &quot;xenc11&quot;;
  77 
  78     private static final com.sun.org.slf4j.internal.Logger LOG =
  79         com.sun.org.slf4j.internal.LoggerFactory.getLogger(XMLUtils.class);
  80 
<a name="7" id="anc7"></a><span class="line-added">  81     private static final Map&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt; DOCUMENT_BUILDERS =</span>
<span class="line-added">  82         Collections.synchronizedMap(new WeakHashMap&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt;());</span>
<span class="line-added">  83 </span>
<span class="line-added">  84     private static final Map&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt; DOCUMENT_BUILDERS_DISALLOW_DOCTYPE =</span>
<span class="line-added">  85         Collections.synchronizedMap(new WeakHashMap&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt;());</span>
  86 
  87     /**
  88      * Constructor XMLUtils
  89      *
  90      */
  91     private XMLUtils() {
  92         // we don&#39;t allow instantiation
  93     }
  94 
  95     /**
  96      * Set the prefix for the digital signature namespace
  97      * @param prefix the new prefix for the digital signature namespace
  98      * @throws SecurityException if a security manager is installed and the
  99      *    caller does not have permission to set the prefix
 100      */
 101     public static void setDsPrefix(String prefix) {
 102         JavaUtils.checkRegisterPermission();
 103         dsPrefix = prefix;
 104     }
 105 
 106     /**
 107      * Set the prefix for the digital signature 1.1 namespace
 108      * @param prefix the new prefix for the digital signature 1.1 namespace
 109      * @throws SecurityException if a security manager is installed and the
 110      *    caller does not have permission to set the prefix
 111      */
 112     public static void setDs11Prefix(String prefix) {
 113         JavaUtils.checkRegisterPermission();
 114         ds11Prefix = prefix;
 115     }
 116 
 117     /**
 118      * Set the prefix for the encryption namespace
 119      * @param prefix the new prefix for the encryption namespace
 120      * @throws SecurityException if a security manager is installed and the
 121      *    caller does not have permission to set the prefix
 122      */
 123     public static void setXencPrefix(String prefix) {
 124         JavaUtils.checkRegisterPermission();
 125         xencPrefix = prefix;
 126     }
 127 
 128     /**
 129      * Set the prefix for the encryption namespace 1.1
 130      * @param prefix the new prefix for the encryption namespace 1.1
 131      * @throws SecurityException if a security manager is installed and the
 132      *    caller does not have permission to set the prefix
 133      */
 134     public static void setXenc11Prefix(String prefix) {
 135         JavaUtils.checkRegisterPermission();
 136         xenc11Prefix = prefix;
 137     }
 138 
 139     public static Element getNextElement(Node el) {
 140         Node node = el;
 141         while (node != null &amp;&amp; node.getNodeType() != Node.ELEMENT_NODE) {
 142             node = node.getNextSibling();
 143         }
 144         return (Element)node;
 145     }
 146 
 147     /**
 148      * @param rootNode
 149      * @param result
 150      * @param exclude
 151      * @param com whether comments or not
 152      */
 153     public static void getSet(Node rootNode, Set&lt;Node&gt; result, Node exclude, boolean com) {
 154         if (exclude != null &amp;&amp; isDescendantOrSelf(exclude, rootNode)) {
 155             return;
 156         }
 157         getSetRec(rootNode, result, exclude, com);
 158     }
 159 
 160     @SuppressWarnings(&quot;fallthrough&quot;)
 161     private static void getSetRec(final Node rootNode, final Set&lt;Node&gt; result,
 162                                 final Node exclude, final boolean com) {
 163         if (rootNode == exclude) {
 164             return;
 165         }
<a name="8" id="anc8"></a><span class="line-modified"> 166         switch (rootNode.getNodeType()) { //NOPMD</span>
 167         case Node.ELEMENT_NODE:
 168             result.add(rootNode);
 169             Element el = (Element)rootNode;
 170             if (el.hasAttributes()) {
 171                 NamedNodeMap nl = el.getAttributes();
 172                 int length = nl.getLength();
 173                 for (int i = 0; i &lt; length; i++) {
 174                     result.add(nl.item(i));
 175                 }
 176             }
 177             //no return keep working
 178         case Node.DOCUMENT_NODE:
 179             for (Node r = rootNode.getFirstChild(); r != null; r = r.getNextSibling()) {
 180                 if (r.getNodeType() == Node.TEXT_NODE) {
 181                     result.add(r);
 182                     while (r != null &amp;&amp; r.getNodeType() == Node.TEXT_NODE) {
 183                         r = r.getNextSibling();
 184                     }
 185                     if (r == null) {
 186                         return;
 187                     }
 188                 }
 189                 getSetRec(r, result, exclude, com);
 190             }
<a name="9" id="anc9"></a><span class="line-modified"> 191             break;</span>
 192         case Node.COMMENT_NODE:
 193             if (com) {
 194                 result.add(rootNode);
 195             }
<a name="10" id="anc10"></a><span class="line-modified"> 196             break;</span>
 197         case Node.DOCUMENT_TYPE_NODE:
<a name="11" id="anc11"></a><span class="line-modified"> 198             break;</span>
 199         default:
 200             result.add(rootNode);
 201         }
 202     }
 203 
<a name="12" id="anc12"></a>
 204     /**
 205      * Outputs a DOM tree to an {@link OutputStream}.
 206      *
 207      * @param contextNode root node of the DOM tree
 208      * @param os the {@link OutputStream}
 209      */
 210     public static void outputDOM(Node contextNode, OutputStream os) {
 211         XMLUtils.outputDOM(contextNode, os, false);
 212     }
 213 
 214     /**
 215      * Outputs a DOM tree to an {@link OutputStream}. &lt;I&gt;If an Exception is
 216      * thrown during execution, it&#39;s StackTrace is output to System.out, but the
 217      * Exception is not re-thrown.&lt;/I&gt;
 218      *
 219      * @param contextNode root node of the DOM tree
 220      * @param os the {@link OutputStream}
 221      * @param addPreamble
 222      */
 223     public static void outputDOM(Node contextNode, OutputStream os, boolean addPreamble) {
 224         try {
 225             if (addPreamble) {
 226                 os.write(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;.getBytes(java.nio.charset.StandardCharsets.UTF_8));
 227             }
 228 
 229             os.write(Canonicalizer.getInstance(
 230                 Canonicalizer.ALGO_ID_C14N_PHYSICAL).canonicalizeSubtree(contextNode)
 231             );
 232         } catch (IOException ex) {
 233             LOG.debug(ex.getMessage(), ex);
 234         }
 235         catch (InvalidCanonicalizerException ex) {
 236             LOG.debug(ex.getMessage(), ex);
 237         } catch (CanonicalizationException ex) {
 238             LOG.debug(ex.getMessage(), ex);
 239         }
 240     }
 241 
 242     /**
 243      * Serializes the {@code contextNode} into the OutputStream, &lt;I&gt;but
 244      * suppresses all Exceptions&lt;/I&gt;.
 245      * &lt;p&gt;&lt;/p&gt;
 246      * NOTE: &lt;I&gt;This should only be used for debugging purposes,
 247      * NOT in a production environment; this method ignores all exceptions,
 248      * so you won&#39;t notice if something goes wrong. If you&#39;re asking what is to
 249      * be used in a production environment, simply use the code inside the
 250      * {@code try{}} statement, but handle the Exceptions appropriately.&lt;/I&gt;
 251      *
 252      * @param contextNode
 253      * @param os
 254      */
 255     public static void outputDOMc14nWithComments(Node contextNode, OutputStream os) {
 256         try {
 257             os.write(Canonicalizer.getInstance(
 258                 Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS).canonicalizeSubtree(contextNode)
 259             );
 260         } catch (IOException ex) {
 261             LOG.debug(ex.getMessage(), ex);
 262             // throw new RuntimeException(ex.getMessage());
 263         } catch (InvalidCanonicalizerException ex) {
 264             LOG.debug(ex.getMessage(), ex);
 265             // throw new RuntimeException(ex.getMessage());
 266         } catch (CanonicalizationException ex) {
 267             LOG.debug(ex.getMessage(), ex);
 268             // throw new RuntimeException(ex.getMessage());
 269         }
 270     }
 271 
<a name="13" id="anc13"></a><span class="line-added"> 272     @Deprecated</span>
<span class="line-added"> 273     public static String getFullTextChildrenFromElement(Element element) {</span>
<span class="line-added"> 274         return getFullTextChildrenFromNode(element);</span>
<span class="line-added"> 275     }</span>
<span class="line-added"> 276 </span>
 277     /**
<a name="14" id="anc14"></a><span class="line-modified"> 278      * Method getFullTextChildrenFromNode</span>
 279      *
<a name="15" id="anc15"></a><span class="line-modified"> 280      * @param node</span>
 281      * @return the string of children
 282      */
<a name="16" id="anc16"></a><span class="line-modified"> 283     public static String getFullTextChildrenFromNode(Node node) {</span>
 284         StringBuilder sb = new StringBuilder();
 285 
<a name="17" id="anc17"></a><span class="line-modified"> 286         Node child = node.getFirstChild();</span>
 287         while (child != null) {
 288             if (child.getNodeType() == Node.TEXT_NODE) {
 289                 sb.append(((Text)child).getData());
 290             }
 291             child = child.getNextSibling();
 292         }
 293 
 294         return sb.toString();
 295     }
 296 
 297     /**
 298      * Creates an Element in the XML Signature specification namespace.
 299      *
 300      * @param doc the factory Document
 301      * @param elementName the local name of the Element
 302      * @return the Element
 303      */
 304     public static Element createElementInSignatureSpace(Document doc, String elementName) {
 305         if (doc == null) {
 306             throw new RuntimeException(&quot;Document is null&quot;);
 307         }
 308 
 309         if (dsPrefix == null || dsPrefix.length() == 0) {
 310             return doc.createElementNS(Constants.SignatureSpecNS, elementName);
 311         }
 312         return doc.createElementNS(Constants.SignatureSpecNS, dsPrefix + &quot;:&quot; + elementName);
 313     }
 314 
 315     /**
 316      * Creates an Element in the XML Signature 1.1 specification namespace.
 317      *
 318      * @param doc the factory Document
 319      * @param elementName the local name of the Element
 320      * @return the Element
 321      */
 322     public static Element createElementInSignature11Space(Document doc, String elementName) {
 323         if (doc == null) {
 324             throw new RuntimeException(&quot;Document is null&quot;);
 325         }
 326 
 327         if (ds11Prefix == null || ds11Prefix.length() == 0) {
 328             return doc.createElementNS(Constants.SignatureSpec11NS, elementName);
 329         }
 330         return doc.createElementNS(Constants.SignatureSpec11NS, ds11Prefix + &quot;:&quot; + elementName);
 331     }
 332 
 333     /**
 334      * Returns true if the element is in XML Signature namespace and the local
 335      * name equals the supplied one.
 336      *
 337      * @param element
 338      * @param localName
 339      * @return true if the element is in XML Signature namespace and the local name equals
 340      * the supplied one
 341      */
 342     public static boolean elementIsInSignatureSpace(Element element, String localName) {
 343         if (element == null){
 344             return false;
 345         }
 346 
 347         return Constants.SignatureSpecNS.equals(element.getNamespaceURI())
 348             &amp;&amp; element.getLocalName().equals(localName);
 349     }
 350 
 351     /**
 352      * Returns true if the element is in XML Signature 1.1 namespace and the local
 353      * name equals the supplied one.
 354      *
 355      * @param element
 356      * @param localName
 357      * @return true if the element is in XML Signature namespace and the local name equals
 358      * the supplied one
 359      */
 360     public static boolean elementIsInSignature11Space(Element element, String localName) {
 361         if (element == null) {
 362             return false;
 363         }
 364 
 365         return Constants.SignatureSpec11NS.equals(element.getNamespaceURI())
 366             &amp;&amp; element.getLocalName().equals(localName);
 367     }
 368 
 369     /**
 370      * This method returns the owner document of a particular node.
 371      * This method is necessary because it &lt;I&gt;always&lt;/I&gt; returns a
 372      * {@link Document}. {@link Node#getOwnerDocument} returns {@code null}
 373      * if the {@link Node} is a {@link Document}.
 374      *
 375      * @param node
 376      * @return the owner document of the node
 377      */
 378     public static Document getOwnerDocument(Node node) {
 379         if (node.getNodeType() == Node.DOCUMENT_NODE) {
 380             return (Document) node;
 381         }
 382         try {
 383             return node.getOwnerDocument();
 384         } catch (NullPointerException npe) {
 385             throw new NullPointerException(I18n.translate(&quot;endorsed.jdk1.4.0&quot;)
 386                                            + &quot; Original message was \&quot;&quot;
 387                                            + npe.getMessage() + &quot;\&quot;&quot;);
 388         }
 389     }
 390 
 391     /**
 392      * This method returns the first non-null owner document of the Nodes in this Set.
 393      * This method is necessary because it &lt;I&gt;always&lt;/I&gt; returns a
 394      * {@link Document}. {@link Node#getOwnerDocument} returns {@code null}
 395      * if the {@link Node} is a {@link Document}.
 396      *
 397      * @param xpathNodeSet
 398      * @return the owner document
 399      */
 400     public static Document getOwnerDocument(Set&lt;Node&gt; xpathNodeSet) {
 401         NullPointerException npe = null;
 402         for (Node node : xpathNodeSet) {
 403             int nodeType = node.getNodeType();
 404             if (nodeType == Node.DOCUMENT_NODE) {
 405                 return (Document) node;
 406             }
 407             try {
 408                 if (nodeType == Node.ATTRIBUTE_NODE) {
 409                     return ((Attr)node).getOwnerElement().getOwnerDocument();
 410                 }
 411                 return node.getOwnerDocument();
 412             } catch (NullPointerException e) {
 413                 npe = e;
 414             }
 415         }
 416 
 417         throw new NullPointerException(I18n.translate(&quot;endorsed.jdk1.4.0&quot;)
 418                                        + &quot; Original message was \&quot;&quot;
 419                                        + (npe == null ? &quot;&quot; : npe.getMessage()) + &quot;\&quot;&quot;);
 420     }
 421 
 422     /**
 423      * Method createDSctx
 424      *
 425      * @param doc
 426      * @param prefix
 427      * @param namespace
 428      * @return the element.
 429      */
 430     public static Element createDSctx(Document doc, String prefix, String namespace) {
 431         if (prefix == null || prefix.trim().length() == 0) {
 432             throw new IllegalArgumentException(&quot;You must supply a prefix&quot;);
 433         }
 434 
 435         Element ctx = doc.createElementNS(null, &quot;namespaceContext&quot;);
 436 
 437         ctx.setAttributeNS(Constants.NamespaceSpecNS, &quot;xmlns:&quot; + prefix.trim(), namespace);
 438 
 439         return ctx;
 440     }
 441 
 442     /**
 443      * Method addReturnToElement
 444      *
 445      * @param e
 446      */
 447     public static void addReturnToElement(Element e) {
 448         if (!ignoreLineBreaks) {
 449             Document doc = e.getOwnerDocument();
 450             e.appendChild(doc.createTextNode(&quot;\n&quot;));
 451         }
 452     }
 453 
 454     public static void addReturnToElement(Document doc, HelperNodeList nl) {
 455         if (!ignoreLineBreaks) {
 456             nl.appendChild(doc.createTextNode(&quot;\n&quot;));
 457         }
 458     }
 459 
 460     public static void addReturnBeforeChild(Element e, Node child) {
 461         if (!ignoreLineBreaks) {
 462             Document doc = e.getOwnerDocument();
 463             e.insertBefore(doc.createTextNode(&quot;\n&quot;), child);
 464         }
 465     }
 466 
 467     public static String encodeToString(byte[] bytes) {
 468         if (ignoreLineBreaks) {
 469             return Base64.getEncoder().encodeToString(bytes);
 470         }
 471         return Base64.getMimeEncoder().encodeToString(bytes);
 472     }
 473 
 474     public static byte[] decode(String encodedString) {
 475         return Base64.getMimeDecoder().decode(encodedString);
 476     }
 477 
 478     public static byte[] decode(byte[] encodedBytes) {
 479         return Base64.getMimeDecoder().decode(encodedBytes);
 480     }
 481 
 482     public static boolean isIgnoreLineBreaks() {
 483         return ignoreLineBreaks;
 484     }
 485 
 486     /**
 487      * Method convertNodelistToSet
 488      *
 489      * @param xpathNodeSet
 490      * @return the set with the nodelist
 491      */
 492     public static Set&lt;Node&gt; convertNodelistToSet(NodeList xpathNodeSet) {
 493         if (xpathNodeSet == null) {
 494             return new HashSet&lt;&gt;();
 495         }
 496 
 497         int length = xpathNodeSet.getLength();
 498         Set&lt;Node&gt; set = new HashSet&lt;&gt;(length);
 499 
 500         for (int i = 0; i &lt; length; i++) {
 501             set.add(xpathNodeSet.item(i));
 502         }
 503 
 504         return set;
 505     }
 506 
 507     /**
 508      * This method spreads all namespace attributes in a DOM document to their
 509      * children. This is needed because the XML Signature XPath transform
 510      * must evaluate the XPath against all nodes in the input, even against
 511      * XPath namespace nodes. Through a bug in XalanJ2, the namespace nodes are
 512      * not fully visible in the Xalan XPath model, so we have to do this by
 513      * hand in DOM spaces so that the nodes become visible in XPath space.
 514      *
 515      * @param doc
 516      * @see &lt;A HREF=&quot;http://nagoya.apache.org/bugzilla/show_bug.cgi?id=2650&quot;&gt;
 517      * Namespace axis resolution is not XPath compliant &lt;/A&gt;
 518      */
 519     public static void circumventBug2650(Document doc) {
 520 
 521         Element documentElement = doc.getDocumentElement();
 522 
 523         // if the document element has no xmlns definition, we add xmlns=&quot;&quot;
 524         Attr xmlnsAttr =
 525             documentElement.getAttributeNodeNS(Constants.NamespaceSpecNS, &quot;xmlns&quot;);
 526 
 527         if (xmlnsAttr == null) {
 528             documentElement.setAttributeNS(Constants.NamespaceSpecNS, &quot;xmlns&quot;, &quot;&quot;);
 529         }
 530 
 531         XMLUtils.circumventBug2650internal(doc);
 532     }
 533 
 534     /**
 535      * This is the work horse for {@link #circumventBug2650}.
 536      *
 537      * @param node
 538      * @see &lt;A HREF=&quot;http://nagoya.apache.org/bugzilla/show_bug.cgi?id=2650&quot;&gt;
 539      * Namespace axis resolution is not XPath compliant &lt;/A&gt;
 540      */
 541     @SuppressWarnings(&quot;fallthrough&quot;)
 542     private static void circumventBug2650internal(Node node) {
 543         Node parent = null;
 544         Node sibling = null;
 545         final String namespaceNs = Constants.NamespaceSpecNS;
 546         do {
 547             switch (node.getNodeType()) {
 548             case Node.ELEMENT_NODE :
 549                 Element element = (Element) node;
 550                 if (!element.hasChildNodes()) {
 551                     break;
 552                 }
 553                 if (element.hasAttributes()) {
 554                     NamedNodeMap attributes = element.getAttributes();
 555                     int attributesLength = attributes.getLength();
 556 
 557                     for (Node child = element.getFirstChild(); child!=null;
 558                         child = child.getNextSibling()) {
 559 
 560                         if (child.getNodeType() != Node.ELEMENT_NODE) {
 561                             continue;
 562                         }
 563                         Element childElement = (Element) child;
 564 
 565                         for (int i = 0; i &lt; attributesLength; i++) {
 566                             Attr currentAttr = (Attr) attributes.item(i);
 567                             if (!namespaceNs.equals(currentAttr.getNamespaceURI())) {
 568                                 continue;
 569                             }
 570                             if (childElement.hasAttributeNS(namespaceNs,
 571                                                             currentAttr.getLocalName())) {
 572                                 continue;
 573                             }
 574                             childElement.setAttributeNS(namespaceNs,
 575                                                         currentAttr.getName(),
 576                                                         currentAttr.getNodeValue());
 577                         }
 578                     }
 579                 }
 580             case Node.ENTITY_REFERENCE_NODE :
 581             case Node.DOCUMENT_NODE :
 582                 parent = node;
 583                 sibling = node.getFirstChild();
 584                 break;
 585             }
 586             while (sibling == null &amp;&amp; parent != null) {
 587                 sibling = parent.getNextSibling();
 588                 parent = parent.getParentNode();
 589             }
 590             if (sibling == null) {
 591                 return;
 592             }
 593 
 594             node = sibling;
 595             sibling = node.getNextSibling();
 596         } while (true);
 597     }
 598 
 599     /**
 600      * @param sibling
 601      * @param nodeName
 602      * @param number
 603      * @return nodes with the constraint
 604      */
 605     public static Element selectDsNode(Node sibling, String nodeName, int number) {
 606         while (sibling != null) {
 607             if (Constants.SignatureSpecNS.equals(sibling.getNamespaceURI())
 608                 &amp;&amp; sibling.getLocalName().equals(nodeName)) {
 609                 if (number == 0){
 610                     return (Element)sibling;
 611                 }
 612                 number--;
 613             }
 614             sibling = sibling.getNextSibling();
 615         }
 616         return null;
 617     }
 618 
 619     /**
 620      * @param sibling
 621      * @param nodeName
 622      * @param number
 623      * @return nodes with the constraint
 624      */
 625     public static Element selectDs11Node(Node sibling, String nodeName, int number) {
 626         while (sibling != null) {
 627             if (Constants.SignatureSpec11NS.equals(sibling.getNamespaceURI())
 628                 &amp;&amp; sibling.getLocalName().equals(nodeName)) {
 629                 if (number == 0){
 630                     return (Element)sibling;
 631                 }
 632                 number--;
 633             }
 634             sibling = sibling.getNextSibling();
 635         }
 636         return null;
 637     }
 638 
 639     /**
 640      * @param sibling
 641      * @param nodeName
 642      * @param number
 643      * @return nodes with the constrain
 644      */
 645     public static Text selectDsNodeText(Node sibling, String nodeName, int number) {
 646         Node n = selectDsNode(sibling, nodeName, number);
 647         if (n == null) {
 648             return null;
 649         }
 650         n = n.getFirstChild();
 651         while (n != null &amp;&amp; n.getNodeType() != Node.TEXT_NODE) {
 652             n = n.getNextSibling();
 653         }
 654         return (Text)n;
 655     }
 656 
 657     /**
 658      * @param sibling
 659      * @param nodeName
 660      * @param number
 661      * @return nodes with the constrain
 662      */
 663     public static Text selectDs11NodeText(Node sibling, String nodeName, int number) {
 664         Node n = selectDs11Node(sibling, nodeName, number);
 665         if (n == null) {
 666             return null;
 667         }
 668         n = n.getFirstChild();
 669         while (n != null &amp;&amp; n.getNodeType() != Node.TEXT_NODE) {
 670             n = n.getNextSibling();
 671         }
 672         return (Text)n;
 673     }
 674 
 675     /**
 676      * @param sibling
 677      * @param uri
 678      * @param nodeName
 679      * @param number
 680      * @return nodes with the constrain
 681      */
 682     public static Text selectNodeText(Node sibling, String uri, String nodeName, int number) {
 683         Node n = selectNode(sibling, uri, nodeName, number);
 684         if (n == null) {
 685             return null;
 686         }
 687         n = n.getFirstChild();
 688         while (n != null &amp;&amp; n.getNodeType() != Node.TEXT_NODE) {
 689             n = n.getNextSibling();
 690         }
 691         return (Text)n;
 692     }
 693 
 694     /**
 695      * @param sibling
 696      * @param uri
 697      * @param nodeName
 698      * @param number
 699      * @return nodes with the constrain
 700      */
 701     public static Element selectNode(Node sibling, String uri, String nodeName, int number) {
 702         while (sibling != null) {
 703             if (sibling.getNamespaceURI() != null &amp;&amp; sibling.getNamespaceURI().equals(uri)
 704                 &amp;&amp; sibling.getLocalName().equals(nodeName)) {
<a name="18" id="anc18"></a><span class="line-modified"> 705                 if (number == 0) {</span>
 706                     return (Element)sibling;
 707                 }
 708                 number--;
 709             }
 710             sibling = sibling.getNextSibling();
 711         }
 712         return null;
 713     }
 714 
 715     /**
 716      * @param sibling
 717      * @param nodeName
 718      * @return nodes with the constrain
 719      */
 720     public static Element[] selectDsNodes(Node sibling, String nodeName) {
 721         return selectNodes(sibling, Constants.SignatureSpecNS, nodeName);
 722     }
 723 
 724     /**
 725      * @param sibling
 726      * @param nodeName
 727      * @return nodes with the constrain
 728      */
 729     public static Element[] selectDs11Nodes(Node sibling, String nodeName) {
 730         return selectNodes(sibling, Constants.SignatureSpec11NS, nodeName);
 731     }
 732 
 733     /**
 734      * @param sibling
 735      * @param uri
 736      * @param nodeName
 737      * @return nodes with the constraint
 738      */
 739     public static Element[] selectNodes(Node sibling, String uri, String nodeName) {
 740         List&lt;Element&gt; list = new ArrayList&lt;&gt;();
 741         while (sibling != null) {
 742             if (sibling.getNamespaceURI() != null &amp;&amp; sibling.getNamespaceURI().equals(uri)
 743                 &amp;&amp; sibling.getLocalName().equals(nodeName)) {
 744                 list.add((Element)sibling);
 745             }
 746             sibling = sibling.getNextSibling();
 747         }
 748         return list.toArray(new Element[list.size()]);
 749     }
 750 
 751     /**
 752      * @param signatureElement
 753      * @param inputSet
 754      * @return nodes with the constrain
 755      */
 756     public static Set&lt;Node&gt; excludeNodeFromSet(Node signatureElement, Set&lt;Node&gt; inputSet) {
 757         Set&lt;Node&gt; resultSet = new HashSet&lt;&gt;();
 758         Iterator&lt;Node&gt; iterator = inputSet.iterator();
 759 
 760         while (iterator.hasNext()) {
 761             Node inputNode = iterator.next();
 762 
 763             if (!XMLUtils.isDescendantOrSelf(signatureElement, inputNode)) {
 764                 resultSet.add(inputNode);
 765             }
 766         }
 767         return resultSet;
 768     }
 769 
 770     /**
 771      * Method getStrFromNode
 772      *
 773      * @param xpathnode
 774      * @return the string for the node.
 775      */
 776     public static String getStrFromNode(Node xpathnode) {
 777         if (xpathnode.getNodeType() == Node.TEXT_NODE) {
 778             // we iterate over all siblings of the context node because eventually,
 779             // the text is &quot;polluted&quot; with pi&#39;s or comments
 780             StringBuilder sb = new StringBuilder();
 781 
 782             for (Node currentSibling = xpathnode.getParentNode().getFirstChild();
 783                 currentSibling != null;
 784                 currentSibling = currentSibling.getNextSibling()) {
 785                 if (currentSibling.getNodeType() == Node.TEXT_NODE) {
 786                     sb.append(((Text) currentSibling).getData());
 787                 }
 788             }
 789 
 790             return sb.toString();
 791         } else if (xpathnode.getNodeType() == Node.ATTRIBUTE_NODE) {
 792             return xpathnode.getNodeValue();
 793         } else if (xpathnode.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
 794             return xpathnode.getNodeValue();
 795         }
 796 
 797         return null;
 798     }
 799 
 800     /**
 801      * Returns true if the descendantOrSelf is on the descendant-or-self axis
 802      * of the context node.
 803      *
 804      * @param ctx
 805      * @param descendantOrSelf
 806      * @return true if the node is descendant
 807      */
 808     public static boolean isDescendantOrSelf(Node ctx, Node descendantOrSelf) {
 809         if (ctx == descendantOrSelf) {
 810             return true;
 811         }
 812 
 813         Node parent = descendantOrSelf;
 814 
 815         while (true) {
 816             if (parent == null) {
 817                 return false;
 818             }
 819 
 820             if (parent == ctx) {
 821                 return true;
 822             }
 823 
 824             if (parent.getNodeType() == Node.ATTRIBUTE_NODE) {
 825                 parent = ((Attr) parent).getOwnerElement();
 826             } else {
 827                 parent = parent.getParentNode();
 828             }
 829         }
 830     }
 831 
 832     public static boolean ignoreLineBreaks() {
 833         return ignoreLineBreaks;
 834     }
 835 
 836     /**
 837      * Returns the attribute value for the attribute with the specified name.
 838      * Returns null if there is no such attribute, or
 839      * the empty string if the attribute value is empty.
 840      *
 841      * &lt;p&gt;This works around a limitation of the DOM
 842      * {@code Element.getAttributeNode} method, which does not distinguish
 843      * between an unspecified attribute and an attribute with a value of
 844      * &quot;&quot; (it returns &quot;&quot; for both cases).
 845      *
 846      * @param elem the element containing the attribute
 847      * @param name the name of the attribute
 848      * @return the attribute value (may be null if unspecified)
 849      */
 850     public static String getAttributeValue(Element elem, String name) {
 851         Attr attr = elem.getAttributeNodeNS(null, name);
 852         return (attr == null) ? null : attr.getValue();
 853     }
 854 
 855     /**
 856      * This method is a tree-search to help prevent against wrapping attacks. It checks that no
 857      * two Elements have ID Attributes that match the &quot;value&quot; argument, if this is the case then
 858      * &quot;false&quot; is returned. Note that a return value of &quot;true&quot; does not necessarily mean that
 859      * a matching Element has been found, just that no wrapping attack has been detected.
 860      */
 861     public static boolean protectAgainstWrappingAttack(Node startNode, String value) {
 862         String id = value.trim();
 863         if (!id.isEmpty() &amp;&amp; id.charAt(0) == &#39;#&#39;) {
 864             id = id.substring(1);
 865         }
 866 
 867         Node startParent = null;
 868         Node processedNode = null;
 869         Element foundElement = null;
 870         if (startNode != null) {
 871             startParent = startNode.getParentNode();
 872         }
 873 
 874         while (startNode != null) {
 875             if (startNode.getNodeType() == Node.ELEMENT_NODE) {
 876                 Element se = (Element) startNode;
 877 
 878                 NamedNodeMap attributes = se.getAttributes();
 879                 if (attributes != null) {
 880                     int length = attributes.getLength();
 881                     for (int i = 0; i &lt; length; i++) {
 882                         Attr attr = (Attr)attributes.item(i);
 883                         if (attr.isId() &amp;&amp; id.equals(attr.getValue())) {
 884                             if (foundElement == null) {
 885                                 // Continue searching to find duplicates
 886                                 foundElement = attr.getOwnerElement();
 887                             } else {
 888                                 LOG.debug(&quot;Multiple elements with the same &#39;Id&#39; attribute value!&quot;);
 889                                 return false;
 890                             }
 891                         }
 892                     }
 893                 }
 894             }
 895 
 896             processedNode = startNode;
 897             startNode = startNode.getFirstChild();
 898 
 899             // no child, this node is done.
 900             if (startNode == null) {
 901                 // close node processing, get sibling
 902                 startNode = processedNode.getNextSibling();
 903             }
 904 
 905             // no more siblings, get parent, all children
 906             // of parent are processed.
 907             while (startNode == null) {
 908                 processedNode = processedNode.getParentNode();
 909                 if (processedNode == startParent) {
 910                     return true;
 911                 }
 912                 // close parent node processing (processed node now)
 913                 startNode = processedNode.getNextSibling();
 914             }
 915         }
 916         return true;
 917     }
 918 
 919     /**
 920      * This method is a tree-search to help prevent against wrapping attacks. It checks that no other
 921      * Element than the given &quot;knownElement&quot; argument has an ID attribute that matches the &quot;value&quot;
 922      * argument, which is the ID value of &quot;knownElement&quot;. If this is the case then &quot;false&quot; is returned.
 923      */
 924     public static boolean protectAgainstWrappingAttack(
 925         Node startNode, Element knownElement, String value
 926     ) {
 927         String id = value.trim();
 928         if (!id.isEmpty() &amp;&amp; id.charAt(0) == &#39;#&#39;) {
 929             id = id.substring(1);
 930         }
 931 
 932         Node startParent = null;
 933         Node processedNode = null;
 934         if (startNode != null) {
 935             startParent = startNode.getParentNode();
 936         }
 937 
 938         while (startNode != null) {
 939             if (startNode.getNodeType() == Node.ELEMENT_NODE) {
 940                 Element se = (Element) startNode;
 941 
 942                 NamedNodeMap attributes = se.getAttributes();
 943                 if (attributes != null) {
 944                     int length = attributes.getLength();
 945                     for (int i = 0; i &lt; length; i++) {
 946                         Attr attr = (Attr)attributes.item(i);
 947                         if (attr.isId() &amp;&amp; id.equals(attr.getValue()) &amp;&amp; se != knownElement) {
 948                             LOG.debug(&quot;Multiple elements with the same &#39;Id&#39; attribute value!&quot;);
 949                             return false;
 950                         }
 951                     }
 952                 }
 953             }
 954 
 955             processedNode = startNode;
 956             startNode = startNode.getFirstChild();
 957 
 958             // no child, this node is done.
 959             if (startNode == null) {
 960                 // close node processing, get sibling
 961                 startNode = processedNode.getNextSibling();
 962             }
 963 
 964             // no more siblings, get parent, all children
 965             // of parent are processed.
 966             while (startNode == null) {
 967                 processedNode = processedNode.getParentNode();
 968                 if (processedNode == startParent) {
 969                     return true;
 970                 }
 971                 // close parent node processing (processed node now)
 972                 startNode = processedNode.getNextSibling();
 973             }
 974         }
 975         return true;
 976     }
 977 
<a name="19" id="anc19"></a><span class="line-modified"> 978     public static Document newDocument() throws ParserConfigurationException {</span>
<span class="line-modified"> 979         ClassLoader loader = getContextClassLoader();</span>
<span class="line-added"> 980         if (loader == null) {</span>
<span class="line-added"> 981             loader = getClassLoader(XMLUtils.class);</span>
<span class="line-added"> 982         }</span>
<span class="line-added"> 983         // If the ClassLoader is null then just create a DocumentBuilder and use it</span>
<span class="line-added"> 984         if (loader == null) {</span>
<span class="line-added"> 985             DocumentBuilder documentBuilder = buildDocumentBuilder(true);</span>
<span class="line-added"> 986             return documentBuilder.newDocument();</span>
<span class="line-added"> 987         }</span>
<span class="line-added"> 988 </span>
<span class="line-added"> 989         Queue&lt;DocumentBuilder&gt; queue = getDocumentBuilderQueue(true, loader);</span>
<span class="line-added"> 990         DocumentBuilder documentBuilder = getDocumentBuilder(true, queue);</span>
<span class="line-added"> 991         Document doc = documentBuilder.newDocument();</span>
<span class="line-added"> 992         repoolDocumentBuilder(documentBuilder, queue);</span>
<span class="line-added"> 993         return doc;</span>
<span class="line-added"> 994     }</span>
<span class="line-added"> 995 </span>
<span class="line-added"> 996     public static Document read(InputStream inputStream) throws ParserConfigurationException, SAXException, IOException {</span>
<span class="line-added"> 997         return read(inputStream, true);</span>
<span class="line-added"> 998     }</span>
<span class="line-added"> 999 </span>
<span class="line-added">1000     public static Document read(InputStream inputStream, boolean disAllowDocTypeDeclarations) throws ParserConfigurationException, SAXException, IOException {</span>
<span class="line-added">1001         ClassLoader loader = getContextClassLoader();</span>
<span class="line-added">1002         if (loader == null) {</span>
<span class="line-added">1003             loader = getClassLoader(XMLUtils.class);</span>
<span class="line-added">1004         }</span>
<span class="line-added">1005         // If the ClassLoader is null then just create a DocumentBuilder and use it</span>
<span class="line-added">1006         if (loader == null) {</span>
<span class="line-added">1007             DocumentBuilder documentBuilder = buildDocumentBuilder(disAllowDocTypeDeclarations);</span>
<span class="line-added">1008             return documentBuilder.parse(inputStream);</span>
<span class="line-added">1009         }</span>
<span class="line-added">1010 </span>
<span class="line-added">1011         Queue&lt;DocumentBuilder&gt; queue = getDocumentBuilderQueue(disAllowDocTypeDeclarations, loader);</span>
<span class="line-added">1012         DocumentBuilder documentBuilder = getDocumentBuilder(disAllowDocTypeDeclarations, queue);</span>
<span class="line-added">1013         Document doc = documentBuilder.parse(inputStream);</span>
<span class="line-added">1014         repoolDocumentBuilder(documentBuilder, queue);</span>
<span class="line-added">1015         return doc;</span>
<span class="line-added">1016     }</span>
<span class="line-added">1017 </span>
<span class="line-added">1018     public static Document read(String uri, boolean disAllowDocTypeDeclarations)</span>
<span class="line-added">1019         throws ParserConfigurationException, SAXException, IOException {</span>
<span class="line-added">1020         ClassLoader loader = getContextClassLoader();</span>
<span class="line-added">1021         if (loader == null) {</span>
<span class="line-added">1022             loader = getClassLoader(XMLUtils.class);</span>
<span class="line-added">1023         }</span>
<span class="line-added">1024         // If the ClassLoader is null then just create a DocumentBuilder and use it</span>
<span class="line-added">1025         if (loader == null) {</span>
<span class="line-added">1026             DocumentBuilder documentBuilder = buildDocumentBuilder(disAllowDocTypeDeclarations);</span>
<span class="line-added">1027             return documentBuilder.parse(uri);</span>
<span class="line-added">1028         }</span>
<span class="line-added">1029 </span>
<span class="line-added">1030         Queue&lt;DocumentBuilder&gt; queue = getDocumentBuilderQueue(disAllowDocTypeDeclarations, loader);</span>
<span class="line-added">1031         DocumentBuilder documentBuilder = getDocumentBuilder(disAllowDocTypeDeclarations, queue);</span>
<span class="line-added">1032         Document doc = documentBuilder.parse(uri);</span>
<span class="line-added">1033         repoolDocumentBuilder(documentBuilder, queue);</span>
<span class="line-added">1034         return doc;</span>
<span class="line-added">1035     }</span>
<span class="line-added">1036 </span>
<span class="line-added">1037     public static Document read(InputSource inputSource) throws ParserConfigurationException, SAXException, IOException {</span>
<span class="line-added">1038         return read(inputSource, true);</span>
<span class="line-added">1039     }</span>
<span class="line-added">1040 </span>
<span class="line-added">1041     public static Document read(InputSource inputSource, boolean disAllowDocTypeDeclarations)</span>
<span class="line-added">1042         throws ParserConfigurationException, SAXException, IOException {</span>
<span class="line-added">1043         ClassLoader loader = getContextClassLoader();</span>
<span class="line-added">1044         if (loader == null) {</span>
<span class="line-added">1045             loader = getClassLoader(XMLUtils.class);</span>
<span class="line-added">1046         }</span>
<span class="line-added">1047         // If the ClassLoader is null then just create a DocumentBuilder and use it</span>
<span class="line-added">1048         if (loader == null) {</span>
<span class="line-added">1049             DocumentBuilder documentBuilder = buildDocumentBuilder(disAllowDocTypeDeclarations);</span>
<span class="line-added">1050             return documentBuilder.parse(inputSource);</span>
<span class="line-added">1051         }</span>
<span class="line-added">1052 </span>
<span class="line-added">1053         Queue&lt;DocumentBuilder&gt; queue = getDocumentBuilderQueue(disAllowDocTypeDeclarations, loader);</span>
<span class="line-added">1054         DocumentBuilder documentBuilder = getDocumentBuilder(disAllowDocTypeDeclarations, queue);</span>
<span class="line-added">1055         Document doc = documentBuilder.parse(inputSource);</span>
<span class="line-added">1056         repoolDocumentBuilder(documentBuilder, queue);</span>
<span class="line-added">1057         return doc;</span>
<span class="line-added">1058     }</span>
<span class="line-added">1059 </span>
<span class="line-added">1060     /**</span>
<span class="line-added">1061      * @deprecated Use XMLUtils.read instead to directly read a document.</span>
<span class="line-added">1062      */</span>
<span class="line-added">1063     @Deprecated</span>
<span class="line-added">1064     public static DocumentBuilder createDocumentBuilder(boolean validating) throws ParserConfigurationException {</span>
1065         return createDocumentBuilder(validating, true);
1066     }
1067 
<a name="20" id="anc20"></a><span class="line-modified">1068     /**</span>
<span class="line-modified">1069      * @deprecated Use XMLUtils.read instead to directly read a document.</span>
<span class="line-added">1070      */</span>
<span class="line-added">1071     @Deprecated</span>
1072     public static DocumentBuilder createDocumentBuilder(
1073         boolean validating, boolean disAllowDocTypeDeclarations
1074     ) throws ParserConfigurationException {
1075         DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();
<a name="21" id="anc21"></a><span class="line-modified">1076         dfactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE);</span>
1077         if (disAllowDocTypeDeclarations) {
1078             dfactory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
1079         }
1080         dfactory.setValidating(validating);
1081         dfactory.setNamespaceAware(true);
1082         return dfactory.newDocumentBuilder();
1083     }
1084 
<a name="22" id="anc22"></a><span class="line-added">1085     /**</span>
<span class="line-added">1086      * @deprecated This method has no effect in Santuario 2.1.4</span>
<span class="line-added">1087      */</span>
<span class="line-added">1088     @Deprecated</span>
<span class="line-added">1089     public static boolean repoolDocumentBuilder(DocumentBuilder db) {</span>
<span class="line-added">1090         return true;</span>
<span class="line-added">1091     }</span>
<span class="line-added">1092 </span>
1093     /**
1094      * Returns a byte-array representation of a {@code {@link BigInteger}}.
1095      * No sign-bit is output.
1096      *
1097      * &lt;b&gt;N.B.:&lt;/B&gt; {@code {@link BigInteger}}&#39;s toByteArray
1098      * returns eventually longer arrays because of the leading sign-bit.
1099      *
1100      * @param big {@code BigInteger} to be converted
1101      * @param bitlen {@code int} the desired length in bits of the representation
1102      * @return a byte array with {@code bitlen} bits of {@code big}
1103      */
1104     public static byte[] getBytes(BigInteger big, int bitlen) {
1105 
1106         //round bitlen
1107         bitlen = ((bitlen + 7) &gt;&gt; 3) &lt;&lt; 3;
1108 
1109         if (bitlen &lt; big.bitLength()) {
1110             throw new IllegalArgumentException(I18n.translate(&quot;utils.Base64.IllegalBitlength&quot;));
1111         }
1112 
1113         byte[] bigBytes = big.toByteArray();
1114 
1115         if (big.bitLength() % 8 != 0
1116             &amp;&amp; big.bitLength() / 8 + 1 == bitlen / 8) {
1117             return bigBytes;
1118         }
1119 
1120         // some copying needed
1121         int startSrc = 0;    // no need to skip anything
1122         int bigLen = bigBytes.length;    //valid length of the string
1123 
1124         if (big.bitLength() % 8 == 0) {    // correct values
1125             startSrc = 1;    // skip sign bit
1126 
1127             bigLen--;    // valid length of the string
1128         }
1129 
1130         int startDst = bitlen / 8 - bigLen;    //pad with leading nulls
1131         byte[] resizedBytes = new byte[bitlen / 8];
1132 
1133         System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, bigLen);
1134 
1135         return resizedBytes;
1136     }
<a name="23" id="anc23"></a><span class="line-added">1137 </span>
<span class="line-added">1138     private static Queue&lt;DocumentBuilder&gt; getDocumentBuilderQueue(boolean disAllowDocTypeDeclarations, ClassLoader loader) throws ParserConfigurationException {</span>
<span class="line-added">1139         Map&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt; docBuilderCache =</span>
<span class="line-added">1140             disAllowDocTypeDeclarations ? DOCUMENT_BUILDERS_DISALLOW_DOCTYPE : DOCUMENT_BUILDERS;</span>
<span class="line-added">1141         Queue&lt;DocumentBuilder&gt; queue = docBuilderCache.get(loader);</span>
<span class="line-added">1142         if (queue == null) {</span>
<span class="line-added">1143             queue = new ArrayBlockingQueue&lt;&gt;(parserPoolSize);</span>
<span class="line-added">1144             docBuilderCache.put(loader, queue);</span>
<span class="line-added">1145         }</span>
<span class="line-added">1146 </span>
<span class="line-added">1147         return queue;</span>
<span class="line-added">1148     }</span>
<span class="line-added">1149 </span>
<span class="line-added">1150     private static DocumentBuilder getDocumentBuilder(boolean disAllowDocTypeDeclarations, Queue&lt;DocumentBuilder&gt; queue) throws ParserConfigurationException {</span>
<span class="line-added">1151         DocumentBuilder db = queue.poll();</span>
<span class="line-added">1152         if (db == null) {</span>
<span class="line-added">1153             db = buildDocumentBuilder(disAllowDocTypeDeclarations);</span>
<span class="line-added">1154         }</span>
<span class="line-added">1155         return db;</span>
<span class="line-added">1156     }</span>
<span class="line-added">1157 </span>
<span class="line-added">1158     private static DocumentBuilder buildDocumentBuilder(boolean disAllowDocTypeDeclarations) throws ParserConfigurationException {</span>
<span class="line-added">1159         DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();</span>
<span class="line-added">1160         f.setNamespaceAware(true);</span>
<span class="line-added">1161         f.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);</span>
<span class="line-added">1162         f.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, disAllowDocTypeDeclarations);</span>
<span class="line-added">1163         return f.newDocumentBuilder();</span>
<span class="line-added">1164     }</span>
<span class="line-added">1165 </span>
<span class="line-added">1166     private static void repoolDocumentBuilder(DocumentBuilder db, Queue&lt;DocumentBuilder&gt; queue) {</span>
<span class="line-added">1167         if (queue != null) {</span>
<span class="line-added">1168             db.reset();</span>
<span class="line-added">1169             queue.offer(db);</span>
<span class="line-added">1170         }</span>
<span class="line-added">1171     }</span>
<span class="line-added">1172 </span>
<span class="line-added">1173     private static ClassLoader getContextClassLoader() {</span>
<span class="line-added">1174         final SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">1175         if (sm != null) {</span>
<span class="line-added">1176             return AccessController.doPrivileged(new PrivilegedAction&lt;ClassLoader&gt;() {</span>
<span class="line-added">1177                 public ClassLoader run() {</span>
<span class="line-added">1178                     return Thread.currentThread().getContextClassLoader();</span>
<span class="line-added">1179                 }</span>
<span class="line-added">1180             });</span>
<span class="line-added">1181         }</span>
<span class="line-added">1182         return Thread.currentThread().getContextClassLoader();</span>
<span class="line-added">1183     }</span>
<span class="line-added">1184 </span>
<span class="line-added">1185     private static ClassLoader getClassLoader(final Class&lt;?&gt; clazz) {</span>
<span class="line-added">1186         final SecurityManager sm = System.getSecurityManager();</span>
<span class="line-added">1187         if (sm != null) {</span>
<span class="line-added">1188             return AccessController.doPrivileged(new PrivilegedAction&lt;ClassLoader&gt;() {</span>
<span class="line-added">1189                 public ClassLoader run() {</span>
<span class="line-added">1190                     return clazz.getClassLoader();</span>
<span class="line-added">1191                 }</span>
<span class="line-added">1192             });</span>
<span class="line-added">1193         }</span>
<span class="line-added">1194         return clazz.getClassLoader();</span>
<span class="line-added">1195     }</span>
<span class="line-added">1196 </span>
1197 }
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/Manifest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.signature;
 24 
 25 import java.io.IOException;
 26 import java.security.AccessController;
 27 import java.security.PrivilegedAction;
 28 import java.util.ArrayList;
 29 import java.util.Collections;
 30 import java.util.HashMap;
 31 import java.util.Iterator;
 32 import java.util.List;
 33 import java.util.Map;
 34 import java.util.Set;
 35 
 36 import javax.xml.parsers.ParserConfigurationException;
 37 
 38 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 39 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
 40 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 41 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
 42 import com.sun.org.apache.xml.internal.security.utils.Constants;
 43 import com.sun.org.apache.xml.internal.security.utils.I18n;
 44 import com.sun.org.apache.xml.internal.security.utils.SignatureElementProxy;
 45 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 46 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;
 47 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverSpi;
 48 import org.w3c.dom.Attr;
 49 import org.w3c.dom.DOMException;
 50 import org.w3c.dom.Document;
 51 import org.w3c.dom.Element;
 52 import org.w3c.dom.Node;
 53 import org.xml.sax.SAXException;
 54 
 55 /**
 56  * Handles {@code &amp;lt;ds:Manifest&amp;gt;} elements.
 57  * &lt;p&gt; This element holds the {@code Reference} elements&lt;/p&gt;
 58  */
 59 public class Manifest extends SignatureElementProxy {
 60 
 61     /**
 62      * The default maximum number of references per Manifest, if secure validation is enabled.
 63      */
 64     public static final int MAXIMUM_REFERENCE_COUNT = 30;
 65 
 66     private static final com.sun.org.slf4j.internal.Logger LOG =
 67         com.sun.org.slf4j.internal.LoggerFactory.getLogger(Manifest.class);
 68 
 69     private static Integer referenceCount =
 70         AccessController.doPrivileged(
 71             (PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.parseInt(System.getProperty(&quot;com.sun.org.apache.xml.internal.security.maxReferences&quot;,
 72                                                                 Integer.toString(MAXIMUM_REFERENCE_COUNT))));
 73 
 74     /** Field references */
 75     private List&lt;Reference&gt; references;
 76     private Element[] referencesEl;
 77 
 78     /** Field verificationResults[] */
 79     private List&lt;VerifiedReference&gt; verificationResults;
 80 
 81     /** Field resolverProperties */
 82     private Map&lt;String, String&gt; resolverProperties;
 83 
 84     /** Field perManifestResolvers */
 85     private List&lt;ResourceResolver&gt; perManifestResolvers;
 86 
 87     private boolean secureValidation;
 88 
 89     /**
 90      * Constructs {@link Manifest}
 91      *
 92      * @param doc the {@link Document} in which {@code XMLsignature} is placed
 93      */
 94     public Manifest(Document doc) {
 95         super(doc);
 96 
 97         addReturnToSelf();
 98 
 99         this.references = new ArrayList&lt;&gt;();
100     }
101 
102     /**
103      * Constructor Manifest
104      *
105      * @param element
106      * @param baseURI
107      * @throws XMLSecurityException
108      */
109     public Manifest(Element element, String baseURI) throws XMLSecurityException {
110         this(element, baseURI, true);
111 
112     }
113     /**
114      * Constructor Manifest
115      *
116      * @param element
117      * @param baseURI
118      * @param secureValidation
119      * @throws XMLSecurityException
120      */
121     public Manifest(
122         Element element, String baseURI, boolean secureValidation
123     ) throws XMLSecurityException {
124         super(element, baseURI);
125 
126         Attr attr = element.getAttributeNodeNS(null, &quot;Id&quot;);
127         if (attr != null) {
128             element.setIdAttributeNode(attr, true);
129         }
130         this.secureValidation = secureValidation;
131 
132         // check out Reference children
133         this.referencesEl =
134             XMLUtils.selectDsNodes(
135                 getFirstChild(), Constants._TAG_REFERENCE
136             );
137         int le = this.referencesEl.length;
138         if (le == 0) {
139             // At least one Reference must be present. Bad.
140             Object exArgs[] = { Constants._TAG_REFERENCE, Constants._TAG_MANIFEST };
141 
142             throw new DOMException(DOMException.WRONG_DOCUMENT_ERR,
143                                    I18n.translate(&quot;xml.WrongContent&quot;, exArgs));
144         }
145 
146         if (secureValidation &amp;&amp; le &gt; referenceCount) {
147             Object exArgs[] = { le, referenceCount };
148 
149             throw new XMLSecurityException(&quot;signature.tooManyReferences&quot;, exArgs);
150         }
151 
152         // create List
153         this.references = new ArrayList&lt;&gt;(le);
154 
155         for (int i = 0; i &lt; le; i++) {
156             Element refElem = referencesEl[i];
157             Attr refAttr = refElem.getAttributeNodeNS(null, &quot;Id&quot;);
158             if (refAttr != null) {
159                 refElem.setIdAttributeNode(refAttr, true);
160             }
161             this.references.add(null);
162         }
163     }
164 
165     /**
166      * This {@code addDocument} method is used to add a new resource to the
167      * signed info. A {@link com.sun.org.apache.xml.internal.security.signature.Reference} is built
168      * from the supplied values.
169      *
170      * @param baseURI the URI of the resource where the XML instance was stored
171      * @param referenceURI {@code URI} attribute in {@code Reference} for specifying
172      * where data is
173      * @param transforms com.sun.org.apache.xml.internal.security.signature.Transforms object with an ordered
174      * list of transformations to be performed.
175      * @param digestURI The digest algorithm URI to be used.
176      * @param referenceId
177      * @param referenceType
178      * @throws XMLSignatureException
179      */
180     public void addDocument(
181         String baseURI, String referenceURI, Transforms transforms,
182         String digestURI, String referenceId, String referenceType
183     ) throws XMLSignatureException {
184         // the this.doc is handed implicitly by the this.getOwnerDocument()
185         Reference ref =
186             new Reference(getDocument(), baseURI, referenceURI, this, transforms, digestURI);
187 
188         if (referenceId != null) {
189             ref.setId(referenceId);
190         }
191 
192         if (referenceType != null) {
193             ref.setType(referenceType);
194         }
195 
196         // add Reference object to our cache vector
197         this.references.add(ref);
198 
199         // add the Element of the Reference object to the Manifest/SignedInfo
200         appendSelf(ref);
201         addReturnToSelf();
202     }
203 
204     /**
205      * The calculation of the DigestValues in the References must be after the
206      * References are already added to the document and during the signing
207      * process. This ensures that all necessary data is in place.
208      *
209      * @throws ReferenceNotInitializedException
210      * @throws XMLSignatureException
211      */
212     public void generateDigestValues()
213         throws XMLSignatureException, ReferenceNotInitializedException {
214         for (int i = 0; i &lt; this.getLength(); i++) {
215             // update the cached Reference object, the Element content is automatically updated
216             Reference currentRef = this.references.get(i);
217             currentRef.generateDigestValue();
218         }
219     }
220 
221     /**
222      * Return the nonnegative number of added references.
223      *
224      * @return the number of references
225      */
226     public int getLength() {
227         return this.references.size();
228     }
229 
230     /**
231      * Return the &lt;i&gt;i&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt; reference. Valid {@code i}
232      * values are 0 to {@code {link@ getSize}-1}.
233      *
234      * @param i Index of the requested {@link Reference}
235      * @return the &lt;i&gt;i&lt;/i&gt;&lt;sup&gt;th&lt;/sup&gt; reference
236      * @throws XMLSecurityException
237      */
238     public Reference item(int i) throws XMLSecurityException {
239         if (this.references.get(i) == null) {
240             // not yet constructed, so _we_ have to
241             Reference ref =
242                 new Reference(referencesEl[i], this.baseURI, this, secureValidation);
243 
244             this.references.set(i, ref);
245         }
246 
247         return this.references.get(i);
248     }
249 
250     /**
251      * Sets the {@code Id} attribute
252      *
253      * @param Id the {@code Id} attribute in {@code ds:Manifest}
254      */
255     public void setId(String Id) {
256         if (Id != null) {
257             setLocalIdAttribute(Constants._ATT_ID, Id);
258         }
259     }
260 
261     /**
262      * Returns the {@code Id} attribute
263      *
264      * @return the {@code Id} attribute in {@code ds:Manifest}
265      */
266     public String getId() {
267         return getLocalAttribute(Constants._ATT_ID);
268     }
269 
270     /**
271      * Used to do a &lt;A HREF=&quot;http://www.w3.org/TR/xmldsig-core/#def-ValidationReference&quot;&gt;reference
272      * validation&lt;/A&gt; of all enclosed references using the {@link Reference#verify} method.
273      *
274      * &lt;p&gt;This step loops through all {@link Reference}s and does verify the hash
275      * values. If one or more verifications fail, the method returns
276      * {@code false}. If &lt;i&gt;all&lt;/i&gt; verifications are successful,
277      * it returns {@code true}. The results of the individual reference
278      * validations are available by using the {@link #getVerificationResult(int)} method
279      *
280      * @return true if all References verify, false if one or more do not verify.
281      * @throws MissingResourceFailureException if a {@link Reference} does not verify
282      * (throws a {@link com.sun.org.apache.xml.internal.security.signature.ReferenceNotInitializedException}
283      * because of an uninitialized {@link XMLSignatureInput}
284      * @see com.sun.org.apache.xml.internal.security.signature.Reference#verify
285      * @see com.sun.org.apache.xml.internal.security.signature.SignedInfo#verify()
286      * @see com.sun.org.apache.xml.internal.security.signature.MissingResourceFailureException
287      * @throws XMLSecurityException
288      */
289     public boolean verifyReferences()
290         throws MissingResourceFailureException, XMLSecurityException {
291         return this.verifyReferences(false);
292     }
293 
294     /**
295      * Used to do a &lt;A HREF=&quot;http://www.w3.org/TR/xmldsig-core/#def-ValidationReference&quot;&gt;reference
296      * validation&lt;/A&gt; of all enclosed references using the {@link Reference#verify} method.
297      *
298      * &lt;p&gt;This step loops through all {@link Reference}s and does verify the hash
299      * values. If one or more verifications fail, the method returns
300      * {@code false}. If &lt;i&gt;all&lt;/i&gt; verifications are successful,
301      * it returns {@code true}. The results of the individual reference
302      * validations are available by using the {@link #getVerificationResult(int)} method
303      *
304      * @param followManifests
305      * @return true if all References verify, false if one or more do not verify.
306      * @throws MissingResourceFailureException if a {@link Reference} does not verify
307      * (throws a {@link com.sun.org.apache.xml.internal.security.signature.ReferenceNotInitializedException}
308      * because of an uninitialized {@link XMLSignatureInput}
309      * @see com.sun.org.apache.xml.internal.security.signature.Reference#verify
310      * @see com.sun.org.apache.xml.internal.security.signature.SignedInfo#verify(boolean)
311      * @see com.sun.org.apache.xml.internal.security.signature.MissingResourceFailureException
312      * @throws XMLSecurityException
313      */
314     public boolean verifyReferences(boolean followManifests)
315         throws MissingResourceFailureException, XMLSecurityException {
316         if (referencesEl == null) {
317             this.referencesEl =
318                 XMLUtils.selectDsNodes(
319                     getFirstChild(), Constants._TAG_REFERENCE
320                 );
321         }
322         LOG.debug(&quot;verify {} References&quot;, referencesEl.length);
323         LOG.debug(&quot;I am {} requested to follow nested Manifests&quot;, (followManifests
324             ? &quot;&quot; : &quot;not&quot;));
325         if (referencesEl.length == 0) {
326             throw new XMLSecurityException(&quot;empty&quot;, new Object[]{&quot;References are empty&quot;});
327         }
328         if (secureValidation &amp;&amp; referencesEl.length &gt; referenceCount) {
329             Object exArgs[] = { referencesEl.length, referenceCount };
330 
331             throw new XMLSecurityException(&quot;signature.tooManyReferences&quot;, exArgs);
332         }
333 
334         this.verificationResults = new ArrayList&lt;&gt;(referencesEl.length);
335         boolean verify = true;
336         for (int i = 0; i &lt; this.referencesEl.length; i++) {
337             Reference currentRef =
338                 new Reference(referencesEl[i], this.baseURI, this, secureValidation);
339 
340             this.references.set(i, currentRef);
341 
342             // if only one item does not verify, the whole verification fails
343             try {
344                 boolean currentRefVerified = currentRef.verify();
345 
346                 if (!currentRefVerified) {
347                     verify = false;
348                 }
349                 LOG.debug(&quot;The Reference has Type {}&quot;, currentRef.getType());
350 
351                 List&lt;VerifiedReference&gt; manifestReferences = Collections.emptyList();
352 
353                 // was verification successful till now and do we want to verify the Manifest?
354                 if (verify &amp;&amp; followManifests &amp;&amp; currentRef.typeIsReferenceToManifest()) {
355                     LOG.debug(&quot;We have to follow a nested Manifest&quot;);
356 
357                     try {
358                         XMLSignatureInput signedManifestNodes =
359                             currentRef.dereferenceURIandPerformTransforms(null);
360                         Set&lt;Node&gt; nl = signedManifestNodes.getNodeSet();
361                         Manifest referencedManifest = null;
362                         Iterator&lt;Node&gt; nlIterator = nl.iterator();
363 
364                         while (nlIterator.hasNext()) {
365                             Node n = nlIterator.next();
366 
367                             if (n.getNodeType() == Node.ELEMENT_NODE
368                                 &amp;&amp; ((Element) n).getNamespaceURI().equals(Constants.SignatureSpecNS)
369                                 &amp;&amp; ((Element) n).getLocalName().equals(Constants._TAG_MANIFEST)
370                             ) {
371                                 try {
372                                     referencedManifest =
373                                         new Manifest(
374                                              (Element)n, signedManifestNodes.getSourceURI(), secureValidation
375                                         );
376                                     break;
377                                 } catch (XMLSecurityException ex) {
378                                     LOG.debug(ex.getMessage(), ex);
379                                     // Hm, seems not to be a ds:Manifest
380                                 }
381                             }
382                         }
383 
384                         if (referencedManifest == null) {
385                             // The Reference stated that it points to a ds:Manifest
386                             // but we did not find a ds:Manifest in the signed area
387                             throw new MissingResourceFailureException(currentRef, &quot;empty&quot;,
388                                                                       new Object[]{&quot;No Manifest found&quot;});
389                         }
390 
391                         referencedManifest.perManifestResolvers = this.perManifestResolvers;
392                         referencedManifest.resolverProperties = this.resolverProperties;
393 
394                         boolean referencedManifestValid =
395                             referencedManifest.verifyReferences(followManifests);
396 
397                         if (!referencedManifestValid) {
398                             verify = false;
399 
400                             LOG.warn(&quot;The nested Manifest was invalid (bad)&quot;);
401                         } else {
402                             LOG.debug(&quot;The nested Manifest was valid (good)&quot;);
403                         }
404 
405                         manifestReferences = referencedManifest.getVerificationResults();
406                     } catch (IOException ex) {
407                         throw new ReferenceNotInitializedException(ex);
408                     } catch (ParserConfigurationException ex) {
409                         throw new ReferenceNotInitializedException(ex);
410                     } catch (SAXException ex) {
411                         throw new ReferenceNotInitializedException(ex);
412                     }
413                 }
414 
415                 verificationResults.add(new VerifiedReference(currentRefVerified, currentRef.getURI(), manifestReferences));
416             } catch (ReferenceNotInitializedException ex) {
417                 Object exArgs[] = { currentRef.getURI() };
418 
419                 throw new MissingResourceFailureException(
420                     ex, currentRef, &quot;signature.Verification.Reference.NoInput&quot;, exArgs
421                 );
422             }
423         }
424 
425         return verify;
426     }
427 
428     /**
429      * After verifying a {@link Manifest} or a {@link SignedInfo} using the
430      * {@link Manifest#verifyReferences()} or {@link SignedInfo#verify()} methods,
431      * the individual results can be retrieved with this method.
432      *
433      * @param index an index of into a {@link Manifest} or a {@link SignedInfo}
434      * @return the results of reference validation at the specified index
435      * @throws XMLSecurityException
436      */
437     public boolean getVerificationResult(int index) throws XMLSecurityException {
438         if (index &lt; 0 || index &gt; this.getLength() - 1) {
439             Object exArgs[] = { Integer.toString(index), Integer.toString(this.getLength()) };
440             Exception e =
441                 new IndexOutOfBoundsException(
442                     I18n.translate(&quot;signature.Verification.IndexOutOfBounds&quot;, exArgs)
443                 );
444 
445             throw new XMLSecurityException(e);
446         }
447 
448         if (this.verificationResults == null) {
449             try {
450                 this.verifyReferences();
451             } catch (Exception ex) {
452                 throw new XMLSecurityException(ex);
453             }
454         }
455 
456         return ((ArrayList&lt;VerifiedReference&gt;)verificationResults).get(index).isValid();
457     }
458 
459     /**
460      * Get the list of verification result objects
461      */
462     public List&lt;VerifiedReference&gt; getVerificationResults() {
463         if (verificationResults == null) {
464             return Collections.emptyList();
465         }
466         return Collections.unmodifiableList(verificationResults);
467     }
468 
469     /**
470      * Adds Resource Resolver for retrieving resources at specified {@code URI} attribute
471      * in {@code reference} element
472      *
473      * @param resolver {@link ResourceResolver} can provide the implementation subclass of
474      * {@link ResourceResolverSpi} for retrieving resource.
475      */
476     public void addResourceResolver(ResourceResolver resolver) {
477         if (resolver == null) {
478             return;
479         }
480         if (perManifestResolvers == null) {
481             perManifestResolvers = new ArrayList&lt;&gt;();
482         }
483         this.perManifestResolvers.add(resolver);
484     }
485 
486     /**
487      * Adds Resource Resolver for retrieving resources at specified {@code URI} attribute
488      * in {@code reference} element
489      *
490      * @param resolverSpi the implementation subclass of {@link ResourceResolverSpi} for
491      * retrieving the resource.
492      */
493     public void addResourceResolver(ResourceResolverSpi resolverSpi) {
494         if (resolverSpi == null) {
495             return;
496         }
497         if (perManifestResolvers == null) {
498             perManifestResolvers = new ArrayList&lt;&gt;();
499         }
500         perManifestResolvers.add(new ResourceResolver(resolverSpi));
501     }
502 
503     /**
504      * Get the Per-Manifest Resolver List
505      * @return the per-manifest Resolver List
506      */
507     public List&lt;ResourceResolver&gt; getPerManifestResolvers() {
508         return perManifestResolvers;
509     }
510 
511     /**
512      * Get the resolver property map
513      * @return the resolver property map
514      */
515     public Map&lt;String, String&gt; getResolverProperties() {
516         return resolverProperties;
517     }
518 
519     /**
520      * Used to pass parameters like proxy servers etc to the ResourceResolver
521      * implementation.
522      *
523      * @param key the key
524      * @param value the value
525      */
526     public void setResolverProperty(String key, String value) {
527         if (resolverProperties == null) {
528             resolverProperties = new HashMap&lt;&gt;(10);
529         }
530         this.resolverProperties.put(key, value);
531     }
532 
533     /**
534      * Returns the value at specified key
535      *
536      * @param key the key
537      * @return the value
538      */
539     public String getResolverProperty(String key) {
540         return this.resolverProperties.get(key);
541     }
542 
543     /**
544      * Method getSignedContentItem
545      *
546      * @param i
547      * @return The signed content of the i reference.
548      *
549      * @throws XMLSignatureException
550      */
551     public byte[] getSignedContentItem(int i) throws XMLSignatureException {
552         try {
553             return this.getReferencedContentAfterTransformsItem(i).getBytes();
554         } catch (IOException ex) {
555             throw new XMLSignatureException(ex);
556         } catch (CanonicalizationException ex) {
557             throw new XMLSignatureException(ex);
558         } catch (InvalidCanonicalizerException ex) {
559             throw new XMLSignatureException(ex);
560         } catch (XMLSecurityException ex) {
561             throw new XMLSignatureException(ex);
562         }
563     }
564 
565     /**
566      * Method getReferencedContentPriorTransformsItem
567      *
568      * @param i
569      * @return The contents before transformation of the reference i.
570      * @throws XMLSecurityException
571      */
572     public XMLSignatureInput getReferencedContentBeforeTransformsItem(int i)
573         throws XMLSecurityException {
574         return this.item(i).getContentsBeforeTransformation();
575     }
576 
577     /**
578      * Method getReferencedContentAfterTransformsItem
579      *
580      * @param i
581      * @return The contents after transformation of the reference i.
582      * @throws XMLSecurityException
583      */
584     public XMLSignatureInput getReferencedContentAfterTransformsItem(int i)
585         throws XMLSecurityException {
586         return this.item(i).getContentsAfterTransformation();
587     }
588 
589     /**
590      * Method getSignedContentLength
591      *
592      * @return The number of references contained in this reference.
593      */
594     public int getSignedContentLength() {
595         return this.getLength();
596     }
597 
598     /**
599      * Method getBaseLocalName
600      *
601      * {@inheritDoc}
602      */
603     public String getBaseLocalName() {
604         return Constants._TAG_MANIFEST;
605     }
606 
607     public boolean isSecureValidation() {
608         return secureValidation;
609     }
610 }
    </pre>
  </body>
</html>
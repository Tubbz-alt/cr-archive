<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/keys/keyresolver/KeyResolver.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.keys.keyresolver;
 24 
 25 import java.security.PublicKey;
 26 import java.security.cert.X509Certificate;
 27 import java.util.ArrayList;
 28 import java.util.Iterator;
 29 import java.util.List;
 30 import java.util.concurrent.CopyOnWriteArrayList;
 31 
 32 import javax.crypto.SecretKey;
 33 
 34 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.DEREncodedKeyValueResolver;
 35 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.DSAKeyValueResolver;
<a name="1" id="anc1"></a>
 36 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.KeyInfoReferenceResolver;
 37 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.RSAKeyValueResolver;
 38 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.RetrievalMethodResolver;
 39 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.X509CertificateResolver;
 40 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.X509DigestResolver;
 41 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.X509IssuerSerialResolver;
 42 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.X509SKIResolver;
 43 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.X509SubjectNameResolver;
 44 import com.sun.org.apache.xml.internal.security.keys.storage.StorageResolver;
 45 import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 46 import org.w3c.dom.Element;
 47 import org.w3c.dom.Node;
 48 
 49 /**
 50  * KeyResolver is factory class for subclass of KeyResolverSpi that
 51  * represent child element of KeyInfo.
 52  */
 53 public class KeyResolver {
 54 
 55     private static final com.sun.org.slf4j.internal.Logger LOG =
 56         com.sun.org.slf4j.internal.LoggerFactory.getLogger(KeyResolver.class);
 57 
 58     /** Field resolverVector */
 59     private static List&lt;KeyResolver&gt; resolverVector = new CopyOnWriteArrayList&lt;KeyResolver&gt;();
 60 
 61     /** Field resolverSpi */
 62     private final KeyResolverSpi resolverSpi;
 63 
 64     /**
 65      * Constructor.
 66      *
 67      * @param keyResolverSpi a KeyResolverSpi instance
 68      */
 69     private KeyResolver(KeyResolverSpi keyResolverSpi) {
 70         resolverSpi = keyResolverSpi;
 71     }
 72 
 73     /**
 74      * Method length
 75      *
 76      * @return the length of resolvers registered
 77      */
 78     public static int length() {
 79         return resolverVector.size();
 80     }
 81 
 82     /**
 83      * Method getX509Certificate
 84      *
 85      * @param element
 86      * @param baseURI
 87      * @param storage
 88      * @return The certificate represented by the element.
 89      *
 90      * @throws KeyResolverException
 91      */
 92     public static final X509Certificate getX509Certificate(
 93         Element element, String baseURI, StorageResolver storage
 94     ) throws KeyResolverException {
 95         for (KeyResolver resolver : resolverVector) {
 96             if (resolver == null) {
 97                 Object exArgs[] = {
 98                                    element != null
 99                                        &amp;&amp; element.getNodeType() == Node.ELEMENT_NODE
100                                        ? element.getTagName() : &quot;null&quot;
101                 };
102 
103                 throw new KeyResolverException(&quot;utils.resolver.noClass&quot;, exArgs);
104             }
105             LOG.debug(&quot;check resolvability by class {}&quot;, resolver.getClass());
106 
107             X509Certificate cert = resolver.resolveX509Certificate(element, baseURI, storage);
108             if (cert != null) {
109                 return cert;
110             }
111         }
112 
113         Object exArgs[] = {
114                            element != null &amp;&amp; element.getNodeType() == Node.ELEMENT_NODE
115                            ? element.getTagName() : &quot;null&quot;
116                           };
117 
118         throw new KeyResolverException(&quot;utils.resolver.noClass&quot;, exArgs);
119     }
120 
121     /**
122      * Method getPublicKey
123      *
124      * @param element
125      * @param baseURI
126      * @param storage
127      * @return the public key contained in the element
128      *
129      * @throws KeyResolverException
130      */
131     public static final PublicKey getPublicKey(
132         Element element, String baseURI, StorageResolver storage
133     ) throws KeyResolverException {
134         for (KeyResolver resolver : resolverVector) {
135             if (resolver == null) {
136                 Object exArgs[] = {
137                                    element != null
138                                        &amp;&amp; element.getNodeType() == Node.ELEMENT_NODE
139                                        ? element.getTagName() : &quot;null&quot;
140                 };
141 
142                 throw new KeyResolverException(&quot;utils.resolver.noClass&quot;, exArgs);
143             }
144             LOG.debug(&quot;check resolvability by class {}&quot;, resolver.getClass());
145 
146             PublicKey cert = resolver.resolvePublicKey(element, baseURI, storage);
147             if (cert != null) {
148                 return cert;
149             }
150         }
151 
152         Object exArgs[] = {
153                            element != null &amp;&amp; element.getNodeType() == Node.ELEMENT_NODE
154                            ? element.getTagName() : &quot;null&quot;
155                           };
156 
157         throw new KeyResolverException(&quot;utils.resolver.noClass&quot;, exArgs);
158     }
159 
160     /**
161      * This method is used for registering {@link KeyResolverSpi}s which are
162      * available to &lt;I&gt;all&lt;/I&gt; {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} objects. This means that
163      * personalized {@link KeyResolverSpi}s should only be registered directly
164      * to the {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} using
165      * {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo#registerInternalKeyResolver}.
166      * Please note that this method will create a new copy of the underlying array, as the
167      * underlying collection is a CopyOnWriteArrayList.
168      *
169      * @param className
170      * @param globalResolver Whether the KeyResolverSpi is a global resolver or not
171      * @throws InstantiationException
172      * @throws IllegalAccessException
173      * @throws ClassNotFoundException
174      * @throws SecurityException if a security manager is installed and the
175      *    caller does not have permission to register the key resolver
176      */
177     public static void register(String className, boolean globalResolver)
178         throws ClassNotFoundException, IllegalAccessException, InstantiationException {
179         JavaUtils.checkRegisterPermission();
180         @SuppressWarnings(&quot;deprecation&quot;)
181         KeyResolverSpi keyResolverSpi =
182             (KeyResolverSpi) ClassLoaderUtils.loadClass(className, KeyResolver.class).newInstance();
183         keyResolverSpi.setGlobalResolver(globalResolver);
184         register(keyResolverSpi, false);
185     }
186 
187     /**
188      * This method is used for registering {@link KeyResolverSpi}s which are
189      * available to &lt;I&gt;all&lt;/I&gt; {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} objects. This means that
190      * personalized {@link KeyResolverSpi}s should only be registered directly
191      * to the {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} using
192      * {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo#registerInternalKeyResolver}.
193      * Please note that this method will create a new copy of the underlying array, as the
194      * underlying collection is a CopyOnWriteArrayList.
195      *
196      * @param className
197      * @param globalResolver Whether the KeyResolverSpi is a global resolver or not
198      * @throws SecurityException if a security manager is installed and the
199      *    caller does not have permission to register the key resolver
200      */
201     public static void registerAtStart(String className, boolean globalResolver) {
202         JavaUtils.checkRegisterPermission();
203         KeyResolverSpi keyResolverSpi = null;
204         Exception ex = null;
205         try {
206             @SuppressWarnings(&quot;deprecation&quot;)
207             KeyResolverSpi tmp = (KeyResolverSpi) ClassLoaderUtils.loadClass(className, KeyResolver.class).newInstance();
208             keyResolverSpi = tmp;
209             keyResolverSpi.setGlobalResolver(globalResolver);
210             register(keyResolverSpi, true);
211         } catch (ClassNotFoundException e) {
212             ex = e;
213         } catch (IllegalAccessException e) {
214             ex = e;
215         } catch (InstantiationException e) {
216             ex = e;
217         }
218 
219         if (ex != null) {
220             throw (IllegalArgumentException) new
221             IllegalArgumentException(&quot;Invalid KeyResolver class name&quot;).initCause(ex);
222         }
223     }
224 
225     /**
226      * This method is used for registering {@link KeyResolverSpi}s which are
227      * available to &lt;I&gt;all&lt;/I&gt; {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} objects. This means that
228      * personalized {@link KeyResolverSpi}s should only be registered directly
229      * to the {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} using
230      * {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo#registerInternalKeyResolver}.
231      * Please note that this method will create a new copy of the underlying array, as the
232      * underlying collection is a CopyOnWriteArrayList.
233      *
234      * @param keyResolverSpi a KeyResolverSpi instance to register
235      * @param start whether to register the KeyResolverSpi at the start of the list or not
236      * @throws SecurityException if a security manager is installed and the
237      *    caller does not have permission to register the key resolver
238      */
239     public static void register(
240         KeyResolverSpi keyResolverSpi,
241         boolean start
242     ) {
243         JavaUtils.checkRegisterPermission();
244         KeyResolver resolver = new KeyResolver(keyResolverSpi);
245         if (start) {
246             resolverVector.add(0, resolver);
247         } else {
248             resolverVector.add(resolver);
249         }
250     }
251 
252     /**
253      * This method is used for registering {@link KeyResolverSpi}s which are
254      * available to &lt;I&gt;all&lt;/I&gt; {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} objects. This means that
255      * personalized {@link KeyResolverSpi}s should only be registered directly
256      * to the {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo} using
257      * {@link com.sun.org.apache.xml.internal.security.keys.KeyInfo#registerInternalKeyResolver}.
258      * The KeyResolverSpi instances are not registered as a global resolver.
259      *
260      *
261      * @param classNames
262      * @throws InstantiationException
263      * @throws IllegalAccessException
264      * @throws ClassNotFoundException
265      * @throws SecurityException if a security manager is installed and the
266      *    caller does not have permission to register the key resolver
267      */
268     public static void registerClassNames(List&lt;String&gt; classNames)
269         throws ClassNotFoundException, IllegalAccessException, InstantiationException {
270         JavaUtils.checkRegisterPermission();
271         List&lt;KeyResolver&gt; keyResolverList = new ArrayList&lt;&gt;(classNames.size());
272         for (String className : classNames) {
273             @SuppressWarnings(&quot;deprecation&quot;)
274             KeyResolverSpi keyResolverSpi =
275                 (KeyResolverSpi)ClassLoaderUtils.loadClass(className, KeyResolver.class).newInstance();
276             keyResolverSpi.setGlobalResolver(false);
277             keyResolverList.add(new KeyResolver(keyResolverSpi));
278         }
279         resolverVector.addAll(keyResolverList);
280     }
281 
282     /**
283      * This method registers the default resolvers.
284      */
285     public static void registerDefaultResolvers() {
286 
287         List&lt;KeyResolver&gt; keyResolverList = new ArrayList&lt;&gt;();
288         keyResolverList.add(new KeyResolver(new RSAKeyValueResolver()));
289         keyResolverList.add(new KeyResolver(new DSAKeyValueResolver()));
290         keyResolverList.add(new KeyResolver(new X509CertificateResolver()));
291         keyResolverList.add(new KeyResolver(new X509SKIResolver()));
292         keyResolverList.add(new KeyResolver(new RetrievalMethodResolver()));
293         keyResolverList.add(new KeyResolver(new X509SubjectNameResolver()));
294         keyResolverList.add(new KeyResolver(new X509IssuerSerialResolver()));
295         keyResolverList.add(new KeyResolver(new DEREncodedKeyValueResolver()));
296         keyResolverList.add(new KeyResolver(new KeyInfoReferenceResolver()));
297         keyResolverList.add(new KeyResolver(new X509DigestResolver()));
<a name="2" id="anc2"></a>
298 
299         resolverVector.addAll(keyResolverList);
300     }
301 
302     /**
303      * Method resolvePublicKey
304      *
305      * @param element
306      * @param baseURI
307      * @param storage
308      * @return resolved public key from the registered from the elements
309      *
310      * @throws KeyResolverException
311      */
312     public PublicKey resolvePublicKey(
313         Element element, String baseURI, StorageResolver storage
314     ) throws KeyResolverException {
315         return resolverSpi.engineLookupAndResolvePublicKey(element, baseURI, storage);
316     }
317 
318     /**
319      * Method resolveX509Certificate
320      *
321      * @param element
322      * @param baseURI
323      * @param storage
324      * @return resolved X509certificate key from the registered from the elements
325      *
326      * @throws KeyResolverException
327      */
328     public X509Certificate resolveX509Certificate(
329         Element element, String baseURI, StorageResolver storage
330     ) throws KeyResolverException {
331         return resolverSpi.engineLookupResolveX509Certificate(element, baseURI, storage);
332     }
333 
334     /**
335      * @param element
336      * @param baseURI
337      * @param storage
338      * @return resolved SecretKey key from the registered from the elements
339      * @throws KeyResolverException
340      */
341     public SecretKey resolveSecretKey(
342         Element element, String baseURI, StorageResolver storage
343     ) throws KeyResolverException {
344         return resolverSpi.engineLookupAndResolveSecretKey(element, baseURI, storage);
345     }
346 
347     /**
348      * Method setProperty
349      *
350      * @param key
351      * @param value
352      */
353     public void setProperty(String key, String value) {
354         resolverSpi.engineSetProperty(key, value);
355     }
356 
357     /**
358      * Method getProperty
359      *
360      * @param key
361      * @return the property set for this resolver
362      */
363     public String getProperty(String key) {
364         return resolverSpi.engineGetProperty(key);
365     }
366 
367 
368     /**
369      * Method understandsProperty
370      *
371      * @param propertyToTest
372      * @return true if the resolver understands property propertyToTest
373      */
374     public boolean understandsProperty(String propertyToTest) {
375         return resolverSpi.understandsProperty(propertyToTest);
376     }
377 
378 
379     /**
380      * Method resolverClassName
381      *
382      * @return the name of the resolver.
383      */
384     public String resolverClassName() {
385         return resolverSpi.getClass().getName();
386     }
387 
388     /**
389      * Iterate over the KeyResolverSpi instances
390      */
391     static class ResolverIterator implements Iterator&lt;KeyResolverSpi&gt; {
392         List&lt;KeyResolver&gt; res;
393         Iterator&lt;KeyResolver&gt; it;
394 
395         public ResolverIterator(List&lt;KeyResolver&gt; list) {
396             res = list;
397             it = res.iterator();
398         }
399 
400         public boolean hasNext() {
401             return it.hasNext();
402         }
403 
404         public KeyResolverSpi next() {
405             KeyResolver resolver = it.next();
406             if (resolver == null) {
407                 throw new RuntimeException(&quot;utils.resolver.noClass&quot;);
408             }
409 
410             return resolver.resolverSpi;
411         }
412 
413         public void remove() {
414             throw new UnsupportedOperationException(&quot;Can&#39;t remove resolvers using the iterator&quot;);
415         }
416     }
417 
418     public static Iterator&lt;KeyResolverSpi&gt; iterator() {
419         return new ResolverIterator(resolverVector);
420     }
421 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/keys/KeyInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * reserved comment block
   3  * DO NOT REMOVE OR ALTER!
   4  */
   5 /**
   6  * Licensed to the Apache Software Foundation (ASF) under one
   7  * or more contributor license agreements. See the NOTICE file
   8  * distributed with this work for additional information
   9  * regarding copyright ownership. The ASF licenses this file
  10  * to you under the Apache License, Version 2.0 (the
  11  * &quot;License&quot;); you may not use this file except in compliance
  12  * with the License. You may obtain a copy of the License at
  13  *
  14  * http://www.apache.org/licenses/LICENSE-2.0
  15  *
  16  * Unless required by applicable law or agreed to in writing,
  17  * software distributed under the License is distributed on an
  18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  19  * KIND, either express or implied. See the License for the
  20  * specific language governing permissions and limitations
  21  * under the License.
  22  */
  23 package com.sun.org.apache.xml.internal.security.keys;
  24 
  25 import java.security.PrivateKey;
  26 import java.security.PublicKey;
  27 import java.security.cert.X509Certificate;
  28 import java.util.ArrayList;
  29 import java.util.Iterator;
  30 import java.util.List;
  31 
  32 import javax.crypto.SecretKey;
  33 
  34 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
  35 import com.sun.org.apache.xml.internal.security.keys.content.DEREncodedKeyValue;
  36 import com.sun.org.apache.xml.internal.security.keys.content.KeyInfoReference;
  37 import com.sun.org.apache.xml.internal.security.keys.content.KeyName;
  38 import com.sun.org.apache.xml.internal.security.keys.content.KeyValue;
  39 import com.sun.org.apache.xml.internal.security.keys.content.MgmtData;
  40 import com.sun.org.apache.xml.internal.security.keys.content.PGPData;
  41 import com.sun.org.apache.xml.internal.security.keys.content.RetrievalMethod;
  42 import com.sun.org.apache.xml.internal.security.keys.content.SPKIData;
  43 import com.sun.org.apache.xml.internal.security.keys.content.X509Data;
  44 import com.sun.org.apache.xml.internal.security.keys.content.keyvalues.DSAKeyValue;
  45 import com.sun.org.apache.xml.internal.security.keys.content.keyvalues.RSAKeyValue;
  46 import com.sun.org.apache.xml.internal.security.keys.keyresolver.KeyResolver;
  47 import com.sun.org.apache.xml.internal.security.keys.keyresolver.KeyResolverException;
  48 import com.sun.org.apache.xml.internal.security.keys.keyresolver.KeyResolverSpi;
  49 import com.sun.org.apache.xml.internal.security.keys.storage.StorageResolver;
  50 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
  51 import com.sun.org.apache.xml.internal.security.utils.Constants;
  52 import com.sun.org.apache.xml.internal.security.utils.ElementProxy;
  53 import com.sun.org.apache.xml.internal.security.utils.EncryptionConstants;
  54 import com.sun.org.apache.xml.internal.security.utils.SignatureElementProxy;
  55 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
  56 import org.w3c.dom.Attr;
  57 import org.w3c.dom.Document;
  58 import org.w3c.dom.Element;
  59 import org.w3c.dom.Node;
  60 
  61 /**
  62  * This class stand for KeyInfo Element that may contain keys, names,
  63  * certificates and other public key management information,
  64  * such as in-band key distribution or key agreement data.
  65  * &lt;p&gt;&lt;/p&gt;
  66  * KeyInfo Element has two basic functions:
  67  * One is KeyResolve for getting the public key in signature validation processing.
  68  * the other one is toElement for getting the element in signature generation processing.
  69  * &lt;p&gt;&lt;/p&gt;
  70  * The {@code lengthXXX()} methods provide access to the internal Key
  71  * objects:
  72  * &lt;UL&gt;
  73  * &lt;LI&gt;If the {@code KeyInfo} was constructed from an Element
  74  * (Signature verification), the {@code lengthXXX()} methods searches
  75  * for child elements of {@code ds:KeyInfo} for known types. &lt;/LI&gt;
  76  * &lt;LI&gt;If the {@code KeyInfo} was constructed from scratch (during
  77  * Signature generation), the {@code lengthXXX()} methods return the number
  78  * of {@code XXXs} objects already passed to the KeyInfo&lt;/LI&gt;
  79  * &lt;/UL&gt;
  80  * &lt;p&gt;&lt;/p&gt;
  81  * The {@code addXXX()} methods are used for adding Objects of the
  82  * appropriate type to the {@code KeyInfo}. This is used during signature
  83  * generation.
  84  * &lt;p&gt;&lt;/p&gt;
  85  * The {@code itemXXX(int i)} methods return the i&#39;th object of the
  86  * corresponding type.
  87  * &lt;p&gt;&lt;/p&gt;
  88  * The {@code containsXXX()} methods return &lt;I&gt;whether&lt;/I&gt; the KeyInfo
  89  * contains the corresponding type.
  90  *
  91  */
  92 public class KeyInfo extends SignatureElementProxy {
  93 
  94     private static final com.sun.org.slf4j.internal.Logger LOG =
  95         com.sun.org.slf4j.internal.LoggerFactory.getLogger(KeyInfo.class);
  96 
  97     // We need at least one StorageResolver otherwise
  98     // the KeyResolvers would not be called.
  99     // The default StorageResolver is null.
 100 
 101     private List&lt;X509Data&gt; x509Datas;
 102 
 103     private static final List&lt;StorageResolver&gt; nullList;
 104     static {
 105         List&lt;StorageResolver&gt; list = new ArrayList&lt;&gt;(1);
 106         list.add(null);
 107         nullList = java.util.Collections.unmodifiableList(list);
 108     }
 109 
 110     /** Field storageResolvers */
 111     private List&lt;StorageResolver&gt; storageResolvers = nullList;
 112 
 113     /**
 114      * Stores the individual (per-KeyInfo) {@link KeyResolverSpi}s
 115      */
 116     private List&lt;KeyResolverSpi&gt; internalKeyResolvers = new ArrayList&lt;&gt;();
 117 
 118     private boolean secureValidation;
 119 
 120     /**
 121      * Constructor KeyInfo
 122      * @param doc
 123      */
 124     public KeyInfo(Document doc) {
 125         super(doc);
 126         addReturnToSelf();
 127 
 128         String prefix = ElementProxy.getDefaultPrefix(this.getBaseNamespace());
 129         if (prefix != null &amp;&amp; prefix.length() &gt; 0) {
 130             getElement().setAttributeNS(Constants.NamespaceSpecNS, &quot;xmlns:&quot; + prefix,
 131                                         this.getBaseNamespace());
 132         }
 133 
 134     }
 135 
 136     /**
 137      * Constructor KeyInfo
 138      *
 139      * @param element
 140      * @param baseURI
 141      * @throws XMLSecurityException
 142      */
 143     public KeyInfo(Element element, String baseURI) throws XMLSecurityException {
 144         super(element, baseURI);
 145 
 146         Attr attr = element.getAttributeNodeNS(null, &quot;Id&quot;);
 147         if (attr != null) {
 148             element.setIdAttributeNode(attr, true);
 149         }
 150     }
 151 
 152     /**
 153      * Set whether secure processing is enabled or not. The default is false.
 154      */
 155     public void setSecureValidation(boolean secureValidation) {
 156         this.secureValidation = secureValidation;
 157     }
 158 
 159     /**
 160      * Sets the {@code Id} attribute
 161      *
 162      * @param id ID
 163      */
 164     public void setId(String id) {
 165         if (id != null) {
 166             setLocalIdAttribute(Constants._ATT_ID, id);
 167         }
 168     }
 169 
 170     /**
 171      * Returns the {@code Id} attribute
 172      *
 173      * @return the {@code Id} attribute
 174      */
 175     public String getId() {
 176         return getLocalAttribute(Constants._ATT_ID);
 177     }
 178 
 179     /**
 180      * Method addKeyName
 181      *
 182      * @param keynameString
 183      */
 184     public void addKeyName(String keynameString) {
 185         this.add(new KeyName(getDocument(), keynameString));
 186     }
 187 
 188     /**
 189      * Method add
 190      *
 191      * @param keyname
 192      */
 193     public void add(KeyName keyname) {
 194         appendSelf(keyname);
 195         addReturnToSelf();
 196     }
 197 
 198     /**
 199      * Method addKeyValue
 200      *
 201      * @param pk
 202      */
 203     public void addKeyValue(PublicKey pk) {
 204         this.add(new KeyValue(getDocument(), pk));
 205     }
 206 
 207     /**
 208      * Method addKeyValue
 209      *
 210      * @param unknownKeyValueElement
 211      */
 212     public void addKeyValue(Element unknownKeyValueElement) {
 213         this.add(new KeyValue(getDocument(), unknownKeyValueElement));
 214     }
 215 
 216     /**
 217      * Method add
 218      *
 219      * @param dsakeyvalue
 220      */
 221     public void add(DSAKeyValue dsakeyvalue) {
 222         this.add(new KeyValue(getDocument(), dsakeyvalue));
 223     }
 224 
 225     /**
 226      * Method add
 227      *
 228      * @param rsakeyvalue
 229      */
 230     public void add(RSAKeyValue rsakeyvalue) {
 231         this.add(new KeyValue(getDocument(), rsakeyvalue));
 232     }
 233 
 234     /**
 235      * Method add
 236      *
 237      * @param pk
 238      */
 239     public void add(PublicKey pk) {
 240         this.add(new KeyValue(getDocument(), pk));
 241     }
 242 
 243     /**
 244      * Method add
 245      *
 246      * @param keyvalue
 247      */
 248     public void add(KeyValue keyvalue) {
 249         appendSelf(keyvalue);
 250         addReturnToSelf();
 251     }
 252 
 253     /**
 254      * Method addMgmtData
 255      *
 256      * @param mgmtdata
 257      */
 258     public void addMgmtData(String mgmtdata) {
 259         this.add(new MgmtData(getDocument(), mgmtdata));
 260     }
 261 
 262     /**
 263      * Method add
 264      *
 265      * @param mgmtdata
 266      */
 267     public void add(MgmtData mgmtdata) {
 268         appendSelf(mgmtdata);
 269         addReturnToSelf();
 270     }
 271 
 272     /**
 273      * Method addPGPData
 274      *
 275      * @param pgpdata
 276      */
 277     public void add(PGPData pgpdata) {
 278         appendSelf(pgpdata);
 279         addReturnToSelf();
 280     }
 281 
 282     /**
 283      * Method addRetrievalMethod
 284      *
 285      * @param uri
 286      * @param transforms
 287      * @param Type
 288      */
 289     public void addRetrievalMethod(String uri, Transforms transforms, String Type) {
 290         this.add(new RetrievalMethod(getDocument(), uri, transforms, Type));
 291     }
 292 
 293     /**
 294      * Method add
 295      *
 296      * @param retrievalmethod
 297      */
 298     public void add(RetrievalMethod retrievalmethod) {
 299         appendSelf(retrievalmethod);
 300         addReturnToSelf();
 301     }
 302 
 303     /**
 304      * Method add
 305      *
 306      * @param spkidata
 307      */
 308     public void add(SPKIData spkidata) {
 309         appendSelf(spkidata);
 310         addReturnToSelf();
 311     }
 312 
 313     /**
 314      * Method addX509Data
 315      *
 316      * @param x509data
 317      */
 318     public void add(X509Data x509data) {
 319         if (x509Datas == null) {
 320             x509Datas = new ArrayList&lt;&gt;();
 321         }
 322         x509Datas.add(x509data);
 323         appendSelf(x509data);
 324         addReturnToSelf();
 325     }
 326 
 327     /**
 328      * Method addDEREncodedKeyValue
 329      *
 330      * @param pk
 331      * @throws XMLSecurityException
 332      */
 333     public void addDEREncodedKeyValue(PublicKey pk) throws XMLSecurityException {
 334         this.add(new DEREncodedKeyValue(getDocument(), pk));
 335     }
 336 
 337     /**
 338      * Method add
 339      *
 340      * @param derEncodedKeyValue
 341      */
 342     public void add(DEREncodedKeyValue derEncodedKeyValue) {
 343         appendSelf(derEncodedKeyValue);
 344         addReturnToSelf();
 345     }
 346 
 347     /**
 348      * Method addKeyInfoReference
 349      *
 350      * @param URI
 351      * @throws XMLSecurityException
 352      */
 353     public void addKeyInfoReference(String URI) throws XMLSecurityException {
 354         this.add(new KeyInfoReference(getDocument(), URI));
 355     }
 356 
 357     /**
 358      * Method add
 359      *
 360      * @param keyInfoReference
 361      */
 362     public void add(KeyInfoReference keyInfoReference) {
 363         appendSelf(keyInfoReference);
 364         addReturnToSelf();
 365     }
 366 
 367     /**
 368      * Method addUnknownElement
 369      *
 370      * @param element
 371      */
 372     public void addUnknownElement(Element element) {
 373         appendSelf(element);
 374         addReturnToSelf();
 375     }
 376 
 377     /**
 378      * Method lengthKeyName
 379      *
 380      * @return the number of the KeyName tags
 381      */
 382     public int lengthKeyName() {
 383         return this.length(Constants.SignatureSpecNS, Constants._TAG_KEYNAME);
 384     }
 385 
 386     /**
 387      * Method lengthKeyValue
 388      *
 389      *@return the number of the KeyValue tags
 390      */
 391     public int lengthKeyValue() {
 392         return this.length(Constants.SignatureSpecNS, Constants._TAG_KEYVALUE);
 393     }
 394 
 395     /**
 396      * Method lengthMgmtData
 397      *
 398      *@return the number of the MgmtData tags
 399      */
 400     public int lengthMgmtData() {
 401         return this.length(Constants.SignatureSpecNS, Constants._TAG_MGMTDATA);
 402     }
 403 
 404     /**
 405      * Method lengthPGPData
 406      *
 407      *@return the number of the PGPDat. tags
 408      */
 409     public int lengthPGPData() {
 410         return this.length(Constants.SignatureSpecNS, Constants._TAG_PGPDATA);
 411     }
 412 
 413     /**
 414      * Method lengthRetrievalMethod
 415      *
 416      *@return the number of the RetrievalMethod tags
 417      */
 418     public int lengthRetrievalMethod() {
 419         return this.length(Constants.SignatureSpecNS, Constants._TAG_RETRIEVALMETHOD);
 420     }
 421 
 422     /**
 423      * Method lengthSPKIData
 424      *
 425      *@return the number of the SPKIData tags
 426      */
 427     public int lengthSPKIData() {
 428         return this.length(Constants.SignatureSpecNS, Constants._TAG_SPKIDATA);
 429     }
 430 
 431     /**
 432      * Method lengthX509Data
 433      *
 434      *@return the number of the X509Data tags
 435      */
 436     public int lengthX509Data() {
 437         if (x509Datas != null) {
 438             return x509Datas.size();
 439         }
 440         return this.length(Constants.SignatureSpecNS, Constants._TAG_X509DATA);
 441     }
 442 
 443     /**
 444      * Method lengthDEREncodedKeyValue
 445      *
 446      *@return the number of the DEREncodedKeyValue tags
 447      */
 448     public int lengthDEREncodedKeyValue() {
 449         return this.length(Constants.SignatureSpec11NS, Constants._TAG_DERENCODEDKEYVALUE);
 450     }
 451 
 452     /**
 453      * Method lengthKeyInfoReference
 454      *
 455      *@return the number of the KeyInfoReference tags
 456      */
 457     public int lengthKeyInfoReference() {
 458         return this.length(Constants.SignatureSpec11NS, Constants._TAG_KEYINFOREFERENCE);
 459     }
 460 
 461     /**
 462      * Method lengthUnknownElement
 463      * NOTE possibly buggy.
 464      * @return the number of the UnknownElement tags
 465      */
 466     public int lengthUnknownElement() {
 467         int res = 0;
 468         Node childNode = getElement().getFirstChild();
 469         while (childNode != null) {
 470             /**
 471              * $todo$ using this method, we don&#39;t see unknown Elements
 472              *  from Signature NS; revisit
 473              */
 474             if (childNode.getNodeType() == Node.ELEMENT_NODE
 475                 &amp;&amp; childNode.getNamespaceURI().equals(Constants.SignatureSpecNS)) {
 476                 res++;
 477             }
 478             childNode = childNode.getNextSibling();
 479         }
 480 
 481         return res;
 482     }
 483 
 484     /**
 485      * Method itemKeyName
 486      *
 487      * @param i
 488      * @return the asked KeyName element, null if the index is too big
 489      * @throws XMLSecurityException
 490      */
 491     public KeyName itemKeyName(int i) throws XMLSecurityException {
 492         Element e =
 493             XMLUtils.selectDsNode(
 494                 getFirstChild(), Constants._TAG_KEYNAME, i);
 495 
 496         if (e != null) {
 497             return new KeyName(e, this.baseURI);
 498         }
 499         return null;
 500     }
 501 
 502     /**
 503      * Method itemKeyValue
 504      *
 505      * @param i
 506      * @return the asked KeyValue element, null if the index is too big
 507      * @throws XMLSecurityException
 508      */
 509     public KeyValue itemKeyValue(int i) throws XMLSecurityException {
 510         Element e =
 511             XMLUtils.selectDsNode(
 512                 getFirstChild(), Constants._TAG_KEYVALUE, i);
 513 
 514         if (e != null) {
 515             return new KeyValue(e, this.baseURI);
 516         }
 517         return null;
 518     }
 519 
 520     /**
 521      * Method itemMgmtData
 522      *
 523      * @param i
 524      * @return the asked MgmtData element, null if the index is too big
 525      * @throws XMLSecurityException
 526      */
 527     public MgmtData itemMgmtData(int i) throws XMLSecurityException {
 528         Element e =
 529             XMLUtils.selectDsNode(
 530                 getFirstChild(), Constants._TAG_MGMTDATA, i);
 531 
 532         if (e != null) {
 533             return new MgmtData(e, this.baseURI);
 534         }
 535         return null;
 536     }
 537 
 538     /**
 539      * Method itemPGPData
 540      *
 541      * @param i
 542      * @return the asked PGPData element, null if the index is too big
 543      * @throws XMLSecurityException
 544      */
 545     public PGPData itemPGPData(int i) throws XMLSecurityException {
 546         Element e =
 547             XMLUtils.selectDsNode(
 548                 getFirstChild(), Constants._TAG_PGPDATA, i);
 549 
 550         if (e != null) {
 551             return new PGPData(e, this.baseURI);
 552         }
 553         return null;
 554     }
 555 
 556     /**
 557      * Method itemRetrievalMethod
 558      *
 559      * @param i
 560      *@return the asked RetrievalMethod element, null if the index is too big
 561      * @throws XMLSecurityException
 562      */
 563     public RetrievalMethod itemRetrievalMethod(int i) throws XMLSecurityException {
 564         Element e =
 565             XMLUtils.selectDsNode(
 566                 getFirstChild(), Constants._TAG_RETRIEVALMETHOD, i);
 567 
 568         if (e != null) {
 569             return new RetrievalMethod(e, this.baseURI);
 570         }
 571         return null;
 572     }
 573 
 574     /**
 575      * Method itemSPKIData
 576      *
 577      * @param i
 578      * @return the asked SPKIData element, null if the index is too big
 579      * @throws XMLSecurityException
 580      */
 581     public SPKIData itemSPKIData(int i) throws XMLSecurityException {
 582         Element e =
 583             XMLUtils.selectDsNode(
 584                 getFirstChild(), Constants._TAG_SPKIDATA, i);
 585 
 586         if (e != null) {
 587             return new SPKIData(e, this.baseURI);
 588         }
 589         return null;
 590     }
 591 
 592     /**
 593      * Method itemX509Data
 594      *
 595      * @param i
 596      * @return the asked X509Data element, null if the index is too big
 597      * @throws XMLSecurityException
 598      */
 599     public X509Data itemX509Data(int i) throws XMLSecurityException {
 600         if (x509Datas != null) {
 601             return x509Datas.get(i);
 602         }
 603         Element e =
 604             XMLUtils.selectDsNode(
 605                 getFirstChild(), Constants._TAG_X509DATA, i);
 606 
 607         if (e != null) {
 608             return new X509Data(e, this.baseURI);
 609         }
 610         return null;
 611     }
 612 
 613     /**
 614      * Method itemDEREncodedKeyValue
 615      *
 616      * @param i
 617      * @return the asked DEREncodedKeyValue element, null if the index is too big
 618      * @throws XMLSecurityException
 619      */
 620     public DEREncodedKeyValue itemDEREncodedKeyValue(int i) throws XMLSecurityException {
 621         Element e =
 622             XMLUtils.selectDs11Node(
 623                 getFirstChild(), Constants._TAG_DERENCODEDKEYVALUE, i);
 624 
 625         if (e != null) {
 626             return new DEREncodedKeyValue(e, this.baseURI);
 627         }
 628         return null;
 629     }
 630 
 631     /**
 632      * Method itemKeyInfoReference
 633      *
 634      * @param i
 635      * @return the asked KeyInfoReference element, null if the index is too big
 636      * @throws XMLSecurityException
 637      */
 638     public KeyInfoReference itemKeyInfoReference(int i) throws XMLSecurityException {
 639         Element e =
 640             XMLUtils.selectDs11Node(
 641                 getFirstChild(), Constants._TAG_KEYINFOREFERENCE, i);
 642 
 643         if (e != null) {
 644             return new KeyInfoReference(e, this.baseURI);
 645         }
 646         return null;
 647     }
 648 
 649     /**
 650      * Method itemUnknownElement
 651      *
 652      * @param i index
 653      * @return the element number of the unknown elements
 654      */
 655     public Element itemUnknownElement(int i) {
 656         int res = 0;
 657         Node childNode = getElement().getFirstChild();
 658         while (childNode != null) {
 659             /**
 660              * $todo$ using this method, we don&#39;t see unknown Elements
 661              *  from Signature NS; revisit
 662              */
 663             if (childNode.getNodeType() == Node.ELEMENT_NODE
 664                 &amp;&amp; childNode.getNamespaceURI().equals(Constants.SignatureSpecNS)) {
 665                 res++;
 666 
 667                 if (res == i) {
 668                     return (Element) childNode;
 669                 }
 670             }
 671             childNode = childNode.getNextSibling();
 672         }
 673 
 674         return null;
 675     }
 676 
 677     /**
 678      * Method isEmpty
 679      *
 680      * @return true if the element has no descendants.
 681      */
 682     public boolean isEmpty() {
 683         return getFirstChild() == null;
 684     }
 685 
 686     /**
 687      * Method containsKeyName
 688      *
 689      * @return If the KeyInfo contains a KeyName node
 690      */
 691     public boolean containsKeyName() {
 692         return this.lengthKeyName() &gt; 0;
 693     }
 694 
 695     /**
 696      * Method containsKeyValue
 697      *
 698      * @return If the KeyInfo contains a KeyValue node
 699      */
 700     public boolean containsKeyValue() {
 701         return this.lengthKeyValue() &gt; 0;
 702     }
 703 
 704     /**
 705      * Method containsMgmtData
 706      *
 707      * @return If the KeyInfo contains a MgmtData node
 708      */
 709     public boolean containsMgmtData() {
 710         return this.lengthMgmtData() &gt; 0;
 711     }
 712 
 713     /**
 714      * Method containsPGPData
 715      *
 716      * @return If the KeyInfo contains a PGPData node
 717      */
 718     public boolean containsPGPData() {
 719         return this.lengthPGPData() &gt; 0;
 720     }
 721 
 722     /**
 723      * Method containsRetrievalMethod
 724      *
 725      * @return If the KeyInfo contains a RetrievalMethod node
 726      */
 727     public boolean containsRetrievalMethod() {
 728         return this.lengthRetrievalMethod() &gt; 0;
 729     }
 730 
 731     /**
 732      * Method containsSPKIData
 733      *
 734      * @return If the KeyInfo contains a SPKIData node
 735      */
 736     public boolean containsSPKIData() {
 737         return this.lengthSPKIData() &gt; 0;
 738     }
 739 
 740     /**
 741      * Method containsUnknownElement
 742      *
 743      * @return If the KeyInfo contains a UnknownElement node
 744      */
 745     public boolean containsUnknownElement() {
 746         return this.lengthUnknownElement() &gt; 0;
 747     }
 748 
 749     /**
 750      * Method containsX509Data
 751      *
 752      * @return If the KeyInfo contains a X509Data node
 753      */
 754     public boolean containsX509Data() {
 755         return this.lengthX509Data() &gt; 0;
 756     }
 757 
 758     /**
 759      * Method containsDEREncodedKeyValue
 760      *
 761      * @return If the KeyInfo contains a DEREncodedKeyValue node
 762      */
 763     public boolean containsDEREncodedKeyValue() {
 764         return this.lengthDEREncodedKeyValue() &gt; 0;
 765     }
 766 
 767     /**
 768      * Method containsKeyInfoReference
 769      *
 770      * @return If the KeyInfo contains a KeyInfoReference node
 771      */
 772     public boolean containsKeyInfoReference() {
 773         return this.lengthKeyInfoReference() &gt; 0;
 774     }
 775 
 776     /**
 777      * This method returns the public key.
 778      *
 779      * @return If the KeyInfo contains a PublicKey node
 780      * @throws KeyResolverException
 781      */
 782     public PublicKey getPublicKey() throws KeyResolverException {
 783         PublicKey pk = this.getPublicKeyFromInternalResolvers();
 784 
 785         if (pk != null) {
 786             LOG.debug(&quot;I could find a key using the per-KeyInfo key resolvers&quot;);
 787 
 788             return pk;
 789         }
 790         LOG.debug(&quot;I couldn&#39;t find a key using the per-KeyInfo key resolvers&quot;);
 791 
 792         pk = this.getPublicKeyFromStaticResolvers();
 793 
 794         if (pk != null) {
 795             LOG.debug(&quot;I could find a key using the system-wide key resolvers&quot;);
 796 
 797             return pk;
 798         }
 799         LOG.debug(&quot;I couldn&#39;t find a key using the system-wide key resolvers&quot;);
 800 
 801         return null;
 802     }
 803 
 804     /**
 805      * Searches the library wide KeyResolvers for public keys
 806      *
 807      * @return The public key contained in this Node.
 808      * @throws KeyResolverException
 809      */
 810     PublicKey getPublicKeyFromStaticResolvers() throws KeyResolverException {
 811         Iterator&lt;KeyResolverSpi&gt; it = KeyResolver.iterator();
 812         while (it.hasNext()) {
 813             KeyResolverSpi keyResolver = it.next();
 814             keyResolver.setSecureValidation(secureValidation);
 815             Node currentChild = getFirstChild();
 816             String uri = this.getBaseURI();
 817             while (currentChild != null) {
 818                 if (currentChild.getNodeType() == Node.ELEMENT_NODE) {
 819                     for (StorageResolver storage : storageResolvers) {
 820                         PublicKey pk =
 821                             keyResolver.engineLookupAndResolvePublicKey(
 822                                 (Element) currentChild, uri, storage
 823                             );
 824 
 825                         if (pk != null) {
 826                             return pk;
 827                         }
 828                     }
 829                 }
 830                 currentChild = currentChild.getNextSibling();
 831             }
 832         }
 833         return null;
 834     }
 835 
 836     /**
 837      * Searches the per-KeyInfo KeyResolvers for public keys
 838      *
 839      * @return The public key contained in this Node.
 840      * @throws KeyResolverException
 841      */
 842     PublicKey getPublicKeyFromInternalResolvers() throws KeyResolverException {
 843         for (KeyResolverSpi keyResolver : internalKeyResolvers) {
 844             LOG.debug(&quot;Try {}&quot;, keyResolver.getClass().getName());
 845             keyResolver.setSecureValidation(secureValidation);
 846             Node currentChild = getFirstChild();
 847             String uri = this.getBaseURI();
 848             while (currentChild != null)      {
 849                 if (currentChild.getNodeType() == Node.ELEMENT_NODE) {
 850                     for (StorageResolver storage : storageResolvers) {
 851                         PublicKey pk =
 852                             keyResolver.engineLookupAndResolvePublicKey(
 853                                 (Element) currentChild, uri, storage
 854                             );
 855 
 856                         if (pk != null) {
 857                             return pk;
 858                         }
 859                     }
 860                 }
 861                 currentChild = currentChild.getNextSibling();
 862             }
 863         }
 864 
 865         return null;
 866     }
 867 
 868     /**
 869      * Method getX509Certificate
 870      *
 871      * @return The certificate contained in this KeyInfo
 872      * @throws KeyResolverException
 873      */
 874     public X509Certificate getX509Certificate() throws KeyResolverException {
 875         // First search using the individual resolvers from the user
 876         X509Certificate cert = this.getX509CertificateFromInternalResolvers();
 877 
 878         if (cert != null) {
 879             LOG.debug(&quot;I could find a X509Certificate using the per-KeyInfo key resolvers&quot;);
 880 
 881             return cert;
 882         }
 883         LOG.debug(&quot;I couldn&#39;t find a X509Certificate using the per-KeyInfo key resolvers&quot;);
 884 
 885         // Then use the system-wide Resolvers
 886         cert = this.getX509CertificateFromStaticResolvers();
 887 
 888         if (cert != null) {
 889             LOG.debug(&quot;I could find a X509Certificate using the system-wide key resolvers&quot;);
 890 
 891             return cert;
 892         }
 893         LOG.debug(&quot;I couldn&#39;t find a X509Certificate using the system-wide key resolvers&quot;);
 894 
 895         return null;
 896     }
 897 
 898     /**
 899      * This method uses each System-wide {@link KeyResolver} to search the
 900      * child elements. Each combination of {@link KeyResolver} and child element
 901      * is checked against all {@link StorageResolver}s.
 902      *
 903      * @return The certificate contained in this KeyInfo
 904      * @throws KeyResolverException
 905      */
 906     X509Certificate getX509CertificateFromStaticResolvers()
 907         throws KeyResolverException {
 908         LOG.debug(
 909             &quot;Start getX509CertificateFromStaticResolvers() with {} resolvers&quot;, KeyResolver.length()
 910         );
 911         String uri = this.getBaseURI();
 912         Iterator&lt;KeyResolverSpi&gt; it = KeyResolver.iterator();
 913         while (it.hasNext()) {
 914             KeyResolverSpi keyResolver = it.next();
 915             keyResolver.setSecureValidation(secureValidation);
 916             X509Certificate cert = applyCurrentResolver(uri, keyResolver);
 917             if (cert != null) {
 918                 return cert;
 919             }
 920         }
 921         return null;
 922     }
 923 
 924     private X509Certificate applyCurrentResolver(
 925         String uri, KeyResolverSpi keyResolver
 926     ) throws KeyResolverException {
 927         Node currentChild = getFirstChild();
 928         while (currentChild != null)      {
 929             if (currentChild.getNodeType() == Node.ELEMENT_NODE) {
 930                 for (StorageResolver storage : storageResolvers) {
 931                     X509Certificate cert =
 932                         keyResolver.engineLookupResolveX509Certificate(
 933                             (Element) currentChild, uri, storage
 934                         );
 935 
 936                     if (cert != null) {
 937                         return cert;
 938                     }
 939                 }
 940             }
 941             currentChild = currentChild.getNextSibling();
 942         }
 943         return null;
 944     }
 945 
 946     /**
 947      * Method getX509CertificateFromInternalResolvers
 948      *
 949      * @return The certificate contained in this KeyInfo
 950      * @throws KeyResolverException
 951      */
 952     X509Certificate getX509CertificateFromInternalResolvers()
 953         throws KeyResolverException {
 954         LOG.debug(
 955             &quot;Start getX509CertificateFromInternalResolvers() with {} resolvers&quot;,
 956             + this.lengthInternalKeyResolver()
 957         );
 958         String uri = this.getBaseURI();
 959         for (KeyResolverSpi keyResolver : internalKeyResolvers) {
 960             LOG.debug(&quot;Try {}&quot;, keyResolver.getClass().getName());
 961             keyResolver.setSecureValidation(secureValidation);
 962             X509Certificate cert = applyCurrentResolver(uri, keyResolver);
 963             if (cert != null) {
 964                 return cert;
 965             }
 966         }
 967 
 968         return null;
 969     }
 970 
 971     /**
 972      * This method returns a secret (symmetric) key. This is for XML Encryption.
 973      * @return the secret key contained in this KeyInfo
 974      * @throws KeyResolverException
 975      */
 976     public SecretKey getSecretKey() throws KeyResolverException {
 977         SecretKey sk = this.getSecretKeyFromInternalResolvers();
 978 
 979         if (sk != null) {
 980             LOG.debug(&quot;I could find a secret key using the per-KeyInfo key resolvers&quot;);
 981 
 982             return sk;
 983         }
 984         LOG.debug(&quot;I couldn&#39;t find a secret key using the per-KeyInfo key resolvers&quot;);
 985 
 986         sk = this.getSecretKeyFromStaticResolvers();
 987 
 988         if (sk != null) {
 989             LOG.debug(&quot;I could find a secret key using the system-wide key resolvers&quot;);
 990 
 991             return sk;
 992         }
 993         LOG.debug(&quot;I couldn&#39;t find a secret key using the system-wide key resolvers&quot;);
 994 
 995         return null;
 996     }
 997 
 998     /**
 999      * Searches the library wide KeyResolvers for Secret keys
1000      *
1001      * @return the secret key contained in this KeyInfo
1002      * @throws KeyResolverException
1003      */
1004     SecretKey getSecretKeyFromStaticResolvers() throws KeyResolverException {
1005         Iterator&lt;KeyResolverSpi&gt; it = KeyResolver.iterator();
1006         while (it.hasNext()) {
1007             KeyResolverSpi keyResolver = it.next();
1008             keyResolver.setSecureValidation(secureValidation);
1009 
1010             Node currentChild = getFirstChild();
1011             String uri = this.getBaseURI();
1012             while (currentChild != null)      {
1013                 if (currentChild.getNodeType() == Node.ELEMENT_NODE) {
1014                     for (StorageResolver storage : storageResolvers) {
1015                         SecretKey sk =
1016                             keyResolver.engineLookupAndResolveSecretKey(
1017                                 (Element) currentChild, uri, storage
1018                             );
1019 
1020                         if (sk != null) {
1021                             return sk;
1022                         }
1023                     }
1024                 }
1025                 currentChild = currentChild.getNextSibling();
1026             }
1027         }
1028         return null;
1029     }
1030 
1031     /**
1032      * Searches the per-KeyInfo KeyResolvers for secret keys
1033      *
1034      * @return the secret key contained in this KeyInfo
1035      * @throws KeyResolverException
1036      */
1037 
1038     SecretKey getSecretKeyFromInternalResolvers() throws KeyResolverException {
1039         for (KeyResolverSpi keyResolver : internalKeyResolvers) {
1040             LOG.debug(&quot;Try {}&quot;, keyResolver.getClass().getName());
1041             keyResolver.setSecureValidation(secureValidation);
1042             Node currentChild = getFirstChild();
1043             String uri = this.getBaseURI();
1044             while (currentChild != null)      {
1045                 if (currentChild.getNodeType() == Node.ELEMENT_NODE) {
1046                     for (StorageResolver storage : storageResolvers) {
1047                         SecretKey sk =
1048                             keyResolver.engineLookupAndResolveSecretKey(
1049                                 (Element) currentChild, uri, storage
1050                             );
1051 
1052                         if (sk != null) {
1053                             return sk;
1054                         }
1055                     }
1056                 }
1057                 currentChild = currentChild.getNextSibling();
1058             }
1059         }
1060 
1061         return null;
1062     }
1063 
1064     /**
1065      * This method returns a private key. This is for Key Transport in XML Encryption.
1066      * @return the private key contained in this KeyInfo
1067      * @throws KeyResolverException
1068      */
1069     public PrivateKey getPrivateKey() throws KeyResolverException {
1070         PrivateKey pk = this.getPrivateKeyFromInternalResolvers();
1071 
1072         if (pk != null) {
1073             LOG.debug(&quot;I could find a private key using the per-KeyInfo key resolvers&quot;);
1074             return pk;
1075         }
1076         LOG.debug(&quot;I couldn&#39;t find a secret key using the per-KeyInfo key resolvers&quot;);
1077 
1078         pk = this.getPrivateKeyFromStaticResolvers();
1079         if (pk != null) {
1080             LOG.debug(&quot;I could find a private key using the system-wide key resolvers&quot;);
1081             return pk;
1082         }
1083         LOG.debug(&quot;I couldn&#39;t find a private key using the system-wide key resolvers&quot;);
1084 
1085         return null;
1086     }
1087 
1088     /**
1089      * Searches the library wide KeyResolvers for Private keys
1090      *
1091      * @return the private key contained in this KeyInfo
1092      * @throws KeyResolverException
1093      */
1094     PrivateKey getPrivateKeyFromStaticResolvers() throws KeyResolverException {
1095         Iterator&lt;KeyResolverSpi&gt; it = KeyResolver.iterator();
1096         while (it.hasNext()) {
1097             KeyResolverSpi keyResolver = it.next();
1098             keyResolver.setSecureValidation(secureValidation);
1099 
1100             Node currentChild = getFirstChild();
1101             String uri = this.getBaseURI();
1102             while (currentChild != null)      {
1103                 if (currentChild.getNodeType() == Node.ELEMENT_NODE) {
1104                     // not using StorageResolvers at the moment
1105                     // since they cannot return private keys
1106                     PrivateKey pk =
1107                         keyResolver.engineLookupAndResolvePrivateKey(
1108                             (Element) currentChild, uri, null
1109                         );
1110 
1111                     if (pk != null) {
1112                         return pk;
1113                     }
1114                 }
1115                 currentChild = currentChild.getNextSibling();
1116             }
1117         }
1118         return null;
1119     }
1120 
1121     /**
1122      * Searches the per-KeyInfo KeyResolvers for private keys
1123      *
1124      * @return the private key contained in this KeyInfo
1125      * @throws KeyResolverException
1126      */
1127     PrivateKey getPrivateKeyFromInternalResolvers() throws KeyResolverException {
1128         for (KeyResolverSpi keyResolver : internalKeyResolvers) {
1129             LOG.debug(&quot;Try {}&quot;, keyResolver.getClass().getName());
1130             keyResolver.setSecureValidation(secureValidation);
1131             Node currentChild = getFirstChild();
1132             String uri = this.getBaseURI();
1133             while (currentChild != null) {
1134                 if (currentChild.getNodeType() == Node.ELEMENT_NODE) {
1135                     // not using StorageResolvers at the moment
1136                     // since they cannot return private keys
1137                     PrivateKey pk =
1138                         keyResolver.engineLookupAndResolvePrivateKey(
1139                             (Element) currentChild, uri, null
1140                         );
1141 
1142                     if (pk != null) {
1143                         return pk;
1144                     }
1145                 }
1146                 currentChild = currentChild.getNextSibling();
1147             }
1148         }
1149 
1150         return null;
1151     }
1152 
1153     /**
1154      * This method is used to add a custom {@link KeyResolverSpi} to a KeyInfo
1155      * object.
1156      *
1157      * @param realKeyResolver
1158      */
1159     public void registerInternalKeyResolver(KeyResolverSpi realKeyResolver) {
1160         this.internalKeyResolvers.add(realKeyResolver);
1161     }
1162 
1163     /**
1164      * Method lengthInternalKeyResolver
1165      * @return the length of the key
1166      */
1167     int lengthInternalKeyResolver() {
1168         return this.internalKeyResolvers.size();
1169     }
1170 
1171     /**
1172      * Method itemInternalKeyResolver
1173      *
1174      * @param i the index
1175      * @return the KeyResolverSpi for the index.
1176      */
1177     KeyResolverSpi itemInternalKeyResolver(int i) {
1178         return this.internalKeyResolvers.get(i);
1179     }
1180 
1181     /**
1182      * Method addStorageResolver
1183      *
1184      * @param storageResolver
1185      */
1186     public void addStorageResolver(StorageResolver storageResolver) {
1187         if (storageResolvers == nullList) {
1188             // Replace the default null StorageResolver
1189             storageResolvers = new ArrayList&lt;&gt;();
1190         }
1191         this.storageResolvers.add(storageResolver);
1192     }
1193 
1194 
1195     /** {@inheritDoc} */
1196     public String getBaseLocalName() {
1197         return Constants._TAG_KEYINFO;
1198     }
1199 }
    </pre>
  </body>
</html>
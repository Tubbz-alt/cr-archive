<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/transforms/implementations/TransformBase64Decode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../signature/XMLSignatureInput.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="TransformXSLT.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/transforms/implementations/TransformBase64Decode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.transforms.implementations;
 24 
 25 import java.io.IOException;
 26 import java.io.OutputStream;
<span class="line-removed"> 27 import java.util.Base64;</span>
 28 
 29 import javax.xml.parsers.ParserConfigurationException;
 30 
 31 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 32 import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
 33 import com.sun.org.apache.xml.internal.security.transforms.Transform;
 34 import com.sun.org.apache.xml.internal.security.transforms.TransformSpi;
 35 import com.sun.org.apache.xml.internal.security.transforms.TransformationException;
 36 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
 37 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 38 import org.w3c.dom.Document;
 39 import org.w3c.dom.Element;
 40 import org.w3c.dom.Node;
 41 import org.w3c.dom.Text;
 42 import org.xml.sax.SAXException;
 43 
 44 import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 45 
 46 /**
 47  * Implements the {@code http://www.w3.org/2000/09/xmldsig#base64} decoding
</pre>
<hr />
<pre>
 92      * @throws IOException
 93      * @throws TransformationException
 94      */
 95     protected XMLSignatureInput enginePerformTransform(
 96         XMLSignatureInput input, Transform transformObject
 97     ) throws IOException, CanonicalizationException, TransformationException {
 98         return enginePerformTransform(input, null, transformObject);
 99     }
100 
101     protected XMLSignatureInput enginePerformTransform(
102         XMLSignatureInput input, OutputStream os, Transform transformObject
103     ) throws IOException, CanonicalizationException, TransformationException {
104         if (input.isElement()) {
105             Node el = input.getSubNode();
106             if (input.getSubNode().getNodeType() == Node.TEXT_NODE) {
107                 el = el.getParentNode();
108             }
109             StringBuilder sb = new StringBuilder();
110             traverseElement((Element)el, sb);
111             if (os == null) {
<span class="line-modified">112                 byte[] decodedBytes = Base64.getMimeDecoder().decode(sb.toString());</span>
113                 XMLSignatureInput output = new XMLSignatureInput(decodedBytes);
114                 output.setSecureValidation(secureValidation);
115                 return output;
116             }
<span class="line-modified">117             byte[] bytes = Base64.getMimeDecoder().decode(sb.toString());</span>
118             os.write(bytes);
119             XMLSignatureInput output = new XMLSignatureInput((byte[])null);
120             output.setSecureValidation(secureValidation);
121             output.setOutputStream(os);
122             return output;
123         }
124 
125         if (input.isOctetStream() || input.isNodeSet()) {
126             if (os == null) {
127                 byte[] base64Bytes = input.getBytes();
<span class="line-modified">128                 byte[] decodedBytes = Base64.getMimeDecoder().decode(base64Bytes);</span>
129                 XMLSignatureInput output = new XMLSignatureInput(decodedBytes);
130                 output.setSecureValidation(secureValidation);
131                 return output;
132             }
133             if (input.isByteArray() || input.isNodeSet()) {
<span class="line-modified">134                 byte[] bytes = Base64.getMimeDecoder().decode(input.getBytes());</span>
135                 os.write(bytes);
136             } else {
137                 byte[] inputBytes = JavaUtils.getBytesFromStream(input.getOctetStreamReal());
<span class="line-modified">138                 byte[] bytes = Base64.getMimeDecoder().decode(inputBytes);</span>
139                 os.write(bytes);
140             }
141             XMLSignatureInput output = new XMLSignatureInput((byte[])null);
142             output.setSecureValidation(secureValidation);
143             output.setOutputStream(os);
144             return output;
145         }
146 
147         try {
148             //Exceptional case there is current not text case testing this(Before it was a
149             //a common case).
150             Document doc =
<span class="line-modified">151                 XMLUtils.createDocumentBuilder(false, secureValidation).parse(input.getOctetStream());</span>
152 
153             Element rootNode = doc.getDocumentElement();
154             StringBuilder sb = new StringBuilder();
155             traverseElement(rootNode, sb);
<span class="line-modified">156             byte[] decodedBytes = Base64.getMimeDecoder().decode(sb.toString());</span>
157             XMLSignatureInput output = new XMLSignatureInput(decodedBytes);
158             output.setSecureValidation(secureValidation);
159             return output;
160         } catch (ParserConfigurationException e) {
161             throw new TransformationException(e, &quot;c14n.Canonicalizer.Exception&quot;);
162         } catch (SAXException e) {
163             throw new TransformationException(e, &quot;SAX exception&quot;);
164         }
165     }
166 
167     void traverseElement(Element node, StringBuilder sb) {
168         Node sibling = node.getFirstChild();
169         while (sibling != null) {
170             switch (sibling.getNodeType()) {
171             case Node.ELEMENT_NODE:
172                 traverseElement((Element)sibling, sb);
173                 break;
174             case Node.TEXT_NODE:
175                 sb.append(((Text)sibling).getData());
176             }
</pre>
</td>
<td>
<hr />
<pre>
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.transforms.implementations;
 24 
 25 import java.io.IOException;
 26 import java.io.OutputStream;

 27 
 28 import javax.xml.parsers.ParserConfigurationException;
 29 
 30 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 31 import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
 32 import com.sun.org.apache.xml.internal.security.transforms.Transform;
 33 import com.sun.org.apache.xml.internal.security.transforms.TransformSpi;
 34 import com.sun.org.apache.xml.internal.security.transforms.TransformationException;
 35 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
 36 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 37 import org.w3c.dom.Document;
 38 import org.w3c.dom.Element;
 39 import org.w3c.dom.Node;
 40 import org.w3c.dom.Text;
 41 import org.xml.sax.SAXException;
 42 
 43 import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 44 
 45 /**
 46  * Implements the {@code http://www.w3.org/2000/09/xmldsig#base64} decoding
</pre>
<hr />
<pre>
 91      * @throws IOException
 92      * @throws TransformationException
 93      */
 94     protected XMLSignatureInput enginePerformTransform(
 95         XMLSignatureInput input, Transform transformObject
 96     ) throws IOException, CanonicalizationException, TransformationException {
 97         return enginePerformTransform(input, null, transformObject);
 98     }
 99 
100     protected XMLSignatureInput enginePerformTransform(
101         XMLSignatureInput input, OutputStream os, Transform transformObject
102     ) throws IOException, CanonicalizationException, TransformationException {
103         if (input.isElement()) {
104             Node el = input.getSubNode();
105             if (input.getSubNode().getNodeType() == Node.TEXT_NODE) {
106                 el = el.getParentNode();
107             }
108             StringBuilder sb = new StringBuilder();
109             traverseElement((Element)el, sb);
110             if (os == null) {
<span class="line-modified">111                 byte[] decodedBytes = XMLUtils.decode(sb.toString());</span>
112                 XMLSignatureInput output = new XMLSignatureInput(decodedBytes);
113                 output.setSecureValidation(secureValidation);
114                 return output;
115             }
<span class="line-modified">116             byte[] bytes = XMLUtils.decode(sb.toString());</span>
117             os.write(bytes);
118             XMLSignatureInput output = new XMLSignatureInput((byte[])null);
119             output.setSecureValidation(secureValidation);
120             output.setOutputStream(os);
121             return output;
122         }
123 
124         if (input.isOctetStream() || input.isNodeSet()) {
125             if (os == null) {
126                 byte[] base64Bytes = input.getBytes();
<span class="line-modified">127                 byte[] decodedBytes = XMLUtils.decode(base64Bytes);</span>
128                 XMLSignatureInput output = new XMLSignatureInput(decodedBytes);
129                 output.setSecureValidation(secureValidation);
130                 return output;
131             }
132             if (input.isByteArray() || input.isNodeSet()) {
<span class="line-modified">133                 byte[] bytes = XMLUtils.decode(input.getBytes());</span>
134                 os.write(bytes);
135             } else {
136                 byte[] inputBytes = JavaUtils.getBytesFromStream(input.getOctetStreamReal());
<span class="line-modified">137                 byte[] bytes = XMLUtils.decode(inputBytes);</span>
138                 os.write(bytes);
139             }
140             XMLSignatureInput output = new XMLSignatureInput((byte[])null);
141             output.setSecureValidation(secureValidation);
142             output.setOutputStream(os);
143             return output;
144         }
145 
146         try {
147             //Exceptional case there is current not text case testing this(Before it was a
148             //a common case).
149             Document doc =
<span class="line-modified">150                 XMLUtils.read(input.getOctetStream(), secureValidation);</span>
151 
152             Element rootNode = doc.getDocumentElement();
153             StringBuilder sb = new StringBuilder();
154             traverseElement(rootNode, sb);
<span class="line-modified">155             byte[] decodedBytes = XMLUtils.decode(sb.toString());</span>
156             XMLSignatureInput output = new XMLSignatureInput(decodedBytes);
157             output.setSecureValidation(secureValidation);
158             return output;
159         } catch (ParserConfigurationException e) {
160             throw new TransformationException(e, &quot;c14n.Canonicalizer.Exception&quot;);
161         } catch (SAXException e) {
162             throw new TransformationException(e, &quot;SAX exception&quot;);
163         }
164     }
165 
166     void traverseElement(Element node, StringBuilder sb) {
167         Node sibling = node.getFirstChild();
168         while (sibling != null) {
169             switch (sibling.getNodeType()) {
170             case Node.ELEMENT_NODE:
171                 traverseElement((Element)sibling, sb);
172                 break;
173             case Node.TEXT_NODE:
174                 sb.append(((Text)sibling).getData());
175             }
</pre>
</td>
</tr>
</table>
<center><a href="../../signature/XMLSignatureInput.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="TransformXSLT.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
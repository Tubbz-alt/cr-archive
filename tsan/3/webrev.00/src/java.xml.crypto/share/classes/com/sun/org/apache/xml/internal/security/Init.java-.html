<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/Init.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security;
 24 
 25 import java.io.InputStream;
 26 import java.security.AccessController;
 27 import java.security.PrivilegedAction;
 28 import java.security.PrivilegedActionException;
 29 import java.security.PrivilegedExceptionAction;
 30 import java.util.ArrayList;
 31 import java.util.List;
 32 
 33 import javax.xml.parsers.DocumentBuilder;
 34 
 35 import com.sun.org.apache.xml.internal.security.algorithms.JCEMapper;
 36 import com.sun.org.apache.xml.internal.security.algorithms.SignatureAlgorithm;
 37 import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
 38 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 39 import com.sun.org.apache.xml.internal.security.keys.keyresolver.KeyResolver;
 40 import com.sun.org.apache.xml.internal.security.transforms.Transform;
 41 import com.sun.org.apache.xml.internal.security.utils.ElementProxy;
 42 import com.sun.org.apache.xml.internal.security.utils.I18n;
 43 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 44 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;
 45 import org.w3c.dom.Attr;
 46 import org.w3c.dom.Document;
 47 import org.w3c.dom.Element;
 48 import org.w3c.dom.Node;
 49 
 50 
 51 /**
 52  * This class does the configuration of the library. This includes creating
 53  * the mapping of Canonicalization and Transform algorithms. Initialization is
 54  * done by calling {@link Init#init} which should be done in any static block
 55  * of the files of this library. We ensure that this call is only executed once.
 56  */
 57 public class Init {
 58 
 59     /** The namespace for CONF file **/
 60     public static final String CONF_NS = &quot;http://www.xmlsecurity.org/NS/#configuration&quot;;
 61 
 62     private static final com.sun.org.slf4j.internal.Logger LOG =
 63         com.sun.org.slf4j.internal.LoggerFactory.getLogger(Init.class);
 64 
 65     /** Field alreadyInitialized */
 66     private static boolean alreadyInitialized = false;
 67 
 68     /**
 69      * Method isInitialized
 70      * @return true if the library is already initialized.
 71      */
 72     public static final synchronized boolean isInitialized() {
 73         return Init.alreadyInitialized;
 74     }
 75 
 76     /**
 77      * Method init
 78      *
 79      */
 80     public static synchronized void init() {
 81         if (alreadyInitialized) {
 82             return;
 83         }
 84 
 85         InputStream is =
 86             AccessController.doPrivileged(
 87                 (PrivilegedAction&lt;InputStream&gt;)
 88                     () -&gt; {
 89                         String cfile =
 90                             System.getProperty(&quot;com.sun.org.apache.xml.internal.security.resource.config&quot;);
 91                         if (cfile == null) {
 92                             return null;
 93                         }
 94                         return Init.class.getResourceAsStream(cfile);
 95                     }
 96                 );
 97         if (is == null) {
 98             dynamicInit();
 99         } else {
100             fileInit(is);
101         }
102 
103         alreadyInitialized = true;
104     }
105 
106     /**
107      * Dynamically initialise the library by registering the default algorithms/implementations
108      */
109     private static void dynamicInit() {
110         //
111         // Load the Resource Bundle - the default is the English resource bundle.
112         // To load another resource bundle, call I18n.init(...) before calling this
113         // method.
114         //
115         I18n.init(&quot;en&quot;, &quot;US&quot;);
116 
117         LOG.debug(&quot;Registering default algorithms&quot;);
118 
119         try {
120             AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Void&gt;(){
121                 @Override public Void run() throws XMLSecurityException {
122                     //
123                     // Bind the default prefixes
124                     //
125                     ElementProxy.registerDefaultPrefixes();
126 
127                     //
128                     // Set the default Transforms
129                     //
130                     Transform.registerDefaultAlgorithms();
131 
132                     //
133                     // Set the default signature algorithms
134                     //
135                     SignatureAlgorithm.registerDefaultAlgorithms();
136 
137                     //
138                     // Set the default JCE algorithms
139                     //
140                     JCEMapper.registerDefaultAlgorithms();
141 
142                     //
143                     // Set the default c14n algorithms
144                     //
145                     Canonicalizer.registerDefaultAlgorithms();
146 
147                     //
148                     // Register the default resolvers
149                     //
150                     ResourceResolver.registerDefaultResolvers();
151 
152                     //
153                     // Register the default key resolvers
154                     //
155                     KeyResolver.registerDefaultResolvers();
156 
157                     return null;
158                 }
159             });
160         } catch (PrivilegedActionException ex) {
161             XMLSecurityException xse = (XMLSecurityException)ex.getException();
162             LOG.error(xse.getMessage(), xse);
163             xse.printStackTrace();
164         }
165     }
166 
167     /**
168      * Initialise the library from a configuration file
169      */
170     private static void fileInit(InputStream is) {
171         try {
172             /* read library configuration file */
173             DocumentBuilder db = XMLUtils.createDocumentBuilder(false);
174             Document doc = db.parse(is);
175             Node config = doc.getFirstChild();
176             for (; config != null; config = config.getNextSibling()) {
177                 if (&quot;Configuration&quot;.equals(config.getLocalName())) {
178                     break;
179                 }
180             }
181             if (config == null) {
182                 LOG.error(&quot;Error in reading configuration file - Configuration element not found&quot;);
183                 return;
184             }
185             for (Node el = config.getFirstChild(); el != null; el = el.getNextSibling()) {
186                 if (Node.ELEMENT_NODE != el.getNodeType()) {
187                     continue;
188                 }
189                 String tag = el.getLocalName();
190                 if (&quot;ResourceBundles&quot;.equals(tag)) {
191                     Element resource = (Element)el;
192                     /* configure internationalization */
193                     Attr langAttr = resource.getAttributeNodeNS(null, &quot;defaultLanguageCode&quot;);
194                     Attr countryAttr = resource.getAttributeNodeNS(null, &quot;defaultCountryCode&quot;);
195                     String languageCode =
196                         (langAttr == null) ? null : langAttr.getNodeValue();
197                     String countryCode =
198                         (countryAttr == null) ? null : countryAttr.getNodeValue();
199                     I18n.init(languageCode, countryCode);
200                 }
201 
202                 if (&quot;CanonicalizationMethods&quot;.equals(tag)) {
203                     Element[] list =
204                         XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;CanonicalizationMethod&quot;);
205 
206                     for (Element element : list) {
207                         String uri = element.getAttributeNS(null, &quot;URI&quot;);
208                         String javaClass =
209                             element.getAttributeNS(null, &quot;JAVACLASS&quot;);
210                         try {
211                             Canonicalizer.register(uri, javaClass);
212                             LOG.debug(&quot;Canonicalizer.register({}, {})&quot;, uri, javaClass);
213                         } catch (ClassNotFoundException e) {
214                             Object exArgs[] = { uri, javaClass };
215                             LOG.error(I18n.translate(&quot;algorithm.classDoesNotExist&quot;, exArgs));
216                         }
217                     }
218                 }
219 
220                 if (&quot;TransformAlgorithms&quot;.equals(tag)) {
221                     Element[] tranElem =
222                         XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;TransformAlgorithm&quot;);
223 
224                     for (Element element : tranElem) {
225                         String uri = element.getAttributeNS(null, &quot;URI&quot;);
226                         String javaClass =
227                             element.getAttributeNS(null, &quot;JAVACLASS&quot;);
228                         try {
229                             Transform.register(uri, javaClass);
230                             LOG.debug(&quot;Transform.register({}, {})&quot;, uri, javaClass);
231                         } catch (ClassNotFoundException e) {
232                             Object exArgs[] = { uri, javaClass };
233 
234                             LOG.error(I18n.translate(&quot;algorithm.classDoesNotExist&quot;, exArgs));
235                         } catch (NoClassDefFoundError ex) {
236                             LOG.warn(&quot;Not able to found dependencies for algorithm, I&#39;ll keep working.&quot;);
237                         }
238                     }
239                 }
240 
241                 if (&quot;JCEAlgorithmMappings&quot;.equals(tag)) {
242                     Node algorithmsNode = ((Element)el).getElementsByTagName(&quot;Algorithms&quot;).item(0);
243                     if (algorithmsNode != null) {
244                         Element[] algorithms =
245                             XMLUtils.selectNodes(algorithmsNode.getFirstChild(), CONF_NS, &quot;Algorithm&quot;);
246                         for (Element element : algorithms) {
247                             String id = element.getAttributeNS(null, &quot;URI&quot;);
248                             JCEMapper.register(id, new JCEMapper.Algorithm(element));
249                         }
250                     }
251                 }
252 
253                 if (&quot;SignatureAlgorithms&quot;.equals(tag)) {
254                     Element[] sigElems =
255                         XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;SignatureAlgorithm&quot;);
256 
257                     for (Element sigElem : sigElems) {
258                         String uri = sigElem.getAttributeNS(null, &quot;URI&quot;);
259                         String javaClass =
260                             sigElem.getAttributeNS(null, &quot;JAVACLASS&quot;);
261 
262                         /** $todo$ handle registering */
263 
264                         try {
265                             SignatureAlgorithm.register(uri, javaClass);
266                             LOG.debug(&quot;SignatureAlgorithm.register({}, {})&quot;, uri, javaClass);
267                         } catch (ClassNotFoundException e) {
268                             Object exArgs[] = { uri, javaClass };
269 
270                             LOG.error(I18n.translate(&quot;algorithm.classDoesNotExist&quot;, exArgs));
271                         }
272                     }
273                 }
274 
275                 if (&quot;ResourceResolvers&quot;.equals(tag)) {
276                     Element[] resolverElem =
277                         XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;Resolver&quot;);
278 
279                     for (Element element : resolverElem) {
280                         String javaClass =
281                             element.getAttributeNS(null, &quot;JAVACLASS&quot;);
282                         String description =
283                             element.getAttributeNS(null, &quot;DESCRIPTION&quot;);
284 
285                         if (description != null &amp;&amp; description.length() &gt; 0) {
286                             LOG.debug(&quot;Register Resolver: {}: {}&quot;, javaClass, description);
287                         } else {
288                             LOG.debug(&quot;Register Resolver: {}: For unknown purposes&quot;, javaClass);
289                         }
290                         try {
291                             ResourceResolver.register(javaClass);
292                         } catch (Throwable e) {
293                             LOG.warn(
294                                  &quot;Cannot register:&quot; + javaClass
295                                  + &quot; perhaps some needed jars are not installed&quot;,
296                                  e
297                              );
298                         }
299                     }
300                 }
301 
302                 if (&quot;KeyResolver&quot;.equals(tag)){
303                     Element[] resolverElem =
304                         XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;Resolver&quot;);
305                     List&lt;String&gt; classNames = new ArrayList&lt;&gt;(resolverElem.length);
306                     for (Element element : resolverElem) {
307                         String javaClass =
308                             element.getAttributeNS(null, &quot;JAVACLASS&quot;);
309                         String description =
310                             element.getAttributeNS(null, &quot;DESCRIPTION&quot;);
311 
312                         if (description != null &amp;&amp; description.length() &gt; 0) {
313                             LOG.debug(&quot;Register Resolver: {}: {}&quot;, javaClass, description);
314                         } else {
315                             LOG.debug(&quot;Register Resolver: {}: For unknown purposes&quot;, javaClass);
316                         }
317                         classNames.add(javaClass);
318                     }
319                     KeyResolver.registerClassNames(classNames);
320                 }
321 
322 
323                 if (&quot;PrefixMappings&quot;.equals(tag)){
324                     LOG.debug(&quot;Now I try to bind prefixes:&quot;);
325 
326                     Element[] nl =
327                         XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;PrefixMapping&quot;);
328 
329                     for (Element element : nl) {
330                         String namespace = element.getAttributeNS(null, &quot;namespace&quot;);
331                         String prefix = element.getAttributeNS(null, &quot;prefix&quot;);
332                         LOG.debug(&quot;Now I try to bind {} to {}&quot;, prefix, namespace);
333                         ElementProxy.setDefaultPrefix(namespace, prefix);
334                     }
335                 }
336             }
337         } catch (Exception e) {
338             LOG.error(&quot;Bad: &quot;, e);
339         }
340     }
341 
342 }
343 
    </pre>
  </body>
</html>
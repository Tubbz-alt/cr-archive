<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/utils/XMLUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * reserved comment block
   3  * DO NOT REMOVE OR ALTER!
   4  */
   5 /**
   6  * Licensed to the Apache Software Foundation (ASF) under one
   7  * or more contributor license agreements. See the NOTICE file
   8  * distributed with this work for additional information
   9  * regarding copyright ownership. The ASF licenses this file
  10  * to you under the Apache License, Version 2.0 (the
  11  * &quot;License&quot;); you may not use this file except in compliance
  12  * with the License. You may obtain a copy of the License at
  13  *
  14  * http://www.apache.org/licenses/LICENSE-2.0
  15  *
  16  * Unless required by applicable law or agreed to in writing,
  17  * software distributed under the License is distributed on an
  18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  19  * KIND, either express or implied. See the License for the
  20  * specific language governing permissions and limitations
  21  * under the License.
  22  */
  23 package com.sun.org.apache.xml.internal.security.utils;
  24 
  25 import java.io.IOException;
  26 import java.io.InputStream;
  27 import java.io.OutputStream;
  28 import java.math.BigInteger;
  29 import java.security.AccessController;
  30 import java.security.PrivilegedAction;
  31 import java.util.ArrayList;
  32 import java.util.Base64;
  33 import java.util.Collections;
  34 import java.util.HashSet;
  35 import java.util.Iterator;
  36 import java.util.List;
  37 import java.util.Map;
  38 import java.util.Queue;
  39 import java.util.Set;
  40 import java.util.WeakHashMap;
  41 import java.util.concurrent.ArrayBlockingQueue;
  42 
  43 import javax.xml.parsers.DocumentBuilder;
  44 import javax.xml.parsers.DocumentBuilderFactory;
  45 import javax.xml.parsers.ParserConfigurationException;
  46 
  47 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
  48 import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
  49 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
  50 import org.w3c.dom.Attr;
  51 import org.w3c.dom.Document;
  52 import org.w3c.dom.Element;
  53 import org.w3c.dom.NamedNodeMap;
  54 import org.w3c.dom.Node;
  55 import org.w3c.dom.NodeList;
  56 import org.w3c.dom.Text;
  57 import org.xml.sax.InputSource;
  58 import org.xml.sax.SAXException;
  59 
  60 /**
  61  * DOM and XML accessibility and comfort functions.
  62  *
  63  */
  64 public final class XMLUtils {
  65 
  66     private static boolean ignoreLineBreaks =
  67         AccessController.doPrivileged(
  68             (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;com.sun.org.apache.xml.internal.security.ignoreLineBreaks&quot;));
  69     private static int parserPoolSize =
  70         AccessController.doPrivileged(
  71             (PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.getInteger(&quot;com.sun.org.apache.xml.internal.security.parser.pool-size&quot;, 20));
  72 
  73     private static volatile String dsPrefix = &quot;ds&quot;;
  74     private static volatile String ds11Prefix = &quot;dsig11&quot;;
  75     private static volatile String xencPrefix = &quot;xenc&quot;;
  76     private static volatile String xenc11Prefix = &quot;xenc11&quot;;
  77 
  78     private static final com.sun.org.slf4j.internal.Logger LOG =
  79         com.sun.org.slf4j.internal.LoggerFactory.getLogger(XMLUtils.class);
  80 
  81     private static final Map&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt; DOCUMENT_BUILDERS =
  82         Collections.synchronizedMap(new WeakHashMap&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt;());
  83 
  84     private static final Map&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt; DOCUMENT_BUILDERS_DISALLOW_DOCTYPE =
  85         Collections.synchronizedMap(new WeakHashMap&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt;());
  86 
  87     /**
  88      * Constructor XMLUtils
  89      *
  90      */
  91     private XMLUtils() {
  92         // we don&#39;t allow instantiation
  93     }
  94 
  95     /**
  96      * Set the prefix for the digital signature namespace
  97      * @param prefix the new prefix for the digital signature namespace
  98      * @throws SecurityException if a security manager is installed and the
  99      *    caller does not have permission to set the prefix
 100      */
 101     public static void setDsPrefix(String prefix) {
 102         JavaUtils.checkRegisterPermission();
 103         dsPrefix = prefix;
 104     }
 105 
 106     /**
 107      * Set the prefix for the digital signature 1.1 namespace
 108      * @param prefix the new prefix for the digital signature 1.1 namespace
 109      * @throws SecurityException if a security manager is installed and the
 110      *    caller does not have permission to set the prefix
 111      */
 112     public static void setDs11Prefix(String prefix) {
 113         JavaUtils.checkRegisterPermission();
 114         ds11Prefix = prefix;
 115     }
 116 
 117     /**
 118      * Set the prefix for the encryption namespace
 119      * @param prefix the new prefix for the encryption namespace
 120      * @throws SecurityException if a security manager is installed and the
 121      *    caller does not have permission to set the prefix
 122      */
 123     public static void setXencPrefix(String prefix) {
 124         JavaUtils.checkRegisterPermission();
 125         xencPrefix = prefix;
 126     }
 127 
 128     /**
 129      * Set the prefix for the encryption namespace 1.1
 130      * @param prefix the new prefix for the encryption namespace 1.1
 131      * @throws SecurityException if a security manager is installed and the
 132      *    caller does not have permission to set the prefix
 133      */
 134     public static void setXenc11Prefix(String prefix) {
 135         JavaUtils.checkRegisterPermission();
 136         xenc11Prefix = prefix;
 137     }
 138 
 139     public static Element getNextElement(Node el) {
 140         Node node = el;
 141         while (node != null &amp;&amp; node.getNodeType() != Node.ELEMENT_NODE) {
 142             node = node.getNextSibling();
 143         }
 144         return (Element)node;
 145     }
 146 
 147     /**
 148      * @param rootNode
 149      * @param result
 150      * @param exclude
 151      * @param com whether comments or not
 152      */
 153     public static void getSet(Node rootNode, Set&lt;Node&gt; result, Node exclude, boolean com) {
 154         if (exclude != null &amp;&amp; isDescendantOrSelf(exclude, rootNode)) {
 155             return;
 156         }
 157         getSetRec(rootNode, result, exclude, com);
 158     }
 159 
 160     @SuppressWarnings(&quot;fallthrough&quot;)
 161     private static void getSetRec(final Node rootNode, final Set&lt;Node&gt; result,
 162                                 final Node exclude, final boolean com) {
 163         if (rootNode == exclude) {
 164             return;
 165         }
 166         switch (rootNode.getNodeType()) { //NOPMD
 167         case Node.ELEMENT_NODE:
 168             result.add(rootNode);
 169             Element el = (Element)rootNode;
 170             if (el.hasAttributes()) {
 171                 NamedNodeMap nl = el.getAttributes();
 172                 int length = nl.getLength();
 173                 for (int i = 0; i &lt; length; i++) {
 174                     result.add(nl.item(i));
 175                 }
 176             }
 177             //no return keep working
 178         case Node.DOCUMENT_NODE:
 179             for (Node r = rootNode.getFirstChild(); r != null; r = r.getNextSibling()) {
 180                 if (r.getNodeType() == Node.TEXT_NODE) {
 181                     result.add(r);
 182                     while (r != null &amp;&amp; r.getNodeType() == Node.TEXT_NODE) {
 183                         r = r.getNextSibling();
 184                     }
 185                     if (r == null) {
 186                         return;
 187                     }
 188                 }
 189                 getSetRec(r, result, exclude, com);
 190             }
 191             break;
 192         case Node.COMMENT_NODE:
 193             if (com) {
 194                 result.add(rootNode);
 195             }
 196             break;
 197         case Node.DOCUMENT_TYPE_NODE:
 198             break;
 199         default:
 200             result.add(rootNode);
 201         }
 202     }
 203 
 204     /**
 205      * Outputs a DOM tree to an {@link OutputStream}.
 206      *
 207      * @param contextNode root node of the DOM tree
 208      * @param os the {@link OutputStream}
 209      */
 210     public static void outputDOM(Node contextNode, OutputStream os) {
 211         XMLUtils.outputDOM(contextNode, os, false);
 212     }
 213 
 214     /**
 215      * Outputs a DOM tree to an {@link OutputStream}. &lt;I&gt;If an Exception is
 216      * thrown during execution, it&#39;s StackTrace is output to System.out, but the
 217      * Exception is not re-thrown.&lt;/I&gt;
 218      *
 219      * @param contextNode root node of the DOM tree
 220      * @param os the {@link OutputStream}
 221      * @param addPreamble
 222      */
 223     public static void outputDOM(Node contextNode, OutputStream os, boolean addPreamble) {
 224         try {
 225             if (addPreamble) {
 226                 os.write(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;.getBytes(java.nio.charset.StandardCharsets.UTF_8));
 227             }
 228 
 229             os.write(Canonicalizer.getInstance(
 230                 Canonicalizer.ALGO_ID_C14N_PHYSICAL).canonicalizeSubtree(contextNode)
 231             );
 232         } catch (IOException ex) {
 233             LOG.debug(ex.getMessage(), ex);
 234         }
 235         catch (InvalidCanonicalizerException ex) {
 236             LOG.debug(ex.getMessage(), ex);
 237         } catch (CanonicalizationException ex) {
 238             LOG.debug(ex.getMessage(), ex);
 239         }
 240     }
 241 
 242     /**
 243      * Serializes the {@code contextNode} into the OutputStream, &lt;I&gt;but
 244      * suppresses all Exceptions&lt;/I&gt;.
 245      * &lt;p&gt;&lt;/p&gt;
 246      * NOTE: &lt;I&gt;This should only be used for debugging purposes,
 247      * NOT in a production environment; this method ignores all exceptions,
 248      * so you won&#39;t notice if something goes wrong. If you&#39;re asking what is to
 249      * be used in a production environment, simply use the code inside the
 250      * {@code try{}} statement, but handle the Exceptions appropriately.&lt;/I&gt;
 251      *
 252      * @param contextNode
 253      * @param os
 254      */
 255     public static void outputDOMc14nWithComments(Node contextNode, OutputStream os) {
 256         try {
 257             os.write(Canonicalizer.getInstance(
 258                 Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS).canonicalizeSubtree(contextNode)
 259             );
 260         } catch (IOException ex) {
 261             LOG.debug(ex.getMessage(), ex);
 262             // throw new RuntimeException(ex.getMessage());
 263         } catch (InvalidCanonicalizerException ex) {
 264             LOG.debug(ex.getMessage(), ex);
 265             // throw new RuntimeException(ex.getMessage());
 266         } catch (CanonicalizationException ex) {
 267             LOG.debug(ex.getMessage(), ex);
 268             // throw new RuntimeException(ex.getMessage());
 269         }
 270     }
 271 
 272     @Deprecated
 273     public static String getFullTextChildrenFromElement(Element element) {
 274         return getFullTextChildrenFromNode(element);
 275     }
 276 
 277     /**
 278      * Method getFullTextChildrenFromNode
 279      *
 280      * @param node
 281      * @return the string of children
 282      */
 283     public static String getFullTextChildrenFromNode(Node node) {
 284         StringBuilder sb = new StringBuilder();
 285 
 286         Node child = node.getFirstChild();
 287         while (child != null) {
 288             if (child.getNodeType() == Node.TEXT_NODE) {
 289                 sb.append(((Text)child).getData());
 290             }
 291             child = child.getNextSibling();
 292         }
 293 
 294         return sb.toString();
 295     }
 296 
 297     /**
 298      * Creates an Element in the XML Signature specification namespace.
 299      *
 300      * @param doc the factory Document
 301      * @param elementName the local name of the Element
 302      * @return the Element
 303      */
 304     public static Element createElementInSignatureSpace(Document doc, String elementName) {
 305         if (doc == null) {
 306             throw new RuntimeException(&quot;Document is null&quot;);
 307         }
 308 
 309         if (dsPrefix == null || dsPrefix.length() == 0) {
 310             return doc.createElementNS(Constants.SignatureSpecNS, elementName);
 311         }
 312         return doc.createElementNS(Constants.SignatureSpecNS, dsPrefix + &quot;:&quot; + elementName);
 313     }
 314 
 315     /**
 316      * Creates an Element in the XML Signature 1.1 specification namespace.
 317      *
 318      * @param doc the factory Document
 319      * @param elementName the local name of the Element
 320      * @return the Element
 321      */
 322     public static Element createElementInSignature11Space(Document doc, String elementName) {
 323         if (doc == null) {
 324             throw new RuntimeException(&quot;Document is null&quot;);
 325         }
 326 
 327         if (ds11Prefix == null || ds11Prefix.length() == 0) {
 328             return doc.createElementNS(Constants.SignatureSpec11NS, elementName);
 329         }
 330         return doc.createElementNS(Constants.SignatureSpec11NS, ds11Prefix + &quot;:&quot; + elementName);
 331     }
 332 
 333     /**
 334      * Returns true if the element is in XML Signature namespace and the local
 335      * name equals the supplied one.
 336      *
 337      * @param element
 338      * @param localName
 339      * @return true if the element is in XML Signature namespace and the local name equals
 340      * the supplied one
 341      */
 342     public static boolean elementIsInSignatureSpace(Element element, String localName) {
 343         if (element == null){
 344             return false;
 345         }
 346 
 347         return Constants.SignatureSpecNS.equals(element.getNamespaceURI())
 348             &amp;&amp; element.getLocalName().equals(localName);
 349     }
 350 
 351     /**
 352      * Returns true if the element is in XML Signature 1.1 namespace and the local
 353      * name equals the supplied one.
 354      *
 355      * @param element
 356      * @param localName
 357      * @return true if the element is in XML Signature namespace and the local name equals
 358      * the supplied one
 359      */
 360     public static boolean elementIsInSignature11Space(Element element, String localName) {
 361         if (element == null) {
 362             return false;
 363         }
 364 
 365         return Constants.SignatureSpec11NS.equals(element.getNamespaceURI())
 366             &amp;&amp; element.getLocalName().equals(localName);
 367     }
 368 
 369     /**
 370      * This method returns the owner document of a particular node.
 371      * This method is necessary because it &lt;I&gt;always&lt;/I&gt; returns a
 372      * {@link Document}. {@link Node#getOwnerDocument} returns {@code null}
 373      * if the {@link Node} is a {@link Document}.
 374      *
 375      * @param node
 376      * @return the owner document of the node
 377      */
 378     public static Document getOwnerDocument(Node node) {
 379         if (node.getNodeType() == Node.DOCUMENT_NODE) {
 380             return (Document) node;
 381         }
 382         try {
 383             return node.getOwnerDocument();
 384         } catch (NullPointerException npe) {
 385             throw new NullPointerException(I18n.translate(&quot;endorsed.jdk1.4.0&quot;)
 386                                            + &quot; Original message was \&quot;&quot;
 387                                            + npe.getMessage() + &quot;\&quot;&quot;);
 388         }
 389     }
 390 
 391     /**
 392      * This method returns the first non-null owner document of the Nodes in this Set.
 393      * This method is necessary because it &lt;I&gt;always&lt;/I&gt; returns a
 394      * {@link Document}. {@link Node#getOwnerDocument} returns {@code null}
 395      * if the {@link Node} is a {@link Document}.
 396      *
 397      * @param xpathNodeSet
 398      * @return the owner document
 399      */
 400     public static Document getOwnerDocument(Set&lt;Node&gt; xpathNodeSet) {
 401         NullPointerException npe = null;
 402         for (Node node : xpathNodeSet) {
 403             int nodeType = node.getNodeType();
 404             if (nodeType == Node.DOCUMENT_NODE) {
 405                 return (Document) node;
 406             }
 407             try {
 408                 if (nodeType == Node.ATTRIBUTE_NODE) {
 409                     return ((Attr)node).getOwnerElement().getOwnerDocument();
 410                 }
 411                 return node.getOwnerDocument();
 412             } catch (NullPointerException e) {
 413                 npe = e;
 414             }
 415         }
 416 
 417         throw new NullPointerException(I18n.translate(&quot;endorsed.jdk1.4.0&quot;)
 418                                        + &quot; Original message was \&quot;&quot;
 419                                        + (npe == null ? &quot;&quot; : npe.getMessage()) + &quot;\&quot;&quot;);
 420     }
 421 
 422     /**
 423      * Method createDSctx
 424      *
 425      * @param doc
 426      * @param prefix
 427      * @param namespace
 428      * @return the element.
 429      */
 430     public static Element createDSctx(Document doc, String prefix, String namespace) {
 431         if (prefix == null || prefix.trim().length() == 0) {
 432             throw new IllegalArgumentException(&quot;You must supply a prefix&quot;);
 433         }
 434 
 435         Element ctx = doc.createElementNS(null, &quot;namespaceContext&quot;);
 436 
 437         ctx.setAttributeNS(Constants.NamespaceSpecNS, &quot;xmlns:&quot; + prefix.trim(), namespace);
 438 
 439         return ctx;
 440     }
 441 
 442     /**
 443      * Method addReturnToElement
 444      *
 445      * @param e
 446      */
 447     public static void addReturnToElement(Element e) {
 448         if (!ignoreLineBreaks) {
 449             Document doc = e.getOwnerDocument();
 450             e.appendChild(doc.createTextNode(&quot;\n&quot;));
 451         }
 452     }
 453 
 454     public static void addReturnToElement(Document doc, HelperNodeList nl) {
 455         if (!ignoreLineBreaks) {
 456             nl.appendChild(doc.createTextNode(&quot;\n&quot;));
 457         }
 458     }
 459 
 460     public static void addReturnBeforeChild(Element e, Node child) {
 461         if (!ignoreLineBreaks) {
 462             Document doc = e.getOwnerDocument();
 463             e.insertBefore(doc.createTextNode(&quot;\n&quot;), child);
 464         }
 465     }
 466 
 467     public static String encodeToString(byte[] bytes) {
 468         if (ignoreLineBreaks) {
 469             return Base64.getEncoder().encodeToString(bytes);
 470         }
 471         return Base64.getMimeEncoder().encodeToString(bytes);
 472     }
 473 
 474     public static byte[] decode(String encodedString) {
 475         return Base64.getMimeDecoder().decode(encodedString);
 476     }
 477 
 478     public static byte[] decode(byte[] encodedBytes) {
 479         return Base64.getMimeDecoder().decode(encodedBytes);
 480     }
 481 
 482     public static boolean isIgnoreLineBreaks() {
 483         return ignoreLineBreaks;
 484     }
 485 
 486     /**
 487      * Method convertNodelistToSet
 488      *
 489      * @param xpathNodeSet
 490      * @return the set with the nodelist
 491      */
 492     public static Set&lt;Node&gt; convertNodelistToSet(NodeList xpathNodeSet) {
 493         if (xpathNodeSet == null) {
 494             return new HashSet&lt;&gt;();
 495         }
 496 
 497         int length = xpathNodeSet.getLength();
 498         Set&lt;Node&gt; set = new HashSet&lt;&gt;(length);
 499 
 500         for (int i = 0; i &lt; length; i++) {
 501             set.add(xpathNodeSet.item(i));
 502         }
 503 
 504         return set;
 505     }
 506 
 507     /**
 508      * This method spreads all namespace attributes in a DOM document to their
 509      * children. This is needed because the XML Signature XPath transform
 510      * must evaluate the XPath against all nodes in the input, even against
 511      * XPath namespace nodes. Through a bug in XalanJ2, the namespace nodes are
 512      * not fully visible in the Xalan XPath model, so we have to do this by
 513      * hand in DOM spaces so that the nodes become visible in XPath space.
 514      *
 515      * @param doc
 516      * @see &lt;A HREF=&quot;http://nagoya.apache.org/bugzilla/show_bug.cgi?id=2650&quot;&gt;
 517      * Namespace axis resolution is not XPath compliant &lt;/A&gt;
 518      */
 519     public static void circumventBug2650(Document doc) {
 520 
 521         Element documentElement = doc.getDocumentElement();
 522 
 523         // if the document element has no xmlns definition, we add xmlns=&quot;&quot;
 524         Attr xmlnsAttr =
 525             documentElement.getAttributeNodeNS(Constants.NamespaceSpecNS, &quot;xmlns&quot;);
 526 
 527         if (xmlnsAttr == null) {
 528             documentElement.setAttributeNS(Constants.NamespaceSpecNS, &quot;xmlns&quot;, &quot;&quot;);
 529         }
 530 
 531         XMLUtils.circumventBug2650internal(doc);
 532     }
 533 
 534     /**
 535      * This is the work horse for {@link #circumventBug2650}.
 536      *
 537      * @param node
 538      * @see &lt;A HREF=&quot;http://nagoya.apache.org/bugzilla/show_bug.cgi?id=2650&quot;&gt;
 539      * Namespace axis resolution is not XPath compliant &lt;/A&gt;
 540      */
 541     @SuppressWarnings(&quot;fallthrough&quot;)
 542     private static void circumventBug2650internal(Node node) {
 543         Node parent = null;
 544         Node sibling = null;
 545         final String namespaceNs = Constants.NamespaceSpecNS;
 546         do {
 547             switch (node.getNodeType()) {
 548             case Node.ELEMENT_NODE :
 549                 Element element = (Element) node;
 550                 if (!element.hasChildNodes()) {
 551                     break;
 552                 }
 553                 if (element.hasAttributes()) {
 554                     NamedNodeMap attributes = element.getAttributes();
 555                     int attributesLength = attributes.getLength();
 556 
 557                     for (Node child = element.getFirstChild(); child!=null;
 558                         child = child.getNextSibling()) {
 559 
 560                         if (child.getNodeType() != Node.ELEMENT_NODE) {
 561                             continue;
 562                         }
 563                         Element childElement = (Element) child;
 564 
 565                         for (int i = 0; i &lt; attributesLength; i++) {
 566                             Attr currentAttr = (Attr) attributes.item(i);
 567                             if (!namespaceNs.equals(currentAttr.getNamespaceURI())) {
 568                                 continue;
 569                             }
 570                             if (childElement.hasAttributeNS(namespaceNs,
 571                                                             currentAttr.getLocalName())) {
 572                                 continue;
 573                             }
 574                             childElement.setAttributeNS(namespaceNs,
 575                                                         currentAttr.getName(),
 576                                                         currentAttr.getNodeValue());
 577                         }
 578                     }
 579                 }
 580             case Node.ENTITY_REFERENCE_NODE :
 581             case Node.DOCUMENT_NODE :
 582                 parent = node;
 583                 sibling = node.getFirstChild();
 584                 break;
 585             }
 586             while (sibling == null &amp;&amp; parent != null) {
 587                 sibling = parent.getNextSibling();
 588                 parent = parent.getParentNode();
 589             }
 590             if (sibling == null) {
 591                 return;
 592             }
 593 
 594             node = sibling;
 595             sibling = node.getNextSibling();
 596         } while (true);
 597     }
 598 
 599     /**
 600      * @param sibling
 601      * @param nodeName
 602      * @param number
 603      * @return nodes with the constraint
 604      */
 605     public static Element selectDsNode(Node sibling, String nodeName, int number) {
 606         while (sibling != null) {
 607             if (Constants.SignatureSpecNS.equals(sibling.getNamespaceURI())
 608                 &amp;&amp; sibling.getLocalName().equals(nodeName)) {
 609                 if (number == 0){
 610                     return (Element)sibling;
 611                 }
 612                 number--;
 613             }
 614             sibling = sibling.getNextSibling();
 615         }
 616         return null;
 617     }
 618 
 619     /**
 620      * @param sibling
 621      * @param nodeName
 622      * @param number
 623      * @return nodes with the constraint
 624      */
 625     public static Element selectDs11Node(Node sibling, String nodeName, int number) {
 626         while (sibling != null) {
 627             if (Constants.SignatureSpec11NS.equals(sibling.getNamespaceURI())
 628                 &amp;&amp; sibling.getLocalName().equals(nodeName)) {
 629                 if (number == 0){
 630                     return (Element)sibling;
 631                 }
 632                 number--;
 633             }
 634             sibling = sibling.getNextSibling();
 635         }
 636         return null;
 637     }
 638 
 639     /**
 640      * @param sibling
 641      * @param nodeName
 642      * @param number
 643      * @return nodes with the constrain
 644      */
 645     public static Text selectDsNodeText(Node sibling, String nodeName, int number) {
 646         Node n = selectDsNode(sibling, nodeName, number);
 647         if (n == null) {
 648             return null;
 649         }
 650         n = n.getFirstChild();
 651         while (n != null &amp;&amp; n.getNodeType() != Node.TEXT_NODE) {
 652             n = n.getNextSibling();
 653         }
 654         return (Text)n;
 655     }
 656 
 657     /**
 658      * @param sibling
 659      * @param nodeName
 660      * @param number
 661      * @return nodes with the constrain
 662      */
 663     public static Text selectDs11NodeText(Node sibling, String nodeName, int number) {
 664         Node n = selectDs11Node(sibling, nodeName, number);
 665         if (n == null) {
 666             return null;
 667         }
 668         n = n.getFirstChild();
 669         while (n != null &amp;&amp; n.getNodeType() != Node.TEXT_NODE) {
 670             n = n.getNextSibling();
 671         }
 672         return (Text)n;
 673     }
 674 
 675     /**
 676      * @param sibling
 677      * @param uri
 678      * @param nodeName
 679      * @param number
 680      * @return nodes with the constrain
 681      */
 682     public static Text selectNodeText(Node sibling, String uri, String nodeName, int number) {
 683         Node n = selectNode(sibling, uri, nodeName, number);
 684         if (n == null) {
 685             return null;
 686         }
 687         n = n.getFirstChild();
 688         while (n != null &amp;&amp; n.getNodeType() != Node.TEXT_NODE) {
 689             n = n.getNextSibling();
 690         }
 691         return (Text)n;
 692     }
 693 
 694     /**
 695      * @param sibling
 696      * @param uri
 697      * @param nodeName
 698      * @param number
 699      * @return nodes with the constrain
 700      */
 701     public static Element selectNode(Node sibling, String uri, String nodeName, int number) {
 702         while (sibling != null) {
 703             if (sibling.getNamespaceURI() != null &amp;&amp; sibling.getNamespaceURI().equals(uri)
 704                 &amp;&amp; sibling.getLocalName().equals(nodeName)) {
 705                 if (number == 0) {
 706                     return (Element)sibling;
 707                 }
 708                 number--;
 709             }
 710             sibling = sibling.getNextSibling();
 711         }
 712         return null;
 713     }
 714 
 715     /**
 716      * @param sibling
 717      * @param nodeName
 718      * @return nodes with the constrain
 719      */
 720     public static Element[] selectDsNodes(Node sibling, String nodeName) {
 721         return selectNodes(sibling, Constants.SignatureSpecNS, nodeName);
 722     }
 723 
 724     /**
 725      * @param sibling
 726      * @param nodeName
 727      * @return nodes with the constrain
 728      */
 729     public static Element[] selectDs11Nodes(Node sibling, String nodeName) {
 730         return selectNodes(sibling, Constants.SignatureSpec11NS, nodeName);
 731     }
 732 
 733     /**
 734      * @param sibling
 735      * @param uri
 736      * @param nodeName
 737      * @return nodes with the constraint
 738      */
 739     public static Element[] selectNodes(Node sibling, String uri, String nodeName) {
 740         List&lt;Element&gt; list = new ArrayList&lt;&gt;();
 741         while (sibling != null) {
 742             if (sibling.getNamespaceURI() != null &amp;&amp; sibling.getNamespaceURI().equals(uri)
 743                 &amp;&amp; sibling.getLocalName().equals(nodeName)) {
 744                 list.add((Element)sibling);
 745             }
 746             sibling = sibling.getNextSibling();
 747         }
 748         return list.toArray(new Element[list.size()]);
 749     }
 750 
 751     /**
 752      * @param signatureElement
 753      * @param inputSet
 754      * @return nodes with the constrain
 755      */
 756     public static Set&lt;Node&gt; excludeNodeFromSet(Node signatureElement, Set&lt;Node&gt; inputSet) {
 757         Set&lt;Node&gt; resultSet = new HashSet&lt;&gt;();
 758         Iterator&lt;Node&gt; iterator = inputSet.iterator();
 759 
 760         while (iterator.hasNext()) {
 761             Node inputNode = iterator.next();
 762 
 763             if (!XMLUtils.isDescendantOrSelf(signatureElement, inputNode)) {
 764                 resultSet.add(inputNode);
 765             }
 766         }
 767         return resultSet;
 768     }
 769 
 770     /**
 771      * Method getStrFromNode
 772      *
 773      * @param xpathnode
 774      * @return the string for the node.
 775      */
 776     public static String getStrFromNode(Node xpathnode) {
 777         if (xpathnode.getNodeType() == Node.TEXT_NODE) {
 778             // we iterate over all siblings of the context node because eventually,
 779             // the text is &quot;polluted&quot; with pi&#39;s or comments
 780             StringBuilder sb = new StringBuilder();
 781 
 782             for (Node currentSibling = xpathnode.getParentNode().getFirstChild();
 783                 currentSibling != null;
 784                 currentSibling = currentSibling.getNextSibling()) {
 785                 if (currentSibling.getNodeType() == Node.TEXT_NODE) {
 786                     sb.append(((Text) currentSibling).getData());
 787                 }
 788             }
 789 
 790             return sb.toString();
 791         } else if (xpathnode.getNodeType() == Node.ATTRIBUTE_NODE) {
 792             return xpathnode.getNodeValue();
 793         } else if (xpathnode.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
 794             return xpathnode.getNodeValue();
 795         }
 796 
 797         return null;
 798     }
 799 
 800     /**
 801      * Returns true if the descendantOrSelf is on the descendant-or-self axis
 802      * of the context node.
 803      *
 804      * @param ctx
 805      * @param descendantOrSelf
 806      * @return true if the node is descendant
 807      */
 808     public static boolean isDescendantOrSelf(Node ctx, Node descendantOrSelf) {
 809         if (ctx == descendantOrSelf) {
 810             return true;
 811         }
 812 
 813         Node parent = descendantOrSelf;
 814 
 815         while (true) {
 816             if (parent == null) {
 817                 return false;
 818             }
 819 
 820             if (parent == ctx) {
 821                 return true;
 822             }
 823 
 824             if (parent.getNodeType() == Node.ATTRIBUTE_NODE) {
 825                 parent = ((Attr) parent).getOwnerElement();
 826             } else {
 827                 parent = parent.getParentNode();
 828             }
 829         }
 830     }
 831 
 832     public static boolean ignoreLineBreaks() {
 833         return ignoreLineBreaks;
 834     }
 835 
 836     /**
 837      * Returns the attribute value for the attribute with the specified name.
 838      * Returns null if there is no such attribute, or
 839      * the empty string if the attribute value is empty.
 840      *
 841      * &lt;p&gt;This works around a limitation of the DOM
 842      * {@code Element.getAttributeNode} method, which does not distinguish
 843      * between an unspecified attribute and an attribute with a value of
 844      * &quot;&quot; (it returns &quot;&quot; for both cases).
 845      *
 846      * @param elem the element containing the attribute
 847      * @param name the name of the attribute
 848      * @return the attribute value (may be null if unspecified)
 849      */
 850     public static String getAttributeValue(Element elem, String name) {
 851         Attr attr = elem.getAttributeNodeNS(null, name);
 852         return (attr == null) ? null : attr.getValue();
 853     }
 854 
 855     /**
 856      * This method is a tree-search to help prevent against wrapping attacks. It checks that no
 857      * two Elements have ID Attributes that match the &quot;value&quot; argument, if this is the case then
 858      * &quot;false&quot; is returned. Note that a return value of &quot;true&quot; does not necessarily mean that
 859      * a matching Element has been found, just that no wrapping attack has been detected.
 860      */
 861     public static boolean protectAgainstWrappingAttack(Node startNode, String value) {
 862         String id = value.trim();
 863         if (!id.isEmpty() &amp;&amp; id.charAt(0) == &#39;#&#39;) {
 864             id = id.substring(1);
 865         }
 866 
 867         Node startParent = null;
 868         Node processedNode = null;
 869         Element foundElement = null;
 870         if (startNode != null) {
 871             startParent = startNode.getParentNode();
 872         }
 873 
 874         while (startNode != null) {
 875             if (startNode.getNodeType() == Node.ELEMENT_NODE) {
 876                 Element se = (Element) startNode;
 877 
 878                 NamedNodeMap attributes = se.getAttributes();
 879                 if (attributes != null) {
 880                     int length = attributes.getLength();
 881                     for (int i = 0; i &lt; length; i++) {
 882                         Attr attr = (Attr)attributes.item(i);
 883                         if (attr.isId() &amp;&amp; id.equals(attr.getValue())) {
 884                             if (foundElement == null) {
 885                                 // Continue searching to find duplicates
 886                                 foundElement = attr.getOwnerElement();
 887                             } else {
 888                                 LOG.debug(&quot;Multiple elements with the same &#39;Id&#39; attribute value!&quot;);
 889                                 return false;
 890                             }
 891                         }
 892                     }
 893                 }
 894             }
 895 
 896             processedNode = startNode;
 897             startNode = startNode.getFirstChild();
 898 
 899             // no child, this node is done.
 900             if (startNode == null) {
 901                 // close node processing, get sibling
 902                 startNode = processedNode.getNextSibling();
 903             }
 904 
 905             // no more siblings, get parent, all children
 906             // of parent are processed.
 907             while (startNode == null) {
 908                 processedNode = processedNode.getParentNode();
 909                 if (processedNode == startParent) {
 910                     return true;
 911                 }
 912                 // close parent node processing (processed node now)
 913                 startNode = processedNode.getNextSibling();
 914             }
 915         }
 916         return true;
 917     }
 918 
 919     /**
 920      * This method is a tree-search to help prevent against wrapping attacks. It checks that no other
 921      * Element than the given &quot;knownElement&quot; argument has an ID attribute that matches the &quot;value&quot;
 922      * argument, which is the ID value of &quot;knownElement&quot;. If this is the case then &quot;false&quot; is returned.
 923      */
 924     public static boolean protectAgainstWrappingAttack(
 925         Node startNode, Element knownElement, String value
 926     ) {
 927         String id = value.trim();
 928         if (!id.isEmpty() &amp;&amp; id.charAt(0) == &#39;#&#39;) {
 929             id = id.substring(1);
 930         }
 931 
 932         Node startParent = null;
 933         Node processedNode = null;
 934         if (startNode != null) {
 935             startParent = startNode.getParentNode();
 936         }
 937 
 938         while (startNode != null) {
 939             if (startNode.getNodeType() == Node.ELEMENT_NODE) {
 940                 Element se = (Element) startNode;
 941 
 942                 NamedNodeMap attributes = se.getAttributes();
 943                 if (attributes != null) {
 944                     int length = attributes.getLength();
 945                     for (int i = 0; i &lt; length; i++) {
 946                         Attr attr = (Attr)attributes.item(i);
 947                         if (attr.isId() &amp;&amp; id.equals(attr.getValue()) &amp;&amp; se != knownElement) {
 948                             LOG.debug(&quot;Multiple elements with the same &#39;Id&#39; attribute value!&quot;);
 949                             return false;
 950                         }
 951                     }
 952                 }
 953             }
 954 
 955             processedNode = startNode;
 956             startNode = startNode.getFirstChild();
 957 
 958             // no child, this node is done.
 959             if (startNode == null) {
 960                 // close node processing, get sibling
 961                 startNode = processedNode.getNextSibling();
 962             }
 963 
 964             // no more siblings, get parent, all children
 965             // of parent are processed.
 966             while (startNode == null) {
 967                 processedNode = processedNode.getParentNode();
 968                 if (processedNode == startParent) {
 969                     return true;
 970                 }
 971                 // close parent node processing (processed node now)
 972                 startNode = processedNode.getNextSibling();
 973             }
 974         }
 975         return true;
 976     }
 977 
 978     public static Document newDocument() throws ParserConfigurationException {
 979         ClassLoader loader = getContextClassLoader();
 980         if (loader == null) {
 981             loader = getClassLoader(XMLUtils.class);
 982         }
 983         // If the ClassLoader is null then just create a DocumentBuilder and use it
 984         if (loader == null) {
 985             DocumentBuilder documentBuilder = buildDocumentBuilder(true);
 986             return documentBuilder.newDocument();
 987         }
 988 
 989         Queue&lt;DocumentBuilder&gt; queue = getDocumentBuilderQueue(true, loader);
 990         DocumentBuilder documentBuilder = getDocumentBuilder(true, queue);
 991         Document doc = documentBuilder.newDocument();
 992         repoolDocumentBuilder(documentBuilder, queue);
 993         return doc;
 994     }
 995 
 996     public static Document read(InputStream inputStream) throws ParserConfigurationException, SAXException, IOException {
 997         return read(inputStream, true);
 998     }
 999 
1000     public static Document read(InputStream inputStream, boolean disAllowDocTypeDeclarations) throws ParserConfigurationException, SAXException, IOException {
1001         ClassLoader loader = getContextClassLoader();
1002         if (loader == null) {
1003             loader = getClassLoader(XMLUtils.class);
1004         }
1005         // If the ClassLoader is null then just create a DocumentBuilder and use it
1006         if (loader == null) {
1007             DocumentBuilder documentBuilder = buildDocumentBuilder(disAllowDocTypeDeclarations);
1008             return documentBuilder.parse(inputStream);
1009         }
1010 
1011         Queue&lt;DocumentBuilder&gt; queue = getDocumentBuilderQueue(disAllowDocTypeDeclarations, loader);
1012         DocumentBuilder documentBuilder = getDocumentBuilder(disAllowDocTypeDeclarations, queue);
1013         Document doc = documentBuilder.parse(inputStream);
1014         repoolDocumentBuilder(documentBuilder, queue);
1015         return doc;
1016     }
1017 
1018     public static Document read(String uri, boolean disAllowDocTypeDeclarations)
1019         throws ParserConfigurationException, SAXException, IOException {
1020         ClassLoader loader = getContextClassLoader();
1021         if (loader == null) {
1022             loader = getClassLoader(XMLUtils.class);
1023         }
1024         // If the ClassLoader is null then just create a DocumentBuilder and use it
1025         if (loader == null) {
1026             DocumentBuilder documentBuilder = buildDocumentBuilder(disAllowDocTypeDeclarations);
1027             return documentBuilder.parse(uri);
1028         }
1029 
1030         Queue&lt;DocumentBuilder&gt; queue = getDocumentBuilderQueue(disAllowDocTypeDeclarations, loader);
1031         DocumentBuilder documentBuilder = getDocumentBuilder(disAllowDocTypeDeclarations, queue);
1032         Document doc = documentBuilder.parse(uri);
1033         repoolDocumentBuilder(documentBuilder, queue);
1034         return doc;
1035     }
1036 
1037     public static Document read(InputSource inputSource) throws ParserConfigurationException, SAXException, IOException {
1038         return read(inputSource, true);
1039     }
1040 
1041     public static Document read(InputSource inputSource, boolean disAllowDocTypeDeclarations)
1042         throws ParserConfigurationException, SAXException, IOException {
1043         ClassLoader loader = getContextClassLoader();
1044         if (loader == null) {
1045             loader = getClassLoader(XMLUtils.class);
1046         }
1047         // If the ClassLoader is null then just create a DocumentBuilder and use it
1048         if (loader == null) {
1049             DocumentBuilder documentBuilder = buildDocumentBuilder(disAllowDocTypeDeclarations);
1050             return documentBuilder.parse(inputSource);
1051         }
1052 
1053         Queue&lt;DocumentBuilder&gt; queue = getDocumentBuilderQueue(disAllowDocTypeDeclarations, loader);
1054         DocumentBuilder documentBuilder = getDocumentBuilder(disAllowDocTypeDeclarations, queue);
1055         Document doc = documentBuilder.parse(inputSource);
1056         repoolDocumentBuilder(documentBuilder, queue);
1057         return doc;
1058     }
1059 
1060     /**
1061      * @deprecated Use XMLUtils.read instead to directly read a document.
1062      */
1063     @Deprecated
1064     public static DocumentBuilder createDocumentBuilder(boolean validating) throws ParserConfigurationException {
1065         return createDocumentBuilder(validating, true);
1066     }
1067 
1068     /**
1069      * @deprecated Use XMLUtils.read instead to directly read a document.
1070      */
1071     @Deprecated
1072     public static DocumentBuilder createDocumentBuilder(
1073         boolean validating, boolean disAllowDocTypeDeclarations
1074     ) throws ParserConfigurationException {
1075         DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();
1076         dfactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE);
1077         if (disAllowDocTypeDeclarations) {
1078             dfactory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
1079         }
1080         dfactory.setValidating(validating);
1081         dfactory.setNamespaceAware(true);
1082         return dfactory.newDocumentBuilder();
1083     }
1084 
1085     /**
1086      * @deprecated This method has no effect in Santuario 2.1.4
1087      */
1088     @Deprecated
1089     public static boolean repoolDocumentBuilder(DocumentBuilder db) {
1090         return true;
1091     }
1092 
1093     /**
1094      * Returns a byte-array representation of a {@code {@link BigInteger}}.
1095      * No sign-bit is output.
1096      *
1097      * &lt;b&gt;N.B.:&lt;/B&gt; {@code {@link BigInteger}}&#39;s toByteArray
1098      * returns eventually longer arrays because of the leading sign-bit.
1099      *
1100      * @param big {@code BigInteger} to be converted
1101      * @param bitlen {@code int} the desired length in bits of the representation
1102      * @return a byte array with {@code bitlen} bits of {@code big}
1103      */
1104     public static byte[] getBytes(BigInteger big, int bitlen) {
1105 
1106         //round bitlen
1107         bitlen = ((bitlen + 7) &gt;&gt; 3) &lt;&lt; 3;
1108 
1109         if (bitlen &lt; big.bitLength()) {
1110             throw new IllegalArgumentException(I18n.translate(&quot;utils.Base64.IllegalBitlength&quot;));
1111         }
1112 
1113         byte[] bigBytes = big.toByteArray();
1114 
1115         if (big.bitLength() % 8 != 0
1116             &amp;&amp; big.bitLength() / 8 + 1 == bitlen / 8) {
1117             return bigBytes;
1118         }
1119 
1120         // some copying needed
1121         int startSrc = 0;    // no need to skip anything
1122         int bigLen = bigBytes.length;    //valid length of the string
1123 
1124         if (big.bitLength() % 8 == 0) {    // correct values
1125             startSrc = 1;    // skip sign bit
1126 
1127             bigLen--;    // valid length of the string
1128         }
1129 
1130         int startDst = bitlen / 8 - bigLen;    //pad with leading nulls
1131         byte[] resizedBytes = new byte[bitlen / 8];
1132 
1133         System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, bigLen);
1134 
1135         return resizedBytes;
1136     }
1137 
1138     private static Queue&lt;DocumentBuilder&gt; getDocumentBuilderQueue(boolean disAllowDocTypeDeclarations, ClassLoader loader) throws ParserConfigurationException {
1139         Map&lt;ClassLoader, Queue&lt;DocumentBuilder&gt;&gt; docBuilderCache =
1140             disAllowDocTypeDeclarations ? DOCUMENT_BUILDERS_DISALLOW_DOCTYPE : DOCUMENT_BUILDERS;
1141         Queue&lt;DocumentBuilder&gt; queue = docBuilderCache.get(loader);
1142         if (queue == null) {
1143             queue = new ArrayBlockingQueue&lt;&gt;(parserPoolSize);
1144             docBuilderCache.put(loader, queue);
1145         }
1146 
1147         return queue;
1148     }
1149 
1150     private static DocumentBuilder getDocumentBuilder(boolean disAllowDocTypeDeclarations, Queue&lt;DocumentBuilder&gt; queue) throws ParserConfigurationException {
1151         DocumentBuilder db = queue.poll();
1152         if (db == null) {
1153             db = buildDocumentBuilder(disAllowDocTypeDeclarations);
1154         }
1155         return db;
1156     }
1157 
1158     private static DocumentBuilder buildDocumentBuilder(boolean disAllowDocTypeDeclarations) throws ParserConfigurationException {
1159         DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();
1160         f.setNamespaceAware(true);
1161         f.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);
1162         f.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, disAllowDocTypeDeclarations);
1163         return f.newDocumentBuilder();
1164     }
1165 
1166     private static void repoolDocumentBuilder(DocumentBuilder db, Queue&lt;DocumentBuilder&gt; queue) {
1167         if (queue != null) {
1168             db.reset();
1169             queue.offer(db);
1170         }
1171     }
1172 
1173     private static ClassLoader getContextClassLoader() {
1174         final SecurityManager sm = System.getSecurityManager();
1175         if (sm != null) {
1176             return AccessController.doPrivileged(new PrivilegedAction&lt;ClassLoader&gt;() {
1177                 public ClassLoader run() {
1178                     return Thread.currentThread().getContextClassLoader();
1179                 }
1180             });
1181         }
1182         return Thread.currentThread().getContextClassLoader();
1183     }
1184 
1185     private static ClassLoader getClassLoader(final Class&lt;?&gt; clazz) {
1186         final SecurityManager sm = System.getSecurityManager();
1187         if (sm != null) {
1188             return AccessController.doPrivileged(new PrivilegedAction&lt;ClassLoader&gt;() {
1189                 public ClassLoader run() {
1190                     return clazz.getClassLoader();
1191                 }
1192             });
1193         }
1194         return clazz.getClassLoader();
1195     }
1196 
1197 }
    </pre>
  </body>
</html>
diff a/src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/Manifest.java b/src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/Manifest.java
--- a/src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/Manifest.java
+++ b/src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/Manifest.java
@@ -21,11 +21,14 @@
  * under the License.
  */
 package com.sun.org.apache.xml.internal.security.signature;
 
 import java.io.IOException;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -54,23 +57,28 @@
  * <p> This element holds the {@code Reference} elements</p>
  */
 public class Manifest extends SignatureElementProxy {
 
     /**
-     * The maximum number of references per Manifest, if secure validation is enabled.
+     * The default maximum number of references per Manifest, if secure validation is enabled.
      */
     public static final int MAXIMUM_REFERENCE_COUNT = 30;
 
     private static final com.sun.org.slf4j.internal.Logger LOG =
         com.sun.org.slf4j.internal.LoggerFactory.getLogger(Manifest.class);
 
+    private static Integer referenceCount =
+        AccessController.doPrivileged(
+            (PrivilegedAction<Integer>) () -> Integer.parseInt(System.getProperty("com.sun.org.apache.xml.internal.security.maxReferences",
+                                                                Integer.toString(MAXIMUM_REFERENCE_COUNT))));
+
     /** Field references */
     private List<Reference> references;
     private Element[] referencesEl;
 
     /** Field verificationResults[] */
-    private boolean[] verificationResults;
+    private List<VerifiedReference> verificationResults;
 
     /** Field resolverProperties */
     private Map<String, String> resolverProperties;
 
     /** Field perManifestResolvers */
@@ -133,12 +141,12 @@
 
             throw new DOMException(DOMException.WRONG_DOCUMENT_ERR,
                                    I18n.translate("xml.WrongContent", exArgs));
         }
 
-        if (secureValidation && le > MAXIMUM_REFERENCE_COUNT) {
-            Object exArgs[] = { le, MAXIMUM_REFERENCE_COUNT };
+        if (secureValidation && le > referenceCount) {
+            Object exArgs[] = { le, referenceCount };
 
             throw new XMLSecurityException("signature.tooManyReferences", exArgs);
         }
 
         // create List
@@ -315,17 +323,17 @@
         LOG.debug("I am {} requested to follow nested Manifests", (followManifests
             ? "" : "not"));
         if (referencesEl.length == 0) {
             throw new XMLSecurityException("empty", new Object[]{"References are empty"});
         }
-        if (secureValidation && referencesEl.length > MAXIMUM_REFERENCE_COUNT) {
-            Object exArgs[] = { referencesEl.length, MAXIMUM_REFERENCE_COUNT };
+        if (secureValidation && referencesEl.length > referenceCount) {
+            Object exArgs[] = { referencesEl.length, referenceCount };
 
             throw new XMLSecurityException("signature.tooManyReferences", exArgs);
         }
 
-        this.verificationResults = new boolean[referencesEl.length];
+        this.verificationResults = new ArrayList<>(referencesEl.length);
         boolean verify = true;
         for (int i = 0; i < this.referencesEl.length; i++) {
             Reference currentRef =
                 new Reference(referencesEl[i], this.baseURI, this, secureValidation);
 
@@ -333,17 +341,17 @@
 
             // if only one item does not verify, the whole verification fails
             try {
                 boolean currentRefVerified = currentRef.verify();
 
-                this.setVerificationResult(i, currentRefVerified);
-
                 if (!currentRefVerified) {
                     verify = false;
                 }
                 LOG.debug("The Reference has Type {}", currentRef.getType());
 
+                List<VerifiedReference> manifestReferences = Collections.emptyList();
+
                 // was verification successful till now and do we want to verify the Manifest?
                 if (verify && followManifests && currentRef.typeIsReferenceToManifest()) {
                     LOG.debug("We have to follow a nested Manifest");
 
                     try {
@@ -391,18 +399,22 @@
 
                             LOG.warn("The nested Manifest was invalid (bad)");
                         } else {
                             LOG.debug("The nested Manifest was valid (good)");
                         }
+
+                        manifestReferences = referencedManifest.getVerificationResults();
                     } catch (IOException ex) {
                         throw new ReferenceNotInitializedException(ex);
                     } catch (ParserConfigurationException ex) {
                         throw new ReferenceNotInitializedException(ex);
                     } catch (SAXException ex) {
                         throw new ReferenceNotInitializedException(ex);
                     }
                 }
+
+                verificationResults.add(new VerifiedReference(currentRefVerified, currentRef.getURI(), manifestReferences));
             } catch (ReferenceNotInitializedException ex) {
                 Object exArgs[] = { currentRef.getURI() };
 
                 throw new MissingResourceFailureException(
                     ex, currentRef, "signature.Verification.Reference.NoInput", exArgs
@@ -411,24 +423,10 @@
         }
 
         return verify;
     }
 
-    /**
-     * Method setVerificationResult
-     *
-     * @param index
-     * @param verify
-     */
-    private void setVerificationResult(int index, boolean verify) {
-        if (this.verificationResults == null) {
-            this.verificationResults = new boolean[this.getLength()];
-        }
-
-        this.verificationResults[index] = verify;
-    }
-
     /**
      * After verifying a {@link Manifest} or a {@link SignedInfo} using the
      * {@link Manifest#verifyReferences()} or {@link SignedInfo#verify()} methods,
      * the individual results can be retrieved with this method.
      *
@@ -453,18 +451,28 @@
             } catch (Exception ex) {
                 throw new XMLSecurityException(ex);
             }
         }
 
-        return this.verificationResults[index];
+        return ((ArrayList<VerifiedReference>)verificationResults).get(index).isValid();
+    }
+
+    /**
+     * Get the list of verification result objects
+     */
+    public List<VerifiedReference> getVerificationResults() {
+        if (verificationResults == null) {
+            return Collections.emptyList();
+        }
+        return Collections.unmodifiableList(verificationResults);
     }
 
     /**
      * Adds Resource Resolver for retrieving resources at specified {@code URI} attribute
      * in {@code reference} element
      *
-     * @param resolver {@link ResourceResolver} can provide the implemenatin subclass of
+     * @param resolver {@link ResourceResolver} can provide the implementation subclass of
      * {@link ResourceResolverSpi} for retrieving resource.
      */
     public void addResourceResolver(ResourceResolver resolver) {
         if (resolver == null) {
             return;

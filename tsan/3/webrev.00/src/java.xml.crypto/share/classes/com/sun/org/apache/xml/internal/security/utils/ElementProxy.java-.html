<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/utils/ElementProxy.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.utils;
 24 
 25 import java.math.BigInteger;
 26 import java.util.concurrent.ConcurrentHashMap;
 27 import java.util.Base64;
 28 import java.util.Map;
 29 
 30 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 31 import org.w3c.dom.Attr;
 32 import org.w3c.dom.Document;
 33 import org.w3c.dom.Element;
 34 import org.w3c.dom.Node;
 35 import org.w3c.dom.NodeList;
 36 import org.w3c.dom.Text;
 37 
 38 /**
 39  * This is the base class to all Objects which have a direct 1:1 mapping to an
 40  * Element in a particular namespace.
 41  */
 42 public abstract class ElementProxy {
 43 
 44     protected static final com.sun.org.slf4j.internal.Logger LOG =
 45         com.sun.org.slf4j.internal.LoggerFactory.getLogger(ElementProxy.class);
 46 
 47     /**
 48      * What XML element does this ElementProxy instance wrap?
 49      */
 50     private Element wrappedElement;
 51 
 52     /** Field baseURI */
 53     protected String baseURI;
 54 
 55     /** Field doc */
 56     private Document wrappedDoc;
 57 
 58     /** Field prefixMappings */
 59     private static Map&lt;String, String&gt; prefixMappings = new ConcurrentHashMap&lt;String, String&gt;();
 60 
 61     /**
 62      * Constructor ElementProxy
 63      *
 64      */
 65     public ElementProxy() {
 66     }
 67 
 68     /**
 69      * Constructor ElementProxy
 70      *
 71      * @param doc
 72      */
 73     public ElementProxy(Document doc) {
 74         if (doc == null) {
 75             throw new RuntimeException(&quot;Document is null&quot;);
 76         }
 77 
 78         this.wrappedDoc = doc;
 79         this.wrappedElement = createElementForFamilyLocal(this.getBaseNamespace(), this.getBaseLocalName());
 80     }
 81 
 82     /**
 83      * Constructor ElementProxy
 84      *
 85      * @param element
 86      * @param baseURI
 87      * @throws XMLSecurityException
 88      */
 89     public ElementProxy(Element element, String baseURI) throws XMLSecurityException {
 90         if (element == null) {
 91             throw new XMLSecurityException(&quot;ElementProxy.nullElement&quot;);
 92         }
 93 
 94         LOG.debug(&quot;setElement(\&quot;{}\&quot;, \&quot;{}\&quot;)&quot;, element.getTagName(), baseURI);
 95 
 96         setElement(element);
 97         this.baseURI = baseURI;
 98 
 99         this.guaranteeThatElementInCorrectSpace();
100     }
101 
102     /**
103      * Returns the namespace of the Elements of the sub-class.
104      *
105      * @return the namespace of the Elements of the sub-class.
106      */
107     public abstract String getBaseNamespace();
108 
109     /**
110      * Returns the localname of the Elements of the sub-class.
111      *
112      * @return the localname of the Elements of the sub-class.
113      */
114     public abstract String getBaseLocalName();
115 
116 
117     protected Element createElementForFamilyLocal(
118         String namespace, String localName
119     ) {
120         Document doc = getDocument();
121         Element result = null;
122         if (namespace == null) {
123             result = doc.createElementNS(null, localName);
124         } else {
125             String baseName = this.getBaseNamespace();
126             String prefix = ElementProxy.getDefaultPrefix(baseName);
127             if (prefix == null || prefix.length() == 0) {
128                 result = doc.createElementNS(namespace, localName);
129                 result.setAttributeNS(Constants.NamespaceSpecNS, &quot;xmlns&quot;, namespace);
130             } else {
131                 result = doc.createElementNS(namespace, prefix + &quot;:&quot; + localName);
132                 result.setAttributeNS(Constants.NamespaceSpecNS, &quot;xmlns:&quot; + prefix, namespace);
133             }
134         }
135         return result;
136     }
137 
138 
139     /**
140      * This method creates an Element in a given namespace with a given localname.
141      * It uses the {@link ElementProxy#getDefaultPrefix} method to decide whether
142      * a particular prefix is bound to that namespace.
143      * &lt;p&gt;&lt;/p&gt;
144      * This method was refactored out of the constructor.
145      *
146      * @param doc
147      * @param namespace
148      * @param localName
149      * @return The element created.
150      */
151     public static Element createElementForFamily(Document doc, String namespace, String localName) {
152         Element result = null;
153         String prefix = ElementProxy.getDefaultPrefix(namespace);
154 
155         if (namespace == null) {
156             result = doc.createElementNS(null, localName);
157         } else {
158             if (prefix == null || prefix.length() == 0) {
159                 result = doc.createElementNS(namespace, localName);
160                 result.setAttributeNS(Constants.NamespaceSpecNS, &quot;xmlns&quot;, namespace);
161             } else {
162                 result = doc.createElementNS(namespace, prefix + &quot;:&quot; + localName);
163                 result.setAttributeNS(Constants.NamespaceSpecNS, &quot;xmlns:&quot; + prefix, namespace);
164             }
165         }
166 
167         return result;
168     }
169 
170     /**
171      * Method setElement
172      *
173      * @param element
174      * @param baseURI
175      * @throws XMLSecurityException
176      */
177     public void setElement(Element element, String baseURI) throws XMLSecurityException {
178         if (element == null) {
179             throw new XMLSecurityException(&quot;ElementProxy.nullElement&quot;);
180         }
181 
182         LOG.debug(&quot;setElement({}, \&quot;{}\&quot;)&quot;, element.getTagName(), baseURI);
183 
184         setElement(element);
185         this.baseURI = baseURI;
186     }
187 
188     /**
189      * Returns the Element which was constructed by the Object.
190      *
191      * @return the Element which was constructed by the Object.
192      */
193     public final Element getElement() {
194         return this.wrappedElement;
195     }
196 
197     /**
198      * Returns the Element plus a leading and a trailing CarriageReturn Text node.
199      *
200      * @return the Element which was constructed by the Object.
201      */
202     public final NodeList getElementPlusReturns() {
203 
204         HelperNodeList nl = new HelperNodeList();
205 
206         nl.appendChild(createText(&quot;\n&quot;));
207         nl.appendChild(getElement());
208         nl.appendChild(createText(&quot;\n&quot;));
209 
210         return nl;
211     }
212 
213     protected Text createText(String text) {
214         return this.wrappedDoc.createTextNode(text);
215     }
216 
217     /**
218      * Method getDocument
219      *
220      * @return the Document where this element is contained.
221      */
222     public Document getDocument() {
223         if (wrappedDoc == null) {
224             wrappedDoc = XMLUtils.getOwnerDocument(wrappedElement);
225         }
226         return wrappedDoc;
227     }
228 
229     /**
230      * Method getBaseURI
231      *
232      * @return the base uri of the namespace of this element
233      */
234     public String getBaseURI() {
235         return this.baseURI;
236     }
237 
238     /**
239      * Method guaranteeThatElementInCorrectSpace
240      *
241      * @throws XMLSecurityException
242      */
243     void guaranteeThatElementInCorrectSpace() throws XMLSecurityException {
244 
245         String expectedLocalName = this.getBaseLocalName();
246         String expectedNamespaceUri = this.getBaseNamespace();
247 
248         String actualLocalName = getElement().getLocalName();
249         String actualNamespaceUri = getElement().getNamespaceURI();
250 
251         if(!expectedNamespaceUri.equals(actualNamespaceUri)
252             &amp;&amp; !expectedLocalName.equals(actualLocalName)) {
253             Object exArgs[] = { actualNamespaceUri + &quot;:&quot; + actualLocalName,
254                                 expectedNamespaceUri + &quot;:&quot; + expectedLocalName};
255             throw new XMLSecurityException(&quot;xml.WrongElement&quot;, exArgs);
256         }
257     }
258 
259     /**
260      * Method addBigIntegerElement
261      *
262      * @param bi
263      * @param localname
264      */
265     public void addBigIntegerElement(BigInteger bi, String localname) {
266         if (bi != null) {
267             Element e = XMLUtils.createElementInSignatureSpace(getDocument(), localname);
268 
269             byte[] bytes = XMLUtils.getBytes(bi, bi.bitLength());
270             String encodedInt = Base64.getMimeEncoder().encodeToString(bytes);
271 
272             Document doc = e.getOwnerDocument();
273             Text text = doc.createTextNode(encodedInt);
274 
275             e.appendChild(text);
276 
277             appendSelf(e);
278             addReturnToSelf();
279         }
280     }
281 
282     protected void addReturnToSelf() {
283         XMLUtils.addReturnToElement(getElement());
284     }
285 
286     /**
287      * Method addBase64Element
288      *
289      * @param bytes
290      * @param localname
291      */
292     public void addBase64Element(byte[] bytes, String localname) {
293         if (bytes != null) {
294             Element el = XMLUtils.createElementInSignatureSpace(getDocument(), localname);
295             Text text = getDocument().createTextNode(Base64.getMimeEncoder().encodeToString(bytes));
296 
297             el.appendChild(text);
298 
299             appendSelf(el);
300             if (!XMLUtils.ignoreLineBreaks()) {
301                 appendSelf(createText(&quot;\n&quot;));
302             }
303         }
304     }
305 
306     /**
307      * Method addTextElement
308      *
309      * @param text
310      * @param localname
311      */
312     public void addTextElement(String text, String localname) {
313         Element e = XMLUtils.createElementInSignatureSpace(getDocument(), localname);
314         Text t = createText(text);
315 
316         appendOther(e, t);
317         appendSelf(e);
318         addReturnToSelf();
319     }
320 
321     /**
322      * Method addBase64Text
323      *
324      * @param bytes
325      */
326     public void addBase64Text(byte[] bytes) {
327         if (bytes != null) {
328             Text t = XMLUtils.ignoreLineBreaks()
329                 ? createText(Base64.getMimeEncoder().encodeToString(bytes))
330                 : createText(&quot;\n&quot; + Base64.getMimeEncoder().encodeToString(bytes) + &quot;\n&quot;);
331             appendSelf(t);
332         }
333     }
334 
335     protected void appendSelf(ElementProxy toAppend) {
336         getElement().appendChild(toAppend.getElement());
337     }
338 
339     protected void appendSelf(Node toAppend) {
340         getElement().appendChild(toAppend);
341     }
342 
343     protected void appendOther(Element parent, Node toAppend) {
344         parent.appendChild(toAppend);
345     }
346 
347     /**
348      * Method addText
349      *
350      * @param text
351      */
352     public void addText(String text) {
353         if (text != null) {
354             Text t = createText(text);
355 
356             appendSelf(t);
357         }
358     }
359 
360     /**
361      * Method getVal
362      *
363      * @param localname
364      * @param namespace
365      * @return The biginteger contained in the given element
366      */
367     public BigInteger getBigIntegerFromChildElement(
368         String localname, String namespace
369     ) {
370         return new BigInteger(1, Base64.getMimeDecoder().decode(
371             XMLUtils.selectNodeText(
372                 getFirstChild(), namespace, localname, 0
373             ).getNodeValue()
374         ));
375     }
376 
377     /**
378      * Method getTextFromChildElement
379      *
380      * @param localname
381      * @param namespace
382      * @return the Text of the textNode
383      */
384     public String getTextFromChildElement(String localname, String namespace) {
385         return XMLUtils.selectNode(
386                 getFirstChild(),
387                 namespace,
388                 localname,
389                 0).getTextContent();
390     }
391 
392     /**
393      * Method getBytesFromTextChild
394      *
395      * @return The base64 bytes from the text children of this element
396      * @throws XMLSecurityException
397      */
398     public byte[] getBytesFromTextChild() throws XMLSecurityException {
399         return Base64.getMimeDecoder().decode(getTextFromTextChild());
400     }
401 
402     /**
403      * Method getTextFromTextChild
404      *
405      * @return the Text obtained by concatenating all the text nodes of this
406      *    element
407      */
408     public String getTextFromTextChild() {
409         return XMLUtils.getFullTextChildrenFromElement(getElement());
410     }
411 
412     /**
413      * Method length
414      *
415      * @param namespace
416      * @param localname
417      * @return the number of elements {namespace}:localname under this element
418      */
419     public int length(String namespace, String localname) {
420         int number = 0;
421         Node sibling = getFirstChild();
422         while (sibling != null) {
423             if (localname.equals(sibling.getLocalName())
424                 &amp;&amp; namespace.equals(sibling.getNamespaceURI())) {
425                 number++;
426             }
427             sibling = sibling.getNextSibling();
428         }
429         return number;
430     }
431 
432     /**
433      * Adds an xmlns: definition to the Element. This can be called as follows:
434      *
435      * &lt;PRE&gt;
436      * // set namespace with ds prefix
437      * xpathContainer.setXPathNamespaceContext(&quot;ds&quot;, &quot;http://www.w3.org/2000/09/xmldsig#&quot;);
438      * xpathContainer.setXPathNamespaceContext(&quot;xmlns:ds&quot;, &quot;http://www.w3.org/2000/09/xmldsig#&quot;);
439      * &lt;/PRE&gt;
440      *
441      * @param prefix
442      * @param uri
443      * @throws XMLSecurityException
444      */
445     public void setXPathNamespaceContext(String prefix, String uri)
446         throws XMLSecurityException {
447         String ns;
448 
449         if (prefix == null || prefix.length() == 0) {
450             throw new XMLSecurityException(&quot;defaultNamespaceCannotBeSetHere&quot;);
451         } else if (&quot;xmlns&quot;.equals(prefix)) {
452             throw new XMLSecurityException(&quot;defaultNamespaceCannotBeSetHere&quot;);
453         } else if (prefix.startsWith(&quot;xmlns:&quot;)) {
454             ns = prefix;//&quot;xmlns:&quot; + prefix.substring(&quot;xmlns:&quot;.length());
455         } else {
456             ns = &quot;xmlns:&quot; + prefix;
457         }
458 
459         Attr a = getElement().getAttributeNodeNS(Constants.NamespaceSpecNS, ns);
460 
461         if (a != null) {
462             if (!a.getNodeValue().equals(uri)) {
463                 Object exArgs[] = { ns, getElement().getAttributeNS(null, ns) };
464 
465                 throw new XMLSecurityException(&quot;namespacePrefixAlreadyUsedByOtherURI&quot;, exArgs);
466             }
467             return;
468         }
469 
470         getElement().setAttributeNS(Constants.NamespaceSpecNS, ns, uri);
471     }
472 
473     /**
474      * Method setDefaultPrefix
475      *
476      * @param namespace
477      * @param prefix
478      * @throws XMLSecurityException
479      * @throws SecurityException if a security manager is installed and the
480      *    caller does not have permission to set the default prefix
481      */
482     public static void setDefaultPrefix(String namespace, String prefix)
483         throws XMLSecurityException {
484         JavaUtils.checkRegisterPermission();
485         setNamespacePrefix(namespace, prefix);
486     }
487 
488     private static void setNamespacePrefix(String namespace, String prefix)
489         throws XMLSecurityException {
490         if (prefixMappings.containsValue(prefix)) {
491             String storedPrefix = prefixMappings.get(namespace);
492             if (!storedPrefix.equals(prefix)) {
493                 Object exArgs[] = { prefix, namespace, storedPrefix };
494 
495                 throw new XMLSecurityException(&quot;prefix.AlreadyAssigned&quot;, exArgs);
496             }
497         }
498 
499         if (Constants.SignatureSpecNS.equals(namespace)) {
500             XMLUtils.setDsPrefix(prefix);
501         }
502         if (EncryptionConstants.EncryptionSpecNS.equals(namespace)) {
503             XMLUtils.setXencPrefix(prefix);
504         }
505         prefixMappings.put(namespace, prefix);
506     }
507 
508     /**
509      * This method registers the default prefixes.
510      */
511     public static void registerDefaultPrefixes() throws XMLSecurityException {
512         setNamespacePrefix(&quot;http://www.w3.org/2000/09/xmldsig#&quot;, &quot;ds&quot;);
513         setNamespacePrefix(&quot;http://www.w3.org/2001/04/xmlenc#&quot;, &quot;xenc&quot;);
514         setNamespacePrefix(&quot;http://www.w3.org/2009/xmlenc11#&quot;, &quot;xenc11&quot;);
515         setNamespacePrefix(&quot;http://www.xmlsecurity.org/experimental#&quot;, &quot;experimental&quot;);
516         setNamespacePrefix(&quot;http://www.w3.org/2002/04/xmldsig-filter2&quot;, &quot;dsig-xpath-old&quot;);
517         setNamespacePrefix(&quot;http://www.w3.org/2002/06/xmldsig-filter2&quot;, &quot;dsig-xpath&quot;);
518         setNamespacePrefix(&quot;http://www.w3.org/2001/10/xml-exc-c14n#&quot;, &quot;ec&quot;);
519         setNamespacePrefix(
520             &quot;http://www.nue.et-inf.uni-siegen.de/~geuer-pollmann/#xpathFilter&quot;, &quot;xx&quot;
521         );
522     }
523 
524     /**
525      * Method getDefaultPrefix
526      *
527      * @param namespace
528      * @return the default prefix bind to this element.
529      */
530     public static String getDefaultPrefix(String namespace) {
531         return prefixMappings.get(namespace);
532     }
533 
534     /**
535      * New value for the wrapped XML element that this object is a proxy for.
536      *
537      * @param elem  New element
538      *
539      * @see #getElement()
540      */
541     protected void setElement(Element elem) {
542         wrappedElement = elem;
543     }
544 
545     /**
546      * Set a new value for the wrapped document that this object is a proxy for.
547      *
548      * @param doc New document object being wrapped.
549      *
550      * @see #getDocument()
551      */
552     protected void setDocument(Document doc) {
553         wrappedDoc = doc;
554     }
555 
556     protected String getLocalAttribute(String attrName) {
557         return getElement().getAttributeNS(null, attrName);
558     }
559 
560     protected void setLocalAttribute(String attrName, String value) {
561         getElement().setAttributeNS(null, attrName, value);
562     }
563 
564     protected void setLocalIdAttribute(String attrName, String value) {
565 
566         if (value != null) {
567             Attr attr = getDocument().createAttributeNS(null, attrName);
568             attr.setValue(value);
569             getElement().setAttributeNodeNS(attr);
570             getElement().setIdAttributeNode(attr, true);
571         }
572         else {
573             getElement().removeAttributeNS(null, attrName);
574         }
575     }
576 
577     protected Node getFirstChild() {
578         return getElement().getFirstChild();
579     }
580 
581 }
    </pre>
  </body>
</html>
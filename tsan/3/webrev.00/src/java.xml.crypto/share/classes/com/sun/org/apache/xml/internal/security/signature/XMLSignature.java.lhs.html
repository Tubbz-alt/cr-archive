<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/XMLSignature.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.signature;
 24 
 25 import java.io.IOException;
 26 import java.io.OutputStream;
 27 import java.security.Key;
 28 import java.security.PublicKey;
 29 import java.security.cert.X509Certificate;
<a name="1" id="anc1"></a><span class="line-removed"> 30 import java.util.Base64;</span>
 31 
 32 import javax.crypto.SecretKey;
 33 
 34 import com.sun.org.apache.xml.internal.security.algorithms.SignatureAlgorithm;
 35 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 36 import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
 37 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
 38 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 39 import com.sun.org.apache.xml.internal.security.keys.KeyInfo;
 40 import com.sun.org.apache.xml.internal.security.keys.content.X509Data;
 41 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
 42 import com.sun.org.apache.xml.internal.security.utils.Constants;
 43 import com.sun.org.apache.xml.internal.security.utils.I18n;
 44 import com.sun.org.apache.xml.internal.security.utils.SignatureElementProxy;
 45 import com.sun.org.apache.xml.internal.security.utils.SignerOutputStream;
 46 import com.sun.org.apache.xml.internal.security.utils.UnsyncBufferedOutputStream;
 47 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 48 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;
 49 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverSpi;
 50 import org.w3c.dom.Attr;
 51 import org.w3c.dom.Document;
 52 import org.w3c.dom.Element;
 53 import org.w3c.dom.Node;
 54 import org.w3c.dom.Text;
 55 
 56 /**
 57  * Handles {@code &amp;lt;ds:Signature&amp;gt;} elements.
 58  * This is the main class that deals with creating and verifying signatures.
 59  *
 60  * &lt;p&gt;There are 2 types of constructors for this class. The ones that take a
 61  * document, baseURI and 1 or more Java Objects. This is mostly used for
 62  * signing purposes.
 63  * The other constructor is the one that takes a DOM Element and a baseURI.
 64  * This is used mostly with for verifying, when you have a SignatureElement.
 65  *
 66  * There are a few different types of methods:
 67  * &lt;ul&gt;&lt;li&gt;The addDocument* methods are used to add References with optional
 68  * transforms during signing. &lt;/li&gt;
 69  * &lt;li&gt;addKeyInfo* methods are to add Certificates and Keys to the
 70  * KeyInfo tags during signing. &lt;/li&gt;
 71  * &lt;li&gt;appendObject allows a user to add any XML Structure as an
 72  * ObjectContainer during signing.&lt;/li&gt;
 73  * &lt;li&gt;sign and checkSignatureValue methods are used to sign and validate the
 74  * signature. &lt;/li&gt;&lt;/ul&gt;
 75  */
 76 public final class XMLSignature extends SignatureElementProxy {
 77 
 78     /** MAC - Required HMAC-SHA1 */
 79     public static final String ALGO_ID_MAC_HMAC_SHA1 =
 80         Constants.SignatureSpecNS + &quot;hmac-sha1&quot;;
 81 
 82     /** Signature - Required DSAwithSHA1 (DSS) */
 83     public static final String ALGO_ID_SIGNATURE_DSA =
 84         Constants.SignatureSpecNS + &quot;dsa-sha1&quot;;
 85 
 86     /** Signature - Optional DSAwithSHA256 */
 87     public static final String ALGO_ID_SIGNATURE_DSA_SHA256 =
 88         Constants.SignatureSpec11NS + &quot;dsa-sha256&quot;;
 89 
 90     /** Signature - Recommended RSAwithSHA1 */
 91     public static final String ALGO_ID_SIGNATURE_RSA =
 92         Constants.SignatureSpecNS + &quot;rsa-sha1&quot;;
 93 
 94     /** Signature - Recommended RSAwithSHA1 */
 95     public static final String ALGO_ID_SIGNATURE_RSA_SHA1 =
 96         Constants.SignatureSpecNS + &quot;rsa-sha1&quot;;
 97 
 98     /** Signature - NOT Recommended RSAwithMD5 */
 99     public static final String ALGO_ID_SIGNATURE_NOT_RECOMMENDED_RSA_MD5 =
100         Constants.MoreAlgorithmsSpecNS + &quot;rsa-md5&quot;;
101 
102     /** Signature - Optional RSAwithRIPEMD160 */
103     public static final String ALGO_ID_SIGNATURE_RSA_RIPEMD160 =
104         Constants.MoreAlgorithmsSpecNS + &quot;rsa-ripemd160&quot;;
105 
106     /** Signature - Optional RSAwithSHA224 */
107     public static final String ALGO_ID_SIGNATURE_RSA_SHA224 =
108         Constants.MoreAlgorithmsSpecNS + &quot;rsa-sha224&quot;;
109 
110     /** Signature - Optional RSAwithSHA256 */
111     public static final String ALGO_ID_SIGNATURE_RSA_SHA256 =
112         Constants.MoreAlgorithmsSpecNS + &quot;rsa-sha256&quot;;
113 
114     /** Signature - Optional RSAwithSHA384 */
115     public static final String ALGO_ID_SIGNATURE_RSA_SHA384 =
116         Constants.MoreAlgorithmsSpecNS + &quot;rsa-sha384&quot;;
117 
118     /** Signature - Optional RSAwithSHA512 */
119     public static final String ALGO_ID_SIGNATURE_RSA_SHA512 =
120         Constants.MoreAlgorithmsSpecNS + &quot;rsa-sha512&quot;;
121 
122     /** Signature - Optional RSAwithSHA1andMGF1 */
123     public static final String ALGO_ID_SIGNATURE_RSA_SHA1_MGF1 =
124         Constants.XML_DSIG_NS_MORE_07_05 + &quot;sha1-rsa-MGF1&quot;;
125 
126     /** Signature - Optional RSAwithSHA224andMGF1 */
127     public static final String ALGO_ID_SIGNATURE_RSA_SHA224_MGF1 =
128         Constants.XML_DSIG_NS_MORE_07_05 + &quot;sha224-rsa-MGF1&quot;;
129 
130     /** Signature - Optional RSAwithSHA256andMGF1 */
131     public static final String ALGO_ID_SIGNATURE_RSA_SHA256_MGF1 =
132         Constants.XML_DSIG_NS_MORE_07_05 + &quot;sha256-rsa-MGF1&quot;;
133 
134     /** Signature - Optional RSAwithSHA384andMGF1 */
135     public static final String ALGO_ID_SIGNATURE_RSA_SHA384_MGF1 =
136         Constants.XML_DSIG_NS_MORE_07_05 + &quot;sha384-rsa-MGF1&quot;;
137 
138     /** Signature - Optional RSAwithSHA512andMGF1 */
139     public static final String ALGO_ID_SIGNATURE_RSA_SHA512_MGF1 =
140         Constants.XML_DSIG_NS_MORE_07_05 + &quot;sha512-rsa-MGF1&quot;;
141 
142     /** Signature - Optional RSAwithSHA3_224andMGF1 */
143     public static final String ALGO_ID_SIGNATURE_RSA_SHA3_224_MGF1 =
144         Constants.XML_DSIG_NS_MORE_07_05 + &quot;sha3-224-rsa-MGF1&quot;;
145 
146     /** Signature - Optional RSAwithSHA3_256andMGF1 */
147     public static final String ALGO_ID_SIGNATURE_RSA_SHA3_256_MGF1 =
148         Constants.XML_DSIG_NS_MORE_07_05 + &quot;sha3-256-rsa-MGF1&quot;;
149 
150     /** Signature - Optional RSAwithSHA3_384andMGF1 */
151     public static final String ALGO_ID_SIGNATURE_RSA_SHA3_384_MGF1 =
152         Constants.XML_DSIG_NS_MORE_07_05 + &quot;sha3-384-rsa-MGF1&quot;;
153 
154     /** Signature - Optional RSAwithSHA3_512andMGF1 */
155     public static final String ALGO_ID_SIGNATURE_RSA_SHA3_512_MGF1 =
156         Constants.XML_DSIG_NS_MORE_07_05 + &quot;sha3-512-rsa-MGF1&quot;;
157 
158     /** HMAC - NOT Recommended HMAC-MD5 */
159     public static final String ALGO_ID_MAC_HMAC_NOT_RECOMMENDED_MD5 =
160         Constants.MoreAlgorithmsSpecNS + &quot;hmac-md5&quot;;
161 
162     /** HMAC - Optional HMAC-RIPEMD160 */
163     public static final String ALGO_ID_MAC_HMAC_RIPEMD160 =
164         Constants.MoreAlgorithmsSpecNS + &quot;hmac-ripemd160&quot;;
165 
166     /** HMAC - Optional HMAC-SHA2224 */
167     public static final String ALGO_ID_MAC_HMAC_SHA224 =
168         Constants.MoreAlgorithmsSpecNS + &quot;hmac-sha224&quot;;
169 
170     /** HMAC - Optional HMAC-SHA256 */
171     public static final String ALGO_ID_MAC_HMAC_SHA256 =
172         Constants.MoreAlgorithmsSpecNS + &quot;hmac-sha256&quot;;
173 
174     /** HMAC - Optional HMAC-SHA284 */
175     public static final String ALGO_ID_MAC_HMAC_SHA384 =
176         Constants.MoreAlgorithmsSpecNS + &quot;hmac-sha384&quot;;
177 
178     /** HMAC - Optional HMAC-SHA512 */
179     public static final String ALGO_ID_MAC_HMAC_SHA512 =
180         Constants.MoreAlgorithmsSpecNS + &quot;hmac-sha512&quot;;
181 
182     /**Signature - Optional ECDSAwithSHA1 */
183     public static final String ALGO_ID_SIGNATURE_ECDSA_SHA1 =
184         &quot;http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1&quot;;
185 
186     /**Signature - Optional ECDSAwithSHA224 */
187     public static final String ALGO_ID_SIGNATURE_ECDSA_SHA224 =
188         &quot;http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha224&quot;;
189 
190     /**Signature - Optional ECDSAwithSHA256 */
191     public static final String ALGO_ID_SIGNATURE_ECDSA_SHA256 =
192         &quot;http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256&quot;;
193 
194     /**Signature - Optional ECDSAwithSHA384 */
195     public static final String ALGO_ID_SIGNATURE_ECDSA_SHA384 =
196         &quot;http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384&quot;;
197 
198     /**Signature - Optional ECDSAwithSHA512 */
199     public static final String ALGO_ID_SIGNATURE_ECDSA_SHA512 =
200         &quot;http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512&quot;;
201 
202     /**Signature - Optional ECDSAwithRIPEMD160 */
203     public static final String ALGO_ID_SIGNATURE_ECDSA_RIPEMD160 =
204         &quot;http://www.w3.org/2007/05/xmldsig-more#ecdsa-ripemd160&quot;;
205 
206     private static final com.sun.org.slf4j.internal.Logger LOG =
207         com.sun.org.slf4j.internal.LoggerFactory.getLogger(XMLSignature.class);
208 
209     /** ds:Signature.ds:SignedInfo element */
210     private SignedInfo signedInfo;
211 
212     /** ds:Signature.ds:KeyInfo */
213     private KeyInfo keyInfo;
214 
215     /**
216      * Checking the digests in References in a Signature are mandatory, but for
217      * References inside a Manifest it is application specific. This boolean is
218      * to indicate that the References inside Manifests should be validated.
219      */
220     private boolean followManifestsDuringValidation = false;
221 
222     private Element signatureValueElement;
223 
224     private static final int MODE_SIGN = 0;
225     private static final int MODE_VERIFY = 1;
226     private int state = MODE_SIGN;
227 
228     /**
229      * This creates a new {@code ds:Signature} Element and adds an empty
230      * {@code ds:SignedInfo}.
231      * The {@code ds:SignedInfo} is initialized with the specified Signature
232      * algorithm and Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS which is REQUIRED
233      * by the spec. This method&#39;s main use is for creating a new signature.
234      *
235      * @param doc Document in which the signature will be appended after creation.
236      * @param baseURI URI to be used as context for all relative URIs.
237      * @param signatureMethodURI signature algorithm to use.
238      * @throws XMLSecurityException
239      */
240     public XMLSignature(Document doc, String baseURI, String signatureMethodURI)
241         throws XMLSecurityException {
242         this(doc, baseURI, signatureMethodURI, 0, Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS);
243     }
244 
245     /**
246      * Constructor XMLSignature
247      *
248      * @param doc
249      * @param baseURI
250      * @param signatureMethodURI the Signature method to be used.
251      * @param hmacOutputLength
252      * @throws XMLSecurityException
253      */
254     public XMLSignature(Document doc, String baseURI, String signatureMethodURI,
255                         int hmacOutputLength) throws XMLSecurityException {
256         this(
257             doc, baseURI, signatureMethodURI, hmacOutputLength,
258             Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS
259         );
260     }
261 
262     /**
263      * Constructor XMLSignature
264      *
265      * @param doc
266      * @param baseURI
267      * @param signatureMethodURI the Signature method to be used.
268      * @param canonicalizationMethodURI the canonicalization algorithm to be
269      * used to c14nize the SignedInfo element.
270      * @throws XMLSecurityException
271      */
272     public XMLSignature(
273         Document doc,
274         String baseURI,
275         String signatureMethodURI,
276         String canonicalizationMethodURI
277     ) throws XMLSecurityException {
278         this(doc, baseURI, signatureMethodURI, 0, canonicalizationMethodURI);
279     }
280 
281     /**
282      * Constructor XMLSignature
283      *
284      * @param doc
285      * @param baseURI
286      * @param signatureMethodURI
287      * @param hmacOutputLength
288      * @param canonicalizationMethodURI
289      * @throws XMLSecurityException
290      */
291     public XMLSignature(
292         Document doc,
293         String baseURI,
294         String signatureMethodURI,
295         int hmacOutputLength,
296         String canonicalizationMethodURI
297     ) throws XMLSecurityException {
298         super(doc);
299 
300         String xmlnsDsPrefix = getDefaultPrefix(Constants.SignatureSpecNS);
301         if (xmlnsDsPrefix == null || xmlnsDsPrefix.length() == 0) {
302             getElement().setAttributeNS(
303                 Constants.NamespaceSpecNS, &quot;xmlns&quot;, Constants.SignatureSpecNS
304             );
305         } else {
306             getElement().setAttributeNS(
307                 Constants.NamespaceSpecNS, &quot;xmlns:&quot; + xmlnsDsPrefix, Constants.SignatureSpecNS
308             );
309         }
310         addReturnToSelf();
311 
312         this.baseURI = baseURI;
313         this.signedInfo =
314             new SignedInfo(
315                 getDocument(), signatureMethodURI, hmacOutputLength, canonicalizationMethodURI
316             );
317 
318         appendSelf(this.signedInfo);
319         addReturnToSelf();
320 
321         // create an empty SignatureValue; this is filled by setSignatureValueElement
322         signatureValueElement =
323             XMLUtils.createElementInSignatureSpace(getDocument(), Constants._TAG_SIGNATUREVALUE);
324 
325         appendSelf(signatureValueElement);
326         addReturnToSelf();
327     }
328 
329     /**
330      *  Creates a XMLSignature in a Document
331      * @param doc
332      * @param baseURI
333      * @param SignatureMethodElem
334      * @param CanonicalizationMethodElem
335      * @throws XMLSecurityException
336      */
337     public XMLSignature(
338         Document doc,
339         String baseURI,
340         Element SignatureMethodElem,
341         Element CanonicalizationMethodElem
342     ) throws XMLSecurityException {
343         super(doc);
344 
345         String xmlnsDsPrefix = getDefaultPrefix(Constants.SignatureSpecNS);
346         if (xmlnsDsPrefix == null || xmlnsDsPrefix.length() == 0) {
347             getElement().setAttributeNS(
348                 Constants.NamespaceSpecNS, &quot;xmlns&quot;, Constants.SignatureSpecNS
349             );
350         } else {
351             getElement().setAttributeNS(
352                 Constants.NamespaceSpecNS, &quot;xmlns:&quot; + xmlnsDsPrefix, Constants.SignatureSpecNS
353             );
354         }
355         addReturnToSelf();
356 
357         this.baseURI = baseURI;
358         this.signedInfo =
359             new SignedInfo(getDocument(), SignatureMethodElem, CanonicalizationMethodElem);
360 
361         appendSelf(this.signedInfo);
362         addReturnToSelf();
363 
364         // create an empty SignatureValue; this is filled by setSignatureValueElement
365         signatureValueElement =
366             XMLUtils.createElementInSignatureSpace(getDocument(), Constants._TAG_SIGNATUREVALUE);
367 
368         appendSelf(signatureValueElement);
369         addReturnToSelf();
370     }
371 
372     /**
373      * This will parse the element and construct the Java Objects.
374      * That will allow a user to validate the signature.
375      *
376      * @param element ds:Signature element that contains the whole signature
377      * @param baseURI URI to be prepended to all relative URIs
378      * @throws XMLSecurityException
379      * @throws XMLSignatureException if the signature is badly formatted
380      */
381     public XMLSignature(Element element, String baseURI)
382         throws XMLSignatureException, XMLSecurityException {
383         this(element, baseURI, true);
384     }
385 
386     /**
387      * This will parse the element and construct the Java Objects.
388      * That will allow a user to validate the signature.
389      *
390      * @param element ds:Signature element that contains the whole signature
391      * @param baseURI URI to be prepended to all relative URIs
392      * @param secureValidation whether secure secureValidation is enabled or not
393      * @throws XMLSecurityException
394      * @throws XMLSignatureException if the signature is badly formatted
395      */
396     public XMLSignature(Element element, String baseURI, boolean secureValidation)
397         throws XMLSignatureException, XMLSecurityException {
398         super(element, baseURI);
399 
400         // check out SignedInfo child
401         Element signedInfoElem = XMLUtils.getNextElement(element.getFirstChild());
402 
403         // check to see if it is there
404         if (signedInfoElem == null) {
405             Object exArgs[] = { Constants._TAG_SIGNEDINFO, Constants._TAG_SIGNATURE };
406             throw new XMLSignatureException(&quot;xml.WrongContent&quot;, exArgs);
407         }
408 
409         // create a SignedInfo object from that element
410         this.signedInfo = new SignedInfo(signedInfoElem, baseURI, secureValidation);
411         // get signedInfoElem again in case it has changed
412         signedInfoElem = XMLUtils.getNextElement(element.getFirstChild());
413 
414         // check out SignatureValue child
415         this.signatureValueElement =
416             XMLUtils.getNextElement(signedInfoElem.getNextSibling());
417 
418         // check to see if it exists
419         if (signatureValueElement == null) {
420             Object exArgs[] = { Constants._TAG_SIGNATUREVALUE, Constants._TAG_SIGNATURE };
421             throw new XMLSignatureException(&quot;xml.WrongContent&quot;, exArgs);
422         }
423         Attr signatureValueAttr = signatureValueElement.getAttributeNodeNS(null, &quot;Id&quot;);
424         if (signatureValueAttr != null) {
425             signatureValueElement.setIdAttributeNode(signatureValueAttr, true);
426         }
427 
428         // &lt;element ref=&quot;ds:KeyInfo&quot; minOccurs=&quot;0&quot;/&gt;
429         Element keyInfoElem =
430             XMLUtils.getNextElement(signatureValueElement.getNextSibling());
431 
432         // If it exists use it, but it&#39;s not mandatory
433         if (keyInfoElem != null
434             &amp;&amp; Constants.SignatureSpecNS.equals(keyInfoElem.getNamespaceURI())
435             &amp;&amp; Constants._TAG_KEYINFO.equals(keyInfoElem.getLocalName())) {
436             this.keyInfo = new KeyInfo(keyInfoElem, baseURI);
437             this.keyInfo.setSecureValidation(secureValidation);
438         }
439 
440         // &lt;element ref=&quot;ds:Object&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
441         Element objectElem =
442             XMLUtils.getNextElement(signatureValueElement.getNextSibling());
443         while (objectElem != null) {
444             Attr objectAttr = objectElem.getAttributeNodeNS(null, &quot;Id&quot;);
445             if (objectAttr != null) {
446                 objectElem.setIdAttributeNode(objectAttr, true);
447             }
448 
449             Node firstChild = objectElem.getFirstChild();
450             // Register Ids of the Object child elements
451             while (firstChild != null) {
452                 if (firstChild.getNodeType() == Node.ELEMENT_NODE) {
453                     Element childElem = (Element)firstChild;
454                     String tag = childElem.getLocalName();
455                     if (&quot;Manifest&quot;.equals(tag)) {
456                         new Manifest(childElem, baseURI);
457                     } else if (&quot;SignatureProperties&quot;.equals(tag)) {
458                         new SignatureProperties(childElem, baseURI);
459                     }
460                 }
461                 firstChild = firstChild.getNextSibling();
462             }
463 
464             objectElem = XMLUtils.getNextElement(objectElem.getNextSibling());
465         }
466 
467         this.state = MODE_VERIFY;
468     }
469 
470     /**
471      * Sets the {@code Id} attribute
472      *
473      * @param id Id value for the id attribute on the Signature Element
474      */
475     public void setId(String id) {
476         if (id != null) {
477             setLocalIdAttribute(Constants._ATT_ID, id);
478         }
479     }
480 
481     /**
482      * Returns the {@code Id} attribute
483      *
484      * @return the {@code Id} attribute
485      */
486     public String getId() {
487         return getLocalAttribute(Constants._ATT_ID);
488     }
489 
490     /**
491      * Returns the completely parsed {@code SignedInfo} object.
492      *
493      * @return the completely parsed {@code SignedInfo} object.
494      */
495     public SignedInfo getSignedInfo() {
496         return this.signedInfo;
497     }
498 
499     /**
500      * Returns the octet value of the SignatureValue element.
501      * Throws an XMLSignatureException if it has no or wrong content.
502      *
503      * @return the value of the SignatureValue element.
504      * @throws XMLSignatureException If there is no content
505      */
506     public byte[] getSignatureValue() throws XMLSignatureException {
<a name="2" id="anc2"></a><span class="line-modified">507         String content = XMLUtils.getFullTextChildrenFromElement(signatureValueElement);</span>
<span class="line-modified">508         return Base64.getMimeDecoder().decode(content);</span>
509     }
510 
511     /**
512      * Base64 encodes and sets the bytes as the content of the SignatureValue
513      * Node.
514      *
515      * @param bytes bytes to be used by SignatureValue before Base64 encoding
516      */
517     private void setSignatureValueElement(byte[] bytes) {
518 
519         while (signatureValueElement.hasChildNodes()) {
520             signatureValueElement.removeChild(signatureValueElement.getFirstChild());
521         }
522 
<a name="3" id="anc3"></a><span class="line-modified">523         String base64codedValue = Base64.getMimeEncoder().encodeToString(bytes);</span>
524 
525         if (base64codedValue.length() &gt; 76 &amp;&amp; !XMLUtils.ignoreLineBreaks()) {
526             base64codedValue = &quot;\n&quot; + base64codedValue + &quot;\n&quot;;
527         }
528 
529         Text t = createText(base64codedValue);
530         signatureValueElement.appendChild(t);
531     }
532 
533     /**
534      * Returns the KeyInfo child. If we are in signing mode and the KeyInfo
535      * does not exist yet, it is created on demand and added to the Signature.
536      * &lt;br&gt;
537      * This allows to add arbitrary content to the KeyInfo during signing.
538      *
539      * @return the KeyInfo object
540      */
541     public KeyInfo getKeyInfo() {
542         // check to see if we are signing and if we have to create a keyinfo
543         if (this.state == MODE_SIGN &amp;&amp; this.keyInfo == null) {
544 
545             // create the KeyInfo
546             this.keyInfo = new KeyInfo(getDocument());
547 
548             // get the Element from KeyInfo
549             Element keyInfoElement = this.keyInfo.getElement();
550             Element firstObject =
551                 XMLUtils.selectDsNode(
552                     getElement().getFirstChild(), Constants._TAG_OBJECT, 0
553                 );
554 
555             if (firstObject != null) {
556                 // add it before the object
557                 getElement().insertBefore(keyInfoElement, firstObject);
558                 XMLUtils.addReturnBeforeChild(getElement(), firstObject);
559             } else {
560                 // add it as the last element to the signature
561                 appendSelf(keyInfoElement);
562                 addReturnToSelf();
563             }
564         }
565 
566         return this.keyInfo;
567     }
568 
569     /**
570      * Appends an Object (not a {@code java.lang.Object} but an Object
571      * element) to the Signature. Please note that this is only possible
572      * when signing.
573      *
574      * @param object ds:Object to be appended.
575      * @throws XMLSignatureException When this object is used to verify.
576      */
577     public void appendObject(ObjectContainer object) throws XMLSignatureException {
578         //try {
579         //if (this.state != MODE_SIGN) {
580         // throw new XMLSignatureException(
581         //  &quot;signature.operationOnlyBeforeSign&quot;);
582         //}
583 
584         appendSelf(object);
585         addReturnToSelf();
586         //} catch (XMLSecurityException ex) {
587         // throw new XMLSignatureException(ex);
588         //}
589     }
590 
591     /**
592      * Returns the {@code i}th {@code ds:Object} child of the signature
593      * or null if no such {@code ds:Object} element exists.
594      *
595      * @param i
596      * @return the {@code i}th {@code ds:Object} child of the signature
597      * or null if no such {@code ds:Object} element exists.
598      */
599     public ObjectContainer getObjectItem(int i) {
600         Element objElem =
601             XMLUtils.selectDsNode(
602                 getFirstChild(), Constants._TAG_OBJECT, i
603             );
604 
605         try {
606             return new ObjectContainer(objElem, this.baseURI);
607         } catch (XMLSecurityException ex) {
608             return null;
609         }
610     }
611 
612     /**
613      * Returns the number of all {@code ds:Object} elements.
614      *
615      * @return the number of all {@code ds:Object} elements.
616      */
617     public int getObjectLength() {
618         return this.length(Constants.SignatureSpecNS, Constants._TAG_OBJECT);
619     }
620 
621     /**
622      * Digests all References in the SignedInfo, calculates the signature value
623      * and sets it in the SignatureValue Element.
624      *
625      * @param signingKey the {@link java.security.PrivateKey} or
626      * {@link javax.crypto.SecretKey} that is used to sign.
627      * @throws XMLSignatureException
628      */
629     public void sign(Key signingKey) throws XMLSignatureException {
630 
631         if (signingKey instanceof PublicKey) {
632             throw new IllegalArgumentException(
633                 I18n.translate(&quot;algorithms.operationOnlyVerification&quot;)
634             );
635         }
636 
637         //Create a SignatureAlgorithm object
638         SignedInfo si = this.getSignedInfo();
639         SignatureAlgorithm sa = si.getSignatureAlgorithm();
640         try (SignerOutputStream output = new SignerOutputStream(sa);
641             OutputStream so = new UnsyncBufferedOutputStream(output)) {
642 
643             // generate digest values for all References in this SignedInfo
644             si.generateDigestValues();
645 
646             // initialize SignatureAlgorithm for signing
647             sa.initSign(signingKey);
648 
649             // get the canonicalized bytes from SignedInfo
650             si.signInOctetStream(so);
651 
652             // set them on the SignatureValue element
653             this.setSignatureValueElement(sa.sign());
654         } catch (XMLSignatureException ex) {
655             throw ex;
656         } catch (CanonicalizationException ex) {
657             throw new XMLSignatureException(ex);
658         } catch (InvalidCanonicalizerException ex) {
659             throw new XMLSignatureException(ex);
660         } catch (XMLSecurityException ex) {
661             throw new XMLSignatureException(ex);
662         } catch (IOException ex) {
663             throw new XMLSignatureException(ex);
664         }
665     }
666 
667     /**
668      * Adds a {@link ResourceResolver} to enable the retrieval of resources.
669      *
670      * @param resolver
671      */
672     public void addResourceResolver(ResourceResolver resolver) {
673         this.getSignedInfo().addResourceResolver(resolver);
674     }
675 
676     /**
677      * Adds a {@link ResourceResolverSpi} to enable the retrieval of resources.
678      *
679      * @param resolver
680      */
681     public void addResourceResolver(ResourceResolverSpi resolver) {
682         this.getSignedInfo().addResourceResolver(resolver);
683     }
684 
685     /**
686      * Extracts the public key from the certificate and verifies if the signature
687      * is valid by re-digesting all References, comparing those against the
688      * stored DigestValues and then checking to see if the Signatures match on
689      * the SignedInfo.
690      *
691      * @param cert Certificate that contains the public key part of the keypair
692      * that was used to sign.
693      * @return true if the signature is valid, false otherwise
694      * @throws XMLSignatureException
695      */
696     public boolean checkSignatureValue(X509Certificate cert)
697         throws XMLSignatureException {
698         // see if cert is null
699         if (cert != null) {
700             // check the values with the public key from the cert
701             return this.checkSignatureValue(cert.getPublicKey());
702         }
703 
704         Object exArgs[] = { &quot;Didn&#39;t get a certificate&quot; };
705         throw new XMLSignatureException(&quot;empty&quot;, exArgs);
706     }
707 
708     /**
709      * Verifies if the signature is valid by redigesting all References,
710      * comparing those against the stored DigestValues and then checking to see
711      * if the Signatures match on the SignedInfo.
712      *
713      * @param pk {@link java.security.PublicKey} part of the keypair or
714      * {@link javax.crypto.SecretKey} that was used to sign
715      * @return true if the signature is valid, false otherwise
716      * @throws XMLSignatureException
717      */
718     public boolean checkSignatureValue(Key pk) throws XMLSignatureException {
719         //COMMENT: pk suggests it can only be a public key?
720         //check to see if the key is not null
721         if (pk == null) {
722             Object exArgs[] = { &quot;Didn&#39;t get a key&quot; };
723             throw new XMLSignatureException(&quot;empty&quot;, exArgs);
724         }
725         // all references inside the signedinfo need to be dereferenced and
726         // digested again to see if the outcome matches the stored value in the
727         // SignedInfo.
728         // If followManifestsDuringValidation is true it will do the same for
729         // References inside a Manifest.
730         try {
731             SignedInfo si = this.getSignedInfo();
732             //create a SignatureAlgorithms from the SignatureMethod inside
733             //SignedInfo. This is used to validate the signature.
734             SignatureAlgorithm sa = si.getSignatureAlgorithm();
735             LOG.debug(&quot;signatureMethodURI = {}&quot;, sa.getAlgorithmURI());
736             LOG.debug(&quot;jceSigAlgorithm = {}&quot;, sa.getJCEAlgorithmString());
737             LOG.debug(&quot;jceSigProvider = {}&quot;, sa.getJCEProviderName());
738             LOG.debug(&quot;PublicKey = {}&quot;, pk);
739 
740             byte sigBytes[] = null;
741             try (SignerOutputStream so = new SignerOutputStream(sa);
742                 OutputStream bos = new UnsyncBufferedOutputStream(so)) {
743 
744                 sa.initVerify(pk);
745 
746                 // Get the canonicalized (normalized) SignedInfo
747                 si.signInOctetStream(bos);
748                 // retrieve the byte[] from the stored signature
749                 sigBytes = this.getSignatureValue();
750             } catch (IOException ex) {
751                 LOG.debug(ex.getMessage(), ex);
752                 // Impossible...
753             } catch (XMLSecurityException ex) {
754                 throw ex;
755             }
756 
757             // have SignatureAlgorithm sign the input bytes and compare them to
758             // the bytes that were stored in the signature.
759             if (!sa.verify(sigBytes)) {
760                 LOG.warn(&quot;Signature verification failed.&quot;);
761                 return false;
762             }
763 
764             return si.verify(this.followManifestsDuringValidation);
765         } catch (XMLSignatureException ex) {
766             throw ex;
767         } catch (XMLSecurityException ex) {
768             throw new XMLSignatureException(ex);
769         }
770     }
771 
772     /**
773      * Add a Reference with full parameters to this Signature
774      *
775      * @param referenceURI URI of the resource to be signed. Can be null in
776      * which case the dereferencing is application specific. Can be &quot;&quot; in which
777      * it&#39;s the parent node (or parent document?). There can only be one &quot;&quot; in
778      * each signature.
779      * @param trans Optional list of transformations to be done before digesting
780      * @param digestURI Mandatory URI of the digesting algorithm to use.
781      * @param referenceId Optional id attribute for this Reference
782      * @param referenceType Optional mimetype for the URI
783      * @throws XMLSignatureException
784      */
785     public void addDocument(
786         String referenceURI,
787         Transforms trans,
788         String digestURI,
789         String referenceId,
790         String referenceType
791     ) throws XMLSignatureException {
792         this.signedInfo.addDocument(
793             this.baseURI, referenceURI, trans, digestURI, referenceId, referenceType
794         );
795     }
796 
797     /**
798      * This method is a proxy method for the {@link Manifest#addDocument} method.
799      *
800      * @param referenceURI URI according to the XML Signature specification.
801      * @param trans List of transformations to be applied.
802      * @param digestURI URI of the digest algorithm to be used.
803      * @see Manifest#addDocument
804      * @throws XMLSignatureException
805      */
806     public void addDocument(
807         String referenceURI,
808         Transforms trans,
809         String digestURI
810     ) throws XMLSignatureException {
811         this.signedInfo.addDocument(this.baseURI, referenceURI, trans, digestURI, null, null);
812     }
813 
814     /**
815      * Adds a Reference with just the URI and the transforms. This used the
816      * SHA1 algorithm as a default digest algorithm.
817      *
818      * @param referenceURI URI according to the XML Signature specification.
819      * @param trans List of transformations to be applied.
820      * @throws XMLSignatureException
821      */
822     public void addDocument(String referenceURI, Transforms trans)
823         throws XMLSignatureException {
824         this.signedInfo.addDocument(
825             this.baseURI, referenceURI, trans, Constants.ALGO_ID_DIGEST_SHA1, null, null
826         );
827     }
828 
829     /**
830      * Add a Reference with just this URI. It uses SHA1 by default as the digest
831      * algorithm
832      *
833      * @param referenceURI URI according to the XML Signature specification.
834      * @throws XMLSignatureException
835      */
836     public void addDocument(String referenceURI) throws XMLSignatureException {
837         this.signedInfo.addDocument(
838             this.baseURI, referenceURI, null, Constants.ALGO_ID_DIGEST_SHA1, null, null
839         );
840     }
841 
842     /**
843      * Add an X509 Certificate to the KeyInfo. This will include the whole cert
844      * inside X509Data/X509Certificate tags.
845      *
846      * @param cert Certificate to be included. This should be the certificate of
847      * the key that was used to sign.
848      * @throws XMLSecurityException
849      */
850     public void addKeyInfo(X509Certificate cert) throws XMLSecurityException {
851         X509Data x509data = new X509Data(getDocument());
852 
853         x509data.addCertificate(cert);
854         this.getKeyInfo().add(x509data);
855     }
856 
857     /**
858      * Add this public key to the KeyInfo. This will include the complete key in
859      * the KeyInfo structure.
860      *
861      * @param pk
862      */
863     public void addKeyInfo(PublicKey pk) {
864         this.getKeyInfo().add(pk);
865     }
866 
867     /**
868      * Proxy method for {@link SignedInfo#createSecretKey(byte[])}. If you want
869      * to create a MAC, this method helps you to obtain the
870      * {@link javax.crypto.SecretKey} from octets.
871      *
872      * @param secretKeyBytes
873      * @return the secret key created.
874      * @see SignedInfo#createSecretKey(byte[])
875      */
876     public SecretKey createSecretKey(byte[] secretKeyBytes) {
877         return this.getSignedInfo().createSecretKey(secretKeyBytes);
878     }
879 
880     /**
881      * Signal whether Manifest should be automatically validated.
882      * Checking the digests in References in a Signature are mandatory, but for
883      * References inside a Manifest it is application specific. This boolean is
884      * to indicate that the References inside Manifests should be validated.
885      *
886      * @param followManifests
887      * @see &lt;a href=&quot;http://www.w3.org/TR/xmldsig-core/#sec-CoreValidation&quot;&gt;
888      * Core validation section in the XML Signature Rec.&lt;/a&gt;
889      */
890     public void setFollowNestedManifests(boolean followManifests) {
891         this.followManifestsDuringValidation = followManifests;
892     }
893 
894     /**
895      * Get the local name of this element
896      *
897      * @return Constants._TAG_SIGNATURE
898      */
899     public String getBaseLocalName() {
900         return Constants._TAG_SIGNATURE;
901     }
902 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
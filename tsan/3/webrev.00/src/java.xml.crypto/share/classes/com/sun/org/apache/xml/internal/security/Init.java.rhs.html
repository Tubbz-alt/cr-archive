<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/Init.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security;
 24 
 25 import java.io.InputStream;
 26 import java.security.AccessController;
 27 import java.security.PrivilegedAction;
 28 import java.security.PrivilegedActionException;
 29 import java.security.PrivilegedExceptionAction;
 30 import java.util.ArrayList;
 31 import java.util.List;
 32 
<a name="1" id="anc1"></a>

 33 import com.sun.org.apache.xml.internal.security.algorithms.JCEMapper;
 34 import com.sun.org.apache.xml.internal.security.algorithms.SignatureAlgorithm;
 35 import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
 36 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 37 import com.sun.org.apache.xml.internal.security.keys.keyresolver.KeyResolver;
 38 import com.sun.org.apache.xml.internal.security.transforms.Transform;
 39 import com.sun.org.apache.xml.internal.security.utils.ElementProxy;
 40 import com.sun.org.apache.xml.internal.security.utils.I18n;
 41 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 42 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;
 43 import org.w3c.dom.Attr;
 44 import org.w3c.dom.Document;
 45 import org.w3c.dom.Element;
 46 import org.w3c.dom.Node;
 47 
 48 
 49 /**
 50  * This class does the configuration of the library. This includes creating
 51  * the mapping of Canonicalization and Transform algorithms. Initialization is
 52  * done by calling {@link Init#init} which should be done in any static block
 53  * of the files of this library. We ensure that this call is only executed once.
 54  */
 55 public class Init {
 56 
 57     /** The namespace for CONF file **/
 58     public static final String CONF_NS = &quot;http://www.xmlsecurity.org/NS/#configuration&quot;;
 59 
 60     private static final com.sun.org.slf4j.internal.Logger LOG =
 61         com.sun.org.slf4j.internal.LoggerFactory.getLogger(Init.class);
 62 
 63     /** Field alreadyInitialized */
 64     private static boolean alreadyInitialized = false;
 65 
 66     /**
 67      * Method isInitialized
 68      * @return true if the library is already initialized.
 69      */
 70     public static final synchronized boolean isInitialized() {
 71         return Init.alreadyInitialized;
 72     }
 73 
 74     /**
 75      * Method init
 76      *
 77      */
 78     public static synchronized void init() {
 79         if (alreadyInitialized) {
 80             return;
 81         }
 82 
 83         InputStream is =
 84             AccessController.doPrivileged(
 85                 (PrivilegedAction&lt;InputStream&gt;)
 86                     () -&gt; {
 87                         String cfile =
 88                             System.getProperty(&quot;com.sun.org.apache.xml.internal.security.resource.config&quot;);
 89                         if (cfile == null) {
 90                             return null;
 91                         }
 92                         return Init.class.getResourceAsStream(cfile);
 93                     }
 94                 );
 95         if (is == null) {
 96             dynamicInit();
 97         } else {
 98             fileInit(is);
 99         }
100 
101         alreadyInitialized = true;
102     }
103 
104     /**
105      * Dynamically initialise the library by registering the default algorithms/implementations
106      */
107     private static void dynamicInit() {
108         //
109         // Load the Resource Bundle - the default is the English resource bundle.
110         // To load another resource bundle, call I18n.init(...) before calling this
111         // method.
112         //
113         I18n.init(&quot;en&quot;, &quot;US&quot;);
114 
115         LOG.debug(&quot;Registering default algorithms&quot;);
116 
117         try {
118             AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Void&gt;(){
119                 @Override public Void run() throws XMLSecurityException {
120                     //
121                     // Bind the default prefixes
122                     //
123                     ElementProxy.registerDefaultPrefixes();
124 
125                     //
126                     // Set the default Transforms
127                     //
128                     Transform.registerDefaultAlgorithms();
129 
130                     //
131                     // Set the default signature algorithms
132                     //
133                     SignatureAlgorithm.registerDefaultAlgorithms();
134 
135                     //
136                     // Set the default JCE algorithms
137                     //
138                     JCEMapper.registerDefaultAlgorithms();
139 
140                     //
141                     // Set the default c14n algorithms
142                     //
143                     Canonicalizer.registerDefaultAlgorithms();
144 
145                     //
146                     // Register the default resolvers
147                     //
148                     ResourceResolver.registerDefaultResolvers();
149 
150                     //
151                     // Register the default key resolvers
152                     //
153                     KeyResolver.registerDefaultResolvers();
154 
155                     return null;
156                 }
157             });
158         } catch (PrivilegedActionException ex) {
159             XMLSecurityException xse = (XMLSecurityException)ex.getException();
160             LOG.error(xse.getMessage(), xse);
161             xse.printStackTrace();
162         }
163     }
164 
165     /**
166      * Initialise the library from a configuration file
167      */
168     private static void fileInit(InputStream is) {
169         try {
170             /* read library configuration file */
<a name="2" id="anc2"></a><span class="line-modified">171             Document doc = XMLUtils.read(is, false);</span>

172             Node config = doc.getFirstChild();
173             for (; config != null; config = config.getNextSibling()) {
174                 if (&quot;Configuration&quot;.equals(config.getLocalName())) {
175                     break;
176                 }
177             }
178             if (config == null) {
179                 LOG.error(&quot;Error in reading configuration file - Configuration element not found&quot;);
180                 return;
181             }
182             for (Node el = config.getFirstChild(); el != null; el = el.getNextSibling()) {
183                 if (Node.ELEMENT_NODE != el.getNodeType()) {
184                     continue;
185                 }
186                 String tag = el.getLocalName();
187                 if (&quot;ResourceBundles&quot;.equals(tag)) {
188                     Element resource = (Element)el;
189                     /* configure internationalization */
190                     Attr langAttr = resource.getAttributeNodeNS(null, &quot;defaultLanguageCode&quot;);
191                     Attr countryAttr = resource.getAttributeNodeNS(null, &quot;defaultCountryCode&quot;);
192                     String languageCode =
193                         (langAttr == null) ? null : langAttr.getNodeValue();
194                     String countryCode =
195                         (countryAttr == null) ? null : countryAttr.getNodeValue();
196                     I18n.init(languageCode, countryCode);
197                 }
198 
199                 if (&quot;CanonicalizationMethods&quot;.equals(tag)) {
200                     Element[] list =
201                         XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;CanonicalizationMethod&quot;);
202 
203                     for (Element element : list) {
204                         String uri = element.getAttributeNS(null, &quot;URI&quot;);
205                         String javaClass =
206                             element.getAttributeNS(null, &quot;JAVACLASS&quot;);
207                         try {
208                             Canonicalizer.register(uri, javaClass);
209                             LOG.debug(&quot;Canonicalizer.register({}, {})&quot;, uri, javaClass);
210                         } catch (ClassNotFoundException e) {
211                             Object exArgs[] = { uri, javaClass };
212                             LOG.error(I18n.translate(&quot;algorithm.classDoesNotExist&quot;, exArgs));
213                         }
214                     }
215                 }
216 
217                 if (&quot;TransformAlgorithms&quot;.equals(tag)) {
218                     Element[] tranElem =
219                         XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;TransformAlgorithm&quot;);
220 
221                     for (Element element : tranElem) {
222                         String uri = element.getAttributeNS(null, &quot;URI&quot;);
223                         String javaClass =
224                             element.getAttributeNS(null, &quot;JAVACLASS&quot;);
225                         try {
226                             Transform.register(uri, javaClass);
227                             LOG.debug(&quot;Transform.register({}, {})&quot;, uri, javaClass);
228                         } catch (ClassNotFoundException e) {
229                             Object exArgs[] = { uri, javaClass };
230 
231                             LOG.error(I18n.translate(&quot;algorithm.classDoesNotExist&quot;, exArgs));
232                         } catch (NoClassDefFoundError ex) {
233                             LOG.warn(&quot;Not able to found dependencies for algorithm, I&#39;ll keep working.&quot;);
234                         }
235                     }
236                 }
237 
238                 if (&quot;JCEAlgorithmMappings&quot;.equals(tag)) {
239                     Node algorithmsNode = ((Element)el).getElementsByTagName(&quot;Algorithms&quot;).item(0);
240                     if (algorithmsNode != null) {
241                         Element[] algorithms =
242                             XMLUtils.selectNodes(algorithmsNode.getFirstChild(), CONF_NS, &quot;Algorithm&quot;);
243                         for (Element element : algorithms) {
244                             String id = element.getAttributeNS(null, &quot;URI&quot;);
245                             JCEMapper.register(id, new JCEMapper.Algorithm(element));
246                         }
247                     }
248                 }
249 
250                 if (&quot;SignatureAlgorithms&quot;.equals(tag)) {
251                     Element[] sigElems =
252                         XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;SignatureAlgorithm&quot;);
253 
254                     for (Element sigElem : sigElems) {
255                         String uri = sigElem.getAttributeNS(null, &quot;URI&quot;);
256                         String javaClass =
257                             sigElem.getAttributeNS(null, &quot;JAVACLASS&quot;);
258 
259                         /** $todo$ handle registering */
260 
261                         try {
262                             SignatureAlgorithm.register(uri, javaClass);
263                             LOG.debug(&quot;SignatureAlgorithm.register({}, {})&quot;, uri, javaClass);
264                         } catch (ClassNotFoundException e) {
265                             Object exArgs[] = { uri, javaClass };
266 
267                             LOG.error(I18n.translate(&quot;algorithm.classDoesNotExist&quot;, exArgs));
268                         }
269                     }
270                 }
271 
272                 if (&quot;ResourceResolvers&quot;.equals(tag)) {
273                     Element[] resolverElem =
274                         XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;Resolver&quot;);
275 
276                     for (Element element : resolverElem) {
277                         String javaClass =
278                             element.getAttributeNS(null, &quot;JAVACLASS&quot;);
279                         String description =
280                             element.getAttributeNS(null, &quot;DESCRIPTION&quot;);
281 
282                         if (description != null &amp;&amp; description.length() &gt; 0) {
283                             LOG.debug(&quot;Register Resolver: {}: {}&quot;, javaClass, description);
284                         } else {
285                             LOG.debug(&quot;Register Resolver: {}: For unknown purposes&quot;, javaClass);
286                         }
287                         try {
288                             ResourceResolver.register(javaClass);
289                         } catch (Throwable e) {
290                             LOG.warn(
291                                  &quot;Cannot register:&quot; + javaClass
292                                  + &quot; perhaps some needed jars are not installed&quot;,
293                                  e
294                              );
295                         }
296                     }
297                 }
298 
299                 if (&quot;KeyResolver&quot;.equals(tag)){
300                     Element[] resolverElem =
301                         XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;Resolver&quot;);
302                     List&lt;String&gt; classNames = new ArrayList&lt;&gt;(resolverElem.length);
303                     for (Element element : resolverElem) {
304                         String javaClass =
305                             element.getAttributeNS(null, &quot;JAVACLASS&quot;);
306                         String description =
307                             element.getAttributeNS(null, &quot;DESCRIPTION&quot;);
308 
309                         if (description != null &amp;&amp; description.length() &gt; 0) {
310                             LOG.debug(&quot;Register Resolver: {}: {}&quot;, javaClass, description);
311                         } else {
312                             LOG.debug(&quot;Register Resolver: {}: For unknown purposes&quot;, javaClass);
313                         }
314                         classNames.add(javaClass);
315                     }
316                     KeyResolver.registerClassNames(classNames);
317                 }
318 
319 
320                 if (&quot;PrefixMappings&quot;.equals(tag)){
321                     LOG.debug(&quot;Now I try to bind prefixes:&quot;);
322 
323                     Element[] nl =
324                         XMLUtils.selectNodes(el.getFirstChild(), CONF_NS, &quot;PrefixMapping&quot;);
325 
326                     for (Element element : nl) {
327                         String namespace = element.getAttributeNS(null, &quot;namespace&quot;);
328                         String prefix = element.getAttributeNS(null, &quot;prefix&quot;);
329                         LOG.debug(&quot;Now I try to bind {} to {}&quot;, prefix, namespace);
330                         ElementProxy.setDefaultPrefix(namespace, prefix);
331                     }
332                 }
333             }
334         } catch (Exception e) {
335             LOG.error(&quot;Bad: &quot;, e);
336         }
337     }
338 
339 }
340 
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
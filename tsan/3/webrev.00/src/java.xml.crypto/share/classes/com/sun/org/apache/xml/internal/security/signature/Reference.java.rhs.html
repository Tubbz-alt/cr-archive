<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/Reference.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.signature;
 24 
 25 import java.io.IOException;
 26 import java.io.OutputStream;
 27 import java.security.AccessController;
 28 import java.security.PrivilegedAction;
<a name="1" id="anc1"></a>
 29 import java.util.HashSet;
 30 import java.util.Iterator;
 31 import java.util.Set;
 32 
 33 import com.sun.org.apache.xml.internal.security.algorithms.Algorithm;
 34 import com.sun.org.apache.xml.internal.security.algorithms.MessageDigestAlgorithm;
 35 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 36 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
 37 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 38 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceData;
 39 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceNodeSetData;
 40 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceOctetStreamData;
 41 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceSubTreeData;
 42 import com.sun.org.apache.xml.internal.security.transforms.InvalidTransformException;
 43 import com.sun.org.apache.xml.internal.security.transforms.Transform;
 44 import com.sun.org.apache.xml.internal.security.transforms.TransformationException;
 45 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
 46 import com.sun.org.apache.xml.internal.security.transforms.params.InclusiveNamespaces;
 47 import com.sun.org.apache.xml.internal.security.utils.Constants;
 48 import com.sun.org.apache.xml.internal.security.utils.DigesterOutputStream;
 49 import com.sun.org.apache.xml.internal.security.utils.SignatureElementProxy;
 50 import com.sun.org.apache.xml.internal.security.utils.UnsyncBufferedOutputStream;
 51 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 52 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;
 53 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverException;
 54 import org.w3c.dom.Attr;
 55 import org.w3c.dom.Document;
 56 import org.w3c.dom.Element;
 57 import org.w3c.dom.Node;
 58 import org.w3c.dom.Text;
 59 
 60 /**
 61  * Handles {@code &amp;lt;ds:Reference&amp;gt;} elements.
 62  *
 63  * This includes:
 64  *
 65  * Construct a {@code ds:Reference} from an {@link org.w3c.dom.Element}.
 66  *
 67  * &lt;p&gt;Create a new reference&lt;/p&gt;
 68  * &lt;pre&gt;
 69  * Document doc;
 70  * MessageDigestAlgorithm sha1 = MessageDigestAlgorithm.getInstance(&quot;http://#sha1&quot;);
 71  * Reference ref = new Reference(new XMLSignatureInput(new FileInputStream(&quot;1.gif&quot;),
 72  *                               &quot;http://localhost/1.gif&quot;,
 73  *                               (Transforms) null, sha1);
 74  * Element refElem = ref.toElement(doc);
 75  * &lt;/pre&gt;
 76  *
 77  * &lt;p&gt;Verify a reference&lt;/p&gt;
 78  * &lt;pre&gt;
 79  * Element refElem = doc.getElement(&quot;Reference&quot;); // PSEUDO
 80  * Reference ref = new Reference(refElem);
 81  * String url = ref.getURI();
 82  * ref.setData(new XMLSignatureInput(new FileInputStream(url)));
 83  * if (ref.verify()) {
 84  *    System.out.println(&quot;verified&quot;);
 85  * }
 86  * &lt;/pre&gt;
 87  *
 88  * &lt;pre&gt;
 89  * &amp;lt;element name=&quot;Reference&quot; type=&quot;ds:ReferenceType&quot;/&amp;gt;
 90  *  &amp;lt;complexType name=&quot;ReferenceType&quot;&amp;gt;
 91  *    &amp;lt;sequence&amp;gt;
 92  *      &amp;lt;element ref=&quot;ds:Transforms&quot; minOccurs=&quot;0&quot;/&amp;gt;
 93  *      &amp;lt;element ref=&quot;ds:DigestMethod&quot;/&amp;gt;
 94  *      &amp;lt;element ref=&quot;ds:DigestValue&quot;/&amp;gt;
 95  *    &amp;lt;/sequence&amp;gt;
 96  *    &amp;lt;attribute name=&quot;Id&quot; type=&quot;ID&quot; use=&quot;optional&quot;/&amp;gt;
 97  *    &amp;lt;attribute name=&quot;URI&quot; type=&quot;anyURI&quot; use=&quot;optional&quot;/&amp;gt;
 98  *    &amp;lt;attribute name=&quot;Type&quot; type=&quot;anyURI&quot; use=&quot;optional&quot;/&amp;gt;
 99  *  &amp;lt;/complexType&amp;gt;
100  * &lt;/pre&gt;
101  *
102  * @see ObjectContainer
103  * @see Manifest
104  */
105 public class Reference extends SignatureElementProxy {
106 
107     /** Field OBJECT_URI */
108     public static final String OBJECT_URI = Constants.SignatureSpecNS + Constants._TAG_OBJECT;
109 
110     /** Field MANIFEST_URI */
111     public static final String MANIFEST_URI = Constants.SignatureSpecNS + Constants._TAG_MANIFEST;
112 
113     /**
114      * The maximum number of transforms per reference, if secure validation is enabled.
115      */
116     public static final int MAXIMUM_TRANSFORM_COUNT = 5;
117 
118     private boolean secureValidation;
119 
120     /**
121      * Look up useC14N11 system property. If true, an explicit C14N11 transform
122      * will be added if necessary when generating the signature. See section
123      * 3.1.1 of http://www.w3.org/2007/xmlsec/Drafts/xmldsig-core/ for more info.
124      */
125     private static boolean useC14N11 =
126         AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)
127             () -&gt; Boolean.getBoolean(&quot;com.sun.org.apache.xml.internal.security.useC14N11&quot;));
128 
129     private static final com.sun.org.slf4j.internal.Logger LOG =
130         com.sun.org.slf4j.internal.LoggerFactory.getLogger(Reference.class);
131 
132     private Manifest manifest;
133     private XMLSignatureInput transformsOutput;
134 
135     private Transforms transforms;
136 
137     private Element digestMethodElem;
138 
139     private Element digestValueElement;
140 
141     private ReferenceData referenceData;
142 
143     /**
144      * Constructor Reference
145      *
146      * @param doc the {@link Document} in which {@code XMLsignature} is placed
147      * @param baseURI the URI of the resource where the XML instance will be stored
148      * @param referenceURI URI indicate where is data which will digested
149      * @param manifest
150      * @param transforms {@link Transforms} applied to data
151      * @param messageDigestAlgorithm {@link MessageDigestAlgorithm Digest algorithm} which is
152      * applied to the data
153      * TODO should we throw XMLSignatureException if MessageDigestAlgoURI is wrong?
154      * @throws XMLSignatureException
155      */
156     protected Reference(
157         Document doc, String baseURI, String referenceURI, Manifest manifest,
158         Transforms transforms, String messageDigestAlgorithm
159     ) throws XMLSignatureException {
160         super(doc);
161 
162         addReturnToSelf();
163 
164         this.baseURI = baseURI;
165         this.manifest = manifest;
166 
167         this.setURI(referenceURI);
168 
169         // important: The ds:Reference must be added to the associated ds:Manifest
170         //            or ds:SignedInfo _before_ the this.resolverResult() is called.
171         // this.manifest.appendChild(this.constructionElement);
172         // this.manifest.appendChild(this.doc.createTextNode(&quot;\n&quot;));
173 
174         if (transforms != null) {
175             this.transforms = transforms;
176             appendSelf(transforms);
177             addReturnToSelf();
178         }
179 
180         // Create DigestMethod Element without actually instantiating a MessageDigest Object
181         Algorithm digestAlgorithm = new Algorithm(getDocument(), messageDigestAlgorithm) {
182             public String getBaseNamespace() {
183                 return Constants.SignatureSpecNS;
184             }
185 
186             public String getBaseLocalName() {
187                 return Constants._TAG_DIGESTMETHOD;
188             }
189         };
190 
191         digestMethodElem = digestAlgorithm.getElement();
192 
193         appendSelf(digestMethodElem);
194         addReturnToSelf();
195 
196         digestValueElement =
197             XMLUtils.createElementInSignatureSpace(getDocument(), Constants._TAG_DIGESTVALUE);
198 
199         appendSelf(digestValueElement);
200         addReturnToSelf();
201     }
202 
203 
204     /**
205      * Build a {@link Reference} from an {@link Element}
206      *
207      * @param element {@code Reference} element
208      * @param baseURI the URI of the resource where the XML instance was stored
209      * @param manifest is the {@link Manifest} of {@link SignedInfo} in which the Reference occurs.
210      * We need this because the Manifest has the individual {@link ResourceResolver}s which have
211      * been set by the user
212      * @throws XMLSecurityException
213      */
214     protected Reference(Element element, String baseURI, Manifest manifest) throws XMLSecurityException {
215         this(element, baseURI, manifest, true);
216     }
217 
218     /**
219      * Build a {@link Reference} from an {@link Element}
220      *
221      * @param element {@code Reference} element
222      * @param baseURI the URI of the resource where the XML instance was stored
223      * @param manifest is the {@link Manifest} of {@link SignedInfo} in which the Reference occurs.
224      * @param secureValidation whether secure validation is enabled or not
225      * We need this because the Manifest has the individual {@link ResourceResolver}s which have
226      * been set by the user
227      * @throws XMLSecurityException
228      */
229     protected Reference(Element element, String baseURI, Manifest manifest, boolean secureValidation)
230         throws XMLSecurityException {
231         super(element, baseURI);
232         this.secureValidation = secureValidation;
233         this.baseURI = baseURI;
234         Element el = XMLUtils.getNextElement(element.getFirstChild());
235 
236         if (el != null &amp;&amp; Constants._TAG_TRANSFORMS.equals(el.getLocalName())
237             &amp;&amp; Constants.SignatureSpecNS.equals(el.getNamespaceURI())) {
238             transforms = new Transforms(el, this.baseURI);
239             transforms.setSecureValidation(secureValidation);
240             if (secureValidation &amp;&amp; transforms.getLength() &gt; MAXIMUM_TRANSFORM_COUNT) {
241                 Object exArgs[] = { transforms.getLength(), MAXIMUM_TRANSFORM_COUNT };
242 
243                 throw new XMLSecurityException(&quot;signature.tooManyTransforms&quot;, exArgs);
244             }
245             el = XMLUtils.getNextElement(el.getNextSibling());
246         }
247 
248         digestMethodElem = el;
249         if (digestMethodElem == null) {
250             throw new XMLSecurityException(&quot;signature.Reference.NoDigestMethod&quot;);
251         }
252 
253         digestValueElement = XMLUtils.getNextElement(digestMethodElem.getNextSibling());
254         if (digestValueElement == null) {
255             throw new XMLSecurityException(&quot;signature.Reference.NoDigestValue&quot;);
256         }
257         this.manifest = manifest;
258     }
259 
260     /**
261      * Returns {@link MessageDigestAlgorithm}
262      *
263      *
264      * @return {@link MessageDigestAlgorithm}
265      *
266      * @throws XMLSignatureException
267      */
268     public MessageDigestAlgorithm getMessageDigestAlgorithm() throws XMLSignatureException {
269         if (digestMethodElem == null) {
270             return null;
271         }
272 
273         String uri = digestMethodElem.getAttributeNS(null, Constants._ATT_ALGORITHM);
274 
275         if (&quot;&quot;.equals(uri)) {
276             return null;
277         }
278 
279         if (secureValidation &amp;&amp; MessageDigestAlgorithm.ALGO_ID_DIGEST_NOT_RECOMMENDED_MD5.equals(uri)) {
280             Object exArgs[] = { uri };
281 
282             throw new XMLSignatureException(&quot;signature.signatureAlgorithm&quot;, exArgs);
283         }
284 
285         return MessageDigestAlgorithm.getInstance(getDocument(), uri);
286     }
287 
288     /**
289      * Sets the {@code URI} of this {@code Reference} element
290      *
291      * @param uri the {@code URI} of this {@code Reference} element
292      */
293     public void setURI(String uri) {
294         if (uri != null) {
295             setLocalAttribute(Constants._ATT_URI, uri);
296         }
297     }
298 
299     /**
300      * Returns the {@code URI} of this {@code Reference} element
301      *
302      * @return URI the {@code URI} of this {@code Reference} element
303      */
304     public String getURI() {
305         return getLocalAttribute(Constants._ATT_URI);
306     }
307 
308     /**
309      * Sets the {@code Id} attribute of this {@code Reference} element
310      *
311      * @param id the {@code Id} attribute of this {@code Reference} element
312      */
313     public void setId(String id) {
314         if (id != null) {
315             setLocalIdAttribute(Constants._ATT_ID, id);
316         }
317     }
318 
319     /**
320      * Returns the {@code Id} attribute of this {@code Reference} element
321      *
322      * @return Id the {@code Id} attribute of this {@code Reference} element
323      */
324     public String getId() {
325         return getLocalAttribute(Constants._ATT_ID);
326     }
327 
328     /**
329      * Sets the {@code type} atttibute of the Reference indicate whether an
330      * {@code ds:Object}, {@code ds:SignatureProperty}, or {@code ds:Manifest}
331      * element.
332      *
333      * @param type the {@code type} attribute of the Reference
334      */
335     public void setType(String type) {
336         if (type != null) {
337             setLocalAttribute(Constants._ATT_TYPE, type);
338         }
339     }
340 
341     /**
342      * Return the {@code type} atttibute of the Reference indicate whether an
343      * {@code ds:Object}, {@code ds:SignatureProperty}, or {@code ds:Manifest}
344      * element
345      *
346      * @return the {@code type} attribute of the Reference
347      */
348     public String getType() {
349         return getLocalAttribute(Constants._ATT_TYPE);
350     }
351 
352     /**
353      * Method isReferenceToObject
354      *
355      * This returns true if the {@code Type} attribute of the
356      * {@code Reference} element points to a {@code #Object} element
357      *
358      * @return true if the Reference type indicates that this Reference points to an
359      * {@code Object}
360      */
361     public boolean typeIsReferenceToObject() {
362         if (Reference.OBJECT_URI.equals(this.getType())) {
363             return true;
364         }
365 
366         return false;
367     }
368 
369     /**
370      * Method isReferenceToManifest
371      *
372      * This returns true if the {@code Type} attribute of the
373      * {@code Reference} element points to a {@code #Manifest} element
374      *
375      * @return true if the Reference type indicates that this Reference points to a
376      * {@link Manifest}
377      */
378     public boolean typeIsReferenceToManifest() {
379         if (Reference.MANIFEST_URI.equals(this.getType())) {
380             return true;
381         }
382 
383         return false;
384     }
385 
386     /**
387      * Method setDigestValueElement
388      *
389      * @param digestValue
390      */
391     private void setDigestValueElement(byte[] digestValue) {
392         Node n = digestValueElement.getFirstChild();
393         while (n != null) {
394             digestValueElement.removeChild(n);
395             n = n.getNextSibling();
396         }
397 
<a name="2" id="anc2"></a><span class="line-modified">398         String base64codedValue = XMLUtils.encodeToString(digestValue);</span>
399         Text t = createText(base64codedValue);
400 
401         digestValueElement.appendChild(t);
402     }
403 
404     /**
405      * Method generateDigestValue
406      *
407      * @throws ReferenceNotInitializedException
408      * @throws XMLSignatureException
409      */
410     public void generateDigestValue()
411         throws XMLSignatureException, ReferenceNotInitializedException {
412         this.setDigestValueElement(this.calculateDigest(false));
413     }
414 
415     /**
416      * Returns the XMLSignatureInput which is created by de-referencing the URI attribute.
417      * @return the XMLSignatureInput of the source of this reference
418      * @throws ReferenceNotInitializedException If the resolver found any
419      * problem resolving the reference
420      */
421     public XMLSignatureInput getContentsBeforeTransformation()
422         throws ReferenceNotInitializedException {
423         try {
424             Attr uriAttr =
425                 getElement().getAttributeNodeNS(null, Constants._ATT_URI);
426 
427             ResourceResolver resolver =
428                 ResourceResolver.getInstance(
429                     uriAttr, this.baseURI, this.manifest.getPerManifestResolvers(), secureValidation
430                 );
431             resolver.addProperties(this.manifest.getResolverProperties());
432 
433             return resolver.resolve(uriAttr, this.baseURI, secureValidation);
434         }  catch (ResourceResolverException ex) {
435             throw new ReferenceNotInitializedException(ex);
436         }
437     }
438 
439     private XMLSignatureInput getContentsAfterTransformation(
440         XMLSignatureInput input, OutputStream os
441     ) throws XMLSignatureException {
442         try {
443             Transforms transforms = this.getTransforms();
444             XMLSignatureInput output = null;
445 
446             if (transforms != null) {
447                 output = transforms.performTransforms(input, os);
448                 this.transformsOutput = output;//new XMLSignatureInput(output.getBytes());
449 
450                 //this.transformsOutput.setSourceURI(output.getSourceURI());
451             } else {
452                 output = input;
453             }
454 
455             return output;
456         } catch (ResourceResolverException ex) {
457             throw new XMLSignatureException(ex);
458         } catch (CanonicalizationException ex) {
459             throw new XMLSignatureException(ex);
460         } catch (InvalidCanonicalizerException ex) {
461             throw new XMLSignatureException(ex);
462         } catch (TransformationException ex) {
463             throw new XMLSignatureException(ex);
464         } catch (XMLSecurityException ex) {
465             throw new XMLSignatureException(ex);
466         }
467     }
468 
469     /**
470      * Returns the XMLSignatureInput which is the result of the Transforms.
471      * @return a XMLSignatureInput with all transformations applied.
472      * @throws XMLSignatureException
473      */
474     public XMLSignatureInput getContentsAfterTransformation()
475         throws XMLSignatureException {
476         XMLSignatureInput input = this.getContentsBeforeTransformation();
477         cacheDereferencedElement(input);
478 
479         return this.getContentsAfterTransformation(input, null);
480     }
481 
482     /**
483      * This method returns the XMLSignatureInput which represents the node set before
484      * some kind of canonicalization is applied for the first time.
485      * @return Gets a the node doing everything till the first c14n is needed
486      *
487      * @throws XMLSignatureException
488      */
489     public XMLSignatureInput getNodesetBeforeFirstCanonicalization()
490         throws XMLSignatureException {
491         try {
492             XMLSignatureInput input = this.getContentsBeforeTransformation();
493             cacheDereferencedElement(input);
494             XMLSignatureInput output = input;
495             Transforms transforms = this.getTransforms();
496 
497             if (transforms != null) {
498                 for (int i = 0; i &lt; transforms.getLength(); i++) {
499                     Transform t = transforms.item(i);
500                     String uri = t.getURI();
501 
502                     if (uri.equals(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS)
503                         || uri.equals(Transforms.TRANSFORM_C14N_EXCL_WITH_COMMENTS)
504                         || uri.equals(Transforms.TRANSFORM_C14N_OMIT_COMMENTS)
505                         || uri.equals(Transforms.TRANSFORM_C14N_WITH_COMMENTS)
506                         || uri.equals(Transforms.TRANSFORM_C14N11_OMIT_COMMENTS)
507                         || uri.equals(Transforms.TRANSFORM_C14N11_WITH_COMMENTS)) {
508                         break;
509                     }
510 
511                     output = t.performTransform(output, null);
512                 }
513 
514                 output.setSourceURI(input.getSourceURI());
515             }
516             return output;
517         } catch (IOException ex) {
518             throw new XMLSignatureException(ex);
519         } catch (ResourceResolverException ex) {
520             throw new XMLSignatureException(ex);
521         } catch (CanonicalizationException ex) {
522             throw new XMLSignatureException(ex);
523         } catch (InvalidCanonicalizerException ex) {
524             throw new XMLSignatureException(ex);
525         } catch (TransformationException ex) {
526             throw new XMLSignatureException(ex);
527         } catch (XMLSecurityException ex) {
528             throw new XMLSignatureException(ex);
529         }
530     }
531 
532     /**
533      * Method getHTMLRepresentation
534      * @return The HTML of the transformation
535      * @throws XMLSignatureException
536      */
537     public String getHTMLRepresentation() throws XMLSignatureException {
538         try {
539             XMLSignatureInput nodes = this.getNodesetBeforeFirstCanonicalization();
540 
541             Transforms transforms = this.getTransforms();
542             Transform c14nTransform = null;
543 
544             if (transforms != null) {
545                 for (int i = 0; i &lt; transforms.getLength(); i++) {
546                     Transform t = transforms.item(i);
547                     String uri = t.getURI();
548 
549                     if (uri.equals(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS)
550                         || uri.equals(Transforms.TRANSFORM_C14N_EXCL_WITH_COMMENTS)) {
551                         c14nTransform = t;
552                         break;
553                     }
554                 }
555             }
556 
557             Set&lt;String&gt; inclusiveNamespaces = new HashSet&lt;&gt;();
558             if (c14nTransform != null
559                 &amp;&amp; c14nTransform.length(
560                     InclusiveNamespaces.ExclusiveCanonicalizationNamespace,
561                     InclusiveNamespaces._TAG_EC_INCLUSIVENAMESPACES) == 1) {
562 
563                 // there is one InclusiveNamespaces element
564                 InclusiveNamespaces in =
565                     new InclusiveNamespaces(
566                         XMLUtils.selectNode(
567                             c14nTransform.getElement().getFirstChild(),
568                             InclusiveNamespaces.ExclusiveCanonicalizationNamespace,
569                             InclusiveNamespaces._TAG_EC_INCLUSIVENAMESPACES,
570                             0
571                         ), this.getBaseURI());
572 
573                 inclusiveNamespaces =
574                     InclusiveNamespaces.prefixStr2Set(in.getInclusiveNamespaces());
575             }
576 
577             return nodes.getHTMLRepresentation(inclusiveNamespaces);
578         } catch (TransformationException ex) {
579             throw new XMLSignatureException(ex);
580         } catch (InvalidTransformException ex) {
581             throw new XMLSignatureException(ex);
582         } catch (XMLSecurityException ex) {
583             throw new XMLSignatureException(ex);
584         }
585     }
586 
587     /**
588      * This method only works after a call to verify.
589      * @return the transformed output(i.e. what is going to be digested).
590      */
591     public XMLSignatureInput getTransformsOutput() {
592         return this.transformsOutput;
593     }
594 
595     /**
596      * Get the ReferenceData that corresponds to the cached representation of the dereferenced
597      * object before transformation.
598      */
599     public ReferenceData getReferenceData() {
600         return referenceData;
601     }
602 
603     /**
604      * This method returns the {@link XMLSignatureInput} which is referenced by the
605      * {@code URI} Attribute.
606      * @param os where to write the transformation can be null.
607      * @return the element to digest
608      *
609      * @throws XMLSignatureException
610      * @see Manifest#verifyReferences()
611      */
612     protected XMLSignatureInput dereferenceURIandPerformTransforms(OutputStream os)
613         throws XMLSignatureException {
614         try {
615             XMLSignatureInput input = this.getContentsBeforeTransformation();
616             cacheDereferencedElement(input);
617 
618             XMLSignatureInput output = this.getContentsAfterTransformation(input, os);
619             this.transformsOutput = output;
620             return output;
621         } catch (XMLSecurityException ex) {
622             throw new ReferenceNotInitializedException(ex);
623         }
624     }
625 
626     /**
627      * Store the dereferenced Element(s) so that it/they can be retrieved later.
628      */
629     private void cacheDereferencedElement(XMLSignatureInput input) {
630         if (input.isNodeSet()) {
631             try {
632                 final Set&lt;Node&gt; s = input.getNodeSet();
633                 referenceData = new ReferenceNodeSetData() {
634                     public Iterator&lt;Node&gt; iterator() {
635                         return new Iterator&lt;Node&gt;() {
636 
637                             Iterator&lt;Node&gt; sIterator = s.iterator();
638 
639                             @Override
640                             public boolean hasNext() {
641                                 return sIterator.hasNext();
642                             }
643 
644                             @Override
645                             public Node next() {
646                                 return sIterator.next();
647                             }
648 
649                             @Override
650                             public void remove() {
651                                 throw new UnsupportedOperationException();
652                             }
653                         };
654                     }
655                 };
656             } catch (Exception e) {
657                 // LOG a warning
658                 LOG.warn(&quot;cannot cache dereferenced data: &quot; + e);
659             }
660         } else if (input.isElement()) {
661             referenceData = new ReferenceSubTreeData
662                 (input.getSubNode(), input.isExcludeComments());
663         } else if (input.isOctetStream() || input.isByteArray()) {
664             try {
665                 referenceData = new ReferenceOctetStreamData
666                     (input.getOctetStream(), input.getSourceURI(),
667                         input.getMIMEType());
668             } catch (IOException ioe) {
669                 // LOG a warning
670                 LOG.warn(&quot;cannot cache dereferenced data: &quot; + ioe);
671             }
672         }
673     }
674 
675     /**
676      * Method getTransforms
677      *
678      * @return The transforms that applied this reference.
679      * @throws InvalidTransformException
680      * @throws TransformationException
681      * @throws XMLSecurityException
682      * @throws XMLSignatureException
683      */
684     public Transforms getTransforms()
685         throws XMLSignatureException, InvalidTransformException,
686         TransformationException, XMLSecurityException {
687         return transforms;
688     }
689 
690     /**
691      * Method getReferencedBytes
692      *
693      * @return the bytes that will be used to generated digest.
694      * @throws ReferenceNotInitializedException
695      * @throws XMLSignatureException
696      */
697     public byte[] getReferencedBytes()
698         throws ReferenceNotInitializedException, XMLSignatureException {
699         try {
700             XMLSignatureInput output = this.dereferenceURIandPerformTransforms(null);
701             return output.getBytes();
702         } catch (IOException ex) {
703             throw new ReferenceNotInitializedException(ex);
704         } catch (CanonicalizationException ex) {
705             throw new ReferenceNotInitializedException(ex);
706         }
707     }
708 
709 
710     /**
711      * Method calculateDigest
712      *
713      * @param validating true if validating the reference
714      * @return reference Calculate the digest of this reference.
715      * @throws ReferenceNotInitializedException
716      * @throws XMLSignatureException
717      */
718     private byte[] calculateDigest(boolean validating)
719         throws ReferenceNotInitializedException, XMLSignatureException {
720         XMLSignatureInput input = this.getContentsBeforeTransformation();
721         if (input.isPreCalculatedDigest()) {
722             return getPreCalculatedDigest(input);
723         }
724 
<a name="3" id="anc3"></a><span class="line-added">725         cacheDereferencedElement(input);</span>
<span class="line-added">726 </span>
727         MessageDigestAlgorithm mda = this.getMessageDigestAlgorithm();
728         mda.reset();
729 
730         try (DigesterOutputStream diOs = new DigesterOutputStream(mda);
731             OutputStream os = new UnsyncBufferedOutputStream(diOs)) {
<a name="4" id="anc4"></a><span class="line-modified">732 </span>
<span class="line-added">733             XMLSignatureInput output = this.getContentsAfterTransformation(input, os);</span>
<span class="line-added">734             this.transformsOutput = output;</span>
<span class="line-added">735 </span>
736             // if signing and c14n11 property == true explicitly add
737             // C14N11 transform if needed
738             if (Reference.useC14N11 &amp;&amp; !validating &amp;&amp; !output.isOutputStreamSet()
739                 &amp;&amp; !output.isOctetStream()) {
740                 if (transforms == null) {
741                     transforms = new Transforms(getDocument());
742                     transforms.setSecureValidation(secureValidation);
743                     getElement().insertBefore(transforms.getElement(), digestMethodElem);
744                 }
745                 transforms.addTransform(Transforms.TRANSFORM_C14N11_OMIT_COMMENTS);
746                 output.updateOutputStream(os, true);
747             } else {
748                 output.updateOutputStream(os);
749             }
750             os.flush();
751 
752             if (output.getOctetStreamReal() != null) {
753                 output.getOctetStreamReal().close();
754             }
755 
756             //this.getReferencedBytes(diOs);
757             //mda.update(data);
758 
759             return diOs.getDigestValue();
760         } catch (XMLSecurityException ex) {
761             throw new ReferenceNotInitializedException(ex);
762         } catch (IOException ex) {
763             throw new ReferenceNotInitializedException(ex);
764         }
765     }
766 
767     /**
768      * Get the pre-calculated digest value from the XMLSignatureInput.
769      *
770      * @param input XMLSignature
771      * @return a pre-calculated digest value.
772      * @throws ReferenceNotInitializedException if there is an error decoding digest value
773      * in Base64. Properly encoded pre-calculated digest value must be set.
774      */
775     private byte[] getPreCalculatedDigest(XMLSignatureInput input)
776             throws ReferenceNotInitializedException {
777         LOG.debug(&quot;Verifying element with pre-calculated digest&quot;);
778         String preCalculatedDigest = input.getPreCalculatedDigest();
<a name="5" id="anc5"></a><span class="line-modified">779         return XMLUtils.decode(preCalculatedDigest);</span>
780     }
781 
782     /**
783      * Returns the digest value.
784      *
785      * @return the digest value.
786      * @throws XMLSecurityException if the Reference does not contain a DigestValue element
787      */
788     public byte[] getDigestValue() throws XMLSecurityException {
789         if (digestValueElement == null) {
790             // The required element is not in the XML!
791             Object[] exArgs ={ Constants._TAG_DIGESTVALUE, Constants.SignatureSpecNS };
792             throw new XMLSecurityException(
793                 &quot;signature.Verification.NoSignatureElement&quot;, exArgs
794             );
795         }
<a name="6" id="anc6"></a><span class="line-modified">796         String content = XMLUtils.getFullTextChildrenFromNode(digestValueElement);</span>
<span class="line-modified">797         return XMLUtils.decode(content);</span>
798     }
799 
800 
801     /**
802      * Tests reference validation is success or false
803      *
804      * @return true if reference validation is success, otherwise false
805      * @throws ReferenceNotInitializedException
806      * @throws XMLSecurityException
807      */
808     public boolean verify()
809         throws ReferenceNotInitializedException, XMLSecurityException {
810         byte[] elemDig = this.getDigestValue();
811         byte[] calcDig = this.calculateDigest(true);
812         boolean equal = MessageDigestAlgorithm.isEqual(elemDig, calcDig);
813 
814         if (!equal) {
815             LOG.warn(&quot;Verification failed for URI \&quot;&quot; + this.getURI() + &quot;\&quot;&quot;);
<a name="7" id="anc7"></a><span class="line-modified">816             LOG.warn(&quot;Expected Digest: &quot; + XMLUtils.encodeToString(elemDig));</span>
<span class="line-modified">817             LOG.warn(&quot;Actual Digest: &quot; + XMLUtils.encodeToString(calcDig));</span>
818         } else {
819             LOG.debug(&quot;Verification successful for URI \&quot;{}\&quot;&quot;, this.getURI());
820         }
821 
822         return equal;
823     }
824 
825     /**
826      * Method getBaseLocalName
827      * {@inheritDoc}
828      */
829     public String getBaseLocalName() {
830         return Constants._TAG_REFERENCE;
831     }
832 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/c14n/Canonicalizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.c14n;
 24 
 25 import java.io.ByteArrayInputStream;
 26 import java.io.InputStream;
 27 import java.io.OutputStream;
 28 import java.nio.charset.StandardCharsets;
 29 import java.util.Map;
 30 import java.util.Set;
 31 import java.util.concurrent.ConcurrentHashMap;
 32 
 33 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer11_OmitComments;
 34 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer11_WithComments;
 35 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315ExclOmitComments;
 36 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315ExclWithComments;
 37 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315OmitComments;
 38 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315WithComments;
 39 import com.sun.org.apache.xml.internal.security.c14n.implementations.CanonicalizerPhysical;
 40 import com.sun.org.apache.xml.internal.security.exceptions.AlgorithmAlreadyRegisteredException;
 41 import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 42 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 43 import org.w3c.dom.Document;
 44 import org.w3c.dom.Node;
 45 import org.w3c.dom.NodeList;
 46 import org.xml.sax.InputSource;
 47 
 48 /**
 49  *
 50  */
 51 public class Canonicalizer {
 52 
 53     /** The output encoding of canonicalized data */
 54     public static final String ENCODING = StandardCharsets.UTF_8.name();
 55 
 56     /**
 57      * XPath Expression for selecting every node and continuous comments joined
 58      * in only one node
 59      */
 60     public static final String XPATH_C14N_WITH_COMMENTS_SINGLE_NODE =
 61         &quot;(.//. | .//@* | .//namespace::*)&quot;;
 62 
 63     /**
 64      * The URL defined in XML-SEC Rec for inclusive c14n &lt;b&gt;without&lt;/b&gt; comments.
 65      */
 66     public static final String ALGO_ID_C14N_OMIT_COMMENTS =
 67         &quot;http://www.w3.org/TR/2001/REC-xml-c14n-20010315&quot;;
 68     /**
 69      * The URL defined in XML-SEC Rec for inclusive c14n &lt;b&gt;with&lt;/b&gt; comments.
 70      */
 71     public static final String ALGO_ID_C14N_WITH_COMMENTS =
 72         ALGO_ID_C14N_OMIT_COMMENTS + &quot;#WithComments&quot;;
 73     /**
 74      * The URL defined in XML-SEC Rec for exclusive c14n &lt;b&gt;without&lt;/b&gt; comments.
 75      */
 76     public static final String ALGO_ID_C14N_EXCL_OMIT_COMMENTS =
 77         &quot;http://www.w3.org/2001/10/xml-exc-c14n#&quot;;
 78     /**
 79      * The URL defined in XML-SEC Rec for exclusive c14n &lt;b&gt;with&lt;/b&gt; comments.
 80      */
 81     public static final String ALGO_ID_C14N_EXCL_WITH_COMMENTS =
 82         ALGO_ID_C14N_EXCL_OMIT_COMMENTS + &quot;WithComments&quot;;
 83     /**
 84      * The URI for inclusive c14n 1.1 &lt;b&gt;without&lt;/b&gt; comments.
 85      */
 86     public static final String ALGO_ID_C14N11_OMIT_COMMENTS =
 87         &quot;http://www.w3.org/2006/12/xml-c14n11&quot;;
 88     /**
 89      * The URI for inclusive c14n 1.1 &lt;b&gt;with&lt;/b&gt; comments.
 90      */
 91     public static final String ALGO_ID_C14N11_WITH_COMMENTS =
 92         ALGO_ID_C14N11_OMIT_COMMENTS + &quot;#WithComments&quot;;
 93     /**
 94      * Non-standard algorithm to serialize the physical representation for XML Encryption
 95      */
 96     public static final String ALGO_ID_C14N_PHYSICAL =
 97         &quot;http://santuario.apache.org/c14n/physical&quot;;
 98 
 99     private static Map&lt;String, Class&lt;? extends CanonicalizerSpi&gt;&gt; canonicalizerHash =
100         new ConcurrentHashMap&lt;String, Class&lt;? extends CanonicalizerSpi&gt;&gt;();
101 
102     private final CanonicalizerSpi canonicalizerSpi;
103     private boolean secureValidation;
104 
105     /**
106      * Constructor Canonicalizer
107      *
108      * @param algorithmURI
109      * @throws InvalidCanonicalizerException
110      */
111     private Canonicalizer(String algorithmURI) throws InvalidCanonicalizerException {
112         try {
113             Class&lt;? extends CanonicalizerSpi&gt; implementingClass =
114                 canonicalizerHash.get(algorithmURI);
115 
116             @SuppressWarnings(&quot;deprecation&quot;)
117             CanonicalizerSpi tmp = implementingClass.newInstance();
118             canonicalizerSpi = tmp;
119             canonicalizerSpi.reset = true;
120         } catch (Exception e) {
121             Object exArgs[] = { algorithmURI };
122             throw new InvalidCanonicalizerException(
123                 e, &quot;signature.Canonicalizer.UnknownCanonicalizer&quot;, exArgs
124             );
125         }
126     }
127 
128     /**
129      * Method getInstance
130      *
131      * @param algorithmURI
132      * @return a Canonicalizer instance ready for the job
133      * @throws InvalidCanonicalizerException
134      */
135     public static final Canonicalizer getInstance(String algorithmURI)
136         throws InvalidCanonicalizerException {
137         return new Canonicalizer(algorithmURI);
138     }
139 
140     /**
141      * Method register
142      *
143      * @param algorithmURI
144      * @param implementingClass
145      * @throws AlgorithmAlreadyRegisteredException
146      * @throws SecurityException if a security manager is installed and the
147      *    caller does not have permission to register the canonicalizer
148      */
149     @SuppressWarnings(&quot;unchecked&quot;)
150     public static void register(String algorithmURI, String implementingClass)
151         throws AlgorithmAlreadyRegisteredException, ClassNotFoundException {
152         JavaUtils.checkRegisterPermission();
153         // check whether URI is already registered
154         Class&lt;? extends CanonicalizerSpi&gt; registeredClass =
155             canonicalizerHash.get(algorithmURI);
156 
157         if (registeredClass != null)  {
158             Object exArgs[] = { algorithmURI, registeredClass };
159             throw new AlgorithmAlreadyRegisteredException(&quot;algorithm.alreadyRegistered&quot;, exArgs);
160         }
161 
162         canonicalizerHash.put(
163             algorithmURI, (Class&lt;? extends CanonicalizerSpi&gt;)
164             ClassLoaderUtils.loadClass(implementingClass, Canonicalizer.class)
165         );
166     }
167 
168     /**
169      * Method register
170      *
171      * @param algorithmURI
172      * @param implementingClass
173      * @throws AlgorithmAlreadyRegisteredException
174      * @throws SecurityException if a security manager is installed and the
175      *    caller does not have permission to register the canonicalizer
176      */
177     public static void register(String algorithmURI, Class&lt;? extends CanonicalizerSpi&gt; implementingClass)
178         throws AlgorithmAlreadyRegisteredException, ClassNotFoundException {
179         JavaUtils.checkRegisterPermission();
180         // check whether URI is already registered
181         Class&lt;? extends CanonicalizerSpi&gt; registeredClass = canonicalizerHash.get(algorithmURI);
182 
183         if (registeredClass != null)  {
184             Object exArgs[] = { algorithmURI, registeredClass };
185             throw new AlgorithmAlreadyRegisteredException(&quot;algorithm.alreadyRegistered&quot;, exArgs);
186         }
187 
188         canonicalizerHash.put(algorithmURI, implementingClass);
189     }
190 
191     /**
192      * This method registers the default algorithms.
193      */
194     public static void registerDefaultAlgorithms() {
195         canonicalizerHash.put(
196             Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS,
197             Canonicalizer20010315OmitComments.class
198         );
199         canonicalizerHash.put(
200             Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS,
201             Canonicalizer20010315WithComments.class
202         );
203         canonicalizerHash.put(
204             Canonicalizer.ALGO_ID_C14N_EXCL_OMIT_COMMENTS,
205             Canonicalizer20010315ExclOmitComments.class
206         );
207         canonicalizerHash.put(
208             Canonicalizer.ALGO_ID_C14N_EXCL_WITH_COMMENTS,
209             Canonicalizer20010315ExclWithComments.class
210         );
211         canonicalizerHash.put(
212             Canonicalizer.ALGO_ID_C14N11_OMIT_COMMENTS,
213             Canonicalizer11_OmitComments.class
214         );
215         canonicalizerHash.put(
216             Canonicalizer.ALGO_ID_C14N11_WITH_COMMENTS,
217             Canonicalizer11_WithComments.class
218         );
219         canonicalizerHash.put(
220             Canonicalizer.ALGO_ID_C14N_PHYSICAL,
221             CanonicalizerPhysical.class
222         );
223     }
224 
225     /**
226      * Method getURI
227      *
228      * @return the URI defined for this c14n instance.
229      */
230     public final String getURI() {
231         return canonicalizerSpi.engineGetURI();
232     }
233 
234     /**
235      * Method getIncludeComments
236      *
237      * @return true if the c14n respect the comments.
238      */
239     public boolean getIncludeComments() {
240         return canonicalizerSpi.engineGetIncludeComments();
241     }
242 
243     /**
244      * This method tries to canonicalize the given bytes. It&#39;s possible to even
245      * canonicalize non-wellformed sequences if they are well-formed after being
246      * wrapped with a {@code &amp;gt;a&amp;lt;...&amp;gt;/a&amp;lt;}.
247      *
248      * @param inputBytes
249      * @return the result of the canonicalization.
250      * @throws CanonicalizationException
251      * @throws java.io.IOException
252      * @throws javax.xml.parsers.ParserConfigurationException
253      * @throws org.xml.sax.SAXException
254      */
255     public byte[] canonicalize(byte[] inputBytes)
256         throws javax.xml.parsers.ParserConfigurationException,
257         java.io.IOException, org.xml.sax.SAXException, CanonicalizationException {
258         Document document = null;
259         try (InputStream bais = new ByteArrayInputStream(inputBytes)) {
260             InputSource in = new InputSource(bais);
261 
262             /*
263              * Text from the spec:
264              *
265              * The input octet stream MUST contain a well-formed XML document,
266              * but the input need not be validated. However, the attribute
267              * value normalization and entity reference resolution MUST be
268              * performed in accordance with the behaviors of a validating
269              * XML processor. As well, nodes for default attributes (declared
270              * in the ATTLIST with an AttValue but not specified) are created
271              * in each element. Thus, the declarations in the document type
272              * declaration are used to help create the canonical form, even
273              * though the document type declaration is not retained in the
274              * canonical form.
275              */
276             document = XMLUtils.read(in, secureValidation);
277         }
278         return this.canonicalizeSubtree(document);
279     }
280 
281     /**
282      * Canonicalizes the subtree rooted by {@code node}.
283      *
284      * @param node The node to canonicalize
285      * @return the result of the c14n.
286      *
287      * @throws CanonicalizationException
288      */
289     public byte[] canonicalizeSubtree(Node node) throws CanonicalizationException {
290         canonicalizerSpi.secureValidation = secureValidation;
291         return canonicalizerSpi.engineCanonicalizeSubTree(node);
292     }
293 
294     /**
295      * Canonicalizes the subtree rooted by {@code node}.
296      *
297      * @param node
298      * @param inclusiveNamespaces
299      * @return the result of the c14n.
300      * @throws CanonicalizationException
301      */
302     public byte[] canonicalizeSubtree(Node node, String inclusiveNamespaces)
303         throws CanonicalizationException {
304         canonicalizerSpi.secureValidation = secureValidation;
305         return canonicalizerSpi.engineCanonicalizeSubTree(node, inclusiveNamespaces);
306     }
307 
308     /**
309      * Canonicalizes the subtree rooted by {@code node}.
310      *
311      * @param node
312      * @param inclusiveNamespaces
313      * @return the result of the c14n.
314      * @throws CanonicalizationException
315      */
316     public byte[] canonicalizeSubtree(Node node, String inclusiveNamespaces, boolean propagateDefaultNamespace)
317             throws CanonicalizationException {
318         canonicalizerSpi.secureValidation = secureValidation;
319         return canonicalizerSpi.engineCanonicalizeSubTree(node, inclusiveNamespaces, propagateDefaultNamespace);
320     }
321 
322     /**
323      * Canonicalizes an XPath node set. The {@code xpathNodeSet} is treated
324      * as a list of XPath nodes, not as a list of subtrees.
325      *
326      * @param xpathNodeSet
327      * @return the result of the c14n.
328      * @throws CanonicalizationException
329      */
330     public byte[] canonicalizeXPathNodeSet(NodeList xpathNodeSet)
331         throws CanonicalizationException {
332         canonicalizerSpi.secureValidation = secureValidation;
333         return canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet);
334     }
335 
336     /**
337      * Canonicalizes an XPath node set. The {@code xpathNodeSet} is treated
338      * as a list of XPath nodes, not as a list of subtrees.
339      *
340      * @param xpathNodeSet
341      * @param inclusiveNamespaces
342      * @return the result of the c14n.
343      * @throws CanonicalizationException
344      */
345     public byte[] canonicalizeXPathNodeSet(
346         NodeList xpathNodeSet, String inclusiveNamespaces
347     ) throws CanonicalizationException {
348         canonicalizerSpi.secureValidation = secureValidation;
349         return
350             canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet, inclusiveNamespaces);
351     }
352 
353     /**
354      * Canonicalizes an XPath node set.
355      *
356      * @param xpathNodeSet
357      * @return the result of the c14n.
358      * @throws CanonicalizationException
359      */
360     public byte[] canonicalizeXPathNodeSet(Set&lt;Node&gt; xpathNodeSet)
361         throws CanonicalizationException {
362         canonicalizerSpi.secureValidation = secureValidation;
363         return canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet);
364     }
365 
366     /**
367      * Canonicalizes an XPath node set.
368      *
369      * @param xpathNodeSet
370      * @param inclusiveNamespaces
371      * @return the result of the c14n.
372      * @throws CanonicalizationException
373      */
374     public byte[] canonicalizeXPathNodeSet(
375         Set&lt;Node&gt; xpathNodeSet, String inclusiveNamespaces
376     ) throws CanonicalizationException {
377         canonicalizerSpi.secureValidation = secureValidation;
378         return
379             canonicalizerSpi.engineCanonicalizeXPathNodeSet(xpathNodeSet, inclusiveNamespaces);
380     }
381 
382     /**
383      * Sets the writer where the canonicalization ends.  ByteArrayOutputStream
384      * if none is set.
385      * @param os
386      */
387     public void setWriter(OutputStream os) {
388         canonicalizerSpi.setWriter(os);
389     }
390 
391     /**
392      * Returns the name of the implementing {@link CanonicalizerSpi} class
393      *
394      * @return the name of the implementing {@link CanonicalizerSpi} class
395      */
396     public String getImplementingCanonicalizerClass() {
397         return canonicalizerSpi.getClass().getName();
398     }
399 
400     /**
401      * Set the canonicalizer behaviour to not reset.
402      */
403     public void notReset() {
404         canonicalizerSpi.reset = false;
405     }
406 
407     public boolean isSecureValidation() {
408         return secureValidation;
409     }
410 
411     public void setSecureValidation(boolean secureValidation) {
412         this.secureValidation = secureValidation;
413     }
414 
415 }
    </pre>
  </body>
</html>
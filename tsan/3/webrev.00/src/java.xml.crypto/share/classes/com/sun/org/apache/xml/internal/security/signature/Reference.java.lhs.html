<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/signature/Reference.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.signature;
 24 
 25 import java.io.IOException;
 26 import java.io.OutputStream;
 27 import java.security.AccessController;
 28 import java.security.PrivilegedAction;
<a name="1" id="anc1"></a><span class="line-removed"> 29 import java.util.Base64;</span>
 30 import java.util.HashSet;
 31 import java.util.Iterator;
 32 import java.util.Set;
 33 
 34 import com.sun.org.apache.xml.internal.security.algorithms.Algorithm;
 35 import com.sun.org.apache.xml.internal.security.algorithms.MessageDigestAlgorithm;
 36 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 37 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
 38 import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 39 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceData;
 40 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceNodeSetData;
 41 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceOctetStreamData;
 42 import com.sun.org.apache.xml.internal.security.signature.reference.ReferenceSubTreeData;
 43 import com.sun.org.apache.xml.internal.security.transforms.InvalidTransformException;
 44 import com.sun.org.apache.xml.internal.security.transforms.Transform;
 45 import com.sun.org.apache.xml.internal.security.transforms.TransformationException;
 46 import com.sun.org.apache.xml.internal.security.transforms.Transforms;
 47 import com.sun.org.apache.xml.internal.security.transforms.params.InclusiveNamespaces;
 48 import com.sun.org.apache.xml.internal.security.utils.Constants;
 49 import com.sun.org.apache.xml.internal.security.utils.DigesterOutputStream;
 50 import com.sun.org.apache.xml.internal.security.utils.SignatureElementProxy;
 51 import com.sun.org.apache.xml.internal.security.utils.UnsyncBufferedOutputStream;
 52 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 53 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolver;
 54 import com.sun.org.apache.xml.internal.security.utils.resolver.ResourceResolverException;
 55 import org.w3c.dom.Attr;
 56 import org.w3c.dom.Document;
 57 import org.w3c.dom.Element;
 58 import org.w3c.dom.Node;
 59 import org.w3c.dom.Text;
 60 
 61 /**
 62  * Handles {@code &amp;lt;ds:Reference&amp;gt;} elements.
 63  *
 64  * This includes:
 65  *
 66  * Construct a {@code ds:Reference} from an {@link org.w3c.dom.Element}.
 67  *
 68  * &lt;p&gt;Create a new reference&lt;/p&gt;
 69  * &lt;pre&gt;
 70  * Document doc;
 71  * MessageDigestAlgorithm sha1 = MessageDigestAlgorithm.getInstance(&quot;http://#sha1&quot;);
 72  * Reference ref = new Reference(new XMLSignatureInput(new FileInputStream(&quot;1.gif&quot;),
 73  *                               &quot;http://localhost/1.gif&quot;,
 74  *                               (Transforms) null, sha1);
 75  * Element refElem = ref.toElement(doc);
 76  * &lt;/pre&gt;
 77  *
 78  * &lt;p&gt;Verify a reference&lt;/p&gt;
 79  * &lt;pre&gt;
 80  * Element refElem = doc.getElement(&quot;Reference&quot;); // PSEUDO
 81  * Reference ref = new Reference(refElem);
 82  * String url = ref.getURI();
 83  * ref.setData(new XMLSignatureInput(new FileInputStream(url)));
 84  * if (ref.verify()) {
 85  *    System.out.println(&quot;verified&quot;);
 86  * }
 87  * &lt;/pre&gt;
 88  *
 89  * &lt;pre&gt;
 90  * &amp;lt;element name=&quot;Reference&quot; type=&quot;ds:ReferenceType&quot;/&amp;gt;
 91  *  &amp;lt;complexType name=&quot;ReferenceType&quot;&amp;gt;
 92  *    &amp;lt;sequence&amp;gt;
 93  *      &amp;lt;element ref=&quot;ds:Transforms&quot; minOccurs=&quot;0&quot;/&amp;gt;
 94  *      &amp;lt;element ref=&quot;ds:DigestMethod&quot;/&amp;gt;
 95  *      &amp;lt;element ref=&quot;ds:DigestValue&quot;/&amp;gt;
 96  *    &amp;lt;/sequence&amp;gt;
 97  *    &amp;lt;attribute name=&quot;Id&quot; type=&quot;ID&quot; use=&quot;optional&quot;/&amp;gt;
 98  *    &amp;lt;attribute name=&quot;URI&quot; type=&quot;anyURI&quot; use=&quot;optional&quot;/&amp;gt;
 99  *    &amp;lt;attribute name=&quot;Type&quot; type=&quot;anyURI&quot; use=&quot;optional&quot;/&amp;gt;
100  *  &amp;lt;/complexType&amp;gt;
101  * &lt;/pre&gt;
102  *
103  * @see ObjectContainer
104  * @see Manifest
105  */
106 public class Reference extends SignatureElementProxy {
107 
108     /** Field OBJECT_URI */
109     public static final String OBJECT_URI = Constants.SignatureSpecNS + Constants._TAG_OBJECT;
110 
111     /** Field MANIFEST_URI */
112     public static final String MANIFEST_URI = Constants.SignatureSpecNS + Constants._TAG_MANIFEST;
113 
114     /**
115      * The maximum number of transforms per reference, if secure validation is enabled.
116      */
117     public static final int MAXIMUM_TRANSFORM_COUNT = 5;
118 
119     private boolean secureValidation;
120 
121     /**
122      * Look up useC14N11 system property. If true, an explicit C14N11 transform
123      * will be added if necessary when generating the signature. See section
124      * 3.1.1 of http://www.w3.org/2007/xmlsec/Drafts/xmldsig-core/ for more info.
125      */
126     private static boolean useC14N11 =
127         AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)
128             () -&gt; Boolean.getBoolean(&quot;com.sun.org.apache.xml.internal.security.useC14N11&quot;));
129 
130     private static final com.sun.org.slf4j.internal.Logger LOG =
131         com.sun.org.slf4j.internal.LoggerFactory.getLogger(Reference.class);
132 
133     private Manifest manifest;
134     private XMLSignatureInput transformsOutput;
135 
136     private Transforms transforms;
137 
138     private Element digestMethodElem;
139 
140     private Element digestValueElement;
141 
142     private ReferenceData referenceData;
143 
144     /**
145      * Constructor Reference
146      *
147      * @param doc the {@link Document} in which {@code XMLsignature} is placed
148      * @param baseURI the URI of the resource where the XML instance will be stored
149      * @param referenceURI URI indicate where is data which will digested
150      * @param manifest
151      * @param transforms {@link Transforms} applied to data
152      * @param messageDigestAlgorithm {@link MessageDigestAlgorithm Digest algorithm} which is
153      * applied to the data
154      * TODO should we throw XMLSignatureException if MessageDigestAlgoURI is wrong?
155      * @throws XMLSignatureException
156      */
157     protected Reference(
158         Document doc, String baseURI, String referenceURI, Manifest manifest,
159         Transforms transforms, String messageDigestAlgorithm
160     ) throws XMLSignatureException {
161         super(doc);
162 
163         addReturnToSelf();
164 
165         this.baseURI = baseURI;
166         this.manifest = manifest;
167 
168         this.setURI(referenceURI);
169 
170         // important: The ds:Reference must be added to the associated ds:Manifest
171         //            or ds:SignedInfo _before_ the this.resolverResult() is called.
172         // this.manifest.appendChild(this.constructionElement);
173         // this.manifest.appendChild(this.doc.createTextNode(&quot;\n&quot;));
174 
175         if (transforms != null) {
176             this.transforms = transforms;
177             appendSelf(transforms);
178             addReturnToSelf();
179         }
180 
181         // Create DigestMethod Element without actually instantiating a MessageDigest Object
182         Algorithm digestAlgorithm = new Algorithm(getDocument(), messageDigestAlgorithm) {
183             public String getBaseNamespace() {
184                 return Constants.SignatureSpecNS;
185             }
186 
187             public String getBaseLocalName() {
188                 return Constants._TAG_DIGESTMETHOD;
189             }
190         };
191 
192         digestMethodElem = digestAlgorithm.getElement();
193 
194         appendSelf(digestMethodElem);
195         addReturnToSelf();
196 
197         digestValueElement =
198             XMLUtils.createElementInSignatureSpace(getDocument(), Constants._TAG_DIGESTVALUE);
199 
200         appendSelf(digestValueElement);
201         addReturnToSelf();
202     }
203 
204 
205     /**
206      * Build a {@link Reference} from an {@link Element}
207      *
208      * @param element {@code Reference} element
209      * @param baseURI the URI of the resource where the XML instance was stored
210      * @param manifest is the {@link Manifest} of {@link SignedInfo} in which the Reference occurs.
211      * We need this because the Manifest has the individual {@link ResourceResolver}s which have
212      * been set by the user
213      * @throws XMLSecurityException
214      */
215     protected Reference(Element element, String baseURI, Manifest manifest) throws XMLSecurityException {
216         this(element, baseURI, manifest, true);
217     }
218 
219     /**
220      * Build a {@link Reference} from an {@link Element}
221      *
222      * @param element {@code Reference} element
223      * @param baseURI the URI of the resource where the XML instance was stored
224      * @param manifest is the {@link Manifest} of {@link SignedInfo} in which the Reference occurs.
225      * @param secureValidation whether secure validation is enabled or not
226      * We need this because the Manifest has the individual {@link ResourceResolver}s which have
227      * been set by the user
228      * @throws XMLSecurityException
229      */
230     protected Reference(Element element, String baseURI, Manifest manifest, boolean secureValidation)
231         throws XMLSecurityException {
232         super(element, baseURI);
233         this.secureValidation = secureValidation;
234         this.baseURI = baseURI;
235         Element el = XMLUtils.getNextElement(element.getFirstChild());
236 
237         if (el != null &amp;&amp; Constants._TAG_TRANSFORMS.equals(el.getLocalName())
238             &amp;&amp; Constants.SignatureSpecNS.equals(el.getNamespaceURI())) {
239             transforms = new Transforms(el, this.baseURI);
240             transforms.setSecureValidation(secureValidation);
241             if (secureValidation &amp;&amp; transforms.getLength() &gt; MAXIMUM_TRANSFORM_COUNT) {
242                 Object exArgs[] = { transforms.getLength(), MAXIMUM_TRANSFORM_COUNT };
243 
244                 throw new XMLSecurityException(&quot;signature.tooManyTransforms&quot;, exArgs);
245             }
246             el = XMLUtils.getNextElement(el.getNextSibling());
247         }
248 
249         digestMethodElem = el;
250         if (digestMethodElem == null) {
251             throw new XMLSecurityException(&quot;signature.Reference.NoDigestMethod&quot;);
252         }
253 
254         digestValueElement = XMLUtils.getNextElement(digestMethodElem.getNextSibling());
255         if (digestValueElement == null) {
256             throw new XMLSecurityException(&quot;signature.Reference.NoDigestValue&quot;);
257         }
258         this.manifest = manifest;
259     }
260 
261     /**
262      * Returns {@link MessageDigestAlgorithm}
263      *
264      *
265      * @return {@link MessageDigestAlgorithm}
266      *
267      * @throws XMLSignatureException
268      */
269     public MessageDigestAlgorithm getMessageDigestAlgorithm() throws XMLSignatureException {
270         if (digestMethodElem == null) {
271             return null;
272         }
273 
274         String uri = digestMethodElem.getAttributeNS(null, Constants._ATT_ALGORITHM);
275 
276         if (&quot;&quot;.equals(uri)) {
277             return null;
278         }
279 
280         if (secureValidation &amp;&amp; MessageDigestAlgorithm.ALGO_ID_DIGEST_NOT_RECOMMENDED_MD5.equals(uri)) {
281             Object exArgs[] = { uri };
282 
283             throw new XMLSignatureException(&quot;signature.signatureAlgorithm&quot;, exArgs);
284         }
285 
286         return MessageDigestAlgorithm.getInstance(getDocument(), uri);
287     }
288 
289     /**
290      * Sets the {@code URI} of this {@code Reference} element
291      *
292      * @param uri the {@code URI} of this {@code Reference} element
293      */
294     public void setURI(String uri) {
295         if (uri != null) {
296             setLocalAttribute(Constants._ATT_URI, uri);
297         }
298     }
299 
300     /**
301      * Returns the {@code URI} of this {@code Reference} element
302      *
303      * @return URI the {@code URI} of this {@code Reference} element
304      */
305     public String getURI() {
306         return getLocalAttribute(Constants._ATT_URI);
307     }
308 
309     /**
310      * Sets the {@code Id} attribute of this {@code Reference} element
311      *
312      * @param id the {@code Id} attribute of this {@code Reference} element
313      */
314     public void setId(String id) {
315         if (id != null) {
316             setLocalIdAttribute(Constants._ATT_ID, id);
317         }
318     }
319 
320     /**
321      * Returns the {@code Id} attribute of this {@code Reference} element
322      *
323      * @return Id the {@code Id} attribute of this {@code Reference} element
324      */
325     public String getId() {
326         return getLocalAttribute(Constants._ATT_ID);
327     }
328 
329     /**
330      * Sets the {@code type} atttibute of the Reference indicate whether an
331      * {@code ds:Object}, {@code ds:SignatureProperty}, or {@code ds:Manifest}
332      * element.
333      *
334      * @param type the {@code type} attribute of the Reference
335      */
336     public void setType(String type) {
337         if (type != null) {
338             setLocalAttribute(Constants._ATT_TYPE, type);
339         }
340     }
341 
342     /**
343      * Return the {@code type} atttibute of the Reference indicate whether an
344      * {@code ds:Object}, {@code ds:SignatureProperty}, or {@code ds:Manifest}
345      * element
346      *
347      * @return the {@code type} attribute of the Reference
348      */
349     public String getType() {
350         return getLocalAttribute(Constants._ATT_TYPE);
351     }
352 
353     /**
354      * Method isReferenceToObject
355      *
356      * This returns true if the {@code Type} attribute of the
357      * {@code Reference} element points to a {@code #Object} element
358      *
359      * @return true if the Reference type indicates that this Reference points to an
360      * {@code Object}
361      */
362     public boolean typeIsReferenceToObject() {
363         if (Reference.OBJECT_URI.equals(this.getType())) {
364             return true;
365         }
366 
367         return false;
368     }
369 
370     /**
371      * Method isReferenceToManifest
372      *
373      * This returns true if the {@code Type} attribute of the
374      * {@code Reference} element points to a {@code #Manifest} element
375      *
376      * @return true if the Reference type indicates that this Reference points to a
377      * {@link Manifest}
378      */
379     public boolean typeIsReferenceToManifest() {
380         if (Reference.MANIFEST_URI.equals(this.getType())) {
381             return true;
382         }
383 
384         return false;
385     }
386 
387     /**
388      * Method setDigestValueElement
389      *
390      * @param digestValue
391      */
392     private void setDigestValueElement(byte[] digestValue) {
393         Node n = digestValueElement.getFirstChild();
394         while (n != null) {
395             digestValueElement.removeChild(n);
396             n = n.getNextSibling();
397         }
398 
<a name="2" id="anc2"></a><span class="line-modified">399         String base64codedValue = Base64.getMimeEncoder().encodeToString(digestValue);</span>
400         Text t = createText(base64codedValue);
401 
402         digestValueElement.appendChild(t);
403     }
404 
405     /**
406      * Method generateDigestValue
407      *
408      * @throws ReferenceNotInitializedException
409      * @throws XMLSignatureException
410      */
411     public void generateDigestValue()
412         throws XMLSignatureException, ReferenceNotInitializedException {
413         this.setDigestValueElement(this.calculateDigest(false));
414     }
415 
416     /**
417      * Returns the XMLSignatureInput which is created by de-referencing the URI attribute.
418      * @return the XMLSignatureInput of the source of this reference
419      * @throws ReferenceNotInitializedException If the resolver found any
420      * problem resolving the reference
421      */
422     public XMLSignatureInput getContentsBeforeTransformation()
423         throws ReferenceNotInitializedException {
424         try {
425             Attr uriAttr =
426                 getElement().getAttributeNodeNS(null, Constants._ATT_URI);
427 
428             ResourceResolver resolver =
429                 ResourceResolver.getInstance(
430                     uriAttr, this.baseURI, this.manifest.getPerManifestResolvers(), secureValidation
431                 );
432             resolver.addProperties(this.manifest.getResolverProperties());
433 
434             return resolver.resolve(uriAttr, this.baseURI, secureValidation);
435         }  catch (ResourceResolverException ex) {
436             throw new ReferenceNotInitializedException(ex);
437         }
438     }
439 
440     private XMLSignatureInput getContentsAfterTransformation(
441         XMLSignatureInput input, OutputStream os
442     ) throws XMLSignatureException {
443         try {
444             Transforms transforms = this.getTransforms();
445             XMLSignatureInput output = null;
446 
447             if (transforms != null) {
448                 output = transforms.performTransforms(input, os);
449                 this.transformsOutput = output;//new XMLSignatureInput(output.getBytes());
450 
451                 //this.transformsOutput.setSourceURI(output.getSourceURI());
452             } else {
453                 output = input;
454             }
455 
456             return output;
457         } catch (ResourceResolverException ex) {
458             throw new XMLSignatureException(ex);
459         } catch (CanonicalizationException ex) {
460             throw new XMLSignatureException(ex);
461         } catch (InvalidCanonicalizerException ex) {
462             throw new XMLSignatureException(ex);
463         } catch (TransformationException ex) {
464             throw new XMLSignatureException(ex);
465         } catch (XMLSecurityException ex) {
466             throw new XMLSignatureException(ex);
467         }
468     }
469 
470     /**
471      * Returns the XMLSignatureInput which is the result of the Transforms.
472      * @return a XMLSignatureInput with all transformations applied.
473      * @throws XMLSignatureException
474      */
475     public XMLSignatureInput getContentsAfterTransformation()
476         throws XMLSignatureException {
477         XMLSignatureInput input = this.getContentsBeforeTransformation();
478         cacheDereferencedElement(input);
479 
480         return this.getContentsAfterTransformation(input, null);
481     }
482 
483     /**
484      * This method returns the XMLSignatureInput which represents the node set before
485      * some kind of canonicalization is applied for the first time.
486      * @return Gets a the node doing everything till the first c14n is needed
487      *
488      * @throws XMLSignatureException
489      */
490     public XMLSignatureInput getNodesetBeforeFirstCanonicalization()
491         throws XMLSignatureException {
492         try {
493             XMLSignatureInput input = this.getContentsBeforeTransformation();
494             cacheDereferencedElement(input);
495             XMLSignatureInput output = input;
496             Transforms transforms = this.getTransforms();
497 
498             if (transforms != null) {
499                 for (int i = 0; i &lt; transforms.getLength(); i++) {
500                     Transform t = transforms.item(i);
501                     String uri = t.getURI();
502 
503                     if (uri.equals(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS)
504                         || uri.equals(Transforms.TRANSFORM_C14N_EXCL_WITH_COMMENTS)
505                         || uri.equals(Transforms.TRANSFORM_C14N_OMIT_COMMENTS)
506                         || uri.equals(Transforms.TRANSFORM_C14N_WITH_COMMENTS)
507                         || uri.equals(Transforms.TRANSFORM_C14N11_OMIT_COMMENTS)
508                         || uri.equals(Transforms.TRANSFORM_C14N11_WITH_COMMENTS)) {
509                         break;
510                     }
511 
512                     output = t.performTransform(output, null);
513                 }
514 
515                 output.setSourceURI(input.getSourceURI());
516             }
517             return output;
518         } catch (IOException ex) {
519             throw new XMLSignatureException(ex);
520         } catch (ResourceResolverException ex) {
521             throw new XMLSignatureException(ex);
522         } catch (CanonicalizationException ex) {
523             throw new XMLSignatureException(ex);
524         } catch (InvalidCanonicalizerException ex) {
525             throw new XMLSignatureException(ex);
526         } catch (TransformationException ex) {
527             throw new XMLSignatureException(ex);
528         } catch (XMLSecurityException ex) {
529             throw new XMLSignatureException(ex);
530         }
531     }
532 
533     /**
534      * Method getHTMLRepresentation
535      * @return The HTML of the transformation
536      * @throws XMLSignatureException
537      */
538     public String getHTMLRepresentation() throws XMLSignatureException {
539         try {
540             XMLSignatureInput nodes = this.getNodesetBeforeFirstCanonicalization();
541 
542             Transforms transforms = this.getTransforms();
543             Transform c14nTransform = null;
544 
545             if (transforms != null) {
546                 for (int i = 0; i &lt; transforms.getLength(); i++) {
547                     Transform t = transforms.item(i);
548                     String uri = t.getURI();
549 
550                     if (uri.equals(Transforms.TRANSFORM_C14N_EXCL_OMIT_COMMENTS)
551                         || uri.equals(Transforms.TRANSFORM_C14N_EXCL_WITH_COMMENTS)) {
552                         c14nTransform = t;
553                         break;
554                     }
555                 }
556             }
557 
558             Set&lt;String&gt; inclusiveNamespaces = new HashSet&lt;&gt;();
559             if (c14nTransform != null
560                 &amp;&amp; c14nTransform.length(
561                     InclusiveNamespaces.ExclusiveCanonicalizationNamespace,
562                     InclusiveNamespaces._TAG_EC_INCLUSIVENAMESPACES) == 1) {
563 
564                 // there is one InclusiveNamespaces element
565                 InclusiveNamespaces in =
566                     new InclusiveNamespaces(
567                         XMLUtils.selectNode(
568                             c14nTransform.getElement().getFirstChild(),
569                             InclusiveNamespaces.ExclusiveCanonicalizationNamespace,
570                             InclusiveNamespaces._TAG_EC_INCLUSIVENAMESPACES,
571                             0
572                         ), this.getBaseURI());
573 
574                 inclusiveNamespaces =
575                     InclusiveNamespaces.prefixStr2Set(in.getInclusiveNamespaces());
576             }
577 
578             return nodes.getHTMLRepresentation(inclusiveNamespaces);
579         } catch (TransformationException ex) {
580             throw new XMLSignatureException(ex);
581         } catch (InvalidTransformException ex) {
582             throw new XMLSignatureException(ex);
583         } catch (XMLSecurityException ex) {
584             throw new XMLSignatureException(ex);
585         }
586     }
587 
588     /**
589      * This method only works after a call to verify.
590      * @return the transformed output(i.e. what is going to be digested).
591      */
592     public XMLSignatureInput getTransformsOutput() {
593         return this.transformsOutput;
594     }
595 
596     /**
597      * Get the ReferenceData that corresponds to the cached representation of the dereferenced
598      * object before transformation.
599      */
600     public ReferenceData getReferenceData() {
601         return referenceData;
602     }
603 
604     /**
605      * This method returns the {@link XMLSignatureInput} which is referenced by the
606      * {@code URI} Attribute.
607      * @param os where to write the transformation can be null.
608      * @return the element to digest
609      *
610      * @throws XMLSignatureException
611      * @see Manifest#verifyReferences()
612      */
613     protected XMLSignatureInput dereferenceURIandPerformTransforms(OutputStream os)
614         throws XMLSignatureException {
615         try {
616             XMLSignatureInput input = this.getContentsBeforeTransformation();
617             cacheDereferencedElement(input);
618 
619             XMLSignatureInput output = this.getContentsAfterTransformation(input, os);
620             this.transformsOutput = output;
621             return output;
622         } catch (XMLSecurityException ex) {
623             throw new ReferenceNotInitializedException(ex);
624         }
625     }
626 
627     /**
628      * Store the dereferenced Element(s) so that it/they can be retrieved later.
629      */
630     private void cacheDereferencedElement(XMLSignatureInput input) {
631         if (input.isNodeSet()) {
632             try {
633                 final Set&lt;Node&gt; s = input.getNodeSet();
634                 referenceData = new ReferenceNodeSetData() {
635                     public Iterator&lt;Node&gt; iterator() {
636                         return new Iterator&lt;Node&gt;() {
637 
638                             Iterator&lt;Node&gt; sIterator = s.iterator();
639 
640                             @Override
641                             public boolean hasNext() {
642                                 return sIterator.hasNext();
643                             }
644 
645                             @Override
646                             public Node next() {
647                                 return sIterator.next();
648                             }
649 
650                             @Override
651                             public void remove() {
652                                 throw new UnsupportedOperationException();
653                             }
654                         };
655                     }
656                 };
657             } catch (Exception e) {
658                 // LOG a warning
659                 LOG.warn(&quot;cannot cache dereferenced data: &quot; + e);
660             }
661         } else if (input.isElement()) {
662             referenceData = new ReferenceSubTreeData
663                 (input.getSubNode(), input.isExcludeComments());
664         } else if (input.isOctetStream() || input.isByteArray()) {
665             try {
666                 referenceData = new ReferenceOctetStreamData
667                     (input.getOctetStream(), input.getSourceURI(),
668                         input.getMIMEType());
669             } catch (IOException ioe) {
670                 // LOG a warning
671                 LOG.warn(&quot;cannot cache dereferenced data: &quot; + ioe);
672             }
673         }
674     }
675 
676     /**
677      * Method getTransforms
678      *
679      * @return The transforms that applied this reference.
680      * @throws InvalidTransformException
681      * @throws TransformationException
682      * @throws XMLSecurityException
683      * @throws XMLSignatureException
684      */
685     public Transforms getTransforms()
686         throws XMLSignatureException, InvalidTransformException,
687         TransformationException, XMLSecurityException {
688         return transforms;
689     }
690 
691     /**
692      * Method getReferencedBytes
693      *
694      * @return the bytes that will be used to generated digest.
695      * @throws ReferenceNotInitializedException
696      * @throws XMLSignatureException
697      */
698     public byte[] getReferencedBytes()
699         throws ReferenceNotInitializedException, XMLSignatureException {
700         try {
701             XMLSignatureInput output = this.dereferenceURIandPerformTransforms(null);
702             return output.getBytes();
703         } catch (IOException ex) {
704             throw new ReferenceNotInitializedException(ex);
705         } catch (CanonicalizationException ex) {
706             throw new ReferenceNotInitializedException(ex);
707         }
708     }
709 
710 
711     /**
712      * Method calculateDigest
713      *
714      * @param validating true if validating the reference
715      * @return reference Calculate the digest of this reference.
716      * @throws ReferenceNotInitializedException
717      * @throws XMLSignatureException
718      */
719     private byte[] calculateDigest(boolean validating)
720         throws ReferenceNotInitializedException, XMLSignatureException {
721         XMLSignatureInput input = this.getContentsBeforeTransformation();
722         if (input.isPreCalculatedDigest()) {
723             return getPreCalculatedDigest(input);
724         }
725 
<a name="3" id="anc3"></a>

726         MessageDigestAlgorithm mda = this.getMessageDigestAlgorithm();
727         mda.reset();
728 
729         try (DigesterOutputStream diOs = new DigesterOutputStream(mda);
730             OutputStream os = new UnsyncBufferedOutputStream(diOs)) {
<a name="4" id="anc4"></a><span class="line-modified">731             XMLSignatureInput output = this.dereferenceURIandPerformTransforms(os);</span>



732             // if signing and c14n11 property == true explicitly add
733             // C14N11 transform if needed
734             if (Reference.useC14N11 &amp;&amp; !validating &amp;&amp; !output.isOutputStreamSet()
735                 &amp;&amp; !output.isOctetStream()) {
736                 if (transforms == null) {
737                     transforms = new Transforms(getDocument());
738                     transforms.setSecureValidation(secureValidation);
739                     getElement().insertBefore(transforms.getElement(), digestMethodElem);
740                 }
741                 transforms.addTransform(Transforms.TRANSFORM_C14N11_OMIT_COMMENTS);
742                 output.updateOutputStream(os, true);
743             } else {
744                 output.updateOutputStream(os);
745             }
746             os.flush();
747 
748             if (output.getOctetStreamReal() != null) {
749                 output.getOctetStreamReal().close();
750             }
751 
752             //this.getReferencedBytes(diOs);
753             //mda.update(data);
754 
755             return diOs.getDigestValue();
756         } catch (XMLSecurityException ex) {
757             throw new ReferenceNotInitializedException(ex);
758         } catch (IOException ex) {
759             throw new ReferenceNotInitializedException(ex);
760         }
761     }
762 
763     /**
764      * Get the pre-calculated digest value from the XMLSignatureInput.
765      *
766      * @param input XMLSignature
767      * @return a pre-calculated digest value.
768      * @throws ReferenceNotInitializedException if there is an error decoding digest value
769      * in Base64. Properly encoded pre-calculated digest value must be set.
770      */
771     private byte[] getPreCalculatedDigest(XMLSignatureInput input)
772             throws ReferenceNotInitializedException {
773         LOG.debug(&quot;Verifying element with pre-calculated digest&quot;);
774         String preCalculatedDigest = input.getPreCalculatedDigest();
<a name="5" id="anc5"></a><span class="line-modified">775         return Base64.getMimeDecoder().decode(preCalculatedDigest);</span>
776     }
777 
778     /**
779      * Returns the digest value.
780      *
781      * @return the digest value.
782      * @throws XMLSecurityException if the Reference does not contain a DigestValue element
783      */
784     public byte[] getDigestValue() throws XMLSecurityException {
785         if (digestValueElement == null) {
786             // The required element is not in the XML!
787             Object[] exArgs ={ Constants._TAG_DIGESTVALUE, Constants.SignatureSpecNS };
788             throw new XMLSecurityException(
789                 &quot;signature.Verification.NoSignatureElement&quot;, exArgs
790             );
791         }
<a name="6" id="anc6"></a><span class="line-modified">792         String content = XMLUtils.getFullTextChildrenFromElement(digestValueElement);</span>
<span class="line-modified">793         return Base64.getMimeDecoder().decode(content);</span>
794     }
795 
796 
797     /**
798      * Tests reference validation is success or false
799      *
800      * @return true if reference validation is success, otherwise false
801      * @throws ReferenceNotInitializedException
802      * @throws XMLSecurityException
803      */
804     public boolean verify()
805         throws ReferenceNotInitializedException, XMLSecurityException {
806         byte[] elemDig = this.getDigestValue();
807         byte[] calcDig = this.calculateDigest(true);
808         boolean equal = MessageDigestAlgorithm.isEqual(elemDig, calcDig);
809 
810         if (!equal) {
811             LOG.warn(&quot;Verification failed for URI \&quot;&quot; + this.getURI() + &quot;\&quot;&quot;);
<a name="7" id="anc7"></a><span class="line-modified">812             LOG.warn(&quot;Expected Digest: &quot; + Base64.getMimeEncoder().encodeToString(elemDig));</span>
<span class="line-modified">813             LOG.warn(&quot;Actual Digest: &quot; + Base64.getMimeEncoder().encodeToString(calcDig));</span>
814         } else {
815             LOG.debug(&quot;Verification successful for URI \&quot;{}\&quot;&quot;, this.getURI());
816         }
817 
818         return equal;
819     }
820 
821     /**
822      * Method getBaseLocalName
823      * {@inheritDoc}
824      */
825     public String getBaseLocalName() {
826         return Constants._TAG_REFERENCE;
827     }
828 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
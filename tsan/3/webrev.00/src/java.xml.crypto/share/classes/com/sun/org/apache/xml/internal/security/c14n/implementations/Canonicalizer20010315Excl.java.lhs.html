<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml.crypto/share/classes/com/sun/org/apache/xml/internal/security/c14n/implementations/Canonicalizer20010315Excl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 package com.sun.org.apache.xml.internal.security.c14n.implementations;
 24 
 25 import java.io.IOException;
 26 import java.io.OutputStream;
 27 import java.util.Map;
 28 import java.util.Set;
 29 import java.util.SortedSet;
 30 import java.util.TreeSet;
 31 import javax.xml.parsers.ParserConfigurationException;
 32 
 33 import com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException;
 34 import com.sun.org.apache.xml.internal.security.c14n.helper.C14nHelper;
 35 import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
 36 import com.sun.org.apache.xml.internal.security.transforms.params.InclusiveNamespaces;
 37 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 38 import org.w3c.dom.Attr;
 39 import org.w3c.dom.DOMException;
 40 import org.w3c.dom.Document;
 41 import org.w3c.dom.Element;
 42 import org.w3c.dom.NamedNodeMap;
 43 import org.w3c.dom.Node;
 44 import org.xml.sax.SAXException;
 45 
 46 /**
 47  * Implements &amp;quot; &lt;A
 48  * HREF=&quot;http://www.w3.org/TR/2002/REC-xml-exc-c14n-20020718/&quot;&gt;Exclusive XML
 49  * Canonicalization, Version 1.0 &lt;/A&gt;&amp;quot; &lt;p&gt;&lt;/p&gt;
 50  * Credits: During restructuring of the Canonicalizer framework, Ren??
 51  * Kollmorgen from Software AG submitted an implementation of ExclC14n which
 52  * fitted into the old architecture and which based heavily on my old (and slow)
 53  * implementation of &quot;Canonical XML&quot;. A big &quot;thank you&quot; to Ren?? for this.
 54  * &lt;p&gt;&lt;/p&gt;
 55  * &lt;i&gt;THIS &lt;/i&gt; implementation is a complete rewrite of the algorithm.
 56  *
 57  * @see &lt;a href=&quot;http://www.w3.org/TR/2002/REC-xml-exc-c14n-20020718/&quot;&gt;
 58  *          Exclusive XML Canonicalization, Version 1.0&lt;/a&gt;
 59  */
 60 public abstract class Canonicalizer20010315Excl extends CanonicalizerBase {
 61 
 62     /**
 63      * This Set contains the names (Strings like &quot;xmlns&quot; or &quot;xmlns:foo&quot;) of
 64      * the inclusive namespaces.
 65      */
 66     private SortedSet&lt;String&gt; inclusiveNSSet;
 67     private boolean propagateDefaultNamespace = false;
 68 
 69     /**
 70      * Constructor Canonicalizer20010315Excl
 71      *
 72      * @param includeComments
 73      */
 74     public Canonicalizer20010315Excl(boolean includeComments) {
 75         super(includeComments);
 76     }
 77 
 78     /**
 79      * Method engineCanonicalizeSubTree
 80      * {@inheritDoc}
 81      * @param rootNode
 82      *
 83      * @throws CanonicalizationException
 84      */
 85     public byte[] engineCanonicalizeSubTree(Node rootNode)
 86         throws CanonicalizationException {
 87         return engineCanonicalizeSubTree(rootNode, &quot;&quot;, null);
 88     }
 89 
 90     /**
 91      * Method engineCanonicalizeSubTree
 92      *  {@inheritDoc}
 93      * @param rootNode
 94      * @param inclusiveNamespaces
 95      *
 96      * @throws CanonicalizationException
 97      */
 98     public byte[] engineCanonicalizeSubTree(
 99         Node rootNode, String inclusiveNamespaces
100     ) throws CanonicalizationException {
101         return engineCanonicalizeSubTree(rootNode, inclusiveNamespaces, null);
102     }
103 
104     /**
105      * Method engineCanonicalizeSubTree
106      *  {@inheritDoc}
107      * @param rootNode
108      * @param inclusiveNamespaces
109      * @param propagateDefaultNamespace If true the default namespace will be propagated to the c14n-ized root element
110      *
111      * @throws CanonicalizationException
112      */
113     public byte[] engineCanonicalizeSubTree(
114             Node rootNode, String inclusiveNamespaces, boolean propagateDefaultNamespace
115     ) throws CanonicalizationException {
116         this.propagateDefaultNamespace = propagateDefaultNamespace;
117         return engineCanonicalizeSubTree(rootNode, inclusiveNamespaces, null);
118     }
119 
120     /**
121      * Method engineCanonicalizeSubTree
122      * @param rootNode
123      * @param inclusiveNamespaces
124      * @param excl A element to exclude from the c14n process.
125      * @return the rootNode c14n.
126      * @throws CanonicalizationException
127      */
128     public byte[] engineCanonicalizeSubTree(
129         Node rootNode, String inclusiveNamespaces, Node excl
130     ) throws CanonicalizationException{
131         inclusiveNSSet = InclusiveNamespaces.prefixStr2Set(inclusiveNamespaces);
132         return super.engineCanonicalizeSubTree(rootNode, excl);
133     }
134 
135     /**
136      *
137      * @param rootNode
138      * @param inclusiveNamespaces
139      * @return the rootNode c14n.
140      * @throws CanonicalizationException
141      */
142     public byte[] engineCanonicalize(
143         XMLSignatureInput rootNode, String inclusiveNamespaces
144     ) throws CanonicalizationException {
145         inclusiveNSSet = InclusiveNamespaces.prefixStr2Set(inclusiveNamespaces);
146         return super.engineCanonicalize(rootNode);
147     }
148 
149     /**
150      * Method engineCanonicalizeXPathNodeSet
151      * {@inheritDoc}
152      * @param xpathNodeSet
153      * @param inclusiveNamespaces
154      * @throws CanonicalizationException
155      */
156     public byte[] engineCanonicalizeXPathNodeSet(
157         Set&lt;Node&gt; xpathNodeSet, String inclusiveNamespaces
158     ) throws CanonicalizationException {
159         inclusiveNSSet = InclusiveNamespaces.prefixStr2Set(inclusiveNamespaces);
160         return super.engineCanonicalizeXPathNodeSet(xpathNodeSet);
161     }
162 
163     @Override
164     protected void outputAttributesSubtree(Element element, NameSpaceSymbTable ns,
165                                            Map&lt;String, byte[]&gt; cache)
166         throws CanonicalizationException, DOMException, IOException {
167         // result will contain the attrs which have to be output
168         SortedSet&lt;Attr&gt; result = new TreeSet&lt;Attr&gt;(COMPARE);
169 
170         // The prefix visibly utilized (in the attribute or in the name) in
171         // the element
172         SortedSet&lt;String&gt; visiblyUtilized = new TreeSet&lt;String&gt;();
173         if (inclusiveNSSet != null &amp;&amp; !inclusiveNSSet.isEmpty()) {
174             visiblyUtilized.addAll(inclusiveNSSet);
175         }
176 
177         if (element.hasAttributes()) {
178             NamedNodeMap attrs = element.getAttributes();
179             int attrsLength = attrs.getLength();
180             for (int i = 0; i &lt; attrsLength; i++) {
181                 Attr attribute = (Attr) attrs.item(i);
182                 String NName = attribute.getLocalName();
183                 String NNodeValue = attribute.getNodeValue();
184 
185                 if (!XMLNS_URI.equals(attribute.getNamespaceURI())) {
186                     // Not a namespace definition.
187                     // The Element is output element, add the prefix (if used) to
188                     // visiblyUtilized
189                     String prefix = attribute.getPrefix();
190                     if (prefix != null &amp;&amp; !(prefix.equals(XML) || prefix.equals(XMLNS))) {
191                         visiblyUtilized.add(prefix);
192                     }
193                     // Add to the result.
194                     result.add(attribute);
195                 } else if (!(XML.equals(NName) &amp;&amp; XML_LANG_URI.equals(NNodeValue))
196                     &amp;&amp; ns.addMapping(NName, NNodeValue, attribute)
197                     &amp;&amp; C14nHelper.namespaceIsRelative(NNodeValue)) {
198                     // The default mapping for xml must not be output.
199                     // New definition check if it is relative.
200                     Object exArgs[] = {element.getTagName(), NName, attribute.getNodeValue()};
201                     throw new CanonicalizationException(
202                         &quot;c14n.Canonicalizer.RelativeNamespace&quot;, exArgs
203                     );
204                 }
205             }
206         }
207         if (propagateDefaultNamespace &amp;&amp; ns.getLevel() == 1 &amp;&amp;
208                 inclusiveNSSet.contains(XMLNS) &amp;&amp;
209                 ns.getMappingWithoutRendered(XMLNS) == null) {
210                 ns.removeMapping(XMLNS);
211                 ns.addMapping(
212                     XMLNS, &quot;&quot;, getNullNode(element.getOwnerDocument()));
213         }
214         String prefix = null;
215         if (element.getNamespaceURI() != null
216             &amp;&amp; !(element.getPrefix() == null || element.getPrefix().length() == 0)) {
217             prefix = element.getPrefix();
218         } else {
219             prefix = XMLNS;
220         }
221         visiblyUtilized.add(prefix);
222 
223         for (String s : visiblyUtilized) {
224             Attr key = ns.getMapping(s);
225             if (key != null) {
226                 result.add(key);
227             }
228         }
229 
230         OutputStream writer = getWriter();
231         //we output all Attrs which are available
232         for (Attr attr : result) {
233             outputAttrToWriter(attr.getNodeName(), attr.getNodeValue(), writer, cache);
234         }
235     }
236 
237     /**
238      * {@inheritDoc}
239      */
240     @Override
241     protected void outputAttributes(Element element, NameSpaceSymbTable ns,
242                                     Map&lt;String, byte[]&gt; cache)
243         throws CanonicalizationException, DOMException, IOException {
244         // result will contain the attrs which have to be output
245         SortedSet&lt;Attr&gt; result = new TreeSet&lt;Attr&gt;(COMPARE);
246 
247         // The prefix visibly utilized (in the attribute or in the name) in
248         // the element
249         Set&lt;String&gt; visiblyUtilized = null;
250         // It&#39;s the output selected.
251         boolean isOutputElement = isVisibleDO(element, ns.getLevel()) == 1;
252         if (isOutputElement) {
253             visiblyUtilized = new TreeSet&lt;String&gt;();
254             if (inclusiveNSSet != null &amp;&amp; !inclusiveNSSet.isEmpty()) {
255                 visiblyUtilized.addAll(inclusiveNSSet);
256             }
257         }
258 
259         if (element.hasAttributes()) {
260             NamedNodeMap attrs = element.getAttributes();
261             int attrsLength = attrs.getLength();
262             for (int i = 0; i &lt; attrsLength; i++) {
263                 Attr attribute = (Attr) attrs.item(i);
264 
265                 String NName = attribute.getLocalName();
266                 String NNodeValue = attribute.getNodeValue();
267 
268                 if (!XMLNS_URI.equals(attribute.getNamespaceURI())) {
269                     if (isVisible(attribute) &amp;&amp; isOutputElement) {
270                         // The Element is output element, add the prefix (if used)
271                         // to visibyUtilized
272                         String prefix = attribute.getPrefix();
273                         if (prefix != null &amp;&amp; !(prefix.equals(XML) || prefix.equals(XMLNS))) {
274                             visiblyUtilized.add(prefix);
275                         }
276                         // Add to the result.
277                         result.add(attribute);
278                     }
279                 } else if (isOutputElement &amp;&amp; !isVisible(attribute) &amp;&amp; !XMLNS.equals(NName)) {
280                     ns.removeMappingIfNotRender(NName);
281                 } else {
282                     if (!isOutputElement &amp;&amp; isVisible(attribute)
283                         &amp;&amp; inclusiveNSSet.contains(NName)
284                         &amp;&amp; !ns.removeMappingIfRender(NName)) {
285                         Node n = ns.addMappingAndRender(NName, NNodeValue, attribute);
286                         if (n != null) {
287                             result.add((Attr)n);
288                             if (C14nHelper.namespaceIsRelative(attribute)) {
289                                 Object exArgs[] = { element.getTagName(), NName, attribute.getNodeValue() };
290                                 throw new CanonicalizationException(
291                                     &quot;c14n.Canonicalizer.RelativeNamespace&quot;, exArgs
292                                 );
293                             }
294                         }
295                     }
296 
297                     if (ns.addMapping(NName, NNodeValue, attribute)
298                         &amp;&amp; C14nHelper.namespaceIsRelative(NNodeValue)) {
299                         // New definition check if it is relative
300                         Object exArgs[] = { element.getTagName(), NName, attribute.getNodeValue() };
301                         throw new CanonicalizationException(
302                             &quot;c14n.Canonicalizer.RelativeNamespace&quot;, exArgs
303                         );
304                     }
305                 }
306             }
307         }
308 
309         if (isOutputElement) {
310             // The element is visible, handle the xmlns definition
311             Attr xmlns = element.getAttributeNodeNS(XMLNS_URI, XMLNS);
312             if (xmlns != null &amp;&amp; !isVisible(xmlns)) {
313                 // There is a definition but the xmlns is not selected by the
314                 // xpath. then xmlns=&quot;&quot;
315                 ns.addMapping(XMLNS, &quot;&quot;, getNullNode(xmlns.getOwnerDocument()));
316             }
317 
318             String prefix = null;
319             if (element.getNamespaceURI() != null
320                 &amp;&amp; !(element.getPrefix() == null || element.getPrefix().length() == 0)) {
321                 prefix = element.getPrefix();
322             } else {
323                 prefix = XMLNS;
324             }
325             visiblyUtilized.add(prefix);
326 
327             for (String s : visiblyUtilized) {
328                 Attr key = ns.getMapping(s);
329                 if (key != null) {
330                     result.add(key);
331                 }
332             }
333         }
334 
335         OutputStream writer = getWriter();
336         //we output all Attrs which are available
337         for (Attr attr : result) {
338             outputAttrToWriter(attr.getNodeName(), attr.getNodeValue(), writer, cache);
339         }
340     }
341 
342     protected void circumventBugIfNeeded(XMLSignatureInput input)
343         throws CanonicalizationException, ParserConfigurationException,
344                IOException, SAXException {
<a name="1" id="anc1"></a><span class="line-modified">345         if (!input.isNeedsToBeExpanded() || inclusiveNSSet.isEmpty() || inclusiveNSSet.isEmpty()) {</span>
346             return;
347         }
348         Document doc = null;
349         if (input.getSubNode() != null) {
350             doc = XMLUtils.getOwnerDocument(input.getSubNode());
351         } else {
352             doc = XMLUtils.getOwnerDocument(input.getNodeSet());
353         }
354         XMLUtils.circumventBug2650(doc);
355     }
356 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
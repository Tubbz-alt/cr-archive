<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml.crypto/share/classes/org/jcp/xml/dsig/internal/dom/DOMRetrievalMethod.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 /*
 24  * Portions copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
 25  */
 26 /*
 27  * ===========================================================================
 28  *
 29  * (C) Copyright IBM Corp. 2003 All Rights Reserved.
 30  *
 31  * ===========================================================================
 32  */
 33 /*
 34  * $Id: DOMRetrievalMethod.java 1788465 2017-03-24 15:10:51Z coheigea $
 35  */
 36 package org.jcp.xml.dsig.internal.dom;
 37 
 38 import java.io.ByteArrayInputStream;
 39 import java.io.InputStream;
 40 import java.net.URI;
 41 import java.net.URISyntaxException;
 42 import java.security.Provider;
 43 import java.util.ArrayList;
 44 import java.util.Collections;
 45 import java.util.Iterator;
 46 import java.util.List;
 47 
 48 import javax.xml.crypto.Data;
 49 import javax.xml.crypto.MarshalException;
 50 import javax.xml.crypto.NodeSetData;
 51 import javax.xml.crypto.URIDereferencer;
 52 import javax.xml.crypto.URIReferenceException;
 53 import javax.xml.crypto.XMLCryptoContext;
 54 import javax.xml.crypto.XMLStructure;
 55 import javax.xml.crypto.dom.DOMCryptoContext;
 56 import javax.xml.crypto.dom.DOMURIReference;
 57 import javax.xml.crypto.dsig.Transform;
 58 import javax.xml.crypto.dsig.XMLSignature;
 59 import javax.xml.crypto.dsig.keyinfo.RetrievalMethod;
 60 import javax.xml.parsers.DocumentBuilder;
 61 
 62 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 63 import org.w3c.dom.Attr;
 64 import org.w3c.dom.Document;
 65 import org.w3c.dom.Element;
 66 import org.w3c.dom.Node;
 67 
 68 /**
 69  * DOM-based implementation of RetrievalMethod.
 70  *
 71  */
 72 public final class DOMRetrievalMethod extends DOMStructure
 73     implements RetrievalMethod, DOMURIReference {
 74 
 75     private final List&lt;Transform&gt; transforms;
 76     private String uri;
 77     private String type;
 78     private Attr here;
 79 
 80     /**
 81      * Creates a {@code DOMRetrievalMethod} containing the specified
 82      * URIReference and List of Transforms.
 83      *
 84      * @param uri the URI
 85      * @param type the type
 86      * @param transforms a list of {@link Transform}s. The list is defensively
 87      *    copied to prevent subsequent modification. May be {@code null}
 88      *    or empty.
 89      * @throws IllegalArgumentException if the format of {@code uri} is
 90      *    invalid, as specified by Reference&#39;s URI attribute in the W3C
 91      *    specification for XML-Signature Syntax and Processing
 92      * @throws NullPointerException if {@code uriReference}
 93      *    is {@code null}
 94      * @throws ClassCastException if {@code transforms} contains any
 95      *    entries that are not of type {@link Transform}
 96      */
 97     public DOMRetrievalMethod(String uri, String type,
 98                               List&lt;? extends Transform&gt; transforms)
 99     {
100         if (uri == null) {
101             throw new NullPointerException(&quot;uri cannot be null&quot;);
102         }
103         if (transforms == null || transforms.isEmpty()) {
104             this.transforms = Collections.emptyList();
105         } else {
106             this.transforms = Collections.unmodifiableList(
107                 new ArrayList&lt;&gt;(transforms));
108             for (int i = 0, size = this.transforms.size(); i &lt; size; i++) {
109                 if (!(this.transforms.get(i) instanceof Transform)) {
110                     throw new ClassCastException
111                         (&quot;transforms[&quot;+i+&quot;] is not a valid type&quot;);
112                 }
113             }
114         }
115         this.uri = uri;
116         if (!uri.equals(&quot;&quot;)) {
117             try {
118                 new URI(uri);
119             } catch (URISyntaxException e) {
120                 throw new IllegalArgumentException(e.getMessage());
121             }
122         }
123 
124         this.type = type;
125     }
126 
127     /**
128      * Creates a {@code DOMRetrievalMethod} from an element.
129      *
130      * @param rmElem a RetrievalMethod element
131      */
132     public DOMRetrievalMethod(Element rmElem, XMLCryptoContext context,
133                               Provider provider)
134         throws MarshalException
135     {
136         // get URI and Type attributes
137         uri = DOMUtils.getAttributeValue(rmElem, &quot;URI&quot;);
138         type = DOMUtils.getAttributeValue(rmElem, &quot;Type&quot;);
139 
140         // get here node
141         here = rmElem.getAttributeNodeNS(null, &quot;URI&quot;);
142 
143         boolean secVal = Utils.secureValidation(context);
144 
145         // get Transforms, if specified
146         List&lt;Transform&gt; newTransforms = new ArrayList&lt;&gt;();
147         Element transformsElem = DOMUtils.getFirstChildElement(rmElem);
148 
149         if (transformsElem != null) {
150             String localName = transformsElem.getLocalName();
151             String namespace = transformsElem.getNamespaceURI();
152             if (!&quot;Transforms&quot;.equals(localName) || !XMLSignature.XMLNS.equals(namespace)) {
153                 throw new MarshalException(&quot;Invalid element name: &quot; +
154                                            namespace + &quot;:&quot; + localName + &quot;, expected Transforms&quot;);
155             }
156             Element transformElem =
157                 DOMUtils.getFirstChildElement(transformsElem, &quot;Transform&quot;, XMLSignature.XMLNS);
158             while (transformElem != null) {
159                 String name = transformElem.getLocalName();
160                 namespace = transformElem.getNamespaceURI();
161                 if (!&quot;Transform&quot;.equals(name) || !XMLSignature.XMLNS.equals(namespace)) {
162                     throw new MarshalException(&quot;Invalid element name: &quot; +
163                                                name + &quot;, expected Transform&quot;);
164                 }
165                 newTransforms.add
166                     (new DOMTransform(transformElem, context, provider));
167                 if (secVal &amp;&amp; Policy.restrictNumTransforms(newTransforms.size())) {
168                     String error = &quot;A maximum of &quot; + Policy.maxTransforms()
169                         + &quot; transforms per Reference are allowed when&quot;
170                         + &quot; secure validation is enabled&quot;;
171                     throw new MarshalException(error);
172                 }
173                 transformElem = DOMUtils.getNextSiblingElement(transformElem);
174             }
175         }
176         if (newTransforms.isEmpty()) {
177             this.transforms = Collections.emptyList();
178         } else {
179             this.transforms = Collections.unmodifiableList(newTransforms);
180         }
181     }
182 
183     public String getURI() {
184         return uri;
185     }
186 
187     public String getType() {
188         return type;
189     }
190 
191     public List&lt;Transform&gt; getTransforms() {
192         return transforms;
193     }
194 
195     @Override
196     public void marshal(Node parent, String dsPrefix, DOMCryptoContext context)
197         throws MarshalException
198     {
199         Document ownerDoc = DOMUtils.getOwnerDocument(parent);
200         Element rmElem = DOMUtils.createElement(ownerDoc, &quot;RetrievalMethod&quot;,
201                                                 XMLSignature.XMLNS, dsPrefix);
202 
203         // add URI and Type attributes
204         DOMUtils.setAttribute(rmElem, &quot;URI&quot;, uri);
205         DOMUtils.setAttribute(rmElem, &quot;Type&quot;, type);
206 
207         // add Transforms elements
208         if (!transforms.isEmpty()) {
209             Element transformsElem = DOMUtils.createElement(ownerDoc,
210                                                             &quot;Transforms&quot;,
211                                                             XMLSignature.XMLNS,
212                                                             dsPrefix);
213             rmElem.appendChild(transformsElem);
214             for (Transform transform : transforms) {
215                 ((DOMTransform)transform).marshal(transformsElem,
216                                                    dsPrefix, context);
217             }
218         }
219 
220         parent.appendChild(rmElem);
221 
222         // save here node
223         here = rmElem.getAttributeNodeNS(null, &quot;URI&quot;);
224     }
225 
226     public Node getHere() {
227         return here;
228     }
229 
230     public Data dereference(XMLCryptoContext context)
231         throws URIReferenceException
232     {
233         if (context == null) {
234             throw new NullPointerException(&quot;context cannot be null&quot;);
235         }
236 
237         /*
238          * If URIDereferencer is specified in context; use it, otherwise use
239          * built-in.
240          */
241         URIDereferencer deref = context.getURIDereferencer();
242         if (deref == null) {
243             deref = DOMURIDereferencer.INSTANCE;
244         }
245 
246         Data data = deref.dereference(this, context);
247 
248         // pass dereferenced data through Transforms
249         try {
250             for (Transform transform : transforms) {
251                 data = ((DOMTransform)transform).transform(data, context);
252             }
253         } catch (Exception e) {
254             throw new URIReferenceException(e);
255         }
256 
257         // guard against RetrievalMethod loops
258         if (data instanceof NodeSetData &amp;&amp; Utils.secureValidation(context)
259                 &amp;&amp; Policy.restrictRetrievalMethodLoops()) {
260             NodeSetData&lt;?&gt; nsd = (NodeSetData&lt;?&gt;)data;
261             Iterator&lt;?&gt; i = nsd.iterator();
262             if (i.hasNext()) {
263                 Node root = (Node)i.next();
264                 if (&quot;RetrievalMethod&quot;.equals(root.getLocalName())) {
265                     throw new URIReferenceException(
266                         &quot;It is forbidden to have one RetrievalMethod point &quot; +
267                         &quot;to another when secure validation is enabled&quot;);
268                 }
269             }
270         }
271 
272         return data;
273     }
274 
275     public XMLStructure dereferenceAsXMLStructure(XMLCryptoContext context)
276         throws URIReferenceException
277     {
278         DocumentBuilder db = null;
279         boolean secVal = Utils.secureValidation(context);
280         ApacheData data = (ApacheData)dereference(context);
281         try (InputStream is = new ByteArrayInputStream(data.getXMLSignatureInput().getBytes())) {
282             db = XMLUtils.createDocumentBuilder(false, secVal);
283             Document doc = db.parse(is);
284             Element kiElem = doc.getDocumentElement();
285             if (kiElem.getLocalName().equals(&quot;X509Data&quot;)
286                 &amp;&amp; XMLSignature.XMLNS.equals(kiElem.getNamespaceURI())) {
287                 return new DOMX509Data(kiElem);
288             } else {
289                 return null; // unsupported
290             }
291         } catch (Exception e) {
292             throw new URIReferenceException(e);
293         }
294     }
295 
296     @Override
297     public boolean equals(Object obj) {
298         if (this == obj) {
299             return true;
300         }
301         if (!(obj instanceof RetrievalMethod)) {
302             return false;
303         }
304         RetrievalMethod orm = (RetrievalMethod)obj;
305 
306         boolean typesEqual = type == null ? orm.getType() == null
307                                            : type.equals(orm.getType());
308 
309         return uri.equals(orm.getURI()) &amp;&amp;
310             transforms.equals(orm.getTransforms()) &amp;&amp; typesEqual;
311     }
312 
313     @Override
314     public int hashCode() {
315         int result = 17;
316         if (type != null) {
317             result = 31 * result + type.hashCode();
318         }
319         result = 31 * result + uri.hashCode();
320         result = 31 * result + transforms.hashCode();
321 
322         return result;
323     }
324 }
    </pre>
  </body>
</html>
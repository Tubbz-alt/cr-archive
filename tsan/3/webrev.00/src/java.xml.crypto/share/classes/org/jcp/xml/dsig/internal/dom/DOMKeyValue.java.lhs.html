<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml.crypto/share/classes/org/jcp/xml/dsig/internal/dom/DOMKeyValue.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 /*
<a name="1" id="anc1"></a><span class="line-modified"> 24  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
 25  */
 26 /*
<a name="2" id="anc2"></a><span class="line-modified"> 27  * $Id: DOMKeyValue.java 1788465 2017-03-24 15:10:51Z coheigea $</span>
 28  */
 29 package org.jcp.xml.dsig.internal.dom;
 30 
<a name="3" id="anc3"></a><span class="line-removed"> 31 import javax.xml.crypto.*;</span>
<span class="line-removed"> 32 import javax.xml.crypto.dom.DOMCryptoContext;</span>
<span class="line-removed"> 33 import javax.xml.crypto.dsig.*;</span>
<span class="line-removed"> 34 import javax.xml.crypto.dsig.keyinfo.KeyValue;</span>
<span class="line-removed"> 35 </span>
 36 import java.io.IOException;
 37 import java.math.BigInteger;
 38 import java.security.KeyException;
 39 import java.security.KeyFactory;
 40 import java.security.NoSuchAlgorithmException;
 41 import java.security.PublicKey;
 42 import java.security.interfaces.DSAParams;
 43 import java.security.interfaces.DSAPublicKey;
 44 import java.security.interfaces.ECPublicKey;
 45 import java.security.interfaces.RSAPublicKey;
 46 import java.security.spec.DSAPublicKeySpec;
 47 import java.security.spec.ECField;
 48 import java.security.spec.ECFieldFp;
 49 import java.security.spec.ECParameterSpec;
 50 import java.security.spec.ECPoint;
 51 import java.security.spec.ECPublicKeySpec;
 52 import java.security.spec.EllipticCurve;
 53 import java.security.spec.InvalidKeySpecException;
 54 import java.security.spec.KeySpec;
 55 import java.security.spec.RSAPublicKeySpec;
 56 import java.util.Arrays;
 57 
<a name="4" id="anc4"></a>




 58 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 59 import org.w3c.dom.Document;
 60 import org.w3c.dom.Element;
 61 import org.w3c.dom.Node;
 62 
 63 /**
 64  * DOM-based implementation of KeyValue.
 65  *
 66  */
 67 public abstract class DOMKeyValue&lt;K extends PublicKey&gt; extends DOMStructure implements KeyValue {
 68 
 69     private static final String XMLDSIG_11_XMLNS
 70         = &quot;http://www.w3.org/2009/xmldsig11#&quot;;
 71     private final K publicKey;
 72 
 73     public DOMKeyValue(K key) throws KeyException {
 74         if (key == null) {
 75             throw new NullPointerException(&quot;key cannot be null&quot;);
 76         }
 77         this.publicKey = key;
 78     }
 79 
 80     /**
 81      * Creates a {@code DOMKeyValue} from an element.
 82      *
 83      * @param kvtElem a KeyValue child element
 84      */
 85     public DOMKeyValue(Element kvtElem) throws MarshalException {
 86         this.publicKey = unmarshalKeyValue(kvtElem);
 87     }
 88 
 89     static KeyValue unmarshal(Element kvElem) throws MarshalException {
 90         Element kvtElem = DOMUtils.getFirstChildElement(kvElem);
 91         if (kvtElem == null) {
 92             throw new MarshalException(&quot;KeyValue must contain at least one type&quot;);
 93         }
 94 
 95         String namespace = kvtElem.getNamespaceURI();
 96         if (kvtElem.getLocalName().equals(&quot;DSAKeyValue&quot;) &amp;&amp; XMLSignature.XMLNS.equals(namespace)) {
 97             return new DSA(kvtElem);
 98         } else if (kvtElem.getLocalName().equals(&quot;RSAKeyValue&quot;) &amp;&amp; XMLSignature.XMLNS.equals(namespace)) {
 99             return new RSA(kvtElem);
100         } else if (kvtElem.getLocalName().equals(&quot;ECKeyValue&quot;) &amp;&amp; XMLDSIG_11_XMLNS.equals(namespace)) {
101             return new EC(kvtElem);
102         } else {
103             return new Unknown(kvtElem);
104         }
105     }
106 
107     public PublicKey getPublicKey() throws KeyException {
108         if (publicKey == null) {
109             throw new KeyException(&quot;can&#39;t convert KeyValue to PublicKey&quot;);
110         } else {
111             return publicKey;
112         }
113     }
114 
115     @Override
116     public void marshal(Node parent, String dsPrefix, DOMCryptoContext context)
117         throws MarshalException
118     {
119         Document ownerDoc = DOMUtils.getOwnerDocument(parent);
120 
121         // create KeyValue element
122         Element kvElem = DOMUtils.createElement(ownerDoc, &quot;KeyValue&quot;,
123                                                 XMLSignature.XMLNS, dsPrefix);
124         marshalPublicKey(kvElem, ownerDoc, dsPrefix, context);
125 
126         parent.appendChild(kvElem);
127     }
128 
129     abstract void marshalPublicKey(Node parent, Document doc, String dsPrefix,
130         DOMCryptoContext context) throws MarshalException;
131 
132     abstract K unmarshalKeyValue(Element kvtElem)
133         throws MarshalException;
134 
135     private static PublicKey generatePublicKey(KeyFactory kf, KeySpec keyspec) {
136         try {
137             return kf.generatePublic(keyspec);
138         } catch (InvalidKeySpecException e) {
139             //@@@ should dump exception to LOG
140             return null;
141         }
142     }
143 
144     @Override
145     public boolean equals(Object obj) {
146         if (this == obj) {
147             return true;
148         }
149         if (!(obj instanceof KeyValue)) {
150             return false;
151         }
152         try {
153             KeyValue kv = (KeyValue)obj;
154             if (publicKey == null ) {
155                 if (kv.getPublicKey() != null) {
156                     return false;
157                 }
158             } else if (!publicKey.equals(kv.getPublicKey())) {
159                 return false;
160             }
161         } catch (KeyException ke) {
162             // no practical way to determine if the keys are equal
163             return false;
164         }
165 
166         return true;
167     }
168 
169     public static BigInteger decode(Element elem) throws MarshalException {
170         try {
171             String base64str = elem.getFirstChild().getNodeValue();
172             return new BigInteger(1, XMLUtils.decode(base64str));
173         } catch (Exception ex) {
174             throw new MarshalException(ex);
175         }
176     }
177 
178     @Override
179     public int hashCode() {
180         int result = 17;
181         if (publicKey != null) {
182             result = 31 * result + publicKey.hashCode();
183         }
184 
185         return result;
186     }
187 
188     static final class RSA extends DOMKeyValue&lt;RSAPublicKey&gt; {
189         // RSAKeyValue CryptoBinaries
190         private DOMCryptoBinary modulus, exponent;
191         private KeyFactory rsakf;
192 
193         RSA(RSAPublicKey key) throws KeyException {
194             super(key);
195             RSAPublicKey rkey = key;
196             exponent = new DOMCryptoBinary(rkey.getPublicExponent());
197             modulus = new DOMCryptoBinary(rkey.getModulus());
198         }
199 
200         RSA(Element elem) throws MarshalException {
201             super(elem);
202         }
203 
204         void marshalPublicKey(Node parent, Document doc, String dsPrefix,
205             DOMCryptoContext context) throws MarshalException {
206             Element rsaElem = DOMUtils.createElement(doc, &quot;RSAKeyValue&quot;,
207                                                      XMLSignature.XMLNS,
208                                                      dsPrefix);
209             Element modulusElem = DOMUtils.createElement(doc, &quot;Modulus&quot;,
210                                                          XMLSignature.XMLNS,
211                                                          dsPrefix);
212             Element exponentElem = DOMUtils.createElement(doc, &quot;Exponent&quot;,
213                                                           XMLSignature.XMLNS,
214                                                           dsPrefix);
215             modulus.marshal(modulusElem, dsPrefix, context);
216             exponent.marshal(exponentElem, dsPrefix, context);
217             rsaElem.appendChild(modulusElem);
218             rsaElem.appendChild(exponentElem);
219             parent.appendChild(rsaElem);
220         }
221 
222         @Override
223         RSAPublicKey unmarshalKeyValue(Element kvtElem)
224             throws MarshalException
225         {
226             if (rsakf == null) {
227                 try {
228                     rsakf = KeyFactory.getInstance(&quot;RSA&quot;);
229                 } catch (NoSuchAlgorithmException e) {
230                     throw new RuntimeException
231                         (&quot;unable to create RSA KeyFactory: &quot; + e.getMessage());
232                 }
233             }
234             Element modulusElem = DOMUtils.getFirstChildElement(kvtElem,
235                                                                 &quot;Modulus&quot;,
236                                                                 XMLSignature.XMLNS);
237             BigInteger modulus = decode(modulusElem);
238             Element exponentElem = DOMUtils.getNextSiblingElement(modulusElem,
239                                                                   &quot;Exponent&quot;,
240                                                                   XMLSignature.XMLNS);
241             BigInteger exponent = decode(exponentElem);
242             RSAPublicKeySpec spec = new RSAPublicKeySpec(modulus, exponent);
243             return (RSAPublicKey) generatePublicKey(rsakf, spec);
244         }
245     }
246 
247     static final class DSA extends DOMKeyValue&lt;DSAPublicKey&gt; {
248         // DSAKeyValue CryptoBinaries
249         private DOMCryptoBinary p, q, g, y; //, seed, pgen;
250         private KeyFactory dsakf;
251 
252         DSA(DSAPublicKey key) throws KeyException {
253             super(key);
254             DSAPublicKey dkey = key;
255             DSAParams params = dkey.getParams();
256             p = new DOMCryptoBinary(params.getP());
257             q = new DOMCryptoBinary(params.getQ());
258             g = new DOMCryptoBinary(params.getG());
259             y = new DOMCryptoBinary(dkey.getY());
260         }
261 
262         DSA(Element elem) throws MarshalException {
263             super(elem);
264         }
265 
266         @Override
267         void marshalPublicKey(Node parent, Document doc, String dsPrefix,
268                               DOMCryptoContext context)
269             throws MarshalException
270         {
271             Element dsaElem = DOMUtils.createElement(doc, &quot;DSAKeyValue&quot;,
272                                                      XMLSignature.XMLNS,
273                                                      dsPrefix);
274             // parameters J, Seed &amp; PgenCounter are not included
275             Element pElem = DOMUtils.createElement(doc, &quot;P&quot;, XMLSignature.XMLNS,
276                                                    dsPrefix);
277             Element qElem = DOMUtils.createElement(doc, &quot;Q&quot;, XMLSignature.XMLNS,
278                                                    dsPrefix);
279             Element gElem = DOMUtils.createElement(doc, &quot;G&quot;, XMLSignature.XMLNS,
280                                                    dsPrefix);
281             Element yElem = DOMUtils.createElement(doc, &quot;Y&quot;, XMLSignature.XMLNS,
282                                                    dsPrefix);
283             p.marshal(pElem, dsPrefix, context);
284             q.marshal(qElem, dsPrefix, context);
285             g.marshal(gElem, dsPrefix, context);
286             y.marshal(yElem, dsPrefix, context);
287             dsaElem.appendChild(pElem);
288             dsaElem.appendChild(qElem);
289             dsaElem.appendChild(gElem);
290             dsaElem.appendChild(yElem);
291             parent.appendChild(dsaElem);
292         }
293 
294         @Override
295         DSAPublicKey unmarshalKeyValue(Element kvtElem)
296             throws MarshalException
297         {
298             if (dsakf == null) {
299                 try {
300                     dsakf = KeyFactory.getInstance(&quot;DSA&quot;);
301                 } catch (NoSuchAlgorithmException e) {
302                     throw new RuntimeException
303                         (&quot;unable to create DSA KeyFactory: &quot; + e.getMessage());
304                 }
305             }
306             Element curElem = DOMUtils.getFirstChildElement(kvtElem);
307             if (curElem == null) {
308                 throw new MarshalException(&quot;KeyValue must contain at least one type&quot;);
309             }
310             // check for P and Q
311             BigInteger p = null;
312             BigInteger q = null;
313             if (curElem.getLocalName().equals(&quot;P&quot;) &amp;&amp; XMLSignature.XMLNS.equals(curElem.getNamespaceURI())) {
314                 p = decode(curElem);
315                 curElem = DOMUtils.getNextSiblingElement(curElem, &quot;Q&quot;, XMLSignature.XMLNS);
316                 q = decode(curElem);
317                 curElem = DOMUtils.getNextSiblingElement(curElem);
318             }
319             BigInteger g = null;
320             if (curElem != null
321                 &amp;&amp; curElem.getLocalName().equals(&quot;G&quot;) &amp;&amp; XMLSignature.XMLNS.equals(curElem.getNamespaceURI())) {
322                 g = decode(curElem);
323                 curElem = DOMUtils.getNextSiblingElement(curElem, &quot;Y&quot;, XMLSignature.XMLNS);
324             }
325             BigInteger y = null;
326             if (curElem != null) {
327                 y = decode(curElem);
328                 curElem = DOMUtils.getNextSiblingElement(curElem);
329             }
330             //if (curElem != null &amp;&amp; curElem.getLocalName().equals(&quot;J&quot;)) {
331                 //j = new DOMCryptoBinary(curElem.getFirstChild());
332                 // curElem = DOMUtils.getNextSiblingElement(curElem);
333             //}
334             //@@@ do we care about j, pgenCounter or seed?
335             DSAPublicKeySpec spec = new DSAPublicKeySpec(y, p, q, g);
336             return (DSAPublicKey) generatePublicKey(dsakf, spec);
337         }
338     }
339 
340     static final class EC extends DOMKeyValue&lt;ECPublicKey&gt; {
341      // ECKeyValue CryptoBinaries
342         private byte[] ecPublicKey;
343         private KeyFactory eckf;
344         private ECParameterSpec ecParams;
345 
346         /* Supported curve, secp256r1 */
347         private static final Curve SECP256R1 = initializeCurve(
348             &quot;secp256r1 [NIST P-256, X9.62 prime256v1]&quot;,
349             &quot;1.2.840.10045.3.1.7&quot;,
350             &quot;FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF&quot;,
351             &quot;FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC&quot;,
352             &quot;5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B&quot;,
353             &quot;6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296&quot;,
354             &quot;4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5&quot;,
355             &quot;FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551&quot;,
356             1
357         );
358 
359         /* Supported curve secp384r1 */
360         private static final Curve SECP384R1 = initializeCurve(
361             &quot;secp384r1 [NIST P-384]&quot;,
362             &quot;1.3.132.0.34&quot;,
363             &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF&quot;,
364             &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC&quot;,
365             &quot;B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF&quot;,
366             &quot;AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7&quot;,
367             &quot;3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F&quot;,
368             &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973&quot;,
369             1
370         );
371 
372         /* Supported curve secp521r1 */
373         private static final Curve SECP521R1 = initializeCurve(
374             &quot;secp521r1 [NIST P-521]&quot;,
375             &quot;1.3.132.0.35&quot;,
376             &quot;01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;,
377             &quot;01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC&quot;,
378             &quot;0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00&quot;,
379             &quot;00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66&quot;,
380             &quot;011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650&quot;,
381             &quot;01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409&quot;,
382             1
383         );
384 
385         private static Curve initializeCurve(String name, String oid,
386                 String sfield, String a, String b,
387                 String x, String y, String n, int h) {
388             BigInteger p = bigInt(sfield);
389             ECField field = new ECFieldFp(p);
390             EllipticCurve curve = new EllipticCurve(field, bigInt(a),
391                                                     bigInt(b));
392             ECPoint g = new ECPoint(bigInt(x), bigInt(y));
393             return new Curve(name, oid, curve, g, bigInt(n), h);
394         }
395 
396         EC(ECPublicKey ecKey) throws KeyException {
397             super(ecKey);
398             ECPoint ecPoint = ecKey.getW();
399             ecParams = ecKey.getParams();
400             ecPublicKey = encodePoint(ecPoint, ecParams.getCurve());
401         }
402 
403         EC(Element dmElem) throws MarshalException {
404             super(dmElem);
405         }
406 
407         private static ECPoint decodePoint(byte[] data, EllipticCurve curve)
408                 throws IOException {
409             if (data.length == 0 || data[0] != 4) {
410                 throw new IOException(&quot;Only uncompressed point format &quot; +
411                                       &quot;supported&quot;);
412             }
413             // Per ANSI X9.62, an encoded point is a 1 byte type followed by
414             // ceiling(LOG base 2 field-size / 8) bytes of x and the same of y.
415             int n = (data.length - 1) / 2;
416             if (n != (curve.getField().getFieldSize() + 7) &gt;&gt; 3) {
417                 throw new IOException(&quot;Point does not match field size&quot;);
418             }
419 
420             byte[] xb = Arrays.copyOfRange(data, 1, 1 + n);
421             byte[] yb = Arrays.copyOfRange(data, n + 1, n + 1 + n);
422 
423             return new ECPoint(new BigInteger(1, xb), new BigInteger(1, yb));
424         }
425 
426         private static byte[] encodePoint(ECPoint point, EllipticCurve curve) {
427             // get field size in bytes (rounding up)
428             int n = (curve.getField().getFieldSize() + 7) &gt;&gt; 3;
429             byte[] xb = trimZeroes(point.getAffineX().toByteArray());
430             byte[] yb = trimZeroes(point.getAffineY().toByteArray());
431             if (xb.length &gt; n || yb.length &gt; n) {
432                 throw new RuntimeException(&quot;Point coordinates do not &quot; +
433                                            &quot;match field size&quot;);
434             }
435             byte[] b = new byte[1 + (n &lt;&lt; 1)];
436             b[0] = 4; // uncompressed
437             System.arraycopy(xb, 0, b, n - xb.length + 1, xb.length);
438             System.arraycopy(yb, 0, b, b.length - yb.length, yb.length);
439             return b;
440         }
441 
442         private static byte[] trimZeroes(byte[] b) {
443             int i = 0;
444             while (i &lt; b.length - 1 &amp;&amp; b[i] == 0) {
445                 i++;
446             }
447             if (i == 0) {
448                 return b;
449             }
450             return Arrays.copyOfRange(b, i, b.length);
451         }
452 
453         private static String getCurveOid(ECParameterSpec params) {
454             // Check that the params represent one of the supported
455             // curves. If there is a match, return the object identifier
456             // of the curve.
457             Curve match;
458             if (matchCurve(params, SECP256R1)) {
459                 match = SECP256R1;
460             } else if (matchCurve(params, SECP384R1)) {
461                 match = SECP384R1;
462             } else if (matchCurve(params, SECP521R1)) {
463                 match = SECP521R1;
464             } else {
465                 return null;
466             }
467             return match.getObjectId();
468         }
469 
470         private static boolean matchCurve(ECParameterSpec params, Curve curve) {
471             int fieldSize = params.getCurve().getField().getFieldSize();
472             if (curve.getCurve().getField().getFieldSize() == fieldSize
473                 &amp;&amp; curve.getCurve().equals(params.getCurve())
474                 &amp;&amp; curve.getGenerator().equals(params.getGenerator())
475                 &amp;&amp; curve.getOrder().equals(params.getOrder())
476                 &amp;&amp; curve.getCofactor() == params.getCofactor()) {
477                 return true;
478             } else {
479                 return false;
480             }
481         }
482 
483         @Override
484         void marshalPublicKey(Node parent, Document doc, String dsPrefix,
485                               DOMCryptoContext context)
486             throws MarshalException
487         {
488             String prefix = DOMUtils.getNSPrefix(context, XMLDSIG_11_XMLNS);
489             Element ecKeyValueElem = DOMUtils.createElement(doc, &quot;ECKeyValue&quot;,
490                                                             XMLDSIG_11_XMLNS,
491                                                             prefix);
492             Element namedCurveElem = DOMUtils.createElement(doc, &quot;NamedCurve&quot;,
493                                                             XMLDSIG_11_XMLNS,
494                                                             prefix);
495             Element publicKeyElem = DOMUtils.createElement(doc, &quot;PublicKey&quot;,
496                                                            XMLDSIG_11_XMLNS,
497                                                            prefix);
498             String oid = getCurveOid(ecParams);
499             if (oid == null) {
500                 throw new MarshalException(&quot;Invalid ECParameterSpec&quot;);
501             }
502             DOMUtils.setAttribute(namedCurveElem, &quot;URI&quot;, &quot;urn:oid:&quot; + oid);
<a name="5" id="anc5"></a><span class="line-modified">503             String qname = (prefix == null || prefix.length() == 0)</span>
504                        ? &quot;xmlns&quot; : &quot;xmlns:&quot; + prefix;
505             namedCurveElem.setAttributeNS(&quot;http://www.w3.org/2000/xmlns/&quot;,
506                                           qname, XMLDSIG_11_XMLNS);
507             ecKeyValueElem.appendChild(namedCurveElem);
508             String encoded = XMLUtils.encodeToString(ecPublicKey);
509             publicKeyElem.appendChild
510                 (DOMUtils.getOwnerDocument(publicKeyElem).createTextNode(encoded));
511             ecKeyValueElem.appendChild(publicKeyElem);
512             parent.appendChild(ecKeyValueElem);
513         }
514 
515         @Override
516         ECPublicKey unmarshalKeyValue(Element kvtElem)
517             throws MarshalException
518         {
519             if (eckf == null) {
520                 try {
521                     eckf = KeyFactory.getInstance(&quot;EC&quot;);
522                 } catch (NoSuchAlgorithmException e) {
523                     throw new RuntimeException
524                         (&quot;unable to create EC KeyFactory: &quot; + e.getMessage());
525                 }
526             }
527             ECParameterSpec ecParams = null;
528             Element curElem = DOMUtils.getFirstChildElement(kvtElem);
529             if (curElem == null) {
530                 throw new MarshalException(&quot;KeyValue must contain at least one type&quot;);
531             }
532 
533             if (curElem.getLocalName().equals(&quot;ECParameters&quot;)
534                 &amp;&amp; XMLDSIG_11_XMLNS.equals(curElem.getNamespaceURI())) {
535                 throw new UnsupportedOperationException
536                     (&quot;ECParameters not supported&quot;);
537             } else if (curElem.getLocalName().equals(&quot;NamedCurve&quot;)
538                 &amp;&amp; XMLDSIG_11_XMLNS.equals(curElem.getNamespaceURI())) {
539                 String uri = DOMUtils.getAttributeValue(curElem, &quot;URI&quot;);
540                 // strip off &quot;urn:oid&quot;
541                 if (uri.startsWith(&quot;urn:oid:&quot;)) {
542                     String oid = uri.substring(&quot;urn:oid:&quot;.length());
543                     ecParams = getECParameterSpec(oid);
544                     if (ecParams == null) {
545                         throw new MarshalException(&quot;Invalid curve OID&quot;);
546                     }
547                 } else {
548                     throw new MarshalException(&quot;Invalid NamedCurve URI&quot;);
549                 }
550             } else {
551                 throw new MarshalException(&quot;Invalid ECKeyValue&quot;);
552             }
553             curElem = DOMUtils.getNextSiblingElement(curElem, &quot;PublicKey&quot;, XMLDSIG_11_XMLNS);
554             ECPoint ecPoint = null;
555 
556             try {
<a name="6" id="anc6"></a><span class="line-modified">557                 String content = XMLUtils.getFullTextChildrenFromElement(curElem);</span>
558                 ecPoint = decodePoint(XMLUtils.decode(content),
559                                       ecParams.getCurve());
560             } catch (IOException ioe) {
561                 throw new MarshalException(&quot;Invalid EC Point&quot;, ioe);
562             }
563 
564             ECPublicKeySpec spec = new ECPublicKeySpec(ecPoint, ecParams);
565             return (ECPublicKey) generatePublicKey(eckf, spec);
566         }
567 
568         private static ECParameterSpec getECParameterSpec(String oid) {
569             if (oid.equals(SECP256R1.getObjectId())) {
570                 return SECP256R1;
571             } else if (oid.equals(SECP384R1.getObjectId())) {
572                 return SECP384R1;
573             } else if (oid.equals(SECP521R1.getObjectId())) {
574                 return SECP521R1;
575             } else {
576                 return null;
577             }
578         }
579 
580         static final class Curve extends ECParameterSpec {
581             private final String name;
582             private final String oid;
583 
584             Curve(String name, String oid, EllipticCurve curve,
585                   ECPoint g, BigInteger n, int h) {
586                 super(curve, g, n, h);
587                 this.name = name;
588                 this.oid = oid;
589             }
590 
591             private String getName() {
592                 return name;
593             }
594 
595             private String getObjectId() {
596                 return oid;
597             }
598         }
599     }
600 
601     private static BigInteger bigInt(String s) {
602         return new BigInteger(s, 16);
603     }
604 
605     static final class Unknown extends DOMKeyValue&lt;PublicKey&gt; {
606         private javax.xml.crypto.dom.DOMStructure externalPublicKey;
607         Unknown(Element elem) throws MarshalException {
608             super(elem);
609         }
610 
611         @Override
612         PublicKey unmarshalKeyValue(Element kvElem) throws MarshalException {
613             externalPublicKey = new javax.xml.crypto.dom.DOMStructure(kvElem);
614             return null;
615         }
616 
617         @Override
618         void marshalPublicKey(Node parent, Document doc, String dsPrefix,
619                               DOMCryptoContext context)
620             throws MarshalException
621         {
622             parent.appendChild(externalPublicKey.getNode());
623         }
624     }
625 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
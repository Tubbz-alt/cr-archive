<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml.crypto/share/classes/org/jcp/xml/dsig/internal/dom/DOMReference.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 /*
 24  * Portions copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
 25  */
 26 /*
 27  * ===========================================================================
 28  *
 29  * (C) Copyright IBM Corp. 2003 All Rights Reserved.
 30  *
 31  * ===========================================================================
 32  */
 33 /*
 34  * $Id: DOMReference.java 1803518 2017-07-31 11:02:52Z coheigea $
 35  */
 36 package org.jcp.xml.dsig.internal.dom;
 37 
 38 import javax.xml.crypto.*;
 39 import javax.xml.crypto.dsig.*;
 40 import javax.xml.crypto.dom.DOMCryptoContext;
 41 import javax.xml.crypto.dom.DOMURIReference;
 42 
 43 import java.io.*;
 44 import java.net.URI;
 45 import java.net.URISyntaxException;
 46 import java.security.*;
 47 import java.util.*;
 48 
 49 import org.w3c.dom.Attr;
 50 import org.w3c.dom.Document;
 51 import org.w3c.dom.Element;
 52 import org.w3c.dom.Node;
 53 
 54 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 55 
 56 import org.jcp.xml.dsig.internal.DigesterOutputStream;
 57 import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
 58 import com.sun.org.apache.xml.internal.security.utils.UnsyncBufferedOutputStream;
 59 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 60 
 61 /**
 62  * DOM-based implementation of Reference.
 63  *
 64  */
 65 public final class DOMReference extends DOMStructure
 66     implements Reference, DOMURIReference {
 67 
 68    /**
 69     * The maximum number of transforms per reference, if secure validation is enabled.
 70     */
 71    public static final int MAXIMUM_TRANSFORM_COUNT = 5;
 72 
 73    /**
 74     * Look up useC14N11 system property. If true, an explicit C14N11 transform
 75     * will be added if necessary when generating the signature. See section
 76     * 3.1.1 of http://www.w3.org/2007/xmlsec/Drafts/xmldsig-core/ for more info.
 77     *
 78     * If true, overrides the same property if set in the XMLSignContext.
 79     */
 80     private static boolean useC14N11 =
 81         AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)
 82             () -&gt; Boolean.getBoolean(&quot;com.sun.org.apache.xml.internal.security.useC14N11&quot;));
 83 
 84     private static final com.sun.org.slf4j.internal.Logger LOG =
 85         com.sun.org.slf4j.internal.LoggerFactory.getLogger(DOMReference.class);
 86 
 87     private final DigestMethod digestMethod;
 88     private final String id;
 89     private final List&lt;Transform&gt; transforms;
 90     private List&lt;Transform&gt; allTransforms;
 91     private final Data appliedTransformData;
 92     private Attr here;
 93     private final String uri;
 94     private final String type;
 95     private byte[] digestValue;
 96     private byte[] calcDigestValue;
 97     private Element refElem;
 98     private boolean digested = false;
 99     private boolean validated = false;
100     private boolean validationStatus;
101     private Data derefData;
102     private InputStream dis;
103     private MessageDigest md;
104     private Provider provider;
105 
106     /**
107      * Creates a {@code Reference} from the specified parameters.
108      *
109      * @param uri the URI (may be null)
110      * @param type the type (may be null)
111      * @param dm the digest method
112      * @param transforms a list of {@link Transform}s. The list
113      *    is defensively copied to protect against subsequent modification.
114      *    May be {@code null} or empty.
115      * @param id the reference ID (may be {@code null})
116      * @throws NullPointerException if {@code dm} is {@code null}
117      * @throws ClassCastException if any of the {@code transforms} are
118      *    not of type {@code Transform}
119      */
120     public DOMReference(String uri, String type, DigestMethod dm,
121                         List&lt;? extends Transform&gt; transforms, String id,
122                         Provider provider)
123     {
124         this(uri, type, dm, null, null, transforms, id, null, provider);
125     }
126 
127     public DOMReference(String uri, String type, DigestMethod dm,
128                         List&lt;? extends Transform&gt; appliedTransforms,
129                         Data result, List&lt;? extends Transform&gt; transforms,
130                         String id, Provider provider)
131     {
132         this(uri, type, dm, appliedTransforms,
133              result, transforms, id, null, provider);
134     }
135 
136     public DOMReference(String uri, String type, DigestMethod dm,
137                         List&lt;? extends Transform&gt; appliedTransforms,
138                         Data result, List&lt;? extends Transform&gt; transforms,
139                         String id, byte[] digestValue, Provider provider)
140     {
141         if (dm == null) {
142             throw new NullPointerException(&quot;DigestMethod must be non-null&quot;);
143         }
144         if (appliedTransforms == null) {
145             this.allTransforms = new ArrayList&lt;&gt;();
146         } else {
147             this.allTransforms = new ArrayList&lt;&gt;(appliedTransforms);
148             for (int i = 0, size = this.allTransforms.size(); i &lt; size; i++) {
149                 if (!(this.allTransforms.get(i) instanceof Transform)) {
150                     throw new ClassCastException
151                         (&quot;appliedTransforms[&quot;+i+&quot;] is not a valid type&quot;);
152                 }
153             }
154         }
155         if (transforms == null) {
156             this.transforms = Collections.emptyList();
157         } else {
158             this.transforms = new ArrayList&lt;&gt;(transforms);
159             for (int i = 0, size = this.transforms.size(); i &lt; size; i++) {
160                 if (!(this.transforms.get(i) instanceof Transform)) {
161                     throw new ClassCastException
162                         (&quot;transforms[&quot;+i+&quot;] is not a valid type&quot;);
163                 }
164             }
165             this.allTransforms.addAll(this.transforms);
166         }
167         this.digestMethod = dm;
168         this.uri = uri;
169         if (uri != null &amp;&amp; !uri.equals(&quot;&quot;)) {
170             try {
171                 new URI(uri);
172             } catch (URISyntaxException e) {
173                 throw new IllegalArgumentException(e.getMessage());
174             }
175         }
176         this.type = type;
177         this.id = id;
178         if (digestValue != null) {
179             this.digestValue = digestValue.clone();
180             this.digested = true;
181         }
182         this.appliedTransformData = result;
183         this.provider = provider;
184     }
185 
186     /**
187      * Creates a {@code DOMReference} from an element.
188      *
189      * @param refElem a Reference element
190      */
191     public DOMReference(Element refElem, XMLCryptoContext context,
192                         Provider provider)
193         throws MarshalException
194     {
195         boolean secVal = Utils.secureValidation(context);
196 
197         // unmarshal Transforms, if specified
198         Element nextSibling = DOMUtils.getFirstChildElement(refElem);
199         List&lt;Transform&gt; newTransforms = new ArrayList&lt;&gt;(MAXIMUM_TRANSFORM_COUNT);
200         if (nextSibling.getLocalName().equals(&quot;Transforms&quot;)
201             &amp;&amp; XMLSignature.XMLNS.equals(nextSibling.getNamespaceURI())) {
202             Element transformElem = DOMUtils.getFirstChildElement(nextSibling,
203                                                                   &quot;Transform&quot;,
204                                                                   XMLSignature.XMLNS);
205             newTransforms.add(new DOMTransform(transformElem, context, provider));
206             transformElem = DOMUtils.getNextSiblingElement(transformElem);
207             while (transformElem != null) {
208                 String localName = transformElem.getLocalName();
209                 String namespace = transformElem.getNamespaceURI();
210                 if (!&quot;Transform&quot;.equals(localName) || !XMLSignature.XMLNS.equals(namespace)) {
211                     throw new MarshalException(
212                         &quot;Invalid element name: &quot; + localName +
213                         &quot;, expected Transform&quot;);
214                 }
215                 newTransforms.add
216                     (new DOMTransform(transformElem, context, provider));
217                 if (secVal &amp;&amp; Policy.restrictNumTransforms(newTransforms.size())) {
218                     String error = &quot;A maximum of &quot; + Policy.maxTransforms()
219                         + &quot; transforms per Reference are allowed when&quot;
220                         + &quot; secure validation is enabled&quot;;
221                     throw new MarshalException(error);
222                 }
223                 transformElem = DOMUtils.getNextSiblingElement(transformElem);
224             }
225             nextSibling = DOMUtils.getNextSiblingElement(nextSibling);
226         }
227         if (!nextSibling.getLocalName().equals(&quot;DigestMethod&quot;)
228             &amp;&amp; XMLSignature.XMLNS.equals(nextSibling.getNamespaceURI())) {
229             throw new MarshalException(&quot;Invalid element name: &quot; +
230                                        nextSibling.getLocalName() +
231                                        &quot;, expected DigestMethod&quot;);
232         }
233 
234         // unmarshal DigestMethod
235         Element dmElem = nextSibling;
236         this.digestMethod = DOMDigestMethod.unmarshal(dmElem);
237         String digestMethodAlgorithm = this.digestMethod.getAlgorithm();
238         if (secVal &amp;&amp; Policy.restrictAlg(digestMethodAlgorithm)) {
239             throw new MarshalException(
240                 &quot;It is forbidden to use algorithm &quot; + digestMethodAlgorithm +
241                 &quot; when secure validation is enabled&quot;
242             );
243         }
244 
245         // unmarshal DigestValue
246         Element dvElem = DOMUtils.getNextSiblingElement(dmElem, &quot;DigestValue&quot;, XMLSignature.XMLNS);
247         String content = XMLUtils.getFullTextChildrenFromElement(dvElem);
248         this.digestValue = XMLUtils.decode(content);
249 
250         // check for extra elements
251         if (DOMUtils.getNextSiblingElement(dvElem) != null) {
252             throw new MarshalException(
253                 &quot;Unexpected element after DigestValue element&quot;);
254         }
255 
256         // unmarshal attributes
257         this.uri = DOMUtils.getAttributeValue(refElem, &quot;URI&quot;);
258 
259         Attr attr = refElem.getAttributeNodeNS(null, &quot;Id&quot;);
260         if (attr != null) {
261             this.id = attr.getValue();
262             refElem.setIdAttributeNode(attr, true);
263         } else {
264             this.id = null;
265         }
266 
267         this.type = DOMUtils.getAttributeValue(refElem, &quot;Type&quot;);
268         this.here = refElem.getAttributeNodeNS(null, &quot;URI&quot;);
269         this.refElem = refElem;
270         this.transforms = newTransforms;
271         this.allTransforms = transforms;
272         this.appliedTransformData = null;
273         this.provider = provider;
274     }
275 
276     public DigestMethod getDigestMethod() {
277         return digestMethod;
278     }
279 
280     public String getId() {
281         return id;
282     }
283 
284     public String getURI() {
285         return uri;
286     }
287 
288     public String getType() {
289         return type;
290     }
291 
292     public List&lt;Transform&gt; getTransforms() {
293         return Collections.unmodifiableList(allTransforms);
294     }
295 
296     public byte[] getDigestValue() {
297         return digestValue == null ? null : digestValue.clone();
298     }
299 
300     public byte[] getCalculatedDigestValue() {
301         return calcDigestValue == null ? null
302                                         : calcDigestValue.clone();
303     }
304 
305     @Override
306     public void marshal(Node parent, String dsPrefix, DOMCryptoContext context)
307         throws MarshalException
308     {
309         LOG.debug(&quot;Marshalling Reference&quot;);
310         Document ownerDoc = DOMUtils.getOwnerDocument(parent);
311 
312         refElem = DOMUtils.createElement(ownerDoc, &quot;Reference&quot;,
313                                          XMLSignature.XMLNS, dsPrefix);
314         // set attributes
315         DOMUtils.setAttributeID(refElem, &quot;Id&quot;, id);
316         DOMUtils.setAttribute(refElem, &quot;URI&quot;, uri);
317         DOMUtils.setAttribute(refElem, &quot;Type&quot;, type);
318 
319         // create and append Transforms element
320         if (!allTransforms.isEmpty()) {
321             Element transformsElem = DOMUtils.createElement(ownerDoc,
322                                                             &quot;Transforms&quot;,
323                                                             XMLSignature.XMLNS,
324                                                             dsPrefix);
325             refElem.appendChild(transformsElem);
326             for (Transform transform : allTransforms) {
327                 ((DOMStructure)transform).marshal(transformsElem,
328                                                   dsPrefix, context);
329             }
330         }
331 
332         // create and append DigestMethod element
333         ((DOMDigestMethod)digestMethod).marshal(refElem, dsPrefix, context);
334 
335         // create and append DigestValue element
336         LOG.debug(&quot;Adding digestValueElem&quot;);
337         Element digestValueElem = DOMUtils.createElement(ownerDoc,
338                                                          &quot;DigestValue&quot;,
339                                                          XMLSignature.XMLNS,
340                                                          dsPrefix);
341         if (digestValue != null) {
342             digestValueElem.appendChild
343                 (ownerDoc.createTextNode(XMLUtils.encodeToString(digestValue)));
344 
345         }
346         refElem.appendChild(digestValueElem);
347 
348         parent.appendChild(refElem);
349         here = refElem.getAttributeNodeNS(null, &quot;URI&quot;);
350     }
351 
352     public void digest(XMLSignContext signContext)
353         throws XMLSignatureException
354     {
355         Data data = null;
356         if (appliedTransformData == null) {
357             data = dereference(signContext);
358         } else {
359             data = appliedTransformData;
360         }
361         digestValue = transform(data, signContext);
362 
363         // insert digestValue into DigestValue element
364         String encodedDV = XMLUtils.encodeToString(digestValue);
365         LOG.debug(&quot;Reference object uri = {}&quot;, uri);
366         Element digestElem = DOMUtils.getLastChildElement(refElem);
367         if (digestElem == null) {
368             throw new XMLSignatureException(&quot;DigestValue element expected&quot;);
369         }
370         DOMUtils.removeAllChildren(digestElem);
371         digestElem.appendChild
372             (refElem.getOwnerDocument().createTextNode(encodedDV));
373 
374         digested = true;
375         LOG.debug(&quot;Reference digesting completed&quot;);
376     }
377 
378     public boolean validate(XMLValidateContext validateContext)
379         throws XMLSignatureException
380     {
381         if (validateContext == null) {
382             throw new NullPointerException(&quot;validateContext cannot be null&quot;);
383         }
384         if (validated) {
385             return validationStatus;
386         }
387         Data data = dereference(validateContext);
388         calcDigestValue = transform(data, validateContext);
389 
390         if (LOG.isDebugEnabled()) {
391             LOG.debug(&quot;Expected digest: &quot; + XMLUtils.encodeToString(digestValue));
392             LOG.debug(&quot;Actual digest: &quot; + XMLUtils.encodeToString(calcDigestValue));
393         }
394 
395         validationStatus = Arrays.equals(digestValue, calcDigestValue);
396         validated = true;
397         return validationStatus;
398     }
399 
400     public Data getDereferencedData() {
401         return derefData;
402     }
403 
404     public InputStream getDigestInputStream() {
405         return dis;
406     }
407 
408     private Data dereference(XMLCryptoContext context)
409         throws XMLSignatureException
410     {
411         Data data = null;
412 
413         // use user-specified URIDereferencer if specified; otherwise use deflt
414         URIDereferencer deref = context.getURIDereferencer();
415         if (deref == null) {
416             deref = DOMURIDereferencer.INSTANCE;
417         }
418         try {
419             data = deref.dereference(this, context);
420             LOG.debug(&quot;URIDereferencer class name: {}&quot;, deref.getClass().getName());
421             LOG.debug(&quot;Data class name: {}&quot;, data.getClass().getName());
422         } catch (URIReferenceException ure) {
423             throw new XMLSignatureException(ure);
424         }
425 
426         return data;
427     }
428 
429     private byte[] transform(Data dereferencedData,
430                              XMLCryptoContext context)
431         throws XMLSignatureException
432     {
433         if (md == null) {
434             try {
435                 md = MessageDigest.getInstance
436                     (((DOMDigestMethod)digestMethod).getMessageDigestAlgorithm());
437             } catch (NoSuchAlgorithmException nsae) {
438                 throw new XMLSignatureException(nsae);
439             }
440         }
441         md.reset();
442         DigesterOutputStream dos;
443         Boolean cache = (Boolean)
444             context.getProperty(&quot;javax.xml.crypto.dsig.cacheReference&quot;);
445         if (cache != null &amp;&amp; cache) {
446             this.derefData = copyDerefData(dereferencedData);
447             dos = new DigesterOutputStream(md, true);
448         } else {
449             dos = new DigesterOutputStream(md);
450         }
451         Data data = dereferencedData;
452         try (OutputStream os = new UnsyncBufferedOutputStream(dos)) {
453             for (int i = 0, size = transforms.size(); i &lt; size; i++) {
454                 DOMTransform transform = (DOMTransform)transforms.get(i);
455                 if (i &lt; size - 1) {
456                     data = transform.transform(data, context);
457                 } else {
458                     data = transform.transform(data, context, os);
459                 }
460             }
461 
462             if (data != null) {
463                 XMLSignatureInput xi;
464                 // explicitly use C14N 1.1 when generating signature
465                 // first check system property, then context property
466                 boolean c14n11 = useC14N11;
467                 String c14nalg = CanonicalizationMethod.INCLUSIVE;
468                 if (context instanceof XMLSignContext) {
469                     if (!c14n11) {
470                         Boolean prop = (Boolean)context.getProperty
471                             (&quot;com.sun.org.apache.xml.internal.security.useC14N11&quot;);
472                         c14n11 = prop != null &amp;&amp; prop;
473                         if (c14n11) {
474                             c14nalg = &quot;http://www.w3.org/2006/12/xml-c14n11&quot;;
475                         }
476                     } else {
477                         c14nalg = &quot;http://www.w3.org/2006/12/xml-c14n11&quot;;
478                     }
479                 }
480                 if (data instanceof ApacheData) {
481                     xi = ((ApacheData)data).getXMLSignatureInput();
482                 } else if (data instanceof OctetStreamData) {
483                     xi = new XMLSignatureInput
484                         (((OctetStreamData)data).getOctetStream());
485                 } else if (data instanceof NodeSetData) {
486                     TransformService spi = null;
487                     if (provider == null) {
488                         spi = TransformService.getInstance(c14nalg, &quot;DOM&quot;);
489                     } else {
490                         try {
491                             spi = TransformService.getInstance(c14nalg, &quot;DOM&quot;, provider);
492                         } catch (NoSuchAlgorithmException nsae) {
493                             spi = TransformService.getInstance(c14nalg, &quot;DOM&quot;);
494                         }
495                     }
496                     data = spi.transform(data, context);
497                     xi = new XMLSignatureInput
498                         (((OctetStreamData)data).getOctetStream());
499                 } else {
500                     throw new XMLSignatureException(&quot;unrecognized Data type&quot;);
501                 }
502 
503                 boolean secVal = Utils.secureValidation(context);
504                 xi.setSecureValidation(secVal);
505                 if (context instanceof XMLSignContext &amp;&amp; c14n11
506                     &amp;&amp; !xi.isOctetStream() &amp;&amp; !xi.isOutputStreamSet()) {
507                     TransformService spi = null;
508                     if (provider == null) {
509                         spi = TransformService.getInstance(c14nalg, &quot;DOM&quot;);
510                     } else {
511                         try {
512                             spi = TransformService.getInstance(c14nalg, &quot;DOM&quot;, provider);
513                         } catch (NoSuchAlgorithmException nsae) {
514                             spi = TransformService.getInstance(c14nalg, &quot;DOM&quot;);
515                         }
516                     }
517 
518                     DOMTransform t = new DOMTransform(spi);
519                     Element transformsElem = null;
520                     String dsPrefix = DOMUtils.getSignaturePrefix(context);
521                     if (allTransforms.isEmpty()) {
522                         transformsElem = DOMUtils.createElement(
523                             refElem.getOwnerDocument(),
524                             &quot;Transforms&quot;, XMLSignature.XMLNS, dsPrefix);
525                         refElem.insertBefore(transformsElem,
526                             DOMUtils.getFirstChildElement(refElem));
527                     } else {
528                         transformsElem = DOMUtils.getFirstChildElement(refElem);
529                     }
530                     t.marshal(transformsElem, dsPrefix,
531                               (DOMCryptoContext)context);
532                     allTransforms.add(t);
533                     xi.updateOutputStream(os, true);
534                 } else {
535                     xi.updateOutputStream(os);
536                 }
537             }
538             os.flush();
539             if (cache != null &amp;&amp; cache) {
540                 this.dis = dos.getInputStream();
541             }
542             return dos.getDigestValue();
543         } catch (NoSuchAlgorithmException e) {
544             throw new XMLSignatureException(e);
545         } catch (TransformException e) {
546             throw new XMLSignatureException(e);
547         } catch (MarshalException e) {
548             throw new XMLSignatureException(e);
549         } catch (IOException e) {
550             throw new XMLSignatureException(e);
551         } catch (com.sun.org.apache.xml.internal.security.c14n.CanonicalizationException e) {
552             throw new XMLSignatureException(e);
553         } finally {
554             if (dos != null) {
555                 try {
556                     dos.close();
557                 } catch (IOException e) {
558                     throw new XMLSignatureException(e);
559                 }
560             }
561         }
562     }
563 
564     public Node getHere() {
565         return here;
566     }
567 
568     @Override
569     public boolean equals(Object o) {
570         if (this == o) {
571             return true;
572         }
573 
574         if (!(o instanceof Reference)) {
575             return false;
576         }
577         Reference oref = (Reference)o;
578 
579         boolean idsEqual = id == null ? oref.getId() == null
580                                        : id.equals(oref.getId());
581         boolean urisEqual = uri == null ? oref.getURI() == null
582                                          : uri.equals(oref.getURI());
583         boolean typesEqual = type == null ? oref.getType() == null
584                                            : type.equals(oref.getType());
585         boolean digestValuesEqual =
586             Arrays.equals(digestValue, oref.getDigestValue());
587 
588         return digestMethod.equals(oref.getDigestMethod()) &amp;&amp; idsEqual &amp;&amp;
589             urisEqual &amp;&amp; typesEqual &amp;&amp;
590             allTransforms.equals(oref.getTransforms()) &amp;&amp; digestValuesEqual;
591     }
592 
593     @Override
594     public int hashCode() {
595         int result = 17;
596         if (id != null) {
597             result = 31 * result + id.hashCode();
598         }
599         if (uri != null) {
600             result = 31 * result + uri.hashCode();
601         }
602         if (type != null) {
603             result = 31 * result + type.hashCode();
604         }
605         if (digestValue != null) {
606             result = 31 * result + Arrays.hashCode(digestValue);
607         }
608         result = 31 * result + digestMethod.hashCode();
609         result = 31 * result + allTransforms.hashCode();
610 
611         return result;
612     }
613 
614     boolean isDigested() {
615         return digested;
616     }
617 
618     private static Data copyDerefData(Data dereferencedData) {
619         if (dereferencedData instanceof ApacheData) {
620             // need to make a copy of the Data
621             ApacheData ad = (ApacheData)dereferencedData;
622             XMLSignatureInput xsi = ad.getXMLSignatureInput();
623             if (xsi.isNodeSet()) {
624                 try {
625                     final Set&lt;Node&gt; s = xsi.getNodeSet();
626                     return new NodeSetData&lt;Node&gt;() {
627                         public Iterator&lt;Node&gt; iterator() { return s.iterator(); }
628                     };
629                 } catch (Exception e) {
630                     // LOG a warning
631                     LOG.warn(&quot;cannot cache dereferenced data: &quot; + e);
632                     return null;
633                 }
634             } else if (xsi.isElement()) {
635                 return new DOMSubTreeData
636                     (xsi.getSubNode(), xsi.isExcludeComments());
637             } else if (xsi.isOctetStream() || xsi.isByteArray()) {
638                 try {
639                     return new OctetStreamData
640                         (xsi.getOctetStream(), xsi.getSourceURI(),
641                          xsi.getMIMEType());
642                 } catch (IOException ioe) {
643                     // LOG a warning
644                     LOG.warn(&quot;cannot cache dereferenced data: &quot; + ioe);
645                     return null;
646                 }
647             }
648         }
649         return dereferencedData;
650     }
651 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml.crypto/share/classes/org/jcp/xml/dsig/internal/dom/DOMKeyInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 /*
 24  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
 25  */
 26 /*
 27  * $Id: DOMKeyInfo.java 1788465 2017-03-24 15:10:51Z coheigea $
 28  */
 29 package org.jcp.xml.dsig.internal.dom;
 30 
 31 import java.security.Provider;
 32 import java.util.ArrayList;
 33 import java.util.Collections;
 34 import java.util.List;
 35 
 36 import javax.xml.crypto.MarshalException;
 37 import javax.xml.crypto.XMLCryptoContext;
 38 import javax.xml.crypto.XMLStructure;
 39 import javax.xml.crypto.dom.DOMCryptoContext;
 40 import javax.xml.crypto.dsig.XMLSignature;
 41 import javax.xml.crypto.dsig.dom.DOMSignContext;
 42 import javax.xml.crypto.dsig.keyinfo.KeyInfo;
 43 
 44 import org.w3c.dom.Attr;
 45 import org.w3c.dom.Document;
 46 import org.w3c.dom.Element;
 47 import org.w3c.dom.Node;
 48 
 49 /**
 50  * DOM-based implementation of KeyInfo.
 51  *
 52  */
 53 public final class DOMKeyInfo extends DOMStructure implements KeyInfo {
 54 
 55     private final String id;
 56     private final List&lt;XMLStructure&gt; keyInfoTypes;
 57 
 58     /**
 59      * A utility function to suppress casting warnings.
 60      * @param ki
 61      * @return the content of a KeyInfo Object
 62      */
 63     @SuppressWarnings(&quot;unchecked&quot;)
 64     public static List&lt;XMLStructure&gt; getContent(KeyInfo ki) {
 65         return ki.getContent();
 66     }
 67 
 68     /**
 69      * Creates a {@code DOMKeyInfo}.
 70      *
 71      * @param content a list of one or more {@link XMLStructure}s representing
 72      *    key information types. The list is defensively copied to protect
 73      *    against subsequent modification.
 74      * @param id an ID attribute
 75      * @throws NullPointerException if {@code content} is {@code null}
 76      * @throws IllegalArgumentException if {@code content} is empty
 77      * @throws ClassCastException if {@code content} contains any entries
 78      *    that are not of type {@link XMLStructure}
 79      */
 80     public DOMKeyInfo(List&lt;? extends XMLStructure&gt; content, String id) {
 81         if (content == null) {
 82             throw new NullPointerException(&quot;content cannot be null&quot;);
 83         }
 84         this.keyInfoTypes =
 85             Collections.unmodifiableList(new ArrayList&lt;&gt;(content));
 86         if (this.keyInfoTypes.isEmpty()) {
 87             throw new IllegalArgumentException(&quot;content cannot be empty&quot;);
 88         }
 89         for (int i = 0, size = this.keyInfoTypes.size(); i &lt; size; i++) {
 90             if (!(this.keyInfoTypes.get(i) instanceof XMLStructure)) {
 91                 throw new ClassCastException
 92                     (&quot;content[&quot;+i+&quot;] is not a valid KeyInfo type&quot;);
 93             }
 94         }
 95         this.id = id;
 96     }
 97 
 98     /**
 99      * Creates a {@code DOMKeyInfo} from XML.
100      *
101      * @param kiElem KeyInfo element
102      */
103     public DOMKeyInfo(Element kiElem, XMLCryptoContext context,
104                       Provider provider)
105         throws MarshalException
106     {
107         // get Id attribute, if specified
108         Attr attr = kiElem.getAttributeNodeNS(null, &quot;Id&quot;);
109         if (attr != null) {
110             id = attr.getValue();
111             kiElem.setIdAttributeNode(attr, true);
112         } else {
113             id = null;
114         }
115 
116         // get all children nodes
117         List&lt;XMLStructure&gt; content = new ArrayList&lt;&gt;();
118         Node firstChild = kiElem.getFirstChild();
119         if (firstChild == null) {
120             throw new MarshalException(&quot;KeyInfo must contain at least one type&quot;);
121         }
122         while (firstChild != null) {
123             if (firstChild.getNodeType() == Node.ELEMENT_NODE) {
124                 Element childElem = (Element)firstChild;
125                 String localName = childElem.getLocalName();
126                 String namespace = childElem.getNamespaceURI();
127                 if (&quot;X509Data&quot;.equals(localName) &amp;&amp; XMLSignature.XMLNS.equals(namespace)) {
128                     content.add(new DOMX509Data(childElem));
129                 } else if (&quot;KeyName&quot;.equals(localName) &amp;&amp; XMLSignature.XMLNS.equals(namespace)) {
130                     content.add(new DOMKeyName(childElem));
131                 } else if (&quot;KeyValue&quot;.equals(localName) &amp;&amp; XMLSignature.XMLNS.equals(namespace)) {
132                     content.add(DOMKeyValue.unmarshal(childElem));
133                 } else if (&quot;RetrievalMethod&quot;.equals(localName) &amp;&amp; XMLSignature.XMLNS.equals(namespace)) {
134                     content.add(new DOMRetrievalMethod(childElem,
135                                                        context, provider));
136                 } else if (&quot;PGPData&quot;.equals(localName) &amp;&amp; XMLSignature.XMLNS.equals(namespace)) {
137                     content.add(new DOMPGPData(childElem));
138                 } else { //may be MgmtData, SPKIData or element from other namespace
139                     content.add(new javax.xml.crypto.dom.DOMStructure(childElem));
140                 }
141             }
142             firstChild = firstChild.getNextSibling();
143         }
144         keyInfoTypes = Collections.unmodifiableList(content);
145     }
146 
147     public String getId() {
148         return id;
149     }
150 
151     public List&lt;XMLStructure&gt; getContent() {
152         return keyInfoTypes;
153     }
154 
155     public void marshal(XMLStructure parent, XMLCryptoContext context)
156         throws MarshalException
157     {
158         if (parent == null) {
159             throw new NullPointerException(&quot;parent is null&quot;);
160         }
161         if (!(parent instanceof javax.xml.crypto.dom.DOMStructure)) {
162             throw new ClassCastException(&quot;parent must be of type DOMStructure&quot;);
163         }
164 
165         Node pNode = ((javax.xml.crypto.dom.DOMStructure)parent).getNode();
166         String dsPrefix = DOMUtils.getSignaturePrefix(context);
167         Element kiElem = DOMUtils.createElement
168             (DOMUtils.getOwnerDocument(pNode), &quot;KeyInfo&quot;,
169              XMLSignature.XMLNS, dsPrefix);
170         if (dsPrefix == null || dsPrefix.length() == 0) {
171             kiElem.setAttributeNS(&quot;http://www.w3.org/2000/xmlns/&quot;,
172                                   &quot;xmlns&quot;, XMLSignature.XMLNS);
173         } else {
174             kiElem.setAttributeNS(&quot;http://www.w3.org/2000/xmlns/&quot;,
175                                   &quot;xmlns:&quot; + dsPrefix, XMLSignature.XMLNS);
176         }
177 
178         Node nextSibling = null;
179         if (context instanceof DOMSignContext) {
180             nextSibling = ((DOMSignContext)context).getNextSibling();
181         }
182         marshal(pNode, kiElem, nextSibling, dsPrefix, (DOMCryptoContext)context);
183     }
184 
185     @Override
186     public void marshal(Node parent, String dsPrefix,
187                         DOMCryptoContext context)
188         throws MarshalException
189     {
190         marshal(parent, null, dsPrefix, context);
191     }
192 
193     public void marshal(Node parent, Node nextSibling, String dsPrefix,
194                         DOMCryptoContext context)
195         throws MarshalException
196     {
197         Document ownerDoc = DOMUtils.getOwnerDocument(parent);
198         Element kiElem = DOMUtils.createElement(ownerDoc, &quot;KeyInfo&quot;,
199                                                 XMLSignature.XMLNS, dsPrefix);
200         marshal(parent, kiElem, nextSibling, dsPrefix, context);
201     }
202 
203     private void marshal(Node parent, Element kiElem, Node nextSibling,
204                          String dsPrefix, DOMCryptoContext context)
205         throws MarshalException
206     {
207         // create and append KeyInfoType elements
208         for (XMLStructure kiType : keyInfoTypes) {
209             if (kiType instanceof DOMStructure) {
210                 ((DOMStructure)kiType).marshal(kiElem, dsPrefix, context);
211             } else {
212                 DOMUtils.appendChild(kiElem,
213                     ((javax.xml.crypto.dom.DOMStructure)kiType).getNode());
214             }
215         }
216 
217         // append id attribute
218         DOMUtils.setAttributeID(kiElem, &quot;Id&quot;, id);
219 
220         parent.insertBefore(kiElem, nextSibling);
221     }
222 
223     @Override
224     public boolean equals(Object o) {
225         if (this == o) {
226             return true;
227         }
228 
229         if (!(o instanceof KeyInfo)) {
230             return false;
231         }
232         KeyInfo oki = (KeyInfo)o;
233 
234         boolean idsEqual = id == null ? oki.getId() == null
235                                        : id.equals(oki.getId());
236 
237         return keyInfoTypes.equals(oki.getContent()) &amp;&amp; idsEqual;
238     }
239 
240     @Override
241     public int hashCode() {
242         int result = 17;
243         if (id != null) {
244             result = 31 * result + id.hashCode();
245         }
246         result = 31 * result + keyInfoTypes.hashCode();
247 
248         return result;
249     }
250 }
    </pre>
  </body>
</html>
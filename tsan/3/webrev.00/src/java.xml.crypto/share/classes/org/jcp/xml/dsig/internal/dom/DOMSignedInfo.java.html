<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml.crypto/share/classes/org/jcp/xml/dsig/internal/dom/DOMSignedInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 /*
 24  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
 25  */
 26 /*
 27  * $Id: DOMSignedInfo.java 1854026 2019-02-21 09:30:01Z coheigea $
 28  */
 29 package org.jcp.xml.dsig.internal.dom;
 30 
 31 import javax.xml.crypto.*;
 32 import javax.xml.crypto.dom.DOMCryptoContext;
 33 import javax.xml.crypto.dsig.*;
 34 
 35 import java.io.ByteArrayInputStream;
 36 import java.io.ByteArrayOutputStream;
 37 import java.io.InputStream;
 38 import java.io.OutputStream;
 39 import java.io.IOException;
 40 import java.security.Provider;
 41 import java.util.*;
 42 
 43 import org.w3c.dom.Document;
 44 import org.w3c.dom.Element;
 45 import org.w3c.dom.Node;
 46 import com.sun.org.apache.xml.internal.security.utils.UnsyncBufferedOutputStream;
 47 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 48 
 49 /**
 50  * DOM-based implementation of SignedInfo.
 51  *
 52  */
 53 public final class DOMSignedInfo extends DOMStructure implements SignedInfo {
 54 
 55     private static final com.sun.org.slf4j.internal.Logger LOG =
 56         com.sun.org.slf4j.internal.LoggerFactory.getLogger(DOMSignedInfo.class);
 57 
 58     private List&lt;Reference&gt; references;
 59     private CanonicalizationMethod canonicalizationMethod;
 60     private SignatureMethod signatureMethod;
 61     private String id;
 62     private Document ownerDoc;
 63     private Element localSiElem;
 64     private InputStream canonData;
 65 
 66     /**
 67      * Creates a {@code DOMSignedInfo} from the specified parameters. Use
 68      * this constructor when the {@code Id} is not specified.
 69      *
 70      * @param cm the canonicalization method
 71      * @param sm the signature method
 72      * @param references the list of references. The list is copied.
 73      * @throws NullPointerException if
 74      *    {@code cm}, {@code sm}, or {@code references} is
 75      *    {@code null}
 76      * @throws IllegalArgumentException if {@code references} is empty
 77      * @throws ClassCastException if any of the references are not of
 78      *    type {@code Reference}
 79      */
 80     public DOMSignedInfo(CanonicalizationMethod cm, SignatureMethod sm,
 81                          List&lt;? extends Reference&gt; references) {
 82         if (cm == null || sm == null || references == null) {
 83             throw new NullPointerException();
 84         }
 85         this.canonicalizationMethod = cm;
 86         this.signatureMethod = sm;
 87         this.references = Collections.unmodifiableList(
 88             new ArrayList&lt;&gt;(references));
 89         if (this.references.isEmpty()) {
 90             throw new IllegalArgumentException(&quot;list of references must &quot; +
 91                 &quot;contain at least one entry&quot;);
 92         }
 93         for (int i = 0, size = this.references.size(); i &lt; size; i++) {
 94             Object obj = this.references.get(i);
 95             if (!(obj instanceof Reference)) {
 96                 throw new ClassCastException(&quot;list of references contains &quot; +
 97                     &quot;an illegal type&quot;);
 98             }
 99         }
100     }
101 
102     /**
103      * Creates a {@code DOMSignedInfo} from the specified parameters.
104      *
105      * @param cm the canonicalization method
106      * @param sm the signature method
107      * @param references the list of references. The list is copied.
108      * @param id an optional identifer that will allow this
109      *    {@code SignedInfo} to be referenced by other signatures and
110      *    objects
111      * @throws NullPointerException if {@code cm}, {@code sm},
112      *    or {@code references} is {@code null}
113      * @throws IllegalArgumentException if {@code references} is empty
114      * @throws ClassCastException if any of the references are not of
115      *    type {@code Reference}
116      */
117     public DOMSignedInfo(CanonicalizationMethod cm, SignatureMethod sm,
118                          List&lt;? extends Reference&gt; references, String id) {
119         this(cm, sm, references);
120         this.id = id;
121     }
122 
123     /**
124      * Creates a {@code DOMSignedInfo} from an element.
125      *
126      * @param siElem a SignedInfo element
127      */
128     public DOMSignedInfo(Element siElem, XMLCryptoContext context, Provider provider)
129         throws MarshalException {
130         localSiElem = siElem;
131         ownerDoc = siElem.getOwnerDocument();
132 
133         // get Id attribute, if specified
134         id = DOMUtils.getAttributeValue(siElem, &quot;Id&quot;);
135 
136         // unmarshal CanonicalizationMethod
137         Element cmElem = DOMUtils.getFirstChildElement(siElem,
138                                                        &quot;CanonicalizationMethod&quot;,
139                                                        XMLSignature.XMLNS);
140         canonicalizationMethod = new DOMCanonicalizationMethod(cmElem, context,
141                                                                provider);
142 
143         // unmarshal SignatureMethod
144         Element smElem = DOMUtils.getNextSiblingElement(cmElem,
145                                                         &quot;SignatureMethod&quot;,
146                                                         XMLSignature.XMLNS);
147         signatureMethod = DOMSignatureMethod.unmarshal(smElem);
148 
149         boolean secVal = Utils.secureValidation(context);
150 
151         String signatureMethodAlgorithm = signatureMethod.getAlgorithm();
152         if (secVal &amp;&amp; Policy.restrictAlg(signatureMethodAlgorithm)) {
153             throw new MarshalException(
154                 &quot;It is forbidden to use algorithm &quot; + signatureMethodAlgorithm +
155                 &quot; when secure validation is enabled&quot;
156             );
157         }
158 
159         // unmarshal References
160         ArrayList&lt;Reference&gt; refList = new ArrayList&lt;&gt;(5);
161         Element refElem = DOMUtils.getNextSiblingElement(smElem, &quot;Reference&quot;, XMLSignature.XMLNS);
162         refList.add(new DOMReference(refElem, context, provider));
163 
164         refElem = DOMUtils.getNextSiblingElement(refElem);
165         while (refElem != null) {
166             String name = refElem.getLocalName();
167             String namespace = refElem.getNamespaceURI();
168             if (!&quot;Reference&quot;.equals(name) || !XMLSignature.XMLNS.equals(namespace)) {
169                 throw new MarshalException(&quot;Invalid element name: &quot; +
170                                            namespace + &quot;:&quot; + name + &quot;, expected Reference&quot;);
171             }
172             refList.add(new DOMReference(refElem, context, provider));
173             if (secVal &amp;&amp; Policy.restrictNumReferences(refList.size())) {
174                 String error = &quot;A maxiumum of &quot; + Policy.maxReferences()
175                     + &quot; references per Manifest are allowed when&quot;
176                     + &quot; secure validation is enabled&quot;;
177                 throw new MarshalException(error);
178             }
179             refElem = DOMUtils.getNextSiblingElement(refElem);
180         }
181         references = Collections.unmodifiableList(refList);
182     }
183 
184     public CanonicalizationMethod getCanonicalizationMethod() {
185         return canonicalizationMethod;
186     }
187 
188     public SignatureMethod getSignatureMethod() {
189         return signatureMethod;
190     }
191 
192     public String getId() {
193         return id;
194     }
195 
196     public List&lt;Reference&gt; getReferences() {
197         return references;
198     }
199 
200     public InputStream getCanonicalizedData() {
201         return canonData;
202     }
203 
204     public void canonicalize(XMLCryptoContext context, ByteArrayOutputStream bos)
205         throws XMLSignatureException {
206         if (context == null) {
207             throw new NullPointerException(&quot;context cannot be null&quot;);
208         }
209 
210         DOMSubTreeData subTree = new DOMSubTreeData(localSiElem, true);
211         try (OutputStream os = new UnsyncBufferedOutputStream(bos)) {
212             ((DOMCanonicalizationMethod)
213                 canonicalizationMethod).canonicalize(subTree, context, os);
214 
215             os.flush();
216 
217             byte[] signedInfoBytes = bos.toByteArray();
218 
219             // this whole block should only be done if LOGging is enabled
220             if (LOG.isDebugEnabled()) {
221                 LOG.debug(&quot;Canonicalized SignedInfo:&quot;);
222                 StringBuilder sb = new StringBuilder(signedInfoBytes.length);
223                 for (int i = 0; i &lt; signedInfoBytes.length; i++) {
224                     sb.append((char)signedInfoBytes[i]);
225                 }
226                 LOG.debug(sb.toString());
227                 LOG.debug(&quot;Data to be signed/verified:&quot; + XMLUtils.encodeToString(signedInfoBytes));
228             }
229 
230             this.canonData = new ByteArrayInputStream(signedInfoBytes);
231         } catch (TransformException te) {
232             throw new XMLSignatureException(te);
233         } catch (IOException e) {
234             LOG.debug(e.getMessage(), e);
235             // Impossible
236         }
237     }
238 
239     @Override
240     public void marshal(Node parent, String dsPrefix, DOMCryptoContext context)
241         throws MarshalException
242     {
243         ownerDoc = DOMUtils.getOwnerDocument(parent);
244         Element siElem = DOMUtils.createElement(ownerDoc, &quot;SignedInfo&quot;,
245                                                 XMLSignature.XMLNS, dsPrefix);
246 
247         // create and append CanonicalizationMethod element
248         DOMCanonicalizationMethod dcm =
249             (DOMCanonicalizationMethod)canonicalizationMethod;
250         dcm.marshal(siElem, dsPrefix, context);
251 
252         // create and append SignatureMethod element
253         ((DOMStructure)signatureMethod).marshal(siElem, dsPrefix, context);
254 
255         // create and append Reference elements
256         for (Reference reference : references) {
257             ((DOMReference)reference).marshal(siElem, dsPrefix, context);
258         }
259 
260         // append Id attribute
261         DOMUtils.setAttributeID(siElem, &quot;Id&quot;, id);
262 
263         parent.appendChild(siElem);
264         localSiElem = siElem;
265     }
266 
267     @Override
268     public boolean equals(Object o) {
269         if (this == o) {
270             return true;
271         }
272 
273         if (!(o instanceof SignedInfo)) {
274             return false;
275         }
276         SignedInfo osi = (SignedInfo)o;
277 
278         boolean idEqual = id == null ? osi.getId() == null
279                                       : id.equals(osi.getId());
280 
281         return canonicalizationMethod.equals(osi.getCanonicalizationMethod())
282                 &amp;&amp; signatureMethod.equals(osi.getSignatureMethod()) &amp;&amp;
283                 references.equals(osi.getReferences()) &amp;&amp; idEqual;
284     }
285 
286     @SuppressWarnings(&quot;unchecked&quot;)
287     public static List&lt;Reference&gt; getSignedInfoReferences(SignedInfo si) {
288         return si.getReferences();
289     }
290 
291     @Override
292     public int hashCode() {
293         int result = 17;
294         if (id != null) {
295             result = 31 * result + id.hashCode();
296         }
297         result = 31 * result + canonicalizationMethod.hashCode();
298         result = 31 * result + signatureMethod.hashCode();
299         result = 31 * result + references.hashCode();
300 
301         return result;
302     }
303 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml.crypto/share/classes/org/jcp/xml/dsig/internal/dom/DOMUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 /*
 24  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
 25  */
 26 /*
 27  * $Id: DOMUtils.java 1788465 2017-03-24 15:10:51Z coheigea $
 28  */
 29 package org.jcp.xml.dsig.internal.dom;
 30 
 31 import java.util.*;
 32 import java.security.spec.AlgorithmParameterSpec;
 33 import org.w3c.dom.Attr;
 34 import org.w3c.dom.Document;
 35 import org.w3c.dom.Element;
 36 import org.w3c.dom.Node;
 37 import org.w3c.dom.NodeList;
 38 
 39 import javax.xml.XMLConstants;
 40 import javax.xml.crypto.*;
 41 import javax.xml.crypto.dsig.*;
 42 import javax.xml.crypto.dsig.spec.*;
 43 
 44 /**
 45  * Useful static DOM utility methods.
 46  *
 47  */
 48 public final class DOMUtils {
 49 
 50     // class cannot be instantiated
 51     private DOMUtils() {}
 52 
 53     /**
 54      * Returns the owner document of the specified node.
 55      *
 56      * @param node the node
 57      * @return the owner document
 58      */
 59     public static Document getOwnerDocument(Node node) {
 60         if (node.getNodeType() == Node.DOCUMENT_NODE) {
 61             return (Document)node;
 62         } else {
 63             return node.getOwnerDocument();
 64         }
 65     }
 66 
 67     /**
 68      * Create a QName string from a prefix and local name.
 69      *
 70      * @param prefix    The prefix, if any. Can be either null or empty.
 71      * @param localName The local name.
 72      *
 73      * @return The string for the qName, for example, &quot;xsd:element&quot;.
 74      */
 75     public static String getQNameString(String prefix, String localName) {
 76         String qName = prefix == null || prefix.length() == 0
 77                 ? localName : prefix + &quot;:&quot; + localName;
 78 
 79         return qName;
 80     }
 81 
 82     /**
 83      * Creates an element in the specified namespace, with the specified tag
 84      * and namespace prefix.
 85      *
 86      * @param doc the owner document
 87      * @param tag the tag
 88      * @param nsURI the namespace URI
 89      * @param prefix the namespace prefix
 90      * @return the newly created element
 91      */
 92     public static Element createElement(Document doc, String tag,
 93                                         String nsURI, String prefix)
 94     {
 95         String qName = (prefix == null || prefix.length() == 0)
 96                        ? tag : prefix + &quot;:&quot; + tag;
 97         return doc.createElementNS(nsURI, qName);
 98     }
 99 
100     /**
101      * Sets an element&#39;s attribute (using DOM level 2) with the
102      * specified value and namespace prefix.
103      *
104      * @param elem the element to set the attribute on
105      * @param name the name of the attribute
106      * @param value the attribute value. If null, no attribute is set.
107      */
108     public static void setAttribute(Element elem, String name, String value) {
109         if (value == null) {
110             return;
111         }
112         elem.setAttributeNS(null, name, value);
113     }
114 
115     /**
116      * Sets an element&#39;s attribute (using DOM level 2) with the
117      * specified value and namespace prefix AND registers the ID value with
118      * the specified element. This is for resolving same-document
119      * ID references.
120      *
121      * @param elem the element to set the attribute on
122      * @param name the name of the attribute
123      * @param value the attribute value. If null, no attribute is set.
124      */
125     public static void setAttributeID(Element elem, String name, String value) {
126         if (value == null) {
127             return;
128         }
129         elem.setAttributeNS(null, name, value);
130         elem.setIdAttributeNS(null, name, true);
131     }
132 
133     /**
134      * Returns the first child element of the specified node, or null if there
135      * is no such element.
136      *
137      * @param node the node
138      * @return the first child element of the specified node, or null if there
139      *    is no such element
140      * @throws NullPointerException if {@code node == null}
141      */
142     public static Element getFirstChildElement(Node node) {
143         Node child = node.getFirstChild();
144         while (child != null &amp;&amp; child.getNodeType() != Node.ELEMENT_NODE) {
145             child = child.getNextSibling();
146         }
147         return (Element)child;
148     }
149 
150     /**
151      * Returns the first child element of the specified node and checks that
152      * the local name is equal to {@code localName}.
153      *
154      * @param node the node
155      * @return the first child element of the specified node
156      * @throws NullPointerException if {@code node == null}
157      * @throws MarshalException if no such element or the local name is not
158      *    equal to {@code localName}
159      */
160     @Deprecated
161     public static Element getFirstChildElement(Node node, String localName)
162         throws MarshalException
163     {
164         return verifyElement(getFirstChildElement(node), localName);
165     }
166 
167     /**
168      * Returns the first child element of the specified node and checks that
169      * the local name is equal to {@code localName} and the namespace is equal to
170      * {@code namespaceURI}
171      *
172      * @param node the node
173      * @return the first child element of the specified node
174      * @throws NullPointerException if {@code node == null}
175      * @throws MarshalException if no such element or the local name is not
176      *    equal to {@code localName}
177      */
178     public static Element getFirstChildElement(Node node, String localName, String namespaceURI)
179         throws MarshalException
180     {
181         return verifyElement(getFirstChildElement(node), localName, namespaceURI);
182     }
183 
184     private static Element verifyElement(Element elem, String localName)
185         throws MarshalException
186     {
187         if (elem == null) {
188             throw new MarshalException(&quot;Missing &quot; + localName + &quot; element&quot;);
189         }
190         String name = elem.getLocalName();
191         if (!name.equals(localName)) {
192             throw new MarshalException(&quot;Invalid element name: &quot; +
193                                        name + &quot;, expected &quot; + localName);
194         }
195         return elem;
196     }
197 
198     private static Element verifyElement(Element elem, String localName, String namespaceURI)
199         throws MarshalException
200     {
201         if (elem == null) {
202             throw new MarshalException(&quot;Missing &quot; + localName + &quot; element&quot;);
203         }
204         String name = elem.getLocalName();
205         String namespace = elem.getNamespaceURI();
206         if (!name.equals(localName) || namespace == null &amp;&amp; namespaceURI != null
207             || namespace != null &amp;&amp; !namespace.equals(namespaceURI)) {
208             throw new MarshalException(&quot;Invalid element name: &quot; +
209                 namespace + &quot;:&quot; + name + &quot;, expected &quot; + namespaceURI + &quot;:&quot; + localName);
210         }
211         return elem;
212     }
213 
214     /**
215      * Returns the last child element of the specified node, or null if there
216      * is no such element.
217      *
218      * @param node the node
219      * @return the last child element of the specified node, or null if there
220      *    is no such element
221      * @throws NullPointerException if {@code node == null}
222      */
223     public static Element getLastChildElement(Node node) {
224         Node child = node.getLastChild();
225         while (child != null &amp;&amp; child.getNodeType() != Node.ELEMENT_NODE) {
226             child = child.getPreviousSibling();
227         }
228         return (Element)child;
229     }
230 
231     /**
232      * Returns the next sibling element of the specified node, or null if there
233      * is no such element.
234      *
235      * @param node the node
236      * @return the next sibling element of the specified node, or null if there
237      *    is no such element
238      * @throws NullPointerException if {@code node == null}
239      */
240     public static Element getNextSiblingElement(Node node) {
241         Node sibling = node.getNextSibling();
242         while (sibling != null &amp;&amp; sibling.getNodeType() != Node.ELEMENT_NODE) {
243             sibling = sibling.getNextSibling();
244         }
245         return (Element)sibling;
246     }
247 
248     /**
249      * Returns the next sibling element of the specified node and checks that
250      * the local name is equal to {@code localName}.
251      *
252      * @param node the node
253      * @return the next sibling element of the specified node
254      * @throws NullPointerException if {@code node == null}
255      * @throws MarshalException if no such element or the local name is not
256      * equal to {@code localName}
257      */
258     @Deprecated
259     public static Element getNextSiblingElement(Node node, String localName)
260         throws MarshalException
261     {
262         return verifyElement(getNextSiblingElement(node), localName);
263     }
264 
265     /**
266      * Returns the next sibling element of the specified node and checks that
267      * the local name is equal to {@code localName} and the namespace is equal to
268      * {@code namespaceURI}
269      *
270      * @param node the node
271      * @return the next sibling element of the specified node
272      * @throws NullPointerException if {@code node == null}
273      * @throws MarshalException if no such element or the local name is not
274      * equal to {@code localName}
275      */
276     public static Element getNextSiblingElement(Node node, String localName, String namespaceURI)
277         throws MarshalException
278     {
279         return verifyElement(getNextSiblingElement(node), localName, namespaceURI);
280     }
281 
282     /**
283      * Returns the attribute value for the attribute with the specified name.
284      * Returns null if there is no such attribute, or
285      * the empty string if the attribute value is empty.
286      *
287      * &lt;p&gt;This works around a limitation of the DOM
288      * {@code Element.getAttributeNode} method, which does not distinguish
289      * between an unspecified attribute and an attribute with a value of
290      * &quot;&quot; (it returns &quot;&quot; for both cases).
291      *
292      * @param elem the element containing the attribute
293      * @param name the name of the attribute
294      * @return the attribute value (may be null if unspecified)
295      */
296     public static String getAttributeValue(Element elem, String name) {
297         Attr attr = elem.getAttributeNodeNS(null, name);
298         return (attr == null) ? null : attr.getValue();
299     }
300 
301     /**
302      * Returns the attribute value for the attribute with the specified name.
303      * Returns null if there is no such attribute, or
304      * the empty string if the attribute value is empty.
305      *
306      * &lt;p&gt;This works around a limitation of the DOM
307      * {@code Element.getAttributeNode} method, which does not distinguish
308      * between an unspecified attribute and an attribute with a value of
309      * &quot;&quot; (it returns &quot;&quot; for both cases).
310      *
311      * @param elem the element containing the attribute
312      * @param name the name of the attribute
313      * @return the attribute value (may be null if unspecified)
314      */
315     public static &lt;N&gt; String getIdAttributeValue(Element elem, String name) {
316         Attr attr = elem.getAttributeNodeNS(null, name);
317         if (attr != null &amp;&amp; !attr.isId()) {
318             elem.setIdAttributeNode(attr, true);
319         }
320         return (attr == null) ? null : attr.getValue();
321     }
322 
323     /**
324      * Returns a Set of {@code Node}s, backed by the specified
325      * {@code NodeList}.
326      *
327      * @param nl the NodeList
328      * @return a Set of Nodes
329      */
330     public static Set&lt;Node&gt; nodeSet(NodeList nl) {
331         return new NodeSet(nl);
332     }
333 
334     static class NodeSet extends AbstractSet&lt;Node&gt; {
335         private NodeList nl;
336         public NodeSet(NodeList nl) {
337             this.nl = nl;
338         }
339 
340         public int size() { return nl.getLength(); }
341         public Iterator&lt;Node&gt; iterator() {
342             return new Iterator&lt;Node&gt;() {
343                 private int index;
344 
345                 public void remove() {
346                     throw new UnsupportedOperationException();
347                 }
348                 public Node next() {
349                     if (!hasNext()) {
350                         throw new NoSuchElementException();
351                     }
352                     return nl.item(index++);
353                 }
354                 public boolean hasNext() {
355                     return index &lt; nl.getLength();
356                 }
357             };
358         }
359     }
360 
361     /**
362      * Returns the prefix associated with the specified namespace URI
363      *
364      * @param context contains the namespace map
365      * @param nsURI the namespace URI
366      * @return the prefix associated with the specified namespace URI, or
367      *    null if not set
368      */
369     public static String getNSPrefix(XMLCryptoContext context, String nsURI) {
370         if (context != null) {
371             return context.getNamespacePrefix
372                 (nsURI, context.getDefaultNamespacePrefix());
373         } else {
374             return null;
375         }
376     }
377 
378     /**
379      * Returns the prefix associated with the XML Signature namespace URI
380      *
381      * @param context contains the namespace map
382      * @return the prefix associated with the specified namespace URI, or
383      *    null if not set
384      */
385     public static String getSignaturePrefix(XMLCryptoContext context) {
386         return getNSPrefix(context, XMLSignature.XMLNS);
387     }
388 
389     /**
390      * Removes all children nodes from the specified node.
391      *
392      * @param node the parent node whose children are to be removed
393      */
394     public static void removeAllChildren(Node node) {
395         Node firstChild = node.getFirstChild();
396         while (firstChild != null) {
397             Node nodeToRemove = firstChild;
398             firstChild = firstChild.getNextSibling();
399             node.removeChild(nodeToRemove);
400         }
401     }
402 
403     /**
404      * Compares 2 nodes for equality. Implementation is not complete.
405      */
406     public static boolean nodesEqual(Node thisNode, Node otherNode) {
407         if (thisNode == otherNode) {
408             return true;
409         }
410         if (thisNode.getNodeType() != otherNode.getNodeType()) {
411             return false;
412         }
413         // FIXME - test content, etc
414         return true;
415     }
416 
417     /**
418      * Checks if child element has same owner document before
419      * appending to the parent, and imports it to the parent&#39;s document
420      * if necessary.
421      */
422     public static void appendChild(Node parent, Node child) {
423         Document ownerDoc = getOwnerDocument(parent);
424         if (child.getOwnerDocument() != ownerDoc) {
425             parent.appendChild(ownerDoc.importNode(child, true));
426         } else {
427             parent.appendChild(child);
428         }
429     }
430 
431     public static boolean paramsEqual(AlgorithmParameterSpec spec1,
432         AlgorithmParameterSpec spec2) {
433         if (spec1 == spec2) {
434             return true;
435         }
436         if (spec1 instanceof XPathFilter2ParameterSpec &amp;&amp;
437             spec2 instanceof XPathFilter2ParameterSpec) {
438             return paramsEqual((XPathFilter2ParameterSpec)spec1,
439                                (XPathFilter2ParameterSpec)spec2);
440         }
441         if (spec1 instanceof ExcC14NParameterSpec &amp;&amp;
442             spec2 instanceof ExcC14NParameterSpec) {
443             return paramsEqual((ExcC14NParameterSpec) spec1,
444                                (ExcC14NParameterSpec)spec2);
445         }
446         if (spec1 instanceof XPathFilterParameterSpec &amp;&amp;
447             spec2 instanceof XPathFilterParameterSpec) {
448             return paramsEqual((XPathFilterParameterSpec)spec1,
449                                (XPathFilterParameterSpec)spec2);
450         }
451         if (spec1 instanceof XSLTTransformParameterSpec &amp;&amp;
452             spec2 instanceof XSLTTransformParameterSpec) {
453             return paramsEqual((XSLTTransformParameterSpec)spec1,
454                                (XSLTTransformParameterSpec)spec2);
455         }
456         return false;
457     }
458 
459     private static boolean paramsEqual(XPathFilter2ParameterSpec spec1,
460                                        XPathFilter2ParameterSpec spec2)
461     {
462         @SuppressWarnings(&quot;unchecked&quot;)
463         List&lt;XPathType&gt; types = spec1.getXPathList();
464         @SuppressWarnings(&quot;unchecked&quot;)
465         List&lt;XPathType&gt; otypes = spec2.getXPathList();
466         int size = types.size();
467         if (size != otypes.size()) {
468             return false;
469         }
470         for (int i = 0; i &lt; size; i++) {
471             XPathType type = types.get(i);
472             XPathType otype = otypes.get(i);
473             if (!type.getExpression().equals(otype.getExpression()) ||
474                 !type.getNamespaceMap().equals(otype.getNamespaceMap()) ||
475                 type.getFilter() != otype.getFilter()) {
476                 return false;
477             }
478         }
479         return true;
480     }
481 
482     private static boolean paramsEqual(ExcC14NParameterSpec spec1,
483                                        ExcC14NParameterSpec spec2)
484     {
485         return spec1.getPrefixList().equals(spec2.getPrefixList());
486     }
487 
488     private static boolean paramsEqual(XPathFilterParameterSpec spec1,
489                                        XPathFilterParameterSpec spec2)
490     {
491         return spec1.getXPath().equals(spec2.getXPath()) &amp;&amp;
492                 spec1.getNamespaceMap().equals(spec2.getNamespaceMap());
493     }
494 
495     private static boolean paramsEqual(XSLTTransformParameterSpec spec1,
496                                        XSLTTransformParameterSpec spec2)
497     {
498 
499         XMLStructure ostylesheet = spec2.getStylesheet();
500         if (!(ostylesheet instanceof javax.xml.crypto.dom.DOMStructure)) {
501             return false;
502         }
503         Node ostylesheetElem =
504             ((javax.xml.crypto.dom.DOMStructure) ostylesheet).getNode();
505         XMLStructure stylesheet = spec1.getStylesheet();
506         Node stylesheetElem =
507             ((javax.xml.crypto.dom.DOMStructure) stylesheet).getNode();
508         return nodesEqual(stylesheetElem, ostylesheetElem);
509     }
510 
511     public static boolean isNamespace(Node node)
512     {
513         final short nodeType = node.getNodeType();
514         if (nodeType == Node.ATTRIBUTE_NODE) {
515             final String namespaceURI = node.getNamespaceURI();
516             return XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(namespaceURI);
517         }
518         return false;
519     }
520 }
    </pre>
  </body>
</html>
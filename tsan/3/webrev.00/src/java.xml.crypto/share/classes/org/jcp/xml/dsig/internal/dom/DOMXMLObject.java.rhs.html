<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml.crypto/share/classes/org/jcp/xml/dsig/internal/dom/DOMXMLObject.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 /*
<a name="1" id="anc1"></a><span class="line-modified"> 24  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
 25  */
 26 /*
<a name="2" id="anc2"></a><span class="line-modified"> 27  * $Id: DOMXMLObject.java 1854026 2019-02-21 09:30:01Z coheigea $</span>
 28  */
 29 package org.jcp.xml.dsig.internal.dom;
 30 
 31 import javax.xml.crypto.*;
 32 import javax.xml.crypto.dom.DOMCryptoContext;
 33 import javax.xml.crypto.dsig.*;
 34 
 35 import java.security.Provider;
 36 import java.util.*;
 37 
 38 import org.w3c.dom.Attr;
 39 import org.w3c.dom.Document;
 40 import org.w3c.dom.Element;
 41 import org.w3c.dom.NamedNodeMap;
 42 import org.w3c.dom.Node;
 43 
 44 /**
 45  * DOM-based implementation of XMLObject.
 46  *
 47  */
 48 public final class DOMXMLObject extends DOMStructure implements XMLObject {
 49 
 50     private final String id;
 51     private final String mimeType;
 52     private final String encoding;
 53     private final List&lt;XMLStructure&gt; content;
 54     private Element objectElem;
 55 
 56     /**
 57      * Creates an {@code XMLObject} from the specified parameters.
 58      *
 59      * @param content a list of {@link XMLStructure}s. The list
 60      *    is defensively copied to protect against subsequent modification.
 61      *    May be {@code null} or empty.
 62      * @param id the Id (may be {@code null})
 63      * @param mimeType the mime type (may be {@code null})
 64      * @param encoding the encoding (may be {@code null})
 65      * @throws ClassCastException if {@code content} contains any
 66      *    entries that are not of type {@link XMLStructure}
 67      */
 68     public DOMXMLObject(List&lt;? extends XMLStructure&gt; content, String id,
 69                         String mimeType, String encoding)
 70     {
 71         if (content == null || content.isEmpty()) {
 72             this.content = Collections.emptyList();
 73         } else {
 74             this.content = Collections.unmodifiableList(
 75                 new ArrayList&lt;&gt;(content));
 76             for (int i = 0, size = this.content.size(); i &lt; size; i++) {
 77                 if (!(this.content.get(i) instanceof XMLStructure)) {
 78                     throw new ClassCastException
 79                         (&quot;content[&quot;+i+&quot;] is not a valid type&quot;);
 80                 }
 81             }
 82         }
 83         this.id = id;
 84         this.mimeType = mimeType;
 85         this.encoding = encoding;
 86     }
 87 
 88     /**
 89      * Creates an {@code XMLObject} from an element.
 90      *
 91      * @param objElem an Object element
 92      * @throws MarshalException if there is an error when unmarshalling
 93      */
 94     public DOMXMLObject(Element objElem, XMLCryptoContext context,
 95                         Provider provider)
 96     throws MarshalException
 97     {
 98         // unmarshal attributes
 99         this.encoding = DOMUtils.getAttributeValue(objElem, &quot;Encoding&quot;);
100 
101         Attr attr = objElem.getAttributeNodeNS(null, &quot;Id&quot;);
102         if (attr != null) {
103             this.id = attr.getValue();
104             objElem.setIdAttributeNode(attr, true);
105         } else {
106             this.id = null;
107         }
108         this.mimeType = DOMUtils.getAttributeValue(objElem, &quot;MimeType&quot;);
109 
110         List&lt;XMLStructure&gt; newContent = new ArrayList&lt;&gt;();
111         Node firstChild = objElem.getFirstChild();
112         while (firstChild != null) {
113             if (firstChild.getNodeType() == Node.ELEMENT_NODE) {
114                 Element childElem = (Element)firstChild;
115                 String tag = childElem.getLocalName();
116                 String namespace = childElem.getNamespaceURI();
117                 if (&quot;Manifest&quot;.equals(tag) &amp;&amp; XMLSignature.XMLNS.equals(namespace)) {
118                     newContent.add(new DOMManifest(childElem, context, provider));
119                 } else if (&quot;SignatureProperties&quot;.equals(tag) &amp;&amp; XMLSignature.XMLNS.equals(namespace)) {
120                     newContent.add(new DOMSignatureProperties(childElem));
121                 } else if (&quot;X509Data&quot;.equals(tag) &amp;&amp; XMLSignature.XMLNS.equals(namespace)) {
122                     newContent.add(new DOMX509Data(childElem));
123                 } else {
124                     //@@@FIXME: check for other dsig structures
125                     newContent.add(new javax.xml.crypto.dom.DOMStructure(firstChild));
126                 }
127             } else {
128                 newContent.add(new javax.xml.crypto.dom.DOMStructure(firstChild));
129             }
130             firstChild = firstChild.getNextSibling();
131         }
132 
133         // Here we capture namespace declarations, so that when they&#39;re marshalled back
134         // out, we can make copies of them. Note that attributes are NOT captured.
135         NamedNodeMap nnm = objElem.getAttributes();
136         for (int idx = 0 ; idx &lt; nnm.getLength() ; idx++) {
137             Node nsDecl = nnm.item(idx);
138             if (DOMUtils.isNamespace(nsDecl)) {
139                 newContent.add(new javax.xml.crypto.dom.DOMStructure(nsDecl));
140             }
141         }
142 
143         if (newContent.isEmpty()) {
144             this.content = Collections.emptyList();
145         } else {
146             this.content = Collections.unmodifiableList(newContent);
147         }
148         this.objectElem = objElem;
149     }
150 
151     public List&lt;XMLStructure&gt; getContent() {
152         return content;
153     }
154 
155     public String getId() {
156         return id;
157     }
158 
159     public String getMimeType() {
160         return mimeType;
161     }
162 
163     public String getEncoding() {
164         return encoding;
165     }
166 
167     @Override
168     public void marshal(Node parent, String dsPrefix, DOMCryptoContext context)
169         throws MarshalException {
170         Document ownerDoc = DOMUtils.getOwnerDocument(parent);
171 
172         Element objElem = objectElem != null ? objectElem : null;
173         if (objElem == null) {
174             objElem = DOMUtils.createElement(ownerDoc, &quot;Object&quot;,
175                                              XMLSignature.XMLNS, dsPrefix);
176 
177             // set attributes
178             DOMUtils.setAttributeID(objElem, &quot;Id&quot;, id);
179             DOMUtils.setAttribute(objElem, &quot;MimeType&quot;, mimeType);
180             DOMUtils.setAttribute(objElem, &quot;Encoding&quot;, encoding);
181 
182             // create and append any elements and mixed content, if necessary
183             for (XMLStructure object : content) {
184                 if (object instanceof DOMStructure) {
185                     ((DOMStructure)object).marshal(objElem, dsPrefix, context);
186                 } else {
187                     javax.xml.crypto.dom.DOMStructure domObject =
188                         (javax.xml.crypto.dom.DOMStructure)object;
189                     DOMUtils.appendChild(objElem, domObject.getNode());
190                 }
191             }
192         }
193 
194         parent.appendChild(objElem);
195     }
196 
197     @SuppressWarnings(&quot;unchecked&quot;)
198     @Override
199     public boolean equals(Object o) {
200         if (this == o) {
201             return true;
202         }
203 
204         if (!(o instanceof XMLObject)) {
205             return false;
206         }
207         XMLObject oxo = (XMLObject)o;
208 
209         boolean idsEqual = id == null ? oxo.getId() == null
210                                        : id.equals(oxo.getId());
211         boolean encodingsEqual =
212             encoding == null ? oxo.getEncoding() == null
213                               : encoding.equals(oxo.getEncoding());
214         boolean mimeTypesEqual =
215             mimeType == null ? oxo.getMimeType() == null
216                               : mimeType.equals(oxo.getMimeType());
217 
218         return idsEqual &amp;&amp; encodingsEqual &amp;&amp; mimeTypesEqual &amp;&amp;
219                 equalsContent(oxo.getContent());
220     }
221 
222     @Override
223     public int hashCode() {
224         int result = 17;
225         if (id != null) {
226             result = 31 * result + id.hashCode();
227         }
228         if (encoding != null) {
229             result = 31 * result + encoding.hashCode();
230         }
231         if (mimeType != null) {
232             result = 31 * result + mimeType.hashCode();
233         }
234         result = 31 * result + content.hashCode();
235 
236         return result;
237     }
238 
239     private boolean equalsContent(List&lt;XMLStructure&gt; otherContent) {
240         if (content.size() != otherContent.size()) {
241             return false;
242         }
243         for (int i = 0, osize = otherContent.size(); i &lt; osize; i++) {
244             XMLStructure oxs = otherContent.get(i);
245             XMLStructure xs = content.get(i);
246             if (oxs instanceof javax.xml.crypto.dom.DOMStructure) {
247                 if (!(xs instanceof javax.xml.crypto.dom.DOMStructure)) {
248                     return false;
249                 }
250                 Node onode = ((javax.xml.crypto.dom.DOMStructure)oxs).getNode();
251                 Node node = ((javax.xml.crypto.dom.DOMStructure)xs).getNode();
252                 if (!DOMUtils.nodesEqual(node, onode)) {
253                     return false;
254                 }
255             } else {
256                 if (!(xs.equals(oxs))) {
257                     return false;
258                 }
259             }
260         }
261 
262         return true;
263     }
264 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
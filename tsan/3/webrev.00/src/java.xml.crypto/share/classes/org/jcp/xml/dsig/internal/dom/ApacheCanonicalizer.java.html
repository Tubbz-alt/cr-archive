<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml.crypto/share/classes/org/jcp/xml/dsig/internal/dom/ApacheCanonicalizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /**
  6  * Licensed to the Apache Software Foundation (ASF) under one
  7  * or more contributor license agreements. See the NOTICE file
  8  * distributed with this work for additional information
  9  * regarding copyright ownership. The ASF licenses this file
 10  * to you under the Apache License, Version 2.0 (the
 11  * &quot;License&quot;); you may not use this file except in compliance
 12  * with the License. You may obtain a copy of the License at
 13  *
 14  * http://www.apache.org/licenses/LICENSE-2.0
 15  *
 16  * Unless required by applicable law or agreed to in writing,
 17  * software distributed under the License is distributed on an
 18  * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 19  * KIND, either express or implied. See the License for the
 20  * specific language governing permissions and limitations
 21  * under the License.
 22  */
 23 /*
 24  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
 25  */
 26 /*
 27  * $Id: ApacheCanonicalizer.java 1854026 2019-02-21 09:30:01Z coheigea $
 28  */
 29 package org.jcp.xml.dsig.internal.dom;
 30 
 31 import java.io.ByteArrayInputStream;
 32 import java.io.ByteArrayOutputStream;
 33 import java.io.OutputStream;
 34 import java.security.spec.AlgorithmParameterSpec;
 35 import java.security.InvalidAlgorithmParameterException;
 36 import java.util.Set;
 37 
 38 import javax.xml.crypto.*;
 39 import javax.xml.crypto.dom.DOMCryptoContext;
 40 import javax.xml.crypto.dsig.TransformException;
 41 import javax.xml.crypto.dsig.TransformService;
 42 import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;
 43 
 44 import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
 45 import com.sun.org.apache.xml.internal.security.c14n.InvalidCanonicalizerException;
 46 import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
 47 import com.sun.org.apache.xml.internal.security.transforms.Transform;
 48 import org.w3c.dom.Document;
 49 import org.w3c.dom.Element;
 50 import org.w3c.dom.Node;
 51 
 52 public abstract class ApacheCanonicalizer extends TransformService {
 53 
 54     static {
 55         com.sun.org.apache.xml.internal.security.Init.init();
 56     }
 57 
 58     private static final com.sun.org.slf4j.internal.Logger LOG =
 59         com.sun.org.slf4j.internal.LoggerFactory.getLogger(ApacheCanonicalizer.class);
 60     protected Canonicalizer apacheCanonicalizer;
 61     private Transform apacheTransform;
 62     protected String inclusiveNamespaces;
 63     protected C14NMethodParameterSpec params;
 64     protected Document ownerDoc;
 65     protected Element transformElem;
 66 
 67     public final AlgorithmParameterSpec getParameterSpec()
 68     {
 69         return params;
 70     }
 71 
 72     public void init(XMLStructure parent, XMLCryptoContext context)
 73         throws InvalidAlgorithmParameterException
 74     {
 75         if (context != null &amp;&amp; !(context instanceof DOMCryptoContext)) {
 76             throw new ClassCastException
 77                 (&quot;context must be of type DOMCryptoContext&quot;);
 78         }
 79         if (parent == null) {
 80             throw new NullPointerException();
 81         }
 82         if (!(parent instanceof javax.xml.crypto.dom.DOMStructure)) {
 83             throw new ClassCastException(&quot;parent must be of type DOMStructure&quot;);
 84         }
 85         transformElem = (Element)
 86             ((javax.xml.crypto.dom.DOMStructure)parent).getNode();
 87         ownerDoc = DOMUtils.getOwnerDocument(transformElem);
 88     }
 89 
 90     public void marshalParams(XMLStructure parent, XMLCryptoContext context)
 91         throws MarshalException
 92     {
 93         if (context != null &amp;&amp; !(context instanceof DOMCryptoContext)) {
 94             throw new ClassCastException
 95                 (&quot;context must be of type DOMCryptoContext&quot;);
 96         }
 97         if (parent == null) {
 98             throw new NullPointerException();
 99         }
100         if (!(parent instanceof javax.xml.crypto.dom.DOMStructure)) {
101             throw new ClassCastException(&quot;parent must be of type DOMStructure&quot;);
102         }
103         transformElem = (Element)
104             ((javax.xml.crypto.dom.DOMStructure)parent).getNode();
105         ownerDoc = DOMUtils.getOwnerDocument(transformElem);
106     }
107 
108     public Data canonicalize(Data data, XMLCryptoContext xc)
109         throws TransformException
110     {
111         return canonicalize(data, xc, null);
112     }
113 
114     public Data canonicalize(Data data, XMLCryptoContext xc, OutputStream os)
115         throws TransformException
116     {
117         if (apacheCanonicalizer == null) {
118             try {
119                 apacheCanonicalizer = Canonicalizer.getInstance(getAlgorithm());
120                 boolean secVal = Utils.secureValidation(xc);
121                 apacheCanonicalizer.setSecureValidation(secVal);
122                 LOG.debug(&quot;Created canonicalizer for algorithm: {}&quot;, getAlgorithm());
123             } catch (InvalidCanonicalizerException ice) {
124                 throw new TransformException
125                     (&quot;Couldn&#39;t find Canonicalizer for: &quot; + getAlgorithm() +
126                      &quot;: &quot; + ice.getMessage(), ice);
127             }
128         }
129 
130         if (os != null) {
131             apacheCanonicalizer.setWriter(os);
132         } else {
133             apacheCanonicalizer.setWriter(new ByteArrayOutputStream());
134         }
135 
136         try {
137             Set&lt;Node&gt; nodeSet = null;
138             if (data instanceof ApacheData) {
139                 XMLSignatureInput in =
140                     ((ApacheData)data).getXMLSignatureInput();
141                 if (in.isElement()) {
142                     if (inclusiveNamespaces != null) {
143                         return new OctetStreamData(new ByteArrayInputStream
144                             (apacheCanonicalizer.canonicalizeSubtree
145                                 (in.getSubNode(), inclusiveNamespaces)));
146                     } else {
147                         return new OctetStreamData(new ByteArrayInputStream
148                             (apacheCanonicalizer.canonicalizeSubtree
149                                 (in.getSubNode())));
150                     }
151                 } else if (in.isNodeSet()) {
152                     nodeSet = in.getNodeSet();
153                 } else {
154                     return new OctetStreamData(new ByteArrayInputStream(
155                         apacheCanonicalizer.canonicalize(
156                             Utils.readBytesFromStream(in.getOctetStream()))));
157                 }
158             } else if (data instanceof DOMSubTreeData) {
159                 DOMSubTreeData subTree = (DOMSubTreeData)data;
160                 if (inclusiveNamespaces != null) {
161                     return new OctetStreamData(new ByteArrayInputStream
162                         (apacheCanonicalizer.canonicalizeSubtree
163                          (subTree.getRoot(), inclusiveNamespaces)));
164                 } else {
165                     return new OctetStreamData(new ByteArrayInputStream
166                         (apacheCanonicalizer.canonicalizeSubtree
167                          (subTree.getRoot())));
168                 }
169             } else if (data instanceof NodeSetData) {
170                 NodeSetData&lt;?&gt; nsd = (NodeSetData&lt;?&gt;)data;
171                 // convert Iterator to Set
172                 nodeSet = Utils.toNodeSet(nsd.iterator());
173                 LOG.debug(&quot;Canonicalizing {} nodes&quot;, nodeSet.size());
174             } else {
175                 return new OctetStreamData(new ByteArrayInputStream(
176                     apacheCanonicalizer.canonicalize(
177                         Utils.readBytesFromStream(
178                         ((OctetStreamData)data).getOctetStream()))));
179             }
180             if (inclusiveNamespaces != null) {
181                 return new OctetStreamData(new ByteArrayInputStream(
182                     apacheCanonicalizer.canonicalizeXPathNodeSet
183                         (nodeSet, inclusiveNamespaces)));
184             } else {
185                 return new OctetStreamData(new ByteArrayInputStream(
186                     apacheCanonicalizer.canonicalizeXPathNodeSet(nodeSet)));
187             }
188         } catch (Exception e) {
189             throw new TransformException(e);
190         }
191     }
192 
193     public Data transform(Data data, XMLCryptoContext xc, OutputStream os)
194         throws TransformException
195     {
196         if (data == null) {
197             throw new NullPointerException(&quot;data must not be null&quot;);
198         }
199         if (os == null) {
200             throw new NullPointerException(&quot;output stream must not be null&quot;);
201         }
202 
203         if (ownerDoc == null) {
204             throw new TransformException(&quot;transform must be marshalled&quot;);
205         }
206 
207         if (apacheTransform == null) {
208             try {
209                 apacheTransform =
210                     new Transform(ownerDoc, getAlgorithm(), transformElem.getChildNodes());
211                 apacheTransform.setElement(transformElem, xc.getBaseURI());
212                 boolean secVal = Utils.secureValidation(xc);
213                 apacheTransform.setSecureValidation(secVal);
214                 LOG.debug(&quot;Created transform for algorithm: {}&quot;, getAlgorithm());
215             } catch (Exception ex) {
216                 throw new TransformException
217                     (&quot;Couldn&#39;t find Transform for: &quot; + getAlgorithm(), ex);
218             }
219         }
220 
221         XMLSignatureInput in;
222         if (data instanceof ApacheData) {
223             LOG.debug(&quot;ApacheData = true&quot;);
224             in = ((ApacheData)data).getXMLSignatureInput();
225         } else if (data instanceof NodeSetData) {
226             LOG.debug(&quot;isNodeSet() = true&quot;);
227             if (data instanceof DOMSubTreeData) {
228                 DOMSubTreeData subTree = (DOMSubTreeData)data;
229                 in = new XMLSignatureInput(subTree.getRoot());
230                 in.setExcludeComments(subTree.excludeComments());
231             } else {
232                 @SuppressWarnings(&quot;unchecked&quot;)
233                 Set&lt;Node&gt; nodeSet =
234                     Utils.toNodeSet(((NodeSetData)data).iterator());
235                 in = new XMLSignatureInput(nodeSet);
236             }
237         } else {
238             LOG.debug(&quot;isNodeSet() = false&quot;);
239             try {
240                 in = new XMLSignatureInput
241                     (((OctetStreamData)data).getOctetStream());
242             } catch (Exception ex) {
243                 throw new TransformException(ex);
244             }
245         }
246 
247         boolean secVal = Utils.secureValidation(xc);
248         in.setSecureValidation(secVal);
249 
250         try {
251             in = apacheTransform.performTransform(in, os);
252             if (!in.isNodeSet() &amp;&amp; !in.isElement()) {
253                 return null;
254             }
255             if (in.isOctetStream()) {
256                 return new ApacheOctetStreamData(in);
257             } else {
258                 return new ApacheNodeSetData(in);
259             }
260         } catch (Exception ex) {
261             throw new TransformException(ex);
262         }
263     }
264 
265     public final boolean isFeatureSupported(String feature) {
266         if (feature == null) {
267             throw new NullPointerException();
268         } else {
269             return false;
270         }
271     }
272 }
    </pre>
  </body>
</html>
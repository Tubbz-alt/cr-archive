<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.sql.rowset/share/classes/com/sun/rowset/CachedRowSetImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 /*
<a name="1" id="anc1"></a><span class="line-modified">    2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
    3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4  *
    5  * This code is free software; you can redistribute it and/or modify it
    6  * under the terms of the GNU General Public License version 2 only, as
    7  * published by the Free Software Foundation.  Oracle designates this
    8  * particular file as subject to the &quot;Classpath&quot; exception as provided
    9  * by Oracle in the LICENSE file that accompanied this code.
   10  *
   11  * This code is distributed in the hope that it will be useful, but WITHOUT
   12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   14  * version 2 for more details (a copy is included in the LICENSE file that
   15  * accompanied this code).
   16  *
   17  * You should have received a copy of the GNU General Public License version
   18  * 2 along with this work; if not, write to the Free Software Foundation,
   19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   20  *
   21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   22  * or visit www.oracle.com if you need additional information or have any
   23  * questions.
   24  */
   25 
   26 package com.sun.rowset;
   27 
   28 import java.sql.*;
   29 import javax.sql.*;
   30 import java.io.*;
   31 import java.math.*;
   32 import java.util.*;
   33 import java.text.*;
   34 import java.security.AccessController;
   35 import java.security.PrivilegedActionException;
   36 import java.security.PrivilegedExceptionAction;
   37 
   38 import javax.sql.rowset.*;
   39 import javax.sql.rowset.spi.*;
   40 import javax.sql.rowset.serial.*;
   41 import com.sun.rowset.internal.*;
   42 import com.sun.rowset.providers.*;
   43 import sun.reflect.misc.ReflectUtil;
   44 
<a name="2" id="anc2"></a><span class="line-added">   45 import static java.nio.charset.StandardCharsets.US_ASCII;</span>
<span class="line-added">   46 </span>
   47 /**
   48  * The standard implementation of the &lt;code&gt;CachedRowSet&lt;/code&gt; interface.
   49  *
   50  * See interface definition for full behavior and implementation requirements.
   51  * This reference implementation has made provision for a one-to-one write back
   52  * facility and it is curremtly be possible to change the peristence provider
   53  * during the life-time of any CachedRowSetImpl.
   54  *
   55  * @author Jonathan Bruce, Amit Handa
   56  */
   57 
   58 public class CachedRowSetImpl extends BaseRowSet implements RowSet, RowSetInternal, Serializable, Cloneable, CachedRowSet {
   59 
   60     /**
   61      * The &lt;code&gt;SyncProvider&lt;/code&gt; used by the CachedRowSet
   62      */
   63     private SyncProvider provider;
   64 
   65     /**
   66      * The &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object that is the reader
   67      * for this rowset.  The method &lt;code&gt;execute&lt;/code&gt; uses this
   68      * reader as part of its implementation.
   69      * @serial
   70      */
   71     private RowSetReader rowSetReader;
   72 
   73     /**
   74      * The &lt;code&gt;RowSetWriterImpl&lt;/code&gt; object that is the writer
   75      * for this rowset.  The method &lt;code&gt;acceptChanges&lt;/code&gt; uses
   76      * this writer as part of its implementation.
   77      * @serial
   78      */
   79     private RowSetWriter rowSetWriter;
   80 
   81     /**
   82      * The &lt;code&gt;Connection&lt;/code&gt; object that connects with this
   83      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s current underlying data source.
   84      */
   85     private transient Connection conn;
   86 
   87     /**
   88      * The &lt;code&gt;ResultSetMetaData&lt;/code&gt; object that contains information
   89      * about the columns in the &lt;code&gt;ResultSet&lt;/code&gt; object that is the
   90      * current source of data for this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.
   91      */
   92     private transient ResultSetMetaData RSMD;
   93 
   94     /**
   95      * The &lt;code&gt;RowSetMetaData&lt;/code&gt; object that contains information about
   96      * the columns in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.
   97      * @serial
   98      */
   99     private RowSetMetaDataImpl RowSetMD;
  100 
  101     // Properties of this RowSet
  102 
  103     /**
  104      * An array containing the columns in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
  105      * object that form a unique identifier for a row. This array
  106      * is used by the writer.
  107      * @serial
  108      */
  109     private int keyCols[];
  110 
  111     /**
  112      * The name of the table in the underlying database to which updates
  113      * should be written.  This name is needed because most drivers
  114      * do not return this information in a &lt;code&gt;ResultSetMetaData&lt;/code&gt;
  115      * object.
  116      * @serial
  117      */
  118     private String tableName;
  119 
  120     /**
  121      * A &lt;code&gt;Vector&lt;/code&gt; object containing the &lt;code&gt;Row&lt;/code&gt;
  122      * objects that comprise  this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.
  123      * @serial
  124      */
  125     private Vector&lt;Object&gt; rvh;
  126 
  127     /**
  128      * The current position of the cursor in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
  129      * object.
  130      * @serial
  131      */
  132     private int cursorPos;
  133 
  134     /**
  135      * The current position of the cursor in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
  136      * object not counting rows that have been deleted, if any.
  137      * &lt;P&gt;
  138      * For example, suppose that the cursor is on the last row of a rowset
  139      * that started with five rows and subsequently had the second and third
  140      * rows deleted. The &lt;code&gt;absolutePos&lt;/code&gt; would be &lt;code&gt;3&lt;/code&gt;,
  141      * whereas the &lt;code&gt;cursorPos&lt;/code&gt; would be &lt;code&gt;5&lt;/code&gt;.
  142      * @serial
  143      */
  144     private int absolutePos;
  145 
  146     /**
  147      * The number of deleted rows currently in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
  148      * object.
  149      * @serial
  150      */
  151     private int numDeleted;
  152 
  153     /**
  154      * The total number of rows currently in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
  155      * object.
  156      * @serial
  157      */
  158     private int numRows;
  159 
  160     /**
  161      * A special row used for constructing a new row. A new
  162      * row is constructed by using &lt;code&gt;ResultSet.updateXXX&lt;/code&gt;
  163      * methods to insert column values into the insert row.
  164      * @serial
  165      */
  166     private InsertRow insertRow;
  167 
  168     /**
  169      * A &lt;code&gt;boolean&lt;/code&gt; indicating whether the cursor is
  170      * currently on the insert row.
  171      * @serial
  172      */
  173     private boolean onInsertRow;
  174 
  175     /**
  176      * The field that temporarily holds the last position of the
  177      * cursor before it moved to the insert row, thus preserving
  178      * the number of the current row to which the cursor may return.
  179      * @serial
  180      */
  181     private int currentRow;
  182 
  183     /**
  184      * A &lt;code&gt;boolean&lt;/code&gt; indicating whether the last value
  185      * returned was an SQL &lt;code&gt;NULL&lt;/code&gt;.
  186      * @serial
  187      */
  188     private boolean lastValueNull;
  189 
  190     /**
  191      * A &lt;code&gt;SQLWarning&lt;/code&gt; which logs on the warnings
  192      */
  193     private SQLWarning sqlwarn;
  194 
  195     /**
  196      * Used to track match column for JoinRowSet consumption
  197      */
  198     private String strMatchColumn =&quot;&quot;;
  199 
  200     /**
  201      * Used to track match column for JoinRowSet consumption
  202      */
  203     private int iMatchColumn = -1;
  204 
  205     /**
  206      * A &lt;code&gt;RowSetWarning&lt;/code&gt; which logs on the warnings
  207      */
  208     private RowSetWarning rowsetWarning;
  209 
  210     /**
  211      * The default SyncProvider for the RI CachedRowSetImpl
  212      */
  213     private String DEFAULT_SYNC_PROVIDER = &quot;com.sun.rowset.providers.RIOptimisticProvider&quot;;
  214 
  215     /**
  216      * The boolean variable indicating locatorsUpdateValue
  217      */
  218     private boolean dbmslocatorsUpdateCopy;
  219 
  220     /**
  221      * The &lt;code&gt;ResultSet&lt;/code&gt; object that is used to maintain the data when
  222      * a ResultSet and start position are passed as parameters to the populate function
  223      */
  224     private transient ResultSet resultSet;
  225 
  226     /**
  227      * The integer value indicating the end position in the ResultSetwhere the picking
  228      * up of rows for populating a CachedRowSet object was left off.
  229      */
  230     private int endPos;
  231 
  232     /**
  233      * The integer value indicating the end position in the ResultSetwhere the picking
  234      * up of rows for populating a CachedRowSet object was left off.
  235      */
  236     private int prevEndPos;
  237 
  238     /**
  239      * The integer value indicating the position in the ResultSet, to populate the
  240      * CachedRowSet object.
  241      */
  242     private int startPos;
  243 
  244     /**
  245      * The integer value indicating the position from where the page prior to this
  246      * was populated.
  247      */
  248     private int startPrev;
  249 
  250     /**
  251      * The integer value indicating size of the page.
  252      */
  253     private int pageSize;
  254 
  255     /**
  256      * The integer value indicating number of rows that have been processed so far.
  257      * Used for checking whether maxRows has been reached or not.
  258      */
  259     private int maxRowsreached;
  260     /**
  261      * The boolean value when true signifies that pages are still to follow and a
  262      * false value indicates that this is the last page.
  263      */
  264     private boolean pagenotend = true;
  265 
  266     /**
  267      * The boolean value indicating whether this is the first page or not.
  268      */
  269     private boolean onFirstPage;
  270 
  271     /**
  272      * The boolean value indicating whether this is the last page or not.
  273      */
  274     private boolean onLastPage;
  275 
  276     /**
  277      * The integer value indicating how many times the populate function has been called.
  278      */
  279     private int populatecallcount;
  280 
  281     /**
  282      * The integer value indicating the total number of rows to be processed in the
  283      * ResultSet object passed to the populate function.
  284      */
  285     private int totalRows;
  286 
  287     /**
  288      * The boolean value indicating how the CahedRowSet object has been populated for
  289      * paging purpose. True indicates that connection parameter is passed.
  290      */
  291     private boolean callWithCon;
  292 
  293     /**
  294      * CachedRowSet reader object to read the data from the ResultSet when a connection
  295      * parameter is passed to populate the CachedRowSet object for paging.
  296      */
  297     private CachedRowSetReader crsReader;
  298 
  299     /**
  300      * The Vector holding the Match Columns
  301      */
  302     private Vector&lt;Integer&gt; iMatchColumns;
  303 
  304     /**
  305      * The Vector that will hold the Match Column names.
  306      */
  307     private Vector&lt;String&gt; strMatchColumns;
  308 
  309     /**
  310      * Trigger that indicates whether the active SyncProvider is exposes the
  311      * additional TransactionalWriter method
  312      */
  313     private boolean tXWriter = false;
  314 
  315     /**
  316      * The field object for a transactional RowSet writer
  317      */
  318     private TransactionalWriter tWriter = null;
  319 
  320     protected transient JdbcRowSetResourceBundle resBundle;
  321 
  322     private boolean updateOnInsert;
  323 
  324 
  325 
  326     /**
  327      * Constructs a new default &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with
  328      * the capacity to hold 100 rows. This new object has no metadata
  329      * and has the following default values:
  330      * &lt;pre&gt;
  331      *     onInsertRow = false
  332      *     insertRow = null
  333      *     cursorPos = 0
  334      *     numRows = 0
  335      *     showDeleted = false
  336      *     queryTimeout = 0
  337      *     maxRows = 0
  338      *     maxFieldSize = 0
  339      *     rowSetType = ResultSet.TYPE_SCROLL_INSENSITIVE
  340      *     concurrency = ResultSet.CONCUR_UPDATABLE
  341      *     readOnly = false
  342      *     isolation = Connection.TRANSACTION_READ_COMMITTED
  343      *     escapeProcessing = true
  344      *     onInsertRow = false
  345      *     insertRow = null
  346      *     cursorPos = 0
  347      *     absolutePos = 0
  348      *     numRows = 0
  349      * &lt;/pre&gt;
  350      * A &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object is configured to use the default
  351      * &lt;code&gt;RIOptimisticProvider&lt;/code&gt; implementation to provide connectivity
  352      * and synchronization capabilities to the set data source.
  353      * &lt;P&gt;
  354      * @throws SQLException if an error occurs
  355      */
  356     public CachedRowSetImpl() throws SQLException {
  357 
  358         try {
  359            resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();
  360         } catch(IOException ioe) {
  361             throw new RuntimeException(ioe);
  362         }
  363 
  364         // set the Reader, this maybe overridden latter
  365         try {
  366             provider = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;&gt;() {
  367                 @Override
  368                 public SyncProvider run() throws SyncFactoryException {
  369                     return SyncFactory.getInstance(DEFAULT_SYNC_PROVIDER);
  370                 }
  371             }, null, new RuntimePermission(&quot;accessClassInPackage.com.sun.rowset.providers&quot;));
  372         } catch (PrivilegedActionException pae) {
  373             throw (SyncFactoryException) pae.getException();
  374         }
  375 
  376         if (!(provider instanceof RIOptimisticProvider)) {
  377             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidp&quot;).toString());
  378         }
  379 
  380         rowSetReader = (CachedRowSetReader)provider.getRowSetReader();
  381         rowSetWriter = (CachedRowSetWriter)provider.getRowSetWriter();
  382 
  383         // allocate the parameters collection
  384         initParams();
  385 
  386         initContainer();
  387 
  388         // set up some default values
  389         initProperties();
  390 
  391         // insert row setup
  392         onInsertRow = false;
  393         insertRow = null;
  394 
  395         // set the warninings
  396         sqlwarn = new SQLWarning();
  397         rowsetWarning = new RowSetWarning();
  398 
  399     }
  400 
  401     /**
  402      * Provides a &lt;code&gt;CachedRowSetImpl&lt;/code&gt; instance with the same default properties as
  403      * as the zero parameter constructor.
  404      * &lt;pre&gt;
  405      *     onInsertRow = false
  406      *     insertRow = null
  407      *     cursorPos = 0
  408      *     numRows = 0
  409      *     showDeleted = false
  410      *     queryTimeout = 0
  411      *     maxRows = 0
  412      *     maxFieldSize = 0
  413      *     rowSetType = ResultSet.TYPE_SCROLL_INSENSITIVE
  414      *     concurrency = ResultSet.CONCUR_UPDATABLE
  415      *     readOnly = false
  416      *     isolation = Connection.TRANSACTION_READ_COMMITTED
  417      *     escapeProcessing = true
  418      *     onInsertRow = false
  419      *     insertRow = null
  420      *     cursorPos = 0
  421      *     absolutePos = 0
  422      *     numRows = 0
  423      * &lt;/pre&gt;
  424      *
  425      * However, applications will have the means to specify at runtime the
  426      * desired &lt;code&gt;SyncProvider&lt;/code&gt; object.
  427      * &lt;p&gt;
  428      * For example, creating a &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as follows ensures
  429      * that a it is established with the &lt;code&gt;com.foo.provider.Impl&lt;/code&gt; synchronization
  430      * implementation providing the synchronization mechanism for this disconnected
  431      * &lt;code&gt;RowSet&lt;/code&gt; object.
  432      * &lt;pre&gt;
  433      *     Hashtable env = new Hashtable();
  434      *     env.put(javax.sql.rowset.spi.SyncFactory.ROWSET_PROVIDER_NAME,
  435      *         &quot;com.foo.provider.Impl&quot;);
  436      *     CachedRowSetImpl crs = new CachedRowSet(env);
  437      * &lt;/pre&gt;
  438      * &lt;p&gt;
  439      * Calling this constructor with a &lt;code&gt;null&lt;/code&gt; parameter will
  440      * cause the &lt;code&gt;SyncFactory&lt;/code&gt; to provide the reference
  441      * optimistic provider &lt;code&gt;com.sun.rowset.providers.RIOptimisticProvider&lt;/code&gt;.
  442      * &lt;p&gt;
  443      * In addition, the following properties can be associated with the
  444      * provider to assist in determining the choice of the synchronizaton
  445      * provider such as:
  446      * &lt;ul&gt;
  447      * &lt;li&gt;&lt;code&gt;ROWSET_SYNC_PROVIDER&lt;/code&gt; - the property specifying the
  448      * &lt;code&gt;SyncProvider&lt;/code&gt; class name to be instantiated by the
  449      * &lt;code&gt;SyncFacttory&lt;/code&gt;
  450      * &lt;li&gt;&lt;code&gt;ROWSET_SYNC_VENDOR&lt;/code&gt; - the property specifying the software
  451      * vendor associated with a &lt;code&gt;SyncProvider&lt;/code&gt; implementation.
  452      * &lt;li&gt;&lt;code&gt;ROWSET_SYNC_PROVIDER_VER&lt;/code&gt; - the property specifying the
  453      * version of the &lt;code&gt;SyncProvider&lt;/code&gt; implementation provided by the
  454      * software vendor.
  455      * &lt;/ul&gt;
  456      * More specific detailes are available in the &lt;code&gt;SyncFactory&lt;/code&gt;
  457      * and &lt;code&gt;SyncProvider&lt;/code&gt; specificiations later in this document.
  458      * &lt;p&gt;
  459      * @param env a &lt;code&gt;Hashtable&lt;/code&gt; object with a list of desired
  460      *        synchronization providers
  461      * @throws SQLException if the requested provider cannot be found by the
  462      * synchronization factory
  463      * @see SyncProvider
  464      */
  465     public CachedRowSetImpl(@SuppressWarnings(&quot;rawtypes&quot;) Hashtable env) throws SQLException {
  466 
  467 
  468         try {
  469            resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();
  470         } catch(IOException ioe) {
  471             throw new RuntimeException(ioe);
  472         }
  473 
  474         if (env == null) {
  475             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.nullhash&quot;).toString());
  476         }
  477 
  478         String providerName = (String)env.get(
  479         javax.sql.rowset.spi.SyncFactory.ROWSET_SYNC_PROVIDER);
  480 
  481         // set the Reader, this maybe overridden latter
  482         provider =
  483         SyncFactory.getInstance(providerName);
  484 
  485         rowSetReader = provider.getRowSetReader();
  486         rowSetWriter = provider.getRowSetWriter();
  487 
  488         initParams(); // allocate the parameters collection
  489         initContainer();
  490         initProperties(); // set up some default values
  491     }
  492 
  493     /**
  494      * Sets the &lt;code&gt;rvh&lt;/code&gt; field to a new &lt;code&gt;Vector&lt;/code&gt;
  495      * object with a capacity of 100 and sets the
  496      * &lt;code&gt;cursorPos&lt;/code&gt; and &lt;code&gt;numRows&lt;/code&gt; fields to zero.
  497      */
  498     private void initContainer() {
  499 
  500         rvh = new Vector&lt;Object&gt;(100);
  501         cursorPos = 0;
  502         absolutePos = 0;
  503         numRows = 0;
  504         numDeleted = 0;
  505     }
  506 
  507     /**
  508      * Sets the properties for this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object to
  509      * their default values. This method is called internally by the
  510      * default constructor.
  511      */
  512 
  513     private void initProperties() throws SQLException {
  514 
  515         if(resBundle == null) {
  516             try {
  517                resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();
  518             } catch(IOException ioe) {
  519                 throw new RuntimeException(ioe);
  520             }
  521         }
  522         setShowDeleted(false);
  523         setQueryTimeout(0);
  524         setMaxRows(0);
  525         setMaxFieldSize(0);
  526         setType(ResultSet.TYPE_SCROLL_INSENSITIVE);
  527         setConcurrency(ResultSet.CONCUR_UPDATABLE);
  528         if((rvh.size() &gt; 0) &amp;&amp; (isReadOnly() == false))
  529             setReadOnly(false);
  530         else
  531             setReadOnly(true);
  532         setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
  533         setEscapeProcessing(true);
  534         //setTypeMap(null);
  535         checkTransactionalWriter();
  536 
  537         //Instantiating the vector for MatchColumns
  538 
  539         iMatchColumns = new Vector&lt;Integer&gt;(10);
  540         for(int i = 0; i &lt; 10 ; i++) {
  541            iMatchColumns.add(i, -1);
  542         }
  543 
  544         strMatchColumns = new Vector&lt;String&gt;(10);
  545         for(int j = 0; j &lt; 10; j++) {
  546            strMatchColumns.add(j,null);
  547         }
  548     }
  549 
  550     /**
  551      * Determine whether the SyncProvider&#39;s writer implements the
  552      * &lt;code&gt;TransactionalWriter&lt;code&gt; interface
  553      */
  554     private void checkTransactionalWriter() {
  555         if (rowSetWriter != null) {
  556             Class&lt;?&gt; c = rowSetWriter.getClass();
  557             if (c != null) {
  558                 Class&lt;?&gt;[] theInterfaces = c.getInterfaces();
  559                 for (int i = 0; i &lt; theInterfaces.length; i++) {
  560                     if ((theInterfaces[i].getName()).indexOf(&quot;TransactionalWriter&quot;) &gt; 0) {
  561                         tXWriter = true;
  562                         establishTransactionalWriter();
  563                     }
  564                 }
  565             }
  566         }
  567     }
  568 
  569     /**
  570      * Sets an private field to all transaction bounddaries to be set
  571      */
  572     private void establishTransactionalWriter() {
  573         tWriter = (TransactionalWriter)provider.getRowSetWriter();
  574     }
  575 
  576     //-----------------------------------------------------------------------
  577     // Properties
  578     //-----------------------------------------------------------------------
  579 
  580     /**
  581      * Sets this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s command property
  582      * to the given &lt;code&gt;String&lt;/code&gt; object and clears the parameters,
  583      * if any, that were set for the previous command.
  584      * &lt;P&gt;
  585      * The command property may not be needed
  586      * if the rowset is produced by a data source, such as a spreadsheet,
  587      * that does not support commands. Thus, this property is optional
  588      * and may be &lt;code&gt;null&lt;/code&gt;.
  589      *
  590      * @param cmd a &lt;code&gt;String&lt;/code&gt; object containing an SQL query
  591      *            that will be set as the command; may be &lt;code&gt;null&lt;/code&gt;
  592      * @throws SQLException if an error occurs
  593      */
  594     public void setCommand(String cmd) throws SQLException {
  595 
  596         super.setCommand(cmd);
  597 
  598         if(!buildTableName(cmd).isEmpty()) {
  599             this.setTableName(buildTableName(cmd));
  600         }
  601     }
  602 
  603 
  604     //---------------------------------------------------------------------
  605     // Reading and writing data
  606     //---------------------------------------------------------------------
  607 
  608     /**
  609      * Populates this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with data from
  610      * the given &lt;code&gt;ResultSet&lt;/code&gt; object.  This
  611      * method is an alternative to the method &lt;code&gt;execute&lt;/code&gt;
  612      * for filling the rowset with data.  The method &lt;code&gt;populate&lt;/code&gt;
  613      * does not require that the properties needed by the method
  614      * &lt;code&gt;execute&lt;/code&gt;, such as the &lt;code&gt;command&lt;/code&gt; property,
  615      * be set. This is true because the method &lt;code&gt;populate&lt;/code&gt;
  616      * is given the &lt;code&gt;ResultSet&lt;/code&gt; object from
  617      * which to get data and thus does not need to use the properties
  618      * required for setting up a connection and executing this
  619      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s command.
  620      * &lt;P&gt;
  621      * After populating this rowset with data, the method
  622      * &lt;code&gt;populate&lt;/code&gt; sets the rowset&#39;s metadata and
  623      * then sends a &lt;code&gt;RowSetChangedEvent&lt;/code&gt; object
  624      * to all registered listeners prior to returning.
  625      *
  626      * @param data the &lt;code&gt;ResultSet&lt;/code&gt; object containing the data
  627      *             to be read into this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
  628      * @throws SQLException if an error occurs; or the max row setting is
  629      *          violated while populating the RowSet
  630      * @see #execute
  631      */
  632 
  633      public void populate(ResultSet data) throws SQLException {
  634         int rowsFetched;
  635         Row currentRow;
  636         int numCols;
  637         int i;
  638         Map&lt;String, Class&lt;?&gt;&gt; map = getTypeMap();
  639         Object obj;
  640         int mRows;
  641 
  642         if (data == null) {
  643             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.populate&quot;).toString());
  644         }
  645         this.resultSet = data;
  646 
  647         // get the meta data for this ResultSet
  648         RSMD = data.getMetaData();
  649 
  650         // set up the metadata
  651         RowSetMD = new RowSetMetaDataImpl();
  652         initMetaData(RowSetMD, RSMD);
  653 
  654         // release the meta-data so that aren&#39;t tempted to use it.
  655         RSMD = null;
  656         numCols = RowSetMD.getColumnCount();
  657         mRows = this.getMaxRows();
  658         rowsFetched = 0;
  659         currentRow = null;
  660 
  661         while ( data.next()) {
  662 
  663             currentRow = new Row(numCols);
  664 
  665             if ( rowsFetched &gt; mRows &amp;&amp; mRows &gt; 0) {
  666                 rowsetWarning.setNextWarning(new RowSetWarning(&quot;Populating rows &quot;
  667                 + &quot;setting has exceeded max row setting&quot;));
  668             }
  669             for ( i = 1; i &lt;= numCols; i++) {
  670                 /*
  671                  * check if the user has set a map. If no map
  672                  * is set then use plain getObject. This lets
  673                  * us work with drivers that do not support
  674                  * getObject with a map in fairly sensible way
  675                  */
  676                 if (map == null || map.isEmpty()) {
  677                     obj = data.getObject(i);
  678                 } else {
  679                     obj = data.getObject(i, map);
  680                 }
  681                 /*
  682                  * the following block checks for the various
  683                  * types that we have to serialize in order to
  684                  * store - right now only structs have been tested
  685                  */
  686                 if (obj instanceof Struct) {
  687                     obj = new SerialStruct((Struct)obj, map);
  688                 } else if (obj instanceof SQLData) {
  689                     obj = new SerialStruct((SQLData)obj, map);
  690                 } else if (obj instanceof Blob) {
  691                     obj = new SerialBlob((Blob)obj);
  692                 } else if (obj instanceof Clob) {
  693                     obj = new SerialClob((Clob)obj);
  694                 } else if (obj instanceof java.sql.Array) {
  695                     if(map != null)
  696                         obj = new SerialArray((java.sql.Array)obj, map);
  697                     else
  698                         obj = new SerialArray((java.sql.Array)obj);
  699                 }
  700 
  701                 currentRow.initColumnObject(i, obj);
  702             }
  703             rowsFetched++;
  704             rvh.add(currentRow);
  705         }
  706 
  707         numRows = rowsFetched ;
  708         // Also rowsFetched should be equal to rvh.size()
  709 
  710         // notify any listeners that the rowset has changed
  711         notifyRowSetChanged();
  712 
  713 
  714     }
  715 
  716     /**
  717      * Initializes the given &lt;code&gt;RowSetMetaData&lt;/code&gt; object with the values
  718      * in the given &lt;code&gt;ResultSetMetaData&lt;/code&gt; object.
  719      *
  720      * @param md the &lt;code&gt;RowSetMetaData&lt;/code&gt; object for this
  721      *           &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object, which will be set with
  722      *           values from rsmd
  723      * @param rsmd the &lt;code&gt;ResultSetMetaData&lt;/code&gt; object from which new
  724      *             values for md will be read
  725      * @throws SQLException if an error occurs
  726      */
  727     private void initMetaData(RowSetMetaDataImpl md, ResultSetMetaData rsmd) throws SQLException {
  728         int numCols = rsmd.getColumnCount();
  729 
  730         md.setColumnCount(numCols);
  731         for (int col=1; col &lt;= numCols; col++) {
  732             md.setAutoIncrement(col, rsmd.isAutoIncrement(col));
  733             if(rsmd.isAutoIncrement(col))
  734                 updateOnInsert = true;
  735             md.setCaseSensitive(col, rsmd.isCaseSensitive(col));
  736             md.setCurrency(col, rsmd.isCurrency(col));
  737             md.setNullable(col, rsmd.isNullable(col));
  738             md.setSigned(col, rsmd.isSigned(col));
  739             md.setSearchable(col, rsmd.isSearchable(col));
  740              /*
  741              * The PostgreSQL drivers sometimes return negative columnDisplaySize,
  742              * which causes an exception to be thrown.  Check for it.
  743              */
  744             int size = rsmd.getColumnDisplaySize(col);
  745             if (size &lt; 0) {
  746                 size = 0;
  747             }
  748             md.setColumnDisplaySize(col, size);
  749             md.setColumnLabel(col, rsmd.getColumnLabel(col));
  750             md.setColumnName(col, rsmd.getColumnName(col));
  751             md.setSchemaName(col, rsmd.getSchemaName(col));
  752             /*
  753              * Drivers return some strange values for precision, for non-numeric data, including reports of
  754              * non-integer values; maybe we should check type, &amp; set to 0 for non-numeric types.
  755              */
  756             int precision = rsmd.getPrecision(col);
  757             if (precision &lt; 0) {
  758                 precision = 0;
  759             }
  760             md.setPrecision(col, precision);
  761 
  762             /*
  763              * It seems, from a bug report, that a driver can sometimes return a negative
  764              * value for scale.  javax.sql.rowset.RowSetMetaDataImpl will throw an exception
  765              * if we attempt to set a negative value.  As such, we&#39;ll check for this case.
  766              */
  767             int scale = rsmd.getScale(col);
  768             if (scale &lt; 0) {
  769                 scale = 0;
  770             }
  771             md.setScale(col, scale);
  772             md.setTableName(col, rsmd.getTableName(col));
  773             md.setCatalogName(col, rsmd.getCatalogName(col));
  774             md.setColumnType(col, rsmd.getColumnType(col));
  775             md.setColumnTypeName(col, rsmd.getColumnTypeName(col));
  776         }
  777 
  778         if( conn != null){
  779            // JDBC 4.0 mandates as does the Java EE spec that all DataBaseMetaData methods
  780            // must be implemented, therefore, the previous fix for 5055528 is being backed out
  781             dbmslocatorsUpdateCopy = conn.getMetaData().locatorsUpdateCopy();
  782         }
  783     }
  784 
  785     /**
  786      * Populates this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with data,
  787      * using the given connection to produce the result set from
  788      * which data will be read.  A second form of this method,
  789      * which takes no arguments, uses the values from this rowset&#39;s
  790      * user, password, and either url or data source properties to
  791      * create a new database connection. The form of &lt;code&gt;execute&lt;/code&gt;
  792      * that is given a connection ignores these properties.
  793      *
  794      * @param conn A standard JDBC &lt;code&gt;Connection&lt;/code&gt; object that this
  795      * &lt;code&gt;CachedRowSet&lt;/code&gt; object can pass to a synchronization provider
  796      * to establish a connection to the data source
  797      * @throws SQLException if an invalid &lt;code&gt;Connection&lt;/code&gt; is supplied
  798      *           or an error occurs in establishing the connection to the
  799      *           data source
  800      * @see #populate
  801      * @see java.sql.Connection
  802      */
  803     public void execute(Connection conn) throws SQLException {
  804         // store the connection so the reader can find it.
  805         setConnection(conn);
  806 
  807         if(getPageSize() != 0){
  808             crsReader = (CachedRowSetReader)provider.getRowSetReader();
  809             crsReader.setStartPosition(1);
  810             callWithCon = true;
  811             crsReader.readData((RowSetInternal)this);
  812         }
  813 
  814         // Now call the current reader&#39;s readData method
  815         else {
  816            rowSetReader.readData((RowSetInternal)this);
  817         }
  818         RowSetMD = (RowSetMetaDataImpl)this.getMetaData();
  819 
  820         if(conn != null){
  821             // JDBC 4.0 mandates as does the Java EE spec that all DataBaseMetaData methods
  822             // must be implemented, therefore, the previous fix for 5055528 is being backed out
  823             dbmslocatorsUpdateCopy = conn.getMetaData().locatorsUpdateCopy();
  824         }
  825 
  826     }
  827 
  828     /**
  829      * Sets this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s connection property
  830      * to the given &lt;code&gt;Connection&lt;/code&gt; object.  This method is called
  831      * internally by the version of the method &lt;code&gt;execute&lt;/code&gt; that takes a
  832      * &lt;code&gt;Connection&lt;/code&gt; object as an argument. The reader for this
  833      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object can retrieve the connection stored
  834      * in the rowset&#39;s connection property by calling its
  835      * &lt;code&gt;getConnection&lt;/code&gt; method.
  836      *
  837      * @param connection the &lt;code&gt;Connection&lt;/code&gt; object that was passed in
  838      *                   to the method &lt;code&gt;execute&lt;/code&gt; and is to be stored
  839      *                   in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s connection
  840      *                   property
  841      */
  842     private void setConnection (Connection connection) {
  843         conn = connection;
  844     }
  845 
  846 
  847     /**
  848      * Propagates all row update, insert, and delete changes to the
  849      * underlying data source backing this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
  850      * object.
  851      * &lt;P&gt;
  852      * &lt;b&gt;Note&lt;/b&gt;In the reference implementation an optimistic concurrency implementation
  853      * is provided as a sample implementation of a the &lt;code&gt;SyncProvider&lt;/code&gt;
  854      * abstract class.
  855      * &lt;P&gt;
  856      * This method fails if any of the updates cannot be propagated back
  857      * to the data source.  When it fails, the caller can assume that
  858      * none of the updates are reflected in the data source.
  859      * When an exception is thrown, the current row
  860      * is set to the first &quot;updated&quot; row that resulted in an exception
  861      * unless the row that caused the exception is a &quot;deleted&quot; row.
  862      * In that case, when deleted rows are not shown, which is usually true,
  863      * the current row is not affected.
  864      * &lt;P&gt;
  865      * If no &lt;code&gt;SyncProvider&lt;/code&gt; is configured, the reference implementation
  866      * leverages the &lt;code&gt;RIOptimisticProvider&lt;/code&gt; available which provides the
  867      * default and reference synchronization capabilities for disconnected
  868      * &lt;code&gt;RowSets&lt;/code&gt;.
  869      *
  870      * @throws SQLException if the cursor is on the insert row or the underlying
  871      *          reference synchronization provider fails to commit the updates
  872      *          to the datasource
  873      * @throws SyncProviderException if an internal error occurs within the
  874      *          &lt;code&gt;SyncProvider&lt;/code&gt; instance during either during the
  875      *          process or at any time when the &lt;code&gt;SyncProvider&lt;/code&gt;
  876      *          instance touches the data source.
  877      * @see #acceptChanges(java.sql.Connection)
  878      * @see javax.sql.RowSetWriter
  879      * @see javax.sql.rowset.spi.SyncProvider
  880      */
  881     public void acceptChanges() throws SyncProviderException {
  882         if (onInsertRow == true) {
  883             throw new SyncProviderException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidop&quot;).toString());
  884         }
  885 
  886         int saveCursorPos = cursorPos;
  887         boolean success = false;
  888         boolean conflict = false;
  889 
  890         try {
  891             if (rowSetWriter != null) {
  892                 saveCursorPos = cursorPos;
  893                 conflict = rowSetWriter.writeData((RowSetInternal)this);
  894                 cursorPos = saveCursorPos;
  895             }
  896 
  897             if (tXWriter) {
  898                 // do commit/rollback&#39;s here
  899                 if (!conflict) {
  900                     tWriter = (TransactionalWriter)rowSetWriter;
  901                     tWriter.rollback();
  902                     success = false;
  903                 } else {
  904                     tWriter = (TransactionalWriter)rowSetWriter;
  905                     if (tWriter instanceof CachedRowSetWriter) {
  906                         ((CachedRowSetWriter)tWriter).commit(this, updateOnInsert);
  907                     } else {
  908                         tWriter.commit();
  909                     }
  910 
  911                     success = true;
  912                 }
  913             }
  914 
  915             if (success == true) {
  916                 setOriginal();
  917             } else if (!(success) ) {
  918                 throw new SyncProviderException(resBundle.handleGetObject(&quot;cachedrowsetimpl.accfailed&quot;).toString());
  919             }
  920 
  921         } catch (SyncProviderException spe) {
  922                throw spe;
  923         } catch (SQLException e) {
  924             e.printStackTrace();
  925             throw new SyncProviderException(e.getMessage());
  926         } catch (SecurityException e) {
  927             throw new SyncProviderException(e.getMessage());
  928         }
  929     }
  930 
  931     /**
  932      * Propagates all row update, insert, and delete changes to the
  933      * data source backing this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
  934      * using the given &lt;code&gt;Connection&lt;/code&gt; object.
  935      * &lt;P&gt;
  936      * The reference implementation &lt;code&gt;RIOptimisticProvider&lt;/code&gt;
  937      * modifies its synchronization to a write back function given
  938      * the updated connection
  939      * The reference implementation modifies its synchronization behaviour
  940      * via the &lt;code&gt;SyncProvider&lt;/code&gt; to ensure the synchronization
  941      * occurs according to the updated JDBC &lt;code&gt;Connection&lt;/code&gt;
  942      * properties.
  943      *
  944      * @param con a standard JDBC &lt;code&gt;Connection&lt;/code&gt; object
  945      * @throws SQLException if the cursor is on the insert row or the underlying
  946      *                   synchronization provider fails to commit the updates
  947      *                   back to the data source
  948      * @see #acceptChanges
  949      * @see javax.sql.RowSetWriter
  950      * @see javax.sql.rowset.spi.SyncFactory
  951      * @see javax.sql.rowset.spi.SyncProvider
  952      */
  953     public void acceptChanges(Connection con) throws SyncProviderException{
  954       setConnection(con);
  955       acceptChanges();
  956     }
  957 
  958     /**
  959      * Restores this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object to its original state,
  960      * that is, its state before the last set of changes.
  961      * &lt;P&gt;
  962      * Before returning, this method moves the cursor before the first row
  963      * and sends a &lt;code&gt;rowSetChanged&lt;/code&gt; event to all registered
  964      * listeners.
  965      * @throws SQLException if an error is occurs rolling back the RowSet
  966      *           state to the definied original value.
  967      * @see javax.sql.RowSetListener#rowSetChanged
  968      */
  969     public void restoreOriginal() throws SQLException {
  970         Row currentRow;
  971         for (Iterator&lt;?&gt; i = rvh.iterator(); i.hasNext();) {
  972             currentRow = (Row)i.next();
  973             if (currentRow.getInserted() == true) {
  974                 i.remove();
  975                 --numRows;
  976             } else {
  977                 if (currentRow.getDeleted() == true) {
  978                     currentRow.clearDeleted();
  979                 }
  980                 if (currentRow.getUpdated() == true) {
  981                     currentRow.clearUpdated();
  982                 }
  983             }
  984         }
  985         // move to before the first
  986         cursorPos = 0;
  987 
  988         // notify any listeners
  989         notifyRowSetChanged();
  990     }
  991 
  992     /**
  993      * Releases the current contents of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
  994      * object and sends a &lt;code&gt;rowSetChanged&lt;/code&gt; event object to all
  995      * registered listeners.
  996      *
  997      * @throws SQLException if an error occurs flushing the contents of
  998      *           RowSet.
  999      * @see javax.sql.RowSetListener#rowSetChanged
 1000      */
 1001     public void release() throws SQLException {
 1002         initContainer();
 1003         notifyRowSetChanged();
 1004     }
 1005 
 1006     /**
 1007      * Cancels deletion of the current row and notifies listeners that
 1008      * a row has changed.
 1009      * &lt;P&gt;
 1010      * Note:  This method can be ignored if deleted rows are not being shown,
 1011      * which is the normal case.
 1012      *
 1013      * @throws SQLException if the cursor is not on a valid row
 1014      */
 1015     public void undoDelete() throws SQLException {
 1016         if (getShowDeleted() == false) {
 1017             return;
 1018         }
 1019         // make sure we are on a row
 1020         checkCursor();
 1021 
 1022         // don&#39;t want this to happen...
 1023         if (onInsertRow == true) {
 1024             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcp&quot;).toString());
 1025         }
 1026 
 1027         Row currentRow = (Row)getCurrentRow();
 1028         if (currentRow.getDeleted() == true) {
 1029             currentRow.clearDeleted();
 1030             --numDeleted;
 1031             notifyRowChanged();
 1032         }
 1033     }
 1034 
 1035     /**
 1036      * Immediately removes the current row from this
 1037      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object if the row has been inserted, and
 1038      * also notifies listeners the a row has changed.  An exception is thrown
 1039      * if the row is not a row that has been inserted or the cursor is before
 1040      * the first row, after the last row, or on the insert row.
 1041      * &lt;P&gt;
 1042      * This operation cannot be undone.
 1043      *
 1044      * @throws SQLException if an error occurs,
 1045      *                         the cursor is not on a valid row,
 1046      *                         or the row has not been inserted
 1047      */
 1048     public void undoInsert() throws SQLException {
 1049         // make sure we are on a row
 1050         checkCursor();
 1051 
 1052         // don&#39;t want this to happen...
 1053         if (onInsertRow == true) {
 1054             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcp&quot;).toString());
 1055         }
 1056 
 1057         Row currentRow = (Row)getCurrentRow();
 1058         if (currentRow.getInserted() == true) {
 1059             rvh.remove(cursorPos-1);
 1060             --numRows;
 1061             notifyRowChanged();
 1062         } else {
 1063             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.illegalop&quot;).toString());
 1064         }
 1065     }
 1066 
 1067     /**
 1068      * Immediately reverses the last update operation if the
 1069      * row has been modified. This method can be
 1070      * called to reverse updates on a all columns until all updates in a row have
 1071      * been rolled back to their originating state since the last synchronization
 1072      * (&lt;code&gt;acceptChanges&lt;/code&gt;) or population. This method may also be called
 1073      * while performing updates to the insert row.
 1074      * &lt;P&gt;
 1075      * {@code undoUpdate} may be called at any time during the life-time of a
 1076      * rowset, however after a synchronization has occurs this method has no
 1077      * affect until further modification to the RowSet data occurs.
 1078      *
 1079      * @throws SQLException if cursor is before the first row, after the last
 1080      *     row in rowset.
 1081      * @see #undoDelete
 1082      * @see #undoInsert
 1083      * @see java.sql.ResultSet#cancelRowUpdates
 1084      */
 1085     public void undoUpdate() throws SQLException {
 1086         // if on insert row, cancel the insert row
 1087         // make the insert row flag,
 1088         // cursorPos back to the current row
 1089         moveToCurrentRow();
 1090 
 1091         // else if not on insert row
 1092         // call undoUpdate or undoInsert
 1093         undoDelete();
 1094 
 1095         undoInsert();
 1096 
 1097     }
 1098 
 1099     //--------------------------------------------------------------------
 1100     // Views
 1101     //--------------------------------------------------------------------
 1102 
 1103     /**
 1104      * Returns a new &lt;code&gt;RowSet&lt;/code&gt; object backed by the same data as
 1105      * that of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object and sharing a set of cursors
 1106      * with it. This allows cursors to interate over a shared set of rows, providing
 1107      * multiple views of the underlying data.
 1108      *
 1109      * @return a &lt;code&gt;RowSet&lt;/code&gt; object that is a copy of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1110      * object and shares a set of cursors with it
 1111      * @throws SQLException if an error occurs or cloning is
 1112      *                         not supported
 1113      * @see javax.sql.RowSetEvent
 1114      * @see javax.sql.RowSetListener
 1115      */
 1116     public RowSet createShared() throws SQLException {
 1117         RowSet clone;
 1118         try {
 1119             clone = (RowSet)clone();
 1120         } catch (CloneNotSupportedException ex) {
 1121             throw new SQLException(ex.getMessage());
 1122         }
 1123         return clone;
 1124     }
 1125 
 1126     /**
 1127      * Returns a new &lt;code&gt;RowSet&lt;/code&gt; object containing by the same data
 1128      * as this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.  This method
 1129      * differs from the method &lt;code&gt;createCopy&lt;/code&gt; in that it throws a
 1130      * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; object instead of an
 1131      * &lt;code&gt;SQLException&lt;/code&gt; object, as the method &lt;code&gt;createShared&lt;/code&gt;
 1132      * does.  This &lt;code&gt;clone&lt;/code&gt;
 1133      * method is called internally by the method &lt;code&gt;createShared&lt;/code&gt;,
 1134      * which catches the &lt;code&gt;CloneNotSupportedException&lt;/code&gt; object
 1135      * and in turn throws a new &lt;code&gt;SQLException&lt;/code&gt; object.
 1136      *
 1137      * @return a copy of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 1138      * @throws CloneNotSupportedException if an error occurs when
 1139      * attempting to clone this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 1140      * @see #createShared
 1141      */
 1142     protected Object clone() throws CloneNotSupportedException  {
 1143         return (super.clone());
 1144     }
 1145 
 1146     /**
 1147      * Creates a &lt;code&gt;RowSet&lt;/code&gt; object that is a deep copy of
 1148      * this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s data, including
 1149      * constraints.  Updates made
 1150      * on a copy are not visible to the original rowset;
 1151      * a copy of a rowset is completely independent from the original.
 1152      * &lt;P&gt;
 1153      * Making a copy saves the cost of creating an identical rowset
 1154      * from first principles, which can be quite expensive.
 1155      * For example, it can eliminate the need to query a
 1156      * remote database server.
 1157      * @return a new &lt;code&gt;CachedRowSet&lt;/code&gt; object that is a deep copy
 1158      *           of this &lt;code&gt;CachedRowSet&lt;/code&gt; object and is
 1159      *           completely independent from this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1160      *           object.
 1161      * @throws SQLException if an error occurs in generating the copy of this
 1162      *           of the &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1163      * @see #createShared
 1164      * @see javax.sql.RowSetEvent
 1165      * @see javax.sql.RowSetListener
 1166      */
 1167     public CachedRowSet createCopy() throws SQLException {
 1168         ObjectOutputStream out;
 1169         ByteArrayOutputStream bOut = new ByteArrayOutputStream();
 1170         try {
 1171             out = new ObjectOutputStream(bOut);
 1172             out.writeObject(this);
 1173         } catch (IOException ex) {
 1174             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.clonefail&quot;).toString() , ex.getMessage()));
 1175         }
 1176 
 1177         ObjectInputStream in;
 1178 
 1179         try {
 1180             ByteArrayInputStream bIn = new ByteArrayInputStream(bOut.toByteArray());
 1181             in = new ObjectInputStream(bIn);
 1182         } catch (StreamCorruptedException ex) {
 1183             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.clonefail&quot;).toString() , ex.getMessage()));
 1184         } catch (IOException ex) {
 1185             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.clonefail&quot;).toString() , ex.getMessage()));
 1186         }
 1187 
 1188         try {
 1189             //return ((CachedRowSet)(in.readObject()));
 1190             CachedRowSetImpl crsTemp = (CachedRowSetImpl)in.readObject();
 1191             crsTemp.resBundle = this.resBundle;
 1192             return ((CachedRowSet)crsTemp);
 1193 
 1194         } catch (ClassNotFoundException ex) {
 1195             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.clonefail&quot;).toString() , ex.getMessage()));
 1196         } catch (OptionalDataException ex) {
 1197             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.clonefail&quot;).toString() , ex.getMessage()));
 1198         } catch (IOException ex) {
 1199             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.clonefail&quot;).toString() , ex.getMessage()));
 1200         }
 1201     }
 1202 
 1203     /**
 1204      * Creates a &lt;code&gt;RowSet&lt;/code&gt; object that is a copy of
 1205      * this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s table structure
 1206      * and the constraints only.
 1207      * There will be no data in the object being returned.
 1208      * Updates made on a copy are not visible to the original rowset.
 1209      * &lt;P&gt;
 1210      * This helps in getting the underlying XML schema which can
 1211      * be used as the basis for populating a &lt;code&gt;WebRowSet&lt;/code&gt;.
 1212      *
 1213      * @return a new &lt;code&gt;CachedRowSet&lt;/code&gt; object that is a copy
 1214      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s schema and
 1215      * retains all the constraints on the original rowset but contains
 1216      * no data
 1217      * @throws SQLException if an error occurs in generating the copy
 1218      * of the &lt;code&gt;CachedRowSet&lt;/code&gt; object
 1219      * @see #createShared
 1220      * @see #createCopy
 1221      * @see #createCopyNoConstraints
 1222      * @see javax.sql.RowSetEvent
 1223      * @see javax.sql.RowSetListener
 1224      */
 1225     public CachedRowSet createCopySchema() throws SQLException {
 1226         // Copy everything except data i.e all constraints
 1227 
 1228         // Store the number of rows of &quot;this&quot;
 1229         // and make numRows equals zero.
 1230         // and make data also zero.
 1231         int nRows = numRows;
 1232         numRows = 0;
 1233 
 1234         CachedRowSet crs = this.createCopy();
 1235 
 1236         // reset this object back to number of rows.
 1237         numRows = nRows;
 1238 
 1239         return crs;
 1240     }
 1241 
 1242     /**
 1243      * Creates a &lt;code&gt;CachedRowSet&lt;/code&gt; object that is a copy of
 1244      * this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s data only.
 1245      * All constraints set in this object will not be there
 1246      * in the returning object.  Updates made
 1247      * on a copy are not visible to the original rowset.
 1248      *
 1249      * @return a new &lt;code&gt;CachedRowSet&lt;/code&gt; object that is a deep copy
 1250      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object and is
 1251      * completely independent from this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 1252      * @throws SQLException if an error occurs in generating the copy of the
 1253      * of the &lt;code&gt;CachedRowSet&lt;/code&gt;
 1254      * @see #createShared
 1255      * @see #createCopy
 1256      * @see #createCopySchema
 1257      * @see javax.sql.RowSetEvent
 1258      * @see javax.sql.RowSetListener
 1259      */
 1260     public CachedRowSet createCopyNoConstraints() throws SQLException {
 1261         // Copy the whole data ONLY without any constraints.
 1262         CachedRowSetImpl crs;
 1263         crs = (CachedRowSetImpl)this.createCopy();
 1264 
 1265         crs.initProperties();
 1266         try {
 1267             crs.unsetMatchColumn(crs.getMatchColumnIndexes());
 1268         } catch(SQLException sqle) {
 1269             //do nothing, if the setMatchColumn is not set.
 1270         }
 1271 
 1272         try {
 1273             crs.unsetMatchColumn(crs.getMatchColumnNames());
 1274         } catch(SQLException sqle) {
 1275             //do nothing, if the setMatchColumn is not set.
 1276         }
 1277 
 1278         return crs;
 1279     }
 1280 
 1281     /**
 1282      * Converts this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object to a collection
 1283      * of tables. The sample implementation utilitizes the &lt;code&gt;TreeMap&lt;/code&gt;
 1284      * collection type.
 1285      * This class guarantees that the map will be in ascending key order,
 1286      * sorted according to the natural order for the key&#39;s class.
 1287      *
 1288      * @return a &lt;code&gt;Collection&lt;/code&gt; object consisting of tables,
 1289      *         each of which is a copy of a row in this
 1290      *         &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 1291      * @throws SQLException if an error occurs in generating the collection
 1292      * @see #toCollection(int)
 1293      * @see #toCollection(String)
 1294      * @see java.util.TreeMap
 1295      */
 1296     public Collection&lt;?&gt; toCollection() throws SQLException {
 1297 
 1298         TreeMap&lt;Integer, Object&gt; tMap = new TreeMap&lt;&gt;();
 1299 
 1300         for (int i = 0; i&lt;numRows; i++) {
 1301             tMap.put(i, rvh.get(i));
 1302         }
 1303 
 1304         return (tMap.values());
 1305     }
 1306 
 1307     /**
 1308      * Returns the specified column of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 1309      * as a &lt;code&gt;Collection&lt;/code&gt; object.  This method makes a copy of the
 1310      * column&#39;s data and utilitizes the &lt;code&gt;Vector&lt;/code&gt; to establish the
 1311      * collection. The &lt;code&gt;Vector&lt;/code&gt; class implements a growable array
 1312      * objects allowing the individual components to be accessed using an
 1313      * an integer index similar to that of an array.
 1314      *
 1315      * @return a &lt;code&gt;Collection&lt;/code&gt; object that contains the value(s)
 1316      *         stored in the specified column of this
 1317      *         &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1318      *         object
 1319      * @throws SQLException if an error occurs generated the collection; or
 1320      *          an invalid column is provided.
 1321      * @see #toCollection()
 1322      * @see #toCollection(String)
 1323      * @see java.util.Vector
 1324      */
 1325     public Collection&lt;?&gt; toCollection(int column) throws SQLException {
 1326 
 1327         int nRows = numRows;
 1328         Vector&lt;Object&gt; vec = new Vector&lt;&gt;(nRows);
 1329 
 1330         // create a copy
 1331         CachedRowSetImpl crsTemp;
 1332         crsTemp = (CachedRowSetImpl) this.createCopy();
 1333 
 1334         while(nRows!=0) {
 1335             crsTemp.next();
 1336             vec.add(crsTemp.getObject(column));
 1337             nRows--;
 1338         }
 1339 
 1340         return (Collection)vec;
 1341     }
 1342 
 1343     /**
 1344      * Returns the specified column of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 1345      * as a &lt;code&gt;Collection&lt;/code&gt; object.  This method makes a copy of the
 1346      * column&#39;s data and utilitizes the &lt;code&gt;Vector&lt;/code&gt; to establish the
 1347      * collection. The &lt;code&gt;Vector&lt;/code&gt; class implements a growable array
 1348      * objects allowing the individual components to be accessed using an
 1349      * an integer index similar to that of an array.
 1350      *
 1351      * @return a &lt;code&gt;Collection&lt;/code&gt; object that contains the value(s)
 1352      *         stored in the specified column of this
 1353      *         &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1354      *         object
 1355      * @throws SQLException if an error occurs generated the collection; or
 1356      *          an invalid column is provided.
 1357      * @see #toCollection()
 1358      * @see #toCollection(int)
 1359      * @see java.util.Vector
 1360      */
 1361     public Collection&lt;?&gt; toCollection(String column) throws SQLException {
 1362         return toCollection(getColIdxByName(column));
 1363     }
 1364 
 1365     //--------------------------------------------------------------------
 1366     // Advanced features
 1367     //--------------------------------------------------------------------
 1368 
 1369 
 1370     /**
 1371      * Returns the &lt;code&gt;SyncProvider&lt;/code&gt; implementation being used
 1372      * with this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; implementation rowset.
 1373      *
 1374      * @return the SyncProvider used by the rowset. If not provider was
 1375      *          set when the rowset was instantiated, the reference
 1376      *          implementation (default) provider is returned.
 1377      * @throws SQLException if error occurs while return the
 1378      *          &lt;code&gt;SyncProvider&lt;/code&gt; instance.
 1379      */
 1380     public SyncProvider getSyncProvider() throws SQLException {
 1381         return provider;
 1382     }
 1383 
 1384     /**
 1385      * Sets the active &lt;code&gt;SyncProvider&lt;/code&gt; and attempts to load
 1386      * load the new provider using the &lt;code&gt;SyncFactory&lt;/code&gt; SPI.
 1387      *
 1388      * @throws SQLException if an error occurs while resetting the
 1389      *          &lt;code&gt;SyncProvider&lt;/code&gt;.
 1390      */
 1391     public void setSyncProvider(String providerStr) throws SQLException {
 1392         provider =
 1393         SyncFactory.getInstance(providerStr);
 1394 
 1395         rowSetReader = provider.getRowSetReader();
 1396         rowSetWriter = provider.getRowSetWriter();
 1397     }
 1398 
 1399 
 1400     //-----------------
 1401     // methods inherited from RowSet
 1402     //-----------------
 1403 
 1404 
 1405 
 1406 
 1407 
 1408 
 1409     //---------------------------------------------------------------------
 1410     // Reading and writing data
 1411     //---------------------------------------------------------------------
 1412 
 1413     /**
 1414      * Populates this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with data.
 1415      * This form of the method uses the rowset&#39;s user, password, and url or
 1416      * data source name properties to create a database
 1417      * connection.  If properties that are needed
 1418      * have not been set, this method will throw an exception.
 1419      * &lt;P&gt;
 1420      * Another form of this method uses an existing JDBC &lt;code&gt;Connection&lt;/code&gt;
 1421      * object instead of creating a new one; therefore, it ignores the
 1422      * properties used for establishing a new connection.
 1423      * &lt;P&gt;
 1424      * The query specified by the command property is executed to create a
 1425      * &lt;code&gt;ResultSet&lt;/code&gt; object from which to retrieve data.
 1426      * The current contents of the rowset are discarded, and the
 1427      * rowset&#39;s metadata is also (re)set.  If there are outstanding updates,
 1428      * they are also ignored.
 1429      * &lt;P&gt;
 1430      * The method &lt;code&gt;execute&lt;/code&gt; closes any database connections that it
 1431      * creates.
 1432      *
 1433      * @throws SQLException if an error occurs or the
 1434      *                         necessary properties have not been set
 1435      */
 1436     public void execute() throws SQLException {
 1437         execute(null);
 1438     }
 1439 
 1440 
 1441 
 1442     //-----------------------------------
 1443     // Methods inherited from ResultSet
 1444     //-----------------------------------
 1445 
 1446     /**
 1447      * Moves the cursor down one row from its current position and
 1448      * returns &lt;code&gt;true&lt;/code&gt; if the new cursor position is a
 1449      * valid row.
 1450      * The cursor for a new &lt;code&gt;ResultSet&lt;/code&gt; object is initially
 1451      * positioned before the first row. The first call to the method
 1452      * &lt;code&gt;next&lt;/code&gt; moves the cursor to the first row, making it
 1453      * the current row; the second call makes the second row the
 1454      * current row, and so on.
 1455      *
 1456      * &lt;P&gt;If an input stream from the previous row is open, it is
 1457      * implicitly closed. The &lt;code&gt;ResultSet&lt;/code&gt; object&#39;s warning
 1458      * chain is cleared when a new row is read.
 1459      *
 1460      * @return &lt;code&gt;true&lt;/code&gt; if the new current row is valid;
 1461      *         &lt;code&gt;false&lt;/code&gt; if there are no more rows
 1462      * @throws SQLException if an error occurs or
 1463      *            the cursor is not positioned in the rowset, before
 1464      *            the first row, or after the last row
 1465      */
 1466     public boolean next() throws SQLException {
 1467         /*
 1468          * make sure things look sane. The cursor must be
 1469          * positioned in the rowset or before first (0) or
 1470          * after last (numRows + 1)
 1471          */
 1472         if (cursorPos &lt; 0 || cursorPos &gt;= numRows + 1) {
 1473             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcp&quot;).toString());
 1474         }
 1475         // now move and notify
 1476         boolean ret = this.internalNext();
 1477         notifyCursorMoved();
 1478 
 1479         return ret;
 1480     }
 1481 
 1482     /**
 1483      * Moves this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s cursor to the next
 1484      * row and returns &lt;code&gt;true&lt;/code&gt; if the cursor is still in the rowset;
 1485      * returns &lt;code&gt;false&lt;/code&gt; if the cursor has moved to the position after
 1486      * the last row.
 1487      * &lt;P&gt;
 1488      * This method handles the cases where the cursor moves to a row that
 1489      * has been deleted.
 1490      * If this rowset shows deleted rows and the cursor moves to a row
 1491      * that has been deleted, this method moves the cursor to the next
 1492      * row until the cursor is on a row that has not been deleted.
 1493      * &lt;P&gt;
 1494      * The method &lt;code&gt;internalNext&lt;/code&gt; is called by methods such as
 1495      * &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;absolute&lt;/code&gt;, and &lt;code&gt;relative&lt;/code&gt;,
 1496      * and, as its name implies, is only called internally.
 1497      * &lt;p&gt;
 1498      * This is a implementation only method and is not required as a standard
 1499      * implementation of the &lt;code&gt;CachedRowSet&lt;/code&gt; interface.
 1500      *
 1501      * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a valid row in this
 1502      *         rowset; &lt;code&gt;false&lt;/code&gt; if it is after the last row
 1503      * @throws SQLException if an error occurs
 1504      */
 1505     protected boolean internalNext() throws SQLException {
 1506         boolean ret = false;
 1507 
 1508         do {
 1509             if (cursorPos &lt; numRows) {
 1510                 ++cursorPos;
 1511                 ret = true;
 1512             } else if (cursorPos == numRows) {
 1513                 // increment to after last
 1514                 ++cursorPos;
 1515                 ret = false;
 1516                 break;
 1517             }
 1518         } while ((getShowDeleted() == false) &amp;&amp; (rowDeleted() == true));
 1519 
 1520         /* each call to internalNext may increment cursorPos multiple
 1521          * times however, the absolutePos only increments once per call.
 1522          */
 1523         if (ret == true)
 1524             absolutePos++;
 1525         else
 1526             absolutePos = 0;
 1527 
 1528         return ret;
 1529     }
 1530 
 1531     /**
 1532      * Closes this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; objecy and releases any resources
 1533      * it was using.
 1534      *
 1535      * @throws SQLException if an error occurs when releasing any resources in use
 1536      * by this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 1537      */
 1538     public void close() throws SQLException {
 1539 
 1540         // close all data structures holding
 1541         // the disconnected rowset
 1542 
 1543         cursorPos = 0;
 1544         absolutePos = 0;
 1545         numRows = 0;
 1546         numDeleted = 0;
 1547 
 1548         // set all insert(s), update(s) &amp; delete(s),
 1549         // if at all, to their initial values.
 1550         initProperties();
 1551 
 1552         // clear the vector of it&#39;s present contents
 1553         rvh.clear();
 1554 
 1555         // this will make it eligible for gc
 1556         // rvh = null;
 1557     }
 1558 
 1559     /**
 1560      * Reports whether the last column read was SQL &lt;code&gt;NULL&lt;/code&gt;.
 1561      * Note that you must first call the method &lt;code&gt;getXXX&lt;/code&gt;
 1562      * on a column to try to read its value and then call the method
 1563      * &lt;code&gt;wasNull&lt;/code&gt; to determine whether the value was
 1564      * SQL &lt;code&gt;NULL&lt;/code&gt;.
 1565      *
 1566      * @return &lt;code&gt;true&lt;/code&gt; if the value in the last column read
 1567      *         was SQL &lt;code&gt;NULL&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise
 1568      * @throws SQLException if an error occurs
 1569      */
 1570     public boolean wasNull() throws SQLException {
 1571         return lastValueNull;
 1572     }
 1573 
 1574     /**
 1575      * Sets the field &lt;code&gt;lastValueNull&lt;/code&gt; to the given
 1576      * &lt;code&gt;boolean&lt;/code&gt; value.
 1577      *
 1578      * @param value &lt;code&gt;true&lt;/code&gt; to indicate that the value of
 1579      *        the last column read was SQL &lt;code&gt;NULL&lt;/code&gt;;
 1580      *        &lt;code&gt;false&lt;/code&gt; to indicate that it was not
 1581      */
 1582     private void setLastValueNull(boolean value) {
 1583         lastValueNull = value;
 1584     }
 1585 
 1586     // Methods for accessing results by column index
 1587 
 1588     /**
 1589      * Checks to see whether the given index is a valid column number
 1590      * in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object and throws
 1591      * an &lt;code&gt;SQLException&lt;/code&gt; if it is not. The index is out of bounds
 1592      * if it is less than &lt;code&gt;1&lt;/code&gt; or greater than the number of
 1593      * columns in this rowset.
 1594      * &lt;P&gt;
 1595      * This method is called internally by the &lt;code&gt;getXXX&lt;/code&gt; and
 1596      * &lt;code&gt;updateXXX&lt;/code&gt; methods.
 1597      *
 1598      * @param idx the number of a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1599      *            object; must be between &lt;code&gt;1&lt;/code&gt; and the number of
 1600      *            rows in this rowset
 1601      * @throws SQLException if the given index is out of bounds
 1602      */
 1603     private void checkIndex(int idx) throws SQLException {
<a name="3" id="anc3"></a><span class="line-modified"> 1604         if (idx &lt; 1 ||  RowSetMD == null || idx &gt; RowSetMD.getColumnCount()) {</span>
 1605             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcol&quot;).toString());
 1606         }
 1607     }
 1608 
 1609     /**
 1610      * Checks to see whether the cursor for this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1611      * object is on a row in the rowset and throws an
 1612      * &lt;code&gt;SQLException&lt;/code&gt; if it is not.
 1613      * &lt;P&gt;
 1614      * This method is called internally by &lt;code&gt;getXXX&lt;/code&gt; methods, by
 1615      * &lt;code&gt;updateXXX&lt;/code&gt; methods, and by methods that update, insert,
 1616      * or delete a row or that cancel a row update, insert, or delete.
 1617      *
 1618      * @throws SQLException if the cursor for this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1619      *         object is not on a valid row
 1620      */
 1621     private void checkCursor() throws SQLException {
 1622         if (isAfterLast() == true || isBeforeFirst() == true) {
 1623             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcp&quot;).toString());
 1624         }
 1625     }
 1626 
 1627     /**
 1628      * Returns the column number of the column with the given name in this
 1629      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.  This method throws an
 1630      * &lt;code&gt;SQLException&lt;/code&gt; if the given name is not the name of
 1631      * one of the columns in this rowset.
 1632      *
 1633      * @param name a &lt;code&gt;String&lt;/code&gt; object that is the name of a column in
 1634      *              this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 1635      * @throws SQLException if the given name does not match the name of one of
 1636      *         the columns in this rowset
 1637      */
 1638     private int getColIdxByName(String name) throws SQLException {
 1639         RowSetMD = (RowSetMetaDataImpl)this.getMetaData();
 1640         int cols = RowSetMD.getColumnCount();
<a name="4" id="anc4"></a><span class="line-modified"> 1641         if (RowSetMD != null) {</span>
<span class="line-modified"> 1642             for (int i = 1; i &lt;= cols; ++i) {</span>
<span class="line-modified"> 1643                 String colName = RowSetMD.getColumnName(i);</span>
<span class="line-modified"> 1644                 if (colName != null)</span>
<span class="line-modified"> 1645                     if (name.equalsIgnoreCase(colName))</span>
<span class="line-modified"> 1646                         return (i);</span>
<span class="line-modified"> 1647                     else</span>
<span class="line-modified"> 1648                         continue;</span>
<span class="line-added"> 1649             }</span>
 1650         }
 1651         throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalcolnm&quot;).toString());
 1652 
 1653     }
 1654 
 1655     /**
 1656      * Returns the insert row or the current row of this
 1657      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt;object.
 1658      *
 1659      * @return the &lt;code&gt;Row&lt;/code&gt; object on which this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1660      * objects&#39;s cursor is positioned
 1661      */
 1662     protected BaseRow getCurrentRow() {
 1663         if (onInsertRow == true) {
 1664             return (BaseRow)insertRow;
 1665         } else {
 1666             return (BaseRow)(rvh.get(cursorPos - 1));
 1667         }
 1668     }
 1669 
 1670     /**
 1671      * Removes the row on which the cursor is positioned.
 1672      * &lt;p&gt;
 1673      * This is a implementation only method and is not required as a standard
 1674      * implementation of the &lt;code&gt;CachedRowSet&lt;/code&gt; interface.
 1675      *
 1676      * @throws SQLException if the cursor is positioned on the insert
 1677      *            row
 1678      */
 1679     protected void removeCurrentRow() {
 1680         ((Row)getCurrentRow()).setDeleted();
 1681         rvh.remove(cursorPos - 1);
 1682         --numRows;
 1683     }
 1684 
 1685 
 1686     /**
 1687      * Retrieves the value of the designated column in the current row
 1688      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 1689      * &lt;code&gt;String&lt;/code&gt; object.
 1690      *
 1691      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 1692      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 1693      *        and equal to or less than the number of columns in the rowset
 1694      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
 1695      *         result is &lt;code&gt;null&lt;/code&gt;
 1696      * @throws SQLException if (1) the given column index is out of bounds,
 1697      * (2) the cursor is not on one of this rowset&#39;s rows or its
 1698      * insert row, or (3) the designated column does not store an
 1699      * SQL &lt;code&gt;TINYINT, SMALLINT, INTEGER, BIGINT, REAL,
 1700      * FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, &lt;b&gt;CHAR&lt;/b&gt;, &lt;b&gt;VARCHAR&lt;/b&gt;&lt;/code&gt;
 1701      * or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type designates the
 1702      * recommended return type.
 1703      */
 1704     public String getString(int columnIndex) throws SQLException {
 1705         Object value;
 1706 
 1707         // sanity check.
 1708         checkIndex(columnIndex);
 1709         // make sure the cursor is on a valid row
 1710         checkCursor();
 1711 
 1712         setLastValueNull(false);
 1713         value = getCurrentRow().getColumnObject(columnIndex);
 1714 
 1715         // check for SQL NULL
 1716         if (value == null) {
 1717             setLastValueNull(true);
 1718             return null;
 1719         }
 1720 
 1721         return value.toString();
 1722     }
 1723 
 1724     /**
 1725      * Retrieves the value of the designated column in the current row
 1726      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 1727      * &lt;code&gt;boolean&lt;/code&gt; value.
 1728      *
 1729      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 1730      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 1731      *        and equal to or less than the number of columns in the rowset
 1732      * @return the column value as a &lt;code&gt;boolean&lt;/code&gt; in the Java progamming language;
 1733      *        if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;false&lt;/code&gt;
 1734      * @throws SQLException if (1) the given column index is out of bounds,
 1735      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 1736      *            insert row, or (3) the designated column does not store an
 1737      *            SQL &lt;code&gt;BOOLEAN&lt;/code&gt; value
 1738      * @see #getBoolean(String)
 1739      */
 1740     public boolean getBoolean(int columnIndex) throws SQLException {
 1741         Object value;
 1742 
 1743         // sanity check.
 1744         checkIndex(columnIndex);
 1745         // make sure the cursor is on a valid row
 1746         checkCursor();
 1747 
 1748         setLastValueNull(false);
 1749         value = getCurrentRow().getColumnObject(columnIndex);
 1750 
 1751         // check for SQL NULL
 1752         if (value == null) {
 1753             setLastValueNull(true);
 1754             return false;
 1755         }
 1756 
 1757         // check for Boolean...
 1758         if (value instanceof Boolean) {
 1759             return ((Boolean)value).booleanValue();
 1760         }
 1761 
 1762         // convert to a Double and compare to zero
 1763         try {
 1764             return Double.compare(Double.parseDouble(value.toString()), 0) != 0;
 1765         } catch (NumberFormatException ex) {
 1766             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.boolfail&quot;).toString(),
 1767                   new Object[] {value.toString().trim(), columnIndex}));
 1768         }
 1769     }
 1770 
 1771     /**
 1772      * Retrieves the value of the designated column in the current row
 1773      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 1774      * &lt;code&gt;byte&lt;/code&gt; value.
 1775      *
 1776      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 1777      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 1778      *        and equal to or less than the number of columns in the rowset
 1779      * @return the column value as a &lt;code&gt;byte&lt;/code&gt; in the Java programming
 1780      * language; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;0&lt;/code&gt;
 1781      * @throws SQLException if (1) the given column index is out of bounds,
 1782      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 1783      *            insert row, or (3) the designated column does not store an
 1784      *            SQL &lt;code&gt;&lt;b&gt;TINYINT&lt;/b&gt;, SMALLINT, INTEGER, BIGINT, REAL,
 1785      *            FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR, VARCHAR&lt;/code&gt;
 1786      *            or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type
 1787      *            designates the recommended return type.
 1788      * @see #getByte(String)
 1789      */
 1790     public byte getByte(int columnIndex) throws SQLException {
 1791         Object value;
 1792 
 1793         // sanity check.
 1794         checkIndex(columnIndex);
 1795         // make sure the cursor is on a valid row
 1796         checkCursor();
 1797 
 1798         setLastValueNull(false);
 1799         value = getCurrentRow().getColumnObject(columnIndex);
 1800 
 1801         // check for SQL NULL
 1802         if (value == null) {
 1803             setLastValueNull(true);
 1804             return (byte)0;
 1805         }
 1806         try {
 1807             return ((Byte.valueOf(value.toString())).byteValue());
 1808         } catch (NumberFormatException ex) {
 1809             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.bytefail&quot;).toString(),
 1810                   new Object[] {value.toString().trim(), columnIndex}));
 1811         }
 1812     }
 1813 
 1814     /**
 1815      * Retrieves the value of the designated column in the current row
 1816      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 1817      * &lt;code&gt;short&lt;/code&gt; value.
 1818      *
 1819      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 1820      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 1821      *        and equal to or less than the number of columns in the rowset
 1822      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
 1823      *         result is &lt;code&gt;0&lt;/code&gt;
 1824      * @throws SQLException if (1) the given column index is out of bounds,
 1825      * (2) the cursor is not on one of this rowset&#39;s rows or its
 1826      * insert row, or (3) the designated column does not store an
 1827      * SQL &lt;code&gt;TINYINT, &lt;b&gt;SMALLINT&lt;/b&gt;, INTEGER, BIGINT, REAL
 1828      * FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR, VARCHAR&lt;/code&gt;
 1829      * or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type designates the
 1830      * recommended return type.
 1831      * @see #getShort(String)
 1832      */
 1833     public short getShort(int columnIndex) throws SQLException {
 1834         Object value;
 1835 
 1836         // sanity check.
 1837         checkIndex(columnIndex);
 1838         // make sure the cursor is on a valid row
 1839         checkCursor();
 1840 
 1841         setLastValueNull(false);
 1842         value = getCurrentRow().getColumnObject(columnIndex);
 1843 
 1844         // check for SQL NULL
 1845         if (value == null) {
 1846             setLastValueNull(true);
 1847             return (short)0;
 1848         }
 1849 
 1850         try {
 1851             return ((Short.valueOf(value.toString().trim())).shortValue());
 1852         } catch (NumberFormatException ex) {
 1853             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.shortfail&quot;).toString(),
 1854                   new Object[] {value.toString().trim(), columnIndex}));
 1855         }
 1856     }
 1857 
 1858     /**
 1859      * Retrieves the value of the designated column in the current row
 1860      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as an
 1861      * &lt;code&gt;int&lt;/code&gt; value.
 1862      *
 1863      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 1864      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 1865      *        and equal to or less than the number of columns in the rowset
 1866      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
 1867      *         result is &lt;code&gt;0&lt;/code&gt;
 1868      * @throws SQLException if (1) the given column index is out of bounds,
 1869      * (2) the cursor is not on one of this rowset&#39;s rows or its
 1870      * insert row, or (3) the designated column does not store an
 1871      * SQL &lt;code&gt;TINYINT, SMALLINT, &lt;b&gt;INTEGER&lt;/b&gt;, BIGINT, REAL
 1872      * FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR, VARCHAR&lt;/code&gt;
 1873      * or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type designates the
 1874      * recommended return type.
 1875      */
 1876     public int getInt(int columnIndex) throws SQLException {
 1877         Object value;
 1878 
 1879         // sanity check.
 1880         checkIndex(columnIndex);
 1881         // make sure the cursor is on a valid row
 1882         checkCursor();
 1883 
 1884         setLastValueNull(false);
 1885         value = getCurrentRow().getColumnObject(columnIndex);
 1886 
 1887         // check for SQL NULL
 1888         if (value == null) {
 1889             setLastValueNull(true);
 1890             return 0;
 1891         }
 1892 
 1893         try {
 1894             return ((Integer.valueOf(value.toString().trim())).intValue());
 1895         } catch (NumberFormatException ex) {
 1896             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.intfail&quot;).toString(),
 1897                   new Object[] {value.toString().trim(), columnIndex}));
 1898         }
 1899     }
 1900 
 1901     /**
 1902      * Retrieves the value of the designated column in the current row
 1903      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 1904      * &lt;code&gt;long&lt;/code&gt; value.
 1905      *
 1906      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 1907      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 1908      *        and equal to or less than the number of columns in the rowset
 1909      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
 1910      *         result is &lt;code&gt;0&lt;/code&gt;
 1911      * @throws SQLException if (1) the given column index is out of bounds,
 1912      * (2) the cursor is not on one of this rowset&#39;s rows or its
 1913      * insert row, or (3) the designated column does not store an
 1914      * SQL &lt;code&gt;TINYINT, SMALLINT, INTEGER, &lt;b&gt;BIGINT&lt;/b&gt;, REAL
 1915      * FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR, VARCHAR&lt;/code&gt;
 1916      * or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type designates the
 1917      * recommended return type.
 1918      * @see #getLong(String)
 1919      */
 1920     public long getLong(int columnIndex) throws SQLException {
 1921         Object value;
 1922 
 1923         // sanity check.
 1924         checkIndex(columnIndex);
 1925         // make sure the cursor is on a valid row
 1926         checkCursor();
 1927 
 1928         setLastValueNull(false);
 1929         value = getCurrentRow().getColumnObject(columnIndex);
 1930 
 1931         // check for SQL NULL
 1932         if (value == null) {
 1933             setLastValueNull(true);
 1934             return (long)0;
 1935         }
 1936         try {
 1937             return ((Long.valueOf(value.toString().trim())).longValue());
 1938         } catch (NumberFormatException ex) {
 1939             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.longfail&quot;).toString(),
 1940                   new Object[] {value.toString().trim(), columnIndex}));
 1941         }
 1942     }
 1943 
 1944     /**
 1945      * Retrieves the value of the designated column in the current row
 1946      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 1947      * &lt;code&gt;float&lt;/code&gt; value.
 1948      *
 1949      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 1950      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 1951      *        and equal to or less than the number of columns in the rowset
 1952      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
 1953      *         result is &lt;code&gt;0&lt;/code&gt;
 1954      * @throws SQLException if (1) the given column index is out of bounds,
 1955      * (2) the cursor is not on one of this rowset&#39;s rows or its
 1956      * insert row, or (3) the designated column does not store an
 1957      * SQL &lt;code&gt;TINYINT, SMALLINT, INTEGER, BIGINT, &lt;b&gt;REAL&lt;/b&gt;,
 1958      * FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR, VARCHAR&lt;/code&gt;
 1959      * or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type designates the
 1960      * recommended return type.
 1961      * @see #getFloat(String)
 1962      */
 1963     public float getFloat(int columnIndex) throws SQLException {
 1964         Object value;
 1965 
 1966         // sanity check.
 1967         checkIndex(columnIndex);
 1968         // make sure the cursor is on a valid row
 1969         checkCursor();
 1970 
 1971         setLastValueNull(false);
 1972         value = getCurrentRow().getColumnObject(columnIndex);
 1973 
 1974         // check for SQL NULL
 1975         if (value == null) {
 1976             setLastValueNull(true);
 1977             return (float)0;
 1978         }
 1979         try {
 1980             return Float.parseFloat(value.toString());
 1981         } catch (NumberFormatException ex) {
 1982             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.floatfail&quot;).toString(),
 1983                   new Object[] {value.toString().trim(), columnIndex}));
 1984         }
 1985     }
 1986 
 1987     /**
 1988      * Retrieves the value of the designated column in the current row
 1989      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 1990      * &lt;code&gt;double&lt;/code&gt; value.
 1991      *
 1992      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 1993      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 1994      *        and equal to or less than the number of columns in the rowset
 1995      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
 1996      *         result is &lt;code&gt;0&lt;/code&gt;
 1997      * @throws SQLException if (1) the given column index is out of bounds,
 1998      * (2) the cursor is not on one of this rowset&#39;s rows or its
 1999      * insert row, or (3) the designated column does not store an
 2000      * SQL &lt;code&gt;TINYINT, SMALLINT, INTEGER, BIGINT, REAL,
 2001      * &lt;b&gt;FLOAT&lt;/b&gt;, &lt;b&gt;DOUBLE&lt;/b&gt;, DECIMAL, NUMERIC, BIT, CHAR, VARCHAR&lt;/code&gt;
 2002      * or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type designates the
 2003      * recommended return type.
 2004      * @see #getDouble(String)
 2005      *
 2006      */
 2007     public double getDouble(int columnIndex) throws SQLException {
 2008         Object value;
 2009 
 2010         // sanity check.
 2011         checkIndex(columnIndex);
 2012         // make sure the cursor is on a valid row
 2013         checkCursor();
 2014 
 2015         setLastValueNull(false);
 2016         value = getCurrentRow().getColumnObject(columnIndex);
 2017 
 2018         // check for SQL NULL
 2019         if (value == null) {
 2020             setLastValueNull(true);
 2021             return (double)0;
 2022         }
 2023         try {
 2024             return Double.parseDouble(value.toString().trim());
 2025         } catch (NumberFormatException ex) {
 2026             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.doublefail&quot;).toString(),
 2027                   new Object[] {value.toString().trim(), columnIndex}));
 2028         }
 2029     }
 2030 
 2031     /**
 2032      * Retrieves the value of the designated column in the current row
 2033      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 2034      * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
 2035      * &lt;P&gt;
 2036      * This method is deprecated; use the version of &lt;code&gt;getBigDecimal&lt;/code&gt;
 2037      * that does not take a scale parameter and returns a value with full
 2038      * precision.
 2039      *
 2040      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 2041      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 2042      *        and equal to or less than the number of columns in the rowset
 2043      * @param scale the number of digits to the right of the decimal point in the
 2044      *        value returned
 2045      * @return the column value with the specified number of digits to the right
 2046      *         of the decimal point; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
 2047      *         result is &lt;code&gt;null&lt;/code&gt;
 2048      * @throws SQLException if the given column index is out of bounds,
 2049      *            the cursor is not on a valid row, or this method fails
 2050      * @deprecated
 2051      */
 2052     @Deprecated
 2053     public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
 2054         Object value;
 2055         BigDecimal bDecimal, retVal;
 2056 
 2057         // sanity check.
 2058         checkIndex(columnIndex);
 2059         // make sure the cursor is on a valid row
 2060         checkCursor();
 2061 
 2062         setLastValueNull(false);
 2063         value = getCurrentRow().getColumnObject(columnIndex);
 2064 
 2065         // check for SQL NULL
 2066         if (value == null) {
 2067             setLastValueNull(true);
 2068             return (new BigDecimal(0));
 2069         }
 2070 
 2071         bDecimal = this.getBigDecimal(columnIndex);
 2072 
 2073         retVal = bDecimal.setScale(scale);
 2074 
 2075         return retVal;
 2076     }
 2077 
 2078     /**
 2079      * Retrieves the value of the designated column in the current row
 2080      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 2081      * &lt;code&gt;byte&lt;/code&gt; array value.
 2082      *
 2083      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 2084      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 2085      *        and equal to or less than the number of columns in the rowset
 2086      * @return the column value as a &lt;code&gt;byte&lt;/code&gt; array in the Java programming
 2087      * language; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
 2088      * result is &lt;code&gt;null&lt;/code&gt;
 2089      *
 2090      * @throws SQLException if (1) the given column index is out of bounds,
 2091      * (2) the cursor is not on one of this rowset&#39;s rows or its
 2092      * insert row, or (3) the designated column does not store an
 2093      * SQL &lt;code&gt;&lt;b&gt;BINARY&lt;/b&gt;, &lt;b&gt;VARBINARY&lt;/b&gt; or
 2094      * LONGVARBINARY&lt;/code&gt; value.
 2095      * The bold SQL type designates the recommended return type.
 2096      * @see #getBytes(String)
 2097      */
 2098     public byte[] getBytes(int columnIndex) throws SQLException {
 2099         // sanity check.
 2100         checkIndex(columnIndex);
 2101         // make sure the cursor is on a valid row
 2102         checkCursor();
 2103 
 2104         if (isBinary(RowSetMD.getColumnType(columnIndex)) == false) {
 2105             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 2106         }
 2107 
 2108         return (byte[])(getCurrentRow().getColumnObject(columnIndex));
 2109     }
 2110 
 2111     /**
 2112      * Retrieves the value of the designated column in the current row
 2113      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 2114      * &lt;code&gt;java.sql.Date&lt;/code&gt; object.
 2115      *
 2116      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 2117      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 2118      *        and equal to or less than the number of columns in the rowset
 2119      * @return the column value as a &lt;code&gt;java.sql.Data&lt;/code&gt; object; if
 2120      *        the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
 2121      *        result is &lt;code&gt;null&lt;/code&gt;
 2122      * @throws SQLException if the given column index is out of bounds,
 2123      *            the cursor is not on a valid row, or this method fails
 2124      */
 2125     public java.sql.Date getDate(int columnIndex) throws SQLException {
 2126         Object value;
 2127 
 2128         // sanity check.
 2129         checkIndex(columnIndex);
 2130         // make sure the cursor is on a valid row
 2131         checkCursor();
 2132 
 2133         setLastValueNull(false);
 2134         value = getCurrentRow().getColumnObject(columnIndex);
 2135 
 2136         // check for SQL NULL
 2137         if (value == null) {
 2138             setLastValueNull(true);
 2139             return null;
 2140         }
 2141 
 2142         /*
 2143          * The object coming back from the db could be
 2144          * a date, a timestamp, or a char field variety.
 2145          * If it&#39;s a date type return it, a timestamp
 2146          * we turn into a long and then into a date,
 2147          * char strings we try to parse. Yuck.
 2148          */
 2149         switch (RowSetMD.getColumnType(columnIndex)) {
 2150             case java.sql.Types.DATE: {
 2151                 long sec = ((java.sql.Date)value).getTime();
 2152                 return new java.sql.Date(sec);
 2153             }
 2154             case java.sql.Types.TIMESTAMP: {
 2155                 long sec = ((java.sql.Timestamp)value).getTime();
 2156                 return new java.sql.Date(sec);
 2157             }
 2158             case java.sql.Types.CHAR:
 2159             case java.sql.Types.VARCHAR:
 2160             case java.sql.Types.LONGVARCHAR: {
 2161                 try {
 2162                     DateFormat df = DateFormat.getDateInstance();
 2163                     return ((java.sql.Date)(df.parse(value.toString())));
 2164                 } catch (ParseException ex) {
 2165                     throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.datefail&quot;).toString(),
 2166                         new Object[] {value.toString().trim(), columnIndex}));
 2167                 }
 2168             }
 2169             default: {
 2170                 throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.datefail&quot;).toString(),
 2171                         new Object[] {value.toString().trim(), columnIndex}));
 2172             }
 2173         }
 2174     }
 2175 
 2176     /**
 2177      * Retrieves the value of the designated column in the current row
 2178      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 2179      * &lt;code&gt;java.sql.Time&lt;/code&gt; object.
 2180      *
 2181      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 2182      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 2183      *        and equal to or less than the number of columns in the rowset
 2184      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
 2185      *         result is &lt;code&gt;null&lt;/code&gt;
 2186      * @throws SQLException if the given column index is out of bounds,
 2187      *         the cursor is not on a valid row, or this method fails
 2188      */
 2189     public java.sql.Time getTime(int columnIndex) throws SQLException {
 2190         Object value;
 2191 
 2192         // sanity check.
 2193         checkIndex(columnIndex);
 2194         // make sure the cursor is on a valid row
 2195         checkCursor();
 2196 
 2197         setLastValueNull(false);
 2198         value = getCurrentRow().getColumnObject(columnIndex);
 2199 
 2200         // check for SQL NULL
 2201         if (value == null) {
 2202             setLastValueNull(true);
 2203             return null;
 2204         }
 2205 
 2206         /*
 2207          * The object coming back from the db could be
 2208          * a date, a timestamp, or a char field variety.
 2209          * If it&#39;s a date type return it, a timestamp
 2210          * we turn into a long and then into a date,
 2211          * char strings we try to parse. Yuck.
 2212          */
 2213         switch (RowSetMD.getColumnType(columnIndex)) {
 2214             case java.sql.Types.TIME: {
 2215                 return (java.sql.Time)value;
 2216             }
 2217             case java.sql.Types.TIMESTAMP: {
 2218                 long sec = ((java.sql.Timestamp)value).getTime();
 2219                 return new java.sql.Time(sec);
 2220             }
 2221             case java.sql.Types.CHAR:
 2222             case java.sql.Types.VARCHAR:
 2223             case java.sql.Types.LONGVARCHAR: {
 2224                 try {
 2225                     DateFormat tf = DateFormat.getTimeInstance();
 2226                     return ((java.sql.Time)(tf.parse(value.toString())));
 2227                 } catch (ParseException ex) {
 2228                     throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.timefail&quot;).toString(),
 2229                         new Object[] {value.toString().trim(), columnIndex}));
 2230                 }
 2231             }
 2232             default: {
 2233                 throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.timefail&quot;).toString(),
 2234                         new Object[] {value.toString().trim(), columnIndex}));
 2235             }
 2236         }
 2237     }
 2238 
 2239     /**
 2240      * Retrieves the value of the designated column in the current row
 2241      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 2242      * &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object.
 2243      *
 2244      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 2245      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 2246      *        and equal to or less than the number of columns in the rowset
 2247      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
 2248      *         result is &lt;code&gt;null&lt;/code&gt;
 2249      * @throws SQLException if the given column index is out of bounds,
 2250      *            the cursor is not on a valid row, or this method fails
 2251      */
 2252     public java.sql.Timestamp getTimestamp(int columnIndex) throws SQLException {
 2253         Object value;
 2254 
 2255         // sanity check.
 2256         checkIndex(columnIndex);
 2257         // make sure the cursor is on a valid row
 2258         checkCursor();
 2259 
 2260         setLastValueNull(false);
 2261         value = getCurrentRow().getColumnObject(columnIndex);
 2262 
 2263         // check for SQL NULL
 2264         if (value == null) {
 2265             setLastValueNull(true);
 2266             return null;
 2267         }
 2268 
 2269         /*
 2270          * The object coming back from the db could be
 2271          * a date, a timestamp, or a char field variety.
 2272          * If it&#39;s a date type return it; a timestamp
 2273          * we turn into a long and then into a date;
 2274          * char strings we try to parse. Yuck.
 2275          */
 2276         switch (RowSetMD.getColumnType(columnIndex)) {
 2277             case java.sql.Types.TIMESTAMP: {
 2278                 return (java.sql.Timestamp)value;
 2279             }
 2280             case java.sql.Types.TIME: {
 2281                 long sec = ((java.sql.Time)value).getTime();
 2282                 return new java.sql.Timestamp(sec);
 2283             }
 2284             case java.sql.Types.DATE: {
 2285                 long sec = ((java.sql.Date)value).getTime();
 2286                 return new java.sql.Timestamp(sec);
 2287             }
 2288             case java.sql.Types.CHAR:
 2289             case java.sql.Types.VARCHAR:
 2290             case java.sql.Types.LONGVARCHAR: {
 2291                 try {
 2292                     DateFormat tf = DateFormat.getTimeInstance();
 2293                     return ((java.sql.Timestamp)(tf.parse(value.toString())));
 2294                 } catch (ParseException ex) {
 2295                     throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.timefail&quot;).toString(),
 2296                         new Object[] {value.toString().trim(), columnIndex}));
 2297                 }
 2298             }
 2299             default: {
 2300                 throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.timefail&quot;).toString(),
 2301                         new Object[] {value.toString().trim(), columnIndex}));
 2302             }
 2303         }
 2304     }
 2305 
 2306     /**
 2307      * Retrieves the value of the designated column in the current row of this
 2308      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.io.InputStream&lt;/code&gt;
 2309      * object.
 2310      *
 2311      * A column value can be retrieved as a stream of ASCII characters
 2312      * and then read in chunks from the stream.  This method is particularly
 2313      * suitable for retrieving large &lt;code&gt;LONGVARCHAR&lt;/code&gt; values.  The JDBC
 2314      * driver will do any necessary conversion from the database format into ASCII.
 2315      *
 2316      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
 2317      * read prior to getting the value of any other column. The next
 2318      * call to a get method implicitly closes the stream. . Also, a
 2319      * stream may return &lt;code&gt;0&lt;/code&gt; for &lt;code&gt;CachedRowSetImpl.available()&lt;/code&gt;
 2320      * whether there is data available or not.
 2321      *
 2322      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 2323      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 2324      *        and equal to or less than the number of columns in this rowset
 2325      * @return a Java input stream that delivers the database column value
 2326      *         as a stream of one-byte ASCII characters.  If the value is SQL
 2327      *         &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
 2328      * @throws SQLException if (1) the given column index is out of bounds,
 2329      * (2) the cursor is not on one of this rowset&#39;s rows or its
 2330      * insert row, or (3) the designated column does not store an
 2331      * SQL &lt;code&gt;CHAR, VARCHAR&lt;/code&gt;, &lt;code&gt;&lt;b&gt;LONGVARCHAR&lt;/b&gt;&lt;/code&gt;
 2332      * &lt;code&gt;BINARY, VARBINARY&lt;/code&gt; or &lt;code&gt;LONGVARBINARY&lt;/code&gt; value. The
 2333      * bold SQL type designates the recommended return types that this method is
 2334      * used to retrieve.
 2335      * @see #getAsciiStream(String)
 2336      */
 2337     public java.io.InputStream getAsciiStream(int columnIndex) throws SQLException {
 2338         Object value;
 2339 
 2340         // always free an old stream
 2341         asciiStream = null;
 2342 
 2343         // sanity check
 2344         checkIndex(columnIndex);
 2345         //make sure the cursor is on a vlid row
 2346         checkCursor();
 2347 
 2348         value =  getCurrentRow().getColumnObject(columnIndex);
 2349         if (value == null) {
 2350             lastValueNull = true;
 2351             return null;
 2352         }
 2353 
<a name="5" id="anc5"></a><span class="line-modified"> 2354         if (isString(RowSetMD.getColumnType(columnIndex))) {</span>
<span class="line-modified"> 2355             asciiStream = new ByteArrayInputStream(((String)value).getBytes(US_ASCII));</span>
<span class="line-modified"> 2356         } else {</span>
<span class="line-modified"> 2357             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());</span>




 2358         }
 2359 
 2360         return asciiStream;
 2361     }
 2362 
 2363     /**
 2364      * A column value can be retrieved as a stream of Unicode characters
 2365      * and then read in chunks from the stream.  This method is particularly
 2366      * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
 2367      * do any necessary conversion from the database format into Unicode.
 2368      *
 2369      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
 2370      * read prior to getting the value of any other column. The next
 2371      * call to a get method implicitly closes the stream. . Also, a
 2372      * stream may return 0 for available() whether there is data
 2373      * available or not.
 2374      *
 2375      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 2376      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 2377      *        and equal to or less than the number of columns in this rowset
 2378      * @return a Java input stream that delivers the database column value
 2379      * as a stream of two byte Unicode characters.  If the value is SQL NULL
 2380      * then the result is null.
 2381      * @throws SQLException if an error occurs
 2382      * @deprecated
 2383      */
 2384     @Deprecated
 2385     public java.io.InputStream getUnicodeStream(int columnIndex) throws SQLException {
 2386         // always free an old stream
 2387         unicodeStream = null;
 2388 
 2389         // sanity check.
 2390         checkIndex(columnIndex);
 2391         // make sure the cursor is on a valid row
 2392         checkCursor();
 2393 
 2394         if (isBinary(RowSetMD.getColumnType(columnIndex)) == false &amp;&amp;
 2395         isString(RowSetMD.getColumnType(columnIndex)) == false) {
 2396             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 2397         }
 2398 
 2399         Object value = getCurrentRow().getColumnObject(columnIndex);
 2400         if (value == null) {
 2401             lastValueNull = true;
 2402             return null;
 2403         }
 2404 
 2405         unicodeStream = new StringBufferInputStream(value.toString());
 2406 
 2407         return unicodeStream;
 2408     }
 2409 
 2410     /**
 2411      * Retrieves the value of the designated column in the current row of this
 2412      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.io.InputStream&lt;/code&gt;
 2413      * object.
 2414      * &lt;P&gt;
 2415      * A column value can be retrieved as a stream of uninterpreted bytes
 2416      * and then read in chunks from the stream.  This method is particularly
 2417      * suitable for retrieving large &lt;code&gt;LONGVARBINARY&lt;/code&gt; values.
 2418      *
 2419      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
 2420      * read prior to getting the value of any other column. The next
 2421      * call to a get method implicitly closes the stream. Also, a
 2422      * stream may return &lt;code&gt;0&lt;/code&gt; for
 2423      * &lt;code&gt;CachedRowSetImpl.available()&lt;/code&gt; whether there is data
 2424      * available or not.
 2425      *
 2426      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 2427      * is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 2428      * and equal to or less than the number of columns in the rowset
 2429      * @return a Java input stream that delivers the database column value
 2430      * as a stream of uninterpreted bytes.  If the value is SQL &lt;code&gt;NULL&lt;/code&gt;
 2431      * then the result is &lt;code&gt;null&lt;/code&gt;.
 2432      * @throws SQLException if (1) the given column index is out of bounds,
 2433      * (2) the cursor is not on one of this rowset&#39;s rows or its
 2434      * insert row, or (3) the designated column does not store an
 2435      * SQL &lt;code&gt;BINARY, VARBINARY&lt;/code&gt; or &lt;code&gt;&lt;b&gt;LONGVARBINARY&lt;/b&gt;&lt;/code&gt;
 2436      * The bold type indicates the SQL type that this method is recommened
 2437      * to retrieve.
 2438      * @see #getBinaryStream(String)
 2439      */
 2440     public java.io.InputStream getBinaryStream(int columnIndex) throws SQLException {
 2441 
 2442         // always free an old stream
 2443         binaryStream = null;
 2444 
 2445         // sanity check.
 2446         checkIndex(columnIndex);
 2447         // make sure the cursor is on a valid row
 2448         checkCursor();
 2449 
 2450         if (isBinary(RowSetMD.getColumnType(columnIndex)) == false) {
 2451             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 2452         }
 2453 
 2454         Object value = getCurrentRow().getColumnObject(columnIndex);
 2455         if (value == null) {
 2456             lastValueNull = true;
 2457             return null;
 2458         }
 2459 
 2460         binaryStream = new ByteArrayInputStream((byte[])value);
 2461 
 2462         return binaryStream;
 2463 
 2464     }
 2465 
 2466 
 2467     // Methods for accessing results by column name
 2468 
 2469     /**
 2470      * Retrieves the value stored in the designated column
 2471      * of the current row as a &lt;code&gt;String&lt;/code&gt; object.
 2472      *
 2473      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2474      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2475      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 2476      *         the result is &lt;code&gt;null&lt;/code&gt;
 2477      * @throws SQLException if (1) the given column name is not the name of
 2478      * a column in this rowset, (2) the cursor is not on one of
 2479      * this rowset&#39;s rows or its insert row, or (3) the designated
 2480      * column does not store an SQL {@code TINYINT, SMALLINT, INTEGER
 2481      * BIGINT, REAL, FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, }
 2482      * &lt;b&gt;{@code CHAR, VARCHAR}&lt;/b&gt; or
 2483      * &lt;b&gt;{@code LONGVARCHAR}&lt;/b&gt; value.
 2484      * The bold SQL type designates the recommended return type.
 2485      */
 2486     public String getString(String columnName) throws SQLException {
 2487         return getString(getColIdxByName(columnName));
 2488     }
 2489 
 2490     /**
 2491      * Retrieves the value stored in the designated column
 2492      * of the current row as a &lt;code&gt;boolean&lt;/code&gt; value.
 2493      *
 2494      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2495      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2496      * @return the column value as a &lt;code&gt;boolean&lt;/code&gt; in the Java programming
 2497      *        language; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 2498      *        the result is &lt;code&gt;false&lt;/code&gt;
 2499      * @throws SQLException if (1) the given column name is not the name of
 2500      *            a column in this rowset, (2) the cursor is not on one of
 2501      *            this rowset&#39;s rows or its insert row, or (3) the designated
 2502      *            column does not store an SQL &lt;code&gt;BOOLEAN&lt;/code&gt; value
 2503      * @see #getBoolean(int)
 2504      */
 2505     public boolean getBoolean(String columnName) throws SQLException {
 2506         return getBoolean(getColIdxByName(columnName));
 2507     }
 2508 
 2509     /**
 2510      * Retrieves the value stored in the designated column
 2511      * of the current row as a &lt;code&gt;byte&lt;/code&gt; value.
 2512      *
 2513      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2514      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2515      * @return the column value as a &lt;code&gt;byte&lt;/code&gt; in the Java programming
 2516      * language; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;0&lt;/code&gt;
 2517      * @throws SQLException if (1) the given column name is not the name of
 2518      * a column in this rowset, (2) the cursor is not on one of
 2519      * this rowset&#39;s rows or its insert row, or (3) the designated
 2520      * column does not store an SQL &lt;code&gt;&lt;B&gt;TINYINT&lt;/B&gt;, SMALLINT, INTEGER,
 2521      * BIGINT, REAL, FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR,
 2522      * VARCHAR&lt;/code&gt; or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The
 2523      * bold type designates the recommended return type
 2524      */
 2525     public byte getByte(String columnName) throws SQLException {
 2526         return getByte(getColIdxByName(columnName));
 2527     }
 2528 
 2529     /**
 2530      * Retrieves the value stored in the designated column
 2531      * of the current row as a &lt;code&gt;short&lt;/code&gt; value.
 2532      *
 2533      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2534      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2535      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 2536      *         the result is &lt;code&gt;0&lt;/code&gt;
 2537      * @throws SQLException if (1) the given column name is not the name of
 2538      * a column in this rowset, (2) the cursor is not on one of
 2539      * this rowset&#39;s rows or its insert row, or (3) the designated
 2540      * column does not store an SQL &lt;code&gt;TINYINT, &lt;b&gt;SMALLINT&lt;/b&gt;, INTEGER
 2541      * BIGINT, REAL, FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR,
 2542      * VARCHAR&lt;/code&gt; or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type
 2543      * designates the recommended return type.
 2544      * @see #getShort(int)
 2545      */
 2546     public short getShort(String columnName) throws SQLException {
 2547         return getShort(getColIdxByName(columnName));
 2548     }
 2549 
 2550     /**
 2551      * Retrieves the value stored in the designated column
 2552      * of the current row as an &lt;code&gt;int&lt;/code&gt; value.
 2553      *
 2554      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2555      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2556      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 2557      *         the result is &lt;code&gt;0&lt;/code&gt;
 2558      * @throws SQLException if (1) the given column name is not the name
 2559      * of a column in this rowset,
 2560      * (2) the cursor is not on one of this rowset&#39;s rows or its
 2561      * insert row, or (3) the designated column does not store an
 2562      * SQL &lt;code&gt;TINYINT, SMALLINT, &lt;b&gt;INTEGER&lt;/b&gt;, BIGINT, REAL
 2563      * FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR, VARCHAR&lt;/code&gt;
 2564      * or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type designates the
 2565      * recommended return type.
 2566      */
 2567     public int getInt(String columnName) throws SQLException {
 2568         return getInt(getColIdxByName(columnName));
 2569     }
 2570 
 2571     /**
 2572      * Retrieves the value stored in the designated column
 2573      * of the current row as a &lt;code&gt;long&lt;/code&gt; value.
 2574      *
 2575      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2576      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2577      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 2578      *         the result is &lt;code&gt;0&lt;/code&gt;
 2579      * @throws SQLException if (1) the given column name is not the name of
 2580      * a column in this rowset, (2) the cursor is not on one of
 2581      * this rowset&#39;s rows or its insert row, or (3) the designated
 2582      * column does not store an SQL &lt;code&gt;TINYINT, SMALLINT, INTEGER
 2583      * &lt;b&gt;BIGINT&lt;/b&gt;, REAL, FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR,
 2584      * VARCHAR&lt;/code&gt; or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type
 2585      * designates the recommended return type.
 2586      * @see #getLong(int)
 2587      */
 2588     public long getLong(String columnName) throws SQLException {
 2589         return getLong(getColIdxByName(columnName));
 2590     }
 2591 
 2592     /**
 2593      * Retrieves the value stored in the designated column
 2594      * of the current row as a &lt;code&gt;float&lt;/code&gt; value.
 2595      *
 2596      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2597      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2598      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 2599      *         the result is &lt;code&gt;0&lt;/code&gt;
 2600      * @throws SQLException if (1) the given column name is not the name of
 2601      * a column in this rowset, (2) the cursor is not on one of
 2602      * this rowset&#39;s rows or its insert row, or (3) the designated
 2603      * column does not store an SQL &lt;code&gt;TINYINT, SMALLINT, INTEGER
 2604      * BIGINT, &lt;b&gt;REAL&lt;/b&gt;, FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR,
 2605      * VARCHAR&lt;/code&gt; or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type
 2606      * designates the recommended return type.
 2607      * @see #getFloat(String)
 2608      */
 2609     public float getFloat(String columnName) throws SQLException {
 2610         return getFloat(getColIdxByName(columnName));
 2611     }
 2612 
 2613     /**
 2614      * Retrieves the value stored in the designated column
 2615      * of the current row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2616      * as a &lt;code&gt;double&lt;/code&gt; value.
 2617      *
 2618      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2619      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2620      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 2621      *         the result is &lt;code&gt;0&lt;/code&gt;
 2622      * @throws SQLException if (1) the given column name is not the name of
 2623      * a column in this rowset, (2) the cursor is not on one of
 2624      * this rowset&#39;s rows or its insert row, or (3) the designated
 2625      * column does not store an SQL &lt;code&gt;TINYINT, SMALLINT, INTEGER
 2626      * BIGINT, REAL, &lt;b&gt;FLOAT&lt;/b&gt;, &lt;b&gt;DOUBLE&lt;/b&gt;, DECIMAL, NUMERIC, BIT, CHAR,
 2627      * VARCHAR&lt;/code&gt; or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type
 2628      * designates the recommended return types.
 2629      * @see #getDouble(int)
 2630      */
 2631     public double getDouble(String columnName) throws SQLException {
 2632         return getDouble(getColIdxByName(columnName));
 2633     }
 2634 
 2635     /**
 2636      * Retrieves the value stored in the designated column
 2637      * of the current row as a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
 2638      *
 2639      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2640      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2641      * @param scale the number of digits to the right of the decimal point
 2642      * @return a java.math.BugDecimal object with &lt;code&gt;&lt;i&gt;scale&lt;/i&gt;&lt;/code&gt;
 2643      * number of digits to the right of the decimal point.
 2644      * @throws SQLException if (1) the given column name is not the name of
 2645      * a column in this rowset, (2) the cursor is not on one of
 2646      * this rowset&#39;s rows or its insert row, or (3) the designated
 2647      * column does not store an SQL &lt;code&gt;TINYINT, SMALLINT, INTEGER
 2648      * BIGINT, REAL, FLOAT, DOUBLE, &lt;b&gt;DECIMAL&lt;/b&gt;, &lt;b&gt;NUMERIC&lt;/b&gt;, BIT CHAR,
 2649      * VARCHAR&lt;/code&gt; or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type
 2650      * designates the recommended return type that this method is used to
 2651      * retrieve.
 2652      * @deprecated Use the &lt;code&gt;getBigDecimal(String columnName)&lt;/code&gt;
 2653      *             method instead
 2654      */
 2655     @Deprecated
 2656     public BigDecimal getBigDecimal(String columnName, int scale) throws SQLException {
 2657         return getBigDecimal(getColIdxByName(columnName), scale);
 2658     }
 2659 
 2660     /**
 2661      * Retrieves the value stored in the designated column
 2662      * of the current row as a &lt;code&gt;byte&lt;/code&gt; array.
 2663      * The bytes represent the raw values returned by the driver.
 2664      *
 2665      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2666      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2667      * @return the column value as a &lt;code&gt;byte&lt;/code&gt; array in the Java programming
 2668      * language; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;
 2669      * @throws SQLException if (1) the given column name is not the name of
 2670      * a column in this rowset, (2) the cursor is not on one of
 2671      * this rowset&#39;s rows or its insert row, or (3) the designated
 2672      * column does not store an SQL &lt;code&gt;&lt;b&gt;BINARY&lt;/b&gt;, &lt;b&gt;VARBINARY&lt;/b&gt;
 2673      * &lt;/code&gt; or &lt;code&gt;LONGVARBINARY&lt;/code&gt; values
 2674      * The bold SQL type designates the recommended return type.
 2675      * @see #getBytes(int)
 2676      */
 2677     public byte[] getBytes(String columnName) throws SQLException {
 2678         return getBytes(getColIdxByName(columnName));
 2679     }
 2680 
 2681     /**
 2682      * Retrieves the value stored in the designated column
 2683      * of the current row as a &lt;code&gt;java.sql.Date&lt;/code&gt; object.
 2684      *
 2685      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2686      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2687      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 2688      *         the result is &lt;code&gt;null&lt;/code&gt;
 2689      * @throws SQLException if (1) the given column name is not the name of
 2690      *            a column in this rowset, (2) the cursor is not on one of
 2691      *            this rowset&#39;s rows or its insert row, or (3) the designated
 2692      *            column does not store an SQL &lt;code&gt;DATE&lt;/code&gt; or
 2693      *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
 2694      */
 2695     public java.sql.Date getDate(String columnName) throws SQLException {
 2696         return getDate(getColIdxByName(columnName));
 2697     }
 2698 
 2699     /**
 2700      * Retrieves the value stored in the designated column
 2701      * of the current row as a &lt;code&gt;java.sql.Time&lt;/code&gt; object.
 2702      *
 2703      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2704      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2705      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 2706      *         the result is &lt;code&gt;null&lt;/code&gt;
 2707      * @throws SQLException if the given column name does not match one of
 2708      *            this rowset&#39;s column names or the cursor is not on one of
 2709      *            this rowset&#39;s rows or its insert row
 2710      */
 2711     public java.sql.Time getTime(String columnName) throws SQLException {
 2712         return getTime(getColIdxByName(columnName));
 2713     }
 2714 
 2715     /**
 2716      * Retrieves the value stored in the designated column
 2717      * of the current row as a &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object.
 2718      *
 2719      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2720      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2721      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 2722      *         the result is &lt;code&gt;null&lt;/code&gt;
 2723      * @throws SQLException if the given column name does not match one of
 2724      *            this rowset&#39;s column names or the cursor is not on one of
 2725      *            this rowset&#39;s rows or its insert row
 2726      */
 2727     public java.sql.Timestamp getTimestamp(String columnName) throws SQLException {
 2728         return getTimestamp(getColIdxByName(columnName));
 2729     }
 2730 
 2731     /**
 2732      * Retrieves the value of the designated column in the current row of this
 2733      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.io.InputStream&lt;/code&gt;
 2734      * object.
 2735      *
 2736      * A column value can be retrieved as a stream of ASCII characters
 2737      * and then read in chunks from the stream. This method is particularly
 2738      * suitable for retrieving large &lt;code&gt;LONGVARCHAR&lt;/code&gt; values. The
 2739      * &lt;code&gt;SyncProvider&lt;/code&gt; will rely on the JDBC driver to do any necessary
 2740      * conversion from the database format into ASCII format.
 2741      *
 2742      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
 2743      * be read prior to getting the value of any other column. The
 2744      * next call to a &lt;code&gt;getXXX&lt;/code&gt; method implicitly closes the stream.
 2745      *
 2746      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2747      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2748      * @return a Java input stream that delivers the database column value
 2749      *         as a stream of one-byte ASCII characters.  If the value is SQL
 2750      *         &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
 2751      * @throws SQLException if (1) the given column name is not the name of
 2752      * a column in this rowset
 2753      * (2) the cursor is not on one of this rowset&#39;s rows or its
 2754      * insert row, or (3) the designated column does not store an
 2755      * SQL &lt;code&gt;CHAR, VARCHAR&lt;/code&gt;, &lt;code&gt;&lt;b&gt;LONGVARCHAR&lt;/b&gt;&lt;/code&gt;
 2756      * &lt;code&gt;BINARY, VARBINARY&lt;/code&gt; or &lt;code&gt;LONGVARBINARY&lt;/code&gt; value. The
 2757      * bold SQL type designates the recommended return types that this method is
 2758      * used to retrieve.
 2759      * @see #getAsciiStream(int)
 2760      */
 2761     public java.io.InputStream getAsciiStream(String columnName) throws SQLException {
 2762         return getAsciiStream(getColIdxByName(columnName));
 2763 
 2764     }
 2765 
 2766     /**
 2767      * A column value can be retrieved as a stream of Unicode characters
 2768      * and then read in chunks from the stream.  This method is particularly
 2769      * suitable for retrieving large &lt;code&gt;LONGVARCHAR&lt;/code&gt; values.
 2770      * The JDBC driver will do any necessary conversion from the database
 2771      * format into Unicode.
 2772      *
 2773      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
 2774      * be read prior to getting the value of any other column. The
 2775      * next call to a &lt;code&gt;getXXX&lt;/code&gt; method implicitly closes the stream.
 2776      *
 2777      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2778      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2779      * @return a Java input stream that delivers the database column value
 2780      *         as a stream of two-byte Unicode characters.  If the value is
 2781      *         SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
 2782      * @throws SQLException if the given column name does not match one of
 2783      *            this rowset&#39;s column names or the cursor is not on one of
 2784      *            this rowset&#39;s rows or its insert row
 2785      * @deprecated use the method &lt;code&gt;getCharacterStream&lt;/code&gt; instead
 2786      */
 2787     @Deprecated
 2788     public java.io.InputStream getUnicodeStream(String columnName) throws SQLException {
 2789         return getUnicodeStream(getColIdxByName(columnName));
 2790     }
 2791 
 2792     /**
 2793      * Retrieves the value of the designated column in the current row of this
 2794      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.io.InputStream&lt;/code&gt;
 2795      * object.
 2796      * &lt;P&gt;
 2797      * A column value can be retrieved as a stream of uninterpreted bytes
 2798      * and then read in chunks from the stream.  This method is particularly
 2799      * suitable for retrieving large &lt;code&gt;LONGVARBINARY&lt;/code&gt; values.
 2800      *
 2801      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
 2802      * read prior to getting the value of any other column. The next
 2803      * call to a get method implicitly closes the stream. Also, a
 2804      * stream may return &lt;code&gt;0&lt;/code&gt; for &lt;code&gt;CachedRowSetImpl.available()&lt;/code&gt;
 2805      * whether there is data available or not.
 2806      *
 2807      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 2808      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 2809      * @return a Java input stream that delivers the database column value
 2810      *         as a stream of uninterpreted bytes.  If the value is SQL
 2811      *         &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
 2812      * @throws SQLException if (1) the given column name is unknown,
 2813      * (2) the cursor is not on one of this rowset&#39;s rows or its
 2814      * insert row, or (3) the designated column does not store an
 2815      * SQL &lt;code&gt;BINARY, VARBINARY&lt;/code&gt; or &lt;code&gt;&lt;b&gt;LONGVARBINARY&lt;/b&gt;&lt;/code&gt;
 2816      * The bold type indicates the SQL type that this method is recommened
 2817      * to retrieve.
 2818      * @see #getBinaryStream(int)
 2819      *
 2820      */
 2821     public java.io.InputStream getBinaryStream(String columnName) throws SQLException {
 2822         return getBinaryStream(getColIdxByName(columnName));
 2823     }
 2824 
 2825 
 2826     // Advanced features:
 2827 
 2828     /**
 2829      * The first warning reported by calls on this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 2830      * object is returned. Subsequent &lt;code&gt;CachedRowSetImpl&lt;/code&gt; warnings will
 2831      * be chained to this &lt;code&gt;SQLWarning&lt;/code&gt;.
 2832      *
 2833      * &lt;P&gt;The warning chain is automatically cleared each time a new
 2834      * row is read.
 2835      *
 2836      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This warning chain only covers warnings caused
 2837      * by &lt;code&gt;ResultSet&lt;/code&gt; methods.  Any warning caused by statement
 2838      * methods (such as reading OUT parameters) will be chained on the
 2839      * &lt;code&gt;Statement&lt;/code&gt; object.
 2840      *
 2841      * @return the first SQLWarning or null
 2842      */
 2843     public SQLWarning getWarnings() {
 2844         return sqlwarn;
 2845     }
 2846 
 2847     /**
 2848      * Clears all the warnings reporeted for the &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 2849      * object. After a call to this method, the &lt;code&gt;getWarnings&lt;/code&gt; method
 2850      * returns &lt;code&gt;null&lt;/code&gt; until a new warning is reported for this
 2851      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.
 2852      */
 2853     public void clearWarnings() {
 2854         sqlwarn = null;
 2855     }
 2856 
 2857     /**
 2858      * Retrieves the name of the SQL cursor used by this
 2859      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.
 2860      *
 2861      * &lt;P&gt;In SQL, a result table is retrieved through a cursor that is
 2862      * named. The current row of a &lt;code&gt;ResultSet&lt;/code&gt; can be updated or deleted
 2863      * using a positioned update/delete statement that references the
 2864      * cursor name. To ensure that the cursor has the proper isolation
 2865      * level to support an update operation, the cursor&#39;s &lt;code&gt;SELECT&lt;/code&gt;
 2866      * statement should be of the form &lt;code&gt;select for update&lt;/code&gt;.
 2867      * If the &lt;code&gt;for update&lt;/code&gt; clause
 2868      * is omitted, positioned updates may fail.
 2869      *
 2870      * &lt;P&gt;JDBC supports this SQL feature by providing the name of the
 2871      * SQL cursor used by a &lt;code&gt;ResultSet&lt;/code&gt; object. The current row
 2872      * of a result set is also the current row of this SQL cursor.
 2873      *
 2874      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; If positioned updates are not supported, an
 2875      * &lt;code&gt;SQLException&lt;/code&gt; is thrown.
 2876      *
 2877      * @return the SQL cursor name for this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s
 2878      *         cursor
 2879      * @throws SQLException if an error occurs
 2880      */
 2881     public String getCursorName() throws SQLException {
 2882         throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.posupdate&quot;).toString());
 2883     }
 2884 
 2885     /**
 2886      * Retrieves a &lt;code&gt;ResultSetMetaData&lt;/code&gt; object instance that
 2887      * contains information about the &lt;code&gt;CachedRowSet&lt;/code&gt; object.
 2888      * However, applications should cast the returned object to a
 2889      * &lt;code&gt;RowSetMetaData&lt;/code&gt; interface implementation. In the
 2890      * reference implementation, this cast can be done on the
 2891      * &lt;code&gt;RowSetMetaDataImpl&lt;/code&gt; class.
 2892      * &lt;P&gt;
 2893      * For example:
 2894      * &lt;pre&gt;
 2895      * CachedRowSet crs = new CachedRowSetImpl();
 2896      * RowSetMetaDataImpl metaData =
 2897      *     (RowSetMetaDataImpl)crs.getMetaData();
 2898      * // Set the number of columns in the RowSet object for
 2899      * // which this RowSetMetaDataImpl object was created to the
 2900      * // given number.
 2901      * metaData.setColumnCount(3);
 2902      * crs.setMetaData(metaData);
 2903      * &lt;/pre&gt;
 2904      *
 2905      * @return the &lt;code&gt;ResultSetMetaData&lt;/code&gt; object that describes this
 2906      *         &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s columns
 2907      * @throws SQLException if an error occurs in generating the RowSet
 2908      * meta data; or if the &lt;code&gt;CachedRowSetImpl&lt;/code&gt; is empty.
 2909      * @see javax.sql.RowSetMetaData
 2910      */
 2911     public ResultSetMetaData getMetaData() throws SQLException {
 2912         return (ResultSetMetaData)RowSetMD;
 2913     }
 2914 
 2915 
 2916     /**
 2917      * Retrieves the value of the designated column in the current row
 2918      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as an
 2919      * &lt;code&gt;Object&lt;/code&gt; value.
 2920      * &lt;P&gt;
 2921      * The type of the &lt;code&gt;Object&lt;/code&gt; will be the default
 2922      * Java object type corresponding to the column&#39;s SQL type,
 2923      * following the mapping for built-in types specified in the JDBC 3.0
 2924      * specification.
 2925      * &lt;P&gt;
 2926      * This method may also be used to read datatabase-specific
 2927      * abstract data types.
 2928      * &lt;P&gt;
 2929      * This implementation of the method &lt;code&gt;getObject&lt;/code&gt; extends its
 2930      * behavior so that it gets the attributes of an SQL structured type
 2931      * as an array of &lt;code&gt;Object&lt;/code&gt; values.  This method also custom
 2932      * maps SQL user-defined types to classes in the Java programming language.
 2933      * When the specified column contains
 2934      * a structured or distinct value, the behavior of this method is as
 2935      * if it were a call to the method &lt;code&gt;getObject(columnIndex,
 2936      * this.getStatement().getConnection().getTypeMap())&lt;/code&gt;.
 2937      *
 2938      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 2939      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 2940      *        and equal to or less than the number of columns in the rowset
 2941      * @return a &lt;code&gt;java.lang.Object&lt;/code&gt; holding the column value;
 2942      *         if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;
 2943      * @throws SQLException if the given column index is out of bounds,
 2944      *            the cursor is not on a valid row, or there is a problem getting
 2945      *            the &lt;code&gt;Class&lt;/code&gt; object for a custom mapping
 2946      * @see #getObject(String)
 2947      */
 2948     public Object getObject(int columnIndex) throws SQLException {
 2949         Object value;
 2950         Map&lt;String, Class&lt;?&gt;&gt; map;
 2951 
 2952         // sanity check.
 2953         checkIndex(columnIndex);
 2954         // make sure the cursor is on a valid row
 2955         checkCursor();
 2956 
 2957         setLastValueNull(false);
 2958         value = getCurrentRow().getColumnObject(columnIndex);
 2959 
 2960         // check for SQL NULL
 2961         if (value == null) {
 2962             setLastValueNull(true);
 2963             return null;
 2964         }
 2965         if (value instanceof Struct) {
 2966             Struct s = (Struct)value;
 2967             map = getTypeMap();
 2968             // look up the class in the map
 2969             Class&lt;?&gt; c = map.get(s.getSQLTypeName());
 2970             if (c != null) {
 2971                 // create new instance of the class
 2972                 SQLData obj = null;
 2973                 try {
 2974                     ReflectUtil.checkPackageAccess(c);
 2975                     @SuppressWarnings(&quot;deprecation&quot;)
 2976                     Object tmp = c.newInstance();
 2977                     obj = (SQLData) tmp;
 2978                 } catch(Exception ex) {
 2979                     throw new SQLException(&quot;Unable to Instantiate: &quot;, ex);
 2980                 }
 2981                 // get the attributes from the struct
 2982                 Object attribs[] = s.getAttributes(map);
 2983                 // create the SQLInput &quot;stream&quot;
 2984                 SQLInputImpl sqlInput = new SQLInputImpl(attribs, map);
 2985                 // read the values...
 2986                 obj.readSQL(sqlInput, s.getSQLTypeName());
 2987                 return (Object)obj;
 2988             }
 2989         }
 2990         return value;
 2991     }
 2992 
 2993     /**
 2994      * Retrieves the value of the designated column in the current row
 2995      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as an
 2996      * &lt;code&gt;Object&lt;/code&gt; value.
 2997      * &lt;P&gt;
 2998      * The type of the &lt;code&gt;Object&lt;/code&gt; will be the default
 2999      * Java object type corresponding to the column&#39;s SQL type,
 3000      * following the mapping for built-in types specified in the JDBC 3.0
 3001      * specification.
 3002      * &lt;P&gt;
 3003      * This method may also be used to read datatabase-specific
 3004      * abstract data types.
 3005      * &lt;P&gt;
 3006      * This implementation of the method &lt;code&gt;getObject&lt;/code&gt; extends its
 3007      * behavior so that it gets the attributes of an SQL structured type
 3008      * as an array of &lt;code&gt;Object&lt;/code&gt; values.  This method also custom
 3009      * maps SQL user-defined types to classes
 3010      * in the Java programming language. When the specified column contains
 3011      * a structured or distinct value, the behavior of this method is as
 3012      * if it were a call to the method &lt;code&gt;getObject(columnIndex,
 3013      * this.getStatement().getConnection().getTypeMap())&lt;/code&gt;.
 3014      *
 3015      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 3016      *        SQL name of a column in this rowset, ignoring case
 3017      * @return a &lt;code&gt;java.lang.Object&lt;/code&gt; holding the column value;
 3018      *         if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;
 3019      * @throws SQLException if (1) the given column name does not match one of
 3020      *            this rowset&#39;s column names, (2) the cursor is not
 3021      *            on a valid row, or (3) there is a problem getting
 3022      *            the &lt;code&gt;Class&lt;/code&gt; object for a custom mapping
 3023      * @see #getObject(int)
 3024      */
 3025     public Object getObject(String columnName) throws SQLException {
 3026         return getObject(getColIdxByName(columnName));
 3027     }
 3028 
 3029     //----------------------------------------------------------------
 3030 
 3031     /**
 3032      * Maps the given column name for one of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 3033      * object&#39;s columns to its column number.
 3034      *
 3035      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 3036      *        SQL name of a column in this rowset, ignoring case
 3037      * @return the column index of the given column name
 3038      * @throws SQLException if the given column name does not match one
 3039      *            of this rowset&#39;s column names
 3040      */
 3041     public int findColumn(String columnName) throws SQLException {
 3042         return getColIdxByName(columnName);
 3043     }
 3044 
 3045 
 3046     //--------------------------JDBC 2.0-----------------------------------
 3047 
 3048     //---------------------------------------------------------------------
 3049     // Getter&#39;s and Setter&#39;s
 3050     //---------------------------------------------------------------------
 3051 
 3052     /**
 3053      * Retrieves the value stored in the designated column
 3054      * of the current row as a &lt;code&gt;java.io.Reader&lt;/code&gt; object.
 3055      *
 3056      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
 3057      * be read prior to getting the value of any other column. The
 3058      * next call to a &lt;code&gt;getXXX&lt;/code&gt; method implicitly closes the stream.
 3059      *
 3060      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 3061      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 3062      *        and equal to or less than the number of columns in the rowset
 3063      * @return a Java character stream that delivers the database column value
 3064      * as a stream of two-byte unicode characters in a
 3065      * &lt;code&gt;java.io.Reader&lt;/code&gt; object.  If the value is
 3066      * SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
 3067      * @throws SQLException if (1) the given column index is out of bounds,
 3068      * (2) the cursor is not on one of this rowset&#39;s rows or its
 3069      * insert row, or (3) the designated column does not store an
 3070      * SQL &lt;code&gt;CHAR, VARCHAR, &lt;b&gt;LONGVARCHAR&lt;/b&gt;, BINARY, VARBINARY&lt;/code&gt; or
 3071      * &lt;code&gt;LONGVARBINARY&lt;/code&gt; value.
 3072      * The bold SQL type designates the recommended return type.
 3073      * @see #getCharacterStream(String)
 3074      */
 3075     public java.io.Reader getCharacterStream(int columnIndex) throws SQLException{
 3076 
 3077         // sanity check.
 3078         checkIndex(columnIndex);
 3079         // make sure the cursor is on a valid row
 3080         checkCursor();
 3081 
 3082         if (isBinary(RowSetMD.getColumnType(columnIndex))) {
 3083             Object value = getCurrentRow().getColumnObject(columnIndex);
 3084             if (value == null) {
 3085                 lastValueNull = true;
 3086                 return null;
 3087             }
 3088             charStream = new InputStreamReader
 3089             (new ByteArrayInputStream((byte[])value));
 3090         } else if (isString(RowSetMD.getColumnType(columnIndex))) {
 3091             Object value = getCurrentRow().getColumnObject(columnIndex);
 3092             if (value == null) {
 3093                 lastValueNull = true;
 3094                 return null;
 3095             }
 3096             charStream = new StringReader(value.toString());
 3097         } else {
 3098             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 3099         }
 3100 
 3101         return charStream;
 3102     }
 3103 
 3104     /**
 3105      * Retrieves the value stored in the designated column
 3106      * of the current row as a &lt;code&gt;java.io.Reader&lt;/code&gt; object.
 3107      *
 3108      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
 3109      * be read prior to getting the value of any other column. The
 3110      * next call to a &lt;code&gt;getXXX&lt;/code&gt; method implicitly closes the stream.
 3111      *
 3112      * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
 3113      *        a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 3114      * @return a Java input stream that delivers the database column value
 3115      *         as a stream of two-byte Unicode characters.  If the value is
 3116      *         SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
 3117      * @throws SQLException if (1) the given column name is not the name of
 3118      * a column in this rowset, (2) the cursor is not on one of
 3119      * this rowset&#39;s rows or its insert row, or (3) the designated
 3120      * column does not store an SQL &lt;code&gt;CHAR, VARCHAR, &lt;b&gt;LONGVARCHAR&lt;/b&gt;,
 3121      * BINARY, VARYBINARY&lt;/code&gt; or &lt;code&gt;LONGVARBINARY&lt;/code&gt; value.
 3122      * The bold SQL type designates the recommended return type.
 3123      */
 3124     public java.io.Reader getCharacterStream(String columnName) throws SQLException {
 3125         return getCharacterStream(getColIdxByName(columnName));
 3126     }
 3127 
 3128     /**
 3129      * Retrieves the value of the designated column in the current row
 3130      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 3131      * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
 3132      *
 3133      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 3134      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 3135      *        and equal to or less than the number of columns in the rowset
 3136      * @return a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; value with full precision;
 3137      *         if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;
 3138      * @throws SQLException if (1) the given column index is out of bounds,
 3139      * (2) the cursor is not on one of this rowset&#39;s rows or its
 3140      * insert row, or (3) the designated column does not store an
 3141      * SQL &lt;code&gt;TINYINT, SMALLINT, INTEGER, BIGINT, REAL,
 3142      * FLOAT, DOUBLE, &lt;b&gt;DECIMAL&lt;/b&gt;, &lt;b&gt;NUMERIC&lt;/b&gt;, BIT, CHAR, VARCHAR&lt;/code&gt;
 3143      * or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type designates the
 3144      * recommended return types that this method is used to retrieve.
 3145      * @see #getBigDecimal(String)
 3146      */
 3147     public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
 3148         Object value;
 3149 
 3150         // sanity check.
 3151         checkIndex(columnIndex);
 3152         // make sure the cursor is on a valid row
 3153         checkCursor();
 3154 
 3155         setLastValueNull(false);
 3156         value = getCurrentRow().getColumnObject(columnIndex);
 3157 
 3158         // check for SQL NULL
 3159         if (value == null) {
 3160             setLastValueNull(true);
 3161             return null;
 3162         }
 3163         try {
 3164             return (new BigDecimal(value.toString().trim()));
 3165         } catch (NumberFormatException ex) {
 3166             throw new SQLException(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.doublefail&quot;).toString(),
 3167                 new Object[] {value.toString().trim(), columnIndex}));
 3168         }
 3169     }
 3170 
 3171     /**
 3172      * Retrieves the value of the designated column in the current row
 3173      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 3174      * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
 3175      *
 3176      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 3177      *        SQL name of a column in this rowset, ignoring case
 3178      * @return a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; value with full precision;
 3179      *         if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;
 3180      * @throws SQLException if (1) the given column name is not the name of
 3181      * a column in this rowset, (2) the cursor is not on one of
 3182      * this rowset&#39;s rows or its insert row, or (3) the designated
 3183      * column does not store an SQL &lt;code&gt;TINYINT, SMALLINT, INTEGER
 3184      * BIGINT, REAL, FLOAT, DOUBLE, &lt;b&gt;DECIMAL&lt;/b&gt;, &lt;b&gt;NUMERIC&lt;/b&gt;, BIT CHAR,
 3185      * VARCHAR&lt;/code&gt; or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value. The bold SQL type
 3186      * designates the recommended return type that this method is used to
 3187      * retrieve
 3188      * @see #getBigDecimal(int)
 3189      */
 3190     public BigDecimal getBigDecimal(String columnName) throws SQLException {
 3191         return getBigDecimal(getColIdxByName(columnName));
 3192     }
 3193 
 3194     //---------------------------------------------------------------------
 3195     // Traversal/Positioning
 3196     //---------------------------------------------------------------------
 3197 
 3198     /**
 3199      * Returns the number of rows in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.
 3200      *
 3201      * @return number of rows in the rowset
 3202      */
 3203     public int size() {
 3204         return numRows;
 3205     }
 3206 
 3207     /**
 3208      * Indicates whether the cursor is before the first row in this
 3209      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.
 3210      *
 3211      * @return &lt;code&gt;true&lt;/code&gt; if the cursor is before the first row;
 3212      *         &lt;code&gt;false&lt;/code&gt; otherwise or if the rowset contains no rows
 3213      * @throws SQLException if an error occurs
 3214      */
 3215     public boolean isBeforeFirst() throws SQLException {
 3216         if (cursorPos == 0 &amp;&amp; numRows &gt; 0) {
 3217             return true;
 3218         } else {
 3219             return false;
 3220         }
 3221     }
 3222 
 3223     /**
 3224      * Indicates whether the cursor is after the last row in this
 3225      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.
 3226      *
 3227      * @return &lt;code&gt;true&lt;/code&gt; if the cursor is after the last row;
 3228      *         &lt;code&gt;false&lt;/code&gt; otherwise or if the rowset contains no rows
 3229      * @throws SQLException if an error occurs
 3230      */
 3231     public boolean isAfterLast() throws SQLException {
 3232         if (cursorPos == numRows+1 &amp;&amp; numRows &gt; 0) {
 3233             return true;
 3234         } else {
 3235             return false;
 3236         }
 3237     }
 3238 
 3239     /**
 3240      * Indicates whether the cursor is on the first row in this
 3241      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.
 3242      *
 3243      * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on the first row;
 3244      *         &lt;code&gt;false&lt;/code&gt; otherwise or if the rowset contains no rows
 3245      * @throws SQLException if an error occurs
 3246      */
 3247     public boolean isFirst() throws SQLException {
 3248         // this becomes nasty because of deletes.
 3249         int saveCursorPos = cursorPos;
 3250         int saveAbsoluteCursorPos = absolutePos;
 3251         internalFirst();
 3252         if (cursorPos == saveCursorPos) {
 3253             return true;
 3254         } else {
 3255             cursorPos = saveCursorPos;
 3256             absolutePos = saveAbsoluteCursorPos;
 3257             return false;
 3258         }
 3259     }
 3260 
 3261     /**
 3262      * Indicates whether the cursor is on the last row in this
 3263      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.
 3264      * &lt;P&gt;
 3265      * Note: Calling the method &lt;code&gt;isLast&lt;/code&gt; may be expensive
 3266      * because the JDBC driver might need to fetch ahead one row in order
 3267      * to determine whether the current row is the last row in this rowset.
 3268      *
 3269      * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on the last row;
 3270      *         &lt;code&gt;false&lt;/code&gt; otherwise or if this rowset contains no rows
 3271      * @throws SQLException if an error occurs
 3272      */
 3273     public boolean isLast() throws SQLException {
 3274         int saveCursorPos = cursorPos;
 3275         int saveAbsoluteCursorPos = absolutePos;
 3276         boolean saveShowDeleted = getShowDeleted();
 3277         setShowDeleted(true);
 3278         internalLast();
 3279         if (cursorPos == saveCursorPos) {
 3280             setShowDeleted(saveShowDeleted);
 3281             return true;
 3282         } else {
 3283             setShowDeleted(saveShowDeleted);
 3284             cursorPos = saveCursorPos;
 3285             absolutePos = saveAbsoluteCursorPos;
 3286             return false;
 3287         }
 3288     }
 3289 
 3290     /**
 3291      * Moves this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s cursor to the front of
 3292      * the rowset, just before the first row. This method has no effect if
 3293      * this rowset contains no rows.
 3294      *
 3295      * @throws SQLException if an error occurs or the type of this rowset
 3296      *            is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
 3297      */
 3298     public void beforeFirst() throws SQLException {
 3299        if (getType() == ResultSet.TYPE_FORWARD_ONLY) {
 3300             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.beforefirst&quot;).toString());
 3301         }
 3302         cursorPos = 0;
 3303         absolutePos = 0;
 3304         notifyCursorMoved();
 3305     }
 3306 
 3307     /**
 3308      * Moves this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s cursor to the end of
 3309      * the rowset, just after the last row. This method has no effect if
 3310      * this rowset contains no rows.
 3311      *
 3312      * @throws SQLException if an error occurs
 3313      */
 3314     public void afterLast() throws SQLException {
 3315         if (numRows &gt; 0) {
 3316             cursorPos = numRows + 1;
 3317             absolutePos = 0;
 3318             notifyCursorMoved();
 3319         }
 3320     }
 3321 
 3322     /**
 3323      * Moves this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s cursor to the first row
 3324      * and returns &lt;code&gt;true&lt;/code&gt; if the operation was successful.  This
 3325      * method also notifies registered listeners that the cursor has moved.
 3326      *
 3327      * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a valid row;
 3328      *         &lt;code&gt;false&lt;/code&gt; otherwise or if there are no rows in this
 3329      *         &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 3330      * @throws SQLException if the type of this rowset
 3331      *            is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
 3332      */
 3333     public boolean first() throws SQLException {
 3334         if(getType() == ResultSet.TYPE_FORWARD_ONLY) {
 3335             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.first&quot;).toString());
 3336         }
 3337 
 3338         // move and notify
 3339         boolean ret = this.internalFirst();
 3340         notifyCursorMoved();
 3341 
 3342         return ret;
 3343     }
 3344 
 3345     /**
 3346      * Moves this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s cursor to the first
 3347      * row and returns &lt;code&gt;true&lt;/code&gt; if the operation is successful.
 3348      * &lt;P&gt;
 3349      * This method is called internally by the methods &lt;code&gt;first&lt;/code&gt;,
 3350      * &lt;code&gt;isFirst&lt;/code&gt;, and &lt;code&gt;absolute&lt;/code&gt;.
 3351      * It in turn calls the method &lt;code&gt;internalNext&lt;/code&gt; in order to
 3352      * handle the case where the first row is a deleted row that is not visible.
 3353      * &lt;p&gt;
 3354      * This is a implementation only method and is not required as a standard
 3355      * implementation of the &lt;code&gt;CachedRowSet&lt;/code&gt; interface.
 3356      *
 3357      * @return &lt;code&gt;true&lt;/code&gt; if the cursor moved to the first row;
 3358      *         &lt;code&gt;false&lt;/code&gt; otherwise
 3359      * @throws SQLException if an error occurs
 3360      */
 3361     protected boolean internalFirst() throws SQLException {
 3362         boolean ret = false;
 3363 
 3364         if (numRows &gt; 0) {
 3365             cursorPos = 1;
 3366             if ((getShowDeleted() == false) &amp;&amp; (rowDeleted() == true)) {
 3367                 ret = internalNext();
 3368             } else {
 3369                 ret = true;
 3370             }
 3371         }
 3372 
 3373         if (ret == true)
 3374             absolutePos = 1;
 3375         else
 3376             absolutePos = 0;
 3377 
 3378         return ret;
 3379     }
 3380 
 3381     /**
 3382      * Moves this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s cursor to the last row
 3383      * and returns &lt;code&gt;true&lt;/code&gt; if the operation was successful.  This
 3384      * method also notifies registered listeners that the cursor has moved.
 3385      *
 3386      * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a valid row;
 3387      *         &lt;code&gt;false&lt;/code&gt; otherwise or if there are no rows in this
 3388      *         &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 3389      * @throws SQLException if the type of this rowset
 3390      *            is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
 3391      */
 3392     public boolean last() throws SQLException {
 3393         if (getType() == ResultSet.TYPE_FORWARD_ONLY) {
 3394             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.last&quot;).toString());
 3395         }
 3396 
 3397         // move and notify
 3398         boolean ret = this.internalLast();
 3399         notifyCursorMoved();
 3400 
 3401         return ret;
 3402     }
 3403 
 3404     /**
 3405      * Moves this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s cursor to the last
 3406      * row and returns &lt;code&gt;true&lt;/code&gt; if the operation is successful.
 3407      * &lt;P&gt;
 3408      * This method is called internally by the method &lt;code&gt;last&lt;/code&gt;
 3409      * when rows have been deleted and the deletions are not visible.
 3410      * The method &lt;code&gt;internalLast&lt;/code&gt; handles the case where the
 3411      * last row is a deleted row that is not visible by in turn calling
 3412      * the method &lt;code&gt;internalPrevious&lt;/code&gt;.
 3413      * &lt;p&gt;
 3414      * This is a implementation only method and is not required as a standard
 3415      * implementation of the &lt;code&gt;CachedRowSet&lt;/code&gt; interface.
 3416      *
 3417      * @return &lt;code&gt;true&lt;/code&gt; if the cursor moved to the last row;
 3418      *         &lt;code&gt;false&lt;/code&gt; otherwise
 3419      * @throws SQLException if an error occurs
 3420      */
 3421     protected boolean internalLast() throws SQLException {
 3422         boolean ret = false;
 3423 
 3424         if (numRows &gt; 0) {
 3425             cursorPos = numRows;
 3426             if ((getShowDeleted() == false) &amp;&amp; (rowDeleted() == true)) {
 3427                 ret = internalPrevious();
 3428             } else {
 3429                 ret = true;
 3430             }
 3431         }
 3432         if (ret == true)
 3433             absolutePos = numRows - numDeleted;
 3434         else
 3435             absolutePos = 0;
 3436         return ret;
 3437     }
 3438 
 3439     /**
 3440      * Returns the number of the current row in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 3441      * object. The first row is number 1, the second number 2, and so on.
 3442      *
 3443      * @return the number of the current row;  &lt;code&gt;0&lt;/code&gt; if there is no
 3444      *         current row
 3445      * @throws SQLException if an error occurs; or if the &lt;code&gt;CacheRowSetImpl&lt;/code&gt;
 3446      *         is empty
 3447      */
 3448     public int getRow() throws SQLException {
 3449         // are we on a valid row? Valid rows are between first and last
 3450         if (numRows &gt; 0 &amp;&amp;
 3451         cursorPos &gt; 0 &amp;&amp;
 3452         cursorPos &lt; (numRows + 1) &amp;&amp;
 3453         (getShowDeleted() == false &amp;&amp; rowDeleted() == false)) {
 3454             return absolutePos;
 3455         } else if (getShowDeleted() == true) {
 3456             return cursorPos;
 3457         } else {
 3458             return 0;
 3459         }
 3460     }
 3461 
 3462     /**
 3463      * Moves this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s cursor to the row number
 3464      * specified.
 3465      *
 3466      * &lt;p&gt;If the number is positive, the cursor moves to an absolute row with
 3467      * respect to the beginning of the rowset.  The first row is row 1, the second
 3468      * is row 2, and so on.  For example, the following command, in which
 3469      * &lt;code&gt;crs&lt;/code&gt; is a &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object, moves the cursor
 3470      * to the fourth row, starting from the beginning of the rowset.
 3471      * &lt;PRE&gt;&lt;code&gt;
 3472      *
 3473      *    crs.absolute(4);
 3474      *
 3475      * &lt;/code&gt; &lt;/PRE&gt;
 3476      * &lt;P&gt;
 3477      * If the number is negative, the cursor moves to an absolute row position
 3478      * with respect to the end of the rowset.  For example, calling
 3479      * &lt;code&gt;absolute(-1)&lt;/code&gt; positions the cursor on the last row,
 3480      * &lt;code&gt;absolute(-2)&lt;/code&gt; moves it on the next-to-last row, and so on.
 3481      * If the &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object &lt;code&gt;crs&lt;/code&gt; has five rows,
 3482      * the following command moves the cursor to the fourth-to-last row, which
 3483      * in the case of a  rowset with five rows, is also the second row, counting
 3484      * from the beginning.
 3485      * &lt;PRE&gt;&lt;code&gt;
 3486      *
 3487      *    crs.absolute(-4);
 3488      *
 3489      * &lt;/code&gt; &lt;/PRE&gt;
 3490      *
 3491      * If the number specified is larger than the number of rows, the cursor
 3492      * will move to the position after the last row. If the number specified
 3493      * would move the cursor one or more rows before the first row, the cursor
 3494      * moves to the position before the first row.
 3495      * &lt;P&gt;
 3496      * Note: Calling &lt;code&gt;absolute(1)&lt;/code&gt; is the same as calling the
 3497      * method &lt;code&gt;first()&lt;/code&gt;.  Calling &lt;code&gt;absolute(-1)&lt;/code&gt; is the
 3498      * same as calling &lt;code&gt;last()&lt;/code&gt;.
 3499      *
 3500      * @param row a positive number to indicate the row, starting row numbering from
 3501      *        the first row, which is &lt;code&gt;1&lt;/code&gt;; a negative number to indicate
 3502      *        the row, starting row numbering from the last row, which is
 3503      *        &lt;code&gt;-1&lt;/code&gt;; it must not be &lt;code&gt;0&lt;/code&gt;
 3504      * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on the rowset; &lt;code&gt;false&lt;/code&gt;
 3505      *         otherwise
 3506      * @throws SQLException if the given cursor position is &lt;code&gt;0&lt;/code&gt; or the
 3507      *            type of this rowset is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
 3508      */
 3509     public boolean absolute( int row ) throws SQLException {
 3510         if (row == 0 || getType() == ResultSet.TYPE_FORWARD_ONLY) {
 3511             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.absolute&quot;).toString());
 3512         }
 3513 
 3514         if (row &gt; 0) { // we are moving foward
 3515             if (row &gt; numRows) {
 3516                 // fell off the end
 3517                 afterLast();
 3518                 return false;
 3519             } else {
 3520                 if (absolutePos &lt;= 0)
 3521                     internalFirst();
 3522             }
 3523         } else { // we are moving backward
 3524             if (cursorPos + row &lt; 0) {
 3525                 // fell off the front
 3526                 beforeFirst();
 3527                 return false;
 3528             } else {
 3529                 if (absolutePos &gt;= 0)
 3530                     internalLast();
 3531             }
 3532         }
 3533 
 3534         // Now move towards the absolute row that we&#39;re looking for
 3535         while (absolutePos != row) {
 3536             if (absolutePos &lt; row) {
 3537                 if (!internalNext())
 3538                     break;
 3539             }
 3540             else {
 3541                 if (!internalPrevious())
 3542                     break;
 3543             }
 3544         }
 3545 
 3546         notifyCursorMoved();
 3547 
 3548         if (isAfterLast() || isBeforeFirst()) {
 3549             return false;
 3550         } else {
 3551             return true;
 3552         }
 3553     }
 3554 
 3555     /**
 3556      * Moves the cursor the specified number of rows from the current
 3557      * position, with a positive number moving it forward and a
 3558      * negative number moving it backward.
 3559      * &lt;P&gt;
 3560      * If the number is positive, the cursor moves the specified number of
 3561      * rows toward the end of the rowset, starting at the current row.
 3562      * For example, the following command, in which
 3563      * &lt;code&gt;crs&lt;/code&gt; is a &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with 100 rows,
 3564      * moves the cursor forward four rows from the current row.  If the
 3565      * current row is 50, the cursor would move to row 54.
 3566      * &lt;PRE&gt;&lt;code&gt;
 3567      *
 3568      *    crs.relative(4);
 3569      *
 3570      * &lt;/code&gt; &lt;/PRE&gt;
 3571      * &lt;P&gt;
 3572      * If the number is negative, the cursor moves back toward the beginning
 3573      * the specified number of rows, starting at the current row.
 3574      * For example, calling the method
 3575      * &lt;code&gt;absolute(-1)&lt;/code&gt; positions the cursor on the last row,
 3576      * &lt;code&gt;absolute(-2)&lt;/code&gt; moves it on the next-to-last row, and so on.
 3577      * If the &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object &lt;code&gt;crs&lt;/code&gt; has five rows,
 3578      * the following command moves the cursor to the fourth-to-last row, which
 3579      * in the case of a  rowset with five rows, is also the second row
 3580      * from the beginning.
 3581      * &lt;PRE&gt;&lt;code&gt;
 3582      *
 3583      *    crs.absolute(-4);
 3584      *
 3585      * &lt;/code&gt; &lt;/PRE&gt;
 3586      *
 3587      * If the number specified is larger than the number of rows, the cursor
 3588      * will move to the position after the last row. If the number specified
 3589      * would move the cursor one or more rows before the first row, the cursor
 3590      * moves to the position before the first row. In both cases, this method
 3591      * throws an &lt;code&gt;SQLException&lt;/code&gt;.
 3592      * &lt;P&gt;
 3593      * Note: Calling &lt;code&gt;absolute(1)&lt;/code&gt; is the same as calling the
 3594      * method &lt;code&gt;first()&lt;/code&gt;.  Calling &lt;code&gt;absolute(-1)&lt;/code&gt; is the
 3595      * same as calling &lt;code&gt;last()&lt;/code&gt;.  Calling &lt;code&gt;relative(0)&lt;/code&gt;
 3596      * is valid, but it does not change the cursor position.
 3597      *
 3598      * @param rows an &lt;code&gt;int&lt;/code&gt; indicating the number of rows to move
 3599      *             the cursor, starting at the current row; a positive number
 3600      *             moves the cursor forward; a negative number moves the cursor
 3601      *             backward; must not move the cursor past the valid
 3602      *             rows
 3603      * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a row in this
 3604      *         &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object; &lt;code&gt;false&lt;/code&gt;
 3605      *         otherwise
 3606      * @throws SQLException if there are no rows in this rowset, the cursor is
 3607      *         positioned either before the first row or after the last row, or
 3608      *         the rowset is type &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
 3609      */
 3610     public boolean relative(int rows) throws SQLException {
 3611         if (numRows == 0 || isBeforeFirst() ||
 3612         isAfterLast() || getType() == ResultSet.TYPE_FORWARD_ONLY) {
 3613             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.relative&quot;).toString());
 3614         }
 3615 
 3616         if (rows == 0) {
 3617             return true;
 3618         }
 3619 
 3620         if (rows &gt; 0) { // we are moving forward
 3621             if (cursorPos + rows &gt; numRows) {
 3622                 // fell off the end
 3623                 afterLast();
 3624             } else {
 3625                 for (int i=0; i &lt; rows; i++) {
 3626                     if (!internalNext())
 3627                         break;
 3628                 }
 3629             }
 3630         } else { // we are moving backward
 3631             if (cursorPos + rows &lt; 0) {
 3632                 // fell off the front
 3633                 beforeFirst();
 3634             } else {
 3635                 for (int i=rows; i &lt; 0; i++) {
 3636                     if (!internalPrevious())
 3637                         break;
 3638                 }
 3639             }
 3640         }
 3641         notifyCursorMoved();
 3642 
 3643         if (isAfterLast() || isBeforeFirst()) {
 3644             return false;
 3645         } else {
 3646             return true;
 3647         }
 3648     }
 3649 
 3650     /**
 3651      * Moves this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s cursor to the
 3652      * previous row and returns &lt;code&gt;true&lt;/code&gt; if the cursor is on
 3653      * a valid row or &lt;code&gt;false&lt;/code&gt; if it is not.
 3654      * This method also notifies all listeners registered with this
 3655      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object that its cursor has moved.
 3656      * &lt;P&gt;
 3657      * Note: calling the method &lt;code&gt;previous()&lt;/code&gt; is not the same
 3658      * as calling the method &lt;code&gt;relative(-1)&lt;/code&gt;.  This is true
 3659      * because it is possible to call &lt;code&gt;previous()&lt;/code&gt; from the insert
 3660      * row, from after the last row, or from the current row, whereas
 3661      * &lt;code&gt;relative&lt;/code&gt; may only be called from the current row.
 3662      * &lt;P&gt;
 3663      * The method &lt;code&gt;previous&lt;/code&gt; may used in a &lt;code&gt;while&lt;/code&gt;
 3664      * loop to iterate through a rowset starting after the last row
 3665      * and moving toward the beginning. The loop ends when &lt;code&gt;previous&lt;/code&gt;
 3666      * returns &lt;code&gt;false&lt;/code&gt;, meaning that there are no more rows.
 3667      * For example, the following code fragment retrieves all the data in
 3668      * the &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object &lt;code&gt;crs&lt;/code&gt;, which has
 3669      * three columns.  Note that the cursor must initially be positioned
 3670      * after the last row so that the first call to the method
 3671      * &lt;code&gt;previous&lt;/code&gt; places the cursor on the last line.
 3672      * &lt;PRE&gt; &lt;code&gt;
 3673      *
 3674      *     crs.afterLast();
 3675      *     while (previous()) {
 3676      *         String name = crs.getString(1);
 3677      *         int age = crs.getInt(2);
 3678      *         short ssn = crs.getShort(3);
 3679      *         System.out.println(name + &quot;   &quot; + age + &quot;   &quot; + ssn);
 3680      *     }
 3681      *
 3682      * &lt;/code&gt; &lt;/PRE&gt;
 3683      * This method throws an &lt;code&gt;SQLException&lt;/code&gt; if the cursor is not
 3684      * on a row in the rowset, before the first row, or after the last row.
 3685      *
 3686      * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a valid row;
 3687      *         &lt;code&gt;false&lt;/code&gt; if it is before the first row or after the
 3688      *         last row
 3689      * @throws SQLException if the cursor is not on a valid position or the
 3690      *           type of this rowset is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
 3691      */
 3692     public boolean previous() throws SQLException {
 3693         if (getType() == ResultSet.TYPE_FORWARD_ONLY) {
 3694             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.last&quot;).toString());
 3695         }
 3696         /*
 3697          * make sure things look sane. The cursor must be
 3698          * positioned in the rowset or before first (0) or
 3699          * after last (numRows + 1)
 3700          */
 3701         if (cursorPos &lt; 0 || cursorPos &gt; numRows + 1) {
 3702             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcp&quot;).toString());
 3703         }
 3704         // move and notify
 3705         boolean ret = this.internalPrevious();
 3706         notifyCursorMoved();
 3707 
 3708         return ret;
 3709     }
 3710 
 3711     /**
 3712      * Moves the cursor to the previous row in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 3713      * object, skipping past deleted rows that are not visible; returns
 3714      * &lt;code&gt;true&lt;/code&gt; if the cursor is on a row in this rowset and
 3715      * &lt;code&gt;false&lt;/code&gt; when the cursor goes before the first row.
 3716      * &lt;P&gt;
 3717      * This method is called internally by the method &lt;code&gt;previous&lt;/code&gt;.
 3718      * &lt;P&gt;
 3719      * This is a implementation only method and is not required as a standard
 3720      * implementation of the &lt;code&gt;CachedRowSet&lt;/code&gt; interface.
 3721      *
 3722      * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a row in this rowset;
 3723      *         &lt;code&gt;false&lt;/code&gt; when the cursor reaches the position before
 3724      *         the first row
 3725      * @throws SQLException if an error occurs
 3726      */
 3727     protected boolean internalPrevious() throws SQLException {
 3728         boolean ret = false;
 3729 
 3730         do {
 3731             if (cursorPos &gt; 1) {
 3732                 --cursorPos;
 3733                 ret = true;
 3734             } else if (cursorPos == 1) {
 3735                 // decrement to before first
 3736                 --cursorPos;
 3737                 ret = false;
 3738                 break;
 3739             }
 3740         } while ((getShowDeleted() == false) &amp;&amp; (rowDeleted() == true));
 3741 
 3742         /*
 3743          * Each call to internalPrevious may move the cursor
 3744          * over multiple rows, the absolute position moves one row
 3745          */
 3746         if (ret == true)
 3747             --absolutePos;
 3748         else
 3749             absolutePos = 0;
 3750 
 3751         return ret;
 3752     }
 3753 
 3754 
 3755     //---------------------------------------------------------------------
 3756     // Updates
 3757     //---------------------------------------------------------------------
 3758 
 3759     /**
 3760      * Indicates whether the current row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 3761      * object has been updated.  The value returned
 3762      * depends on whether this rowset can detect updates: &lt;code&gt;false&lt;/code&gt;
 3763      * will always be returned if it does not detect updates.
 3764      *
 3765      * @return &lt;code&gt;true&lt;/code&gt; if the row has been visibly updated
 3766      *         by the owner or another and updates are detected;
 3767      *         &lt;code&gt;false&lt;/code&gt; otherwise
 3768      * @throws SQLException if the cursor is on the insert row or not
 3769      *            not on a valid row
 3770      *
 3771      * @see DatabaseMetaData#updatesAreDetected
 3772      */
 3773     public boolean rowUpdated() throws SQLException {
 3774         // make sure the cursor is on a valid row
 3775         checkCursor();
 3776         if (onInsertRow == true) {
 3777             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidop&quot;).toString());
 3778         }
 3779         return(((Row)getCurrentRow()).getUpdated());
 3780     }
 3781 
 3782     /**
 3783      * Indicates whether the designated column of the current row of
 3784      * this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object has been updated. The
 3785      * value returned depends on whether this rowset can detcted updates:
 3786      * &lt;code&gt;false&lt;/code&gt; will always be returned if it does not detect updates.
 3787      *
 3788      * @param idx the index identifier of the column that may be have been updated.
 3789      * @return &lt;code&gt;true&lt;/code&gt; is the designated column has been updated
 3790      * and the rowset detects updates; &lt;code&gt;false&lt;/code&gt; if the rowset has not
 3791      * been updated or the rowset does not detect updates
 3792      * @throws SQLException if the cursor is on the insert row or not
 3793      *          on a valid row
 3794      * @see DatabaseMetaData#updatesAreDetected
 3795      */
 3796     public boolean columnUpdated(int idx) throws SQLException {
 3797         // make sure the cursor is on a valid row
 3798         checkCursor();
 3799         if (onInsertRow == true) {
 3800             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidop&quot;).toString());
 3801         }
 3802         return (((Row)getCurrentRow()).getColUpdated(idx - 1));
 3803     }
 3804 
 3805     /**
 3806      * Indicates whether the designated column of the current row of
 3807      * this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object has been updated. The
 3808      * value returned depends on whether this rowset can detcted updates:
 3809      * &lt;code&gt;false&lt;/code&gt; will always be returned if it does not detect updates.
 3810      *
 3811      * @param columnName the &lt;code&gt;String&lt;/code&gt; column name column that may be have
 3812      * been updated.
 3813      * @return &lt;code&gt;true&lt;/code&gt; is the designated column has been updated
 3814      * and the rowset detects updates; &lt;code&gt;false&lt;/code&gt; if the rowset has not
 3815      * been updated or the rowset does not detect updates
 3816      * @throws SQLException if the cursor is on the insert row or not
 3817      *          on a valid row
 3818      * @see DatabaseMetaData#updatesAreDetected
 3819      */
 3820     public boolean columnUpdated(String columnName) throws SQLException {
 3821         return columnUpdated(getColIdxByName(columnName));
 3822     }
 3823 
 3824     /**
 3825      * Indicates whether the current row has been inserted.  The value returned
 3826      * depends on whether or not the rowset can detect visible inserts.
 3827      *
 3828      * @return &lt;code&gt;true&lt;/code&gt; if a row has been inserted and inserts are detected;
 3829      *         &lt;code&gt;false&lt;/code&gt; otherwise
 3830      * @throws SQLException if the cursor is on the insert row or not
 3831      *            not on a valid row
 3832      *
 3833      * @see DatabaseMetaData#insertsAreDetected
 3834      */
 3835     public boolean rowInserted() throws SQLException {
 3836         // make sure the cursor is on a valid row
 3837         checkCursor();
 3838         if (onInsertRow == true) {
 3839             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidop&quot;).toString());
 3840         }
 3841         return(((Row)getCurrentRow()).getInserted());
 3842     }
 3843 
 3844     /**
 3845      * Indicates whether the current row has been deleted.  A deleted row
 3846      * may leave a visible &quot;hole&quot; in a rowset.  This method can be used to
 3847      * detect such holes if the rowset can detect deletions. This method
 3848      * will always return &lt;code&gt;false&lt;/code&gt; if this rowset cannot detect
 3849      * deletions.
 3850      *
 3851      * @return &lt;code&gt;true&lt;/code&gt; if (1)the current row is blank, indicating that
 3852      *         the row has been deleted, and (2)deletions are detected;
 3853      *         &lt;code&gt;false&lt;/code&gt; otherwise
 3854      * @throws SQLException if the cursor is on a valid row in this rowset
 3855      * @see DatabaseMetaData#deletesAreDetected
 3856      */
 3857     public boolean rowDeleted() throws SQLException {
 3858         // make sure the cursor is on a valid row
 3859 
 3860         if (isAfterLast() == true ||
 3861         isBeforeFirst() == true ||
 3862         onInsertRow == true) {
 3863 
 3864             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcp&quot;).toString());
 3865         }
 3866         return(((Row)getCurrentRow()).getDeleted());
 3867     }
 3868 
 3869     /**
 3870      * Indicates whether the given SQL data type is a numberic type.
 3871      *
 3872      * @param type one of the constants from &lt;code&gt;java.sql.Types&lt;/code&gt;
 3873      * @return &lt;code&gt;true&lt;/code&gt; if the given type is &lt;code&gt;NUMERIC&lt;/code&gt;,&#39;
 3874      *         &lt;code&gt;DECIMAL&lt;/code&gt;, &lt;code&gt;BIT&lt;/code&gt;, &lt;code&gt;TINYINT&lt;/code&gt;,
 3875      *         &lt;code&gt;SMALLINT&lt;/code&gt;, &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;BIGINT&lt;/code&gt;,
 3876      *         &lt;code&gt;REAL&lt;/code&gt;, &lt;code&gt;DOUBLE&lt;/code&gt;, or &lt;code&gt;FLOAT&lt;/code&gt;;
 3877      *         &lt;code&gt;false&lt;/code&gt; otherwise
 3878      */
 3879     private boolean isNumeric(int type) {
 3880         switch (type) {
 3881             case java.sql.Types.NUMERIC:
 3882             case java.sql.Types.DECIMAL:
 3883             case java.sql.Types.BIT:
 3884             case java.sql.Types.TINYINT:
 3885             case java.sql.Types.SMALLINT:
 3886             case java.sql.Types.INTEGER:
 3887             case java.sql.Types.BIGINT:
 3888             case java.sql.Types.REAL:
 3889             case java.sql.Types.DOUBLE:
 3890             case java.sql.Types.FLOAT:
 3891                 return true;
 3892             default:
 3893                 return false;
 3894         }
 3895     }
 3896 
 3897     /**
 3898      * Indicates whether the given SQL data type is a string type.
 3899      *
 3900      * @param type one of the constants from &lt;code&gt;java.sql.Types&lt;/code&gt;
 3901      * @return &lt;code&gt;true&lt;/code&gt; if the given type is &lt;code&gt;CHAR&lt;/code&gt;,&#39;
 3902      *         &lt;code&gt;VARCHAR&lt;/code&gt;, or &lt;code&gt;LONGVARCHAR&lt;/code&gt;;
 3903      *         &lt;code&gt;false&lt;/code&gt; otherwise
 3904      */
 3905     private boolean isString(int type) {
 3906         switch (type) {
 3907             case java.sql.Types.CHAR:
 3908             case java.sql.Types.VARCHAR:
 3909             case java.sql.Types.LONGVARCHAR:
 3910                 return true;
 3911             default:
 3912                 return false;
 3913         }
 3914     }
 3915 
 3916     /**
 3917      * Indicates whether the given SQL data type is a binary type.
 3918      *
 3919      * @param type one of the constants from &lt;code&gt;java.sql.Types&lt;/code&gt;
 3920      * @return &lt;code&gt;true&lt;/code&gt; if the given type is &lt;code&gt;BINARY&lt;/code&gt;,&#39;
 3921      *         &lt;code&gt;VARBINARY&lt;/code&gt;, or &lt;code&gt;LONGVARBINARY&lt;/code&gt;;
 3922      *         &lt;code&gt;false&lt;/code&gt; otherwise
 3923      */
 3924     private boolean isBinary(int type) {
 3925         switch (type) {
 3926             case java.sql.Types.BINARY:
 3927             case java.sql.Types.VARBINARY:
 3928             case java.sql.Types.LONGVARBINARY:
 3929                 return true;
 3930             default:
 3931                 return false;
 3932         }
 3933     }
 3934 
 3935     /**
 3936      * Indicates whether the given SQL data type is a temporal type.
 3937      * This method is called internally by the conversion methods
 3938      * &lt;code&gt;convertNumeric&lt;/code&gt; and &lt;code&gt;convertTemporal&lt;/code&gt;.
 3939      *
 3940      * @param type one of the constants from &lt;code&gt;java.sql.Types&lt;/code&gt;
 3941      * @return &lt;code&gt;true&lt;/code&gt; if the given type is &lt;code&gt;DATE&lt;/code&gt;,
 3942      *         &lt;code&gt;TIME&lt;/code&gt;, or &lt;code&gt;TIMESTAMP&lt;/code&gt;;
 3943      *         &lt;code&gt;false&lt;/code&gt; otherwise
 3944      */
 3945     private boolean isTemporal(int type) {
 3946         switch (type) {
 3947             case java.sql.Types.DATE:
 3948             case java.sql.Types.TIME:
 3949             case java.sql.Types.TIMESTAMP:
 3950                 return true;
 3951             default:
 3952                 return false;
 3953         }
 3954     }
 3955 
 3956     /**
 3957      * Indicates whether the given SQL data type is a boolean type.
 3958      * This method is called internally by the conversion methods
 3959      * &lt;code&gt;convertNumeric&lt;/code&gt; and &lt;code&gt;convertBoolean&lt;/code&gt;.
 3960      *
 3961      * @param type one of the constants from &lt;code&gt;java.sql.Types&lt;/code&gt;
 3962      * @return &lt;code&gt;true&lt;/code&gt; if the given type is &lt;code&gt;BIT&lt;/code&gt;,
 3963      *         , or &lt;code&gt;BOOLEAN&lt;/code&gt;;
 3964      *         &lt;code&gt;false&lt;/code&gt; otherwise
 3965      */
 3966     private boolean isBoolean(int type) {
 3967         switch (type) {
 3968             case java.sql.Types.BIT:
 3969             case java.sql.Types.BOOLEAN:
 3970                 return true;
 3971             default:
 3972                 return false;
 3973         }
 3974     }
 3975 
 3976 
 3977     /**
 3978      * Converts the given &lt;code&gt;Object&lt;/code&gt; in the Java programming language
 3979      * to the standard mapping for the specified SQL target data type.
 3980      * The conversion must be to a string or numeric type, but there are no
 3981      * restrictions on the type to be converted.  If the source type and target
 3982      * type are the same, the given object is simply returned.
 3983      *
 3984      * @param srcObj the &lt;code&gt;Object&lt;/code&gt; in the Java programming language
 3985      *               that is to be converted to the target type
 3986      * @param srcType the data type that is the standard mapping in SQL of the
 3987      *                object to be converted; must be one of the constants in
 3988      *                &lt;code&gt;java.sql.Types&lt;/code&gt;
 3989      * @param trgType the SQL data type to which to convert the given object;
 3990      *                must be one of the following constants in
 3991      *                &lt;code&gt;java.sql.Types&lt;/code&gt;: &lt;code&gt;NUMERIC&lt;/code&gt;,
 3992      *         &lt;code&gt;DECIMAL&lt;/code&gt;, &lt;code&gt;BIT&lt;/code&gt;, &lt;code&gt;TINYINT&lt;/code&gt;,
 3993      *         &lt;code&gt;SMALLINT&lt;/code&gt;, &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;BIGINT&lt;/code&gt;,
 3994      *         &lt;code&gt;REAL&lt;/code&gt;, &lt;code&gt;DOUBLE&lt;/code&gt;, &lt;code&gt;FLOAT&lt;/code&gt;,
 3995      *         &lt;code&gt;VARCHAR&lt;/code&gt;, &lt;code&gt;LONGVARCHAR&lt;/code&gt;, or &lt;code&gt;CHAR&lt;/code&gt;
 3996      * @return an &lt;code&gt;Object&lt;/code&gt; value.that is
 3997      *         the standard object mapping for the target SQL type
 3998      * @throws SQLException if the given target type is not one of the string or
 3999      *         numeric types in &lt;code&gt;java.sql.Types&lt;/code&gt;
 4000      */
 4001     private Object convertNumeric(Object srcObj, int srcType,
 4002     int trgType) throws SQLException {
 4003 
 4004         if (srcType == trgType) {
 4005             return srcObj;
 4006         }
 4007 
 4008         if (isNumeric(trgType) == false &amp;&amp; isString(trgType) == false) {
 4009             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString() + trgType);
 4010         }
 4011 
 4012         try {
 4013             switch (trgType) {
 4014                 case java.sql.Types.BIT:
 4015                     Integer i = Integer.valueOf(srcObj.toString().trim());
 4016                     return i.equals(0) ?
 4017                     Boolean.valueOf(false) :
 4018                         Boolean.valueOf(true);
 4019                 case java.sql.Types.TINYINT:
 4020                     return Byte.valueOf(srcObj.toString().trim());
 4021                 case java.sql.Types.SMALLINT:
 4022                     return Short.valueOf(srcObj.toString().trim());
 4023                 case java.sql.Types.INTEGER:
 4024                     return Integer.valueOf(srcObj.toString().trim());
 4025                 case java.sql.Types.BIGINT:
 4026                     return Long.valueOf(srcObj.toString().trim());
 4027                 case java.sql.Types.NUMERIC:
 4028                 case java.sql.Types.DECIMAL:
 4029                     return new BigDecimal(srcObj.toString().trim());
 4030                 case java.sql.Types.REAL:
 4031                 case java.sql.Types.FLOAT:
 4032                     return Float.valueOf(srcObj.toString().trim());
 4033                 case java.sql.Types.DOUBLE:
 4034                     return Double.valueOf(srcObj.toString().trim());
 4035                 case java.sql.Types.CHAR:
 4036                 case java.sql.Types.VARCHAR:
 4037                 case java.sql.Types.LONGVARCHAR:
 4038                     return srcObj.toString();
 4039                 default:
 4040                     throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString()+ trgType);
 4041             }
 4042         } catch (NumberFormatException ex) {
 4043             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString() + trgType);
 4044         }
 4045     }
 4046 
 4047     /**
 4048      * Converts the given &lt;code&gt;Object&lt;/code&gt; in the Java programming language
 4049      * to the standard object mapping for the specified SQL target data type.
 4050      * The conversion must be to a string or temporal type, and there are also
 4051      * restrictions on the type to be converted.
 4052      * &lt;P&gt;
 4053      * &lt;TABLE ALIGN=&quot;CENTER&quot; BORDER CELLPADDING=10 BORDERCOLOR=&quot;#0000FF&quot;
 4054      * &lt;CAPTION ALIGN=&quot;CENTER&quot;&gt;&lt;B&gt;Parameters and Return Values&lt;/B&gt;&lt;/CAPTION&gt;
 4055      * &lt;TR&gt;
 4056      *   &lt;TD&gt;&lt;B&gt;Source SQL Type&lt;/B&gt;
 4057      *   &lt;TD&gt;&lt;B&gt;Target SQL Type&lt;/B&gt;
 4058      *   &lt;TD&gt;&lt;B&gt;Object Returned&lt;/B&gt;
 4059      * &lt;/TR&gt;
 4060      * &lt;TR&gt;
 4061      *   &lt;TD&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt;
 4062      *   &lt;TD&gt;&lt;code&gt;DATE&lt;/code&gt;
 4063      *   &lt;TD&gt;&lt;code&gt;java.sql.Date&lt;/code&gt;
 4064      * &lt;/TR&gt;
 4065      * &lt;TR&gt;
 4066      *   &lt;TD&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt;
 4067      *   &lt;TD&gt;&lt;code&gt;TIME&lt;/code&gt;
 4068      *   &lt;TD&gt;&lt;code&gt;java.sql.Time&lt;/code&gt;
 4069      * &lt;/TR&gt;
 4070      * &lt;TR&gt;
 4071      *   &lt;TD&gt;&lt;code&gt;TIME&lt;/code&gt;
 4072      *   &lt;TD&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt;
 4073      *   &lt;TD&gt;&lt;code&gt;java.sql.Timestamp&lt;/code&gt;
 4074      * &lt;/TR&gt;
 4075      * &lt;TR&gt;
 4076      *   &lt;TD&gt;&lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;TIME&lt;/code&gt;, or &lt;code&gt;TIMESTAMP&lt;/code&gt;
 4077      *   &lt;TD&gt;&lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;, or &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 4078      *   &lt;TD&gt;&lt;code&gt;java.lang.String&lt;/code&gt;
 4079      * &lt;/TR&gt;
 4080      * &lt;/TABLE&gt;
 4081      * &lt;P&gt;
 4082      * If the source type and target type are the same,
 4083      * the given object is simply returned.
 4084      *
 4085      * @param srcObj the &lt;code&gt;Object&lt;/code&gt; in the Java programming language
 4086      *               that is to be converted to the target type
 4087      * @param srcType the data type that is the standard mapping in SQL of the
 4088      *                object to be converted; must be one of the constants in
 4089      *                &lt;code&gt;java.sql.Types&lt;/code&gt;
 4090      * @param trgType the SQL data type to which to convert the given object;
 4091      *                must be one of the following constants in
 4092      *                &lt;code&gt;java.sql.Types&lt;/code&gt;: &lt;code&gt;DATE&lt;/code&gt;,
 4093      *         &lt;code&gt;TIME&lt;/code&gt;, &lt;code&gt;TIMESTAMP&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;,
 4094      *         &lt;code&gt;VARCHAR&lt;/code&gt;, or &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 4095      * @return an &lt;code&gt;Object&lt;/code&gt; value.that is
 4096      *         the standard object mapping for the target SQL type
 4097      * @throws SQLException if the given target type is not one of the string or
 4098      *         temporal types in &lt;code&gt;java.sql.Types&lt;/code&gt;
 4099      */
 4100     private Object convertTemporal(Object srcObj,
 4101     int srcType, int trgType) throws SQLException {
 4102 
 4103         if (srcType == trgType) {
 4104             return srcObj;
 4105         }
 4106 
 4107         if (isNumeric(trgType) == true ||
 4108         (isString(trgType) == false &amp;&amp; isTemporal(trgType) == false)) {
 4109             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 4110         }
 4111 
 4112         try {
 4113             switch (trgType) {
 4114                 case java.sql.Types.DATE:
 4115                     if (srcType == java.sql.Types.TIMESTAMP) {
 4116                         return new java.sql.Date(((java.sql.Timestamp)srcObj).getTime());
 4117                     } else {
 4118                         throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 4119                     }
 4120                 case java.sql.Types.TIMESTAMP:
 4121                     if (srcType == java.sql.Types.TIME) {
 4122                         return new Timestamp(((java.sql.Time)srcObj).getTime());
 4123                     } else {
 4124                         return new Timestamp(((java.sql.Date)srcObj).getTime());
 4125                     }
 4126                 case java.sql.Types.TIME:
 4127                     if (srcType == java.sql.Types.TIMESTAMP) {
 4128                         return new Time(((java.sql.Timestamp)srcObj).getTime());
 4129                     } else {
 4130                         throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 4131                     }
 4132                 case java.sql.Types.CHAR:
 4133                 case java.sql.Types.VARCHAR:
 4134                 case java.sql.Types.LONGVARCHAR:
 4135                     return srcObj.toString();
 4136                 default:
 4137                     throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 4138             }
 4139         } catch (NumberFormatException ex) {
 4140             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 4141         }
 4142 
 4143     }
 4144 
 4145     /**
 4146      * Converts the given &lt;code&gt;Object&lt;/code&gt; in the Java programming language
 4147      * to the standard mapping for the specified SQL target data type.
 4148      * The conversion must be to a string or numeric type, but there are no
 4149      * restrictions on the type to be converted.  If the source type and target
 4150      * type are the same, the given object is simply returned.
 4151      *
 4152      * @param srcObj the &lt;code&gt;Object&lt;/code&gt; in the Java programming language
 4153      *               that is to be converted to the target type
 4154      * @param srcType the data type that is the standard mapping in SQL of the
 4155      *                object to be converted; must be one of the constants in
 4156      *                &lt;code&gt;java.sql.Types&lt;/code&gt;
 4157      * @param trgType the SQL data type to which to convert the given object;
 4158      *                must be one of the following constants in
 4159      *                &lt;code&gt;java.sql.Types&lt;/code&gt;: &lt;code&gt;BIT&lt;/code&gt;,
 4160      *         or &lt;code&gt;BOOLEAN&lt;/code&gt;
 4161      * @return an &lt;code&gt;Object&lt;/code&gt; value.that is
 4162      *         the standard object mapping for the target SQL type
 4163      * @throws SQLException if the given target type is not one of the Boolean
 4164      *         types in &lt;code&gt;java.sql.Types&lt;/code&gt;
 4165      */
 4166     private Object convertBoolean(Object srcObj, int srcType,
 4167     int trgType) throws SQLException {
 4168 
 4169         if (srcType == trgType) {
 4170             return srcObj;
 4171         }
 4172 
 4173         if (isNumeric(trgType) == true ||
 4174         (isString(trgType) == false &amp;&amp; isBoolean(trgType) == false)) {
 4175             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 4176         }
 4177 
 4178 
 4179         try {
 4180             switch (trgType) {
 4181                 case java.sql.Types.BIT:
 4182                     Integer i = Integer.valueOf(srcObj.toString().trim());
 4183                     return i.equals(0) ?
 4184                     Boolean.valueOf(false) :
 4185                         Boolean.valueOf(true);
 4186                 case java.sql.Types.BOOLEAN:
 4187                     return Boolean.valueOf(srcObj.toString().trim());
 4188                 default:
 4189                     throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString()+ trgType);
 4190             }
 4191         } catch (NumberFormatException ex) {
 4192             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString() + trgType);
 4193         }
 4194     }
 4195 
 4196     /**
 4197      * Sets the designated nullable column in the current row or the
 4198      * insert row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with
 4199      * &lt;code&gt;null&lt;/code&gt; value.
 4200      * &lt;P&gt;
 4201      * This method updates a column value in the current row or the insert
 4202      * row of this rowset; however, another method must be called to complete
 4203      * the update process. If the cursor is on a row in the rowset, the
 4204      * method {@link #updateRow} must be called to mark the row as updated
 4205      * and to notify listeners that the row has changed.
 4206      * If the cursor is on the insert row, the method {@link #insertRow}
 4207      * must be called to insert the new row into this rowset and to notify
 4208      * listeners that a row has changed.
 4209      * &lt;P&gt;
 4210      * In order to propagate updates in this rowset to the underlying
 4211      * data source, an application must call the method {@link #acceptChanges}
 4212      * after it calls either &lt;code&gt;updateRow&lt;/code&gt; or &lt;code&gt;insertRow&lt;/code&gt;.
 4213      *
 4214      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4215      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4216      *        and equal to or less than the number of columns in this rowset
 4217      * @throws SQLException if (1) the given column index is out of bounds,
 4218      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4219      *            insert row, or (3) this rowset is
 4220      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4221      */
 4222     public void updateNull(int columnIndex) throws SQLException {
 4223         // sanity check.
 4224         checkIndex(columnIndex);
 4225         // make sure the cursor is on a valid row
 4226         checkCursor();
 4227 
 4228         BaseRow row = getCurrentRow();
 4229         row.setColumnObject(columnIndex, null);
 4230 
 4231     }
 4232 
 4233     /**
 4234      * Sets the designated column in either the current row or the insert
 4235      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4236      * &lt;code&gt;boolean&lt;/code&gt; value.
 4237      * &lt;P&gt;
 4238      * This method updates a column value in the current row or the insert
 4239      * row of this rowset, but it does not update the database.
 4240      * If the cursor is on a row in the rowset, the
 4241      * method {@link #updateRow} must be called to update the database.
 4242      * If the cursor is on the insert row, the method {@link #insertRow}
 4243      * must be called, which will insert the new row into both this rowset
 4244      * and the database. Both of these methods must be called before the
 4245      * cursor moves to another row.
 4246      *
 4247      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4248      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4249      *        and equal to or less than the number of columns in this rowset
 4250      * @param x the new column value
 4251      * @throws SQLException if (1) the given column index is out of bounds,
 4252      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4253      *            insert row, or (3) this rowset is
 4254      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4255      */
 4256     public void updateBoolean(int columnIndex, boolean x) throws SQLException {
 4257         // sanity check.
 4258         checkIndex(columnIndex);
 4259         // make sure the cursor is on a valid row
 4260         checkCursor();
 4261         Object obj = convertBoolean(Boolean.valueOf(x),
 4262         java.sql.Types.BIT,
 4263         RowSetMD.getColumnType(columnIndex));
 4264 
 4265         getCurrentRow().setColumnObject(columnIndex, obj);
 4266     }
 4267 
 4268     /**
 4269      * Sets the designated column in either the current row or the insert
 4270      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4271      * &lt;code&gt;byte&lt;/code&gt; value.
 4272      * &lt;P&gt;
 4273      * This method updates a column value in the current row or the insert
 4274      * row of this rowset, but it does not update the database.
 4275      * If the cursor is on a row in the rowset, the
 4276      * method {@link #updateRow} must be called to update the database.
 4277      * If the cursor is on the insert row, the method {@link #insertRow}
 4278      * must be called, which will insert the new row into both this rowset
 4279      * and the database. Both of these methods must be called before the
 4280      * cursor moves to another row.
 4281      *
 4282      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4283      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4284      *        and equal to or less than the number of columns in this rowset
 4285      * @param x the new column value
 4286      * @throws SQLException if (1) the given column index is out of bounds,
 4287      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4288      *            insert row, or (3) this rowset is
 4289      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4290      */
 4291     public void updateByte(int columnIndex, byte x) throws SQLException {
 4292         // sanity check.
 4293         checkIndex(columnIndex);
 4294         // make sure the cursor is on a valid row
 4295         checkCursor();
 4296 
 4297         Object obj = convertNumeric(Byte.valueOf(x),
 4298         java.sql.Types.TINYINT,
 4299         RowSetMD.getColumnType(columnIndex));
 4300 
 4301         getCurrentRow().setColumnObject(columnIndex, obj);
 4302     }
 4303 
 4304     /**
 4305      * Sets the designated column in either the current row or the insert
 4306      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4307      * &lt;code&gt;short&lt;/code&gt; value.
 4308      * &lt;P&gt;
 4309      * This method updates a column value in the current row or the insert
 4310      * row of this rowset, but it does not update the database.
 4311      * If the cursor is on a row in the rowset, the
 4312      * method {@link #updateRow} must be called to update the database.
 4313      * If the cursor is on the insert row, the method {@link #insertRow}
 4314      * must be called, which will insert the new row into both this rowset
 4315      * and the database. Both of these methods must be called before the
 4316      * cursor moves to another row.
 4317      *
 4318      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4319      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4320      *        and equal to or less than the number of columns in this rowset
 4321      * @param x the new column value
 4322      * @throws SQLException if (1) the given column index is out of bounds,
 4323      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4324      *            insert row, or (3) this rowset is
 4325      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4326      */
 4327     public void updateShort(int columnIndex, short x) throws SQLException {
 4328         // sanity check.
 4329         checkIndex(columnIndex);
 4330         // make sure the cursor is on a valid row
 4331         checkCursor();
 4332 
 4333         Object obj = convertNumeric(Short.valueOf(x),
 4334         java.sql.Types.SMALLINT,
 4335         RowSetMD.getColumnType(columnIndex));
 4336 
 4337         getCurrentRow().setColumnObject(columnIndex, obj);
 4338     }
 4339 
 4340     /**
 4341      * Sets the designated column in either the current row or the insert
 4342      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4343      * &lt;code&gt;int&lt;/code&gt; value.
 4344      * &lt;P&gt;
 4345      * This method updates a column value in the current row or the insert
 4346      * row of this rowset, but it does not update the database.
 4347      * If the cursor is on a row in the rowset, the
 4348      * method {@link #updateRow} must be called to update the database.
 4349      * If the cursor is on the insert row, the method {@link #insertRow}
 4350      * must be called, which will insert the new row into both this rowset
 4351      * and the database. Both of these methods must be called before the
 4352      * cursor moves to another row.
 4353      *
 4354      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4355      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4356      *        and equal to or less than the number of columns in this rowset
 4357      * @param x the new column value
 4358      * @throws SQLException if (1) the given column index is out of bounds,
 4359      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4360      *            insert row, or (3) this rowset is
 4361      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4362      */
 4363     public void updateInt(int columnIndex, int x) throws SQLException {
 4364         // sanity check.
 4365         checkIndex(columnIndex);
 4366         // make sure the cursor is on a valid row
 4367         checkCursor();
 4368         Object obj = convertNumeric(x,
 4369         java.sql.Types.INTEGER,
 4370         RowSetMD.getColumnType(columnIndex));
 4371 
 4372         getCurrentRow().setColumnObject(columnIndex, obj);
 4373     }
 4374 
 4375     /**
 4376      * Sets the designated column in either the current row or the insert
 4377      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4378      * &lt;code&gt;long&lt;/code&gt; value.
 4379      * &lt;P&gt;
 4380      * This method updates a column value in the current row or the insert
 4381      * row of this rowset, but it does not update the database.
 4382      * If the cursor is on a row in the rowset, the
 4383      * method {@link #updateRow} must be called to update the database.
 4384      * If the cursor is on the insert row, the method {@link #insertRow}
 4385      * must be called, which will insert the new row into both this rowset
 4386      * and the database. Both of these methods must be called before the
 4387      * cursor moves to another row.
 4388      *
 4389      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4390      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4391      *        and equal to or less than the number of columns in this rowset
 4392      * @param x the new column value
 4393      * @throws SQLException if (1) the given column index is out of bounds,
 4394      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4395      *            insert row, or (3) this rowset is
 4396      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4397      */
 4398     public void updateLong(int columnIndex, long x) throws SQLException {
 4399         // sanity check.
 4400         checkIndex(columnIndex);
 4401         // make sure the cursor is on a valid row
 4402         checkCursor();
 4403 
 4404         Object obj = convertNumeric(Long.valueOf(x),
 4405         java.sql.Types.BIGINT,
 4406         RowSetMD.getColumnType(columnIndex));
 4407 
 4408         getCurrentRow().setColumnObject(columnIndex, obj);
 4409 
 4410     }
 4411 
 4412     /**
 4413      * Sets the designated column in either the current row or the insert
 4414      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4415      * &lt;code&gt;float&lt;/code&gt; value.
 4416      * &lt;P&gt;
 4417      * This method updates a column value in the current row or the insert
 4418      * row of this rowset, but it does not update the database.
 4419      * If the cursor is on a row in the rowset, the
 4420      * method {@link #updateRow} must be called to update the database.
 4421      * If the cursor is on the insert row, the method {@link #insertRow}
 4422      * must be called, which will insert the new row into both this rowset
 4423      * and the database. Both of these methods must be called before the
 4424      * cursor moves to another row.
 4425      *
 4426      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4427      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4428      *        and equal to or less than the number of columns in this rowset
 4429      * @param x the new column value
 4430      * @throws SQLException if (1) the given column index is out of bounds,
 4431      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4432      *            insert row, or (3) this rowset is
 4433      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4434      */
 4435     public void updateFloat(int columnIndex, float x) throws SQLException {
 4436         // sanity check.
 4437         checkIndex(columnIndex);
 4438         // make sure the cursor is on a valid row
 4439         checkCursor();
 4440 
 4441         Object obj = convertNumeric(Float.valueOf(x),
 4442         java.sql.Types.REAL,
 4443         RowSetMD.getColumnType(columnIndex));
 4444 
 4445         getCurrentRow().setColumnObject(columnIndex, obj);
 4446     }
 4447 
 4448     /**
 4449      * Sets the designated column in either the current row or the insert
 4450      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4451      * &lt;code&gt;double&lt;/code&gt; value.
 4452      *
 4453      * This method updates a column value in either the current row or
 4454      * the insert row of this rowset, but it does not update the
 4455      * database.  If the cursor is on a row in the rowset, the
 4456      * method {@link #updateRow} must be called to update the database.
 4457      * If the cursor is on the insert row, the method {@link #insertRow}
 4458      * must be called, which will insert the new row into both this rowset
 4459      * and the database. Both of these methods must be called before the
 4460      * cursor moves to another row.
 4461      *
 4462      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4463      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4464      *        and equal to or less than the number of columns in this rowset
 4465      * @param x the new column value
 4466      * @throws SQLException if (1) the given column index is out of bounds,
 4467      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4468      *            insert row, or (3) this rowset is
 4469      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4470      */
 4471     public void updateDouble(int columnIndex, double x) throws SQLException {
 4472         // sanity check.
 4473         checkIndex(columnIndex);
 4474         // make sure the cursor is on a valid row
 4475         checkCursor();
 4476         Object obj = convertNumeric(Double.valueOf(x),
 4477         java.sql.Types.DOUBLE,
 4478         RowSetMD.getColumnType(columnIndex));
 4479 
 4480         getCurrentRow().setColumnObject(columnIndex, obj);
 4481     }
 4482 
 4483     /**
 4484      * Sets the designated column in either the current row or the insert
 4485      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4486      * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
 4487      * &lt;P&gt;
 4488      * This method updates a column value in the current row or the insert
 4489      * row of this rowset, but it does not update the database.
 4490      * If the cursor is on a row in the rowset, the
 4491      * method {@link #updateRow} must be called to update the database.
 4492      * If the cursor is on the insert row, the method {@link #insertRow}
 4493      * must be called, which will insert the new row into both this rowset
 4494      * and the database. Both of these methods must be called before the
 4495      * cursor moves to another row.
 4496      *
 4497      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4498      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4499      *        and equal to or less than the number of columns in this rowset
 4500      * @param x the new column value
 4501      * @throws SQLException if (1) the given column index is out of bounds,
 4502      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4503      *            insert row, or (3) this rowset is
 4504      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4505      */
 4506     public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
 4507         // sanity check.
 4508         checkIndex(columnIndex);
 4509         // make sure the cursor is on a valid row
 4510         checkCursor();
 4511 
 4512         Object obj = convertNumeric(x,
 4513         java.sql.Types.NUMERIC,
 4514         RowSetMD.getColumnType(columnIndex));
 4515 
 4516         getCurrentRow().setColumnObject(columnIndex, obj);
 4517     }
 4518 
 4519     /**
 4520      * Sets the designated column in either the current row or the insert
 4521      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4522      * &lt;code&gt;String&lt;/code&gt; object.
 4523      * &lt;P&gt;
 4524      * This method updates a column value in either the current row or
 4525      * the insert row of this rowset, but it does not update the
 4526      * database.  If the cursor is on a row in the rowset, the
 4527      * method {@link #updateRow} must be called to mark the row as updated.
 4528      * If the cursor is on the insert row, the method {@link #insertRow}
 4529      * must be called to insert the new row into this rowset and mark it
 4530      * as inserted. Both of these methods must be called before the
 4531      * cursor moves to another row.
 4532      * &lt;P&gt;
 4533      * The method &lt;code&gt;acceptChanges&lt;/code&gt; must be called if the
 4534      * updated values are to be written back to the underlying database.
 4535      *
 4536      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4537      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4538      *        and equal to or less than the number of columns in this rowset
 4539      * @param x the new column value
 4540      * @throws SQLException if (1) the given column index is out of bounds,
 4541      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4542      *            insert row, or (3) this rowset is
 4543      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4544      */
 4545     public void updateString(int columnIndex, String x) throws SQLException {
 4546         // sanity check.
 4547         checkIndex(columnIndex);
 4548         // make sure the cursor is on a valid row
 4549         checkCursor();
 4550 
 4551         getCurrentRow().setColumnObject(columnIndex, x);
 4552     }
 4553 
 4554     /**
 4555      * Sets the designated column in either the current row or the insert
 4556      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4557      * &lt;code&gt;byte&lt;/code&gt; array.
 4558      *
 4559      * This method updates a column value in either the current row or
 4560      * the insert row of this rowset, but it does not update the
 4561      * database.  If the cursor is on a row in the rowset, the
 4562      * method {@link #updateRow} must be called to update the database.
 4563      * If the cursor is on the insert row, the method {@link #insertRow}
 4564      * must be called, which will insert the new row into both this rowset
 4565      * and the database. Both of these methods must be called before the
 4566      * cursor moves to another row.
 4567      *
 4568      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4569      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4570      *        and equal to or less than the number of columns in this rowset
 4571      * @param x the new column value
 4572      * @throws SQLException if (1) the given column index is out of bounds,
 4573      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4574      *            insert row, or (3) this rowset is
 4575      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4576      */
 4577     public void updateBytes(int columnIndex, byte x[]) throws SQLException {
 4578         // sanity check.
 4579         checkIndex(columnIndex);
 4580         // make sure the cursor is on a valid row
 4581         checkCursor();
 4582 
 4583         if (isBinary(RowSetMD.getColumnType(columnIndex)) == false) {
 4584             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 4585         }
 4586 
 4587         getCurrentRow().setColumnObject(columnIndex, x);
 4588     }
 4589 
 4590     /**
 4591      * Sets the designated column in either the current row or the insert
 4592      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4593      * &lt;code&gt;Date&lt;/code&gt; object.
 4594      *
 4595      * This method updates a column value in either the current row or
 4596      * the insert row of this rowset, but it does not update the
 4597      * database.  If the cursor is on a row in the rowset, the
 4598      * method {@link #updateRow} must be called to update the database.
 4599      * If the cursor is on the insert row, the method {@link #insertRow}
 4600      * must be called, which will insert the new row into both this rowset
 4601      * and the database. Both of these methods must be called before the
 4602      * cursor moves to another row.
 4603      *
 4604      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4605      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4606      *        and equal to or less than the number of columns in this rowset
 4607      * @param x the new column value
 4608      * @throws SQLException if (1) the given column index is out of bounds,
 4609      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4610      *            insert row, (3) the type of the designated column is not
 4611      *            an SQL &lt;code&gt;DATE&lt;/code&gt; or &lt;code&gt;TIMESTAMP&lt;/code&gt;, or
 4612      *            (4) this rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4613      */
 4614     public void updateDate(int columnIndex, java.sql.Date x) throws SQLException {
 4615         // sanity check.
 4616         checkIndex(columnIndex);
 4617         // make sure the cursor is on a valid row
 4618         checkCursor();
 4619 
 4620         Object obj = convertTemporal(x,
 4621         java.sql.Types.DATE,
 4622         RowSetMD.getColumnType(columnIndex));
 4623 
 4624         getCurrentRow().setColumnObject(columnIndex, obj);
 4625     }
 4626 
 4627     /**
 4628      * Sets the designated column in either the current row or the insert
 4629      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4630      * &lt;code&gt;Time&lt;/code&gt; object.
 4631      *
 4632      * This method updates a column value in either the current row or
 4633      * the insert row of this rowset, but it does not update the
 4634      * database.  If the cursor is on a row in the rowset, the
 4635      * method {@link #updateRow} must be called to update the database.
 4636      * If the cursor is on the insert row, the method {@link #insertRow}
 4637      * must be called, which will insert the new row into both this rowset
 4638      * and the database. Both of these methods must be called before the
 4639      * cursor moves to another row.
 4640      *
 4641      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4642      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4643      *        and equal to or less than the number of columns in this rowset
 4644      * @param x the new column value
 4645      * @throws SQLException if (1) the given column index is out of bounds,
 4646      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4647      *            insert row, (3) the type of the designated column is not
 4648      *            an SQL &lt;code&gt;TIME&lt;/code&gt; or &lt;code&gt;TIMESTAMP&lt;/code&gt;, or
 4649      *            (4) this rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4650      */
 4651     public void updateTime(int columnIndex, java.sql.Time x) throws SQLException {
 4652         // sanity check.
 4653         checkIndex(columnIndex);
 4654         // make sure the cursor is on a valid row
 4655         checkCursor();
 4656 
 4657         Object obj = convertTemporal(x,
 4658         java.sql.Types.TIME,
 4659         RowSetMD.getColumnType(columnIndex));
 4660 
 4661         getCurrentRow().setColumnObject(columnIndex, obj);
 4662     }
 4663 
 4664     /**
 4665      * Sets the designated column in either the current row or the insert
 4666      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4667      * &lt;code&gt;Timestamp&lt;/code&gt; object.
 4668      *
 4669      * This method updates a column value in either the current row or
 4670      * the insert row of this rowset, but it does not update the
 4671      * database.  If the cursor is on a row in the rowset, the
 4672      * method {@link #updateRow} must be called to update the database.
 4673      * If the cursor is on the insert row, the method {@link #insertRow}
 4674      * must be called, which will insert the new row into both this rowset
 4675      * and the database. Both of these methods must be called before the
 4676      * cursor moves to another row.
 4677      *
 4678      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4679      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4680      *        and equal to or less than the number of columns in this rowset
 4681      * @param x the new column value
 4682      * @throws SQLException if (1) the given column index is out of bounds,
 4683      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4684      *            insert row, (3) the type of the designated column is not
 4685      *            an SQL &lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;TIME&lt;/code&gt;, or
 4686      *            &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this rowset is
 4687      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4688      */
 4689     public void updateTimestamp(int columnIndex, java.sql.Timestamp x) throws SQLException {
 4690         // sanity check.
 4691         checkIndex(columnIndex);
 4692         // make sure the cursor is on a valid row
 4693         checkCursor();
 4694 
 4695         Object obj = convertTemporal(x,
 4696         java.sql.Types.TIMESTAMP,
 4697         RowSetMD.getColumnType(columnIndex));
 4698 
 4699         getCurrentRow().setColumnObject(columnIndex, obj);
 4700     }
 4701 
 4702     /**
 4703      * Sets the designated column in either the current row or the insert
 4704      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4705      * ASCII stream value.
 4706      * &lt;P&gt;
 4707      * This method updates a column value in either the current row or
 4708      * the insert row of this rowset, but it does not update the
 4709      * database.  If the cursor is on a row in the rowset, the
 4710      * method {@link #updateRow} must be called to update the database.
 4711      * If the cursor is on the insert row, the method {@link #insertRow}
 4712      * must be called, which will insert the new row into both this rowset
 4713      * and the database. Both of these methods must be called before the
 4714      * cursor moves to another row.
 4715      *
 4716      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4717      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4718      *        and equal to or less than the number of columns in this rowset
 4719      * @param x the new column value
 4720      * @param length the number of one-byte ASCII characters in the stream
 4721      * @throws SQLException if this method is invoked
 4722      */
 4723     public void updateAsciiStream(int columnIndex, java.io.InputStream x, int length) throws SQLException {
 4724         // sanity Check
 4725         checkIndex(columnIndex);
 4726         // make sure the cursor is on a valid row
 4727         checkCursor();
 4728 
 4729 
 4730         if (isString(RowSetMD.getColumnType(columnIndex)) == false &amp;&amp;
 4731         isBinary(RowSetMD.getColumnType(columnIndex)) == false) {
 4732             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 4733         }
 4734 
 4735         byte buf[] = new byte[length];
 4736         try {
 4737             int charsRead = 0;
 4738             do {
 4739                 charsRead += x.read(buf, charsRead, length - charsRead);
 4740             } while (charsRead != length);
 4741             //Changed the condition check to check for length instead of -1
 4742         } catch (java.io.IOException ex) {
 4743             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.asciistream&quot;).toString());
 4744         }
 4745         String str = new String(buf);
 4746 
 4747         getCurrentRow().setColumnObject(columnIndex, str);
 4748 
 4749     }
 4750 
 4751     /**
 4752      * Sets the designated column in either the current row or the insert
 4753      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4754      * &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
 4755      * &lt;P&gt;
 4756      * This method updates a column value in either the current row or
 4757      * the insert row of this rowset, but it does not update the
 4758      * database.  If the cursor is on a row in the rowset, the
 4759      * method {@link #updateRow} must be called to update the database.
 4760      * If the cursor is on the insert row, the method {@link #insertRow}
 4761      * must be called, which will insert the new row into both this rowset
 4762      * and the database. Both of these methods must be called before the
 4763      * cursor moves to another row.
 4764      *
 4765      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4766      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4767      *        and equal to or less than the number of columns in this rowset
 4768      * @param x the new column value; must be a &lt;code&gt;java.io.InputStream&lt;/code&gt;
 4769      *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;, or
 4770      *          &lt;code&gt;LONGVARBINARY&lt;/code&gt; data
 4771      * @param length the length of the stream in bytes
 4772      * @throws SQLException if (1) the given column index is out of bounds,
 4773      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4774      *            insert row, (3) the data in the stream is not binary, or
 4775      *            (4) this rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4776      */
 4777     public void updateBinaryStream(int columnIndex, java.io.InputStream x,int length) throws SQLException {
 4778         // sanity Check
 4779         checkIndex(columnIndex);
 4780         // make sure the cursor is on a valid row
 4781         checkCursor();
 4782 
 4783         if (isBinary(RowSetMD.getColumnType(columnIndex)) == false) {
 4784             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 4785         }
 4786 
 4787         byte buf[] = new byte[length];
 4788         try {
 4789             int bytesRead = 0;
 4790             do {
 4791                 bytesRead += x.read(buf, bytesRead, length - bytesRead);
 4792             } while (bytesRead != -1);
 4793         } catch (java.io.IOException ex) {
 4794             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.binstream&quot;).toString());
 4795         }
 4796 
 4797         getCurrentRow().setColumnObject(columnIndex, buf);
 4798     }
 4799 
 4800     /**
 4801      * Sets the designated column in either the current row or the insert
 4802      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4803      * &lt;code&gt;java.io.Reader&lt;/code&gt; object.
 4804      * &lt;P&gt;
 4805      * This method updates a column value in either the current row or
 4806      * the insert row of this rowset, but it does not update the
 4807      * database.  If the cursor is on a row in the rowset, the
 4808      * method {@link #updateRow} must be called to update the database.
 4809      * If the cursor is on the insert row, the method {@link #insertRow}
 4810      * must be called, which will insert the new row into both this rowset
 4811      * and the database. Both of these methods must be called before the
 4812      * cursor moves to another row.
 4813      *
 4814      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4815      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4816      *        and equal to or less than the number of columns in this rowset
 4817      * @param x the new column value; must be a &lt;code&gt;java.io.Reader&lt;/code&gt;
 4818      *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;,
 4819      *          &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;,
 4820      *          or &lt;code&gt;LONGVARCHAR&lt;/code&gt; data
 4821      * @param length the length of the stream in characters
 4822      * @throws SQLException if (1) the given column index is out of bounds,
 4823      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4824      *            insert row, (3) the data in the stream is not a binary or
 4825      *            character type, or (4) this rowset is
 4826      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4827      */
 4828     public void updateCharacterStream(int columnIndex, java.io.Reader x, int length) throws SQLException {
 4829         // sanity Check
 4830         checkIndex(columnIndex);
 4831         // make sure the cursor is on a valid row
 4832         checkCursor();
 4833 
 4834         if (isString(RowSetMD.getColumnType(columnIndex)) == false &amp;&amp;
 4835         isBinary(RowSetMD.getColumnType(columnIndex)) == false) {
 4836             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 4837         }
 4838 
 4839         char buf[] = new char[length];
 4840         try {
 4841             int charsRead = 0;
 4842             do {
 4843                 charsRead += x.read(buf, charsRead, length - charsRead);
 4844             } while (charsRead != length);
 4845             //Changed the condition checking to check for length instead of -1
 4846         } catch (java.io.IOException ex) {
 4847             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.binstream&quot;).toString());
 4848         }
 4849         String str = new String(buf);
 4850 
 4851         getCurrentRow().setColumnObject(columnIndex, str);
 4852     }
 4853 
 4854     /**
 4855      * Sets the designated column in either the current row or the insert
 4856      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4857      * &lt;code&gt;Object&lt;/code&gt; value.  The &lt;code&gt;scale&lt;/code&gt; parameter indicates
 4858      * the number of digits to the right of the decimal point and is ignored
 4859      * if the new column value is not a type that will be mapped to an SQL
 4860      * &lt;code&gt;DECIMAL&lt;/code&gt; or &lt;code&gt;NUMERIC&lt;/code&gt; value.
 4861      * &lt;P&gt;
 4862      * This method updates a column value in either the current row or
 4863      * the insert row of this rowset, but it does not update the
 4864      * database.  If the cursor is on a row in the rowset, the
 4865      * method {@link #updateRow} must be called to update the database.
 4866      * If the cursor is on the insert row, the method {@link #insertRow}
 4867      * must be called, which will insert the new row into both this rowset
 4868      * and the database. Both of these methods must be called before the
 4869      * cursor moves to another row.
 4870      *
 4871      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4872      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4873      *        and equal to or less than the number of columns in this rowset
 4874      * @param x the new column value
 4875      * @param scale the number of digits to the right of the decimal point (for
 4876      *              &lt;code&gt;DECIMAL&lt;/code&gt; and &lt;code&gt;NUMERIC&lt;/code&gt; types only)
 4877      * @throws SQLException if (1) the given column index is out of bounds,
 4878      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4879      *            insert row, or (3) this rowset is
 4880      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4881      */
 4882     public void updateObject(int columnIndex, Object x, int scale) throws SQLException {
 4883         // sanity check.
 4884         checkIndex(columnIndex);
 4885         // make sure the cursor is on a valid row
 4886         checkCursor();
 4887 
 4888         int type = RowSetMD.getColumnType(columnIndex);
 4889         if (type == Types.DECIMAL || type == Types.NUMERIC) {
 4890             ((java.math.BigDecimal)x).setScale(scale);
 4891         }
 4892         getCurrentRow().setColumnObject(columnIndex, x);
 4893     }
 4894 
 4895     /**
 4896      * Sets the designated column in either the current row or the insert
 4897      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4898      * &lt;code&gt;Object&lt;/code&gt; value.
 4899      * &lt;P&gt;
 4900      * This method updates a column value in either the current row or
 4901      * the insert row of this rowset, but it does not update the
 4902      * database.  If the cursor is on a row in the rowset, the
 4903      * method {@link #updateRow} must be called to update the database.
 4904      * If the cursor is on the insert row, the method {@link #insertRow}
 4905      * must be called, which will insert the new row into both this rowset
 4906      * and the database. Both of these methods must be called before the
 4907      * cursor moves to another row.
 4908      *
 4909      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 4910      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 4911      *        and equal to or less than the number of columns in this rowset
 4912      * @param x the new column value
 4913      * @throws SQLException if (1) the given column index is out of bounds,
 4914      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 4915      *            insert row, or (3) this rowset is
 4916      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4917      */
 4918     public void updateObject(int columnIndex, Object x) throws SQLException {
 4919         // sanity check.
 4920         checkIndex(columnIndex);
 4921         // make sure the cursor is on a valid row
 4922         checkCursor();
 4923 
 4924         getCurrentRow().setColumnObject(columnIndex, x);
 4925     }
 4926 
 4927     /**
 4928      * Sets the designated nullable column in the current row or the
 4929      * insert row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with
 4930      * &lt;code&gt;null&lt;/code&gt; value.
 4931      * &lt;P&gt;
 4932      * This method updates a column value in the current row or the insert
 4933      * row of this rowset, but it does not update the database.
 4934      * If the cursor is on a row in the rowset, the
 4935      * method {@link #updateRow} must be called to update the database.
 4936      * If the cursor is on the insert row, the method {@link #insertRow}
 4937      * must be called, which will insert the new row into both this rowset
 4938      * and the database.
 4939      *
 4940      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 4941      *        SQL name of a column in this rowset, ignoring case
 4942      * @throws SQLException if (1) the given column name does not match the
 4943      *            name of a column in this rowset, (2) the cursor is not on
 4944      *            one of this rowset&#39;s rows or its insert row, or (3) this
 4945      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4946      */
 4947     public void updateNull(String columnName) throws SQLException {
 4948         updateNull(getColIdxByName(columnName));
 4949     }
 4950 
 4951     /**
 4952      * Sets the designated column in either the current row or the insert
 4953      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4954      * &lt;code&gt;boolean&lt;/code&gt; value.
 4955      * &lt;P&gt;
 4956      * This method updates a column value in the current row or the insert
 4957      * row of this rowset, but it does not update the database.
 4958      * If the cursor is on a row in the rowset, the
 4959      * method {@link #updateRow} must be called to update the database.
 4960      * If the cursor is on the insert row, the method {@link #insertRow}
 4961      * must be called, which will insert the new row into both this rowset
 4962      * and the database. Both of these methods must be called before the
 4963      * cursor moves to another row.
 4964      *
 4965      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 4966      *        SQL name of a column in this rowset, ignoring case
 4967      * @param x the new column value
 4968      * @throws SQLException if (1) the given column name does not match the
 4969      *            name of a column in this rowset, (2) the cursor is not on
 4970      *            one of this rowset&#39;s rows or its insert row, or (3) this
 4971      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4972      */
 4973     public void updateBoolean(String columnName, boolean x) throws SQLException {
 4974         updateBoolean(getColIdxByName(columnName), x);
 4975     }
 4976 
 4977     /**
 4978      * Sets the designated column in either the current row or the insert
 4979      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 4980      * &lt;code&gt;byte&lt;/code&gt; value.
 4981      * &lt;P&gt;
 4982      * This method updates a column value in the current row or the insert
 4983      * row of this rowset, but it does not update the database.
 4984      * If the cursor is on a row in the rowset, the
 4985      * method {@link #updateRow} must be called to update the database.
 4986      * If the cursor is on the insert row, the method {@link #insertRow}
 4987      * must be called, which will insert the new row into both this rowset
 4988      * and the database. Both of these methods must be called before the
 4989      * cursor moves to another row.
 4990      *
 4991      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 4992      *        SQL name of a column in this rowset, ignoring case
 4993      * @param x the new column value
 4994      * @throws SQLException if (1) the given column name does not match the
 4995      *            name of a column in this rowset, (2) the cursor is not on
 4996      *            one of this rowset&#39;s rows or its insert row, or (3) this
 4997      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 4998      */
 4999     public void updateByte(String columnName, byte x) throws SQLException {
 5000         updateByte(getColIdxByName(columnName), x);
 5001     }
 5002 
 5003     /**
 5004      * Sets the designated column in either the current row or the insert
 5005      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5006      * &lt;code&gt;short&lt;/code&gt; value.
 5007      * &lt;P&gt;
 5008      * This method updates a column value in the current row or the insert
 5009      * row of this rowset, but it does not update the database.
 5010      * If the cursor is on a row in the rowset, the
 5011      * method {@link #updateRow} must be called to update the database.
 5012      * If the cursor is on the insert row, the method {@link #insertRow}
 5013      * must be called, which will insert the new row into both this rowset
 5014      * and the database. Both of these methods must be called before the
 5015      * cursor moves to another row.
 5016      *
 5017      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5018      *        SQL name of a column in this rowset, ignoring case
 5019      * @param x the new column value
 5020      * @throws SQLException if (1) the given column name does not match the
 5021      *            name of a column in this rowset, (2) the cursor is not on
 5022      *            one of this rowset&#39;s rows or its insert row, or (3) this
 5023      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5024      */
 5025     public void updateShort(String columnName, short x) throws SQLException {
 5026         updateShort(getColIdxByName(columnName), x);
 5027     }
 5028 
 5029     /**
 5030      * Sets the designated column in either the current row or the insert
 5031      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5032      * &lt;code&gt;int&lt;/code&gt; value.
 5033      * &lt;P&gt;
 5034      * This method updates a column value in the current row or the insert
 5035      * row of this rowset, but it does not update the database.
 5036      * If the cursor is on a row in the rowset, the
 5037      * method {@link #updateRow} must be called to update the database.
 5038      * If the cursor is on the insert row, the method {@link #insertRow}
 5039      * must be called, which will insert the new row into both this rowset
 5040      * and the database. Both of these methods must be called before the
 5041      * cursor moves to another row.
 5042      *
 5043      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5044      *        SQL name of a column in this rowset, ignoring case
 5045      * @param x the new column value
 5046      * @throws SQLException if (1) the given column name does not match the
 5047      *            name of a column in this rowset, (2) the cursor is not on
 5048      *            one of this rowset&#39;s rows or its insert row, or (3) this
 5049      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5050      */
 5051     public void updateInt(String columnName, int x) throws SQLException {
 5052         updateInt(getColIdxByName(columnName), x);
 5053     }
 5054 
 5055     /**
 5056      * Sets the designated column in either the current row or the insert
 5057      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5058      * &lt;code&gt;long&lt;/code&gt; value.
 5059      * &lt;P&gt;
 5060      * This method updates a column value in the current row or the insert
 5061      * row of this rowset, but it does not update the database.
 5062      * If the cursor is on a row in the rowset, the
 5063      * method {@link #updateRow} must be called to update the database.
 5064      * If the cursor is on the insert row, the method {@link #insertRow}
 5065      * must be called, which will insert the new row into both this rowset
 5066      * and the database. Both of these methods must be called before the
 5067      * cursor moves to another row.
 5068      *
 5069      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5070      *        SQL name of a column in this rowset, ignoring case
 5071      * @param x the new column value
 5072      * @throws SQLException if (1) the given column name does not match the
 5073      *            name of a column in this rowset, (2) the cursor is not on
 5074      *            one of this rowset&#39;s rows or its insert row, or (3) this
 5075      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5076      */
 5077     public void updateLong(String columnName, long x) throws SQLException {
 5078         updateLong(getColIdxByName(columnName), x);
 5079     }
 5080 
 5081     /**
 5082      * Sets the designated column in either the current row or the insert
 5083      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5084      * &lt;code&gt;float&lt;/code&gt; value.
 5085      * &lt;P&gt;
 5086      * This method updates a column value in the current row or the insert
 5087      * row of this rowset, but it does not update the database.
 5088      * If the cursor is on a row in the rowset, the
 5089      * method {@link #updateRow} must be called to update the database.
 5090      * If the cursor is on the insert row, the method {@link #insertRow}
 5091      * must be called, which will insert the new row into both this rowset
 5092      * and the database. Both of these methods must be called before the
 5093      * cursor moves to another row.
 5094      *
 5095      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5096      *        SQL name of a column in this rowset, ignoring case
 5097      * @param x the new column value
 5098      * @throws SQLException if (1) the given column name does not match the
 5099      *            name of a column in this rowset, (2) the cursor is not on
 5100      *            one of this rowset&#39;s rows or its insert row, or (3) this
 5101      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5102      */
 5103     public void updateFloat(String columnName, float x) throws SQLException {
 5104         updateFloat(getColIdxByName(columnName), x);
 5105     }
 5106 
 5107     /**
 5108      * Sets the designated column in either the current row or the insert
 5109      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5110      * &lt;code&gt;double&lt;/code&gt; value.
 5111      *
 5112      * This method updates a column value in either the current row or
 5113      * the insert row of this rowset, but it does not update the
 5114      * database.  If the cursor is on a row in the rowset, the
 5115      * method {@link #updateRow} must be called to update the database.
 5116      * If the cursor is on the insert row, the method {@link #insertRow}
 5117      * must be called, which will insert the new row into both this rowset
 5118      * and the database. Both of these methods must be called before the
 5119      * cursor moves to another row.
 5120      *
 5121      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5122      *        SQL name of a column in this rowset, ignoring case
 5123      * @param x the new column value
 5124      * @throws SQLException if (1) the given column name does not match the
 5125      *            name of a column in this rowset, (2) the cursor is not on
 5126      *            one of this rowset&#39;s rows or its insert row, or (3) this
 5127      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5128      */
 5129     public void updateDouble(String columnName, double x) throws SQLException {
 5130         updateDouble(getColIdxByName(columnName), x);
 5131     }
 5132 
 5133     /**
 5134      * Sets the designated column in either the current row or the insert
 5135      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5136      * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
 5137      * &lt;P&gt;
 5138      * This method updates a column value in the current row or the insert
 5139      * row of this rowset, but it does not update the database.
 5140      * If the cursor is on a row in the rowset, the
 5141      * method {@link #updateRow} must be called to update the database.
 5142      * If the cursor is on the insert row, the method {@link #insertRow}
 5143      * must be called, which will insert the new row into both this rowset
 5144      * and the database. Both of these methods must be called before the
 5145      * cursor moves to another row.
 5146      *
 5147      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5148      *        SQL name of a column in this rowset, ignoring case
 5149      * @param x the new column value
 5150      * @throws SQLException if (1) the given column name does not match the
 5151      *            name of a column in this rowset, (2) the cursor is not on
 5152      *            one of this rowset&#39;s rows or its insert row, or (3) this
 5153      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5154      */
 5155     public void updateBigDecimal(String columnName, BigDecimal x) throws SQLException {
 5156         updateBigDecimal(getColIdxByName(columnName), x);
 5157     }
 5158 
 5159     /**
 5160      * Sets the designated column in either the current row or the insert
 5161      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5162      * &lt;code&gt;String&lt;/code&gt; object.
 5163      *
 5164      * This method updates a column value in either the current row or
 5165      * the insert row of this rowset, but it does not update the
 5166      * database.  If the cursor is on a row in the rowset, the
 5167      * method {@link #updateRow} must be called to update the database.
 5168      * If the cursor is on the insert row, the method {@link #insertRow}
 5169      * must be called, which will insert the new row into both this rowset
 5170      * and the database. Both of these methods must be called before the
 5171      * cursor moves to another row.
 5172      *
 5173      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5174      *        SQL name of a column in this rowset, ignoring case
 5175      * @param x the new column value
 5176      * @throws SQLException if (1) the given column name does not match the
 5177      *            name of a column in this rowset, (2) the cursor is not on
 5178      *            one of this rowset&#39;s rows or its insert row, or (3) this
 5179      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5180      */
 5181     public void updateString(String columnName, String x) throws SQLException {
 5182         updateString(getColIdxByName(columnName), x);
 5183     }
 5184 
 5185     /**
 5186      * Sets the designated column in either the current row or the insert
 5187      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5188      * &lt;code&gt;byte&lt;/code&gt; array.
 5189      *
 5190      * This method updates a column value in either the current row or
 5191      * the insert row of this rowset, but it does not update the
 5192      * database.  If the cursor is on a row in the rowset, the
 5193      * method {@link #updateRow} must be called to update the database.
 5194      * If the cursor is on the insert row, the method {@link #insertRow}
 5195      * must be called, which will insert the new row into both this rowset
 5196      * and the database. Both of these methods must be called before the
 5197      * cursor moves to another row.
 5198      *
 5199      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5200      *        SQL name of a column in this rowset, ignoring case
 5201      * @param x the new column value
 5202      * @throws SQLException if (1) the given column name does not match the
 5203      *            name of a column in this rowset, (2) the cursor is not on
 5204      *            one of this rowset&#39;s rows or its insert row, or (3) this
 5205      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5206      */
 5207     public void updateBytes(String columnName, byte x[]) throws SQLException {
 5208         updateBytes(getColIdxByName(columnName), x);
 5209     }
 5210 
 5211     /**
 5212      * Sets the designated column in either the current row or the insert
 5213      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5214      * &lt;code&gt;Date&lt;/code&gt; object.
 5215      *
 5216      * This method updates a column value in either the current row or
 5217      * the insert row of this rowset, but it does not update the
 5218      * database.  If the cursor is on a row in the rowset, the
 5219      * method {@link #updateRow} must be called to update the database.
 5220      * If the cursor is on the insert row, the method {@link #insertRow}
 5221      * must be called, which will insert the new row into both this rowset
 5222      * and the database. Both of these methods must be called before the
 5223      * cursor moves to another row.
 5224      *
 5225      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5226      *        SQL name of a column in this rowset, ignoring case
 5227      * @param x the new column value
 5228      * @throws SQLException if (1) the given column name does not match the
 5229      *            name of a column in this rowset, (2) the cursor is not on
 5230      *            one of this rowset&#39;s rows or its insert row, (3) the type
 5231      *            of the designated column is not an SQL &lt;code&gt;DATE&lt;/code&gt; or
 5232      *            &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this rowset is
 5233      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5234      */
 5235     public void updateDate(String columnName, java.sql.Date x) throws SQLException {
 5236         updateDate(getColIdxByName(columnName), x);
 5237     }
 5238 
 5239     /**
 5240      * Sets the designated column in either the current row or the insert
 5241      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5242      * &lt;code&gt;Time&lt;/code&gt; object.
 5243      *
 5244      * This method updates a column value in either the current row or
 5245      * the insert row of this rowset, but it does not update the
 5246      * database.  If the cursor is on a row in the rowset, the
 5247      * method {@link #updateRow} must be called to update the database.
 5248      * If the cursor is on the insert row, the method {@link #insertRow}
 5249      * must be called, which will insert the new row into both this rowset
 5250      * and the database. Both of these methods must be called before the
 5251      * cursor moves to another row.
 5252      *
 5253      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5254      *        SQL name of a column in this rowset, ignoring case
 5255      * @param x the new column value
 5256      * @throws SQLException if (1) the given column name does not match the
 5257      *            name of a column in this rowset, (2) the cursor is not on
 5258      *            one of this rowset&#39;s rows or its insert row, (3) the type
 5259      *            of the designated column is not an SQL &lt;code&gt;TIME&lt;/code&gt; or
 5260      *            &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this rowset is
 5261      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5262      */
 5263     public void updateTime(String columnName, java.sql.Time x) throws SQLException {
 5264         updateTime(getColIdxByName(columnName), x);
 5265     }
 5266 
 5267     /**
 5268      * Sets the designated column in either the current row or the insert
 5269      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5270      * &lt;code&gt;Timestamp&lt;/code&gt; object.
 5271      *
 5272      * This method updates a column value in either the current row or
 5273      * the insert row of this rowset, but it does not update the
 5274      * database.  If the cursor is on a row in the rowset, the
 5275      * method {@link #updateRow} must be called to update the database.
 5276      * If the cursor is on the insert row, the method {@link #insertRow}
 5277      * must be called, which will insert the new row into both this rowset
 5278      * and the database. Both of these methods must be called before the
 5279      * cursor moves to another row.
 5280      *
 5281      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5282      *        SQL name of a column in this rowset, ignoring case
 5283      * @param x the new column value
 5284      * @throws SQLException if the given column index is out of bounds or
 5285      *            the cursor is not on one of this rowset&#39;s rows or its
 5286      *            insert row
 5287      * @throws SQLException if (1) the given column name does not match the
 5288      *            name of a column in this rowset, (2) the cursor is not on
 5289      *            one of this rowset&#39;s rows or its insert row, (3) the type
 5290      *            of the designated column is not an SQL &lt;code&gt;DATE&lt;/code&gt;,
 5291      *            &lt;code&gt;TIME&lt;/code&gt;, or &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this
 5292      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5293      */
 5294     public void updateTimestamp(String columnName, java.sql.Timestamp x) throws SQLException {
 5295         updateTimestamp(getColIdxByName(columnName), x);
 5296     }
 5297 
 5298     /**
 5299      * Sets the designated column in either the current row or the insert
 5300      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5301      * ASCII stream value.
 5302      * &lt;P&gt;
 5303      * This method updates a column value in either the current row or
 5304      * the insert row of this rowset, but it does not update the
 5305      * database.  If the cursor is on a row in the rowset, the
 5306      * method {@link #updateRow} must be called to update the database.
 5307      * If the cursor is on the insert row, the method {@link #insertRow}
 5308      * must be called, which will insert the new row into both this rowset
 5309      * and the database. Both of these methods must be called before the
 5310      * cursor moves to another row.
 5311      *
 5312      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5313      *        SQL name of a column in this rowset, ignoring case
 5314      * @param x the new column value
 5315      * @param length the number of one-byte ASCII characters in the stream
 5316      */
 5317     public void updateAsciiStream(String columnName,
 5318     java.io.InputStream x,
 5319     int length) throws SQLException {
 5320         updateAsciiStream(getColIdxByName(columnName), x, length);
 5321     }
 5322 
 5323     /**
 5324      * Sets the designated column in either the current row or the insert
 5325      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5326      * &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
 5327      * &lt;P&gt;
 5328      * This method updates a column value in either the current row or
 5329      * the insert row of this rowset, but it does not update the
 5330      * database.  If the cursor is on a row in the rowset, the
 5331      * method {@link #updateRow} must be called to update the database.
 5332      * If the cursor is on the insert row, the method {@link #insertRow}
 5333      * must be called, which will insert the new row into both this rowset
 5334      * and the database. Both of these methods must be called before the
 5335      * cursor moves to another row.
 5336      *
 5337      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5338      *        SQL name of a column in this rowset, ignoring case
 5339      * @param x the new column value; must be a &lt;code&gt;java.io.InputStream&lt;/code&gt;
 5340      *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;, or
 5341      *          &lt;code&gt;LONGVARBINARY&lt;/code&gt; data
 5342      * @param length the length of the stream in bytes
 5343      * @throws SQLException if (1) the given column name does not match the
 5344      *            name of a column in this rowset, (2) the cursor is not on
 5345      *            one of this rowset&#39;s rows or its insert row, (3) the data
 5346      *            in the stream is not binary, or (4) this rowset is
 5347      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5348      */
 5349     public void updateBinaryStream(String columnName, java.io.InputStream x, int length) throws SQLException {
 5350         updateBinaryStream(getColIdxByName(columnName), x, length);
 5351     }
 5352 
 5353     /**
 5354      * Sets the designated column in either the current row or the insert
 5355      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5356      * &lt;code&gt;java.io.Reader&lt;/code&gt; object.
 5357      * &lt;P&gt;
 5358      * This method updates a column value in either the current row or
 5359      * the insert row of this rowset, but it does not update the
 5360      * database.  If the cursor is on a row in the rowset, the
 5361      * method {@link #updateRow} must be called to update the database.
 5362      * If the cursor is on the insert row, the method {@link #insertRow}
 5363      * must be called, which will insert the new row into both this rowset
 5364      * and the database. Both of these methods must be called before the
 5365      * cursor moves to another row.
 5366      *
 5367      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5368      *        SQL name of a column in this rowset, ignoring case
 5369      * @param reader the new column value; must be a
 5370      * &lt;code&gt;java.io.Reader&lt;/code&gt; containing &lt;code&gt;BINARY&lt;/code&gt;,
 5371      * &lt;code&gt;VARBINARY&lt;/code&gt;, &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;,
 5372      * &lt;code&gt;VARCHAR&lt;/code&gt;, or &lt;code&gt;LONGVARCHAR&lt;/code&gt; data
 5373      * @param length the length of the stream in characters
 5374      * @throws SQLException if (1) the given column name does not match the
 5375      *            name of a column in this rowset, (2) the cursor is not on
 5376      *            one of this rowset&#39;s rows or its insert row, (3) the data
 5377      *            in the stream is not a binary or character type, or (4) this
 5378      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5379      */
 5380     public void updateCharacterStream(String columnName,
 5381     java.io.Reader reader,
 5382     int length) throws SQLException {
 5383         updateCharacterStream(getColIdxByName(columnName), reader, length);
 5384     }
 5385 
 5386     /**
 5387      * Sets the designated column in either the current row or the insert
 5388      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5389      * &lt;code&gt;Object&lt;/code&gt; value.  The &lt;code&gt;scale&lt;/code&gt; parameter
 5390      * indicates the number of digits to the right of the decimal point
 5391      * and is ignored if the new column value is not a type that will be
 5392      *  mapped to an SQL &lt;code&gt;DECIMAL&lt;/code&gt; or &lt;code&gt;NUMERIC&lt;/code&gt; value.
 5393      * &lt;P&gt;
 5394      * This method updates a column value in either the current row or
 5395      * the insert row of this rowset, but it does not update the
 5396      * database.  If the cursor is on a row in the rowset, the
 5397      * method {@link #updateRow} must be called to update the database.
 5398      * If the cursor is on the insert row, the method {@link #insertRow}
 5399      * must be called, which will insert the new row into both this rowset
 5400      * and the database. Both of these methods must be called before the
 5401      * cursor moves to another row.
 5402      *
 5403      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5404      *        SQL name of a column in this rowset, ignoring case
 5405      * @param x the new column value
 5406      * @param scale the number of digits to the right of the decimal point (for
 5407      *              &lt;code&gt;DECIMAL&lt;/code&gt; and &lt;code&gt;NUMERIC&lt;/code&gt; types only)
 5408      * @throws SQLException if (1) the given column name does not match the
 5409      *            name of a column in this rowset, (2) the cursor is not on
 5410      *            one of this rowset&#39;s rows or its insert row, or (3) this
 5411      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5412      */
 5413     public void updateObject(String columnName, Object x, int scale) throws SQLException {
 5414         updateObject(getColIdxByName(columnName), x, scale);
 5415     }
 5416 
 5417     /**
 5418      * Sets the designated column in either the current row or the insert
 5419      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 5420      * &lt;code&gt;Object&lt;/code&gt; value.
 5421      * &lt;P&gt;
 5422      * This method updates a column value in either the current row or
 5423      * the insert row of this rowset, but it does not update the
 5424      * database.  If the cursor is on a row in the rowset, the
 5425      * method {@link #updateRow} must be called to update the database.
 5426      * If the cursor is on the insert row, the method {@link #insertRow}
 5427      * must be called, which will insert the new row into both this rowset
 5428      * and the database. Both of these methods must be called before the
 5429      * cursor moves to another row.
 5430      *
 5431      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5432      *        SQL name of a column in this rowset, ignoring case
 5433      * @param x the new column value
 5434      * @throws SQLException if (1) the given column name does not match the
 5435      *            name of a column in this rowset, (2) the cursor is not on
 5436      *            one of this rowset&#39;s rows or its insert row, or (3) this
 5437      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5438      */
 5439     public void updateObject(String columnName, Object x) throws SQLException {
 5440         updateObject(getColIdxByName(columnName), x);
 5441     }
 5442 
 5443     /**
 5444      * Inserts the contents of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s insert
 5445      * row into this rowset immediately following the current row.
 5446      * If the current row is the
 5447      * position after the last row or before the first row, the new row will
 5448      * be inserted at the end of the rowset.  This method also notifies
 5449      * listeners registered with this rowset that the row has changed.
 5450      * &lt;P&gt;
 5451      * The cursor must be on the insert row when this method is called.
 5452      *
 5453      * @throws SQLException if (1) the cursor is not on the insert row,
 5454      *            (2) one or more of the non-nullable columns in the insert
 5455      *            row has not been given a value, or (3) this rowset is
 5456      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5457      */
 5458     public void insertRow() throws SQLException {
 5459         int pos;
 5460 
 5461         if (onInsertRow == false ||
 5462             insertRow.isCompleteRow(RowSetMD) == false) {
 5463                 throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.failedins&quot;).toString());
 5464         }
 5465         // Added the setting of parameters that are passed
 5466         // to setXXX methods after an empty CRS Object is
 5467         // created through RowSetMetaData object
 5468         Object [] toInsert = getParams();
 5469 
 5470         for(int i = 0;i &lt; toInsert.length; i++) {
 5471           insertRow.setColumnObject(i+1,toInsert[i]);
 5472         }
 5473 
 5474         Row insRow = new Row(RowSetMD.getColumnCount(),
 5475         insertRow.getOrigRow());
 5476         insRow.setInserted();
 5477         /*
 5478          * The new row is inserted into the RowSet
 5479          * immediately following the current row.
 5480          *
 5481          * If we are afterlast then the rows are
 5482          * inserted at the end.
 5483          */
 5484         if (currentRow &gt;= numRows || currentRow &lt; 0) {
 5485             pos = numRows;
 5486         } else {
 5487             pos = currentRow;
 5488         }
 5489 
 5490         rvh.add(pos, insRow);
 5491         ++numRows;
 5492         // notify the listeners that the row changed.
 5493         notifyRowChanged();
 5494     }
 5495 
 5496     /**
 5497      * Marks the current row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as
 5498      * updated and notifies listeners registered with this rowset that the
 5499      * row has changed.
 5500      * &lt;P&gt;
 5501      * This method  cannot be called when the cursor is on the insert row, and
 5502      * it should be called before the cursor moves to another row.  If it is
 5503      * called after the cursor moves to another row, this method has no effect,
 5504      * and the updates made before the cursor moved will be lost.
 5505      *
 5506      * @throws SQLException if the cursor is on the insert row or this
 5507      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5508      */
 5509     public void updateRow() throws SQLException {
 5510         // make sure we aren&#39;t on the insert row
 5511         if (onInsertRow == true) {
 5512             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.updateins&quot;).toString());
 5513         }
 5514 
 5515         ((Row)getCurrentRow()).setUpdated();
 5516 
 5517         // notify the listeners that the row changed.
 5518         notifyRowChanged();
 5519     }
 5520 
 5521     /**
 5522      * Deletes the current row from this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object and
 5523      * notifies listeners registered with this rowset that a row has changed.
 5524      * This method cannot be called when the cursor is on the insert row.
 5525      * &lt;P&gt;
 5526      * This method marks the current row as deleted, but it does not delete
 5527      * the row from the underlying data source.  The method
 5528      * &lt;code&gt;acceptChanges&lt;/code&gt; must be called to delete the row in
 5529      * the data source.
 5530      *
 5531      * @throws SQLException if (1) this method is called when the cursor
 5532      *            is on the insert row, before the first row, or after the
 5533      *            last row or (2) this rowset is
 5534      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5535      */
 5536     public void deleteRow() throws SQLException {
 5537         // make sure the cursor is on a valid row
 5538         checkCursor();
 5539 
 5540         ((Row)getCurrentRow()).setDeleted();
 5541         ++numDeleted;
 5542 
 5543         // notify the listeners that the row changed.
 5544         notifyRowChanged();
 5545     }
 5546 
 5547     /**
 5548      * Sets the current row with its original value and marks the row as
 5549      * not updated, thus undoing any changes made to the row since the
 5550      * last call to the methods &lt;code&gt;updateRow&lt;/code&gt; or &lt;code&gt;deleteRow&lt;/code&gt;.
 5551      * This method should be called only when the cursor is on a row in
 5552      * this rowset.
 5553      *
 5554      * @throws SQLException if the cursor is on the insert row, before the
 5555      *            first row, or after the last row
 5556      */
 5557     public void refreshRow() throws SQLException {
 5558         // make sure we are on a row
 5559         checkCursor();
 5560 
 5561         // don&#39;t want this to happen...
 5562         if (onInsertRow == true) {
 5563             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcp&quot;).toString());
 5564         }
 5565 
 5566         Row currentRow = (Row)getCurrentRow();
 5567         // just undo any changes made to this row.
 5568         currentRow.clearUpdated();
 5569 
 5570     }
 5571 
 5572     /**
 5573      * Rolls back any updates made to the current row of this
 5574      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object and notifies listeners that
 5575      * a row has changed.  To have an effect, this method
 5576      * must be called after an &lt;code&gt;updateXXX&lt;/code&gt; method has been
 5577      * called and before the method &lt;code&gt;updateRow&lt;/code&gt; has been called.
 5578      * If no updates have been made or the method &lt;code&gt;updateRow&lt;/code&gt;
 5579      * has already been called, this method has no effect.
 5580      *
 5581      * @throws SQLException if the cursor is on the insert row, before the
 5582      *            first row, or after the last row
 5583      */
 5584     public void cancelRowUpdates() throws SQLException {
 5585         // make sure we are on a row
 5586         checkCursor();
 5587 
 5588         // don&#39;t want this to happen...
 5589         if (onInsertRow == true) {
 5590             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcp&quot;).toString());
 5591         }
 5592 
 5593         Row currentRow = (Row)getCurrentRow();
 5594         if (currentRow.getUpdated() == true) {
 5595             currentRow.clearUpdated();
 5596             notifyRowChanged();
 5597         }
 5598     }
 5599 
 5600     /**
 5601      * Moves the cursor for this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 5602      * to the insert row.  The current row in the rowset is remembered
 5603      * while the cursor is on the insert row.
 5604      * &lt;P&gt;
 5605      * The insert row is a special row associated with an updatable
 5606      * rowset.  It is essentially a buffer where a new row may
 5607      * be constructed by calling the appropriate &lt;code&gt;updateXXX&lt;/code&gt;
 5608      * methods to assign a value to each column in the row.  A complete
 5609      * row must be constructed; that is, every column that is not nullable
 5610      * must be assigned a value.  In order for the new row to become part
 5611      * of this rowset, the method &lt;code&gt;insertRow&lt;/code&gt; must be called
 5612      * before the cursor is moved back to the rowset.
 5613      * &lt;P&gt;
 5614      * Only certain methods may be invoked while the cursor is on the insert
 5615      * row; many methods throw an exception if they are called while the
 5616      * cursor is there.  In addition to the &lt;code&gt;updateXXX&lt;/code&gt;
 5617      * and &lt;code&gt;insertRow&lt;/code&gt; methods, only the &lt;code&gt;getXXX&lt;/code&gt; methods
 5618      * may be called when the cursor is on the insert row.  A &lt;code&gt;getXXX&lt;/code&gt;
 5619      * method should be called on a column only after an &lt;code&gt;updateXXX&lt;/code&gt;
 5620      * method has been called on that column; otherwise, the value returned is
 5621      * undetermined.
 5622      *
 5623      * @throws SQLException if this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object is
 5624      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 5625      */
 5626     public void moveToInsertRow() throws SQLException {
 5627         if (getConcurrency() == ResultSet.CONCUR_READ_ONLY) {
 5628             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.movetoins&quot;).toString());
 5629         }
 5630         if (insertRow == null) {
 5631             if (RowSetMD == null)
 5632                 throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.movetoins1&quot;).toString());
 5633             int numCols = RowSetMD.getColumnCount();
 5634             if (numCols &gt; 0) {
 5635                 insertRow = new InsertRow(numCols);
 5636             } else {
 5637                 throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.movetoins2&quot;).toString());
 5638             }
 5639         }
 5640         onInsertRow = true;
 5641         // %%% setCurrentRow called in BaseRow
 5642 
 5643         currentRow = cursorPos;
 5644         cursorPos = -1;
 5645 
 5646         insertRow.initInsertRow();
 5647     }
 5648 
 5649     /**
 5650      * Moves the cursor for this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object to
 5651      * the current row.  The current row is the row the cursor was on
 5652      * when the method &lt;code&gt;moveToInsertRow&lt;/code&gt; was called.
 5653      * &lt;P&gt;
 5654      * Calling this method has no effect unless it is called while the
 5655      * cursor is on the insert row.
 5656      *
 5657      * @throws SQLException if an error occurs
 5658      */
 5659     public void moveToCurrentRow() throws SQLException {
 5660         if (onInsertRow == false) {
 5661             return;
 5662         } else {
 5663             cursorPos = currentRow;
 5664             onInsertRow = false;
 5665         }
 5666     }
 5667 
 5668     /**
 5669      * Returns &lt;code&gt;null&lt;/code&gt;.
 5670      *
 5671      * @return &lt;code&gt;null&lt;/code&gt;
 5672      * @throws SQLException if an error occurs
 5673      */
 5674     public Statement getStatement() throws SQLException {
 5675         return null;
 5676     }
 5677 
 5678     /**
 5679      * Retrieves the value of the designated column in this
 5680      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as an &lt;code&gt;Object&lt;/code&gt; in
 5681      * the Java programming language, using the given
 5682      * &lt;code&gt;java.util.Map&lt;/code&gt; object to custom map the value if
 5683      * appropriate.
 5684      *
 5685      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 5686      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 5687      *        and equal to or less than the number of columns in this rowset
 5688      * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object showing the mapping
 5689      *            from SQL type names to classes in the Java programming
 5690      *            language
 5691      * @return an &lt;code&gt;Object&lt;/code&gt; representing the SQL value
 5692      * @throws SQLException if the given column index is out of bounds or
 5693      *            the cursor is not on one of this rowset&#39;s rows or its
 5694      *            insert row
 5695      */
 5696      public Object getObject(int columnIndex,
 5697                              java.util.Map&lt;String,Class&lt;?&gt;&gt; map)
 5698          throws SQLException
 5699      {
 5700         Object value;
 5701 
 5702         // sanity check.
 5703         checkIndex(columnIndex);
 5704         // make sure the cursor is on a valid row
 5705         checkCursor();
 5706 
 5707         setLastValueNull(false);
 5708         value = getCurrentRow().getColumnObject(columnIndex);
 5709 
 5710         // check for SQL NULL
 5711         if (value == null) {
 5712             setLastValueNull(true);
 5713             return null;
 5714         }
 5715         if (value instanceof Struct) {
 5716             Struct s = (Struct)value;
 5717 
 5718             // look up the class in the map
 5719             Class&lt;?&gt; c = map.get(s.getSQLTypeName());
 5720             if (c != null) {
 5721                 // create new instance of the class
 5722                 SQLData obj = null;
 5723                 try {
 5724                     ReflectUtil.checkPackageAccess(c);
 5725                     @SuppressWarnings(&quot;deprecation&quot;)
 5726                     Object tmp = c.newInstance();
 5727                     obj = (SQLData) tmp;
 5728                 } catch(Exception ex) {
 5729                     throw new SQLException(&quot;Unable to Instantiate: &quot;, ex);
 5730                 }
 5731                 // get the attributes from the struct
 5732                 Object attribs[] = s.getAttributes(map);
 5733                 // create the SQLInput &quot;stream&quot;
 5734                 SQLInputImpl sqlInput = new SQLInputImpl(attribs, map);
 5735                 // read the values...
 5736                 obj.readSQL(sqlInput, s.getSQLTypeName());
 5737                 return (Object)obj;
 5738             }
 5739         }
 5740         return value;
 5741     }
 5742 
 5743     /**
 5744      * Retrieves the value of the designated column in this
 5745      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Ref&lt;/code&gt; object
 5746      * in the Java programming language.
 5747      *
 5748      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 5749      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 5750      *        and equal to or less than the number of columns in this rowset
 5751      * @return a &lt;code&gt;Ref&lt;/code&gt; object representing an SQL&lt;code&gt; REF&lt;/code&gt; value
 5752      * @throws SQLException if (1) the given column index is out of bounds,
 5753      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 5754      *            insert row, or (3) the designated column does not store an
 5755      *            SQL &lt;code&gt;REF&lt;/code&gt; value
 5756      * @see #getRef(String)
 5757      */
 5758     public Ref getRef(int columnIndex) throws SQLException {
 5759         Ref value;
 5760 
 5761         // sanity check.
 5762         checkIndex(columnIndex);
 5763         // make sure the cursor is on a valid row
 5764         checkCursor();
 5765 
 5766         if (RowSetMD.getColumnType(columnIndex) != java.sql.Types.REF) {
 5767             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 5768         }
 5769 
 5770         setLastValueNull(false);
 5771         value = (Ref)(getCurrentRow().getColumnObject(columnIndex));
 5772 
 5773         // check for SQL NULL
 5774         if (value == null) {
 5775             setLastValueNull(true);
 5776             return null;
 5777         }
 5778 
 5779         return value;
 5780     }
 5781 
 5782     /**
 5783      * Retrieves the value of the designated column in this
 5784      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Blob&lt;/code&gt; object
 5785      * in the Java programming language.
 5786      *
 5787      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 5788      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 5789      *        and equal to or less than the number of columns in this rowset
 5790      * @return a &lt;code&gt;Blob&lt;/code&gt; object representing an SQL &lt;code&gt;BLOB&lt;/code&gt; value
 5791      * @throws SQLException if (1) the given column index is out of bounds,
 5792      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 5793      *            insert row, or (3) the designated column does not store an
 5794      *            SQL &lt;code&gt;BLOB&lt;/code&gt; value
 5795      * @see #getBlob(String)
 5796      */
 5797     public Blob getBlob(int columnIndex) throws SQLException {
 5798         Blob value;
 5799 
 5800         // sanity check.
 5801         checkIndex(columnIndex);
 5802         // make sure the cursor is on a valid row
 5803         checkCursor();
 5804 
 5805         if (RowSetMD.getColumnType(columnIndex) != java.sql.Types.BLOB) {
 5806             System.out.println(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.type&quot;).toString(), RowSetMD.getColumnType(columnIndex)));
 5807             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 5808         }
 5809 
 5810         setLastValueNull(false);
 5811         value = (Blob)(getCurrentRow().getColumnObject(columnIndex));
 5812 
 5813         // check for SQL NULL
 5814         if (value == null) {
 5815             setLastValueNull(true);
 5816             return null;
 5817         }
 5818 
 5819         return value;
 5820     }
 5821 
 5822     /**
 5823      * Retrieves the value of the designated column in this
 5824      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Clob&lt;/code&gt; object
 5825      * in the Java programming language.
 5826      *
 5827      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 5828      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 5829      *        and equal to or less than the number of columns in this rowset
 5830      * @return a &lt;code&gt;Clob&lt;/code&gt; object representing an SQL &lt;code&gt;CLOB&lt;/code&gt; value
 5831      * @throws SQLException if (1) the given column index is out of bounds,
 5832      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 5833      *            insert row, or (3) the designated column does not store an
 5834      *            SQL &lt;code&gt;CLOB&lt;/code&gt; value
 5835      * @see #getClob(String)
 5836      */
 5837     public Clob getClob(int columnIndex) throws SQLException {
 5838         Clob value;
 5839 
 5840         // sanity check.
 5841         checkIndex(columnIndex);
 5842         // make sure the cursor is on a valid row
 5843         checkCursor();
 5844 
 5845         if (RowSetMD.getColumnType(columnIndex) != java.sql.Types.CLOB) {
 5846             System.out.println(MessageFormat.format(resBundle.handleGetObject(&quot;cachedrowsetimpl.type&quot;).toString(), RowSetMD.getColumnType(columnIndex)));
 5847             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 5848         }
 5849 
 5850         setLastValueNull(false);
 5851         value = (Clob)(getCurrentRow().getColumnObject(columnIndex));
 5852 
 5853         // check for SQL NULL
 5854         if (value == null) {
 5855             setLastValueNull(true);
 5856             return null;
 5857         }
 5858 
 5859         return value;
 5860     }
 5861 
 5862     /**
 5863      * Retrieves the value of the designated column in this
 5864      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as an &lt;code&gt;Array&lt;/code&gt; object
 5865      * in the Java programming language.
 5866      *
 5867      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 5868      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 5869      *        and equal to or less than the number of columns in this rowset
 5870      * @return an &lt;code&gt;Array&lt;/code&gt; object representing an SQL
 5871      *         &lt;code&gt;ARRAY&lt;/code&gt; value
 5872      * @throws SQLException if (1) the given column index is out of bounds,
 5873      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 5874      *            insert row, or (3) the designated column does not store an
 5875      *            SQL &lt;code&gt;ARRAY&lt;/code&gt; value
 5876      * @see #getArray(String)
 5877      */
 5878     public Array getArray(int columnIndex) throws SQLException {
 5879         java.sql.Array value;
 5880 
 5881         // sanity check.
 5882         checkIndex(columnIndex);
 5883         // make sure the cursor is on a valid row
 5884         checkCursor();
 5885 
 5886         if (RowSetMD.getColumnType(columnIndex) != java.sql.Types.ARRAY) {
 5887             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 5888         }
 5889 
 5890         setLastValueNull(false);
 5891         value = (java.sql.Array)(getCurrentRow().getColumnObject(columnIndex));
 5892 
 5893         // check for SQL NULL
 5894         if (value == null) {
 5895             setLastValueNull(true);
 5896             return null;
 5897         }
 5898 
 5899         return value;
 5900     }
 5901 
 5902     /**
 5903      * Retrieves the value of the designated column in this
 5904      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as an &lt;code&gt;Object&lt;/code&gt; in
 5905      * the Java programming language, using the given
 5906      * &lt;code&gt;java.util.Map&lt;/code&gt; object to custom map the value if
 5907      * appropriate.
 5908      *
 5909      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5910      *        SQL name of a column in this rowset, ignoring case
 5911      * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object showing the mapping
 5912      *        from SQL type names to classes in the Java programming
 5913      *        language
 5914      * @return an &lt;code&gt;Object&lt;/code&gt; representing the SQL value
 5915      * @throws SQLException if the given column name is not the name of
 5916      *         a column in this rowset or the cursor is not on one of
 5917      *         this rowset&#39;s rows or its insert row
 5918      */
 5919     public Object getObject(String columnName,
 5920                             java.util.Map&lt;String,Class&lt;?&gt;&gt; map)
 5921     throws SQLException {
 5922         return getObject(getColIdxByName(columnName), map);
 5923     }
 5924 
 5925     /**
 5926      * Retrieves the value of the designated column in this
 5927      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Ref&lt;/code&gt; object
 5928      * in the Java programming language.
 5929      *
 5930      * @param colName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5931      *        SQL name of a column in this rowset, ignoring case
 5932      * @return a &lt;code&gt;Ref&lt;/code&gt; object representing an SQL&lt;code&gt; REF&lt;/code&gt; value
 5933      * @throws SQLException  if (1) the given column name is not the name of
 5934      *            a column in this rowset, (2) the cursor is not on one of
 5935      *            this rowset&#39;s rows or its insert row, or (3) the column value
 5936      *            is not an SQL &lt;code&gt;REF&lt;/code&gt; value
 5937      * @see #getRef(int)
 5938      */
 5939     public Ref getRef(String colName) throws SQLException {
 5940         return getRef(getColIdxByName(colName));
 5941     }
 5942 
 5943     /**
 5944      * Retrieves the value of the designated column in this
 5945      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Blob&lt;/code&gt; object
 5946      * in the Java programming language.
 5947      *
 5948      * @param colName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5949      *        SQL name of a column in this rowset, ignoring case
 5950      * @return a &lt;code&gt;Blob&lt;/code&gt; object representing an SQL &lt;code&gt;BLOB&lt;/code&gt; value
 5951      * @throws SQLException if (1) the given column name is not the name of
 5952      *            a column in this rowset, (2) the cursor is not on one of
 5953      *            this rowset&#39;s rows or its insert row, or (3) the designated
 5954      *            column does not store an SQL &lt;code&gt;BLOB&lt;/code&gt; value
 5955      * @see #getBlob(int)
 5956      */
 5957     public Blob getBlob(String colName) throws SQLException {
 5958         return getBlob(getColIdxByName(colName));
 5959     }
 5960 
 5961     /**
 5962      * Retrieves the value of the designated column in this
 5963      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Clob&lt;/code&gt; object
 5964      * in the Java programming language.
 5965      *
 5966      * @param colName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5967      *        SQL name of a column in this rowset, ignoring case
 5968      * @return a &lt;code&gt;Clob&lt;/code&gt; object representing an SQL
 5969      *         &lt;code&gt;CLOB&lt;/code&gt; value
 5970      * @throws SQLException if (1) the given column name is not the name of
 5971      *            a column in this rowset, (2) the cursor is not on one of
 5972      *            this rowset&#39;s rows or its insert row, or (3) the designated
 5973      *            column does not store an SQL &lt;code&gt;CLOB&lt;/code&gt; value
 5974      * @see #getClob(int)
 5975      */
 5976     public Clob getClob(String colName) throws SQLException {
 5977         return getClob(getColIdxByName(colName));
 5978     }
 5979 
 5980     /**
 5981      * Retrieves the value of the designated column in this
 5982      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as an &lt;code&gt;Array&lt;/code&gt; object
 5983      * in the Java programming langugage.
 5984      *
 5985      * @param colName a &lt;code&gt;String&lt;/code&gt; object that must match the
 5986      *        SQL name of a column in this rowset, ignoring case
 5987      * @return an &lt;code&gt;Array&lt;/code&gt; object representing an SQL
 5988      *         &lt;code&gt;ARRAY&lt;/code&gt; value
 5989      * @throws SQLException if (1) the given column name is not the name of
 5990      *            a column in this rowset, (2) the cursor is not on one of
 5991      *            this rowset&#39;s rows or its insert row, or (3) the designated
 5992      *            column does not store an SQL &lt;code&gt;ARRAY&lt;/code&gt; value
 5993      * @see #getArray(int)
 5994      */
 5995     public Array getArray(String colName) throws SQLException {
 5996         return getArray(getColIdxByName(colName));
 5997     }
 5998 
 5999     /**
 6000      * Retrieves the value of the designated column in the current row
 6001      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Date&lt;/code&gt;
 6002      * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
 6003      * appropriate millisecond value for the date.
 6004      *
 6005      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 6006      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 6007      *        and equal to or less than the number of columns in the rowset
 6008      * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
 6009      *            constructing the date
 6010      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 6011      *         the result is &lt;code&gt;null&lt;/code&gt;
 6012      * @throws SQLException if (1) the given column name is not the name of
 6013      *            a column in this rowset, (2) the cursor is not on one of
 6014      *            this rowset&#39;s rows or its insert row, or (3) the designated
 6015      *            column does not store an SQL &lt;code&gt;DATE&lt;/code&gt; or
 6016      *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
 6017      */
 6018     public java.sql.Date getDate(int columnIndex, Calendar cal) throws SQLException {
 6019         Object value;
 6020 
 6021         // sanity check.
 6022         checkIndex(columnIndex);
 6023         // make sure the cursor is on a valid row
 6024         checkCursor();
 6025 
 6026         setLastValueNull(false);
 6027         value = getCurrentRow().getColumnObject(columnIndex);
 6028 
 6029         // check for SQL NULL
 6030         if (value == null) {
 6031             setLastValueNull(true);
 6032             return null;
 6033         }
 6034 
 6035         value = convertTemporal(value,
 6036         RowSetMD.getColumnType(columnIndex),
 6037         java.sql.Types.DATE);
 6038 
 6039         // create a default calendar
 6040         Calendar defaultCal = Calendar.getInstance();
 6041         // set this Calendar to the time we have
 6042         defaultCal.setTime((java.util.Date)value);
 6043 
 6044         /*
 6045          * Now we can pull the pieces of the date out
 6046          * of the default calendar and put them into
 6047          * the user provided calendar
 6048          */
 6049         cal.set(Calendar.YEAR, defaultCal.get(Calendar.YEAR));
 6050         cal.set(Calendar.MONTH, defaultCal.get(Calendar.MONTH));
 6051         cal.set(Calendar.DAY_OF_MONTH, defaultCal.get(Calendar.DAY_OF_MONTH));
 6052 
 6053         /*
 6054          * This looks a little odd but it is correct -
 6055          * Calendar.getTime() returns a Date...
 6056          */
 6057         return new java.sql.Date(cal.getTime().getTime());
 6058     }
 6059 
 6060     /**
 6061      * Retrieves the value of the designated column in the current row
 6062      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Date&lt;/code&gt;
 6063      * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
 6064      * appropriate millisecond value for the date.
 6065      *
 6066      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 6067      *        SQL name of a column in this rowset, ignoring case
 6068      * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
 6069      *            constructing the date
 6070      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 6071      *         the result is &lt;code&gt;null&lt;/code&gt;
 6072      * @throws SQLException if (1) the given column name is not the name of
 6073      *            a column in this rowset, (2) the cursor is not on one of
 6074      *            this rowset&#39;s rows or its insert row, or (3) the designated
 6075      *            column does not store an SQL &lt;code&gt;DATE&lt;/code&gt; or
 6076      *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
 6077      */
 6078     public java.sql.Date getDate(String columnName, Calendar cal) throws SQLException {
 6079         return getDate(getColIdxByName(columnName), cal);
 6080     }
 6081 
 6082     /**
 6083      * Retrieves the value of the designated column in the current row
 6084      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Time&lt;/code&gt;
 6085      * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
 6086      * appropriate millisecond value for the date.
 6087      *
 6088      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 6089      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 6090      *        and equal to or less than the number of columns in the rowset
 6091      * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
 6092      *            constructing the date
 6093      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 6094      *         the result is &lt;code&gt;null&lt;/code&gt;
 6095      * @throws SQLException if (1) the given column name is not the name of
 6096      *            a column in this rowset, (2) the cursor is not on one of
 6097      *            this rowset&#39;s rows or its insert row, or (3) the designated
 6098      *            column does not store an SQL &lt;code&gt;TIME&lt;/code&gt; or
 6099      *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
 6100      */
 6101     public java.sql.Time getTime(int columnIndex, Calendar cal) throws SQLException {
 6102         Object value;
 6103 
 6104         // sanity check.
 6105         checkIndex(columnIndex);
 6106         // make sure the cursor is on a valid row
 6107         checkCursor();
 6108 
 6109         setLastValueNull(false);
 6110         value = getCurrentRow().getColumnObject(columnIndex);
 6111 
 6112         // check for SQL NULL
 6113         if (value == null) {
 6114             setLastValueNull(true);
 6115             return null;
 6116         }
 6117 
 6118         value = convertTemporal(value,
 6119         RowSetMD.getColumnType(columnIndex),
 6120         java.sql.Types.TIME);
 6121 
 6122         // create a default calendar
 6123         Calendar defaultCal = Calendar.getInstance();
 6124         // set the time in the default calendar
 6125         defaultCal.setTime((java.util.Date)value);
 6126 
 6127         /*
 6128          * Now we can pull the pieces of the date out
 6129          * of the default calendar and put them into
 6130          * the user provided calendar
 6131          */
 6132         cal.set(Calendar.HOUR_OF_DAY, defaultCal.get(Calendar.HOUR_OF_DAY));
 6133         cal.set(Calendar.MINUTE, defaultCal.get(Calendar.MINUTE));
 6134         cal.set(Calendar.SECOND, defaultCal.get(Calendar.SECOND));
 6135 
 6136         return new java.sql.Time(cal.getTime().getTime());
 6137     }
 6138 
 6139     /**
 6140      * Retrieves the value of the designated column in the current row
 6141      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Time&lt;/code&gt;
 6142      * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
 6143      * appropriate millisecond value for the date.
 6144      *
 6145      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 6146      *        SQL name of a column in this rowset, ignoring case
 6147      * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
 6148      *            constructing the date
 6149      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 6150      *         the result is &lt;code&gt;null&lt;/code&gt;
 6151      * @throws SQLException if (1) the given column name is not the name of
 6152      *            a column in this rowset, (2) the cursor is not on one of
 6153      *            this rowset&#39;s rows or its insert row, or (3) the designated
 6154      *            column does not store an SQL &lt;code&gt;TIME&lt;/code&gt; or
 6155      *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
 6156      */
 6157     public java.sql.Time getTime(String columnName, Calendar cal) throws SQLException {
 6158         return getTime(getColIdxByName(columnName), cal);
 6159     }
 6160 
 6161     /**
 6162      * Retrieves the value of the designated column in the current row
 6163      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Timestamp&lt;/code&gt;
 6164      * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
 6165      * appropriate millisecond value for the date.
 6166      *
 6167      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 6168      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 6169      *        and equal to or less than the number of columns in the rowset
 6170      * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
 6171      *            constructing the date
 6172      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 6173      *         the result is &lt;code&gt;null&lt;/code&gt;
 6174      * @throws SQLException if (1) the given column name is not the name of
 6175      *            a column in this rowset, (2) the cursor is not on one of
 6176      *            this rowset&#39;s rows or its insert row, or (3) the designated
 6177      *            column does not store an SQL &lt;code&gt;TIME&lt;/code&gt; or
 6178      *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
 6179      */
 6180     public java.sql.Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
 6181         Object value;
 6182 
 6183         // sanity check.
 6184         checkIndex(columnIndex);
 6185         // make sure the cursor is on a valid row
 6186         checkCursor();
 6187 
 6188         setLastValueNull(false);
 6189         value = getCurrentRow().getColumnObject(columnIndex);
 6190 
 6191         // check for SQL NULL
 6192         if (value == null) {
 6193             setLastValueNull(true);
 6194             return null;
 6195         }
 6196 
 6197         value = convertTemporal(value,
 6198         RowSetMD.getColumnType(columnIndex),
 6199         java.sql.Types.TIMESTAMP);
 6200 
 6201         // create a default calendar
 6202         Calendar defaultCal = Calendar.getInstance();
 6203         // set the time in the default calendar
 6204         defaultCal.setTime((java.util.Date)value);
 6205 
 6206         /*
 6207          * Now we can pull the pieces of the date out
 6208          * of the default calendar and put them into
 6209          * the user provided calendar
 6210          */
 6211         cal.set(Calendar.YEAR, defaultCal.get(Calendar.YEAR));
 6212         cal.set(Calendar.MONTH, defaultCal.get(Calendar.MONTH));
 6213         cal.set(Calendar.DAY_OF_MONTH, defaultCal.get(Calendar.DAY_OF_MONTH));
 6214         cal.set(Calendar.HOUR_OF_DAY, defaultCal.get(Calendar.HOUR_OF_DAY));
 6215         cal.set(Calendar.MINUTE, defaultCal.get(Calendar.MINUTE));
 6216         cal.set(Calendar.SECOND, defaultCal.get(Calendar.SECOND));
 6217 
 6218         return new java.sql.Timestamp(cal.getTime().getTime());
 6219     }
 6220 
 6221     /**
 6222      * Retrieves the value of the designated column in the current row
 6223      * of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a
 6224      * &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object, using the given
 6225      * &lt;code&gt;Calendar&lt;/code&gt; object to construct an appropriate
 6226      * millisecond value for the date.
 6227      *
 6228      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 6229      *        SQL name of a column in this rowset, ignoring case
 6230      * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
 6231      *            constructing the date
 6232      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
 6233      *         the result is &lt;code&gt;null&lt;/code&gt;
 6234      * @throws SQLException if (1) the given column name is not the name of
 6235      *            a column in this rowset, (2) the cursor is not on one of
 6236      *            this rowset&#39;s rows or its insert row, or (3) the designated
 6237      *            column does not store an SQL &lt;code&gt;DATE&lt;/code&gt;,
 6238      *            &lt;code&gt;TIME&lt;/code&gt;, or &lt;code&gt;TIMESTAMP&lt;/code&gt; value
 6239      */
 6240     public java.sql.Timestamp getTimestamp(String columnName, Calendar cal) throws SQLException {
 6241         return getTimestamp(getColIdxByName(columnName), cal);
 6242     }
 6243 
 6244     /*
 6245      * RowSetInternal Interface
 6246      */
 6247 
 6248     /**
 6249      * Retrieves the &lt;code&gt;Connection&lt;/code&gt; object passed to this
 6250      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.  This connection may be
 6251      * used to populate this rowset with data or to write data back
 6252      * to its underlying data source.
 6253      *
 6254      * @return the &lt;code&gt;Connection&lt;/code&gt; object passed to this rowset;
 6255      *         may be &lt;code&gt;null&lt;/code&gt; if there is no connection
 6256      * @throws SQLException if an error occurs
 6257      */
 6258     public Connection getConnection() throws SQLException{
 6259         return conn;
 6260     }
 6261 
 6262     /**
 6263      * Sets the metadata for this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 6264      * with the given &lt;code&gt;RowSetMetaData&lt;/code&gt; object.
 6265      *
 6266      * @param md a &lt;code&gt;RowSetMetaData&lt;/code&gt; object instance containing
 6267      *            metadata about the columsn in the rowset
 6268      * @throws SQLException if invalid meta data is supplied to the
 6269      *            rowset
 6270      */
 6271     public void setMetaData(RowSetMetaData md) throws SQLException {
 6272         RowSetMD =(RowSetMetaDataImpl) md;
 6273     }
 6274 
 6275     /**
 6276      * Returns a result set containing the original value of the rowset. The
 6277      * original value is the state of the &lt;code&gt;CachedRowSetImpl&lt;/code&gt; after the
 6278      * last population or synchronization (whichever occurred most recently) with
 6279      * the data source.
 6280      * &lt;p&gt;
 6281      * The cursor is positioned before the first row in the result set.
 6282      * Only rows contained in the result set returned by &lt;code&gt;getOriginal()&lt;/code&gt;
 6283      * are said to have an original value.
 6284      *
 6285      * @return the original result set of the rowset
 6286      * @throws SQLException if an error occurs produce the
 6287      *           &lt;code&gt;ResultSet&lt;/code&gt; object
 6288      */
 6289     public ResultSet getOriginal() throws SQLException {
 6290         CachedRowSetImpl crs = new CachedRowSetImpl();
 6291         crs.RowSetMD = RowSetMD;
 6292         crs.numRows = numRows;
 6293         crs.cursorPos = 0;
 6294 
 6295         // make sure we don&#39;t get someone playing with these
 6296         // %%% is this now necessary ???
 6297         //crs.setReader(null);
 6298         //crs.setWriter(null);
 6299         int colCount = RowSetMD.getColumnCount();
 6300         Row orig;
 6301 
 6302         for (Iterator&lt;?&gt; i = rvh.iterator(); i.hasNext();) {
 6303             orig = new Row(colCount, ((Row)i.next()).getOrigRow());
 6304             crs.rvh.add(orig);
 6305         }
 6306         return (ResultSet)crs;
 6307     }
 6308 
 6309     /**
 6310      * Returns a result set containing the original value of the current
 6311      * row only.
 6312      * The original value is the state of the &lt;code&gt;CachedRowSetImpl&lt;/code&gt; after
 6313      * the last population or synchronization (whichever occurred most recently)
 6314      * with the data source.
 6315      *
 6316      * @return the original result set of the row
 6317      * @throws SQLException if there is no current row
 6318      * @see #setOriginalRow
 6319      */
 6320     public ResultSet getOriginalRow() throws SQLException {
 6321         CachedRowSetImpl crs = new CachedRowSetImpl();
 6322         crs.RowSetMD = RowSetMD;
 6323         crs.numRows = 1;
 6324         crs.cursorPos = 0;
 6325         crs.setTypeMap(this.getTypeMap());
 6326 
 6327         // make sure we don&#39;t get someone playing with these
 6328         // %%% is this now necessary ???
 6329         //crs.setReader(null);
 6330         //crs.setWriter(null);
 6331 
 6332         Row orig = new Row(RowSetMD.getColumnCount(),
 6333         getCurrentRow().getOrigRow());
 6334 
 6335         crs.rvh.add(orig);
 6336 
 6337         return (ResultSet)crs;
 6338 
 6339     }
 6340 
 6341     /**
 6342      * Marks the current row in this rowset as being an original row.
 6343      *
 6344      * @throws SQLException if there is no current row
 6345      * @see #getOriginalRow
 6346      */
 6347     public void setOriginalRow() throws SQLException {
 6348         if (onInsertRow == true) {
 6349             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidop&quot;).toString());
 6350         }
 6351 
 6352         Row row = (Row)getCurrentRow();
 6353         makeRowOriginal(row);
 6354 
 6355         // this can happen if deleted rows are being shown
 6356         if (row.getDeleted() == true) {
 6357             removeCurrentRow();
 6358         }
 6359     }
 6360 
 6361     /**
 6362      * Makes the given row of this rowset the original row by clearing any
 6363      * settings that mark the row as having been inserted, deleted, or updated.
 6364      * This method is called internally by the methods
 6365      * &lt;code&gt;setOriginalRow&lt;/code&gt;
 6366      * and &lt;code&gt;setOriginal&lt;/code&gt;.
 6367      *
 6368      * @param row the row to be made the original row
 6369      */
 6370     private void makeRowOriginal(Row row) {
 6371         if (row.getInserted() == true) {
 6372             row.clearInserted();
 6373         }
 6374 
 6375         if (row.getUpdated() == true) {
 6376             row.moveCurrentToOrig();
 6377         }
 6378     }
 6379 
 6380     /**
 6381      * Marks all rows in this rowset as being original rows. Any updates
 6382      * made to the rows become the original values for the rowset.
 6383      * Calls to the method &lt;code&gt;setOriginal&lt;/code&gt; connot be reversed.
 6384      *
 6385      * @throws SQLException if an error occurs
 6386      */
 6387     public void setOriginal() throws SQLException {
 6388         for (Iterator&lt;?&gt; i = rvh.iterator(); i.hasNext();) {
 6389             Row row = (Row)i.next();
 6390             makeRowOriginal(row);
 6391             // remove deleted rows from the collection.
 6392             if (row.getDeleted() == true) {
 6393                 i.remove();
 6394                 --numRows;
 6395             }
 6396         }
 6397         numDeleted = 0;
 6398 
 6399         // notify any listeners that the rowset has changed
 6400         notifyRowSetChanged();
 6401     }
 6402 
 6403     /**
 6404      * Returns an identifier for the object (table) that was used to create this
 6405      * rowset.
 6406      *
 6407      * @return a &lt;code&gt;String&lt;/code&gt; object that identifies the table from
 6408      *         which this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object was derived
 6409      * @throws SQLException if an error occurs
 6410      */
 6411     public String getTableName() throws SQLException {
 6412         return tableName;
 6413     }
 6414 
 6415     /**
 6416      * Sets the identifier for the table from which this rowset was derived
 6417      * to the given table name.
 6418      *
 6419      * @param tabName a &lt;code&gt;String&lt;/code&gt; object that identifies the
 6420      *          table from which this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 6421      *          was derived
 6422      * @throws SQLException if an error occurs
 6423      */
 6424     public void setTableName(String tabName) throws SQLException {
 6425         if (tabName == null)
 6426             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.tablename&quot;).toString());
 6427         else
 6428             tableName = tabName;
 6429     }
 6430 
 6431     /**
 6432      * Returns the columns that make a key to uniquely identify a
 6433      * row in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.
 6434      *
 6435      * @return an array of column numbers that constitutes a primary
 6436      *           key for this rowset. This array should be empty
 6437      *           if no column is representitive of a primary key
 6438      * @throws SQLException if the rowset is empty or no columns
 6439      *           are designated as primary keys
 6440      * @see #setKeyColumns
 6441      */
 6442     public int[] getKeyColumns() throws SQLException {
 6443         int[]keyColumns  = this.keyCols;
 6444         return (keyColumns == null) ? null : Arrays.copyOf(keyColumns, keyColumns.length);
 6445     }
 6446 
 6447 
 6448     /**
 6449      * Sets this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s
 6450      * &lt;code&gt;keyCols&lt;/code&gt; field with the given array of column
 6451      * numbers, which forms a key for uniquely identifying a row
 6452      * in this rowset.
 6453      *
 6454      * @param keys an array of &lt;code&gt;int&lt;/code&gt; indicating the
 6455      *        columns that form a primary key for this
 6456      *        &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object; every
 6457      *        element in the array must be greater than
 6458      *        &lt;code&gt;0&lt;/code&gt; and less than or equal to the number
 6459      *        of columns in this rowset
 6460      * @throws SQLException if any of the numbers in the
 6461      *            given array is not valid for this rowset
 6462      * @see #getKeyColumns
 6463      */
 6464     public void setKeyColumns(int [] keys) throws SQLException {
 6465         int numCols = 0;
 6466         if (RowSetMD != null) {
 6467             numCols = RowSetMD.getColumnCount();
 6468             if (keys.length &gt; numCols)
 6469                 throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.keycols&quot;).toString());
 6470         }
 6471         keyCols = new int[keys.length];
 6472         for (int i = 0; i &lt; keys.length; i++) {
 6473             if (RowSetMD != null &amp;&amp; (keys[i] &lt;= 0 ||
 6474             keys[i] &gt; numCols)) {
 6475                 throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcol&quot;).toString() +
 6476                 keys[i]);
 6477             }
 6478             keyCols[i] = keys[i];
 6479         }
 6480     }
 6481 
 6482     /**
 6483      * Sets the designated column in either the current row or the insert
 6484      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 6485      * &lt;code&gt;Ref&lt;/code&gt; value.
 6486      *
 6487      * This method updates a column value in either the current row or
 6488      * the insert row of this rowset, but it does not update the
 6489      * database.  If the cursor is on a row in the rowset, the
 6490      * method {@link #updateRow} must be called to update the database.
 6491      * If the cursor is on the insert row, the method {@link #insertRow}
 6492      * must be called, which will insert the new row into both this rowset
 6493      * and the database. Both of these methods must be called before the
 6494      * cursor moves to another row.
 6495      *
 6496      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 6497      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 6498      *        and equal to or less than the number of columns in this rowset
 6499      * @param ref the new column &lt;code&gt;java.sql.Ref&lt;/code&gt; value
 6500      * @throws SQLException if (1) the given column index is out of bounds,
 6501      *        (2) the cursor is not on one of this rowset&#39;s rows or its
 6502      *        insert row, or (3) this rowset is
 6503      *        &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 6504      */
 6505     public void updateRef(int columnIndex, java.sql.Ref ref) throws SQLException {
 6506         // sanity check.
 6507         checkIndex(columnIndex);
 6508         // make sure the cursor is on a valid row
 6509         checkCursor();
 6510 
 6511         // SerialClob will help in getting the byte array and storing it.
 6512         // We need to be checking DatabaseMetaData.locatorsUpdatorCopy()
 6513         // or through RowSetMetaData.locatorsUpdatorCopy()
 6514         getCurrentRow().setColumnObject(columnIndex, new SerialRef(ref));
 6515     }
 6516 
 6517     /**
 6518      * Sets the designated column in either the current row or the insert
 6519      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 6520      * &lt;code&gt;double&lt;/code&gt; value.
 6521      *
 6522      * This method updates a column value in either the current row or
 6523      * the insert row of this rowset, but it does not update the
 6524      * database.  If the cursor is on a row in the rowset, the
 6525      * method {@link #updateRow} must be called to update the database.
 6526      * If the cursor is on the insert row, the method {@link #insertRow}
 6527      * must be called, which will insert the new row into both this rowset
 6528      * and the database. Both of these methods must be called before the
 6529      * cursor moves to another row.
 6530      *
 6531      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 6532      *        SQL name of a column in this rowset, ignoring case
 6533      * @param ref the new column &lt;code&gt;java.sql.Ref&lt;/code&gt; value
 6534      * @throws SQLException if (1) the given column name does not match the
 6535      *        name of a column in this rowset, (2) the cursor is not on
 6536      *        one of this rowset&#39;s rows or its insert row, or (3) this
 6537      *        rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 6538      */
 6539     public void updateRef(String columnName, java.sql.Ref ref) throws SQLException {
 6540         updateRef(getColIdxByName(columnName), ref);
 6541     }
 6542 
 6543     /**
 6544      * Sets the designated column in either the current row or the insert
 6545      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 6546      * &lt;code&gt;double&lt;/code&gt; value.
 6547      *
 6548      * This method updates a column value in either the current row or
 6549      * the insert row of this rowset, but it does not update the
 6550      * database.  If the cursor is on a row in the rowset, the
 6551      * method {@link #updateRow} must be called to update the database.
 6552      * If the cursor is on the insert row, the method {@link #insertRow}
 6553      * must be called, which will insert the new row into both this rowset
 6554      * and the database. Both of these methods must be called before the
 6555      * cursor moves to another row.
 6556      *
 6557      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 6558      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 6559      *        and equal to or less than the number of columns in this rowset
 6560      * @param c the new column &lt;code&gt;Clob&lt;/code&gt; value
 6561      * @throws SQLException if (1) the given column index is out of bounds,
 6562      *        (2) the cursor is not on one of this rowset&#39;s rows or its
 6563      *        insert row, or (3) this rowset is
 6564      *        &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 6565      */
 6566     public void updateClob(int columnIndex, Clob c) throws SQLException {
 6567         // sanity check.
 6568         checkIndex(columnIndex);
 6569         // make sure the cursor is on a valid row
 6570         checkCursor();
 6571 
 6572         // SerialClob will help in getting the byte array and storing it.
 6573         // We need to be checking DatabaseMetaData.locatorsUpdatorCopy()
 6574         // or through RowSetMetaData.locatorsUpdatorCopy()
 6575 
 6576         if(dbmslocatorsUpdateCopy){
 6577            getCurrentRow().setColumnObject(columnIndex, new SerialClob(c));
 6578         }
 6579         else{
 6580            throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotsupp&quot;).toString());
 6581         }
 6582     }
 6583 
 6584     /**
 6585      * Sets the designated column in either the current row or the insert
 6586      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 6587      * &lt;code&gt;double&lt;/code&gt; value.
 6588      *
 6589      * This method updates a column value in either the current row or
 6590      * the insert row of this rowset, but it does not update the
 6591      * database.  If the cursor is on a row in the rowset, the
 6592      * method {@link #updateRow} must be called to update the database.
 6593      * If the cursor is on the insert row, the method {@link #insertRow}
 6594      * must be called, which will insert the new row into both this rowset
 6595      * and the database. Both of these methods must be called before the
 6596      * cursor moves to another row.
 6597      *
 6598      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 6599      *        SQL name of a column in this rowset, ignoring case
 6600      * @param c the new column &lt;code&gt;Clob&lt;/code&gt; value
 6601      * @throws SQLException if (1) the given column name does not match the
 6602      *            name of a column in this rowset, (2) the cursor is not on
 6603      *            one of this rowset&#39;s rows or its insert row, or (3) this
 6604      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 6605      */
 6606     public void updateClob(String columnName, Clob c) throws SQLException {
 6607         updateClob(getColIdxByName(columnName), c);
 6608     }
 6609 
 6610     /**
 6611      * Sets the designated column in either the current row or the insert
 6612      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 6613      * &lt;code&gt;java.sql.Blob&lt;/code&gt; value.
 6614      *
 6615      * This method updates a column value in either the current row or
 6616      * the insert row of this rowset, but it does not update the
 6617      * database.  If the cursor is on a row in the rowset, the
 6618      * method {@link #updateRow} must be called to update the database.
 6619      * If the cursor is on the insert row, the method {@link #insertRow}
 6620      * must be called, which will insert the new row into both this rowset
 6621      * and the database. Both of these methods must be called before the
 6622      * cursor moves to another row.
 6623      *
 6624      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 6625      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 6626      *        and equal to or less than the number of columns in this rowset
 6627      * @param b the new column &lt;code&gt;Blob&lt;/code&gt; value
 6628      * @throws SQLException if (1) the given column index is out of bounds,
 6629      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 6630      *            insert row, or (3) this rowset is
 6631      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 6632      */
 6633     public void updateBlob(int columnIndex, Blob b) throws SQLException {
 6634         // sanity check.
 6635         checkIndex(columnIndex);
 6636         // make sure the cursor is on a valid row
 6637         checkCursor();
 6638 
 6639         // SerialBlob will help in getting the byte array and storing it.
 6640         // We need to be checking DatabaseMetaData.locatorsUpdatorCopy()
 6641         // or through RowSetMetaData.locatorsUpdatorCopy()
 6642 
 6643         if(dbmslocatorsUpdateCopy){
 6644            getCurrentRow().setColumnObject(columnIndex, new SerialBlob(b));
 6645         }
 6646         else{
 6647            throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotsupp&quot;).toString());
 6648         }
 6649     }
 6650 
 6651     /**
 6652      * Sets the designated column in either the current row or the insert
 6653      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 6654      * &lt;code&gt;java.sql.Blob &lt;/code&gt; value.
 6655      *
 6656      * This method updates a column value in either the current row or
 6657      * the insert row of this rowset, but it does not update the
 6658      * database.  If the cursor is on a row in the rowset, the
 6659      * method {@link #updateRow} must be called to update the database.
 6660      * If the cursor is on the insert row, the method {@link #insertRow}
 6661      * must be called, which will insert the new row into both this rowset
 6662      * and the database. Both of these methods must be called before the
 6663      * cursor moves to another row.
 6664      *
 6665      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 6666      *        SQL name of a column in this rowset, ignoring case
 6667      * @param b the new column &lt;code&gt;Blob&lt;/code&gt; value
 6668      * @throws SQLException if (1) the given column name does not match the
 6669      *            name of a column in this rowset, (2) the cursor is not on
 6670      *            one of this rowset&#39;s rows or its insert row, or (3) this
 6671      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 6672      */
 6673     public void updateBlob(String columnName, Blob b) throws SQLException {
 6674         updateBlob(getColIdxByName(columnName), b);
 6675     }
 6676 
 6677     /**
 6678      * Sets the designated column in either the current row or the insert
 6679      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 6680      * &lt;code&gt;java.sql.Array&lt;/code&gt; values.
 6681      *
 6682      * This method updates a column value in either the current row or
 6683      * the insert row of this rowset, but it does not update the
 6684      * database.  If the cursor is on a row in the rowset, the
 6685      * method {@link #updateRow} must be called to update the database.
 6686      * If the cursor is on the insert row, the method {@link #insertRow}
 6687      * must be called, which will insert the new row into both this rowset
 6688      * and the database. Both of these methods must be called before the
 6689      * cursor moves to another row.
 6690      *
 6691      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 6692      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 6693      *        and equal to or less than the number of columns in this rowset
 6694      * @param a the new column &lt;code&gt;Array&lt;/code&gt; value
 6695      * @throws SQLException if (1) the given column index is out of bounds,
 6696      *            (2) the cursor is not on one of this rowset&#39;s rows or its
 6697      *            insert row, or (3) this rowset is
 6698      *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 6699      */
 6700     public void updateArray(int columnIndex, Array a) throws SQLException {
 6701         // sanity check.
 6702         checkIndex(columnIndex);
 6703         // make sure the cursor is on a valid row
 6704         checkCursor();
 6705 
 6706         // SerialArray will help in getting the byte array and storing it.
 6707         // We need to be checking DatabaseMetaData.locatorsUpdatorCopy()
 6708         // or through RowSetMetaData.locatorsUpdatorCopy()
 6709         getCurrentRow().setColumnObject(columnIndex, new SerialArray(a));
 6710     }
 6711 
 6712     /**
 6713      * Sets the designated column in either the current row or the insert
 6714      * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
 6715      * &lt;code&gt;java.sql.Array&lt;/code&gt; value.
 6716      *
 6717      * This method updates a column value in either the current row or
 6718      * the insert row of this rowset, but it does not update the
 6719      * database.  If the cursor is on a row in the rowset, the
 6720      * method {@link #updateRow} must be called to update the database.
 6721      * If the cursor is on the insert row, the method {@link #insertRow}
 6722      * must be called, which will insert the new row into both this rowset
 6723      * and the database. Both of these methods must be called before the
 6724      * cursor moves to another row.
 6725      *
 6726      * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
 6727      *        SQL name of a column in this rowset, ignoring case
 6728      * @param a the new column &lt;code&gt;Array&lt;/code&gt; value
 6729      * @throws SQLException if (1) the given column name does not match the
 6730      *            name of a column in this rowset, (2) the cursor is not on
 6731      *            one of this rowset&#39;s rows or its insert row, or (3) this
 6732      *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 6733      */
 6734     public void updateArray(String columnName, Array a) throws SQLException {
 6735         updateArray(getColIdxByName(columnName), a);
 6736     }
 6737 
 6738 
 6739     /**
 6740      * Retrieves the value of the designated column in this
 6741      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.net.URL&lt;/code&gt; object
 6742      * in the Java programming language.
 6743      *
 6744      * @return a java.net.URL object containing the resource reference described by
 6745      * the URL
 6746      * @throws SQLException if (1) the given column index is out of bounds,
 6747      * (2) the cursor is not on one of this rowset&#39;s rows or its
 6748      * insert row, or (3) the designated column does not store an
 6749      * SQL &lt;code&gt;DATALINK&lt;/code&gt; value.
 6750      * @see #getURL(String)
 6751      */
 6752     public java.net.URL getURL(int columnIndex) throws SQLException {
 6753         //throw new SQLException(&quot;Operation not supported&quot;);
 6754 
 6755         java.net.URL value;
 6756 
 6757         // sanity check.
 6758         checkIndex(columnIndex);
 6759         // make sure the cursor is on a valid row
 6760         checkCursor();
 6761 
 6762         if (RowSetMD.getColumnType(columnIndex) != java.sql.Types.DATALINK) {
 6763             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());
 6764         }
 6765 
 6766         setLastValueNull(false);
 6767         value = (java.net.URL)(getCurrentRow().getColumnObject(columnIndex));
 6768 
 6769         // check for SQL NULL
 6770         if (value == null) {
 6771             setLastValueNull(true);
 6772             return null;
 6773         }
 6774 
 6775         return value;
 6776     }
 6777 
 6778     /**
 6779      * Retrieves the value of the designated column in this
 6780      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.net.URL&lt;/code&gt; object
 6781      * in the Java programming language.
 6782      *
 6783      * @return a java.net.URL object containing the resource reference described by
 6784      * the URL
 6785      * @throws SQLException if (1) the given column name not the name of a column
 6786      * in this rowset, or
 6787      * (2) the cursor is not on one of this rowset&#39;s rows or its
 6788      * insert row, or (3) the designated column does not store an
 6789      * SQL &lt;code&gt;DATALINK&lt;/code&gt; value.
 6790      * @see #getURL(int)
 6791      */
 6792     public java.net.URL getURL(String columnName) throws SQLException {
 6793         return getURL(getColIdxByName(columnName));
 6794 
 6795     }
 6796 
 6797     /**
 6798      * The first warning reported by calls on this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 6799      * object is returned. Subsequent &lt;code&gt;CachedRowSetImpl&lt;/code&gt; warnings will
 6800      * be chained to this &lt;code&gt;SQLWarning&lt;/code&gt;. All &lt;code&gt;RowSetWarnings&lt;/code&gt;
 6801      * warnings are generated in the disconnected environment and remain a
 6802      * seperate warning chain to that provided by the &lt;code&gt;getWarnings&lt;/code&gt;
 6803      * method.
 6804      *
 6805      * &lt;P&gt;The warning chain is automatically cleared each time a new
 6806      * row is read.
 6807      *
 6808      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This warning chain only covers warnings caused
 6809      * by &lt;code&gt;CachedRowSet&lt;/code&gt; (and their child interface)
 6810      * methods. All &lt;code&gt;SQLWarnings&lt;/code&gt; can be obtained using the
 6811      * &lt;code&gt;getWarnings&lt;/code&gt; method which tracks warnings generated
 6812      * by the underlying JDBC driver.
 6813      * @return the first SQLWarning or null
 6814      *
 6815      */
 6816     public RowSetWarning getRowSetWarnings() {
 6817         try {
 6818             notifyCursorMoved();
 6819         } catch (SQLException e) {} // mask exception
 6820         return rowsetWarning;
 6821     }
 6822 
 6823 
 6824     /**
 6825      * The function tries to isolate the tablename when only setCommand
 6826      * is set and not setTablename is called provided there is only one table
 6827      * name in the query else just leaves the setting of table name as such.
 6828      * If setTablename is set later it will over ride this table name
 6829      * value so retrieved.
 6830      *
 6831      * @return the tablename if only one table in query else return &quot;&quot;
 6832      */
 6833     private String buildTableName(String command) throws SQLException {
 6834 
 6835         // If we have a query from one table,
 6836         // we set the table name implicitly
 6837         // else user has to explicitly set the table name.
 6838 
 6839         int indexFrom, indexComma;
 6840         String strTablename =&quot;&quot;;
 6841         command = command.trim();
 6842 
 6843         // Query can be a select, insert or  update
 6844 
 6845         if(command.toLowerCase().startsWith(&quot;select&quot;)) {
 6846             // look for &quot;from&quot; keyword, after that look for a
 6847             // comma after from. If comma is there don&#39;t set
 6848             // table name else isolate table name.
 6849 
 6850             indexFrom = command.toLowerCase().indexOf(&quot;from&quot;);
 6851             indexComma = command.indexOf(&#39;,&#39;, indexFrom);
 6852 
 6853             if(indexComma == -1) {
 6854                 // implies only one table
 6855                 strTablename = (command.substring(indexFrom+&quot;from&quot;.length(),command.length())).trim();
 6856 
 6857                 String tabName = strTablename;
 6858 
 6859                 int idxWhere = tabName.toLowerCase().indexOf(&quot;where&quot;);
 6860 
 6861                 /**
 6862                   * Adding the addtional check for conditions following the table name.
 6863                   * If a condition is found truncate it.
 6864                   **/
 6865 
 6866                 if(idxWhere != -1)
 6867                 {
 6868                    tabName = tabName.substring(0,idxWhere).trim();
 6869                 }
 6870 
 6871                 strTablename = tabName;
 6872 
 6873             } else {
 6874                 //strTablename=&quot;&quot;;
 6875             }
 6876 
 6877         } else if(command.toLowerCase().startsWith(&quot;insert&quot;)) {
 6878             //strTablename=&quot;&quot;;
 6879         } else if(command.toLowerCase().startsWith(&quot;update&quot;)) {
 6880             //strTablename=&quot;&quot;;
 6881         }
 6882         return strTablename;
 6883     }
 6884 
 6885     /**
 6886      * Commits all changes performed by the &lt;code&gt;acceptChanges()&lt;/code&gt;
 6887      * methods
 6888      *
 6889      * @see java.sql.Connection#commit
 6890      */
 6891     public void commit() throws SQLException {
 6892         conn.commit();
 6893     }
 6894 
 6895     /**
 6896      * Rolls back all changes performed by the &lt;code&gt;acceptChanges()&lt;/code&gt;
 6897      * methods
 6898      *
 6899      * @see java.sql.Connection#rollback
 6900      */
 6901     public void rollback() throws SQLException {
 6902         conn.rollback();
 6903     }
 6904 
 6905     /**
 6906      * Rolls back all changes performed by the &lt;code&gt;acceptChanges()&lt;/code&gt;
 6907      * to the last &lt;code&gt;Savepoint&lt;/code&gt; transaction marker.
 6908      *
 6909      * @see java.sql.Connection#rollback(Savepoint)
 6910      */
 6911     public void rollback(Savepoint s) throws SQLException {
 6912         conn.rollback(s);
 6913     }
 6914 
 6915     /**
 6916      * Unsets the designated parameter to the given int array.
 6917      * This was set using &lt;code&gt;setMatchColumn&lt;/code&gt;
 6918      * as the column which will form the basis of the join.
 6919      * &lt;P&gt;
 6920      * The parameter value unset by this method should be same
 6921      * as was set.
 6922      *
 6923      * @param columnIdxes the index into this rowset
 6924      *        object&#39;s internal representation of parameter values
 6925      * @throws SQLException if an error occurs or the
 6926      *  parameter index is out of bounds or if the columnIdx is
 6927      *  not the same as set using &lt;code&gt;setMatchColumn(int [])&lt;/code&gt;
 6928      */
 6929     public void unsetMatchColumn(int[] columnIdxes) throws SQLException {
 6930 
 6931          int i_val;
 6932          for( int j= 0 ;j &lt; columnIdxes.length; j++) {
 6933             i_val = (Integer.parseInt(iMatchColumns.get(j).toString()));
 6934             if(columnIdxes[j] != i_val) {
 6935                throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.matchcols&quot;).toString());
 6936             }
 6937          }
 6938 
 6939          for( int i = 0;i &lt; columnIdxes.length ;i++) {
 6940             iMatchColumns.set(i, -1);
 6941          }
 6942     }
 6943 
 6944    /**
 6945      * Unsets the designated parameter to the given String array.
 6946      * This was set using &lt;code&gt;setMatchColumn&lt;/code&gt;
 6947      * as the column which will form the basis of the join.
 6948      * &lt;P&gt;
 6949      * The parameter value unset by this method should be same
 6950      * as was set.
 6951      *
 6952      * @param columnIdxes the index into this rowset
 6953      *        object&#39;s internal representation of parameter values
 6954      * @throws SQLException if an error occurs or the
 6955      *  parameter index is out of bounds or if the columnName is
 6956      *  not the same as set using &lt;code&gt;setMatchColumn(String [])&lt;/code&gt;
 6957      */
 6958     public void unsetMatchColumn(String[] columnIdxes) throws SQLException {
 6959 
 6960         for(int j = 0 ;j &lt; columnIdxes.length; j++) {
 6961            if( !columnIdxes[j].equals(strMatchColumns.get(j)) ){
 6962               throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.matchcols&quot;).toString());
 6963            }
 6964         }
 6965 
 6966         for(int i = 0 ; i &lt; columnIdxes.length; i++) {
 6967            strMatchColumns.set(i,null);
 6968         }
 6969     }
 6970 
 6971     /**
 6972      * Retrieves the column name as &lt;code&gt;String&lt;/code&gt; array
 6973      * that was set using &lt;code&gt;setMatchColumn(String [])&lt;/code&gt;
 6974      * for this rowset.
 6975      *
 6976      * @return a &lt;code&gt;String&lt;/code&gt; array object that contains the column names
 6977      *         for the rowset which has this the match columns
 6978      *
 6979      * @throws SQLException if an error occurs or column name is not set
 6980      */
 6981     public String[] getMatchColumnNames() throws SQLException {
 6982 
 6983         String []str_temp = new String[strMatchColumns.size()];
 6984 
 6985         if( strMatchColumns.get(0) == null) {
 6986            throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.setmatchcols&quot;).toString());
 6987         }
 6988 
 6989         strMatchColumns.copyInto(str_temp);
 6990         return str_temp;
 6991     }
 6992 
 6993     /**
 6994      * Retrieves the column id as &lt;code&gt;int&lt;/code&gt; array that was set using
 6995      * &lt;code&gt;setMatchColumn(int [])&lt;/code&gt; for this rowset.
 6996      *
 6997      * @return a &lt;code&gt;int&lt;/code&gt; array object that contains the column ids
 6998      *         for the rowset which has this as the match columns.
 6999      *
 7000      * @throws SQLException if an error occurs or column index is not set
 7001      */
 7002     public int[] getMatchColumnIndexes() throws SQLException {
 7003 
 7004         Integer []int_temp = new Integer[iMatchColumns.size()];
 7005         int [] i_temp = new int[iMatchColumns.size()];
 7006         int i_val;
 7007 
 7008         i_val = iMatchColumns.get(0);
 7009 
 7010         if( i_val == -1 ) {
 7011            throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.setmatchcols&quot;).toString());
 7012         }
 7013 
 7014 
 7015         iMatchColumns.copyInto(int_temp);
 7016 
 7017         for(int i = 0; i &lt; int_temp.length; i++) {
 7018            i_temp[i] = (int_temp[i]).intValue();
 7019         }
 7020 
 7021         return i_temp;
 7022     }
 7023 
 7024     /**
 7025      * Sets the designated parameter to the given int array.
 7026      * This forms the basis of the join for the
 7027      * &lt;code&gt;JoinRowSet&lt;/code&gt; as the column which will form the basis of the
 7028      * join.
 7029      * &lt;P&gt;
 7030      * The parameter value set by this method is stored internally and
 7031      * will be supplied as the appropriate parameter in this rowset&#39;s
 7032      * command when the method &lt;code&gt;getMatchColumnIndexes&lt;/code&gt; is called.
 7033      *
 7034      * @param columnIdxes the indexes into this rowset
 7035      *        object&#39;s internal representation of parameter values; the
 7036      *        first parameter is 0, the second is 1, and so on; must be
 7037      *        &lt;code&gt;0&lt;/code&gt; or greater
 7038      * @throws SQLException if an error occurs or the
 7039      *                         parameter index is out of bounds
 7040      */
 7041     public void setMatchColumn(int[] columnIdxes) throws SQLException {
 7042 
 7043         for(int j = 0 ; j &lt; columnIdxes.length; j++) {
 7044            if( columnIdxes[j] &lt; 0 ) {
 7045               throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.matchcols1&quot;).toString());
 7046            }
 7047         }
 7048         for(int i = 0 ;i &lt; columnIdxes.length; i++) {
 7049            iMatchColumns.add(i,columnIdxes[i]);
 7050         }
 7051     }
 7052 
 7053     /**
 7054      * Sets the designated parameter to the given String array.
 7055      *  This forms the basis of the join for the
 7056      * &lt;code&gt;JoinRowSet&lt;/code&gt; as the column which will form the basis of the
 7057      * join.
 7058      * &lt;P&gt;
 7059      * The parameter value set by this method is stored internally and
 7060      * will be supplied as the appropriate parameter in this rowset&#39;s
 7061      * command when the method &lt;code&gt;getMatchColumn&lt;/code&gt; is called.
 7062      *
 7063      * @param columnNames the name of the column into this rowset
 7064      *        object&#39;s internal representation of parameter values
 7065      * @throws SQLException if an error occurs or the
 7066      *  parameter index is out of bounds
 7067      */
 7068     public void setMatchColumn(String[] columnNames) throws SQLException {
 7069 
 7070         for(int j = 0; j &lt; columnNames.length; j++) {
 7071            if( columnNames[j] == null || columnNames[j].isEmpty()) {
 7072               throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.matchcols2&quot;).toString());
 7073            }
 7074         }
 7075         for( int i = 0; i &lt; columnNames.length; i++) {
 7076            strMatchColumns.add(i,columnNames[i]);
 7077         }
 7078     }
 7079 
 7080 
 7081     /**
 7082      * Sets the designated parameter to the given &lt;code&gt;int&lt;/code&gt;
 7083      * object.  This forms the basis of the join for the
 7084      * &lt;code&gt;JoinRowSet&lt;/code&gt; as the column which will form the basis of the
 7085      * join.
 7086      * &lt;P&gt;
 7087      * The parameter value set by this method is stored internally and
 7088      * will be supplied as the appropriate parameter in this rowset&#39;s
 7089      * command when the method &lt;code&gt;getMatchColumn&lt;/code&gt; is called.
 7090      *
 7091      * @param columnIdx the index into this rowset
 7092      *        object&#39;s internal representation of parameter values; the
 7093      *        first parameter is 0, the second is 1, and so on; must be
 7094      *        &lt;code&gt;0&lt;/code&gt; or greater
 7095      * @throws SQLException if an error occurs or the
 7096      *                         parameter index is out of bounds
 7097      */
 7098     public void setMatchColumn(int columnIdx) throws SQLException {
 7099         // validate, if col is ok to be set
 7100         if(columnIdx &lt; 0) {
 7101             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.matchcols1&quot;).toString());
 7102         } else {
 7103             // set iMatchColumn
 7104             iMatchColumns.set(0, columnIdx);
 7105             //strMatchColumn = null;
 7106         }
 7107     }
 7108 
 7109     /**
 7110      * Sets the designated parameter to the given &lt;code&gt;String&lt;/code&gt;
 7111      * object.  This forms the basis of the join for the
 7112      * &lt;code&gt;JoinRowSet&lt;/code&gt; as the column which will form the basis of the
 7113      * join.
 7114      * &lt;P&gt;
 7115      * The parameter value set by this method is stored internally and
 7116      * will be supplied as the appropriate parameter in this rowset&#39;s
 7117      * command when the method &lt;code&gt;getMatchColumn&lt;/code&gt; is called.
 7118      *
 7119      * @param columnName the name of the column into this rowset
 7120      *        object&#39;s internal representation of parameter values
 7121      * @throws SQLException if an error occurs or the
 7122      *  parameter index is out of bounds
 7123      */
 7124     public void setMatchColumn(String columnName) throws SQLException {
 7125         // validate, if col is ok to be set
 7126         if(columnName == null || (columnName= columnName.trim()).isEmpty() ) {
 7127             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.matchcols2&quot;).toString());
 7128         } else {
 7129             // set strMatchColumn
 7130             strMatchColumns.set(0, columnName);
 7131             //iMatchColumn = -1;
 7132         }
 7133     }
 7134 
 7135     /**
 7136      * Unsets the designated parameter to the given &lt;code&gt;int&lt;/code&gt;
 7137      * object.  This was set using &lt;code&gt;setMatchColumn&lt;/code&gt;
 7138      * as the column which will form the basis of the join.
 7139      * &lt;P&gt;
 7140      * The parameter value unset by this method should be same
 7141      * as was set.
 7142      *
 7143      * @param columnIdx the index into this rowset
 7144      *        object&#39;s internal representation of parameter values
 7145      * @throws SQLException if an error occurs or the
 7146      *  parameter index is out of bounds or if the columnIdx is
 7147      *  not the same as set using &lt;code&gt;setMatchColumn(int)&lt;/code&gt;
 7148      */
 7149     public void unsetMatchColumn(int columnIdx) throws SQLException {
 7150         // check if we are unsetting the SAME column
 7151         if(! iMatchColumns.get(0).equals(Integer.valueOf(columnIdx) )  ) {
 7152             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.unsetmatch&quot;).toString());
 7153         } else if(strMatchColumns.get(0) != null) {
 7154             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.unsetmatch1&quot;).toString());
 7155         } else {
 7156                 // that is, we are unsetting it.
 7157                iMatchColumns.set(0, -1);
 7158         }
 7159     }
 7160 
 7161     /**
 7162      * Unsets the designated parameter to the given &lt;code&gt;String&lt;/code&gt;
 7163      * object.  This was set using &lt;code&gt;setMatchColumn&lt;/code&gt;
 7164      * as the column which will form the basis of the join.
 7165      * &lt;P&gt;
 7166      * The parameter value unset by this method should be same
 7167      * as was set.
 7168      *
 7169      * @param columnName the index into this rowset
 7170      *        object&#39;s internal representation of parameter values
 7171      * @throws SQLException if an error occurs or the
 7172      *  parameter index is out of bounds or if the columnName is
 7173      *  not the same as set using &lt;code&gt;setMatchColumn(String)&lt;/code&gt;
 7174      */
 7175     public void unsetMatchColumn(String columnName) throws SQLException {
 7176         // check if we are unsetting the same column
 7177         columnName = columnName.trim();
 7178 
 7179         if(!((strMatchColumns.get(0)).equals(columnName))) {
 7180             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.unsetmatch&quot;).toString());
 7181         } else if(iMatchColumns.get(0) &gt; 0) {
 7182             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.unsetmatch2&quot;).toString());
 7183         } else {
 7184             strMatchColumns.set(0, null);   // that is, we are unsetting it.
 7185         }
 7186     }
 7187 
 7188     /**
 7189      * Notifies registered listeners that a RowSet object in the given RowSetEvent
 7190      * object has populated a number of additional rows. The &lt;code&gt;numRows&lt;/code&gt; parameter
 7191      * ensures that this event will only be fired every &lt;code&gt;numRow&lt;/code&gt;.
 7192      * &lt;p&gt;
 7193      * The source of the event can be retrieved with the method event.getSource.
 7194      *
 7195      * @param event a &lt;code&gt;RowSetEvent&lt;/code&gt; object that contains the
 7196      *     &lt;code&gt;RowSet&lt;/code&gt; object that is the source of the events
 7197      * @param numRows when populating, the number of rows interval on which the
 7198      *     &lt;code&gt;CachedRowSet&lt;/code&gt; populated should fire; the default value
 7199      *     is zero; cannot be less than &lt;code&gt;fetchSize&lt;/code&gt; or zero
 7200      */
 7201     public void rowSetPopulated(RowSetEvent event, int numRows) throws SQLException {
 7202 
 7203         if( numRows &lt; 0 || numRows &lt; getFetchSize()) {
 7204            throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.numrows&quot;).toString());
 7205         }
 7206 
 7207         if(size() % numRows == 0) {
 7208             RowSetEvent event_temp = new RowSetEvent(this);
 7209             event = event_temp;
 7210             notifyRowSetChanged();
 7211         }
 7212     }
 7213 
 7214     /**
 7215      * Populates this &lt;code&gt;CachedRowSet&lt;/code&gt; object with data from
 7216      * the given &lt;code&gt;ResultSet&lt;/code&gt; object. While related to the &lt;code&gt;populate(ResultSet)&lt;/code&gt;
 7217      * method, an additional parameter is provided to allow starting position within
 7218      * the &lt;code&gt;ResultSet&lt;/code&gt; from where to populate the CachedRowSet
 7219      * instance.
 7220      *
 7221      * This method is an alternative to the method &lt;code&gt;execute&lt;/code&gt;
 7222      * for filling the rowset with data.  The method &lt;code&gt;populate&lt;/code&gt;
 7223      * does not require that the properties needed by the method
 7224      * &lt;code&gt;execute&lt;/code&gt;, such as the &lt;code&gt;command&lt;/code&gt; property,
 7225      * be set. This is true because the method &lt;code&gt;populate&lt;/code&gt;
 7226      * is given the &lt;code&gt;ResultSet&lt;/code&gt; object from
 7227      * which to get data and thus does not need to use the properties
 7228      * required for setting up a connection and executing this
 7229      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object&#39;s command.
 7230      * &lt;P&gt;
 7231      * After populating this rowset with data, the method
 7232      * &lt;code&gt;populate&lt;/code&gt; sets the rowset&#39;s metadata and
 7233      * then sends a &lt;code&gt;RowSetChangedEvent&lt;/code&gt; object
 7234      * to all registered listeners prior to returning.
 7235      *
 7236      * @param data the &lt;code&gt;ResultSet&lt;/code&gt; object containing the data
 7237      *             to be read into this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 7238      * @param start the integer specifing the position in the
 7239      *        &lt;code&gt;ResultSet&lt;/code&gt; object to popultate the
 7240      *        &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.
 7241      * @throws SQLException if an error occurs; or the max row setting is
 7242      *          violated while populating the RowSet.Also id the start position
 7243      *          is negative.
 7244      * @see #execute
 7245      */
 7246      public void populate(ResultSet data, int start) throws SQLException{
 7247 
 7248         int rowsFetched;
 7249         Row currentRow;
 7250         int numCols;
 7251         int i;
 7252         Map&lt;String, Class&lt;?&gt;&gt; map = getTypeMap();
 7253         Object obj;
 7254         int mRows;
 7255 
 7256         cursorPos = 0;
 7257         if(populatecallcount == 0){
 7258             if(start &lt; 0){
 7259                throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.startpos&quot;).toString());
 7260             }
 7261             if(getMaxRows() == 0){
 7262                data.absolute(start);
 7263                while(data.next()){
 7264                    totalRows++;
 7265                }
 7266                totalRows++;
 7267             }
 7268             startPos = start;
 7269         }
 7270         populatecallcount = populatecallcount +1;
 7271         resultSet = data;
 7272         if((endPos - startPos) &gt;= getMaxRows() &amp;&amp; (getMaxRows() &gt; 0)){
 7273             endPos = prevEndPos;
 7274             pagenotend = false;
 7275             return;
 7276         }
 7277 
 7278         if((maxRowsreached != getMaxRows() || maxRowsreached != totalRows) &amp;&amp; pagenotend) {
 7279            startPrev = start - getPageSize();
 7280         }
 7281 
 7282         if( pageSize == 0){
 7283            prevEndPos = endPos;
 7284            endPos = start + getMaxRows() ;
 7285         }
 7286         else{
 7287             prevEndPos = endPos;
 7288             endPos = start + getPageSize();
 7289         }
 7290 
 7291 
 7292         if (start == 1){
 7293             resultSet.beforeFirst();
 7294         }
 7295         else {
 7296             resultSet.absolute(start -1);
 7297         }
 7298         if( pageSize == 0) {
 7299            rvh = new Vector&lt;Object&gt;(getMaxRows());
 7300 
 7301         }
 7302         else{
 7303             rvh = new Vector&lt;Object&gt;(getPageSize());
 7304         }
 7305 
 7306         if (data == null) {
 7307             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.populate&quot;).toString());
 7308         }
 7309 
 7310         // get the meta data for this ResultSet
 7311         RSMD = data.getMetaData();
 7312 
 7313         // set up the metadata
 7314         RowSetMD = new RowSetMetaDataImpl();
 7315         initMetaData(RowSetMD, RSMD);
 7316 
 7317         // release the meta-data so that aren&#39;t tempted to use it.
 7318         RSMD = null;
 7319         numCols = RowSetMD.getColumnCount();
 7320         mRows = this.getMaxRows();
 7321         rowsFetched = 0;
 7322         currentRow = null;
 7323 
 7324         if(!data.next() &amp;&amp; mRows == 0){
 7325             endPos = prevEndPos;
 7326             pagenotend = false;
 7327             return;
 7328         }
 7329 
 7330         data.previous();
 7331 
 7332         while ( data.next()) {
 7333 
 7334             currentRow = new Row(numCols);
 7335           if(pageSize == 0){
 7336             if ( rowsFetched &gt;= mRows &amp;&amp; mRows &gt; 0) {
 7337                 rowsetWarning.setNextException(new SQLException(&quot;Populating rows &quot;
 7338                 + &quot;setting has exceeded max row setting&quot;));
 7339                 break;
 7340             }
 7341           }
 7342           else {
 7343               if ( (rowsFetched &gt;= pageSize) ||( maxRowsreached &gt;= mRows &amp;&amp; mRows &gt; 0)) {
 7344                 rowsetWarning.setNextException(new SQLException(&quot;Populating rows &quot;
 7345                 + &quot;setting has exceeded max row setting&quot;));
 7346                 break;
 7347             }
 7348           }
 7349 
 7350             for ( i = 1; i &lt;= numCols; i++) {
 7351                 /*
 7352                  * check if the user has set a map. If no map
 7353                  * is set then use plain getObject. This lets
 7354                  * us work with drivers that do not support
 7355                  * getObject with a map in fairly sensible way
 7356                  */
 7357                 if (map == null) {
 7358                     obj = data.getObject(i);
 7359                 } else {
 7360                     obj = data.getObject(i, map);
 7361                 }
 7362                 /*
 7363                  * the following block checks for the various
 7364                  * types that we have to serialize in order to
 7365                  * store - right now only structs have been tested
 7366                  */
 7367                 if (obj instanceof Struct) {
 7368                     obj = new SerialStruct((Struct)obj, map);
 7369                 } else if (obj instanceof SQLData) {
 7370                     obj = new SerialStruct((SQLData)obj, map);
 7371                 } else if (obj instanceof Blob) {
 7372                     obj = new SerialBlob((Blob)obj);
 7373                 } else if (obj instanceof Clob) {
 7374                     obj = new SerialClob((Clob)obj);
 7375                 } else if (obj instanceof java.sql.Array) {
 7376                     obj = new SerialArray((java.sql.Array)obj, map);
 7377                 }
 7378 
 7379                 currentRow.initColumnObject(i, obj);
 7380             }
 7381             rowsFetched++;
 7382             maxRowsreached++;
 7383             rvh.add(currentRow);
 7384         }
 7385         numRows = rowsFetched ;
 7386         // Also rowsFetched should be equal to rvh.size()
 7387         // notify any listeners that the rowset has changed
 7388         notifyRowSetChanged();
 7389 
 7390      }
 7391 
 7392     /**
 7393      * The nextPage gets the next page, that is a &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 7394      * containing the number of rows specified by page size.
 7395      * @return boolean value true indicating whether there are more pages to come and
 7396      *         false indicating that this is the last page.
 7397      * @throws SQLException if an error occurs or this called before calling populate.
 7398      */
 7399      public boolean nextPage() throws SQLException {
 7400 
 7401          if (populatecallcount == 0){
 7402              throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.nextpage&quot;).toString());
 7403          }
 7404          // Fix for 6554186
 7405          onFirstPage = false;
 7406          if(callWithCon){
 7407             crsReader.setStartPosition(endPos);
 7408             crsReader.readData((RowSetInternal)this);
 7409             resultSet = null;
 7410          }
 7411          else {
 7412             populate(resultSet,endPos);
 7413          }
 7414          return pagenotend;
 7415      }
 7416 
 7417     /**
 7418      * This is the setter function for setting the size of the page, which specifies
 7419      * how many rows have to be retrived at a time.
 7420      *
 7421      * @param size which is the page size
 7422      * @throws SQLException if size is less than zero or greater than max rows.
 7423      */
 7424      public void setPageSize (int size) throws SQLException {
 7425         if (size &lt; 0) {
 7426             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.pagesize&quot;).toString());
 7427         }
 7428         if (size &gt; getMaxRows() &amp;&amp; getMaxRows() != 0) {
 7429             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.pagesize1&quot;).toString());
 7430         }
 7431         pageSize = size;
 7432      }
 7433 
 7434     /**
 7435      * This is the getter function for the size of the page.
 7436      *
 7437      * @return an integer that is the page size.
 7438      */
 7439     public int getPageSize() {
 7440         return pageSize;
 7441     }
 7442 
 7443 
 7444     /**
 7445      * Retrieves the data present in the page prior to the page from where it is
 7446      * called.
 7447      * @return boolean value true if it retrieves the previous page, flase if it
 7448      *         is on the first page.
 7449      * @throws SQLException if it is called before populate is called or ResultSet
 7450      *         is of type &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; or if an error
 7451      *         occurs.
 7452      */
 7453     public boolean previousPage() throws SQLException {
 7454         int pS;
 7455         int mR;
 7456         int rem;
 7457 
 7458         pS = getPageSize();
 7459         mR = maxRowsreached;
 7460 
 7461         if (populatecallcount == 0){
 7462              throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.nextpage&quot;).toString());
 7463          }
 7464 
 7465         if( !callWithCon){
 7466            if(resultSet.getType() == ResultSet.TYPE_FORWARD_ONLY){
 7467                throw new SQLException (resBundle.handleGetObject(&quot;cachedrowsetimpl.fwdonly&quot;).toString());
 7468            }
 7469         }
 7470 
 7471         pagenotend = true;
 7472 
 7473         if(startPrev &lt; startPos ){
 7474                 onFirstPage = true;
 7475                return false;
 7476             }
 7477 
 7478         if(onFirstPage){
 7479             return false;
 7480         }
 7481 
 7482         rem = mR % pS;
 7483 
 7484         if(rem == 0){
 7485             maxRowsreached -= (2 * pS);
 7486             if(callWithCon){
 7487                 crsReader.setStartPosition(startPrev);
 7488                 crsReader.readData((RowSetInternal)this);
 7489                 resultSet = null;
 7490             }
 7491             else {
 7492                populate(resultSet,startPrev);
 7493             }
 7494             return true;
 7495         }
 7496         else
 7497         {
 7498             maxRowsreached -= (pS + rem);
 7499             if(callWithCon){
 7500                 crsReader.setStartPosition(startPrev);
 7501                 crsReader.readData((RowSetInternal)this);
 7502                 resultSet = null;
 7503             }
 7504             else {
 7505                populate(resultSet,startPrev);
 7506             }
 7507             return true;
 7508         }
 7509     }
 7510 
 7511     /**
 7512      * Goes to the page number passed as the parameter
 7513      * @param page , the page loaded on a call to this function
 7514      * @return true if the page exists false otherwise
 7515      * @throws SQLException if an error occurs
 7516      */
 7517     /*
 7518     public boolean absolutePage(int page) throws SQLException{
 7519 
 7520         boolean isAbs = true, retVal = true;
 7521         int counter;
 7522 
 7523         if( page &lt;= 0 ){
 7524             throw new SQLException(&quot;Absolute positoin is invalid&quot;);
 7525         }
 7526         counter = 0;
 7527 
 7528         firstPage();
 7529         counter++;
 7530         while((counter &lt; page) &amp;&amp; isAbs) {
 7531             isAbs = nextPage();
 7532             counter ++;
 7533         }
 7534 
 7535         if( !isAbs &amp;&amp; counter &lt; page){
 7536             retVal = false;
 7537         }
 7538         else if(counter == page){
 7539             retVal = true;
 7540         }
 7541 
 7542        return retVal;
 7543     }
 7544     */
 7545 
 7546 
 7547     /**
 7548      * Goes to the page number passed as the parameter  from the current page.
 7549      * The parameter can take postive or negative value accordingly.
 7550      * @param page , the page loaded on a call to this function
 7551      * @return true if the page exists false otherwise
 7552      * @throws SQLException if an error occurs
 7553      */
 7554     /*
 7555     public boolean relativePage(int page) throws SQLException {
 7556 
 7557         boolean isRel = true,retVal = true;
 7558         int counter;
 7559 
 7560         if(page &gt; 0){
 7561            counter  = 0;
 7562            while((counter &lt; page) &amp;&amp; isRel){
 7563               isRel = nextPage();
 7564               counter++;
 7565            }
 7566 
 7567            if(!isRel &amp;&amp; counter &lt; page){
 7568                retVal = false;
 7569            }
 7570            else if( counter == page){
 7571                retVal = true;
 7572            }
 7573            return retVal;
 7574         }
 7575         else {
 7576             counter = page;
 7577             isRel = true;
 7578             while((counter &lt; 0) &amp;&amp; isRel){
 7579                 isRel = previousPage();
 7580                 counter++;
 7581             }
 7582 
 7583             if( !isRel &amp;&amp; counter &lt; 0){
 7584                 retVal = false;
 7585             }
 7586             else if(counter == 0){
 7587                 retVal = true;
 7588             }
 7589             return retVal;
 7590         }
 7591     }
 7592     */
 7593 
 7594      /**
 7595      * Retrieves the first page of data as specified by the page size.
 7596      * @return boolean value true if present on first page, false otherwise
 7597      * @throws SQLException if it called before populate or ResultSet is of
 7598      *         type &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; or an error occurs
 7599      */
 7600     /*
 7601     public boolean firstPage() throws SQLException {
 7602            if (populatecallcount == 0){
 7603              throw new SQLException(&quot;Populate the data before calling &quot;);
 7604            }
 7605            if( !callWithCon){
 7606               if(resultSet.getType() == ResultSet.TYPE_FORWARD_ONLY) {
 7607                   throw new SQLException(&quot;Result of type forward only&quot;);
 7608               }
 7609            }
 7610            endPos = 0;
 7611            maxRowsreached = 0;
 7612            pagenotend = true;
 7613            if(callWithCon){
 7614                crsReader.setStartPosition(startPos);
 7615                crsReader.readData((RowSetInternal)this);
 7616                resultSet = null;
 7617            }
 7618            else {
 7619               populate(resultSet,startPos);
 7620            }
 7621            onFirstPage = true;
 7622            return onFirstPage;
 7623     }
 7624     */
 7625 
 7626     /**
 7627      * Retrives the last page of data as specified by the page size.
 7628      * @return boolean value tur if present on the last page, false otherwise
 7629      * @throws SQLException if called before populate or if an error occurs.
 7630      */
 7631      /*
 7632     public boolean lastPage() throws SQLException{
 7633           int pS;
 7634           int mR;
 7635           int quo;
 7636           int rem;
 7637 
 7638           pS = getPageSize();
 7639           mR = getMaxRows();
 7640 
 7641           if(pS == 0){
 7642               onLastPage = true;
 7643               return onLastPage;
 7644           }
 7645 
 7646           if(getMaxRows() == 0){
 7647               mR = totalRows;
 7648           }
 7649 
 7650           if (populatecallcount == 0){
 7651              throw new SQLException(&quot;Populate the data before calling &quot;);
 7652          }
 7653 
 7654          onFirstPage = false;
 7655 
 7656          if((mR % pS) == 0){
 7657              quo = mR / pS;
 7658              int start = startPos + (pS * (quo - 1));
 7659              maxRowsreached = mR - pS;
 7660              if(callWithCon){
 7661                  crsReader.setStartPosition(start);
 7662                  crsReader.readData((RowSetInternal)this);
 7663                  resultSet = null;
 7664              }
 7665              else {
 7666                 populate(resultSet,start);
 7667              }
 7668              onLastPage = true;
 7669              return onLastPage;
 7670          }
 7671         else {
 7672               quo = mR /pS;
 7673               rem = mR % pS;
 7674               int start = startPos + (pS * quo);
 7675              maxRowsreached = mR - (rem);
 7676              if(callWithCon){
 7677                  crsReader.setStartPosition(start);
 7678                  crsReader.readData((RowSetInternal)this);
 7679                  resultSet = null;
 7680              }
 7681              else {
 7682                 populate(resultSet,start);
 7683              }
 7684              onLastPage = true;
 7685              return onLastPage;
 7686          }
 7687     }
 7688     */
 7689 
 7690    /**
 7691      * Sets the status for the row on which the cursor is positioned. The insertFlag is used
 7692      * to mention the toggle status for this row
 7693      * @param insertFlag if it is true  - marks this row as inserted
 7694      *                   if it is false - marks it as not a newly inserted row
 7695      * @throws SQLException if an error occurs while doing this operation
 7696      */
 7697     public void setRowInserted(boolean insertFlag) throws SQLException {
 7698 
 7699         checkCursor();
 7700 
 7701         if(onInsertRow == true)
 7702           throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidop&quot;).toString());
 7703 
 7704         if( insertFlag ) {
 7705           ((Row)getCurrentRow()).setInserted();
 7706         } else {
 7707           ((Row)getCurrentRow()).clearInserted();
 7708         }
 7709     }
 7710 
 7711     /**
 7712      * Retrieves the value of the designated &lt;code&gt;SQL XML&lt;/code&gt; parameter as a
 7713      * &lt;code&gt;SQLXML&lt;/code&gt; object in the Java programming language.
 7714      * @param columnIndex the first column is 1, the second is 2, ...
 7715      * @return a SQLXML object that maps an SQL XML value
 7716      * @throws SQLException if a database access error occurs
 7717      * @since 1.6
 7718      */
 7719     public SQLXML getSQLXML(int columnIndex) throws SQLException {
 7720         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7721     }
 7722 
 7723     /**
 7724      * Retrieves the value of the designated &lt;code&gt;SQL XML&lt;/code&gt; parameter as a
 7725      * &lt;code&gt;SQLXML&lt;/code&gt; object in the Java programming language.
 7726      * @param colName the name of the column from which to retrieve the value
 7727      * @return a SQLXML object that maps an SQL XML value
 7728      * @throws SQLException if a database access error occurs
 7729      */
 7730     public SQLXML getSQLXML(String colName) throws SQLException {
 7731         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7732     }
 7733 
 7734     /**
 7735      * Retrieves the value of the designated column in the current row of this
 7736      * &lt;code&gt;ResultSet&lt;/code&gt; object as a java.sql.RowId object in the Java
 7737      * programming language.
 7738      *
 7739      * @param columnIndex the first column is 1, the second 2, ...
 7740      * @return the column value if the value is a SQL &lt;code&gt;NULL&lt;/code&gt; the
 7741      *     value returned is &lt;code&gt;null&lt;/code&gt;
 7742      * @throws SQLException if a database access error occurs
 7743      * @since 1.6
 7744      */
 7745     public RowId getRowId(int columnIndex) throws SQLException {
 7746         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7747     }
 7748 
 7749     /**
 7750      * Retrieves the value of the designated column in the current row of this
 7751      * &lt;code&gt;ResultSet&lt;/code&gt; object as a java.sql.RowId object in the Java
 7752      * programming language.
 7753      *
 7754      * @param columnName the name of the column
 7755      * @return the column value if the value is a SQL &lt;code&gt;NULL&lt;/code&gt; the
 7756      *     value returned is &lt;code&gt;null&lt;/code&gt;
 7757      * @throws SQLException if a database access error occurs
 7758      * @since 1.6
 7759      */
 7760     public RowId getRowId(String columnName) throws SQLException {
 7761         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7762     }
 7763 
 7764     /**
 7765      * Updates the designated column with a &lt;code&gt;RowId&lt;/code&gt; value. The updater
 7766      * methods are used to update column values in the current row or the insert
 7767      * row. The updater methods do not update the underlying database; instead
 7768      * the {@code updateRow} or {@code insertRow} methods are called
 7769      * to update the database.
 7770      *
 7771      * @param columnIndex the first column is 1, the second 2, ...
 7772      * @param x the column value
 7773      * @throws SQLException if a database access occurs
 7774      * @since 1.6
 7775      */
 7776     public void updateRowId(int columnIndex, RowId x) throws SQLException {
 7777         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7778     }
 7779 
 7780     /**
 7781      * Updates the designated column with a &lt;code&gt;RowId&lt;/code&gt; value. The updater
 7782      * methods are used to update column values in the current row or the insert
 7783      * row. The updater methods do not update the underlying database; instead
 7784      * the {@code updateRow} or {@code insertRow} methods are called
 7785      * to update the database.
 7786      *
 7787      * @param columnName the name of the column
 7788      * @param x the column value
 7789      * @throws SQLException if a database access occurs
 7790      * @since 1.6
 7791      */
 7792     public void updateRowId(String columnName, RowId x) throws SQLException {
 7793         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7794     }
 7795 
 7796     /**
 7797      * Retrieves the holdability of this ResultSet object
 7798      * @return  either ResultSet.HOLD_CURSORS_OVER_COMMIT or ResultSet.CLOSE_CURSORS_AT_COMMIT
 7799      * @throws SQLException if a database error occurs
 7800      * @since 1.6
 7801      */
 7802     public int getHoldability() throws SQLException {
 7803         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7804     }
 7805 
 7806     /**
 7807      * Retrieves whether this ResultSet object has been closed. A ResultSet is closed if the
 7808      * method close has been called on it, or if it is automatically closed.
 7809      * @return true if this ResultSet object is closed; false if it is still open
 7810      * @throws SQLException if a database access error occurs
 7811      * @since 1.6
 7812      */
 7813     public boolean isClosed() throws SQLException {
 7814         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7815     }
 7816 
 7817     /**
 7818      * This method is used for updating columns that support National Character sets.
 7819      * It can be used for updating NCHAR,NVARCHAR and LONGNVARCHAR columns.
 7820      * @param columnIndex the first column is 1, the second 2, ...
 7821      * @param nString the value for the column to be updated
 7822      * @throws SQLException if a database access error occurs
 7823      * @since 1.6
 7824      */
 7825     public void updateNString(int columnIndex, String nString) throws SQLException {
 7826         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7827     }
 7828 
 7829     /**
 7830      * This method is used for updating columns that support National Character sets.
 7831      * It can be used for updating NCHAR,NVARCHAR and LONGNVARCHAR columns.
 7832      * @param columnName name of the Column
 7833      * @param nString the value for the column to be updated
 7834      * @throws SQLException if a database access error occurs
 7835      * @since 1.6
 7836      */
 7837     public void updateNString(String columnName, String nString) throws SQLException {
 7838         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7839     }
 7840 
 7841 
 7842     /*o
 7843      * This method is used for updating SQL &lt;code&gt;NCLOB&lt;/code&gt;  type that maps
 7844      * to &lt;code&gt;java.sql.Types.NCLOB&lt;/code&gt;
 7845      * @param columnIndex the first column is 1, the second 2, ...
 7846      * @param nClob the value for the column to be updated
 7847      * @throws SQLException if a database access error occurs
 7848      * @since 1.6
 7849      */
 7850     public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
 7851         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7852     }
 7853 
 7854     /**
 7855      * This method is used for updating SQL &lt;code&gt;NCLOB&lt;/code&gt;  type that maps
 7856      * to &lt;code&gt;java.sql.Types.NCLOB&lt;/code&gt;
 7857      * @param columnName name of the column
 7858      * @param nClob the value for the column to be updated
 7859      * @throws SQLException if a database access error occurs
 7860      * @since 1.6
 7861      */
 7862     public void updateNClob(String columnName, NClob nClob) throws SQLException {
 7863        throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7864     }
 7865 
 7866     /**
 7867      * Retrieves the value of the designated column in the current row
 7868      * of this &lt;code&gt;ResultSet&lt;/code&gt; object as a &lt;code&gt;NClob&lt;/code&gt; object
 7869      * in the Java programming language.
 7870      *
 7871      * @param i the first column is 1, the second is 2, ...
 7872      * @return a &lt;code&gt;NClob&lt;/code&gt; object representing the SQL
 7873      *         &lt;code&gt;NCLOB&lt;/code&gt; value in the specified column
 7874      * @exception SQLException if a database access error occurs
 7875      * @since 1.6
 7876      */
 7877     public NClob getNClob(int i) throws SQLException {
 7878         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7879     }
 7880 
 7881 
 7882    /**
 7883      * Retrieves the value of the designated column in the current row
 7884      * of this &lt;code&gt;ResultSet&lt;/code&gt; object as a &lt;code&gt;NClob&lt;/code&gt; object
 7885      * in the Java programming language.
 7886      *
 7887      * @param colName the name of the column from which to retrieve the value
 7888      * @return a &lt;code&gt;NClob&lt;/code&gt; object representing the SQL &lt;code&gt;NCLOB&lt;/code&gt;
 7889      * value in the specified column
 7890      * @exception SQLException if a database access error occurs
 7891      * @since 1.6
 7892      */
 7893     public NClob getNClob(String colName) throws SQLException {
 7894         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7895     }
 7896 
 7897     public &lt;T&gt; T unwrap(java.lang.Class&lt;T&gt; iface) throws java.sql.SQLException {
 7898         return null;
 7899     }
 7900 
 7901     public boolean isWrapperFor(Class&lt;?&gt; interfaces) throws SQLException {
 7902         return false;
 7903     }
 7904 
 7905 
 7906    /**
 7907       * Sets the designated parameter to the given &lt;code&gt;java.sql.SQLXML&lt;/code&gt; object. The driver converts this to an
 7908       * SQL &lt;code&gt;XML&lt;/code&gt; value when it sends it to the database.
 7909       * @param parameterIndex index of the first parameter is 1, the second is 2, ...
 7910       * @param xmlObject a &lt;code&gt;SQLXML&lt;/code&gt; object that maps an SQL &lt;code&gt;XML&lt;/code&gt; value
 7911       * @throws SQLException if a database access error occurs
 7912       * @since 1.6
 7913       */
 7914      public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
 7915          throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7916      }
 7917 
 7918    /**
 7919      * Sets the designated parameter to the given &lt;code&gt;java.sql.SQLXML&lt;/code&gt; object. The driver converts this to an
 7920      * &lt;code&gt;SQL XML&lt;/code&gt; value when it sends it to the database.
 7921      * @param parameterName the name of the parameter
 7922      * @param xmlObject a &lt;code&gt;SQLXML&lt;/code&gt; object that maps an &lt;code&gt;SQL XML&lt;/code&gt; value
 7923      * @throws SQLException if a database access error occurs
 7924      * @since 1.6
 7925      */
 7926     public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {
 7927          throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7928      }
 7929 
 7930 
 7931     /**
 7932      * Sets the designated parameter to the given &lt;code&gt;java.sql.RowId&lt;/code&gt; object. The
 7933      * driver converts this to a SQL &lt;code&gt;ROWID&lt;/code&gt; value when it sends it
 7934      * to the database
 7935      *
 7936      * @param parameterIndex the first parameter is 1, the second is 2, ...
 7937      * @param x the parameter value
 7938      * @throws SQLException if a database access error occurs
 7939      *
 7940      * @since 1.6
 7941      */
 7942     public void setRowId(int parameterIndex, RowId x) throws SQLException {
 7943          throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7944      }
 7945 
 7946 
 7947     /**
 7948     * Sets the designated parameter to the given &lt;code&gt;java.sql.RowId&lt;/code&gt; object. The
 7949     * driver converts this to a SQL &lt;code&gt;ROWID&lt;/code&gt; when it sends it to the
 7950     * database.
 7951     *
 7952     * @param parameterName the name of the parameter
 7953     * @param x the parameter value
 7954     * @throws SQLException if a database access error occurs
 7955     * @since 1.6
 7956     */
 7957    public void setRowId(String parameterName, RowId x) throws SQLException {
 7958          throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 7959      }
 7960 
 7961 
 7962     /**
 7963      * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object. The
 7964      * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
 7965      * driver does the necessary conversion from Java character format to
 7966      * the national character set in the database.
 7967 
 7968      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 7969      * Java stream object or your own subclass that implements the
 7970      * standard interface.
 7971      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 7972      * it might be more efficient to use a version of
 7973      * &lt;code&gt;setNCharacterStream&lt;/code&gt; which takes a length parameter.
 7974      *
 7975      * @param parameterIndex of the first parameter is 1, the second is 2, ...
 7976      * @param value the parameter value
 7977      * @throws SQLException if the driver does not support national
 7978      *         character sets;  if the driver can detect that a data conversion
 7979      *  error could occur ; if a database access error occurs; or
 7980      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 7981      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 7982      * @since 1.6
 7983      */
 7984      public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
 7985         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 7986      }
 7987 
 7988 
 7989     /**
 7990     * Sets the designated parameter to a &lt;code&gt;java.sql.NClob&lt;/code&gt; object. The object
 7991     * implements the &lt;code&gt;java.sql.NClob&lt;/code&gt; interface. This &lt;code&gt;NClob&lt;/code&gt;
 7992     * object maps to a SQL &lt;code&gt;NCLOB&lt;/code&gt;.
 7993     * @param parameterName the name of the column to be set
 7994     * @param value the parameter value
 7995     * @throws SQLException if the driver does not support national
 7996     *         character sets;  if the driver can detect that a data conversion
 7997     *  error could occur; or if a database access error occurs
 7998     * @since 1.6
 7999     */
 8000     public void setNClob(String parameterName, NClob value) throws SQLException {
 8001          throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 8002      }
 8003 
 8004 
 8005   /**
 8006      * Retrieves the value of the designated column in the current row
 8007      * of this &lt;code&gt;ResultSet&lt;/code&gt; object as a
 8008      * &lt;code&gt;java.io.Reader&lt;/code&gt; object.
 8009      * It is intended for use when
 8010      * accessing  &lt;code&gt;NCHAR&lt;/code&gt;,&lt;code&gt;NVARCHAR&lt;/code&gt;
 8011      * and &lt;code&gt;LONGNVARCHAR&lt;/code&gt; columns.
 8012      *
 8013      * @return a &lt;code&gt;java.io.Reader&lt;/code&gt; object that contains the column
 8014      * value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the value returned is
 8015      * &lt;code&gt;null&lt;/code&gt; in the Java programming language.
 8016      * @param columnIndex the first column is 1, the second is 2, ...
 8017      * @exception SQLException if a database access error occurs
 8018      * @since 1.6
 8019      */
 8020     public java.io.Reader getNCharacterStream(int columnIndex) throws SQLException {
 8021        throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 8022      }
 8023 
 8024 
 8025     /**
 8026      * Retrieves the value of the designated column in the current row
 8027      * of this &lt;code&gt;ResultSet&lt;/code&gt; object as a
 8028      * &lt;code&gt;java.io.Reader&lt;/code&gt; object.
 8029      * It is intended for use when
 8030      * accessing  &lt;code&gt;NCHAR&lt;/code&gt;,&lt;code&gt;NVARCHAR&lt;/code&gt;
 8031      * and &lt;code&gt;LONGNVARCHAR&lt;/code&gt; columns.
 8032      *
 8033      * @param columnName the name of the column
 8034      * @return a &lt;code&gt;java.io.Reader&lt;/code&gt; object that contains the column
 8035      * value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the value returned is
 8036      * &lt;code&gt;null&lt;/code&gt; in the Java programming language
 8037      * @exception SQLException if a database access error occurs
 8038      * @since 1.6
 8039      */
 8040     public java.io.Reader getNCharacterStream(String columnName) throws SQLException {
 8041        throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 8042      }
 8043 
 8044 
 8045     /**
 8046      * Updates the designated column with a &lt;code&gt;java.sql.SQLXML&lt;/code&gt; value.
 8047      * The updater
 8048      * methods are used to update column values in the current row or the insert
 8049      * row. The updater methods do not update the underlying database; instead
 8050      * the &lt;code&gt;updateRow&lt;/code&gt; or &lt;code&gt;insertRow&lt;/code&gt; methods are called
 8051      * to update the database.
 8052      * @param columnIndex the first column is 1, the second 2, ...
 8053      * @param xmlObject the value for the column to be updated
 8054      * @throws SQLException if a database access error occurs
 8055      * @since 1.6
 8056      */
 8057     public void updateSQLXML(int columnIndex, SQLXML xmlObject) throws SQLException {
 8058         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 8059     }
 8060 
 8061     /**
 8062      * Updates the designated column with a &lt;code&gt;java.sql.SQLXML&lt;/code&gt; value.
 8063      * The updater
 8064      * methods are used to update column values in the current row or the insert
 8065      * row. The updater methods do not update the underlying database; instead
 8066      * the &lt;code&gt;updateRow&lt;/code&gt; or &lt;code&gt;insertRow&lt;/code&gt; methods are called
 8067      * to update the database.
 8068      *
 8069      * @param columnName the name of the column
 8070      * @param xmlObject the column value
 8071      * @throws SQLException if a database access occurs
 8072      * @since 1.6
 8073      */
 8074     public void updateSQLXML(String columnName, SQLXML xmlObject) throws SQLException {
 8075         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 8076     }
 8077 
 8078      /**
 8079      * Retrieves the value of the designated column in the current row
 8080      * of this &lt;code&gt;ResultSet&lt;/code&gt; object as
 8081      * a &lt;code&gt;String&lt;/code&gt; in the Java programming language.
 8082      * It is intended for use when
 8083      * accessing  &lt;code&gt;NCHAR&lt;/code&gt;,&lt;code&gt;NVARCHAR&lt;/code&gt;
 8084      * and &lt;code&gt;LONGNVARCHAR&lt;/code&gt; columns.
 8085      *
 8086      * @param columnIndex the first column is 1, the second is 2, ...
 8087      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
 8088      * value returned is &lt;code&gt;null&lt;/code&gt;
 8089      * @exception SQLException if a database access error occurs
 8090      * @since 1.6
 8091      */
 8092     public String getNString(int columnIndex) throws SQLException {
 8093         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 8094     }
 8095 
 8096     /**
 8097      * Retrieves the value of the designated column in the current row
 8098      * of this &lt;code&gt;ResultSet&lt;/code&gt; object as
 8099      * a &lt;code&gt;String&lt;/code&gt; in the Java programming language.
 8100      * It is intended for use when
 8101      * accessing  &lt;code&gt;NCHAR&lt;/code&gt;,&lt;code&gt;NVARCHAR&lt;/code&gt;
 8102      * and &lt;code&gt;LONGNVARCHAR&lt;/code&gt; columns.
 8103      *
 8104      * @param columnName the SQL name of the column
 8105      * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
 8106      * value returned is &lt;code&gt;null&lt;/code&gt;
 8107      * @exception SQLException if a database access error occurs
 8108      * @since 1.6
 8109      */
 8110     public String getNString(String columnName) throws SQLException {
 8111         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 8112     }
 8113 
 8114      /**
 8115        * Updates the designated column with a character stream value, which will
 8116        * have the specified number of bytes. The driver does the necessary conversion
 8117        * from Java character format to the national character set in the database.
 8118        * It is intended for use when updating NCHAR,NVARCHAR and LONGNVARCHAR columns.
 8119        * The updater methods are used to update column values in the current row or
 8120        * the insert row. The updater methods do not update the underlying database;
 8121        * instead the updateRow or insertRow methods are called to update the database.
 8122        *
 8123        * @param columnIndex - the first column is 1, the second is 2, ...
 8124        * @param x - the new column value
 8125        * @param length - the length of the stream
 8126        * @exception SQLException if a database access error occurs
 8127        * @since 1.6
 8128        */
 8129        public void updateNCharacterStream(int columnIndex,
 8130                             java.io.Reader x,
 8131                             long length)
 8132                             throws SQLException {
 8133           throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 8134        }
 8135 
 8136      /**
 8137        * Updates the designated column with a character stream value, which will
 8138        * have the specified number of bytes. The driver does the necessary conversion
 8139        * from Java character format to the national character set in the database.
 8140        * It is intended for use when updating NCHAR,NVARCHAR and LONGNVARCHAR columns.
 8141        * The updater methods are used to update column values in the current row or
 8142        * the insert row. The updater methods do not update the underlying database;
 8143        * instead the updateRow or insertRow methods are called to update the database.
 8144        *
 8145        * @param columnName - name of the Column
 8146        * @param x - the new column value
 8147        * @param length - the length of the stream
 8148        * @exception SQLException if a database access error occurs
 8149        * @since 1.6
 8150        */
 8151        public void updateNCharacterStream(String columnName,
 8152                             java.io.Reader x,
 8153                             long length)
 8154                             throws SQLException {
 8155           throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.opnotysupp&quot;).toString());
 8156        }
 8157 
 8158      /**
 8159      * Updates the designated column with a character stream value.   The
 8160      * driver does the necessary conversion from Java character format to
 8161      * the national character set in the database.
 8162      * It is intended for use when
 8163      * updating  &lt;code&gt;NCHAR&lt;/code&gt;,&lt;code&gt;NVARCHAR&lt;/code&gt;
 8164      * and &lt;code&gt;LONGNVARCHAR&lt;/code&gt; columns.
 8165      *
 8166      * The updater methods are used to update column values in the
 8167      * current row or the insert row.  The updater methods do not
 8168      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8169      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8170      *
 8171      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8172      * it might be more efficient to use a version of
 8173      * &lt;code&gt;updateNCharacterStream&lt;/code&gt; which takes a length parameter.
 8174      *
 8175      * @param columnIndex the first column is 1, the second is 2, ...
 8176      * @param x the new column value
 8177      * @exception SQLException if a database access error occurs,
 8178      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt; or this method is called on a closed result set
 8179      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8180      * this method
 8181      * @since 1.6
 8182      */
 8183     public void updateNCharacterStream(int columnIndex,
 8184                              java.io.Reader x) throws SQLException {
 8185         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8186     }
 8187 
 8188     /**
 8189      * Updates the designated column with a character stream value.  The
 8190      * driver does the necessary conversion from Java character format to
 8191      * the national character set in the database.
 8192      * It is intended for use when
 8193      * updating  &lt;code&gt;NCHAR&lt;/code&gt;,&lt;code&gt;NVARCHAR&lt;/code&gt;
 8194      * and &lt;code&gt;LONGNVARCHAR&lt;/code&gt; columns.
 8195      *
 8196      * The updater methods are used to update column values in the
 8197      * current row or the insert row.  The updater methods do not
 8198      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8199      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8200      *
 8201      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8202      * it might be more efficient to use a version of
 8203      * &lt;code&gt;updateNCharacterStream&lt;/code&gt; which takes a length parameter.
 8204      *
 8205      * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the la
 8206 bel is the name of the column
 8207      * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object containing
 8208      *        the new column value
 8209      * @exception SQLException if a database access error occurs,
 8210      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt; or this method is called on a closed result set
 8211       * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8212      * this method
 8213      * @since 1.6
 8214      */
 8215     public void updateNCharacterStream(String columnLabel,
 8216                              java.io.Reader reader) throws SQLException {
 8217         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8218     }
 8219 
 8220 //////////////////////////
 8221 
 8222     /**
 8223      * Updates the designated column using the given input stream, which
 8224      * will have the specified number of bytes.
 8225      * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 8226      * parameter, it may be more practical to send it via a
 8227      * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
 8228      * as needed until end-of-file is reached.  The JDBC driver will
 8229      * do any necessary conversion from ASCII to the database char format.
 8230      *
 8231      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 8232      * Java stream object or your own subclass that implements the
 8233      * standard interface.
 8234      * &lt;p&gt;
 8235      * The updater methods are used to update column values in the
 8236      * current row or the insert row.  The updater methods do not
 8237      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8238      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8239      *
 8240      * @param columnIndex the first column is 1, the second is 2, ...
 8241      * @param inputStream An object that contains the data to set the parameter
 8242      * value to.
 8243      * @param length the number of bytes in the parameter data.
 8244      * @exception SQLException if a database access error occurs,
 8245      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8246      * or this method is called on a closed result set
 8247      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8248      * this method
 8249      * @since 1.6
 8250      */
 8251     public void updateBlob(int columnIndex, InputStream inputStream, long length) throws SQLException{
 8252         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8253     }
 8254 
 8255     /**
 8256      * Updates the designated column using the given input stream, which
 8257      * will have the specified number of bytes.
 8258      * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 8259      * parameter, it may be more practical to send it via a
 8260      * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
 8261      * as needed until end-of-file is reached.  The JDBC driver will
 8262      * do any necessary conversion from ASCII to the database char format.
 8263      *
 8264      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 8265      * Java stream object or your own subclass that implements the
 8266      * standard interface.
 8267      * &lt;p&gt;
 8268      * The updater methods are used to update column values in the
 8269      * current row or the insert row.  The updater methods do not
 8270      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8271      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8272      *
 8273      * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
 8274      * @param inputStream An object that contains the data to set the parameter
 8275      * value to.
 8276      * @param length the number of bytes in the parameter data.
 8277      * @exception SQLException if a database access error occurs,
 8278      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8279      * or this method is called on a closed result set
 8280      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8281      * this method
 8282      * @since 1.6
 8283      */
 8284     public void updateBlob(String columnLabel, InputStream inputStream, long length) throws SQLException {
 8285         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8286     }
 8287 
 8288     /**
 8289      * Updates the designated column using the given input stream.
 8290      * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 8291      * parameter, it may be more practical to send it via a
 8292      * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
 8293      * as needed until end-of-file is reached.  The JDBC driver will
 8294      * do any necessary conversion from ASCII to the database char format.
 8295      *
 8296      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 8297      * Java stream object or your own subclass that implements the
 8298      * standard interface.
 8299      *
 8300      *  &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8301      * it might be more efficient to use a version of
 8302      * &lt;code&gt;updateBlob&lt;/code&gt; which takes a length parameter.
 8303      * &lt;p&gt;
 8304      * The updater methods are used to update column values in the
 8305      * current row or the insert row.  The updater methods do not
 8306      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8307      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8308      *
 8309      * @param columnIndex the first column is 1, the second is 2, ...
 8310      * @param inputStream An object that contains the data to set the parameter
 8311      * value to.
 8312      * @exception SQLException if a database access error occurs,
 8313      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8314      * or this method is called on a closed result set
 8315      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8316      * this method
 8317      * @since 1.6
 8318      */
 8319     public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
 8320         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8321     }
 8322 
 8323     /**
 8324      * Updates the designated column using the given input stream.
 8325      * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 8326      * parameter, it may be more practical to send it via a
 8327      * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
 8328      * as needed until end-of-file is reached.  The JDBC driver will
 8329      * do any necessary conversion from ASCII to the database char format.
 8330      *
 8331      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 8332      * Java stream object or your own subclass that implements the
 8333      * standard interface.
 8334      *   &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8335      * it might be more efficient to use a version of
 8336      * &lt;code&gt;updateBlob&lt;/code&gt; which takes a length parameter.
 8337      * &lt;p&gt;
 8338      * The updater methods are used to update column values in the
 8339      * current row or the insert row.  The updater methods do not
 8340      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8341      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8342      *
 8343      * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the la
 8344 bel is the name of the column
 8345      * @param inputStream An object that contains the data to set the parameter
 8346      * value to.
 8347      * @exception SQLException if a database access error occurs,
 8348      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8349      * or this method is called on a closed result set
 8350      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8351      * this method
 8352      * @since 1.6
 8353      */
 8354     public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
 8355         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8356     }
 8357 
 8358     /**
 8359      * Updates the designated column using the given &lt;code&gt;Reader&lt;/code&gt;
 8360      * object, which is the given number of characters long.
 8361      * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 8362      * parameter, it may be more practical to send it via a
 8363      * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
 8364      * as needed until end-of-file is reached.  The JDBC driver will
 8365      * do any necessary conversion from UNICODE to the database char format.
 8366      *
 8367      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 8368      * Java stream object or your own subclass that implements the
 8369      * standard interface.
 8370      * &lt;p&gt;
 8371      * The updater methods are used to update column values in the
 8372      * current row or the insert row.  The updater methods do not
 8373      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8374      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8375      *
 8376      * @param columnIndex the first column is 1, the second is 2, ...
 8377      * @param reader An object that contains the data to set the parameter value to.
 8378      * @param length the number of characters in the parameter data.
 8379      * @exception SQLException if a database access error occurs,
 8380      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8381      * or this method is called on a closed result set
 8382      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8383      * this method
 8384      * @since 1.6
 8385      */
 8386     public void updateClob(int columnIndex,  Reader reader, long length) throws SQLException {
 8387         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8388     }
 8389 
 8390     /**
 8391      * Updates the designated column using the given &lt;code&gt;Reader&lt;/code&gt;
 8392      * object, which is the given number of characters long.
 8393      * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 8394      * parameter, it may be more practical to send it via a
 8395      * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
 8396      * as needed until end-of-file is reached.  The JDBC driver will
 8397      * do any necessary conversion from UNICODE to the database char format.
 8398      *
 8399      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 8400      * Java stream object or your own subclass that implements the
 8401      * standard interface.
 8402      * &lt;p&gt;
 8403      * The updater methods are used to update column values in the
 8404      * current row or the insert row.  The updater methods do not
 8405      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8406      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8407      *
 8408      * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
 8409      * @param reader An object that contains the data to set the parameter value to.
 8410      * @param length the number of characters in the parameter data.
 8411      * @exception SQLException if a database access error occurs,
 8412      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8413      * or this method is called on a closed result set
 8414      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8415      * this method
 8416      * @since 1.6
 8417      */
 8418     public void updateClob(String columnLabel,  Reader reader, long length) throws SQLException {
 8419         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8420     }
 8421 
 8422    /**
 8423      * Updates the designated column using the given &lt;code&gt;Reader&lt;/code&gt;
 8424      * object.
 8425      * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 8426      * parameter, it may be more practical to send it via a
 8427      * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
 8428      * as needed until end-of-file is reached.  The JDBC driver will
 8429      * do any necessary conversion from UNICODE to the database char format.
 8430      *
 8431      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 8432      * Java stream object or your own subclass that implements the
 8433      * standard interface.
 8434      *   &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8435      * it might be more efficient to use a version of
 8436      * &lt;code&gt;updateClob&lt;/code&gt; which takes a length parameter.
 8437      * &lt;p&gt;
 8438      * The updater methods are used to update column values in the
 8439      * current row or the insert row.  The updater methods do not
 8440      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8441      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8442      *
 8443      * @param columnIndex the first column is 1, the second is 2, ...
 8444      * @param reader An object that contains the data to set the parameter value to.
 8445      * @exception SQLException if a database access error occurs,
 8446      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8447      * or this method is called on a closed result set
 8448      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8449      * this method
 8450      * @since 1.6
 8451      */
 8452     public void updateClob(int columnIndex,  Reader reader) throws SQLException {
 8453         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8454     }
 8455 
 8456     /**
 8457      * Updates the designated column using the given &lt;code&gt;Reader&lt;/code&gt;
 8458      * object.
 8459      * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 8460      * parameter, it may be more practical to send it via a
 8461      * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
 8462      * as needed until end-of-file is reached.  The JDBC driver will
 8463      * do any necessary conversion from UNICODE to the database char format.
 8464      *
 8465      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 8466      * Java stream object or your own subclass that implements the
 8467      * standard interface.
 8468      *  &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8469      * it might be more efficient to use a version of
 8470      * &lt;code&gt;updateClob&lt;/code&gt; which takes a length parameter.
 8471      * &lt;p&gt;
 8472      * The updater methods are used to update column values in the
 8473      * current row or the insert row.  The updater methods do not
 8474      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8475      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8476      *
 8477      * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the la
 8478 bel is the name of the column
 8479      * @param reader An object that contains the data to set the parameter value to.
 8480      * @exception SQLException if a database access error occurs,
 8481      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8482      * or this method is called on a closed result set
 8483      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8484      * this method
 8485      * @since 1.6
 8486      */
 8487     public void updateClob(String columnLabel,  Reader reader) throws SQLException {
 8488         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8489     }
 8490 
 8491    /**
 8492      * Updates the designated column using the given &lt;code&gt;Reader&lt;/code&gt;
 8493      * object, which is the given number of characters long.
 8494      * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 8495      * parameter, it may be more practical to send it via a
 8496      * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
 8497      * as needed until end-of-file is reached.  The JDBC driver will
 8498      * do any necessary conversion from UNICODE to the database char format.
 8499      *
 8500      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 8501      * Java stream object or your own subclass that implements the
 8502      * standard interface.
 8503      * &lt;p&gt;
 8504      * The updater methods are used to update column values in the
 8505      * current row or the insert row.  The updater methods do not
 8506      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8507      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8508      *
 8509      * @param columnIndex the first column is 1, the second 2, ...
 8510      * @param reader An object that contains the data to set the parameter value to.
 8511      * @param length the number of characters in the parameter data.
 8512      * @throws SQLException if the driver does not support national
 8513      *         character sets;  if the driver can detect that a data conversion
 8514      *  error could occur; this method is called on a closed result set,
 8515      * if a database access error occurs or
 8516      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8517      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8518      * this method
 8519      * @since 1.6
 8520      */
 8521     public void updateNClob(int columnIndex,  Reader reader, long length) throws SQLException {
 8522         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8523     }
 8524 
 8525     /**
 8526      * Updates the designated column using the given &lt;code&gt;Reader&lt;/code&gt;
 8527      * object, which is the given number of characters long.
 8528      * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 8529      * parameter, it may be more practical to send it via a
 8530      * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
 8531      * as needed until end-of-file is reached.  The JDBC driver will
 8532      * do any necessary conversion from UNICODE to the database char format.
 8533      *
 8534      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 8535      * Java stream object or your own subclass that implements the
 8536      * standard interface.
 8537      * &lt;p&gt;
 8538      * The updater methods are used to update column values in the
 8539      * current row or the insert row.  The updater methods do not
 8540      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8541      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8542      *
 8543      * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
 8544      * @param reader An object that contains the data to set the parameter value to.
 8545      * @param length the number of characters in the parameter data.
 8546      * @throws SQLException if the driver does not support national
 8547      *         character sets;  if the driver can detect that a data conversion
 8548      *  error could occur; this method is called on a closed result set;
 8549      *  if a database access error occurs or
 8550      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8551      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8552      * this method
 8553      * @since 1.6
 8554      */
 8555     public void updateNClob(String columnLabel,  Reader reader, long length) throws SQLException {
 8556         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8557     }
 8558 
 8559     /**
 8560      * Updates the designated column using the given &lt;code&gt;Reader&lt;/code&gt;
 8561      * object.
 8562      * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 8563      * parameter, it may be more practical to send it via a
 8564      * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
 8565      * as needed until end-of-file is reached.  The JDBC driver will
 8566      * do any necessary conversion from UNICODE to the database char format.
 8567      *
 8568      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 8569      * Java stream object or your own subclass that implements the
 8570      * standard interface.
 8571      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8572      * it might be more efficient to use a version of
 8573      * &lt;code&gt;updateNClob&lt;/code&gt; which takes a length parameter.
 8574      * &lt;p&gt;
 8575      * The updater methods are used to update column values in the
 8576      * current row or the insert row.  The updater methods do not
 8577      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8578      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8579      *
 8580      * @param columnIndex the first column is 1, the second 2, ...
 8581      * @param reader An object that contains the data to set the parameter value to.
 8582      * @throws SQLException if the driver does not support national
 8583      *         character sets;  if the driver can detect that a data conversion
 8584      *  error could occur; this method is called on a closed result set,
 8585      * if a database access error occurs or
 8586      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8587      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8588      * this method
 8589      * @since 1.6
 8590      */
 8591     public void updateNClob(int columnIndex,  Reader reader) throws SQLException {
 8592         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8593     }
 8594 
 8595     /**
 8596      * Updates the designated column using the given &lt;code&gt;Reader&lt;/code&gt;
 8597      * object.
 8598      * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 8599      * parameter, it may be more practical to send it via a
 8600      * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
 8601      * as needed until end-of-file is reached.  The JDBC driver will
 8602      * do any necessary conversion from UNICODE to the database char format.
 8603      *
 8604      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 8605      * Java stream object or your own subclass that implements the
 8606      * standard interface.
 8607      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8608      * it might be more efficient to use a version of
 8609      * &lt;code&gt;updateNClob&lt;/code&gt; which takes a length parameter.
 8610      * &lt;p&gt;
 8611      * The updater methods are used to update column values in the
 8612      * current row or the insert row.  The updater methods do not
 8613      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8614      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8615      *
 8616      * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the la
 8617 bel is the name of the column
 8618      * @param reader An object that contains the data to set the parameter value to.
 8619      * @throws SQLException if the driver does not support national
 8620      *         character sets;  if the driver can detect that a data conversion
 8621      *  error could occur; this method is called on a closed result set;
 8622      *  if a database access error occurs or
 8623      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8624      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8625      * this method
 8626      * @since 1.6
 8627      */
 8628     public void updateNClob(String columnLabel,  Reader reader) throws SQLException {
 8629         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8630     }
 8631 
 8632         /**
 8633      * Updates the designated column with an ascii stream value, which will have
 8634      * the specified number of bytes.
 8635      * The updater methods are used to update column values in the
 8636      * current row or the insert row.  The updater methods do not
 8637      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8638      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8639      *
 8640      * @param columnIndex the first column is 1, the second is 2, ...
 8641      * @param x the new column value
 8642      * @param length the length of the stream
 8643      * @exception SQLException if a database access error occurs,
 8644      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8645      * or this method is called on a closed result set
 8646      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8647      * this method
 8648      * @since 1.6
 8649      */
 8650     public void updateAsciiStream(int columnIndex,
 8651                            java.io.InputStream x,
 8652                            long length) throws SQLException {
 8653 
 8654     }
 8655 
 8656     /**
 8657      * Updates the designated column with a binary stream value, which will have
 8658      * the specified number of bytes.
 8659      * The updater methods are used to update column values in the
 8660      * current row or the insert row.  The updater methods do not
 8661      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8662      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8663      *
 8664      * @param columnIndex the first column is 1, the second is 2, ...
 8665      * @param x the new column value
 8666      * @param length the length of the stream
 8667      * @exception SQLException if a database access error occurs,
 8668      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8669      * or this method is called on a closed result set
 8670      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8671      * this method
 8672      * @since 1.6
 8673      */
 8674     public void updateBinaryStream(int columnIndex,
 8675                             java.io.InputStream x,
 8676                             long length) throws SQLException {
 8677     }
 8678 
 8679     /**
 8680      * Updates the designated column with a character stream value, which will have
 8681      * the specified number of bytes.
 8682      * The updater methods are used to update column values in the
 8683      * current row or the insert row.  The updater methods do not
 8684      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8685      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8686      *
 8687      * @param columnIndex the first column is 1, the second is 2, ...
 8688      * @param x the new column value
 8689      * @param length the length of the stream
 8690      * @exception SQLException if a database access error occurs,
 8691      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8692      * or this method is called on a closed result set
 8693      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8694      * this method
 8695      * @since 1.6
 8696      */
 8697     public void updateCharacterStream(int columnIndex,
 8698                              java.io.Reader x,
 8699                              long length) throws SQLException {
 8700         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8701     }
 8702 
 8703     /**
 8704      * Updates the designated column with a character stream value, which will have
 8705      * the specified number of bytes.
 8706      * The updater methods are used to update column values in the
 8707      * current row or the insert row.  The updater methods do not
 8708      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8709      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8710      *
 8711      * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the la
 8712 bel is the name of the column
 8713      * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object containing
 8714      *        the new column value
 8715      * @param length the length of the stream
 8716      * @exception SQLException if a database access error occurs,
 8717      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8718      * or this method is called on a closed result set
 8719      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8720      * this method
 8721      * @since 1.6
 8722      */
 8723     public void updateCharacterStream(String columnLabel,
 8724                              java.io.Reader reader,
 8725                              long length) throws SQLException {
 8726         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8727     }
 8728      /**
 8729      * Updates the designated column with an ascii stream value, which will have
 8730      * the specified number of bytes..
 8731      * The updater methods are used to update column values in the
 8732      * current row or the insert row.  The updater methods do not
 8733      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8734      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8735      *
 8736      * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
 8737      * @param x the new column value
 8738      * @param length the length of the stream
 8739      * @exception SQLException if a database access error occurs,
 8740      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8741      * or this method is called on a closed result set
 8742      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8743      * this method
 8744      * @since 1.6
 8745      */
 8746     public void updateAsciiStream(String columnLabel,
 8747                            java.io.InputStream x,
 8748                            long length) throws SQLException {
 8749     }
 8750 
 8751     /**
 8752      * Updates the designated column with a binary stream value, which will have
 8753      * the specified number of bytes.
 8754      * The updater methods are used to update column values in the
 8755      * current row or the insert row.  The updater methods do not
 8756      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8757      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8758      *
 8759      * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the label is the name of the column
 8760      * @param x the new column value
 8761      * @param length the length of the stream
 8762      * @exception SQLException if a database access error occurs,
 8763      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8764      * or this method is called on a closed result set
 8765      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8766      * this method
 8767      * @since 1.6
 8768      */
 8769     public void updateBinaryStream(String columnLabel,
 8770                             java.io.InputStream x,
 8771                             long length) throws SQLException {
 8772     }
 8773 
 8774     /**
 8775      * Updates the designated column with a binary stream value.
 8776      * The updater methods are used to update column values in the
 8777      * current row or the insert row.  The updater methods do not
 8778      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8779      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8780      *
 8781      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8782      * it might be more efficient to use a version of
 8783      * &lt;code&gt;updateBinaryStream&lt;/code&gt; which takes a length parameter.
 8784      *
 8785      * @param columnIndex the first column is 1, the second is 2, ...
 8786      * @param x the new column value
 8787      * @exception SQLException if a database access error occurs,
 8788      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8789      * or this method is called on a closed result set
 8790      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8791      * this method
 8792      * @since 1.6
 8793      */
 8794     public void updateBinaryStream(int columnIndex,
 8795                             java.io.InputStream x) throws SQLException {
 8796         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8797     }
 8798 
 8799 
 8800     /**
 8801      * Updates the designated column with a binary stream value.
 8802      * The updater methods are used to update column values in the
 8803      * current row or the insert row.  The updater methods do not
 8804      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8805      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8806      *
 8807      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8808      * it might be more efficient to use a version of
 8809      * &lt;code&gt;updateBinaryStream&lt;/code&gt; which takes a length parameter.
 8810      *
 8811      * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the la
 8812 bel is the name of the column
 8813      * @param x the new column value
 8814      * @exception SQLException if a database access error occurs,
 8815      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8816      * or this method is called on a closed result set
 8817      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8818      * this method
 8819      * @since 1.6
 8820      */
 8821     public void updateBinaryStream(String columnLabel,
 8822                             java.io.InputStream x) throws SQLException {
 8823         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8824     }
 8825 
 8826     /**
 8827      * Updates the designated column with a character stream value.
 8828      * The updater methods are used to update column values in the
 8829      * current row or the insert row.  The updater methods do not
 8830      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8831      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8832      *
 8833      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8834      * it might be more efficient to use a version of
 8835      * &lt;code&gt;updateCharacterStream&lt;/code&gt; which takes a length parameter.
 8836      *
 8837      * @param columnIndex the first column is 1, the second is 2, ...
 8838      * @param x the new column value
 8839      * @exception SQLException if a database access error occurs,
 8840      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8841      * or this method is called on a closed result set
 8842      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8843      * this method
 8844      * @since 1.6
 8845      */
 8846     public void updateCharacterStream(int columnIndex,
 8847                              java.io.Reader x) throws SQLException {
 8848         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8849     }
 8850 
 8851     /**
 8852      * Updates the designated column with a character stream value.
 8853      * The updater methods are used to update column values in the
 8854      * current row or the insert row.  The updater methods do not
 8855      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8856      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8857      *
 8858      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8859      * it might be more efficient to use a version of
 8860      * &lt;code&gt;updateCharacterStream&lt;/code&gt; which takes a length parameter.
 8861      *
 8862      * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the la
 8863 bel is the name of the column
 8864      * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object containing
 8865      *        the new column value
 8866      * @exception SQLException if a database access error occurs,
 8867      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8868      * or this method is called on a closed result set
 8869      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8870      * this method
 8871      * @since 1.6
 8872      */
 8873     public void updateCharacterStream(String columnLabel,
 8874                              java.io.Reader reader) throws SQLException {
 8875         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8876     }
 8877 
 8878     /**
 8879      * Updates the designated column with an ascii stream value.
 8880      * The updater methods are used to update column values in the
 8881      * current row or the insert row.  The updater methods do not
 8882      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8883      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8884      *
 8885      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8886      * it might be more efficient to use a version of
 8887      * &lt;code&gt;updateAsciiStream&lt;/code&gt; which takes a length parameter.
 8888      *
 8889      * @param columnIndex the first column is 1, the second is 2, ...
 8890      * @param x the new column value
 8891      * @exception SQLException if a database access error occurs,
 8892      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8893      * or this method is called on a closed result set
 8894      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8895      * this method
 8896      * @since 1.6
 8897      */
 8898     public void updateAsciiStream(int columnIndex,
 8899                            java.io.InputStream x) throws SQLException {
 8900         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8901     }
 8902 
 8903     /**
 8904      * Updates the designated column with an ascii stream value.
 8905      * The updater methods are used to update column values in the
 8906      * current row or the insert row.  The updater methods do not
 8907      * update the underlying database; instead the &lt;code&gt;updateRow&lt;/code&gt; or
 8908      * &lt;code&gt;insertRow&lt;/code&gt; methods are called to update the database.
 8909      *
 8910      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8911      * it might be more efficient to use a version of
 8912      * &lt;code&gt;updateAsciiStream&lt;/code&gt; which takes a length parameter.
 8913      *
 8914      * @param columnLabel the label for the column specified with the SQL AS clause.  If the SQL AS clause was not specified, then the la
 8915 bel is the name of the column
 8916      * @param x the new column value
 8917      * @exception SQLException if a database access error occurs,
 8918      * the result set concurrency is &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt;
 8919      * or this method is called on a closed result set
 8920      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8921      * this method
 8922      * @since 1.6
 8923      */
 8924     public void updateAsciiStream(String columnLabel,
 8925                            java.io.InputStream x) throws SQLException {
 8926 
 8927     }
 8928 
 8929    /**
 8930   * Sets the designated parameter to the given &lt;code&gt;java.net.URL&lt;/code&gt; value.
 8931   * The driver converts this to an SQL &lt;code&gt;DATALINK&lt;/code&gt; value
 8932   * when it sends it to the database.
 8933   *
 8934   * @param parameterIndex the first parameter is 1, the second is 2, ...
 8935   * @param x the &lt;code&gt;java.net.URL&lt;/code&gt; object to be set
 8936   * @exception SQLException if a database access error occurs or
 8937   * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 8938   * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 8939   * @since 1.4
 8940   */
 8941   public void setURL(int parameterIndex, java.net.URL x) throws SQLException{
 8942         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8943    }
 8944 
 8945   /**
 8946   * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
 8947   * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
 8948   * because it informs the driver that the parameter value should be sent to
 8949   * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
 8950   * driver may have to do extra work to determine whether the parameter
 8951   * data should be sent to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
 8952   * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 8953   * it might be more efficient to use a version of
 8954   * &lt;code&gt;setNClob&lt;/code&gt; which takes a length parameter.
 8955   *
 8956   * @param parameterIndex index of the first parameter is 1, the second is 2, ...
 8957   * @param reader An object that contains the data to set the parameter value to.
 8958   * @throws SQLException if parameterIndex does not correspond to a parameter
 8959   * marker in the SQL statement;
 8960   * if the driver does not support national character sets;
 8961   * if the driver can detect that a data conversion
 8962   *  error could occur;  if a database access error occurs or
 8963   * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 8964   * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 8965   *
 8966   * @since 1.6
 8967   */
 8968   public void setNClob(int parameterIndex, Reader reader)
 8969     throws SQLException{
 8970         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8971    }
 8972 
 8973   /**
 8974   * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.  The &lt;code&gt;reader&lt;/code&gt; must contain  the number
 8975              * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
 8976             * generated when the &lt;code&gt;CallableStatement&lt;/code&gt; is executed.
 8977             * This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
 8978             * because it informs the driver that the parameter value should be sent to
 8979             * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
 8980             * driver may have to do extra work to determine whether the parameter
 8981             * data should be send to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
 8982             *
 8983             * @param parameterName the name of the parameter to be set
 8984             * @param reader An object that contains the data to set the parameter value to.
 8985             * @param length the number of characters in the parameter data.
 8986             * @throws SQLException if parameterIndex does not correspond to a parameter
 8987             * marker in the SQL statement; if the length specified is less than zero;
 8988             * if the driver does not support national
 8989             *         character sets;  if the driver can detect that a data conversion
 8990             *  error could occur; if a database access error occurs or
 8991             * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 8992             * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 8993             * this method
 8994             * @since 1.6
 8995             */
 8996             public void setNClob(String parameterName, Reader reader, long length)
 8997     throws SQLException{
 8998         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 8999    }
 9000 
 9001 
 9002  /**
 9003   * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
 9004   * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
 9005   * because it informs the driver that the parameter value should be sent to
 9006   * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
 9007   * driver may have to do extra work to determine whether the parameter
 9008   * data should be send to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
 9009   * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 9010   * it might be more efficient to use a version of
 9011   * &lt;code&gt;setNClob&lt;/code&gt; which takes a length parameter.
 9012   *
 9013   * @param parameterName the name of the parameter
 9014   * @param reader An object that contains the data to set the parameter value to.
 9015   * @throws SQLException if the driver does not support national character sets;
 9016   * if the driver can detect that a data conversion
 9017   *  error could occur;  if a database access error occurs or
 9018   * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9019   * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 9020   *
 9021   * @since 1.6
 9022   */
 9023   public void setNClob(String parameterName, Reader reader)
 9024     throws SQLException{
 9025         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9026    }
 9027 
 9028 
 9029     /**
 9030      * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.  The reader must contain  the number
 9031      * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
 9032      * generated when the &lt;code&gt;PreparedStatement&lt;/code&gt; is executed.
 9033      * This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
 9034      * because it informs the driver that the parameter value should be sent to
 9035      * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
 9036      * driver may have to do extra work to determine whether the parameter
 9037      * data should be sent to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
 9038      * @param parameterIndex index of the first parameter is 1, the second is 2, ...
 9039      * @param reader An object that contains the data to set the parameter value to.
 9040      * @param length the number of characters in the parameter data.
 9041      * @throws SQLException if parameterIndex does not correspond to a parameter
 9042      * marker in the SQL statement; if the length specified is less than zero;
 9043      * if the driver does not support national character sets;
 9044      * if the driver can detect that a data conversion
 9045      *  error could occur;  if a database access error occurs or
 9046      * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
 9047      * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 9048      *
 9049      * @since 1.6
 9050      */
 9051      public void setNClob(int parameterIndex, Reader reader, long length)
 9052        throws SQLException{
 9053         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9054    }
 9055 
 9056 
 9057     /**
 9058      * Sets the designated parameter to a &lt;code&gt;java.sql.NClob&lt;/code&gt; object. The driver converts this to
 9059 a
 9060      * SQL &lt;code&gt;NCLOB&lt;/code&gt; value when it sends it to the database.
 9061      * @param parameterIndex of the first parameter is 1, the second is 2, ...
 9062      * @param value the parameter value
 9063      * @throws SQLException if the driver does not support national
 9064      *         character sets;  if the driver can detect that a data conversion
 9065      *  error could occur ; or if a database access error occurs
 9066      * @since 1.6
 9067      */
 9068      public void setNClob(int parameterIndex, NClob value) throws SQLException{
 9069         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9070    }
 9071 
 9072 
 9073    /**
 9074   * Sets the designated parameter to the given &lt;code&gt;String&lt;/code&gt; object.
 9075   * The driver converts this to a SQL &lt;code&gt;NCHAR&lt;/code&gt; or
 9076   * &lt;code&gt;NVARCHAR&lt;/code&gt; or &lt;code&gt;LONGNVARCHAR&lt;/code&gt; value
 9077   * (depending on the argument&#39;s
 9078   * size relative to the driver&#39;s limits on &lt;code&gt;NVARCHAR&lt;/code&gt; values)
 9079   * when it sends it to the database.
 9080   *
 9081   * @param parameterIndex of the first parameter is 1, the second is 2, ...
 9082   * @param value the parameter value
 9083   * @throws SQLException if the driver does not support national
 9084   *         character sets;  if the driver can detect that a data conversion
 9085   *  error could occur ; or if a database access error occurs
 9086   * @since 1.6
 9087   */
 9088   public void setNString(int parameterIndex, String value) throws SQLException{
 9089         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9090    }
 9091 
 9092 
 9093  /**
 9094   * Sets the designated parameter to the given &lt;code&gt;String&lt;/code&gt; object.
 9095   * The driver converts this to a SQL &lt;code&gt;NCHAR&lt;/code&gt; or
 9096   * &lt;code&gt;NVARCHAR&lt;/code&gt; or &lt;code&gt;LONGNVARCHAR&lt;/code&gt;
 9097   * @param parameterName the name of the column to be set
 9098   * @param value the parameter value
 9099   * @throws SQLException if the driver does not support national
 9100   *         character sets;  if the driver can detect that a data conversion
 9101   *  error could occur; or if a database access error occurs
 9102   * @since 1.6
 9103   */
 9104  public void setNString(String parameterName, String value)
 9105          throws SQLException{
 9106         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9107    }
 9108 
 9109 
 9110  /**
 9111   * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object. The
 9112   * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
 9113   * driver does the necessary conversion from Java character format to
 9114   * the national character set in the database.
 9115   * @param parameterIndex of the first parameter is 1, the second is 2, ...
 9116   * @param value the parameter value
 9117   * @param length the number of characters in the parameter data.
 9118   * @throws SQLException if the driver does not support national
 9119   *         character sets;  if the driver can detect that a data conversion
 9120   *  error could occur ; or if a database access error occurs
 9121   * @since 1.6
 9122   */
 9123   public void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException{
 9124         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9125    }
 9126 
 9127 
 9128  /**
 9129   * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object. The
 9130   * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
 9131   * driver does the necessary conversion from Java character format to
 9132   * the national character set in the database.
 9133   * @param parameterName the name of the column to be set
 9134   * @param value the parameter value
 9135   * @param length the number of characters in the parameter data.
 9136   * @throws SQLException if the driver does not support national
 9137   *         character sets;  if the driver can detect that a data conversion
 9138   *  error could occur; or if a database access error occurs
 9139   * @since 1.6
 9140   */
 9141  public void setNCharacterStream(String parameterName, Reader value, long length)
 9142          throws SQLException{
 9143         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9144    }
 9145 
 9146   /**
 9147   * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object. The
 9148   * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
 9149   * driver does the necessary conversion from Java character format to
 9150   * the national character set in the database.
 9151 
 9152   * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 9153   * Java stream object or your own subclass that implements the
 9154   * standard interface.
 9155   * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 9156   * it might be more efficient to use a version of
 9157   * &lt;code&gt;setNCharacterStream&lt;/code&gt; which takes a length parameter.
 9158   *
 9159   * @param parameterName the name of the parameter
 9160   * @param value the parameter value
 9161   * @throws SQLException if the driver does not support national
 9162   *         character sets;  if the driver can detect that a data conversion
 9163   *  error could occur ; if a database access error occurs; or
 9164   * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9165   * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 9166   * @since 1.6
 9167   */
 9168   public void setNCharacterStream(String parameterName, Reader value) throws SQLException{
 9169         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9170    }
 9171 
 9172   /**
 9173     * Sets the designated parameter to the given &lt;code&gt;java.sql.Timestamp&lt;/code&gt; value,
 9174     * using the given &lt;code&gt;Calendar&lt;/code&gt; object.  The driver uses
 9175     * the &lt;code&gt;Calendar&lt;/code&gt; object to construct an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value,
 9176     * which the driver then sends to the database.  With a
 9177     * a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the timestamp
 9178     * taking into account a custom timezone.  If no
 9179     * &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the default
 9180     * timezone, which is that of the virtual machine running the application.
 9181     *
 9182     * @param parameterName the name of the parameter
 9183     * @param x the parameter value
 9184     * @param cal the &lt;code&gt;Calendar&lt;/code&gt; object the driver will use
 9185     *            to construct the timestamp
 9186     * @exception SQLException if a database access error occurs or
 9187     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9188     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9189     * this method
 9190     * @see #getTimestamp
 9191     * @since 1.4
 9192     */
 9193     public void setTimestamp(String parameterName, java.sql.Timestamp x, Calendar cal)
 9194        throws SQLException{
 9195         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9196    }
 9197 
 9198     /**
 9199     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.  The &lt;code&gt;reader&lt;/code&gt; must contain  the number
 9200                * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
 9201                * generated when the &lt;code&gt;CallableStatement&lt;/code&gt; is executed.
 9202               * This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
 9203               * because it informs the driver that the parameter value should be sent to
 9204               * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
 9205               * driver may have to do extra work to determine whether the parameter
 9206               * data should be send to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
 9207               * @param parameterName the name of the parameter to be set
 9208               * @param reader An object that contains the data to set the parameter value to.
 9209               * @param length the number of characters in the parameter data.
 9210               * @throws SQLException if parameterIndex does not correspond to a parameter
 9211               * marker in the SQL statement; if the length specified is less than zero;
 9212               * a database access error occurs or
 9213               * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9214               * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9215               * this method
 9216               *
 9217               * @since 1.6
 9218               */
 9219       public  void setClob(String parameterName, Reader reader, long length)
 9220       throws SQLException{
 9221         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9222    }
 9223 
 9224 
 9225   /**
 9226     * Sets the designated parameter to the given &lt;code&gt;java.sql.Clob&lt;/code&gt; object.
 9227     * The driver converts this to an SQL &lt;code&gt;CLOB&lt;/code&gt; value when it
 9228     * sends it to the database.
 9229     *
 9230     * @param parameterName the name of the parameter
 9231     * @param x a &lt;code&gt;Clob&lt;/code&gt; object that maps an SQL &lt;code&gt;CLOB&lt;/code&gt; value
 9232     * @exception SQLException if a database access error occurs or
 9233     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9234     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9235     * this method
 9236     * @since 1.6
 9237     */
 9238     public void setClob (String parameterName, Clob x) throws SQLException{
 9239         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9240    }
 9241 
 9242 
 9243  /**
 9244     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
 9245     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
 9246     * because it informs the driver that the parameter value should be sent to
 9247     * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
 9248     * driver may have to do extra work to determine whether the parameter
 9249     * data should be send to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
 9250     *
 9251     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 9252     * it might be more efficient to use a version of
 9253     * &lt;code&gt;setClob&lt;/code&gt; which takes a length parameter.
 9254     *
 9255     * @param parameterName the name of the parameter
 9256     * @param reader An object that contains the data to set the parameter value to.
 9257     * @throws SQLException if a database access error occurs or this method is called on
 9258     * a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9259     *
 9260     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 9261     * @since 1.6
 9262     */
 9263     public void setClob(String parameterName, Reader reader)
 9264       throws SQLException{
 9265         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9266    }
 9267 
 9268 
 9269  /**
 9270     * Sets the designated parameter to the given &lt;code&gt;java.sql.Date&lt;/code&gt; value
 9271     * using the default time zone of the virtual machine that is running
 9272     * the application.
 9273     * The driver converts this
 9274     * to an SQL &lt;code&gt;DATE&lt;/code&gt; value when it sends it to the database.
 9275     *
 9276     * @param parameterName the name of the parameter
 9277     * @param x the parameter value
 9278     * @exception SQLException if a database access error occurs or
 9279     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9280     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9281     * this method
 9282     * @see #getDate
 9283     * @since 1.4
 9284     */
 9285     public void setDate(String parameterName, java.sql.Date x)
 9286        throws SQLException{
 9287         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9288    }
 9289 
 9290 
 9291  /**
 9292     * Sets the designated parameter to the given &lt;code&gt;java.sql.Date&lt;/code&gt; value,
 9293     * using the given &lt;code&gt;Calendar&lt;/code&gt; object.  The driver uses
 9294     * the &lt;code&gt;Calendar&lt;/code&gt; object to construct an SQL &lt;code&gt;DATE&lt;/code&gt; value,
 9295     * which the driver then sends to the database.  With a
 9296     * a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the date
 9297     * taking into account a custom timezone.  If no
 9298     * &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the default
 9299     * timezone, which is that of the virtual machine running the application.
 9300     *
 9301     * @param parameterName the name of the parameter
 9302     * @param x the parameter value
 9303     * @param cal the &lt;code&gt;Calendar&lt;/code&gt; object the driver will use
 9304     *            to construct the date
 9305     * @exception SQLException if a database access error occurs or
 9306     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9307     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9308     * this method
 9309     * @see #getDate
 9310     * @since 1.4
 9311     */
 9312    public void setDate(String parameterName, java.sql.Date x, Calendar cal)
 9313        throws SQLException{
 9314         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9315    }
 9316 
 9317 
 9318  /**
 9319     * Sets the designated parameter to the given &lt;code&gt;java.sql.Time&lt;/code&gt; value.
 9320     * The driver converts this
 9321     * to an SQL &lt;code&gt;TIME&lt;/code&gt; value when it sends it to the database.
 9322     *
 9323     * @param parameterName the name of the parameter
 9324     * @param x the parameter value
 9325     * @exception SQLException if a database access error occurs or
 9326     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9327     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9328     * this method
 9329     * @see #getTime
 9330     * @since 1.4
 9331     */
 9332    public void setTime(String parameterName, java.sql.Time x)
 9333        throws SQLException{
 9334         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9335    }
 9336 
 9337 
 9338  /**
 9339     * Sets the designated parameter to the given &lt;code&gt;java.sql.Time&lt;/code&gt; value,
 9340     * using the given &lt;code&gt;Calendar&lt;/code&gt; object.  The driver uses
 9341     * the &lt;code&gt;Calendar&lt;/code&gt; object to construct an SQL &lt;code&gt;TIME&lt;/code&gt; value,
 9342     * which the driver then sends to the database.  With a
 9343     * a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the time
 9344     * taking into account a custom timezone.  If no
 9345     * &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the default
 9346     * timezone, which is that of the virtual machine running the application.
 9347     *
 9348     * @param parameterName the name of the parameter
 9349     * @param x the parameter value
 9350     * @param cal the &lt;code&gt;Calendar&lt;/code&gt; object the driver will use
 9351     *            to construct the time
 9352     * @exception SQLException if a database access error occurs or
 9353     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9354     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9355     * this method
 9356     * @see #getTime
 9357     * @since 1.4
 9358     */
 9359    public void setTime(String parameterName, java.sql.Time x, Calendar cal)
 9360        throws SQLException{
 9361         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9362    }
 9363 
 9364    /**
 9365    * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
 9366    * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
 9367    * because it informs the driver that the parameter value should be sent to
 9368    * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
 9369    * driver may have to do extra work to determine whether the parameter
 9370    * data should be sent to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
 9371    *
 9372    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 9373    * it might be more efficient to use a version of
 9374    * &lt;code&gt;setClob&lt;/code&gt; which takes a length parameter.
 9375    *
 9376    * @param parameterIndex index of the first parameter is 1, the second is 2, ...
 9377    * @param reader An object that contains the data to set the parameter value to.
 9378    * @throws SQLException if a database access error occurs, this method is called on
 9379    * a closed &lt;code&gt;PreparedStatement&lt;/code&gt;or if parameterIndex does not correspond to a parameter
 9380    * marker in the SQL statement
 9381    *
 9382    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 9383    * @since 1.6
 9384    */
 9385    public void setClob(int parameterIndex, Reader reader)
 9386      throws SQLException{
 9387         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9388    }
 9389 
 9390     /**
 9391    * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.  The reader must contain  the number
 9392    * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
 9393    * generated when the &lt;code&gt;PreparedStatement&lt;/code&gt; is executed.
 9394    *This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
 9395    * because it informs the driver that the parameter value should be sent to
 9396    * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
 9397    * driver may have to do extra work to determine whether the parameter
 9398    * data should be sent to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
 9399    * @param parameterIndex index of the first parameter is 1, the second is 2, ...
 9400    * @param reader An object that contains the data to set the parameter value to.
 9401    * @param length the number of characters in the parameter data.
 9402    * @throws SQLException if a database access error occurs, this method is called on
 9403    * a closed &lt;code&gt;PreparedStatement&lt;/code&gt;, if parameterIndex does not correspond to a parameter
 9404    * marker in the SQL statement, or if the length specified is less than zero.
 9405    *
 9406    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 9407    * @since 1.6
 9408    */
 9409    public void setClob(int parameterIndex, Reader reader, long length)
 9410      throws SQLException{
 9411         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9412    }
 9413 
 9414 
 9415  /**
 9416     * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.  The inputstream must contain  the number
 9417     * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
 9418     * generated when the &lt;code&gt;PreparedStatement&lt;/code&gt; is executed.
 9419     * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream, int)&lt;/code&gt;
 9420     * method because it informs the driver that the parameter value should be
 9421     * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
 9422     * the driver may have to do extra work to determine whether the parameter
 9423     * data should be sent to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
 9424     * @param parameterIndex index of the first parameter is 1,
 9425     * the second is 2, ...
 9426     * @param inputStream An object that contains the data to set the parameter
 9427     * value to.
 9428     * @param length the number of bytes in the parameter data.
 9429     * @throws SQLException if a database access error occurs,
 9430     * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;,
 9431     * if parameterIndex does not correspond
 9432     * to a parameter marker in the SQL statement,  if the length specified
 9433     * is less than zero or if the number of bytes in the inputstream does not match
 9434     * the specified length.
 9435     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 9436     *
 9437     * @since 1.6
 9438     */
 9439     public void setBlob(int parameterIndex, InputStream inputStream, long length)
 9440        throws SQLException{
 9441         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9442    }
 9443 
 9444 
 9445  /**
 9446     * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.
 9447     * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream)&lt;/code&gt;
 9448     * method because it informs the driver that the parameter value should be
 9449     * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
 9450     * the driver may have to do extra work to determine whether the parameter
 9451     * data should be sent to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
 9452     *
 9453     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 9454     * it might be more efficient to use a version of
 9455     * &lt;code&gt;setBlob&lt;/code&gt; which takes a length parameter.
 9456     *
 9457     * @param parameterIndex index of the first parameter is 1,
 9458     * the second is 2, ...
 9459     * @param inputStream An object that contains the data to set the parameter
 9460     * value to.
 9461     * @throws SQLException if a database access error occurs,
 9462     * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt; or
 9463     * if parameterIndex does not correspond
 9464     * to a parameter marker in the SQL statement,
 9465     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 9466     *
 9467     * @since 1.6
 9468     */
 9469     public void setBlob(int parameterIndex, InputStream inputStream)
 9470        throws SQLException{
 9471         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9472    }
 9473 
 9474 
 9475  /**
 9476     * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.  The &lt;code&gt;inputstream&lt;/code&gt; must contain  the number
 9477      * of characters specified by length, otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
 9478      * generated when the &lt;code&gt;CallableStatement&lt;/code&gt; is executed.
 9479      * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream, int)&lt;/code&gt;
 9480      * method because it informs the driver that the parameter value should be
 9481      * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
 9482      * the driver may have to do extra work to determine whether the parameter
 9483      * data should be sent to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
 9484      *
 9485      * @param parameterName the name of the parameter to be set
 9486      * the second is 2, ...
 9487      *
 9488      * @param inputStream An object that contains the data to set the parameter
 9489      * value to.
 9490      * @param length the number of bytes in the parameter data.
 9491      * @throws SQLException  if parameterIndex does not correspond
 9492      * to a parameter marker in the SQL statement,  or if the length specified
 9493      * is less than zero; if the number of bytes in the inputstream does not match
 9494      * the specified length; if a database access error occurs or
 9495      * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9496      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9497      * this method
 9498      *
 9499      * @since 1.6
 9500      */
 9501      public void setBlob(String parameterName, InputStream inputStream, long length)
 9502         throws SQLException{
 9503         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9504    }
 9505 
 9506 
 9507  /**
 9508     * Sets the designated parameter to the given &lt;code&gt;java.sql.Blob&lt;/code&gt; object.
 9509     * The driver converts this to an SQL &lt;code&gt;BLOB&lt;/code&gt; value when it
 9510     * sends it to the database.
 9511     *
 9512     * @param parameterName the name of the parameter
 9513     * @param x a &lt;code&gt;Blob&lt;/code&gt; object that maps an SQL &lt;code&gt;BLOB&lt;/code&gt; value
 9514     * @exception SQLException if a database access error occurs or
 9515     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9516     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9517     * this method
 9518     * @since 1.6
 9519     */
 9520    public void setBlob (String parameterName, Blob x) throws SQLException{
 9521         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9522    }
 9523 
 9524 
 9525  /**
 9526     * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.
 9527     * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream)&lt;/code&gt;
 9528     * method because it informs the driver that the parameter value should be
 9529     * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
 9530     * the driver may have to do extra work to determine whether the parameter
 9531     * data should be send to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
 9532     *
 9533     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 9534     * it might be more efficient to use a version of
 9535     * &lt;code&gt;setBlob&lt;/code&gt; which takes a length parameter.
 9536     *
 9537     * @param parameterName the name of the parameter
 9538     * @param inputStream An object that contains the data to set the parameter
 9539     * value to.
 9540     * @throws SQLException if a database access error occurs or
 9541     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9542     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 9543     *
 9544     * @since 1.6
 9545     */
 9546     public void setBlob(String parameterName, InputStream inputStream)
 9547        throws SQLException{
 9548         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9549    }
 9550 
 9551     /**
 9552     * Sets the value of the designated parameter with the given object. The second
 9553     * argument must be an object type; for integral values, the
 9554     * &lt;code&gt;java.lang&lt;/code&gt; equivalent objects should be used.
 9555     *
 9556     * &lt;p&gt;The given Java object will be converted to the given targetSqlType
 9557     * before being sent to the database.
 9558     *
 9559     * If the object has a custom mapping (is of a class implementing the
 9560     * interface &lt;code&gt;SQLData&lt;/code&gt;),
 9561     * the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write it
 9562     * to the SQL data stream.
 9563     * If, on the other hand, the object is of a class implementing
 9564     * &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;,  &lt;code&gt;NClob&lt;/code&gt;,
 9565     *  &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;,
 9566     * or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a
 9567     * value of the corresponding SQL type.
 9568     * &lt;P&gt;
 9569     * Note that this method may be used to pass datatabase-
 9570     * specific abstract data types.
 9571     *
 9572     * @param parameterName the name of the parameter
 9573     * @param x the object containing the input parameter value
 9574     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
 9575     * sent to the database. The scale argument may further qualify this type.
 9576     * @param scale for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types,
 9577     *          this is the number of digits after the decimal point.  For all other
 9578     *          types, this value will be ignored.
 9579     * @exception SQLException if a database access error occurs or
 9580     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9581     * @exception SQLFeatureNotSupportedException if &lt;code&gt;targetSqlType&lt;/code&gt; is
 9582     * a &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;BLOB&lt;/code&gt;, &lt;code&gt;CLOB&lt;/code&gt;,
 9583     * &lt;code&gt;DATALINK&lt;/code&gt;, &lt;code&gt;JAVA_OBJECT&lt;/code&gt;, &lt;code&gt;NCHAR&lt;/code&gt;,
 9584     * &lt;code&gt;NCLOB&lt;/code&gt;, &lt;code&gt;NVARCHAR&lt;/code&gt;, &lt;code&gt;LONGNVARCHAR&lt;/code&gt;,
 9585     *  &lt;code&gt;REF&lt;/code&gt;, &lt;code&gt;ROWID&lt;/code&gt;, &lt;code&gt;SQLXML&lt;/code&gt;
 9586     * or  &lt;code&gt;STRUCT&lt;/code&gt; data type and the JDBC driver does not support
 9587     * this data type
 9588     * @see Types
 9589     * @see #getObject
 9590     * @since 1.4
 9591     */
 9592     public void setObject(String parameterName, Object x, int targetSqlType, int scale)
 9593        throws SQLException{
 9594         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9595    }
 9596 
 9597 
 9598 
 9599  /**
 9600     * Sets the value of the designated parameter with the given object.
 9601     * This method is like the method &lt;code&gt;setObject&lt;/code&gt;
 9602     * above, except that it assumes a scale of zero.
 9603     *
 9604     * @param parameterName the name of the parameter
 9605     * @param x the object containing the input parameter value
 9606     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
 9607     *                      sent to the database
 9608     * @exception SQLException if a database access error occurs or
 9609     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9610     * @exception SQLFeatureNotSupportedException if &lt;code&gt;targetSqlType&lt;/code&gt; is
 9611     * a &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;BLOB&lt;/code&gt;, &lt;code&gt;CLOB&lt;/code&gt;,
 9612     * &lt;code&gt;DATALINK&lt;/code&gt;, &lt;code&gt;JAVA_OBJECT&lt;/code&gt;, &lt;code&gt;NCHAR&lt;/code&gt;,
 9613     * &lt;code&gt;NCLOB&lt;/code&gt;, &lt;code&gt;NVARCHAR&lt;/code&gt;, &lt;code&gt;LONGNVARCHAR&lt;/code&gt;,
 9614     *  &lt;code&gt;REF&lt;/code&gt;, &lt;code&gt;ROWID&lt;/code&gt;, &lt;code&gt;SQLXML&lt;/code&gt;
 9615     * or  &lt;code&gt;STRUCT&lt;/code&gt; data type and the JDBC driver does not support
 9616     * this data type
 9617     * @see #getObject
 9618     * @since 1.4
 9619     */
 9620     public void setObject(String parameterName, Object x, int targetSqlType)
 9621        throws SQLException{
 9622         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9623    }
 9624 
 9625 
 9626  /**
 9627    * Sets the value of the designated parameter with the given object.
 9628    * The second parameter must be of type &lt;code&gt;Object&lt;/code&gt;; therefore, the
 9629    * &lt;code&gt;java.lang&lt;/code&gt; equivalent objects should be used for built-in types.
 9630    *
 9631    * &lt;p&gt;The JDBC specification specifies a standard mapping from
 9632    * Java &lt;code&gt;Object&lt;/code&gt; types to SQL types.  The given argument
 9633    * will be converted to the corresponding SQL type before being
 9634    * sent to the database.
 9635    *
 9636    * &lt;p&gt;Note that this method may be used to pass datatabase-
 9637    * specific abstract data types, by using a driver-specific Java
 9638    * type.
 9639    *
 9640    * If the object is of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;,
 9641    * the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt;
 9642    * to write it to the SQL data stream.
 9643    * If, on the other hand, the object is of a class implementing
 9644    * &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;,  &lt;code&gt;NClob&lt;/code&gt;,
 9645    *  &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;,
 9646    * or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a
 9647    * value of the corresponding SQL type.
 9648    * &lt;P&gt;
 9649    * This method throws an exception if there is an ambiguity, for example, if the
 9650    * object is of a class implementing more than one of the interfaces named above.
 9651    *
 9652    * @param parameterName the name of the parameter
 9653    * @param x the object containing the input parameter value
 9654    * @exception SQLException if a database access error occurs,
 9655    * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt; or if the given
 9656    *            &lt;code&gt;Object&lt;/code&gt; parameter is ambiguous
 9657    * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9658    * this method
 9659    * @see #getObject
 9660    * @since 1.4
 9661    */
 9662    public void setObject(String parameterName, Object x) throws SQLException{
 9663         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9664    }
 9665 
 9666     /**
 9667     * Sets the designated parameter to the given input stream, which will have
 9668     * the specified number of bytes.
 9669     * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 9670     * parameter, it may be more practical to send it via a
 9671     * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
 9672     * as needed until end-of-file is reached.  The JDBC driver will
 9673     * do any necessary conversion from ASCII to the database char format.
 9674     *
 9675     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 9676     * Java stream object or your own subclass that implements the
 9677     * standard interface.
 9678     *
 9679     * @param parameterName the name of the parameter
 9680     * @param x the Java input stream that contains the ASCII parameter value
 9681     * @param length the number of bytes in the stream
 9682     * @exception SQLException if a database access error occurs or
 9683     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9684     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9685     * this method
 9686     * @since 1.4
 9687     */
 9688    public void setAsciiStream(String parameterName, java.io.InputStream x, int length)
 9689        throws SQLException{
 9690         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9691    }
 9692 
 9693 
 9694  /**
 9695     * Sets the designated parameter to the given input stream, which will have
 9696     * the specified number of bytes.
 9697     * When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt;
 9698     * parameter, it may be more practical to send it via a
 9699     * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The data will be read from the stream
 9700     * as needed until end-of-file is reached.
 9701     *
 9702     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 9703     * Java stream object or your own subclass that implements the
 9704     * standard interface.
 9705     *
 9706     * @param parameterName the name of the parameter
 9707     * @param x the java input stream which contains the binary parameter value
 9708     * @param length the number of bytes in the stream
 9709     * @exception SQLException if a database access error occurs or
 9710     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9711     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9712     * this method
 9713     * @since 1.4
 9714     */
 9715    public void setBinaryStream(String parameterName, java.io.InputStream x,
 9716                         int length) throws SQLException{
 9717         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9718    }
 9719 
 9720 
 9721   /**
 9722     * Sets the designated parameter to the given &lt;code&gt;Reader&lt;/code&gt;
 9723     * object, which is the given number of characters long.
 9724     * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 9725     * parameter, it may be more practical to send it via a
 9726     * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
 9727     * as needed until end-of-file is reached.  The JDBC driver will
 9728     * do any necessary conversion from UNICODE to the database char format.
 9729     *
 9730     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 9731     * Java stream object or your own subclass that implements the
 9732     * standard interface.
 9733     *
 9734     * @param parameterName the name of the parameter
 9735     * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object that
 9736     *        contains the UNICODE data used as the designated parameter
 9737     * @param length the number of characters in the stream
 9738     * @exception SQLException if a database access error occurs or
 9739     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9740     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9741     * this method
 9742     * @since 1.4
 9743     */
 9744    public void setCharacterStream(String parameterName,
 9745                            java.io.Reader reader,
 9746                            int length) throws SQLException{
 9747         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9748    }
 9749 
 9750 
 9751   /**
 9752    * Sets the designated parameter to the given input stream.
 9753    * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 9754    * parameter, it may be more practical to send it via a
 9755    * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
 9756    * as needed until end-of-file is reached.  The JDBC driver will
 9757    * do any necessary conversion from ASCII to the database char format.
 9758    *
 9759    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 9760    * Java stream object or your own subclass that implements the
 9761    * standard interface.
 9762    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 9763    * it might be more efficient to use a version of
 9764    * &lt;code&gt;setAsciiStream&lt;/code&gt; which takes a length parameter.
 9765    *
 9766    * @param parameterName the name of the parameter
 9767    * @param x the Java input stream that contains the ASCII parameter value
 9768    * @exception SQLException if a database access error occurs or
 9769    * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9770    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 9771      * @since 1.6
 9772   */
 9773   public void setAsciiStream(String parameterName, java.io.InputStream x)
 9774           throws SQLException{
 9775         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9776    }
 9777 
 9778 
 9779  /**
 9780     * Sets the designated parameter to the given input stream.
 9781     * When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt;
 9782     * parameter, it may be more practical to send it via a
 9783     * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The data will be read from the
 9784     * stream as needed until end-of-file is reached.
 9785     *
 9786     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 9787     * Java stream object or your own subclass that implements the
 9788     * standard interface.
 9789     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 9790     * it might be more efficient to use a version of
 9791     * &lt;code&gt;setBinaryStream&lt;/code&gt; which takes a length parameter.
 9792     *
 9793     * @param parameterName the name of the parameter
 9794     * @param x the java input stream which contains the binary parameter value
 9795     * @exception SQLException if a database access error occurs or
 9796     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9797     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 9798     * @since 1.6
 9799     */
 9800    public void setBinaryStream(String parameterName, java.io.InputStream x)
 9801    throws SQLException{
 9802         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9803    }
 9804 
 9805 
 9806 
 9807  /**
 9808     * Sets the designated parameter to the given &lt;code&gt;Reader&lt;/code&gt;
 9809     * object.
 9810     * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
 9811     * parameter, it may be more practical to send it via a
 9812     * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
 9813     * as needed until end-of-file is reached.  The JDBC driver will
 9814     * do any necessary conversion from UNICODE to the database char format.
 9815     *
 9816     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
 9817     * Java stream object or your own subclass that implements the
 9818     * standard interface.
 9819     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
 9820     * it might be more efficient to use a version of
 9821     * &lt;code&gt;setCharacterStream&lt;/code&gt; which takes a length parameter.
 9822     *
 9823     * @param parameterName the name of the parameter
 9824     * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object that contains the
 9825     *        Unicode data
 9826     * @exception SQLException if a database access error occurs or
 9827     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9828     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
 9829     * @since 1.6
 9830     */
 9831    public void setCharacterStream(String parameterName,
 9832                          java.io.Reader reader) throws SQLException{
 9833         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9834    }
 9835 
 9836    /**
 9837     * Sets the designated parameter to the given
 9838     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; value.
 9839     * The driver converts this to an SQL &lt;code&gt;NUMERIC&lt;/code&gt; value when
 9840     * it sends it to the database.
 9841     *
 9842     * @param parameterName the name of the parameter
 9843     * @param x the parameter value
 9844     * @exception SQLException if a database access error occurs or
 9845     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9846     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9847     * this method
 9848     * @see #getBigDecimal
 9849     * @since 1.4
 9850     */
 9851    public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException{
 9852         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9853    }
 9854 
 9855 
 9856 
 9857  /**
 9858     * Sets the designated parameter to the given Java &lt;code&gt;String&lt;/code&gt; value.
 9859     * The driver converts this
 9860     * to an SQL &lt;code&gt;VARCHAR&lt;/code&gt; or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value
 9861     * (depending on the argument&#39;s
 9862     * size relative to the driver&#39;s limits on &lt;code&gt;VARCHAR&lt;/code&gt; values)
 9863     * when it sends it to the database.
 9864     *
 9865     * @param parameterName the name of the parameter
 9866     * @param x the parameter value
 9867     * @exception SQLException if a database access error occurs or
 9868     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9869     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9870     * this method
 9871     * @see #getString
 9872     * @since 1.4
 9873     */
 9874    public void setString(String parameterName, String x) throws SQLException{
 9875         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9876    }
 9877 
 9878 
 9879 
 9880  /**
 9881     * Sets the designated parameter to the given Java array of bytes.
 9882     * The driver converts this to an SQL &lt;code&gt;VARBINARY&lt;/code&gt; or
 9883     * &lt;code&gt;LONGVARBINARY&lt;/code&gt; (depending on the argument&#39;s size relative
 9884     * to the driver&#39;s limits on &lt;code&gt;VARBINARY&lt;/code&gt; values) when it sends
 9885     * it to the database.
 9886     *
 9887     * @param parameterName the name of the parameter
 9888     * @param x the parameter value
 9889     * @exception SQLException if a database access error occurs or
 9890     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9891     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9892     * this method
 9893     * @see #getBytes
 9894     * @since 1.4
 9895     */
 9896    public void setBytes(String parameterName, byte x[]) throws SQLException{
 9897         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9898    }
 9899 
 9900 
 9901 
 9902  /**
 9903     * Sets the designated parameter to the given &lt;code&gt;java.sql.Timestamp&lt;/code&gt; value.
 9904     * The driver
 9905     * converts this to an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value when it sends it to the
 9906     * database.
 9907     *
 9908     * @param parameterName the name of the parameter
 9909     * @param x the parameter value
 9910     * @exception SQLException if a database access error occurs or
 9911     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9912     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9913     * this method
 9914     * @see #getTimestamp
 9915     * @since 1.4
 9916     */
 9917    public void setTimestamp(String parameterName, java.sql.Timestamp x)
 9918        throws SQLException{
 9919         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9920    }
 9921 
 9922     /**
 9923     * Sets the designated parameter to SQL &lt;code&gt;NULL&lt;/code&gt;.
 9924     *
 9925     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; You must specify the parameter&#39;s SQL type.
 9926     *
 9927     * @param parameterName the name of the parameter
 9928     * @param sqlType the SQL type code defined in &lt;code&gt;java.sql.Types&lt;/code&gt;
 9929     * @exception SQLException if a database access error occurs or
 9930     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9931     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9932     * this method
 9933     * @since 1.4
 9934     */
 9935    public void setNull(String parameterName, int sqlType) throws SQLException {
 9936         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9937    }
 9938 
 9939 
 9940  /**
 9941     * Sets the designated parameter to SQL &lt;code&gt;NULL&lt;/code&gt;.
 9942     * This version of the method &lt;code&gt;setNull&lt;/code&gt; should
 9943     * be used for user-defined types and REF type parameters.  Examples
 9944     * of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and
 9945     * named array types.
 9946     *
 9947     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; To be portable, applications must give the
 9948     * SQL type code and the fully-qualified SQL type name when specifying
 9949     * a NULL user-defined or REF parameter.  In the case of a user-defined type
 9950     * the name is the type name of the parameter itself.  For a REF
 9951     * parameter, the name is the type name of the referenced type.  If
 9952     * a JDBC driver does not need the type code or type name information,
 9953     * it may ignore it.
 9954     *
 9955     * Although it is intended for user-defined and Ref parameters,
 9956     * this method may be used to set a null parameter of any JDBC type.
 9957     * If the parameter does not have a user-defined or REF type, the given
 9958     * typeName is ignored.
 9959     *
 9960     *
 9961     * @param parameterName the name of the parameter
 9962     * @param sqlType a value from &lt;code&gt;java.sql.Types&lt;/code&gt;
 9963     * @param typeName the fully-qualified name of an SQL user-defined type;
 9964     *        ignored if the parameter is not a user-defined type or
 9965     *        SQL &lt;code&gt;REF&lt;/code&gt; value
 9966     * @exception SQLException if a database access error occurs or
 9967     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9968     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9969     * this method
 9970     * @since 1.4
 9971     */
 9972    public void setNull (String parameterName, int sqlType, String typeName)
 9973        throws SQLException{
 9974         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9975    }
 9976 
 9977 
 9978 
 9979  /**
 9980     * Sets the designated parameter to the given Java &lt;code&gt;boolean&lt;/code&gt; value.
 9981     * The driver converts this
 9982     * to an SQL &lt;code&gt;BIT&lt;/code&gt; or &lt;code&gt;BOOLEAN&lt;/code&gt; value when it sends it to the database.
 9983     *
 9984     * @param parameterName the name of the parameter
 9985     * @param x the parameter value
 9986     * @exception SQLException if a database access error occurs or
 9987     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
 9988     * @see #getBoolean
 9989     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
 9990     * this method
 9991     * @since 1.4
 9992     */
 9993    public void setBoolean(String parameterName, boolean x) throws SQLException{
 9994         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
 9995    }
 9996 
 9997 
 9998 
 9999  /**
10000     * Sets the designated parameter to the given Java &lt;code&gt;byte&lt;/code&gt; value.
10001     * The driver converts this
10002     * to an SQL &lt;code&gt;TINYINT&lt;/code&gt; value when it sends it to the database.
10003     *
10004     * @param parameterName the name of the parameter
10005     * @param x the parameter value
10006     * @exception SQLException if a database access error occurs or
10007     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
10008     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
10009     * this method
10010     * @see #getByte
10011     * @since 1.4
10012     */
10013    public void setByte(String parameterName, byte x) throws SQLException{
10014         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
10015    }
10016 
10017 
10018 
10019  /**
10020     * Sets the designated parameter to the given Java &lt;code&gt;short&lt;/code&gt; value.
10021     * The driver converts this
10022     * to an SQL &lt;code&gt;SMALLINT&lt;/code&gt; value when it sends it to the database.
10023     *
10024     * @param parameterName the name of the parameter
10025     * @param x the parameter value
10026     * @exception SQLException if a database access error occurs or
10027     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
10028     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
10029     * this method
10030     * @see #getShort
10031     * @since 1.4
10032     */
10033    public void setShort(String parameterName, short x) throws SQLException{
10034         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
10035    }
10036 
10037 
10038  /**
10039     * Sets the designated parameter to the given Java &lt;code&gt;int&lt;/code&gt; value.
10040     * The driver converts this
10041     * to an SQL &lt;code&gt;INTEGER&lt;/code&gt; value when it sends it to the database.
10042     *
10043     * @param parameterName the name of the parameter
10044     * @param x the parameter value
10045     * @exception SQLException if a database access error occurs or
10046     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
10047     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
10048     * this method
10049     * @see #getInt
10050     * @since 1.4
10051     */
10052    public void setInt(String parameterName, int x) throws SQLException{
10053         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
10054    }
10055 
10056 
10057  /**
10058     * Sets the designated parameter to the given Java &lt;code&gt;long&lt;/code&gt; value.
10059     * The driver converts this
10060     * to an SQL &lt;code&gt;BIGINT&lt;/code&gt; value when it sends it to the database.
10061     *
10062     * @param parameterName the name of the parameter
10063     * @param x the parameter value
10064     * @exception SQLException if a database access error occurs or
10065     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
10066     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
10067     * this method
10068     * @see #getLong
10069     * @since 1.4
10070     */
10071    public void setLong(String parameterName, long x) throws SQLException{
10072         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
10073    }
10074 
10075 
10076  /**
10077     * Sets the designated parameter to the given Java &lt;code&gt;float&lt;/code&gt; value.
10078     * The driver converts this
10079     * to an SQL &lt;code&gt;FLOAT&lt;/code&gt; value when it sends it to the database.
10080     *
10081     * @param parameterName the name of the parameter
10082     * @param x the parameter value
10083     * @exception SQLException if a database access error occurs or
10084     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
10085     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
10086     * this method
10087     * @see #getFloat
10088     * @since 1.4
10089     */
10090    public void setFloat(String parameterName, float x) throws SQLException{
10091         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
10092    }
10093 
10094 
10095  /**
10096     * Sets the designated parameter to the given Java &lt;code&gt;double&lt;/code&gt; value.
10097     * The driver converts this
10098     * to an SQL &lt;code&gt;DOUBLE&lt;/code&gt; value when it sends it to the database.
10099     *
10100     * @param parameterName the name of the parameter
10101     * @param x the parameter value
10102     * @exception SQLException if a database access error occurs or
10103     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
10104     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
10105     * this method
10106     * @see #getDouble
10107     * @since 1.4
10108     */
10109    public void setDouble(String parameterName, double x) throws SQLException{
10110         throw new SQLFeatureNotSupportedException(resBundle.handleGetObject(&quot;cachedrowsetimpl.featnotsupp&quot;).toString());
10111    }
10112 
10113    /**
10114      * This method re populates the resBundle
10115      * during the deserialization process
10116      *
10117      */
10118     private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
10119         // Default state initialization happens here
10120         ois.defaultReadObject();
10121         // Initialization of transient Res Bundle happens here .
10122         try {
10123            resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();
10124         } catch(IOException ioe) {
10125             throw new RuntimeException(ioe);
10126         }
10127 
10128     }
10129 
10130     //------------------------- JDBC 4.1 -----------------------------------
10131     public &lt;T&gt; T getObject(int columnIndex, Class&lt;T&gt; type) throws SQLException {
10132         throw new SQLFeatureNotSupportedException(&quot;Not supported yet.&quot;);
10133     }
10134 
10135     public &lt;T&gt; T getObject(String columnLabel, Class&lt;T&gt; type) throws SQLException {
10136         throw new SQLFeatureNotSupportedException(&quot;Not supported yet.&quot;);
10137     }
10138 
10139     static final long serialVersionUID =1884577171200622428L;
10140 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
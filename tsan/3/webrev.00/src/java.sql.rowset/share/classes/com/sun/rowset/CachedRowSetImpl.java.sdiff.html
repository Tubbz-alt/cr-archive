<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.sql.rowset/share/classes/com/sun/rowset/CachedRowSetImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../java.smartcardio/unix/legal/pcsclite.md.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="internal/SyncResolverImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.sql.rowset/share/classes/com/sun/rowset/CachedRowSetImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
    1 /*
<span class="line-modified">    2  * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.</span>
    3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4  *
    5  * This code is free software; you can redistribute it and/or modify it
    6  * under the terms of the GNU General Public License version 2 only, as
    7  * published by the Free Software Foundation.  Oracle designates this
    8  * particular file as subject to the &quot;Classpath&quot; exception as provided
    9  * by Oracle in the LICENSE file that accompanied this code.
   10  *
   11  * This code is distributed in the hope that it will be useful, but WITHOUT
   12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   14  * version 2 for more details (a copy is included in the LICENSE file that
   15  * accompanied this code).
   16  *
   17  * You should have received a copy of the GNU General Public License version
   18  * 2 along with this work; if not, write to the Free Software Foundation,
   19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   20  *
   21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
   25 
   26 package com.sun.rowset;
   27 
   28 import java.sql.*;
   29 import javax.sql.*;
   30 import java.io.*;
   31 import java.math.*;
   32 import java.util.*;
   33 import java.text.*;
   34 import java.security.AccessController;
   35 import java.security.PrivilegedActionException;
   36 import java.security.PrivilegedExceptionAction;
   37 
   38 import javax.sql.rowset.*;
   39 import javax.sql.rowset.spi.*;
   40 import javax.sql.rowset.serial.*;
   41 import com.sun.rowset.internal.*;
   42 import com.sun.rowset.providers.*;
   43 import sun.reflect.misc.ReflectUtil;
   44 


   45 /**
   46  * The standard implementation of the &lt;code&gt;CachedRowSet&lt;/code&gt; interface.
   47  *
   48  * See interface definition for full behavior and implementation requirements.
   49  * This reference implementation has made provision for a one-to-one write back
   50  * facility and it is curremtly be possible to change the peristence provider
   51  * during the life-time of any CachedRowSetImpl.
   52  *
   53  * @author Jonathan Bruce, Amit Handa
   54  */
   55 
   56 public class CachedRowSetImpl extends BaseRowSet implements RowSet, RowSetInternal, Serializable, Cloneable, CachedRowSet {
   57 
   58     /**
   59      * The &lt;code&gt;SyncProvider&lt;/code&gt; used by the CachedRowSet
   60      */
   61     private SyncProvider provider;
   62 
   63     /**
   64      * The &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object that is the reader
</pre>
<hr />
<pre>
 1582     }
 1583 
 1584     // Methods for accessing results by column index
 1585 
 1586     /**
 1587      * Checks to see whether the given index is a valid column number
 1588      * in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object and throws
 1589      * an &lt;code&gt;SQLException&lt;/code&gt; if it is not. The index is out of bounds
 1590      * if it is less than &lt;code&gt;1&lt;/code&gt; or greater than the number of
 1591      * columns in this rowset.
 1592      * &lt;P&gt;
 1593      * This method is called internally by the &lt;code&gt;getXXX&lt;/code&gt; and
 1594      * &lt;code&gt;updateXXX&lt;/code&gt; methods.
 1595      *
 1596      * @param idx the number of a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1597      *            object; must be between &lt;code&gt;1&lt;/code&gt; and the number of
 1598      *            rows in this rowset
 1599      * @throws SQLException if the given index is out of bounds
 1600      */
 1601     private void checkIndex(int idx) throws SQLException {
<span class="line-modified"> 1602         if (idx &lt; 1 || idx &gt; RowSetMD.getColumnCount()) {</span>
 1603             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcol&quot;).toString());
 1604         }
 1605     }
 1606 
 1607     /**
 1608      * Checks to see whether the cursor for this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1609      * object is on a row in the rowset and throws an
 1610      * &lt;code&gt;SQLException&lt;/code&gt; if it is not.
 1611      * &lt;P&gt;
 1612      * This method is called internally by &lt;code&gt;getXXX&lt;/code&gt; methods, by
 1613      * &lt;code&gt;updateXXX&lt;/code&gt; methods, and by methods that update, insert,
 1614      * or delete a row or that cancel a row update, insert, or delete.
 1615      *
 1616      * @throws SQLException if the cursor for this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1617      *         object is not on a valid row
 1618      */
 1619     private void checkCursor() throws SQLException {
 1620         if (isAfterLast() == true || isBeforeFirst() == true) {
 1621             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcp&quot;).toString());
 1622         }
 1623     }
 1624 
 1625     /**
 1626      * Returns the column number of the column with the given name in this
 1627      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.  This method throws an
 1628      * &lt;code&gt;SQLException&lt;/code&gt; if the given name is not the name of
 1629      * one of the columns in this rowset.
 1630      *
 1631      * @param name a &lt;code&gt;String&lt;/code&gt; object that is the name of a column in
 1632      *              this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 1633      * @throws SQLException if the given name does not match the name of one of
 1634      *         the columns in this rowset
 1635      */
 1636     private int getColIdxByName(String name) throws SQLException {
 1637         RowSetMD = (RowSetMetaDataImpl)this.getMetaData();
 1638         int cols = RowSetMD.getColumnCount();
<span class="line-modified"> 1639 </span>
<span class="line-modified"> 1640         for (int i=1; i &lt;= cols; ++i) {</span>
<span class="line-modified"> 1641             String colName = RowSetMD.getColumnName(i);</span>
<span class="line-modified"> 1642             if (colName != null)</span>
<span class="line-modified"> 1643                 if (name.equalsIgnoreCase(colName))</span>
<span class="line-modified"> 1644                     return (i);</span>
<span class="line-modified"> 1645                 else</span>
<span class="line-modified"> 1646                     continue;</span>

 1647         }
 1648         throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalcolnm&quot;).toString());
 1649 
 1650     }
 1651 
 1652     /**
 1653      * Returns the insert row or the current row of this
 1654      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt;object.
 1655      *
 1656      * @return the &lt;code&gt;Row&lt;/code&gt; object on which this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1657      * objects&#39;s cursor is positioned
 1658      */
 1659     protected BaseRow getCurrentRow() {
 1660         if (onInsertRow == true) {
 1661             return (BaseRow)insertRow;
 1662         } else {
 1663             return (BaseRow)(rvh.get(cursorPos - 1));
 1664         }
 1665     }
 1666 
</pre>
<hr />
<pre>
 2331      * used to retrieve.
 2332      * @see #getAsciiStream(String)
 2333      */
 2334     public java.io.InputStream getAsciiStream(int columnIndex) throws SQLException {
 2335         Object value;
 2336 
 2337         // always free an old stream
 2338         asciiStream = null;
 2339 
 2340         // sanity check
 2341         checkIndex(columnIndex);
 2342         //make sure the cursor is on a vlid row
 2343         checkCursor();
 2344 
 2345         value =  getCurrentRow().getColumnObject(columnIndex);
 2346         if (value == null) {
 2347             lastValueNull = true;
 2348             return null;
 2349         }
 2350 
<span class="line-modified"> 2351         try {</span>
<span class="line-modified"> 2352             if (isString(RowSetMD.getColumnType(columnIndex))) {</span>
<span class="line-modified"> 2353                 asciiStream = new ByteArrayInputStream(((String)value).getBytes(&quot;ASCII&quot;));</span>
<span class="line-modified"> 2354             } else {</span>
<span class="line-removed"> 2355                 throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());</span>
<span class="line-removed"> 2356             }</span>
<span class="line-removed"> 2357         } catch (java.io.UnsupportedEncodingException ex) {</span>
<span class="line-removed"> 2358             throw new SQLException(ex.getMessage());</span>
 2359         }
 2360 
 2361         return asciiStream;
 2362     }
 2363 
 2364     /**
 2365      * A column value can be retrieved as a stream of Unicode characters
 2366      * and then read in chunks from the stream.  This method is particularly
 2367      * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
 2368      * do any necessary conversion from the database format into Unicode.
 2369      *
 2370      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
 2371      * read prior to getting the value of any other column. The next
 2372      * call to a get method implicitly closes the stream. . Also, a
 2373      * stream may return 0 for available() whether there is data
 2374      * available or not.
 2375      *
 2376      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 2377      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 2378      *        and equal to or less than the number of columns in this rowset
</pre>
</td>
<td>
<hr />
<pre>
    1 /*
<span class="line-modified">    2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
    3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4  *
    5  * This code is free software; you can redistribute it and/or modify it
    6  * under the terms of the GNU General Public License version 2 only, as
    7  * published by the Free Software Foundation.  Oracle designates this
    8  * particular file as subject to the &quot;Classpath&quot; exception as provided
    9  * by Oracle in the LICENSE file that accompanied this code.
   10  *
   11  * This code is distributed in the hope that it will be useful, but WITHOUT
   12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   14  * version 2 for more details (a copy is included in the LICENSE file that
   15  * accompanied this code).
   16  *
   17  * You should have received a copy of the GNU General Public License version
   18  * 2 along with this work; if not, write to the Free Software Foundation,
   19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   20  *
   21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
   25 
   26 package com.sun.rowset;
   27 
   28 import java.sql.*;
   29 import javax.sql.*;
   30 import java.io.*;
   31 import java.math.*;
   32 import java.util.*;
   33 import java.text.*;
   34 import java.security.AccessController;
   35 import java.security.PrivilegedActionException;
   36 import java.security.PrivilegedExceptionAction;
   37 
   38 import javax.sql.rowset.*;
   39 import javax.sql.rowset.spi.*;
   40 import javax.sql.rowset.serial.*;
   41 import com.sun.rowset.internal.*;
   42 import com.sun.rowset.providers.*;
   43 import sun.reflect.misc.ReflectUtil;
   44 
<span class="line-added">   45 import static java.nio.charset.StandardCharsets.US_ASCII;</span>
<span class="line-added">   46 </span>
   47 /**
   48  * The standard implementation of the &lt;code&gt;CachedRowSet&lt;/code&gt; interface.
   49  *
   50  * See interface definition for full behavior and implementation requirements.
   51  * This reference implementation has made provision for a one-to-one write back
   52  * facility and it is curremtly be possible to change the peristence provider
   53  * during the life-time of any CachedRowSetImpl.
   54  *
   55  * @author Jonathan Bruce, Amit Handa
   56  */
   57 
   58 public class CachedRowSetImpl extends BaseRowSet implements RowSet, RowSetInternal, Serializable, Cloneable, CachedRowSet {
   59 
   60     /**
   61      * The &lt;code&gt;SyncProvider&lt;/code&gt; used by the CachedRowSet
   62      */
   63     private SyncProvider provider;
   64 
   65     /**
   66      * The &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object that is the reader
</pre>
<hr />
<pre>
 1584     }
 1585 
 1586     // Methods for accessing results by column index
 1587 
 1588     /**
 1589      * Checks to see whether the given index is a valid column number
 1590      * in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object and throws
 1591      * an &lt;code&gt;SQLException&lt;/code&gt; if it is not. The index is out of bounds
 1592      * if it is less than &lt;code&gt;1&lt;/code&gt; or greater than the number of
 1593      * columns in this rowset.
 1594      * &lt;P&gt;
 1595      * This method is called internally by the &lt;code&gt;getXXX&lt;/code&gt; and
 1596      * &lt;code&gt;updateXXX&lt;/code&gt; methods.
 1597      *
 1598      * @param idx the number of a column in this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1599      *            object; must be between &lt;code&gt;1&lt;/code&gt; and the number of
 1600      *            rows in this rowset
 1601      * @throws SQLException if the given index is out of bounds
 1602      */
 1603     private void checkIndex(int idx) throws SQLException {
<span class="line-modified"> 1604         if (idx &lt; 1 ||  RowSetMD == null || idx &gt; RowSetMD.getColumnCount()) {</span>
 1605             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcol&quot;).toString());
 1606         }
 1607     }
 1608 
 1609     /**
 1610      * Checks to see whether the cursor for this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1611      * object is on a row in the rowset and throws an
 1612      * &lt;code&gt;SQLException&lt;/code&gt; if it is not.
 1613      * &lt;P&gt;
 1614      * This method is called internally by &lt;code&gt;getXXX&lt;/code&gt; methods, by
 1615      * &lt;code&gt;updateXXX&lt;/code&gt; methods, and by methods that update, insert,
 1616      * or delete a row or that cancel a row update, insert, or delete.
 1617      *
 1618      * @throws SQLException if the cursor for this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1619      *         object is not on a valid row
 1620      */
 1621     private void checkCursor() throws SQLException {
 1622         if (isAfterLast() == true || isBeforeFirst() == true) {
 1623             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalidcp&quot;).toString());
 1624         }
 1625     }
 1626 
 1627     /**
 1628      * Returns the column number of the column with the given name in this
 1629      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object.  This method throws an
 1630      * &lt;code&gt;SQLException&lt;/code&gt; if the given name is not the name of
 1631      * one of the columns in this rowset.
 1632      *
 1633      * @param name a &lt;code&gt;String&lt;/code&gt; object that is the name of a column in
 1634      *              this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
 1635      * @throws SQLException if the given name does not match the name of one of
 1636      *         the columns in this rowset
 1637      */
 1638     private int getColIdxByName(String name) throws SQLException {
 1639         RowSetMD = (RowSetMetaDataImpl)this.getMetaData();
 1640         int cols = RowSetMD.getColumnCount();
<span class="line-modified"> 1641         if (RowSetMD != null) {</span>
<span class="line-modified"> 1642             for (int i = 1; i &lt;= cols; ++i) {</span>
<span class="line-modified"> 1643                 String colName = RowSetMD.getColumnName(i);</span>
<span class="line-modified"> 1644                 if (colName != null)</span>
<span class="line-modified"> 1645                     if (name.equalsIgnoreCase(colName))</span>
<span class="line-modified"> 1646                         return (i);</span>
<span class="line-modified"> 1647                     else</span>
<span class="line-modified"> 1648                         continue;</span>
<span class="line-added"> 1649             }</span>
 1650         }
 1651         throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalcolnm&quot;).toString());
 1652 
 1653     }
 1654 
 1655     /**
 1656      * Returns the insert row or the current row of this
 1657      * &lt;code&gt;CachedRowSetImpl&lt;/code&gt;object.
 1658      *
 1659      * @return the &lt;code&gt;Row&lt;/code&gt; object on which this &lt;code&gt;CachedRowSetImpl&lt;/code&gt;
 1660      * objects&#39;s cursor is positioned
 1661      */
 1662     protected BaseRow getCurrentRow() {
 1663         if (onInsertRow == true) {
 1664             return (BaseRow)insertRow;
 1665         } else {
 1666             return (BaseRow)(rvh.get(cursorPos - 1));
 1667         }
 1668     }
 1669 
</pre>
<hr />
<pre>
 2334      * used to retrieve.
 2335      * @see #getAsciiStream(String)
 2336      */
 2337     public java.io.InputStream getAsciiStream(int columnIndex) throws SQLException {
 2338         Object value;
 2339 
 2340         // always free an old stream
 2341         asciiStream = null;
 2342 
 2343         // sanity check
 2344         checkIndex(columnIndex);
 2345         //make sure the cursor is on a vlid row
 2346         checkCursor();
 2347 
 2348         value =  getCurrentRow().getColumnObject(columnIndex);
 2349         if (value == null) {
 2350             lastValueNull = true;
 2351             return null;
 2352         }
 2353 
<span class="line-modified"> 2354         if (isString(RowSetMD.getColumnType(columnIndex))) {</span>
<span class="line-modified"> 2355             asciiStream = new ByteArrayInputStream(((String)value).getBytes(US_ASCII));</span>
<span class="line-modified"> 2356         } else {</span>
<span class="line-modified"> 2357             throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.dtypemismt&quot;).toString());</span>




 2358         }
 2359 
 2360         return asciiStream;
 2361     }
 2362 
 2363     /**
 2364      * A column value can be retrieved as a stream of Unicode characters
 2365      * and then read in chunks from the stream.  This method is particularly
 2366      * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
 2367      * do any necessary conversion from the database format into Unicode.
 2368      *
 2369      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
 2370      * read prior to getting the value of any other column. The next
 2371      * call to a get method implicitly closes the stream. . Also, a
 2372      * stream may return 0 for available() whether there is data
 2373      * available or not.
 2374      *
 2375      * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
 2376      *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
 2377      *        and equal to or less than the number of columns in this rowset
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../java.smartcardio/unix/legal/pcsclite.md.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="internal/SyncResolverImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
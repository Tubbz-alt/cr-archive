<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.sql.rowset/share/classes/com/sun/rowset/internal/SyncResolverImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../CachedRowSetImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../package-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.sql.rowset/share/classes/com/sun/rowset/internal/SyncResolverImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 106     public SyncResolverImpl() throws SQLException {
 107         try {
 108             crsSync = new CachedRowSetImpl();
 109             crsRes = new CachedRowSetImpl();
 110             crw = new CachedRowSetWriter();
 111             row = new CachedRowSetImpl();
 112             rowStatus = 1;
 113             try {
 114                 resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();
 115             } catch(IOException ioe) {
 116                 throw new RuntimeException(ioe);
 117             }
 118 
 119         } catch(SQLException sqle) {
 120         }
 121      }
 122 
 123 
 124     /**
 125      * Retrieves the conflict status of the current row of this
<span class="line-modified"> 126      * {@code SyncResolver}, which indicates the operationthe {@code RowSet}</span>
 127      * object was attempting when the conflict occurred.
 128      *
 129      * @return one of the following constants:
 130      *         {@code SyncResolver.UPDATE_ROW_CONFLICT},
 131      *         {@code SyncResolver.DELETE_ROW_CONFLICT}, or
 132      *         {@code SyncResolver.INSERT_ROW_CONFLICT}
 133      */
 134     public int getStatus() {
<span class="line-modified"> 135         return ((Integer)stats.get(rowStatus-1)).intValue();</span>

 136     }
 137 
 138     /**
 139      * Retrieves the value in the designated column in the current row of this
 140      * {@code SyncResolver} object, which is the value that caused a conflict.
 141      *
 142      * @param index {@code int} designating the column in this row of this
 143      *        {@code SyncResolver} object from which to retrieve the value
 144      *        causing a conflict
 145      */
 146     public Object getConflictValue(int index) throws SQLException {
 147         try {
 148              return crsRes.getObject(index);
 149         } catch(SQLException sqle) {
 150             throw new SQLException(sqle.getMessage());


 151         }
 152     }
 153 
 154     /**
 155      * Retrieves the value in the designated column in the current row of this
 156      * {@code SyncResolver} object, which is the value that caused a conflict.
 157      *
 158      * @param columnName a {@code String} object designating the column in this row of this
 159      *        {@code SyncResolver} object from which to retrieve the value
 160      *        causing a conflict
 161      */
 162     public Object getConflictValue(String columnName) throws SQLException {
 163         try {
 164              return crsRes.getObject(columnName);
 165         } catch(SQLException sqle) {
 166              throw new SQLException(sqle.getMessage());


 167         }
 168     }
 169 
 170     /**
 171      * Sets &lt;i&gt;obj&lt;/i&gt; as the value in column &lt;i&gt;index&lt;/i&gt; in the current row of the
 172      * {@code RowSet} object. This value is the resolved value that is to be
 173      * persisted in the data source.
 174      *
 175      * @param index an {@code int} giving the number of the column into which to
 176      *        set the value to be persisted
 177      * @param obj an {@code Object} that is the value to be set in the data source
 178      */
 179     public void setResolvedValue(int index, Object obj) throws SQLException {
 180         // modify method to throw SQLException in spec
 181 
 182         /**
 183          * When a value is resolved properly make it to null
 184          * inside crsRes for that column.
 185          *
 186          * For more than one conflicts in the row,
 187          * check for the last resolved value of the current row
 188          * (Note: it can be resolved randomly for same row)
 189          * then sync back immediately.
 190          **/
 191         try {

 192             // check whether the index is in range
<span class="line-modified"> 193             if(index&lt;=0 || index &gt; crsSync.getMetaData().getColumnCount() ) {</span>
 194                 throw new SQLException(resBundle.handleGetObject(&quot;syncrsimpl.indexval&quot;).toString()+ index);
 195             }
 196              // check whether index col is in conflict
 197             if(crsRes.getObject(index) == null) {
 198                 throw new SQLException(resBundle.handleGetObject(&quot;syncrsimpl.noconflict&quot;).toString());
 199             }
 200         } catch (SQLException sqle) {
 201             // modify method to throw for SQLException
 202             throw new SQLException(sqle.getMessage());
 203         }
 204         try {
 205              boolean bool = true;
 206              /** Check resolved value to be either of conflict
 207                * or in rowset else throw sql exception.
 208                * If we allow a value other than that in CachedRowSet or
 209                * datasource we will end up in looping the loop of exceptions.
 210               **/
 211 
 212              if( ((crsSync.getObject(index)).toString()).equals(obj.toString()) ||
 213                      ((crsRes.getObject(index)).toString()).equals(obj.toString()) ) {
</pre>
<hr />
<pre>
 376        try {
 377             crsRow.setKeyColumns(crsSync.getKeyColumns());
 378        } catch(SQLException sqle) {
 379 
 380        }
 381        return crsRow;
 382     }
 383 
 384 
 385 
 386     /**
 387      * Sets &lt;i&gt;obj&lt;/i&gt; as the value in column &lt;i&gt;columnName&lt;/i&gt; in the current row of the
 388      * {@code RowSet} object. This value is the resolved value that is to be
 389      * persisted in the data source.
 390      *
 391      * @param columnName a {@code String} object giving the name of the column
 392      *        into which to set the value to be persisted
 393      * @param obj an {@code Object} that is the value to be set in the data source
 394      */
 395     public void setResolvedValue(String columnName, Object obj) throws SQLException {
<span class="line-modified"> 396        // modify method to throw SQLException in spec</span>
<span class="line-modified"> 397        // %%% Missing implementation!</span>
 398     }
 399 
 400     /**
 401      * This function is package private,
 402      * i.e. cannot be accesses outside this package.
 403      * This is used to set the actual CachedRowSet
 404      * which is being synchronized to the database
 405      **/
 406    void setCachedRowSet(CachedRowSet crs) {
 407            crsSync = (CachedRowSetImpl)crs;
 408     }
 409 
 410     /**
 411      * This function is package private,
 412      * i.e. cannot be accesses outside this package.
 413      * This is used to set the CachedRowSet formed
 414      * with conflict values.
 415      **/
 416     void setCachedRowSetResolver(CachedRowSet crs){
 417          try {
</pre>
<hr />
<pre>
 486              bool = true;
 487              break;
 488            } //end if
 489 
 490       } //end while
 491 
 492         crsSync.setShowDeleted(false);
 493         return bool;
 494    } // end next() method
 495 
 496 
 497     /**
 498      * Moves the cursor to the previous conflict row in this {@code SyncResolver} object.
 499      *
 500      * @return {@code true} if the cursor is on a valid row; {@code false}
 501      *     if it is off the result set
 502      * @throws SQLException if a database access error occurs or the result set type
 503      *     is TYPE_FORWARD_ONLY
 504      */
 505    public boolean previousConflict() throws SQLException {
<span class="line-modified"> 506        throw new UnsupportedOperationException();</span>
 507    }
 508 
 509     //-----------------------------------------------------------------------
 510     // Properties
 511     //-----------------------------------------------------------------------
 512 
 513     /**
 514      * Sets this {@code CachedRowSetImpl} object&#39;s command property
 515      * to the given {@code String} object and clears the parameters,
 516      * if any, that were set for the previous command.
 517      * &lt;P&gt;
 518      * The command property may not be needed
 519      * if the rowset is produced by a data source, such as a spreadsheet,
 520      * that does not support commands. Thus, this property is optional
 521      * and may be {@code null}.
 522      *
 523      * @param cmd a {@code String} object containing an SQL query
 524      *            that will be set as the command; may be {@code null}
 525      * @throws SQLException if an error occurs
 526      */
</pre>
</td>
<td>
<hr />
<pre>
 106     public SyncResolverImpl() throws SQLException {
 107         try {
 108             crsSync = new CachedRowSetImpl();
 109             crsRes = new CachedRowSetImpl();
 110             crw = new CachedRowSetWriter();
 111             row = new CachedRowSetImpl();
 112             rowStatus = 1;
 113             try {
 114                 resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();
 115             } catch(IOException ioe) {
 116                 throw new RuntimeException(ioe);
 117             }
 118 
 119         } catch(SQLException sqle) {
 120         }
 121      }
 122 
 123 
 124     /**
 125      * Retrieves the conflict status of the current row of this
<span class="line-modified"> 126      * {@code SyncResolver}, which indicates the operation the {@code RowSet}</span>
 127      * object was attempting when the conflict occurred.
 128      *
 129      * @return one of the following constants:
 130      *         {@code SyncResolver.UPDATE_ROW_CONFLICT},
 131      *         {@code SyncResolver.DELETE_ROW_CONFLICT}, or
 132      *         {@code SyncResolver.INSERT_ROW_CONFLICT}
 133      */
 134     public int getStatus() {
<span class="line-modified"> 135         return stats != null ? (Integer) stats.get(rowStatus - 1) :</span>
<span class="line-added"> 136                 SyncResolver.NO_ROW_CONFLICT;</span>
 137     }
 138 
 139     /**
 140      * Retrieves the value in the designated column in the current row of this
 141      * {@code SyncResolver} object, which is the value that caused a conflict.
 142      *
 143      * @param index {@code int} designating the column in this row of this
 144      *        {@code SyncResolver} object from which to retrieve the value
 145      *        causing a conflict
 146      */
 147     public Object getConflictValue(int index) throws SQLException {
 148         try {
 149              return crsRes.getObject(index);
 150         } catch(SQLException sqle) {
 151             throw new SQLException(sqle.getMessage());
<span class="line-added"> 152         } catch (Exception e ) {</span>
<span class="line-added"> 153             throw new SQLException(&quot;Problem obtaining conflicted value!&quot;, e);</span>
 154         }
 155     }
 156 
 157     /**
 158      * Retrieves the value in the designated column in the current row of this
 159      * {@code SyncResolver} object, which is the value that caused a conflict.
 160      *
 161      * @param columnName a {@code String} object designating the column in this row of this
 162      *        {@code SyncResolver} object from which to retrieve the value
 163      *        causing a conflict
 164      */
 165     public Object getConflictValue(String columnName) throws SQLException {
 166         try {
 167              return crsRes.getObject(columnName);
 168         } catch(SQLException sqle) {
 169              throw new SQLException(sqle.getMessage());
<span class="line-added"> 170         } catch (Exception e ) {</span>
<span class="line-added"> 171             throw new SQLException(&quot;Problem obtaining conflicted value!&quot;, e);</span>
 172         }
 173     }
 174 
 175     /**
 176      * Sets &lt;i&gt;obj&lt;/i&gt; as the value in column &lt;i&gt;index&lt;/i&gt; in the current row of the
 177      * {@code RowSet} object. This value is the resolved value that is to be
 178      * persisted in the data source.
 179      *
 180      * @param index an {@code int} giving the number of the column into which to
 181      *        set the value to be persisted
 182      * @param obj an {@code Object} that is the value to be set in the data source
 183      */
 184     public void setResolvedValue(int index, Object obj) throws SQLException {
 185         // modify method to throw SQLException in spec
 186 
 187         /**
 188          * When a value is resolved properly make it to null
 189          * inside crsRes for that column.
 190          *
 191          * For more than one conflicts in the row,
 192          * check for the last resolved value of the current row
 193          * (Note: it can be resolved randomly for same row)
 194          * then sync back immediately.
 195          **/
 196         try {
<span class="line-added"> 197             ResultSetMetaData rsmd = crsSync.getMetaData();</span>
 198             // check whether the index is in range
<span class="line-modified"> 199             if(index&lt;=0 || rsmd == null || index &gt; rsmd.getColumnCount() ) {</span>
 200                 throw new SQLException(resBundle.handleGetObject(&quot;syncrsimpl.indexval&quot;).toString()+ index);
 201             }
 202              // check whether index col is in conflict
 203             if(crsRes.getObject(index) == null) {
 204                 throw new SQLException(resBundle.handleGetObject(&quot;syncrsimpl.noconflict&quot;).toString());
 205             }
 206         } catch (SQLException sqle) {
 207             // modify method to throw for SQLException
 208             throw new SQLException(sqle.getMessage());
 209         }
 210         try {
 211              boolean bool = true;
 212              /** Check resolved value to be either of conflict
 213                * or in rowset else throw sql exception.
 214                * If we allow a value other than that in CachedRowSet or
 215                * datasource we will end up in looping the loop of exceptions.
 216               **/
 217 
 218              if( ((crsSync.getObject(index)).toString()).equals(obj.toString()) ||
 219                      ((crsRes.getObject(index)).toString()).equals(obj.toString()) ) {
</pre>
<hr />
<pre>
 382        try {
 383             crsRow.setKeyColumns(crsSync.getKeyColumns());
 384        } catch(SQLException sqle) {
 385 
 386        }
 387        return crsRow;
 388     }
 389 
 390 
 391 
 392     /**
 393      * Sets &lt;i&gt;obj&lt;/i&gt; as the value in column &lt;i&gt;columnName&lt;/i&gt; in the current row of the
 394      * {@code RowSet} object. This value is the resolved value that is to be
 395      * persisted in the data source.
 396      *
 397      * @param columnName a {@code String} object giving the name of the column
 398      *        into which to set the value to be persisted
 399      * @param obj an {@code Object} that is the value to be set in the data source
 400      */
 401     public void setResolvedValue(String columnName, Object obj) throws SQLException {
<span class="line-modified"> 402         // %%% Missing implementation!</span>
<span class="line-modified"> 403         throw new SQLException(&quot;Method not supported&quot;);</span>
 404     }
 405 
 406     /**
 407      * This function is package private,
 408      * i.e. cannot be accesses outside this package.
 409      * This is used to set the actual CachedRowSet
 410      * which is being synchronized to the database
 411      **/
 412    void setCachedRowSet(CachedRowSet crs) {
 413            crsSync = (CachedRowSetImpl)crs;
 414     }
 415 
 416     /**
 417      * This function is package private,
 418      * i.e. cannot be accesses outside this package.
 419      * This is used to set the CachedRowSet formed
 420      * with conflict values.
 421      **/
 422     void setCachedRowSetResolver(CachedRowSet crs){
 423          try {
</pre>
<hr />
<pre>
 492              bool = true;
 493              break;
 494            } //end if
 495 
 496       } //end while
 497 
 498         crsSync.setShowDeleted(false);
 499         return bool;
 500    } // end next() method
 501 
 502 
 503     /**
 504      * Moves the cursor to the previous conflict row in this {@code SyncResolver} object.
 505      *
 506      * @return {@code true} if the cursor is on a valid row; {@code false}
 507      *     if it is off the result set
 508      * @throws SQLException if a database access error occurs or the result set type
 509      *     is TYPE_FORWARD_ONLY
 510      */
 511    public boolean previousConflict() throws SQLException {
<span class="line-modified"> 512        return false;</span>
 513    }
 514 
 515     //-----------------------------------------------------------------------
 516     // Properties
 517     //-----------------------------------------------------------------------
 518 
 519     /**
 520      * Sets this {@code CachedRowSetImpl} object&#39;s command property
 521      * to the given {@code String} object and clears the parameters,
 522      * if any, that were set for the previous command.
 523      * &lt;P&gt;
 524      * The command property may not be needed
 525      * if the rowset is produced by a data source, such as a spreadsheet,
 526      * that does not support commands. Thus, this property is optional
 527      * and may be {@code null}.
 528      *
 529      * @param cmd a {@code String} object containing an SQL query
 530      *            that will be set as the command; may be {@code null}
 531      * @throws SQLException if an error occurs
 532      */
</pre>
</td>
</tr>
</table>
<center><a href="../CachedRowSetImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../package-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
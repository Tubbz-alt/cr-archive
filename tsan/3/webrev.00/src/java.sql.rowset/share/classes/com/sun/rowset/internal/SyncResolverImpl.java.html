<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.sql.rowset/share/classes/com/sun/rowset/internal/SyncResolverImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.rowset.internal;
  27 
  28 import java.sql.*;
  29 import javax.sql.*;
  30 import java.util.*;
  31 import java.math.BigDecimal;
  32 
  33 import javax.sql.rowset.*;
  34 import javax.sql.rowset.spi.*;
  35 
  36 import com.sun.rowset.*;
  37 import java.io.IOException;
  38 import java.io.ObjectInputStream;
  39 
  40 /**
  41  * There will be two sets of data which will be maintained by the rowset at the
  42  * time of synchronization. The {@code SyncProvider} will utilize the
  43  * {@code SyncResolver} to synchronize the changes back to database.
  44  */
  45 public class SyncResolverImpl extends CachedRowSetImpl implements SyncResolver {
  46     /**
  47      * This CachedRowSet object will encapsulate a rowset
  48      * which will be sync&#39;ed with the datasource but will
  49      * contain values in rows where there is conflict.
  50      * For rows other than conflict, it will *not* contain
  51      * any data. For rows containing conflict it will
  52      * return either of the three values set by SyncResolver.*_CONFLICT
  53      * from getStatus()
  54      */
  55     private CachedRowSetImpl crsRes;
  56 
  57     /**
  58      * This is the actual CachedRowSet object
  59      * which is being synchronized back to
  60      * datasource.
  61      */
  62     private CachedRowSetImpl crsSync;
  63 
  64     /**
  65      *  This ArrayList will contain the status of a row
  66      *  from the SyncResolver.* values else it will be null.
  67      */
  68     private ArrayList&lt;?&gt; stats;
  69 
  70     /**
  71      * The RowSetWriter associated with the original
  72      * CachedRowSet object which is being synchronized.
  73      */
  74     private CachedRowSetWriter crw;
  75 
  76     /**
  77      * Row number identifier
  78      */
  79     private int rowStatus;
  80 
  81     /**
  82      * This will contain the size of the {@code CachedRowSet} object
  83      */
  84     private int sz;
  85 
  86     /**
  87      * The {@code Connection} handle used to synchronize the changes
  88      * back to datasource. This is the same connection handle as was passed
  89      * to the CachedRowSet while fetching the data.
  90      */
  91     private transient Connection con;
  92 
  93     /**
  94      * The {@code CachedRowSet} object which will encapsulate
  95      * a row at any time. This will be built from CachedRowSet and
  96      * SyncResolver values. Synchronization takes place on a row by
  97      * row basis encapsulated as a CahedRowSet.
  98      */
  99     private CachedRowSet row;
 100 
 101     private JdbcRowSetResourceBundle resBundle;
 102 
 103     /**
 104      * Public constructor
 105      */
 106     public SyncResolverImpl() throws SQLException {
 107         try {
 108             crsSync = new CachedRowSetImpl();
 109             crsRes = new CachedRowSetImpl();
 110             crw = new CachedRowSetWriter();
 111             row = new CachedRowSetImpl();
 112             rowStatus = 1;
 113             try {
 114                 resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();
 115             } catch(IOException ioe) {
 116                 throw new RuntimeException(ioe);
 117             }
 118 
 119         } catch(SQLException sqle) {
 120         }
 121      }
 122 
 123 
 124     /**
 125      * Retrieves the conflict status of the current row of this
 126      * {@code SyncResolver}, which indicates the operation the {@code RowSet}
 127      * object was attempting when the conflict occurred.
 128      *
 129      * @return one of the following constants:
 130      *         {@code SyncResolver.UPDATE_ROW_CONFLICT},
 131      *         {@code SyncResolver.DELETE_ROW_CONFLICT}, or
 132      *         {@code SyncResolver.INSERT_ROW_CONFLICT}
 133      */
 134     public int getStatus() {
 135         return stats != null ? (Integer) stats.get(rowStatus - 1) :
 136                 SyncResolver.NO_ROW_CONFLICT;
 137     }
 138 
 139     /**
 140      * Retrieves the value in the designated column in the current row of this
 141      * {@code SyncResolver} object, which is the value that caused a conflict.
 142      *
 143      * @param index {@code int} designating the column in this row of this
 144      *        {@code SyncResolver} object from which to retrieve the value
 145      *        causing a conflict
 146      */
 147     public Object getConflictValue(int index) throws SQLException {
 148         try {
 149              return crsRes.getObject(index);
 150         } catch(SQLException sqle) {
 151             throw new SQLException(sqle.getMessage());
 152         } catch (Exception e ) {
 153             throw new SQLException(&quot;Problem obtaining conflicted value!&quot;, e);
 154         }
 155     }
 156 
 157     /**
 158      * Retrieves the value in the designated column in the current row of this
 159      * {@code SyncResolver} object, which is the value that caused a conflict.
 160      *
 161      * @param columnName a {@code String} object designating the column in this row of this
 162      *        {@code SyncResolver} object from which to retrieve the value
 163      *        causing a conflict
 164      */
 165     public Object getConflictValue(String columnName) throws SQLException {
 166         try {
 167              return crsRes.getObject(columnName);
 168         } catch(SQLException sqle) {
 169              throw new SQLException(sqle.getMessage());
 170         } catch (Exception e ) {
 171             throw new SQLException(&quot;Problem obtaining conflicted value!&quot;, e);
 172         }
 173     }
 174 
 175     /**
 176      * Sets &lt;i&gt;obj&lt;/i&gt; as the value in column &lt;i&gt;index&lt;/i&gt; in the current row of the
 177      * {@code RowSet} object. This value is the resolved value that is to be
 178      * persisted in the data source.
 179      *
 180      * @param index an {@code int} giving the number of the column into which to
 181      *        set the value to be persisted
 182      * @param obj an {@code Object} that is the value to be set in the data source
 183      */
 184     public void setResolvedValue(int index, Object obj) throws SQLException {
 185         // modify method to throw SQLException in spec
 186 
 187         /**
 188          * When a value is resolved properly make it to null
 189          * inside crsRes for that column.
 190          *
 191          * For more than one conflicts in the row,
 192          * check for the last resolved value of the current row
 193          * (Note: it can be resolved randomly for same row)
 194          * then sync back immediately.
 195          **/
 196         try {
 197             ResultSetMetaData rsmd = crsSync.getMetaData();
 198             // check whether the index is in range
 199             if(index&lt;=0 || rsmd == null || index &gt; rsmd.getColumnCount() ) {
 200                 throw new SQLException(resBundle.handleGetObject(&quot;syncrsimpl.indexval&quot;).toString()+ index);
 201             }
 202              // check whether index col is in conflict
 203             if(crsRes.getObject(index) == null) {
 204                 throw new SQLException(resBundle.handleGetObject(&quot;syncrsimpl.noconflict&quot;).toString());
 205             }
 206         } catch (SQLException sqle) {
 207             // modify method to throw for SQLException
 208             throw new SQLException(sqle.getMessage());
 209         }
 210         try {
 211              boolean bool = true;
 212              /** Check resolved value to be either of conflict
 213                * or in rowset else throw sql exception.
 214                * If we allow a value other than that in CachedRowSet or
 215                * datasource we will end up in looping the loop of exceptions.
 216               **/
 217 
 218              if( ((crsSync.getObject(index)).toString()).equals(obj.toString()) ||
 219                      ((crsRes.getObject(index)).toString()).equals(obj.toString()) ) {
 220 
 221                 /**
 222                  * Check whether this is the only conflict in the row.
 223                  * If yes, synchronize this row back
 224                  * which has been resolved, else wait
 225                  * for all conflicts of current row to be resolved
 226                  *
 227                  * Step 1: Update crsRes and make the index col as null
 228                  * i.e. resolved
 229                  * crsRes.updateObject(index, obj);
 230                  **/
 231                   crsRes.updateNull(index);
 232                   crsRes.updateRow();
 233 
 234                  /**
 235                   * Step 2: Change the value in the CachedRowSetImpl object
 236                   * crsSync.updateObject(index, obj);
 237                   * crsSync.updateRow();
 238                   **/
 239                  if(row.size() != 1) {
 240                     row = buildCachedRow();
 241                  }
 242 
 243                  row.updateObject(index, obj);
 244                  row.updateRow();
 245 
 246                  for(int j=1; j &lt; crsRes.getMetaData().getColumnCount(); j++) {
 247                      if(crsRes.getObject(j) != null) {
 248                         bool = false;
 249                         break;
 250                          // break out of loop and wait for other cols
 251                          // in same row to get resolved
 252                      } //end if
 253 
 254                   } //end for
 255 
 256                   if(bool) {
 257                      /**
 258                       * sync data back using CachedRowSetWriter
 259                       * construct the present row and pass it to the writer
 260                       * to write back to db.
 261                       **/
 262                      try {
 263                            /**
 264                             * Note : The use of CachedRowSetWriter to get *same* Connection handle.
 265                             * The CachedRowSetWriter uses the connection handle
 266                             * from the reader, Hence will use the same connection handle
 267                             * as of original CachedRowSetImpl
 268                             **/
 269 
 270                           writeData(row);
 271 
 272                           //crw.writeData( (RowSetInternal)crsRow);
 273                           //System.out.printlnt.println(&quot;12&quot;);
 274 
 275                      } catch(SyncProviderException spe) {
 276                          /**
 277                           * This will occur if db is not allowing
 278                           * even after resolving the conflicts
 279                           * due to some reasons.
 280                           * Also will prevent from going into a loop of SPE&#39;s
 281                           **/
 282                          throw new SQLException(resBundle.handleGetObject(&quot;syncrsimpl.syncnotpos&quot;).toString());
 283                      }
 284                   } //end if(bool)
 285 
 286              } else {
 287                  throw new SQLException(resBundle.handleGetObject(&quot;syncrsimpl.valtores&quot;).toString());
 288              } //end if (crs.getObject ...) block
 289 
 290 
 291         } catch(SQLException sqle) {
 292            throw new SQLException(sqle.getMessage());
 293         }
 294     }
 295 
 296     /**
 297      * This passes a CachedRowSet as a row to the CachedRowSetWriter
 298      * after the values have been resolved, back to the datasource.
 299      *
 300      * @param row a {@code CachedRowSet} object which will hold the
 301      *        values of a particular row after they have been resolved by
 302      *        the user to synchronize back to datasource.
 303      * @throws SQLException if synchronization does not happen properly
 304      *         maybe beacuse {@code Connection} has timed out.
 305      **/
 306      private void writeData(CachedRowSet row) throws SQLException {
 307         crw.updateResolvedConflictToDB(row, crw.getReader().connect((RowSetInternal)crsSync));
 308      }
 309 
 310     /**
 311      * This function builds a row  as a {@code CachedRowSet} object
 312      * which has been resolved and is ready to be synchrinized to the datasource
 313      *
 314      * @throws SQLException if there is problem in building
 315      *         the metadata of the row.
 316      **/
 317      private CachedRowSet buildCachedRow() throws SQLException {
 318        int iColCount;
 319        CachedRowSetImpl crsRow = new CachedRowSetImpl();
 320 
 321        RowSetMetaDataImpl rsmd = new RowSetMetaDataImpl();
 322        RowSetMetaDataImpl rsmdWrite = (RowSetMetaDataImpl)crsSync.getMetaData();
 323        RowSetMetaDataImpl rsmdRow = new RowSetMetaDataImpl();
 324 
 325        iColCount = rsmdWrite.getColumnCount();
 326        rsmdRow.setColumnCount(iColCount);
 327 
 328        for(int i =1;i&lt;=iColCount;i++) {
 329           rsmdRow.setColumnType(i,rsmdWrite.getColumnType(i));
 330           rsmdRow.setColumnName(i,rsmdWrite.getColumnName(i));
 331           rsmdRow.setNullable(i,ResultSetMetaData.columnNullableUnknown);
 332 
 333           try {
 334              rsmdRow.setCatalogName(i, rsmdWrite.getCatalogName(i));
 335              rsmdRow.setSchemaName(i, rsmdWrite.getSchemaName(i));
 336           } catch(SQLException e) {
 337                e.printStackTrace();
 338           }
 339         } //end for
 340 
 341        crsRow.setMetaData(rsmdRow);
 342 
 343        crsRow.moveToInsertRow();
 344 
 345        for(int col=1;col&lt;=crsSync.getMetaData().getColumnCount();col++) {
 346            crsRow.updateObject(col, crsSync.getObject(col));
 347        }
 348 
 349        crsRow.insertRow();
 350        crsRow.moveToCurrentRow();
 351 
 352        crsRow.absolute(1);
 353        crsRow.setOriginalRow();
 354 
 355       try {
 356           crsRow.setUrl(crsSync.getUrl());
 357       } catch(SQLException sqle) {
 358 
 359       }
 360 
 361       try {
 362           crsRow.setDataSourceName(crsSync.getCommand());
 363        } catch(SQLException sqle) {
 364 
 365        }
 366 
 367        try {
 368            if(crsSync.getTableName()!= null){
 369               crsRow.setTableName(crsSync.getTableName());
 370            }
 371         } catch(SQLException sqle) {
 372 
 373         }
 374 
 375        try {
 376             if(crsSync.getCommand() != null)
 377                 crsRow.setCommand(crsSync.getCommand());
 378        } catch(SQLException sqle) {
 379 
 380        }
 381 
 382        try {
 383             crsRow.setKeyColumns(crsSync.getKeyColumns());
 384        } catch(SQLException sqle) {
 385 
 386        }
 387        return crsRow;
 388     }
 389 
 390 
 391 
 392     /**
 393      * Sets &lt;i&gt;obj&lt;/i&gt; as the value in column &lt;i&gt;columnName&lt;/i&gt; in the current row of the
 394      * {@code RowSet} object. This value is the resolved value that is to be
 395      * persisted in the data source.
 396      *
 397      * @param columnName a {@code String} object giving the name of the column
 398      *        into which to set the value to be persisted
 399      * @param obj an {@code Object} that is the value to be set in the data source
 400      */
 401     public void setResolvedValue(String columnName, Object obj) throws SQLException {
 402         // %%% Missing implementation!
 403         throw new SQLException(&quot;Method not supported&quot;);
 404     }
 405 
 406     /**
 407      * This function is package private,
 408      * i.e. cannot be accesses outside this package.
 409      * This is used to set the actual CachedRowSet
 410      * which is being synchronized to the database
 411      **/
 412    void setCachedRowSet(CachedRowSet crs) {
 413            crsSync = (CachedRowSetImpl)crs;
 414     }
 415 
 416     /**
 417      * This function is package private,
 418      * i.e. cannot be accesses outside this package.
 419      * This is used to set the CachedRowSet formed
 420      * with conflict values.
 421      **/
 422     void setCachedRowSetResolver(CachedRowSet crs){
 423          try {
 424               crsRes = (CachedRowSetImpl)crs;
 425               crsRes.afterLast();
 426               sz = crsRes.size();
 427          } catch (SQLException sqle) {
 428             // do nothing
 429          }
 430     }
 431 
 432     /**
 433      * This function is package private,
 434      * i.e. cannot be accesses outside this package.
 435      * This is used to set the status of each row
 436      * to either of the values SyncResolver.*_CONFLICT
 437      **/
 438     @SuppressWarnings(&quot;rawtypes&quot;)
 439     void setStatus(ArrayList status){
 440              stats = status;
 441     }
 442 
 443     /**
 444      * This function is package private,
 445      * i.e. cannot be accesses outside this package.
 446      * This is used to set the handle to the writer object
 447      * which will write the resolved values back to datasource
 448      **/
 449     void setCachedRowSetWriter(CachedRowSetWriter CRWriter) {
 450          crw = CRWriter;
 451     }
 452 
 453     /**
 454      * Moves the cursor down one row from its current position. A {@code SyncResolver}
 455      * cursor is initially positioned before the first conflict row; the first call to the
 456      * method {@code nextConflict()} makes the first conflict row the current row;
 457      * the second call makes the second conflict row the current row, and so on.
 458      * &lt;p&gt;
 459      * If an input stream is open for the current row, a call to the method next will
 460      * implicitly close it. A {@code SyncResolver} object&#39;s warning chain is cleared
 461      * when a new row
 462      *
 463      * @return true if the new current row is valid; false if there are no more rows
 464      * @throws SQLException if a database access occurs
 465      *
 466      */
 467     public boolean nextConflict() throws SQLException {
 468         /**
 469           * The next() method will hop from
 470           * one conflict to another
 471           *
 472           * Internally do a crs.next() until
 473           * next conflict.
 474           **/
 475       boolean bool = false;
 476 
 477       crsSync.setShowDeleted(true);
 478       while(crsSync.next()) {
 479            crsRes.previous();
 480            rowStatus++;  //sz--;
 481 
 482           if((rowStatus-1) &gt;= stats.size()) {
 483              bool = false;
 484              break;
 485           }
 486 
 487           if(((Integer)stats.get(rowStatus-1)).intValue() == SyncResolver.NO_ROW_CONFLICT) {
 488               // do nothing
 489               // bool remains as false
 490              ;
 491            } else {
 492              bool = true;
 493              break;
 494            } //end if
 495 
 496       } //end while
 497 
 498         crsSync.setShowDeleted(false);
 499         return bool;
 500    } // end next() method
 501 
 502 
 503     /**
 504      * Moves the cursor to the previous conflict row in this {@code SyncResolver} object.
 505      *
 506      * @return {@code true} if the cursor is on a valid row; {@code false}
 507      *     if it is off the result set
 508      * @throws SQLException if a database access error occurs or the result set type
 509      *     is TYPE_FORWARD_ONLY
 510      */
 511    public boolean previousConflict() throws SQLException {
 512        return false;
 513    }
 514 
 515     //-----------------------------------------------------------------------
 516     // Properties
 517     //-----------------------------------------------------------------------
 518 
 519     /**
 520      * Sets this {@code CachedRowSetImpl} object&#39;s command property
 521      * to the given {@code String} object and clears the parameters,
 522      * if any, that were set for the previous command.
 523      * &lt;P&gt;
 524      * The command property may not be needed
 525      * if the rowset is produced by a data source, such as a spreadsheet,
 526      * that does not support commands. Thus, this property is optional
 527      * and may be {@code null}.
 528      *
 529      * @param cmd a {@code String} object containing an SQL query
 530      *            that will be set as the command; may be {@code null}
 531      * @throws SQLException if an error occurs
 532      */
 533     public void setCommand(String cmd) throws SQLException {
 534          throw new UnsupportedOperationException();
 535     }
 536 
 537 
 538     //---------------------------------------------------------------------
 539     // Reading and writing data
 540     //---------------------------------------------------------------------
 541 
 542     /**
 543      * Populates this {@code CachedRowSetImpl} object with data from
 544      * the given {@code ResultSet} object.  This
 545      * method is an alternative to the method {@code execute}
 546      * for filling the rowset with data.  The method {@code populate}
 547      * does not require that the properties needed by the method
 548      * {@code execute}, such as the {@code command} property,
 549      * be set. This is true because the method {@code populate}
 550      * is given the {@code ResultSet} object from
 551      * which to get data and thus does not need to use the properties
 552      * required for setting up a connection and executing this
 553      * {@code CachedRowSetImpl} object&#39;s command.
 554      * &lt;P&gt;
 555      * After populating this rowset with data, the method
 556      * {@code populate} sets the rowset&#39;s metadata and
 557      * then sends a {@code RowSetChangedEvent} object
 558      * to all registered listeners prior to returning.
 559      *
 560      * @param data the {@code ResultSet} object containing the data
 561      *             to be read into this {@code CachedRowSetImpl} object
 562      * @throws SQLException if an error occurs; or the max row setting is
 563      *          violated while populating the RowSet
 564      * @see #execute
 565      */
 566     public void populate(ResultSet data) throws SQLException {
 567          throw new UnsupportedOperationException();
 568     }
 569 
 570     /**
 571      * Populates this {@code CachedRowSetImpl} object with data,
 572      * using the given connection to produce the result set from
 573      * which data will be read.  A second form of this method,
 574      * which takes no arguments, uses the values from this rowset&#39;s
 575      * user, password, and either url or data source properties to
 576      * create a new database connection. The form of {@code execute}
 577      * that is given a connection ignores these properties.
 578      *
 579      * @param conn A standard JDBC {@code Connection} object that this
 580      * {@code CachedRowSet} object can pass to a synchronization provider
 581      * to establish a connection to the data source
 582      * @throws SQLException if an invalid {@code Connection} is supplied
 583      *           or an error occurs in establishing the connection to the
 584      *           data source
 585      * @see #populate
 586      * @see java.sql.Connection
 587      */
 588     public void execute(Connection conn) throws SQLException {
 589         throw new UnsupportedOperationException();
 590     }
 591 
 592     /**
 593      * Propagates all row update, insert, and delete changes to the
 594      * underlying data source backing this {@code CachedRowSetImpl}
 595      * object.
 596      * &lt;P&gt;
 597      * &lt;b&gt;Note&lt;/b&gt;In the reference implementation an optimistic concurrency implementation
 598      * is provided as a sample implementation of a the {@code SyncProvider}
 599      * abstract class.
 600      * &lt;P&gt;
 601      * This method fails if any of the updates cannot be propagated back
 602      * to the data source.  When it fails, the caller can assume that
 603      * none of the updates are reflected in the data source.
 604      * When an exception is thrown, the current row
 605      * is set to the first &quot;updated&quot; row that resulted in an exception
 606      * unless the row that caused the exception is a &quot;deleted&quot; row.
 607      * In that case, when deleted rows are not shown, which is usually true,
 608      * the current row is not affected.
 609      * &lt;P&gt;
 610      * If no {@code SyncProvider} is configured, the reference implementation
 611      * leverages the {@code RIOptimisticProvider} available which provides the
 612      * default and reference synchronization capabilities for disconnected
 613      * {@code RowSets}.
 614      *
 615      * @throws SQLException if the cursor is on the insert row or the underlying
 616      *          reference synchronization provider fails to commit the updates
 617      *          to the datasource
 618      * @throws SyncProviderException if an internal error occurs within the
 619      *          {@code SyncProvider} instance during either during the
 620      *          process or at any time when the {@code SyncProvider}
 621      *          instance touches the data source.
 622      * @see #acceptChanges(java.sql.Connection)
 623      * @see javax.sql.RowSetWriter
 624      * @see javax.sql.rowset.spi.SyncProvider
 625      */
 626     public void acceptChanges() throws SyncProviderException {
 627         throw new UnsupportedOperationException();
 628     }
 629 
 630     /**
 631      * Propagates all row update, insert, and delete changes to the
 632      * data source backing this {@code CachedRowSetImpl} object
 633      * using the given {@code Connection} object.
 634      * &lt;P&gt;
 635      * The reference implementation {@code RIOptimisticProvider}
 636      * modifies its synchronization to a write back function given
 637      * the updated connection
 638      * The reference implementation modifies its synchronization behaviour
 639      * via the {@code SyncProvider} to ensure the synchronization
 640      * occurs according to the updated JDBC {@code Connection}
 641      * properties.
 642      *
 643      * @param con a standard JDBC {@code Connection} object
 644      * @throws SQLException if the cursor is on the insert row or the underlying
 645      *                   synchronization provider fails to commit the updates
 646      *                   back to the data source
 647      * @see #acceptChanges
 648      * @see javax.sql.RowSetWriter
 649      * @see javax.sql.rowset.spi.SyncFactory
 650      * @see javax.sql.rowset.spi.SyncProvider
 651      */
 652     public void acceptChanges(Connection con) throws SyncProviderException{
 653      throw new UnsupportedOperationException();
 654     }
 655 
 656     /**
 657      * Restores this {@code CachedRowSetImpl} object to its original state,
 658      * that is, its state before the last set of changes.
 659      * &lt;P&gt;
 660      * Before returning, this method moves the cursor before the first row
 661      * and sends a {@code rowSetChanged} event to all registered
 662      * listeners.
 663      * @throws SQLException if an error is occurs rolling back the RowSet
 664      *           state to the definied original value.
 665      * @see javax.sql.RowSetListener#rowSetChanged
 666      */
 667     public void restoreOriginal() throws SQLException {
 668         throw new UnsupportedOperationException();
 669     }
 670 
 671     /**
 672      * Releases the current contents of this {@code CachedRowSetImpl}
 673      * object and sends a {@code rowSetChanged} event object to all
 674      * registered listeners.
 675      *
 676      * @throws SQLException if an error occurs flushing the contents of
 677      *           RowSet.
 678      * @see javax.sql.RowSetListener#rowSetChanged
 679      */
 680     public void release() throws SQLException {
 681         throw new UnsupportedOperationException();
 682     }
 683 
 684     /**
 685      * Cancels deletion of the current row and notifies listeners that
 686      * a row has changed.
 687      * &lt;P&gt;
 688      * Note:  This method can be ignored if deleted rows are not being shown,
 689      * which is the normal case.
 690      *
 691      * @throws SQLException if the cursor is not on a valid row
 692      */
 693     public void undoDelete() throws SQLException {
 694         throw new UnsupportedOperationException();
 695     }
 696 
 697     /**
 698      * Immediately removes the current row from this
 699      * {@code CachedRowSetImpl} object if the row has been inserted, and
 700      * also notifies listeners the a row has changed.  An exception is thrown
 701      * if the row is not a row that has been inserted or the cursor is before
 702      * the first row, after the last row, or on the insert row.
 703      * &lt;P&gt;
 704      * This operation cannot be undone.
 705      *
 706      * @throws SQLException if an error occurs,
 707      *                         the cursor is not on a valid row,
 708      *                         or the row has not been inserted
 709      */
 710     public void undoInsert() throws SQLException {
 711         throw new UnsupportedOperationException();
 712     }
 713 
 714     /**
 715      * Immediately reverses the last update operation if the
 716      * row has been modified. This method can be
 717      * called to reverse updates on a all columns until all updates in a row have
 718      * been rolled back to their originating state since the last synchronization
 719      * ({@code acceptChanges}) or population. This method may also be called
 720      * while performing updates to the insert row.
 721      * &lt;P&gt;
 722      * {@code undoUpdate} may be called at any time during the life-time of a
 723      * rowset, however after a synchronization has occurs this method has no
 724      * affect until further modification to the RowSet data occurs.
 725      *
 726      * @throws SQLException if cursor is before the first row, after the last
 727      *     row in rowset.
 728      * @see #undoDelete
 729      * @see #undoInsert
 730      * @see java.sql.ResultSet#cancelRowUpdates
 731      */
 732     public void undoUpdate() throws SQLException {
 733         throw new UnsupportedOperationException();
 734 
 735     }
 736 
 737     //--------------------------------------------------------------------
 738     // Views
 739     //--------------------------------------------------------------------
 740 
 741     /**
 742      * Returns a new {@code RowSet} object backed by the same data as
 743      * that of this {@code CachedRowSetImpl} object and sharing a set of cursors
 744      * with it. This allows cursors to interate over a shared set of rows, providing
 745      * multiple views of the underlying data.
 746      *
 747      * @return a {@code RowSet} object that is a copy of this {@code CachedRowSetImpl}
 748      * object and shares a set of cursors with it
 749      * @throws SQLException if an error occurs or cloning is
 750      *                         not supported
 751      * @see javax.sql.RowSetEvent
 752      * @see javax.sql.RowSetListener
 753      */
 754     public RowSet createShared() throws SQLException {
 755         throw new UnsupportedOperationException();
 756     }
 757 
 758     /**
 759      * Returns a new {@code RowSet} object containing by the same data
 760      * as this {@code CachedRowSetImpl} object.  This method
 761      * differs from the method {@code createCopy} in that it throws a
 762      * {@code CloneNotSupportedException} object instead of an
 763      * {@code SQLException} object, as the method {@code createShared}
 764      * does.  This {@code clone}
 765      * method is called internally by the method {@code createShared},
 766      * which catches the {@code CloneNotSupportedException} object
 767      * and in turn throws a new {@code SQLException} object.
 768      *
 769      * @return a copy of this {@code CachedRowSetImpl} object
 770      * @throws CloneNotSupportedException if an error occurs when
 771      * attempting to clone this {@code CachedRowSetImpl} object
 772      * @see #createShared
 773      */
 774     protected Object clone() throws CloneNotSupportedException  {
 775        throw new UnsupportedOperationException();
 776     }
 777 
 778     /**
 779      * Creates a {@code RowSet} object that is a deep copy of
 780      * this {@code CachedRowSetImpl} object&#39;s data, including
 781      * constraints.  Updates made
 782      * on a copy are not visible to the original rowset;
 783      * a copy of a rowset is completely independent from the original.
 784      * &lt;P&gt;
 785      * Making a copy saves the cost of creating an identical rowset
 786      * from first principles, which can be quite expensive.
 787      * For example, it can eliminate the need to query a
 788      * remote database server.
 789      * @return a new {@code CachedRowSet} object that is a deep copy
 790      *           of this {@code CachedRowSet} object and is
 791      *           completely independent from this {@code CachedRowSetImpl}
 792      *           object.
 793      * @throws SQLException if an error occurs in generating the copy of this
 794      *           of the {@code CachedRowSetImpl}
 795      * @see #createShared
 796      * @see javax.sql.RowSetEvent
 797      * @see javax.sql.RowSetListener
 798      */
 799     public CachedRowSet createCopy() throws SQLException {
 800         throw new UnsupportedOperationException();
 801     }
 802 
 803     /**
 804      * Creates a {@code RowSet} object that is a copy of
 805      * this {@code CachedRowSetImpl} object&#39;s table structure
 806      * and the constraints only.
 807      * There will be no data in the object being returned.
 808      * Updates made on a copy are not visible to the original rowset.
 809      * &lt;P&gt;
 810      * This helps in getting the underlying XML schema which can
 811      * be used as the basis for populating a {@code WebRowSet}.
 812      *
 813      * @return a new {@code CachedRowSet} object that is a copy
 814      * of this {@code CachedRowSetImpl} object&#39;s schema and
 815      * retains all the constraints on the original rowset but contains
 816      * no data
 817      * @throws SQLException if an error occurs in generating the copy
 818      * of the {@code CachedRowSet} object
 819      * @see #createShared
 820      * @see #createCopy
 821      * @see #createCopyNoConstraints
 822      * @see javax.sql.RowSetEvent
 823      * @see javax.sql.RowSetListener
 824      */
 825     public CachedRowSet createCopySchema() throws SQLException {
 826         throw new UnsupportedOperationException();
 827     }
 828 
 829     /**
 830      * Creates a {@code CachedRowSet} object that is a copy of
 831      * this {@code CachedRowSetImpl} object&#39;s data only.
 832      * All constraints set in this object will not be there
 833      * in the returning object.  Updates made
 834      * on a copy are not visible to the original rowset.
 835      *
 836      * @return a new {@code CachedRowSet} object that is a deep copy
 837      * of this {@code CachedRowSetImpl} object and is
 838      * completely independent from this {@code CachedRowSetImpl} object
 839      * @throws SQLException if an error occurs in generating the copy of the
 840      * of the {@code CachedRowSet}
 841      * @see #createShared
 842      * @see #createCopy
 843      * @see #createCopySchema
 844      * @see javax.sql.RowSetEvent
 845      * @see javax.sql.RowSetListener
 846      */
 847     public CachedRowSet createCopyNoConstraints() throws SQLException {
 848         throw new UnsupportedOperationException();
 849     }
 850 
 851     /**
 852      * Converts this {@code CachedRowSetImpl} object to a collection
 853      * of tables. The sample implementation utilitizes the {@code TreeMap}
 854      * collection type.
 855      * This class guarantees that the map will be in ascending key order,
 856      * sorted according to the natural order for the key&#39;s class.
 857      *
 858      * @return a {@code Collection} object consisting of tables,
 859      *         each of which is a copy of a row in this
 860      *         {@code CachedRowSetImpl} object
 861      * @throws SQLException if an error occurs in generating the collection
 862      * @see #toCollection(int)
 863      * @see #toCollection(String)
 864      * @see java.util.TreeMap
 865      */
 866     @SuppressWarnings(&quot;rawtypes&quot;)
 867     public Collection toCollection() throws SQLException {
 868        throw new UnsupportedOperationException();
 869     }
 870 
 871     /**
 872      * Returns the specified column of this {@code CachedRowSetImpl} object
 873      * as a {@code Collection} object.  This method makes a copy of the
 874      * column&#39;s data and utilitizes the {@code Vector} to establish the
 875      * collection. The {@code Vector} class implements a growable array
 876      * objects allowing the individual components to be accessed using an
 877      * an integer index similar to that of an array.
 878      *
 879      * @return a {@code Collection} object that contains the value(s)
 880      *         stored in the specified column of this
 881      *         {@code CachedRowSetImpl}
 882      *         object
 883      * @throws SQLException if an error occurs generated the collection; or
 884      *          an invalid column is provided.
 885      * @see #toCollection()
 886      * @see #toCollection(String)
 887      * @see java.util.Vector
 888      */
 889     @SuppressWarnings(&quot;rawtypes&quot;)
 890     public Collection toCollection(int column) throws SQLException {
 891        throw new UnsupportedOperationException();
 892     }
 893 
 894     /**
 895      * Returns the specified column of this {@code CachedRowSetImpl} object
 896      * as a {@code Collection} object.  This method makes a copy of the
 897      * column&#39;s data and utilitizes the {@code Vector} to establish the
 898      * collection. The {@code Vector} class implements a growable array
 899      * objects allowing the individual components to be accessed using an
 900      * an integer index similar to that of an array.
 901      *
 902      * @return a {@code Collection} object that contains the value(s)
 903      *         stored in the specified column of this
 904      *         {@code CachedRowSetImpl}
 905      *         object
 906      * @throws SQLException if an error occurs generated the collection; or
 907      *          an invalid column is provided.
 908      * @see #toCollection()
 909      * @see #toCollection(int)
 910      * @see java.util.Vector
 911      */
 912     @SuppressWarnings(&quot;rawtypes&quot;)
 913     public Collection toCollection(String column) throws SQLException {
 914         throw new UnsupportedOperationException();
 915     }
 916 
 917     //--------------------------------------------------------------------
 918     // Advanced features
 919     //--------------------------------------------------------------------
 920 
 921 
 922     /**
 923      * Returns the {@code SyncProvider} implementation being used
 924      * with this {@code CachedRowSetImpl} implementation rowset.
 925      *
 926      * @return the SyncProvider used by the rowset. If not provider was
 927      *          set when the rowset was instantiated, the reference
 928      *          implementation (default) provider is returned.
 929      * @throws SQLException if error occurs while return the
 930      *          {@code SyncProvider} instance.
 931      */
 932     public SyncProvider getSyncProvider() throws SQLException {
 933       throw new UnsupportedOperationException();
 934     }
 935 
 936     /**
 937      * Sets the active {@code SyncProvider} and attempts to load
 938      * load the new provider using the {@code SyncFactory} SPI.
 939      *
 940      * @throws SQLException if an error occurs while resetting the
 941      *          {@code SyncProvider}.
 942      */
 943     public void setSyncProvider(String providerStr) throws SQLException {
 944         throw new UnsupportedOperationException();
 945     }
 946 
 947 
 948     //-----------------
 949     // methods inherited from RowSet
 950     //-----------------
 951 
 952 
 953 
 954 
 955 
 956 
 957     //---------------------------------------------------------------------
 958     // Reading and writing data
 959     //---------------------------------------------------------------------
 960 
 961     /**
 962      * Populates this {@code CachedRowSetImpl} object with data.
 963      * This form of the method uses the rowset&#39;s user, password, and url or
 964      * data source name properties to create a database
 965      * connection.  If properties that are needed
 966      * have not been set, this method will throw an exception.
 967      * &lt;P&gt;
 968      * Another form of this method uses an existing JDBC {@code Connection}
 969      * object instead of creating a new one; therefore, it ignores the
 970      * properties used for establishing a new connection.
 971      * &lt;P&gt;
 972      * The query specified by the command property is executed to create a
 973      * {@code ResultSet} object from which to retrieve data.
 974      * The current contents of the rowset are discarded, and the
 975      * rowset&#39;s metadata is also (re)set.  If there are outstanding updates,
 976      * they are also ignored.
 977      * &lt;P&gt;
 978      * The method {@code execute} closes any database connections that it
 979      * creates.
 980      *
 981      * @throws SQLException if an error occurs or the
 982      *                         necessary properties have not been set
 983      */
 984     public void execute() throws SQLException {
 985         throw new UnsupportedOperationException();
 986     }
 987 
 988 
 989 
 990     //-----------------------------------
 991     // Methods inherited from ResultSet
 992     //-----------------------------------
 993 
 994     /**
 995      * Moves the cursor down one row from its current position and
 996      * returns {@code true} if the new cursor position is a
 997      * valid row.
 998      * The cursor for a new {@code ResultSet} object is initially
 999      * positioned before the first row. The first call to the method
1000      * {@code next} moves the cursor to the first row, making it
1001      * the current row; the second call makes the second row the
1002      * current row, and so on.
1003      *
1004      * &lt;P&gt;If an input stream from the previous row is open, it is
1005      * implicitly closed. The {@code ResultSet} object&#39;s warning
1006      * chain is cleared when a new row is read.
1007      *
1008      * @return {@code true} if the new current row is valid;
1009      *         {@code false} if there are no more rows
1010      * @throws SQLException if an error occurs or
1011      *            the cursor is not positioned in the rowset, before
1012      *            the first row, or after the last row
1013      */
1014     public boolean next() throws SQLException {
1015        throw new UnsupportedOperationException();
1016     }
1017 
1018     /**
1019      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the next
1020      * row and returns {@code true} if the cursor is still in the rowset;
1021      * returns {@code false} if the cursor has moved to the position after
1022      * the last row.
1023      * &lt;P&gt;
1024      * This method handles the cases where the cursor moves to a row that
1025      * has been deleted.
1026      * If this rowset shows deleted rows and the cursor moves to a row
1027      * that has been deleted, this method moves the cursor to the next
1028      * row until the cursor is on a row that has not been deleted.
1029      * &lt;P&gt;
1030      * The method {@code internalNext} is called by methods such as
1031      * {@code next}, {@code absolute}, and {@code relative},
1032      * and, as its name implies, is only called internally.
1033      * &lt;p&gt;
1034      * This is a implementation only method and is not required as a standard
1035      * implementation of the {@code CachedRowSet} interface.
1036      *
1037      * @return {@code true} if the cursor is on a valid row in this
1038      *         rowset; {@code false} if it is after the last row
1039      * @throws SQLException if an error occurs
1040      */
1041     protected boolean internalNext() throws SQLException {
1042         throw new UnsupportedOperationException();
1043     }
1044 
1045     /**
1046      * Closes this {@code CachedRowSetImpl} objecy and releases any resources
1047      * it was using.
1048      *
1049      * @throws SQLException if an error occurs when releasing any resources in use
1050      * by this {@code CachedRowSetImpl} object
1051      */
1052     public void close() throws SQLException {
1053         throw new UnsupportedOperationException();
1054     }
1055 
1056     /**
1057      * Reports whether the last column read was SQL {@code NULL}.
1058      * Note that you must first call the method {@code getXXX}
1059      * on a column to try to read its value and then call the method
1060      * {@code wasNull} to determine whether the value was
1061      * SQL {@code NULL}.
1062      *
1063      * @return {@code true} if the value in the last column read
1064      *         was SQL {@code NULL}; {@code false} otherwise
1065      * @throws SQLException if an error occurs
1066      */
1067     public boolean wasNull() throws SQLException {
1068         throw new UnsupportedOperationException();
1069     }
1070 
1071     /**
1072      * Returns the insert row or the current row of this
1073      * {@code CachedRowSetImpl} object.
1074      *
1075      * @return the {@code Row} object on which this {@code CachedRowSetImpl}
1076      * objects&#39;s cursor is positioned
1077      */
1078     protected BaseRow getCurrentRow() {
1079         throw new UnsupportedOperationException();
1080     }
1081 
1082     /**
1083      * Removes the row on which the cursor is positioned.
1084      * &lt;p&gt;
1085      * This is a implementation only method and is not required as a standard
1086      * implementation of the {@code CachedRowSet} interface.
1087      *
1088      * @throws SQLException if the cursor is positioned on the insert
1089      *            row
1090      */
1091     protected void removeCurrentRow() {
1092         throw new UnsupportedOperationException();
1093     }
1094 
1095 
1096     /**
1097      * Retrieves the value of the designated column in the current row
1098      * of this {@code CachedRowSetImpl} object as a
1099      * {@code String} object.
1100      *
1101      * @param columnIndex the first column is {@code 1}, the second
1102      *        is {@code 2}, and so on; must be {@code 1} or larger
1103      *        and equal to or less than the number of columns in the rowset
1104      * @return the column value; if the value is SQL {@code NULL}, the
1105      *         result is {@code null}
1106      * @throws SQLException if (1) the given column index is out of bounds,
1107      * (2) the cursor is not on one of this rowset&#39;s rows or its
1108      * insert row, or (3) the designated column does not store an
1109      * SQL {@code TINYINT, SMALLINT, INTEGER, BIGINT, REAL,
1110      * FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT,} &lt;b&gt;{@code CHAR, VARCHAR}&lt;/b&gt;
1111      * or {@code LONGVARCHAR} value. The bold SQL type designates the
1112      * recommended return type.
1113      */
1114     public String getString(int columnIndex) throws SQLException {
1115         throw new UnsupportedOperationException();
1116     }
1117 
1118     /**
1119      * Retrieves the value of the designated column in the current row
1120      * of this {@code CachedRowSetImpl} object as a
1121      * {@code boolean} value.
1122      *
1123      * @param columnIndex the first column is {@code 1}, the second
1124      *        is {@code 2}, and so on; must be {@code 1} or larger
1125      *        and equal to or less than the number of columns in the rowset
1126      * @return the column value as a {@code boolean} in the Java progamming language;
1127      *        if the value is SQL {@code NULL}, the result is {@code false}
1128      * @throws SQLException if (1) the given column index is out of bounds,
1129      *            (2) the cursor is not on one of this rowset&#39;s rows or its
1130      *            insert row, or (3) the designated column does not store an
1131      *            SQL {@code BOOLEAN} value
1132      * @see #getBoolean(String)
1133      */
1134     public boolean getBoolean(int columnIndex) throws SQLException {
1135         throw new UnsupportedOperationException();
1136     }
1137 
1138     /**
1139      * Retrieves the value of the designated column in the current row
1140      * of this {@code CachedRowSetImpl} object as a
1141      * {@code byte} value.
1142      *
1143      * @param columnIndex the first column is {@code 1}, the second
1144      *        is {@code 2}, and so on; must be {@code 1} or larger
1145      *        and equal to or less than the number of columns in the rowset
1146      * @return the column value as a {@code byte} in the Java programming
1147      * language; if the value is SQL {@code NULL}, the result is {@code 0}
1148      * @throws SQLException if (1) the given column index is out of bounds,
1149      *            (2) the cursor is not on one of this rowset&#39;s rows or its
1150      *            insert row, or (3) the designated column does not store an
1151      *            SQL &lt;b&gt;{@code TINYINT}&lt;/b&gt;, {@code SMALLINT, INTEGER,
1152      *            BIGINT, REAL, FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR,
1153      *            VARCHAR} or {@code LONGVARCHAR} value. The bold SQL type
1154      *            designates the recommended return type.
1155      * @see #getByte(String)
1156      */
1157     public byte getByte(int columnIndex) throws SQLException {
1158         throw new UnsupportedOperationException();
1159     }
1160 
1161     /**
1162      * Retrieves the value of the designated column in the current row
1163      * of this {@code CachedRowSetImpl} object as a
1164      * {@code short} value.
1165      *
1166      * @param columnIndex the first column is {@code 1}, the second
1167      *        is {@code 2}, and so on; must be {@code 1} or larger
1168      *        and equal to or less than the number of columns in the rowset
1169      * @return the column value; if the value is SQL {@code NULL}, the
1170      *         result is {@code 0}
1171      * @throws SQLException if (1) the given column index is out of bounds,
1172      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1173      *         insert row, or (3) the designated column does not store an
1174      *         SQL {@code TINYINT}, &lt;b&gt;{@code SMALLINT}&lt;/b&gt;,
1175      *         {@code INTEGER, BIGINT, REAL, FLOAT, DOUBLE,
1176      *         DECIMAL, NUMERIC, BIT, CHAR, VARCHAR}
1177      *         or {@code LONGVARCHAR} value. The bold SQL type
1178      *         designates the recommended return type.
1179      * @see #getShort(String)
1180      */
1181     public short getShort(int columnIndex) throws SQLException {
1182         throw new UnsupportedOperationException();
1183     }
1184 
1185     /**
1186      * Retrieves the value of the designated column in the current row
1187      * of this {@code CachedRowSetImpl} object as an
1188      * {@code int} value.
1189      *
1190      * @param columnIndex the first column is {@code 1}, the second
1191      *        is {@code 2}, and so on; must be {@code 1} or larger
1192      *        and equal to or less than the number of columns in the rowset
1193      * @return the column value; if the value is SQL {@code NULL}, the
1194      *         result is {@code 0}
1195      * @throws SQLException if (1) the given column index is out of bounds,
1196      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1197      *         insert row, or (3) the designated column does not store an
1198      *         SQL {@code TINYINT, SMALLINT,} &lt;b&gt;{@code INTEGER}&lt;/b&gt;,
1199      *         {@code BIGINT, REAL, FLOAT, DOUBLE, DECIMAL,
1200      *         NUMERIC, BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1201      *         The bold SQL type designates the
1202      *         recommended return type.
1203      */
1204     public int getInt(int columnIndex) throws SQLException {
1205         throw new UnsupportedOperationException();
1206     }
1207 
1208     /**
1209      * Retrieves the value of the designated column in the current row
1210      * of this {@code CachedRowSetImpl} object as a
1211      * {@code long} value.
1212      *
1213      * @param columnIndex the first column is {@code 1}, the second
1214      *        is {@code 2}, and so on; must be {@code 1} or larger
1215      *        and equal to or less than the number of columns in the rowset
1216      * @return the column value; if the value is SQL {@code NULL}, the
1217      *         result is {@code 0}
1218      * @throws SQLException if (1) the given column index is out of bounds,
1219      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1220      *         insert row, or (3) the designated column does not store an
1221      *         SQL {@code TINYINT, SMALLINT, INTEGER,}
1222      *         &lt;b&gt;{@code BIGINT}&lt;/b&gt;, {@code REAL, FLOAT, DOUBLE,
1223      *         DECIMAL, NUMERIC, BIT, CHAR, VARCHAR}
1224      *         or {@code LONGVARCHAR} value. The bold SQL type
1225      * designates the recommended return type.
1226      * @see #getLong(String)
1227      */
1228     public long getLong(int columnIndex) throws SQLException {
1229         throw new UnsupportedOperationException();
1230     }
1231 
1232     /**
1233      * Retrieves the value of the designated column in the current row
1234      * of this {@code CachedRowSetImpl} object as a
1235      * {@code float} value.
1236      *
1237      * @param columnIndex the first column is {@code 1}, the second
1238      *        is {@code 2}, and so on; must be {@code 1} or larger
1239      *        and equal to or less than the number of columns in the rowset
1240      * @return the column value; if the value is SQL {@code NULL}, the
1241      *         result is {@code 0}
1242      * @throws SQLException if (1) the given column index is out of bounds,
1243      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1244      *         insert row, or (3) the designated column does not store an
1245      *         SQL {@code TINYINT, SMALLINT, INTEGER, BIGINT,}
1246      *         &lt;b&gt;{@code REAL}&lt;/b&gt;, {@code FLOAT, DOUBLE, DECIMAL, NUMERIC,
1247      *         BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1248      *         The bold SQL type designates the recommended return type.
1249      * @see #getFloat(String)
1250      */
1251     public float getFloat(int columnIndex) throws SQLException {
1252         throw new UnsupportedOperationException();
1253     }
1254 
1255     /**
1256      * Retrieves the value of the designated column in the current row
1257      * of this {@code CachedRowSetImpl} object as a
1258      * {@code double} value.
1259      *
1260      * @param columnIndex the first column is {@code 1}, the second
1261      *        is {@code 2}, and so on; must be {@code 1} or larger
1262      *        and equal to or less than the number of columns in the rowset
1263      * @return the column value; if the value is SQL {@code NULL}, the
1264      *         result is {@code 0}
1265      * @throws SQLException if (1) the given column index is out of bounds,
1266      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1267      *         insert row, or (3) the designated column does not store an
1268      *         SQL {@code TINYINT, SMALLINT, INTEGER, BIGINT, REAL,}
1269      *         &lt;b&gt;{@code FLOAT, DOUBLE}&lt;/b&gt;,
1270      *         {@code DECIMAL, NUMERIC, BIT, CHAR, VARCHAR}
1271      *         or {@code LONGVARCHAR} value. The bold SQL type
1272      *         designates the recommended return type.
1273      * @see #getDouble(String)
1274      *
1275      */
1276     public double getDouble(int columnIndex) throws SQLException {
1277         throw new UnsupportedOperationException();
1278     }
1279 
1280     /**
1281      * Retrieves the value of the designated column in the current row
1282      * of this {@code CachedRowSetImpl} object as a
1283      * {@code java.math.BigDecimal} object.
1284      * &lt;P&gt;
1285      * This method is deprecated; use the version of {@code getBigDecimal}
1286      * that does not take a scale parameter and returns a value with full
1287      * precision.
1288      *
1289      * @param columnIndex the first column is {@code 1}, the second
1290      *        is {@code 2}, and so on; must be {@code 1} or larger
1291      *        and equal to or less than the number of columns in the rowset
1292      * @param scale the number of digits to the right of the decimal point in the
1293      *        value returned
1294      * @return the column value with the specified number of digits to the right
1295      *         of the decimal point; if the value is SQL {@code NULL}, the
1296      *         result is {@code null}
1297      * @throws SQLException if the given column index is out of bounds,
1298      *            the cursor is not on a valid row, or this method fails
1299      * @deprecated
1300      */
1301     @Deprecated
1302     public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
1303        throw new UnsupportedOperationException();
1304     }
1305 
1306     /**
1307      * Retrieves the value of the designated column in the current row
1308      * of this {@code CachedRowSetImpl} object as a
1309      * {@code byte} array value.
1310      *
1311      * @param columnIndex the first column is {@code 1}, the second
1312      *        is {@code 2}, and so on; must be {@code 1} or larger
1313      *        and equal to or less than the number of columns in the rowset
1314      * @return the column value as a {@code byte} array in the Java programming
1315      * language; if the value is SQL {@code NULL}, the
1316      * result is {@code null}
1317      *
1318      * @throws SQLException if (1) the given column index is out of bounds,
1319      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1320      *         insert row, or (3) the designated column does not store an
1321      *         SQL &lt;b&gt;{@code BINARY, VARBINARY}&lt;/b&gt; or
1322      *         {@code LONGVARBINARY} value.
1323      *         The bold SQL type designates the recommended return type.
1324      * @see #getBytes(String)
1325      */
1326     public byte[] getBytes(int columnIndex) throws SQLException {
1327         throw new UnsupportedOperationException();
1328     }
1329 
1330     /**
1331      * Retrieves the value of the designated column in the current row
1332      * of this {@code CachedRowSetImpl} object as a
1333      * {@code java.sql.Date} object.
1334      *
1335      * @param columnIndex the first column is {@code 1}, the second
1336      *        is {@code 2}, and so on; must be {@code 1} or larger
1337      *        and equal to or less than the number of columns in the rowset
1338      * @return the column value as a {@code java.sql.Data} object; if
1339      *        the value is SQL {@code NULL}, the
1340      *        result is {@code null}
1341      * @throws SQLException if the given column index is out of bounds,
1342      *         the cursor is not on a valid row, or this method fails
1343      */
1344     public java.sql.Date getDate(int columnIndex) throws SQLException {
1345         throw new UnsupportedOperationException();
1346     }
1347 
1348     /**
1349      * Retrieves the value of the designated column in the current row
1350      * of this {@code CachedRowSetImpl} object as a
1351      * {@code java.sql.Time} object.
1352      *
1353      * @param columnIndex the first column is {@code 1}, the second
1354      *        is {@code 2}, and so on; must be {@code 1} or larger
1355      *        and equal to or less than the number of columns in the rowset
1356      * @return the column value; if the value is SQL {@code NULL}, the
1357      *         result is {@code null}
1358      * @throws SQLException if the given column index is out of bounds,
1359      *         the cursor is not on a valid row, or this method fails
1360      */
1361     public java.sql.Time getTime(int columnIndex) throws SQLException {
1362         throw new UnsupportedOperationException();
1363     }
1364 
1365     /**
1366      * Retrieves the value of the designated column in the current row
1367      * of this {@code CachedRowSetImpl} object as a
1368      * {@code java.sql.Timestamp} object.
1369      *
1370      * @param columnIndex the first column is {@code 1}, the second
1371      *        is {@code 2}, and so on; must be {@code 1} or larger
1372      *        and equal to or less than the number of columns in the rowset
1373      * @return the column value; if the value is SQL {@code NULL}, the
1374      *         result is {@code null}
1375      * @throws SQLException if the given column index is out of bounds,
1376      *            the cursor is not on a valid row, or this method fails
1377      */
1378     public java.sql.Timestamp getTimestamp(int columnIndex) throws SQLException {
1379         throw new UnsupportedOperationException();
1380     }
1381 
1382     /**
1383      * Retrieves the value of the designated column in the current row of this
1384      * {@code CachedRowSetImpl} object as a {@code java.io.InputStream}
1385      * object.
1386      *
1387      * A column value can be retrieved as a stream of ASCII characters
1388      * and then read in chunks from the stream.  This method is particularly
1389      * suitable for retrieving large {@code LONGVARCHAR} values.  The JDBC
1390      * driver will do any necessary conversion from the database format into ASCII.
1391      *
1392      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
1393      * read prior to getting the value of any other column. The next
1394      * call to a get method implicitly closes the stream. . Also, a
1395      * stream may return {@code 0} for {@code CachedRowSetImpl.available()}
1396      * whether there is data available or not.
1397      *
1398      * @param columnIndex the first column is {@code 1}, the second
1399      *        is {@code 2}, and so on; must be {@code 1} or larger
1400      *        and equal to or less than the number of columns in this rowset
1401      * @return a Java input stream that delivers the database column value
1402      *         as a stream of one-byte ASCII characters.  If the value is SQL
1403      *         {@code NULL}, the result is {@code null}.
1404      * @throws SQLException if (1) the given column index is out of bounds,
1405      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1406      *         insert row, or (3) the designated column does not store an
1407      *         SQL {@code CHAR, VARCHAR}, &lt;b&gt;{@code LONGVARCHAR}&lt;/b&gt;,
1408      *         {@code BINARY, VARBINARY} or {@code LONGVARBINARY} value. The
1409      *         bold SQL type designates the recommended return types
1410      *         that this method is used to retrieve.
1411      * @see #getAsciiStream(String)
1412      */
1413     public java.io.InputStream getAsciiStream(int columnIndex) throws SQLException {
1414        throw new UnsupportedOperationException();
1415     }
1416 
1417     /**
1418      * A column value can be retrieved as a stream of Unicode characters
1419      * and then read in chunks from the stream.  This method is particularly
1420      * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
1421      * do any necessary conversion from the database format into Unicode.
1422      *
1423      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
1424      * read prior to getting the value of any other column. The next
1425      * call to a get method implicitly closes the stream. . Also, a
1426      * stream may return 0 for available() whether there is data
1427      * available or not.
1428      *
1429      * @param columnIndex the first column is {@code 1}, the second
1430      *        is {@code 2}, and so on; must be {@code 1} or larger
1431      *        and equal to or less than the number of columns in this rowset
1432      * @return a Java input stream that delivers the database column value
1433      * as a stream of two byte Unicode characters.  If the value is SQL NULL
1434      * then the result is null.
1435      * @throws SQLException if an error occurs
1436      * @deprecated
1437      */
1438     @Deprecated
1439     public java.io.InputStream getUnicodeStream(int columnIndex) throws SQLException {
1440        throw new UnsupportedOperationException();
1441     }
1442 
1443     /**
1444      * Retrieves the value of the designated column in the current row of this
1445      * {@code CachedRowSetImpl} object as a {@code java.io.InputStream}
1446      * object.
1447      * &lt;P&gt;
1448      * A column value can be retrieved as a stream of uninterpreted bytes
1449      * and then read in chunks from the stream.  This method is particularly
1450      * suitable for retrieving large {@code LONGVARBINARY} values.
1451      *
1452      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
1453      * read prior to getting the value of any other column. The next
1454      * call to a get method implicitly closes the stream. Also, a
1455      * stream may return {@code 0} for
1456      * {@code CachedRowSetImpl.available()} whether there is data
1457      * available or not.
1458      *
1459      * @param columnIndex the first column is {@code 1}, the second
1460      * is {@code 2}, and so on; must be {@code 1} or larger
1461      * and equal to or less than the number of columns in the rowset
1462      * @return a Java input stream that delivers the database column value
1463      * as a stream of uninterpreted bytes.  If the value is SQL {@code NULL}
1464      * then the result is {@code null}.
1465      * @throws SQLException if (1) the given column index is out of bounds,
1466      * (2) the cursor is not on one of this rowset&#39;s rows or its
1467      * insert row, or (3) the designated column does not store an
1468      * SQL {@code BINARY, VARBINARY} or &lt;b&gt;{@code LONGVARBINARY}&lt;/b&gt;.
1469      * The bold type indicates the SQL type that this method is recommened
1470      * to retrieve.
1471      * @see #getBinaryStream(String)
1472      */
1473     public java.io.InputStream getBinaryStream(int columnIndex) throws SQLException {
1474        throw new UnsupportedOperationException();
1475 
1476     }
1477 
1478 
1479     //======================================================================
1480     // Methods for accessing results by column name
1481     //======================================================================
1482 
1483     /**
1484      * Retrieves the value stored in the designated column
1485      * of the current row as a {@code String} object.
1486      *
1487      * @param columnName a {@code String} object giving the SQL name of
1488      *        a column in this {@code CachedRowSetImpl} object
1489      * @return the column value; if the value is SQL {@code NULL},
1490      *         the result is {@code null}
1491      * @throws SQLException if (1) the given column name is not the name of
1492      *         a column in this rowset, (2) the cursor is not on one of
1493      *         this rowset&#39;s rows or its insert row, or (3) the designated
1494      *         column does not store an SQL {@code TINYINT, SMALLINT, INTEGER,
1495      *         BIGINT, REAL, FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT,}
1496      *         &lt;b&gt;{@code CHAR, VARCHAR}&lt;/b&gt; or {@code LONGVARCHAR} value.
1497      *         The bold SQL type designates the recommended return type.
1498      */
1499     public String getString(String columnName) throws SQLException {
1500         throw new UnsupportedOperationException();
1501     }
1502 
1503     /**
1504      * Retrieves the value stored in the designated column
1505      * of the current row as a {@code boolean} value.
1506      *
1507      * @param columnName a {@code String} object giving the SQL name of
1508      *        a column in this {@code CachedRowSetImpl} object
1509      * @return the column value as a {@code boolean} in the Java programming
1510      *        language; if the value is SQL {@code NULL},
1511      *        the result is {@code false}
1512      * @throws SQLException if (1) the given column name is not the name of
1513      *         a column in this rowset, (2) the cursor is not on one of
1514      *         this rowset&#39;s rows or its insert row, or (3) the designated
1515      *         column does not store an SQL {@code BOOLEAN} value
1516      * @see #getBoolean(int)
1517      */
1518     public boolean getBoolean(String columnName) throws SQLException {
1519         throw new UnsupportedOperationException();
1520     }
1521 
1522     /**
1523      * Retrieves the value stored in the designated column
1524      * of the current row as a {@code byte} value.
1525      *
1526      * @param columnName a {@code String} object giving the SQL name of
1527      *        a column in this {@code CachedRowSetImpl} object
1528      * @return the column value as a {@code byte} in the Java programming
1529      * language; if the value is SQL {@code NULL}, the result is {@code 0}
1530      * @throws SQLException if (1) the given column name is not the name of
1531      *         a column in this rowset, (2) the cursor is not on one of
1532      *         this rowset&#39;s rows or its insert row, or (3) the designated
1533      *         column does not store an SQL &lt;b&gt;{@code TINYINT}&lt;/b&gt;,
1534      *         {@code SMALLINT, INTEGER, BIGINT, REAL, FLOAT, DOUBLE,
1535      *         DECIMAL, NUMERIC, BIT, CHAR, VARCHAR} or {@code LONGVARCHAR}
1536      *         value. The bold type designates the recommended return type.
1537      */
1538     public byte getByte(String columnName) throws SQLException {
1539         throw new UnsupportedOperationException();
1540     }
1541 
1542     /**
1543      * Retrieves the value stored in the designated column
1544      * of the current row as a {@code short} value.
1545      *
1546      * @param columnName a {@code String} object giving the SQL name of
1547      *        a column in this {@code CachedRowSetImpl} object
1548      * @return the column value; if the value is SQL {@code NULL},
1549      *         the result is {@code 0}
1550      * @throws SQLException if (1) the given column name is not the name of
1551      *         a column in this rowset, (2) the cursor is not on one of
1552      *         this rowset&#39;s rows or its insert row, or (3) the designated
1553      *         column does not store an SQL {@code TINYINT,}
1554      *         &lt;b&gt;{@code SMALLINT}&lt;/b&gt;, {@code INTEGER,
1555      *         BIGINT, REAL, FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR,
1556      *         VARCHAR} or {@code LONGVARCHAR} value. The bold SQL type
1557      *         designates the recommended return type.
1558      * @see #getShort(int)
1559      */
1560     public short getShort(String columnName) throws SQLException {
1561        throw new UnsupportedOperationException();
1562     }
1563 
1564     /**
1565      * Retrieves the value stored in the designated column
1566      * of the current row as an {@code int} value.
1567      *
1568      * @param columnName a {@code String} object giving the SQL name of
1569      *        a column in this {@code CachedRowSetImpl} object
1570      * @return the column value; if the value is SQL {@code NULL},
1571      *         the result is {@code 0}
1572      * @throws SQLException if (1) the given column name is not the name
1573      *         of a column in this rowset,
1574      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1575      *         insert row, or (3) the designated column does not store an
1576      *         SQL {@code TINYINT, SMALLINT,} &lt;b&gt;{@code INTEGER}&lt;/b&gt;,
1577      *         {@code BIGINT, REAL, FLOAT, DOUBLE, DECIMAL,
1578      *         NUMERIC, BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1579      *         The bold SQL type designates the
1580      *         recommended return type.
1581      */
1582     public int getInt(String columnName) throws SQLException {
1583         throw new UnsupportedOperationException();
1584     }
1585 
1586     /**
1587      * Retrieves the value stored in the designated column
1588      * of the current row as a {@code long} value.
1589      *
1590      * @param columnName a {@code String} object giving the SQL name of
1591      *        a column in this {@code CachedRowSetImpl} object
1592      * @return the column value; if the value is SQL {@code NULL},
1593      *         the result is {@code 0}
1594      * @throws SQLException if (1) the given column name is not the name of
1595      *         a column in this rowset, (2) the cursor is not on one of
1596      *         this rowset&#39;s rows or its insert row, or (3) the designated
1597      *         column does not store an SQL {@code TINYINT, SMALLINT, INTEGER,}
1598      *         &lt;b&gt;{@code BIGINT}&lt;/b&gt;, {@code REAL, FLOAT, DOUBLE, DECIMAL,
1599      *         NUMERIC, BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1600      *         The bold SQL type designates the recommended return type.
1601      * @see #getLong(int)
1602      */
1603     public long getLong(String columnName) throws SQLException {
1604         throw new UnsupportedOperationException();
1605     }
1606 
1607     /**
1608      * Retrieves the value stored in the designated column
1609      * of the current row as a {@code float} value.
1610      *
1611      * @param columnName a {@code String} object giving the SQL name of
1612      *        a column in this {@code CachedRowSetImpl} object
1613      * @return the column value; if the value is SQL {@code NULL},
1614      *         the result is {@code 0}
1615      * @throws SQLException if (1) the given column name is not the name of
1616      *         a column in this rowset, (2) the cursor is not on one of
1617      *         this rowset&#39;s rows or its insert row, or (3) the designated
1618      *         column does not store an SQL {@code TINYINT, SMALLINT, INTEGER,
1619      *         BIGINT,} &lt;b&gt;{@code REAL}&lt;/b&gt;, {@code FLOAT, DOUBLE, DECIMAL,
1620      *         NUMERIC, BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1621      *         The bold SQL type designates the recommended return type.
1622      * @see #getFloat(String)
1623      */
1624     public float getFloat(String columnName) throws SQLException {
1625        throw new UnsupportedOperationException();
1626     }
1627 
1628     /**
1629      * Retrieves the value stored in the designated column
1630      * of the current row of this {@code CachedRowSetImpl} object
1631      * as a {@code double} value.
1632      *
1633      * @param columnName a {@code String} object giving the SQL name of
1634      *        a column in this {@code CachedRowSetImpl} object
1635      * @return the column value; if the value is SQL {@code NULL},
1636      *         the result is {@code 0}
1637      * @throws SQLException if (1) the given column name is not the name of
1638      *         a column in this rowset, (2) the cursor is not on one of
1639      *         this rowset&#39;s rows or its insert row, or (3) the designated
1640      *         column does not store an SQL {@code TINYINT, SMALLINT, INTEGER,
1641      *         BIGINT, REAL,} &lt;b&gt;{@code FLOAT, DOUBLE}&lt;/b&gt;, {@code DECIMAL,
1642      *         NUMERIC, BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1643      *         The bold SQL type designates the recommended return types.
1644      * @see #getDouble(int)
1645      */
1646     public double getDouble(String columnName) throws SQLException {
1647         throw new UnsupportedOperationException();
1648     }
1649 
1650     /**
1651      * Retrieves the value stored in the designated column
1652      * of the current row as a {@code java.math.BigDecimal} object.
1653      *
1654      * @param columnName a {@code String} object giving the SQL name of
1655      *        a column in this {@code CachedRowSetImpl} object
1656      * @param scale the number of digits to the right of the decimal point
1657      * @return a java.math.BugDecimal object with &lt;i&gt;{@code scale}&lt;/i&gt;
1658      *         number of digits to the right of the decimal point.
1659      * @throws SQLException if (1) the given column name is not the name of
1660      *         a column in this rowset, (2) the cursor is not on one of
1661      *         this rowset&#39;s rows or its insert row, or (3) the designated
1662      *         column does not store an SQL {@code TINYINT, SMALLINT, INTEGER,
1663      *         BIGINT, REAL, FLOAT, DOUBLE,} &lt;b&gt;{@code DECIMAL, NUMERIC}&lt;/b&gt;,
1664      *         {@code BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1665      *         The bold SQL type designates the recommended return type
1666      *         that this method is used to retrieve.
1667      * @deprecated Use the {@code getBigDecimal(String columnName)}
1668      *             method instead
1669      */
1670     @Deprecated
1671     public BigDecimal getBigDecimal(String columnName, int scale) throws SQLException {
1672         throw new UnsupportedOperationException();
1673     }
1674 
1675     /**
1676      * Retrieves the value stored in the designated column
1677      * of the current row as a {@code byte} array.
1678      * The bytes represent the raw values returned by the driver.
1679      *
1680      * @param columnName a {@code String} object giving the SQL name of
1681      *        a column in this {@code CachedRowSetImpl} object
1682      * @return the column value as a {@code byte} array in the Java programming
1683      *         language; if the value is SQL {@code NULL}, the result is {@code null}
1684      * @throws SQLException if (1) the given column name is not the name of
1685      *         a column in this rowset, (2) the cursor is not on one of
1686      *         this rowset&#39;s rows or its insert row, or (3) the designated
1687      *         column does not store an SQL &lt;b&gt;{@code BINARY, VARBINARY}&lt;/b&gt;
1688      *         or {@code LONGVARBINARY} values.
1689      *         The bold SQL type designates the recommended return type.
1690      * @see #getBytes(int)
1691      */
1692     public byte[] getBytes(String columnName) throws SQLException {
1693         throw new UnsupportedOperationException();
1694     }
1695 
1696     /**
1697      * Retrieves the value stored in the designated column
1698      * of the current row as a {@code java.sql.Date} object.
1699      *
1700      * @param columnName a {@code String} object giving the SQL name of
1701      *        a column in this {@code CachedRowSetImpl} object
1702      * @return the column value; if the value is SQL {@code NULL},
1703      *         the result is {@code null}
1704      * @throws SQLException if (1) the given column name is not the name of
1705      *            a column in this rowset, (2) the cursor is not on one of
1706      *            this rowset&#39;s rows or its insert row, or (3) the designated
1707      *            column does not store an SQL {@code DATE} or
1708      *            {@code TIMESTAMP} value
1709      */
1710     public java.sql.Date getDate(String columnName) throws SQLException {
1711         throw new UnsupportedOperationException();
1712     }
1713 
1714     /**
1715      * Retrieves the value stored in the designated column
1716      * of the current row as a {@code java.sql.Time} object.
1717      *
1718      * @param columnName a {@code String} object giving the SQL name of
1719      *        a column in this {@code CachedRowSetImpl} object
1720      * @return the column value; if the value is SQL {@code NULL},
1721      *         the result is {@code null}
1722      * @throws SQLException if the given column name does not match one of
1723      *            this rowset&#39;s column names or the cursor is not on one of
1724      *            this rowset&#39;s rows or its insert row
1725      */
1726     public java.sql.Time getTime(String columnName) throws SQLException {
1727         throw new UnsupportedOperationException();
1728     }
1729 
1730     /**
1731      * Retrieves the value stored in the designated column
1732      * of the current row as a {@code java.sql.Timestamp} object.
1733      *
1734      * @param columnName a {@code String} object giving the SQL name of
1735      *        a column in this {@code CachedRowSetImpl} object
1736      * @return the column value; if the value is SQL {@code NULL},
1737      *         the result is {@code null}
1738      * @throws SQLException if the given column name does not match one of
1739      *            this rowset&#39;s column names or the cursor is not on one of
1740      *            this rowset&#39;s rows or its insert row
1741      */
1742     public java.sql.Timestamp getTimestamp(String columnName) throws SQLException {
1743         throw new UnsupportedOperationException();
1744     }
1745 
1746     /**
1747      * Retrieves the value of the designated column in the current row of this
1748      * {@code CachedRowSetImpl} object as a {@code java.io.InputStream}
1749      * object.
1750      *
1751      * A column value can be retrieved as a stream of ASCII characters
1752      * and then read in chunks from the stream. This method is particularly
1753      * suitable for retrieving large {@code LONGVARCHAR} values. The
1754      * {@code SyncProvider} will rely on the JDBC driver to do any necessary
1755      * conversion from the database format into ASCII format.
1756      *
1757      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
1758      * be read prior to getting the value of any other column. The
1759      * next call to a {@code getXXX} method implicitly closes the stream.
1760      *
1761      * @param columnName a {@code String} object giving the SQL name of
1762      *        a column in this {@code CachedRowSetImpl} object
1763      * @return a Java input stream that delivers the database column value
1764      *         as a stream of one-byte ASCII characters.  If the value is SQL
1765      *         {@code NULL}, the result is {@code null}.
1766      * @throws SQLException if (1) the given column name is not the name of
1767      *         a column in this rowset
1768      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1769      *         insert row, or (3) the designated column does not store an
1770      *         SQL {@code CHAR, VARCHAR}, &lt;b&gt;{@code LONGVARCHAR}&lt;/b&gt;,
1771      *         {@code BINARY, VARBINARY} or {@code LONGVARBINARY} value. The
1772      *         bold SQL type designates the recommended return types
1773      *         that this method is used to retrieve.
1774      * @see #getAsciiStream(int)
1775      */
1776     public java.io.InputStream getAsciiStream(String columnName) throws SQLException {
1777         throw new UnsupportedOperationException();
1778 
1779     }
1780 
1781     /**
1782      * A column value can be retrieved as a stream of Unicode characters
1783      * and then read in chunks from the stream.  This method is particularly
1784      * suitable for retrieving large {@code LONGVARCHAR} values.
1785      * The JDBC driver will do any necessary conversion from the database
1786      * format into Unicode.
1787      *
1788      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
1789      * be read prior to getting the value of any other column. The
1790      * next call to a {@code getXXX} method implicitly closes the stream.
1791      *
1792      * @param columnName a {@code String} object giving the SQL name of
1793      *        a column in this {@code CachedRowSetImpl} object
1794      * @return a Java input stream that delivers the database column value
1795      *         as a stream of two-byte Unicode characters.  If the value is
1796      *         SQL {@code NULL}, the result is {@code null}.
1797      * @throws SQLException if the given column name does not match one of
1798      *            this rowset&#39;s column names or the cursor is not on one of
1799      *            this rowset&#39;s rows or its insert row
1800      * @deprecated use the method {@code getCharacterStream} instead
1801      */
1802     @Deprecated
1803     public java.io.InputStream getUnicodeStream(String columnName) throws SQLException {
1804         throw new UnsupportedOperationException();
1805     }
1806 
1807     /**
1808      * Retrieves the value of the designated column in the current row of this
1809      * {@code CachedRowSetImpl} object as a {@code java.io.InputStream}
1810      * object.
1811      * &lt;P&gt;
1812      * A column value can be retrieved as a stream of uninterpreted bytes
1813      * and then read in chunks from the stream.  This method is particularly
1814      * suitable for retrieving large {@code LONGVARBINARY} values.
1815      *
1816      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
1817      * read prior to getting the value of any other column. The next
1818      * call to a get method implicitly closes the stream. Also, a
1819      * stream may return {@code 0} for {@code CachedRowSetImpl.available()}
1820      * whether there is data available or not.
1821      *
1822      * @param columnName a {@code String} object giving the SQL name of
1823      *        a column in this {@code CachedRowSetImpl} object
1824      * @return a Java input stream that delivers the database column value
1825      *         as a stream of uninterpreted bytes.  If the value is SQL
1826      *         {@code NULL}, the result is {@code null}.
1827      * @throws SQLException if (1) the given column name is unknown,
1828      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1829      *         insert row, or (3) the designated column does not store an
1830      *         SQL {@code BINARY, VARBINARY} or &lt;b&gt;{@code LONGVARBINARY}&lt;/b&gt;
1831      *         The bold type indicates the SQL type that this method is recommened
1832      *         to retrieve.
1833      * @see #getBinaryStream(int)
1834      *
1835      */
1836     public java.io.InputStream getBinaryStream(String columnName) throws SQLException {
1837         throw new UnsupportedOperationException();
1838     }
1839 
1840 
1841     //=====================================================================
1842     // Advanced features:
1843     //=====================================================================
1844 
1845     /**
1846      * The first warning reported by calls on this {@code CachedRowSetImpl}
1847      * object is returned. Subsequent {@code CachedRowSetImpl} warnings will
1848      * be chained to this {@code SQLWarning}.
1849      *
1850      * &lt;P&gt;The warning chain is automatically cleared each time a new
1851      * row is read.
1852      *
1853      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This warning chain only covers warnings caused
1854      * by {@code ResultSet} methods.  Any warning caused by statement
1855      * methods (such as reading OUT parameters) will be chained on the
1856      * {@code Statement} object.
1857      *
1858      * @return the first SQLWarning or null
1859      */
1860     public SQLWarning getWarnings() {
1861         throw new UnsupportedOperationException();
1862     }
1863 
1864     /**
1865      * Clears all the warnings reporeted for the {@code CachedRowSetImpl}
1866      * object. After a call to this method, the {@code getWarnings} method
1867      * returns {@code null} until a new warning is reported for this
1868      * {@code CachedRowSetImpl} object.
1869      */
1870     public void clearWarnings() {
1871        throw new UnsupportedOperationException();
1872     }
1873 
1874     /**
1875      * Retrieves the name of the SQL cursor used by this
1876      * {@code CachedRowSetImpl} object.
1877      *
1878      * &lt;P&gt;In SQL, a result table is retrieved through a cursor that is
1879      * named. The current row of a {@code ResultSet} can be updated or deleted
1880      * using a positioned update/delete statement that references the
1881      * cursor name. To ensure that the cursor has the proper isolation
1882      * level to support an update operation, the cursor&#39;s {@code SELECT}
1883      * statement should be of the form {@code select for update}.
1884      * If the {@code for update} clause
1885      * is omitted, positioned updates may fail.
1886      *
1887      * &lt;P&gt;JDBC supports this SQL feature by providing the name of the
1888      * SQL cursor used by a {@code ResultSet} object. The current row
1889      * of a result set is also the current row of this SQL cursor.
1890      *
1891      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; If positioned updates are not supported, an
1892      * {@code SQLException} is thrown.
1893      *
1894      * @return the SQL cursor name for this {@code CachedRowSetImpl} object&#39;s
1895      *         cursor
1896      * @throws SQLException if an error occurs
1897      */
1898     public String getCursorName() throws SQLException {
1899         throw new UnsupportedOperationException();
1900     }
1901 
1902     /**
1903      * Retrieves a {@code ResultSetMetaData} object instance that
1904      * contains information about the {@code CachedRowSet} object.
1905      * However, applications should cast the returned object to a
1906      * {@code RowSetMetaData} interface implementation. In the
1907      * reference implementation, this cast can be done on the
1908      * {@code RowSetMetaDataImpl} class.
1909      * &lt;P&gt;
1910      * For example:
1911      * &lt;pre&gt;
1912      * CachedRowSet crs = new CachedRowSetImpl();
1913      * RowSetMetaDataImpl metaData =
1914      *     (RowSetMetaDataImpl)crs.getMetaData();
1915      * // Set the number of columns in the RowSet object for
1916      * // which this RowSetMetaDataImpl object was created to the
1917      * // given number.
1918      * metaData.setColumnCount(3);
1919      * crs.setMetaData(metaData);
1920      * &lt;/pre&gt;
1921      *
1922      * @return the {@code ResultSetMetaData} object that describes this
1923      *         {@code CachedRowSetImpl} object&#39;s columns
1924      * @throws SQLException if an error occurs in generating the RowSet
1925      * meta data; or if the {@code CachedRowSetImpl} is empty.
1926      * @see javax.sql.RowSetMetaData
1927      */
1928     public ResultSetMetaData getMetaData() throws SQLException {
1929         throw new UnsupportedOperationException();
1930     }
1931 
1932 
1933     /**
1934      * Retrieves the value of the designated column in the current row
1935      * of this {@code CachedRowSetImpl} object as an
1936      * {@code Object} value.
1937      * &lt;P&gt;
1938      * The type of the {@code Object} will be the default
1939      * Java object type corresponding to the column&#39;s SQL type,
1940      * following the mapping for built-in types specified in the JDBC 3.0
1941      * specification.
1942      * &lt;P&gt;
1943      * This method may also be used to read datatabase-specific
1944      * abstract data types.
1945      * &lt;P&gt;
1946      * This implementation of the method {@code getObject} extends its
1947      * behavior so that it gets the attributes of an SQL structured type
1948      * as an array of {@code Object} values.  This method also custom
1949      * maps SQL user-defined types to classes in the Java programming language.
1950      * When the specified column contains
1951      * a structured or distinct value, the behavior of this method is as
1952      * if it were a call to the method {@code getObject(columnIndex,
1953      * this.getStatement().getConnection().getTypeMap())}.
1954      *
1955      * @param columnIndex the first column is {@code 1}, the second
1956      *        is {@code 2}, and so on; must be {@code 1} or larger
1957      *        and equal to or less than the number of columns in the rowset
1958      * @return a {@code java.lang.Object} holding the column value;
1959      *         if the value is SQL {@code NULL}, the result is {@code null}
1960      * @throws SQLException if the given column index is out of bounds,
1961      *            the cursor is not on a valid row, or there is a problem getting
1962      *            the {@code Class} object for a custom mapping
1963      * @see #getObject(String)
1964      */
1965     public Object getObject(int columnIndex) throws SQLException {
1966         throw new UnsupportedOperationException();
1967     }
1968 
1969     /**
1970      * Retrieves the value of the designated column in the current row
1971      * of this {@code CachedRowSetImpl} object as an
1972      * {@code Object} value.
1973      * &lt;P&gt;
1974      * The type of the {@code Object} will be the default
1975      * Java object type corresponding to the column&#39;s SQL type,
1976      * following the mapping for built-in types specified in the JDBC 3.0
1977      * specification.
1978      * &lt;P&gt;
1979      * This method may also be used to read datatabase-specific
1980      * abstract data types.
1981      * &lt;P&gt;
1982      * This implementation of the method {@code getObject} extends its
1983      * behavior so that it gets the attributes of an SQL structured type
1984      * as an array of {@code Object} values.  This method also custom
1985      * maps SQL user-defined types to classes
1986      * in the Java programming language. When the specified column contains
1987      * a structured or distinct value, the behavior of this method is as
1988      * if it were a call to the method {@code getObject(columnIndex,
1989      * this.getStatement().getConnection().getTypeMap())}.
1990      *
1991      * @param columnName a {@code String} object that must match the
1992      *        SQL name of a column in this rowset, ignoring case
1993      * @return a {@code java.lang.Object} holding the column value;
1994      *         if the value is SQL {@code NULL}, the result is {@code null}
1995      * @throws SQLException if (1) the given column name does not match one of
1996      *            this rowset&#39;s column names, (2) the cursor is not
1997      *            on a valid row, or (3) there is a problem getting
1998      *            the {@code Class} object for a custom mapping
1999      * @see #getObject(int)
2000      */
2001     public Object getObject(String columnName) throws SQLException {
2002        throw new UnsupportedOperationException();
2003     }
2004 
2005     //----------------------------------------------------------------
2006 
2007     /**
2008      * Maps the given column name for one of this {@code CachedRowSetImpl}
2009      * object&#39;s columns to its column number.
2010      *
2011      * @param columnName a {@code String} object that must match the
2012      *        SQL name of a column in this rowset, ignoring case
2013      * @return the column index of the given column name
2014      * @throws SQLException if the given column name does not match one
2015      *            of this rowset&#39;s column names
2016      */
2017     public int findColumn(String columnName) throws SQLException {
2018        throw new UnsupportedOperationException();
2019     }
2020 
2021     //--------------------------JDBC 2.0-----------------------------------
2022 
2023     //---------------------------------------------------------------------
2024     // Getter&#39;s and Setter&#39;s
2025     //---------------------------------------------------------------------
2026 
2027     /**
2028      * Retrieves the value stored in the designated column
2029      * of the current row as a {@code java.io.Reader} object.
2030      *
2031      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
2032      * be read prior to getting the value of any other column. The
2033      * next call to a {@code getXXX} method implicitly closes the stream.
2034      *
2035      * @param columnIndex the first column is {@code 1}, the second
2036      *        is {@code 2}, and so on; must be {@code 1} or larger
2037      *        and equal to or less than the number of columns in the rowset
2038      * @return a Java character stream that delivers the database column value
2039      * as a stream of two-byte unicode characters in a
2040      * {@code java.io.Reader} object.  If the value is
2041      * SQL {@code NULL}, the result is {@code null}.
2042      * @throws SQLException if (1) the given column index is out of bounds,
2043      *         (2) the cursor is not on one of this rowset&#39;s rows or its
2044      *         insert row, or (3) the designated column does not store an
2045      *         SQL {@code CHAR, VARCHAR,} &lt;b&gt;{@code LONGVARCHAR}&lt;/b&gt;,
2046      *         {@code BINARY, VARBINARY} or {@code LONGVARBINARY} value.
2047      *         The bold SQL type designates the recommended return type.
2048      * @see #getCharacterStream(String)
2049      */
2050     public java.io.Reader getCharacterStream(int columnIndex) throws SQLException{
2051         throw new UnsupportedOperationException();
2052     }
2053 
2054     /**
2055      * Retrieves the value stored in the designated column
2056      * of the current row as a {@code java.io.Reader} object.
2057      *
2058      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
2059      * be read prior to getting the value of any other column. The
2060      * next call to a {@code getXXX} method implicitly closes the stream.
2061      *
2062      * @param columnName a {@code String} object giving the SQL name of
2063      *        a column in this {@code CachedRowSetImpl} object
2064      * @return a Java input stream that delivers the database column value
2065      *         as a stream of two-byte Unicode characters.  If the value is
2066      *         SQL {@code NULL}, the result is {@code null}.
2067      * @throws SQLException if (1) the given column name is not the name of
2068      *         a column in this rowset, (2) the cursor is not on one of
2069      *         this rowset&#39;s rows or its insert row, or (3) the designated
2070      *         column does not store an SQL {@code CHAR, VARCHAR,}
2071      *         &lt;b&gt;{@code LONGVARCHAR}&lt;/b&gt;,
2072      *         {@code BINARY, VARYBINARY} or {@code LONGVARBINARY} value.
2073      *         The bold SQL type designates the recommended return type.
2074      */
2075     public java.io.Reader getCharacterStream(String columnName) throws SQLException {
2076         throw new UnsupportedOperationException();
2077     }
2078 
2079     /**
2080      * Retrieves the value of the designated column in the current row
2081      * of this {@code CachedRowSetImpl} object as a
2082      * {@code java.math.BigDecimal} object.
2083      *
2084      * @param columnIndex the first column is {@code 1}, the second
2085      *        is {@code 2}, and so on; must be {@code 1} or larger
2086      *        and equal to or less than the number of columns in the rowset
2087      * @return a {@code java.math.BigDecimal} value with full precision;
2088      *         if the value is SQL {@code NULL}, the result is {@code null}
2089      * @throws SQLException if (1) the given column index is out of bounds,
2090      *         (2) the cursor is not on one of this rowset&#39;s rows or its
2091      *         insert row, or (3) the designated column does not store an
2092      *         SQL {@code TINYINT, SMALLINT, INTEGER, BIGINT, REAL,
2093      *         FLOAT, DOUBLE,} &lt;b&gt;{@code DECIMAL, NUMERIC}&lt;/b&gt;,
2094      *         {@code BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
2095      *         The bold SQL type designates the
2096      *         recommended return types that this method is used to retrieve.
2097      * @see #getBigDecimal(String)
2098      */
2099     public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
2100         throw new UnsupportedOperationException();
2101     }
2102 
2103     /**
2104      * Retrieves the value of the designated column in the current row
2105      * of this {@code CachedRowSetImpl} object as a
2106      * {@code java.math.BigDecimal} object.
2107      *
2108      * @param columnName a {@code String} object that must match the
2109      *        SQL name of a column in this rowset, ignoring case
2110      * @return a {@code java.math.BigDecimal} value with full precision;
2111      *         if the value is SQL {@code NULL}, the result is {@code null}
2112      * @throws SQLException if (1) the given column name is not the name of
2113      *         a column in this rowset, (2) the cursor is not on one of
2114      *         this rowset&#39;s rows or its insert row, or (3) the designated
2115      *         column does not store an SQL {@code TINYINT, SMALLINT, INTEGER,
2116      *         BIGINT, REAL, FLOAT, DOUBLE,} &lt;b&gt;{@code DECIMAL, NUMERIC}&lt;/b&gt;,
2117      *         {@code BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
2118      *         The bold SQL type designates the recommended return type
2119      *         that this method is used to retrieve.
2120      * @see #getBigDecimal(int)
2121      */
2122     public BigDecimal getBigDecimal(String columnName) throws SQLException {
2123         throw new UnsupportedOperationException();
2124     }
2125 
2126     //---------------------------------------------------------------------
2127     // Traversal/Positioning
2128     //---------------------------------------------------------------------
2129 
2130     /**
2131      * Returns the number of rows in this {@code CachedRowSetImpl} object.
2132      *
2133      * @return number of rows in the rowset
2134      */
2135     public int size() {
2136         throw new UnsupportedOperationException();
2137     }
2138 
2139     /**
2140      * Indicates whether the cursor is before the first row in this
2141      * {@code CachedRowSetImpl} object.
2142      *
2143      * @return {@code true} if the cursor is before the first row;
2144      *         {@code false} otherwise or if the rowset contains no rows
2145      * @throws SQLException if an error occurs
2146      */
2147     public boolean isBeforeFirst() throws SQLException {
2148         throw new UnsupportedOperationException();
2149     }
2150 
2151     /**
2152      * Indicates whether the cursor is after the last row in this
2153      * {@code CachedRowSetImpl} object.
2154      *
2155      * @return {@code true} if the cursor is after the last row;
2156      *         {@code false} otherwise or if the rowset contains no rows
2157      * @throws SQLException if an error occurs
2158      */
2159     public boolean isAfterLast() throws SQLException {
2160         throw new UnsupportedOperationException();
2161     }
2162 
2163     /**
2164      * Indicates whether the cursor is on the first row in this
2165      * {@code CachedRowSetImpl} object.
2166      *
2167      * @return {@code true} if the cursor is on the first row;
2168      *         {@code false} otherwise or if the rowset contains no rows
2169      * @throws SQLException if an error occurs
2170      */
2171     public boolean isFirst() throws SQLException {
2172         throw new UnsupportedOperationException();
2173     }
2174 
2175     /**
2176      * Indicates whether the cursor is on the last row in this
2177      * {@code CachedRowSetImpl} object.
2178      * &lt;P&gt;
2179      * Note: Calling the method {@code isLast} may be expensive
2180      * because the JDBC driver might need to fetch ahead one row in order
2181      * to determine whether the current row is the last row in this rowset.
2182      *
2183      * @return {@code true} if the cursor is on the last row;
2184      *         {@code false} otherwise or if this rowset contains no rows
2185      * @throws SQLException if an error occurs
2186      */
2187     public boolean isLast() throws SQLException {
2188         throw new UnsupportedOperationException();
2189     }
2190 
2191     /**
2192      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the front of
2193      * the rowset, just before the first row. This method has no effect if
2194      * this rowset contains no rows.
2195      *
2196      * @throws SQLException if an error occurs or the type of this rowset
2197      *            is {@code ResultSet.TYPE_FORWARD_ONLY}
2198      */
2199     public void beforeFirst() throws SQLException {
2200         throw new UnsupportedOperationException();
2201     }
2202 
2203     /**
2204      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the end of
2205      * the rowset, just after the last row. This method has no effect if
2206      * this rowset contains no rows.
2207      *
2208      * @throws SQLException if an error occurs
2209      */
2210     public void afterLast() throws SQLException {
2211         throw new UnsupportedOperationException();
2212     }
2213 
2214     /**
2215      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the first row
2216      * and returns {@code true} if the operation was successful.  This
2217      * method also notifies registered listeners that the cursor has moved.
2218      *
2219      * @return {@code true} if the cursor is on a valid row;
2220      *         {@code false} otherwise or if there are no rows in this
2221      *         {@code CachedRowSetImpl} object
2222      * @throws SQLException if the type of this rowset
2223      *            is {@code ResultSet.TYPE_FORWARD_ONLY}
2224      */
2225     public boolean first() throws SQLException {
2226         throw new UnsupportedOperationException();
2227     }
2228 
2229     /**
2230      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the first
2231      * row and returns {@code true} if the operation is successful.
2232      * &lt;P&gt;
2233      * This method is called internally by the methods {@code first},
2234      * {@code isFirst}, and {@code absolute}.
2235      * It in turn calls the method {@code internalNext} in order to
2236      * handle the case where the first row is a deleted row that is not visible.
2237      * &lt;p&gt;
2238      * This is a implementation only method and is not required as a standard
2239      * implementation of the {@code CachedRowSet} interface.
2240      *
2241      * @return {@code true} if the cursor moved to the first row;
2242      *         {@code false} otherwise
2243      * @throws SQLException if an error occurs
2244      */
2245     protected boolean internalFirst() throws SQLException {
2246         throw new UnsupportedOperationException();
2247     }
2248 
2249     /**
2250      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the last row
2251      * and returns {@code true} if the operation was successful.  This
2252      * method also notifies registered listeners that the cursor has moved.
2253      *
2254      * @return {@code true} if the cursor is on a valid row;
2255      *         {@code false} otherwise or if there are no rows in this
2256      *         {@code CachedRowSetImpl} object
2257      * @throws SQLException if the type of this rowset
2258      *            is {@code ResultSet.TYPE_FORWARD_ONLY}
2259      */
2260     public boolean last() throws SQLException {
2261         throw new UnsupportedOperationException();
2262     }
2263 
2264     /**
2265      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the last
2266      * row and returns {@code true} if the operation is successful.
2267      * &lt;P&gt;
2268      * This method is called internally by the method {@code last}
2269      * when rows have been deleted and the deletions are not visible.
2270      * The method {@code internalLast} handles the case where the
2271      * last row is a deleted row that is not visible by in turn calling
2272      * the method {@code internalPrevious}.
2273      * &lt;p&gt;
2274      * This is a implementation only method and is not required as a standard
2275      * implementation of the {@code CachedRowSet} interface.
2276      *
2277      * @return {@code true} if the cursor moved to the last row;
2278      *         {@code false} otherwise
2279      * @throws SQLException if an error occurs
2280      */
2281     protected boolean internalLast() throws SQLException {
2282         throw new UnsupportedOperationException();
2283     }
2284 
2285     /**
2286      * Returns the number of the current row in this {@code CachedRowSetImpl}
2287      * object. The first row is number 1, the second number 2, and so on.
2288      *
2289      * @return the number of the current row;  {@code 0} if there is no
2290      *         current row
2291      * @throws SQLException if an error occurs; or if the {@code CacheRowSetImpl}
2292      *         is empty
2293      */
2294     public int getRow() throws SQLException {
2295         return crsSync.getRow();
2296     }
2297 
2298     /**
2299      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the row number
2300      * specified.
2301      *
2302      * &lt;p&gt;If the number is positive, the cursor moves to an absolute row with
2303      * respect to the beginning of the rowset.  The first row is row 1, the second
2304      * is row 2, and so on.  For example, the following command, in which
2305      * {@code crs} is a {@code CachedRowSetImpl} object, moves the cursor
2306      * to the fourth row, starting from the beginning of the rowset.
2307      * &lt;PRE&gt;{@code
2308      *
2309      *    crs.absolute(4);
2310      *
2311      * }&lt;/PRE&gt;
2312      * &lt;P&gt;
2313      * If the number is negative, the cursor moves to an absolute row position
2314      * with respect to the end of the rowset.  For example, calling
2315      * {@code absolute(-1)} positions the cursor on the last row,
2316      * {@code absolute(-2)} moves it on the next-to-last row, and so on.
2317      * If the {@code CachedRowSetImpl} object {@code crs} has five rows,
2318      * the following command moves the cursor to the fourth-to-last row, which
2319      * in the case of a  rowset with five rows, is also the second row, counting
2320      * from the beginning.
2321      * &lt;PRE&gt;{@code
2322      *
2323      *    crs.absolute(-4);
2324      *
2325      * }&lt;/PRE&gt;
2326      *
2327      * If the number specified is larger than the number of rows, the cursor
2328      * will move to the position after the last row. If the number specified
2329      * would move the cursor one or more rows before the first row, the cursor
2330      * moves to the position before the first row.
2331      * &lt;P&gt;
2332      * Note: Calling {@code absolute(1)} is the same as calling the
2333      * method {@code first()}.  Calling {@code absolute(-1)} is the
2334      * same as calling {@code last()}.
2335      *
2336      * @param row a positive number to indicate the row, starting row numbering from
2337      *        the first row, which is {@code 1}; a negative number to indicate
2338      *        the row, starting row numbering from the last row, which is
2339      *        {@code -1}; it must not be {@code 0}
2340      * @return {@code true} if the cursor is on the rowset; {@code false}
2341      *         otherwise
2342      * @throws SQLException if the given cursor position is {@code 0} or the
2343      *            type of this rowset is {@code ResultSet.TYPE_FORWARD_ONLY}
2344      */
2345     public boolean absolute( int row ) throws SQLException {
2346         throw new UnsupportedOperationException();
2347     }
2348 
2349     /**
2350      * Moves the cursor the specified number of rows from the current
2351      * position, with a positive number moving it forward and a
2352      * negative number moving it backward.
2353      * &lt;P&gt;
2354      * If the number is positive, the cursor moves the specified number of
2355      * rows toward the end of the rowset, starting at the current row.
2356      * For example, the following command, in which
2357      * {@code crs} is a {@code CachedRowSetImpl} object with 100 rows,
2358      * moves the cursor forward four rows from the current row.  If the
2359      * current row is 50, the cursor would move to row 54.
2360      * &lt;PRE&gt;{@code
2361      *
2362      *    crs.relative(4);
2363      *
2364      * }&lt;/PRE&gt;
2365      * &lt;P&gt;
2366      * If the number is negative, the cursor moves back toward the beginning
2367      * the specified number of rows, starting at the current row.
2368      * For example, calling the method
2369      * {@code absolute(-1)} positions the cursor on the last row,
2370      * {@code absolute(-2)} moves it on the next-to-last row, and so on.
2371      * If the {@code CachedRowSetImpl} object {@code crs} has five rows,
2372      * the following command moves the cursor to the fourth-to-last row, which
2373      * in the case of a  rowset with five rows, is also the second row
2374      * from the beginning.
2375      * &lt;PRE&gt;{@code
2376      *
2377      *    crs.absolute(-4);
2378      *
2379      * }&lt;/PRE&gt;
2380      *
2381      * If the number specified is larger than the number of rows, the cursor
2382      * will move to the position after the last row. If the number specified
2383      * would move the cursor one or more rows before the first row, the cursor
2384      * moves to the position before the first row. In both cases, this method
2385      * throws an {@code SQLException}.
2386      * &lt;P&gt;
2387      * Note: Calling {@code absolute(1)} is the same as calling the
2388      * method {@code first()}.  Calling {@code absolute(-1)} is the
2389      * same as calling {@code last()}.  Calling {@code relative(0)}
2390      * is valid, but it does not change the cursor position.
2391      *
2392      * @param rows an {@code int} indicating the number of rows to move
2393      *             the cursor, starting at the current row; a positive number
2394      *             moves the cursor forward; a negative number moves the cursor
2395      *             backward; must not move the cursor past the valid
2396      *             rows
2397      * @return {@code true} if the cursor is on a row in this
2398      *         {@code CachedRowSetImpl} object; {@code false}
2399      *         otherwise
2400      * @throws SQLException if there are no rows in this rowset, the cursor is
2401      *         positioned either before the first row or after the last row, or
2402      *         the rowset is type {@code ResultSet.TYPE_FORWARD_ONLY}
2403      */
2404     public boolean relative(int rows) throws SQLException {
2405         throw new UnsupportedOperationException();
2406     }
2407 
2408     /**
2409      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the
2410      * previous row and returns {@code true} if the cursor is on
2411      * a valid row or {@code false} if it is not.
2412      * This method also notifies all listeners registered with this
2413      * {@code CachedRowSetImpl} object that its cursor has moved.
2414      * &lt;P&gt;
2415      * Note: calling the method {@code previous()} is not the same
2416      * as calling the method {@code relative(-1)}.  This is true
2417      * because it is possible to call {@code previous()} from the insert
2418      * row, from after the last row, or from the current row, whereas
2419      * {@code relative} may only be called from the current row.
2420      * &lt;P&gt;
2421      * The method {@code previous} may used in a {@code while}
2422      * loop to iterate through a rowset starting after the last row
2423      * and moving toward the beginning. The loop ends when {@code previous}
2424      * returns {@code false}, meaning that there are no more rows.
2425      * For example, the following code fragment retrieves all the data in
2426      * the {@code CachedRowSetImpl} object {@code crs}, which has
2427      * three columns.  Note that the cursor must initially be positioned
2428      * after the last row so that the first call to the method
2429      * {@code previous} places the cursor on the last line.
2430      * &lt;PRE&gt;{@code
2431      *
2432      *     crs.afterLast();
2433      *     while (previous()) {
2434      *         String name = crs.getString(1);
2435      *         int age = crs.getInt(2);
2436      *         short ssn = crs.getShort(3);
2437      *         System.out.println(name + &quot;   &quot; + age + &quot;   &quot; + ssn);
2438      *     }
2439      *
2440      * }&lt;/PRE&gt;
2441      * This method throws an {@code SQLException} if the cursor is not
2442      * on a row in the rowset, before the first row, or after the last row.
2443      *
2444      * @return {@code true} if the cursor is on a valid row;
2445      *         {@code false} if it is before the first row or after the
2446      *         last row
2447      * @throws SQLException if the cursor is not on a valid position or the
2448      *           type of this rowset is {@code ResultSet.TYPE_FORWARD_ONLY}
2449      */
2450     public boolean previous() throws SQLException {
2451         throw new UnsupportedOperationException();
2452     }
2453 
2454     /**
2455      * Moves the cursor to the previous row in this {@code CachedRowSetImpl}
2456      * object, skipping past deleted rows that are not visible; returns
2457      * {@code true} if the cursor is on a row in this rowset and
2458      * {@code false} when the cursor goes before the first row.
2459      * &lt;P&gt;
2460      * This method is called internally by the method {@code previous}.
2461      * &lt;P&gt;
2462      * This is a implementation only method and is not required as a standard
2463      * implementation of the {@code CachedRowSet} interface.
2464      *
2465      * @return {@code true} if the cursor is on a row in this rowset;
2466      *         {@code false} when the cursor reaches the position before
2467      *         the first row
2468      * @throws SQLException if an error occurs
2469      */
2470     protected boolean internalPrevious() throws SQLException {
2471         throw new UnsupportedOperationException();
2472     }
2473 
2474 
2475     //---------------------------------------------------------------------
2476     // Updates
2477     //---------------------------------------------------------------------
2478 
2479     /**
2480      * Indicates whether the current row of this {@code CachedRowSetImpl}
2481      * object has been updated.  The value returned
2482      * depends on whether this rowset can detect updates: {@code false}
2483      * will always be returned if it does not detect updates.
2484      *
2485      * @return {@code true} if the row has been visibly updated
2486      *         by the owner or another and updates are detected;
2487      *         {@code false} otherwise
2488      * @throws SQLException if the cursor is on the insert row or not
2489      *            not on a valid row
2490      *
2491      * @see DatabaseMetaData#updatesAreDetected
2492      */
2493     public boolean rowUpdated() throws SQLException {
2494         throw new UnsupportedOperationException();
2495     }
2496 
2497     /**
2498      * Indicates whether the designated column of the current row of
2499      * this {@code CachedRowSetImpl} object has been updated. The
2500      * value returned depends on whether this rowset can detcted updates:
2501      * {@code false} will always be returned if it does not detect updates.
2502      *
2503      * @param idx the index identifier of the column that may be have been updated.
2504      * @return {@code true} is the designated column has been updated
2505      * and the rowset detects updates; {@code false} if the rowset has not
2506      * been updated or the rowset does not detect updates
2507      * @throws SQLException if the cursor is on the insert row or not
2508      *          on a valid row
2509      * @see DatabaseMetaData#updatesAreDetected
2510      */
2511     public boolean columnUpdated(int idx) throws SQLException {
2512         throw new UnsupportedOperationException();
2513     }
2514 
2515     /**
2516      * Indicates whether the designated column of the current row of
2517      * this {@code CachedRowSetImpl} object has been updated. The
2518      * value returned depends on whether this rowset can detcted updates:
2519      * {@code false} will always be returned if it does not detect updates.
2520      *
2521      * @param columnName the {@code String} column name column that may be have
2522      * been updated.
2523      * @return {@code true} is the designated column has been updated
2524      * and the rowset detects updates; {@code false} if the rowset has not
2525      * been updated or the rowset does not detect updates
2526      * @throws SQLException if the cursor is on the insert row or not
2527      *          on a valid row
2528      * @see DatabaseMetaData#updatesAreDetected
2529      */
2530     public boolean columnUpdated(String columnName) throws SQLException {
2531         throw new UnsupportedOperationException();
2532     }
2533 
2534     /**
2535      * Indicates whether the current row has been inserted.  The value returned
2536      * depends on whether or not the rowset can detect visible inserts.
2537      *
2538      * @return {@code true} if a row has been inserted and inserts are detected;
2539      *         {@code false} otherwise
2540      * @throws SQLException if the cursor is on the insert row or not
2541      *            not on a valid row
2542      *
2543      * @see DatabaseMetaData#insertsAreDetected
2544      */
2545     public boolean rowInserted() throws SQLException {
2546         throw new UnsupportedOperationException();
2547     }
2548 
2549     /**
2550      * Indicates whether the current row has been deleted.  A deleted row
2551      * may leave a visible &quot;hole&quot; in a rowset.  This method can be used to
2552      * detect such holes if the rowset can detect deletions. This method
2553      * will always return {@code false} if this rowset cannot detect
2554      * deletions.
2555      *
2556      * @return {@code true} if (1)the current row is blank, indicating that
2557      *         the row has been deleted, and (2)deletions are detected;
2558      *         {@code false} otherwise
2559      * @throws SQLException if the cursor is on a valid row in this rowset
2560      * @see DatabaseMetaData#deletesAreDetected
2561      */
2562     public boolean rowDeleted() throws SQLException {
2563         throw new UnsupportedOperationException();
2564     }
2565 
2566     /**
2567      * Sets the designated nullable column in the current row or the
2568      * insert row of this {@code CachedRowSetImpl} object with
2569      * {@code null} value.
2570      * &lt;P&gt;
2571      * This method updates a column value in the current row or the insert
2572      * row of this rowset; however, another method must be called to complete
2573      * the update process. If the cursor is on a row in the rowset, the
2574      * method {@link #updateRow} must be called to mark the row as updated
2575      * and to notify listeners that the row has changed.
2576      * If the cursor is on the insert row, the method {@link #insertRow}
2577      * must be called to insert the new row into this rowset and to notify
2578      * listeners that a row has changed.
2579      * &lt;P&gt;
2580      * In order to propagate updates in this rowset to the underlying
2581      * data source, an application must call the method {@link #acceptChanges}
2582      * after it calls either {@code updateRow} or {@code insertRow}.
2583      *
2584      * @param columnIndex the first column is {@code 1}, the second
2585      *        is {@code 2}, and so on; must be {@code 1} or larger
2586      *        and equal to or less than the number of columns in this rowset
2587      * @throws SQLException if (1) the given column index is out of bounds,
2588      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2589      *            insert row, or (3) this rowset is
2590      *            {@code ResultSet.CONCUR_READ_ONLY}
2591      */
2592     public void updateNull(int columnIndex) throws SQLException {
2593         throw new UnsupportedOperationException();
2594     }
2595 
2596     /**
2597      * Sets the designated column in either the current row or the insert
2598      * row of this {@code CachedRowSetImpl} object with the given
2599      * {@code boolean} value.
2600      * &lt;P&gt;
2601      * This method updates a column value in the current row or the insert
2602      * row of this rowset, but it does not update the database.
2603      * If the cursor is on a row in the rowset, the
2604      * method {@link #updateRow} must be called to update the database.
2605      * If the cursor is on the insert row, the method {@link #insertRow}
2606      * must be called, which will insert the new row into both this rowset
2607      * and the database. Both of these methods must be called before the
2608      * cursor moves to another row.
2609      *
2610      * @param columnIndex the first column is {@code 1}, the second
2611      *        is {@code 2}, and so on; must be {@code 1} or larger
2612      *        and equal to or less than the number of columns in this rowset
2613      * @param x the new column value
2614      * @throws SQLException if (1) the given column index is out of bounds,
2615      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2616      *            insert row, or (3) this rowset is
2617      *            {@code ResultSet.CONCUR_READ_ONLY}
2618      */
2619     public void updateBoolean(int columnIndex, boolean x) throws SQLException {
2620         throw new UnsupportedOperationException();
2621     }
2622 
2623     /**
2624      * Sets the designated column in either the current row or the insert
2625      * row of this {@code CachedRowSetImpl} object with the given
2626      * {@code byte} value.
2627      * &lt;P&gt;
2628      * This method updates a column value in the current row or the insert
2629      * row of this rowset, but it does not update the database.
2630      * If the cursor is on a row in the rowset, the
2631      * method {@link #updateRow} must be called to update the database.
2632      * If the cursor is on the insert row, the method {@link #insertRow}
2633      * must be called, which will insert the new row into both this rowset
2634      * and the database. Both of these methods must be called before the
2635      * cursor moves to another row.
2636      *
2637      * @param columnIndex the first column is {@code 1}, the second
2638      *        is {@code 2}, and so on; must be {@code 1} or larger
2639      *        and equal to or less than the number of columns in this rowset
2640      * @param x the new column value
2641      * @throws SQLException if (1) the given column index is out of bounds,
2642      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2643      *            insert row, or (3) this rowset is
2644      *            {@code ResultSet.CONCUR_READ_ONLY}
2645      */
2646     public void updateByte(int columnIndex, byte x) throws SQLException {
2647         throw new UnsupportedOperationException();
2648     }
2649 
2650     /**
2651      * Sets the designated column in either the current row or the insert
2652      * row of this {@code CachedRowSetImpl} object with the given
2653      * {@code short} value.
2654      * &lt;P&gt;
2655      * This method updates a column value in the current row or the insert
2656      * row of this rowset, but it does not update the database.
2657      * If the cursor is on a row in the rowset, the
2658      * method {@link #updateRow} must be called to update the database.
2659      * If the cursor is on the insert row, the method {@link #insertRow}
2660      * must be called, which will insert the new row into both this rowset
2661      * and the database. Both of these methods must be called before the
2662      * cursor moves to another row.
2663      *
2664      * @param columnIndex the first column is {@code 1}, the second
2665      *        is {@code 2}, and so on; must be {@code 1} or larger
2666      *        and equal to or less than the number of columns in this rowset
2667      * @param x the new column value
2668      * @throws SQLException if (1) the given column index is out of bounds,
2669      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2670      *            insert row, or (3) this rowset is
2671      *            {@code ResultSet.CONCUR_READ_ONLY}
2672      */
2673     public void updateShort(int columnIndex, short x) throws SQLException {
2674         throw new UnsupportedOperationException();
2675     }
2676 
2677     /**
2678      * Sets the designated column in either the current row or the insert
2679      * row of this {@code CachedRowSetImpl} object with the given
2680      * {@code int} value.
2681      * &lt;P&gt;
2682      * This method updates a column value in the current row or the insert
2683      * row of this rowset, but it does not update the database.
2684      * If the cursor is on a row in the rowset, the
2685      * method {@link #updateRow} must be called to update the database.
2686      * If the cursor is on the insert row, the method {@link #insertRow}
2687      * must be called, which will insert the new row into both this rowset
2688      * and the database. Both of these methods must be called before the
2689      * cursor moves to another row.
2690      *
2691      * @param columnIndex the first column is {@code 1}, the second
2692      *        is {@code 2}, and so on; must be {@code 1} or larger
2693      *        and equal to or less than the number of columns in this rowset
2694      * @param x the new column value
2695      * @throws SQLException if (1) the given column index is out of bounds,
2696      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2697      *            insert row, or (3) this rowset is
2698      *            {@code ResultSet.CONCUR_READ_ONLY}
2699      */
2700     public void updateInt(int columnIndex, int x) throws SQLException {
2701         throw new UnsupportedOperationException();
2702     }
2703 
2704     /**
2705      * Sets the designated column in either the current row or the insert
2706      * row of this {@code CachedRowSetImpl} object with the given
2707      * {@code long} value.
2708      * &lt;P&gt;
2709      * This method updates a column value in the current row or the insert
2710      * row of this rowset, but it does not update the database.
2711      * If the cursor is on a row in the rowset, the
2712      * method {@link #updateRow} must be called to update the database.
2713      * If the cursor is on the insert row, the method {@link #insertRow}
2714      * must be called, which will insert the new row into both this rowset
2715      * and the database. Both of these methods must be called before the
2716      * cursor moves to another row.
2717      *
2718      * @param columnIndex the first column is {@code 1}, the second
2719      *        is {@code 2}, and so on; must be {@code 1} or larger
2720      *        and equal to or less than the number of columns in this rowset
2721      * @param x the new column value
2722      * @throws SQLException if (1) the given column index is out of bounds,
2723      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2724      *            insert row, or (3) this rowset is
2725      *            {@code ResultSet.CONCUR_READ_ONLY}
2726      */
2727     public void updateLong(int columnIndex, long x) throws SQLException {
2728        throw new UnsupportedOperationException();
2729 
2730     }
2731 
2732     /**
2733      * Sets the designated column in either the current row or the insert
2734      * row of this {@code CachedRowSetImpl} object with the given
2735      * {@code float} value.
2736      * &lt;P&gt;
2737      * This method updates a column value in the current row or the insert
2738      * row of this rowset, but it does not update the database.
2739      * If the cursor is on a row in the rowset, the
2740      * method {@link #updateRow} must be called to update the database.
2741      * If the cursor is on the insert row, the method {@link #insertRow}
2742      * must be called, which will insert the new row into both this rowset
2743      * and the database. Both of these methods must be called before the
2744      * cursor moves to another row.
2745      *
2746      * @param columnIndex the first column is {@code 1}, the second
2747      *        is {@code 2}, and so on; must be {@code 1} or larger
2748      *        and equal to or less than the number of columns in this rowset
2749      * @param x the new column value
2750      * @throws SQLException if (1) the given column index is out of bounds,
2751      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2752      *            insert row, or (3) this rowset is
2753      *            {@code ResultSet.CONCUR_READ_ONLY}
2754      */
2755     public void updateFloat(int columnIndex, float x) throws SQLException {
2756         throw new UnsupportedOperationException();
2757     }
2758 
2759     /**
2760      * Sets the designated column in either the current row or the insert
2761      * row of this {@code CachedRowSetImpl} object with the given
2762      * {@code double} value.
2763      *
2764      * This method updates a column value in either the current row or
2765      * the insert row of this rowset, but it does not update the
2766      * database.  If the cursor is on a row in the rowset, the
2767      * method {@link #updateRow} must be called to update the database.
2768      * If the cursor is on the insert row, the method {@link #insertRow}
2769      * must be called, which will insert the new row into both this rowset
2770      * and the database. Both of these methods must be called before the
2771      * cursor moves to another row.
2772      *
2773      * @param columnIndex the first column is {@code 1}, the second
2774      *        is {@code 2}, and so on; must be {@code 1} or larger
2775      *        and equal to or less than the number of columns in this rowset
2776      * @param x the new column value
2777      * @throws SQLException if (1) the given column index is out of bounds,
2778      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2779      *            insert row, or (3) this rowset is
2780      *            {@code ResultSet.CONCUR_READ_ONLY}
2781      */
2782     public void updateDouble(int columnIndex, double x) throws SQLException {
2783         throw new UnsupportedOperationException();
2784     }
2785 
2786     /**
2787      * Sets the designated column in either the current row or the insert
2788      * row of this {@code CachedRowSetImpl} object with the given
2789      * {@code java.math.BigDecimal} object.
2790      * &lt;P&gt;
2791      * This method updates a column value in the current row or the insert
2792      * row of this rowset, but it does not update the database.
2793      * If the cursor is on a row in the rowset, the
2794      * method {@link #updateRow} must be called to update the database.
2795      * If the cursor is on the insert row, the method {@link #insertRow}
2796      * must be called, which will insert the new row into both this rowset
2797      * and the database. Both of these methods must be called before the
2798      * cursor moves to another row.
2799      *
2800      * @param columnIndex the first column is {@code 1}, the second
2801      *        is {@code 2}, and so on; must be {@code 1} or larger
2802      *        and equal to or less than the number of columns in this rowset
2803      * @param x the new column value
2804      * @throws SQLException if (1) the given column index is out of bounds,
2805      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2806      *            insert row, or (3) this rowset is
2807      *            {@code ResultSet.CONCUR_READ_ONLY}
2808      */
2809     public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
2810         throw new UnsupportedOperationException();
2811     }
2812 
2813     /**
2814      * Sets the designated column in either the current row or the insert
2815      * row of this {@code CachedRowSetImpl} object with the given
2816      * {@code String} object.
2817      * &lt;P&gt;
2818      * This method updates a column value in either the current row or
2819      * the insert row of this rowset, but it does not update the
2820      * database.  If the cursor is on a row in the rowset, the
2821      * method {@link #updateRow} must be called to mark the row as updated.
2822      * If the cursor is on the insert row, the method {@link #insertRow}
2823      * must be called to insert the new row into this rowset and mark it
2824      * as inserted. Both of these methods must be called before the
2825      * cursor moves to another row.
2826      * &lt;P&gt;
2827      * The method {@code acceptChanges} must be called if the
2828      * updated values are to be written back to the underlying database.
2829      *
2830      * @param columnIndex the first column is {@code 1}, the second
2831      *        is {@code 2}, and so on; must be {@code 1} or larger
2832      *        and equal to or less than the number of columns in this rowset
2833      * @param x the new column value
2834      * @throws SQLException if (1) the given column index is out of bounds,
2835      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2836      *            insert row, or (3) this rowset is
2837      *            {@code ResultSet.CONCUR_READ_ONLY}
2838      */
2839     public void updateString(int columnIndex, String x) throws SQLException {
2840         throw new UnsupportedOperationException();
2841     }
2842 
2843     /**
2844      * Sets the designated column in either the current row or the insert
2845      * row of this {@code CachedRowSetImpl} object with the given
2846      * {@code byte} array.
2847      *
2848      * This method updates a column value in either the current row or
2849      * the insert row of this rowset, but it does not update the
2850      * database.  If the cursor is on a row in the rowset, the
2851      * method {@link #updateRow} must be called to update the database.
2852      * If the cursor is on the insert row, the method {@link #insertRow}
2853      * must be called, which will insert the new row into both this rowset
2854      * and the database. Both of these methods must be called before the
2855      * cursor moves to another row.
2856      *
2857      * @param columnIndex the first column is {@code 1}, the second
2858      *        is {@code 2}, and so on; must be {@code 1} or larger
2859      *        and equal to or less than the number of columns in this rowset
2860      * @param x the new column value
2861      * @throws SQLException if (1) the given column index is out of bounds,
2862      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2863      *            insert row, or (3) this rowset is
2864      *            {@code ResultSet.CONCUR_READ_ONLY}
2865      */
2866     public void updateBytes(int columnIndex, byte x[]) throws SQLException {
2867         throw new UnsupportedOperationException();
2868     }
2869 
2870     /**
2871      * Sets the designated column in either the current row or the insert
2872      * row of this {@code CachedRowSetImpl} object with the given
2873      * {@code Date} object.
2874      *
2875      * This method updates a column value in either the current row or
2876      * the insert row of this rowset, but it does not update the
2877      * database.  If the cursor is on a row in the rowset, the
2878      * method {@link #updateRow} must be called to update the database.
2879      * If the cursor is on the insert row, the method {@link #insertRow}
2880      * must be called, which will insert the new row into both this rowset
2881      * and the database. Both of these methods must be called before the
2882      * cursor moves to another row.
2883      *
2884      * @param columnIndex the first column is {@code 1}, the second
2885      *        is {@code 2}, and so on; must be {@code 1} or larger
2886      *        and equal to or less than the number of columns in this rowset
2887      * @param x the new column value
2888      * @throws SQLException if (1) the given column index is out of bounds,
2889      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2890      *            insert row, (3) the type of the designated column is not
2891      *            an SQL {@code DATE} or {@code TIMESTAMP}, or
2892      *            (4) this rowset is {@code ResultSet.CONCUR_READ_ONLY}
2893      */
2894     public void updateDate(int columnIndex, java.sql.Date x) throws SQLException {
2895         throw new UnsupportedOperationException();
2896     }
2897 
2898     /**
2899      * Sets the designated column in either the current row or the insert
2900      * row of this {@code CachedRowSetImpl} object with the given
2901      * {@code Time} object.
2902      *
2903      * This method updates a column value in either the current row or
2904      * the insert row of this rowset, but it does not update the
2905      * database.  If the cursor is on a row in the rowset, the
2906      * method {@link #updateRow} must be called to update the database.
2907      * If the cursor is on the insert row, the method {@link #insertRow}
2908      * must be called, which will insert the new row into both this rowset
2909      * and the database. Both of these methods must be called before the
2910      * cursor moves to another row.
2911      *
2912      * @param columnIndex the first column is {@code 1}, the second
2913      *        is {@code 2}, and so on; must be {@code 1} or larger
2914      *        and equal to or less than the number of columns in this rowset
2915      * @param x the new column value
2916      * @throws SQLException if (1) the given column index is out of bounds,
2917      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2918      *            insert row, (3) the type of the designated column is not
2919      *            an SQL {@code TIME} or {@code TIMESTAMP}, or
2920      *            (4) this rowset is {@code ResultSet.CONCUR_READ_ONLY}
2921      */
2922     public void updateTime(int columnIndex, java.sql.Time x) throws SQLException {
2923        throw new UnsupportedOperationException();
2924     }
2925 
2926     /**
2927      * Sets the designated column in either the current row or the insert
2928      * row of this {@code CachedRowSetImpl} object with the given
2929      * {@code Timestamp} object.
2930      *
2931      * This method updates a column value in either the current row or
2932      * the insert row of this rowset, but it does not update the
2933      * database.  If the cursor is on a row in the rowset, the
2934      * method {@link #updateRow} must be called to update the database.
2935      * If the cursor is on the insert row, the method {@link #insertRow}
2936      * must be called, which will insert the new row into both this rowset
2937      * and the database. Both of these methods must be called before the
2938      * cursor moves to another row.
2939      *
2940      * @param columnIndex the first column is {@code 1}, the second
2941      *        is {@code 2}, and so on; must be {@code 1} or larger
2942      *        and equal to or less than the number of columns in this rowset
2943      * @param x the new column value
2944      * @throws SQLException if (1) the given column index is out of bounds,
2945      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2946      *            insert row, (3) the type of the designated column is not
2947      *            an SQL {@code DATE}, {@code TIME}, or
2948      *            {@code TIMESTAMP}, or (4) this rowset is
2949      *            {@code ResultSet.CONCUR_READ_ONLY}
2950      */
2951     public void updateTimestamp(int columnIndex, java.sql.Timestamp x) throws SQLException {
2952         throw new UnsupportedOperationException();
2953     }
2954 
2955     /**
2956      * Sets the designated column in either the current row or the insert
2957      * row of this {@code CachedRowSetImpl} object with the given
2958      * ASCII stream value.
2959      * &lt;P&gt;
2960      * This method updates a column value in either the current row or
2961      * the insert row of this rowset, but it does not update the
2962      * database.  If the cursor is on a row in the rowset, the
2963      * method {@link #updateRow} must be called to update the database.
2964      * If the cursor is on the insert row, the method {@link #insertRow}
2965      * must be called, which will insert the new row into both this rowset
2966      * and the database. Both of these methods must be called before the
2967      * cursor moves to another row.
2968      *
2969      * @param columnIndex the first column is {@code 1}, the second
2970      *        is {@code 2}, and so on; must be {@code 1} or larger
2971      *        and equal to or less than the number of columns in this rowset
2972      * @param x the new column value
2973      * @param length the number of one-byte ASCII characters in the stream
2974      * @throws SQLException if this method is invoked
2975      */
2976     public void updateAsciiStream(int columnIndex, java.io.InputStream x, int length) throws SQLException {
2977         throw new UnsupportedOperationException();
2978     }
2979 
2980     /**
2981      * Sets the designated column in either the current row or the insert
2982      * row of this {@code CachedRowSetImpl} object with the given
2983      * {@code java.io.InputStream} object.
2984      * &lt;P&gt;
2985      * This method updates a column value in either the current row or
2986      * the insert row of this rowset, but it does not update the
2987      * database.  If the cursor is on a row in the rowset, the
2988      * method {@link #updateRow} must be called to update the database.
2989      * If the cursor is on the insert row, the method {@link #insertRow}
2990      * must be called, which will insert the new row into both this rowset
2991      * and the database. Both of these methods must be called before the
2992      * cursor moves to another row.
2993      *
2994      * @param columnIndex the first column is {@code 1}, the second
2995      *        is {@code 2}, and so on; must be {@code 1} or larger
2996      *        and equal to or less than the number of columns in this rowset
2997      * @param x the new column value; must be a {@code java.io.InputStream}
2998      *          containing {@code BINARY}, {@code VARBINARY}, or
2999      *          {@code LONGVARBINARY} data
3000      * @param length the length of the stream in bytes
3001      * @throws SQLException if (1) the given column index is out of bounds,
3002      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3003      *            insert row, (3) the data in the stream is not binary, or
3004      *            (4) this rowset is {@code ResultSet.CONCUR_READ_ONLY}
3005      */
3006     public void updateBinaryStream(int columnIndex, java.io.InputStream x,int length) throws SQLException {
3007         throw new UnsupportedOperationException();
3008     }
3009 
3010     /**
3011      * Sets the designated column in either the current row or the insert
3012      * row of this {@code CachedRowSetImpl} object with the given
3013      * {@code java.io.Reader} object.
3014      * &lt;P&gt;
3015      * This method updates a column value in either the current row or
3016      * the insert row of this rowset, but it does not update the
3017      * database.  If the cursor is on a row in the rowset, the
3018      * method {@link #updateRow} must be called to update the database.
3019      * If the cursor is on the insert row, the method {@link #insertRow}
3020      * must be called, which will insert the new row into both this rowset
3021      * and the database. Both of these methods must be called before the
3022      * cursor moves to another row.
3023      *
3024      * @param columnIndex the first column is {@code 1}, the second
3025      *        is {@code 2}, and so on; must be {@code 1} or larger
3026      *        and equal to or less than the number of columns in this rowset
3027      * @param x the new column value; must be a {@code java.io.Reader}
3028      *          containing {@code BINARY}, {@code VARBINARY},
3029      *          {@code LONGVARBINARY}, {@code CHAR}, {@code VARCHAR},
3030      *          or {@code LONGVARCHAR} data
3031      * @param length the length of the stream in characters
3032      * @throws SQLException if (1) the given column index is out of bounds,
3033      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3034      *            insert row, (3) the data in the stream is not a binary or
3035      *            character type, or (4) this rowset is
3036      *            {@code ResultSet.CONCUR_READ_ONLY}
3037      */
3038     public void updateCharacterStream(int columnIndex, java.io.Reader x, int length) throws SQLException {
3039         throw new UnsupportedOperationException();
3040     }
3041 
3042     /**
3043      * Sets the designated column in either the current row or the insert
3044      * row of this {@code CachedRowSetImpl} object with the given
3045      * {@code Object} value.  The {@code scale} parameter indicates
3046      * the number of digits to the right of the decimal point and is ignored
3047      * if the new column value is not a type that will be mapped to an SQL
3048      * {@code DECIMAL} or {@code NUMERIC} value.
3049      * &lt;P&gt;
3050      * This method updates a column value in either the current row or
3051      * the insert row of this rowset, but it does not update the
3052      * database.  If the cursor is on a row in the rowset, the
3053      * method {@link #updateRow} must be called to update the database.
3054      * If the cursor is on the insert row, the method {@link #insertRow}
3055      * must be called, which will insert the new row into both this rowset
3056      * and the database. Both of these methods must be called before the
3057      * cursor moves to another row.
3058      *
3059      * @param columnIndex the first column is {@code 1}, the second
3060      *        is {@code 2}, and so on; must be {@code 1} or larger
3061      *        and equal to or less than the number of columns in this rowset
3062      * @param x the new column value
3063      * @param scale the number of digits to the right of the decimal point (for
3064      *              {@code DECIMAL} and {@code NUMERIC} types only)
3065      * @throws SQLException if (1) the given column index is out of bounds,
3066      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3067      *            insert row, or (3) this rowset is
3068      *            {@code ResultSet.CONCUR_READ_ONLY}
3069      */
3070     public void updateObject(int columnIndex, Object x, int scale) throws SQLException {
3071        throw new UnsupportedOperationException();
3072     }
3073 
3074     /**
3075      * Sets the designated column in either the current row or the insert
3076      * row of this {@code CachedRowSetImpl} object with the given
3077      * {@code Object} value.
3078      * &lt;P&gt;
3079      * This method updates a column value in either the current row or
3080      * the insert row of this rowset, but it does not update the
3081      * database.  If the cursor is on a row in the rowset, the
3082      * method {@link #updateRow} must be called to update the database.
3083      * If the cursor is on the insert row, the method {@link #insertRow}
3084      * must be called, which will insert the new row into both this rowset
3085      * and the database. Both of these methods must be called before the
3086      * cursor moves to another row.
3087      *
3088      * @param columnIndex the first column is {@code 1}, the second
3089      *        is {@code 2}, and so on; must be {@code 1} or larger
3090      *        and equal to or less than the number of columns in this rowset
3091      * @param x the new column value
3092      * @throws SQLException if (1) the given column index is out of bounds,
3093      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3094      *            insert row, or (3) this rowset is
3095      *            {@code ResultSet.CONCUR_READ_ONLY}
3096      */
3097     public void updateObject(int columnIndex, Object x) throws SQLException {
3098         throw new UnsupportedOperationException();
3099     }
3100 
3101 
3102     /**
3103      * Sets the designated nullable column in the current row or the
3104      * insert row of this {@code CachedRowSetImpl} object with
3105      * {@code null} value.
3106      * &lt;P&gt;
3107      * This method updates a column value in the current row or the insert
3108      * row of this rowset, but it does not update the database.
3109      * If the cursor is on a row in the rowset, the
3110      * method {@link #updateRow} must be called to update the database.
3111      * If the cursor is on the insert row, the method {@link #insertRow}
3112      * must be called, which will insert the new row into both this rowset
3113      * and the database.
3114      *
3115      * @param columnName a {@code String} object that must match the
3116      *        SQL name of a column in this rowset, ignoring case
3117      * @throws SQLException if (1) the given column name does not match the
3118      *            name of a column in this rowset, (2) the cursor is not on
3119      *            one of this rowset&#39;s rows or its insert row, or (3) this
3120      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3121      */
3122     public void updateNull(String columnName) throws SQLException {
3123         throw new UnsupportedOperationException();
3124     }
3125 
3126     /**
3127      * Sets the designated column in either the current row or the insert
3128      * row of this {@code CachedRowSetImpl} object with the given
3129      * {@code boolean} value.
3130      * &lt;P&gt;
3131      * This method updates a column value in the current row or the insert
3132      * row of this rowset, but it does not update the database.
3133      * If the cursor is on a row in the rowset, the
3134      * method {@link #updateRow} must be called to update the database.
3135      * If the cursor is on the insert row, the method {@link #insertRow}
3136      * must be called, which will insert the new row into both this rowset
3137      * and the database. Both of these methods must be called before the
3138      * cursor moves to another row.
3139      *
3140      * @param columnName a {@code String} object that must match the
3141      *        SQL name of a column in this rowset, ignoring case
3142      * @param x the new column value
3143      * @throws SQLException if (1) the given column name does not match the
3144      *            name of a column in this rowset, (2) the cursor is not on
3145      *            one of this rowset&#39;s rows or its insert row, or (3) this
3146      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3147      */
3148     public void updateBoolean(String columnName, boolean x) throws SQLException {
3149        throw new UnsupportedOperationException();
3150     }
3151 
3152     /**
3153      * Sets the designated column in either the current row or the insert
3154      * row of this {@code CachedRowSetImpl} object with the given
3155      * {@code byte} value.
3156      * &lt;P&gt;
3157      * This method updates a column value in the current row or the insert
3158      * row of this rowset, but it does not update the database.
3159      * If the cursor is on a row in the rowset, the
3160      * method {@link #updateRow} must be called to update the database.
3161      * If the cursor is on the insert row, the method {@link #insertRow}
3162      * must be called, which will insert the new row into both this rowset
3163      * and the database. Both of these methods must be called before the
3164      * cursor moves to another row.
3165      *
3166      * @param columnName a {@code String} object that must match the
3167      *        SQL name of a column in this rowset, ignoring case
3168      * @param x the new column value
3169      * @throws SQLException if (1) the given column name does not match the
3170      *            name of a column in this rowset, (2) the cursor is not on
3171      *            one of this rowset&#39;s rows or its insert row, or (3) this
3172      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3173      */
3174     public void updateByte(String columnName, byte x) throws SQLException {
3175         throw new UnsupportedOperationException();
3176     }
3177 
3178     /**
3179      * Sets the designated column in either the current row or the insert
3180      * row of this {@code CachedRowSetImpl} object with the given
3181      * {@code short} value.
3182      * &lt;P&gt;
3183      * This method updates a column value in the current row or the insert
3184      * row of this rowset, but it does not update the database.
3185      * If the cursor is on a row in the rowset, the
3186      * method {@link #updateRow} must be called to update the database.
3187      * If the cursor is on the insert row, the method {@link #insertRow}
3188      * must be called, which will insert the new row into both this rowset
3189      * and the database. Both of these methods must be called before the
3190      * cursor moves to another row.
3191      *
3192      * @param columnName a {@code String} object that must match the
3193      *        SQL name of a column in this rowset, ignoring case
3194      * @param x the new column value
3195      * @throws SQLException if (1) the given column name does not match the
3196      *            name of a column in this rowset, (2) the cursor is not on
3197      *            one of this rowset&#39;s rows or its insert row, or (3) this
3198      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3199      */
3200     public void updateShort(String columnName, short x) throws SQLException {
3201         throw new UnsupportedOperationException();
3202     }
3203 
3204     /**
3205      * Sets the designated column in either the current row or the insert
3206      * row of this {@code CachedRowSetImpl} object with the given
3207      * {@code int} value.
3208      * &lt;P&gt;
3209      * This method updates a column value in the current row or the insert
3210      * row of this rowset, but it does not update the database.
3211      * If the cursor is on a row in the rowset, the
3212      * method {@link #updateRow} must be called to update the database.
3213      * If the cursor is on the insert row, the method {@link #insertRow}
3214      * must be called, which will insert the new row into both this rowset
3215      * and the database. Both of these methods must be called before the
3216      * cursor moves to another row.
3217      *
3218      * @param columnName a {@code String} object that must match the
3219      *        SQL name of a column in this rowset, ignoring case
3220      * @param x the new column value
3221      * @throws SQLException if (1) the given column name does not match the
3222      *            name of a column in this rowset, (2) the cursor is not on
3223      *            one of this rowset&#39;s rows or its insert row, or (3) this
3224      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3225      */
3226     public void updateInt(String columnName, int x) throws SQLException {
3227         throw new UnsupportedOperationException();
3228     }
3229 
3230     /**
3231      * Sets the designated column in either the current row or the insert
3232      * row of this {@code CachedRowSetImpl} object with the given
3233      * {@code long} value.
3234      * &lt;P&gt;
3235      * This method updates a column value in the current row or the insert
3236      * row of this rowset, but it does not update the database.
3237      * If the cursor is on a row in the rowset, the
3238      * method {@link #updateRow} must be called to update the database.
3239      * If the cursor is on the insert row, the method {@link #insertRow}
3240      * must be called, which will insert the new row into both this rowset
3241      * and the database. Both of these methods must be called before the
3242      * cursor moves to another row.
3243      *
3244      * @param columnName a {@code String} object that must match the
3245      *        SQL name of a column in this rowset, ignoring case
3246      * @param x the new column value
3247      * @throws SQLException if (1) the given column name does not match the
3248      *            name of a column in this rowset, (2) the cursor is not on
3249      *            one of this rowset&#39;s rows or its insert row, or (3) this
3250      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3251      */
3252     public void updateLong(String columnName, long x) throws SQLException {
3253         throw new UnsupportedOperationException();
3254     }
3255 
3256     /**
3257      * Sets the designated column in either the current row or the insert
3258      * row of this {@code CachedRowSetImpl} object with the given
3259      * {@code float} value.
3260      * &lt;P&gt;
3261      * This method updates a column value in the current row or the insert
3262      * row of this rowset, but it does not update the database.
3263      * If the cursor is on a row in the rowset, the
3264      * method {@link #updateRow} must be called to update the database.
3265      * If the cursor is on the insert row, the method {@link #insertRow}
3266      * must be called, which will insert the new row into both this rowset
3267      * and the database. Both of these methods must be called before the
3268      * cursor moves to another row.
3269      *
3270      * @param columnName a {@code String} object that must match the
3271      *        SQL name of a column in this rowset, ignoring case
3272      * @param x the new column value
3273      * @throws SQLException if (1) the given column name does not match the
3274      *            name of a column in this rowset, (2) the cursor is not on
3275      *            one of this rowset&#39;s rows or its insert row, or (3) this
3276      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3277      */
3278     public void updateFloat(String columnName, float x) throws SQLException {
3279         throw new UnsupportedOperationException();
3280     }
3281 
3282     /**
3283      * Sets the designated column in either the current row or the insert
3284      * row of this {@code CachedRowSetImpl} object with the given
3285      * {@code double} value.
3286      *
3287      * This method updates a column value in either the current row or
3288      * the insert row of this rowset, but it does not update the
3289      * database.  If the cursor is on a row in the rowset, the
3290      * method {@link #updateRow} must be called to update the database.
3291      * If the cursor is on the insert row, the method {@link #insertRow}
3292      * must be called, which will insert the new row into both this rowset
3293      * and the database. Both of these methods must be called before the
3294      * cursor moves to another row.
3295      *
3296      * @param columnName a {@code String} object that must match the
3297      *        SQL name of a column in this rowset, ignoring case
3298      * @param x the new column value
3299      * @throws SQLException if (1) the given column name does not match the
3300      *            name of a column in this rowset, (2) the cursor is not on
3301      *            one of this rowset&#39;s rows or its insert row, or (3) this
3302      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3303      */
3304     public void updateDouble(String columnName, double x) throws SQLException {
3305         throw new UnsupportedOperationException();
3306     }
3307 
3308     /**
3309      * Sets the designated column in either the current row or the insert
3310      * row of this {@code CachedRowSetImpl} object with the given
3311      * {@code java.math.BigDecimal} object.
3312      * &lt;P&gt;
3313      * This method updates a column value in the current row or the insert
3314      * row of this rowset, but it does not update the database.
3315      * If the cursor is on a row in the rowset, the
3316      * method {@link #updateRow} must be called to update the database.
3317      * If the cursor is on the insert row, the method {@link #insertRow}
3318      * must be called, which will insert the new row into both this rowset
3319      * and the database. Both of these methods must be called before the
3320      * cursor moves to another row.
3321      *
3322      * @param columnName a {@code String} object that must match the
3323      *        SQL name of a column in this rowset, ignoring case
3324      * @param x the new column value
3325      * @throws SQLException if (1) the given column name does not match the
3326      *            name of a column in this rowset, (2) the cursor is not on
3327      *            one of this rowset&#39;s rows or its insert row, or (3) this
3328      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3329      */
3330     public void updateBigDecimal(String columnName, BigDecimal x) throws SQLException {
3331         throw new UnsupportedOperationException();
3332     }
3333 
3334     /**
3335      * Sets the designated column in either the current row or the insert
3336      * row of this {@code CachedRowSetImpl} object with the given
3337      * {@code String} object.
3338      *
3339      * This method updates a column value in either the current row or
3340      * the insert row of this rowset, but it does not update the
3341      * database.  If the cursor is on a row in the rowset, the
3342      * method {@link #updateRow} must be called to update the database.
3343      * If the cursor is on the insert row, the method {@link #insertRow}
3344      * must be called, which will insert the new row into both this rowset
3345      * and the database. Both of these methods must be called before the
3346      * cursor moves to another row.
3347      *
3348      * @param columnName a {@code String} object that must match the
3349      *        SQL name of a column in this rowset, ignoring case
3350      * @param x the new column value
3351      * @throws SQLException if (1) the given column name does not match the
3352      *            name of a column in this rowset, (2) the cursor is not on
3353      *            one of this rowset&#39;s rows or its insert row, or (3) this
3354      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3355      */
3356     public void updateString(String columnName, String x) throws SQLException {
3357         throw new UnsupportedOperationException();
3358     }
3359 
3360     /**
3361      * Sets the designated column in either the current row or the insert
3362      * row of this {@code CachedRowSetImpl} object with the given
3363      * {@code byte} array.
3364      *
3365      * This method updates a column value in either the current row or
3366      * the insert row of this rowset, but it does not update the
3367      * database.  If the cursor is on a row in the rowset, the
3368      * method {@link #updateRow} must be called to update the database.
3369      * If the cursor is on the insert row, the method {@link #insertRow}
3370      * must be called, which will insert the new row into both this rowset
3371      * and the database. Both of these methods must be called before the
3372      * cursor moves to another row.
3373      *
3374      * @param columnName a {@code String} object that must match the
3375      *        SQL name of a column in this rowset, ignoring case
3376      * @param x the new column value
3377      * @throws SQLException if (1) the given column name does not match the
3378      *            name of a column in this rowset, (2) the cursor is not on
3379      *            one of this rowset&#39;s rows or its insert row, or (3) this
3380      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3381      */
3382     public void updateBytes(String columnName, byte x[]) throws SQLException {
3383         throw new UnsupportedOperationException();
3384     }
3385 
3386     /**
3387      * Sets the designated column in either the current row or the insert
3388      * row of this {@code CachedRowSetImpl} object with the given
3389      * {@code Date} object.
3390      *
3391      * This method updates a column value in either the current row or
3392      * the insert row of this rowset, but it does not update the
3393      * database.  If the cursor is on a row in the rowset, the
3394      * method {@link #updateRow} must be called to update the database.
3395      * If the cursor is on the insert row, the method {@link #insertRow}
3396      * must be called, which will insert the new row into both this rowset
3397      * and the database. Both of these methods must be called before the
3398      * cursor moves to another row.
3399      *
3400      * @param columnName a {@code String} object that must match the
3401      *        SQL name of a column in this rowset, ignoring case
3402      * @param x the new column value
3403      * @throws SQLException if (1) the given column name does not match the
3404      *            name of a column in this rowset, (2) the cursor is not on
3405      *            one of this rowset&#39;s rows or its insert row, (3) the type
3406      *            of the designated column is not an SQL {@code DATE} or
3407      *            {@code TIMESTAMP}, or (4) this rowset is
3408      *            {@code ResultSet.CONCUR_READ_ONLY}
3409      */
3410     public void updateDate(String columnName, java.sql.Date x) throws SQLException {
3411         throw new UnsupportedOperationException();
3412     }
3413 
3414     /**
3415      * Sets the designated column in either the current row or the insert
3416      * row of this {@code CachedRowSetImpl} object with the given
3417      * {@code Time} object.
3418      *
3419      * This method updates a column value in either the current row or
3420      * the insert row of this rowset, but it does not update the
3421      * database.  If the cursor is on a row in the rowset, the
3422      * method {@link #updateRow} must be called to update the database.
3423      * If the cursor is on the insert row, the method {@link #insertRow}
3424      * must be called, which will insert the new row into both this rowset
3425      * and the database. Both of these methods must be called before the
3426      * cursor moves to another row.
3427      *
3428      * @param columnName a {@code String} object that must match the
3429      *        SQL name of a column in this rowset, ignoring case
3430      * @param x the new column value
3431      * @throws SQLException if (1) the given column name does not match the
3432      *            name of a column in this rowset, (2) the cursor is not on
3433      *            one of this rowset&#39;s rows or its insert row, (3) the type
3434      *            of the designated column is not an SQL {@code TIME} or
3435      *            {@code TIMESTAMP}, or (4) this rowset is
3436      *            {@code ResultSet.CONCUR_READ_ONLY}
3437      */
3438     public void updateTime(String columnName, java.sql.Time x) throws SQLException {
3439         throw new UnsupportedOperationException();
3440     }
3441 
3442     /**
3443      * Sets the designated column in either the current row or the insert
3444      * row of this {@code CachedRowSetImpl} object with the given
3445      * {@code Timestamp} object.
3446      *
3447      * This method updates a column value in either the current row or
3448      * the insert row of this rowset, but it does not update the
3449      * database.  If the cursor is on a row in the rowset, the
3450      * method {@link #updateRow} must be called to update the database.
3451      * If the cursor is on the insert row, the method {@link #insertRow}
3452      * must be called, which will insert the new row into both this rowset
3453      * and the database. Both of these methods must be called before the
3454      * cursor moves to another row.
3455      *
3456      * @param columnName a {@code String} object that must match the
3457      *        SQL name of a column in this rowset, ignoring case
3458      * @param x the new column value
3459      * @throws SQLException if the given column index is out of bounds or
3460      *            the cursor is not on one of this rowset&#39;s rows or its
3461      *            insert row
3462      * @throws SQLException if (1) the given column name does not match the
3463      *            name of a column in this rowset, (2) the cursor is not on
3464      *            one of this rowset&#39;s rows or its insert row, (3) the type
3465      *            of the designated column is not an SQL {@code DATE},
3466      *            {@code TIME}, or {@code TIMESTAMP}, or (4) this
3467      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3468      */
3469     public void updateTimestamp(String columnName, java.sql.Timestamp x) throws SQLException {
3470         throw new UnsupportedOperationException();
3471     }
3472 
3473     /**
3474      * Sets the designated column in either the current row or the insert
3475      * row of this {@code CachedRowSetImpl} object with the given
3476      * ASCII stream value.
3477      * &lt;P&gt;
3478      * This method updates a column value in either the current row or
3479      * the insert row of this rowset, but it does not update the
3480      * database.  If the cursor is on a row in the rowset, the
3481      * method {@link #updateRow} must be called to update the database.
3482      * If the cursor is on the insert row, the method {@link #insertRow}
3483      * must be called, which will insert the new row into both this rowset
3484      * and the database. Both of these methods must be called before the
3485      * cursor moves to another row.
3486      *
3487      * @param columnName a {@code String} object that must match the
3488      *        SQL name of a column in this rowset, ignoring case
3489      * @param x the new column value
3490      * @param length the number of one-byte ASCII characters in the stream
3491      */
3492     public void updateAsciiStream(String columnName,
3493     java.io.InputStream x,
3494     int length) throws SQLException {
3495        throw new UnsupportedOperationException();
3496     }
3497 
3498     /**
3499      * Sets the designated column in either the current row or the insert
3500      * row of this {@code CachedRowSetImpl} object with the given
3501      * {@code java.io.InputStream} object.
3502      * &lt;P&gt;
3503      * This method updates a column value in either the current row or
3504      * the insert row of this rowset, but it does not update the
3505      * database.  If the cursor is on a row in the rowset, the
3506      * method {@link #updateRow} must be called to update the database.
3507      * If the cursor is on the insert row, the method {@link #insertRow}
3508      * must be called, which will insert the new row into both this rowset
3509      * and the database. Both of these methods must be called before the
3510      * cursor moves to another row.
3511      *
3512      * @param columnName a {@code String} object that must match the
3513      *        SQL name of a column in this rowset, ignoring case
3514      * @param x the new column value; must be a {@code java.io.InputStream}
3515      *          containing {@code BINARY}, {@code VARBINARY}, or
3516      *          {@code LONGVARBINARY} data
3517      * @param length the length of the stream in bytes
3518      * @throws SQLException if (1) the given column name does not match the
3519      *            name of a column in this rowset, (2) the cursor is not on
3520      *            one of this rowset&#39;s rows or its insert row, (3) the data
3521      *            in the stream is not binary, or (4) this rowset is
3522      *            {@code ResultSet.CONCUR_READ_ONLY}
3523      */
3524     public void updateBinaryStream(String columnName, java.io.InputStream x, int length) throws SQLException {
3525         throw new UnsupportedOperationException();
3526     }
3527 
3528     /**
3529      * Sets the designated column in either the current row or the insert
3530      * row of this {@code CachedRowSetImpl} object with the given
3531      * {@code java.io.Reader} object.
3532      * &lt;P&gt;
3533      * This method updates a column value in either the current row or
3534      * the insert row of this rowset, but it does not update the
3535      * database.  If the cursor is on a row in the rowset, the
3536      * method {@link #updateRow} must be called to update the database.
3537      * If the cursor is on the insert row, the method {@link #insertRow}
3538      * must be called, which will insert the new row into both this rowset
3539      * and the database. Both of these methods must be called before the
3540      * cursor moves to another row.
3541      *
3542      * @param columnName a {@code String} object that must match the
3543      *        SQL name of a column in this rowset, ignoring case
3544      * @param reader the new column value; must be a
3545      * {@code java.io.Reader} containing {@code BINARY},
3546      * {@code VARBINARY}, {@code LONGVARBINARY}, {@code CHAR},
3547      * {@code VARCHAR}, or {@code LONGVARCHAR} data
3548      * @param length the length of the stream in characters
3549      * @throws SQLException if (1) the given column name does not match the
3550      *            name of a column in this rowset, (2) the cursor is not on
3551      *            one of this rowset&#39;s rows or its insert row, (3) the data
3552      *            in the stream is not a binary or character type, or (4) this
3553      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3554      */
3555     public void updateCharacterStream(String columnName,
3556     java.io.Reader reader,
3557     int length) throws SQLException {
3558         throw new UnsupportedOperationException();
3559     }
3560 
3561     /**
3562      * Sets the designated column in either the current row or the insert
3563      * row of this {@code CachedRowSetImpl} object with the given
3564      * {@code Object} value.  The {@code scale} parameter
3565      * indicates the number of digits to the right of the decimal point
3566      * and is ignored if the new column value is not a type that will be
3567      *  mapped to an SQL {@code DECIMAL} or {@code NUMERIC} value.
3568      * &lt;P&gt;
3569      * This method updates a column value in either the current row or
3570      * the insert row of this rowset, but it does not update the
3571      * database.  If the cursor is on a row in the rowset, the
3572      * method {@link #updateRow} must be called to update the database.
3573      * If the cursor is on the insert row, the method {@link #insertRow}
3574      * must be called, which will insert the new row into both this rowset
3575      * and the database. Both of these methods must be called before the
3576      * cursor moves to another row.
3577      *
3578      * @param columnName a {@code String} object that must match the
3579      *        SQL name of a column in this rowset, ignoring case
3580      * @param x the new column value
3581      * @param scale the number of digits to the right of the decimal point (for
3582      *              {@code DECIMAL} and {@code NUMERIC} types only)
3583      * @throws SQLException if (1) the given column name does not match the
3584      *            name of a column in this rowset, (2) the cursor is not on
3585      *            one of this rowset&#39;s rows or its insert row, or (3) this
3586      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3587      */
3588     public void updateObject(String columnName, Object x, int scale) throws SQLException {
3589         throw new UnsupportedOperationException();
3590     }
3591 
3592     /**
3593      * Sets the designated column in either the current row or the insert
3594      * row of this {@code CachedRowSetImpl} object with the given
3595      * {@code Object} value.
3596      * &lt;P&gt;
3597      * This method updates a column value in either the current row or
3598      * the insert row of this rowset, but it does not update the
3599      * database.  If the cursor is on a row in the rowset, the
3600      * method {@link #updateRow} must be called to update the database.
3601      * If the cursor is on the insert row, the method {@link #insertRow}
3602      * must be called, which will insert the new row into both this rowset
3603      * and the database. Both of these methods must be called before the
3604      * cursor moves to another row.
3605      *
3606      * @param columnName a {@code String} object that must match the
3607      *        SQL name of a column in this rowset, ignoring case
3608      * @param x the new column value
3609      * @throws SQLException if (1) the given column name does not match the
3610      *            name of a column in this rowset, (2) the cursor is not on
3611      *            one of this rowset&#39;s rows or its insert row, or (3) this
3612      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3613      */
3614     public void updateObject(String columnName, Object x) throws SQLException {
3615         throw new UnsupportedOperationException();
3616     }
3617 
3618     /**
3619      * Inserts the contents of this {@code CachedRowSetImpl} object&#39;s insert
3620      * row into this rowset immediately following the current row.
3621      * If the current row is the
3622      * position after the last row or before the first row, the new row will
3623      * be inserted at the end of the rowset.  This method also notifies
3624      * listeners registered with this rowset that the row has changed.
3625      * &lt;P&gt;
3626      * The cursor must be on the insert row when this method is called.
3627      *
3628      * @throws SQLException if (1) the cursor is not on the insert row,
3629      *            (2) one or more of the non-nullable columns in the insert
3630      *            row has not been given a value, or (3) this rowset is
3631      *            {@code ResultSet.CONCUR_READ_ONLY}
3632      */
3633     public void insertRow() throws SQLException {
3634         throw new UnsupportedOperationException();
3635     }
3636 
3637     /**
3638      * Marks the current row of this {@code CachedRowSetImpl} object as
3639      * updated and notifies listeners registered with this rowset that the
3640      * row has changed.
3641      * &lt;P&gt;
3642      * This method  cannot be called when the cursor is on the insert row, and
3643      * it should be called before the cursor moves to another row.  If it is
3644      * called after the cursor moves to another row, this method has no effect,
3645      * and the updates made before the cursor moved will be lost.
3646      *
3647      * @throws SQLException if the cursor is on the insert row or this
3648      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3649      */
3650     public void updateRow() throws SQLException {
3651         throw new UnsupportedOperationException();
3652     }
3653 
3654     /**
3655      * Deletes the current row from this {@code CachedRowSetImpl} object and
3656      * notifies listeners registered with this rowset that a row has changed.
3657      * This method cannot be called when the cursor is on the insert row.
3658      * &lt;P&gt;
3659      * This method marks the current row as deleted, but it does not delete
3660      * the row from the underlying data source.  The method
3661      * {@code acceptChanges} must be called to delete the row in
3662      * the data source.
3663      *
3664      * @throws SQLException if (1) this method is called when the cursor
3665      *            is on the insert row, before the first row, or after the
3666      *            last row or (2) this rowset is
3667      *            {@code ResultSet.CONCUR_READ_ONLY}
3668      */
3669     public void deleteRow() throws SQLException {
3670         throw new UnsupportedOperationException();
3671     }
3672 
3673     /**
3674      * Sets the current row with its original value and marks the row as
3675      * not updated, thus undoing any changes made to the row since the
3676      * last call to the methods {@code updateRow} or {@code deleteRow}.
3677      * This method should be called only when the cursor is on a row in
3678      * this rowset.
3679      *
3680      * @throws SQLException if the cursor is on the insert row, before the
3681      *            first row, or after the last row
3682      */
3683     public void refreshRow() throws SQLException {
3684         throw new UnsupportedOperationException();
3685     }
3686 
3687     /**
3688      * Rolls back any updates made to the current row of this
3689      * {@code CachedRowSetImpl} object and notifies listeners that
3690      * a row has changed.  To have an effect, this method
3691      * must be called after an {@code updateXXX} method has been
3692      * called and before the method {@code updateRow} has been called.
3693      * If no updates have been made or the method {@code updateRow}
3694      * has already been called, this method has no effect.
3695      *
3696      * @throws SQLException if the cursor is on the insert row, before the
3697      *            first row, or after the last row
3698      */
3699     public void cancelRowUpdates() throws SQLException {
3700         throw new UnsupportedOperationException();
3701     }
3702 
3703     /**
3704      * Moves the cursor for this {@code CachedRowSetImpl} object
3705      * to the insert row.  The current row in the rowset is remembered
3706      * while the cursor is on the insert row.
3707      * &lt;P&gt;
3708      * The insert row is a special row associated with an updatable
3709      * rowset.  It is essentially a buffer where a new row may
3710      * be constructed by calling the appropriate {@code updateXXX}
3711      * methods to assign a value to each column in the row.  A complete
3712      * row must be constructed; that is, every column that is not nullable
3713      * must be assigned a value.  In order for the new row to become part
3714      * of this rowset, the method {@code insertRow} must be called
3715      * before the cursor is moved back to the rowset.
3716      * &lt;P&gt;
3717      * Only certain methods may be invoked while the cursor is on the insert
3718      * row; many methods throw an exception if they are called while the
3719      * cursor is there.  In addition to the {@code updateXXX}
3720      * and {@code insertRow} methods, only the {@code getXXX} methods
3721      * may be called when the cursor is on the insert row.  A {@code getXXX}
3722      * method should be called on a column only after an {@code updateXXX}
3723      * method has been called on that column; otherwise, the value returned is
3724      * undetermined.
3725      *
3726      * @throws SQLException if this {@code CachedRowSetImpl} object is
3727      *            {@code ResultSet.CONCUR_READ_ONLY}
3728      */
3729     public void moveToInsertRow() throws SQLException {
3730         throw new UnsupportedOperationException();
3731     }
3732 
3733     /**
3734      * Moves the cursor for this {@code CachedRowSetImpl} object to
3735      * the current row.  The current row is the row the cursor was on
3736      * when the method {@code moveToInsertRow} was called.
3737      * &lt;P&gt;
3738      * Calling this method has no effect unless it is called while the
3739      * cursor is on the insert row.
3740      *
3741      * @throws SQLException if an error occurs
3742      */
3743     public void moveToCurrentRow() throws SQLException {
3744         throw new UnsupportedOperationException();
3745     }
3746 
3747     /**
3748      * Returns {@code null}.
3749      *
3750      * @return {@code null}
3751      * @throws SQLException if an error occurs
3752      */
3753     public Statement getStatement() throws SQLException {
3754         throw new UnsupportedOperationException();
3755     }
3756 
3757     /**
3758      * Retrieves the value of the designated column in this
3759      * {@code CachedRowSetImpl} object as an {@code Object} in
3760      * the Java programming language, using the given
3761      * {@code java.util.Map} object to custom map the value if
3762      * appropriate.
3763      *
3764      * @param columnIndex the first column is {@code 1}, the second
3765      *        is {@code 2}, and so on; must be {@code 1} or larger
3766      *        and equal to or less than the number of columns in this rowset
3767      * @param map a {@code java.util.Map} object showing the mapping
3768      *            from SQL type names to classes in the Java programming
3769      *            language
3770      * @return an {@code Object} representing the SQL value
3771      * @throws SQLException if the given column index is out of bounds or
3772      *            the cursor is not on one of this rowset&#39;s rows or its
3773      *            insert row
3774      */
3775     public Object getObject(int columnIndex,
3776                             java.util.Map&lt;String,Class&lt;?&gt;&gt; map)
3777           throws SQLException
3778     {
3779        throw new UnsupportedOperationException();
3780     }
3781 
3782     /**
3783      * Retrieves the value of the designated column in this
3784      * {@code CachedRowSetImpl} object as a {@code Ref} object
3785      * in the Java programming language.
3786      *
3787      * @param columnIndex the first column is {@code 1}, the second
3788      *        is {@code 2}, and so on; must be {@code 1} or larger
3789      *        and equal to or less than the number of columns in this rowset
3790      * @return a {@code Ref} object representing an SQL{@code  REF} value
3791      * @throws SQLException if (1) the given column index is out of bounds,
3792      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3793      *            insert row, or (3) the designated column does not store an
3794      *            SQL {@code REF} value
3795      * @see #getRef(String)
3796      */
3797     public Ref getRef(int columnIndex) throws SQLException {
3798         throw new UnsupportedOperationException();
3799     }
3800 
3801     /**
3802      * Retrieves the value of the designated column in this
3803      * {@code CachedRowSetImpl} object as a {@code Blob} object
3804      * in the Java programming language.
3805      *
3806      * @param columnIndex the first column is {@code 1}, the second
3807      *        is {@code 2}, and so on; must be {@code 1} or larger
3808      *        and equal to or less than the number of columns in this rowset
3809      * @return a {@code Blob} object representing an SQL {@code BLOB} value
3810      * @throws SQLException if (1) the given column index is out of bounds,
3811      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3812      *            insert row, or (3) the designated column does not store an
3813      *            SQL {@code BLOB} value
3814      * @see #getBlob(String)
3815      */
3816     public Blob getBlob(int columnIndex) throws SQLException {
3817        throw new UnsupportedOperationException();
3818     }
3819 
3820     /**
3821      * Retrieves the value of the designated column in this
3822      * {@code CachedRowSetImpl} object as a {@code Clob} object
3823      * in the Java programming language.
3824      *
3825      * @param columnIndex the first column is {@code 1}, the second
3826      *        is {@code 2}, and so on; must be {@code 1} or larger
3827      *        and equal to or less than the number of columns in this rowset
3828      * @return a {@code Clob} object representing an SQL {@code CLOB} value
3829      * @throws SQLException if (1) the given column index is out of bounds,
3830      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3831      *            insert row, or (3) the designated column does not store an
3832      *            SQL {@code CLOB} value
3833      * @see #getClob(String)
3834      */
3835     public Clob getClob(int columnIndex) throws SQLException {
3836         throw new UnsupportedOperationException();
3837     }
3838 
3839     /**
3840      * Retrieves the value of the designated column in this
3841      * {@code CachedRowSetImpl} object as an {@code Array} object
3842      * in the Java programming language.
3843      *
3844      * @param columnIndex the first column is {@code 1}, the second
3845      *        is {@code 2}, and so on; must be {@code 1} or larger
3846      *        and equal to or less than the number of columns in this rowset
3847      * @return an {@code Array} object representing an SQL
3848      *         {@code ARRAY} value
3849      * @throws SQLException if (1) the given column index is out of bounds,
3850      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3851      *            insert row, or (3) the designated column does not store an
3852      *            SQL {@code ARRAY} value
3853      * @see #getArray(String)
3854      */
3855     public Array getArray(int columnIndex) throws SQLException {
3856         throw new UnsupportedOperationException();
3857     }
3858 
3859     /**
3860      * Retrieves the value of the designated column in this
3861      * {@code CachedRowSetImpl} object as an {@code Object} in
3862      * the Java programming language, using the given
3863      * {@code java.util.Map} object to custom map the value if
3864      * appropriate.
3865      *
3866      * @param columnName a {@code String} object that must match the
3867      *        SQL name of a column in this rowset, ignoring case
3868      * @param map a {@code java.util.Map} object showing the mapping
3869      *        from SQL type names to classes in the Java programming
3870      *        language
3871      * @return an {@code Object} representing the SQL value
3872      * @throws SQLException if the given column name is not the name of
3873      *         a column in this rowset or the cursor is not on one of
3874      *         this rowset&#39;s rows or its insert row
3875      */
3876     public Object getObject(String columnName,
3877                             java.util.Map&lt;String,Class&lt;?&gt;&gt; map)
3878     throws SQLException {
3879         throw new UnsupportedOperationException();
3880     }
3881 
3882     /**
3883      * Retrieves the value of the designated column in this
3884      * {@code CachedRowSetImpl} object as a {@code Ref} object
3885      * in the Java programming language.
3886      *
3887      * @param colName a {@code String} object that must match the
3888      *        SQL name of a column in this rowset, ignoring case
3889      * @return a {@code Ref} object representing an SQL{@code  REF} value
3890      * @throws SQLException  if (1) the given column name is not the name of
3891      *            a column in this rowset, (2) the cursor is not on one of
3892      *            this rowset&#39;s rows or its insert row, or (3) the column value
3893      *            is not an SQL {@code REF} value
3894      * @see #getRef(int)
3895      */
3896     public Ref getRef(String colName) throws SQLException {
3897         throw new UnsupportedOperationException();
3898     }
3899 
3900     /**
3901      * Retrieves the value of the designated column in this
3902      * {@code CachedRowSetImpl} object as a {@code Blob} object
3903      * in the Java programming language.
3904      *
3905      * @param colName a {@code String} object that must match the
3906      *        SQL name of a column in this rowset, ignoring case
3907      * @return a {@code Blob} object representing an SQL {@code BLOB} value
3908      * @throws SQLException if (1) the given column name is not the name of
3909      *            a column in this rowset, (2) the cursor is not on one of
3910      *            this rowset&#39;s rows or its insert row, or (3) the designated
3911      *            column does not store an SQL {@code BLOB} value
3912      * @see #getBlob(int)
3913      */
3914     public Blob getBlob(String colName) throws SQLException {
3915        throw new UnsupportedOperationException();
3916     }
3917 
3918     /**
3919      * Retrieves the value of the designated column in this
3920      * {@code CachedRowSetImpl} object as a {@code Clob} object
3921      * in the Java programming language.
3922      *
3923      * @param colName a {@code String} object that must match the
3924      *        SQL name of a column in this rowset, ignoring case
3925      * @return a {@code Clob} object representing an SQL
3926      *         {@code CLOB} value
3927      * @throws SQLException if (1) the given column name is not the name of
3928      *            a column in this rowset, (2) the cursor is not on one of
3929      *            this rowset&#39;s rows or its insert row, or (3) the designated
3930      *            column does not store an SQL {@code CLOB} value
3931      * @see #getClob(int)
3932      */
3933     public Clob getClob(String colName) throws SQLException {
3934         throw new UnsupportedOperationException();
3935     }
3936 
3937     /**
3938      * Retrieves the value of the designated column in this
3939      * {@code CachedRowSetImpl} object as an {@code Array} object
3940      * in the Java programming langugage.
3941      *
3942      * @param colName a {@code String} object that must match the
3943      *        SQL name of a column in this rowset, ignoring case
3944      * @return an {@code Array} object representing an SQL
3945      *         {@code ARRAY} value
3946      * @throws SQLException if (1) the given column name is not the name of
3947      *            a column in this rowset, (2) the cursor is not on one of
3948      *            this rowset&#39;s rows or its insert row, or (3) the designated
3949      *            column does not store an SQL {@code ARRAY} value
3950      * @see #getArray(int)
3951      */
3952     public Array getArray(String colName) throws SQLException {
3953         throw new UnsupportedOperationException();
3954     }
3955 
3956     /**
3957      * Retrieves the value of the designated column in the current row
3958      * of this {@code CachedRowSetImpl} object as a {@code java.sql.Date}
3959      * object, using the given {@code Calendar} object to construct an
3960      * appropriate millisecond value for the date.
3961      *
3962      * @param columnIndex the first column is {@code 1}, the second
3963      *        is {@code 2}, and so on; must be {@code 1} or larger
3964      *        and equal to or less than the number of columns in the rowset
3965      * @param cal the {@code java.util.Calendar} object to use in
3966      *            constructing the date
3967      * @return the column value; if the value is SQL {@code NULL},
3968      *         the result is {@code null}
3969      * @throws SQLException if (1) the given column name is not the name of
3970      *            a column in this rowset, (2) the cursor is not on one of
3971      *            this rowset&#39;s rows or its insert row, or (3) the designated
3972      *            column does not store an SQL {@code DATE} or
3973      *            {@code TIMESTAMP} value
3974      */
3975     public java.sql.Date getDate(int columnIndex, Calendar cal) throws SQLException {
3976         throw new UnsupportedOperationException();
3977     }
3978 
3979     /**
3980      * Retrieves the value of the designated column in the current row
3981      * of this {@code CachedRowSetImpl} object as a {@code java.sql.Date}
3982      * object, using the given {@code Calendar} object to construct an
3983      * appropriate millisecond value for the date.
3984      *
3985      * @param columnName a {@code String} object that must match the
3986      *        SQL name of a column in this rowset, ignoring case
3987      * @param cal the {@code java.util.Calendar} object to use in
3988      *            constructing the date
3989      * @return the column value; if the value is SQL {@code NULL},
3990      *         the result is {@code null}
3991      * @throws SQLException if (1) the given column name is not the name of
3992      *            a column in this rowset, (2) the cursor is not on one of
3993      *            this rowset&#39;s rows or its insert row, or (3) the designated
3994      *            column does not store an SQL {@code DATE} or
3995      *            {@code TIMESTAMP} value
3996      */
3997     public java.sql.Date getDate(String columnName, Calendar cal) throws SQLException {
3998         throw new UnsupportedOperationException();
3999     }
4000 
4001     /**
4002      * Retrieves the value of the designated column in the current row
4003      * of this {@code CachedRowSetImpl} object as a {@code java.sql.Time}
4004      * object, using the given {@code Calendar} object to construct an
4005      * appropriate millisecond value for the date.
4006      *
4007      * @param columnIndex the first column is {@code 1}, the second
4008      *        is {@code 2}, and so on; must be {@code 1} or larger
4009      *        and equal to or less than the number of columns in the rowset
4010      * @param cal the {@code java.util.Calendar} object to use in
4011      *            constructing the date
4012      * @return the column value; if the value is SQL {@code NULL},
4013      *         the result is {@code null}
4014      * @throws SQLException if (1) the given column name is not the name of
4015      *            a column in this rowset, (2) the cursor is not on one of
4016      *            this rowset&#39;s rows or its insert row, or (3) the designated
4017      *            column does not store an SQL {@code TIME} or
4018      *            {@code TIMESTAMP} value
4019      */
4020     public java.sql.Time getTime(int columnIndex, Calendar cal) throws SQLException {
4021         throw new UnsupportedOperationException();
4022     }
4023 
4024     /**
4025      * Retrieves the value of the designated column in the current row
4026      * of this {@code CachedRowSetImpl} object as a {@code java.sql.Time}
4027      * object, using the given {@code Calendar} object to construct an
4028      * appropriate millisecond value for the date.
4029      *
4030      * @param columnName a {@code String} object that must match the
4031      *        SQL name of a column in this rowset, ignoring case
4032      * @param cal the {@code java.util.Calendar} object to use in
4033      *            constructing the date
4034      * @return the column value; if the value is SQL {@code NULL},
4035      *         the result is {@code null}
4036      * @throws SQLException if (1) the given column name is not the name of
4037      *            a column in this rowset, (2) the cursor is not on one of
4038      *            this rowset&#39;s rows or its insert row, or (3) the designated
4039      *            column does not store an SQL {@code TIME} or
4040      *            {@code TIMESTAMP} value
4041      */
4042     public java.sql.Time getTime(String columnName, Calendar cal) throws SQLException {
4043         throw new UnsupportedOperationException();
4044     }
4045 
4046     /**
4047      * Retrieves the value of the designated column in the current row
4048      * of this {@code CachedRowSetImpl} object as a {@code java.sql.Timestamp}
4049      * object, using the given {@code Calendar} object to construct an
4050      * appropriate millisecond value for the date.
4051      *
4052      * @param columnIndex the first column is {@code 1}, the second
4053      *        is {@code 2}, and so on; must be {@code 1} or larger
4054      *        and equal to or less than the number of columns in the rowset
4055      * @param cal the {@code java.util.Calendar} object to use in
4056      *            constructing the date
4057      * @return the column value; if the value is SQL {@code NULL},
4058      *         the result is {@code null}
4059      * @throws SQLException if (1) the given column name is not the name of
4060      *            a column in this rowset, (2) the cursor is not on one of
4061      *            this rowset&#39;s rows or its insert row, or (3) the designated
4062      *            column does not store an SQL {@code TIME} or
4063      *            {@code TIMESTAMP} value
4064      */
4065     public java.sql.Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
4066         throw new UnsupportedOperationException();
4067     }
4068 
4069     /**
4070      * Retrieves the value of the designated column in the current row
4071      * of this {@code CachedRowSetImpl} object as a
4072      * {@code java.sql.Timestamp} object, using the given
4073      * {@code Calendar} object to construct an appropriate
4074      * millisecond value for the date.
4075      *
4076      * @param columnName a {@code String} object that must match the
4077      *        SQL name of a column in this rowset, ignoring case
4078      * @param cal the {@code java.util.Calendar} object to use in
4079      *            constructing the date
4080      * @return the column value; if the value is SQL {@code NULL},
4081      *         the result is {@code null}
4082      * @throws SQLException if (1) the given column name is not the name of
4083      *            a column in this rowset, (2) the cursor is not on one of
4084      *            this rowset&#39;s rows or its insert row, or (3) the designated
4085      *            column does not store an SQL {@code DATE},
4086      *            {@code TIME}, or {@code TIMESTAMP} value
4087      */
4088     public java.sql.Timestamp getTimestamp(String columnName, Calendar cal) throws SQLException {
4089         throw new UnsupportedOperationException();
4090     }
4091 
4092     /*
4093      * RowSetInternal Interface
4094      */
4095 
4096     /**
4097      * Retrieves the {@code Connection} object passed to this
4098      * {@code CachedRowSetImpl} object.  This connection may be
4099      * used to populate this rowset with data or to write data back
4100      * to its underlying data source.
4101      *
4102      * @return the {@code Connection} object passed to this rowset;
4103      *         may be {@code null} if there is no connection
4104      * @throws SQLException if an error occurs
4105      */
4106     public Connection getConnection() throws SQLException{
4107         throw new UnsupportedOperationException();
4108     }
4109 
4110     /**
4111      * Sets the metadata for this {@code CachedRowSetImpl} object
4112      * with the given {@code RowSetMetaData} object.
4113      *
4114      * @param md a {@code RowSetMetaData} object instance containing
4115      *            metadata about the columsn in the rowset
4116      * @throws SQLException if invalid meta data is supplied to the
4117      *            rowset
4118      */
4119     public void setMetaData(RowSetMetaData md) throws SQLException {
4120         throw new UnsupportedOperationException();
4121     }
4122 
4123     /**
4124      * Returns a result set containing the original value of the rowset. The
4125      * original value is the state of the {@code CachedRowSetImpl} after the
4126      * last population or synchronization (whichever occurred most recently) with
4127      * the data source.
4128      * &lt;p&gt;
4129      * The cursor is positioned before the first row in the result set.
4130      * Only rows contained in the result set returned by {@code getOriginal()}
4131      * are said to have an original value.
4132      *
4133      * @return the original result set of the rowset
4134      * @throws SQLException if an error occurs produce the
4135      *           {@code ResultSet} object
4136      */
4137     public ResultSet getOriginal() throws SQLException {
4138        throw new UnsupportedOperationException();
4139     }
4140 
4141     /**
4142      * Returns a result set containing the original value of the current
4143      * row only.
4144      * The original value is the state of the {@code CachedRowSetImpl} after
4145      * the last population or synchronization (whichever occurred most recently)
4146      * with the data source.
4147      *
4148      * @return the original result set of the row
4149      * @throws SQLException if there is no current row
4150      * @see #setOriginalRow
4151      */
4152     public ResultSet getOriginalRow() throws SQLException {
4153         throw new UnsupportedOperationException();
4154 
4155     }
4156 
4157     /**
4158      * Marks the current row in this rowset as being an original row.
4159      *
4160      * @throws SQLException if there is no current row
4161      * @see #getOriginalRow
4162      */
4163     public void setOriginalRow() throws SQLException {
4164         throw new UnsupportedOperationException();
4165     }
4166 
4167     /**
4168      * Marks all rows in this rowset as being original rows. Any updates
4169      * made to the rows become the original values for the rowset.
4170      * Calls to the method {@code setOriginal} connot be reversed.
4171      *
4172      * @throws SQLException if an error occurs
4173      */
4174     public void setOriginal() throws SQLException {
4175         throw new UnsupportedOperationException();
4176     }
4177 
4178     /**
4179      * Returns an identifier for the object (table) that was used to create this
4180      * rowset.
4181      *
4182      * @return a {@code String} object that identifies the table from
4183      *         which this {@code CachedRowSetImpl} object was derived
4184      * @throws SQLException if an error occurs
4185      */
4186     public String getTableName() throws SQLException {
4187         throw new UnsupportedOperationException();
4188     }
4189 
4190     /**
4191      * Sets the identifier for the table from which this rowset was derived
4192      * to the given table name.
4193      *
4194      * @param tabName a {@code String} object that identifies the
4195      *          table from which this {@code CachedRowSetImpl} object
4196      *          was derived
4197      * @throws SQLException if an error occurs
4198      */
4199     public void setTableName(String tabName) throws SQLException {
4200         throw new UnsupportedOperationException();
4201     }
4202 
4203     /**
4204      * Returns the columns that make a key to uniquely identify a
4205      * row in this {@code CachedRowSetImpl} object.
4206      *
4207      * @return an array of column numbers that constitutes a primary
4208      *           key for this rowset. This array should be empty
4209      *           if no column is representitive of a primary key
4210      * @throws SQLException if the rowset is empty or no columns
4211      *           are designated as primary keys
4212      * @see #setKeyColumns
4213      */
4214     public int[] getKeyColumns() throws SQLException {
4215         throw new UnsupportedOperationException();
4216     }
4217 
4218 
4219     /**
4220      * Sets this {@code CachedRowSetImpl} object&#39;s
4221      * {@code keyCols} field with the given array of column
4222      * numbers, which forms a key for uniquely identifying a row
4223      * in this rowset.
4224      *
4225      * @param keys an array of {@code int} indicating the
4226      *        columns that form a primary key for this
4227      *        {@code CachedRowSetImpl} object; every
4228      *        element in the array must be greater than
4229      *        {@code 0} and less than or equal to the number
4230      *        of columns in this rowset
4231      * @throws SQLException if any of the numbers in the
4232      *            given array is not valid for this rowset
4233      * @see #getKeyColumns
4234      */
4235     public void setKeyColumns(int [] keys) throws SQLException {
4236         throw new UnsupportedOperationException();
4237     }
4238 
4239     /**
4240      * Sets the designated column in either the current row or the insert
4241      * row of this {@code CachedRowSetImpl} object with the given
4242      * {@code double} value.
4243      *
4244      * This method updates a column value in either the current row or
4245      * the insert row of this rowset, but it does not update the
4246      * database.  If the cursor is on a row in the rowset, the
4247      * method {@link #updateRow} must be called to update the database.
4248      * If the cursor is on the insert row, the method {@link #insertRow}
4249      * must be called, which will insert the new row into both this rowset
4250      * and the database. Both of these methods must be called before the
4251      * cursor moves to another row.
4252      *
4253      * @param columnIndex the first column is {@code 1}, the second
4254      *        is {@code 2}, and so on; must be {@code 1} or larger
4255      *        and equal to or less than the number of columns in this rowset
4256      * @param ref the new column {@code java.sql.Ref} value
4257      * @throws SQLException if (1) the given column index is out of bounds,
4258      *        (2) the cursor is not on one of this rowset&#39;s rows or its
4259      *        insert row, or (3) this rowset is
4260      *        {@code ResultSet.CONCUR_READ_ONLY}
4261      */
4262     public void updateRef(int columnIndex, java.sql.Ref ref) throws SQLException {
4263         throw new UnsupportedOperationException();
4264     }
4265 
4266     /**
4267      * Sets the designated column in either the current row or the insert
4268      * row of this {@code CachedRowSetImpl} object with the given
4269      * {@code double} value.
4270      *
4271      * This method updates a column value in either the current row or
4272      * the insert row of this rowset, but it does not update the
4273      * database.  If the cursor is on a row in the rowset, the
4274      * method {@link #updateRow} must be called to update the database.
4275      * If the cursor is on the insert row, the method {@link #insertRow}
4276      * must be called, which will insert the new row into both this rowset
4277      * and the database. Both of these methods must be called before the
4278      * cursor moves to another row.
4279      *
4280      * @param columnName a {@code String} object that must match the
4281      *        SQL name of a column in this rowset, ignoring case
4282      * @param ref the new column {@code java.sql.Ref} value
4283      * @throws SQLException if (1) the given column name does not match the
4284      *        name of a column in this rowset, (2) the cursor is not on
4285      *        one of this rowset&#39;s rows or its insert row, or (3) this
4286      *        rowset is {@code ResultSet.CONCUR_READ_ONLY}
4287      */
4288     public void updateRef(String columnName, java.sql.Ref ref) throws SQLException {
4289         throw new UnsupportedOperationException();
4290     }
4291 
4292     /**
4293      * Sets the designated column in either the current row or the insert
4294      * row of this {@code CachedRowSetImpl} object with the given
4295      * {@code double} value.
4296      *
4297      * This method updates a column value in either the current row or
4298      * the insert row of this rowset, but it does not update the
4299      * database.  If the cursor is on a row in the rowset, the
4300      * method {@link #updateRow} must be called to update the database.
4301      * If the cursor is on the insert row, the method {@link #insertRow}
4302      * must be called, which will insert the new row into both this rowset
4303      * and the database. Both of these methods must be called before the
4304      * cursor moves to another row.
4305      *
4306      * @param columnIndex the first column is {@code 1}, the second
4307      *        is {@code 2}, and so on; must be {@code 1} or larger
4308      *        and equal to or less than the number of columns in this rowset
4309      * @param c the new column {@code Clob} value
4310      * @throws SQLException if (1) the given column index is out of bounds,
4311      *        (2) the cursor is not on one of this rowset&#39;s rows or its
4312      *        insert row, or (3) this rowset is
4313      *        {@code ResultSet.CONCUR_READ_ONLY}
4314      */
4315     public void updateClob(int columnIndex, Clob c) throws SQLException {
4316        throw new UnsupportedOperationException();
4317     }
4318 
4319     /**
4320      * Sets the designated column in either the current row or the insert
4321      * row of this {@code CachedRowSetImpl} object with the given
4322      * {@code double} value.
4323      *
4324      * This method updates a column value in either the current row or
4325      * the insert row of this rowset, but it does not update the
4326      * database.  If the cursor is on a row in the rowset, the
4327      * method {@link #updateRow} must be called to update the database.
4328      * If the cursor is on the insert row, the method {@link #insertRow}
4329      * must be called, which will insert the new row into both this rowset
4330      * and the database. Both of these methods must be called before the
4331      * cursor moves to another row.
4332      *
4333      * @param columnName a {@code String} object that must match the
4334      *        SQL name of a column in this rowset, ignoring case
4335      * @param c the new column {@code Clob} value
4336      * @throws SQLException if (1) the given column name does not match the
4337      *            name of a column in this rowset, (2) the cursor is not on
4338      *            one of this rowset&#39;s rows or its insert row, or (3) this
4339      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
4340      */
4341     public void updateClob(String columnName, Clob c) throws SQLException {
4342         throw new UnsupportedOperationException();
4343     }
4344 
4345     /**
4346      * Sets the designated column in either the current row or the insert
4347      * row of this {@code CachedRowSetImpl} object with the given
4348      * {@code java.sql.Blob} value.
4349      *
4350      * This method updates a column value in either the current row or
4351      * the insert row of this rowset, but it does not update the
4352      * database.  If the cursor is on a row in the rowset, the
4353      * method {@link #updateRow} must be called to update the database.
4354      * If the cursor is on the insert row, the method {@link #insertRow}
4355      * must be called, which will insert the new row into both this rowset
4356      * and the database. Both of these methods must be called before the
4357      * cursor moves to another row.
4358      *
4359      * @param columnIndex the first column is {@code 1}, the second
4360      *        is {@code 2}, and so on; must be {@code 1} or larger
4361      *        and equal to or less than the number of columns in this rowset
4362      * @param b the new column {@code Blob} value
4363      * @throws SQLException if (1) the given column index is out of bounds,
4364      *            (2) the cursor is not on one of this rowset&#39;s rows or its
4365      *            insert row, or (3) this rowset is
4366      *            {@code ResultSet.CONCUR_READ_ONLY}
4367      */
4368     public void updateBlob(int columnIndex, Blob b) throws SQLException {
4369        throw new UnsupportedOperationException();
4370     }
4371 
4372     /**
4373      * Sets the designated column in either the current row or the insert
4374      * row of this {@code CachedRowSetImpl} object with the given
4375      * {@code java.sql.Blob } value.
4376      *
4377      * This method updates a column value in either the current row or
4378      * the insert row of this rowset, but it does not update the
4379      * database.  If the cursor is on a row in the rowset, the
4380      * method {@link #updateRow} must be called to update the database.
4381      * If the cursor is on the insert row, the method {@link #insertRow}
4382      * must be called, which will insert the new row into both this rowset
4383      * and the database. Both of these methods must be called before the
4384      * cursor moves to another row.
4385      *
4386      * @param columnName a {@code String} object that must match the
4387      *        SQL name of a column in this rowset, ignoring case
4388      * @param b the new column {@code Blob} value
4389      * @throws SQLException if (1) the given column name does not match the
4390      *            name of a column in this rowset, (2) the cursor is not on
4391      *            one of this rowset&#39;s rows or its insert row, or (3) this
4392      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
4393      */
4394     public void updateBlob(String columnName, Blob b) throws SQLException {
4395         throw new UnsupportedOperationException();
4396     }
4397 
4398     /**
4399      * Sets the designated column in either the current row or the insert
4400      * row of this {@code CachedRowSetImpl} object with the given
4401      * {@code java.sql.Array} values.
4402      *
4403      * This method updates a column value in either the current row or
4404      * the insert row of this rowset, but it does not update the
4405      * database.  If the cursor is on a row in the rowset, the
4406      * method {@link #updateRow} must be called to update the database.
4407      * If the cursor is on the insert row, the method {@link #insertRow}
4408      * must be called, which will insert the new row into both this rowset
4409      * and the database. Both of these methods must be called before the
4410      * cursor moves to another row.
4411      *
4412      * @param columnIndex the first column is {@code 1}, the second
4413      *        is {@code 2}, and so on; must be {@code 1} or larger
4414      *        and equal to or less than the number of columns in this rowset
4415      * @param a the new column {@code Array} value
4416      * @throws SQLException if (1) the given column index is out of bounds,
4417      *            (2) the cursor is not on one of this rowset&#39;s rows or its
4418      *            insert row, or (3) this rowset is
4419      *            {@code ResultSet.CONCUR_READ_ONLY}
4420      */
4421     public void updateArray(int columnIndex, Array a) throws SQLException {
4422         throw new UnsupportedOperationException();
4423     }
4424 
4425     /**
4426      * Sets the designated column in either the current row or the insert
4427      * row of this {@code CachedRowSetImpl} object with the given
4428      * {@code java.sql.Array} value.
4429      *
4430      * This method updates a column value in either the current row or
4431      * the insert row of this rowset, but it does not update the
4432      * database.  If the cursor is on a row in the rowset, the
4433      * method {@link #updateRow} must be called to update the database.
4434      * If the cursor is on the insert row, the method {@link #insertRow}
4435      * must be called, which will insert the new row into both this rowset
4436      * and the database. Both of these methods must be called before the
4437      * cursor moves to another row.
4438      *
4439      * @param columnName a {@code String} object that must match the
4440      *        SQL name of a column in this rowset, ignoring case
4441      * @param a the new column {@code Array} value
4442      * @throws SQLException if (1) the given column name does not match the
4443      *            name of a column in this rowset, (2) the cursor is not on
4444      *            one of this rowset&#39;s rows or its insert row, or (3) this
4445      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
4446      */
4447     public void updateArray(String columnName, Array a) throws SQLException {
4448         throw new UnsupportedOperationException();
4449     }
4450 
4451 
4452     /**
4453      * Retrieves the value of the designated column in this
4454      * {@code CachedRowSetImpl} object as a {@code java.net.URL} object
4455      * in the Java programming language.
4456      *
4457      * @return a java.net.URL object containing the resource reference described by
4458      * the URL
4459      * @throws SQLException if (1) the given column index is out of bounds,
4460      * (2) the cursor is not on one of this rowset&#39;s rows or its
4461      * insert row, or (3) the designated column does not store an
4462      * SQL {@code DATALINK} value.
4463      * @see #getURL(String)
4464      */
4465     public java.net.URL getURL(int columnIndex) throws SQLException {
4466         throw new UnsupportedOperationException();
4467     }
4468 
4469     /**
4470      * Retrieves the value of the designated column in this
4471      * {@code CachedRowSetImpl} object as a {@code java.net.URL} object
4472      * in the Java programming language.
4473      *
4474      * @return a java.net.URL object containing the resource reference described by
4475      * the URL
4476      * @throws SQLException if (1) the given column name not the name of a column
4477      * in this rowset, or
4478      * (2) the cursor is not on one of this rowset&#39;s rows or its
4479      * insert row, or (3) the designated column does not store an
4480      * SQL {@code DATALINK} value.
4481      * @see #getURL(int)
4482      */
4483     public java.net.URL getURL(String columnName) throws SQLException {
4484         throw new UnsupportedOperationException();
4485 
4486     }
4487 
4488     /**
4489      * The first warning reported by calls on this {@code CachedRowSetImpl}
4490      * object is returned. Subsequent {@code CachedRowSetImpl} warnings will
4491      * be chained to this {@code SQLWarning}. All {@code RowSetWarnings}
4492      * warnings are generated in the disconnected environment and remain a
4493      * seperate warning chain to that provided by the {@code getWarnings}
4494      * method.
4495      *
4496      * &lt;P&gt;The warning chain is automatically cleared each time a new
4497      * row is read.
4498      *
4499      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This warning chain only covers warnings caused
4500      * by {@code CachedRowSet} (and their child interface)
4501      * methods. All {@code SQLWarnings} can be obtained using the
4502      * {@code getWarnings} method which tracks warnings generated
4503      * by the underlying JDBC driver.
4504      * @return the first SQLWarning or null
4505      *
4506      */
4507     public RowSetWarning getRowSetWarnings() {
4508         throw new UnsupportedOperationException();
4509     }
4510 
4511      /**
4512      * Commits all changes performed by the {@code acceptChanges()}
4513      * methods
4514      *
4515      * @see java.sql.Connection#commit
4516      */
4517     public void commit() throws SQLException {
4518         throw new UnsupportedOperationException();
4519     }
4520 
4521     /**
4522      * Rolls back all changes performed by the {@code acceptChanges()}
4523      * methods
4524      *
4525      * @see java.sql.Connection#rollback
4526      */
4527     public void rollback() throws SQLException {
4528         throw new UnsupportedOperationException();
4529     }
4530 
4531     /**
4532      * Rolls back all changes performed by the {@code acceptChanges()}
4533      * to the last {@code Savepoint} transaction marker.
4534      *
4535      * @see java.sql.Connection#rollback(Savepoint)
4536      */
4537     public void rollback(Savepoint s) throws SQLException {
4538         throw new UnsupportedOperationException();
4539     }
4540 
4541     /**
4542      * Unsets the designated parameter to the given int array.
4543      * This was set using {@code setMatchColumn}
4544      * as the column which will form the basis of the join.
4545      * &lt;P&gt;
4546      * The parameter value unset by this method should be same
4547      * as was set.
4548      *
4549      * @param columnIdxes the index into this rowset
4550      *        object&#39;s internal representation of parameter values
4551      * @throws SQLException if an error occurs or the
4552      *  parameter index is out of bounds or if the columnIdx is
4553      *  not the same as set using {@code setMatchColumn(int [])}
4554      */
4555     public void unsetMatchColumn(int[] columnIdxes) throws SQLException {
4556          throw new UnsupportedOperationException();
4557     }
4558 
4559    /**
4560      * Unsets the designated parameter to the given String array.
4561      * This was set using {@code setMatchColumn}
4562      * as the column which will form the basis of the join.
4563      * &lt;P&gt;
4564      * The parameter value unset by this method should be same
4565      * as was set.
4566      *
4567      * @param columnIdxes the index into this rowset
4568      *        object&#39;s internal representation of parameter values
4569      * @throws SQLException if an error occurs or the
4570      *  parameter index is out of bounds or if the columnName is
4571      *  not the same as set using {@code setMatchColumn(String [])}
4572      */
4573     public void unsetMatchColumn(String[] columnIdxes) throws SQLException {
4574        throw new UnsupportedOperationException();
4575     }
4576 
4577     /**
4578      * Retrieves the column name as {@code String} array
4579      * that was set using {@code setMatchColumn(String [])}
4580      * for this rowset.
4581      *
4582      * @return a {@code String} array object that contains the column names
4583      *         for the rowset which has this the match columns
4584      *
4585      * @throws SQLException if an error occurs or column name is not set
4586      */
4587     public String[] getMatchColumnNames() throws SQLException {
4588         throw new UnsupportedOperationException();
4589     }
4590 
4591     /**
4592      * Retrieves the column id as {@code int} array that was set using
4593      * {@code setMatchColumn(int [])} for this rowset.
4594      *
4595      * @return an {@code int} array object that contains the column ids
4596      *         for the rowset which has this as the match columns.
4597      *
4598      * @throws SQLException if an error occurs or column index is not set
4599      */
4600     public int[] getMatchColumnIndexes() throws SQLException {
4601         throw new UnsupportedOperationException();
4602     }
4603 
4604     /**
4605      * Sets the designated parameter to the given int array.
4606      * This forms the basis of the join for the
4607      * {@code JoinRowSet} as the column which will form the basis of the
4608      * join.
4609      * &lt;P&gt;
4610      * The parameter value set by this method is stored internally and
4611      * will be supplied as the appropriate parameter in this rowset&#39;s
4612      * command when the method {@code getMatchColumnIndexes} is called.
4613      *
4614      * @param columnIdxes the indexes into this rowset
4615      *        object&#39;s internal representation of parameter values; the
4616      *        first parameter is 0, the second is 1, and so on; must be
4617      *        {@code 0} or greater
4618      * @throws SQLException if an error occurs or the
4619      *                         parameter index is out of bounds
4620      */
4621     public void setMatchColumn(int[] columnIdxes) throws SQLException {
4622         throw new UnsupportedOperationException();
4623     }
4624 
4625     /**
4626      * Sets the designated parameter to the given String array.
4627      *  This forms the basis of the join for the
4628      * {@code JoinRowSet} as the column which will form the basis of the
4629      * join.
4630      * &lt;P&gt;
4631      * The parameter value set by this method is stored internally and
4632      * will be supplied as the appropriate parameter in this rowset&#39;s
4633      * command when the method {@code getMatchColumn} is called.
4634      *
4635      * @param columnNames the name of the column into this rowset
4636      *        object&#39;s internal representation of parameter values
4637      * @throws SQLException if an error occurs or the
4638      *  parameter index is out of bounds
4639      */
4640     public void setMatchColumn(String[] columnNames) throws SQLException {
4641         throw new UnsupportedOperationException();
4642     }
4643 
4644 
4645     /**
4646      * Sets the designated parameter to the given {@code int}
4647      * object.  This forms the basis of the join for the
4648      * {@code JoinRowSet} as the column which will form the basis of the
4649      * join.
4650      * &lt;P&gt;
4651      * The parameter value set by this method is stored internally and
4652      * will be supplied as the appropriate parameter in this rowset&#39;s
4653      * command when the method {@code getMatchColumn} is called.
4654      *
4655      * @param columnIdx the index into this rowset
4656      *        object&#39;s internal representation of parameter values; the
4657      *        first parameter is 0, the second is 1, and so on; must be
4658      *        {@code 0} or greater
4659      * @throws SQLException if an error occurs or the
4660      *                         parameter index is out of bounds
4661      */
4662     public void setMatchColumn(int columnIdx) throws SQLException {
4663         throw new UnsupportedOperationException();
4664     }
4665 
4666     /**
4667      * Sets the designated parameter to the given {@code String}
4668      * object.  This forms the basis of the join for the
4669      * {@code JoinRowSet} as the column which will form the basis of the
4670      * join.
4671      * &lt;P&gt;
4672      * The parameter value set by this method is stored internally and
4673      * will be supplied as the appropriate parameter in this rowset&#39;s
4674      * command when the method {@code getMatchColumn} is called.
4675      *
4676      * @param columnName the name of the column into this rowset
4677      *        object&#39;s internal representation of parameter values
4678      * @throws SQLException if an error occurs or the
4679      *  parameter index is out of bounds
4680      */
4681     public void setMatchColumn(String columnName) throws SQLException {
4682         throw new UnsupportedOperationException();
4683     }
4684 
4685     /**
4686      * Unsets the designated parameter to the given {@code int}
4687      * object.  This was set using {@code setMatchColumn}
4688      * as the column which will form the basis of the join.
4689      * &lt;P&gt;
4690      * The parameter value unset by this method should be same
4691      * as was set.
4692      *
4693      * @param columnIdx the index into this rowset
4694      *        object&#39;s internal representation of parameter values
4695      * @throws SQLException if an error occurs or the
4696      *  parameter index is out of bounds or if the columnIdx is
4697      *  not the same as set using {@code setMatchColumn(int)}
4698      */
4699     public void unsetMatchColumn(int columnIdx) throws SQLException {
4700         throw new UnsupportedOperationException();
4701     }
4702 
4703     /**
4704      * Unsets the designated parameter to the given {@code String}
4705      * object.  This was set using {@code setMatchColumn}
4706      * as the column which will form the basis of the join.
4707      * &lt;P&gt;
4708      * The parameter value unset by this method should be same
4709      * as was set.
4710      *
4711      * @param columnName the index into this rowset
4712      *        object&#39;s internal representation of parameter values
4713      * @throws SQLException if an error occurs or the
4714      *  parameter index is out of bounds or if the columnName is
4715      *  not the same as set using {@code setMatchColumn(String)}
4716      */
4717     public void unsetMatchColumn(String columnName) throws SQLException {
4718         throw new UnsupportedOperationException();
4719     }
4720 
4721     /**
4722      * Notifies registered listeners that a RowSet object in the given RowSetEvent
4723      * object has populated a number of additional rows. The {@code numRows} parameter
4724      * ensures that this event will only be fired every {@code numRow}.
4725      * &lt;p&gt;
4726      * The source of the event can be retrieved with the method event.getSource.
4727      *
4728      * @param event a {@code RowSetEvent} object that contains the
4729      *     {@code RowSet} object that is the source of the events
4730      * @param numRows when populating, the number of rows interval on which the
4731      *     {@code CachedRowSet} populated should fire; the default value
4732      *     is zero; cannot be less than {@code fetchSize} or zero
4733      */
4734     public void rowSetPopulated(RowSetEvent event, int numRows) throws SQLException {
4735         throw new UnsupportedOperationException();
4736     }
4737 
4738     /**
4739      * Populates this {@code CachedRowSet} object with data from
4740      * the given {@code ResultSet} object. While related to the {@code populate(ResultSet)}
4741      * method, an additional parameter is provided to allow starting position within
4742      * the {@code ResultSet} from where to populate the CachedRowSet
4743      * instance.
4744      *
4745      * This method is an alternative to the method {@code execute}
4746      * for filling the rowset with data.  The method {@code populate}
4747      * does not require that the properties needed by the method
4748      * {@code execute}, such as the {@code command} property,
4749      * be set. This is true because the method {@code populate}
4750      * is given the {@code ResultSet} object from
4751      * which to get data and thus does not need to use the properties
4752      * required for setting up a connection and executing this
4753      * {@code CachedRowSetImpl} object&#39;s command.
4754      * &lt;P&gt;
4755      * After populating this rowset with data, the method
4756      * {@code populate} sets the rowset&#39;s metadata and
4757      * then sends a {@code RowSetChangedEvent} object
4758      * to all registered listeners prior to returning.
4759      *
4760      * @param data the {@code ResultSet} object containing the data
4761      *             to be read into this {@code CachedRowSetImpl} object
4762      * @param start the integer specifing the position in the
4763      *        {@code ResultSet} object to popultate the
4764      *        {@code CachedRowSetImpl} object.
4765      * @throws SQLException if an error occurs; or the max row setting is
4766      *          violated while populating the RowSet.Also id the start position
4767      *          is negative.
4768      * @see #execute
4769      */
4770      public void populate(ResultSet data, int start) throws SQLException{
4771         throw new UnsupportedOperationException();
4772 
4773      }
4774 
4775     /**
4776      * The nextPage gets the next page, that is a {@code CachedRowSetImpl} object
4777      * containing the number of rows specified by page size.
4778      * @return boolean value true indicating whether there are more pages to come and
4779      *         false indicating that this is the last page.
4780      * @throws SQLException if an error occurs or this called before calling populate.
4781      */
4782      public boolean nextPage() throws SQLException {
4783          throw new UnsupportedOperationException();
4784      }
4785 
4786     /**
4787      * This is the setter function for setting the size of the page, which specifies
4788      * how many rows have to be retrived at a time.
4789      *
4790      * @param size which is the page size
4791      * @throws SQLException if size is less than zero or greater than max rows.
4792      */
4793      public void setPageSize (int size) throws SQLException {
4794         throw new UnsupportedOperationException();
4795      }
4796 
4797     /**
4798      * This is the getter function for the size of the page.
4799      *
4800      * @return an integer that is the page size.
4801      */
4802     public int getPageSize() {
4803         throw new UnsupportedOperationException();
4804     }
4805 
4806 
4807     /**
4808      * Retrieves the data present in the page prior to the page from where it is
4809      * called.
4810      * @return boolean value true if it retrieves the previous page, flase if it
4811      *         is on the first page.
4812      * @throws SQLException if it is called before populate is called or ResultSet
4813      *         is of type {@code ResultSet.TYPE_FORWARD_ONLY} or if an error
4814      *         occurs.
4815      */
4816     public boolean previousPage() throws SQLException {
4817        throw new UnsupportedOperationException();
4818     }
4819 
4820     /**
4821        * Updates the designated column with a character stream value, which will
4822        * have the specified number of bytes. The driver does the necessary conversion
4823        * from Java character format to the national character set in the database.
4824        * It is intended for use when updating NCHAR, NVARCHAR and LONGNVARCHAR columns.
4825        * The updater methods are used to update column values in the current row or
4826        * the insert row. The updater methods do not update the underlying database;
4827        * instead the updateRow or insertRow methods are called to update the database.
4828        *
4829        * @param columnIndex - the first column is 1, the second is 2, ...
4830        * @param x - the new column value
4831        * @param length - the length of the stream
4832        * @exception SQLException if a database access error occurs
4833        * @since 1.6
4834        */
4835        public void updateNCharacterStream(int columnIndex,
4836                             java.io.Reader x,
4837                             int length)
4838                             throws SQLException {
4839           throw new UnsupportedOperationException(&quot;Operation not yet supported&quot;);
4840        }
4841 
4842      /**
4843        * Updates the designated column with a character stream value, which will
4844        * have the specified number of bytes. The driver does the necessary conversion
4845        * from Java character format to the national character set in the database.
4846        * It is intended for use when updating NCHAR,NVARCHAR and LONGNVARCHAR columns.
4847        * The updater methods are used to update column values in the current row or
4848        * the insert row. The updater methods do not update the underlying database;
4849        * instead the updateRow or insertRow methods are called to update the database.
4850        *
4851        * @param columnName - name of the Column
4852        * @param x - the new column value
4853        * @param length - the length of the stream
4854        * @exception SQLException if a database access error occurs
4855        * @since 1.6
4856        */
4857        public void updateNCharacterStream(String columnName,
4858                             java.io.Reader x,
4859                             int length)
4860                             throws SQLException {
4861           throw new UnsupportedOperationException(&quot;Operation not yet supported&quot;);
4862        }
4863 
4864       /**
4865        * This method re populates the resBundle
4866        * during the deserialization process
4867        *
4868        */
4869        private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
4870          // Default state initialization happens here
4871          ois.defaultReadObject();
4872          // Initialization of transient Res Bundle happens here .
4873          try {
4874             resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();
4875          } catch(IOException ioe) {
4876              throw new RuntimeException(ioe);
4877          }
4878 
4879        }
4880 
4881        static final long serialVersionUID = -3345004441725080251L;
4882 } //end class
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.sql.rowset/share/classes/com/sun/rowset/providers/package-info.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RIXMLProvider.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../javax/sql/rowset/BaseRowSet.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.sql.rowset/share/classes/com/sun/rowset/providers/package-info.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,88 ***</span>
   * questions.
   */
  
  /**
   *
<span class="line-modified">!  * Repository for the &lt;code&gt;RowSet&lt;/code&gt; reference implementations of the</span>
<span class="line-modified">!  * &lt;code&gt;SyncProvider&lt;/code&gt; abstract class. These implementations provide a</span>
<span class="line-modified">!  * disconnected &lt;code&gt;RowSet&lt;/code&gt;</span>
   * object with the ability to synchronize the data in the underlying data
   * source with its data.  These implementations are provided as
<span class="line-modified">!  * the default &lt;code&gt;SyncProvider&lt;/code&gt; implementations and are accessible via the</span>
<span class="line-modified">!  * &lt;code&gt;SyncProvider&lt;/code&gt; SPI managed by the &lt;code&gt;SyncFactory&lt;/code&gt;.</span>
   *
<span class="line-modified">!  * &lt;h2&gt;1.0 &lt;code&gt;SyncProvider&lt;/code&gt; Reference Implementations&lt;/h2&gt;</span>
<span class="line-modified">!  *   The main job of a &lt;code&gt;SyncProvider&lt;/code&gt; implementation is to manage</span>
   * the reader and writer mechanisms.
<span class="line-modified">!  *  The &lt;code&gt;SyncProvider&lt;/code&gt; SPI, as specified in the &lt;code&gt;javax.sql.rowset.spi&lt;/code&gt;</span>
<span class="line-modified">!  * package, provides a pluggable mechanism by which &lt;code&gt;javax.sql.RowSetReader&lt;/code&gt;</span>
<span class="line-modified">!  * and &lt;code&gt;javax.sql.RowSetWriter&lt;/code&gt; implementations can be supplied to a disconnected</span>
<span class="line-modified">!  * &lt;code&gt;RowSet&lt;/code&gt; object.</span>
   * &lt;P&gt;
<span class="line-modified">!  *  A reader, a &lt;code&gt;javax.sql.RowSetReader&lt;/code&gt;</span>
<span class="line-modified">!  * object, does the work necessary to populate a &lt;code&gt;RowSet&lt;/code&gt; object with data.</span>
<span class="line-modified">!  * A writer, a &lt;code&gt;javax.sql.RowSetWriter&lt;/code&gt; object, does the work necessary for</span>
<span class="line-modified">!  * synchronizing a &lt;code&gt;RowSet&lt;/code&gt; object&#39;s data with the data in the originating</span>
<span class="line-modified">!  * source of data. Put another way, a writer writes a &lt;code&gt;RowSet&lt;/code&gt;</span>
   * object&#39;s data back to the data source.
   * &lt;P&gt;
   * Generally speaking, the course of events is this.  The reader makes a connection to
<span class="line-modified">!  * the data source and reads the data from a &lt;code&gt;ResultSet&lt;/code&gt; object into its</span>
<span class="line-modified">!  * &lt;code&gt;RowSet&lt;/code&gt; object.  Then it closes the connection.  While</span>
<span class="line-modified">!  * the &lt;code&gt;RowSet&lt;/code&gt; object is disconnected, an application makes some modifications</span>
<span class="line-modified">!  * to the data and calls the method &lt;code&gt;acceptChanges&lt;/code&gt;. At this point, the</span>
   * writer is called to write the changes back to the database table or view
   * from which the original data came. This is called &lt;i&gt;synchronization&lt;/i&gt;.
   * &lt;P&gt;
   * If the data in the originating data source has not changed, there is no problem
<span class="line-modified">!  * with just writing the &lt;code&gt;RowSet&lt;/code&gt; object&#39;s new data to the data source.</span>
   * If it has changed, however, there is a conflict that needs to be resolved. One
   * way to solve the problem is not to let the data in the data source be changed in
   * the first place, which can be done by setting locks on a row, a table, or the
   * whole data source.  Setting locks is a way to avoid conflicts, but it can be
   * very expensive. Another approach, which is at the other end of the spectrum,
   *  is simply to assume that no conflicts will occur and thus do nothing to avoid
   * conflicts.
<span class="line-modified">!  * Different &lt;code&gt;SyncProvider&lt;/code&gt; implementations may handle synchronization in</span>
   * any of these ways, varying from doing no checking for
   * conflicts, to doing various levels of checking, to guaranteeing that there are no
   * conflicts.
   * &lt;P&gt;
<span class="line-modified">!  * The &lt;code&gt;SyncProvider&lt;/code&gt; class offers methods to help a &lt;code&gt;RowSet&lt;/code&gt;</span>
   * object discover and manage how a provider handles synchronization.
<span class="line-modified">!  * The method &lt;code&gt;getProviderGrade&lt;/code&gt; returns the</span>
   * grade of synchronization a provider offers. An application can
   * direct the provider to use a particular level of locking by calling
<span class="line-modified">!  * the method &lt;code&gt;setDataSourceLock&lt;/code&gt; and specifying the level of locking desired.</span>
<span class="line-modified">!  * If a &lt;code&gt;RowSet&lt;/code&gt; object&#39;s data came from an SQL &lt;code&gt;VIEW&lt;/code&gt;, an</span>
<span class="line-modified">!  * application may call the method &lt;code&gt;supportsUpdatableView&lt;/code&gt; to</span>
<span class="line-modified">!  * find out whether the &lt;code&gt;VIEW&lt;/code&gt; can be updated.</span>
   * &lt;P&gt;
   * Synchronization is done completely behind the scenes, so it is third party vendors of
   * synchronization provider implementations who have to take care of this complex task.
   * Application programmers can decide which provider to use and the level of locking to
   * be done, but they are free from having to worry about the implementation details.
   * &lt;P&gt;
<span class="line-modified">!  * The JDBC &lt;code&gt;RowSet&lt;/code&gt; Implementations reference implementation provides two</span>
<span class="line-modified">!  * implementations of the &lt;code&gt;SyncProvider&lt;/code&gt; class:</span>
   *
   * &lt;UL&gt;
   * &lt;LI&gt;
<span class="line-modified">!  * &lt;b&gt;&lt;code&gt;RIOptimisticProvider&lt;/code&gt;&lt;/b&gt; - provides the &lt;code&gt;javax.sql.RowSetReader&lt;/code&gt;</span>
<span class="line-modified">!  * and &lt;code&gt;javax.sql.RowSetWriter&lt;/code&gt; interface implementations and provides</span>
   * an optimistic concurrency model for synchronization. This model assumes that there
   * will be few conflicts and therefore uses a relatively low grade of synchronization.
   * If no other provider is available, this is the default provider that the
<span class="line-modified">!  * &lt;code&gt;SyncFactory&lt;/code&gt; will supply to a &lt;code&gt;RowSet&lt;/code&gt; object.</span>
   *     &lt;br&gt;
   * &lt;LI&gt;
<span class="line-modified">!  * &lt;b&gt;&lt;code&gt;RIXMLProvider&lt;/code&gt;&lt;/b&gt; - provides the &lt;code&gt;XmlReader&lt;/code&gt; (an extension</span>
<span class="line-modified">!  * of the &lt;code&gt;javax.sql.RowSetReader&lt;/code&gt; interface) and the &lt;code&gt;XmlWriter&lt;/code&gt;</span>
<span class="line-modified">!  * (an extension of the &lt;code&gt;javax.sql.RowSetWriter&lt;/code&gt; interface) to enable</span>
<span class="line-modified">!  * &lt;code&gt;WebRowSet&lt;/code&gt; objects to write their state to a</span>
<span class="line-modified">!  * well formed XML document according to the &lt;code&gt;WebRowSet&lt;/code&gt; XML schema</span>
   * definition.&lt;br&gt;
   * &lt;/UL&gt;
   *
   * &lt;h2&gt;2.0 Basics in RowSet Population &amp;amp; Synchronization&lt;/h2&gt;
   * A rowset&#39;s first task is to populate itself with rows of column values.
<span class="line-new-header">--- 23,88 ---</span>
   * questions.
   */
  
  /**
   *
<span class="line-modified">!  * Repository for the {@code RowSet} reference implementations of the</span>
<span class="line-modified">!  * {@code SyncProvider} abstract class. These implementations provide a</span>
<span class="line-modified">!  * disconnected {@code RowSet}</span>
   * object with the ability to synchronize the data in the underlying data
   * source with its data.  These implementations are provided as
<span class="line-modified">!  * the default {@code SyncProvider} implementations and are accessible via the</span>
<span class="line-modified">!  * {@code SyncProvider} SPI managed by the {@code SyncFactory}.</span>
   *
<span class="line-modified">!  * &lt;h2&gt;1.0 {@code SyncProvider} Reference Implementations&lt;/h2&gt;</span>
<span class="line-modified">!  *   The main job of a {@code SyncProvider} implementation is to manage</span>
   * the reader and writer mechanisms.
<span class="line-modified">!  *  The {@code SyncProvider} SPI, as specified in the {@code javax.sql.rowset.spi}</span>
<span class="line-modified">!  * package, provides a pluggable mechanism by which {@code javax.sql.RowSetReader}</span>
<span class="line-modified">!  * and {@code javax.sql.RowSetWriter} implementations can be supplied to a disconnected</span>
<span class="line-modified">!  * {@code RowSet} object.</span>
   * &lt;P&gt;
<span class="line-modified">!  *  A reader, a {@code javax.sql.RowSetReader}</span>
<span class="line-modified">!  * object, does the work necessary to populate a {@code RowSet} object with data.</span>
<span class="line-modified">!  * A writer, a {@code javax.sql.RowSetWriter} object, does the work necessary for</span>
<span class="line-modified">!  * synchronizing a {@code RowSet} object&#39;s data with the data in the originating</span>
<span class="line-modified">!  * source of data. Put another way, a writer writes a {@code RowSet}</span>
   * object&#39;s data back to the data source.
   * &lt;P&gt;
   * Generally speaking, the course of events is this.  The reader makes a connection to
<span class="line-modified">!  * the data source and reads the data from a {@code ResultSet} object into its</span>
<span class="line-modified">!  * {@code RowSet} object.  Then it closes the connection.  While</span>
<span class="line-modified">!  * the {@code RowSet} object is disconnected, an application makes some modifications</span>
<span class="line-modified">!  * to the data and calls the method {@code acceptChanges}. At this point, the</span>
   * writer is called to write the changes back to the database table or view
   * from which the original data came. This is called &lt;i&gt;synchronization&lt;/i&gt;.
   * &lt;P&gt;
   * If the data in the originating data source has not changed, there is no problem
<span class="line-modified">!  * with just writing the {@code RowSet} object&#39;s new data to the data source.</span>
   * If it has changed, however, there is a conflict that needs to be resolved. One
   * way to solve the problem is not to let the data in the data source be changed in
   * the first place, which can be done by setting locks on a row, a table, or the
   * whole data source.  Setting locks is a way to avoid conflicts, but it can be
   * very expensive. Another approach, which is at the other end of the spectrum,
   *  is simply to assume that no conflicts will occur and thus do nothing to avoid
   * conflicts.
<span class="line-modified">!  * Different {@code SyncProvider} implementations may handle synchronization in</span>
   * any of these ways, varying from doing no checking for
   * conflicts, to doing various levels of checking, to guaranteeing that there are no
   * conflicts.
   * &lt;P&gt;
<span class="line-modified">!  * The {@code SyncProvider} class offers methods to help a {@code RowSet}</span>
   * object discover and manage how a provider handles synchronization.
<span class="line-modified">!  * The method {@code getProviderGrade} returns the</span>
   * grade of synchronization a provider offers. An application can
   * direct the provider to use a particular level of locking by calling
<span class="line-modified">!  * the method {@code setDataSourceLock} and specifying the level of locking desired.</span>
<span class="line-modified">!  * If a {@code RowSet} object&#39;s data came from an SQL {@code VIEW}, an</span>
<span class="line-modified">!  * application may call the method {@code supportsUpdatableView} to</span>
<span class="line-modified">!  * find out whether the {@code VIEW} can be updated.</span>
   * &lt;P&gt;
   * Synchronization is done completely behind the scenes, so it is third party vendors of
   * synchronization provider implementations who have to take care of this complex task.
   * Application programmers can decide which provider to use and the level of locking to
   * be done, but they are free from having to worry about the implementation details.
   * &lt;P&gt;
<span class="line-modified">!  * The JDBC {@code RowSet} Implementations reference implementation provides two</span>
<span class="line-modified">!  * implementations of the {@code SyncProvider} class:</span>
   *
   * &lt;UL&gt;
   * &lt;LI&gt;
<span class="line-modified">!  * &lt;b&gt;{@code RIOptimisticProvider}&lt;/b&gt; - provides the {@code javax.sql.RowSetReader}</span>
<span class="line-modified">!  * and {@code javax.sql.RowSetWriter} interface implementations and provides</span>
   * an optimistic concurrency model for synchronization. This model assumes that there
   * will be few conflicts and therefore uses a relatively low grade of synchronization.
   * If no other provider is available, this is the default provider that the
<span class="line-modified">!  * {@code SyncFactory} will supply to a {@code RowSet} object.</span>
   *     &lt;br&gt;
   * &lt;LI&gt;
<span class="line-modified">!  * &lt;b&gt;{@code RIXMLProvider}&lt;/b&gt; - provides the {@code XmlReader} (an extension</span>
<span class="line-modified">!  * of the {@code javax.sql.RowSetReader} interface) and the {@code XmlWriter}</span>
<span class="line-modified">!  * (an extension of the {@code javax.sql.RowSetWriter} interface) to enable</span>
<span class="line-modified">!  * {@code WebRowSet} objects to write their state to a</span>
<span class="line-modified">!  * well formed XML document according to the {@code WebRowSet} XML schema</span>
   * definition.&lt;br&gt;
   * &lt;/UL&gt;
   *
   * &lt;h2&gt;2.0 Basics in RowSet Population &amp;amp; Synchronization&lt;/h2&gt;
   * A rowset&#39;s first task is to populate itself with rows of column values.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,16 ***</span>
   * a tabular file instead of a relational database, does not need to have these
   * properties set. The vast  majority of RowSets, however, do need to set these
   * properties. The general  rule is that a RowSet is required to set only the
   * properties that it uses.&lt;br&gt;
   *     &lt;br&gt;
<span class="line-modified">!  * The &lt;code&gt;command&lt;/code&gt; property contains the query that determines what</span>
<span class="line-modified">!  * data  a &lt;code&gt;RowSet&lt;/code&gt; will contain. Rowsets have methods for setting a query&#39;s</span>
   * parameter(s),  which means that a query can be executed multiple times with
   * different parameters  to produce different result sets. Or the query can be
   * changed to something  completely new to get a new result set.
<span class="line-modified">!  * &lt;p&gt;Once a rowset contains the rows from a &lt;code&gt;ResultSet&lt;/code&gt; object or some</span>
   * other data source, its column values can be updated, and its rows can be
   * inserted or deleted. Any method that causes a change in the rowset&#39;s values
   * or cursor position also notifies any object that has been registered as
   * a listener with the rowset. So, for example, a table that displays the rowset&#39;s
   * data in an applet can be notified of changes and make updates as they
<span class="line-new-header">--- 115,16 ---</span>
   * a tabular file instead of a relational database, does not need to have these
   * properties set. The vast  majority of RowSets, however, do need to set these
   * properties. The general  rule is that a RowSet is required to set only the
   * properties that it uses.&lt;br&gt;
   *     &lt;br&gt;
<span class="line-modified">!  * The {@code command} property contains the query that determines what</span>
<span class="line-modified">!  * data  a {@code RowSet} will contain. Rowsets have methods for setting a query&#39;s</span>
   * parameter(s),  which means that a query can be executed multiple times with
   * different parameters  to produce different result sets. Or the query can be
   * changed to something  completely new to get a new result set.
<span class="line-modified">!  * &lt;p&gt;Once a rowset contains the rows from a {@code ResultSet} object or some</span>
   * other data source, its column values can be updated, and its rows can be
   * inserted or deleted. Any method that causes a change in the rowset&#39;s values
   * or cursor position also notifies any object that has been registered as
   * a listener with the rowset. So, for example, a table that displays the rowset&#39;s
   * data in an applet can be notified of changes and make updates as they
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,27 ***</span>
   *     &lt;br&gt;
   * The changes made to a rowset can be propagated back to the original data
   * source to keep the rowset and its data source synchronized. Although this
   * involves many operations behind the scenes, it is completely transparent
   * to the application programmer and remains the concern of the RowSet provider
<span class="line-modified">!  * developer. All an application has to do is invoke the method &lt;code&gt;acceptChanges&lt;/code&gt;,</span>
   * and the data source backing the rowset will be updated to match the current
   * values in the rowset. &lt;/p&gt;
   *
<span class="line-modified">!  * &lt;p&gt;A disconnected rowset, such as a &lt;code&gt;CachedRowSet&lt;/code&gt; or &lt;code&gt;WebRowSet&lt;/code&gt;</span>
   *  object, establishes a connection to populate itself with data from a database
<span class="line-modified">!  *  and then closes the connection. The &lt;code&gt;RowSet&lt;/code&gt; object will remain</span>
   *  disconnected until it wants to propagate changes back to its database table,
   *  which is optional. To write its changes back to the database (synchronize with
   *  the database), the rowset establishes a connection, write the changes, and then
   *  once again disconnects itself.&lt;br&gt;
   *   &lt;/p&gt;
   *
   * &lt;h2&gt; 3.0 Other Possible Implementations&lt;/h2&gt;
<span class="line-modified">!  *  There are many other possible implementations of the &lt;code&gt;SyncProvider&lt;/code&gt; abstract</span>
   *  class. One possibility is to employ a more robust synchronization model, which
<span class="line-modified">!  *  would give a &lt;code&gt;RowSet&lt;/code&gt; object increased trust in the provider&#39;s</span>
   *  ability to get any updates back to the original data source. Another possibility
   *  is a more formal synchronization mechanism such as SyncML
   *  (&lt;a href=&quot;http://www.syncml.org/&quot;&gt;http://www.syncml.org/&lt;/a&gt;)   &lt;br&gt;
   */
  package com.sun.rowset.providers;
<span class="line-new-header">--- 132,27 ---</span>
   *     &lt;br&gt;
   * The changes made to a rowset can be propagated back to the original data
   * source to keep the rowset and its data source synchronized. Although this
   * involves many operations behind the scenes, it is completely transparent
   * to the application programmer and remains the concern of the RowSet provider
<span class="line-modified">!  * developer. All an application has to do is invoke the method {@code acceptChanges},</span>
   * and the data source backing the rowset will be updated to match the current
   * values in the rowset. &lt;/p&gt;
   *
<span class="line-modified">!  * &lt;p&gt;A disconnected rowset, such as a {@code CachedRowSet} or {@code WebRowSet}</span>
   *  object, establishes a connection to populate itself with data from a database
<span class="line-modified">!  *  and then closes the connection. The {@code RowSet} object will remain</span>
   *  disconnected until it wants to propagate changes back to its database table,
   *  which is optional. To write its changes back to the database (synchronize with
   *  the database), the rowset establishes a connection, write the changes, and then
   *  once again disconnects itself.&lt;br&gt;
   *   &lt;/p&gt;
   *
   * &lt;h2&gt; 3.0 Other Possible Implementations&lt;/h2&gt;
<span class="line-modified">!  *  There are many other possible implementations of the {@code SyncProvider} abstract</span>
   *  class. One possibility is to employ a more robust synchronization model, which
<span class="line-modified">!  *  would give a {@code RowSet} object increased trust in the provider&#39;s</span>
   *  ability to get any updates back to the original data source. Another possibility
   *  is a more formal synchronization mechanism such as SyncML
   *  (&lt;a href=&quot;http://www.syncml.org/&quot;&gt;http://www.syncml.org/&lt;/a&gt;)   &lt;br&gt;
   */
  package com.sun.rowset.providers;
</pre>
<center><a href="RIXMLProvider.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../javax/sql/rowset/BaseRowSet.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
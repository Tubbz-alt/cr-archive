<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.sql.rowset/share/classes/com/sun/rowset/internal/SyncResolverImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.rowset.internal;
  27 
  28 import java.sql.*;
  29 import javax.sql.*;
  30 import java.util.*;
  31 import java.math.BigDecimal;
  32 
  33 import javax.sql.rowset.*;
  34 import javax.sql.rowset.spi.*;
  35 
  36 import com.sun.rowset.*;
  37 import java.io.IOException;
  38 import java.io.ObjectInputStream;
  39 
  40 /**
  41  * There will be two sets of data which will be maintained by the rowset at the
  42  * time of synchronization. The {@code SyncProvider} will utilize the
  43  * {@code SyncResolver} to synchronize the changes back to database.
  44  */
  45 public class SyncResolverImpl extends CachedRowSetImpl implements SyncResolver {
  46     /**
  47      * This CachedRowSet object will encapsulate a rowset
  48      * which will be sync&#39;ed with the datasource but will
  49      * contain values in rows where there is conflict.
  50      * For rows other than conflict, it will *not* contain
  51      * any data. For rows containing conflict it will
  52      * return either of the three values set by SyncResolver.*_CONFLICT
  53      * from getStatus()
  54      */
  55     private CachedRowSetImpl crsRes;
  56 
  57     /**
  58      * This is the actual CachedRowSet object
  59      * which is being synchronized back to
  60      * datasource.
  61      */
  62     private CachedRowSetImpl crsSync;
  63 
  64     /**
  65      *  This ArrayList will contain the status of a row
  66      *  from the SyncResolver.* values else it will be null.
  67      */
  68     private ArrayList&lt;?&gt; stats;
  69 
  70     /**
  71      * The RowSetWriter associated with the original
  72      * CachedRowSet object which is being synchronized.
  73      */
  74     private CachedRowSetWriter crw;
  75 
  76     /**
  77      * Row number identifier
  78      */
  79     private int rowStatus;
  80 
  81     /**
  82      * This will contain the size of the {@code CachedRowSet} object
  83      */
  84     private int sz;
  85 
  86     /**
  87      * The {@code Connection} handle used to synchronize the changes
  88      * back to datasource. This is the same connection handle as was passed
  89      * to the CachedRowSet while fetching the data.
  90      */
  91     private transient Connection con;
  92 
  93     /**
  94      * The {@code CachedRowSet} object which will encapsulate
  95      * a row at any time. This will be built from CachedRowSet and
  96      * SyncResolver values. Synchronization takes place on a row by
  97      * row basis encapsulated as a CahedRowSet.
  98      */
  99     private CachedRowSet row;
 100 
 101     private JdbcRowSetResourceBundle resBundle;
 102 
 103     /**
 104      * Public constructor
 105      */
 106     public SyncResolverImpl() throws SQLException {
 107         try {
 108             crsSync = new CachedRowSetImpl();
 109             crsRes = new CachedRowSetImpl();
 110             crw = new CachedRowSetWriter();
 111             row = new CachedRowSetImpl();
 112             rowStatus = 1;
 113             try {
 114                 resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();
 115             } catch(IOException ioe) {
 116                 throw new RuntimeException(ioe);
 117             }
 118 
 119         } catch(SQLException sqle) {
 120         }
 121      }
 122 
 123 
 124     /**
 125      * Retrieves the conflict status of the current row of this
 126      * {@code SyncResolver}, which indicates the operationthe {@code RowSet}
 127      * object was attempting when the conflict occurred.
 128      *
 129      * @return one of the following constants:
 130      *         {@code SyncResolver.UPDATE_ROW_CONFLICT},
 131      *         {@code SyncResolver.DELETE_ROW_CONFLICT}, or
 132      *         {@code SyncResolver.INSERT_ROW_CONFLICT}
 133      */
 134     public int getStatus() {
 135         return ((Integer)stats.get(rowStatus-1)).intValue();
 136     }
 137 
 138     /**
 139      * Retrieves the value in the designated column in the current row of this
 140      * {@code SyncResolver} object, which is the value that caused a conflict.
 141      *
 142      * @param index {@code int} designating the column in this row of this
 143      *        {@code SyncResolver} object from which to retrieve the value
 144      *        causing a conflict
 145      */
 146     public Object getConflictValue(int index) throws SQLException {
 147         try {
 148              return crsRes.getObject(index);
 149         } catch(SQLException sqle) {
 150             throw new SQLException(sqle.getMessage());
 151         }
 152     }
 153 
 154     /**
 155      * Retrieves the value in the designated column in the current row of this
 156      * {@code SyncResolver} object, which is the value that caused a conflict.
 157      *
 158      * @param columnName a {@code String} object designating the column in this row of this
 159      *        {@code SyncResolver} object from which to retrieve the value
 160      *        causing a conflict
 161      */
 162     public Object getConflictValue(String columnName) throws SQLException {
 163         try {
 164              return crsRes.getObject(columnName);
 165         } catch(SQLException sqle) {
 166              throw new SQLException(sqle.getMessage());
 167         }
 168     }
 169 
 170     /**
 171      * Sets &lt;i&gt;obj&lt;/i&gt; as the value in column &lt;i&gt;index&lt;/i&gt; in the current row of the
 172      * {@code RowSet} object. This value is the resolved value that is to be
 173      * persisted in the data source.
 174      *
 175      * @param index an {@code int} giving the number of the column into which to
 176      *        set the value to be persisted
 177      * @param obj an {@code Object} that is the value to be set in the data source
 178      */
 179     public void setResolvedValue(int index, Object obj) throws SQLException {
 180         // modify method to throw SQLException in spec
 181 
 182         /**
 183          * When a value is resolved properly make it to null
 184          * inside crsRes for that column.
 185          *
 186          * For more than one conflicts in the row,
 187          * check for the last resolved value of the current row
 188          * (Note: it can be resolved randomly for same row)
 189          * then sync back immediately.
 190          **/
 191         try {
 192             // check whether the index is in range
 193             if(index&lt;=0 || index &gt; crsSync.getMetaData().getColumnCount() ) {
 194                 throw new SQLException(resBundle.handleGetObject(&quot;syncrsimpl.indexval&quot;).toString()+ index);
 195             }
 196              // check whether index col is in conflict
 197             if(crsRes.getObject(index) == null) {
 198                 throw new SQLException(resBundle.handleGetObject(&quot;syncrsimpl.noconflict&quot;).toString());
 199             }
 200         } catch (SQLException sqle) {
 201             // modify method to throw for SQLException
 202             throw new SQLException(sqle.getMessage());
 203         }
 204         try {
 205              boolean bool = true;
 206              /** Check resolved value to be either of conflict
 207                * or in rowset else throw sql exception.
 208                * If we allow a value other than that in CachedRowSet or
 209                * datasource we will end up in looping the loop of exceptions.
 210               **/
 211 
 212              if( ((crsSync.getObject(index)).toString()).equals(obj.toString()) ||
 213                      ((crsRes.getObject(index)).toString()).equals(obj.toString()) ) {
 214 
 215                 /**
 216                  * Check whether this is the only conflict in the row.
 217                  * If yes, synchronize this row back
 218                  * which has been resolved, else wait
 219                  * for all conflicts of current row to be resolved
 220                  *
 221                  * Step 1: Update crsRes and make the index col as null
 222                  * i.e. resolved
 223                  * crsRes.updateObject(index, obj);
 224                  **/
 225                   crsRes.updateNull(index);
 226                   crsRes.updateRow();
 227 
 228                  /**
 229                   * Step 2: Change the value in the CachedRowSetImpl object
 230                   * crsSync.updateObject(index, obj);
 231                   * crsSync.updateRow();
 232                   **/
 233                  if(row.size() != 1) {
 234                     row = buildCachedRow();
 235                  }
 236 
 237                  row.updateObject(index, obj);
 238                  row.updateRow();
 239 
 240                  for(int j=1; j &lt; crsRes.getMetaData().getColumnCount(); j++) {
 241                      if(crsRes.getObject(j) != null) {
 242                         bool = false;
 243                         break;
 244                          // break out of loop and wait for other cols
 245                          // in same row to get resolved
 246                      } //end if
 247 
 248                   } //end for
 249 
 250                   if(bool) {
 251                      /**
 252                       * sync data back using CachedRowSetWriter
 253                       * construct the present row and pass it to the writer
 254                       * to write back to db.
 255                       **/
 256                      try {
 257                            /**
 258                             * Note : The use of CachedRowSetWriter to get *same* Connection handle.
 259                             * The CachedRowSetWriter uses the connection handle
 260                             * from the reader, Hence will use the same connection handle
 261                             * as of original CachedRowSetImpl
 262                             **/
 263 
 264                           writeData(row);
 265 
 266                           //crw.writeData( (RowSetInternal)crsRow);
 267                           //System.out.printlnt.println(&quot;12&quot;);
 268 
 269                      } catch(SyncProviderException spe) {
 270                          /**
 271                           * This will occur if db is not allowing
 272                           * even after resolving the conflicts
 273                           * due to some reasons.
 274                           * Also will prevent from going into a loop of SPE&#39;s
 275                           **/
 276                          throw new SQLException(resBundle.handleGetObject(&quot;syncrsimpl.syncnotpos&quot;).toString());
 277                      }
 278                   } //end if(bool)
 279 
 280              } else {
 281                  throw new SQLException(resBundle.handleGetObject(&quot;syncrsimpl.valtores&quot;).toString());
 282              } //end if (crs.getObject ...) block
 283 
 284 
 285         } catch(SQLException sqle) {
 286            throw new SQLException(sqle.getMessage());
 287         }
 288     }
 289 
 290     /**
 291      * This passes a CachedRowSet as a row to the CachedRowSetWriter
 292      * after the values have been resolved, back to the datasource.
 293      *
 294      * @param row a {@code CachedRowSet} object which will hold the
 295      *        values of a particular row after they have been resolved by
 296      *        the user to synchronize back to datasource.
 297      * @throws SQLException if synchronization does not happen properly
 298      *         maybe beacuse {@code Connection} has timed out.
 299      **/
 300      private void writeData(CachedRowSet row) throws SQLException {
 301         crw.updateResolvedConflictToDB(row, crw.getReader().connect((RowSetInternal)crsSync));
 302      }
 303 
 304     /**
 305      * This function builds a row  as a {@code CachedRowSet} object
 306      * which has been resolved and is ready to be synchrinized to the datasource
 307      *
 308      * @throws SQLException if there is problem in building
 309      *         the metadata of the row.
 310      **/
 311      private CachedRowSet buildCachedRow() throws SQLException {
 312        int iColCount;
 313        CachedRowSetImpl crsRow = new CachedRowSetImpl();
 314 
 315        RowSetMetaDataImpl rsmd = new RowSetMetaDataImpl();
 316        RowSetMetaDataImpl rsmdWrite = (RowSetMetaDataImpl)crsSync.getMetaData();
 317        RowSetMetaDataImpl rsmdRow = new RowSetMetaDataImpl();
 318 
 319        iColCount = rsmdWrite.getColumnCount();
 320        rsmdRow.setColumnCount(iColCount);
 321 
 322        for(int i =1;i&lt;=iColCount;i++) {
 323           rsmdRow.setColumnType(i,rsmdWrite.getColumnType(i));
 324           rsmdRow.setColumnName(i,rsmdWrite.getColumnName(i));
 325           rsmdRow.setNullable(i,ResultSetMetaData.columnNullableUnknown);
 326 
 327           try {
 328              rsmdRow.setCatalogName(i, rsmdWrite.getCatalogName(i));
 329              rsmdRow.setSchemaName(i, rsmdWrite.getSchemaName(i));
 330           } catch(SQLException e) {
 331                e.printStackTrace();
 332           }
 333         } //end for
 334 
 335        crsRow.setMetaData(rsmdRow);
 336 
 337        crsRow.moveToInsertRow();
 338 
 339        for(int col=1;col&lt;=crsSync.getMetaData().getColumnCount();col++) {
 340            crsRow.updateObject(col, crsSync.getObject(col));
 341        }
 342 
 343        crsRow.insertRow();
 344        crsRow.moveToCurrentRow();
 345 
 346        crsRow.absolute(1);
 347        crsRow.setOriginalRow();
 348 
 349       try {
 350           crsRow.setUrl(crsSync.getUrl());
 351       } catch(SQLException sqle) {
 352 
 353       }
 354 
 355       try {
 356           crsRow.setDataSourceName(crsSync.getCommand());
 357        } catch(SQLException sqle) {
 358 
 359        }
 360 
 361        try {
 362            if(crsSync.getTableName()!= null){
 363               crsRow.setTableName(crsSync.getTableName());
 364            }
 365         } catch(SQLException sqle) {
 366 
 367         }
 368 
 369        try {
 370             if(crsSync.getCommand() != null)
 371                 crsRow.setCommand(crsSync.getCommand());
 372        } catch(SQLException sqle) {
 373 
 374        }
 375 
 376        try {
 377             crsRow.setKeyColumns(crsSync.getKeyColumns());
 378        } catch(SQLException sqle) {
 379 
 380        }
 381        return crsRow;
 382     }
 383 
 384 
 385 
 386     /**
 387      * Sets &lt;i&gt;obj&lt;/i&gt; as the value in column &lt;i&gt;columnName&lt;/i&gt; in the current row of the
 388      * {@code RowSet} object. This value is the resolved value that is to be
 389      * persisted in the data source.
 390      *
 391      * @param columnName a {@code String} object giving the name of the column
 392      *        into which to set the value to be persisted
 393      * @param obj an {@code Object} that is the value to be set in the data source
 394      */
 395     public void setResolvedValue(String columnName, Object obj) throws SQLException {
 396        // modify method to throw SQLException in spec
 397        // %%% Missing implementation!
 398     }
 399 
 400     /**
 401      * This function is package private,
 402      * i.e. cannot be accesses outside this package.
 403      * This is used to set the actual CachedRowSet
 404      * which is being synchronized to the database
 405      **/
 406    void setCachedRowSet(CachedRowSet crs) {
 407            crsSync = (CachedRowSetImpl)crs;
 408     }
 409 
 410     /**
 411      * This function is package private,
 412      * i.e. cannot be accesses outside this package.
 413      * This is used to set the CachedRowSet formed
 414      * with conflict values.
 415      **/
 416     void setCachedRowSetResolver(CachedRowSet crs){
 417          try {
 418               crsRes = (CachedRowSetImpl)crs;
 419               crsRes.afterLast();
 420               sz = crsRes.size();
 421          } catch (SQLException sqle) {
 422             // do nothing
 423          }
 424     }
 425 
 426     /**
 427      * This function is package private,
 428      * i.e. cannot be accesses outside this package.
 429      * This is used to set the status of each row
 430      * to either of the values SyncResolver.*_CONFLICT
 431      **/
 432     @SuppressWarnings(&quot;rawtypes&quot;)
 433     void setStatus(ArrayList status){
 434              stats = status;
 435     }
 436 
 437     /**
 438      * This function is package private,
 439      * i.e. cannot be accesses outside this package.
 440      * This is used to set the handle to the writer object
 441      * which will write the resolved values back to datasource
 442      **/
 443     void setCachedRowSetWriter(CachedRowSetWriter CRWriter) {
 444          crw = CRWriter;
 445     }
 446 
 447     /**
 448      * Moves the cursor down one row from its current position. A {@code SyncResolver}
 449      * cursor is initially positioned before the first conflict row; the first call to the
 450      * method {@code nextConflict()} makes the first conflict row the current row;
 451      * the second call makes the second conflict row the current row, and so on.
 452      * &lt;p&gt;
 453      * If an input stream is open for the current row, a call to the method next will
 454      * implicitly close it. A {@code SyncResolver} object&#39;s warning chain is cleared
 455      * when a new row
 456      *
 457      * @return true if the new current row is valid; false if there are no more rows
 458      * @throws SQLException if a database access occurs
 459      *
 460      */
 461     public boolean nextConflict() throws SQLException {
 462         /**
 463           * The next() method will hop from
 464           * one conflict to another
 465           *
 466           * Internally do a crs.next() until
 467           * next conflict.
 468           **/
 469       boolean bool = false;
 470 
 471       crsSync.setShowDeleted(true);
 472       while(crsSync.next()) {
 473            crsRes.previous();
 474            rowStatus++;  //sz--;
 475 
 476           if((rowStatus-1) &gt;= stats.size()) {
 477              bool = false;
 478              break;
 479           }
 480 
 481           if(((Integer)stats.get(rowStatus-1)).intValue() == SyncResolver.NO_ROW_CONFLICT) {
 482               // do nothing
 483               // bool remains as false
 484              ;
 485            } else {
 486              bool = true;
 487              break;
 488            } //end if
 489 
 490       } //end while
 491 
 492         crsSync.setShowDeleted(false);
 493         return bool;
 494    } // end next() method
 495 
 496 
 497     /**
 498      * Moves the cursor to the previous conflict row in this {@code SyncResolver} object.
 499      *
 500      * @return {@code true} if the cursor is on a valid row; {@code false}
 501      *     if it is off the result set
 502      * @throws SQLException if a database access error occurs or the result set type
 503      *     is TYPE_FORWARD_ONLY
 504      */
 505    public boolean previousConflict() throws SQLException {
 506        throw new UnsupportedOperationException();
 507    }
 508 
 509     //-----------------------------------------------------------------------
 510     // Properties
 511     //-----------------------------------------------------------------------
 512 
 513     /**
 514      * Sets this {@code CachedRowSetImpl} object&#39;s command property
 515      * to the given {@code String} object and clears the parameters,
 516      * if any, that were set for the previous command.
 517      * &lt;P&gt;
 518      * The command property may not be needed
 519      * if the rowset is produced by a data source, such as a spreadsheet,
 520      * that does not support commands. Thus, this property is optional
 521      * and may be {@code null}.
 522      *
 523      * @param cmd a {@code String} object containing an SQL query
 524      *            that will be set as the command; may be {@code null}
 525      * @throws SQLException if an error occurs
 526      */
 527     public void setCommand(String cmd) throws SQLException {
 528          throw new UnsupportedOperationException();
 529     }
 530 
 531 
 532     //---------------------------------------------------------------------
 533     // Reading and writing data
 534     //---------------------------------------------------------------------
 535 
 536     /**
 537      * Populates this {@code CachedRowSetImpl} object with data from
 538      * the given {@code ResultSet} object.  This
 539      * method is an alternative to the method {@code execute}
 540      * for filling the rowset with data.  The method {@code populate}
 541      * does not require that the properties needed by the method
 542      * {@code execute}, such as the {@code command} property,
 543      * be set. This is true because the method {@code populate}
 544      * is given the {@code ResultSet} object from
 545      * which to get data and thus does not need to use the properties
 546      * required for setting up a connection and executing this
 547      * {@code CachedRowSetImpl} object&#39;s command.
 548      * &lt;P&gt;
 549      * After populating this rowset with data, the method
 550      * {@code populate} sets the rowset&#39;s metadata and
 551      * then sends a {@code RowSetChangedEvent} object
 552      * to all registered listeners prior to returning.
 553      *
 554      * @param data the {@code ResultSet} object containing the data
 555      *             to be read into this {@code CachedRowSetImpl} object
 556      * @throws SQLException if an error occurs; or the max row setting is
 557      *          violated while populating the RowSet
 558      * @see #execute
 559      */
 560     public void populate(ResultSet data) throws SQLException {
 561          throw new UnsupportedOperationException();
 562     }
 563 
 564     /**
 565      * Populates this {@code CachedRowSetImpl} object with data,
 566      * using the given connection to produce the result set from
 567      * which data will be read.  A second form of this method,
 568      * which takes no arguments, uses the values from this rowset&#39;s
 569      * user, password, and either url or data source properties to
 570      * create a new database connection. The form of {@code execute}
 571      * that is given a connection ignores these properties.
 572      *
 573      * @param conn A standard JDBC {@code Connection} object that this
 574      * {@code CachedRowSet} object can pass to a synchronization provider
 575      * to establish a connection to the data source
 576      * @throws SQLException if an invalid {@code Connection} is supplied
 577      *           or an error occurs in establishing the connection to the
 578      *           data source
 579      * @see #populate
 580      * @see java.sql.Connection
 581      */
 582     public void execute(Connection conn) throws SQLException {
 583         throw new UnsupportedOperationException();
 584     }
 585 
 586     /**
 587      * Propagates all row update, insert, and delete changes to the
 588      * underlying data source backing this {@code CachedRowSetImpl}
 589      * object.
 590      * &lt;P&gt;
 591      * &lt;b&gt;Note&lt;/b&gt;In the reference implementation an optimistic concurrency implementation
 592      * is provided as a sample implementation of a the {@code SyncProvider}
 593      * abstract class.
 594      * &lt;P&gt;
 595      * This method fails if any of the updates cannot be propagated back
 596      * to the data source.  When it fails, the caller can assume that
 597      * none of the updates are reflected in the data source.
 598      * When an exception is thrown, the current row
 599      * is set to the first &quot;updated&quot; row that resulted in an exception
 600      * unless the row that caused the exception is a &quot;deleted&quot; row.
 601      * In that case, when deleted rows are not shown, which is usually true,
 602      * the current row is not affected.
 603      * &lt;P&gt;
 604      * If no {@code SyncProvider} is configured, the reference implementation
 605      * leverages the {@code RIOptimisticProvider} available which provides the
 606      * default and reference synchronization capabilities for disconnected
 607      * {@code RowSets}.
 608      *
 609      * @throws SQLException if the cursor is on the insert row or the underlying
 610      *          reference synchronization provider fails to commit the updates
 611      *          to the datasource
 612      * @throws SyncProviderException if an internal error occurs within the
 613      *          {@code SyncProvider} instance during either during the
 614      *          process or at any time when the {@code SyncProvider}
 615      *          instance touches the data source.
 616      * @see #acceptChanges(java.sql.Connection)
 617      * @see javax.sql.RowSetWriter
 618      * @see javax.sql.rowset.spi.SyncProvider
 619      */
 620     public void acceptChanges() throws SyncProviderException {
 621         throw new UnsupportedOperationException();
 622     }
 623 
 624     /**
 625      * Propagates all row update, insert, and delete changes to the
 626      * data source backing this {@code CachedRowSetImpl} object
 627      * using the given {@code Connection} object.
 628      * &lt;P&gt;
 629      * The reference implementation {@code RIOptimisticProvider}
 630      * modifies its synchronization to a write back function given
 631      * the updated connection
 632      * The reference implementation modifies its synchronization behaviour
 633      * via the {@code SyncProvider} to ensure the synchronization
 634      * occurs according to the updated JDBC {@code Connection}
 635      * properties.
 636      *
 637      * @param con a standard JDBC {@code Connection} object
 638      * @throws SQLException if the cursor is on the insert row or the underlying
 639      *                   synchronization provider fails to commit the updates
 640      *                   back to the data source
 641      * @see #acceptChanges
 642      * @see javax.sql.RowSetWriter
 643      * @see javax.sql.rowset.spi.SyncFactory
 644      * @see javax.sql.rowset.spi.SyncProvider
 645      */
 646     public void acceptChanges(Connection con) throws SyncProviderException{
 647      throw new UnsupportedOperationException();
 648     }
 649 
 650     /**
 651      * Restores this {@code CachedRowSetImpl} object to its original state,
 652      * that is, its state before the last set of changes.
 653      * &lt;P&gt;
 654      * Before returning, this method moves the cursor before the first row
 655      * and sends a {@code rowSetChanged} event to all registered
 656      * listeners.
 657      * @throws SQLException if an error is occurs rolling back the RowSet
 658      *           state to the definied original value.
 659      * @see javax.sql.RowSetListener#rowSetChanged
 660      */
 661     public void restoreOriginal() throws SQLException {
 662         throw new UnsupportedOperationException();
 663     }
 664 
 665     /**
 666      * Releases the current contents of this {@code CachedRowSetImpl}
 667      * object and sends a {@code rowSetChanged} event object to all
 668      * registered listeners.
 669      *
 670      * @throws SQLException if an error occurs flushing the contents of
 671      *           RowSet.
 672      * @see javax.sql.RowSetListener#rowSetChanged
 673      */
 674     public void release() throws SQLException {
 675         throw new UnsupportedOperationException();
 676     }
 677 
 678     /**
 679      * Cancels deletion of the current row and notifies listeners that
 680      * a row has changed.
 681      * &lt;P&gt;
 682      * Note:  This method can be ignored if deleted rows are not being shown,
 683      * which is the normal case.
 684      *
 685      * @throws SQLException if the cursor is not on a valid row
 686      */
 687     public void undoDelete() throws SQLException {
 688         throw new UnsupportedOperationException();
 689     }
 690 
 691     /**
 692      * Immediately removes the current row from this
 693      * {@code CachedRowSetImpl} object if the row has been inserted, and
 694      * also notifies listeners the a row has changed.  An exception is thrown
 695      * if the row is not a row that has been inserted or the cursor is before
 696      * the first row, after the last row, or on the insert row.
 697      * &lt;P&gt;
 698      * This operation cannot be undone.
 699      *
 700      * @throws SQLException if an error occurs,
 701      *                         the cursor is not on a valid row,
 702      *                         or the row has not been inserted
 703      */
 704     public void undoInsert() throws SQLException {
 705         throw new UnsupportedOperationException();
 706     }
 707 
 708     /**
 709      * Immediately reverses the last update operation if the
 710      * row has been modified. This method can be
 711      * called to reverse updates on a all columns until all updates in a row have
 712      * been rolled back to their originating state since the last synchronization
 713      * ({@code acceptChanges}) or population. This method may also be called
 714      * while performing updates to the insert row.
 715      * &lt;P&gt;
 716      * {@code undoUpdate} may be called at any time during the life-time of a
 717      * rowset, however after a synchronization has occurs this method has no
 718      * affect until further modification to the RowSet data occurs.
 719      *
 720      * @throws SQLException if cursor is before the first row, after the last
 721      *     row in rowset.
 722      * @see #undoDelete
 723      * @see #undoInsert
 724      * @see java.sql.ResultSet#cancelRowUpdates
 725      */
 726     public void undoUpdate() throws SQLException {
 727         throw new UnsupportedOperationException();
 728 
 729     }
 730 
 731     //--------------------------------------------------------------------
 732     // Views
 733     //--------------------------------------------------------------------
 734 
 735     /**
 736      * Returns a new {@code RowSet} object backed by the same data as
 737      * that of this {@code CachedRowSetImpl} object and sharing a set of cursors
 738      * with it. This allows cursors to interate over a shared set of rows, providing
 739      * multiple views of the underlying data.
 740      *
 741      * @return a {@code RowSet} object that is a copy of this {@code CachedRowSetImpl}
 742      * object and shares a set of cursors with it
 743      * @throws SQLException if an error occurs or cloning is
 744      *                         not supported
 745      * @see javax.sql.RowSetEvent
 746      * @see javax.sql.RowSetListener
 747      */
 748     public RowSet createShared() throws SQLException {
 749         throw new UnsupportedOperationException();
 750     }
 751 
 752     /**
 753      * Returns a new {@code RowSet} object containing by the same data
 754      * as this {@code CachedRowSetImpl} object.  This method
 755      * differs from the method {@code createCopy} in that it throws a
 756      * {@code CloneNotSupportedException} object instead of an
 757      * {@code SQLException} object, as the method {@code createShared}
 758      * does.  This {@code clone}
 759      * method is called internally by the method {@code createShared},
 760      * which catches the {@code CloneNotSupportedException} object
 761      * and in turn throws a new {@code SQLException} object.
 762      *
 763      * @return a copy of this {@code CachedRowSetImpl} object
 764      * @throws CloneNotSupportedException if an error occurs when
 765      * attempting to clone this {@code CachedRowSetImpl} object
 766      * @see #createShared
 767      */
 768     protected Object clone() throws CloneNotSupportedException  {
 769        throw new UnsupportedOperationException();
 770     }
 771 
 772     /**
 773      * Creates a {@code RowSet} object that is a deep copy of
 774      * this {@code CachedRowSetImpl} object&#39;s data, including
 775      * constraints.  Updates made
 776      * on a copy are not visible to the original rowset;
 777      * a copy of a rowset is completely independent from the original.
 778      * &lt;P&gt;
 779      * Making a copy saves the cost of creating an identical rowset
 780      * from first principles, which can be quite expensive.
 781      * For example, it can eliminate the need to query a
 782      * remote database server.
 783      * @return a new {@code CachedRowSet} object that is a deep copy
 784      *           of this {@code CachedRowSet} object and is
 785      *           completely independent from this {@code CachedRowSetImpl}
 786      *           object.
 787      * @throws SQLException if an error occurs in generating the copy of this
 788      *           of the {@code CachedRowSetImpl}
 789      * @see #createShared
 790      * @see javax.sql.RowSetEvent
 791      * @see javax.sql.RowSetListener
 792      */
 793     public CachedRowSet createCopy() throws SQLException {
 794         throw new UnsupportedOperationException();
 795     }
 796 
 797     /**
 798      * Creates a {@code RowSet} object that is a copy of
 799      * this {@code CachedRowSetImpl} object&#39;s table structure
 800      * and the constraints only.
 801      * There will be no data in the object being returned.
 802      * Updates made on a copy are not visible to the original rowset.
 803      * &lt;P&gt;
 804      * This helps in getting the underlying XML schema which can
 805      * be used as the basis for populating a {@code WebRowSet}.
 806      *
 807      * @return a new {@code CachedRowSet} object that is a copy
 808      * of this {@code CachedRowSetImpl} object&#39;s schema and
 809      * retains all the constraints on the original rowset but contains
 810      * no data
 811      * @throws SQLException if an error occurs in generating the copy
 812      * of the {@code CachedRowSet} object
 813      * @see #createShared
 814      * @see #createCopy
 815      * @see #createCopyNoConstraints
 816      * @see javax.sql.RowSetEvent
 817      * @see javax.sql.RowSetListener
 818      */
 819     public CachedRowSet createCopySchema() throws SQLException {
 820         throw new UnsupportedOperationException();
 821     }
 822 
 823     /**
 824      * Creates a {@code CachedRowSet} object that is a copy of
 825      * this {@code CachedRowSetImpl} object&#39;s data only.
 826      * All constraints set in this object will not be there
 827      * in the returning object.  Updates made
 828      * on a copy are not visible to the original rowset.
 829      *
 830      * @return a new {@code CachedRowSet} object that is a deep copy
 831      * of this {@code CachedRowSetImpl} object and is
 832      * completely independent from this {@code CachedRowSetImpl} object
 833      * @throws SQLException if an error occurs in generating the copy of the
 834      * of the {@code CachedRowSet}
 835      * @see #createShared
 836      * @see #createCopy
 837      * @see #createCopySchema
 838      * @see javax.sql.RowSetEvent
 839      * @see javax.sql.RowSetListener
 840      */
 841     public CachedRowSet createCopyNoConstraints() throws SQLException {
 842         throw new UnsupportedOperationException();
 843     }
 844 
 845     /**
 846      * Converts this {@code CachedRowSetImpl} object to a collection
 847      * of tables. The sample implementation utilitizes the {@code TreeMap}
 848      * collection type.
 849      * This class guarantees that the map will be in ascending key order,
 850      * sorted according to the natural order for the key&#39;s class.
 851      *
 852      * @return a {@code Collection} object consisting of tables,
 853      *         each of which is a copy of a row in this
 854      *         {@code CachedRowSetImpl} object
 855      * @throws SQLException if an error occurs in generating the collection
 856      * @see #toCollection(int)
 857      * @see #toCollection(String)
 858      * @see java.util.TreeMap
 859      */
 860     @SuppressWarnings(&quot;rawtypes&quot;)
 861     public Collection toCollection() throws SQLException {
 862        throw new UnsupportedOperationException();
 863     }
 864 
 865     /**
 866      * Returns the specified column of this {@code CachedRowSetImpl} object
 867      * as a {@code Collection} object.  This method makes a copy of the
 868      * column&#39;s data and utilitizes the {@code Vector} to establish the
 869      * collection. The {@code Vector} class implements a growable array
 870      * objects allowing the individual components to be accessed using an
 871      * an integer index similar to that of an array.
 872      *
 873      * @return a {@code Collection} object that contains the value(s)
 874      *         stored in the specified column of this
 875      *         {@code CachedRowSetImpl}
 876      *         object
 877      * @throws SQLException if an error occurs generated the collection; or
 878      *          an invalid column is provided.
 879      * @see #toCollection()
 880      * @see #toCollection(String)
 881      * @see java.util.Vector
 882      */
 883     @SuppressWarnings(&quot;rawtypes&quot;)
 884     public Collection toCollection(int column) throws SQLException {
 885        throw new UnsupportedOperationException();
 886     }
 887 
 888     /**
 889      * Returns the specified column of this {@code CachedRowSetImpl} object
 890      * as a {@code Collection} object.  This method makes a copy of the
 891      * column&#39;s data and utilitizes the {@code Vector} to establish the
 892      * collection. The {@code Vector} class implements a growable array
 893      * objects allowing the individual components to be accessed using an
 894      * an integer index similar to that of an array.
 895      *
 896      * @return a {@code Collection} object that contains the value(s)
 897      *         stored in the specified column of this
 898      *         {@code CachedRowSetImpl}
 899      *         object
 900      * @throws SQLException if an error occurs generated the collection; or
 901      *          an invalid column is provided.
 902      * @see #toCollection()
 903      * @see #toCollection(int)
 904      * @see java.util.Vector
 905      */
 906     @SuppressWarnings(&quot;rawtypes&quot;)
 907     public Collection toCollection(String column) throws SQLException {
 908         throw new UnsupportedOperationException();
 909     }
 910 
 911     //--------------------------------------------------------------------
 912     // Advanced features
 913     //--------------------------------------------------------------------
 914 
 915 
 916     /**
 917      * Returns the {@code SyncProvider} implementation being used
 918      * with this {@code CachedRowSetImpl} implementation rowset.
 919      *
 920      * @return the SyncProvider used by the rowset. If not provider was
 921      *          set when the rowset was instantiated, the reference
 922      *          implementation (default) provider is returned.
 923      * @throws SQLException if error occurs while return the
 924      *          {@code SyncProvider} instance.
 925      */
 926     public SyncProvider getSyncProvider() throws SQLException {
 927       throw new UnsupportedOperationException();
 928     }
 929 
 930     /**
 931      * Sets the active {@code SyncProvider} and attempts to load
 932      * load the new provider using the {@code SyncFactory} SPI.
 933      *
 934      * @throws SQLException if an error occurs while resetting the
 935      *          {@code SyncProvider}.
 936      */
 937     public void setSyncProvider(String providerStr) throws SQLException {
 938         throw new UnsupportedOperationException();
 939     }
 940 
 941 
 942     //-----------------
 943     // methods inherited from RowSet
 944     //-----------------
 945 
 946 
 947 
 948 
 949 
 950 
 951     //---------------------------------------------------------------------
 952     // Reading and writing data
 953     //---------------------------------------------------------------------
 954 
 955     /**
 956      * Populates this {@code CachedRowSetImpl} object with data.
 957      * This form of the method uses the rowset&#39;s user, password, and url or
 958      * data source name properties to create a database
 959      * connection.  If properties that are needed
 960      * have not been set, this method will throw an exception.
 961      * &lt;P&gt;
 962      * Another form of this method uses an existing JDBC {@code Connection}
 963      * object instead of creating a new one; therefore, it ignores the
 964      * properties used for establishing a new connection.
 965      * &lt;P&gt;
 966      * The query specified by the command property is executed to create a
 967      * {@code ResultSet} object from which to retrieve data.
 968      * The current contents of the rowset are discarded, and the
 969      * rowset&#39;s metadata is also (re)set.  If there are outstanding updates,
 970      * they are also ignored.
 971      * &lt;P&gt;
 972      * The method {@code execute} closes any database connections that it
 973      * creates.
 974      *
 975      * @throws SQLException if an error occurs or the
 976      *                         necessary properties have not been set
 977      */
 978     public void execute() throws SQLException {
 979         throw new UnsupportedOperationException();
 980     }
 981 
 982 
 983 
 984     //-----------------------------------
 985     // Methods inherited from ResultSet
 986     //-----------------------------------
 987 
 988     /**
 989      * Moves the cursor down one row from its current position and
 990      * returns {@code true} if the new cursor position is a
 991      * valid row.
 992      * The cursor for a new {@code ResultSet} object is initially
 993      * positioned before the first row. The first call to the method
 994      * {@code next} moves the cursor to the first row, making it
 995      * the current row; the second call makes the second row the
 996      * current row, and so on.
 997      *
 998      * &lt;P&gt;If an input stream from the previous row is open, it is
 999      * implicitly closed. The {@code ResultSet} object&#39;s warning
1000      * chain is cleared when a new row is read.
1001      *
1002      * @return {@code true} if the new current row is valid;
1003      *         {@code false} if there are no more rows
1004      * @throws SQLException if an error occurs or
1005      *            the cursor is not positioned in the rowset, before
1006      *            the first row, or after the last row
1007      */
1008     public boolean next() throws SQLException {
1009        throw new UnsupportedOperationException();
1010     }
1011 
1012     /**
1013      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the next
1014      * row and returns {@code true} if the cursor is still in the rowset;
1015      * returns {@code false} if the cursor has moved to the position after
1016      * the last row.
1017      * &lt;P&gt;
1018      * This method handles the cases where the cursor moves to a row that
1019      * has been deleted.
1020      * If this rowset shows deleted rows and the cursor moves to a row
1021      * that has been deleted, this method moves the cursor to the next
1022      * row until the cursor is on a row that has not been deleted.
1023      * &lt;P&gt;
1024      * The method {@code internalNext} is called by methods such as
1025      * {@code next}, {@code absolute}, and {@code relative},
1026      * and, as its name implies, is only called internally.
1027      * &lt;p&gt;
1028      * This is a implementation only method and is not required as a standard
1029      * implementation of the {@code CachedRowSet} interface.
1030      *
1031      * @return {@code true} if the cursor is on a valid row in this
1032      *         rowset; {@code false} if it is after the last row
1033      * @throws SQLException if an error occurs
1034      */
1035     protected boolean internalNext() throws SQLException {
1036         throw new UnsupportedOperationException();
1037     }
1038 
1039     /**
1040      * Closes this {@code CachedRowSetImpl} objecy and releases any resources
1041      * it was using.
1042      *
1043      * @throws SQLException if an error occurs when releasing any resources in use
1044      * by this {@code CachedRowSetImpl} object
1045      */
1046     public void close() throws SQLException {
1047         throw new UnsupportedOperationException();
1048     }
1049 
1050     /**
1051      * Reports whether the last column read was SQL {@code NULL}.
1052      * Note that you must first call the method {@code getXXX}
1053      * on a column to try to read its value and then call the method
1054      * {@code wasNull} to determine whether the value was
1055      * SQL {@code NULL}.
1056      *
1057      * @return {@code true} if the value in the last column read
1058      *         was SQL {@code NULL}; {@code false} otherwise
1059      * @throws SQLException if an error occurs
1060      */
1061     public boolean wasNull() throws SQLException {
1062         throw new UnsupportedOperationException();
1063     }
1064 
1065     /**
1066      * Returns the insert row or the current row of this
1067      * {@code CachedRowSetImpl} object.
1068      *
1069      * @return the {@code Row} object on which this {@code CachedRowSetImpl}
1070      * objects&#39;s cursor is positioned
1071      */
1072     protected BaseRow getCurrentRow() {
1073         throw new UnsupportedOperationException();
1074     }
1075 
1076     /**
1077      * Removes the row on which the cursor is positioned.
1078      * &lt;p&gt;
1079      * This is a implementation only method and is not required as a standard
1080      * implementation of the {@code CachedRowSet} interface.
1081      *
1082      * @throws SQLException if the cursor is positioned on the insert
1083      *            row
1084      */
1085     protected void removeCurrentRow() {
1086         throw new UnsupportedOperationException();
1087     }
1088 
1089 
1090     /**
1091      * Retrieves the value of the designated column in the current row
1092      * of this {@code CachedRowSetImpl} object as a
1093      * {@code String} object.
1094      *
1095      * @param columnIndex the first column is {@code 1}, the second
1096      *        is {@code 2}, and so on; must be {@code 1} or larger
1097      *        and equal to or less than the number of columns in the rowset
1098      * @return the column value; if the value is SQL {@code NULL}, the
1099      *         result is {@code null}
1100      * @throws SQLException if (1) the given column index is out of bounds,
1101      * (2) the cursor is not on one of this rowset&#39;s rows or its
1102      * insert row, or (3) the designated column does not store an
1103      * SQL {@code TINYINT, SMALLINT, INTEGER, BIGINT, REAL,
1104      * FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT,} &lt;b&gt;{@code CHAR, VARCHAR}&lt;/b&gt;
1105      * or {@code LONGVARCHAR} value. The bold SQL type designates the
1106      * recommended return type.
1107      */
1108     public String getString(int columnIndex) throws SQLException {
1109         throw new UnsupportedOperationException();
1110     }
1111 
1112     /**
1113      * Retrieves the value of the designated column in the current row
1114      * of this {@code CachedRowSetImpl} object as a
1115      * {@code boolean} value.
1116      *
1117      * @param columnIndex the first column is {@code 1}, the second
1118      *        is {@code 2}, and so on; must be {@code 1} or larger
1119      *        and equal to or less than the number of columns in the rowset
1120      * @return the column value as a {@code boolean} in the Java progamming language;
1121      *        if the value is SQL {@code NULL}, the result is {@code false}
1122      * @throws SQLException if (1) the given column index is out of bounds,
1123      *            (2) the cursor is not on one of this rowset&#39;s rows or its
1124      *            insert row, or (3) the designated column does not store an
1125      *            SQL {@code BOOLEAN} value
1126      * @see #getBoolean(String)
1127      */
1128     public boolean getBoolean(int columnIndex) throws SQLException {
1129         throw new UnsupportedOperationException();
1130     }
1131 
1132     /**
1133      * Retrieves the value of the designated column in the current row
1134      * of this {@code CachedRowSetImpl} object as a
1135      * {@code byte} value.
1136      *
1137      * @param columnIndex the first column is {@code 1}, the second
1138      *        is {@code 2}, and so on; must be {@code 1} or larger
1139      *        and equal to or less than the number of columns in the rowset
1140      * @return the column value as a {@code byte} in the Java programming
1141      * language; if the value is SQL {@code NULL}, the result is {@code 0}
1142      * @throws SQLException if (1) the given column index is out of bounds,
1143      *            (2) the cursor is not on one of this rowset&#39;s rows or its
1144      *            insert row, or (3) the designated column does not store an
1145      *            SQL &lt;b&gt;{@code TINYINT}&lt;/b&gt;, {@code SMALLINT, INTEGER,
1146      *            BIGINT, REAL, FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR,
1147      *            VARCHAR} or {@code LONGVARCHAR} value. The bold SQL type
1148      *            designates the recommended return type.
1149      * @see #getByte(String)
1150      */
1151     public byte getByte(int columnIndex) throws SQLException {
1152         throw new UnsupportedOperationException();
1153     }
1154 
1155     /**
1156      * Retrieves the value of the designated column in the current row
1157      * of this {@code CachedRowSetImpl} object as a
1158      * {@code short} value.
1159      *
1160      * @param columnIndex the first column is {@code 1}, the second
1161      *        is {@code 2}, and so on; must be {@code 1} or larger
1162      *        and equal to or less than the number of columns in the rowset
1163      * @return the column value; if the value is SQL {@code NULL}, the
1164      *         result is {@code 0}
1165      * @throws SQLException if (1) the given column index is out of bounds,
1166      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1167      *         insert row, or (3) the designated column does not store an
1168      *         SQL {@code TINYINT}, &lt;b&gt;{@code SMALLINT}&lt;/b&gt;,
1169      *         {@code INTEGER, BIGINT, REAL, FLOAT, DOUBLE,
1170      *         DECIMAL, NUMERIC, BIT, CHAR, VARCHAR}
1171      *         or {@code LONGVARCHAR} value. The bold SQL type
1172      *         designates the recommended return type.
1173      * @see #getShort(String)
1174      */
1175     public short getShort(int columnIndex) throws SQLException {
1176         throw new UnsupportedOperationException();
1177     }
1178 
1179     /**
1180      * Retrieves the value of the designated column in the current row
1181      * of this {@code CachedRowSetImpl} object as an
1182      * {@code int} value.
1183      *
1184      * @param columnIndex the first column is {@code 1}, the second
1185      *        is {@code 2}, and so on; must be {@code 1} or larger
1186      *        and equal to or less than the number of columns in the rowset
1187      * @return the column value; if the value is SQL {@code NULL}, the
1188      *         result is {@code 0}
1189      * @throws SQLException if (1) the given column index is out of bounds,
1190      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1191      *         insert row, or (3) the designated column does not store an
1192      *         SQL {@code TINYINT, SMALLINT,} &lt;b&gt;{@code INTEGER}&lt;/b&gt;,
1193      *         {@code BIGINT, REAL, FLOAT, DOUBLE, DECIMAL,
1194      *         NUMERIC, BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1195      *         The bold SQL type designates the
1196      *         recommended return type.
1197      */
1198     public int getInt(int columnIndex) throws SQLException {
1199         throw new UnsupportedOperationException();
1200     }
1201 
1202     /**
1203      * Retrieves the value of the designated column in the current row
1204      * of this {@code CachedRowSetImpl} object as a
1205      * {@code long} value.
1206      *
1207      * @param columnIndex the first column is {@code 1}, the second
1208      *        is {@code 2}, and so on; must be {@code 1} or larger
1209      *        and equal to or less than the number of columns in the rowset
1210      * @return the column value; if the value is SQL {@code NULL}, the
1211      *         result is {@code 0}
1212      * @throws SQLException if (1) the given column index is out of bounds,
1213      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1214      *         insert row, or (3) the designated column does not store an
1215      *         SQL {@code TINYINT, SMALLINT, INTEGER,}
1216      *         &lt;b&gt;{@code BIGINT}&lt;/b&gt;, {@code REAL, FLOAT, DOUBLE,
1217      *         DECIMAL, NUMERIC, BIT, CHAR, VARCHAR}
1218      *         or {@code LONGVARCHAR} value. The bold SQL type
1219      * designates the recommended return type.
1220      * @see #getLong(String)
1221      */
1222     public long getLong(int columnIndex) throws SQLException {
1223         throw new UnsupportedOperationException();
1224     }
1225 
1226     /**
1227      * Retrieves the value of the designated column in the current row
1228      * of this {@code CachedRowSetImpl} object as a
1229      * {@code float} value.
1230      *
1231      * @param columnIndex the first column is {@code 1}, the second
1232      *        is {@code 2}, and so on; must be {@code 1} or larger
1233      *        and equal to or less than the number of columns in the rowset
1234      * @return the column value; if the value is SQL {@code NULL}, the
1235      *         result is {@code 0}
1236      * @throws SQLException if (1) the given column index is out of bounds,
1237      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1238      *         insert row, or (3) the designated column does not store an
1239      *         SQL {@code TINYINT, SMALLINT, INTEGER, BIGINT,}
1240      *         &lt;b&gt;{@code REAL}&lt;/b&gt;, {@code FLOAT, DOUBLE, DECIMAL, NUMERIC,
1241      *         BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1242      *         The bold SQL type designates the recommended return type.
1243      * @see #getFloat(String)
1244      */
1245     public float getFloat(int columnIndex) throws SQLException {
1246         throw new UnsupportedOperationException();
1247     }
1248 
1249     /**
1250      * Retrieves the value of the designated column in the current row
1251      * of this {@code CachedRowSetImpl} object as a
1252      * {@code double} value.
1253      *
1254      * @param columnIndex the first column is {@code 1}, the second
1255      *        is {@code 2}, and so on; must be {@code 1} or larger
1256      *        and equal to or less than the number of columns in the rowset
1257      * @return the column value; if the value is SQL {@code NULL}, the
1258      *         result is {@code 0}
1259      * @throws SQLException if (1) the given column index is out of bounds,
1260      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1261      *         insert row, or (3) the designated column does not store an
1262      *         SQL {@code TINYINT, SMALLINT, INTEGER, BIGINT, REAL,}
1263      *         &lt;b&gt;{@code FLOAT, DOUBLE}&lt;/b&gt;,
1264      *         {@code DECIMAL, NUMERIC, BIT, CHAR, VARCHAR}
1265      *         or {@code LONGVARCHAR} value. The bold SQL type
1266      *         designates the recommended return type.
1267      * @see #getDouble(String)
1268      *
1269      */
1270     public double getDouble(int columnIndex) throws SQLException {
1271         throw new UnsupportedOperationException();
1272     }
1273 
1274     /**
1275      * Retrieves the value of the designated column in the current row
1276      * of this {@code CachedRowSetImpl} object as a
1277      * {@code java.math.BigDecimal} object.
1278      * &lt;P&gt;
1279      * This method is deprecated; use the version of {@code getBigDecimal}
1280      * that does not take a scale parameter and returns a value with full
1281      * precision.
1282      *
1283      * @param columnIndex the first column is {@code 1}, the second
1284      *        is {@code 2}, and so on; must be {@code 1} or larger
1285      *        and equal to or less than the number of columns in the rowset
1286      * @param scale the number of digits to the right of the decimal point in the
1287      *        value returned
1288      * @return the column value with the specified number of digits to the right
1289      *         of the decimal point; if the value is SQL {@code NULL}, the
1290      *         result is {@code null}
1291      * @throws SQLException if the given column index is out of bounds,
1292      *            the cursor is not on a valid row, or this method fails
1293      * @deprecated
1294      */
1295     @Deprecated
1296     public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
1297        throw new UnsupportedOperationException();
1298     }
1299 
1300     /**
1301      * Retrieves the value of the designated column in the current row
1302      * of this {@code CachedRowSetImpl} object as a
1303      * {@code byte} array value.
1304      *
1305      * @param columnIndex the first column is {@code 1}, the second
1306      *        is {@code 2}, and so on; must be {@code 1} or larger
1307      *        and equal to or less than the number of columns in the rowset
1308      * @return the column value as a {@code byte} array in the Java programming
1309      * language; if the value is SQL {@code NULL}, the
1310      * result is {@code null}
1311      *
1312      * @throws SQLException if (1) the given column index is out of bounds,
1313      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1314      *         insert row, or (3) the designated column does not store an
1315      *         SQL &lt;b&gt;{@code BINARY, VARBINARY}&lt;/b&gt; or
1316      *         {@code LONGVARBINARY} value.
1317      *         The bold SQL type designates the recommended return type.
1318      * @see #getBytes(String)
1319      */
1320     public byte[] getBytes(int columnIndex) throws SQLException {
1321         throw new UnsupportedOperationException();
1322     }
1323 
1324     /**
1325      * Retrieves the value of the designated column in the current row
1326      * of this {@code CachedRowSetImpl} object as a
1327      * {@code java.sql.Date} object.
1328      *
1329      * @param columnIndex the first column is {@code 1}, the second
1330      *        is {@code 2}, and so on; must be {@code 1} or larger
1331      *        and equal to or less than the number of columns in the rowset
1332      * @return the column value as a {@code java.sql.Data} object; if
1333      *        the value is SQL {@code NULL}, the
1334      *        result is {@code null}
1335      * @throws SQLException if the given column index is out of bounds,
1336      *         the cursor is not on a valid row, or this method fails
1337      */
1338     public java.sql.Date getDate(int columnIndex) throws SQLException {
1339         throw new UnsupportedOperationException();
1340     }
1341 
1342     /**
1343      * Retrieves the value of the designated column in the current row
1344      * of this {@code CachedRowSetImpl} object as a
1345      * {@code java.sql.Time} object.
1346      *
1347      * @param columnIndex the first column is {@code 1}, the second
1348      *        is {@code 2}, and so on; must be {@code 1} or larger
1349      *        and equal to or less than the number of columns in the rowset
1350      * @return the column value; if the value is SQL {@code NULL}, the
1351      *         result is {@code null}
1352      * @throws SQLException if the given column index is out of bounds,
1353      *         the cursor is not on a valid row, or this method fails
1354      */
1355     public java.sql.Time getTime(int columnIndex) throws SQLException {
1356         throw new UnsupportedOperationException();
1357     }
1358 
1359     /**
1360      * Retrieves the value of the designated column in the current row
1361      * of this {@code CachedRowSetImpl} object as a
1362      * {@code java.sql.Timestamp} object.
1363      *
1364      * @param columnIndex the first column is {@code 1}, the second
1365      *        is {@code 2}, and so on; must be {@code 1} or larger
1366      *        and equal to or less than the number of columns in the rowset
1367      * @return the column value; if the value is SQL {@code NULL}, the
1368      *         result is {@code null}
1369      * @throws SQLException if the given column index is out of bounds,
1370      *            the cursor is not on a valid row, or this method fails
1371      */
1372     public java.sql.Timestamp getTimestamp(int columnIndex) throws SQLException {
1373         throw new UnsupportedOperationException();
1374     }
1375 
1376     /**
1377      * Retrieves the value of the designated column in the current row of this
1378      * {@code CachedRowSetImpl} object as a {@code java.io.InputStream}
1379      * object.
1380      *
1381      * A column value can be retrieved as a stream of ASCII characters
1382      * and then read in chunks from the stream.  This method is particularly
1383      * suitable for retrieving large {@code LONGVARCHAR} values.  The JDBC
1384      * driver will do any necessary conversion from the database format into ASCII.
1385      *
1386      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
1387      * read prior to getting the value of any other column. The next
1388      * call to a get method implicitly closes the stream. . Also, a
1389      * stream may return {@code 0} for {@code CachedRowSetImpl.available()}
1390      * whether there is data available or not.
1391      *
1392      * @param columnIndex the first column is {@code 1}, the second
1393      *        is {@code 2}, and so on; must be {@code 1} or larger
1394      *        and equal to or less than the number of columns in this rowset
1395      * @return a Java input stream that delivers the database column value
1396      *         as a stream of one-byte ASCII characters.  If the value is SQL
1397      *         {@code NULL}, the result is {@code null}.
1398      * @throws SQLException if (1) the given column index is out of bounds,
1399      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1400      *         insert row, or (3) the designated column does not store an
1401      *         SQL {@code CHAR, VARCHAR}, &lt;b&gt;{@code LONGVARCHAR}&lt;/b&gt;,
1402      *         {@code BINARY, VARBINARY} or {@code LONGVARBINARY} value. The
1403      *         bold SQL type designates the recommended return types
1404      *         that this method is used to retrieve.
1405      * @see #getAsciiStream(String)
1406      */
1407     public java.io.InputStream getAsciiStream(int columnIndex) throws SQLException {
1408        throw new UnsupportedOperationException();
1409     }
1410 
1411     /**
1412      * A column value can be retrieved as a stream of Unicode characters
1413      * and then read in chunks from the stream.  This method is particularly
1414      * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
1415      * do any necessary conversion from the database format into Unicode.
1416      *
1417      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
1418      * read prior to getting the value of any other column. The next
1419      * call to a get method implicitly closes the stream. . Also, a
1420      * stream may return 0 for available() whether there is data
1421      * available or not.
1422      *
1423      * @param columnIndex the first column is {@code 1}, the second
1424      *        is {@code 2}, and so on; must be {@code 1} or larger
1425      *        and equal to or less than the number of columns in this rowset
1426      * @return a Java input stream that delivers the database column value
1427      * as a stream of two byte Unicode characters.  If the value is SQL NULL
1428      * then the result is null.
1429      * @throws SQLException if an error occurs
1430      * @deprecated
1431      */
1432     @Deprecated
1433     public java.io.InputStream getUnicodeStream(int columnIndex) throws SQLException {
1434        throw new UnsupportedOperationException();
1435     }
1436 
1437     /**
1438      * Retrieves the value of the designated column in the current row of this
1439      * {@code CachedRowSetImpl} object as a {@code java.io.InputStream}
1440      * object.
1441      * &lt;P&gt;
1442      * A column value can be retrieved as a stream of uninterpreted bytes
1443      * and then read in chunks from the stream.  This method is particularly
1444      * suitable for retrieving large {@code LONGVARBINARY} values.
1445      *
1446      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
1447      * read prior to getting the value of any other column. The next
1448      * call to a get method implicitly closes the stream. Also, a
1449      * stream may return {@code 0} for
1450      * {@code CachedRowSetImpl.available()} whether there is data
1451      * available or not.
1452      *
1453      * @param columnIndex the first column is {@code 1}, the second
1454      * is {@code 2}, and so on; must be {@code 1} or larger
1455      * and equal to or less than the number of columns in the rowset
1456      * @return a Java input stream that delivers the database column value
1457      * as a stream of uninterpreted bytes.  If the value is SQL {@code NULL}
1458      * then the result is {@code null}.
1459      * @throws SQLException if (1) the given column index is out of bounds,
1460      * (2) the cursor is not on one of this rowset&#39;s rows or its
1461      * insert row, or (3) the designated column does not store an
1462      * SQL {@code BINARY, VARBINARY} or &lt;b&gt;{@code LONGVARBINARY}&lt;/b&gt;.
1463      * The bold type indicates the SQL type that this method is recommened
1464      * to retrieve.
1465      * @see #getBinaryStream(String)
1466      */
1467     public java.io.InputStream getBinaryStream(int columnIndex) throws SQLException {
1468        throw new UnsupportedOperationException();
1469 
1470     }
1471 
1472 
1473     //======================================================================
1474     // Methods for accessing results by column name
1475     //======================================================================
1476 
1477     /**
1478      * Retrieves the value stored in the designated column
1479      * of the current row as a {@code String} object.
1480      *
1481      * @param columnName a {@code String} object giving the SQL name of
1482      *        a column in this {@code CachedRowSetImpl} object
1483      * @return the column value; if the value is SQL {@code NULL},
1484      *         the result is {@code null}
1485      * @throws SQLException if (1) the given column name is not the name of
1486      *         a column in this rowset, (2) the cursor is not on one of
1487      *         this rowset&#39;s rows or its insert row, or (3) the designated
1488      *         column does not store an SQL {@code TINYINT, SMALLINT, INTEGER,
1489      *         BIGINT, REAL, FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT,}
1490      *         &lt;b&gt;{@code CHAR, VARCHAR}&lt;/b&gt; or {@code LONGVARCHAR} value.
1491      *         The bold SQL type designates the recommended return type.
1492      */
1493     public String getString(String columnName) throws SQLException {
1494         throw new UnsupportedOperationException();
1495     }
1496 
1497     /**
1498      * Retrieves the value stored in the designated column
1499      * of the current row as a {@code boolean} value.
1500      *
1501      * @param columnName a {@code String} object giving the SQL name of
1502      *        a column in this {@code CachedRowSetImpl} object
1503      * @return the column value as a {@code boolean} in the Java programming
1504      *        language; if the value is SQL {@code NULL},
1505      *        the result is {@code false}
1506      * @throws SQLException if (1) the given column name is not the name of
1507      *         a column in this rowset, (2) the cursor is not on one of
1508      *         this rowset&#39;s rows or its insert row, or (3) the designated
1509      *         column does not store an SQL {@code BOOLEAN} value
1510      * @see #getBoolean(int)
1511      */
1512     public boolean getBoolean(String columnName) throws SQLException {
1513         throw new UnsupportedOperationException();
1514     }
1515 
1516     /**
1517      * Retrieves the value stored in the designated column
1518      * of the current row as a {@code byte} value.
1519      *
1520      * @param columnName a {@code String} object giving the SQL name of
1521      *        a column in this {@code CachedRowSetImpl} object
1522      * @return the column value as a {@code byte} in the Java programming
1523      * language; if the value is SQL {@code NULL}, the result is {@code 0}
1524      * @throws SQLException if (1) the given column name is not the name of
1525      *         a column in this rowset, (2) the cursor is not on one of
1526      *         this rowset&#39;s rows or its insert row, or (3) the designated
1527      *         column does not store an SQL &lt;b&gt;{@code TINYINT}&lt;/b&gt;,
1528      *         {@code SMALLINT, INTEGER, BIGINT, REAL, FLOAT, DOUBLE,
1529      *         DECIMAL, NUMERIC, BIT, CHAR, VARCHAR} or {@code LONGVARCHAR}
1530      *         value. The bold type designates the recommended return type.
1531      */
1532     public byte getByte(String columnName) throws SQLException {
1533         throw new UnsupportedOperationException();
1534     }
1535 
1536     /**
1537      * Retrieves the value stored in the designated column
1538      * of the current row as a {@code short} value.
1539      *
1540      * @param columnName a {@code String} object giving the SQL name of
1541      *        a column in this {@code CachedRowSetImpl} object
1542      * @return the column value; if the value is SQL {@code NULL},
1543      *         the result is {@code 0}
1544      * @throws SQLException if (1) the given column name is not the name of
1545      *         a column in this rowset, (2) the cursor is not on one of
1546      *         this rowset&#39;s rows or its insert row, or (3) the designated
1547      *         column does not store an SQL {@code TINYINT,}
1548      *         &lt;b&gt;{@code SMALLINT}&lt;/b&gt;, {@code INTEGER,
1549      *         BIGINT, REAL, FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR,
1550      *         VARCHAR} or {@code LONGVARCHAR} value. The bold SQL type
1551      *         designates the recommended return type.
1552      * @see #getShort(int)
1553      */
1554     public short getShort(String columnName) throws SQLException {
1555        throw new UnsupportedOperationException();
1556     }
1557 
1558     /**
1559      * Retrieves the value stored in the designated column
1560      * of the current row as an {@code int} value.
1561      *
1562      * @param columnName a {@code String} object giving the SQL name of
1563      *        a column in this {@code CachedRowSetImpl} object
1564      * @return the column value; if the value is SQL {@code NULL},
1565      *         the result is {@code 0}
1566      * @throws SQLException if (1) the given column name is not the name
1567      *         of a column in this rowset,
1568      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1569      *         insert row, or (3) the designated column does not store an
1570      *         SQL {@code TINYINT, SMALLINT,} &lt;b&gt;{@code INTEGER}&lt;/b&gt;,
1571      *         {@code BIGINT, REAL, FLOAT, DOUBLE, DECIMAL,
1572      *         NUMERIC, BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1573      *         The bold SQL type designates the
1574      *         recommended return type.
1575      */
1576     public int getInt(String columnName) throws SQLException {
1577         throw new UnsupportedOperationException();
1578     }
1579 
1580     /**
1581      * Retrieves the value stored in the designated column
1582      * of the current row as a {@code long} value.
1583      *
1584      * @param columnName a {@code String} object giving the SQL name of
1585      *        a column in this {@code CachedRowSetImpl} object
1586      * @return the column value; if the value is SQL {@code NULL},
1587      *         the result is {@code 0}
1588      * @throws SQLException if (1) the given column name is not the name of
1589      *         a column in this rowset, (2) the cursor is not on one of
1590      *         this rowset&#39;s rows or its insert row, or (3) the designated
1591      *         column does not store an SQL {@code TINYINT, SMALLINT, INTEGER,}
1592      *         &lt;b&gt;{@code BIGINT}&lt;/b&gt;, {@code REAL, FLOAT, DOUBLE, DECIMAL,
1593      *         NUMERIC, BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1594      *         The bold SQL type designates the recommended return type.
1595      * @see #getLong(int)
1596      */
1597     public long getLong(String columnName) throws SQLException {
1598         throw new UnsupportedOperationException();
1599     }
1600 
1601     /**
1602      * Retrieves the value stored in the designated column
1603      * of the current row as a {@code float} value.
1604      *
1605      * @param columnName a {@code String} object giving the SQL name of
1606      *        a column in this {@code CachedRowSetImpl} object
1607      * @return the column value; if the value is SQL {@code NULL},
1608      *         the result is {@code 0}
1609      * @throws SQLException if (1) the given column name is not the name of
1610      *         a column in this rowset, (2) the cursor is not on one of
1611      *         this rowset&#39;s rows or its insert row, or (3) the designated
1612      *         column does not store an SQL {@code TINYINT, SMALLINT, INTEGER,
1613      *         BIGINT,} &lt;b&gt;{@code REAL}&lt;/b&gt;, {@code FLOAT, DOUBLE, DECIMAL,
1614      *         NUMERIC, BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1615      *         The bold SQL type designates the recommended return type.
1616      * @see #getFloat(String)
1617      */
1618     public float getFloat(String columnName) throws SQLException {
1619        throw new UnsupportedOperationException();
1620     }
1621 
1622     /**
1623      * Retrieves the value stored in the designated column
1624      * of the current row of this {@code CachedRowSetImpl} object
1625      * as a {@code double} value.
1626      *
1627      * @param columnName a {@code String} object giving the SQL name of
1628      *        a column in this {@code CachedRowSetImpl} object
1629      * @return the column value; if the value is SQL {@code NULL},
1630      *         the result is {@code 0}
1631      * @throws SQLException if (1) the given column name is not the name of
1632      *         a column in this rowset, (2) the cursor is not on one of
1633      *         this rowset&#39;s rows or its insert row, or (3) the designated
1634      *         column does not store an SQL {@code TINYINT, SMALLINT, INTEGER,
1635      *         BIGINT, REAL,} &lt;b&gt;{@code FLOAT, DOUBLE}&lt;/b&gt;, {@code DECIMAL,
1636      *         NUMERIC, BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1637      *         The bold SQL type designates the recommended return types.
1638      * @see #getDouble(int)
1639      */
1640     public double getDouble(String columnName) throws SQLException {
1641         throw new UnsupportedOperationException();
1642     }
1643 
1644     /**
1645      * Retrieves the value stored in the designated column
1646      * of the current row as a {@code java.math.BigDecimal} object.
1647      *
1648      * @param columnName a {@code String} object giving the SQL name of
1649      *        a column in this {@code CachedRowSetImpl} object
1650      * @param scale the number of digits to the right of the decimal point
1651      * @return a java.math.BugDecimal object with &lt;i&gt;{@code scale}&lt;/i&gt;
1652      *         number of digits to the right of the decimal point.
1653      * @throws SQLException if (1) the given column name is not the name of
1654      *         a column in this rowset, (2) the cursor is not on one of
1655      *         this rowset&#39;s rows or its insert row, or (3) the designated
1656      *         column does not store an SQL {@code TINYINT, SMALLINT, INTEGER,
1657      *         BIGINT, REAL, FLOAT, DOUBLE,} &lt;b&gt;{@code DECIMAL, NUMERIC}&lt;/b&gt;,
1658      *         {@code BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
1659      *         The bold SQL type designates the recommended return type
1660      *         that this method is used to retrieve.
1661      * @deprecated Use the {@code getBigDecimal(String columnName)}
1662      *             method instead
1663      */
1664     @Deprecated
1665     public BigDecimal getBigDecimal(String columnName, int scale) throws SQLException {
1666         throw new UnsupportedOperationException();
1667     }
1668 
1669     /**
1670      * Retrieves the value stored in the designated column
1671      * of the current row as a {@code byte} array.
1672      * The bytes represent the raw values returned by the driver.
1673      *
1674      * @param columnName a {@code String} object giving the SQL name of
1675      *        a column in this {@code CachedRowSetImpl} object
1676      * @return the column value as a {@code byte} array in the Java programming
1677      *         language; if the value is SQL {@code NULL}, the result is {@code null}
1678      * @throws SQLException if (1) the given column name is not the name of
1679      *         a column in this rowset, (2) the cursor is not on one of
1680      *         this rowset&#39;s rows or its insert row, or (3) the designated
1681      *         column does not store an SQL &lt;b&gt;{@code BINARY, VARBINARY}&lt;/b&gt;
1682      *         or {@code LONGVARBINARY} values.
1683      *         The bold SQL type designates the recommended return type.
1684      * @see #getBytes(int)
1685      */
1686     public byte[] getBytes(String columnName) throws SQLException {
1687         throw new UnsupportedOperationException();
1688     }
1689 
1690     /**
1691      * Retrieves the value stored in the designated column
1692      * of the current row as a {@code java.sql.Date} object.
1693      *
1694      * @param columnName a {@code String} object giving the SQL name of
1695      *        a column in this {@code CachedRowSetImpl} object
1696      * @return the column value; if the value is SQL {@code NULL},
1697      *         the result is {@code null}
1698      * @throws SQLException if (1) the given column name is not the name of
1699      *            a column in this rowset, (2) the cursor is not on one of
1700      *            this rowset&#39;s rows or its insert row, or (3) the designated
1701      *            column does not store an SQL {@code DATE} or
1702      *            {@code TIMESTAMP} value
1703      */
1704     public java.sql.Date getDate(String columnName) throws SQLException {
1705         throw new UnsupportedOperationException();
1706     }
1707 
1708     /**
1709      * Retrieves the value stored in the designated column
1710      * of the current row as a {@code java.sql.Time} object.
1711      *
1712      * @param columnName a {@code String} object giving the SQL name of
1713      *        a column in this {@code CachedRowSetImpl} object
1714      * @return the column value; if the value is SQL {@code NULL},
1715      *         the result is {@code null}
1716      * @throws SQLException if the given column name does not match one of
1717      *            this rowset&#39;s column names or the cursor is not on one of
1718      *            this rowset&#39;s rows or its insert row
1719      */
1720     public java.sql.Time getTime(String columnName) throws SQLException {
1721         throw new UnsupportedOperationException();
1722     }
1723 
1724     /**
1725      * Retrieves the value stored in the designated column
1726      * of the current row as a {@code java.sql.Timestamp} object.
1727      *
1728      * @param columnName a {@code String} object giving the SQL name of
1729      *        a column in this {@code CachedRowSetImpl} object
1730      * @return the column value; if the value is SQL {@code NULL},
1731      *         the result is {@code null}
1732      * @throws SQLException if the given column name does not match one of
1733      *            this rowset&#39;s column names or the cursor is not on one of
1734      *            this rowset&#39;s rows or its insert row
1735      */
1736     public java.sql.Timestamp getTimestamp(String columnName) throws SQLException {
1737         throw new UnsupportedOperationException();
1738     }
1739 
1740     /**
1741      * Retrieves the value of the designated column in the current row of this
1742      * {@code CachedRowSetImpl} object as a {@code java.io.InputStream}
1743      * object.
1744      *
1745      * A column value can be retrieved as a stream of ASCII characters
1746      * and then read in chunks from the stream. This method is particularly
1747      * suitable for retrieving large {@code LONGVARCHAR} values. The
1748      * {@code SyncProvider} will rely on the JDBC driver to do any necessary
1749      * conversion from the database format into ASCII format.
1750      *
1751      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
1752      * be read prior to getting the value of any other column. The
1753      * next call to a {@code getXXX} method implicitly closes the stream.
1754      *
1755      * @param columnName a {@code String} object giving the SQL name of
1756      *        a column in this {@code CachedRowSetImpl} object
1757      * @return a Java input stream that delivers the database column value
1758      *         as a stream of one-byte ASCII characters.  If the value is SQL
1759      *         {@code NULL}, the result is {@code null}.
1760      * @throws SQLException if (1) the given column name is not the name of
1761      *         a column in this rowset
1762      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1763      *         insert row, or (3) the designated column does not store an
1764      *         SQL {@code CHAR, VARCHAR}, &lt;b&gt;{@code LONGVARCHAR}&lt;/b&gt;,
1765      *         {@code BINARY, VARBINARY} or {@code LONGVARBINARY} value. The
1766      *         bold SQL type designates the recommended return types
1767      *         that this method is used to retrieve.
1768      * @see #getAsciiStream(int)
1769      */
1770     public java.io.InputStream getAsciiStream(String columnName) throws SQLException {
1771         throw new UnsupportedOperationException();
1772 
1773     }
1774 
1775     /**
1776      * A column value can be retrieved as a stream of Unicode characters
1777      * and then read in chunks from the stream.  This method is particularly
1778      * suitable for retrieving large {@code LONGVARCHAR} values.
1779      * The JDBC driver will do any necessary conversion from the database
1780      * format into Unicode.
1781      *
1782      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
1783      * be read prior to getting the value of any other column. The
1784      * next call to a {@code getXXX} method implicitly closes the stream.
1785      *
1786      * @param columnName a {@code String} object giving the SQL name of
1787      *        a column in this {@code CachedRowSetImpl} object
1788      * @return a Java input stream that delivers the database column value
1789      *         as a stream of two-byte Unicode characters.  If the value is
1790      *         SQL {@code NULL}, the result is {@code null}.
1791      * @throws SQLException if the given column name does not match one of
1792      *            this rowset&#39;s column names or the cursor is not on one of
1793      *            this rowset&#39;s rows or its insert row
1794      * @deprecated use the method {@code getCharacterStream} instead
1795      */
1796     @Deprecated
1797     public java.io.InputStream getUnicodeStream(String columnName) throws SQLException {
1798         throw new UnsupportedOperationException();
1799     }
1800 
1801     /**
1802      * Retrieves the value of the designated column in the current row of this
1803      * {@code CachedRowSetImpl} object as a {@code java.io.InputStream}
1804      * object.
1805      * &lt;P&gt;
1806      * A column value can be retrieved as a stream of uninterpreted bytes
1807      * and then read in chunks from the stream.  This method is particularly
1808      * suitable for retrieving large {@code LONGVARBINARY} values.
1809      *
1810      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
1811      * read prior to getting the value of any other column. The next
1812      * call to a get method implicitly closes the stream. Also, a
1813      * stream may return {@code 0} for {@code CachedRowSetImpl.available()}
1814      * whether there is data available or not.
1815      *
1816      * @param columnName a {@code String} object giving the SQL name of
1817      *        a column in this {@code CachedRowSetImpl} object
1818      * @return a Java input stream that delivers the database column value
1819      *         as a stream of uninterpreted bytes.  If the value is SQL
1820      *         {@code NULL}, the result is {@code null}.
1821      * @throws SQLException if (1) the given column name is unknown,
1822      *         (2) the cursor is not on one of this rowset&#39;s rows or its
1823      *         insert row, or (3) the designated column does not store an
1824      *         SQL {@code BINARY, VARBINARY} or &lt;b&gt;{@code LONGVARBINARY}&lt;/b&gt;
1825      *         The bold type indicates the SQL type that this method is recommened
1826      *         to retrieve.
1827      * @see #getBinaryStream(int)
1828      *
1829      */
1830     public java.io.InputStream getBinaryStream(String columnName) throws SQLException {
1831         throw new UnsupportedOperationException();
1832     }
1833 
1834 
1835     //=====================================================================
1836     // Advanced features:
1837     //=====================================================================
1838 
1839     /**
1840      * The first warning reported by calls on this {@code CachedRowSetImpl}
1841      * object is returned. Subsequent {@code CachedRowSetImpl} warnings will
1842      * be chained to this {@code SQLWarning}.
1843      *
1844      * &lt;P&gt;The warning chain is automatically cleared each time a new
1845      * row is read.
1846      *
1847      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This warning chain only covers warnings caused
1848      * by {@code ResultSet} methods.  Any warning caused by statement
1849      * methods (such as reading OUT parameters) will be chained on the
1850      * {@code Statement} object.
1851      *
1852      * @return the first SQLWarning or null
1853      */
1854     public SQLWarning getWarnings() {
1855         throw new UnsupportedOperationException();
1856     }
1857 
1858     /**
1859      * Clears all the warnings reporeted for the {@code CachedRowSetImpl}
1860      * object. After a call to this method, the {@code getWarnings} method
1861      * returns {@code null} until a new warning is reported for this
1862      * {@code CachedRowSetImpl} object.
1863      */
1864     public void clearWarnings() {
1865        throw new UnsupportedOperationException();
1866     }
1867 
1868     /**
1869      * Retrieves the name of the SQL cursor used by this
1870      * {@code CachedRowSetImpl} object.
1871      *
1872      * &lt;P&gt;In SQL, a result table is retrieved through a cursor that is
1873      * named. The current row of a {@code ResultSet} can be updated or deleted
1874      * using a positioned update/delete statement that references the
1875      * cursor name. To ensure that the cursor has the proper isolation
1876      * level to support an update operation, the cursor&#39;s {@code SELECT}
1877      * statement should be of the form {@code select for update}.
1878      * If the {@code for update} clause
1879      * is omitted, positioned updates may fail.
1880      *
1881      * &lt;P&gt;JDBC supports this SQL feature by providing the name of the
1882      * SQL cursor used by a {@code ResultSet} object. The current row
1883      * of a result set is also the current row of this SQL cursor.
1884      *
1885      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; If positioned updates are not supported, an
1886      * {@code SQLException} is thrown.
1887      *
1888      * @return the SQL cursor name for this {@code CachedRowSetImpl} object&#39;s
1889      *         cursor
1890      * @throws SQLException if an error occurs
1891      */
1892     public String getCursorName() throws SQLException {
1893         throw new UnsupportedOperationException();
1894     }
1895 
1896     /**
1897      * Retrieves a {@code ResultSetMetaData} object instance that
1898      * contains information about the {@code CachedRowSet} object.
1899      * However, applications should cast the returned object to a
1900      * {@code RowSetMetaData} interface implementation. In the
1901      * reference implementation, this cast can be done on the
1902      * {@code RowSetMetaDataImpl} class.
1903      * &lt;P&gt;
1904      * For example:
1905      * &lt;pre&gt;
1906      * CachedRowSet crs = new CachedRowSetImpl();
1907      * RowSetMetaDataImpl metaData =
1908      *     (RowSetMetaDataImpl)crs.getMetaData();
1909      * // Set the number of columns in the RowSet object for
1910      * // which this RowSetMetaDataImpl object was created to the
1911      * // given number.
1912      * metaData.setColumnCount(3);
1913      * crs.setMetaData(metaData);
1914      * &lt;/pre&gt;
1915      *
1916      * @return the {@code ResultSetMetaData} object that describes this
1917      *         {@code CachedRowSetImpl} object&#39;s columns
1918      * @throws SQLException if an error occurs in generating the RowSet
1919      * meta data; or if the {@code CachedRowSetImpl} is empty.
1920      * @see javax.sql.RowSetMetaData
1921      */
1922     public ResultSetMetaData getMetaData() throws SQLException {
1923         throw new UnsupportedOperationException();
1924     }
1925 
1926 
1927     /**
1928      * Retrieves the value of the designated column in the current row
1929      * of this {@code CachedRowSetImpl} object as an
1930      * {@code Object} value.
1931      * &lt;P&gt;
1932      * The type of the {@code Object} will be the default
1933      * Java object type corresponding to the column&#39;s SQL type,
1934      * following the mapping for built-in types specified in the JDBC 3.0
1935      * specification.
1936      * &lt;P&gt;
1937      * This method may also be used to read datatabase-specific
1938      * abstract data types.
1939      * &lt;P&gt;
1940      * This implementation of the method {@code getObject} extends its
1941      * behavior so that it gets the attributes of an SQL structured type
1942      * as an array of {@code Object} values.  This method also custom
1943      * maps SQL user-defined types to classes in the Java programming language.
1944      * When the specified column contains
1945      * a structured or distinct value, the behavior of this method is as
1946      * if it were a call to the method {@code getObject(columnIndex,
1947      * this.getStatement().getConnection().getTypeMap())}.
1948      *
1949      * @param columnIndex the first column is {@code 1}, the second
1950      *        is {@code 2}, and so on; must be {@code 1} or larger
1951      *        and equal to or less than the number of columns in the rowset
1952      * @return a {@code java.lang.Object} holding the column value;
1953      *         if the value is SQL {@code NULL}, the result is {@code null}
1954      * @throws SQLException if the given column index is out of bounds,
1955      *            the cursor is not on a valid row, or there is a problem getting
1956      *            the {@code Class} object for a custom mapping
1957      * @see #getObject(String)
1958      */
1959     public Object getObject(int columnIndex) throws SQLException {
1960         throw new UnsupportedOperationException();
1961     }
1962 
1963     /**
1964      * Retrieves the value of the designated column in the current row
1965      * of this {@code CachedRowSetImpl} object as an
1966      * {@code Object} value.
1967      * &lt;P&gt;
1968      * The type of the {@code Object} will be the default
1969      * Java object type corresponding to the column&#39;s SQL type,
1970      * following the mapping for built-in types specified in the JDBC 3.0
1971      * specification.
1972      * &lt;P&gt;
1973      * This method may also be used to read datatabase-specific
1974      * abstract data types.
1975      * &lt;P&gt;
1976      * This implementation of the method {@code getObject} extends its
1977      * behavior so that it gets the attributes of an SQL structured type
1978      * as an array of {@code Object} values.  This method also custom
1979      * maps SQL user-defined types to classes
1980      * in the Java programming language. When the specified column contains
1981      * a structured or distinct value, the behavior of this method is as
1982      * if it were a call to the method {@code getObject(columnIndex,
1983      * this.getStatement().getConnection().getTypeMap())}.
1984      *
1985      * @param columnName a {@code String} object that must match the
1986      *        SQL name of a column in this rowset, ignoring case
1987      * @return a {@code java.lang.Object} holding the column value;
1988      *         if the value is SQL {@code NULL}, the result is {@code null}
1989      * @throws SQLException if (1) the given column name does not match one of
1990      *            this rowset&#39;s column names, (2) the cursor is not
1991      *            on a valid row, or (3) there is a problem getting
1992      *            the {@code Class} object for a custom mapping
1993      * @see #getObject(int)
1994      */
1995     public Object getObject(String columnName) throws SQLException {
1996        throw new UnsupportedOperationException();
1997     }
1998 
1999     //----------------------------------------------------------------
2000 
2001     /**
2002      * Maps the given column name for one of this {@code CachedRowSetImpl}
2003      * object&#39;s columns to its column number.
2004      *
2005      * @param columnName a {@code String} object that must match the
2006      *        SQL name of a column in this rowset, ignoring case
2007      * @return the column index of the given column name
2008      * @throws SQLException if the given column name does not match one
2009      *            of this rowset&#39;s column names
2010      */
2011     public int findColumn(String columnName) throws SQLException {
2012        throw new UnsupportedOperationException();
2013     }
2014 
2015     //--------------------------JDBC 2.0-----------------------------------
2016 
2017     //---------------------------------------------------------------------
2018     // Getter&#39;s and Setter&#39;s
2019     //---------------------------------------------------------------------
2020 
2021     /**
2022      * Retrieves the value stored in the designated column
2023      * of the current row as a {@code java.io.Reader} object.
2024      *
2025      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
2026      * be read prior to getting the value of any other column. The
2027      * next call to a {@code getXXX} method implicitly closes the stream.
2028      *
2029      * @param columnIndex the first column is {@code 1}, the second
2030      *        is {@code 2}, and so on; must be {@code 1} or larger
2031      *        and equal to or less than the number of columns in the rowset
2032      * @return a Java character stream that delivers the database column value
2033      * as a stream of two-byte unicode characters in a
2034      * {@code java.io.Reader} object.  If the value is
2035      * SQL {@code NULL}, the result is {@code null}.
2036      * @throws SQLException if (1) the given column index is out of bounds,
2037      *         (2) the cursor is not on one of this rowset&#39;s rows or its
2038      *         insert row, or (3) the designated column does not store an
2039      *         SQL {@code CHAR, VARCHAR,} &lt;b&gt;{@code LONGVARCHAR}&lt;/b&gt;,
2040      *         {@code BINARY, VARBINARY} or {@code LONGVARBINARY} value.
2041      *         The bold SQL type designates the recommended return type.
2042      * @see #getCharacterStream(String)
2043      */
2044     public java.io.Reader getCharacterStream(int columnIndex) throws SQLException{
2045         throw new UnsupportedOperationException();
2046     }
2047 
2048     /**
2049      * Retrieves the value stored in the designated column
2050      * of the current row as a {@code java.io.Reader} object.
2051      *
2052      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
2053      * be read prior to getting the value of any other column. The
2054      * next call to a {@code getXXX} method implicitly closes the stream.
2055      *
2056      * @param columnName a {@code String} object giving the SQL name of
2057      *        a column in this {@code CachedRowSetImpl} object
2058      * @return a Java input stream that delivers the database column value
2059      *         as a stream of two-byte Unicode characters.  If the value is
2060      *         SQL {@code NULL}, the result is {@code null}.
2061      * @throws SQLException if (1) the given column name is not the name of
2062      *         a column in this rowset, (2) the cursor is not on one of
2063      *         this rowset&#39;s rows or its insert row, or (3) the designated
2064      *         column does not store an SQL {@code CHAR, VARCHAR,}
2065      *         &lt;b&gt;{@code LONGVARCHAR}&lt;/b&gt;,
2066      *         {@code BINARY, VARYBINARY} or {@code LONGVARBINARY} value.
2067      *         The bold SQL type designates the recommended return type.
2068      */
2069     public java.io.Reader getCharacterStream(String columnName) throws SQLException {
2070         throw new UnsupportedOperationException();
2071     }
2072 
2073     /**
2074      * Retrieves the value of the designated column in the current row
2075      * of this {@code CachedRowSetImpl} object as a
2076      * {@code java.math.BigDecimal} object.
2077      *
2078      * @param columnIndex the first column is {@code 1}, the second
2079      *        is {@code 2}, and so on; must be {@code 1} or larger
2080      *        and equal to or less than the number of columns in the rowset
2081      * @return a {@code java.math.BigDecimal} value with full precision;
2082      *         if the value is SQL {@code NULL}, the result is {@code null}
2083      * @throws SQLException if (1) the given column index is out of bounds,
2084      *         (2) the cursor is not on one of this rowset&#39;s rows or its
2085      *         insert row, or (3) the designated column does not store an
2086      *         SQL {@code TINYINT, SMALLINT, INTEGER, BIGINT, REAL,
2087      *         FLOAT, DOUBLE,} &lt;b&gt;{@code DECIMAL, NUMERIC}&lt;/b&gt;,
2088      *         {@code BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
2089      *         The bold SQL type designates the
2090      *         recommended return types that this method is used to retrieve.
2091      * @see #getBigDecimal(String)
2092      */
2093     public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
2094         throw new UnsupportedOperationException();
2095     }
2096 
2097     /**
2098      * Retrieves the value of the designated column in the current row
2099      * of this {@code CachedRowSetImpl} object as a
2100      * {@code java.math.BigDecimal} object.
2101      *
2102      * @param columnName a {@code String} object that must match the
2103      *        SQL name of a column in this rowset, ignoring case
2104      * @return a {@code java.math.BigDecimal} value with full precision;
2105      *         if the value is SQL {@code NULL}, the result is {@code null}
2106      * @throws SQLException if (1) the given column name is not the name of
2107      *         a column in this rowset, (2) the cursor is not on one of
2108      *         this rowset&#39;s rows or its insert row, or (3) the designated
2109      *         column does not store an SQL {@code TINYINT, SMALLINT, INTEGER,
2110      *         BIGINT, REAL, FLOAT, DOUBLE,} &lt;b&gt;{@code DECIMAL, NUMERIC}&lt;/b&gt;,
2111      *         {@code BIT, CHAR, VARCHAR} or {@code LONGVARCHAR} value.
2112      *         The bold SQL type designates the recommended return type
2113      *         that this method is used to retrieve.
2114      * @see #getBigDecimal(int)
2115      */
2116     public BigDecimal getBigDecimal(String columnName) throws SQLException {
2117         throw new UnsupportedOperationException();
2118     }
2119 
2120     //---------------------------------------------------------------------
2121     // Traversal/Positioning
2122     //---------------------------------------------------------------------
2123 
2124     /**
2125      * Returns the number of rows in this {@code CachedRowSetImpl} object.
2126      *
2127      * @return number of rows in the rowset
2128      */
2129     public int size() {
2130         throw new UnsupportedOperationException();
2131     }
2132 
2133     /**
2134      * Indicates whether the cursor is before the first row in this
2135      * {@code CachedRowSetImpl} object.
2136      *
2137      * @return {@code true} if the cursor is before the first row;
2138      *         {@code false} otherwise or if the rowset contains no rows
2139      * @throws SQLException if an error occurs
2140      */
2141     public boolean isBeforeFirst() throws SQLException {
2142         throw new UnsupportedOperationException();
2143     }
2144 
2145     /**
2146      * Indicates whether the cursor is after the last row in this
2147      * {@code CachedRowSetImpl} object.
2148      *
2149      * @return {@code true} if the cursor is after the last row;
2150      *         {@code false} otherwise or if the rowset contains no rows
2151      * @throws SQLException if an error occurs
2152      */
2153     public boolean isAfterLast() throws SQLException {
2154         throw new UnsupportedOperationException();
2155     }
2156 
2157     /**
2158      * Indicates whether the cursor is on the first row in this
2159      * {@code CachedRowSetImpl} object.
2160      *
2161      * @return {@code true} if the cursor is on the first row;
2162      *         {@code false} otherwise or if the rowset contains no rows
2163      * @throws SQLException if an error occurs
2164      */
2165     public boolean isFirst() throws SQLException {
2166         throw new UnsupportedOperationException();
2167     }
2168 
2169     /**
2170      * Indicates whether the cursor is on the last row in this
2171      * {@code CachedRowSetImpl} object.
2172      * &lt;P&gt;
2173      * Note: Calling the method {@code isLast} may be expensive
2174      * because the JDBC driver might need to fetch ahead one row in order
2175      * to determine whether the current row is the last row in this rowset.
2176      *
2177      * @return {@code true} if the cursor is on the last row;
2178      *         {@code false} otherwise or if this rowset contains no rows
2179      * @throws SQLException if an error occurs
2180      */
2181     public boolean isLast() throws SQLException {
2182         throw new UnsupportedOperationException();
2183     }
2184 
2185     /**
2186      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the front of
2187      * the rowset, just before the first row. This method has no effect if
2188      * this rowset contains no rows.
2189      *
2190      * @throws SQLException if an error occurs or the type of this rowset
2191      *            is {@code ResultSet.TYPE_FORWARD_ONLY}
2192      */
2193     public void beforeFirst() throws SQLException {
2194         throw new UnsupportedOperationException();
2195     }
2196 
2197     /**
2198      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the end of
2199      * the rowset, just after the last row. This method has no effect if
2200      * this rowset contains no rows.
2201      *
2202      * @throws SQLException if an error occurs
2203      */
2204     public void afterLast() throws SQLException {
2205         throw new UnsupportedOperationException();
2206     }
2207 
2208     /**
2209      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the first row
2210      * and returns {@code true} if the operation was successful.  This
2211      * method also notifies registered listeners that the cursor has moved.
2212      *
2213      * @return {@code true} if the cursor is on a valid row;
2214      *         {@code false} otherwise or if there are no rows in this
2215      *         {@code CachedRowSetImpl} object
2216      * @throws SQLException if the type of this rowset
2217      *            is {@code ResultSet.TYPE_FORWARD_ONLY}
2218      */
2219     public boolean first() throws SQLException {
2220         throw new UnsupportedOperationException();
2221     }
2222 
2223     /**
2224      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the first
2225      * row and returns {@code true} if the operation is successful.
2226      * &lt;P&gt;
2227      * This method is called internally by the methods {@code first},
2228      * {@code isFirst}, and {@code absolute}.
2229      * It in turn calls the method {@code internalNext} in order to
2230      * handle the case where the first row is a deleted row that is not visible.
2231      * &lt;p&gt;
2232      * This is a implementation only method and is not required as a standard
2233      * implementation of the {@code CachedRowSet} interface.
2234      *
2235      * @return {@code true} if the cursor moved to the first row;
2236      *         {@code false} otherwise
2237      * @throws SQLException if an error occurs
2238      */
2239     protected boolean internalFirst() throws SQLException {
2240         throw new UnsupportedOperationException();
2241     }
2242 
2243     /**
2244      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the last row
2245      * and returns {@code true} if the operation was successful.  This
2246      * method also notifies registered listeners that the cursor has moved.
2247      *
2248      * @return {@code true} if the cursor is on a valid row;
2249      *         {@code false} otherwise or if there are no rows in this
2250      *         {@code CachedRowSetImpl} object
2251      * @throws SQLException if the type of this rowset
2252      *            is {@code ResultSet.TYPE_FORWARD_ONLY}
2253      */
2254     public boolean last() throws SQLException {
2255         throw new UnsupportedOperationException();
2256     }
2257 
2258     /**
2259      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the last
2260      * row and returns {@code true} if the operation is successful.
2261      * &lt;P&gt;
2262      * This method is called internally by the method {@code last}
2263      * when rows have been deleted and the deletions are not visible.
2264      * The method {@code internalLast} handles the case where the
2265      * last row is a deleted row that is not visible by in turn calling
2266      * the method {@code internalPrevious}.
2267      * &lt;p&gt;
2268      * This is a implementation only method and is not required as a standard
2269      * implementation of the {@code CachedRowSet} interface.
2270      *
2271      * @return {@code true} if the cursor moved to the last row;
2272      *         {@code false} otherwise
2273      * @throws SQLException if an error occurs
2274      */
2275     protected boolean internalLast() throws SQLException {
2276         throw new UnsupportedOperationException();
2277     }
2278 
2279     /**
2280      * Returns the number of the current row in this {@code CachedRowSetImpl}
2281      * object. The first row is number 1, the second number 2, and so on.
2282      *
2283      * @return the number of the current row;  {@code 0} if there is no
2284      *         current row
2285      * @throws SQLException if an error occurs; or if the {@code CacheRowSetImpl}
2286      *         is empty
2287      */
2288     public int getRow() throws SQLException {
2289         return crsSync.getRow();
2290     }
2291 
2292     /**
2293      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the row number
2294      * specified.
2295      *
2296      * &lt;p&gt;If the number is positive, the cursor moves to an absolute row with
2297      * respect to the beginning of the rowset.  The first row is row 1, the second
2298      * is row 2, and so on.  For example, the following command, in which
2299      * {@code crs} is a {@code CachedRowSetImpl} object, moves the cursor
2300      * to the fourth row, starting from the beginning of the rowset.
2301      * &lt;PRE&gt;{@code
2302      *
2303      *    crs.absolute(4);
2304      *
2305      * }&lt;/PRE&gt;
2306      * &lt;P&gt;
2307      * If the number is negative, the cursor moves to an absolute row position
2308      * with respect to the end of the rowset.  For example, calling
2309      * {@code absolute(-1)} positions the cursor on the last row,
2310      * {@code absolute(-2)} moves it on the next-to-last row, and so on.
2311      * If the {@code CachedRowSetImpl} object {@code crs} has five rows,
2312      * the following command moves the cursor to the fourth-to-last row, which
2313      * in the case of a  rowset with five rows, is also the second row, counting
2314      * from the beginning.
2315      * &lt;PRE&gt;{@code
2316      *
2317      *    crs.absolute(-4);
2318      *
2319      * }&lt;/PRE&gt;
2320      *
2321      * If the number specified is larger than the number of rows, the cursor
2322      * will move to the position after the last row. If the number specified
2323      * would move the cursor one or more rows before the first row, the cursor
2324      * moves to the position before the first row.
2325      * &lt;P&gt;
2326      * Note: Calling {@code absolute(1)} is the same as calling the
2327      * method {@code first()}.  Calling {@code absolute(-1)} is the
2328      * same as calling {@code last()}.
2329      *
2330      * @param row a positive number to indicate the row, starting row numbering from
2331      *        the first row, which is {@code 1}; a negative number to indicate
2332      *        the row, starting row numbering from the last row, which is
2333      *        {@code -1}; it must not be {@code 0}
2334      * @return {@code true} if the cursor is on the rowset; {@code false}
2335      *         otherwise
2336      * @throws SQLException if the given cursor position is {@code 0} or the
2337      *            type of this rowset is {@code ResultSet.TYPE_FORWARD_ONLY}
2338      */
2339     public boolean absolute( int row ) throws SQLException {
2340         throw new UnsupportedOperationException();
2341     }
2342 
2343     /**
2344      * Moves the cursor the specified number of rows from the current
2345      * position, with a positive number moving it forward and a
2346      * negative number moving it backward.
2347      * &lt;P&gt;
2348      * If the number is positive, the cursor moves the specified number of
2349      * rows toward the end of the rowset, starting at the current row.
2350      * For example, the following command, in which
2351      * {@code crs} is a {@code CachedRowSetImpl} object with 100 rows,
2352      * moves the cursor forward four rows from the current row.  If the
2353      * current row is 50, the cursor would move to row 54.
2354      * &lt;PRE&gt;{@code
2355      *
2356      *    crs.relative(4);
2357      *
2358      * }&lt;/PRE&gt;
2359      * &lt;P&gt;
2360      * If the number is negative, the cursor moves back toward the beginning
2361      * the specified number of rows, starting at the current row.
2362      * For example, calling the method
2363      * {@code absolute(-1)} positions the cursor on the last row,
2364      * {@code absolute(-2)} moves it on the next-to-last row, and so on.
2365      * If the {@code CachedRowSetImpl} object {@code crs} has five rows,
2366      * the following command moves the cursor to the fourth-to-last row, which
2367      * in the case of a  rowset with five rows, is also the second row
2368      * from the beginning.
2369      * &lt;PRE&gt;{@code
2370      *
2371      *    crs.absolute(-4);
2372      *
2373      * }&lt;/PRE&gt;
2374      *
2375      * If the number specified is larger than the number of rows, the cursor
2376      * will move to the position after the last row. If the number specified
2377      * would move the cursor one or more rows before the first row, the cursor
2378      * moves to the position before the first row. In both cases, this method
2379      * throws an {@code SQLException}.
2380      * &lt;P&gt;
2381      * Note: Calling {@code absolute(1)} is the same as calling the
2382      * method {@code first()}.  Calling {@code absolute(-1)} is the
2383      * same as calling {@code last()}.  Calling {@code relative(0)}
2384      * is valid, but it does not change the cursor position.
2385      *
2386      * @param rows an {@code int} indicating the number of rows to move
2387      *             the cursor, starting at the current row; a positive number
2388      *             moves the cursor forward; a negative number moves the cursor
2389      *             backward; must not move the cursor past the valid
2390      *             rows
2391      * @return {@code true} if the cursor is on a row in this
2392      *         {@code CachedRowSetImpl} object; {@code false}
2393      *         otherwise
2394      * @throws SQLException if there are no rows in this rowset, the cursor is
2395      *         positioned either before the first row or after the last row, or
2396      *         the rowset is type {@code ResultSet.TYPE_FORWARD_ONLY}
2397      */
2398     public boolean relative(int rows) throws SQLException {
2399         throw new UnsupportedOperationException();
2400     }
2401 
2402     /**
2403      * Moves this {@code CachedRowSetImpl} object&#39;s cursor to the
2404      * previous row and returns {@code true} if the cursor is on
2405      * a valid row or {@code false} if it is not.
2406      * This method also notifies all listeners registered with this
2407      * {@code CachedRowSetImpl} object that its cursor has moved.
2408      * &lt;P&gt;
2409      * Note: calling the method {@code previous()} is not the same
2410      * as calling the method {@code relative(-1)}.  This is true
2411      * because it is possible to call {@code previous()} from the insert
2412      * row, from after the last row, or from the current row, whereas
2413      * {@code relative} may only be called from the current row.
2414      * &lt;P&gt;
2415      * The method {@code previous} may used in a {@code while}
2416      * loop to iterate through a rowset starting after the last row
2417      * and moving toward the beginning. The loop ends when {@code previous}
2418      * returns {@code false}, meaning that there are no more rows.
2419      * For example, the following code fragment retrieves all the data in
2420      * the {@code CachedRowSetImpl} object {@code crs}, which has
2421      * three columns.  Note that the cursor must initially be positioned
2422      * after the last row so that the first call to the method
2423      * {@code previous} places the cursor on the last line.
2424      * &lt;PRE&gt;{@code
2425      *
2426      *     crs.afterLast();
2427      *     while (previous()) {
2428      *         String name = crs.getString(1);
2429      *         int age = crs.getInt(2);
2430      *         short ssn = crs.getShort(3);
2431      *         System.out.println(name + &quot;   &quot; + age + &quot;   &quot; + ssn);
2432      *     }
2433      *
2434      * }&lt;/PRE&gt;
2435      * This method throws an {@code SQLException} if the cursor is not
2436      * on a row in the rowset, before the first row, or after the last row.
2437      *
2438      * @return {@code true} if the cursor is on a valid row;
2439      *         {@code false} if it is before the first row or after the
2440      *         last row
2441      * @throws SQLException if the cursor is not on a valid position or the
2442      *           type of this rowset is {@code ResultSet.TYPE_FORWARD_ONLY}
2443      */
2444     public boolean previous() throws SQLException {
2445         throw new UnsupportedOperationException();
2446     }
2447 
2448     /**
2449      * Moves the cursor to the previous row in this {@code CachedRowSetImpl}
2450      * object, skipping past deleted rows that are not visible; returns
2451      * {@code true} if the cursor is on a row in this rowset and
2452      * {@code false} when the cursor goes before the first row.
2453      * &lt;P&gt;
2454      * This method is called internally by the method {@code previous}.
2455      * &lt;P&gt;
2456      * This is a implementation only method and is not required as a standard
2457      * implementation of the {@code CachedRowSet} interface.
2458      *
2459      * @return {@code true} if the cursor is on a row in this rowset;
2460      *         {@code false} when the cursor reaches the position before
2461      *         the first row
2462      * @throws SQLException if an error occurs
2463      */
2464     protected boolean internalPrevious() throws SQLException {
2465         throw new UnsupportedOperationException();
2466     }
2467 
2468 
2469     //---------------------------------------------------------------------
2470     // Updates
2471     //---------------------------------------------------------------------
2472 
2473     /**
2474      * Indicates whether the current row of this {@code CachedRowSetImpl}
2475      * object has been updated.  The value returned
2476      * depends on whether this rowset can detect updates: {@code false}
2477      * will always be returned if it does not detect updates.
2478      *
2479      * @return {@code true} if the row has been visibly updated
2480      *         by the owner or another and updates are detected;
2481      *         {@code false} otherwise
2482      * @throws SQLException if the cursor is on the insert row or not
2483      *            not on a valid row
2484      *
2485      * @see DatabaseMetaData#updatesAreDetected
2486      */
2487     public boolean rowUpdated() throws SQLException {
2488         throw new UnsupportedOperationException();
2489     }
2490 
2491     /**
2492      * Indicates whether the designated column of the current row of
2493      * this {@code CachedRowSetImpl} object has been updated. The
2494      * value returned depends on whether this rowset can detcted updates:
2495      * {@code false} will always be returned if it does not detect updates.
2496      *
2497      * @param idx the index identifier of the column that may be have been updated.
2498      * @return {@code true} is the designated column has been updated
2499      * and the rowset detects updates; {@code false} if the rowset has not
2500      * been updated or the rowset does not detect updates
2501      * @throws SQLException if the cursor is on the insert row or not
2502      *          on a valid row
2503      * @see DatabaseMetaData#updatesAreDetected
2504      */
2505     public boolean columnUpdated(int idx) throws SQLException {
2506         throw new UnsupportedOperationException();
2507     }
2508 
2509     /**
2510      * Indicates whether the designated column of the current row of
2511      * this {@code CachedRowSetImpl} object has been updated. The
2512      * value returned depends on whether this rowset can detcted updates:
2513      * {@code false} will always be returned if it does not detect updates.
2514      *
2515      * @param columnName the {@code String} column name column that may be have
2516      * been updated.
2517      * @return {@code true} is the designated column has been updated
2518      * and the rowset detects updates; {@code false} if the rowset has not
2519      * been updated or the rowset does not detect updates
2520      * @throws SQLException if the cursor is on the insert row or not
2521      *          on a valid row
2522      * @see DatabaseMetaData#updatesAreDetected
2523      */
2524     public boolean columnUpdated(String columnName) throws SQLException {
2525         throw new UnsupportedOperationException();
2526     }
2527 
2528     /**
2529      * Indicates whether the current row has been inserted.  The value returned
2530      * depends on whether or not the rowset can detect visible inserts.
2531      *
2532      * @return {@code true} if a row has been inserted and inserts are detected;
2533      *         {@code false} otherwise
2534      * @throws SQLException if the cursor is on the insert row or not
2535      *            not on a valid row
2536      *
2537      * @see DatabaseMetaData#insertsAreDetected
2538      */
2539     public boolean rowInserted() throws SQLException {
2540         throw new UnsupportedOperationException();
2541     }
2542 
2543     /**
2544      * Indicates whether the current row has been deleted.  A deleted row
2545      * may leave a visible &quot;hole&quot; in a rowset.  This method can be used to
2546      * detect such holes if the rowset can detect deletions. This method
2547      * will always return {@code false} if this rowset cannot detect
2548      * deletions.
2549      *
2550      * @return {@code true} if (1)the current row is blank, indicating that
2551      *         the row has been deleted, and (2)deletions are detected;
2552      *         {@code false} otherwise
2553      * @throws SQLException if the cursor is on a valid row in this rowset
2554      * @see DatabaseMetaData#deletesAreDetected
2555      */
2556     public boolean rowDeleted() throws SQLException {
2557         throw new UnsupportedOperationException();
2558     }
2559 
2560     /**
2561      * Sets the designated nullable column in the current row or the
2562      * insert row of this {@code CachedRowSetImpl} object with
2563      * {@code null} value.
2564      * &lt;P&gt;
2565      * This method updates a column value in the current row or the insert
2566      * row of this rowset; however, another method must be called to complete
2567      * the update process. If the cursor is on a row in the rowset, the
2568      * method {@link #updateRow} must be called to mark the row as updated
2569      * and to notify listeners that the row has changed.
2570      * If the cursor is on the insert row, the method {@link #insertRow}
2571      * must be called to insert the new row into this rowset and to notify
2572      * listeners that a row has changed.
2573      * &lt;P&gt;
2574      * In order to propagate updates in this rowset to the underlying
2575      * data source, an application must call the method {@link #acceptChanges}
2576      * after it calls either {@code updateRow} or {@code insertRow}.
2577      *
2578      * @param columnIndex the first column is {@code 1}, the second
2579      *        is {@code 2}, and so on; must be {@code 1} or larger
2580      *        and equal to or less than the number of columns in this rowset
2581      * @throws SQLException if (1) the given column index is out of bounds,
2582      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2583      *            insert row, or (3) this rowset is
2584      *            {@code ResultSet.CONCUR_READ_ONLY}
2585      */
2586     public void updateNull(int columnIndex) throws SQLException {
2587         throw new UnsupportedOperationException();
2588     }
2589 
2590     /**
2591      * Sets the designated column in either the current row or the insert
2592      * row of this {@code CachedRowSetImpl} object with the given
2593      * {@code boolean} value.
2594      * &lt;P&gt;
2595      * This method updates a column value in the current row or the insert
2596      * row of this rowset, but it does not update the database.
2597      * If the cursor is on a row in the rowset, the
2598      * method {@link #updateRow} must be called to update the database.
2599      * If the cursor is on the insert row, the method {@link #insertRow}
2600      * must be called, which will insert the new row into both this rowset
2601      * and the database. Both of these methods must be called before the
2602      * cursor moves to another row.
2603      *
2604      * @param columnIndex the first column is {@code 1}, the second
2605      *        is {@code 2}, and so on; must be {@code 1} or larger
2606      *        and equal to or less than the number of columns in this rowset
2607      * @param x the new column value
2608      * @throws SQLException if (1) the given column index is out of bounds,
2609      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2610      *            insert row, or (3) this rowset is
2611      *            {@code ResultSet.CONCUR_READ_ONLY}
2612      */
2613     public void updateBoolean(int columnIndex, boolean x) throws SQLException {
2614         throw new UnsupportedOperationException();
2615     }
2616 
2617     /**
2618      * Sets the designated column in either the current row or the insert
2619      * row of this {@code CachedRowSetImpl} object with the given
2620      * {@code byte} value.
2621      * &lt;P&gt;
2622      * This method updates a column value in the current row or the insert
2623      * row of this rowset, but it does not update the database.
2624      * If the cursor is on a row in the rowset, the
2625      * method {@link #updateRow} must be called to update the database.
2626      * If the cursor is on the insert row, the method {@link #insertRow}
2627      * must be called, which will insert the new row into both this rowset
2628      * and the database. Both of these methods must be called before the
2629      * cursor moves to another row.
2630      *
2631      * @param columnIndex the first column is {@code 1}, the second
2632      *        is {@code 2}, and so on; must be {@code 1} or larger
2633      *        and equal to or less than the number of columns in this rowset
2634      * @param x the new column value
2635      * @throws SQLException if (1) the given column index is out of bounds,
2636      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2637      *            insert row, or (3) this rowset is
2638      *            {@code ResultSet.CONCUR_READ_ONLY}
2639      */
2640     public void updateByte(int columnIndex, byte x) throws SQLException {
2641         throw new UnsupportedOperationException();
2642     }
2643 
2644     /**
2645      * Sets the designated column in either the current row or the insert
2646      * row of this {@code CachedRowSetImpl} object with the given
2647      * {@code short} value.
2648      * &lt;P&gt;
2649      * This method updates a column value in the current row or the insert
2650      * row of this rowset, but it does not update the database.
2651      * If the cursor is on a row in the rowset, the
2652      * method {@link #updateRow} must be called to update the database.
2653      * If the cursor is on the insert row, the method {@link #insertRow}
2654      * must be called, which will insert the new row into both this rowset
2655      * and the database. Both of these methods must be called before the
2656      * cursor moves to another row.
2657      *
2658      * @param columnIndex the first column is {@code 1}, the second
2659      *        is {@code 2}, and so on; must be {@code 1} or larger
2660      *        and equal to or less than the number of columns in this rowset
2661      * @param x the new column value
2662      * @throws SQLException if (1) the given column index is out of bounds,
2663      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2664      *            insert row, or (3) this rowset is
2665      *            {@code ResultSet.CONCUR_READ_ONLY}
2666      */
2667     public void updateShort(int columnIndex, short x) throws SQLException {
2668         throw new UnsupportedOperationException();
2669     }
2670 
2671     /**
2672      * Sets the designated column in either the current row or the insert
2673      * row of this {@code CachedRowSetImpl} object with the given
2674      * {@code int} value.
2675      * &lt;P&gt;
2676      * This method updates a column value in the current row or the insert
2677      * row of this rowset, but it does not update the database.
2678      * If the cursor is on a row in the rowset, the
2679      * method {@link #updateRow} must be called to update the database.
2680      * If the cursor is on the insert row, the method {@link #insertRow}
2681      * must be called, which will insert the new row into both this rowset
2682      * and the database. Both of these methods must be called before the
2683      * cursor moves to another row.
2684      *
2685      * @param columnIndex the first column is {@code 1}, the second
2686      *        is {@code 2}, and so on; must be {@code 1} or larger
2687      *        and equal to or less than the number of columns in this rowset
2688      * @param x the new column value
2689      * @throws SQLException if (1) the given column index is out of bounds,
2690      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2691      *            insert row, or (3) this rowset is
2692      *            {@code ResultSet.CONCUR_READ_ONLY}
2693      */
2694     public void updateInt(int columnIndex, int x) throws SQLException {
2695         throw new UnsupportedOperationException();
2696     }
2697 
2698     /**
2699      * Sets the designated column in either the current row or the insert
2700      * row of this {@code CachedRowSetImpl} object with the given
2701      * {@code long} value.
2702      * &lt;P&gt;
2703      * This method updates a column value in the current row or the insert
2704      * row of this rowset, but it does not update the database.
2705      * If the cursor is on a row in the rowset, the
2706      * method {@link #updateRow} must be called to update the database.
2707      * If the cursor is on the insert row, the method {@link #insertRow}
2708      * must be called, which will insert the new row into both this rowset
2709      * and the database. Both of these methods must be called before the
2710      * cursor moves to another row.
2711      *
2712      * @param columnIndex the first column is {@code 1}, the second
2713      *        is {@code 2}, and so on; must be {@code 1} or larger
2714      *        and equal to or less than the number of columns in this rowset
2715      * @param x the new column value
2716      * @throws SQLException if (1) the given column index is out of bounds,
2717      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2718      *            insert row, or (3) this rowset is
2719      *            {@code ResultSet.CONCUR_READ_ONLY}
2720      */
2721     public void updateLong(int columnIndex, long x) throws SQLException {
2722        throw new UnsupportedOperationException();
2723 
2724     }
2725 
2726     /**
2727      * Sets the designated column in either the current row or the insert
2728      * row of this {@code CachedRowSetImpl} object with the given
2729      * {@code float} value.
2730      * &lt;P&gt;
2731      * This method updates a column value in the current row or the insert
2732      * row of this rowset, but it does not update the database.
2733      * If the cursor is on a row in the rowset, the
2734      * method {@link #updateRow} must be called to update the database.
2735      * If the cursor is on the insert row, the method {@link #insertRow}
2736      * must be called, which will insert the new row into both this rowset
2737      * and the database. Both of these methods must be called before the
2738      * cursor moves to another row.
2739      *
2740      * @param columnIndex the first column is {@code 1}, the second
2741      *        is {@code 2}, and so on; must be {@code 1} or larger
2742      *        and equal to or less than the number of columns in this rowset
2743      * @param x the new column value
2744      * @throws SQLException if (1) the given column index is out of bounds,
2745      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2746      *            insert row, or (3) this rowset is
2747      *            {@code ResultSet.CONCUR_READ_ONLY}
2748      */
2749     public void updateFloat(int columnIndex, float x) throws SQLException {
2750         throw new UnsupportedOperationException();
2751     }
2752 
2753     /**
2754      * Sets the designated column in either the current row or the insert
2755      * row of this {@code CachedRowSetImpl} object with the given
2756      * {@code double} value.
2757      *
2758      * This method updates a column value in either the current row or
2759      * the insert row of this rowset, but it does not update the
2760      * database.  If the cursor is on a row in the rowset, the
2761      * method {@link #updateRow} must be called to update the database.
2762      * If the cursor is on the insert row, the method {@link #insertRow}
2763      * must be called, which will insert the new row into both this rowset
2764      * and the database. Both of these methods must be called before the
2765      * cursor moves to another row.
2766      *
2767      * @param columnIndex the first column is {@code 1}, the second
2768      *        is {@code 2}, and so on; must be {@code 1} or larger
2769      *        and equal to or less than the number of columns in this rowset
2770      * @param x the new column value
2771      * @throws SQLException if (1) the given column index is out of bounds,
2772      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2773      *            insert row, or (3) this rowset is
2774      *            {@code ResultSet.CONCUR_READ_ONLY}
2775      */
2776     public void updateDouble(int columnIndex, double x) throws SQLException {
2777         throw new UnsupportedOperationException();
2778     }
2779 
2780     /**
2781      * Sets the designated column in either the current row or the insert
2782      * row of this {@code CachedRowSetImpl} object with the given
2783      * {@code java.math.BigDecimal} object.
2784      * &lt;P&gt;
2785      * This method updates a column value in the current row or the insert
2786      * row of this rowset, but it does not update the database.
2787      * If the cursor is on a row in the rowset, the
2788      * method {@link #updateRow} must be called to update the database.
2789      * If the cursor is on the insert row, the method {@link #insertRow}
2790      * must be called, which will insert the new row into both this rowset
2791      * and the database. Both of these methods must be called before the
2792      * cursor moves to another row.
2793      *
2794      * @param columnIndex the first column is {@code 1}, the second
2795      *        is {@code 2}, and so on; must be {@code 1} or larger
2796      *        and equal to or less than the number of columns in this rowset
2797      * @param x the new column value
2798      * @throws SQLException if (1) the given column index is out of bounds,
2799      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2800      *            insert row, or (3) this rowset is
2801      *            {@code ResultSet.CONCUR_READ_ONLY}
2802      */
2803     public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
2804         throw new UnsupportedOperationException();
2805     }
2806 
2807     /**
2808      * Sets the designated column in either the current row or the insert
2809      * row of this {@code CachedRowSetImpl} object with the given
2810      * {@code String} object.
2811      * &lt;P&gt;
2812      * This method updates a column value in either the current row or
2813      * the insert row of this rowset, but it does not update the
2814      * database.  If the cursor is on a row in the rowset, the
2815      * method {@link #updateRow} must be called to mark the row as updated.
2816      * If the cursor is on the insert row, the method {@link #insertRow}
2817      * must be called to insert the new row into this rowset and mark it
2818      * as inserted. Both of these methods must be called before the
2819      * cursor moves to another row.
2820      * &lt;P&gt;
2821      * The method {@code acceptChanges} must be called if the
2822      * updated values are to be written back to the underlying database.
2823      *
2824      * @param columnIndex the first column is {@code 1}, the second
2825      *        is {@code 2}, and so on; must be {@code 1} or larger
2826      *        and equal to or less than the number of columns in this rowset
2827      * @param x the new column value
2828      * @throws SQLException if (1) the given column index is out of bounds,
2829      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2830      *            insert row, or (3) this rowset is
2831      *            {@code ResultSet.CONCUR_READ_ONLY}
2832      */
2833     public void updateString(int columnIndex, String x) throws SQLException {
2834         throw new UnsupportedOperationException();
2835     }
2836 
2837     /**
2838      * Sets the designated column in either the current row or the insert
2839      * row of this {@code CachedRowSetImpl} object with the given
2840      * {@code byte} array.
2841      *
2842      * This method updates a column value in either the current row or
2843      * the insert row of this rowset, but it does not update the
2844      * database.  If the cursor is on a row in the rowset, the
2845      * method {@link #updateRow} must be called to update the database.
2846      * If the cursor is on the insert row, the method {@link #insertRow}
2847      * must be called, which will insert the new row into both this rowset
2848      * and the database. Both of these methods must be called before the
2849      * cursor moves to another row.
2850      *
2851      * @param columnIndex the first column is {@code 1}, the second
2852      *        is {@code 2}, and so on; must be {@code 1} or larger
2853      *        and equal to or less than the number of columns in this rowset
2854      * @param x the new column value
2855      * @throws SQLException if (1) the given column index is out of bounds,
2856      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2857      *            insert row, or (3) this rowset is
2858      *            {@code ResultSet.CONCUR_READ_ONLY}
2859      */
2860     public void updateBytes(int columnIndex, byte x[]) throws SQLException {
2861         throw new UnsupportedOperationException();
2862     }
2863 
2864     /**
2865      * Sets the designated column in either the current row or the insert
2866      * row of this {@code CachedRowSetImpl} object with the given
2867      * {@code Date} object.
2868      *
2869      * This method updates a column value in either the current row or
2870      * the insert row of this rowset, but it does not update the
2871      * database.  If the cursor is on a row in the rowset, the
2872      * method {@link #updateRow} must be called to update the database.
2873      * If the cursor is on the insert row, the method {@link #insertRow}
2874      * must be called, which will insert the new row into both this rowset
2875      * and the database. Both of these methods must be called before the
2876      * cursor moves to another row.
2877      *
2878      * @param columnIndex the first column is {@code 1}, the second
2879      *        is {@code 2}, and so on; must be {@code 1} or larger
2880      *        and equal to or less than the number of columns in this rowset
2881      * @param x the new column value
2882      * @throws SQLException if (1) the given column index is out of bounds,
2883      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2884      *            insert row, (3) the type of the designated column is not
2885      *            an SQL {@code DATE} or {@code TIMESTAMP}, or
2886      *            (4) this rowset is {@code ResultSet.CONCUR_READ_ONLY}
2887      */
2888     public void updateDate(int columnIndex, java.sql.Date x) throws SQLException {
2889         throw new UnsupportedOperationException();
2890     }
2891 
2892     /**
2893      * Sets the designated column in either the current row or the insert
2894      * row of this {@code CachedRowSetImpl} object with the given
2895      * {@code Time} object.
2896      *
2897      * This method updates a column value in either the current row or
2898      * the insert row of this rowset, but it does not update the
2899      * database.  If the cursor is on a row in the rowset, the
2900      * method {@link #updateRow} must be called to update the database.
2901      * If the cursor is on the insert row, the method {@link #insertRow}
2902      * must be called, which will insert the new row into both this rowset
2903      * and the database. Both of these methods must be called before the
2904      * cursor moves to another row.
2905      *
2906      * @param columnIndex the first column is {@code 1}, the second
2907      *        is {@code 2}, and so on; must be {@code 1} or larger
2908      *        and equal to or less than the number of columns in this rowset
2909      * @param x the new column value
2910      * @throws SQLException if (1) the given column index is out of bounds,
2911      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2912      *            insert row, (3) the type of the designated column is not
2913      *            an SQL {@code TIME} or {@code TIMESTAMP}, or
2914      *            (4) this rowset is {@code ResultSet.CONCUR_READ_ONLY}
2915      */
2916     public void updateTime(int columnIndex, java.sql.Time x) throws SQLException {
2917        throw new UnsupportedOperationException();
2918     }
2919 
2920     /**
2921      * Sets the designated column in either the current row or the insert
2922      * row of this {@code CachedRowSetImpl} object with the given
2923      * {@code Timestamp} object.
2924      *
2925      * This method updates a column value in either the current row or
2926      * the insert row of this rowset, but it does not update the
2927      * database.  If the cursor is on a row in the rowset, the
2928      * method {@link #updateRow} must be called to update the database.
2929      * If the cursor is on the insert row, the method {@link #insertRow}
2930      * must be called, which will insert the new row into both this rowset
2931      * and the database. Both of these methods must be called before the
2932      * cursor moves to another row.
2933      *
2934      * @param columnIndex the first column is {@code 1}, the second
2935      *        is {@code 2}, and so on; must be {@code 1} or larger
2936      *        and equal to or less than the number of columns in this rowset
2937      * @param x the new column value
2938      * @throws SQLException if (1) the given column index is out of bounds,
2939      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2940      *            insert row, (3) the type of the designated column is not
2941      *            an SQL {@code DATE}, {@code TIME}, or
2942      *            {@code TIMESTAMP}, or (4) this rowset is
2943      *            {@code ResultSet.CONCUR_READ_ONLY}
2944      */
2945     public void updateTimestamp(int columnIndex, java.sql.Timestamp x) throws SQLException {
2946         throw new UnsupportedOperationException();
2947     }
2948 
2949     /**
2950      * Sets the designated column in either the current row or the insert
2951      * row of this {@code CachedRowSetImpl} object with the given
2952      * ASCII stream value.
2953      * &lt;P&gt;
2954      * This method updates a column value in either the current row or
2955      * the insert row of this rowset, but it does not update the
2956      * database.  If the cursor is on a row in the rowset, the
2957      * method {@link #updateRow} must be called to update the database.
2958      * If the cursor is on the insert row, the method {@link #insertRow}
2959      * must be called, which will insert the new row into both this rowset
2960      * and the database. Both of these methods must be called before the
2961      * cursor moves to another row.
2962      *
2963      * @param columnIndex the first column is {@code 1}, the second
2964      *        is {@code 2}, and so on; must be {@code 1} or larger
2965      *        and equal to or less than the number of columns in this rowset
2966      * @param x the new column value
2967      * @param length the number of one-byte ASCII characters in the stream
2968      * @throws SQLException if this method is invoked
2969      */
2970     public void updateAsciiStream(int columnIndex, java.io.InputStream x, int length) throws SQLException {
2971         throw new UnsupportedOperationException();
2972     }
2973 
2974     /**
2975      * Sets the designated column in either the current row or the insert
2976      * row of this {@code CachedRowSetImpl} object with the given
2977      * {@code java.io.InputStream} object.
2978      * &lt;P&gt;
2979      * This method updates a column value in either the current row or
2980      * the insert row of this rowset, but it does not update the
2981      * database.  If the cursor is on a row in the rowset, the
2982      * method {@link #updateRow} must be called to update the database.
2983      * If the cursor is on the insert row, the method {@link #insertRow}
2984      * must be called, which will insert the new row into both this rowset
2985      * and the database. Both of these methods must be called before the
2986      * cursor moves to another row.
2987      *
2988      * @param columnIndex the first column is {@code 1}, the second
2989      *        is {@code 2}, and so on; must be {@code 1} or larger
2990      *        and equal to or less than the number of columns in this rowset
2991      * @param x the new column value; must be a {@code java.io.InputStream}
2992      *          containing {@code BINARY}, {@code VARBINARY}, or
2993      *          {@code LONGVARBINARY} data
2994      * @param length the length of the stream in bytes
2995      * @throws SQLException if (1) the given column index is out of bounds,
2996      *            (2) the cursor is not on one of this rowset&#39;s rows or its
2997      *            insert row, (3) the data in the stream is not binary, or
2998      *            (4) this rowset is {@code ResultSet.CONCUR_READ_ONLY}
2999      */
3000     public void updateBinaryStream(int columnIndex, java.io.InputStream x,int length) throws SQLException {
3001         throw new UnsupportedOperationException();
3002     }
3003 
3004     /**
3005      * Sets the designated column in either the current row or the insert
3006      * row of this {@code CachedRowSetImpl} object with the given
3007      * {@code java.io.Reader} object.
3008      * &lt;P&gt;
3009      * This method updates a column value in either the current row or
3010      * the insert row of this rowset, but it does not update the
3011      * database.  If the cursor is on a row in the rowset, the
3012      * method {@link #updateRow} must be called to update the database.
3013      * If the cursor is on the insert row, the method {@link #insertRow}
3014      * must be called, which will insert the new row into both this rowset
3015      * and the database. Both of these methods must be called before the
3016      * cursor moves to another row.
3017      *
3018      * @param columnIndex the first column is {@code 1}, the second
3019      *        is {@code 2}, and so on; must be {@code 1} or larger
3020      *        and equal to or less than the number of columns in this rowset
3021      * @param x the new column value; must be a {@code java.io.Reader}
3022      *          containing {@code BINARY}, {@code VARBINARY},
3023      *          {@code LONGVARBINARY}, {@code CHAR}, {@code VARCHAR},
3024      *          or {@code LONGVARCHAR} data
3025      * @param length the length of the stream in characters
3026      * @throws SQLException if (1) the given column index is out of bounds,
3027      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3028      *            insert row, (3) the data in the stream is not a binary or
3029      *            character type, or (4) this rowset is
3030      *            {@code ResultSet.CONCUR_READ_ONLY}
3031      */
3032     public void updateCharacterStream(int columnIndex, java.io.Reader x, int length) throws SQLException {
3033         throw new UnsupportedOperationException();
3034     }
3035 
3036     /**
3037      * Sets the designated column in either the current row or the insert
3038      * row of this {@code CachedRowSetImpl} object with the given
3039      * {@code Object} value.  The {@code scale} parameter indicates
3040      * the number of digits to the right of the decimal point and is ignored
3041      * if the new column value is not a type that will be mapped to an SQL
3042      * {@code DECIMAL} or {@code NUMERIC} value.
3043      * &lt;P&gt;
3044      * This method updates a column value in either the current row or
3045      * the insert row of this rowset, but it does not update the
3046      * database.  If the cursor is on a row in the rowset, the
3047      * method {@link #updateRow} must be called to update the database.
3048      * If the cursor is on the insert row, the method {@link #insertRow}
3049      * must be called, which will insert the new row into both this rowset
3050      * and the database. Both of these methods must be called before the
3051      * cursor moves to another row.
3052      *
3053      * @param columnIndex the first column is {@code 1}, the second
3054      *        is {@code 2}, and so on; must be {@code 1} or larger
3055      *        and equal to or less than the number of columns in this rowset
3056      * @param x the new column value
3057      * @param scale the number of digits to the right of the decimal point (for
3058      *              {@code DECIMAL} and {@code NUMERIC} types only)
3059      * @throws SQLException if (1) the given column index is out of bounds,
3060      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3061      *            insert row, or (3) this rowset is
3062      *            {@code ResultSet.CONCUR_READ_ONLY}
3063      */
3064     public void updateObject(int columnIndex, Object x, int scale) throws SQLException {
3065        throw new UnsupportedOperationException();
3066     }
3067 
3068     /**
3069      * Sets the designated column in either the current row or the insert
3070      * row of this {@code CachedRowSetImpl} object with the given
3071      * {@code Object} value.
3072      * &lt;P&gt;
3073      * This method updates a column value in either the current row or
3074      * the insert row of this rowset, but it does not update the
3075      * database.  If the cursor is on a row in the rowset, the
3076      * method {@link #updateRow} must be called to update the database.
3077      * If the cursor is on the insert row, the method {@link #insertRow}
3078      * must be called, which will insert the new row into both this rowset
3079      * and the database. Both of these methods must be called before the
3080      * cursor moves to another row.
3081      *
3082      * @param columnIndex the first column is {@code 1}, the second
3083      *        is {@code 2}, and so on; must be {@code 1} or larger
3084      *        and equal to or less than the number of columns in this rowset
3085      * @param x the new column value
3086      * @throws SQLException if (1) the given column index is out of bounds,
3087      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3088      *            insert row, or (3) this rowset is
3089      *            {@code ResultSet.CONCUR_READ_ONLY}
3090      */
3091     public void updateObject(int columnIndex, Object x) throws SQLException {
3092         throw new UnsupportedOperationException();
3093     }
3094 
3095 
3096     /**
3097      * Sets the designated nullable column in the current row or the
3098      * insert row of this {@code CachedRowSetImpl} object with
3099      * {@code null} value.
3100      * &lt;P&gt;
3101      * This method updates a column value in the current row or the insert
3102      * row of this rowset, but it does not update the database.
3103      * If the cursor is on a row in the rowset, the
3104      * method {@link #updateRow} must be called to update the database.
3105      * If the cursor is on the insert row, the method {@link #insertRow}
3106      * must be called, which will insert the new row into both this rowset
3107      * and the database.
3108      *
3109      * @param columnName a {@code String} object that must match the
3110      *        SQL name of a column in this rowset, ignoring case
3111      * @throws SQLException if (1) the given column name does not match the
3112      *            name of a column in this rowset, (2) the cursor is not on
3113      *            one of this rowset&#39;s rows or its insert row, or (3) this
3114      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3115      */
3116     public void updateNull(String columnName) throws SQLException {
3117         throw new UnsupportedOperationException();
3118     }
3119 
3120     /**
3121      * Sets the designated column in either the current row or the insert
3122      * row of this {@code CachedRowSetImpl} object with the given
3123      * {@code boolean} value.
3124      * &lt;P&gt;
3125      * This method updates a column value in the current row or the insert
3126      * row of this rowset, but it does not update the database.
3127      * If the cursor is on a row in the rowset, the
3128      * method {@link #updateRow} must be called to update the database.
3129      * If the cursor is on the insert row, the method {@link #insertRow}
3130      * must be called, which will insert the new row into both this rowset
3131      * and the database. Both of these methods must be called before the
3132      * cursor moves to another row.
3133      *
3134      * @param columnName a {@code String} object that must match the
3135      *        SQL name of a column in this rowset, ignoring case
3136      * @param x the new column value
3137      * @throws SQLException if (1) the given column name does not match the
3138      *            name of a column in this rowset, (2) the cursor is not on
3139      *            one of this rowset&#39;s rows or its insert row, or (3) this
3140      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3141      */
3142     public void updateBoolean(String columnName, boolean x) throws SQLException {
3143        throw new UnsupportedOperationException();
3144     }
3145 
3146     /**
3147      * Sets the designated column in either the current row or the insert
3148      * row of this {@code CachedRowSetImpl} object with the given
3149      * {@code byte} value.
3150      * &lt;P&gt;
3151      * This method updates a column value in the current row or the insert
3152      * row of this rowset, but it does not update the database.
3153      * If the cursor is on a row in the rowset, the
3154      * method {@link #updateRow} must be called to update the database.
3155      * If the cursor is on the insert row, the method {@link #insertRow}
3156      * must be called, which will insert the new row into both this rowset
3157      * and the database. Both of these methods must be called before the
3158      * cursor moves to another row.
3159      *
3160      * @param columnName a {@code String} object that must match the
3161      *        SQL name of a column in this rowset, ignoring case
3162      * @param x the new column value
3163      * @throws SQLException if (1) the given column name does not match the
3164      *            name of a column in this rowset, (2) the cursor is not on
3165      *            one of this rowset&#39;s rows or its insert row, or (3) this
3166      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3167      */
3168     public void updateByte(String columnName, byte x) throws SQLException {
3169         throw new UnsupportedOperationException();
3170     }
3171 
3172     /**
3173      * Sets the designated column in either the current row or the insert
3174      * row of this {@code CachedRowSetImpl} object with the given
3175      * {@code short} value.
3176      * &lt;P&gt;
3177      * This method updates a column value in the current row or the insert
3178      * row of this rowset, but it does not update the database.
3179      * If the cursor is on a row in the rowset, the
3180      * method {@link #updateRow} must be called to update the database.
3181      * If the cursor is on the insert row, the method {@link #insertRow}
3182      * must be called, which will insert the new row into both this rowset
3183      * and the database. Both of these methods must be called before the
3184      * cursor moves to another row.
3185      *
3186      * @param columnName a {@code String} object that must match the
3187      *        SQL name of a column in this rowset, ignoring case
3188      * @param x the new column value
3189      * @throws SQLException if (1) the given column name does not match the
3190      *            name of a column in this rowset, (2) the cursor is not on
3191      *            one of this rowset&#39;s rows or its insert row, or (3) this
3192      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3193      */
3194     public void updateShort(String columnName, short x) throws SQLException {
3195         throw new UnsupportedOperationException();
3196     }
3197 
3198     /**
3199      * Sets the designated column in either the current row or the insert
3200      * row of this {@code CachedRowSetImpl} object with the given
3201      * {@code int} value.
3202      * &lt;P&gt;
3203      * This method updates a column value in the current row or the insert
3204      * row of this rowset, but it does not update the database.
3205      * If the cursor is on a row in the rowset, the
3206      * method {@link #updateRow} must be called to update the database.
3207      * If the cursor is on the insert row, the method {@link #insertRow}
3208      * must be called, which will insert the new row into both this rowset
3209      * and the database. Both of these methods must be called before the
3210      * cursor moves to another row.
3211      *
3212      * @param columnName a {@code String} object that must match the
3213      *        SQL name of a column in this rowset, ignoring case
3214      * @param x the new column value
3215      * @throws SQLException if (1) the given column name does not match the
3216      *            name of a column in this rowset, (2) the cursor is not on
3217      *            one of this rowset&#39;s rows or its insert row, or (3) this
3218      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3219      */
3220     public void updateInt(String columnName, int x) throws SQLException {
3221         throw new UnsupportedOperationException();
3222     }
3223 
3224     /**
3225      * Sets the designated column in either the current row or the insert
3226      * row of this {@code CachedRowSetImpl} object with the given
3227      * {@code long} value.
3228      * &lt;P&gt;
3229      * This method updates a column value in the current row or the insert
3230      * row of this rowset, but it does not update the database.
3231      * If the cursor is on a row in the rowset, the
3232      * method {@link #updateRow} must be called to update the database.
3233      * If the cursor is on the insert row, the method {@link #insertRow}
3234      * must be called, which will insert the new row into both this rowset
3235      * and the database. Both of these methods must be called before the
3236      * cursor moves to another row.
3237      *
3238      * @param columnName a {@code String} object that must match the
3239      *        SQL name of a column in this rowset, ignoring case
3240      * @param x the new column value
3241      * @throws SQLException if (1) the given column name does not match the
3242      *            name of a column in this rowset, (2) the cursor is not on
3243      *            one of this rowset&#39;s rows or its insert row, or (3) this
3244      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3245      */
3246     public void updateLong(String columnName, long x) throws SQLException {
3247         throw new UnsupportedOperationException();
3248     }
3249 
3250     /**
3251      * Sets the designated column in either the current row or the insert
3252      * row of this {@code CachedRowSetImpl} object with the given
3253      * {@code float} value.
3254      * &lt;P&gt;
3255      * This method updates a column value in the current row or the insert
3256      * row of this rowset, but it does not update the database.
3257      * If the cursor is on a row in the rowset, the
3258      * method {@link #updateRow} must be called to update the database.
3259      * If the cursor is on the insert row, the method {@link #insertRow}
3260      * must be called, which will insert the new row into both this rowset
3261      * and the database. Both of these methods must be called before the
3262      * cursor moves to another row.
3263      *
3264      * @param columnName a {@code String} object that must match the
3265      *        SQL name of a column in this rowset, ignoring case
3266      * @param x the new column value
3267      * @throws SQLException if (1) the given column name does not match the
3268      *            name of a column in this rowset, (2) the cursor is not on
3269      *            one of this rowset&#39;s rows or its insert row, or (3) this
3270      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3271      */
3272     public void updateFloat(String columnName, float x) throws SQLException {
3273         throw new UnsupportedOperationException();
3274     }
3275 
3276     /**
3277      * Sets the designated column in either the current row or the insert
3278      * row of this {@code CachedRowSetImpl} object with the given
3279      * {@code double} value.
3280      *
3281      * This method updates a column value in either the current row or
3282      * the insert row of this rowset, but it does not update the
3283      * database.  If the cursor is on a row in the rowset, the
3284      * method {@link #updateRow} must be called to update the database.
3285      * If the cursor is on the insert row, the method {@link #insertRow}
3286      * must be called, which will insert the new row into both this rowset
3287      * and the database. Both of these methods must be called before the
3288      * cursor moves to another row.
3289      *
3290      * @param columnName a {@code String} object that must match the
3291      *        SQL name of a column in this rowset, ignoring case
3292      * @param x the new column value
3293      * @throws SQLException if (1) the given column name does not match the
3294      *            name of a column in this rowset, (2) the cursor is not on
3295      *            one of this rowset&#39;s rows or its insert row, or (3) this
3296      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3297      */
3298     public void updateDouble(String columnName, double x) throws SQLException {
3299         throw new UnsupportedOperationException();
3300     }
3301 
3302     /**
3303      * Sets the designated column in either the current row or the insert
3304      * row of this {@code CachedRowSetImpl} object with the given
3305      * {@code java.math.BigDecimal} object.
3306      * &lt;P&gt;
3307      * This method updates a column value in the current row or the insert
3308      * row of this rowset, but it does not update the database.
3309      * If the cursor is on a row in the rowset, the
3310      * method {@link #updateRow} must be called to update the database.
3311      * If the cursor is on the insert row, the method {@link #insertRow}
3312      * must be called, which will insert the new row into both this rowset
3313      * and the database. Both of these methods must be called before the
3314      * cursor moves to another row.
3315      *
3316      * @param columnName a {@code String} object that must match the
3317      *        SQL name of a column in this rowset, ignoring case
3318      * @param x the new column value
3319      * @throws SQLException if (1) the given column name does not match the
3320      *            name of a column in this rowset, (2) the cursor is not on
3321      *            one of this rowset&#39;s rows or its insert row, or (3) this
3322      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3323      */
3324     public void updateBigDecimal(String columnName, BigDecimal x) throws SQLException {
3325         throw new UnsupportedOperationException();
3326     }
3327 
3328     /**
3329      * Sets the designated column in either the current row or the insert
3330      * row of this {@code CachedRowSetImpl} object with the given
3331      * {@code String} object.
3332      *
3333      * This method updates a column value in either the current row or
3334      * the insert row of this rowset, but it does not update the
3335      * database.  If the cursor is on a row in the rowset, the
3336      * method {@link #updateRow} must be called to update the database.
3337      * If the cursor is on the insert row, the method {@link #insertRow}
3338      * must be called, which will insert the new row into both this rowset
3339      * and the database. Both of these methods must be called before the
3340      * cursor moves to another row.
3341      *
3342      * @param columnName a {@code String} object that must match the
3343      *        SQL name of a column in this rowset, ignoring case
3344      * @param x the new column value
3345      * @throws SQLException if (1) the given column name does not match the
3346      *            name of a column in this rowset, (2) the cursor is not on
3347      *            one of this rowset&#39;s rows or its insert row, or (3) this
3348      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3349      */
3350     public void updateString(String columnName, String x) throws SQLException {
3351         throw new UnsupportedOperationException();
3352     }
3353 
3354     /**
3355      * Sets the designated column in either the current row or the insert
3356      * row of this {@code CachedRowSetImpl} object with the given
3357      * {@code byte} array.
3358      *
3359      * This method updates a column value in either the current row or
3360      * the insert row of this rowset, but it does not update the
3361      * database.  If the cursor is on a row in the rowset, the
3362      * method {@link #updateRow} must be called to update the database.
3363      * If the cursor is on the insert row, the method {@link #insertRow}
3364      * must be called, which will insert the new row into both this rowset
3365      * and the database. Both of these methods must be called before the
3366      * cursor moves to another row.
3367      *
3368      * @param columnName a {@code String} object that must match the
3369      *        SQL name of a column in this rowset, ignoring case
3370      * @param x the new column value
3371      * @throws SQLException if (1) the given column name does not match the
3372      *            name of a column in this rowset, (2) the cursor is not on
3373      *            one of this rowset&#39;s rows or its insert row, or (3) this
3374      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3375      */
3376     public void updateBytes(String columnName, byte x[]) throws SQLException {
3377         throw new UnsupportedOperationException();
3378     }
3379 
3380     /**
3381      * Sets the designated column in either the current row or the insert
3382      * row of this {@code CachedRowSetImpl} object with the given
3383      * {@code Date} object.
3384      *
3385      * This method updates a column value in either the current row or
3386      * the insert row of this rowset, but it does not update the
3387      * database.  If the cursor is on a row in the rowset, the
3388      * method {@link #updateRow} must be called to update the database.
3389      * If the cursor is on the insert row, the method {@link #insertRow}
3390      * must be called, which will insert the new row into both this rowset
3391      * and the database. Both of these methods must be called before the
3392      * cursor moves to another row.
3393      *
3394      * @param columnName a {@code String} object that must match the
3395      *        SQL name of a column in this rowset, ignoring case
3396      * @param x the new column value
3397      * @throws SQLException if (1) the given column name does not match the
3398      *            name of a column in this rowset, (2) the cursor is not on
3399      *            one of this rowset&#39;s rows or its insert row, (3) the type
3400      *            of the designated column is not an SQL {@code DATE} or
3401      *            {@code TIMESTAMP}, or (4) this rowset is
3402      *            {@code ResultSet.CONCUR_READ_ONLY}
3403      */
3404     public void updateDate(String columnName, java.sql.Date x) throws SQLException {
3405         throw new UnsupportedOperationException();
3406     }
3407 
3408     /**
3409      * Sets the designated column in either the current row or the insert
3410      * row of this {@code CachedRowSetImpl} object with the given
3411      * {@code Time} object.
3412      *
3413      * This method updates a column value in either the current row or
3414      * the insert row of this rowset, but it does not update the
3415      * database.  If the cursor is on a row in the rowset, the
3416      * method {@link #updateRow} must be called to update the database.
3417      * If the cursor is on the insert row, the method {@link #insertRow}
3418      * must be called, which will insert the new row into both this rowset
3419      * and the database. Both of these methods must be called before the
3420      * cursor moves to another row.
3421      *
3422      * @param columnName a {@code String} object that must match the
3423      *        SQL name of a column in this rowset, ignoring case
3424      * @param x the new column value
3425      * @throws SQLException if (1) the given column name does not match the
3426      *            name of a column in this rowset, (2) the cursor is not on
3427      *            one of this rowset&#39;s rows or its insert row, (3) the type
3428      *            of the designated column is not an SQL {@code TIME} or
3429      *            {@code TIMESTAMP}, or (4) this rowset is
3430      *            {@code ResultSet.CONCUR_READ_ONLY}
3431      */
3432     public void updateTime(String columnName, java.sql.Time x) throws SQLException {
3433         throw new UnsupportedOperationException();
3434     }
3435 
3436     /**
3437      * Sets the designated column in either the current row or the insert
3438      * row of this {@code CachedRowSetImpl} object with the given
3439      * {@code Timestamp} object.
3440      *
3441      * This method updates a column value in either the current row or
3442      * the insert row of this rowset, but it does not update the
3443      * database.  If the cursor is on a row in the rowset, the
3444      * method {@link #updateRow} must be called to update the database.
3445      * If the cursor is on the insert row, the method {@link #insertRow}
3446      * must be called, which will insert the new row into both this rowset
3447      * and the database. Both of these methods must be called before the
3448      * cursor moves to another row.
3449      *
3450      * @param columnName a {@code String} object that must match the
3451      *        SQL name of a column in this rowset, ignoring case
3452      * @param x the new column value
3453      * @throws SQLException if the given column index is out of bounds or
3454      *            the cursor is not on one of this rowset&#39;s rows or its
3455      *            insert row
3456      * @throws SQLException if (1) the given column name does not match the
3457      *            name of a column in this rowset, (2) the cursor is not on
3458      *            one of this rowset&#39;s rows or its insert row, (3) the type
3459      *            of the designated column is not an SQL {@code DATE},
3460      *            {@code TIME}, or {@code TIMESTAMP}, or (4) this
3461      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3462      */
3463     public void updateTimestamp(String columnName, java.sql.Timestamp x) throws SQLException {
3464         throw new UnsupportedOperationException();
3465     }
3466 
3467     /**
3468      * Sets the designated column in either the current row or the insert
3469      * row of this {@code CachedRowSetImpl} object with the given
3470      * ASCII stream value.
3471      * &lt;P&gt;
3472      * This method updates a column value in either the current row or
3473      * the insert row of this rowset, but it does not update the
3474      * database.  If the cursor is on a row in the rowset, the
3475      * method {@link #updateRow} must be called to update the database.
3476      * If the cursor is on the insert row, the method {@link #insertRow}
3477      * must be called, which will insert the new row into both this rowset
3478      * and the database. Both of these methods must be called before the
3479      * cursor moves to another row.
3480      *
3481      * @param columnName a {@code String} object that must match the
3482      *        SQL name of a column in this rowset, ignoring case
3483      * @param x the new column value
3484      * @param length the number of one-byte ASCII characters in the stream
3485      */
3486     public void updateAsciiStream(String columnName,
3487     java.io.InputStream x,
3488     int length) throws SQLException {
3489        throw new UnsupportedOperationException();
3490     }
3491 
3492     /**
3493      * Sets the designated column in either the current row or the insert
3494      * row of this {@code CachedRowSetImpl} object with the given
3495      * {@code java.io.InputStream} object.
3496      * &lt;P&gt;
3497      * This method updates a column value in either the current row or
3498      * the insert row of this rowset, but it does not update the
3499      * database.  If the cursor is on a row in the rowset, the
3500      * method {@link #updateRow} must be called to update the database.
3501      * If the cursor is on the insert row, the method {@link #insertRow}
3502      * must be called, which will insert the new row into both this rowset
3503      * and the database. Both of these methods must be called before the
3504      * cursor moves to another row.
3505      *
3506      * @param columnName a {@code String} object that must match the
3507      *        SQL name of a column in this rowset, ignoring case
3508      * @param x the new column value; must be a {@code java.io.InputStream}
3509      *          containing {@code BINARY}, {@code VARBINARY}, or
3510      *          {@code LONGVARBINARY} data
3511      * @param length the length of the stream in bytes
3512      * @throws SQLException if (1) the given column name does not match the
3513      *            name of a column in this rowset, (2) the cursor is not on
3514      *            one of this rowset&#39;s rows or its insert row, (3) the data
3515      *            in the stream is not binary, or (4) this rowset is
3516      *            {@code ResultSet.CONCUR_READ_ONLY}
3517      */
3518     public void updateBinaryStream(String columnName, java.io.InputStream x, int length) throws SQLException {
3519         throw new UnsupportedOperationException();
3520     }
3521 
3522     /**
3523      * Sets the designated column in either the current row or the insert
3524      * row of this {@code CachedRowSetImpl} object with the given
3525      * {@code java.io.Reader} object.
3526      * &lt;P&gt;
3527      * This method updates a column value in either the current row or
3528      * the insert row of this rowset, but it does not update the
3529      * database.  If the cursor is on a row in the rowset, the
3530      * method {@link #updateRow} must be called to update the database.
3531      * If the cursor is on the insert row, the method {@link #insertRow}
3532      * must be called, which will insert the new row into both this rowset
3533      * and the database. Both of these methods must be called before the
3534      * cursor moves to another row.
3535      *
3536      * @param columnName a {@code String} object that must match the
3537      *        SQL name of a column in this rowset, ignoring case
3538      * @param reader the new column value; must be a
3539      * {@code java.io.Reader} containing {@code BINARY},
3540      * {@code VARBINARY}, {@code LONGVARBINARY}, {@code CHAR},
3541      * {@code VARCHAR}, or {@code LONGVARCHAR} data
3542      * @param length the length of the stream in characters
3543      * @throws SQLException if (1) the given column name does not match the
3544      *            name of a column in this rowset, (2) the cursor is not on
3545      *            one of this rowset&#39;s rows or its insert row, (3) the data
3546      *            in the stream is not a binary or character type, or (4) this
3547      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3548      */
3549     public void updateCharacterStream(String columnName,
3550     java.io.Reader reader,
3551     int length) throws SQLException {
3552         throw new UnsupportedOperationException();
3553     }
3554 
3555     /**
3556      * Sets the designated column in either the current row or the insert
3557      * row of this {@code CachedRowSetImpl} object with the given
3558      * {@code Object} value.  The {@code scale} parameter
3559      * indicates the number of digits to the right of the decimal point
3560      * and is ignored if the new column value is not a type that will be
3561      *  mapped to an SQL {@code DECIMAL} or {@code NUMERIC} value.
3562      * &lt;P&gt;
3563      * This method updates a column value in either the current row or
3564      * the insert row of this rowset, but it does not update the
3565      * database.  If the cursor is on a row in the rowset, the
3566      * method {@link #updateRow} must be called to update the database.
3567      * If the cursor is on the insert row, the method {@link #insertRow}
3568      * must be called, which will insert the new row into both this rowset
3569      * and the database. Both of these methods must be called before the
3570      * cursor moves to another row.
3571      *
3572      * @param columnName a {@code String} object that must match the
3573      *        SQL name of a column in this rowset, ignoring case
3574      * @param x the new column value
3575      * @param scale the number of digits to the right of the decimal point (for
3576      *              {@code DECIMAL} and {@code NUMERIC} types only)
3577      * @throws SQLException if (1) the given column name does not match the
3578      *            name of a column in this rowset, (2) the cursor is not on
3579      *            one of this rowset&#39;s rows or its insert row, or (3) this
3580      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3581      */
3582     public void updateObject(String columnName, Object x, int scale) throws SQLException {
3583         throw new UnsupportedOperationException();
3584     }
3585 
3586     /**
3587      * Sets the designated column in either the current row or the insert
3588      * row of this {@code CachedRowSetImpl} object with the given
3589      * {@code Object} value.
3590      * &lt;P&gt;
3591      * This method updates a column value in either the current row or
3592      * the insert row of this rowset, but it does not update the
3593      * database.  If the cursor is on a row in the rowset, the
3594      * method {@link #updateRow} must be called to update the database.
3595      * If the cursor is on the insert row, the method {@link #insertRow}
3596      * must be called, which will insert the new row into both this rowset
3597      * and the database. Both of these methods must be called before the
3598      * cursor moves to another row.
3599      *
3600      * @param columnName a {@code String} object that must match the
3601      *        SQL name of a column in this rowset, ignoring case
3602      * @param x the new column value
3603      * @throws SQLException if (1) the given column name does not match the
3604      *            name of a column in this rowset, (2) the cursor is not on
3605      *            one of this rowset&#39;s rows or its insert row, or (3) this
3606      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3607      */
3608     public void updateObject(String columnName, Object x) throws SQLException {
3609         throw new UnsupportedOperationException();
3610     }
3611 
3612     /**
3613      * Inserts the contents of this {@code CachedRowSetImpl} object&#39;s insert
3614      * row into this rowset immediately following the current row.
3615      * If the current row is the
3616      * position after the last row or before the first row, the new row will
3617      * be inserted at the end of the rowset.  This method also notifies
3618      * listeners registered with this rowset that the row has changed.
3619      * &lt;P&gt;
3620      * The cursor must be on the insert row when this method is called.
3621      *
3622      * @throws SQLException if (1) the cursor is not on the insert row,
3623      *            (2) one or more of the non-nullable columns in the insert
3624      *            row has not been given a value, or (3) this rowset is
3625      *            {@code ResultSet.CONCUR_READ_ONLY}
3626      */
3627     public void insertRow() throws SQLException {
3628         throw new UnsupportedOperationException();
3629     }
3630 
3631     /**
3632      * Marks the current row of this {@code CachedRowSetImpl} object as
3633      * updated and notifies listeners registered with this rowset that the
3634      * row has changed.
3635      * &lt;P&gt;
3636      * This method  cannot be called when the cursor is on the insert row, and
3637      * it should be called before the cursor moves to another row.  If it is
3638      * called after the cursor moves to another row, this method has no effect,
3639      * and the updates made before the cursor moved will be lost.
3640      *
3641      * @throws SQLException if the cursor is on the insert row or this
3642      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
3643      */
3644     public void updateRow() throws SQLException {
3645         throw new UnsupportedOperationException();
3646     }
3647 
3648     /**
3649      * Deletes the current row from this {@code CachedRowSetImpl} object and
3650      * notifies listeners registered with this rowset that a row has changed.
3651      * This method cannot be called when the cursor is on the insert row.
3652      * &lt;P&gt;
3653      * This method marks the current row as deleted, but it does not delete
3654      * the row from the underlying data source.  The method
3655      * {@code acceptChanges} must be called to delete the row in
3656      * the data source.
3657      *
3658      * @throws SQLException if (1) this method is called when the cursor
3659      *            is on the insert row, before the first row, or after the
3660      *            last row or (2) this rowset is
3661      *            {@code ResultSet.CONCUR_READ_ONLY}
3662      */
3663     public void deleteRow() throws SQLException {
3664         throw new UnsupportedOperationException();
3665     }
3666 
3667     /**
3668      * Sets the current row with its original value and marks the row as
3669      * not updated, thus undoing any changes made to the row since the
3670      * last call to the methods {@code updateRow} or {@code deleteRow}.
3671      * This method should be called only when the cursor is on a row in
3672      * this rowset.
3673      *
3674      * @throws SQLException if the cursor is on the insert row, before the
3675      *            first row, or after the last row
3676      */
3677     public void refreshRow() throws SQLException {
3678         throw new UnsupportedOperationException();
3679     }
3680 
3681     /**
3682      * Rolls back any updates made to the current row of this
3683      * {@code CachedRowSetImpl} object and notifies listeners that
3684      * a row has changed.  To have an effect, this method
3685      * must be called after an {@code updateXXX} method has been
3686      * called and before the method {@code updateRow} has been called.
3687      * If no updates have been made or the method {@code updateRow}
3688      * has already been called, this method has no effect.
3689      *
3690      * @throws SQLException if the cursor is on the insert row, before the
3691      *            first row, or after the last row
3692      */
3693     public void cancelRowUpdates() throws SQLException {
3694         throw new UnsupportedOperationException();
3695     }
3696 
3697     /**
3698      * Moves the cursor for this {@code CachedRowSetImpl} object
3699      * to the insert row.  The current row in the rowset is remembered
3700      * while the cursor is on the insert row.
3701      * &lt;P&gt;
3702      * The insert row is a special row associated with an updatable
3703      * rowset.  It is essentially a buffer where a new row may
3704      * be constructed by calling the appropriate {@code updateXXX}
3705      * methods to assign a value to each column in the row.  A complete
3706      * row must be constructed; that is, every column that is not nullable
3707      * must be assigned a value.  In order for the new row to become part
3708      * of this rowset, the method {@code insertRow} must be called
3709      * before the cursor is moved back to the rowset.
3710      * &lt;P&gt;
3711      * Only certain methods may be invoked while the cursor is on the insert
3712      * row; many methods throw an exception if they are called while the
3713      * cursor is there.  In addition to the {@code updateXXX}
3714      * and {@code insertRow} methods, only the {@code getXXX} methods
3715      * may be called when the cursor is on the insert row.  A {@code getXXX}
3716      * method should be called on a column only after an {@code updateXXX}
3717      * method has been called on that column; otherwise, the value returned is
3718      * undetermined.
3719      *
3720      * @throws SQLException if this {@code CachedRowSetImpl} object is
3721      *            {@code ResultSet.CONCUR_READ_ONLY}
3722      */
3723     public void moveToInsertRow() throws SQLException {
3724         throw new UnsupportedOperationException();
3725     }
3726 
3727     /**
3728      * Moves the cursor for this {@code CachedRowSetImpl} object to
3729      * the current row.  The current row is the row the cursor was on
3730      * when the method {@code moveToInsertRow} was called.
3731      * &lt;P&gt;
3732      * Calling this method has no effect unless it is called while the
3733      * cursor is on the insert row.
3734      *
3735      * @throws SQLException if an error occurs
3736      */
3737     public void moveToCurrentRow() throws SQLException {
3738         throw new UnsupportedOperationException();
3739     }
3740 
3741     /**
3742      * Returns {@code null}.
3743      *
3744      * @return {@code null}
3745      * @throws SQLException if an error occurs
3746      */
3747     public Statement getStatement() throws SQLException {
3748         throw new UnsupportedOperationException();
3749     }
3750 
3751     /**
3752      * Retrieves the value of the designated column in this
3753      * {@code CachedRowSetImpl} object as an {@code Object} in
3754      * the Java programming language, using the given
3755      * {@code java.util.Map} object to custom map the value if
3756      * appropriate.
3757      *
3758      * @param columnIndex the first column is {@code 1}, the second
3759      *        is {@code 2}, and so on; must be {@code 1} or larger
3760      *        and equal to or less than the number of columns in this rowset
3761      * @param map a {@code java.util.Map} object showing the mapping
3762      *            from SQL type names to classes in the Java programming
3763      *            language
3764      * @return an {@code Object} representing the SQL value
3765      * @throws SQLException if the given column index is out of bounds or
3766      *            the cursor is not on one of this rowset&#39;s rows or its
3767      *            insert row
3768      */
3769     public Object getObject(int columnIndex,
3770                             java.util.Map&lt;String,Class&lt;?&gt;&gt; map)
3771           throws SQLException
3772     {
3773        throw new UnsupportedOperationException();
3774     }
3775 
3776     /**
3777      * Retrieves the value of the designated column in this
3778      * {@code CachedRowSetImpl} object as a {@code Ref} object
3779      * in the Java programming language.
3780      *
3781      * @param columnIndex the first column is {@code 1}, the second
3782      *        is {@code 2}, and so on; must be {@code 1} or larger
3783      *        and equal to or less than the number of columns in this rowset
3784      * @return a {@code Ref} object representing an SQL{@code  REF} value
3785      * @throws SQLException if (1) the given column index is out of bounds,
3786      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3787      *            insert row, or (3) the designated column does not store an
3788      *            SQL {@code REF} value
3789      * @see #getRef(String)
3790      */
3791     public Ref getRef(int columnIndex) throws SQLException {
3792         throw new UnsupportedOperationException();
3793     }
3794 
3795     /**
3796      * Retrieves the value of the designated column in this
3797      * {@code CachedRowSetImpl} object as a {@code Blob} object
3798      * in the Java programming language.
3799      *
3800      * @param columnIndex the first column is {@code 1}, the second
3801      *        is {@code 2}, and so on; must be {@code 1} or larger
3802      *        and equal to or less than the number of columns in this rowset
3803      * @return a {@code Blob} object representing an SQL {@code BLOB} value
3804      * @throws SQLException if (1) the given column index is out of bounds,
3805      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3806      *            insert row, or (3) the designated column does not store an
3807      *            SQL {@code BLOB} value
3808      * @see #getBlob(String)
3809      */
3810     public Blob getBlob(int columnIndex) throws SQLException {
3811        throw new UnsupportedOperationException();
3812     }
3813 
3814     /**
3815      * Retrieves the value of the designated column in this
3816      * {@code CachedRowSetImpl} object as a {@code Clob} object
3817      * in the Java programming language.
3818      *
3819      * @param columnIndex the first column is {@code 1}, the second
3820      *        is {@code 2}, and so on; must be {@code 1} or larger
3821      *        and equal to or less than the number of columns in this rowset
3822      * @return a {@code Clob} object representing an SQL {@code CLOB} value
3823      * @throws SQLException if (1) the given column index is out of bounds,
3824      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3825      *            insert row, or (3) the designated column does not store an
3826      *            SQL {@code CLOB} value
3827      * @see #getClob(String)
3828      */
3829     public Clob getClob(int columnIndex) throws SQLException {
3830         throw new UnsupportedOperationException();
3831     }
3832 
3833     /**
3834      * Retrieves the value of the designated column in this
3835      * {@code CachedRowSetImpl} object as an {@code Array} object
3836      * in the Java programming language.
3837      *
3838      * @param columnIndex the first column is {@code 1}, the second
3839      *        is {@code 2}, and so on; must be {@code 1} or larger
3840      *        and equal to or less than the number of columns in this rowset
3841      * @return an {@code Array} object representing an SQL
3842      *         {@code ARRAY} value
3843      * @throws SQLException if (1) the given column index is out of bounds,
3844      *            (2) the cursor is not on one of this rowset&#39;s rows or its
3845      *            insert row, or (3) the designated column does not store an
3846      *            SQL {@code ARRAY} value
3847      * @see #getArray(String)
3848      */
3849     public Array getArray(int columnIndex) throws SQLException {
3850         throw new UnsupportedOperationException();
3851     }
3852 
3853     /**
3854      * Retrieves the value of the designated column in this
3855      * {@code CachedRowSetImpl} object as an {@code Object} in
3856      * the Java programming language, using the given
3857      * {@code java.util.Map} object to custom map the value if
3858      * appropriate.
3859      *
3860      * @param columnName a {@code String} object that must match the
3861      *        SQL name of a column in this rowset, ignoring case
3862      * @param map a {@code java.util.Map} object showing the mapping
3863      *        from SQL type names to classes in the Java programming
3864      *        language
3865      * @return an {@code Object} representing the SQL value
3866      * @throws SQLException if the given column name is not the name of
3867      *         a column in this rowset or the cursor is not on one of
3868      *         this rowset&#39;s rows or its insert row
3869      */
3870     public Object getObject(String columnName,
3871                             java.util.Map&lt;String,Class&lt;?&gt;&gt; map)
3872     throws SQLException {
3873         throw new UnsupportedOperationException();
3874     }
3875 
3876     /**
3877      * Retrieves the value of the designated column in this
3878      * {@code CachedRowSetImpl} object as a {@code Ref} object
3879      * in the Java programming language.
3880      *
3881      * @param colName a {@code String} object that must match the
3882      *        SQL name of a column in this rowset, ignoring case
3883      * @return a {@code Ref} object representing an SQL{@code  REF} value
3884      * @throws SQLException  if (1) the given column name is not the name of
3885      *            a column in this rowset, (2) the cursor is not on one of
3886      *            this rowset&#39;s rows or its insert row, or (3) the column value
3887      *            is not an SQL {@code REF} value
3888      * @see #getRef(int)
3889      */
3890     public Ref getRef(String colName) throws SQLException {
3891         throw new UnsupportedOperationException();
3892     }
3893 
3894     /**
3895      * Retrieves the value of the designated column in this
3896      * {@code CachedRowSetImpl} object as a {@code Blob} object
3897      * in the Java programming language.
3898      *
3899      * @param colName a {@code String} object that must match the
3900      *        SQL name of a column in this rowset, ignoring case
3901      * @return a {@code Blob} object representing an SQL {@code BLOB} value
3902      * @throws SQLException if (1) the given column name is not the name of
3903      *            a column in this rowset, (2) the cursor is not on one of
3904      *            this rowset&#39;s rows or its insert row, or (3) the designated
3905      *            column does not store an SQL {@code BLOB} value
3906      * @see #getBlob(int)
3907      */
3908     public Blob getBlob(String colName) throws SQLException {
3909        throw new UnsupportedOperationException();
3910     }
3911 
3912     /**
3913      * Retrieves the value of the designated column in this
3914      * {@code CachedRowSetImpl} object as a {@code Clob} object
3915      * in the Java programming language.
3916      *
3917      * @param colName a {@code String} object that must match the
3918      *        SQL name of a column in this rowset, ignoring case
3919      * @return a {@code Clob} object representing an SQL
3920      *         {@code CLOB} value
3921      * @throws SQLException if (1) the given column name is not the name of
3922      *            a column in this rowset, (2) the cursor is not on one of
3923      *            this rowset&#39;s rows or its insert row, or (3) the designated
3924      *            column does not store an SQL {@code CLOB} value
3925      * @see #getClob(int)
3926      */
3927     public Clob getClob(String colName) throws SQLException {
3928         throw new UnsupportedOperationException();
3929     }
3930 
3931     /**
3932      * Retrieves the value of the designated column in this
3933      * {@code CachedRowSetImpl} object as an {@code Array} object
3934      * in the Java programming langugage.
3935      *
3936      * @param colName a {@code String} object that must match the
3937      *        SQL name of a column in this rowset, ignoring case
3938      * @return an {@code Array} object representing an SQL
3939      *         {@code ARRAY} value
3940      * @throws SQLException if (1) the given column name is not the name of
3941      *            a column in this rowset, (2) the cursor is not on one of
3942      *            this rowset&#39;s rows or its insert row, or (3) the designated
3943      *            column does not store an SQL {@code ARRAY} value
3944      * @see #getArray(int)
3945      */
3946     public Array getArray(String colName) throws SQLException {
3947         throw new UnsupportedOperationException();
3948     }
3949 
3950     /**
3951      * Retrieves the value of the designated column in the current row
3952      * of this {@code CachedRowSetImpl} object as a {@code java.sql.Date}
3953      * object, using the given {@code Calendar} object to construct an
3954      * appropriate millisecond value for the date.
3955      *
3956      * @param columnIndex the first column is {@code 1}, the second
3957      *        is {@code 2}, and so on; must be {@code 1} or larger
3958      *        and equal to or less than the number of columns in the rowset
3959      * @param cal the {@code java.util.Calendar} object to use in
3960      *            constructing the date
3961      * @return the column value; if the value is SQL {@code NULL},
3962      *         the result is {@code null}
3963      * @throws SQLException if (1) the given column name is not the name of
3964      *            a column in this rowset, (2) the cursor is not on one of
3965      *            this rowset&#39;s rows or its insert row, or (3) the designated
3966      *            column does not store an SQL {@code DATE} or
3967      *            {@code TIMESTAMP} value
3968      */
3969     public java.sql.Date getDate(int columnIndex, Calendar cal) throws SQLException {
3970         throw new UnsupportedOperationException();
3971     }
3972 
3973     /**
3974      * Retrieves the value of the designated column in the current row
3975      * of this {@code CachedRowSetImpl} object as a {@code java.sql.Date}
3976      * object, using the given {@code Calendar} object to construct an
3977      * appropriate millisecond value for the date.
3978      *
3979      * @param columnName a {@code String} object that must match the
3980      *        SQL name of a column in this rowset, ignoring case
3981      * @param cal the {@code java.util.Calendar} object to use in
3982      *            constructing the date
3983      * @return the column value; if the value is SQL {@code NULL},
3984      *         the result is {@code null}
3985      * @throws SQLException if (1) the given column name is not the name of
3986      *            a column in this rowset, (2) the cursor is not on one of
3987      *            this rowset&#39;s rows or its insert row, or (3) the designated
3988      *            column does not store an SQL {@code DATE} or
3989      *            {@code TIMESTAMP} value
3990      */
3991     public java.sql.Date getDate(String columnName, Calendar cal) throws SQLException {
3992         throw new UnsupportedOperationException();
3993     }
3994 
3995     /**
3996      * Retrieves the value of the designated column in the current row
3997      * of this {@code CachedRowSetImpl} object as a {@code java.sql.Time}
3998      * object, using the given {@code Calendar} object to construct an
3999      * appropriate millisecond value for the date.
4000      *
4001      * @param columnIndex the first column is {@code 1}, the second
4002      *        is {@code 2}, and so on; must be {@code 1} or larger
4003      *        and equal to or less than the number of columns in the rowset
4004      * @param cal the {@code java.util.Calendar} object to use in
4005      *            constructing the date
4006      * @return the column value; if the value is SQL {@code NULL},
4007      *         the result is {@code null}
4008      * @throws SQLException if (1) the given column name is not the name of
4009      *            a column in this rowset, (2) the cursor is not on one of
4010      *            this rowset&#39;s rows or its insert row, or (3) the designated
4011      *            column does not store an SQL {@code TIME} or
4012      *            {@code TIMESTAMP} value
4013      */
4014     public java.sql.Time getTime(int columnIndex, Calendar cal) throws SQLException {
4015         throw new UnsupportedOperationException();
4016     }
4017 
4018     /**
4019      * Retrieves the value of the designated column in the current row
4020      * of this {@code CachedRowSetImpl} object as a {@code java.sql.Time}
4021      * object, using the given {@code Calendar} object to construct an
4022      * appropriate millisecond value for the date.
4023      *
4024      * @param columnName a {@code String} object that must match the
4025      *        SQL name of a column in this rowset, ignoring case
4026      * @param cal the {@code java.util.Calendar} object to use in
4027      *            constructing the date
4028      * @return the column value; if the value is SQL {@code NULL},
4029      *         the result is {@code null}
4030      * @throws SQLException if (1) the given column name is not the name of
4031      *            a column in this rowset, (2) the cursor is not on one of
4032      *            this rowset&#39;s rows or its insert row, or (3) the designated
4033      *            column does not store an SQL {@code TIME} or
4034      *            {@code TIMESTAMP} value
4035      */
4036     public java.sql.Time getTime(String columnName, Calendar cal) throws SQLException {
4037         throw new UnsupportedOperationException();
4038     }
4039 
4040     /**
4041      * Retrieves the value of the designated column in the current row
4042      * of this {@code CachedRowSetImpl} object as a {@code java.sql.Timestamp}
4043      * object, using the given {@code Calendar} object to construct an
4044      * appropriate millisecond value for the date.
4045      *
4046      * @param columnIndex the first column is {@code 1}, the second
4047      *        is {@code 2}, and so on; must be {@code 1} or larger
4048      *        and equal to or less than the number of columns in the rowset
4049      * @param cal the {@code java.util.Calendar} object to use in
4050      *            constructing the date
4051      * @return the column value; if the value is SQL {@code NULL},
4052      *         the result is {@code null}
4053      * @throws SQLException if (1) the given column name is not the name of
4054      *            a column in this rowset, (2) the cursor is not on one of
4055      *            this rowset&#39;s rows or its insert row, or (3) the designated
4056      *            column does not store an SQL {@code TIME} or
4057      *            {@code TIMESTAMP} value
4058      */
4059     public java.sql.Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
4060         throw new UnsupportedOperationException();
4061     }
4062 
4063     /**
4064      * Retrieves the value of the designated column in the current row
4065      * of this {@code CachedRowSetImpl} object as a
4066      * {@code java.sql.Timestamp} object, using the given
4067      * {@code Calendar} object to construct an appropriate
4068      * millisecond value for the date.
4069      *
4070      * @param columnName a {@code String} object that must match the
4071      *        SQL name of a column in this rowset, ignoring case
4072      * @param cal the {@code java.util.Calendar} object to use in
4073      *            constructing the date
4074      * @return the column value; if the value is SQL {@code NULL},
4075      *         the result is {@code null}
4076      * @throws SQLException if (1) the given column name is not the name of
4077      *            a column in this rowset, (2) the cursor is not on one of
4078      *            this rowset&#39;s rows or its insert row, or (3) the designated
4079      *            column does not store an SQL {@code DATE},
4080      *            {@code TIME}, or {@code TIMESTAMP} value
4081      */
4082     public java.sql.Timestamp getTimestamp(String columnName, Calendar cal) throws SQLException {
4083         throw new UnsupportedOperationException();
4084     }
4085 
4086     /*
4087      * RowSetInternal Interface
4088      */
4089 
4090     /**
4091      * Retrieves the {@code Connection} object passed to this
4092      * {@code CachedRowSetImpl} object.  This connection may be
4093      * used to populate this rowset with data or to write data back
4094      * to its underlying data source.
4095      *
4096      * @return the {@code Connection} object passed to this rowset;
4097      *         may be {@code null} if there is no connection
4098      * @throws SQLException if an error occurs
4099      */
4100     public Connection getConnection() throws SQLException{
4101         throw new UnsupportedOperationException();
4102     }
4103 
4104     /**
4105      * Sets the metadata for this {@code CachedRowSetImpl} object
4106      * with the given {@code RowSetMetaData} object.
4107      *
4108      * @param md a {@code RowSetMetaData} object instance containing
4109      *            metadata about the columsn in the rowset
4110      * @throws SQLException if invalid meta data is supplied to the
4111      *            rowset
4112      */
4113     public void setMetaData(RowSetMetaData md) throws SQLException {
4114         throw new UnsupportedOperationException();
4115     }
4116 
4117     /**
4118      * Returns a result set containing the original value of the rowset. The
4119      * original value is the state of the {@code CachedRowSetImpl} after the
4120      * last population or synchronization (whichever occurred most recently) with
4121      * the data source.
4122      * &lt;p&gt;
4123      * The cursor is positioned before the first row in the result set.
4124      * Only rows contained in the result set returned by {@code getOriginal()}
4125      * are said to have an original value.
4126      *
4127      * @return the original result set of the rowset
4128      * @throws SQLException if an error occurs produce the
4129      *           {@code ResultSet} object
4130      */
4131     public ResultSet getOriginal() throws SQLException {
4132        throw new UnsupportedOperationException();
4133     }
4134 
4135     /**
4136      * Returns a result set containing the original value of the current
4137      * row only.
4138      * The original value is the state of the {@code CachedRowSetImpl} after
4139      * the last population or synchronization (whichever occurred most recently)
4140      * with the data source.
4141      *
4142      * @return the original result set of the row
4143      * @throws SQLException if there is no current row
4144      * @see #setOriginalRow
4145      */
4146     public ResultSet getOriginalRow() throws SQLException {
4147         throw new UnsupportedOperationException();
4148 
4149     }
4150 
4151     /**
4152      * Marks the current row in this rowset as being an original row.
4153      *
4154      * @throws SQLException if there is no current row
4155      * @see #getOriginalRow
4156      */
4157     public void setOriginalRow() throws SQLException {
4158         throw new UnsupportedOperationException();
4159     }
4160 
4161     /**
4162      * Marks all rows in this rowset as being original rows. Any updates
4163      * made to the rows become the original values for the rowset.
4164      * Calls to the method {@code setOriginal} connot be reversed.
4165      *
4166      * @throws SQLException if an error occurs
4167      */
4168     public void setOriginal() throws SQLException {
4169         throw new UnsupportedOperationException();
4170     }
4171 
4172     /**
4173      * Returns an identifier for the object (table) that was used to create this
4174      * rowset.
4175      *
4176      * @return a {@code String} object that identifies the table from
4177      *         which this {@code CachedRowSetImpl} object was derived
4178      * @throws SQLException if an error occurs
4179      */
4180     public String getTableName() throws SQLException {
4181         throw new UnsupportedOperationException();
4182     }
4183 
4184     /**
4185      * Sets the identifier for the table from which this rowset was derived
4186      * to the given table name.
4187      *
4188      * @param tabName a {@code String} object that identifies the
4189      *          table from which this {@code CachedRowSetImpl} object
4190      *          was derived
4191      * @throws SQLException if an error occurs
4192      */
4193     public void setTableName(String tabName) throws SQLException {
4194         throw new UnsupportedOperationException();
4195     }
4196 
4197     /**
4198      * Returns the columns that make a key to uniquely identify a
4199      * row in this {@code CachedRowSetImpl} object.
4200      *
4201      * @return an array of column numbers that constitutes a primary
4202      *           key for this rowset. This array should be empty
4203      *           if no column is representitive of a primary key
4204      * @throws SQLException if the rowset is empty or no columns
4205      *           are designated as primary keys
4206      * @see #setKeyColumns
4207      */
4208     public int[] getKeyColumns() throws SQLException {
4209         throw new UnsupportedOperationException();
4210     }
4211 
4212 
4213     /**
4214      * Sets this {@code CachedRowSetImpl} object&#39;s
4215      * {@code keyCols} field with the given array of column
4216      * numbers, which forms a key for uniquely identifying a row
4217      * in this rowset.
4218      *
4219      * @param keys an array of {@code int} indicating the
4220      *        columns that form a primary key for this
4221      *        {@code CachedRowSetImpl} object; every
4222      *        element in the array must be greater than
4223      *        {@code 0} and less than or equal to the number
4224      *        of columns in this rowset
4225      * @throws SQLException if any of the numbers in the
4226      *            given array is not valid for this rowset
4227      * @see #getKeyColumns
4228      */
4229     public void setKeyColumns(int [] keys) throws SQLException {
4230         throw new UnsupportedOperationException();
4231     }
4232 
4233     /**
4234      * Sets the designated column in either the current row or the insert
4235      * row of this {@code CachedRowSetImpl} object with the given
4236      * {@code double} value.
4237      *
4238      * This method updates a column value in either the current row or
4239      * the insert row of this rowset, but it does not update the
4240      * database.  If the cursor is on a row in the rowset, the
4241      * method {@link #updateRow} must be called to update the database.
4242      * If the cursor is on the insert row, the method {@link #insertRow}
4243      * must be called, which will insert the new row into both this rowset
4244      * and the database. Both of these methods must be called before the
4245      * cursor moves to another row.
4246      *
4247      * @param columnIndex the first column is {@code 1}, the second
4248      *        is {@code 2}, and so on; must be {@code 1} or larger
4249      *        and equal to or less than the number of columns in this rowset
4250      * @param ref the new column {@code java.sql.Ref} value
4251      * @throws SQLException if (1) the given column index is out of bounds,
4252      *        (2) the cursor is not on one of this rowset&#39;s rows or its
4253      *        insert row, or (3) this rowset is
4254      *        {@code ResultSet.CONCUR_READ_ONLY}
4255      */
4256     public void updateRef(int columnIndex, java.sql.Ref ref) throws SQLException {
4257         throw new UnsupportedOperationException();
4258     }
4259 
4260     /**
4261      * Sets the designated column in either the current row or the insert
4262      * row of this {@code CachedRowSetImpl} object with the given
4263      * {@code double} value.
4264      *
4265      * This method updates a column value in either the current row or
4266      * the insert row of this rowset, but it does not update the
4267      * database.  If the cursor is on a row in the rowset, the
4268      * method {@link #updateRow} must be called to update the database.
4269      * If the cursor is on the insert row, the method {@link #insertRow}
4270      * must be called, which will insert the new row into both this rowset
4271      * and the database. Both of these methods must be called before the
4272      * cursor moves to another row.
4273      *
4274      * @param columnName a {@code String} object that must match the
4275      *        SQL name of a column in this rowset, ignoring case
4276      * @param ref the new column {@code java.sql.Ref} value
4277      * @throws SQLException if (1) the given column name does not match the
4278      *        name of a column in this rowset, (2) the cursor is not on
4279      *        one of this rowset&#39;s rows or its insert row, or (3) this
4280      *        rowset is {@code ResultSet.CONCUR_READ_ONLY}
4281      */
4282     public void updateRef(String columnName, java.sql.Ref ref) throws SQLException {
4283         throw new UnsupportedOperationException();
4284     }
4285 
4286     /**
4287      * Sets the designated column in either the current row or the insert
4288      * row of this {@code CachedRowSetImpl} object with the given
4289      * {@code double} value.
4290      *
4291      * This method updates a column value in either the current row or
4292      * the insert row of this rowset, but it does not update the
4293      * database.  If the cursor is on a row in the rowset, the
4294      * method {@link #updateRow} must be called to update the database.
4295      * If the cursor is on the insert row, the method {@link #insertRow}
4296      * must be called, which will insert the new row into both this rowset
4297      * and the database. Both of these methods must be called before the
4298      * cursor moves to another row.
4299      *
4300      * @param columnIndex the first column is {@code 1}, the second
4301      *        is {@code 2}, and so on; must be {@code 1} or larger
4302      *        and equal to or less than the number of columns in this rowset
4303      * @param c the new column {@code Clob} value
4304      * @throws SQLException if (1) the given column index is out of bounds,
4305      *        (2) the cursor is not on one of this rowset&#39;s rows or its
4306      *        insert row, or (3) this rowset is
4307      *        {@code ResultSet.CONCUR_READ_ONLY}
4308      */
4309     public void updateClob(int columnIndex, Clob c) throws SQLException {
4310        throw new UnsupportedOperationException();
4311     }
4312 
4313     /**
4314      * Sets the designated column in either the current row or the insert
4315      * row of this {@code CachedRowSetImpl} object with the given
4316      * {@code double} value.
4317      *
4318      * This method updates a column value in either the current row or
4319      * the insert row of this rowset, but it does not update the
4320      * database.  If the cursor is on a row in the rowset, the
4321      * method {@link #updateRow} must be called to update the database.
4322      * If the cursor is on the insert row, the method {@link #insertRow}
4323      * must be called, which will insert the new row into both this rowset
4324      * and the database. Both of these methods must be called before the
4325      * cursor moves to another row.
4326      *
4327      * @param columnName a {@code String} object that must match the
4328      *        SQL name of a column in this rowset, ignoring case
4329      * @param c the new column {@code Clob} value
4330      * @throws SQLException if (1) the given column name does not match the
4331      *            name of a column in this rowset, (2) the cursor is not on
4332      *            one of this rowset&#39;s rows or its insert row, or (3) this
4333      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
4334      */
4335     public void updateClob(String columnName, Clob c) throws SQLException {
4336         throw new UnsupportedOperationException();
4337     }
4338 
4339     /**
4340      * Sets the designated column in either the current row or the insert
4341      * row of this {@code CachedRowSetImpl} object with the given
4342      * {@code java.sql.Blob} value.
4343      *
4344      * This method updates a column value in either the current row or
4345      * the insert row of this rowset, but it does not update the
4346      * database.  If the cursor is on a row in the rowset, the
4347      * method {@link #updateRow} must be called to update the database.
4348      * If the cursor is on the insert row, the method {@link #insertRow}
4349      * must be called, which will insert the new row into both this rowset
4350      * and the database. Both of these methods must be called before the
4351      * cursor moves to another row.
4352      *
4353      * @param columnIndex the first column is {@code 1}, the second
4354      *        is {@code 2}, and so on; must be {@code 1} or larger
4355      *        and equal to or less than the number of columns in this rowset
4356      * @param b the new column {@code Blob} value
4357      * @throws SQLException if (1) the given column index is out of bounds,
4358      *            (2) the cursor is not on one of this rowset&#39;s rows or its
4359      *            insert row, or (3) this rowset is
4360      *            {@code ResultSet.CONCUR_READ_ONLY}
4361      */
4362     public void updateBlob(int columnIndex, Blob b) throws SQLException {
4363        throw new UnsupportedOperationException();
4364     }
4365 
4366     /**
4367      * Sets the designated column in either the current row or the insert
4368      * row of this {@code CachedRowSetImpl} object with the given
4369      * {@code java.sql.Blob } value.
4370      *
4371      * This method updates a column value in either the current row or
4372      * the insert row of this rowset, but it does not update the
4373      * database.  If the cursor is on a row in the rowset, the
4374      * method {@link #updateRow} must be called to update the database.
4375      * If the cursor is on the insert row, the method {@link #insertRow}
4376      * must be called, which will insert the new row into both this rowset
4377      * and the database. Both of these methods must be called before the
4378      * cursor moves to another row.
4379      *
4380      * @param columnName a {@code String} object that must match the
4381      *        SQL name of a column in this rowset, ignoring case
4382      * @param b the new column {@code Blob} value
4383      * @throws SQLException if (1) the given column name does not match the
4384      *            name of a column in this rowset, (2) the cursor is not on
4385      *            one of this rowset&#39;s rows or its insert row, or (3) this
4386      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
4387      */
4388     public void updateBlob(String columnName, Blob b) throws SQLException {
4389         throw new UnsupportedOperationException();
4390     }
4391 
4392     /**
4393      * Sets the designated column in either the current row or the insert
4394      * row of this {@code CachedRowSetImpl} object with the given
4395      * {@code java.sql.Array} values.
4396      *
4397      * This method updates a column value in either the current row or
4398      * the insert row of this rowset, but it does not update the
4399      * database.  If the cursor is on a row in the rowset, the
4400      * method {@link #updateRow} must be called to update the database.
4401      * If the cursor is on the insert row, the method {@link #insertRow}
4402      * must be called, which will insert the new row into both this rowset
4403      * and the database. Both of these methods must be called before the
4404      * cursor moves to another row.
4405      *
4406      * @param columnIndex the first column is {@code 1}, the second
4407      *        is {@code 2}, and so on; must be {@code 1} or larger
4408      *        and equal to or less than the number of columns in this rowset
4409      * @param a the new column {@code Array} value
4410      * @throws SQLException if (1) the given column index is out of bounds,
4411      *            (2) the cursor is not on one of this rowset&#39;s rows or its
4412      *            insert row, or (3) this rowset is
4413      *            {@code ResultSet.CONCUR_READ_ONLY}
4414      */
4415     public void updateArray(int columnIndex, Array a) throws SQLException {
4416         throw new UnsupportedOperationException();
4417     }
4418 
4419     /**
4420      * Sets the designated column in either the current row or the insert
4421      * row of this {@code CachedRowSetImpl} object with the given
4422      * {@code java.sql.Array} value.
4423      *
4424      * This method updates a column value in either the current row or
4425      * the insert row of this rowset, but it does not update the
4426      * database.  If the cursor is on a row in the rowset, the
4427      * method {@link #updateRow} must be called to update the database.
4428      * If the cursor is on the insert row, the method {@link #insertRow}
4429      * must be called, which will insert the new row into both this rowset
4430      * and the database. Both of these methods must be called before the
4431      * cursor moves to another row.
4432      *
4433      * @param columnName a {@code String} object that must match the
4434      *        SQL name of a column in this rowset, ignoring case
4435      * @param a the new column {@code Array} value
4436      * @throws SQLException if (1) the given column name does not match the
4437      *            name of a column in this rowset, (2) the cursor is not on
4438      *            one of this rowset&#39;s rows or its insert row, or (3) this
4439      *            rowset is {@code ResultSet.CONCUR_READ_ONLY}
4440      */
4441     public void updateArray(String columnName, Array a) throws SQLException {
4442         throw new UnsupportedOperationException();
4443     }
4444 
4445 
4446     /**
4447      * Retrieves the value of the designated column in this
4448      * {@code CachedRowSetImpl} object as a {@code java.net.URL} object
4449      * in the Java programming language.
4450      *
4451      * @return a java.net.URL object containing the resource reference described by
4452      * the URL
4453      * @throws SQLException if (1) the given column index is out of bounds,
4454      * (2) the cursor is not on one of this rowset&#39;s rows or its
4455      * insert row, or (3) the designated column does not store an
4456      * SQL {@code DATALINK} value.
4457      * @see #getURL(String)
4458      */
4459     public java.net.URL getURL(int columnIndex) throws SQLException {
4460         throw new UnsupportedOperationException();
4461     }
4462 
4463     /**
4464      * Retrieves the value of the designated column in this
4465      * {@code CachedRowSetImpl} object as a {@code java.net.URL} object
4466      * in the Java programming language.
4467      *
4468      * @return a java.net.URL object containing the resource reference described by
4469      * the URL
4470      * @throws SQLException if (1) the given column name not the name of a column
4471      * in this rowset, or
4472      * (2) the cursor is not on one of this rowset&#39;s rows or its
4473      * insert row, or (3) the designated column does not store an
4474      * SQL {@code DATALINK} value.
4475      * @see #getURL(int)
4476      */
4477     public java.net.URL getURL(String columnName) throws SQLException {
4478         throw new UnsupportedOperationException();
4479 
4480     }
4481 
4482     /**
4483      * The first warning reported by calls on this {@code CachedRowSetImpl}
4484      * object is returned. Subsequent {@code CachedRowSetImpl} warnings will
4485      * be chained to this {@code SQLWarning}. All {@code RowSetWarnings}
4486      * warnings are generated in the disconnected environment and remain a
4487      * seperate warning chain to that provided by the {@code getWarnings}
4488      * method.
4489      *
4490      * &lt;P&gt;The warning chain is automatically cleared each time a new
4491      * row is read.
4492      *
4493      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This warning chain only covers warnings caused
4494      * by {@code CachedRowSet} (and their child interface)
4495      * methods. All {@code SQLWarnings} can be obtained using the
4496      * {@code getWarnings} method which tracks warnings generated
4497      * by the underlying JDBC driver.
4498      * @return the first SQLWarning or null
4499      *
4500      */
4501     public RowSetWarning getRowSetWarnings() {
4502         throw new UnsupportedOperationException();
4503     }
4504 
4505      /**
4506      * Commits all changes performed by the {@code acceptChanges()}
4507      * methods
4508      *
4509      * @see java.sql.Connection#commit
4510      */
4511     public void commit() throws SQLException {
4512         throw new UnsupportedOperationException();
4513     }
4514 
4515     /**
4516      * Rolls back all changes performed by the {@code acceptChanges()}
4517      * methods
4518      *
4519      * @see java.sql.Connection#rollback
4520      */
4521     public void rollback() throws SQLException {
4522         throw new UnsupportedOperationException();
4523     }
4524 
4525     /**
4526      * Rolls back all changes performed by the {@code acceptChanges()}
4527      * to the last {@code Savepoint} transaction marker.
4528      *
4529      * @see java.sql.Connection#rollback(Savepoint)
4530      */
4531     public void rollback(Savepoint s) throws SQLException {
4532         throw new UnsupportedOperationException();
4533     }
4534 
4535     /**
4536      * Unsets the designated parameter to the given int array.
4537      * This was set using {@code setMatchColumn}
4538      * as the column which will form the basis of the join.
4539      * &lt;P&gt;
4540      * The parameter value unset by this method should be same
4541      * as was set.
4542      *
4543      * @param columnIdxes the index into this rowset
4544      *        object&#39;s internal representation of parameter values
4545      * @throws SQLException if an error occurs or the
4546      *  parameter index is out of bounds or if the columnIdx is
4547      *  not the same as set using {@code setMatchColumn(int [])}
4548      */
4549     public void unsetMatchColumn(int[] columnIdxes) throws SQLException {
4550          throw new UnsupportedOperationException();
4551     }
4552 
4553    /**
4554      * Unsets the designated parameter to the given String array.
4555      * This was set using {@code setMatchColumn}
4556      * as the column which will form the basis of the join.
4557      * &lt;P&gt;
4558      * The parameter value unset by this method should be same
4559      * as was set.
4560      *
4561      * @param columnIdxes the index into this rowset
4562      *        object&#39;s internal representation of parameter values
4563      * @throws SQLException if an error occurs or the
4564      *  parameter index is out of bounds or if the columnName is
4565      *  not the same as set using {@code setMatchColumn(String [])}
4566      */
4567     public void unsetMatchColumn(String[] columnIdxes) throws SQLException {
4568        throw new UnsupportedOperationException();
4569     }
4570 
4571     /**
4572      * Retrieves the column name as {@code String} array
4573      * that was set using {@code setMatchColumn(String [])}
4574      * for this rowset.
4575      *
4576      * @return a {@code String} array object that contains the column names
4577      *         for the rowset which has this the match columns
4578      *
4579      * @throws SQLException if an error occurs or column name is not set
4580      */
4581     public String[] getMatchColumnNames() throws SQLException {
4582         throw new UnsupportedOperationException();
4583     }
4584 
4585     /**
4586      * Retrieves the column id as {@code int} array that was set using
4587      * {@code setMatchColumn(int [])} for this rowset.
4588      *
4589      * @return an {@code int} array object that contains the column ids
4590      *         for the rowset which has this as the match columns.
4591      *
4592      * @throws SQLException if an error occurs or column index is not set
4593      */
4594     public int[] getMatchColumnIndexes() throws SQLException {
4595         throw new UnsupportedOperationException();
4596     }
4597 
4598     /**
4599      * Sets the designated parameter to the given int array.
4600      * This forms the basis of the join for the
4601      * {@code JoinRowSet} as the column which will form the basis of the
4602      * join.
4603      * &lt;P&gt;
4604      * The parameter value set by this method is stored internally and
4605      * will be supplied as the appropriate parameter in this rowset&#39;s
4606      * command when the method {@code getMatchColumnIndexes} is called.
4607      *
4608      * @param columnIdxes the indexes into this rowset
4609      *        object&#39;s internal representation of parameter values; the
4610      *        first parameter is 0, the second is 1, and so on; must be
4611      *        {@code 0} or greater
4612      * @throws SQLException if an error occurs or the
4613      *                         parameter index is out of bounds
4614      */
4615     public void setMatchColumn(int[] columnIdxes) throws SQLException {
4616         throw new UnsupportedOperationException();
4617     }
4618 
4619     /**
4620      * Sets the designated parameter to the given String array.
4621      *  This forms the basis of the join for the
4622      * {@code JoinRowSet} as the column which will form the basis of the
4623      * join.
4624      * &lt;P&gt;
4625      * The parameter value set by this method is stored internally and
4626      * will be supplied as the appropriate parameter in this rowset&#39;s
4627      * command when the method {@code getMatchColumn} is called.
4628      *
4629      * @param columnNames the name of the column into this rowset
4630      *        object&#39;s internal representation of parameter values
4631      * @throws SQLException if an error occurs or the
4632      *  parameter index is out of bounds
4633      */
4634     public void setMatchColumn(String[] columnNames) throws SQLException {
4635         throw new UnsupportedOperationException();
4636     }
4637 
4638 
4639     /**
4640      * Sets the designated parameter to the given {@code int}
4641      * object.  This forms the basis of the join for the
4642      * {@code JoinRowSet} as the column which will form the basis of the
4643      * join.
4644      * &lt;P&gt;
4645      * The parameter value set by this method is stored internally and
4646      * will be supplied as the appropriate parameter in this rowset&#39;s
4647      * command when the method {@code getMatchColumn} is called.
4648      *
4649      * @param columnIdx the index into this rowset
4650      *        object&#39;s internal representation of parameter values; the
4651      *        first parameter is 0, the second is 1, and so on; must be
4652      *        {@code 0} or greater
4653      * @throws SQLException if an error occurs or the
4654      *                         parameter index is out of bounds
4655      */
4656     public void setMatchColumn(int columnIdx) throws SQLException {
4657         throw new UnsupportedOperationException();
4658     }
4659 
4660     /**
4661      * Sets the designated parameter to the given {@code String}
4662      * object.  This forms the basis of the join for the
4663      * {@code JoinRowSet} as the column which will form the basis of the
4664      * join.
4665      * &lt;P&gt;
4666      * The parameter value set by this method is stored internally and
4667      * will be supplied as the appropriate parameter in this rowset&#39;s
4668      * command when the method {@code getMatchColumn} is called.
4669      *
4670      * @param columnName the name of the column into this rowset
4671      *        object&#39;s internal representation of parameter values
4672      * @throws SQLException if an error occurs or the
4673      *  parameter index is out of bounds
4674      */
4675     public void setMatchColumn(String columnName) throws SQLException {
4676         throw new UnsupportedOperationException();
4677     }
4678 
4679     /**
4680      * Unsets the designated parameter to the given {@code int}
4681      * object.  This was set using {@code setMatchColumn}
4682      * as the column which will form the basis of the join.
4683      * &lt;P&gt;
4684      * The parameter value unset by this method should be same
4685      * as was set.
4686      *
4687      * @param columnIdx the index into this rowset
4688      *        object&#39;s internal representation of parameter values
4689      * @throws SQLException if an error occurs or the
4690      *  parameter index is out of bounds or if the columnIdx is
4691      *  not the same as set using {@code setMatchColumn(int)}
4692      */
4693     public void unsetMatchColumn(int columnIdx) throws SQLException {
4694         throw new UnsupportedOperationException();
4695     }
4696 
4697     /**
4698      * Unsets the designated parameter to the given {@code String}
4699      * object.  This was set using {@code setMatchColumn}
4700      * as the column which will form the basis of the join.
4701      * &lt;P&gt;
4702      * The parameter value unset by this method should be same
4703      * as was set.
4704      *
4705      * @param columnName the index into this rowset
4706      *        object&#39;s internal representation of parameter values
4707      * @throws SQLException if an error occurs or the
4708      *  parameter index is out of bounds or if the columnName is
4709      *  not the same as set using {@code setMatchColumn(String)}
4710      */
4711     public void unsetMatchColumn(String columnName) throws SQLException {
4712         throw new UnsupportedOperationException();
4713     }
4714 
4715     /**
4716      * Notifies registered listeners that a RowSet object in the given RowSetEvent
4717      * object has populated a number of additional rows. The {@code numRows} parameter
4718      * ensures that this event will only be fired every {@code numRow}.
4719      * &lt;p&gt;
4720      * The source of the event can be retrieved with the method event.getSource.
4721      *
4722      * @param event a {@code RowSetEvent} object that contains the
4723      *     {@code RowSet} object that is the source of the events
4724      * @param numRows when populating, the number of rows interval on which the
4725      *     {@code CachedRowSet} populated should fire; the default value
4726      *     is zero; cannot be less than {@code fetchSize} or zero
4727      */
4728     public void rowSetPopulated(RowSetEvent event, int numRows) throws SQLException {
4729         throw new UnsupportedOperationException();
4730     }
4731 
4732     /**
4733      * Populates this {@code CachedRowSet} object with data from
4734      * the given {@code ResultSet} object. While related to the {@code populate(ResultSet)}
4735      * method, an additional parameter is provided to allow starting position within
4736      * the {@code ResultSet} from where to populate the CachedRowSet
4737      * instance.
4738      *
4739      * This method is an alternative to the method {@code execute}
4740      * for filling the rowset with data.  The method {@code populate}
4741      * does not require that the properties needed by the method
4742      * {@code execute}, such as the {@code command} property,
4743      * be set. This is true because the method {@code populate}
4744      * is given the {@code ResultSet} object from
4745      * which to get data and thus does not need to use the properties
4746      * required for setting up a connection and executing this
4747      * {@code CachedRowSetImpl} object&#39;s command.
4748      * &lt;P&gt;
4749      * After populating this rowset with data, the method
4750      * {@code populate} sets the rowset&#39;s metadata and
4751      * then sends a {@code RowSetChangedEvent} object
4752      * to all registered listeners prior to returning.
4753      *
4754      * @param data the {@code ResultSet} object containing the data
4755      *             to be read into this {@code CachedRowSetImpl} object
4756      * @param start the integer specifing the position in the
4757      *        {@code ResultSet} object to popultate the
4758      *        {@code CachedRowSetImpl} object.
4759      * @throws SQLException if an error occurs; or the max row setting is
4760      *          violated while populating the RowSet.Also id the start position
4761      *          is negative.
4762      * @see #execute
4763      */
4764      public void populate(ResultSet data, int start) throws SQLException{
4765         throw new UnsupportedOperationException();
4766 
4767      }
4768 
4769     /**
4770      * The nextPage gets the next page, that is a {@code CachedRowSetImpl} object
4771      * containing the number of rows specified by page size.
4772      * @return boolean value true indicating whether there are more pages to come and
4773      *         false indicating that this is the last page.
4774      * @throws SQLException if an error occurs or this called before calling populate.
4775      */
4776      public boolean nextPage() throws SQLException {
4777          throw new UnsupportedOperationException();
4778      }
4779 
4780     /**
4781      * This is the setter function for setting the size of the page, which specifies
4782      * how many rows have to be retrived at a time.
4783      *
4784      * @param size which is the page size
4785      * @throws SQLException if size is less than zero or greater than max rows.
4786      */
4787      public void setPageSize (int size) throws SQLException {
4788         throw new UnsupportedOperationException();
4789      }
4790 
4791     /**
4792      * This is the getter function for the size of the page.
4793      *
4794      * @return an integer that is the page size.
4795      */
4796     public int getPageSize() {
4797         throw new UnsupportedOperationException();
4798     }
4799 
4800 
4801     /**
4802      * Retrieves the data present in the page prior to the page from where it is
4803      * called.
4804      * @return boolean value true if it retrieves the previous page, flase if it
4805      *         is on the first page.
4806      * @throws SQLException if it is called before populate is called or ResultSet
4807      *         is of type {@code ResultSet.TYPE_FORWARD_ONLY} or if an error
4808      *         occurs.
4809      */
4810     public boolean previousPage() throws SQLException {
4811        throw new UnsupportedOperationException();
4812     }
4813 
4814     /**
4815        * Updates the designated column with a character stream value, which will
4816        * have the specified number of bytes. The driver does the necessary conversion
4817        * from Java character format to the national character set in the database.
4818        * It is intended for use when updating NCHAR, NVARCHAR and LONGNVARCHAR columns.
4819        * The updater methods are used to update column values in the current row or
4820        * the insert row. The updater methods do not update the underlying database;
4821        * instead the updateRow or insertRow methods are called to update the database.
4822        *
4823        * @param columnIndex - the first column is 1, the second is 2, ...
4824        * @param x - the new column value
4825        * @param length - the length of the stream
4826        * @exception SQLException if a database access error occurs
4827        * @since 1.6
4828        */
4829        public void updateNCharacterStream(int columnIndex,
4830                             java.io.Reader x,
4831                             int length)
4832                             throws SQLException {
4833           throw new UnsupportedOperationException(&quot;Operation not yet supported&quot;);
4834        }
4835 
4836      /**
4837        * Updates the designated column with a character stream value, which will
4838        * have the specified number of bytes. The driver does the necessary conversion
4839        * from Java character format to the national character set in the database.
4840        * It is intended for use when updating NCHAR,NVARCHAR and LONGNVARCHAR columns.
4841        * The updater methods are used to update column values in the current row or
4842        * the insert row. The updater methods do not update the underlying database;
4843        * instead the updateRow or insertRow methods are called to update the database.
4844        *
4845        * @param columnName - name of the Column
4846        * @param x - the new column value
4847        * @param length - the length of the stream
4848        * @exception SQLException if a database access error occurs
4849        * @since 1.6
4850        */
4851        public void updateNCharacterStream(String columnName,
4852                             java.io.Reader x,
4853                             int length)
4854                             throws SQLException {
4855           throw new UnsupportedOperationException(&quot;Operation not yet supported&quot;);
4856        }
4857 
4858       /**
4859        * This method re populates the resBundle
4860        * during the deserialization process
4861        *
4862        */
4863        private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
4864          // Default state initialization happens here
4865          ois.defaultReadObject();
4866          // Initialization of transient Res Bundle happens here .
4867          try {
4868             resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();
4869          } catch(IOException ioe) {
4870              throw new RuntimeException(ioe);
4871          }
4872 
4873        }
4874 
4875        static final long serialVersionUID = -3345004441725080251L;
4876 } //end class
    </pre>
  </body>
</html>
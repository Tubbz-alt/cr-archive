<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.sql.rowset/share/classes/javax/sql/rowset/BaseRowSet.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javax.sql.rowset;
  27 
  28 import java.sql.*;
  29 import javax.sql.*;
  30 import java.util.*;
  31 import java.io.*;
  32 import java.math.*;
  33 import java.io.Serializable;
  34 
  35 import javax.sql.rowset.serial.*;
  36 
  37 /**
  38  * An abstract class providing a &lt;code&gt;RowSet&lt;/code&gt; object with its basic functionality.
  39  * The basic functions include having properties and sending event notifications,
  40  * which all JavaBeans&amp;trade; components must implement.
  41  *
  42  * &lt;h2&gt;1.0 Overview&lt;/h2&gt;
  43  * The &lt;code&gt;BaseRowSet&lt;/code&gt; class provides the core functionality
  44  * for all &lt;code&gt;RowSet&lt;/code&gt; implementations,
  45  * and all standard implementations &lt;b&gt;may&lt;/b&gt; use this class in combination with
  46  * one or more &lt;code&gt;RowSet&lt;/code&gt; interfaces in order to provide a standard
  47  * vendor-specific implementation.  To clarify, all implementations must implement
  48  * at least one of the &lt;code&gt;RowSet&lt;/code&gt; interfaces (&lt;code&gt;JdbcRowSet&lt;/code&gt;,
  49  * &lt;code&gt;CachedRowSet&lt;/code&gt;, &lt;code&gt;JoinRowSet&lt;/code&gt;, &lt;code&gt;FilteredRowSet&lt;/code&gt;,
  50  * or &lt;code&gt;WebRowSet&lt;/code&gt;). This means that any implementation that extends
  51  * the &lt;code&gt;BaseRowSet&lt;/code&gt; class must also implement one of the &lt;code&gt;RowSet&lt;/code&gt;
  52  * interfaces.
  53  * &lt;p&gt;
  54  * The &lt;code&gt;BaseRowSet&lt;/code&gt; class provides the following:
  55  *
  56  * &lt;UL&gt;
  57  * &lt;LI&gt;&lt;b&gt;Properties&lt;/b&gt;
  58  *     &lt;ul&gt;
  59  *     &lt;li&gt;Fields for storing current properties
  60  *     &lt;li&gt;Methods for getting and setting properties
  61  *     &lt;/ul&gt;
  62  *
  63  * &lt;LI&gt;&lt;b&gt;Event notification&lt;/b&gt;
  64  *
  65  * &lt;LI&gt;&lt;b&gt;A complete set of setter methods&lt;/b&gt; for setting the parameters in a
  66  *      &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
  67  *
  68  * &lt;LI&gt; &lt;b&gt;Streams&lt;/b&gt;
  69  *  &lt;ul&gt;
  70  *  &lt;li&gt;Fields for storing stream instances
  71  *  &lt;li&gt;Constants for indicating the type of a stream
  72  *  &lt;/ul&gt;
  73  * &lt;/UL&gt;
  74  *
  75  * &lt;h2&gt;2.0 Setting Properties&lt;/h2&gt;
  76  * All rowsets maintain a set of properties, which will usually be set using
  77  * a tool.  The number and kinds of properties a rowset has will vary,
  78  * depending on what the &lt;code&gt;RowSet&lt;/code&gt; implementation does and how it gets
  79  * its data.  For example,
  80  * rowsets that get their data from a &lt;code&gt;ResultSet&lt;/code&gt; object need to
  81  * set the properties that are required for making a database connection.
  82  * If a &lt;code&gt;RowSet&lt;/code&gt; object uses the &lt;code&gt;DriverManager&lt;/code&gt; facility to make a
  83  * connection, it needs to set a property for the JDBC URL that identifies the
  84  * appropriate driver, and it needs to set the properties that give the
  85  * user name and password.
  86  * If, on the other hand, the rowset uses a &lt;code&gt;DataSource&lt;/code&gt; object
  87  * to make the connection, which is the preferred method, it does not need to
  88  * set the property for the JDBC URL.  Instead, it needs to set the property
  89  * for the logical name of the data source along with the properties for
  90  * the user name and password.
  91  * &lt;P&gt;
  92  * NOTE:  In order to use a &lt;code&gt;DataSource&lt;/code&gt; object for making a
  93  * connection, the &lt;code&gt;DataSource&lt;/code&gt; object must have been registered
  94  * with a naming service that uses the Java Naming and Directory
  95  * Interface&amp;trade; (JNDI) API.  This registration
  96  * is usually done by a person acting in the capacity of a system administrator.
  97  *
  98  * &lt;h2&gt;3.0 Setting the Command and Its Parameters&lt;/h2&gt;
  99  * When a rowset gets its data from a relational database, it executes a command (a query)
 100  * that produces a &lt;code&gt;ResultSet&lt;/code&gt; object.  This query is the command that is set
 101  * for the &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command property.  The rowset populates itself with data by reading the
 102  * data from the &lt;code&gt;ResultSet&lt;/code&gt; object into itself. If the query
 103  * contains placeholders for values to be set, the &lt;code&gt;BaseRowSet&lt;/code&gt; setter methods
 104  * are used to set these values. All setter methods allow these values to be set
 105  * to &lt;code&gt;null&lt;/code&gt; if required.
 106  * &lt;P&gt;
 107  * The following code fragment illustrates how the
 108  * &lt;code&gt;CachedRowSet&lt;/code&gt;&amp;trade;
 109  * object &lt;code&gt;crs&lt;/code&gt; might have its command property set.  Note that if a
 110  * tool is used to set properties, this is the code that the tool would use.
 111  * &lt;PRE&gt;{@code
 112  *    crs.setCommand(&quot;SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS&quot; +
 113  *                   &quot;WHERE CREDIT_LIMIT &gt; ? AND REGION = ?&quot;);
 114  * }&lt;/PRE&gt;
 115  * &lt;P&gt;
 116  * In this example, the values for &lt;code&gt;CREDIT_LIMIT&lt;/code&gt; and
 117  * &lt;code&gt;REGION&lt;/code&gt; are placeholder parameters, which are indicated with a
 118  * question mark (?).  The first question mark is placeholder parameter number
 119  * &lt;code&gt;1&lt;/code&gt;, the second question mark is placeholder parameter number
 120  * &lt;code&gt;2&lt;/code&gt;, and so on.  Any placeholder parameters must be set with
 121  * values before the query can be executed. To set these
 122  * placeholder parameters, the &lt;code&gt;BaseRowSet&lt;/code&gt; class provides a set of setter
 123  * methods, similar to those provided by the &lt;code&gt;PreparedStatement&lt;/code&gt;
 124  * interface, for setting values of each data type.  A &lt;code&gt;RowSet&lt;/code&gt; object stores the
 125  * parameter values internally, and its &lt;code&gt;execute&lt;/code&gt; method uses them internally
 126  * to set values for the placeholder parameters
 127  * before it sends the command to the DBMS to be executed.
 128  * &lt;P&gt;
 129  * The following code fragment demonstrates
 130  * setting the two parameters in the query from the previous example.
 131  * &lt;PRE&gt;{@code
 132  *    crs.setInt(1, 5000);
 133  *    crs.setString(2, &quot;West&quot;);
 134  * }&lt;/PRE&gt;
 135  * If the &lt;code&gt;execute&lt;/code&gt; method is called at this point, the query
 136  * sent to the DBMS will be:
 137  * &lt;PRE&gt;{@code
 138  *    &quot;SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS&quot; +
 139  *                   &quot;WHERE CREDIT_LIMIT &gt; 5000 AND REGION = &#39;West&#39;&quot;
 140  * }&lt;/PRE&gt;
 141  * NOTE: Setting &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt; and
 142  * &lt;code&gt;Ref&lt;/code&gt; objects as a command parameter, stores these values as
 143  * &lt;code&gt;SerialArray&lt;/code&gt;, &lt;code&gt;SerialClob&lt;/code&gt;, &lt;code&gt;SerialBlob&lt;/code&gt;
 144  * and &lt;code&gt;SerialRef&lt;/code&gt; objects respectively.
 145  *
 146  * &lt;h2&gt;4.0 Handling of Parameters Behind the Scenes&lt;/h2&gt;
 147  *
 148  * NOTE: The &lt;code&gt;BaseRowSet&lt;/code&gt; class provides two kinds of setter methods,
 149  * those that set properties and those that set placeholder parameters. The setter
 150  * methods discussed in this section are those that set placeholder parameters.
 151  * &lt;P&gt;
 152  * The placeholder parameters set with the &lt;code&gt;BaseRowSet&lt;/code&gt; setter methods
 153  * are stored as objects in an internal &lt;code&gt;Hashtable&lt;/code&gt; object.
 154  * Primitives are stored as their &lt;code&gt;Object&lt;/code&gt; type. For example, &lt;code&gt;byte&lt;/code&gt;
 155  * is stored as &lt;code&gt;Byte&lt;/code&gt; object, and &lt;code&gt;int&lt;/code&gt; is stored as
 156  * an &lt;code&gt;Integer&lt;/code&gt; object.
 157  * When the method &lt;code&gt;execute&lt;/code&gt; is called, the values in the
 158  * &lt;code&gt;Hashtable&lt;/code&gt; object are substituted for the appropriate placeholder
 159  * parameters in the command.
 160  * &lt;P&gt;
 161  * A call to the method &lt;code&gt;getParams&lt;/code&gt; returns the values stored in the
 162  * &lt;code&gt;Hashtable&lt;/code&gt; object as an array of &lt;code&gt;Object&lt;/code&gt; instances.
 163  * An element in this array may be a simple &lt;code&gt;Object&lt;/code&gt; instance or an
 164  * array (which is a type of &lt;code&gt;Object&lt;/code&gt;). The particular setter method used
 165  * determines whether an element in this array is an &lt;code&gt;Object&lt;/code&gt; or an array.
 166  * &lt;P&gt;
 167  * The majority of methods for setting placeholder parameters take two parameters,
 168  *  with the first parameter
 169  * indicating which placeholder parameter is to be set, and the second parameter
 170  * giving the value to be set.  Methods such as &lt;code&gt;setInt&lt;/code&gt;,
 171  * &lt;code&gt;setString&lt;/code&gt;, &lt;code&gt;setBoolean&lt;/code&gt;, and &lt;code&gt;setLong&lt;/code&gt; fall into
 172  * this category.  After these methods have been called, a call to the method
 173  * &lt;code&gt;getParams&lt;/code&gt; will return an array with the values that have been set. Each
 174  * element in the array is an &lt;code&gt;Object&lt;/code&gt; instance representing the
 175  * values that have been set. The order of these values in the array is determined by the
 176  * &lt;code&gt;int&lt;/code&gt; (the first parameter) passed to the setter method. The values in the
 177  * array are the values (the second parameter) passed to the setter method.
 178  * In other words, the first element in the array is the value
 179  * to be set for the first placeholder parameter in the &lt;code&gt;RowSet&lt;/code&gt; object&#39;s
 180  * command. The second element is the value to
 181  * be set for the second placeholder parameter, and so on.
 182  * &lt;P&gt;
 183  * Several setter methods send the driver and DBMS information beyond the value to be set.
 184  * When the method &lt;code&gt;getParams&lt;/code&gt; is called after one of these setter methods has
 185  * been used, the elements in the array will themselves be arrays to accommodate the
 186  * additional information. In this category, the method &lt;code&gt;setNull&lt;/code&gt; is a special case
 187  * because one version takes only
 188  * two parameters (&lt;code&gt;setNull(int parameterIndex, int SqlType)&lt;/code&gt;). Nevertheless,
 189  * it requires
 190  * an array to contain the information that will be passed to the driver and DBMS.  The first
 191  * element in this array is the value to be set, which is &lt;code&gt;null&lt;/code&gt;, and the
 192  * second element is the &lt;code&gt;int&lt;/code&gt; supplied for &lt;i&gt;sqlType&lt;/i&gt;, which
 193  * indicates the type of SQL value that is being set to &lt;code&gt;null&lt;/code&gt;. This information
 194  * is needed by some DBMSs and is therefore required in order to ensure that applications
 195  * are portable.
 196  * The other version is intended to be used when the value to be set to &lt;code&gt;null&lt;/code&gt;
 197  * is a user-defined type. It takes three parameters
 198  * (&lt;code&gt;setNull(int parameterIndex, int sqlType, String typeName)&lt;/code&gt;) and also
 199  * requires an array to contain the information to be passed to the driver and DBMS.
 200  * The first two elements in this array are the same as for the first version of
 201  * &lt;code&gt;setNull&lt;/code&gt;.  The third element, &lt;i&gt;typeName&lt;/i&gt;, gives the SQL name of
 202  * the user-defined type. As is true with the other setter methods, the number of the
 203  * placeholder parameter to be set is indicated by an element&#39;s position in the array
 204  * returned by &lt;code&gt;getParams&lt;/code&gt;.  So, for example, if the parameter
 205  * supplied to &lt;code&gt;setNull&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, the second element in the array
 206  * returned by &lt;code&gt;getParams&lt;/code&gt; will be an array of two or three elements.
 207  * &lt;P&gt;
 208  * Some methods, such as &lt;code&gt;setObject&lt;/code&gt; and &lt;code&gt;setDate&lt;/code&gt; have versions
 209  * that take more than two parameters, with the extra parameters giving information
 210  * to the driver or the DBMS. For example, the methods &lt;code&gt;setDate&lt;/code&gt;,
 211  * &lt;code&gt;setTime&lt;/code&gt;, and &lt;code&gt;setTimestamp&lt;/code&gt; can take a &lt;code&gt;Calendar&lt;/code&gt;
 212  * object as their third parameter.  If the DBMS does not store time zone information,
 213  * the driver uses the &lt;code&gt;Calendar&lt;/code&gt; object to construct the &lt;code&gt;Date&lt;/code&gt;,
 214  * &lt;code&gt;Time&lt;/code&gt;, or &lt;code&gt;Timestamp&lt;/code&gt; object being set. As is true with other
 215  * methods that provide additional information, the element in the array returned
 216  * by &lt;code&gt;getParams&lt;/code&gt; is an array instead of a simple &lt;code&gt;Object&lt;/code&gt; instance.
 217  * &lt;P&gt;
 218  * The methods &lt;code&gt;setAsciiStream&lt;/code&gt;, &lt;code&gt;setBinaryStream&lt;/code&gt;,
 219  * &lt;code&gt;setCharacterStream&lt;/code&gt;, and &lt;code&gt;setUnicodeStream&lt;/code&gt; (which is
 220  * deprecated, so applications should use &lt;code&gt;getCharacterStream&lt;/code&gt; instead)
 221  * take three parameters, so for them, the element in the array returned by
 222  * &lt;code&gt;getParams&lt;/code&gt; is also an array.  What is different about these setter
 223  * methods is that in addition to the information provided by parameters, the array contains
 224  * one of the &lt;code&gt;BaseRowSet&lt;/code&gt; constants indicating the type of stream being set.
 225 * &lt;p&gt;
 226 * NOTE: The method &lt;code&gt;getParams&lt;/code&gt; is called internally by
 227 * &lt;code&gt;RowSet&lt;/code&gt; implementations extending this class; it is not normally called by an
 228 * application programmer directly.
 229 *
 230 * &lt;h2&gt;5.0 Event Notification&lt;/h2&gt;
 231 * The &lt;code&gt;BaseRowSet&lt;/code&gt; class provides the event notification
 232 * mechanism for rowsets.  It contains the field
 233 * &lt;code&gt;listeners&lt;/code&gt;, methods for adding and removing listeners, and
 234 * methods for notifying listeners of changes.
 235 * &lt;P&gt;
 236 * A listener is an object that has implemented the &lt;code&gt;RowSetListener&lt;/code&gt; interface.
 237 * If it has been added to a &lt;code&gt;RowSet&lt;/code&gt; object&#39;s list of listeners, it will be notified
 238 *  when an event occurs on that &lt;code&gt;RowSet&lt;/code&gt; object.  Each listener&#39;s
 239 * implementation of the &lt;code&gt;RowSetListener&lt;/code&gt; methods defines what that object
 240 * will do when it is notified that an event has occurred.
 241 * &lt;P&gt;
 242 * There are three possible events for a &lt;code&gt;RowSet&lt;/code&gt; object:
 243 * &lt;OL&gt;
 244 * &lt;LI&gt;the cursor moves
 245 * &lt;LI&gt;an individual row is changed (updated, deleted, or inserted)
 246 * &lt;LI&gt;the contents of the entire &lt;code&gt;RowSet&lt;/code&gt; object  are changed
 247 * &lt;/OL&gt;
 248 * &lt;P&gt;
 249 * The &lt;code&gt;BaseRowSet&lt;/code&gt; method used for the notification indicates the
 250 * type of event that has occurred.  For example, the method
 251 * &lt;code&gt;notifyRowChanged&lt;/code&gt; indicates that a row has been updated,
 252 * deleted, or inserted.  Each of the notification methods creates a
 253 * &lt;code&gt;RowSetEvent&lt;/code&gt; object, which is supplied to the listener in order to
 254 * identify the &lt;code&gt;RowSet&lt;/code&gt; object on which the event occurred.
 255 * What the listener does with this information, which may be nothing, depends on how it was
 256 * implemented.
 257 *
 258 * &lt;h2&gt;6.0 Default Behavior&lt;/h2&gt;
 259 * A default &lt;code&gt;BaseRowSet&lt;/code&gt; object is initialized with many starting values.
 260 *
 261 * The following is true of a default &lt;code&gt;RowSet&lt;/code&gt; instance that extends
 262 * the &lt;code&gt;BaseRowSet&lt;/code&gt; class:
 263 * &lt;UL&gt;
 264 *   &lt;LI&gt;Has a scrollable cursor and does not show changes
 265 *       made by others.
 266 *   &lt;LI&gt;Is updatable.
 267 *   &lt;LI&gt;Does not show rows that have been deleted.
 268 *   &lt;LI&gt;Has no time limit for how long a driver may take to
 269 *       execute the &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command.
 270 *   &lt;LI&gt;Has no limit for the number of rows it may contain.
 271 *   &lt;LI&gt;Has no limit for the number of bytes a column may contain. NOTE: This
 272 *   limit applies only to columns that hold values of the
 273 *   following types:  &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;,
 274 *   &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;,
 275 *   and &lt;code&gt;LONGVARCHAR&lt;/code&gt;.
 276 *   &lt;LI&gt;Will not see uncommitted data (make &quot;dirty&quot; reads).
 277 *   &lt;LI&gt;Has escape processing turned on.
 278 *   &lt;LI&gt;Has its connection&#39;s type map set to &lt;code&gt;null&lt;/code&gt;.
 279 *   &lt;LI&gt;Has an empty &lt;code&gt;Vector&lt;/code&gt; object for storing the values set
 280 *       for the placeholder parameters in the &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command.
 281 * &lt;/UL&gt;
 282 * &lt;p&gt;
 283 * If other values are desired, an application must set the property values
 284 * explicitly. For example, the following line of code sets the maximum number
 285 * of rows for the &lt;code&gt;CachedRowSet&lt;/code&gt; object &lt;i&gt;crs&lt;/i&gt; to 500.
 286 * &lt;PRE&gt;
 287 *    crs.setMaxRows(500);
 288 * &lt;/PRE&gt;
 289 * Methods implemented in extensions of this &lt;code&gt;BaseRowSet&lt;/code&gt; class &lt;b&gt;must&lt;/b&gt; throw an
 290 * &lt;code&gt;SQLException&lt;/code&gt; object for any violation of the defined assertions.  Also, if the
 291 * extending class overrides and reimplements any &lt;code&gt;BaseRowSet&lt;/code&gt; method and encounters
 292 * connectivity or underlying data source issues, that method &lt;b&gt;may&lt;/b&gt; in addition throw an
 293 * &lt;code&gt;SQLException&lt;/code&gt; object for that reason.
 294 *
 295 * @since 1.5
 296 */
 297 
 298 public abstract class BaseRowSet implements Serializable, Cloneable {
 299 
 300     /**
 301      * A constant indicating to a &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object
 302      * that a given parameter is a Unicode stream. This
 303      * &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object is provided as an extension of the
 304      * &lt;code&gt;SyncProvider&lt;/code&gt; abstract class defined in the
 305      * &lt;code&gt;SyncFactory&lt;/code&gt; static factory SPI mechanism.
 306      */
 307     public static final int UNICODE_STREAM_PARAM = 0;
 308 
 309     /**
 310      * A constant indicating to a &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object
 311      * that a given parameter is a binary stream. A
 312      * &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object is provided as an extension of the
 313      * &lt;code&gt;SyncProvider&lt;/code&gt; abstract class defined in the
 314      * &lt;code&gt;SyncFactory&lt;/code&gt; static factory SPI mechanism.
 315      */
 316     public static final int BINARY_STREAM_PARAM = 1;
 317 
 318     /**
 319      * A constant indicating to a &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object
 320      * that a given parameter is an ASCII stream. A
 321      * &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object is provided as an extension of the
 322      * &lt;code&gt;SyncProvider&lt;/code&gt; abstract class defined in the
 323      * &lt;code&gt;SyncFactory&lt;/code&gt; static factory SPI mechanism.
 324      */
 325     public static final int ASCII_STREAM_PARAM = 2;
 326 
 327     /**
 328      * The &lt;code&gt;InputStream&lt;/code&gt; object that will be
 329      * returned by the method &lt;code&gt;getBinaryStream&lt;/code&gt;, which is
 330      * specified in the &lt;code&gt;ResultSet&lt;/code&gt; interface.
 331      * @serial
 332      */
 333     protected java.io.InputStream binaryStream;
 334 
 335     /**
 336      * The &lt;code&gt;InputStream&lt;/code&gt; object that will be
 337      * returned by the method &lt;code&gt;getUnicodeStream&lt;/code&gt;,
 338      * which is specified in the &lt;code&gt;ResultSet&lt;/code&gt; interface.
 339      * @serial
 340      */
 341     protected java.io.InputStream unicodeStream;
 342 
 343     /**
 344      * The &lt;code&gt;InputStream&lt;/code&gt; object that will be
 345      * returned by the method &lt;code&gt;getAsciiStream&lt;/code&gt;,
 346      * which is specified in the &lt;code&gt;ResultSet&lt;/code&gt; interface.
 347      * @serial
 348      */
 349     protected java.io.InputStream asciiStream;
 350 
 351     /**
 352      * The &lt;code&gt;Reader&lt;/code&gt; object that will be
 353      * returned by the method &lt;code&gt;getCharacterStream&lt;/code&gt;,
 354      * which is specified in the &lt;code&gt;ResultSet&lt;/code&gt; interface.
 355      * @serial
 356      */
 357     protected java.io.Reader charStream;
 358 
 359     /**
 360      * The query that will be sent to the DBMS for execution when the
 361      * method &lt;code&gt;execute&lt;/code&gt; is called.
 362      * @serial
 363      */
 364     private String command;
 365 
 366     /**
 367      * The JDBC URL the reader, writer, or both supply to the method
 368      * &lt;code&gt;DriverManager.getConnection&lt;/code&gt; when the
 369      * &lt;code&gt;DriverManager&lt;/code&gt; is used to get a connection.
 370      * &lt;P&gt;
 371      * The JDBC URL identifies the driver to be used to make the connection.
 372      * This URL can be found in the documentation supplied by the driver
 373      * vendor.
 374      * @serial
 375      */
 376     private String URL;
 377 
 378     /**
 379      * The logical name of the data source that the reader/writer should use
 380      * in order to retrieve a &lt;code&gt;DataSource&lt;/code&gt; object from a Java
 381      * Directory and Naming Interface (JNDI) naming service.
 382      * @serial
 383      */
 384     private String dataSource;
 385 
 386     /**
 387      * The user name the reader, writer, or both supply to the method
 388      * &lt;code&gt;DriverManager.getConnection&lt;/code&gt; when the
 389      * &lt;code&gt;DriverManager&lt;/code&gt; is used to get a connection.
 390      * @serial
 391      */
 392     private transient String username;
 393 
 394     /**
 395      * The password the reader, writer, or both supply to the method
 396      * &lt;code&gt;DriverManager.getConnection&lt;/code&gt; when the
 397      * &lt;code&gt;DriverManager&lt;/code&gt; is used to get a connection.
 398      * @serial
 399      */
 400     private transient String password;
 401 
 402     /**
 403      * A constant indicating the type of this JDBC &lt;code&gt;RowSet&lt;/code&gt;
 404      * object. It must be one of the following &lt;code&gt;ResultSet&lt;/code&gt;
 405      * constants:  &lt;code&gt;TYPE_FORWARD_ONLY&lt;/code&gt;,
 406      * &lt;code&gt;TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
 407      * &lt;code&gt;TYPE_SCROLL_SENSITIVE&lt;/code&gt;.
 408      * @serial
 409      */
 410     private int rowSetType = ResultSet.TYPE_SCROLL_INSENSITIVE;
 411 
 412     /**
 413      * A &lt;code&gt;boolean&lt;/code&gt; indicating whether deleted rows are visible in this
 414      * JDBC &lt;code&gt;RowSet&lt;/code&gt; object .
 415      * @serial
 416      */
 417     private boolean showDeleted = false; // default is false
 418 
 419     /**
 420      * The maximum number of seconds the driver
 421      * will wait for a command to execute.  This limit applies while
 422      * this JDBC &lt;code&gt;RowSet&lt;/code&gt; object is connected to its data
 423      * source, that is, while it is populating itself with
 424      * data and while it is writing data back to the data source.
 425      * @serial
 426      */
 427     private int queryTimeout = 0; // default is no timeout
 428 
 429     /**
 430      * The maximum number of rows the reader should read.
 431      * @serial
 432      */
 433     private int maxRows = 0; // default is no limit
 434 
 435     /**
 436      * The maximum field size the reader should read.
 437      * @serial
 438      */
 439     private int maxFieldSize = 0; // default is no limit
 440 
 441     /**
 442      * A constant indicating the concurrency of this JDBC &lt;code&gt;RowSet&lt;/code&gt;
 443      * object. It must be one of the following &lt;code&gt;ResultSet&lt;/code&gt;
 444      * constants: &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt; or
 445      * &lt;code&gt;CONCUR_UPDATABLE&lt;/code&gt;.
 446      * @serial
 447      */
 448     private int concurrency = ResultSet.CONCUR_UPDATABLE;
 449 
 450     /**
 451      * A &lt;code&gt;boolean&lt;/code&gt; indicating whether this JDBC &lt;code&gt;RowSet&lt;/code&gt;
 452      * object is read-only.  &lt;code&gt;true&lt;/code&gt; indicates that it is read-only;
 453      * &lt;code&gt;false&lt;/code&gt; that it is writable.
 454      * @serial
 455      */
 456     private boolean readOnly;
 457 
 458     /**
 459      * A &lt;code&gt;boolean&lt;/code&gt; indicating whether the reader for this
 460      * JDBC &lt;code&gt;RowSet&lt;/code&gt; object should perform escape processing.
 461      * &lt;code&gt;true&lt;/code&gt; means that escape processing is turned on;
 462      * &lt;code&gt;false&lt;/code&gt; that it is not. The default is &lt;code&gt;true&lt;/code&gt;.
 463      * @serial
 464      */
 465     private boolean escapeProcessing = true;
 466 
 467     /**
 468      * A constant indicating the isolation level of the connection
 469      * for this JDBC &lt;code&gt;RowSet&lt;/code&gt; object . It must be one of
 470      * the following &lt;code&gt;Connection&lt;/code&gt; constants:
 471      * &lt;code&gt;TRANSACTION_NONE&lt;/code&gt;,
 472      * &lt;code&gt;TRANSACTION_READ_UNCOMMITTED&lt;/code&gt;,
 473      * &lt;code&gt;TRANSACTION_READ_COMMITTED&lt;/code&gt;,
 474      * &lt;code&gt;TRANSACTION_REPEATABLE_READ&lt;/code&gt; or
 475      * &lt;code&gt;TRANSACTION_SERIALIZABLE&lt;/code&gt;.
 476      * @serial
 477      */
 478     private int isolation;
 479 
 480     /**
 481      * A constant used as a hint to the driver that indicates the direction in
 482      * which data from this JDBC &lt;code&gt;RowSet&lt;/code&gt; object  is going
 483      * to be fetched. The following &lt;code&gt;ResultSet&lt;/code&gt; constants are
 484      * possible values:
 485      * &lt;code&gt;FETCH_FORWARD&lt;/code&gt;,
 486      * &lt;code&gt;FETCH_REVERSE&lt;/code&gt;,
 487      * &lt;code&gt;FETCH_UNKNOWN&lt;/code&gt;.
 488      * &lt;P&gt;
 489      * Unused at this time.
 490      * @serial
 491      */
 492     private int fetchDir = ResultSet.FETCH_FORWARD; // default fetch direction
 493 
 494     /**
 495      * A hint to the driver that indicates the expected number of rows
 496      * in this JDBC &lt;code&gt;RowSet&lt;/code&gt; object .
 497      * &lt;P&gt;
 498      * Unused at this time.
 499      * @serial
 500      */
 501     private int fetchSize = 0; // default fetchSize
 502 
 503     /**
 504      * The &lt;code&gt;java.util.Map&lt;/code&gt; object that contains entries mapping
 505      * SQL type names to classes in the Java programming language for the
 506      * custom mapping of user-defined types.
 507      * @serial
 508      */
 509     private Map&lt;String, Class&lt;?&gt;&gt; map;
 510 
 511     /**
 512      * A &lt;code&gt;Vector&lt;/code&gt; object that holds the list of listeners
 513      * that have registered with this &lt;code&gt;RowSet&lt;/code&gt; object.
 514      * @serial
 515      */
 516     private Vector&lt;RowSetListener&gt; listeners;
 517 
 518     /**
 519      * A &lt;code&gt;Vector&lt;/code&gt; object that holds the parameters set
 520      * for this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s current command.
 521      * @serial
 522      */
 523     private Hashtable&lt;Integer, Object&gt; params; // could be transient?
 524 
 525     /**
 526      * Constructs a new &lt;code&gt;BaseRowSet&lt;/code&gt; object initialized with
 527      * a default &lt;code&gt;Vector&lt;/code&gt; object for its &lt;code&gt;listeners&lt;/code&gt;
 528      * field. The other default values with which it is initialized are listed
 529      * in Section 6.0 of the class comment for this class.
 530      */
 531     public BaseRowSet() {
 532         // allocate the listeners collection
 533         listeners = new Vector&lt;RowSetListener&gt;();
 534     }
 535 
 536     /**
 537      * Performs the necessary internal configurations and initializations
 538      * to allow any JDBC &lt;code&gt;RowSet&lt;/code&gt; implementation to start using
 539      * the standard facilities provided by a &lt;code&gt;BaseRowSet&lt;/code&gt;
 540      * instance. This method &lt;b&gt;should&lt;/b&gt; be called after the &lt;code&gt;RowSet&lt;/code&gt; object
 541      * has been instantiated to correctly initialize all parameters. This method
 542      * &lt;b&gt;should&lt;/b&gt; never be called by an application, but is called from with
 543      * a &lt;code&gt;RowSet&lt;/code&gt; implementation extending this class.
 544      */
 545     protected void initParams() {
 546         params = new Hashtable&lt;Integer, Object&gt;();
 547     }
 548 
 549     //--------------------------------------------------------------------
 550     // Events
 551     //--------------------------------------------------------------------
 552 
 553     /**
 554     * The listener will be notified whenever an event occurs on this &lt;code&gt;RowSet&lt;/code&gt;
 555     * object.
 556     * &lt;P&gt;
 557     * A listener might, for example, be a table or graph that needs to
 558     * be updated in order to accurately reflect the current state of
 559     * the &lt;code&gt;RowSet&lt;/code&gt; object.
 560     * &lt;p&gt;
 561     * &lt;b&gt;Note&lt;/b&gt;: if the &lt;code&gt;RowSetListener&lt;/code&gt; object is
 562     * &lt;code&gt;null&lt;/code&gt;, this method silently discards the &lt;code&gt;null&lt;/code&gt;
 563     * value and does not add a null reference to the set of listeners.
 564     * &lt;p&gt;
 565     * &lt;b&gt;Note&lt;/b&gt;: if the listener is already set, and the new &lt;code&gt;RowSetListener&lt;/code&gt;
 566     * instance is added to the set of listeners already registered to receive
 567     * event notifications from this &lt;code&gt;RowSet&lt;/code&gt;.
 568     *
 569     * @param listener an object that has implemented the
 570     *     &lt;code&gt;javax.sql.RowSetListener&lt;/code&gt; interface and wants to be notified
 571     *     of any events that occur on this &lt;code&gt;RowSet&lt;/code&gt; object; May be
 572     *     null.
 573     * @see #removeRowSetListener
 574     */
 575     public void addRowSetListener(RowSetListener listener) {
 576         listeners.add(listener);
 577     }
 578 
 579     /**
 580     * Removes the designated object from this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s list of listeners.
 581     * If the given argument is not a registered listener, this method
 582     * does nothing.
 583     *
 584     *  &lt;b&gt;Note&lt;/b&gt;: if the &lt;code&gt;RowSetListener&lt;/code&gt; object is
 585     * &lt;code&gt;null&lt;/code&gt;, this method silently discards the &lt;code&gt;null&lt;/code&gt;
 586     * value.
 587     *
 588     * @param listener a &lt;code&gt;RowSetListener&lt;/code&gt; object that is on the list
 589     *        of listeners for this &lt;code&gt;RowSet&lt;/code&gt; object
 590     * @see #addRowSetListener
 591     */
 592     public void removeRowSetListener(RowSetListener listener) {
 593         listeners.remove(listener);
 594     }
 595 
 596     /**
 597      * Determine if instance of this class extends the RowSet interface.
 598      */
 599     private void checkforRowSetInterface() throws SQLException {
 600         if ((this instanceof javax.sql.RowSet) == false) {
 601             throw new SQLException(&quot;The class extending abstract class BaseRowSet &quot; +
 602                 &quot;must implement javax.sql.RowSet or one of it&#39;s sub-interfaces.&quot;);
 603         }
 604     }
 605 
 606     /**
 607     * Notifies all of the listeners registered with this
 608     * &lt;code&gt;RowSet&lt;/code&gt; object that its cursor has moved.
 609     * &lt;P&gt;
 610     * When an application calls a method to move the cursor,
 611     * that method moves the cursor and then calls this method
 612     * internally. An application &lt;b&gt;should&lt;/b&gt; never invoke
 613     * this method directly.
 614     *
 615     * @throws SQLException if the class extending the &lt;code&gt;BaseRowSet&lt;/code&gt;
 616     *     abstract class does not implement the &lt;code&gt;RowSet&lt;/code&gt; interface or
 617     *     one of it&#39;s sub-interfaces.
 618     */
 619     protected void notifyCursorMoved() throws SQLException {
 620         checkforRowSetInterface();
 621         if (listeners.isEmpty() == false) {
 622             RowSetEvent event = new RowSetEvent((RowSet)this);
 623             for (RowSetListener rsl : listeners) {
 624                 rsl.cursorMoved(event);
 625             }
 626         }
 627     }
 628 
 629     /**
 630     * Notifies all of the listeners registered with this &lt;code&gt;RowSet&lt;/code&gt; object that
 631     * one of its rows has changed.
 632     * &lt;P&gt;
 633     * When an application calls a method that changes a row, such as
 634     * the &lt;code&gt;CachedRowSet&lt;/code&gt; methods &lt;code&gt;insertRow&lt;/code&gt;,
 635     * &lt;code&gt;updateRow&lt;/code&gt;, or &lt;code&gt;deleteRow&lt;/code&gt;,
 636     * that method calls &lt;code&gt;notifyRowChanged&lt;/code&gt;
 637     * internally. An application &lt;b&gt;should&lt;/b&gt; never invoke
 638     * this method directly.
 639     *
 640     * @throws SQLException if the class extending the &lt;code&gt;BaseRowSet&lt;/code&gt;
 641     *     abstract class does not implement the &lt;code&gt;RowSet&lt;/code&gt; interface or
 642     *     one of it&#39;s sub-interfaces.
 643     */
 644     protected void notifyRowChanged() throws SQLException {
 645         checkforRowSetInterface();
 646         if (listeners.isEmpty() == false) {
 647                 RowSetEvent event = new RowSetEvent((RowSet)this);
 648                 for (RowSetListener rsl : listeners) {
 649                     rsl.rowChanged(event);
 650                 }
 651         }
 652     }
 653 
 654    /**
 655     * Notifies all of the listeners registered with this &lt;code&gt;RowSet&lt;/code&gt;
 656     * object that its entire contents have changed.
 657     * &lt;P&gt;
 658     * When an application calls methods that change the entire contents
 659     * of the &lt;code&gt;RowSet&lt;/code&gt; object, such as the &lt;code&gt;CachedRowSet&lt;/code&gt; methods
 660     * &lt;code&gt;execute&lt;/code&gt;, &lt;code&gt;populate&lt;/code&gt;, &lt;code&gt;restoreOriginal&lt;/code&gt;,
 661     * or &lt;code&gt;release&lt;/code&gt;, that method calls &lt;code&gt;notifyRowSetChanged&lt;/code&gt;
 662     * internally (either directly or indirectly). An application &lt;b&gt;should&lt;/b&gt;
 663     * never invoke this method directly.
 664     *
 665     * @throws SQLException if the class extending the &lt;code&gt;BaseRowSet&lt;/code&gt;
 666     *     abstract class does not implement the &lt;code&gt;RowSet&lt;/code&gt; interface or
 667     *     one of it&#39;s sub-interfaces.
 668     */
 669     protected void notifyRowSetChanged() throws SQLException {
 670         checkforRowSetInterface();
 671         if (listeners.isEmpty() == false) {
 672                 RowSetEvent event = new RowSetEvent((RowSet)this);
 673                 for (RowSetListener rsl : listeners) {
 674                     rsl.rowSetChanged(event);
 675                 }
 676         }
 677 }
 678 
 679     /**
 680      * Retrieves the SQL query that is the command for this
 681      * &lt;code&gt;RowSet&lt;/code&gt; object. The command property contains the query that
 682      * will be executed to populate this &lt;code&gt;RowSet&lt;/code&gt; object.
 683      * &lt;P&gt;
 684      * The SQL query returned by this method is used by &lt;code&gt;RowSet&lt;/code&gt; methods
 685      * such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt;, which may be implemented
 686      * by any class that extends the &lt;code&gt;BaseRowSet&lt;/code&gt; abstract class and
 687      * implements one or more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt;
 688      * interfaces.
 689      * &lt;P&gt;
 690      * The command is used by the &lt;code&gt;RowSet&lt;/code&gt; object&#39;s
 691      * reader to obtain a &lt;code&gt;ResultSet&lt;/code&gt; object.  The reader then
 692      * reads the data from the &lt;code&gt;ResultSet&lt;/code&gt; object and uses it to
 693      * to populate this &lt;code&gt;RowSet&lt;/code&gt; object.
 694      * &lt;P&gt;
 695      * The default value for the &lt;code&gt;command&lt;/code&gt; property is &lt;code&gt;null&lt;/code&gt;.
 696      *
 697      * @return the &lt;code&gt;String&lt;/code&gt; that is the value for this
 698      *         &lt;code&gt;RowSet&lt;/code&gt; object&#39;s &lt;code&gt;command&lt;/code&gt; property;
 699      *         may be &lt;code&gt;null&lt;/code&gt;
 700      * @see #setCommand
 701      */
 702     public String getCommand() {
 703         return command;
 704     }
 705 
 706     /**
 707      * Sets this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s &lt;code&gt;command&lt;/code&gt; property to
 708      * the given &lt;code&gt;String&lt;/code&gt; object and clears the parameters, if any,
 709      * that were set for the previous command.
 710      * &lt;P&gt;
 711      * The &lt;code&gt;command&lt;/code&gt; property may not be needed if the &lt;code&gt;RowSet&lt;/code&gt;
 712      * object gets its data from a source that does not support commands,
 713      * such as a spreadsheet or other tabular file.
 714      * Thus, this property is optional and may be &lt;code&gt;null&lt;/code&gt;.
 715      *
 716      * @param cmd a &lt;code&gt;String&lt;/code&gt; object containing an SQL query
 717      *            that will be set as this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
 718      *            property; may be &lt;code&gt;null&lt;/code&gt; but may not be an empty string
 719      * @throws SQLException if an empty string is provided as the command value
 720      * @see #getCommand
 721      */
 722     public void setCommand(String cmd) throws SQLException {
 723         // cmd equal to null or
 724         // cmd with length 0 (implies url ==&quot;&quot;)
 725         // are not independent events.
 726 
 727         if(cmd == null) {
 728            command = null;
 729         } else if (cmd.length() == 0) {
 730             throw new SQLException(&quot;Invalid command string detected. &quot; +
 731             &quot;Cannot be of length less than 0&quot;);
 732         } else {
 733             // &quot;unbind&quot; any parameters from any previous command.
 734             if(params == null){
 735                  throw new SQLException(&quot;Set initParams() before setCommand&quot;);
 736             }
 737             params.clear();
 738             command = cmd;
 739         }
 740 
 741     }
 742 
 743     /**
 744      * Retrieves the JDBC URL that this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s
 745      * &lt;code&gt;javax.sql.Reader&lt;/code&gt; object uses to make a connection
 746      * with a relational database using a JDBC technology-enabled driver.
 747      *&lt;P&gt;
 748      * The &lt;code&gt;Url&lt;/code&gt; property will be &lt;code&gt;null&lt;/code&gt; if the underlying data
 749      * source is a non-SQL data source, such as a spreadsheet or an XML
 750      * data source.
 751      *
 752      * @return a &lt;code&gt;String&lt;/code&gt; object that contains the JDBC URL
 753      *         used to establish the connection for this &lt;code&gt;RowSet&lt;/code&gt;
 754      *         object; may be &lt;code&gt;null&lt;/code&gt; (default value) if not set
 755      * @throws SQLException if an error occurs retrieving the URL value
 756      * @see #setUrl
 757      */
 758     public String getUrl() throws SQLException {
 759         return URL;
 760     }
 761 
 762     /**
 763      * Sets the Url property for this &lt;code&gt;RowSet&lt;/code&gt; object
 764      * to the given &lt;code&gt;String&lt;/code&gt; object and sets the dataSource name
 765      * property to &lt;code&gt;null&lt;/code&gt;. The Url property is a
 766      * JDBC URL that is used when
 767      * the connection is created using a JDBC technology-enabled driver
 768      * (&quot;JDBC driver&quot;) and the &lt;code&gt;DriverManager&lt;/code&gt;.
 769      * The correct JDBC URL for the specific driver to be used can be found
 770      * in the driver documentation.  Although there are guidelines for how
 771      * a JDBC URL is formed,
 772      * a driver vendor can specify any &lt;code&gt;String&lt;/code&gt; object except
 773      * one with a length of &lt;code&gt;0&lt;/code&gt; (an empty string).
 774      * &lt;P&gt;
 775      * Setting the Url property is optional if connections are established using
 776      * a &lt;code&gt;DataSource&lt;/code&gt; object instead of the &lt;code&gt;DriverManager&lt;/code&gt;.
 777      * The driver will use either the URL property or the
 778      * dataSourceName property to create a connection, whichever was
 779      * specified most recently. If an application uses a JDBC URL, it
 780      * must load a JDBC driver that accepts the JDBC URL before it uses the
 781      * &lt;code&gt;RowSet&lt;/code&gt; object to connect to a database.  The &lt;code&gt;RowSet&lt;/code&gt;
 782      * object will use the URL internally to create a database connection in order
 783      * to read or write data.
 784      *
 785      * @param url a &lt;code&gt;String&lt;/code&gt; object that contains the JDBC URL
 786      *     that will be used to establish the connection to a database for this
 787      *     &lt;code&gt;RowSet&lt;/code&gt; object; may be &lt;code&gt;null&lt;/code&gt; but must not
 788      *     be an empty string
 789      * @throws SQLException if an error occurs setting the Url property or the
 790      *     parameter supplied is a string with a length of &lt;code&gt;0&lt;/code&gt; (an
 791      *     empty string)
 792      * @see #getUrl
 793      */
 794     public void setUrl(String url) throws SQLException {
 795         if(url == null) {
 796            url = null;
 797         } else if (url.length() &lt; 1) {
 798             throw new SQLException(&quot;Invalid url string detected. &quot; +
 799             &quot;Cannot be of length less than 1&quot;);
 800         } else {
 801             URL = url;
 802         }
 803 
 804         dataSource = null;
 805 
 806     }
 807 
 808     /**
 809      * Returns the logical name that when supplied to a naming service
 810      * that uses the Java Naming and Directory Interface (JNDI) API, will
 811      * retrieve a &lt;code&gt;javax.sql.DataSource&lt;/code&gt; object. This
 812      * &lt;code&gt;DataSource&lt;/code&gt; object can be used to establish a connection
 813      * to the data source that it represents.
 814      * &lt;P&gt;
 815      * Users should set either the url or the data source name property.
 816      * The driver will use the property set most recently to establish a
 817      * connection.
 818      *
 819      * @return a &lt;code&gt;String&lt;/code&gt; object that identifies the
 820      *         &lt;code&gt;DataSource&lt;/code&gt; object to be used for making a
 821      *         connection; if no logical name has been set, &lt;code&gt;null&lt;/code&gt;
 822      *         is returned.
 823      * @see #setDataSourceName
 824      */
 825     public String getDataSourceName() {
 826         return dataSource;
 827     }
 828 
 829 
 830     /**
 831      * Sets the &lt;code&gt;DataSource&lt;/code&gt; name property for this &lt;code&gt;RowSet&lt;/code&gt;
 832      * object to the given logical name and sets this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s
 833      * Url property to &lt;code&gt;null&lt;/code&gt;. The name must have been bound to a
 834      * &lt;code&gt;DataSource&lt;/code&gt; object in a JNDI naming service so that an
 835      * application can do a lookup using that name to retrieve the
 836      * &lt;code&gt;DataSource&lt;/code&gt; object bound to it. The &lt;code&gt;DataSource&lt;/code&gt;
 837      * object can then be used to establish a connection to the data source it
 838      * represents.
 839      * &lt;P&gt;
 840      * Users should set either the Url property or the dataSourceName property.
 841      * If both properties are set, the driver will use the property set most recently.
 842      *
 843      * @param name a &lt;code&gt;String&lt;/code&gt; object with the name that can be supplied
 844      *     to a naming service based on JNDI technology to retrieve the
 845      *     &lt;code&gt;DataSource&lt;/code&gt; object that can be used to get a connection;
 846      *     may be &lt;code&gt;null&lt;/code&gt; but must not be an empty string
 847      * @throws SQLException if an empty string is provided as the &lt;code&gt;DataSource&lt;/code&gt;
 848      *    name
 849      * @see #getDataSourceName
 850      */
 851     public void setDataSourceName(String name) throws SQLException {
 852 
 853         if (name == null) {
 854             dataSource = null;
 855         } else if (name.isEmpty()) {
 856            throw new SQLException(&quot;DataSource name cannot be empty string&quot;);
 857         } else {
 858            dataSource = name;
 859         }
 860 
 861         URL = null;
 862     }
 863 
 864     /**
 865      * Returns the user name used to create a database connection.  Because it
 866      * is not serialized, the username property is set at runtime before
 867      * calling the method &lt;code&gt;execute&lt;/code&gt;.
 868      *
 869      * @return the &lt;code&gt;String&lt;/code&gt; object containing the user name that
 870      *         is supplied to the data source to create a connection; may be
 871      *         &lt;code&gt;null&lt;/code&gt; (default value) if not set
 872      * @see #setUsername
 873      */
 874     public String getUsername() {
 875         return username;
 876     }
 877 
 878     /**
 879      * Sets the username property for this &lt;code&gt;RowSet&lt;/code&gt; object
 880      * to the given user name. Because it
 881      * is not serialized, the username property is set at run time before
 882      * calling the method &lt;code&gt;execute&lt;/code&gt;.
 883      *
 884      * @param name the &lt;code&gt;String&lt;/code&gt; object containing the user name that
 885      *     is supplied to the data source to create a connection. It may be null.
 886      * @see #getUsername
 887      */
 888     public void setUsername(String name) {
 889         if(name == null)
 890         {
 891            username = null;
 892         } else {
 893            username = name;
 894         }
 895     }
 896 
 897     /**
 898      * Returns the password used to create a database connection for this
 899      * &lt;code&gt;RowSet&lt;/code&gt; object.  Because the password property is not
 900      * serialized, it is set at run time before calling the method
 901      * &lt;code&gt;execute&lt;/code&gt;. The default value is &lt;code&gt;null&lt;/code&gt;
 902      *
 903      * @return the &lt;code&gt;String&lt;/code&gt; object that represents the password
 904      *         that must be supplied to the database to create a connection
 905      * @see #setPassword
 906      */
 907     public String getPassword() {
 908         return password;
 909     }
 910 
 911     /**
 912      * Sets the password used to create a database connection for this
 913      * &lt;code&gt;RowSet&lt;/code&gt; object to the given &lt;code&gt;String&lt;/code&gt;
 914      * object.  Because the password property is not
 915      * serialized, it is set at run time before calling the method
 916      * &lt;code&gt;execute&lt;/code&gt;.
 917      *
 918      * @param pass the &lt;code&gt;String&lt;/code&gt; object that represents the password
 919      *     that is supplied to the database to create a connection. It may be
 920      *     null.
 921      * @see #getPassword
 922      */
 923     public void setPassword(String pass) {
 924         if(pass == null)
 925         {
 926            password = null;
 927         } else {
 928            password = pass;
 929         }
 930     }
 931 
 932     /**
 933      * Sets the type for this &lt;code&gt;RowSet&lt;/code&gt; object to the specified type.
 934      * The default type is &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;.
 935      *
 936      * @param type one of the following constants:
 937      *             &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
 938      *             &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
 939      *             &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
 940      * @throws SQLException if the parameter supplied is not one of the
 941      *         following constants:
 942      *          &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; or
 943      *          &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;
 944      *          &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
 945      * @see #getConcurrency
 946      * @see #getType
 947      */
 948     public void setType(int type) throws SQLException {
 949 
 950         if ((type != ResultSet.TYPE_FORWARD_ONLY) &amp;&amp;
 951            (type != ResultSet.TYPE_SCROLL_INSENSITIVE) &amp;&amp;
 952            (type != ResultSet.TYPE_SCROLL_SENSITIVE)) {
 953                 throw new SQLException(&quot;Invalid type of RowSet set. Must be either &quot; +
 954                 &quot;ResultSet.TYPE_FORWARD_ONLY or ResultSet.TYPE_SCROLL_INSENSITIVE &quot; +
 955                 &quot;or ResultSet.TYPE_SCROLL_SENSITIVE.&quot;);
 956         }
 957         this.rowSetType = type;
 958     }
 959 
 960     /**
 961      * Returns the type of this &lt;code&gt;RowSet&lt;/code&gt; object. The type is initially
 962      * determined by the statement that created the &lt;code&gt;RowSet&lt;/code&gt; object.
 963      * The &lt;code&gt;RowSet&lt;/code&gt; object can call the method
 964      * &lt;code&gt;setType&lt;/code&gt; at any time to change its
 965      * type.  The default is &lt;code&gt;TYPE_SCROLL_INSENSITIVE&lt;/code&gt;.
 966      *
 967      * @return the type of this JDBC &lt;code&gt;RowSet&lt;/code&gt;
 968      *         object, which must be one of the following:
 969      *         &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
 970      *         &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
 971      *         &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
 972      * @throws SQLException if an error occurs getting the type of
 973      *     of this &lt;code&gt;RowSet&lt;/code&gt; object
 974      * @see #setType
 975      */
 976     public int getType() throws SQLException {
 977         return rowSetType;
 978     }
 979 
 980     /**
 981      * Sets the concurrency for this &lt;code&gt;RowSet&lt;/code&gt; object to
 982      * the specified concurrency. The default concurrency for any &lt;code&gt;RowSet&lt;/code&gt;
 983      * object (connected or disconnected) is &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;,
 984      * but this method may be called at any time to change the concurrency.
 985      *
 986      * @param concurrency one of the following constants:
 987      *                    &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
 988      *                    &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
 989      * @throws SQLException if the parameter supplied is not one of the
 990      *         following constants:
 991      *          &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt; or
 992      *          &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 993      * @see #getConcurrency
 994      * @see #isReadOnly
 995      */
 996     public void setConcurrency(int concurrency) throws SQLException {
 997 
 998         if((concurrency != ResultSet.CONCUR_READ_ONLY) &amp;&amp;
 999            (concurrency != ResultSet.CONCUR_UPDATABLE)) {
1000                 throw new SQLException(&quot;Invalid concurrency set. Must be either &quot; +
1001                 &quot;ResultSet.CONCUR_READ_ONLY or ResultSet.CONCUR_UPDATABLE.&quot;);
1002         }
1003         this.concurrency = concurrency;
1004     }
1005 
1006     /**
1007      * Returns a &lt;code&gt;boolean&lt;/code&gt; indicating whether this
1008      * &lt;code&gt;RowSet&lt;/code&gt; object is read-only.
1009      * Any attempts to update a read-only &lt;code&gt;RowSet&lt;/code&gt; object will result in an
1010      * &lt;code&gt;SQLException&lt;/code&gt; being thrown. By default,
1011      * rowsets are updatable if updates are possible.
1012      *
1013      * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;RowSet&lt;/code&gt; object
1014      *         cannot be updated; &lt;code&gt;false&lt;/code&gt; otherwise
1015      * @see #setConcurrency
1016      * @see #setReadOnly
1017      */
1018     public boolean isReadOnly() {
1019         return readOnly;
1020     };
1021 
1022     /**
1023      * Sets this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s readOnly  property to the given &lt;code&gt;boolean&lt;/code&gt;.
1024      *
1025      * @param value &lt;code&gt;true&lt;/code&gt; to indicate that this
1026      *              &lt;code&gt;RowSet&lt;/code&gt; object is read-only;
1027      *              &lt;code&gt;false&lt;/code&gt; to indicate that it is updatable
1028      */
1029     public void setReadOnly(boolean value) {
1030         readOnly = value;
1031     }
1032 
1033     /**
1034      * Returns the transaction isolation property for this
1035      * &lt;code&gt;RowSet&lt;/code&gt; object&#39;s connection. This property represents
1036      * the transaction isolation level requested for use in transactions.
1037      * &lt;P&gt;
1038      * For &lt;code&gt;RowSet&lt;/code&gt; implementations such as
1039      * the &lt;code&gt;CachedRowSet&lt;/code&gt; that operate in a disconnected environment,
1040      * the &lt;code&gt;SyncProvider&lt;/code&gt; object
1041      * offers complementary locking and data integrity options. The
1042      * options described below are pertinent only to connected &lt;code&gt;RowSet&lt;/code&gt;
1043      * objects (&lt;code&gt;JdbcRowSet&lt;/code&gt; objects).
1044      *
1045      * @return one of the following constants:
1046      *         &lt;code&gt;Connection.TRANSACTION_NONE&lt;/code&gt;,
1047      *         &lt;code&gt;Connection.TRANSACTION_READ_UNCOMMITTED&lt;/code&gt;,
1048      *         &lt;code&gt;Connection.TRANSACTION_READ_COMMITTED&lt;/code&gt;,
1049      *         &lt;code&gt;Connection.TRANSACTION_REPEATABLE_READ&lt;/code&gt;, or
1050      *         &lt;code&gt;Connection.TRANSACTION_SERIALIZABLE&lt;/code&gt;
1051      * @see javax.sql.rowset.spi.SyncFactory
1052      * @see javax.sql.rowset.spi.SyncProvider
1053      * @see #setTransactionIsolation
1054 
1055      */
1056     public int getTransactionIsolation() {
1057         return isolation;
1058     };
1059 
1060     /**
1061      * Sets the transaction isolation property for this JDBC &lt;code&gt;RowSet&lt;/code&gt; object to the given
1062      * constant. The DBMS will use this transaction isolation level for
1063      * transactions if it can.
1064      * &lt;p&gt;
1065      * For &lt;code&gt;RowSet&lt;/code&gt; implementations such as
1066      * the &lt;code&gt;CachedRowSet&lt;/code&gt; that operate in a disconnected environment,
1067      * the &lt;code&gt;SyncProvider&lt;/code&gt; object being used
1068      * offers complementary locking and data integrity options. The
1069      * options described below are pertinent only to connected &lt;code&gt;RowSet&lt;/code&gt;
1070      * objects (&lt;code&gt;JdbcRowSet&lt;/code&gt; objects).
1071      *
1072      * @param level one of the following constants, listed in ascending order:
1073      *              &lt;code&gt;Connection.TRANSACTION_NONE&lt;/code&gt;,
1074      *              &lt;code&gt;Connection.TRANSACTION_READ_UNCOMMITTED&lt;/code&gt;,
1075      *              &lt;code&gt;Connection.TRANSACTION_READ_COMMITTED&lt;/code&gt;,
1076      *              &lt;code&gt;Connection.TRANSACTION_REPEATABLE_READ&lt;/code&gt;, or
1077      *              &lt;code&gt;Connection.TRANSACTION_SERIALIZABLE&lt;/code&gt;
1078      * @throws SQLException if the given parameter is not one of the Connection
1079      *          constants
1080      * @see javax.sql.rowset.spi.SyncFactory
1081      * @see javax.sql.rowset.spi.SyncProvider
1082      * @see #getTransactionIsolation
1083      */
1084     public void setTransactionIsolation(int level) throws SQLException {
1085         if ((level != Connection.TRANSACTION_NONE) &amp;&amp;
1086            (level != Connection.TRANSACTION_READ_COMMITTED) &amp;&amp;
1087            (level != Connection.TRANSACTION_READ_UNCOMMITTED) &amp;&amp;
1088            (level != Connection.TRANSACTION_REPEATABLE_READ) &amp;&amp;
1089            (level != Connection.TRANSACTION_SERIALIZABLE))
1090             {
1091                 throw new SQLException(&quot;Invalid transaction isolation set. Must &quot; +
1092                 &quot;be either &quot; +
1093                 &quot;Connection.TRANSACTION_NONE or &quot; +
1094                 &quot;Connection.TRANSACTION_READ_UNCOMMITTED or &quot; +
1095                 &quot;Connection.TRANSACTION_READ_COMMITTED or &quot; +
1096                 &quot;Connection.TRANSACTION_REPEATABLE_READ or &quot; +
1097                 &quot;Connection.TRANSACTION_SERIALIZABLE&quot;);
1098             }
1099         this.isolation = level;
1100     }
1101 
1102     /**
1103      * Retrieves the type map associated with the &lt;code&gt;Connection&lt;/code&gt;
1104      * object for this &lt;code&gt;RowSet&lt;/code&gt; object.
1105      * &lt;P&gt;
1106      * Drivers that support the JDBC 3.0 API will create
1107      * &lt;code&gt;Connection&lt;/code&gt; objects with an associated type map.
1108      * This type map, which is initially empty, can contain one or more
1109      * fully-qualified SQL names and &lt;code&gt;Class&lt;/code&gt; objects indicating
1110      * the class to which the named SQL value will be mapped. The type mapping
1111      * specified in the connection&#39;s type map is used for custom type mapping
1112      * when no other type map supersedes it.
1113      * &lt;p&gt;
1114      * If a type map is explicitly supplied to a method that can perform
1115      * custom mapping, that type map supersedes the connection&#39;s type map.
1116      *
1117      * @return the &lt;code&gt;java.util.Map&lt;/code&gt; object that is the type map
1118      *         for this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s connection
1119      */
1120     public java.util.Map&lt;String,Class&lt;?&gt;&gt; getTypeMap() {
1121         return map;
1122     }
1123 
1124     /**
1125      * Installs the given &lt;code&gt;java.util.Map&lt;/code&gt; object as the type map
1126      * associated with the &lt;code&gt;Connection&lt;/code&gt; object for this
1127      * &lt;code&gt;RowSet&lt;/code&gt; object.  The custom mapping indicated in
1128      * this type map will be used unless a different type map is explicitly
1129      * supplied to a method, in which case the type map supplied will be used.
1130      *
1131      * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object that contains the
1132      *     mapping from SQL type names for user defined types (UDT) to classes in
1133      *     the Java programming language.  Each entry in the &lt;code&gt;Map&lt;/code&gt;
1134      *     object consists of the fully qualified SQL name of a UDT and the
1135      *     &lt;code&gt;Class&lt;/code&gt; object for the &lt;code&gt;SQLData&lt;/code&gt; implementation
1136      *     of that UDT. May be &lt;code&gt;null&lt;/code&gt;.
1137      */
1138     public void setTypeMap(java.util.Map&lt;String,Class&lt;?&gt;&gt; map) {
1139         this.map = map;
1140     }
1141 
1142     /**
1143      * Retrieves the maximum number of bytes that can be used for a column
1144      * value in this &lt;code&gt;RowSet&lt;/code&gt; object.
1145      * This limit applies only to columns that hold values of the
1146      * following types:  &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;,
1147      * &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;,
1148      * and &lt;code&gt;LONGVARCHAR&lt;/code&gt;.  If the limit is exceeded, the excess
1149      * data is silently discarded.
1150      *
1151      * @return an &lt;code&gt;int&lt;/code&gt; indicating the current maximum column size
1152      *     limit; zero means that there is no limit
1153      * @throws SQLException if an error occurs internally determining the
1154      *    maximum limit of the column size
1155      */
1156     public int getMaxFieldSize() throws SQLException {
1157         return maxFieldSize;
1158     }
1159 
1160     /**
1161      * Sets the maximum number of bytes that can be used for a column
1162      * value in this &lt;code&gt;RowSet&lt;/code&gt; object to the given number.
1163      * This limit applies only to columns that hold values of the
1164      * following types:  &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;,
1165      * &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;,
1166      * and &lt;code&gt;LONGVARCHAR&lt;/code&gt;.  If the limit is exceeded, the excess
1167      * data is silently discarded. For maximum portability, it is advisable to
1168      * use values greater than 256.
1169      *
1170      * @param max an &lt;code&gt;int&lt;/code&gt; indicating the new maximum column size
1171      *     limit; zero means that there is no limit
1172      * @throws SQLException if (1) an error occurs internally setting the
1173      *     maximum limit of the column size or (2) a size of less than 0 is set
1174      */
1175     public void setMaxFieldSize(int max) throws SQLException {
1176         if (max &lt; 0) {
1177             throw new SQLException(&quot;Invalid max field size set. Cannot be of &quot; +
1178             &quot;value: &quot; + max);
1179         }
1180         maxFieldSize = max;
1181     }
1182 
1183     /**
1184      * Retrieves the maximum number of rows that this &lt;code&gt;RowSet&lt;/code&gt; object may contain. If
1185      * this limit is exceeded, the excess rows are silently dropped.
1186      *
1187      * @return an &lt;code&gt;int&lt;/code&gt; indicating the current maximum number of
1188      *     rows; zero means that there is no limit
1189      * @throws SQLException if an error occurs internally determining the
1190      *     maximum limit of rows that a &lt;code&gt;Rowset&lt;/code&gt; object can contain
1191      */
1192     public int getMaxRows() throws SQLException {
1193         return maxRows;
1194     }
1195 
1196     /**
1197      * Sets the maximum number of rows that this &lt;code&gt;RowSet&lt;/code&gt; object may contain to
1198      * the given number. If this limit is exceeded, the excess rows are
1199      * silently dropped.
1200      *
1201      * @param max an &lt;code&gt;int&lt;/code&gt; indicating the current maximum number
1202      *     of rows; zero means that there is no limit
1203      * @throws SQLException if an error occurs internally setting the
1204      *     maximum limit on the number of rows that a JDBC &lt;code&gt;RowSet&lt;/code&gt; object
1205      *     can contain; or if &lt;i&gt;max&lt;/i&gt; is less than &lt;code&gt;0&lt;/code&gt;; or
1206      *     if &lt;i&gt;max&lt;/i&gt; is less than the &lt;code&gt;fetchSize&lt;/code&gt; of the
1207      *     &lt;code&gt;RowSet&lt;/code&gt;
1208      */
1209     public void setMaxRows(int max) throws SQLException {
1210         if (max &lt; 0) {
1211             throw new SQLException(&quot;Invalid max row size set. Cannot be of &quot; +
1212                 &quot;value: &quot; + max);
1213         } else if (max &lt; this.getFetchSize()) {
1214             throw new SQLException(&quot;Invalid max row size set. Cannot be less &quot; +
1215                 &quot;than the fetchSize.&quot;);
1216         }
1217         this.maxRows = max;
1218     }
1219 
1220     /**
1221      * Sets to the given &lt;code&gt;boolean&lt;/code&gt; whether or not the driver will
1222      * scan for escape syntax and do escape substitution before sending SQL
1223      * statements to the database. The default is for the driver to do escape
1224      * processing.
1225      * &lt;P&gt;
1226      * Note: Since &lt;code&gt;PreparedStatement&lt;/code&gt; objects have usually been
1227      * parsed prior to making this call, disabling escape processing for
1228      * prepared statements will likely have no effect.
1229      *
1230      * @param enable &lt;code&gt;true&lt;/code&gt; to enable escape processing;
1231      *     &lt;code&gt;false&lt;/code&gt; to disable it
1232      * @throws SQLException if an error occurs setting the underlying JDBC
1233      * technology-enabled driver to process the escape syntax
1234      */
1235     public void setEscapeProcessing(boolean enable) throws SQLException {
1236         escapeProcessing = enable;
1237     }
1238 
1239     /**
1240      * Retrieves the maximum number of seconds the driver will wait for a
1241      * query to execute. If the limit is exceeded, an &lt;code&gt;SQLException&lt;/code&gt;
1242      * is thrown.
1243      *
1244      * @return the current query timeout limit in seconds; zero means that
1245      *     there is no limit
1246      * @throws SQLException if an error occurs in determining the query
1247      *     time-out value
1248      */
1249     public int getQueryTimeout() throws SQLException {
1250         return queryTimeout;
1251     }
1252 
1253     /**
1254      * Sets to the given number the maximum number of seconds the driver will
1255      * wait for a query to execute. If the limit is exceeded, an
1256      * &lt;code&gt;SQLException&lt;/code&gt; is thrown.
1257      *
1258      * @param seconds the new query time-out limit in seconds; zero means that
1259      *     there is no limit; must not be less than zero
1260      * @throws SQLException if an error occurs setting the query
1261      *     time-out or if the query time-out value is less than 0
1262      */
1263     public void setQueryTimeout(int seconds) throws SQLException {
1264         if (seconds &lt; 0) {
1265             throw new SQLException(&quot;Invalid query timeout value set. Cannot be &quot; +
1266             &quot;of value: &quot; + seconds);
1267         }
1268         this.queryTimeout = seconds;
1269     }
1270 
1271     /**
1272      * Retrieves a &lt;code&gt;boolean&lt;/code&gt; indicating whether rows marked
1273      * for deletion appear in the set of current rows.
1274      * The default value is &lt;code&gt;false&lt;/code&gt;.
1275      * &lt;P&gt;
1276      * Note: Allowing deleted rows to remain visible complicates the behavior
1277      * of some of the methods.  However, most &lt;code&gt;RowSet&lt;/code&gt; object users
1278      * can simply ignore this extra detail because only sophisticated
1279      * applications will likely want to take advantage of this feature.
1280      *
1281      * @return &lt;code&gt;true&lt;/code&gt; if deleted rows are visible;
1282      *         &lt;code&gt;false&lt;/code&gt; otherwise
1283      * @throws SQLException if an error occurs determining if deleted rows
1284      * are visible or not
1285      * @see #setShowDeleted
1286      */
1287     public boolean getShowDeleted() throws SQLException {
1288         return showDeleted;
1289     }
1290 
1291     /**
1292      * Sets the property &lt;code&gt;showDeleted&lt;/code&gt; to the given
1293      * &lt;code&gt;boolean&lt;/code&gt; value, which determines whether
1294      * rows marked for deletion appear in the set of current rows.
1295      *
1296      * @param value &lt;code&gt;true&lt;/code&gt; if deleted rows should be shown;
1297      *     &lt;code&gt;false&lt;/code&gt; otherwise
1298      * @throws SQLException if an error occurs setting whether deleted
1299      *     rows are visible or not
1300      * @see #getShowDeleted
1301      */
1302     public void setShowDeleted(boolean value) throws SQLException {
1303         showDeleted = value;
1304     }
1305 
1306     /**
1307      * Ascertains whether escape processing is enabled for this
1308      * &lt;code&gt;RowSet&lt;/code&gt; object.
1309      *
1310      * @return &lt;code&gt;true&lt;/code&gt; if escape processing is turned on;
1311      *         &lt;code&gt;false&lt;/code&gt; otherwise
1312      * @throws SQLException if an error occurs determining if escape
1313      *     processing is enabled or not or if the internal escape
1314      *     processing trigger has not been enabled
1315      */
1316     public boolean getEscapeProcessing() throws SQLException {
1317         return escapeProcessing;
1318     }
1319 
1320     /**
1321      * Gives the driver a performance hint as to the direction in
1322      * which the rows in this &lt;code&gt;RowSet&lt;/code&gt; object will be
1323      * processed.  The driver may ignore this hint.
1324      * &lt;P&gt;
1325      * A &lt;code&gt;RowSet&lt;/code&gt; object inherits the default properties of the
1326      * &lt;code&gt;ResultSet&lt;/code&gt; object from which it got its data.  That
1327      * &lt;code&gt;ResultSet&lt;/code&gt; object&#39;s default fetch direction is set by
1328      * the &lt;code&gt;Statement&lt;/code&gt; object that created it.
1329      * &lt;P&gt;
1330      * This method applies to a &lt;code&gt;RowSet&lt;/code&gt; object only while it is
1331      * connected to a database using a JDBC driver.
1332      * &lt;p&gt;
1333      * A &lt;code&gt;RowSet&lt;/code&gt; object may use this method at any time to change
1334      * its setting for the fetch direction.
1335      *
1336      * @param direction one of &lt;code&gt;ResultSet.FETCH_FORWARD&lt;/code&gt;,
1337      *                  &lt;code&gt;ResultSet.FETCH_REVERSE&lt;/code&gt;, or
1338      *                  &lt;code&gt;ResultSet.FETCH_UNKNOWN&lt;/code&gt;
1339      * @throws SQLException if (1) the &lt;code&gt;RowSet&lt;/code&gt; type is
1340      *     &lt;code&gt;TYPE_FORWARD_ONLY&lt;/code&gt; and the given fetch direction is not
1341      *     &lt;code&gt;FETCH_FORWARD&lt;/code&gt; or (2) the given fetch direction is not
1342      *     one of the following:
1343      *        ResultSet.FETCH_FORWARD,
1344      *        ResultSet.FETCH_REVERSE, or
1345      *        ResultSet.FETCH_UNKNOWN
1346      * @see #getFetchDirection
1347      */
1348     public void setFetchDirection(int direction) throws SQLException {
1349         // Changed the condition checking to the below as there were two
1350         // conditions that had to be checked
1351         // 1. RowSet is TYPE_FORWARD_ONLY and direction is not FETCH_FORWARD
1352         // 2. Direction is not one of the valid values
1353 
1354         if (((getType() == ResultSet.TYPE_FORWARD_ONLY) &amp;&amp; (direction != ResultSet.FETCH_FORWARD)) ||
1355             ((direction != ResultSet.FETCH_FORWARD) &amp;&amp;
1356             (direction != ResultSet.FETCH_REVERSE) &amp;&amp;
1357             (direction != ResultSet.FETCH_UNKNOWN))) {
1358             throw new SQLException(&quot;Invalid Fetch Direction&quot;);
1359         }
1360         fetchDir = direction;
1361     }
1362 
1363     /**
1364      * Retrieves this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s current setting for the
1365      * fetch direction. The default type is &lt;code&gt;ResultSet.FETCH_FORWARD&lt;/code&gt;
1366      *
1367      * @return one of &lt;code&gt;ResultSet.FETCH_FORWARD&lt;/code&gt;,
1368      *                  &lt;code&gt;ResultSet.FETCH_REVERSE&lt;/code&gt;, or
1369      *                  &lt;code&gt;ResultSet.FETCH_UNKNOWN&lt;/code&gt;
1370      * @throws SQLException if an error occurs in determining the
1371      *     current fetch direction for fetching rows
1372      * @see #setFetchDirection
1373      */
1374     public int getFetchDirection() throws SQLException {
1375 
1376         //Added the following code to throw a
1377         //SQL Exception if the fetchDir is not
1378         //set properly.Bug id:4914155
1379 
1380         // This checking is not necessary!
1381 
1382         /*
1383          if((fetchDir != ResultSet.FETCH_FORWARD) &amp;&amp;
1384            (fetchDir != ResultSet.FETCH_REVERSE) &amp;&amp;
1385            (fetchDir != ResultSet.FETCH_UNKNOWN)) {
1386             throw new SQLException(&quot;Fetch Direction Invalid&quot;);
1387          }
1388          */
1389         return (fetchDir);
1390     }
1391 
1392     /**
1393      * Sets the fetch size for this &lt;code&gt;RowSet&lt;/code&gt; object to the given number of
1394      * rows.  The fetch size gives a JDBC technology-enabled driver (&quot;JDBC driver&quot;)
1395      * a hint as to the
1396      * number of rows that should be fetched from the database when more rows
1397      * are needed for this &lt;code&gt;RowSet&lt;/code&gt; object. If the fetch size specified
1398      * is zero, the driver ignores the value and is free to make its own best guess
1399      * as to what the fetch size should be.
1400      * &lt;P&gt;
1401      * A &lt;code&gt;RowSet&lt;/code&gt; object inherits the default properties of the
1402      * &lt;code&gt;ResultSet&lt;/code&gt; object from which it got its data.  That
1403      * &lt;code&gt;ResultSet&lt;/code&gt; object&#39;s default fetch size is set by
1404      * the &lt;code&gt;Statement&lt;/code&gt; object that created it.
1405      * &lt;P&gt;
1406      * This method applies to a &lt;code&gt;RowSet&lt;/code&gt; object only while it is
1407      * connected to a database using a JDBC driver.
1408      * For connected &lt;code&gt;RowSet&lt;/code&gt; implementations such as
1409      * &lt;code&gt;JdbcRowSet&lt;/code&gt;, this method has a direct and immediate effect
1410      * on the underlying JDBC driver.
1411      * &lt;P&gt;
1412      * A &lt;code&gt;RowSet&lt;/code&gt; object may use this method at any time to change
1413      * its setting for the fetch size.
1414      * &lt;p&gt;
1415      * For &lt;code&gt;RowSet&lt;/code&gt; implementations such as
1416      * &lt;code&gt;CachedRowSet&lt;/code&gt;, which operate in a disconnected environment,
1417      * the &lt;code&gt;SyncProvider&lt;/code&gt; object being used
1418      * may leverage the fetch size to poll the data source and
1419      * retrieve a number of rows that do not exceed the fetch size and that may
1420      * form a subset of the actual rows returned by the original query. This is
1421      * an implementation variance determined by the specific &lt;code&gt;SyncProvider&lt;/code&gt;
1422      * object employed by the disconnected &lt;code&gt;RowSet&lt;/code&gt; object.
1423      *
1424      * @param rows the number of rows to fetch; &lt;code&gt;0&lt;/code&gt; to let the
1425      *        driver decide what the best fetch size is; must not be less
1426      *        than &lt;code&gt;0&lt;/code&gt; or more than the maximum number of rows
1427      *        allowed for this &lt;code&gt;RowSet&lt;/code&gt; object (the number returned
1428      *        by a call to the method {@link #getMaxRows})
1429      * @throws SQLException if the specified fetch size is less than &lt;code&gt;0&lt;/code&gt;
1430      *        or more than the limit for the maximum number of rows
1431      * @see #getFetchSize
1432      */
1433     public void setFetchSize(int rows) throws SQLException {
1434         //Added this checking as maxRows can be 0 when this function is called
1435         //maxRows = 0 means rowset can hold any number of rows, os this checking
1436         // is needed to take care of this condition.
1437         if (getMaxRows() == 0 &amp;&amp; rows &gt;= 0)  {
1438             fetchSize = rows;
1439             return;
1440         }
1441         if ((rows &lt; 0) || (rows &gt; getMaxRows())) {
1442             throw new SQLException(&quot;Invalid fetch size set. Cannot be of &quot; +
1443             &quot;value: &quot; + rows);
1444         }
1445         fetchSize = rows;
1446     }
1447 
1448     /**
1449      * Returns the fetch size for this &lt;code&gt;RowSet&lt;/code&gt; object. The default
1450      * value is zero.
1451      *
1452      * @return the number of rows suggested as the fetch size when this &lt;code&gt;RowSet&lt;/code&gt; object
1453      *     needs more rows from the database
1454      * @throws SQLException if an error occurs determining the number of rows in the
1455      *     current fetch size
1456      * @see #setFetchSize
1457      */
1458     public int getFetchSize() throws SQLException {
1459         return fetchSize;
1460     }
1461 
1462     /**
1463      * Returns the concurrency for this &lt;code&gt;RowSet&lt;/code&gt; object.
1464      * The default is &lt;code&gt;CONCUR_UPDATABLE&lt;/code&gt; for both connected and
1465      * disconnected &lt;code&gt;RowSet&lt;/code&gt; objects.
1466      * &lt;P&gt;
1467      * An application can call the method &lt;code&gt;setConcurrency&lt;/code&gt; at any time
1468      * to change a &lt;code&gt;RowSet&lt;/code&gt; object&#39;s concurrency.
1469      *
1470      * @return the concurrency type for this &lt;code&gt;RowSet&lt;/code&gt;
1471      *     object, which must be one of the following:
1472      *     &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
1473      *     &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
1474      * @throws SQLException if an error occurs getting the concurrency
1475      *     of this &lt;code&gt;RowSet&lt;/code&gt; object
1476      * @see #setConcurrency
1477      * @see #isReadOnly
1478      */
1479     public int getConcurrency() throws SQLException {
1480         return concurrency;
1481     }
1482 
1483     //-----------------------------------------------------------------------
1484     // Parameters
1485     //-----------------------------------------------------------------------
1486 
1487     /**
1488      * Checks the given index to see whether it is less than &lt;code&gt;1&lt;/code&gt; and
1489      * throws an &lt;code&gt;SQLException&lt;/code&gt; object if it is.
1490      * &lt;P&gt;
1491      * This method is called by many methods internally; it is never
1492      * called by an application directly.
1493      *
1494      * @param idx an &lt;code&gt;int&lt;/code&gt; indicating which parameter is to be
1495      *     checked; the first parameter is &lt;code&gt;1&lt;/code&gt;
1496      * @throws SQLException if the parameter is less than &lt;code&gt;1&lt;/code&gt;
1497      */
1498     private void checkParamIndex(int idx) throws SQLException {
1499         if ((idx &lt; 1)) {
1500             throw new SQLException(&quot;Invalid Parameter Index&quot;);
1501         }
1502     }
1503 
1504     //---------------------------------------------------------------------
1505     // setter methods for setting the parameters in a &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
1506     //---------------------------------------------------------------------
1507 
1508     /**
1509      * Sets the designated parameter to SQL &lt;code&gt;NULL&lt;/code&gt;.
1510      * Note that the parameter&#39;s SQL type must be specified using one of the
1511          * type codes defined in &lt;code&gt;java.sql.Types&lt;/code&gt;.  This SQL type is
1512      * specified in the second parameter.
1513      * &lt;p&gt;
1514      * Note that the second parameter tells the DBMS the data type of the value being
1515      * set to &lt;code&gt;NULL&lt;/code&gt;. Some DBMSs require this information, so it is required
1516      * in order to make code more portable.
1517      * &lt;P&gt;
1518      * The parameter value set by this method is stored internally and
1519      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1520      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1521      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1522      * provided in any class that extends this class and implements one or
1523      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1524      * &lt;P&gt;
1525      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1526      * as it is undefined in this class.
1527      * &lt;P&gt;
1528      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
1529      * &lt;code&gt;setNull&lt;/code&gt;
1530      * has been called will return an &lt;code&gt;Object&lt;/code&gt; array containing the parameter values that
1531      * have been set.  In that array, the element that represents the values
1532      * set with this method will itself be an array. The first element of that array
1533      * is &lt;code&gt;null&lt;/code&gt;.
1534      * The second element is the value set for &lt;i&gt;sqlType&lt;/i&gt;.
1535      * The parameter number is indicated by an element&#39;s position in the array
1536      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
1537      * with the first element being the value for the first placeholder parameter, the
1538      * second element being the value for the second placeholder parameter, and so on.
1539      * In other words, if the second placeholder parameter is being set to
1540      * &lt;code&gt;null&lt;/code&gt;, the array containing it will be the second element in
1541      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
1542      * &lt;P&gt;
1543      * Note that because the numbering of elements in an array starts at zero,
1544      * the array element that corresponds to placeholder parameter number
1545      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
1546      *
1547      * @param parameterIndex the ordinal number of the placeholder parameter
1548      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1549      *        The first parameter is 1, the second is 2, and so on; must be
1550      *        &lt;code&gt;1&lt;/code&gt; or greater
1551      * @param sqlType an &lt;code&gt;int&lt;/code&gt; that is one of the SQL type codes
1552      *        defined in the class {@link java.sql.Types}. If a non-standard
1553      *        &lt;i&gt;sqlType&lt;/i&gt; is supplied, this method will not throw a
1554      *        &lt;code&gt;SQLException&lt;/code&gt;. This allows implicit support for
1555      *        non-standard SQL types.
1556      * @throws SQLException if a database access error occurs or the given
1557      *        parameter index is out of bounds
1558      * @see #getParams
1559      */
1560     public void setNull(int parameterIndex, int sqlType) throws SQLException {
1561         Object nullVal[];
1562         checkParamIndex(parameterIndex);
1563 
1564         nullVal = new Object[2];
1565         nullVal[0] = null;
1566         nullVal[1] = Integer.valueOf(sqlType);
1567 
1568        if (params == null){
1569             throw new SQLException(&quot;Set initParams() before setNull&quot;);
1570        }
1571 
1572         params.put(Integer.valueOf(parameterIndex - 1), nullVal);
1573     }
1574 
1575     /**
1576      * Sets the designated parameter to SQL &lt;code&gt;NULL&lt;/code&gt;.
1577      *
1578      * Although this version of the  method &lt;code&gt;setNull&lt;/code&gt; is intended
1579      * for user-defined
1580      * and &lt;code&gt;REF&lt;/code&gt; parameters, this method may be used to set a null
1581      * parameter for any JDBC type. The following are user-defined types:
1582      * &lt;code&gt;STRUCT&lt;/code&gt;, &lt;code&gt;DISTINCT&lt;/code&gt;, and &lt;code&gt;JAVA_OBJECT&lt;/code&gt;,
1583      * and named array types.
1584      *
1585      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; To be portable, applications must give the
1586      * SQL type code and the fully qualified SQL type name when specifying
1587      * a &lt;code&gt;NULL&lt;/code&gt; user-defined or &lt;code&gt;REF&lt;/code&gt; parameter.
1588      * In the case of a user-defined type, the name is the type name of
1589      * the parameter itself.  For a &lt;code&gt;REF&lt;/code&gt; parameter, the name is
1590      * the type name of the referenced type.  If a JDBC technology-enabled
1591      * driver does not need the type code or type name information,
1592      * it may ignore it.
1593      * &lt;P&gt;
1594      * If the parameter does not have a user-defined or &lt;code&gt;REF&lt;/code&gt; type,
1595      * the given &lt;code&gt;typeName&lt;/code&gt; parameter is ignored.
1596      * &lt;P&gt;
1597      * The parameter value set by this method is stored internally and
1598      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1599      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1600      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1601      * provided in any class that extends this class and implements one or
1602      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1603      * &lt;P&gt;
1604      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1605      * as it is undefined in this class.
1606      * &lt;P&gt;
1607      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
1608      * &lt;code&gt;setNull&lt;/code&gt;
1609      * has been called will return an &lt;code&gt;Object&lt;/code&gt; array containing the parameter values that
1610      * have been set.  In that array, the element that represents the values
1611      * set with this method will itself be an array. The first element of that array
1612      * is &lt;code&gt;null&lt;/code&gt;.
1613      * The second element is the value set for &lt;i&gt;sqlType&lt;/i&gt;, and the third
1614      * element is the value set for &lt;i&gt;typeName&lt;/i&gt;.
1615      * The parameter number is indicated by an element&#39;s position in the array
1616      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
1617      * with the first element being the value for the first placeholder parameter, the
1618      * second element being the value for the second placeholder parameter, and so on.
1619      * In other words, if the second placeholder parameter is being set to
1620      * &lt;code&gt;null&lt;/code&gt;, the array containing it will be the second element in
1621      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
1622      * &lt;P&gt;
1623      * Note that because the numbering of elements in an array starts at zero,
1624      * the array element that corresponds to placeholder parameter number
1625      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
1626      *
1627      * @param parameterIndex the ordinal number of the placeholder parameter
1628      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1629      *        The first parameter is 1, the second is 2, and so on; must be
1630      *        &lt;code&gt;1&lt;/code&gt; or greater
1631      * @param sqlType a value from &lt;code&gt;java.sql.Types&lt;/code&gt;
1632      * @param typeName the fully qualified name of an SQL user-defined type,
1633      *                 which is ignored if the parameter is not a user-defined
1634      *                 type or &lt;code&gt;REF&lt;/code&gt; value
1635      * @throws SQLException if an error occurs or the given parameter index
1636      *            is out of bounds
1637      * @see #getParams
1638      */
1639     public void setNull(int parameterIndex, int sqlType, String typeName)
1640         throws SQLException {
1641 
1642         Object nullVal[];
1643         checkParamIndex(parameterIndex);
1644 
1645         nullVal = new Object[3];
1646         nullVal[0] = null;
1647         nullVal[1] = Integer.valueOf(sqlType);
1648         nullVal[2] = typeName;
1649 
1650        if(params == null){
1651             throw new SQLException(&quot;Set initParams() before setNull&quot;);
1652        }
1653 
1654         params.put(Integer.valueOf(parameterIndex - 1), nullVal);
1655     }
1656 
1657 
1658     /**
1659      * Sets the designated parameter to the given &lt;code&gt;boolean&lt;/code&gt; in the
1660      * Java programming language.  The driver converts this to an SQL
1661      * &lt;code&gt;BIT&lt;/code&gt; value when it sends it to the database.
1662      * &lt;P&gt;
1663      * The parameter value set by this method is stored internally and
1664      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1665      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1666      * Methods such as &lt;code&gt;execute&lt;/code&gt;, &lt;code&gt;populate&lt;/code&gt; must be
1667      * provided in any class that extends this class and implements one or
1668      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1669      * &lt;p&gt;
1670      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1671      * as it is undefined in this class.
1672      *
1673      * @param parameterIndex the ordinal number of the placeholder parameter
1674      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1675      *        The first parameter is 1, the second is 2, and so on; must be
1676      *        &lt;code&gt;1&lt;/code&gt; or greater
1677      * @param x the parameter value
1678      * @throws SQLException if an error occurs or the
1679      *                         parameter index is out of bounds
1680      * @see #getParams
1681      */
1682     public void setBoolean(int parameterIndex, boolean x) throws SQLException {
1683         checkParamIndex(parameterIndex);
1684 
1685        if(params == null){
1686             throw new SQLException(&quot;Set initParams() before setNull&quot;);
1687        }
1688 
1689         params.put(Integer.valueOf(parameterIndex - 1), Boolean.valueOf(x));
1690     }
1691 
1692     /**
1693      * Sets the designated parameter to the given &lt;code&gt;byte&lt;/code&gt; in the Java
1694      * programming language.  The driver converts this to an SQL
1695      * &lt;code&gt;TINYINT&lt;/code&gt; value when it sends it to the database.
1696      * &lt;P&gt;
1697      * The parameter value set by this method is stored internally and
1698      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1699      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1700      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1701      * provided in any class that extends this class and implements one or
1702      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1703      * &lt;p&gt;
1704      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1705      * as it is undefined in this class.
1706      *
1707      * @param parameterIndex the ordinal number of the placeholder parameter
1708      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1709      *        The first parameter is 1, the second is 2, and so on; must be
1710      *        &lt;code&gt;1&lt;/code&gt; or greater
1711      * @param x the parameter value
1712      * @throws SQLException if an error occurs or the
1713      *                         parameter index is out of bounds
1714      * @see #getParams
1715      */
1716     public void setByte(int parameterIndex, byte x) throws SQLException {
1717         checkParamIndex(parameterIndex);
1718 
1719        if(params == null){
1720             throw new SQLException(&quot;Set initParams() before setByte&quot;);
1721        }
1722 
1723         params.put(Integer.valueOf(parameterIndex - 1), Byte.valueOf(x));
1724     }
1725 
1726     /**
1727      * Sets the designated parameter to the given &lt;code&gt;short&lt;/code&gt; in the
1728      * Java programming language.  The driver converts this to an SQL
1729      * &lt;code&gt;SMALLINT&lt;/code&gt; value when it sends it to the database.
1730      * &lt;P&gt;
1731      * The parameter value set by this method is stored internally and
1732      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1733      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1734      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1735      * provided in any class that extends this class and implements one or
1736      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1737      * &lt;p&gt;
1738      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1739      * as it is undefined in this class.
1740      *
1741      * @param parameterIndex the ordinal number of the placeholder parameter
1742      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1743      *        The first parameter is 1, the second is 2, and so on; must be
1744      *        &lt;code&gt;1&lt;/code&gt; or greater
1745      * @param x the parameter value
1746      * @throws SQLException if an error occurs or the
1747      *                         parameter index is out of bounds
1748      * @see #getParams
1749      */
1750     public void setShort(int parameterIndex, short x) throws SQLException {
1751         checkParamIndex(parameterIndex);
1752 
1753         if(params == null){
1754              throw new SQLException(&quot;Set initParams() before setShort&quot;);
1755         }
1756 
1757         params.put(Integer.valueOf(parameterIndex - 1), Short.valueOf(x));
1758     }
1759 
1760     /**
1761      * Sets the designated parameter to an &lt;code&gt;int&lt;/code&gt; in the Java
1762      * programming language.  The driver converts this to an SQL
1763      * &lt;code&gt;INTEGER&lt;/code&gt; value when it sends it to the database.
1764      * &lt;P&gt;
1765      * The parameter value set by this method is stored internally and
1766      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1767      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1768      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1769      * provided in any class that extends this class and implements one or
1770      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1771      * &lt;P&gt;
1772      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1773      * as it is undefined in this class.
1774      *
1775      * @param parameterIndex the ordinal number of the placeholder parameter
1776      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1777      *        The first parameter is 1, the second is 2, and so on; must be
1778      *        &lt;code&gt;1&lt;/code&gt; or greater
1779      * @param x the parameter value
1780      * @throws SQLException if an error occurs or the
1781      *                         parameter index is out of bounds
1782      * @see #getParams
1783      */
1784     public void setInt(int parameterIndex, int x) throws SQLException {
1785         checkParamIndex(parameterIndex);
1786         if(params == null){
1787              throw new SQLException(&quot;Set initParams() before setInt&quot;);
1788         }
1789         params.put(Integer.valueOf(parameterIndex - 1), Integer.valueOf(x));
1790     }
1791 
1792     /**
1793      * Sets the designated parameter to the given &lt;code&gt;long&lt;/code&gt; in the Java
1794      * programming language.  The driver converts this to an SQL
1795      * &lt;code&gt;BIGINT&lt;/code&gt; value when it sends it to the database.
1796      * &lt;P&gt;
1797      * The parameter value set by this method is stored internally and
1798      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1799      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1800      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1801      * provided in any class that extends this class and implements one or
1802      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1803      * &lt;P&gt;
1804      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1805      * as it is undefined in this class.
1806      *
1807      * @param parameterIndex the ordinal number of the placeholder parameter
1808      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1809      *        The first parameter is 1, the second is 2, and so on; must be
1810      *        &lt;code&gt;1&lt;/code&gt; or greater
1811      * @param x the parameter value
1812      * @throws SQLException if an error occurs or the
1813      *                         parameter index is out of bounds
1814      * @see #getParams
1815      */
1816     public void setLong(int parameterIndex, long x) throws SQLException {
1817         checkParamIndex(parameterIndex);
1818         if(params == null){
1819              throw new SQLException(&quot;Set initParams() before setLong&quot;);
1820         }
1821         params.put(Integer.valueOf(parameterIndex - 1), Long.valueOf(x));
1822     }
1823 
1824     /**
1825      * Sets the designated parameter to the given &lt;code&gt;float&lt;/code&gt; in the
1826      * Java programming language.  The driver converts this to an SQL
1827      * &lt;code&gt;FLOAT&lt;/code&gt; value when it sends it to the database.
1828      * &lt;P&gt;
1829      * The parameter value set by this method is stored internally and
1830      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1831      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1832      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1833      * provided in any class that extends this class and implements one or
1834      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1835      * &lt;P&gt;
1836      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1837      * as it is undefined in this class.
1838      *
1839      * @param parameterIndex the ordinal number of the placeholder parameter
1840      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1841      *        The first parameter is 1, the second is 2, and so on; must be
1842      *        &lt;code&gt;1&lt;/code&gt; or greater
1843      * @param x the parameter value
1844      * @throws SQLException if an error occurs or the
1845      *                         parameter index is out of bounds
1846      * @see #getParams
1847      */
1848     public void setFloat(int parameterIndex, float x) throws SQLException {
1849         checkParamIndex(parameterIndex);
1850         if(params == null){
1851              throw new SQLException(&quot;Set initParams() before setFloat&quot;);
1852         }
1853         params.put(Integer.valueOf(parameterIndex - 1), Float.valueOf(x));
1854     }
1855 
1856     /**
1857      * Sets the designated parameter to the given &lt;code&gt;double&lt;/code&gt; in the
1858      * Java programming language.  The driver converts this to an SQL
1859      * &lt;code&gt;DOUBLE&lt;/code&gt; value when it sends it to the database.
1860      * &lt;P&gt;
1861      * The parameter value set by this method is stored internally and
1862      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1863      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1864      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1865      * provided in any class that extends this class and implements one or
1866      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1867      * &lt;P&gt;
1868      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1869      * as it is undefined in this class.
1870      *
1871      * @param parameterIndex the ordinal number of the placeholder parameter
1872      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1873      *        The first parameter is 1, the second is 2, and so on; must be
1874      *        &lt;code&gt;1&lt;/code&gt; or greater
1875      * @param x the parameter value
1876      * @throws SQLException if an error occurs or the
1877      *                         parameter index is out of bounds
1878      * @see #getParams
1879      */
1880     public void setDouble(int parameterIndex, double x) throws SQLException {
1881         checkParamIndex(parameterIndex);
1882         if(params == null){
1883              throw new SQLException(&quot;Set initParams() before setDouble&quot;);
1884         }
1885         params.put(Integer.valueOf(parameterIndex - 1), Double.valueOf(x));
1886     }
1887 
1888     /**
1889      * Sets the designated parameter to the given
1890      * &lt;code&gt;java.lang.BigDecimal&lt;/code&gt; value.  The driver converts this to
1891      * an SQL &lt;code&gt;NUMERIC&lt;/code&gt; value when it sends it to the database.
1892      * &lt;P&gt;
1893      * The parameter value set by this method is stored internally and
1894      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1895      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1896      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1897      * provided in any class that extends this class and implements one or
1898      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1899      * &lt;P&gt;
1900      * Note: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1901      * as it is undefined in this class.
1902      *
1903      * @param parameterIndex the ordinal number of the placeholder parameter
1904      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1905      *        The first parameter is 1, the second is 2, and so on; must be
1906      *        &lt;code&gt;1&lt;/code&gt; or greater
1907      * @param x the parameter value
1908      * @throws SQLException if an error occurs or the
1909      *                         parameter index is out of bounds
1910      * @see #getParams
1911      */
1912     public void setBigDecimal(int parameterIndex, java.math.BigDecimal x) throws SQLException {
1913         checkParamIndex(parameterIndex);
1914         if(params == null){
1915              throw new SQLException(&quot;Set initParams() before setBigDecimal&quot;);
1916         }
1917         params.put(Integer.valueOf(parameterIndex - 1), x);
1918     }
1919 
1920     /**
1921      * Sets the designated parameter to the given &lt;code&gt;String&lt;/code&gt;
1922      * value.  The driver converts this to an SQL
1923      * &lt;code&gt;VARCHAR&lt;/code&gt; or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value
1924      * (depending on the argument&#39;s size relative to the driver&#39;s limits
1925      * on &lt;code&gt;VARCHAR&lt;/code&gt; values) when it sends it to the database.
1926      * &lt;P&gt;
1927      * The parameter value set by this method is stored internally and
1928      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1929      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1930      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1931      * provided in any class that extends this class and implements one or
1932      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1933      * &lt;p&gt;
1934      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1935      * as it is undefined in this class.
1936      *
1937      * @param parameterIndex the ordinal number of the placeholder parameter
1938      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1939      *        The first parameter is 1, the second is 2, and so on; must be
1940      *        &lt;code&gt;1&lt;/code&gt; or greater
1941      * @param x the parameter value
1942      * @throws SQLException if an error occurs or the
1943      *                         parameter index is out of bounds
1944      * @see #getParams
1945      */
1946     public void setString(int parameterIndex, String x) throws SQLException {
1947         checkParamIndex(parameterIndex);
1948         if(params == null){
1949              throw new SQLException(&quot;Set initParams() before setString&quot;);
1950         }
1951         params.put(Integer.valueOf(parameterIndex - 1), x);
1952     }
1953 
1954     /**
1955      * Sets the designated parameter to the given array of bytes.
1956      * The driver converts this to an SQL
1957      * &lt;code&gt;VARBINARY&lt;/code&gt; or &lt;code&gt;LONGVARBINARY&lt;/code&gt; value
1958      * (depending on the argument&#39;s size relative to the driver&#39;s limits
1959      * on &lt;code&gt;VARBINARY&lt;/code&gt; values) when it sends it to the database.
1960      * &lt;P&gt;
1961      * The parameter value set by this method is stored internally and
1962      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1963      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1964      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1965      * provided in any class that extends this class and implements one or
1966      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1967      * &lt;p&gt;
1968      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1969      * as it is undefined in this class.
1970      *
1971      * @param parameterIndex the ordinal number of the placeholder parameter
1972      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1973      *        The first parameter is 1, the second is 2, and so on; must be
1974      *        &lt;code&gt;1&lt;/code&gt; or greater
1975      * @param x the parameter value
1976      * @throws SQLException if an error occurs or the
1977      *                         parameter index is out of bounds
1978      * @see #getParams
1979      */
1980     public void setBytes(int parameterIndex, byte x[]) throws SQLException {
1981         checkParamIndex(parameterIndex);
1982         if(params == null){
1983              throw new SQLException(&quot;Set initParams() before setBytes&quot;);
1984         }
1985         params.put(Integer.valueOf(parameterIndex - 1), x);
1986     }
1987 
1988     /**
1989      * Sets the designated parameter to the given &lt;code&gt;java.sql.Date&lt;/code&gt;
1990      * value. The driver converts this to an SQL
1991      * &lt;code&gt;DATE&lt;/code&gt; value when it sends it to the database.
1992      * &lt;P&gt;
1993      * The parameter value set by this method is stored internally and
1994      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1995      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1996      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1997      * provided in any class that extends this class and implements one or
1998      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1999      * &lt;P&gt;
2000      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2001      * as it is undefined in this class.
2002      * &lt;P&gt;
2003      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version
2004      * of &lt;code&gt;setDate&lt;/code&gt;
2005      * has been called will return an array with the value to be set for
2006      * placeholder parameter number &lt;i&gt;parameterIndex&lt;/i&gt; being the &lt;code&gt;Date&lt;/code&gt;
2007      * object supplied as the second parameter.
2008      * Note that because the numbering of elements in an array starts at zero,
2009      * the array element that corresponds to placeholder parameter number
2010      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2011      *
2012      * @param parameterIndex the ordinal number of the placeholder parameter
2013      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2014      *        The first parameter is 1, the second is 2, and so on; must be
2015      *        &lt;code&gt;1&lt;/code&gt; or greater
2016      * @param x the parameter value
2017      * @throws SQLException if an error occurs or the
2018      *                         parameter index is out of bounds
2019      * @see #getParams
2020      */
2021     public void setDate(int parameterIndex, java.sql.Date x) throws SQLException {
2022         checkParamIndex(parameterIndex);
2023 
2024         if(params == null){
2025              throw new SQLException(&quot;Set initParams() before setDate&quot;);
2026         }
2027         params.put(Integer.valueOf(parameterIndex - 1), x);
2028     }
2029 
2030     /**
2031      * Sets the designated parameter to the given &lt;code&gt;java.sql.Time&lt;/code&gt;
2032      * value.  The driver converts this to an SQL &lt;code&gt;TIME&lt;/code&gt; value
2033      * when it sends it to the database.
2034      * &lt;P&gt;
2035      * The parameter value set by this method is stored internally and
2036      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2037      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2038      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2039      * provided in any class that extends this class and implements one or
2040      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2041      * &lt;P&gt;
2042      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2043      * as it is undefined in this class.
2044      * &lt;P&gt;
2045      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version
2046      * of the method &lt;code&gt;setTime&lt;/code&gt;
2047      * has been called will return an array of the parameters that have been set.
2048      * The parameter to be set for parameter placeholder number &lt;i&gt;parameterIndex&lt;/i&gt;
2049      * will be the &lt;code&gt;Time&lt;/code&gt; object that was set as the second parameter
2050      * to this method.
2051      * &lt;P&gt;
2052      * Note that because the numbering of elements in an array starts at zero,
2053      * the array element that corresponds to placeholder parameter number
2054      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2055      *
2056      * @param parameterIndex the ordinal number of the placeholder parameter
2057      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2058      *        The first parameter is 1, the second is 2, and so on; must be
2059      *        &lt;code&gt;1&lt;/code&gt; or greater
2060      * @param x a &lt;code&gt;java.sql.Time&lt;/code&gt; object, which is to be set as the value
2061      *              for placeholder parameter &lt;i&gt;parameterIndex&lt;/i&gt;
2062      * @throws SQLException if an error occurs or the
2063      *                         parameter index is out of bounds
2064      * @see #getParams
2065      */
2066     public void setTime(int parameterIndex, java.sql.Time x) throws SQLException {
2067         checkParamIndex(parameterIndex);
2068         if(params == null){
2069              throw new SQLException(&quot;Set initParams() before setTime&quot;);
2070         }
2071 
2072         params.put(Integer.valueOf(parameterIndex - 1), x);
2073     }
2074 
2075     /**
2076      * Sets the designated parameter to the given
2077      * &lt;code&gt;java.sql.Timestamp&lt;/code&gt; value.
2078      * The driver converts this to an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value when it
2079      * sends it to the database.
2080      * &lt;P&gt;
2081      * The parameter value set by this method is stored internally and
2082      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2083      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2084      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2085      * provided in any class that extends this class and implements one or
2086      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2087      * &lt;P&gt;
2088      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2089      * as it is undefined in this class.
2090      * &lt;P&gt;
2091      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
2092      * &lt;code&gt;setTimestamp&lt;/code&gt;
2093      * has been called will return an array with the value for parameter placeholder
2094      * number &lt;i&gt;parameterIndex&lt;/i&gt; being the &lt;code&gt;Timestamp&lt;/code&gt; object that was
2095      * supplied as the second parameter to this method.
2096      * Note that because the numbering of elements in an array starts at zero,
2097      * the array element that corresponds to placeholder parameter number
2098      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2099      *
2100      * @param parameterIndex the ordinal number of the placeholder parameter
2101      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2102      *        The first parameter is 1, the second is 2, and so on; must be
2103      *        &lt;code&gt;1&lt;/code&gt; or greater
2104      * @param x a &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object
2105      * @throws SQLException if an error occurs or the
2106      *                         parameter index is out of bounds
2107      * @see #getParams
2108      */
2109     public void setTimestamp(int parameterIndex, java.sql.Timestamp x) throws SQLException {
2110         checkParamIndex(parameterIndex);
2111         if(params == null){
2112              throw new SQLException(&quot;Set initParams() before setTimestamp&quot;);
2113         }
2114 
2115         params.put(Integer.valueOf(parameterIndex - 1), x);
2116     }
2117 
2118     /**
2119      * Sets the designated parameter to the given
2120      * &lt;code&gt;java.io.InputStream&lt;/code&gt; object,
2121      * which will have the specified number of bytes.
2122      * The contents of the stream will be read and sent to the database.
2123      * This method throws an &lt;code&gt;SQLException&lt;/code&gt; object if the number of bytes
2124      * read and sent to the database is not equal to &lt;i&gt;length&lt;/i&gt;.
2125      * &lt;P&gt;
2126      * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
2127      * parameter, it may be more practical to send it via a
2128      * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. A JDBC technology-enabled
2129      * driver will read the data from the stream as needed until it reaches
2130      * end-of-file. The driver will do any necessary conversion from ASCII to
2131      * the database &lt;code&gt;CHAR&lt;/code&gt; format.
2132      *
2133      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can be either a standard
2134      * Java stream object or your own subclass that implements the
2135      * standard interface.
2136      * &lt;P&gt;
2137      * The parameter value set by this method is stored internally and
2138      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2139      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2140      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2141      * provided in any class that extends this class and implements one or
2142      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2143      * &lt;P&gt;
2144      * Note: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2145      * as it is undefined in this class.
2146      * &lt;P&gt;
2147      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after &lt;code&gt;setAsciiStream&lt;/code&gt;
2148      * has been called will return an array containing the parameter values that
2149      * have been set.  The element in the array that represents the values
2150      * set with this method will itself be an array. The first element of that array
2151      * is the given &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
2152      * The second element is the value set for &lt;i&gt;length&lt;/i&gt;.
2153      * The third element is an internal &lt;code&gt;BaseRowSet&lt;/code&gt; constant
2154      * specifying that the stream passed to this method is an ASCII stream.
2155      * The parameter number is indicated by an element&#39;s position in the array
2156      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2157      * with the first element being the value for the first placeholder parameter, the
2158      * second element being the value for the second placeholder parameter, and so on.
2159      * In other words, if the input stream being set is the value for the second
2160      * placeholder parameter, the array containing it will be the second element in
2161      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2162      * &lt;P&gt;
2163      * Note that because the numbering of elements in an array starts at zero,
2164      * the array element that corresponds to placeholder parameter number
2165      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2166      *
2167      * @param parameterIndex the ordinal number of the placeholder parameter
2168      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2169      *        The first parameter is 1, the second is 2, and so on; must be
2170      *        &lt;code&gt;1&lt;/code&gt; or greater
2171      * @param x the Java input stream that contains the ASCII parameter value
2172      * @param length the number of bytes in the stream. This is the number of bytes
2173      *       the driver will send to the DBMS; lengths of 0 or less are
2174      *       are undefined but will cause an invalid length exception to be
2175      *       thrown in the underlying JDBC driver.
2176      * @throws SQLException if an error occurs, the parameter index is out of bounds,
2177      *       or when connected to a data source, the number of bytes the driver reads
2178      *       and sends to the database is not equal to the number of bytes specified
2179      *       in &lt;i&gt;length&lt;/i&gt;
2180      * @see #getParams
2181      */
2182     public void setAsciiStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException {
2183         Object asciiStream[];
2184         checkParamIndex(parameterIndex);
2185 
2186         asciiStream = new Object[3];
2187         asciiStream[0] = x;
2188         asciiStream[1] = Integer.valueOf(length);
2189         asciiStream[2] = Integer.valueOf(ASCII_STREAM_PARAM);
2190 
2191         if(params == null){
2192              throw new SQLException(&quot;Set initParams() before setAsciiStream&quot;);
2193         }
2194 
2195         params.put(Integer.valueOf(parameterIndex - 1), asciiStream);
2196     }
2197 
2198   /**
2199    * Sets the designated parameter in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
2200    * to the given input stream.
2201    * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
2202    * parameter, it may be more practical to send it via a
2203    * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
2204    * as needed until end-of-file is reached.  The JDBC driver will
2205    * do any necessary conversion from ASCII to the database char format.
2206    *
2207    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
2208    * Java stream object or your own subclass that implements the
2209    * standard interface.
2210    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
2211    * it might be more efficient to use a version of
2212    * &lt;code&gt;setAsciiStream&lt;/code&gt; which takes a length parameter.
2213    *
2214    * @param parameterIndex the first parameter is 1, the second is 2, ...
2215    * @param x the Java input stream that contains the ASCII parameter value
2216    * @exception SQLException if a database access error occurs or
2217    * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
2218    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
2219    * @since 1.6
2220    */
2221   public void setAsciiStream(int parameterIndex, java.io.InputStream x)
2222                       throws SQLException {
2223       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
2224   }
2225 
2226     /**
2227      * Sets the designated parameter to the given &lt;code&gt;java.io.InputStream&lt;/code&gt;
2228      * object, which will have the specified number of bytes.
2229      * The contents of the stream will be read and sent to the database.
2230      * This method throws an &lt;code&gt;SQLException&lt;/code&gt; object if the number of bytes
2231      * read and sent to the database is not equal to &lt;i&gt;length&lt;/i&gt;.
2232      * &lt;P&gt;
2233      * When a very large binary value is input to a
2234      * &lt;code&gt;LONGVARBINARY&lt;/code&gt; parameter, it may be more practical
2235      * to send it via a &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
2236      * A JDBC technology-enabled driver will read the data from the
2237      * stream as needed until it reaches end-of-file.
2238      *
2239      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can be either a standard
2240      * Java stream object or your own subclass that implements the
2241      * standard interface.
2242      * &lt;P&gt;
2243      * The parameter value set by this method is stored internally and
2244      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2245      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2246      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2247      * provided in any class that extends this class and implements one or
2248      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2249      *&lt;P&gt;
2250      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2251      * as it is undefined in this class.
2252      * &lt;P&gt;
2253      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after &lt;code&gt;setBinaryStream&lt;/code&gt;
2254      * has been called will return an array containing the parameter values that
2255      * have been set.  In that array, the element that represents the values
2256      * set with this method will itself be an array. The first element of that array
2257      * is the given &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
2258      * The second element is the value set for &lt;i&gt;length&lt;/i&gt;.
2259      * The third element is an internal &lt;code&gt;BaseRowSet&lt;/code&gt; constant
2260      * specifying that the stream passed to this method is a binary stream.
2261      * The parameter number is indicated by an element&#39;s position in the array
2262      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2263      * with the first element being the value for the first placeholder parameter, the
2264      * second element being the value for the second placeholder parameter, and so on.
2265      * In other words, if the input stream being set is the value for the second
2266      * placeholder parameter, the array containing it will be the second element in
2267      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2268      * &lt;P&gt;
2269      * Note that because the numbering of elements in an array starts at zero,
2270      * the array element that corresponds to placeholder parameter number
2271      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2272      *
2273      * @param parameterIndex the ordinal number of the placeholder parameter
2274      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2275      *        The first parameter is 1, the second is 2, and so on; must be
2276      *        &lt;code&gt;1&lt;/code&gt; or greater
2277      * @param x the input stream that contains the binary value to be set
2278      * @param length the number of bytes in the stream; lengths of 0 or less are
2279      *         are undefined but will cause an invalid length exception to be
2280      *         thrown in the underlying JDBC driver.
2281      * @throws SQLException if an error occurs, the parameter index is out of bounds,
2282      *         or when connected to a data source, the number of bytes the driver
2283      *         reads and sends to the database is not equal to the number of bytes
2284      *         specified in &lt;i&gt;length&lt;/i&gt;
2285      * @see #getParams
2286      */
2287     public void setBinaryStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException {
2288         Object binaryStream[];
2289         checkParamIndex(parameterIndex);
2290 
2291         binaryStream = new Object[3];
2292         binaryStream[0] = x;
2293         binaryStream[1] = Integer.valueOf(length);
2294         binaryStream[2] = Integer.valueOf(BINARY_STREAM_PARAM);
2295         if(params == null){
2296              throw new SQLException(&quot;Set initParams() before setBinaryStream&quot;);
2297         }
2298 
2299         params.put(Integer.valueOf(parameterIndex - 1), binaryStream);
2300     }
2301 
2302 
2303    /**
2304    * Sets the designated parameter in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
2305    * to the given input stream.
2306    * When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt;
2307    * parameter, it may be more practical to send it via a
2308    * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The data will be read from the
2309    * stream as needed until end-of-file is reached.
2310    *
2311    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
2312    * Java stream object or your own subclass that implements the
2313    * standard interface.
2314    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
2315    * it might be more efficient to use a version of
2316    * &lt;code&gt;setBinaryStream&lt;/code&gt; which takes a length parameter.
2317    *
2318    * @param parameterIndex the first parameter is 1, the second is 2, ...
2319    * @param x the java input stream which contains the binary parameter value
2320    * @exception SQLException if a database access error occurs or
2321    * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
2322    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
2323    * @since 1.6
2324    */
2325   public void setBinaryStream(int parameterIndex, java.io.InputStream x)
2326                               throws SQLException {
2327       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
2328   }
2329 
2330 
2331     /**
2332      * Sets the designated parameter to the given
2333      * &lt;code&gt;java.io.InputStream&lt;/code&gt; object, which will have the specified
2334      * number of bytes. The contents of the stream will be read and sent
2335      * to the database.
2336      * This method throws an &lt;code&gt;SQLException&lt;/code&gt; if the number of bytes
2337      * read and sent to the database is not equal to &lt;i&gt;length&lt;/i&gt;.
2338      * &lt;P&gt;
2339      * When a very large Unicode value is input to a
2340      * &lt;code&gt;LONGVARCHAR&lt;/code&gt; parameter, it may be more practical
2341      * to send it via a &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
2342      * A JDBC technology-enabled driver will read the data from the
2343      * stream as needed, until it reaches end-of-file.
2344      * The driver will do any necessary conversion from Unicode to the
2345      * database &lt;code&gt;CHAR&lt;/code&gt; format.
2346      * The byte format of the Unicode stream must be Java UTF-8, as
2347      * defined in the Java Virtual Machine Specification.
2348      *
2349      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can be either a standard
2350      * Java stream object or your own subclass that implements the
2351      * standard interface.
2352      * &lt;P&gt;
2353      * This method is deprecated; the method &lt;code&gt;getCharacterStream&lt;/code&gt;
2354      * should be used in its place.
2355      * &lt;P&gt;
2356      * The parameter value set by this method is stored internally and
2357      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2358      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2359      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after &lt;code&gt;setUnicodeStream&lt;/code&gt;
2360      * has been called will return an array containing the parameter values that
2361      * have been set.  In that array, the element that represents the values
2362      * set with this method will itself be an array. The first element of that array
2363      * is the given &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
2364      * The second element is the value set for &lt;i&gt;length&lt;/i&gt;.
2365      * The third element is an internal &lt;code&gt;BaseRowSet&lt;/code&gt; constant
2366      * specifying that the stream passed to this method is a Unicode stream.
2367      * The parameter number is indicated by an element&#39;s position in the array
2368      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2369      * with the first element being the value for the first placeholder parameter, the
2370      * second element being the value for the second placeholder parameter, and so on.
2371      * In other words, if the input stream being set is the value for the second
2372      * placeholder parameter, the array containing it will be the second element in
2373      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2374      * &lt;P&gt;
2375      * Note that because the numbering of elements in an array starts at zero,
2376      * the array element that corresponds to placeholder parameter number
2377      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2378      *
2379      * @param parameterIndex the ordinal number of the placeholder parameter
2380      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2381      *        The first parameter is 1, the second is 2, and so on; must be
2382      *        &lt;code&gt;1&lt;/code&gt; or greater
2383      * @param x the &lt;code&gt;java.io.InputStream&lt;/code&gt; object that contains the
2384      *          UNICODE parameter value
2385      * @param length the number of bytes in the input stream
2386      * @throws SQLException if an error occurs, the parameter index is out of bounds,
2387      *         or the number of bytes the driver reads and sends to the database is
2388      *         not equal to the number of bytes specified in &lt;i&gt;length&lt;/i&gt;
2389      * @deprecated getCharacterStream should be used in its place
2390      * @see #getParams
2391      */
2392     @Deprecated
2393     public void setUnicodeStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException {
2394         Object unicodeStream[];
2395         checkParamIndex(parameterIndex);
2396 
2397         unicodeStream = new Object[3];
2398         unicodeStream[0] = x;
2399         unicodeStream[1] = Integer.valueOf(length);
2400         unicodeStream[2] = Integer.valueOf(UNICODE_STREAM_PARAM);
2401         if(params == null){
2402              throw new SQLException(&quot;Set initParams() before setUnicodeStream&quot;);
2403         }
2404         params.put(Integer.valueOf(parameterIndex - 1), unicodeStream);
2405     }
2406 
2407     /**
2408      * Sets the designated parameter to the given &lt;code&gt;java.io.Reader&lt;/code&gt;
2409      * object, which will have the specified number of characters. The
2410      * contents of the reader will be read and sent to the database.
2411      * This method throws an &lt;code&gt;SQLException&lt;/code&gt; if the number of bytes
2412      * read and sent to the database is not equal to &lt;i&gt;length&lt;/i&gt;.
2413      * &lt;P&gt;
2414      * When a very large Unicode value is input to a
2415      * &lt;code&gt;LONGVARCHAR&lt;/code&gt; parameter, it may be more practical
2416      * to send it via a &lt;code&gt;Reader&lt;/code&gt; object.
2417      * A JDBC technology-enabled driver will read the data from the
2418      * stream as needed until it reaches end-of-file.
2419      * The driver will do any necessary conversion from Unicode to the
2420      * database &lt;code&gt;CHAR&lt;/code&gt; format.
2421      * The byte format of the Unicode stream must be Java UTF-8, as
2422      * defined in the Java Virtual Machine Specification.
2423      *
2424      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can be either a standard
2425      * Java stream object or your own subclass that implements the
2426      * standard interface.
2427      * &lt;P&gt;
2428      * The parameter value set by this method is stored internally and
2429      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2430      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2431      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2432      * provided in any class that extends this class and implements one or
2433      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2434      * &lt;P&gt;
2435      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2436      * as it is undefined in this class.
2437      * &lt;P&gt;
2438      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after
2439      * &lt;code&gt;setCharacterStream&lt;/code&gt;
2440      * has been called will return an array containing the parameter values that
2441      * have been set.  In that array, the element that represents the values
2442      * set with this method will itself be an array. The first element of that array
2443      * is the given &lt;code&gt;java.io.Reader&lt;/code&gt; object.
2444      * The second element is the value set for &lt;i&gt;length&lt;/i&gt;.
2445      * The parameter number is indicated by an element&#39;s position in the array
2446      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2447      * with the first element being the value for the first placeholder parameter, the
2448      * second element being the value for the second placeholder parameter, and so on.
2449      * In other words, if the reader being set is the value for the second
2450      * placeholder parameter, the array containing it will be the second element in
2451      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2452      * &lt;P&gt;
2453      * Note that because the numbering of elements in an array starts at zero,
2454      * the array element that corresponds to placeholder parameter number
2455      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2456      *
2457      * @param parameterIndex the ordinal number of the placeholder parameter
2458      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2459      *        The first parameter is 1, the second is 2, and so on; must be
2460      *        &lt;code&gt;1&lt;/code&gt; or greater
2461      * @param reader the &lt;code&gt;Reader&lt;/code&gt; object that contains the
2462      *        Unicode data
2463      * @param length the number of characters in the stream; lengths of 0 or
2464      *        less are undefined but will cause an invalid length exception to
2465      *        be thrown in the underlying JDBC driver.
2466      * @throws SQLException if an error occurs, the parameter index is out of bounds,
2467      *        or when connected to a data source, the number of bytes the driver
2468      *        reads and sends to the database is not equal to the number of bytes
2469      *        specified in &lt;i&gt;length&lt;/i&gt;
2470      * @see #getParams
2471      */
2472     public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException {
2473         Object charStream[];
2474         checkParamIndex(parameterIndex);
2475 
2476         charStream = new Object[2];
2477         charStream[0] = reader;
2478         charStream[1] = Integer.valueOf(length);
2479         if(params == null){
2480              throw new SQLException(&quot;Set initParams() before setCharacterStream&quot;);
2481         }
2482         params.put(Integer.valueOf(parameterIndex - 1), charStream);
2483     }
2484 
2485    /**
2486    * Sets the designated parameter in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
2487    * to the given &lt;code&gt;Reader&lt;/code&gt;
2488    * object.
2489    * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
2490    * parameter, it may be more practical to send it via a
2491    * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
2492    * as needed until end-of-file is reached.  The JDBC driver will
2493    * do any necessary conversion from UNICODE to the database char format.
2494    *
2495    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
2496    * Java stream object or your own subclass that implements the
2497    * standard interface.
2498    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
2499    * it might be more efficient to use a version of
2500    * &lt;code&gt;setCharacterStream&lt;/code&gt; which takes a length parameter.
2501    *
2502    * @param parameterIndex the first parameter is 1, the second is 2, ...
2503    * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object that contains the
2504    *        Unicode data
2505    * @exception SQLException if a database access error occurs or
2506    * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
2507    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
2508    * @since 1.6
2509    */
2510   public void setCharacterStream(int parameterIndex,
2511                           java.io.Reader reader) throws SQLException {
2512       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
2513   }
2514 
2515     /**
2516      * Sets the designated parameter to an &lt;code&gt;Object&lt;/code&gt; in the Java
2517      * programming language. The second parameter must be an
2518      * &lt;code&gt;Object&lt;/code&gt; type.  For integral values, the
2519      * &lt;code&gt;java.lang&lt;/code&gt; equivalent
2520      * objects should be used. For example, use the class &lt;code&gt;Integer&lt;/code&gt;
2521      * for an &lt;code&gt;int&lt;/code&gt;.
2522      * &lt;P&gt;
2523      * The driver converts this object to the specified
2524      * target SQL type before sending it to the database.
2525      * If the object has a custom mapping (is of a class implementing
2526      * &lt;code&gt;SQLData&lt;/code&gt;), the driver should call the method
2527      * &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write the object to the SQL
2528      * data stream. If, on the other hand, the object is of a class
2529      * implementing &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;,
2530      * &lt;code&gt;Struct&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;,
2531      * the driver should pass it to the database as a value of the
2532      * corresponding SQL type.
2533      *
2534      * &lt;p&gt;Note that this method may be used to pass database-
2535      * specific abstract data types.
2536      * &lt;P&gt;
2537      * The parameter value set by this method is stored internally and
2538      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2539      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2540      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2541      * provided in any class that extends this class and implements one or
2542      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2543      * &lt;P&gt;
2544      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2545      * as it is undefined in this class.
2546      * &lt;P&gt;
2547      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
2548      * &lt;code&gt;setObject&lt;/code&gt;
2549      * has been called will return an array containing the parameter values that
2550      * have been set.  In that array, the element that represents the values
2551      * set with this method will itself be an array. The first element of that array
2552      * is the given &lt;code&gt;Object&lt;/code&gt; instance, and the
2553      * second element is the value set for &lt;i&gt;targetSqlType&lt;/i&gt;.  The
2554      * third element is the value set for &lt;i&gt;scale&lt;/i&gt;, which the driver will
2555      * ignore if the type of the object being set is not
2556      * &lt;code&gt;java.sql.Types.NUMERIC&lt;/code&gt; or &lt;code&gt;java.sql.Types.DECIMAL&lt;/code&gt;.
2557      * The parameter number is indicated by an element&#39;s position in the array
2558      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2559      * with the first element being the value for the first placeholder parameter, the
2560      * second element being the value for the second placeholder parameter, and so on.
2561      * In other words, if the object being set is the value for the second
2562      * placeholder parameter, the array containing it will be the second element in
2563      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2564      *&lt;P&gt;
2565      * Note that because the numbering of elements in an array starts at zero,
2566      * the array element that corresponds to placeholder parameter number
2567      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2568      *
2569      *
2570      * @param parameterIndex the ordinal number of the placeholder parameter
2571      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2572      *        The first parameter is 1, the second is 2, and so on; must be
2573      *        &lt;code&gt;1&lt;/code&gt; or greater
2574      * @param x the &lt;code&gt;Object&lt;/code&gt; containing the input parameter value;
2575      *        must be an &lt;code&gt;Object&lt;/code&gt; type
2576      * @param targetSqlType the SQL type (as defined in &lt;code&gt;java.sql.Types&lt;/code&gt;)
2577      *        to be sent to the database. The &lt;code&gt;scale&lt;/code&gt; argument may
2578      *        further qualify this type. If a non-standard &lt;i&gt;targetSqlType&lt;/i&gt;
2579      *        is supplied, this method will not throw a &lt;code&gt;SQLException&lt;/code&gt;.
2580      *        This allows implicit support for non-standard SQL types.
2581      * @param scale for the types &lt;code&gt;java.sql.Types.DECIMAL&lt;/code&gt; and
2582      *        &lt;code&gt;java.sql.Types.NUMERIC&lt;/code&gt;, this is the number
2583      *        of digits after the decimal point.  For all other types, this
2584      *        value will be ignored.
2585      * @throws SQLException if an error occurs or the parameter index is out of bounds
2586      * @see #getParams
2587      */
2588     public void setObject(int parameterIndex, Object x, int targetSqlType, int scale) throws SQLException {
2589         Object obj[];
2590         checkParamIndex(parameterIndex);
2591 
2592         obj = new Object[3];
2593         obj[0] = x;
2594         obj[1] = Integer.valueOf(targetSqlType);
2595         obj[2] = Integer.valueOf(scale);
2596         if(params == null){
2597              throw new SQLException(&quot;Set initParams() before setObject&quot;);
2598         }
2599         params.put(Integer.valueOf(parameterIndex - 1), obj);
2600     }
2601 
2602     /**
2603      * Sets the value of the designated parameter with the given
2604      * &lt;code&gt;Object&lt;/code&gt; value.
2605      * This method is like &lt;code&gt;setObject(int parameterIndex, Object x, int
2606      * targetSqlType, int scale)&lt;/code&gt; except that it assumes a scale of zero.
2607      * &lt;P&gt;
2608      * The parameter value set by this method is stored internally and
2609      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2610      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2611      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2612      * provided in any class that extends this class and implements one or
2613      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2614      * &lt;P&gt;
2615      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2616      * as it is undefined in this class.
2617      * &lt;P&gt;
2618      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
2619      * &lt;code&gt;setObject&lt;/code&gt;
2620      * has been called will return an array containing the parameter values that
2621      * have been set.  In that array, the element that represents the values
2622      * set with this method will itself be an array. The first element of that array
2623      * is the given &lt;code&gt;Object&lt;/code&gt; instance.
2624      * The second element is the value set for &lt;i&gt;targetSqlType&lt;/i&gt;.
2625      * The parameter number is indicated by an element&#39;s position in the array
2626      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2627      * with the first element being the value for the first placeholder parameter, the
2628      * second element being the value for the second placeholder parameter, and so on.
2629      * In other words, if the object being set is the value for the second
2630      * placeholder parameter, the array containing it will be the second element in
2631      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2632      * &lt;P&gt;
2633      * Note that because the numbering of elements in an array starts at zero,
2634      * the array element that corresponds to placeholder parameter number
2635      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2636      *
2637      * @param parameterIndex the ordinal number of the placeholder parameter
2638      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2639      *        The first parameter is 1, the second is 2, and so on; must be
2640      *        &lt;code&gt;1&lt;/code&gt; or greater
2641      * @param x the &lt;code&gt;Object&lt;/code&gt; containing the input parameter value;
2642      *        must be an &lt;code&gt;Object&lt;/code&gt; type
2643      * @param targetSqlType the SQL type (as defined in &lt;code&gt;java.sql.Types&lt;/code&gt;)
2644      *        to be sent to the database. If a non-standard &lt;i&gt;targetSqlType&lt;/i&gt;
2645      *        is supplied, this method will not throw a &lt;code&gt;SQLException&lt;/code&gt;.
2646      *        This allows implicit support for non-standard SQL types.
2647      * @throws SQLException if an error occurs or the parameter index
2648      *        is out of bounds
2649      * @see #getParams
2650      */
2651     public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {
2652         Object obj[];
2653         checkParamIndex(parameterIndex);
2654 
2655         obj = new Object[2];
2656         obj[0] = x;
2657         obj[1] = Integer.valueOf(targetSqlType);
2658         if (params == null){
2659              throw new SQLException(&quot;Set initParams() before setObject&quot;);
2660         }
2661         params.put(Integer.valueOf(parameterIndex - 1), obj);
2662     }
2663 
2664     /**
2665      * Sets the designated parameter to an &lt;code&gt;Object&lt;/code&gt; in the Java
2666      * programming language. The second parameter must be an
2667      * &lt;code&gt;Object&lt;/code&gt;
2668      * type.  For integral values, the &lt;code&gt;java.lang&lt;/code&gt; equivalent
2669      * objects should be used. For example, use the class &lt;code&gt;Integer&lt;/code&gt;
2670      * for an &lt;code&gt;int&lt;/code&gt;.
2671      * &lt;P&gt;
2672      * The JDBC specification defines a standard mapping from
2673      * Java &lt;code&gt;Object&lt;/code&gt; types to SQL types.  The driver will
2674      * use this standard mapping to  convert the given object
2675      * to its corresponding SQL type before sending it to the database.
2676      * If the object has a custom mapping (is of a class implementing
2677      * &lt;code&gt;SQLData&lt;/code&gt;), the driver should call the method
2678      * &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write the object to the SQL
2679      * data stream.
2680      * &lt;P&gt;
2681      * If, on the other hand, the object is of a class
2682      * implementing &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;,
2683      * &lt;code&gt;Struct&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;,
2684      * the driver should pass it to the database as a value of the
2685      * corresponding SQL type.
2686      * &lt;P&gt;
2687      * This method throws an exception if there
2688      * is an ambiguity, for example, if the object is of a class
2689      * implementing more than one interface.
2690      * &lt;P&gt;
2691      * Note that this method may be used to pass database-specific
2692      * abstract data types.
2693      * &lt;P&gt;
2694      * The parameter value set by this method is stored internally and
2695      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2696      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2697      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2698      * provided in any class that extends this class and implements one or
2699      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2700      * &lt;p&gt;
2701      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2702      * as it is undefined in this class.
2703      * &lt;P&gt;
2704      * After this method has been called, a call to the
2705      * method &lt;code&gt;getParams&lt;/code&gt;
2706      * will return an object array of the current command parameters, which will
2707      * include the &lt;code&gt;Object&lt;/code&gt; set for placeholder parameter number
2708      * &lt;code&gt;parameterIndex&lt;/code&gt;.
2709      * Note that because the numbering of elements in an array starts at zero,
2710      * the array element that corresponds to placeholder parameter number
2711      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2712      *
2713      * @param parameterIndex the ordinal number of the placeholder parameter
2714      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2715      *        The first parameter is 1, the second is 2, and so on; must be
2716      *        &lt;code&gt;1&lt;/code&gt; or greater
2717      * @param x the object containing the input parameter value
2718      * @throws SQLException if an error occurs the
2719      *                         parameter index is out of bounds, or there
2720      *                         is ambiguity in the implementation of the
2721      *                         object being set
2722      * @see #getParams
2723      */
2724     public void setObject(int parameterIndex, Object x) throws SQLException {
2725         checkParamIndex(parameterIndex);
2726         if (params == null) {
2727              throw new SQLException(&quot;Set initParams() before setObject&quot;);
2728         }
2729         params.put(Integer.valueOf(parameterIndex - 1), x);
2730     }
2731 
2732     /**
2733      * Sets the designated parameter to the given &lt;code&gt;Ref&lt;/code&gt; object in
2734      * the Java programming language.  The driver converts this to an SQL
2735      * &lt;code&gt;REF&lt;/code&gt; value when it sends it to the database. Internally, the
2736      * &lt;code&gt;Ref&lt;/code&gt; is represented as a &lt;code&gt;SerialRef&lt;/code&gt; to ensure
2737      * serializability.
2738      * &lt;P&gt;
2739      * The parameter value set by this method is stored internally and
2740      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2741      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2742      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2743      * provided in any class that extends this class and implements one or
2744      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2745      * &lt;p&gt;
2746      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2747      * as it is undefined in this class.
2748      * &lt;p&gt;
2749      * After this method has been called, a call to the
2750      * method &lt;code&gt;getParams&lt;/code&gt;
2751      * will return an object array of the current command parameters, which will
2752      * include the &lt;code&gt;Ref&lt;/code&gt; object set for placeholder parameter number
2753      * &lt;code&gt;parameterIndex&lt;/code&gt;.
2754      * Note that because the numbering of elements in an array starts at zero,
2755      * the array element that corresponds to placeholder parameter number
2756      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2757      *
2758      * @param parameterIndex the ordinal number of the placeholder parameter
2759      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2760      *        The first parameter is 1, the second is 2, and so on; must be
2761      *        &lt;code&gt;1&lt;/code&gt; or greater
2762      * @param ref a &lt;code&gt;Ref&lt;/code&gt; object representing an SQL &lt;code&gt;REF&lt;/code&gt;
2763      *         value; cannot be null
2764      * @throws SQLException if an error occurs; the parameter index is out of
2765      *         bounds or the &lt;code&gt;Ref&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt;; or
2766      *         the &lt;code&gt;Ref&lt;/code&gt; object returns a &lt;code&gt;null&lt;/code&gt; base type
2767      *         name.
2768      * @see #getParams
2769      * @see javax.sql.rowset.serial.SerialRef
2770      */
2771     public void setRef (int parameterIndex, Ref ref) throws SQLException {
2772         checkParamIndex(parameterIndex);
2773         if (params == null) {
2774              throw new SQLException(&quot;Set initParams() before setRef&quot;);
2775         }
2776         params.put(Integer.valueOf(parameterIndex - 1), new SerialRef(ref));
2777     }
2778 
2779     /**
2780      * Sets the designated parameter to the given &lt;code&gt;Blob&lt;/code&gt; object in
2781      * the Java programming language.  The driver converts this to an SQL
2782      * &lt;code&gt;BLOB&lt;/code&gt; value when it sends it to the database. Internally,
2783      * the &lt;code&gt;Blob&lt;/code&gt; is represented as a &lt;code&gt;SerialBlob&lt;/code&gt;
2784      * to ensure serializability.
2785      * &lt;P&gt;
2786      * The parameter value set by this method is stored internally and
2787      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2788      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2789      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2790      * provided in any class that extends this class and implements one or
2791      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2792      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2793      * as it is undefined in this class.
2794      * &lt;p&gt;
2795      * After this method has been called, a call to the
2796      * method &lt;code&gt;getParams&lt;/code&gt;
2797      * will return an object array of the current command parameters, which will
2798      * include the &lt;code&gt;Blob&lt;/code&gt; object set for placeholder parameter number
2799      * &lt;code&gt;parameterIndex&lt;/code&gt;.
2800      * Note that because the numbering of elements in an array starts at zero,
2801      * the array element that corresponds to placeholder parameter number
2802      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2803      *
2804      * @param parameterIndex the ordinal number of the placeholder parameter
2805      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2806      *        The first parameter is 1, the second is 2, and so on; must be
2807      *        &lt;code&gt;1&lt;/code&gt; or greater
2808      * @param x a &lt;code&gt;Blob&lt;/code&gt; object representing an SQL
2809      *          &lt;code&gt;BLOB&lt;/code&gt; value
2810      * @throws SQLException if an error occurs or the
2811      *                         parameter index is out of bounds
2812      * @see #getParams
2813      * @see javax.sql.rowset.serial.SerialBlob
2814      */
2815     public void setBlob (int parameterIndex, Blob x) throws SQLException {
2816         checkParamIndex(parameterIndex);
2817         if(params == null){
2818              throw new SQLException(&quot;Set initParams() before setBlob&quot;);
2819         }
2820         params.put(Integer.valueOf(parameterIndex - 1), new SerialBlob(x));
2821     }
2822 
2823     /**
2824      * Sets the designated parameter to the given &lt;code&gt;Clob&lt;/code&gt; object in
2825      * the Java programming language.  The driver converts this to an SQL
2826      * &lt;code&gt;CLOB&lt;/code&gt; value when it sends it to the database. Internally, the
2827      * &lt;code&gt;Clob&lt;/code&gt; is represented as a &lt;code&gt;SerialClob&lt;/code&gt; to ensure
2828      * serializability.
2829      * &lt;P&gt;
2830      * The parameter value set by this method is stored internally and
2831      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2832      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2833      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2834      * provided in any class that extends this class and implements one or
2835      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2836      * &lt;p&gt;
2837      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2838      * as it is undefined in this class.
2839      * &lt;p&gt;
2840      * After this method has been called, a call to the
2841      * method &lt;code&gt;getParams&lt;/code&gt;
2842      * will return an object array of the current command parameters, which will
2843      * include the &lt;code&gt;Clob&lt;/code&gt; object set for placeholder parameter number
2844      * &lt;code&gt;parameterIndex&lt;/code&gt;.
2845      * Note that because the numbering of elements in an array starts at zero,
2846      * the array element that corresponds to placeholder parameter number
2847      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2848      *
2849      * @param parameterIndex the ordinal number of the placeholder parameter
2850      *     in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2851      *     The first parameter is 1, the second is 2, and so on; must be
2852      *     &lt;code&gt;1&lt;/code&gt; or greater
2853      * @param x a &lt;code&gt;Clob&lt;/code&gt; object representing an SQL
2854      *     &lt;code&gt;CLOB&lt;/code&gt; value; cannot be null
2855      * @throws SQLException if an error occurs; the parameter index is out of
2856      *     bounds or the &lt;code&gt;Clob&lt;/code&gt; is null
2857      * @see #getParams
2858      * @see javax.sql.rowset.serial.SerialBlob
2859      */
2860     public void setClob (int parameterIndex, Clob x) throws SQLException {
2861         checkParamIndex(parameterIndex);
2862         if(params == null){
2863              throw new SQLException(&quot;Set initParams() before setClob&quot;);
2864         }
2865         params.put(Integer.valueOf(parameterIndex - 1), new SerialClob(x));
2866     }
2867 
2868     /**
2869      * Sets the designated parameter to an &lt;code&gt;Array&lt;/code&gt; object in the
2870      * Java programming language.  The driver converts this to an SQL
2871      * &lt;code&gt;ARRAY&lt;/code&gt; value when it sends it to the database. Internally,
2872      * the &lt;code&gt;Array&lt;/code&gt; is represented as a &lt;code&gt;SerialArray&lt;/code&gt;
2873      * to ensure serializability.
2874      * &lt;P&gt;
2875      * The parameter value set by this method is stored internally and
2876      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2877      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2878      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2879      * provided in any class that extends this class and implements one or
2880      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2881      * &lt;P&gt;
2882      * Note: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2883      * as it is undefined in this class.
2884      * &lt;p&gt;
2885      * After this method has been called, a call to the
2886      * method &lt;code&gt;getParams&lt;/code&gt;
2887      * will return an object array of the current command parameters, which will
2888      * include the &lt;code&gt;Array&lt;/code&gt; object set for placeholder parameter number
2889      * &lt;code&gt;parameterIndex&lt;/code&gt;.
2890      * Note that because the numbering of elements in an array starts at zero,
2891      * the array element that corresponds to placeholder parameter number
2892      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2893      *
2894      * @param parameterIndex the ordinal number of the placeholder parameter
2895      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2896      *        The first parameter is 1, the second is 2, and so on; must be
2897      *        &lt;code&gt;1&lt;/code&gt; or greater
2898      * @param array an &lt;code&gt;Array&lt;/code&gt; object representing an SQL
2899      *        &lt;code&gt;ARRAY&lt;/code&gt; value; cannot be null. The &lt;code&gt;Array&lt;/code&gt; object
2900      *        passed to this method must return a non-null Object for all
2901      *        &lt;code&gt;getArray()&lt;/code&gt; method calls. A null value will cause a
2902      *        &lt;code&gt;SQLException&lt;/code&gt; to be thrown.
2903      * @throws SQLException if an error occurs; the parameter index is out of
2904      *        bounds or the &lt;code&gt;ARRAY&lt;/code&gt; is null
2905      * @see #getParams
2906      * @see javax.sql.rowset.serial.SerialArray
2907      */
2908     public void setArray (int parameterIndex, Array array) throws SQLException {
2909         checkParamIndex(parameterIndex);
2910         if (params == null){
2911              throw new SQLException(&quot;Set initParams() before setArray&quot;);
2912         }
2913         params.put(Integer.valueOf(parameterIndex - 1), new SerialArray(array));
2914     }
2915 
2916     /**
2917      * Sets the designated parameter to the given &lt;code&gt;java.sql.Date&lt;/code&gt;
2918      * object.
2919      * When the DBMS does not store time zone information, the driver will use
2920      * the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;DATE&lt;/code&gt;
2921      * value to send to the database. With a
2922      * &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the date
2923      * taking into account a custom time zone.  If no &lt;code&gt;Calendar&lt;/code&gt;
2924      * object is specified, the driver uses the time zone of the Virtual Machine
2925      * that is running the application.
2926      * &lt;P&gt;
2927      * The parameter value set by this method is stored internally and
2928      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2929      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2930      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2931      * provided in any class that extends this class and implements one or
2932      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2933      * &lt;P&gt;
2934      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2935      * as it is undefined in this class.
2936      * &lt;P&gt;
2937      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
2938      * &lt;code&gt;setDate&lt;/code&gt;
2939      * has been called will return an array containing the parameter values that
2940      * have been set.  In that array, the element that represents the values
2941      * set with this method will itself be an array. The first element of that array
2942      * is the given &lt;code&gt;java.sql.Date&lt;/code&gt; object.
2943      * The second element is the value set for &lt;i&gt;cal&lt;/i&gt;.
2944      * The parameter number is indicated by an element&#39;s position in the array
2945      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2946      * with the first element being the value for the first placeholder parameter, the
2947      * second element being the value for the second placeholder parameter, and so on.
2948      * In other words, if the date being set is the value for the second
2949      * placeholder parameter, the array containing it will be the second element in
2950      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2951      * &lt;P&gt;
2952      * Note that because the numbering of elements in an array starts at zero,
2953      * the array element that corresponds to placeholder parameter number
2954      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2955      *
2956      * @param parameterIndex the ordinal number of the placeholder parameter
2957      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2958      *        The first parameter is 1, the second is 2, and so on; must be
2959      *        &lt;code&gt;1&lt;/code&gt; or greater
2960      * @param x a &lt;code&gt;java.sql.Date&lt;/code&gt; object representing an SQL
2961      *        &lt;code&gt;DATE&lt;/code&gt; value
2962      * @param cal a &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use when
2963      *        when constructing the date
2964      * @throws SQLException if an error occurs or the
2965      *                         parameter index is out of bounds
2966      * @see #getParams
2967      */
2968     public void setDate(int parameterIndex, java.sql.Date x, Calendar cal) throws SQLException {
2969         Object date[];
2970         checkParamIndex(parameterIndex);
2971 
2972         date = new Object[2];
2973         date[0] = x;
2974         date[1] = cal;
2975         if(params == null){
2976              throw new SQLException(&quot;Set initParams() before setDate&quot;);
2977         }
2978         params.put(Integer.valueOf(parameterIndex - 1), date);
2979     }
2980 
2981     /**
2982      * Sets the designated parameter to the given &lt;code&gt;java.sql.Time&lt;/code&gt;
2983      * object.  The driver converts this
2984      * to an SQL &lt;code&gt;TIME&lt;/code&gt; value when it sends it to the database.
2985      * &lt;P&gt;
2986      * When the DBMS does not store time zone information, the driver will use
2987      * the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;TIME&lt;/code&gt;
2988      * value to send to the database. With a
2989      * &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the date
2990      * taking into account a custom time zone.  If no &lt;code&gt;Calendar&lt;/code&gt;
2991      * object is specified, the driver uses the time zone of the Virtual Machine
2992      * that is running the application.
2993      * &lt;P&gt;
2994      * The parameter value set by this method is stored internally and
2995      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2996      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2997      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2998      * provided in any class that extends this class and implements one or
2999      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
3000      * &lt;P&gt;
3001      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
3002      * as it is undefined in this class.
3003      * &lt;P&gt;
3004      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
3005      * &lt;code&gt;setTime&lt;/code&gt;
3006      * has been called will return an array containing the parameter values that
3007      * have been set.  In that array, the element that represents the values
3008      * set with this method will itself be an array. The first element of that array
3009      * is the given &lt;code&gt;java.sql.Time&lt;/code&gt; object.
3010      * The second element is the value set for &lt;i&gt;cal&lt;/i&gt;.
3011      * The parameter number is indicated by an element&#39;s position in the array
3012      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
3013      * with the first element being the value for the first placeholder parameter, the
3014      * second element being the value for the second placeholder parameter, and so on.
3015      * In other words, if the time being set is the value for the second
3016      * placeholder parameter, the array containing it will be the second element in
3017      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
3018      * &lt;P&gt;
3019      * Note that because the numbering of elements in an array starts at zero,
3020      * the array element that corresponds to placeholder parameter number
3021      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
3022      *
3023      * @param parameterIndex the ordinal number of the placeholder parameter
3024      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
3025      *        The first parameter is 1, the second is 2, and so on; must be
3026      *        &lt;code&gt;1&lt;/code&gt; or greater
3027      * @param x a &lt;code&gt;java.sql.Time&lt;/code&gt; object
3028      * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object the driver can use to
3029      *         construct the time
3030      * @throws SQLException if an error occurs or the
3031      *                         parameter index is out of bounds
3032      * @see #getParams
3033      */
3034     public void setTime(int parameterIndex, java.sql.Time x, Calendar cal) throws SQLException {
3035         Object time[];
3036         checkParamIndex(parameterIndex);
3037 
3038         time = new Object[2];
3039         time[0] = x;
3040         time[1] = cal;
3041         if(params == null){
3042              throw new SQLException(&quot;Set initParams() before setTime&quot;);
3043         }
3044         params.put(Integer.valueOf(parameterIndex - 1), time);
3045     }
3046 
3047     /**
3048      * Sets the designated parameter to the given
3049      * &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object.  The driver converts this
3050      * to an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value when it sends it to the database.
3051      * &lt;P&gt;
3052      * When the DBMS does not store time zone information, the driver will use
3053      * the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;TIMESTAMP&lt;/code&gt;
3054      * value to send to the database. With a
3055      * &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the timestamp
3056      * taking into account a custom time zone.  If no &lt;code&gt;Calendar&lt;/code&gt;
3057      * object is specified, the driver uses the time zone of the Virtual Machine
3058      * that is running the application.
3059      * &lt;P&gt;
3060      * The parameter value set by this method is stored internally and
3061      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
3062      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
3063      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
3064      * provided in any class that extends this class and implements one or
3065      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
3066      * &lt;P&gt;
3067      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
3068      * as it is undefined in this class.
3069      * &lt;P&gt;
3070      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
3071      * &lt;code&gt;setTimestamp&lt;/code&gt;
3072      * has been called will return an array containing the parameter values that
3073      * have been set.  In that array, the element that represents the values
3074      * set with this method will itself be an array. The first element of that array
3075      * is the given &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object.
3076      * The second element is the value set for &lt;i&gt;cal&lt;/i&gt;.
3077      * The parameter number is indicated by an element&#39;s position in the array
3078      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
3079      * with the first element being the value for the first placeholder parameter, the
3080      * second element being the value for the second placeholder parameter, and so on.
3081      * In other words, if the timestamp being set is the value for the second
3082      * placeholder parameter, the array containing it will be the second element in
3083      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
3084      * &lt;P&gt;
3085      * Note that because the numbering of elements in an array starts at zero,
3086      * the array element that corresponds to placeholder parameter number
3087      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
3088      *
3089      * @param parameterIndex the ordinal number of the placeholder parameter
3090      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
3091      *        The first parameter is 1, the second is 2, and so on; must be
3092      *        &lt;code&gt;1&lt;/code&gt; or greater
3093      * @param x a &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object
3094      * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object the driver can use to
3095      *         construct the timestamp
3096      * @throws SQLException if an error occurs or the
3097      *                         parameter index is out of bounds
3098      * @see #getParams
3099      */
3100     public void setTimestamp(int parameterIndex, java.sql.Timestamp x, Calendar cal) throws SQLException {
3101         Object timestamp[];
3102         checkParamIndex(parameterIndex);
3103 
3104         timestamp = new Object[2];
3105         timestamp[0] = x;
3106         timestamp[1] = cal;
3107         if(params == null){
3108              throw new SQLException(&quot;Set initParams() before setTimestamp&quot;);
3109         }
3110         params.put(Integer.valueOf(parameterIndex - 1), timestamp);
3111     }
3112 
3113     /**
3114      * Clears all of the current parameter values in this &lt;code&gt;RowSet&lt;/code&gt;
3115      * object&#39;s internal representation of the parameters to be set in
3116      * this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command when it is executed.
3117      * &lt;P&gt;
3118      * In general, parameter values remain in force for repeated use in
3119      * this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command. Setting a parameter value with the
3120      * setter methods automatically clears the value of the
3121      * designated parameter and replaces it with the new specified value.
3122      * &lt;P&gt;
3123      * This method is called internally by the &lt;code&gt;setCommand&lt;/code&gt;
3124      * method to clear all of the parameters set for the previous command.
3125      * &lt;P&gt;
3126      * Furthermore, this method differs from the &lt;code&gt;initParams&lt;/code&gt;
3127      * method in that it maintains the schema of the &lt;code&gt;RowSet&lt;/code&gt; object.
3128      *
3129      * @throws SQLException if an error occurs clearing the parameters
3130      */
3131     public void clearParameters() throws SQLException {
3132         params.clear();
3133     }
3134 
3135     /**
3136      * Retrieves an array containing the parameter values (both Objects and
3137      * primitives) that have been set for this
3138      * &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command and throws an &lt;code&gt;SQLException&lt;/code&gt; object
3139      * if all parameters have not been set.   Before the command is sent to the
3140      * DBMS to be executed, these parameters will be substituted
3141      * for placeholder parameters in the  &lt;code&gt;PreparedStatement&lt;/code&gt; object
3142      * that is the command for a &lt;code&gt;RowSet&lt;/code&gt; implementation extending
3143      * the &lt;code&gt;BaseRowSet&lt;/code&gt; class.
3144      * &lt;P&gt;
3145      * Each element in the array that is returned is an &lt;code&gt;Object&lt;/code&gt; instance
3146      * that contains the values of the parameters supplied to a setter method.
3147      * The order of the elements is determined by the value supplied for
3148      * &lt;i&gt;parameterIndex&lt;/i&gt;.  If the setter method takes only the parameter index
3149      * and the value to be set (possibly null), the array element will contain the value to be set
3150      * (which will be expressed as an &lt;code&gt;Object&lt;/code&gt;).  If there are additional
3151      * parameters, the array element will itself be an array containing the value to be set
3152      * plus any additional parameter values supplied to the setter method. If the method
3153      * sets a stream, the array element includes the type of stream being supplied to the
3154      * method. These additional parameters are for the use of the driver or the DBMS and may or
3155      * may not be used.
3156      * &lt;P&gt;
3157      * NOTE: Stored parameter values of types &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;,
3158      * &lt;code&gt;Clob&lt;/code&gt; and &lt;code&gt;Ref&lt;/code&gt; are returned as &lt;code&gt;SerialArray&lt;/code&gt;,
3159      * &lt;code&gt;SerialBlob&lt;/code&gt;, &lt;code&gt;SerialClob&lt;/code&gt; and &lt;code&gt;SerialRef&lt;/code&gt;
3160      * respectively.
3161      *
3162      * @return an array of &lt;code&gt;Object&lt;/code&gt; instances that includes the
3163      *         parameter values that may be set in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s
3164      *         command; an empty array if no parameters have been set
3165      * @throws SQLException if an error occurs retrieving the object array of
3166      *         parameters of this &lt;code&gt;RowSet&lt;/code&gt; object or if not all parameters have
3167      *         been set
3168      */
3169     public Object[] getParams() throws SQLException {
3170         if (params == null) {
3171 
3172             initParams();
3173             Object [] paramsArray = new Object[params.size()];
3174             return paramsArray;
3175 
3176         } else {
3177             // The parameters may be set in random order
3178             // but all must be set, check to verify all
3179             // have been set till the last parameter
3180             // else throw exception.
3181 
3182             Object[] paramsArray = new Object[params.size()];
3183             for (int i = 0; i &lt; params.size(); i++) {
3184                paramsArray[i] = params.get(Integer.valueOf(i));
3185                if (paramsArray[i] == null) {
3186                  throw new SQLException(&quot;missing parameter: &quot; + (i + 1));
3187                } //end if
3188             } //end for
3189             return paramsArray;
3190 
3191         } //end if
3192 
3193     } //end getParams
3194 
3195 
3196    /**
3197     * Sets the designated parameter to SQL &lt;code&gt;NULL&lt;/code&gt;.
3198     *
3199     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; You must specify the parameter&#39;s SQL type.
3200     *
3201     * @param parameterName the name of the parameter
3202     * @param sqlType the SQL type code defined in &lt;code&gt;java.sql.Types&lt;/code&gt;
3203     * @exception SQLException if a database access error occurs or
3204     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3205     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3206     * this method
3207     */
3208    public void setNull(String parameterName, int sqlType) throws SQLException {
3209         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3210    }
3211 
3212    /**
3213     * Sets the designated parameter to SQL &lt;code&gt;NULL&lt;/code&gt;.
3214     * This version of the method &lt;code&gt;setNull&lt;/code&gt; should
3215     * be used for user-defined types and REF type parameters.  Examples
3216     * of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and
3217     * named array types.
3218     *
3219     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; To be portable, applications must give the
3220     * SQL type code and the fully-qualified SQL type name when specifying
3221     * a NULL user-defined or REF parameter.  In the case of a user-defined type
3222     * the name is the type name of the parameter itself.  For a REF
3223     * parameter, the name is the type name of the referenced type.  If
3224     * a JDBC driver does not need the type code or type name information,
3225     * it may ignore it.
3226     *
3227     * Although it is intended for user-defined and Ref parameters,
3228     * this method may be used to set a null parameter of any JDBC type.
3229     * If the parameter does not have a user-defined or REF type, the given
3230     * typeName is ignored.
3231     *
3232     *
3233     * @param parameterName the name of the parameter
3234     * @param sqlType a value from &lt;code&gt;java.sql.Types&lt;/code&gt;
3235     * @param typeName the fully-qualified name of an SQL user-defined type;
3236     *        ignored if the parameter is not a user-defined type or
3237     *        SQL &lt;code&gt;REF&lt;/code&gt; value
3238     * @exception SQLException if a database access error occurs or
3239     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3240     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3241     * this method
3242     */
3243    public void setNull (String parameterName, int sqlType, String typeName)
3244        throws SQLException{
3245         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3246    }
3247 
3248    /**
3249     * Sets the designated parameter to the given Java &lt;code&gt;boolean&lt;/code&gt; value.
3250     * The driver converts this
3251     * to an SQL &lt;code&gt;BIT&lt;/code&gt; or &lt;code&gt;BOOLEAN&lt;/code&gt; value when it sends it to the database.
3252     *
3253     * @param parameterName the name of the parameter
3254     * @param x the parameter value
3255     * @exception SQLException if a database access error occurs or
3256     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3257     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3258     * this method
3259     * @see #getParams
3260     */
3261    public void setBoolean(String parameterName, boolean x) throws SQLException{
3262         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3263    }
3264 
3265    /**
3266     * Sets the designated parameter to the given Java &lt;code&gt;byte&lt;/code&gt; value.
3267     * The driver converts this
3268     * to an SQL &lt;code&gt;TINYINT&lt;/code&gt; value when it sends it to the database.
3269     *
3270     * @param parameterName the name of the parameter
3271     * @param x the parameter value
3272     * @exception SQLException if a database access error occurs or
3273     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3274     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3275     * this method
3276     * @see #getParams
3277     */
3278    public void setByte(String parameterName, byte x) throws SQLException{
3279         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3280    }
3281 
3282    /**
3283     * Sets the designated parameter to the given Java &lt;code&gt;short&lt;/code&gt; value.
3284     * The driver converts this
3285     * to an SQL &lt;code&gt;SMALLINT&lt;/code&gt; value when it sends it to the database.
3286     *
3287     * @param parameterName the name of the parameter
3288     * @param x the parameter value
3289     * @exception SQLException if a database access error occurs or
3290     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3291     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3292     * this method
3293     * @see #getParams
3294     */
3295    public void setShort(String parameterName, short x) throws SQLException{
3296         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3297    }
3298 
3299    /**
3300     * Sets the designated parameter to the given Java &lt;code&gt;int&lt;/code&gt; value.
3301     * The driver converts this
3302     * to an SQL &lt;code&gt;INTEGER&lt;/code&gt; value when it sends it to the database.
3303     *
3304     * @param parameterName the name of the parameter
3305     * @param x the parameter value
3306     * @exception SQLException if a database access error occurs or
3307     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3308     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3309     * this method
3310     * @see #getParams
3311     */
3312    public void setInt(String parameterName, int x) throws SQLException{
3313         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3314    }
3315 
3316 
3317    /**
3318     * Sets the designated parameter to the given Java &lt;code&gt;long&lt;/code&gt; value.
3319     * The driver converts this
3320     * to an SQL &lt;code&gt;BIGINT&lt;/code&gt; value when it sends it to the database.
3321     *
3322     * @param parameterName the name of the parameter
3323     * @param x the parameter value
3324     * @exception SQLException if a database access error occurs or
3325     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3326     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3327     * this method
3328     * @see #getParams
3329     */
3330    public void setLong(String parameterName, long x) throws SQLException{
3331         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3332    }
3333 
3334    /**
3335     * Sets the designated parameter to the given Java &lt;code&gt;float&lt;/code&gt; value.
3336     * The driver converts this
3337     * to an SQL &lt;code&gt;FLOAT&lt;/code&gt; value when it sends it to the database.
3338     *
3339     * @param parameterName the name of the parameter
3340     * @param x the parameter value
3341     * @exception SQLException if a database access error occurs or
3342     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3343     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3344     * this method
3345     * @see #getParams
3346     */
3347    public void setFloat(String parameterName, float x) throws SQLException{
3348         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3349    }
3350 
3351    /**
3352     * Sets the designated parameter to the given Java &lt;code&gt;double&lt;/code&gt; value.
3353     * The driver converts this
3354     * to an SQL &lt;code&gt;DOUBLE&lt;/code&gt; value when it sends it to the database.
3355     *
3356     * @param parameterName the name of the parameter
3357     * @param x the parameter value
3358     * @exception SQLException if a database access error occurs or
3359     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3360     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3361     * this method
3362     * @see #getParams
3363     */
3364    public void setDouble(String parameterName, double x) throws SQLException{
3365         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3366    }
3367 
3368    /**
3369     * Sets the designated parameter to the given
3370     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; value.
3371     * The driver converts this to an SQL &lt;code&gt;NUMERIC&lt;/code&gt; value when
3372     * it sends it to the database.
3373     *
3374     * @param parameterName the name of the parameter
3375     * @param x the parameter value
3376     * @exception SQLException if a database access error occurs or
3377     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3378     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3379     * this method
3380     * @see #getParams
3381     */
3382    public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException{
3383         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3384    }
3385 
3386    /**
3387     * Sets the designated parameter to the given Java &lt;code&gt;String&lt;/code&gt; value.
3388     * The driver converts this
3389     * to an SQL &lt;code&gt;VARCHAR&lt;/code&gt; or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value
3390     * (depending on the argument&#39;s
3391     * size relative to the driver&#39;s limits on &lt;code&gt;VARCHAR&lt;/code&gt; values)
3392     * when it sends it to the database.
3393     *
3394     * @param parameterName the name of the parameter
3395     * @param x the parameter value
3396     * @exception SQLException if a database access error occurs or
3397     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3398     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3399     * this method
3400     * @see #getParams
3401     */
3402    public void setString(String parameterName, String x) throws SQLException{
3403         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3404    }
3405 
3406    /**
3407     * Sets the designated parameter to the given Java array of bytes.
3408     * The driver converts this to an SQL &lt;code&gt;VARBINARY&lt;/code&gt; or
3409     * &lt;code&gt;LONGVARBINARY&lt;/code&gt; (depending on the argument&#39;s size relative
3410     * to the driver&#39;s limits on &lt;code&gt;VARBINARY&lt;/code&gt; values) when it sends
3411     * it to the database.
3412     *
3413     * @param parameterName the name of the parameter
3414     * @param x the parameter value
3415     * @exception SQLException if a database access error occurs or
3416     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3417     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3418     * this method
3419     * @see #getParams
3420     */
3421    public void setBytes(String parameterName, byte x[]) throws SQLException{
3422         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3423    }
3424 
3425    /**
3426     * Sets the designated parameter to the given &lt;code&gt;java.sql.Timestamp&lt;/code&gt; value.
3427     * The driver
3428     * converts this to an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value when it sends it to the
3429     * database.
3430     *
3431     * @param parameterName the name of the parameter
3432     * @param x the parameter value
3433     * @exception SQLException if a database access error occurs or
3434     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3435     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3436     * this method
3437     * @see #getParams
3438     */
3439    public void setTimestamp(String parameterName, java.sql.Timestamp x)
3440        throws SQLException{
3441         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3442    }
3443 
3444    /**
3445     * Sets the designated parameter to the given input stream, which will have
3446     * the specified number of bytes.
3447     * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
3448     * parameter, it may be more practical to send it via a
3449     * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
3450     * as needed until end-of-file is reached.  The JDBC driver will
3451     * do any necessary conversion from ASCII to the database char format.
3452     *
3453     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3454     * Java stream object or your own subclass that implements the
3455     * standard interface.
3456     *
3457     * @param parameterName the name of the parameter
3458     * @param x the Java input stream that contains the ASCII parameter value
3459     * @param length the number of bytes in the stream
3460     * @exception SQLException if a database access error occurs or
3461     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3462     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3463     * this method
3464     */
3465    public void setAsciiStream(String parameterName, java.io.InputStream x, int length)
3466        throws SQLException{
3467         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3468    }
3469 
3470    /**
3471     * Sets the designated parameter to the given input stream, which will have
3472     * the specified number of bytes.
3473     * When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt;
3474     * parameter, it may be more practical to send it via a
3475     * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The data will be read from the stream
3476     * as needed until end-of-file is reached.
3477     *
3478     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3479     * Java stream object or your own subclass that implements the
3480     * standard interface.
3481     *
3482     * @param parameterName the name of the parameter
3483     * @param x the java input stream which contains the binary parameter value
3484     * @param length the number of bytes in the stream
3485     * @exception SQLException if a database access error occurs or
3486     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3487     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3488     * this method
3489     */
3490    public void setBinaryStream(String parameterName, java.io.InputStream x,
3491                         int length) throws SQLException{
3492         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3493    }
3494 
3495    /**
3496     * Sets the designated parameter to the given &lt;code&gt;Reader&lt;/code&gt;
3497     * object, which is the given number of characters long.
3498     * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
3499     * parameter, it may be more practical to send it via a
3500     * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
3501     * as needed until end-of-file is reached.  The JDBC driver will
3502     * do any necessary conversion from UNICODE to the database char format.
3503     *
3504     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3505     * Java stream object or your own subclass that implements the
3506     * standard interface.
3507     *
3508     * @param parameterName the name of the parameter
3509     * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object that
3510     *        contains the UNICODE data used as the designated parameter
3511     * @param length the number of characters in the stream
3512     * @exception SQLException if a database access error occurs or
3513     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3514     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3515     * this method
3516     */
3517    public void setCharacterStream(String parameterName,
3518                            java.io.Reader reader,
3519                            int length) throws SQLException{
3520         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3521    }
3522 
3523   /**
3524    * Sets the designated parameter to the given input stream.
3525    * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
3526    * parameter, it may be more practical to send it via a
3527    * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
3528    * as needed until end-of-file is reached.  The JDBC driver will
3529    * do any necessary conversion from ASCII to the database char format.
3530    *
3531    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3532    * Java stream object or your own subclass that implements the
3533    * standard interface.
3534    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3535    * it might be more efficient to use a version of
3536    * &lt;code&gt;setAsciiStream&lt;/code&gt; which takes a length parameter.
3537    *
3538    * @param parameterName the name of the parameter
3539    * @param x the Java input stream that contains the ASCII parameter value
3540    * @exception SQLException if a database access error occurs or
3541    * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3542    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3543    * @since 1.6
3544   */
3545   public void setAsciiStream(String parameterName, java.io.InputStream x)
3546           throws SQLException{
3547         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3548    }
3549 
3550    /**
3551     * Sets the designated parameter to the given input stream.
3552     * When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt;
3553     * parameter, it may be more practical to send it via a
3554     * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The data will be read from the
3555     * stream as needed until end-of-file is reached.
3556     *
3557     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3558     * Java stream object or your own subclass that implements the
3559     * standard interface.
3560     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3561     * it might be more efficient to use a version of
3562     * &lt;code&gt;setBinaryStream&lt;/code&gt; which takes a length parameter.
3563     *
3564     * @param parameterName the name of the parameter
3565     * @param x the java input stream which contains the binary parameter value
3566     * @exception SQLException if a database access error occurs or
3567     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3568     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3569     * @since 1.6
3570     */
3571    public void setBinaryStream(String parameterName, java.io.InputStream x)
3572    throws SQLException{
3573         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3574    }
3575 
3576    /**
3577     * Sets the designated parameter to the given &lt;code&gt;Reader&lt;/code&gt;
3578     * object.
3579     * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
3580     * parameter, it may be more practical to send it via a
3581     * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
3582     * as needed until end-of-file is reached.  The JDBC driver will
3583     * do any necessary conversion from UNICODE to the database char format.
3584     *
3585     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3586     * Java stream object or your own subclass that implements the
3587     * standard interface.
3588     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3589     * it might be more efficient to use a version of
3590     * &lt;code&gt;setCharacterStream&lt;/code&gt; which takes a length parameter.
3591     *
3592     * @param parameterName the name of the parameter
3593     * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object that contains the
3594     *        Unicode data
3595     * @exception SQLException if a database access error occurs or
3596     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3597     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3598     * @since 1.6
3599     */
3600    public void setCharacterStream(String parameterName,
3601                          java.io.Reader reader) throws SQLException{
3602         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3603    }
3604 
3605  /**
3606   * Sets the designated parameter in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
3607   * to a &lt;code&gt;Reader&lt;/code&gt; object. The
3608   * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
3609   * driver does the necessary conversion from Java character format to
3610   * the national character set in the database.
3611   *
3612   * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3613   * Java stream object or your own subclass that implements the
3614   * standard interface.
3615   * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3616   * it might be more efficient to use a version of
3617   * &lt;code&gt;setNCharacterStream&lt;/code&gt; which takes a length parameter.
3618   *
3619   * @param parameterIndex of the first parameter is 1, the second is 2, ...
3620   * @param value the parameter value
3621   * @throws SQLException if the driver does not support national
3622   *         character sets;  if the driver can detect that a data conversion
3623   *  error could occur ; if a database access error occurs; or
3624   * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
3625   * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3626   * @since 1.6
3627   */
3628   public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException{
3629         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3630    }
3631 
3632    /**
3633     * Sets the value of the designated parameter with the given object. The second
3634     * argument must be an object type; for integral values, the
3635     * &lt;code&gt;java.lang&lt;/code&gt; equivalent objects should be used.
3636     *
3637     * &lt;p&gt;The given Java object will be converted to the given targetSqlType
3638     * before being sent to the database.
3639     *
3640     * If the object has a custom mapping (is of a class implementing the
3641     * interface &lt;code&gt;SQLData&lt;/code&gt;),
3642     * the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write it
3643     * to the SQL data stream.
3644     * If, on the other hand, the object is of a class implementing
3645     * &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;,  &lt;code&gt;NClob&lt;/code&gt;,
3646     *  &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;,
3647     * or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a
3648     * value of the corresponding SQL type.
3649     * &lt;P&gt;
3650     * Note that this method may be used to pass database-
3651     * specific abstract data types.
3652     *
3653     * @param parameterName the name of the parameter
3654     * @param x the object containing the input parameter value
3655     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
3656     * sent to the database. The scale argument may further qualify this type.
3657     * @param scale for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types,
3658     *          this is the number of digits after the decimal point.  For all other
3659     *          types, this value will be ignored.
3660     * @exception SQLException if a database access error occurs or
3661     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3662     * @exception SQLFeatureNotSupportedException if &lt;code&gt;targetSqlType&lt;/code&gt; is
3663     * a &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;BLOB&lt;/code&gt;, &lt;code&gt;CLOB&lt;/code&gt;,
3664     * &lt;code&gt;DATALINK&lt;/code&gt;, &lt;code&gt;JAVA_OBJECT&lt;/code&gt;, &lt;code&gt;NCHAR&lt;/code&gt;,
3665     * &lt;code&gt;NCLOB&lt;/code&gt;, &lt;code&gt;NVARCHAR&lt;/code&gt;, &lt;code&gt;LONGNVARCHAR&lt;/code&gt;,
3666     *  &lt;code&gt;REF&lt;/code&gt;, &lt;code&gt;ROWID&lt;/code&gt;, &lt;code&gt;SQLXML&lt;/code&gt;
3667     * or  &lt;code&gt;STRUCT&lt;/code&gt; data type and the JDBC driver does not support
3668     * this data type
3669     * @see Types
3670     * @see #getParams
3671     */
3672    public void setObject(String parameterName, Object x, int targetSqlType, int scale)
3673        throws SQLException{
3674         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3675    }
3676 
3677    /**
3678     * Sets the value of the designated parameter with the given object.
3679     * This method is like the method &lt;code&gt;setObject&lt;/code&gt;
3680     * above, except that it assumes a scale of zero.
3681     *
3682     * @param parameterName the name of the parameter
3683     * @param x the object containing the input parameter value
3684     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
3685     *                      sent to the database
3686     * @exception SQLException if a database access error occurs or
3687     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3688     * @exception SQLFeatureNotSupportedException if &lt;code&gt;targetSqlType&lt;/code&gt; is
3689     * a &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;BLOB&lt;/code&gt;, &lt;code&gt;CLOB&lt;/code&gt;,
3690     * &lt;code&gt;DATALINK&lt;/code&gt;, &lt;code&gt;JAVA_OBJECT&lt;/code&gt;, &lt;code&gt;NCHAR&lt;/code&gt;,
3691     * &lt;code&gt;NCLOB&lt;/code&gt;, &lt;code&gt;NVARCHAR&lt;/code&gt;, &lt;code&gt;LONGNVARCHAR&lt;/code&gt;,
3692     *  &lt;code&gt;REF&lt;/code&gt;, &lt;code&gt;ROWID&lt;/code&gt;, &lt;code&gt;SQLXML&lt;/code&gt;
3693     * or  &lt;code&gt;STRUCT&lt;/code&gt; data type and the JDBC driver does not support
3694     * this data type
3695     * @see #getParams
3696     */
3697    public void setObject(String parameterName, Object x, int targetSqlType)
3698        throws SQLException{
3699         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3700    }
3701 
3702   /**
3703    * Sets the value of the designated parameter with the given object.
3704    * The second parameter must be of type &lt;code&gt;Object&lt;/code&gt;; therefore, the
3705    * &lt;code&gt;java.lang&lt;/code&gt; equivalent objects should be used for built-in types.
3706    *
3707    * &lt;p&gt;The JDBC specification specifies a standard mapping from
3708    * Java &lt;code&gt;Object&lt;/code&gt; types to SQL types.  The given argument
3709    * will be converted to the corresponding SQL type before being
3710    * sent to the database.
3711    *
3712    * &lt;p&gt;Note that this method may be used to pass database-
3713    * specific abstract data types, by using a driver-specific Java
3714    * type.
3715    *
3716    * If the object is of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;,
3717    * the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt;
3718    * to write it to the SQL data stream.
3719    * If, on the other hand, the object is of a class implementing
3720    * &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;,  &lt;code&gt;NClob&lt;/code&gt;,
3721    *  &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;,
3722    * or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a
3723    * value of the corresponding SQL type.
3724    * &lt;P&gt;
3725    * This method throws an exception if there is an ambiguity, for example, if the
3726    * object is of a class implementing more than one of the interfaces named above.
3727    *
3728    * @param parameterName the name of the parameter
3729    * @param x the object containing the input parameter value
3730    * @exception SQLException if a database access error occurs,
3731    * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt; or if the given
3732    *            &lt;code&gt;Object&lt;/code&gt; parameter is ambiguous
3733    * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3734    * this method
3735    * @see #getParams
3736    */
3737   public void setObject(String parameterName, Object x) throws SQLException{
3738         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3739    }
3740 
3741    /**
3742     * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.
3743     * The &lt;code&gt;InputStream&lt;/code&gt; must contain  the number
3744     * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
3745     * generated when the &lt;code&gt;PreparedStatement&lt;/code&gt; is executed.
3746     * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream, int)&lt;/code&gt;
3747     * method because it informs the driver that the parameter value should be
3748     * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
3749     * the driver may have to do extra work to determine whether the parameter
3750     * data should be sent to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
3751     * @param parameterIndex index of the first parameter is 1,
3752     * the second is 2, ...
3753     * @param inputStream An object that contains the data to set the parameter
3754     * value to.
3755     * @param length the number of bytes in the parameter data.
3756     * @throws SQLException if a database access error occurs,
3757     * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;,
3758     * if parameterIndex does not correspond
3759     * to a parameter marker in the SQL statement,  if the length specified
3760     * is less than zero or if the number of bytes in the
3761     * &lt;code&gt;InputStream&lt;/code&gt; does not match the specified length.
3762     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3763     *
3764     * @since 1.6
3765     */
3766     public void setBlob(int parameterIndex, InputStream inputStream, long length)
3767        throws SQLException{
3768         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3769    }
3770 
3771    /**
3772     * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.
3773     * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream)&lt;/code&gt;
3774     * method because it informs the driver that the parameter value should be
3775     * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
3776     * the driver may have to do extra work to determine whether the parameter
3777     * data should be sent to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
3778     *
3779     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3780     * it might be more efficient to use a version of
3781     * &lt;code&gt;setBlob&lt;/code&gt; which takes a length parameter.
3782     *
3783     * @param parameterIndex index of the first parameter is 1,
3784     * the second is 2, ...
3785     * @param inputStream An object that contains the data to set the parameter
3786     * value to.
3787     * @throws SQLException if a database access error occurs,
3788     * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt; or
3789     * if parameterIndex does not correspond
3790     * to a parameter marker in the SQL statement,
3791     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3792     *
3793     * @since 1.6
3794     */
3795     public void setBlob(int parameterIndex, InputStream inputStream)
3796        throws SQLException{
3797         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3798     }
3799 
3800     /**
3801      * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.
3802      * The &lt;code&gt;Inputstream&lt;/code&gt; must contain  the number
3803      * of characters specified by length, otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
3804      * generated when the &lt;code&gt;CallableStatement&lt;/code&gt; is executed.
3805      * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream, int)&lt;/code&gt;
3806      * method because it informs the driver that the parameter value should be
3807      * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
3808      * the driver may have to do extra work to determine whether the parameter
3809      * data should be sent to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
3810      *
3811      * @param parameterName the name of the parameter to be set
3812      * the second is 2, ...
3813      *
3814      * @param inputStream An object that contains the data to set the parameter
3815      * value to.
3816      * @param length the number of bytes in the parameter data.
3817      * @throws SQLException  if parameterIndex does not correspond
3818      * to a parameter marker in the SQL statement,  or if the length specified
3819      * is less than zero; if the number of bytes in the &lt;code&gt;InputStream&lt;/code&gt; does not match
3820      * the specified length; if a database access error occurs or
3821      * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3822      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3823      * this method
3824      *
3825      * @since 1.6
3826      */
3827      public void setBlob(String parameterName, InputStream inputStream, long length)
3828         throws SQLException{
3829         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3830    }
3831 
3832    /**
3833     * Sets the designated parameter to the given &lt;code&gt;java.sql.Blob&lt;/code&gt; object.
3834     * The driver converts this to an SQL &lt;code&gt;BLOB&lt;/code&gt; value when it
3835     * sends it to the database.
3836     *
3837     * @param parameterName the name of the parameter
3838     * @param x a &lt;code&gt;Blob&lt;/code&gt; object that maps an SQL &lt;code&gt;BLOB&lt;/code&gt; value
3839     * @exception SQLException if a database access error occurs or
3840     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3841     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3842     * this method
3843     * @since 1.6
3844     */
3845    public void setBlob (String parameterName, Blob x) throws SQLException{
3846         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3847    }
3848 
3849    /**
3850     * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.
3851     * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream)&lt;/code&gt;
3852     * method because it informs the driver that the parameter value should be
3853     * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
3854     * the driver may have to do extra work to determine whether the parameter
3855     * data should be send to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
3856     *
3857     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3858     * it might be more efficient to use a version of
3859     * &lt;code&gt;setBlob&lt;/code&gt; which takes a length parameter.
3860     *
3861     * @param parameterName the name of the parameter
3862     * @param inputStream An object that contains the data to set the parameter
3863     * value to.
3864     * @throws SQLException if a database access error occurs or
3865     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3866     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3867     *
3868     * @since 1.6
3869     */
3870     public void setBlob(String parameterName, InputStream inputStream)
3871        throws SQLException{
3872         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3873     }
3874 
3875    /**
3876     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
3877     * The reader must contain  the number
3878     * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
3879     * generated when the &lt;code&gt;PreparedStatement&lt;/code&gt; is executed.
3880     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
3881     * because it informs the driver that the parameter value should be sent to
3882     * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
3883     * driver may have to do extra work to determine whether the parameter
3884     * data should be sent to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
3885     * @param parameterIndex index of the first parameter is 1, the second is 2, ...
3886     * @param reader An object that contains the data to set the parameter value to.
3887     * @param length the number of characters in the parameter data.
3888     * @throws SQLException if a database access error occurs, this method is called on
3889     * a closed &lt;code&gt;PreparedStatement&lt;/code&gt;, if parameterIndex does not correspond to a parameter
3890     * marker in the SQL statement, or if the length specified is less than zero.
3891     *
3892     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3893     * @since 1.6
3894     */
3895    public void setClob(int parameterIndex, Reader reader, long length)
3896      throws SQLException{
3897         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3898    }
3899 
3900   /**
3901    * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
3902    * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
3903    * because it informs the driver that the parameter value should be sent to
3904    * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
3905    * driver may have to do extra work to determine whether the parameter
3906    * data should be sent to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
3907    *
3908    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3909    * it might be more efficient to use a version of
3910    * &lt;code&gt;setClob&lt;/code&gt; which takes a length parameter.
3911    *
3912    * @param parameterIndex index of the first parameter is 1, the second is 2, ...
3913    * @param reader An object that contains the data to set the parameter value to.
3914    * @throws SQLException if a database access error occurs, this method is called on
3915    * a closed &lt;code&gt;PreparedStatement&lt;/code&gt;or if parameterIndex does not correspond to a parameter
3916    * marker in the SQL statement
3917    *
3918    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3919    * @since 1.6
3920    */
3921    public void setClob(int parameterIndex, Reader reader)
3922      throws SQLException{
3923         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3924    }
3925 
3926    /**
3927     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
3928     * The &lt;code&gt;reader&lt;/code&gt; must contain  the number
3929     * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
3930     * generated when the &lt;code&gt;CallableStatement&lt;/code&gt; is executed.
3931     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
3932     * because it informs the driver that the parameter value should be sent to
3933     * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
3934     * driver may have to do extra work to determine whether the parameter
3935     * data should be send to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
3936     * @param parameterName the name of the parameter to be set
3937     * @param reader An object that contains the data to set the parameter value to.
3938     * @param length the number of characters in the parameter data.
3939     * @throws SQLException if parameterIndex does not correspond to a parameter
3940     * marker in the SQL statement; if the length specified is less than zero;
3941     * a database access error occurs or
3942     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3943     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3944     * this method
3945     *
3946     * @since 1.6
3947     */
3948    public void setClob(String parameterName, Reader reader, long length)
3949       throws SQLException {
3950        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3951    }
3952 
3953    /**
3954     * Sets the designated parameter to the given &lt;code&gt;java.sql.Clob&lt;/code&gt; object.
3955     * The driver converts this to an SQL &lt;code&gt;CLOB&lt;/code&gt; value when it
3956     * sends it to the database.
3957     *
3958     * @param parameterName the name of the parameter
3959     * @param x a &lt;code&gt;Clob&lt;/code&gt; object that maps an SQL &lt;code&gt;CLOB&lt;/code&gt; value
3960     * @exception SQLException if a database access error occurs or
3961     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3962     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3963     * this method
3964     * @since 1.6
3965     */
3966    public void setClob (String parameterName, Clob x) throws SQLException {
3967        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3968    }
3969 
3970    /**
3971     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
3972     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
3973     * because it informs the driver that the parameter value should be sent to
3974     * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
3975     * driver may have to do extra work to determine whether the parameter
3976     * data should be send to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
3977     *
3978     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3979     * it might be more efficient to use a version of
3980     * &lt;code&gt;setClob&lt;/code&gt; which takes a length parameter.
3981     *
3982     * @param parameterName the name of the parameter
3983     * @param reader An object that contains the data to set the parameter value to.
3984     * @throws SQLException if a database access error occurs or this method is called on
3985     * a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3986     *
3987     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3988     * @since 1.6
3989     */
3990     public void setClob(String parameterName, Reader reader) throws SQLException {
3991         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3992     }
3993 
3994    /**
3995     * Sets the designated parameter to the given &lt;code&gt;java.sql.Date&lt;/code&gt; value
3996     * using the default time zone of the virtual machine that is running
3997     * the application.
3998     * The driver converts this
3999     * to an SQL &lt;code&gt;DATE&lt;/code&gt; value when it sends it to the database.
4000     *
4001     * @param parameterName the name of the parameter
4002     * @param x the parameter value
4003     * @exception SQLException if a database access error occurs or
4004     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4005     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
4006     * this method
4007     * @see #getParams
4008     */
4009    public void setDate(String parameterName, java.sql.Date x)
4010            throws SQLException {
4011        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4012    }
4013 
4014    /**
4015     * Sets the designated parameter to the given &lt;code&gt;java.sql.Date&lt;/code&gt; value,
4016     * using the given &lt;code&gt;Calendar&lt;/code&gt; object.  The driver uses
4017     * the &lt;code&gt;Calendar&lt;/code&gt; object to construct an SQL &lt;code&gt;DATE&lt;/code&gt; value,
4018     * which the driver then sends to the database.  With a
4019     * a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the date
4020     * taking into account a custom timezone.  If no
4021     * &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the default
4022     * timezone, which is that of the virtual machine running the application.
4023     *
4024     * @param parameterName the name of the parameter
4025     * @param x the parameter value
4026     * @param cal the &lt;code&gt;Calendar&lt;/code&gt; object the driver will use
4027     *            to construct the date
4028     * @exception SQLException if a database access error occurs or
4029     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4030     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
4031     * this method
4032     * @see #getParams
4033     */
4034    public void setDate(String parameterName, java.sql.Date x, Calendar cal)
4035            throws SQLException {
4036         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4037    }
4038 
4039    /**
4040     * Sets the designated parameter to the given &lt;code&gt;java.sql.Time&lt;/code&gt; value.
4041     * The driver converts this
4042     * to an SQL &lt;code&gt;TIME&lt;/code&gt; value when it sends it to the database.
4043     *
4044     * @param parameterName the name of the parameter
4045     * @param x the parameter value
4046     * @exception SQLException if a database access error occurs or
4047     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4048     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
4049     * this method
4050     * @see #getParams
4051     */
4052    public void setTime(String parameterName, java.sql.Time x)
4053            throws SQLException {
4054         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4055    }
4056 
4057    /**
4058     * Sets the designated parameter to the given &lt;code&gt;java.sql.Time&lt;/code&gt; value,
4059     * using the given &lt;code&gt;Calendar&lt;/code&gt; object.  The driver uses
4060     * the &lt;code&gt;Calendar&lt;/code&gt; object to construct an SQL &lt;code&gt;TIME&lt;/code&gt; value,
4061     * which the driver then sends to the database.  With a
4062     * a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the time
4063     * taking into account a custom timezone.  If no
4064     * &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the default
4065     * timezone, which is that of the virtual machine running the application.
4066     *
4067     * @param parameterName the name of the parameter
4068     * @param x the parameter value
4069     * @param cal the &lt;code&gt;Calendar&lt;/code&gt; object the driver will use
4070     *            to construct the time
4071     * @exception SQLException if a database access error occurs or
4072     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4073     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
4074     * this method
4075     * @see #getParams
4076     */
4077    public void setTime(String parameterName, java.sql.Time x, Calendar cal)
4078            throws SQLException {
4079         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4080    }
4081 
4082    /**
4083     * Sets the designated parameter to the given &lt;code&gt;java.sql.Timestamp&lt;/code&gt; value,
4084     * using the given &lt;code&gt;Calendar&lt;/code&gt; object.  The driver uses
4085     * the &lt;code&gt;Calendar&lt;/code&gt; object to construct an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value,
4086     * which the driver then sends to the database.  With a
4087     * a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the timestamp
4088     * taking into account a custom timezone.  If no
4089     * &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the default
4090     * timezone, which is that of the virtual machine running the application.
4091     *
4092     * @param parameterName the name of the parameter
4093     * @param x the parameter value
4094     * @param cal the &lt;code&gt;Calendar&lt;/code&gt; object the driver will use
4095     *            to construct the timestamp
4096     * @exception SQLException if a database access error occurs or
4097     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4098     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
4099     * this method
4100     * @see #getParams
4101     */
4102    public void setTimestamp(String parameterName, java.sql.Timestamp x, Calendar cal)
4103            throws SQLException {
4104         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4105    }
4106 
4107    /**
4108     * Sets the designated parameter to the given &lt;code&gt;java.sql.SQLXML&lt;/code&gt; object. The driver converts this to an
4109     * SQL &lt;code&gt;XML&lt;/code&gt; value when it sends it to the database.
4110     * @param parameterIndex index of the first parameter is 1, the second is 2, ...
4111     * @param xmlObject a &lt;code&gt;SQLXML&lt;/code&gt; object that maps an SQL &lt;code&gt;XML&lt;/code&gt; value
4112     * @throws SQLException if a database access error occurs, this method
4113     *  is called on a closed result set,
4114     * the &lt;code&gt;java.xml.transform.Result&lt;/code&gt;,
4115     *  &lt;code&gt;Writer&lt;/code&gt; or &lt;code&gt;OutputStream&lt;/code&gt; has not been closed
4116     * for the &lt;code&gt;SQLXML&lt;/code&gt; object  or
4117     *  if there is an error processing the XML value.  The &lt;code&gt;getCause&lt;/code&gt; method
4118     *  of the exception may provide a more detailed exception, for example, if the
4119     *  stream does not contain valid XML.
4120     * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4121     * support this method
4122     * @since 1.6
4123     */
4124    public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
4125        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4126    }
4127 
4128    /**
4129     * Sets the designated parameter to the given &lt;code&gt;java.sql.SQLXML&lt;/code&gt; object. The driver converts this to an
4130     * &lt;code&gt;SQL XML&lt;/code&gt; value when it sends it to the database.
4131     * @param parameterName the name of the parameter
4132     * @param xmlObject a &lt;code&gt;SQLXML&lt;/code&gt; object that maps an &lt;code&gt;SQL XML&lt;/code&gt; value
4133     * @throws SQLException if a database access error occurs, this method
4134     *  is called on a closed result set,
4135     * the &lt;code&gt;java.xml.transform.Result&lt;/code&gt;,
4136     *  &lt;code&gt;Writer&lt;/code&gt; or &lt;code&gt;OutputStream&lt;/code&gt; has not been closed
4137     * for the &lt;code&gt;SQLXML&lt;/code&gt; object  or
4138     *  if there is an error processing the XML value.  The &lt;code&gt;getCause&lt;/code&gt; method
4139     *  of the exception may provide a more detailed exception, for example, if the
4140     *  stream does not contain valid XML.
4141     * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4142     * support this method
4143     * @since 1.6
4144     */
4145    public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {
4146        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4147    }
4148 
4149    /**
4150    * Sets the designated parameter to the given &lt;code&gt;java.sql.RowId&lt;/code&gt; object. The
4151    * driver converts this to a SQL &lt;code&gt;ROWID&lt;/code&gt; value when it sends it
4152    * to the database
4153    *
4154    * @param parameterIndex the first parameter is 1, the second is 2, ...
4155    * @param x the parameter value
4156    * @throws SQLException if a database access error occurs
4157    * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4158    * support this method
4159    *
4160    * @since 1.6
4161    */
4162   public void setRowId(int parameterIndex, RowId x) throws SQLException {
4163       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4164   }
4165 
4166   /**
4167    * Sets the designated parameter to the given &lt;code&gt;java.sql.RowId&lt;/code&gt; object. The
4168    * driver converts this to a SQL &lt;code&gt;ROWID&lt;/code&gt; when it sends it to the
4169    * database.
4170    *
4171    * @param parameterName the name of the parameter
4172    * @param x the parameter value
4173    * @throws SQLException if a database access error occurs
4174    * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4175    * support this method
4176    * @since 1.6
4177    */
4178   public void setRowId(String parameterName, RowId x) throws SQLException {
4179       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4180   }
4181 
4182   /**
4183    * Sets the designated parameter to the given &lt;code&gt;String&lt;/code&gt; object.
4184    * The driver converts this to a SQL &lt;code&gt;NCHAR&lt;/code&gt; or
4185    * &lt;code&gt;NVARCHAR&lt;/code&gt; or &lt;code&gt;LONGNVARCHAR&lt;/code&gt; value
4186    * (depending on the argument&#39;s
4187    * size relative to the driver&#39;s limits on &lt;code&gt;NVARCHAR&lt;/code&gt; values)
4188    * when it sends it to the database.
4189    *
4190    * @param parameterIndex of the first parameter is 1, the second is 2, ...
4191    * @param value the parameter value
4192    * @throws SQLException if the driver does not support national
4193    * character sets;  if the driver can detect that a data conversion
4194    * error could occur ; or if a database access error occurs
4195    * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4196    * support this method
4197    * @since 1.6
4198    */
4199   public void setNString(int parameterIndex, String value) throws SQLException {
4200       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4201   }
4202 
4203   /**
4204    * Sets the designated parameter to the given &lt;code&gt;String&lt;/code&gt; object.
4205    * The driver converts this to a SQL &lt;code&gt;NCHAR&lt;/code&gt; or
4206    * &lt;code&gt;NVARCHAR&lt;/code&gt; or &lt;code&gt;LONGNVARCHAR&lt;/code&gt;
4207    * @param parameterName the name of the column to be set
4208    * @param value the parameter value
4209    * @throws SQLException if the driver does not support national
4210    * character sets;  if the driver can detect that a data conversion
4211    * error could occur; or if a database access error occurs
4212    * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4213    * support this method
4214    * @since 1.6
4215    */
4216   public void setNString(String parameterName, String value) throws SQLException {
4217      throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4218   }
4219 
4220   /**
4221    * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object. The
4222    * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
4223    * driver does the necessary conversion from Java character format to
4224    * the national character set in the database.
4225    * @param parameterIndex of the first parameter is 1, the second is 2, ...
4226    * @param value the parameter value
4227    * @param length the number of characters in the parameter data.
4228    * @throws SQLException if the driver does not support national
4229    *         character sets;  if the driver can detect that a data conversion
4230    *  error could occur ; or if a database access error occurs
4231    * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4232    * support this method
4233    * @since 1.6
4234    */
4235   public void setNCharacterStream(int parameterIndex, Reader value, long length)
4236           throws SQLException {
4237       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4238   }
4239 
4240   /**
4241    * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object. The
4242    * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
4243    * driver does the necessary conversion from Java character format to
4244    * the national character set in the database.
4245    * @param parameterName the name of the column to be set
4246    * @param value the parameter value
4247    * @param length the number of characters in the parameter data.
4248    * @throws SQLException if the driver does not support national
4249    *         character sets;  if the driver can detect that a data conversion
4250    *  error could occur; or if a database access error occurs
4251    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not
4252    * support this method
4253    * @since 1.6
4254    */
4255   public void setNCharacterStream(String parameterName, Reader value, long length)
4256           throws SQLException {
4257       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4258   }
4259 
4260   /**
4261    * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object. The
4262    * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
4263    * driver does the necessary conversion from Java character format to
4264    * the national character set in the database.
4265    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
4266    * Java stream object or your own subclass that implements the
4267    * standard interface.
4268    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
4269    * it might be more efficient to use a version of
4270    * &lt;code&gt;setNCharacterStream&lt;/code&gt; which takes a length parameter.
4271    *
4272    * @param parameterName the name of the parameter
4273    * @param value the parameter value
4274    * @throws SQLException if the driver does not support national
4275    *         character sets;  if the driver can detect that a data conversion
4276    *  error could occur ; if a database access error occurs; or
4277    * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4278    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
4279    * @since 1.6
4280    */
4281   public void setNCharacterStream(String parameterName, Reader value)
4282           throws SQLException {
4283       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4284    }
4285 
4286    /**
4287     * Sets the designated parameter to a &lt;code&gt;java.sql.NClob&lt;/code&gt; object. The object
4288     * implements the &lt;code&gt;java.sql.NClob&lt;/code&gt; interface. This &lt;code&gt;NClob&lt;/code&gt;
4289     * object maps to a SQL &lt;code&gt;NCLOB&lt;/code&gt;.
4290     * @param parameterName the name of the column to be set
4291     * @param value the parameter value
4292     * @throws SQLException if the driver does not support national
4293     *         character sets;  if the driver can detect that a data conversion
4294     *  error could occur; or if a database access error occurs
4295     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not
4296     * support this method
4297     * @since 1.6
4298     */
4299    public void setNClob(String parameterName, NClob value) throws SQLException {
4300        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4301    }
4302 
4303    /**
4304     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.  The &lt;code&gt;reader&lt;/code&gt; must contain
4305     * the number
4306     * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
4307     * generated when the &lt;code&gt;CallableStatement&lt;/code&gt; is executed.
4308     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
4309     * because it informs the driver that the parameter value should be sent to
4310     * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
4311     * driver may have to do extra work to determine whether the parameter
4312     * data should be send to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
4313     *
4314     * @param parameterName the name of the parameter to be set
4315     * @param reader An object that contains the data to set the parameter value to.
4316     * @param length the number of characters in the parameter data.
4317     * @throws SQLException if parameterIndex does not correspond to a parameter
4318     * marker in the SQL statement; if the length specified is less than zero;
4319     * if the driver does not support national
4320     *         character sets;  if the driver can detect that a data conversion
4321     *  error could occur; if a database access error occurs or
4322     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4323     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
4324     * this method
4325     * @since 1.6
4326     */
4327    public void setNClob(String parameterName, Reader reader, long length)
4328            throws SQLException {
4329        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4330    }
4331 
4332    /**
4333     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
4334     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
4335     * because it informs the driver that the parameter value should be sent to
4336     * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
4337     * driver may have to do extra work to determine whether the parameter
4338     * data should be send to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
4339     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
4340     * it might be more efficient to use a version of
4341     * &lt;code&gt;setNClob&lt;/code&gt; which takes a length parameter.
4342     *
4343     * @param parameterName the name of the parameter
4344     * @param reader An object that contains the data to set the parameter value to.
4345     * @throws SQLException if the driver does not support national character sets;
4346     * if the driver can detect that a data conversion
4347     *  error could occur;  if a database access error occurs or
4348     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4349     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
4350     *
4351     * @since 1.6
4352     */
4353    public void setNClob(String parameterName, Reader reader) throws SQLException {
4354        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4355    }
4356 
4357    /**
4358     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.  The reader must contain  the number
4359     * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
4360     * generated when the &lt;code&gt;PreparedStatement&lt;/code&gt; is executed.
4361     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
4362     * because it informs the driver that the parameter value should be sent to
4363     * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
4364     * driver may have to do extra work to determine whether the parameter
4365     * data should be sent to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
4366     * @param parameterIndex index of the first parameter is 1, the second is 2, ...
4367     * @param reader An object that contains the data to set the parameter value to.
4368     * @param length the number of characters in the parameter data.
4369     * @throws SQLException if parameterIndex does not correspond to a parameter
4370     * marker in the SQL statement; if the length specified is less than zero;
4371     * if the driver does not support national character sets;
4372     * if the driver can detect that a data conversion
4373     *  error could occur;  if a database access error occurs or
4374     * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
4375     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not
4376     * support this method
4377     *
4378     * @since 1.6
4379     */
4380    public void setNClob(int parameterIndex, Reader reader, long length)
4381            throws SQLException {
4382        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4383    }
4384 
4385    /**
4386     * Sets the designated parameter to a &lt;code&gt;java.sql.NClob&lt;/code&gt; object. The driver converts this oa
4387     * SQL &lt;code&gt;NCLOB&lt;/code&gt; value when it sends it to the database.
4388     * @param parameterIndex of the first parameter is 1, the second is 2, ...
4389     * @param value the parameter value
4390     * @throws SQLException if the driver does not support national
4391     *         character sets;  if the driver can detect that a data conversion
4392     *  error could occur ; or if a database access error occurs
4393     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not
4394     * support this method
4395     * @since 1.6
4396     */
4397    public void setNClob(int parameterIndex, NClob value) throws SQLException {
4398         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4399    }
4400 
4401    /**
4402     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
4403     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
4404     * because it informs the driver that the parameter value should be sent to
4405     * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
4406     * driver may have to do extra work to determine whether the parameter
4407     * data should be sent to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
4408     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
4409     * it might be more efficient to use a version of
4410     * &lt;code&gt;setNClob&lt;/code&gt; which takes a length parameter.
4411     *
4412     * @param parameterIndex index of the first parameter is 1, the second is 2, ...
4413     * @param reader An object that contains the data to set the parameter value to.
4414     * @throws SQLException if parameterIndex does not correspond to a parameter
4415     * marker in the SQL statement;
4416     * if the driver does not support national character sets;
4417     * if the driver can detect that a data conversion
4418     *  error could occur;  if a database access error occurs or
4419     * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
4420     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
4421     *
4422     * @since 1.6
4423     */
4424    public void setNClob(int parameterIndex, Reader reader)throws SQLException {
4425        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4426    }
4427 
4428    /**
4429     * Sets the designated parameter to the given &lt;code&gt;java.net.URL&lt;/code&gt; value.
4430     * The driver converts this to an SQL &lt;code&gt;DATALINK&lt;/code&gt; value
4431     * when it sends it to the database.
4432     *
4433     * @param parameterIndex the first parameter is 1, the second is 2, ...
4434     * @param x the &lt;code&gt;java.net.URL&lt;/code&gt; object to be set
4435     * @exception SQLException if a database access error occurs or
4436     * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
4437     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
4438     */
4439    public void setURL(int parameterIndex, java.net.URL x) throws SQLException {
4440        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4441    }
4442 
4443    static final long serialVersionUID = 4886719666485113312L;
4444 
4445 } //end class
    </pre>
  </body>
</html>
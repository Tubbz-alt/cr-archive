<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.sql.rowset/share/classes/javax/sql/rowset/serial/SerialBlob.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.sql.rowset.serial;
 27 
 28 import java.sql.*;
 29 import java.io.*;
 30 import java.lang.reflect.*;
 31 import java.util.Arrays;
 32 
 33 
 34 /**
 35  * A serialized mapping in the Java programming language of an SQL
 36  * &lt;code&gt;BLOB&lt;/code&gt; value.
 37  * &lt;P&gt;
 38  * The &lt;code&gt;SerialBlob&lt;/code&gt; class provides a constructor for creating
 39  * an instance from a &lt;code&gt;Blob&lt;/code&gt; object.  Note that the
 40  * &lt;code&gt;Blob&lt;/code&gt;
 41  * object should have brought the SQL &lt;code&gt;BLOB&lt;/code&gt; value&#39;s data over
 42  * to the client before a &lt;code&gt;SerialBlob&lt;/code&gt; object
 43  * is constructed from it.  The data of an SQL &lt;code&gt;BLOB&lt;/code&gt; value can
 44  * be materialized on the client as an array of bytes (using the method
 45  * &lt;code&gt;Blob.getBytes&lt;/code&gt;) or as a stream of uninterpreted bytes
 46  * (using the method &lt;code&gt;Blob.getBinaryStream&lt;/code&gt;).
 47  * &lt;P&gt;
 48  * &lt;code&gt;SerialBlob&lt;/code&gt; methods make it possible to make a copy of a
 49  * &lt;code&gt;SerialBlob&lt;/code&gt; object as an array of bytes or as a stream.
 50  * They also make it possible to locate a given pattern of bytes or a
 51  * &lt;code&gt;Blob&lt;/code&gt; object within a &lt;code&gt;SerialBlob&lt;/code&gt; object
 52  * and to update or truncate a &lt;code&gt;Blob&lt;/code&gt; object.
 53  *
 54  * &lt;h2&gt; Thread safety &lt;/h2&gt;
 55  *
 56  * &lt;p&gt; A SerialBlob is not safe for use by multiple concurrent threads.  If a
 57  * SerialBlob is to be used by more than one thread then access to the SerialBlob
 58  * should be controlled by appropriate synchronization.
 59  *
 60  * @author Jonathan Bruce
 61  * @since 1.5
 62  */
 63 public class SerialBlob implements Blob, Serializable, Cloneable {
 64 
 65     /**
 66      * A serialized array of uninterpreted bytes representing the
 67      * value of this &lt;code&gt;SerialBlob&lt;/code&gt; object.
 68      * @serial
 69      */
 70     private byte[] buf;
 71 
 72     /**
 73      * The internal representation of the &lt;code&gt;Blob&lt;/code&gt; object on which this
 74      * &lt;code&gt;SerialBlob&lt;/code&gt; object is based.
 75      */
 76     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable; checked in writeObject
 77     private Blob blob;
 78 
 79     /**
 80      * The number of bytes in this &lt;code&gt;SerialBlob&lt;/code&gt; object&#39;s
 81      * array of bytes.
 82      * @serial
 83      */
 84     private long len;
 85 
 86     /**
 87      * The original number of bytes in this &lt;code&gt;SerialBlob&lt;/code&gt; object&#39;s
 88      * array of bytes when it was first established.
 89      * @serial
 90      */
 91     private long origLen;
 92 
 93     /**
 94      * Constructs a &lt;code&gt;SerialBlob&lt;/code&gt; object that is a serialized version of
 95      * the given &lt;code&gt;byte&lt;/code&gt; array.
 96      * &lt;p&gt;
 97      * The new &lt;code&gt;SerialBlob&lt;/code&gt; object is initialized with the data from the
 98      * &lt;code&gt;byte&lt;/code&gt; array, thus allowing disconnected &lt;code&gt;RowSet&lt;/code&gt;
 99      * objects to establish serialized &lt;code&gt;Blob&lt;/code&gt; objects without
100      * touching the data source.
101      *
102      * @param b the &lt;code&gt;byte&lt;/code&gt; array containing the data for the
103      *        &lt;code&gt;Blob&lt;/code&gt; object to be serialized
104      * @throws SerialException if an error occurs during serialization
105      * @throws SQLException if a SQL errors occurs
106      */
107     public SerialBlob(byte[] b)
108             throws SerialException, SQLException {
109 
110         len = b.length;
111         buf = new byte[(int)len];
112         for(int i = 0; i &lt; len; i++) {
113             buf[i] = b[i];
114         }
115         origLen = len;
116     }
117 
118 
119     /**
120      * Constructs a &lt;code&gt;SerialBlob&lt;/code&gt; object that is a serialized
121      * version of the given &lt;code&gt;Blob&lt;/code&gt; object.
122      * &lt;P&gt;
123      * The new &lt;code&gt;SerialBlob&lt;/code&gt; object is initialized with the
124      * data from the &lt;code&gt;Blob&lt;/code&gt; object; therefore, the
125      * &lt;code&gt;Blob&lt;/code&gt; object should have previously brought the
126      * SQL &lt;code&gt;BLOB&lt;/code&gt; value&#39;s data over to the client from
127      * the database. Otherwise, the new &lt;code&gt;SerialBlob&lt;/code&gt; object
128      * will contain no data.
129      *
130      * @param blob the &lt;code&gt;Blob&lt;/code&gt; object from which this
131      *     &lt;code&gt;SerialBlob&lt;/code&gt; object is to be constructed;
132      *     cannot be null.
133      * @throws SerialException if an error occurs during serialization
134      * @throws SQLException if the &lt;code&gt;Blob&lt;/code&gt; passed to this
135      *     to this constructor is a &lt;code&gt;null&lt;/code&gt;.
136      * @see java.sql.Blob
137      */
138     public SerialBlob (Blob blob)
139             throws SerialException, SQLException {
140 
141         if (blob == null) {
142             throw new SQLException(
143                     &quot;Cannot instantiate a SerialBlob object with a null Blob object&quot;);
144         }
145 
146         len = blob.length();
147         buf = blob.getBytes(1, (int)len );
148         this.blob = blob;
149         origLen = len;
150     }
151 
152     /**
153      * Copies the specified number of bytes, starting at the given
154      * position, from this &lt;code&gt;SerialBlob&lt;/code&gt; object to
155      * another array of bytes.
156      * &lt;P&gt;
157      * Note that if the given number of bytes to be copied is larger than
158      * the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object&#39;s array of
159      * bytes, the given number will be shortened to the array&#39;s length.
160      *
161      * @param pos the ordinal position of the first byte in this
162      *            &lt;code&gt;SerialBlob&lt;/code&gt; object to be copied;
163      *            numbering starts at &lt;code&gt;1&lt;/code&gt;; must not be less
164      *            than &lt;code&gt;1&lt;/code&gt; and must be less than or equal
165      *            to the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object
166      * @param length the number of bytes to be copied
167      * @return an array of bytes that is a copy of a region of this
168      *         &lt;code&gt;SerialBlob&lt;/code&gt; object, starting at the given
169      *         position and containing the given number of consecutive bytes
170      * @throws SerialException if the given starting position is out of bounds;
171      * if {@code free} had previously been called on this object
172      */
173     public byte[] getBytes(long pos, int length) throws SerialException {
174         isValid();
175         if (length &gt; len) {
176             length = (int)len;
177         }
178 
179         if (pos &lt; 1 || len - pos &lt; 0 ) {
180             throw new SerialException(&quot;Invalid arguments: position cannot be &quot;
181                     + &quot;less than 1 or greater than the length of the SerialBlob&quot;);
182         }
183 
184         pos--; // correct pos to array index
185 
186         byte[] b = new byte[length];
187 
188         for (int i = 0; i &lt; length; i++) {
189             b[i] = this.buf[(int)pos];
190             pos++;
191         }
192         return b;
193     }
194 
195     /**
196      * Retrieves the number of bytes in this &lt;code&gt;SerialBlob&lt;/code&gt;
197      * object&#39;s array of bytes.
198      *
199      * @return a &lt;code&gt;long&lt;/code&gt; indicating the length in bytes of this
200      *         &lt;code&gt;SerialBlob&lt;/code&gt; object&#39;s array of bytes
201      * @throws SerialException if an error occurs;
202      * if {@code free} had previously been called on this object
203      */
204     public long length() throws SerialException {
205         isValid();
206         return len;
207     }
208 
209     /**
210      * Returns this &lt;code&gt;SerialBlob&lt;/code&gt; object as an input stream.
211      * Unlike the related method, &lt;code&gt;setBinaryStream&lt;/code&gt;,
212      * a stream is produced regardless of whether the &lt;code&gt;SerialBlob&lt;/code&gt;
213      * was created with a &lt;code&gt;Blob&lt;/code&gt; object or a &lt;code&gt;byte&lt;/code&gt; array.
214      *
215      * @return a &lt;code&gt;java.io.InputStream&lt;/code&gt; object that contains
216      *         this &lt;code&gt;SerialBlob&lt;/code&gt; object&#39;s array of bytes
217      * @throws SerialException if an error occurs;
218      * if {@code free} had previously been called on this object
219      * @see #setBinaryStream
220      */
221     public java.io.InputStream getBinaryStream() throws SerialException {
222         isValid();
223         InputStream stream = new ByteArrayInputStream(buf);
224         return stream;
225     }
226 
227     /**
228      * Returns the position in this &lt;code&gt;SerialBlob&lt;/code&gt; object where
229      * the given pattern of bytes begins, starting the search at the
230      * specified position.
231      *
232      * @param pattern the pattern of bytes for which to search
233      * @param start the position of the byte in this
234      *              &lt;code&gt;SerialBlob&lt;/code&gt; object from which to begin
235      *              the search; the first position is &lt;code&gt;1&lt;/code&gt;;
236      *              must not be less than &lt;code&gt;1&lt;/code&gt; nor greater than
237      *              the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object
238      * @return the position in this &lt;code&gt;SerialBlob&lt;/code&gt; object
239      *         where the given pattern begins, starting at the specified
240      *         position; &lt;code&gt;-1&lt;/code&gt; if the pattern is not found
241      *         or the given starting position is out of bounds; position
242      *         numbering for the return value starts at &lt;code&gt;1&lt;/code&gt;
243      * @throws SerialException if an error occurs when serializing the blob;
244      * if {@code free} had previously been called on this object
245      * @throws SQLException if there is an error accessing the &lt;code&gt;BLOB&lt;/code&gt;
246      *         value from the database
247      */
248     public long position(byte[] pattern, long start)
249             throws SerialException, SQLException {
250 
251         isValid();
252         if (start &lt; 1 || start &gt; len) {
253             return -1;
254         }
255 
256         int pos = (int)start-1; // internally Blobs are stored as arrays.
257         int i = 0;
258         long patlen = pattern.length;
259 
260         while (pos &lt; len) {
261             if (pattern[i] == buf[pos]) {
262                 if (i + 1 == patlen) {
263                     return (pos + 1) - (patlen - 1);
264                 }
265                 i++; pos++; // increment pos, and i
266             } else if (pattern[i] != buf[pos]) {
267                 pos++; // increment pos only
268             }
269         }
270         return -1; // not found
271     }
272 
273     /**
274      * Returns the position in this &lt;code&gt;SerialBlob&lt;/code&gt; object where
275      * the given &lt;code&gt;Blob&lt;/code&gt; object begins, starting the search at the
276      * specified position.
277      *
278      * @param pattern the &lt;code&gt;Blob&lt;/code&gt; object for which to search;
279      * @param start the position of the byte in this
280      *              &lt;code&gt;SerialBlob&lt;/code&gt; object from which to begin
281      *              the search; the first position is &lt;code&gt;1&lt;/code&gt;;
282      *              must not be less than &lt;code&gt;1&lt;/code&gt; nor greater than
283      *              the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object
284      * @return the position in this &lt;code&gt;SerialBlob&lt;/code&gt; object
285      *         where the given &lt;code&gt;Blob&lt;/code&gt; object begins, starting
286      *         at the specified position; &lt;code&gt;-1&lt;/code&gt; if the pattern is
287      *         not found or the given starting position is out of bounds;
288      *         position numbering for the return value starts at &lt;code&gt;1&lt;/code&gt;
289      * @throws SerialException if an error occurs when serializing the blob;
290      * if {@code free} had previously been called on this object
291      * @throws SQLException if there is an error accessing the &lt;code&gt;BLOB&lt;/code&gt;
292      *         value from the database
293      */
294     public long position(Blob pattern, long start)
295             throws SerialException, SQLException {
296         isValid();
297         return position(pattern.getBytes(1, (int)(pattern.length())), start);
298     }
299 
300     /**
301      * Writes the given array of bytes to the &lt;code&gt;BLOB&lt;/code&gt; value that
302      * this &lt;code&gt;Blob&lt;/code&gt; object represents, starting at position
303      * &lt;code&gt;pos&lt;/code&gt;, and returns the number of bytes written.
304      *
305      * @param pos the position in the SQL &lt;code&gt;BLOB&lt;/code&gt; value at which
306      *     to start writing. The first position is &lt;code&gt;1&lt;/code&gt;;
307      *     must not be less than &lt;code&gt;1&lt;/code&gt; nor greater than
308      *     the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object.
309      * @param bytes the array of bytes to be written to the &lt;code&gt;BLOB&lt;/code&gt;
310      *        value that this &lt;code&gt;Blob&lt;/code&gt; object represents
311      * @return the number of bytes written
312      * @throws SerialException if there is an error accessing the
313      *     &lt;code&gt;BLOB&lt;/code&gt; value; or if an invalid position is set; if an
314      *     invalid offset value is set;
315      * if {@code free} had previously been called on this object
316      * @throws SQLException if there is an error accessing the &lt;code&gt;BLOB&lt;/code&gt;
317      *         value from the database
318      * @see #getBytes
319      */
320     public int setBytes(long pos, byte[] bytes)
321             throws SerialException, SQLException {
322         return setBytes(pos, bytes, 0, bytes.length);
323     }
324 
325     /**
326      * Writes all or part of the given &lt;code&gt;byte&lt;/code&gt; array to the
327      * &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt; object represents
328      * and returns the number of bytes written.
329      * Writing starts at position &lt;code&gt;pos&lt;/code&gt; in the &lt;code&gt;BLOB&lt;/code&gt;
330      * value; &lt;i&gt;len&lt;/i&gt; bytes from the given byte array are written.
331      *
332      * @param pos the position in the &lt;code&gt;BLOB&lt;/code&gt; object at which
333      *     to start writing. The first position is &lt;code&gt;1&lt;/code&gt;;
334      *     must not be less than &lt;code&gt;1&lt;/code&gt; nor greater than
335      *     the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object.
336      * @param bytes the array of bytes to be written to the &lt;code&gt;BLOB&lt;/code&gt;
337      *     value
338      * @param offset the offset in the &lt;code&gt;byte&lt;/code&gt; array at which
339      *     to start reading the bytes. The first offset position is
340      *     &lt;code&gt;0&lt;/code&gt;; must not be less than &lt;code&gt;0&lt;/code&gt; nor greater
341      *     than the length of the &lt;code&gt;byte&lt;/code&gt; array
342      * @param length the number of bytes to be written to the
343      *     &lt;code&gt;BLOB&lt;/code&gt; value from the array of bytes &lt;i&gt;bytes&lt;/i&gt;.
344      *
345      * @return the number of bytes written
346      * @throws SerialException if there is an error accessing the
347      *     &lt;code&gt;BLOB&lt;/code&gt; value; if an invalid position is set; if an
348      *     invalid offset value is set; if number of bytes to be written
349      *     is greater than the &lt;code&gt;SerialBlob&lt;/code&gt; length; or the combined
350      *     values of the length and offset is greater than the Blob buffer;
351      * if {@code free} had previously been called on this object
352      * @throws SQLException if there is an error accessing the &lt;code&gt;BLOB&lt;/code&gt;
353      *         value from the database.
354      * @see #getBytes
355      */
356     public int setBytes(long pos, byte[] bytes, int offset, int length)
357             throws SerialException, SQLException {
358 
359         isValid();
360         if (offset &lt; 0 || offset &gt; bytes.length) {
361             throw new SerialException(&quot;Invalid offset in byte array set&quot;);
362         }
363 
364         if (pos &lt; 1 || pos &gt; this.length()) {
365             throw new SerialException(&quot;Invalid position in BLOB object set&quot;);
366         }
367 
368         if ((long)(length) &gt; origLen) {
369             throw new SerialException(&quot;Buffer is not sufficient to hold the value&quot;);
370         }
371 
372         if ((length + offset) &gt; bytes.length) {
373             throw new SerialException(&quot;Invalid OffSet. Cannot have combined offset &quot; +
374                     &quot;and length that is greater that the Blob buffer&quot;);
375         }
376 
377         int i = 0;
378         pos--; // correct to array indexing
379         while ( i &lt; length || (offset + i +1) &lt; (bytes.length-offset) ) {
380             this.buf[(int)pos + i] = bytes[offset + i ];
381             i++;
382         }
383         return i;
384     }
385 
386     /**
387      * Retrieves a stream that can be used to write to the &lt;code&gt;BLOB&lt;/code&gt;
388      * value that this &lt;code&gt;Blob&lt;/code&gt; object represents.  The stream begins
389      * at position &lt;code&gt;pos&lt;/code&gt;. This method forwards the
390      * &lt;code&gt;setBinaryStream()&lt;/code&gt; call to the underlying &lt;code&gt;Blob&lt;/code&gt; in
391      * the event that this &lt;code&gt;SerialBlob&lt;/code&gt; object is instantiated with a
392      * &lt;code&gt;Blob&lt;/code&gt;. If this &lt;code&gt;SerialBlob&lt;/code&gt; is instantiated with
393      * a &lt;code&gt;byte&lt;/code&gt; array, a &lt;code&gt;SerialException&lt;/code&gt; is thrown.
394      *
395      * @param pos the position in the &lt;code&gt;BLOB&lt;/code&gt; value at which
396      *        to start writing
397      * @return a &lt;code&gt;java.io.OutputStream&lt;/code&gt; object to which data can
398      *         be written
399      * @throws SQLException if there is an error accessing the
400      *            &lt;code&gt;BLOB&lt;/code&gt; value
401      * @throws SerialException if the SerialBlob in not instantiated with a
402      *     &lt;code&gt;Blob&lt;/code&gt; object that supports &lt;code&gt;setBinaryStream()&lt;/code&gt;;
403      * if {@code free} had previously been called on this object
404      * @see #getBinaryStream
405      */
406     public java.io.OutputStream setBinaryStream(long pos)
407             throws SerialException, SQLException {
408 
409         isValid();
410         if (this.blob != null) {
411             return this.blob.setBinaryStream(pos);
412         } else {
413             throw new SerialException(&quot;Unsupported operation. SerialBlob cannot &quot; +
414                 &quot;return a writable binary stream, unless instantiated with a Blob object &quot; +
415                 &quot;that provides a setBinaryStream() implementation&quot;);
416         }
417     }
418 
419     /**
420      * Truncates the &lt;code&gt;BLOB&lt;/code&gt; value that this &lt;code&gt;Blob&lt;/code&gt;
421      * object represents to be &lt;code&gt;len&lt;/code&gt; bytes in length.
422      *
423      * @param length the length, in bytes, to which the &lt;code&gt;BLOB&lt;/code&gt;
424      *        value that this &lt;code&gt;Blob&lt;/code&gt; object represents should be
425      *        truncated
426      * @throws SerialException if there is an error accessing the Blob value;
427      *     or the length to truncate is greater that the SerialBlob length;
428      * if {@code free} had previously been called on this object
429      */
430     public void truncate(long length) throws SerialException {
431         isValid();
432         if (length &gt; len) {
433             throw new SerialException(
434                     &quot;Length more than what can be truncated&quot;);
435         } else if((int)length == 0) {
436             buf = new byte[0];
437             len = length;
438         } else {
439             len = length;
440             buf = this.getBytes(1, (int)len);
441         }
442     }
443 
444 
445     /**
446      * Returns an
447      * &lt;code&gt;InputStream&lt;/code&gt; object that contains a partial
448      * {@code Blob} value, starting with the byte specified by pos, which is
449      * length bytes in length.
450      *
451      * @param pos the offset to the first byte of the partial value to be
452      * retrieved. The first byte in the {@code Blob} is at position 1
453      * @param length the length in bytes of the partial value to be retrieved
454      * @return
455      * &lt;code&gt;InputStream&lt;/code&gt; through which the partial {@code Blob} value can
456      * be read.
457      * @throws SQLException if pos is less than 1 or if pos is greater than the
458      * number of bytes in the {@code Blob} or if pos + length is greater than
459      * the number of bytes in the {@code Blob}
460      * @throws SerialException if the {@code free} method had been previously
461      * called on this object
462      *
463      * @since 1.6
464      */
465     public InputStream getBinaryStream(long pos, long length) throws SQLException {
466         isValid();
467         if (pos &lt; 1 || pos &gt; this.length()) {
468             throw new SerialException(&quot;Invalid position in BLOB object set&quot;);
469         }
470         if (length &lt; 1 || length &gt; len - pos + 1) {
471             throw new SerialException(
472                     &quot;length is &lt; 1 or pos + length &gt; total number of bytes&quot;);
473         }
474         return new ByteArrayInputStream(buf, (int) pos - 1, (int) length);
475     }
476 
477 
478     /**
479      * This method frees the {@code SerialBlob} object and releases the
480      * resources that it holds. The object is invalid once the {@code free}
481      * method is called. &lt;p&gt; If {@code free} is called multiple times, the
482      * subsequent calls to {@code free} are treated as a no-op. &lt;/P&gt;
483      *
484      * @throws SQLException if an error occurs releasing the Blob&#39;s resources
485      * @since 1.6
486      */
487     public void free() throws SQLException {
488         if (buf != null) {
489             buf = null;
490             if (blob != null) {
491                 blob.free();
492             }
493             blob = null;
494         }
495     }
496 
497     /**
498      * Compares this SerialBlob to the specified object.  The result is {@code
499      * true} if and only if the argument is not {@code null} and is a {@code
500      * SerialBlob} object that represents the same sequence of bytes as this
501      * object.
502      *
503      * @param  obj The object to compare this {@code SerialBlob} against
504      *
505      * @return {@code true} if the given object represents a {@code SerialBlob}
506      *          equivalent to this SerialBlob, {@code false} otherwise
507      *
508      */
509     public boolean equals(Object obj) {
510         if (this == obj) {
511             return true;
512         }
513         if (obj instanceof SerialBlob) {
514             SerialBlob sb = (SerialBlob)obj;
515             if (this.len == sb.len) {
516                 return Arrays.equals(buf, sb.buf);
517             }
518         }
519         return false;
520     }
521 
522     /**
523      * Returns a hash code for this {@code SerialBlob}.
524      * @return  a hash code value for this object.
525      */
526     public int hashCode() {
527        return ((31 + Arrays.hashCode(buf)) * 31 + (int)len) * 31 + (int)origLen;
528     }
529 
530     /**
531      * Returns a clone of this {@code SerialBlob}. The copy will contain a
532      * reference to a clone of the internal byte array, not a reference
533      * to the original internal byte array of this {@code SerialBlob} object.
534      * The underlying {@code Blob} object will be set to null.
535      *
536      * @return  a clone of this SerialBlob
537      */
538     public Object clone() {
539         try {
540             SerialBlob sb = (SerialBlob) super.clone();
541             sb.buf = (buf != null) ? Arrays.copyOf(buf, (int)len) : null;
542             sb.blob = null;
543             return sb;
544         } catch (CloneNotSupportedException ex) {
545             // this shouldn&#39;t happen, since we are Cloneable
546             throw new InternalError();
547         }
548     }
549 
550     /**
551      * readObject is called to restore the state of the SerialBlob from
552      * a stream.
553      */
554     private void readObject(ObjectInputStream s)
555             throws IOException, ClassNotFoundException {
556 
557         ObjectInputStream.GetField fields = s.readFields();
558         byte[] tmp = (byte[])fields.get(&quot;buf&quot;, null);
559         if (tmp == null)
560             throw new InvalidObjectException(&quot;buf is null and should not be!&quot;);
561         buf = tmp.clone();
562         len = fields.get(&quot;len&quot;, 0L);
563         if (buf.length != len)
564             throw new InvalidObjectException(&quot;buf is not the expected size&quot;);
565         origLen = fields.get(&quot;origLen&quot;, 0L);
566         blob = (Blob) fields.get(&quot;blob&quot;, null);
567     }
568 
569     /**
570      * writeObject is called to save the state of the SerialBlob
571      * to a stream.
572      */
573     private void writeObject(ObjectOutputStream s)
574             throws IOException {
575 
576         ObjectOutputStream.PutField fields = s.putFields();
577         fields.put(&quot;buf&quot;, buf);
578         fields.put(&quot;len&quot;, len);
579         fields.put(&quot;origLen&quot;, origLen);
580         // Note: this check to see if it is an instance of Serializable
581         // is for backwards compatibility
582         fields.put(&quot;blob&quot;, blob instanceof Serializable ? blob : null);
583         s.writeFields();
584     }
585 
586     /**
587      * Check to see if this object had previously had its {@code free} method
588      * called
589      *
590      * @throws SerialException
591      */
592     private void isValid() throws SerialException {
593         if (buf == null) {
594             throw new SerialException(&quot;Error: You cannot call a method on a &quot; +
595                     &quot;SerialBlob instance once free() has been called.&quot;);
596         }
597     }
598 
599     /**
600      * The identifier that assists in the serialization of this
601      * {@code SerialBlob} object.
602      */
603     static final long serialVersionUID = -8144641928112860441L;
604 }
    </pre>
  </body>
</html>
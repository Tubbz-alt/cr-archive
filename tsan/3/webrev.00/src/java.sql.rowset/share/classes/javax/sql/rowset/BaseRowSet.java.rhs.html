<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.sql.rowset/share/classes/javax/sql/rowset/BaseRowSet.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javax.sql.rowset;
  27 
  28 import java.sql.*;
  29 import javax.sql.*;
  30 import java.util.*;
  31 import java.io.*;
  32 import java.math.*;
  33 import java.io.Serializable;
  34 
  35 import javax.sql.rowset.serial.*;
  36 
  37 /**
  38  * An abstract class providing a &lt;code&gt;RowSet&lt;/code&gt; object with its basic functionality.
  39  * The basic functions include having properties and sending event notifications,
  40  * which all JavaBeans&amp;trade; components must implement.
  41  *
  42  * &lt;h2&gt;1.0 Overview&lt;/h2&gt;
  43  * The &lt;code&gt;BaseRowSet&lt;/code&gt; class provides the core functionality
  44  * for all &lt;code&gt;RowSet&lt;/code&gt; implementations,
  45  * and all standard implementations &lt;b&gt;may&lt;/b&gt; use this class in combination with
  46  * one or more &lt;code&gt;RowSet&lt;/code&gt; interfaces in order to provide a standard
  47  * vendor-specific implementation.  To clarify, all implementations must implement
  48  * at least one of the &lt;code&gt;RowSet&lt;/code&gt; interfaces (&lt;code&gt;JdbcRowSet&lt;/code&gt;,
  49  * &lt;code&gt;CachedRowSet&lt;/code&gt;, &lt;code&gt;JoinRowSet&lt;/code&gt;, &lt;code&gt;FilteredRowSet&lt;/code&gt;,
  50  * or &lt;code&gt;WebRowSet&lt;/code&gt;). This means that any implementation that extends
  51  * the &lt;code&gt;BaseRowSet&lt;/code&gt; class must also implement one of the &lt;code&gt;RowSet&lt;/code&gt;
  52  * interfaces.
  53  * &lt;p&gt;
  54  * The &lt;code&gt;BaseRowSet&lt;/code&gt; class provides the following:
  55  *
  56  * &lt;UL&gt;
  57  * &lt;LI&gt;&lt;b&gt;Properties&lt;/b&gt;
  58  *     &lt;ul&gt;
  59  *     &lt;li&gt;Fields for storing current properties
  60  *     &lt;li&gt;Methods for getting and setting properties
  61  *     &lt;/ul&gt;
  62  *
  63  * &lt;LI&gt;&lt;b&gt;Event notification&lt;/b&gt;
  64  *
  65  * &lt;LI&gt;&lt;b&gt;A complete set of setter methods&lt;/b&gt; for setting the parameters in a
  66  *      &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
  67  *
  68  * &lt;LI&gt; &lt;b&gt;Streams&lt;/b&gt;
  69  *  &lt;ul&gt;
  70  *  &lt;li&gt;Fields for storing stream instances
  71  *  &lt;li&gt;Constants for indicating the type of a stream
  72  *  &lt;/ul&gt;
  73  * &lt;/UL&gt;
  74  *
  75  * &lt;h2&gt;2.0 Setting Properties&lt;/h2&gt;
  76  * All rowsets maintain a set of properties, which will usually be set using
  77  * a tool.  The number and kinds of properties a rowset has will vary,
  78  * depending on what the &lt;code&gt;RowSet&lt;/code&gt; implementation does and how it gets
  79  * its data.  For example,
  80  * rowsets that get their data from a &lt;code&gt;ResultSet&lt;/code&gt; object need to
  81  * set the properties that are required for making a database connection.
  82  * If a &lt;code&gt;RowSet&lt;/code&gt; object uses the &lt;code&gt;DriverManager&lt;/code&gt; facility to make a
  83  * connection, it needs to set a property for the JDBC URL that identifies the
  84  * appropriate driver, and it needs to set the properties that give the
  85  * user name and password.
  86  * If, on the other hand, the rowset uses a &lt;code&gt;DataSource&lt;/code&gt; object
  87  * to make the connection, which is the preferred method, it does not need to
  88  * set the property for the JDBC URL.  Instead, it needs to set the property
  89  * for the logical name of the data source along with the properties for
  90  * the user name and password.
  91  * &lt;P&gt;
  92  * NOTE:  In order to use a &lt;code&gt;DataSource&lt;/code&gt; object for making a
  93  * connection, the &lt;code&gt;DataSource&lt;/code&gt; object must have been registered
  94  * with a naming service that uses the Java Naming and Directory
  95  * Interface&amp;trade; (JNDI) API.  This registration
  96  * is usually done by a person acting in the capacity of a system administrator.
  97  *
  98  * &lt;h2&gt;3.0 Setting the Command and Its Parameters&lt;/h2&gt;
  99  * When a rowset gets its data from a relational database, it executes a command (a query)
 100  * that produces a &lt;code&gt;ResultSet&lt;/code&gt; object.  This query is the command that is set
 101  * for the &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command property.  The rowset populates itself with data by reading the
 102  * data from the &lt;code&gt;ResultSet&lt;/code&gt; object into itself. If the query
 103  * contains placeholders for values to be set, the &lt;code&gt;BaseRowSet&lt;/code&gt; setter methods
 104  * are used to set these values. All setter methods allow these values to be set
 105  * to &lt;code&gt;null&lt;/code&gt; if required.
 106  * &lt;P&gt;
 107  * The following code fragment illustrates how the
 108  * &lt;code&gt;CachedRowSet&lt;/code&gt;&amp;trade;
 109  * object &lt;code&gt;crs&lt;/code&gt; might have its command property set.  Note that if a
 110  * tool is used to set properties, this is the code that the tool would use.
 111  * &lt;PRE&gt;{@code
 112  *    crs.setCommand(&quot;SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS&quot; +
 113  *                   &quot;WHERE CREDIT_LIMIT &gt; ? AND REGION = ?&quot;);
 114  * }&lt;/PRE&gt;
 115  * &lt;P&gt;
 116  * In this example, the values for &lt;code&gt;CREDIT_LIMIT&lt;/code&gt; and
 117  * &lt;code&gt;REGION&lt;/code&gt; are placeholder parameters, which are indicated with a
 118  * question mark (?).  The first question mark is placeholder parameter number
 119  * &lt;code&gt;1&lt;/code&gt;, the second question mark is placeholder parameter number
 120  * &lt;code&gt;2&lt;/code&gt;, and so on.  Any placeholder parameters must be set with
 121  * values before the query can be executed. To set these
 122  * placeholder parameters, the &lt;code&gt;BaseRowSet&lt;/code&gt; class provides a set of setter
 123  * methods, similar to those provided by the &lt;code&gt;PreparedStatement&lt;/code&gt;
 124  * interface, for setting values of each data type.  A &lt;code&gt;RowSet&lt;/code&gt; object stores the
 125  * parameter values internally, and its &lt;code&gt;execute&lt;/code&gt; method uses them internally
 126  * to set values for the placeholder parameters
 127  * before it sends the command to the DBMS to be executed.
 128  * &lt;P&gt;
 129  * The following code fragment demonstrates
 130  * setting the two parameters in the query from the previous example.
 131  * &lt;PRE&gt;{@code
 132  *    crs.setInt(1, 5000);
 133  *    crs.setString(2, &quot;West&quot;);
 134  * }&lt;/PRE&gt;
 135  * If the &lt;code&gt;execute&lt;/code&gt; method is called at this point, the query
 136  * sent to the DBMS will be:
 137  * &lt;PRE&gt;{@code
 138  *    &quot;SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS&quot; +
 139  *                   &quot;WHERE CREDIT_LIMIT &gt; 5000 AND REGION = &#39;West&#39;&quot;
 140  * }&lt;/PRE&gt;
 141  * NOTE: Setting &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt; and
 142  * &lt;code&gt;Ref&lt;/code&gt; objects as a command parameter, stores these values as
 143  * &lt;code&gt;SerialArray&lt;/code&gt;, &lt;code&gt;SerialClob&lt;/code&gt;, &lt;code&gt;SerialBlob&lt;/code&gt;
 144  * and &lt;code&gt;SerialRef&lt;/code&gt; objects respectively.
 145  *
 146  * &lt;h2&gt;4.0 Handling of Parameters Behind the Scenes&lt;/h2&gt;
 147  *
 148  * NOTE: The &lt;code&gt;BaseRowSet&lt;/code&gt; class provides two kinds of setter methods,
 149  * those that set properties and those that set placeholder parameters. The setter
 150  * methods discussed in this section are those that set placeholder parameters.
 151  * &lt;P&gt;
 152  * The placeholder parameters set with the &lt;code&gt;BaseRowSet&lt;/code&gt; setter methods
 153  * are stored as objects in an internal &lt;code&gt;Hashtable&lt;/code&gt; object.
 154  * Primitives are stored as their &lt;code&gt;Object&lt;/code&gt; type. For example, &lt;code&gt;byte&lt;/code&gt;
 155  * is stored as &lt;code&gt;Byte&lt;/code&gt; object, and &lt;code&gt;int&lt;/code&gt; is stored as
 156  * an &lt;code&gt;Integer&lt;/code&gt; object.
 157  * When the method &lt;code&gt;execute&lt;/code&gt; is called, the values in the
 158  * &lt;code&gt;Hashtable&lt;/code&gt; object are substituted for the appropriate placeholder
 159  * parameters in the command.
 160  * &lt;P&gt;
 161  * A call to the method &lt;code&gt;getParams&lt;/code&gt; returns the values stored in the
 162  * &lt;code&gt;Hashtable&lt;/code&gt; object as an array of &lt;code&gt;Object&lt;/code&gt; instances.
 163  * An element in this array may be a simple &lt;code&gt;Object&lt;/code&gt; instance or an
 164  * array (which is a type of &lt;code&gt;Object&lt;/code&gt;). The particular setter method used
 165  * determines whether an element in this array is an &lt;code&gt;Object&lt;/code&gt; or an array.
 166  * &lt;P&gt;
 167  * The majority of methods for setting placeholder parameters take two parameters,
 168  *  with the first parameter
 169  * indicating which placeholder parameter is to be set, and the second parameter
 170  * giving the value to be set.  Methods such as &lt;code&gt;setInt&lt;/code&gt;,
 171  * &lt;code&gt;setString&lt;/code&gt;, &lt;code&gt;setBoolean&lt;/code&gt;, and &lt;code&gt;setLong&lt;/code&gt; fall into
 172  * this category.  After these methods have been called, a call to the method
 173  * &lt;code&gt;getParams&lt;/code&gt; will return an array with the values that have been set. Each
 174  * element in the array is an &lt;code&gt;Object&lt;/code&gt; instance representing the
 175  * values that have been set. The order of these values in the array is determined by the
 176  * &lt;code&gt;int&lt;/code&gt; (the first parameter) passed to the setter method. The values in the
 177  * array are the values (the second parameter) passed to the setter method.
 178  * In other words, the first element in the array is the value
 179  * to be set for the first placeholder parameter in the &lt;code&gt;RowSet&lt;/code&gt; object&#39;s
 180  * command. The second element is the value to
 181  * be set for the second placeholder parameter, and so on.
 182  * &lt;P&gt;
 183  * Several setter methods send the driver and DBMS information beyond the value to be set.
 184  * When the method &lt;code&gt;getParams&lt;/code&gt; is called after one of these setter methods has
 185  * been used, the elements in the array will themselves be arrays to accommodate the
 186  * additional information. In this category, the method &lt;code&gt;setNull&lt;/code&gt; is a special case
 187  * because one version takes only
 188  * two parameters (&lt;code&gt;setNull(int parameterIndex, int SqlType)&lt;/code&gt;). Nevertheless,
 189  * it requires
 190  * an array to contain the information that will be passed to the driver and DBMS.  The first
 191  * element in this array is the value to be set, which is &lt;code&gt;null&lt;/code&gt;, and the
 192  * second element is the &lt;code&gt;int&lt;/code&gt; supplied for &lt;i&gt;sqlType&lt;/i&gt;, which
 193  * indicates the type of SQL value that is being set to &lt;code&gt;null&lt;/code&gt;. This information
 194  * is needed by some DBMSs and is therefore required in order to ensure that applications
 195  * are portable.
 196  * The other version is intended to be used when the value to be set to &lt;code&gt;null&lt;/code&gt;
 197  * is a user-defined type. It takes three parameters
 198  * (&lt;code&gt;setNull(int parameterIndex, int sqlType, String typeName)&lt;/code&gt;) and also
 199  * requires an array to contain the information to be passed to the driver and DBMS.
 200  * The first two elements in this array are the same as for the first version of
 201  * &lt;code&gt;setNull&lt;/code&gt;.  The third element, &lt;i&gt;typeName&lt;/i&gt;, gives the SQL name of
 202  * the user-defined type. As is true with the other setter methods, the number of the
 203  * placeholder parameter to be set is indicated by an element&#39;s position in the array
 204  * returned by &lt;code&gt;getParams&lt;/code&gt;.  So, for example, if the parameter
 205  * supplied to &lt;code&gt;setNull&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, the second element in the array
 206  * returned by &lt;code&gt;getParams&lt;/code&gt; will be an array of two or three elements.
 207  * &lt;P&gt;
 208  * Some methods, such as &lt;code&gt;setObject&lt;/code&gt; and &lt;code&gt;setDate&lt;/code&gt; have versions
 209  * that take more than two parameters, with the extra parameters giving information
 210  * to the driver or the DBMS. For example, the methods &lt;code&gt;setDate&lt;/code&gt;,
 211  * &lt;code&gt;setTime&lt;/code&gt;, and &lt;code&gt;setTimestamp&lt;/code&gt; can take a &lt;code&gt;Calendar&lt;/code&gt;
 212  * object as their third parameter.  If the DBMS does not store time zone information,
 213  * the driver uses the &lt;code&gt;Calendar&lt;/code&gt; object to construct the &lt;code&gt;Date&lt;/code&gt;,
 214  * &lt;code&gt;Time&lt;/code&gt;, or &lt;code&gt;Timestamp&lt;/code&gt; object being set. As is true with other
 215  * methods that provide additional information, the element in the array returned
 216  * by &lt;code&gt;getParams&lt;/code&gt; is an array instead of a simple &lt;code&gt;Object&lt;/code&gt; instance.
 217  * &lt;P&gt;
 218  * The methods &lt;code&gt;setAsciiStream&lt;/code&gt;, &lt;code&gt;setBinaryStream&lt;/code&gt;,
 219  * &lt;code&gt;setCharacterStream&lt;/code&gt;, and &lt;code&gt;setUnicodeStream&lt;/code&gt; (which is
 220  * deprecated, so applications should use &lt;code&gt;getCharacterStream&lt;/code&gt; instead)
 221  * take three parameters, so for them, the element in the array returned by
 222  * &lt;code&gt;getParams&lt;/code&gt; is also an array.  What is different about these setter
 223  * methods is that in addition to the information provided by parameters, the array contains
 224  * one of the &lt;code&gt;BaseRowSet&lt;/code&gt; constants indicating the type of stream being set.
 225 * &lt;p&gt;
 226 * NOTE: The method &lt;code&gt;getParams&lt;/code&gt; is called internally by
 227 * &lt;code&gt;RowSet&lt;/code&gt; implementations extending this class; it is not normally called by an
 228 * application programmer directly.
 229 *
 230 * &lt;h2&gt;5.0 Event Notification&lt;/h2&gt;
 231 * The &lt;code&gt;BaseRowSet&lt;/code&gt; class provides the event notification
 232 * mechanism for rowsets.  It contains the field
 233 * &lt;code&gt;listeners&lt;/code&gt;, methods for adding and removing listeners, and
 234 * methods for notifying listeners of changes.
 235 * &lt;P&gt;
 236 * A listener is an object that has implemented the &lt;code&gt;RowSetListener&lt;/code&gt; interface.
 237 * If it has been added to a &lt;code&gt;RowSet&lt;/code&gt; object&#39;s list of listeners, it will be notified
 238 *  when an event occurs on that &lt;code&gt;RowSet&lt;/code&gt; object.  Each listener&#39;s
 239 * implementation of the &lt;code&gt;RowSetListener&lt;/code&gt; methods defines what that object
 240 * will do when it is notified that an event has occurred.
 241 * &lt;P&gt;
 242 * There are three possible events for a &lt;code&gt;RowSet&lt;/code&gt; object:
 243 * &lt;OL&gt;
 244 * &lt;LI&gt;the cursor moves
 245 * &lt;LI&gt;an individual row is changed (updated, deleted, or inserted)
 246 * &lt;LI&gt;the contents of the entire &lt;code&gt;RowSet&lt;/code&gt; object  are changed
 247 * &lt;/OL&gt;
 248 * &lt;P&gt;
 249 * The &lt;code&gt;BaseRowSet&lt;/code&gt; method used for the notification indicates the
 250 * type of event that has occurred.  For example, the method
 251 * &lt;code&gt;notifyRowChanged&lt;/code&gt; indicates that a row has been updated,
 252 * deleted, or inserted.  Each of the notification methods creates a
 253 * &lt;code&gt;RowSetEvent&lt;/code&gt; object, which is supplied to the listener in order to
 254 * identify the &lt;code&gt;RowSet&lt;/code&gt; object on which the event occurred.
 255 * What the listener does with this information, which may be nothing, depends on how it was
 256 * implemented.
 257 *
 258 * &lt;h2&gt;6.0 Default Behavior&lt;/h2&gt;
 259 * A default &lt;code&gt;BaseRowSet&lt;/code&gt; object is initialized with many starting values.
 260 *
 261 * The following is true of a default &lt;code&gt;RowSet&lt;/code&gt; instance that extends
 262 * the &lt;code&gt;BaseRowSet&lt;/code&gt; class:
 263 * &lt;UL&gt;
 264 *   &lt;LI&gt;Has a scrollable cursor and does not show changes
 265 *       made by others.
 266 *   &lt;LI&gt;Is updatable.
 267 *   &lt;LI&gt;Does not show rows that have been deleted.
 268 *   &lt;LI&gt;Has no time limit for how long a driver may take to
 269 *       execute the &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command.
 270 *   &lt;LI&gt;Has no limit for the number of rows it may contain.
 271 *   &lt;LI&gt;Has no limit for the number of bytes a column may contain. NOTE: This
 272 *   limit applies only to columns that hold values of the
 273 *   following types:  &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;,
 274 *   &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;,
 275 *   and &lt;code&gt;LONGVARCHAR&lt;/code&gt;.
 276 *   &lt;LI&gt;Will not see uncommitted data (make &quot;dirty&quot; reads).
 277 *   &lt;LI&gt;Has escape processing turned on.
 278 *   &lt;LI&gt;Has its connection&#39;s type map set to &lt;code&gt;null&lt;/code&gt;.
 279 *   &lt;LI&gt;Has an empty &lt;code&gt;Vector&lt;/code&gt; object for storing the values set
 280 *       for the placeholder parameters in the &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command.
 281 * &lt;/UL&gt;
 282 * &lt;p&gt;
 283 * If other values are desired, an application must set the property values
 284 * explicitly. For example, the following line of code sets the maximum number
 285 * of rows for the &lt;code&gt;CachedRowSet&lt;/code&gt; object &lt;i&gt;crs&lt;/i&gt; to 500.
 286 * &lt;PRE&gt;
 287 *    crs.setMaxRows(500);
 288 * &lt;/PRE&gt;
 289 * Methods implemented in extensions of this &lt;code&gt;BaseRowSet&lt;/code&gt; class &lt;b&gt;must&lt;/b&gt; throw an
 290 * &lt;code&gt;SQLException&lt;/code&gt; object for any violation of the defined assertions.  Also, if the
 291 * extending class overrides and reimplements any &lt;code&gt;BaseRowSet&lt;/code&gt; method and encounters
 292 * connectivity or underlying data source issues, that method &lt;b&gt;may&lt;/b&gt; in addition throw an
 293 * &lt;code&gt;SQLException&lt;/code&gt; object for that reason.
 294 *
 295 * @since 1.5
 296 */
 297 
 298 public abstract class BaseRowSet implements Serializable, Cloneable {
 299 
 300     /**
 301      * A constant indicating to a &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object
 302      * that a given parameter is a Unicode stream. This
 303      * &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object is provided as an extension of the
 304      * &lt;code&gt;SyncProvider&lt;/code&gt; abstract class defined in the
 305      * &lt;code&gt;SyncFactory&lt;/code&gt; static factory SPI mechanism.
 306      */
 307     public static final int UNICODE_STREAM_PARAM = 0;
 308 
 309     /**
 310      * A constant indicating to a &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object
 311      * that a given parameter is a binary stream. A
 312      * &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object is provided as an extension of the
 313      * &lt;code&gt;SyncProvider&lt;/code&gt; abstract class defined in the
 314      * &lt;code&gt;SyncFactory&lt;/code&gt; static factory SPI mechanism.
 315      */
 316     public static final int BINARY_STREAM_PARAM = 1;
 317 
 318     /**
 319      * A constant indicating to a &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object
 320      * that a given parameter is an ASCII stream. A
 321      * &lt;code&gt;RowSetReaderImpl&lt;/code&gt; object is provided as an extension of the
 322      * &lt;code&gt;SyncProvider&lt;/code&gt; abstract class defined in the
 323      * &lt;code&gt;SyncFactory&lt;/code&gt; static factory SPI mechanism.
 324      */
 325     public static final int ASCII_STREAM_PARAM = 2;
 326 
 327     /**
 328      * The &lt;code&gt;InputStream&lt;/code&gt; object that will be
 329      * returned by the method &lt;code&gt;getBinaryStream&lt;/code&gt;, which is
 330      * specified in the &lt;code&gt;ResultSet&lt;/code&gt; interface.
 331      * @serial
 332      */
<a name="1" id="anc1"></a><span class="line-added"> 333     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 334     protected java.io.InputStream binaryStream;
 335 
 336     /**
 337      * The &lt;code&gt;InputStream&lt;/code&gt; object that will be
 338      * returned by the method &lt;code&gt;getUnicodeStream&lt;/code&gt;,
 339      * which is specified in the &lt;code&gt;ResultSet&lt;/code&gt; interface.
 340      * @serial
 341      */
<a name="2" id="anc2"></a><span class="line-added"> 342     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 343     protected java.io.InputStream unicodeStream;
 344 
 345     /**
 346      * The &lt;code&gt;InputStream&lt;/code&gt; object that will be
 347      * returned by the method &lt;code&gt;getAsciiStream&lt;/code&gt;,
 348      * which is specified in the &lt;code&gt;ResultSet&lt;/code&gt; interface.
 349      * @serial
 350      */
<a name="3" id="anc3"></a><span class="line-added"> 351     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 352     protected java.io.InputStream asciiStream;
 353 
 354     /**
 355      * The &lt;code&gt;Reader&lt;/code&gt; object that will be
 356      * returned by the method &lt;code&gt;getCharacterStream&lt;/code&gt;,
 357      * which is specified in the &lt;code&gt;ResultSet&lt;/code&gt; interface.
 358      * @serial
 359      */
<a name="4" id="anc4"></a><span class="line-added"> 360     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 361     protected java.io.Reader charStream;
 362 
 363     /**
 364      * The query that will be sent to the DBMS for execution when the
 365      * method &lt;code&gt;execute&lt;/code&gt; is called.
 366      * @serial
 367      */
 368     private String command;
 369 
 370     /**
 371      * The JDBC URL the reader, writer, or both supply to the method
 372      * &lt;code&gt;DriverManager.getConnection&lt;/code&gt; when the
 373      * &lt;code&gt;DriverManager&lt;/code&gt; is used to get a connection.
 374      * &lt;P&gt;
 375      * The JDBC URL identifies the driver to be used to make the connection.
 376      * This URL can be found in the documentation supplied by the driver
 377      * vendor.
 378      * @serial
 379      */
 380     private String URL;
 381 
 382     /**
 383      * The logical name of the data source that the reader/writer should use
 384      * in order to retrieve a &lt;code&gt;DataSource&lt;/code&gt; object from a Java
 385      * Directory and Naming Interface (JNDI) naming service.
 386      * @serial
 387      */
 388     private String dataSource;
 389 
 390     /**
 391      * The user name the reader, writer, or both supply to the method
 392      * &lt;code&gt;DriverManager.getConnection&lt;/code&gt; when the
 393      * &lt;code&gt;DriverManager&lt;/code&gt; is used to get a connection.
 394      * @serial
 395      */
 396     private transient String username;
 397 
 398     /**
 399      * The password the reader, writer, or both supply to the method
 400      * &lt;code&gt;DriverManager.getConnection&lt;/code&gt; when the
 401      * &lt;code&gt;DriverManager&lt;/code&gt; is used to get a connection.
 402      * @serial
 403      */
 404     private transient String password;
 405 
 406     /**
 407      * A constant indicating the type of this JDBC &lt;code&gt;RowSet&lt;/code&gt;
 408      * object. It must be one of the following &lt;code&gt;ResultSet&lt;/code&gt;
 409      * constants:  &lt;code&gt;TYPE_FORWARD_ONLY&lt;/code&gt;,
 410      * &lt;code&gt;TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
 411      * &lt;code&gt;TYPE_SCROLL_SENSITIVE&lt;/code&gt;.
 412      * @serial
 413      */
 414     private int rowSetType = ResultSet.TYPE_SCROLL_INSENSITIVE;
 415 
 416     /**
 417      * A &lt;code&gt;boolean&lt;/code&gt; indicating whether deleted rows are visible in this
 418      * JDBC &lt;code&gt;RowSet&lt;/code&gt; object .
 419      * @serial
 420      */
 421     private boolean showDeleted = false; // default is false
 422 
 423     /**
 424      * The maximum number of seconds the driver
 425      * will wait for a command to execute.  This limit applies while
 426      * this JDBC &lt;code&gt;RowSet&lt;/code&gt; object is connected to its data
 427      * source, that is, while it is populating itself with
 428      * data and while it is writing data back to the data source.
 429      * @serial
 430      */
 431     private int queryTimeout = 0; // default is no timeout
 432 
 433     /**
 434      * The maximum number of rows the reader should read.
 435      * @serial
 436      */
 437     private int maxRows = 0; // default is no limit
 438 
 439     /**
 440      * The maximum field size the reader should read.
 441      * @serial
 442      */
 443     private int maxFieldSize = 0; // default is no limit
 444 
 445     /**
 446      * A constant indicating the concurrency of this JDBC &lt;code&gt;RowSet&lt;/code&gt;
 447      * object. It must be one of the following &lt;code&gt;ResultSet&lt;/code&gt;
 448      * constants: &lt;code&gt;CONCUR_READ_ONLY&lt;/code&gt; or
 449      * &lt;code&gt;CONCUR_UPDATABLE&lt;/code&gt;.
 450      * @serial
 451      */
 452     private int concurrency = ResultSet.CONCUR_UPDATABLE;
 453 
 454     /**
 455      * A &lt;code&gt;boolean&lt;/code&gt; indicating whether this JDBC &lt;code&gt;RowSet&lt;/code&gt;
 456      * object is read-only.  &lt;code&gt;true&lt;/code&gt; indicates that it is read-only;
 457      * &lt;code&gt;false&lt;/code&gt; that it is writable.
 458      * @serial
 459      */
 460     private boolean readOnly;
 461 
 462     /**
 463      * A &lt;code&gt;boolean&lt;/code&gt; indicating whether the reader for this
 464      * JDBC &lt;code&gt;RowSet&lt;/code&gt; object should perform escape processing.
 465      * &lt;code&gt;true&lt;/code&gt; means that escape processing is turned on;
 466      * &lt;code&gt;false&lt;/code&gt; that it is not. The default is &lt;code&gt;true&lt;/code&gt;.
 467      * @serial
 468      */
 469     private boolean escapeProcessing = true;
 470 
 471     /**
 472      * A constant indicating the isolation level of the connection
 473      * for this JDBC &lt;code&gt;RowSet&lt;/code&gt; object . It must be one of
 474      * the following &lt;code&gt;Connection&lt;/code&gt; constants:
 475      * &lt;code&gt;TRANSACTION_NONE&lt;/code&gt;,
 476      * &lt;code&gt;TRANSACTION_READ_UNCOMMITTED&lt;/code&gt;,
 477      * &lt;code&gt;TRANSACTION_READ_COMMITTED&lt;/code&gt;,
 478      * &lt;code&gt;TRANSACTION_REPEATABLE_READ&lt;/code&gt; or
 479      * &lt;code&gt;TRANSACTION_SERIALIZABLE&lt;/code&gt;.
 480      * @serial
 481      */
 482     private int isolation;
 483 
 484     /**
 485      * A constant used as a hint to the driver that indicates the direction in
 486      * which data from this JDBC &lt;code&gt;RowSet&lt;/code&gt; object  is going
 487      * to be fetched. The following &lt;code&gt;ResultSet&lt;/code&gt; constants are
 488      * possible values:
 489      * &lt;code&gt;FETCH_FORWARD&lt;/code&gt;,
 490      * &lt;code&gt;FETCH_REVERSE&lt;/code&gt;,
 491      * &lt;code&gt;FETCH_UNKNOWN&lt;/code&gt;.
 492      * &lt;P&gt;
 493      * Unused at this time.
 494      * @serial
 495      */
 496     private int fetchDir = ResultSet.FETCH_FORWARD; // default fetch direction
 497 
 498     /**
 499      * A hint to the driver that indicates the expected number of rows
 500      * in this JDBC &lt;code&gt;RowSet&lt;/code&gt; object .
 501      * &lt;P&gt;
 502      * Unused at this time.
 503      * @serial
 504      */
 505     private int fetchSize = 0; // default fetchSize
 506 
 507     /**
 508      * The &lt;code&gt;java.util.Map&lt;/code&gt; object that contains entries mapping
 509      * SQL type names to classes in the Java programming language for the
 510      * custom mapping of user-defined types.
 511      * @serial
 512      */
<a name="5" id="anc5"></a><span class="line-added"> 513     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 514     private Map&lt;String, Class&lt;?&gt;&gt; map;
 515 
 516     /**
 517      * A &lt;code&gt;Vector&lt;/code&gt; object that holds the list of listeners
 518      * that have registered with this &lt;code&gt;RowSet&lt;/code&gt; object.
 519      * @serial
 520      */
 521     private Vector&lt;RowSetListener&gt; listeners;
 522 
 523     /**
 524      * A &lt;code&gt;Vector&lt;/code&gt; object that holds the parameters set
 525      * for this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s current command.
 526      * @serial
 527      */
 528     private Hashtable&lt;Integer, Object&gt; params; // could be transient?
 529 
 530     /**
 531      * Constructs a new &lt;code&gt;BaseRowSet&lt;/code&gt; object initialized with
 532      * a default &lt;code&gt;Vector&lt;/code&gt; object for its &lt;code&gt;listeners&lt;/code&gt;
 533      * field. The other default values with which it is initialized are listed
 534      * in Section 6.0 of the class comment for this class.
 535      */
 536     public BaseRowSet() {
 537         // allocate the listeners collection
 538         listeners = new Vector&lt;RowSetListener&gt;();
 539     }
 540 
 541     /**
 542      * Performs the necessary internal configurations and initializations
 543      * to allow any JDBC &lt;code&gt;RowSet&lt;/code&gt; implementation to start using
 544      * the standard facilities provided by a &lt;code&gt;BaseRowSet&lt;/code&gt;
 545      * instance. This method &lt;b&gt;should&lt;/b&gt; be called after the &lt;code&gt;RowSet&lt;/code&gt; object
 546      * has been instantiated to correctly initialize all parameters. This method
 547      * &lt;b&gt;should&lt;/b&gt; never be called by an application, but is called from with
 548      * a &lt;code&gt;RowSet&lt;/code&gt; implementation extending this class.
 549      */
 550     protected void initParams() {
 551         params = new Hashtable&lt;Integer, Object&gt;();
 552     }
 553 
 554     //--------------------------------------------------------------------
 555     // Events
 556     //--------------------------------------------------------------------
 557 
 558     /**
 559     * The listener will be notified whenever an event occurs on this &lt;code&gt;RowSet&lt;/code&gt;
 560     * object.
 561     * &lt;P&gt;
 562     * A listener might, for example, be a table or graph that needs to
 563     * be updated in order to accurately reflect the current state of
 564     * the &lt;code&gt;RowSet&lt;/code&gt; object.
 565     * &lt;p&gt;
 566     * &lt;b&gt;Note&lt;/b&gt;: if the &lt;code&gt;RowSetListener&lt;/code&gt; object is
 567     * &lt;code&gt;null&lt;/code&gt;, this method silently discards the &lt;code&gt;null&lt;/code&gt;
 568     * value and does not add a null reference to the set of listeners.
 569     * &lt;p&gt;
 570     * &lt;b&gt;Note&lt;/b&gt;: if the listener is already set, and the new &lt;code&gt;RowSetListener&lt;/code&gt;
 571     * instance is added to the set of listeners already registered to receive
 572     * event notifications from this &lt;code&gt;RowSet&lt;/code&gt;.
 573     *
 574     * @param listener an object that has implemented the
 575     *     &lt;code&gt;javax.sql.RowSetListener&lt;/code&gt; interface and wants to be notified
 576     *     of any events that occur on this &lt;code&gt;RowSet&lt;/code&gt; object; May be
 577     *     null.
 578     * @see #removeRowSetListener
 579     */
 580     public void addRowSetListener(RowSetListener listener) {
 581         listeners.add(listener);
 582     }
 583 
 584     /**
 585     * Removes the designated object from this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s list of listeners.
 586     * If the given argument is not a registered listener, this method
 587     * does nothing.
 588     *
 589     *  &lt;b&gt;Note&lt;/b&gt;: if the &lt;code&gt;RowSetListener&lt;/code&gt; object is
 590     * &lt;code&gt;null&lt;/code&gt;, this method silently discards the &lt;code&gt;null&lt;/code&gt;
 591     * value.
 592     *
 593     * @param listener a &lt;code&gt;RowSetListener&lt;/code&gt; object that is on the list
 594     *        of listeners for this &lt;code&gt;RowSet&lt;/code&gt; object
 595     * @see #addRowSetListener
 596     */
 597     public void removeRowSetListener(RowSetListener listener) {
 598         listeners.remove(listener);
 599     }
 600 
 601     /**
 602      * Determine if instance of this class extends the RowSet interface.
 603      */
 604     private void checkforRowSetInterface() throws SQLException {
 605         if ((this instanceof javax.sql.RowSet) == false) {
 606             throw new SQLException(&quot;The class extending abstract class BaseRowSet &quot; +
 607                 &quot;must implement javax.sql.RowSet or one of it&#39;s sub-interfaces.&quot;);
 608         }
 609     }
 610 
 611     /**
 612     * Notifies all of the listeners registered with this
 613     * &lt;code&gt;RowSet&lt;/code&gt; object that its cursor has moved.
 614     * &lt;P&gt;
 615     * When an application calls a method to move the cursor,
 616     * that method moves the cursor and then calls this method
 617     * internally. An application &lt;b&gt;should&lt;/b&gt; never invoke
 618     * this method directly.
 619     *
 620     * @throws SQLException if the class extending the &lt;code&gt;BaseRowSet&lt;/code&gt;
 621     *     abstract class does not implement the &lt;code&gt;RowSet&lt;/code&gt; interface or
 622     *     one of it&#39;s sub-interfaces.
 623     */
 624     protected void notifyCursorMoved() throws SQLException {
 625         checkforRowSetInterface();
 626         if (listeners.isEmpty() == false) {
 627             RowSetEvent event = new RowSetEvent((RowSet)this);
 628             for (RowSetListener rsl : listeners) {
 629                 rsl.cursorMoved(event);
 630             }
 631         }
 632     }
 633 
 634     /**
 635     * Notifies all of the listeners registered with this &lt;code&gt;RowSet&lt;/code&gt; object that
 636     * one of its rows has changed.
 637     * &lt;P&gt;
 638     * When an application calls a method that changes a row, such as
 639     * the &lt;code&gt;CachedRowSet&lt;/code&gt; methods &lt;code&gt;insertRow&lt;/code&gt;,
 640     * &lt;code&gt;updateRow&lt;/code&gt;, or &lt;code&gt;deleteRow&lt;/code&gt;,
 641     * that method calls &lt;code&gt;notifyRowChanged&lt;/code&gt;
 642     * internally. An application &lt;b&gt;should&lt;/b&gt; never invoke
 643     * this method directly.
 644     *
 645     * @throws SQLException if the class extending the &lt;code&gt;BaseRowSet&lt;/code&gt;
 646     *     abstract class does not implement the &lt;code&gt;RowSet&lt;/code&gt; interface or
 647     *     one of it&#39;s sub-interfaces.
 648     */
 649     protected void notifyRowChanged() throws SQLException {
 650         checkforRowSetInterface();
 651         if (listeners.isEmpty() == false) {
 652                 RowSetEvent event = new RowSetEvent((RowSet)this);
 653                 for (RowSetListener rsl : listeners) {
 654                     rsl.rowChanged(event);
 655                 }
 656         }
 657     }
 658 
 659    /**
 660     * Notifies all of the listeners registered with this &lt;code&gt;RowSet&lt;/code&gt;
 661     * object that its entire contents have changed.
 662     * &lt;P&gt;
 663     * When an application calls methods that change the entire contents
 664     * of the &lt;code&gt;RowSet&lt;/code&gt; object, such as the &lt;code&gt;CachedRowSet&lt;/code&gt; methods
 665     * &lt;code&gt;execute&lt;/code&gt;, &lt;code&gt;populate&lt;/code&gt;, &lt;code&gt;restoreOriginal&lt;/code&gt;,
 666     * or &lt;code&gt;release&lt;/code&gt;, that method calls &lt;code&gt;notifyRowSetChanged&lt;/code&gt;
 667     * internally (either directly or indirectly). An application &lt;b&gt;should&lt;/b&gt;
 668     * never invoke this method directly.
 669     *
 670     * @throws SQLException if the class extending the &lt;code&gt;BaseRowSet&lt;/code&gt;
 671     *     abstract class does not implement the &lt;code&gt;RowSet&lt;/code&gt; interface or
 672     *     one of it&#39;s sub-interfaces.
 673     */
 674     protected void notifyRowSetChanged() throws SQLException {
 675         checkforRowSetInterface();
 676         if (listeners.isEmpty() == false) {
 677                 RowSetEvent event = new RowSetEvent((RowSet)this);
 678                 for (RowSetListener rsl : listeners) {
 679                     rsl.rowSetChanged(event);
 680                 }
 681         }
 682 }
 683 
 684     /**
 685      * Retrieves the SQL query that is the command for this
 686      * &lt;code&gt;RowSet&lt;/code&gt; object. The command property contains the query that
 687      * will be executed to populate this &lt;code&gt;RowSet&lt;/code&gt; object.
 688      * &lt;P&gt;
 689      * The SQL query returned by this method is used by &lt;code&gt;RowSet&lt;/code&gt; methods
 690      * such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt;, which may be implemented
 691      * by any class that extends the &lt;code&gt;BaseRowSet&lt;/code&gt; abstract class and
 692      * implements one or more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt;
 693      * interfaces.
 694      * &lt;P&gt;
 695      * The command is used by the &lt;code&gt;RowSet&lt;/code&gt; object&#39;s
 696      * reader to obtain a &lt;code&gt;ResultSet&lt;/code&gt; object.  The reader then
 697      * reads the data from the &lt;code&gt;ResultSet&lt;/code&gt; object and uses it to
 698      * to populate this &lt;code&gt;RowSet&lt;/code&gt; object.
 699      * &lt;P&gt;
 700      * The default value for the &lt;code&gt;command&lt;/code&gt; property is &lt;code&gt;null&lt;/code&gt;.
 701      *
 702      * @return the &lt;code&gt;String&lt;/code&gt; that is the value for this
 703      *         &lt;code&gt;RowSet&lt;/code&gt; object&#39;s &lt;code&gt;command&lt;/code&gt; property;
 704      *         may be &lt;code&gt;null&lt;/code&gt;
 705      * @see #setCommand
 706      */
 707     public String getCommand() {
 708         return command;
 709     }
 710 
 711     /**
 712      * Sets this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s &lt;code&gt;command&lt;/code&gt; property to
 713      * the given &lt;code&gt;String&lt;/code&gt; object and clears the parameters, if any,
 714      * that were set for the previous command.
 715      * &lt;P&gt;
 716      * The &lt;code&gt;command&lt;/code&gt; property may not be needed if the &lt;code&gt;RowSet&lt;/code&gt;
 717      * object gets its data from a source that does not support commands,
 718      * such as a spreadsheet or other tabular file.
 719      * Thus, this property is optional and may be &lt;code&gt;null&lt;/code&gt;.
 720      *
 721      * @param cmd a &lt;code&gt;String&lt;/code&gt; object containing an SQL query
 722      *            that will be set as this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
 723      *            property; may be &lt;code&gt;null&lt;/code&gt; but may not be an empty string
 724      * @throws SQLException if an empty string is provided as the command value
 725      * @see #getCommand
 726      */
 727     public void setCommand(String cmd) throws SQLException {
 728         // cmd equal to null or
 729         // cmd with length 0 (implies url ==&quot;&quot;)
 730         // are not independent events.
 731 
 732         if(cmd == null) {
 733            command = null;
 734         } else if (cmd.length() == 0) {
 735             throw new SQLException(&quot;Invalid command string detected. &quot; +
 736             &quot;Cannot be of length less than 0&quot;);
 737         } else {
 738             // &quot;unbind&quot; any parameters from any previous command.
 739             if(params == null){
 740                  throw new SQLException(&quot;Set initParams() before setCommand&quot;);
 741             }
 742             params.clear();
 743             command = cmd;
 744         }
 745 
 746     }
 747 
 748     /**
 749      * Retrieves the JDBC URL that this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s
 750      * &lt;code&gt;javax.sql.Reader&lt;/code&gt; object uses to make a connection
 751      * with a relational database using a JDBC technology-enabled driver.
 752      *&lt;P&gt;
 753      * The &lt;code&gt;Url&lt;/code&gt; property will be &lt;code&gt;null&lt;/code&gt; if the underlying data
 754      * source is a non-SQL data source, such as a spreadsheet or an XML
 755      * data source.
 756      *
 757      * @return a &lt;code&gt;String&lt;/code&gt; object that contains the JDBC URL
 758      *         used to establish the connection for this &lt;code&gt;RowSet&lt;/code&gt;
 759      *         object; may be &lt;code&gt;null&lt;/code&gt; (default value) if not set
 760      * @throws SQLException if an error occurs retrieving the URL value
 761      * @see #setUrl
 762      */
 763     public String getUrl() throws SQLException {
 764         return URL;
 765     }
 766 
 767     /**
 768      * Sets the Url property for this &lt;code&gt;RowSet&lt;/code&gt; object
 769      * to the given &lt;code&gt;String&lt;/code&gt; object and sets the dataSource name
 770      * property to &lt;code&gt;null&lt;/code&gt;. The Url property is a
 771      * JDBC URL that is used when
 772      * the connection is created using a JDBC technology-enabled driver
 773      * (&quot;JDBC driver&quot;) and the &lt;code&gt;DriverManager&lt;/code&gt;.
 774      * The correct JDBC URL for the specific driver to be used can be found
 775      * in the driver documentation.  Although there are guidelines for how
 776      * a JDBC URL is formed,
 777      * a driver vendor can specify any &lt;code&gt;String&lt;/code&gt; object except
 778      * one with a length of &lt;code&gt;0&lt;/code&gt; (an empty string).
 779      * &lt;P&gt;
 780      * Setting the Url property is optional if connections are established using
 781      * a &lt;code&gt;DataSource&lt;/code&gt; object instead of the &lt;code&gt;DriverManager&lt;/code&gt;.
 782      * The driver will use either the URL property or the
 783      * dataSourceName property to create a connection, whichever was
 784      * specified most recently. If an application uses a JDBC URL, it
 785      * must load a JDBC driver that accepts the JDBC URL before it uses the
 786      * &lt;code&gt;RowSet&lt;/code&gt; object to connect to a database.  The &lt;code&gt;RowSet&lt;/code&gt;
 787      * object will use the URL internally to create a database connection in order
 788      * to read or write data.
 789      *
 790      * @param url a &lt;code&gt;String&lt;/code&gt; object that contains the JDBC URL
 791      *     that will be used to establish the connection to a database for this
 792      *     &lt;code&gt;RowSet&lt;/code&gt; object; may be &lt;code&gt;null&lt;/code&gt; but must not
 793      *     be an empty string
 794      * @throws SQLException if an error occurs setting the Url property or the
 795      *     parameter supplied is a string with a length of &lt;code&gt;0&lt;/code&gt; (an
 796      *     empty string)
 797      * @see #getUrl
 798      */
 799     public void setUrl(String url) throws SQLException {
 800         if(url == null) {
 801            url = null;
 802         } else if (url.length() &lt; 1) {
 803             throw new SQLException(&quot;Invalid url string detected. &quot; +
 804             &quot;Cannot be of length less than 1&quot;);
 805         } else {
 806             URL = url;
 807         }
 808 
 809         dataSource = null;
 810 
 811     }
 812 
 813     /**
 814      * Returns the logical name that when supplied to a naming service
 815      * that uses the Java Naming and Directory Interface (JNDI) API, will
 816      * retrieve a &lt;code&gt;javax.sql.DataSource&lt;/code&gt; object. This
 817      * &lt;code&gt;DataSource&lt;/code&gt; object can be used to establish a connection
 818      * to the data source that it represents.
 819      * &lt;P&gt;
 820      * Users should set either the url or the data source name property.
 821      * The driver will use the property set most recently to establish a
 822      * connection.
 823      *
 824      * @return a &lt;code&gt;String&lt;/code&gt; object that identifies the
 825      *         &lt;code&gt;DataSource&lt;/code&gt; object to be used for making a
 826      *         connection; if no logical name has been set, &lt;code&gt;null&lt;/code&gt;
 827      *         is returned.
 828      * @see #setDataSourceName
 829      */
 830     public String getDataSourceName() {
 831         return dataSource;
 832     }
 833 
 834 
 835     /**
 836      * Sets the &lt;code&gt;DataSource&lt;/code&gt; name property for this &lt;code&gt;RowSet&lt;/code&gt;
 837      * object to the given logical name and sets this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s
 838      * Url property to &lt;code&gt;null&lt;/code&gt;. The name must have been bound to a
 839      * &lt;code&gt;DataSource&lt;/code&gt; object in a JNDI naming service so that an
 840      * application can do a lookup using that name to retrieve the
 841      * &lt;code&gt;DataSource&lt;/code&gt; object bound to it. The &lt;code&gt;DataSource&lt;/code&gt;
 842      * object can then be used to establish a connection to the data source it
 843      * represents.
 844      * &lt;P&gt;
 845      * Users should set either the Url property or the dataSourceName property.
 846      * If both properties are set, the driver will use the property set most recently.
 847      *
 848      * @param name a &lt;code&gt;String&lt;/code&gt; object with the name that can be supplied
 849      *     to a naming service based on JNDI technology to retrieve the
 850      *     &lt;code&gt;DataSource&lt;/code&gt; object that can be used to get a connection;
 851      *     may be &lt;code&gt;null&lt;/code&gt; but must not be an empty string
 852      * @throws SQLException if an empty string is provided as the &lt;code&gt;DataSource&lt;/code&gt;
 853      *    name
 854      * @see #getDataSourceName
 855      */
 856     public void setDataSourceName(String name) throws SQLException {
 857 
 858         if (name == null) {
 859             dataSource = null;
 860         } else if (name.isEmpty()) {
 861            throw new SQLException(&quot;DataSource name cannot be empty string&quot;);
 862         } else {
 863            dataSource = name;
 864         }
 865 
 866         URL = null;
 867     }
 868 
 869     /**
 870      * Returns the user name used to create a database connection.  Because it
 871      * is not serialized, the username property is set at runtime before
 872      * calling the method &lt;code&gt;execute&lt;/code&gt;.
 873      *
 874      * @return the &lt;code&gt;String&lt;/code&gt; object containing the user name that
 875      *         is supplied to the data source to create a connection; may be
 876      *         &lt;code&gt;null&lt;/code&gt; (default value) if not set
 877      * @see #setUsername
 878      */
 879     public String getUsername() {
 880         return username;
 881     }
 882 
 883     /**
 884      * Sets the username property for this &lt;code&gt;RowSet&lt;/code&gt; object
 885      * to the given user name. Because it
 886      * is not serialized, the username property is set at run time before
 887      * calling the method &lt;code&gt;execute&lt;/code&gt;.
 888      *
 889      * @param name the &lt;code&gt;String&lt;/code&gt; object containing the user name that
 890      *     is supplied to the data source to create a connection. It may be null.
 891      * @see #getUsername
 892      */
 893     public void setUsername(String name) {
 894         if(name == null)
 895         {
 896            username = null;
 897         } else {
 898            username = name;
 899         }
 900     }
 901 
 902     /**
 903      * Returns the password used to create a database connection for this
 904      * &lt;code&gt;RowSet&lt;/code&gt; object.  Because the password property is not
 905      * serialized, it is set at run time before calling the method
 906      * &lt;code&gt;execute&lt;/code&gt;. The default value is &lt;code&gt;null&lt;/code&gt;
 907      *
 908      * @return the &lt;code&gt;String&lt;/code&gt; object that represents the password
 909      *         that must be supplied to the database to create a connection
 910      * @see #setPassword
 911      */
 912     public String getPassword() {
 913         return password;
 914     }
 915 
 916     /**
 917      * Sets the password used to create a database connection for this
 918      * &lt;code&gt;RowSet&lt;/code&gt; object to the given &lt;code&gt;String&lt;/code&gt;
 919      * object.  Because the password property is not
 920      * serialized, it is set at run time before calling the method
 921      * &lt;code&gt;execute&lt;/code&gt;.
 922      *
 923      * @param pass the &lt;code&gt;String&lt;/code&gt; object that represents the password
 924      *     that is supplied to the database to create a connection. It may be
 925      *     null.
 926      * @see #getPassword
 927      */
 928     public void setPassword(String pass) {
 929         if(pass == null)
 930         {
 931            password = null;
 932         } else {
 933            password = pass;
 934         }
 935     }
 936 
 937     /**
 938      * Sets the type for this &lt;code&gt;RowSet&lt;/code&gt; object to the specified type.
 939      * The default type is &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;.
 940      *
 941      * @param type one of the following constants:
 942      *             &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
 943      *             &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
 944      *             &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
 945      * @throws SQLException if the parameter supplied is not one of the
 946      *         following constants:
 947      *          &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt; or
 948      *          &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;
 949      *          &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
 950      * @see #getConcurrency
 951      * @see #getType
 952      */
 953     public void setType(int type) throws SQLException {
 954 
 955         if ((type != ResultSet.TYPE_FORWARD_ONLY) &amp;&amp;
 956            (type != ResultSet.TYPE_SCROLL_INSENSITIVE) &amp;&amp;
 957            (type != ResultSet.TYPE_SCROLL_SENSITIVE)) {
 958                 throw new SQLException(&quot;Invalid type of RowSet set. Must be either &quot; +
 959                 &quot;ResultSet.TYPE_FORWARD_ONLY or ResultSet.TYPE_SCROLL_INSENSITIVE &quot; +
 960                 &quot;or ResultSet.TYPE_SCROLL_SENSITIVE.&quot;);
 961         }
 962         this.rowSetType = type;
 963     }
 964 
 965     /**
 966      * Returns the type of this &lt;code&gt;RowSet&lt;/code&gt; object. The type is initially
 967      * determined by the statement that created the &lt;code&gt;RowSet&lt;/code&gt; object.
 968      * The &lt;code&gt;RowSet&lt;/code&gt; object can call the method
 969      * &lt;code&gt;setType&lt;/code&gt; at any time to change its
 970      * type.  The default is &lt;code&gt;TYPE_SCROLL_INSENSITIVE&lt;/code&gt;.
 971      *
 972      * @return the type of this JDBC &lt;code&gt;RowSet&lt;/code&gt;
 973      *         object, which must be one of the following:
 974      *         &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;,
 975      *         &lt;code&gt;ResultSet.TYPE_SCROLL_INSENSITIVE&lt;/code&gt;, or
 976      *         &lt;code&gt;ResultSet.TYPE_SCROLL_SENSITIVE&lt;/code&gt;
 977      * @throws SQLException if an error occurs getting the type of
 978      *     of this &lt;code&gt;RowSet&lt;/code&gt; object
 979      * @see #setType
 980      */
 981     public int getType() throws SQLException {
 982         return rowSetType;
 983     }
 984 
 985     /**
 986      * Sets the concurrency for this &lt;code&gt;RowSet&lt;/code&gt; object to
 987      * the specified concurrency. The default concurrency for any &lt;code&gt;RowSet&lt;/code&gt;
 988      * object (connected or disconnected) is &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;,
 989      * but this method may be called at any time to change the concurrency.
 990      *
 991      * @param concurrency one of the following constants:
 992      *                    &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
 993      *                    &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
 994      * @throws SQLException if the parameter supplied is not one of the
 995      *         following constants:
 996      *          &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt; or
 997      *          &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
 998      * @see #getConcurrency
 999      * @see #isReadOnly
1000      */
1001     public void setConcurrency(int concurrency) throws SQLException {
1002 
1003         if((concurrency != ResultSet.CONCUR_READ_ONLY) &amp;&amp;
1004            (concurrency != ResultSet.CONCUR_UPDATABLE)) {
1005                 throw new SQLException(&quot;Invalid concurrency set. Must be either &quot; +
1006                 &quot;ResultSet.CONCUR_READ_ONLY or ResultSet.CONCUR_UPDATABLE.&quot;);
1007         }
1008         this.concurrency = concurrency;
1009     }
1010 
1011     /**
1012      * Returns a &lt;code&gt;boolean&lt;/code&gt; indicating whether this
1013      * &lt;code&gt;RowSet&lt;/code&gt; object is read-only.
1014      * Any attempts to update a read-only &lt;code&gt;RowSet&lt;/code&gt; object will result in an
1015      * &lt;code&gt;SQLException&lt;/code&gt; being thrown. By default,
1016      * rowsets are updatable if updates are possible.
1017      *
1018      * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;RowSet&lt;/code&gt; object
1019      *         cannot be updated; &lt;code&gt;false&lt;/code&gt; otherwise
1020      * @see #setConcurrency
1021      * @see #setReadOnly
1022      */
1023     public boolean isReadOnly() {
1024         return readOnly;
1025     };
1026 
1027     /**
1028      * Sets this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s readOnly  property to the given &lt;code&gt;boolean&lt;/code&gt;.
1029      *
1030      * @param value &lt;code&gt;true&lt;/code&gt; to indicate that this
1031      *              &lt;code&gt;RowSet&lt;/code&gt; object is read-only;
1032      *              &lt;code&gt;false&lt;/code&gt; to indicate that it is updatable
1033      */
1034     public void setReadOnly(boolean value) {
1035         readOnly = value;
1036     }
1037 
1038     /**
1039      * Returns the transaction isolation property for this
1040      * &lt;code&gt;RowSet&lt;/code&gt; object&#39;s connection. This property represents
1041      * the transaction isolation level requested for use in transactions.
1042      * &lt;P&gt;
1043      * For &lt;code&gt;RowSet&lt;/code&gt; implementations such as
1044      * the &lt;code&gt;CachedRowSet&lt;/code&gt; that operate in a disconnected environment,
1045      * the &lt;code&gt;SyncProvider&lt;/code&gt; object
1046      * offers complementary locking and data integrity options. The
1047      * options described below are pertinent only to connected &lt;code&gt;RowSet&lt;/code&gt;
1048      * objects (&lt;code&gt;JdbcRowSet&lt;/code&gt; objects).
1049      *
1050      * @return one of the following constants:
1051      *         &lt;code&gt;Connection.TRANSACTION_NONE&lt;/code&gt;,
1052      *         &lt;code&gt;Connection.TRANSACTION_READ_UNCOMMITTED&lt;/code&gt;,
1053      *         &lt;code&gt;Connection.TRANSACTION_READ_COMMITTED&lt;/code&gt;,
1054      *         &lt;code&gt;Connection.TRANSACTION_REPEATABLE_READ&lt;/code&gt;, or
1055      *         &lt;code&gt;Connection.TRANSACTION_SERIALIZABLE&lt;/code&gt;
1056      * @see javax.sql.rowset.spi.SyncFactory
1057      * @see javax.sql.rowset.spi.SyncProvider
1058      * @see #setTransactionIsolation
1059 
1060      */
1061     public int getTransactionIsolation() {
1062         return isolation;
1063     };
1064 
1065     /**
1066      * Sets the transaction isolation property for this JDBC &lt;code&gt;RowSet&lt;/code&gt; object to the given
1067      * constant. The DBMS will use this transaction isolation level for
1068      * transactions if it can.
1069      * &lt;p&gt;
1070      * For &lt;code&gt;RowSet&lt;/code&gt; implementations such as
1071      * the &lt;code&gt;CachedRowSet&lt;/code&gt; that operate in a disconnected environment,
1072      * the &lt;code&gt;SyncProvider&lt;/code&gt; object being used
1073      * offers complementary locking and data integrity options. The
1074      * options described below are pertinent only to connected &lt;code&gt;RowSet&lt;/code&gt;
1075      * objects (&lt;code&gt;JdbcRowSet&lt;/code&gt; objects).
1076      *
1077      * @param level one of the following constants, listed in ascending order:
1078      *              &lt;code&gt;Connection.TRANSACTION_NONE&lt;/code&gt;,
1079      *              &lt;code&gt;Connection.TRANSACTION_READ_UNCOMMITTED&lt;/code&gt;,
1080      *              &lt;code&gt;Connection.TRANSACTION_READ_COMMITTED&lt;/code&gt;,
1081      *              &lt;code&gt;Connection.TRANSACTION_REPEATABLE_READ&lt;/code&gt;, or
1082      *              &lt;code&gt;Connection.TRANSACTION_SERIALIZABLE&lt;/code&gt;
1083      * @throws SQLException if the given parameter is not one of the Connection
1084      *          constants
1085      * @see javax.sql.rowset.spi.SyncFactory
1086      * @see javax.sql.rowset.spi.SyncProvider
1087      * @see #getTransactionIsolation
1088      */
1089     public void setTransactionIsolation(int level) throws SQLException {
1090         if ((level != Connection.TRANSACTION_NONE) &amp;&amp;
1091            (level != Connection.TRANSACTION_READ_COMMITTED) &amp;&amp;
1092            (level != Connection.TRANSACTION_READ_UNCOMMITTED) &amp;&amp;
1093            (level != Connection.TRANSACTION_REPEATABLE_READ) &amp;&amp;
1094            (level != Connection.TRANSACTION_SERIALIZABLE))
1095             {
1096                 throw new SQLException(&quot;Invalid transaction isolation set. Must &quot; +
1097                 &quot;be either &quot; +
1098                 &quot;Connection.TRANSACTION_NONE or &quot; +
1099                 &quot;Connection.TRANSACTION_READ_UNCOMMITTED or &quot; +
1100                 &quot;Connection.TRANSACTION_READ_COMMITTED or &quot; +
1101                 &quot;Connection.TRANSACTION_REPEATABLE_READ or &quot; +
1102                 &quot;Connection.TRANSACTION_SERIALIZABLE&quot;);
1103             }
1104         this.isolation = level;
1105     }
1106 
1107     /**
1108      * Retrieves the type map associated with the &lt;code&gt;Connection&lt;/code&gt;
1109      * object for this &lt;code&gt;RowSet&lt;/code&gt; object.
1110      * &lt;P&gt;
1111      * Drivers that support the JDBC 3.0 API will create
1112      * &lt;code&gt;Connection&lt;/code&gt; objects with an associated type map.
1113      * This type map, which is initially empty, can contain one or more
1114      * fully-qualified SQL names and &lt;code&gt;Class&lt;/code&gt; objects indicating
1115      * the class to which the named SQL value will be mapped. The type mapping
1116      * specified in the connection&#39;s type map is used for custom type mapping
1117      * when no other type map supersedes it.
1118      * &lt;p&gt;
1119      * If a type map is explicitly supplied to a method that can perform
1120      * custom mapping, that type map supersedes the connection&#39;s type map.
1121      *
1122      * @return the &lt;code&gt;java.util.Map&lt;/code&gt; object that is the type map
1123      *         for this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s connection
1124      */
1125     public java.util.Map&lt;String,Class&lt;?&gt;&gt; getTypeMap() {
1126         return map;
1127     }
1128 
1129     /**
1130      * Installs the given &lt;code&gt;java.util.Map&lt;/code&gt; object as the type map
1131      * associated with the &lt;code&gt;Connection&lt;/code&gt; object for this
1132      * &lt;code&gt;RowSet&lt;/code&gt; object.  The custom mapping indicated in
1133      * this type map will be used unless a different type map is explicitly
1134      * supplied to a method, in which case the type map supplied will be used.
1135      *
1136      * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object that contains the
1137      *     mapping from SQL type names for user defined types (UDT) to classes in
1138      *     the Java programming language.  Each entry in the &lt;code&gt;Map&lt;/code&gt;
1139      *     object consists of the fully qualified SQL name of a UDT and the
1140      *     &lt;code&gt;Class&lt;/code&gt; object for the &lt;code&gt;SQLData&lt;/code&gt; implementation
1141      *     of that UDT. May be &lt;code&gt;null&lt;/code&gt;.
1142      */
1143     public void setTypeMap(java.util.Map&lt;String,Class&lt;?&gt;&gt; map) {
1144         this.map = map;
1145     }
1146 
1147     /**
1148      * Retrieves the maximum number of bytes that can be used for a column
1149      * value in this &lt;code&gt;RowSet&lt;/code&gt; object.
1150      * This limit applies only to columns that hold values of the
1151      * following types:  &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;,
1152      * &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;,
1153      * and &lt;code&gt;LONGVARCHAR&lt;/code&gt;.  If the limit is exceeded, the excess
1154      * data is silently discarded.
1155      *
1156      * @return an &lt;code&gt;int&lt;/code&gt; indicating the current maximum column size
1157      *     limit; zero means that there is no limit
1158      * @throws SQLException if an error occurs internally determining the
1159      *    maximum limit of the column size
1160      */
1161     public int getMaxFieldSize() throws SQLException {
1162         return maxFieldSize;
1163     }
1164 
1165     /**
1166      * Sets the maximum number of bytes that can be used for a column
1167      * value in this &lt;code&gt;RowSet&lt;/code&gt; object to the given number.
1168      * This limit applies only to columns that hold values of the
1169      * following types:  &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;,
1170      * &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;,
1171      * and &lt;code&gt;LONGVARCHAR&lt;/code&gt;.  If the limit is exceeded, the excess
1172      * data is silently discarded. For maximum portability, it is advisable to
1173      * use values greater than 256.
1174      *
1175      * @param max an &lt;code&gt;int&lt;/code&gt; indicating the new maximum column size
1176      *     limit; zero means that there is no limit
1177      * @throws SQLException if (1) an error occurs internally setting the
1178      *     maximum limit of the column size or (2) a size of less than 0 is set
1179      */
1180     public void setMaxFieldSize(int max) throws SQLException {
1181         if (max &lt; 0) {
1182             throw new SQLException(&quot;Invalid max field size set. Cannot be of &quot; +
1183             &quot;value: &quot; + max);
1184         }
1185         maxFieldSize = max;
1186     }
1187 
1188     /**
1189      * Retrieves the maximum number of rows that this &lt;code&gt;RowSet&lt;/code&gt; object may contain. If
1190      * this limit is exceeded, the excess rows are silently dropped.
1191      *
1192      * @return an &lt;code&gt;int&lt;/code&gt; indicating the current maximum number of
1193      *     rows; zero means that there is no limit
1194      * @throws SQLException if an error occurs internally determining the
1195      *     maximum limit of rows that a &lt;code&gt;Rowset&lt;/code&gt; object can contain
1196      */
1197     public int getMaxRows() throws SQLException {
1198         return maxRows;
1199     }
1200 
1201     /**
1202      * Sets the maximum number of rows that this &lt;code&gt;RowSet&lt;/code&gt; object may contain to
1203      * the given number. If this limit is exceeded, the excess rows are
1204      * silently dropped.
1205      *
1206      * @param max an &lt;code&gt;int&lt;/code&gt; indicating the current maximum number
1207      *     of rows; zero means that there is no limit
1208      * @throws SQLException if an error occurs internally setting the
1209      *     maximum limit on the number of rows that a JDBC &lt;code&gt;RowSet&lt;/code&gt; object
1210      *     can contain; or if &lt;i&gt;max&lt;/i&gt; is less than &lt;code&gt;0&lt;/code&gt;; or
1211      *     if &lt;i&gt;max&lt;/i&gt; is less than the &lt;code&gt;fetchSize&lt;/code&gt; of the
1212      *     &lt;code&gt;RowSet&lt;/code&gt;
1213      */
1214     public void setMaxRows(int max) throws SQLException {
1215         if (max &lt; 0) {
1216             throw new SQLException(&quot;Invalid max row size set. Cannot be of &quot; +
1217                 &quot;value: &quot; + max);
1218         } else if (max &lt; this.getFetchSize()) {
1219             throw new SQLException(&quot;Invalid max row size set. Cannot be less &quot; +
1220                 &quot;than the fetchSize.&quot;);
1221         }
1222         this.maxRows = max;
1223     }
1224 
1225     /**
1226      * Sets to the given &lt;code&gt;boolean&lt;/code&gt; whether or not the driver will
1227      * scan for escape syntax and do escape substitution before sending SQL
1228      * statements to the database. The default is for the driver to do escape
1229      * processing.
1230      * &lt;P&gt;
1231      * Note: Since &lt;code&gt;PreparedStatement&lt;/code&gt; objects have usually been
1232      * parsed prior to making this call, disabling escape processing for
1233      * prepared statements will likely have no effect.
1234      *
1235      * @param enable &lt;code&gt;true&lt;/code&gt; to enable escape processing;
1236      *     &lt;code&gt;false&lt;/code&gt; to disable it
1237      * @throws SQLException if an error occurs setting the underlying JDBC
1238      * technology-enabled driver to process the escape syntax
1239      */
1240     public void setEscapeProcessing(boolean enable) throws SQLException {
1241         escapeProcessing = enable;
1242     }
1243 
1244     /**
1245      * Retrieves the maximum number of seconds the driver will wait for a
1246      * query to execute. If the limit is exceeded, an &lt;code&gt;SQLException&lt;/code&gt;
1247      * is thrown.
1248      *
1249      * @return the current query timeout limit in seconds; zero means that
1250      *     there is no limit
1251      * @throws SQLException if an error occurs in determining the query
1252      *     time-out value
1253      */
1254     public int getQueryTimeout() throws SQLException {
1255         return queryTimeout;
1256     }
1257 
1258     /**
1259      * Sets to the given number the maximum number of seconds the driver will
1260      * wait for a query to execute. If the limit is exceeded, an
1261      * &lt;code&gt;SQLException&lt;/code&gt; is thrown.
1262      *
1263      * @param seconds the new query time-out limit in seconds; zero means that
1264      *     there is no limit; must not be less than zero
1265      * @throws SQLException if an error occurs setting the query
1266      *     time-out or if the query time-out value is less than 0
1267      */
1268     public void setQueryTimeout(int seconds) throws SQLException {
1269         if (seconds &lt; 0) {
1270             throw new SQLException(&quot;Invalid query timeout value set. Cannot be &quot; +
1271             &quot;of value: &quot; + seconds);
1272         }
1273         this.queryTimeout = seconds;
1274     }
1275 
1276     /**
1277      * Retrieves a &lt;code&gt;boolean&lt;/code&gt; indicating whether rows marked
1278      * for deletion appear in the set of current rows.
1279      * The default value is &lt;code&gt;false&lt;/code&gt;.
1280      * &lt;P&gt;
1281      * Note: Allowing deleted rows to remain visible complicates the behavior
1282      * of some of the methods.  However, most &lt;code&gt;RowSet&lt;/code&gt; object users
1283      * can simply ignore this extra detail because only sophisticated
1284      * applications will likely want to take advantage of this feature.
1285      *
1286      * @return &lt;code&gt;true&lt;/code&gt; if deleted rows are visible;
1287      *         &lt;code&gt;false&lt;/code&gt; otherwise
1288      * @throws SQLException if an error occurs determining if deleted rows
1289      * are visible or not
1290      * @see #setShowDeleted
1291      */
1292     public boolean getShowDeleted() throws SQLException {
1293         return showDeleted;
1294     }
1295 
1296     /**
1297      * Sets the property &lt;code&gt;showDeleted&lt;/code&gt; to the given
1298      * &lt;code&gt;boolean&lt;/code&gt; value, which determines whether
1299      * rows marked for deletion appear in the set of current rows.
1300      *
1301      * @param value &lt;code&gt;true&lt;/code&gt; if deleted rows should be shown;
1302      *     &lt;code&gt;false&lt;/code&gt; otherwise
1303      * @throws SQLException if an error occurs setting whether deleted
1304      *     rows are visible or not
1305      * @see #getShowDeleted
1306      */
1307     public void setShowDeleted(boolean value) throws SQLException {
1308         showDeleted = value;
1309     }
1310 
1311     /**
1312      * Ascertains whether escape processing is enabled for this
1313      * &lt;code&gt;RowSet&lt;/code&gt; object.
1314      *
1315      * @return &lt;code&gt;true&lt;/code&gt; if escape processing is turned on;
1316      *         &lt;code&gt;false&lt;/code&gt; otherwise
1317      * @throws SQLException if an error occurs determining if escape
1318      *     processing is enabled or not or if the internal escape
1319      *     processing trigger has not been enabled
1320      */
1321     public boolean getEscapeProcessing() throws SQLException {
1322         return escapeProcessing;
1323     }
1324 
1325     /**
1326      * Gives the driver a performance hint as to the direction in
1327      * which the rows in this &lt;code&gt;RowSet&lt;/code&gt; object will be
1328      * processed.  The driver may ignore this hint.
1329      * &lt;P&gt;
1330      * A &lt;code&gt;RowSet&lt;/code&gt; object inherits the default properties of the
1331      * &lt;code&gt;ResultSet&lt;/code&gt; object from which it got its data.  That
1332      * &lt;code&gt;ResultSet&lt;/code&gt; object&#39;s default fetch direction is set by
1333      * the &lt;code&gt;Statement&lt;/code&gt; object that created it.
1334      * &lt;P&gt;
1335      * This method applies to a &lt;code&gt;RowSet&lt;/code&gt; object only while it is
1336      * connected to a database using a JDBC driver.
1337      * &lt;p&gt;
1338      * A &lt;code&gt;RowSet&lt;/code&gt; object may use this method at any time to change
1339      * its setting for the fetch direction.
1340      *
1341      * @param direction one of &lt;code&gt;ResultSet.FETCH_FORWARD&lt;/code&gt;,
1342      *                  &lt;code&gt;ResultSet.FETCH_REVERSE&lt;/code&gt;, or
1343      *                  &lt;code&gt;ResultSet.FETCH_UNKNOWN&lt;/code&gt;
1344      * @throws SQLException if (1) the &lt;code&gt;RowSet&lt;/code&gt; type is
1345      *     &lt;code&gt;TYPE_FORWARD_ONLY&lt;/code&gt; and the given fetch direction is not
1346      *     &lt;code&gt;FETCH_FORWARD&lt;/code&gt; or (2) the given fetch direction is not
1347      *     one of the following:
1348      *        ResultSet.FETCH_FORWARD,
1349      *        ResultSet.FETCH_REVERSE, or
1350      *        ResultSet.FETCH_UNKNOWN
1351      * @see #getFetchDirection
1352      */
1353     public void setFetchDirection(int direction) throws SQLException {
1354         // Changed the condition checking to the below as there were two
1355         // conditions that had to be checked
1356         // 1. RowSet is TYPE_FORWARD_ONLY and direction is not FETCH_FORWARD
1357         // 2. Direction is not one of the valid values
1358 
1359         if (((getType() == ResultSet.TYPE_FORWARD_ONLY) &amp;&amp; (direction != ResultSet.FETCH_FORWARD)) ||
1360             ((direction != ResultSet.FETCH_FORWARD) &amp;&amp;
1361             (direction != ResultSet.FETCH_REVERSE) &amp;&amp;
1362             (direction != ResultSet.FETCH_UNKNOWN))) {
1363             throw new SQLException(&quot;Invalid Fetch Direction&quot;);
1364         }
1365         fetchDir = direction;
1366     }
1367 
1368     /**
1369      * Retrieves this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s current setting for the
1370      * fetch direction. The default type is &lt;code&gt;ResultSet.FETCH_FORWARD&lt;/code&gt;
1371      *
1372      * @return one of &lt;code&gt;ResultSet.FETCH_FORWARD&lt;/code&gt;,
1373      *                  &lt;code&gt;ResultSet.FETCH_REVERSE&lt;/code&gt;, or
1374      *                  &lt;code&gt;ResultSet.FETCH_UNKNOWN&lt;/code&gt;
1375      * @throws SQLException if an error occurs in determining the
1376      *     current fetch direction for fetching rows
1377      * @see #setFetchDirection
1378      */
1379     public int getFetchDirection() throws SQLException {
1380 
1381         //Added the following code to throw a
1382         //SQL Exception if the fetchDir is not
1383         //set properly.Bug id:4914155
1384 
1385         // This checking is not necessary!
1386 
1387         /*
1388          if((fetchDir != ResultSet.FETCH_FORWARD) &amp;&amp;
1389            (fetchDir != ResultSet.FETCH_REVERSE) &amp;&amp;
1390            (fetchDir != ResultSet.FETCH_UNKNOWN)) {
1391             throw new SQLException(&quot;Fetch Direction Invalid&quot;);
1392          }
1393          */
1394         return (fetchDir);
1395     }
1396 
1397     /**
1398      * Sets the fetch size for this &lt;code&gt;RowSet&lt;/code&gt; object to the given number of
1399      * rows.  The fetch size gives a JDBC technology-enabled driver (&quot;JDBC driver&quot;)
1400      * a hint as to the
1401      * number of rows that should be fetched from the database when more rows
1402      * are needed for this &lt;code&gt;RowSet&lt;/code&gt; object. If the fetch size specified
1403      * is zero, the driver ignores the value and is free to make its own best guess
1404      * as to what the fetch size should be.
1405      * &lt;P&gt;
1406      * A &lt;code&gt;RowSet&lt;/code&gt; object inherits the default properties of the
1407      * &lt;code&gt;ResultSet&lt;/code&gt; object from which it got its data.  That
1408      * &lt;code&gt;ResultSet&lt;/code&gt; object&#39;s default fetch size is set by
1409      * the &lt;code&gt;Statement&lt;/code&gt; object that created it.
1410      * &lt;P&gt;
1411      * This method applies to a &lt;code&gt;RowSet&lt;/code&gt; object only while it is
1412      * connected to a database using a JDBC driver.
1413      * For connected &lt;code&gt;RowSet&lt;/code&gt; implementations such as
1414      * &lt;code&gt;JdbcRowSet&lt;/code&gt;, this method has a direct and immediate effect
1415      * on the underlying JDBC driver.
1416      * &lt;P&gt;
1417      * A &lt;code&gt;RowSet&lt;/code&gt; object may use this method at any time to change
1418      * its setting for the fetch size.
1419      * &lt;p&gt;
1420      * For &lt;code&gt;RowSet&lt;/code&gt; implementations such as
1421      * &lt;code&gt;CachedRowSet&lt;/code&gt;, which operate in a disconnected environment,
1422      * the &lt;code&gt;SyncProvider&lt;/code&gt; object being used
1423      * may leverage the fetch size to poll the data source and
1424      * retrieve a number of rows that do not exceed the fetch size and that may
1425      * form a subset of the actual rows returned by the original query. This is
1426      * an implementation variance determined by the specific &lt;code&gt;SyncProvider&lt;/code&gt;
1427      * object employed by the disconnected &lt;code&gt;RowSet&lt;/code&gt; object.
1428      *
1429      * @param rows the number of rows to fetch; &lt;code&gt;0&lt;/code&gt; to let the
1430      *        driver decide what the best fetch size is; must not be less
1431      *        than &lt;code&gt;0&lt;/code&gt; or more than the maximum number of rows
1432      *        allowed for this &lt;code&gt;RowSet&lt;/code&gt; object (the number returned
1433      *        by a call to the method {@link #getMaxRows})
1434      * @throws SQLException if the specified fetch size is less than &lt;code&gt;0&lt;/code&gt;
1435      *        or more than the limit for the maximum number of rows
1436      * @see #getFetchSize
1437      */
1438     public void setFetchSize(int rows) throws SQLException {
1439         //Added this checking as maxRows can be 0 when this function is called
1440         //maxRows = 0 means rowset can hold any number of rows, os this checking
1441         // is needed to take care of this condition.
1442         if (getMaxRows() == 0 &amp;&amp; rows &gt;= 0)  {
1443             fetchSize = rows;
1444             return;
1445         }
1446         if ((rows &lt; 0) || (rows &gt; getMaxRows())) {
1447             throw new SQLException(&quot;Invalid fetch size set. Cannot be of &quot; +
1448             &quot;value: &quot; + rows);
1449         }
1450         fetchSize = rows;
1451     }
1452 
1453     /**
1454      * Returns the fetch size for this &lt;code&gt;RowSet&lt;/code&gt; object. The default
1455      * value is zero.
1456      *
1457      * @return the number of rows suggested as the fetch size when this &lt;code&gt;RowSet&lt;/code&gt; object
1458      *     needs more rows from the database
1459      * @throws SQLException if an error occurs determining the number of rows in the
1460      *     current fetch size
1461      * @see #setFetchSize
1462      */
1463     public int getFetchSize() throws SQLException {
1464         return fetchSize;
1465     }
1466 
1467     /**
1468      * Returns the concurrency for this &lt;code&gt;RowSet&lt;/code&gt; object.
1469      * The default is &lt;code&gt;CONCUR_UPDATABLE&lt;/code&gt; for both connected and
1470      * disconnected &lt;code&gt;RowSet&lt;/code&gt; objects.
1471      * &lt;P&gt;
1472      * An application can call the method &lt;code&gt;setConcurrency&lt;/code&gt; at any time
1473      * to change a &lt;code&gt;RowSet&lt;/code&gt; object&#39;s concurrency.
1474      *
1475      * @return the concurrency type for this &lt;code&gt;RowSet&lt;/code&gt;
1476      *     object, which must be one of the following:
1477      *     &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt; or
1478      *     &lt;code&gt;ResultSet.CONCUR_UPDATABLE&lt;/code&gt;
1479      * @throws SQLException if an error occurs getting the concurrency
1480      *     of this &lt;code&gt;RowSet&lt;/code&gt; object
1481      * @see #setConcurrency
1482      * @see #isReadOnly
1483      */
1484     public int getConcurrency() throws SQLException {
1485         return concurrency;
1486     }
1487 
1488     //-----------------------------------------------------------------------
1489     // Parameters
1490     //-----------------------------------------------------------------------
1491 
1492     /**
1493      * Checks the given index to see whether it is less than &lt;code&gt;1&lt;/code&gt; and
1494      * throws an &lt;code&gt;SQLException&lt;/code&gt; object if it is.
1495      * &lt;P&gt;
1496      * This method is called by many methods internally; it is never
1497      * called by an application directly.
1498      *
1499      * @param idx an &lt;code&gt;int&lt;/code&gt; indicating which parameter is to be
1500      *     checked; the first parameter is &lt;code&gt;1&lt;/code&gt;
1501      * @throws SQLException if the parameter is less than &lt;code&gt;1&lt;/code&gt;
1502      */
1503     private void checkParamIndex(int idx) throws SQLException {
1504         if ((idx &lt; 1)) {
1505             throw new SQLException(&quot;Invalid Parameter Index&quot;);
1506         }
1507     }
1508 
1509     //---------------------------------------------------------------------
1510     // setter methods for setting the parameters in a &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
1511     //---------------------------------------------------------------------
1512 
1513     /**
1514      * Sets the designated parameter to SQL &lt;code&gt;NULL&lt;/code&gt;.
1515      * Note that the parameter&#39;s SQL type must be specified using one of the
1516          * type codes defined in &lt;code&gt;java.sql.Types&lt;/code&gt;.  This SQL type is
1517      * specified in the second parameter.
1518      * &lt;p&gt;
1519      * Note that the second parameter tells the DBMS the data type of the value being
1520      * set to &lt;code&gt;NULL&lt;/code&gt;. Some DBMSs require this information, so it is required
1521      * in order to make code more portable.
1522      * &lt;P&gt;
1523      * The parameter value set by this method is stored internally and
1524      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1525      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1526      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1527      * provided in any class that extends this class and implements one or
1528      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1529      * &lt;P&gt;
1530      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1531      * as it is undefined in this class.
1532      * &lt;P&gt;
1533      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
1534      * &lt;code&gt;setNull&lt;/code&gt;
1535      * has been called will return an &lt;code&gt;Object&lt;/code&gt; array containing the parameter values that
1536      * have been set.  In that array, the element that represents the values
1537      * set with this method will itself be an array. The first element of that array
1538      * is &lt;code&gt;null&lt;/code&gt;.
1539      * The second element is the value set for &lt;i&gt;sqlType&lt;/i&gt;.
1540      * The parameter number is indicated by an element&#39;s position in the array
1541      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
1542      * with the first element being the value for the first placeholder parameter, the
1543      * second element being the value for the second placeholder parameter, and so on.
1544      * In other words, if the second placeholder parameter is being set to
1545      * &lt;code&gt;null&lt;/code&gt;, the array containing it will be the second element in
1546      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
1547      * &lt;P&gt;
1548      * Note that because the numbering of elements in an array starts at zero,
1549      * the array element that corresponds to placeholder parameter number
1550      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
1551      *
1552      * @param parameterIndex the ordinal number of the placeholder parameter
1553      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1554      *        The first parameter is 1, the second is 2, and so on; must be
1555      *        &lt;code&gt;1&lt;/code&gt; or greater
1556      * @param sqlType an &lt;code&gt;int&lt;/code&gt; that is one of the SQL type codes
1557      *        defined in the class {@link java.sql.Types}. If a non-standard
1558      *        &lt;i&gt;sqlType&lt;/i&gt; is supplied, this method will not throw a
1559      *        &lt;code&gt;SQLException&lt;/code&gt;. This allows implicit support for
1560      *        non-standard SQL types.
1561      * @throws SQLException if a database access error occurs or the given
1562      *        parameter index is out of bounds
1563      * @see #getParams
1564      */
1565     public void setNull(int parameterIndex, int sqlType) throws SQLException {
1566         Object nullVal[];
1567         checkParamIndex(parameterIndex);
1568 
1569         nullVal = new Object[2];
1570         nullVal[0] = null;
1571         nullVal[1] = Integer.valueOf(sqlType);
1572 
1573        if (params == null){
1574             throw new SQLException(&quot;Set initParams() before setNull&quot;);
1575        }
1576 
1577         params.put(Integer.valueOf(parameterIndex - 1), nullVal);
1578     }
1579 
1580     /**
1581      * Sets the designated parameter to SQL &lt;code&gt;NULL&lt;/code&gt;.
1582      *
1583      * Although this version of the  method &lt;code&gt;setNull&lt;/code&gt; is intended
1584      * for user-defined
1585      * and &lt;code&gt;REF&lt;/code&gt; parameters, this method may be used to set a null
1586      * parameter for any JDBC type. The following are user-defined types:
1587      * &lt;code&gt;STRUCT&lt;/code&gt;, &lt;code&gt;DISTINCT&lt;/code&gt;, and &lt;code&gt;JAVA_OBJECT&lt;/code&gt;,
1588      * and named array types.
1589      *
1590      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; To be portable, applications must give the
1591      * SQL type code and the fully qualified SQL type name when specifying
1592      * a &lt;code&gt;NULL&lt;/code&gt; user-defined or &lt;code&gt;REF&lt;/code&gt; parameter.
1593      * In the case of a user-defined type, the name is the type name of
1594      * the parameter itself.  For a &lt;code&gt;REF&lt;/code&gt; parameter, the name is
1595      * the type name of the referenced type.  If a JDBC technology-enabled
1596      * driver does not need the type code or type name information,
1597      * it may ignore it.
1598      * &lt;P&gt;
1599      * If the parameter does not have a user-defined or &lt;code&gt;REF&lt;/code&gt; type,
1600      * the given &lt;code&gt;typeName&lt;/code&gt; parameter is ignored.
1601      * &lt;P&gt;
1602      * The parameter value set by this method is stored internally and
1603      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1604      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1605      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1606      * provided in any class that extends this class and implements one or
1607      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1608      * &lt;P&gt;
1609      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1610      * as it is undefined in this class.
1611      * &lt;P&gt;
1612      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
1613      * &lt;code&gt;setNull&lt;/code&gt;
1614      * has been called will return an &lt;code&gt;Object&lt;/code&gt; array containing the parameter values that
1615      * have been set.  In that array, the element that represents the values
1616      * set with this method will itself be an array. The first element of that array
1617      * is &lt;code&gt;null&lt;/code&gt;.
1618      * The second element is the value set for &lt;i&gt;sqlType&lt;/i&gt;, and the third
1619      * element is the value set for &lt;i&gt;typeName&lt;/i&gt;.
1620      * The parameter number is indicated by an element&#39;s position in the array
1621      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
1622      * with the first element being the value for the first placeholder parameter, the
1623      * second element being the value for the second placeholder parameter, and so on.
1624      * In other words, if the second placeholder parameter is being set to
1625      * &lt;code&gt;null&lt;/code&gt;, the array containing it will be the second element in
1626      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
1627      * &lt;P&gt;
1628      * Note that because the numbering of elements in an array starts at zero,
1629      * the array element that corresponds to placeholder parameter number
1630      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
1631      *
1632      * @param parameterIndex the ordinal number of the placeholder parameter
1633      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1634      *        The first parameter is 1, the second is 2, and so on; must be
1635      *        &lt;code&gt;1&lt;/code&gt; or greater
1636      * @param sqlType a value from &lt;code&gt;java.sql.Types&lt;/code&gt;
1637      * @param typeName the fully qualified name of an SQL user-defined type,
1638      *                 which is ignored if the parameter is not a user-defined
1639      *                 type or &lt;code&gt;REF&lt;/code&gt; value
1640      * @throws SQLException if an error occurs or the given parameter index
1641      *            is out of bounds
1642      * @see #getParams
1643      */
1644     public void setNull(int parameterIndex, int sqlType, String typeName)
1645         throws SQLException {
1646 
1647         Object nullVal[];
1648         checkParamIndex(parameterIndex);
1649 
1650         nullVal = new Object[3];
1651         nullVal[0] = null;
1652         nullVal[1] = Integer.valueOf(sqlType);
1653         nullVal[2] = typeName;
1654 
1655        if(params == null){
1656             throw new SQLException(&quot;Set initParams() before setNull&quot;);
1657        }
1658 
1659         params.put(Integer.valueOf(parameterIndex - 1), nullVal);
1660     }
1661 
1662 
1663     /**
1664      * Sets the designated parameter to the given &lt;code&gt;boolean&lt;/code&gt; in the
1665      * Java programming language.  The driver converts this to an SQL
1666      * &lt;code&gt;BIT&lt;/code&gt; value when it sends it to the database.
1667      * &lt;P&gt;
1668      * The parameter value set by this method is stored internally and
1669      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1670      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1671      * Methods such as &lt;code&gt;execute&lt;/code&gt;, &lt;code&gt;populate&lt;/code&gt; must be
1672      * provided in any class that extends this class and implements one or
1673      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1674      * &lt;p&gt;
1675      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1676      * as it is undefined in this class.
1677      *
1678      * @param parameterIndex the ordinal number of the placeholder parameter
1679      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1680      *        The first parameter is 1, the second is 2, and so on; must be
1681      *        &lt;code&gt;1&lt;/code&gt; or greater
1682      * @param x the parameter value
1683      * @throws SQLException if an error occurs or the
1684      *                         parameter index is out of bounds
1685      * @see #getParams
1686      */
1687     public void setBoolean(int parameterIndex, boolean x) throws SQLException {
1688         checkParamIndex(parameterIndex);
1689 
1690        if(params == null){
1691             throw new SQLException(&quot;Set initParams() before setNull&quot;);
1692        }
1693 
1694         params.put(Integer.valueOf(parameterIndex - 1), Boolean.valueOf(x));
1695     }
1696 
1697     /**
1698      * Sets the designated parameter to the given &lt;code&gt;byte&lt;/code&gt; in the Java
1699      * programming language.  The driver converts this to an SQL
1700      * &lt;code&gt;TINYINT&lt;/code&gt; value when it sends it to the database.
1701      * &lt;P&gt;
1702      * The parameter value set by this method is stored internally and
1703      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1704      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1705      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1706      * provided in any class that extends this class and implements one or
1707      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1708      * &lt;p&gt;
1709      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1710      * as it is undefined in this class.
1711      *
1712      * @param parameterIndex the ordinal number of the placeholder parameter
1713      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1714      *        The first parameter is 1, the second is 2, and so on; must be
1715      *        &lt;code&gt;1&lt;/code&gt; or greater
1716      * @param x the parameter value
1717      * @throws SQLException if an error occurs or the
1718      *                         parameter index is out of bounds
1719      * @see #getParams
1720      */
1721     public void setByte(int parameterIndex, byte x) throws SQLException {
1722         checkParamIndex(parameterIndex);
1723 
1724        if(params == null){
1725             throw new SQLException(&quot;Set initParams() before setByte&quot;);
1726        }
1727 
1728         params.put(Integer.valueOf(parameterIndex - 1), Byte.valueOf(x));
1729     }
1730 
1731     /**
1732      * Sets the designated parameter to the given &lt;code&gt;short&lt;/code&gt; in the
1733      * Java programming language.  The driver converts this to an SQL
1734      * &lt;code&gt;SMALLINT&lt;/code&gt; value when it sends it to the database.
1735      * &lt;P&gt;
1736      * The parameter value set by this method is stored internally and
1737      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1738      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1739      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1740      * provided in any class that extends this class and implements one or
1741      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1742      * &lt;p&gt;
1743      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1744      * as it is undefined in this class.
1745      *
1746      * @param parameterIndex the ordinal number of the placeholder parameter
1747      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1748      *        The first parameter is 1, the second is 2, and so on; must be
1749      *        &lt;code&gt;1&lt;/code&gt; or greater
1750      * @param x the parameter value
1751      * @throws SQLException if an error occurs or the
1752      *                         parameter index is out of bounds
1753      * @see #getParams
1754      */
1755     public void setShort(int parameterIndex, short x) throws SQLException {
1756         checkParamIndex(parameterIndex);
1757 
1758         if(params == null){
1759              throw new SQLException(&quot;Set initParams() before setShort&quot;);
1760         }
1761 
1762         params.put(Integer.valueOf(parameterIndex - 1), Short.valueOf(x));
1763     }
1764 
1765     /**
1766      * Sets the designated parameter to an &lt;code&gt;int&lt;/code&gt; in the Java
1767      * programming language.  The driver converts this to an SQL
1768      * &lt;code&gt;INTEGER&lt;/code&gt; value when it sends it to the database.
1769      * &lt;P&gt;
1770      * The parameter value set by this method is stored internally and
1771      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1772      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1773      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1774      * provided in any class that extends this class and implements one or
1775      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1776      * &lt;P&gt;
1777      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1778      * as it is undefined in this class.
1779      *
1780      * @param parameterIndex the ordinal number of the placeholder parameter
1781      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1782      *        The first parameter is 1, the second is 2, and so on; must be
1783      *        &lt;code&gt;1&lt;/code&gt; or greater
1784      * @param x the parameter value
1785      * @throws SQLException if an error occurs or the
1786      *                         parameter index is out of bounds
1787      * @see #getParams
1788      */
1789     public void setInt(int parameterIndex, int x) throws SQLException {
1790         checkParamIndex(parameterIndex);
1791         if(params == null){
1792              throw new SQLException(&quot;Set initParams() before setInt&quot;);
1793         }
1794         params.put(Integer.valueOf(parameterIndex - 1), Integer.valueOf(x));
1795     }
1796 
1797     /**
1798      * Sets the designated parameter to the given &lt;code&gt;long&lt;/code&gt; in the Java
1799      * programming language.  The driver converts this to an SQL
1800      * &lt;code&gt;BIGINT&lt;/code&gt; value when it sends it to the database.
1801      * &lt;P&gt;
1802      * The parameter value set by this method is stored internally and
1803      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1804      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1805      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1806      * provided in any class that extends this class and implements one or
1807      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1808      * &lt;P&gt;
1809      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1810      * as it is undefined in this class.
1811      *
1812      * @param parameterIndex the ordinal number of the placeholder parameter
1813      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1814      *        The first parameter is 1, the second is 2, and so on; must be
1815      *        &lt;code&gt;1&lt;/code&gt; or greater
1816      * @param x the parameter value
1817      * @throws SQLException if an error occurs or the
1818      *                         parameter index is out of bounds
1819      * @see #getParams
1820      */
1821     public void setLong(int parameterIndex, long x) throws SQLException {
1822         checkParamIndex(parameterIndex);
1823         if(params == null){
1824              throw new SQLException(&quot;Set initParams() before setLong&quot;);
1825         }
1826         params.put(Integer.valueOf(parameterIndex - 1), Long.valueOf(x));
1827     }
1828 
1829     /**
1830      * Sets the designated parameter to the given &lt;code&gt;float&lt;/code&gt; in the
1831      * Java programming language.  The driver converts this to an SQL
1832      * &lt;code&gt;FLOAT&lt;/code&gt; value when it sends it to the database.
1833      * &lt;P&gt;
1834      * The parameter value set by this method is stored internally and
1835      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1836      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1837      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1838      * provided in any class that extends this class and implements one or
1839      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1840      * &lt;P&gt;
1841      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1842      * as it is undefined in this class.
1843      *
1844      * @param parameterIndex the ordinal number of the placeholder parameter
1845      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1846      *        The first parameter is 1, the second is 2, and so on; must be
1847      *        &lt;code&gt;1&lt;/code&gt; or greater
1848      * @param x the parameter value
1849      * @throws SQLException if an error occurs or the
1850      *                         parameter index is out of bounds
1851      * @see #getParams
1852      */
1853     public void setFloat(int parameterIndex, float x) throws SQLException {
1854         checkParamIndex(parameterIndex);
1855         if(params == null){
1856              throw new SQLException(&quot;Set initParams() before setFloat&quot;);
1857         }
1858         params.put(Integer.valueOf(parameterIndex - 1), Float.valueOf(x));
1859     }
1860 
1861     /**
1862      * Sets the designated parameter to the given &lt;code&gt;double&lt;/code&gt; in the
1863      * Java programming language.  The driver converts this to an SQL
1864      * &lt;code&gt;DOUBLE&lt;/code&gt; value when it sends it to the database.
1865      * &lt;P&gt;
1866      * The parameter value set by this method is stored internally and
1867      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1868      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1869      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1870      * provided in any class that extends this class and implements one or
1871      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1872      * &lt;P&gt;
1873      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1874      * as it is undefined in this class.
1875      *
1876      * @param parameterIndex the ordinal number of the placeholder parameter
1877      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1878      *        The first parameter is 1, the second is 2, and so on; must be
1879      *        &lt;code&gt;1&lt;/code&gt; or greater
1880      * @param x the parameter value
1881      * @throws SQLException if an error occurs or the
1882      *                         parameter index is out of bounds
1883      * @see #getParams
1884      */
1885     public void setDouble(int parameterIndex, double x) throws SQLException {
1886         checkParamIndex(parameterIndex);
1887         if(params == null){
1888              throw new SQLException(&quot;Set initParams() before setDouble&quot;);
1889         }
1890         params.put(Integer.valueOf(parameterIndex - 1), Double.valueOf(x));
1891     }
1892 
1893     /**
1894      * Sets the designated parameter to the given
1895      * &lt;code&gt;java.lang.BigDecimal&lt;/code&gt; value.  The driver converts this to
1896      * an SQL &lt;code&gt;NUMERIC&lt;/code&gt; value when it sends it to the database.
1897      * &lt;P&gt;
1898      * The parameter value set by this method is stored internally and
1899      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1900      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1901      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1902      * provided in any class that extends this class and implements one or
1903      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1904      * &lt;P&gt;
1905      * Note: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1906      * as it is undefined in this class.
1907      *
1908      * @param parameterIndex the ordinal number of the placeholder parameter
1909      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1910      *        The first parameter is 1, the second is 2, and so on; must be
1911      *        &lt;code&gt;1&lt;/code&gt; or greater
1912      * @param x the parameter value
1913      * @throws SQLException if an error occurs or the
1914      *                         parameter index is out of bounds
1915      * @see #getParams
1916      */
1917     public void setBigDecimal(int parameterIndex, java.math.BigDecimal x) throws SQLException {
1918         checkParamIndex(parameterIndex);
1919         if(params == null){
1920              throw new SQLException(&quot;Set initParams() before setBigDecimal&quot;);
1921         }
1922         params.put(Integer.valueOf(parameterIndex - 1), x);
1923     }
1924 
1925     /**
1926      * Sets the designated parameter to the given &lt;code&gt;String&lt;/code&gt;
1927      * value.  The driver converts this to an SQL
1928      * &lt;code&gt;VARCHAR&lt;/code&gt; or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value
1929      * (depending on the argument&#39;s size relative to the driver&#39;s limits
1930      * on &lt;code&gt;VARCHAR&lt;/code&gt; values) when it sends it to the database.
1931      * &lt;P&gt;
1932      * The parameter value set by this method is stored internally and
1933      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1934      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1935      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1936      * provided in any class that extends this class and implements one or
1937      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1938      * &lt;p&gt;
1939      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1940      * as it is undefined in this class.
1941      *
1942      * @param parameterIndex the ordinal number of the placeholder parameter
1943      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1944      *        The first parameter is 1, the second is 2, and so on; must be
1945      *        &lt;code&gt;1&lt;/code&gt; or greater
1946      * @param x the parameter value
1947      * @throws SQLException if an error occurs or the
1948      *                         parameter index is out of bounds
1949      * @see #getParams
1950      */
1951     public void setString(int parameterIndex, String x) throws SQLException {
1952         checkParamIndex(parameterIndex);
1953         if(params == null){
1954              throw new SQLException(&quot;Set initParams() before setString&quot;);
1955         }
1956         params.put(Integer.valueOf(parameterIndex - 1), x);
1957     }
1958 
1959     /**
1960      * Sets the designated parameter to the given array of bytes.
1961      * The driver converts this to an SQL
1962      * &lt;code&gt;VARBINARY&lt;/code&gt; or &lt;code&gt;LONGVARBINARY&lt;/code&gt; value
1963      * (depending on the argument&#39;s size relative to the driver&#39;s limits
1964      * on &lt;code&gt;VARBINARY&lt;/code&gt; values) when it sends it to the database.
1965      * &lt;P&gt;
1966      * The parameter value set by this method is stored internally and
1967      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
1968      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
1969      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
1970      * provided in any class that extends this class and implements one or
1971      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
1972      * &lt;p&gt;
1973      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
1974      * as it is undefined in this class.
1975      *
1976      * @param parameterIndex the ordinal number of the placeholder parameter
1977      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
1978      *        The first parameter is 1, the second is 2, and so on; must be
1979      *        &lt;code&gt;1&lt;/code&gt; or greater
1980      * @param x the parameter value
1981      * @throws SQLException if an error occurs or the
1982      *                         parameter index is out of bounds
1983      * @see #getParams
1984      */
1985     public void setBytes(int parameterIndex, byte x[]) throws SQLException {
1986         checkParamIndex(parameterIndex);
1987         if(params == null){
1988              throw new SQLException(&quot;Set initParams() before setBytes&quot;);
1989         }
1990         params.put(Integer.valueOf(parameterIndex - 1), x);
1991     }
1992 
1993     /**
1994      * Sets the designated parameter to the given &lt;code&gt;java.sql.Date&lt;/code&gt;
1995      * value. The driver converts this to an SQL
1996      * &lt;code&gt;DATE&lt;/code&gt; value when it sends it to the database.
1997      * &lt;P&gt;
1998      * The parameter value set by this method is stored internally and
1999      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2000      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2001      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2002      * provided in any class that extends this class and implements one or
2003      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2004      * &lt;P&gt;
2005      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2006      * as it is undefined in this class.
2007      * &lt;P&gt;
2008      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version
2009      * of &lt;code&gt;setDate&lt;/code&gt;
2010      * has been called will return an array with the value to be set for
2011      * placeholder parameter number &lt;i&gt;parameterIndex&lt;/i&gt; being the &lt;code&gt;Date&lt;/code&gt;
2012      * object supplied as the second parameter.
2013      * Note that because the numbering of elements in an array starts at zero,
2014      * the array element that corresponds to placeholder parameter number
2015      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2016      *
2017      * @param parameterIndex the ordinal number of the placeholder parameter
2018      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2019      *        The first parameter is 1, the second is 2, and so on; must be
2020      *        &lt;code&gt;1&lt;/code&gt; or greater
2021      * @param x the parameter value
2022      * @throws SQLException if an error occurs or the
2023      *                         parameter index is out of bounds
2024      * @see #getParams
2025      */
2026     public void setDate(int parameterIndex, java.sql.Date x) throws SQLException {
2027         checkParamIndex(parameterIndex);
2028 
2029         if(params == null){
2030              throw new SQLException(&quot;Set initParams() before setDate&quot;);
2031         }
2032         params.put(Integer.valueOf(parameterIndex - 1), x);
2033     }
2034 
2035     /**
2036      * Sets the designated parameter to the given &lt;code&gt;java.sql.Time&lt;/code&gt;
2037      * value.  The driver converts this to an SQL &lt;code&gt;TIME&lt;/code&gt; value
2038      * when it sends it to the database.
2039      * &lt;P&gt;
2040      * The parameter value set by this method is stored internally and
2041      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2042      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2043      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2044      * provided in any class that extends this class and implements one or
2045      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2046      * &lt;P&gt;
2047      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2048      * as it is undefined in this class.
2049      * &lt;P&gt;
2050      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version
2051      * of the method &lt;code&gt;setTime&lt;/code&gt;
2052      * has been called will return an array of the parameters that have been set.
2053      * The parameter to be set for parameter placeholder number &lt;i&gt;parameterIndex&lt;/i&gt;
2054      * will be the &lt;code&gt;Time&lt;/code&gt; object that was set as the second parameter
2055      * to this method.
2056      * &lt;P&gt;
2057      * Note that because the numbering of elements in an array starts at zero,
2058      * the array element that corresponds to placeholder parameter number
2059      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2060      *
2061      * @param parameterIndex the ordinal number of the placeholder parameter
2062      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2063      *        The first parameter is 1, the second is 2, and so on; must be
2064      *        &lt;code&gt;1&lt;/code&gt; or greater
2065      * @param x a &lt;code&gt;java.sql.Time&lt;/code&gt; object, which is to be set as the value
2066      *              for placeholder parameter &lt;i&gt;parameterIndex&lt;/i&gt;
2067      * @throws SQLException if an error occurs or the
2068      *                         parameter index is out of bounds
2069      * @see #getParams
2070      */
2071     public void setTime(int parameterIndex, java.sql.Time x) throws SQLException {
2072         checkParamIndex(parameterIndex);
2073         if(params == null){
2074              throw new SQLException(&quot;Set initParams() before setTime&quot;);
2075         }
2076 
2077         params.put(Integer.valueOf(parameterIndex - 1), x);
2078     }
2079 
2080     /**
2081      * Sets the designated parameter to the given
2082      * &lt;code&gt;java.sql.Timestamp&lt;/code&gt; value.
2083      * The driver converts this to an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value when it
2084      * sends it to the database.
2085      * &lt;P&gt;
2086      * The parameter value set by this method is stored internally and
2087      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2088      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2089      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2090      * provided in any class that extends this class and implements one or
2091      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2092      * &lt;P&gt;
2093      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2094      * as it is undefined in this class.
2095      * &lt;P&gt;
2096      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
2097      * &lt;code&gt;setTimestamp&lt;/code&gt;
2098      * has been called will return an array with the value for parameter placeholder
2099      * number &lt;i&gt;parameterIndex&lt;/i&gt; being the &lt;code&gt;Timestamp&lt;/code&gt; object that was
2100      * supplied as the second parameter to this method.
2101      * Note that because the numbering of elements in an array starts at zero,
2102      * the array element that corresponds to placeholder parameter number
2103      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2104      *
2105      * @param parameterIndex the ordinal number of the placeholder parameter
2106      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2107      *        The first parameter is 1, the second is 2, and so on; must be
2108      *        &lt;code&gt;1&lt;/code&gt; or greater
2109      * @param x a &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object
2110      * @throws SQLException if an error occurs or the
2111      *                         parameter index is out of bounds
2112      * @see #getParams
2113      */
2114     public void setTimestamp(int parameterIndex, java.sql.Timestamp x) throws SQLException {
2115         checkParamIndex(parameterIndex);
2116         if(params == null){
2117              throw new SQLException(&quot;Set initParams() before setTimestamp&quot;);
2118         }
2119 
2120         params.put(Integer.valueOf(parameterIndex - 1), x);
2121     }
2122 
2123     /**
2124      * Sets the designated parameter to the given
2125      * &lt;code&gt;java.io.InputStream&lt;/code&gt; object,
2126      * which will have the specified number of bytes.
2127      * The contents of the stream will be read and sent to the database.
2128      * This method throws an &lt;code&gt;SQLException&lt;/code&gt; object if the number of bytes
2129      * read and sent to the database is not equal to &lt;i&gt;length&lt;/i&gt;.
2130      * &lt;P&gt;
2131      * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
2132      * parameter, it may be more practical to send it via a
2133      * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. A JDBC technology-enabled
2134      * driver will read the data from the stream as needed until it reaches
2135      * end-of-file. The driver will do any necessary conversion from ASCII to
2136      * the database &lt;code&gt;CHAR&lt;/code&gt; format.
2137      *
2138      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can be either a standard
2139      * Java stream object or your own subclass that implements the
2140      * standard interface.
2141      * &lt;P&gt;
2142      * The parameter value set by this method is stored internally and
2143      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2144      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2145      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2146      * provided in any class that extends this class and implements one or
2147      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2148      * &lt;P&gt;
2149      * Note: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2150      * as it is undefined in this class.
2151      * &lt;P&gt;
2152      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after &lt;code&gt;setAsciiStream&lt;/code&gt;
2153      * has been called will return an array containing the parameter values that
2154      * have been set.  The element in the array that represents the values
2155      * set with this method will itself be an array. The first element of that array
2156      * is the given &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
2157      * The second element is the value set for &lt;i&gt;length&lt;/i&gt;.
2158      * The third element is an internal &lt;code&gt;BaseRowSet&lt;/code&gt; constant
2159      * specifying that the stream passed to this method is an ASCII stream.
2160      * The parameter number is indicated by an element&#39;s position in the array
2161      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2162      * with the first element being the value for the first placeholder parameter, the
2163      * second element being the value for the second placeholder parameter, and so on.
2164      * In other words, if the input stream being set is the value for the second
2165      * placeholder parameter, the array containing it will be the second element in
2166      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2167      * &lt;P&gt;
2168      * Note that because the numbering of elements in an array starts at zero,
2169      * the array element that corresponds to placeholder parameter number
2170      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2171      *
2172      * @param parameterIndex the ordinal number of the placeholder parameter
2173      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2174      *        The first parameter is 1, the second is 2, and so on; must be
2175      *        &lt;code&gt;1&lt;/code&gt; or greater
2176      * @param x the Java input stream that contains the ASCII parameter value
2177      * @param length the number of bytes in the stream. This is the number of bytes
2178      *       the driver will send to the DBMS; lengths of 0 or less are
2179      *       are undefined but will cause an invalid length exception to be
2180      *       thrown in the underlying JDBC driver.
2181      * @throws SQLException if an error occurs, the parameter index is out of bounds,
2182      *       or when connected to a data source, the number of bytes the driver reads
2183      *       and sends to the database is not equal to the number of bytes specified
2184      *       in &lt;i&gt;length&lt;/i&gt;
2185      * @see #getParams
2186      */
2187     public void setAsciiStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException {
2188         Object asciiStream[];
2189         checkParamIndex(parameterIndex);
2190 
2191         asciiStream = new Object[3];
2192         asciiStream[0] = x;
2193         asciiStream[1] = Integer.valueOf(length);
2194         asciiStream[2] = Integer.valueOf(ASCII_STREAM_PARAM);
2195 
2196         if(params == null){
2197              throw new SQLException(&quot;Set initParams() before setAsciiStream&quot;);
2198         }
2199 
2200         params.put(Integer.valueOf(parameterIndex - 1), asciiStream);
2201     }
2202 
2203   /**
2204    * Sets the designated parameter in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
2205    * to the given input stream.
2206    * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
2207    * parameter, it may be more practical to send it via a
2208    * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
2209    * as needed until end-of-file is reached.  The JDBC driver will
2210    * do any necessary conversion from ASCII to the database char format.
2211    *
2212    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
2213    * Java stream object or your own subclass that implements the
2214    * standard interface.
2215    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
2216    * it might be more efficient to use a version of
2217    * &lt;code&gt;setAsciiStream&lt;/code&gt; which takes a length parameter.
2218    *
2219    * @param parameterIndex the first parameter is 1, the second is 2, ...
2220    * @param x the Java input stream that contains the ASCII parameter value
2221    * @exception SQLException if a database access error occurs or
2222    * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
2223    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
2224    * @since 1.6
2225    */
2226   public void setAsciiStream(int parameterIndex, java.io.InputStream x)
2227                       throws SQLException {
2228       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
2229   }
2230 
2231     /**
2232      * Sets the designated parameter to the given &lt;code&gt;java.io.InputStream&lt;/code&gt;
2233      * object, which will have the specified number of bytes.
2234      * The contents of the stream will be read and sent to the database.
2235      * This method throws an &lt;code&gt;SQLException&lt;/code&gt; object if the number of bytes
2236      * read and sent to the database is not equal to &lt;i&gt;length&lt;/i&gt;.
2237      * &lt;P&gt;
2238      * When a very large binary value is input to a
2239      * &lt;code&gt;LONGVARBINARY&lt;/code&gt; parameter, it may be more practical
2240      * to send it via a &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
2241      * A JDBC technology-enabled driver will read the data from the
2242      * stream as needed until it reaches end-of-file.
2243      *
2244      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can be either a standard
2245      * Java stream object or your own subclass that implements the
2246      * standard interface.
2247      * &lt;P&gt;
2248      * The parameter value set by this method is stored internally and
2249      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2250      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2251      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2252      * provided in any class that extends this class and implements one or
2253      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2254      *&lt;P&gt;
2255      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2256      * as it is undefined in this class.
2257      * &lt;P&gt;
2258      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after &lt;code&gt;setBinaryStream&lt;/code&gt;
2259      * has been called will return an array containing the parameter values that
2260      * have been set.  In that array, the element that represents the values
2261      * set with this method will itself be an array. The first element of that array
2262      * is the given &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
2263      * The second element is the value set for &lt;i&gt;length&lt;/i&gt;.
2264      * The third element is an internal &lt;code&gt;BaseRowSet&lt;/code&gt; constant
2265      * specifying that the stream passed to this method is a binary stream.
2266      * The parameter number is indicated by an element&#39;s position in the array
2267      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2268      * with the first element being the value for the first placeholder parameter, the
2269      * second element being the value for the second placeholder parameter, and so on.
2270      * In other words, if the input stream being set is the value for the second
2271      * placeholder parameter, the array containing it will be the second element in
2272      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2273      * &lt;P&gt;
2274      * Note that because the numbering of elements in an array starts at zero,
2275      * the array element that corresponds to placeholder parameter number
2276      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2277      *
2278      * @param parameterIndex the ordinal number of the placeholder parameter
2279      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2280      *        The first parameter is 1, the second is 2, and so on; must be
2281      *        &lt;code&gt;1&lt;/code&gt; or greater
2282      * @param x the input stream that contains the binary value to be set
2283      * @param length the number of bytes in the stream; lengths of 0 or less are
2284      *         are undefined but will cause an invalid length exception to be
2285      *         thrown in the underlying JDBC driver.
2286      * @throws SQLException if an error occurs, the parameter index is out of bounds,
2287      *         or when connected to a data source, the number of bytes the driver
2288      *         reads and sends to the database is not equal to the number of bytes
2289      *         specified in &lt;i&gt;length&lt;/i&gt;
2290      * @see #getParams
2291      */
2292     public void setBinaryStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException {
2293         Object binaryStream[];
2294         checkParamIndex(parameterIndex);
2295 
2296         binaryStream = new Object[3];
2297         binaryStream[0] = x;
2298         binaryStream[1] = Integer.valueOf(length);
2299         binaryStream[2] = Integer.valueOf(BINARY_STREAM_PARAM);
2300         if(params == null){
2301              throw new SQLException(&quot;Set initParams() before setBinaryStream&quot;);
2302         }
2303 
2304         params.put(Integer.valueOf(parameterIndex - 1), binaryStream);
2305     }
2306 
2307 
2308    /**
2309    * Sets the designated parameter in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
2310    * to the given input stream.
2311    * When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt;
2312    * parameter, it may be more practical to send it via a
2313    * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The data will be read from the
2314    * stream as needed until end-of-file is reached.
2315    *
2316    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
2317    * Java stream object or your own subclass that implements the
2318    * standard interface.
2319    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
2320    * it might be more efficient to use a version of
2321    * &lt;code&gt;setBinaryStream&lt;/code&gt; which takes a length parameter.
2322    *
2323    * @param parameterIndex the first parameter is 1, the second is 2, ...
2324    * @param x the java input stream which contains the binary parameter value
2325    * @exception SQLException if a database access error occurs or
2326    * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
2327    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
2328    * @since 1.6
2329    */
2330   public void setBinaryStream(int parameterIndex, java.io.InputStream x)
2331                               throws SQLException {
2332       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
2333   }
2334 
2335 
2336     /**
2337      * Sets the designated parameter to the given
2338      * &lt;code&gt;java.io.InputStream&lt;/code&gt; object, which will have the specified
2339      * number of bytes. The contents of the stream will be read and sent
2340      * to the database.
2341      * This method throws an &lt;code&gt;SQLException&lt;/code&gt; if the number of bytes
2342      * read and sent to the database is not equal to &lt;i&gt;length&lt;/i&gt;.
2343      * &lt;P&gt;
2344      * When a very large Unicode value is input to a
2345      * &lt;code&gt;LONGVARCHAR&lt;/code&gt; parameter, it may be more practical
2346      * to send it via a &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
2347      * A JDBC technology-enabled driver will read the data from the
2348      * stream as needed, until it reaches end-of-file.
2349      * The driver will do any necessary conversion from Unicode to the
2350      * database &lt;code&gt;CHAR&lt;/code&gt; format.
2351      * The byte format of the Unicode stream must be Java UTF-8, as
2352      * defined in the Java Virtual Machine Specification.
2353      *
2354      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can be either a standard
2355      * Java stream object or your own subclass that implements the
2356      * standard interface.
2357      * &lt;P&gt;
2358      * This method is deprecated; the method &lt;code&gt;getCharacterStream&lt;/code&gt;
2359      * should be used in its place.
2360      * &lt;P&gt;
2361      * The parameter value set by this method is stored internally and
2362      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2363      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2364      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after &lt;code&gt;setUnicodeStream&lt;/code&gt;
2365      * has been called will return an array containing the parameter values that
2366      * have been set.  In that array, the element that represents the values
2367      * set with this method will itself be an array. The first element of that array
2368      * is the given &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
2369      * The second element is the value set for &lt;i&gt;length&lt;/i&gt;.
2370      * The third element is an internal &lt;code&gt;BaseRowSet&lt;/code&gt; constant
2371      * specifying that the stream passed to this method is a Unicode stream.
2372      * The parameter number is indicated by an element&#39;s position in the array
2373      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2374      * with the first element being the value for the first placeholder parameter, the
2375      * second element being the value for the second placeholder parameter, and so on.
2376      * In other words, if the input stream being set is the value for the second
2377      * placeholder parameter, the array containing it will be the second element in
2378      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2379      * &lt;P&gt;
2380      * Note that because the numbering of elements in an array starts at zero,
2381      * the array element that corresponds to placeholder parameter number
2382      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2383      *
2384      * @param parameterIndex the ordinal number of the placeholder parameter
2385      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2386      *        The first parameter is 1, the second is 2, and so on; must be
2387      *        &lt;code&gt;1&lt;/code&gt; or greater
2388      * @param x the &lt;code&gt;java.io.InputStream&lt;/code&gt; object that contains the
2389      *          UNICODE parameter value
2390      * @param length the number of bytes in the input stream
2391      * @throws SQLException if an error occurs, the parameter index is out of bounds,
2392      *         or the number of bytes the driver reads and sends to the database is
2393      *         not equal to the number of bytes specified in &lt;i&gt;length&lt;/i&gt;
2394      * @deprecated getCharacterStream should be used in its place
2395      * @see #getParams
2396      */
2397     @Deprecated
2398     public void setUnicodeStream(int parameterIndex, java.io.InputStream x, int length) throws SQLException {
2399         Object unicodeStream[];
2400         checkParamIndex(parameterIndex);
2401 
2402         unicodeStream = new Object[3];
2403         unicodeStream[0] = x;
2404         unicodeStream[1] = Integer.valueOf(length);
2405         unicodeStream[2] = Integer.valueOf(UNICODE_STREAM_PARAM);
2406         if(params == null){
2407              throw new SQLException(&quot;Set initParams() before setUnicodeStream&quot;);
2408         }
2409         params.put(Integer.valueOf(parameterIndex - 1), unicodeStream);
2410     }
2411 
2412     /**
2413      * Sets the designated parameter to the given &lt;code&gt;java.io.Reader&lt;/code&gt;
2414      * object, which will have the specified number of characters. The
2415      * contents of the reader will be read and sent to the database.
2416      * This method throws an &lt;code&gt;SQLException&lt;/code&gt; if the number of bytes
2417      * read and sent to the database is not equal to &lt;i&gt;length&lt;/i&gt;.
2418      * &lt;P&gt;
2419      * When a very large Unicode value is input to a
2420      * &lt;code&gt;LONGVARCHAR&lt;/code&gt; parameter, it may be more practical
2421      * to send it via a &lt;code&gt;Reader&lt;/code&gt; object.
2422      * A JDBC technology-enabled driver will read the data from the
2423      * stream as needed until it reaches end-of-file.
2424      * The driver will do any necessary conversion from Unicode to the
2425      * database &lt;code&gt;CHAR&lt;/code&gt; format.
2426      * The byte format of the Unicode stream must be Java UTF-8, as
2427      * defined in the Java Virtual Machine Specification.
2428      *
2429      * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can be either a standard
2430      * Java stream object or your own subclass that implements the
2431      * standard interface.
2432      * &lt;P&gt;
2433      * The parameter value set by this method is stored internally and
2434      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2435      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2436      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2437      * provided in any class that extends this class and implements one or
2438      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2439      * &lt;P&gt;
2440      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2441      * as it is undefined in this class.
2442      * &lt;P&gt;
2443      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after
2444      * &lt;code&gt;setCharacterStream&lt;/code&gt;
2445      * has been called will return an array containing the parameter values that
2446      * have been set.  In that array, the element that represents the values
2447      * set with this method will itself be an array. The first element of that array
2448      * is the given &lt;code&gt;java.io.Reader&lt;/code&gt; object.
2449      * The second element is the value set for &lt;i&gt;length&lt;/i&gt;.
2450      * The parameter number is indicated by an element&#39;s position in the array
2451      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2452      * with the first element being the value for the first placeholder parameter, the
2453      * second element being the value for the second placeholder parameter, and so on.
2454      * In other words, if the reader being set is the value for the second
2455      * placeholder parameter, the array containing it will be the second element in
2456      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2457      * &lt;P&gt;
2458      * Note that because the numbering of elements in an array starts at zero,
2459      * the array element that corresponds to placeholder parameter number
2460      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2461      *
2462      * @param parameterIndex the ordinal number of the placeholder parameter
2463      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2464      *        The first parameter is 1, the second is 2, and so on; must be
2465      *        &lt;code&gt;1&lt;/code&gt; or greater
2466      * @param reader the &lt;code&gt;Reader&lt;/code&gt; object that contains the
2467      *        Unicode data
2468      * @param length the number of characters in the stream; lengths of 0 or
2469      *        less are undefined but will cause an invalid length exception to
2470      *        be thrown in the underlying JDBC driver.
2471      * @throws SQLException if an error occurs, the parameter index is out of bounds,
2472      *        or when connected to a data source, the number of bytes the driver
2473      *        reads and sends to the database is not equal to the number of bytes
2474      *        specified in &lt;i&gt;length&lt;/i&gt;
2475      * @see #getParams
2476      */
2477     public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException {
2478         Object charStream[];
2479         checkParamIndex(parameterIndex);
2480 
2481         charStream = new Object[2];
2482         charStream[0] = reader;
2483         charStream[1] = Integer.valueOf(length);
2484         if(params == null){
2485              throw new SQLException(&quot;Set initParams() before setCharacterStream&quot;);
2486         }
2487         params.put(Integer.valueOf(parameterIndex - 1), charStream);
2488     }
2489 
2490    /**
2491    * Sets the designated parameter in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
2492    * to the given &lt;code&gt;Reader&lt;/code&gt;
2493    * object.
2494    * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
2495    * parameter, it may be more practical to send it via a
2496    * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
2497    * as needed until end-of-file is reached.  The JDBC driver will
2498    * do any necessary conversion from UNICODE to the database char format.
2499    *
2500    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
2501    * Java stream object or your own subclass that implements the
2502    * standard interface.
2503    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
2504    * it might be more efficient to use a version of
2505    * &lt;code&gt;setCharacterStream&lt;/code&gt; which takes a length parameter.
2506    *
2507    * @param parameterIndex the first parameter is 1, the second is 2, ...
2508    * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object that contains the
2509    *        Unicode data
2510    * @exception SQLException if a database access error occurs or
2511    * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
2512    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
2513    * @since 1.6
2514    */
2515   public void setCharacterStream(int parameterIndex,
2516                           java.io.Reader reader) throws SQLException {
2517       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
2518   }
2519 
2520     /**
2521      * Sets the designated parameter to an &lt;code&gt;Object&lt;/code&gt; in the Java
2522      * programming language. The second parameter must be an
2523      * &lt;code&gt;Object&lt;/code&gt; type.  For integral values, the
2524      * &lt;code&gt;java.lang&lt;/code&gt; equivalent
2525      * objects should be used. For example, use the class &lt;code&gt;Integer&lt;/code&gt;
2526      * for an &lt;code&gt;int&lt;/code&gt;.
2527      * &lt;P&gt;
2528      * The driver converts this object to the specified
2529      * target SQL type before sending it to the database.
2530      * If the object has a custom mapping (is of a class implementing
2531      * &lt;code&gt;SQLData&lt;/code&gt;), the driver should call the method
2532      * &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write the object to the SQL
2533      * data stream. If, on the other hand, the object is of a class
2534      * implementing &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;,
2535      * &lt;code&gt;Struct&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;,
2536      * the driver should pass it to the database as a value of the
2537      * corresponding SQL type.
2538      *
2539      * &lt;p&gt;Note that this method may be used to pass database-
2540      * specific abstract data types.
2541      * &lt;P&gt;
2542      * The parameter value set by this method is stored internally and
2543      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2544      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2545      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2546      * provided in any class that extends this class and implements one or
2547      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2548      * &lt;P&gt;
2549      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2550      * as it is undefined in this class.
2551      * &lt;P&gt;
2552      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
2553      * &lt;code&gt;setObject&lt;/code&gt;
2554      * has been called will return an array containing the parameter values that
2555      * have been set.  In that array, the element that represents the values
2556      * set with this method will itself be an array. The first element of that array
2557      * is the given &lt;code&gt;Object&lt;/code&gt; instance, and the
2558      * second element is the value set for &lt;i&gt;targetSqlType&lt;/i&gt;.  The
2559      * third element is the value set for &lt;i&gt;scale&lt;/i&gt;, which the driver will
2560      * ignore if the type of the object being set is not
2561      * &lt;code&gt;java.sql.Types.NUMERIC&lt;/code&gt; or &lt;code&gt;java.sql.Types.DECIMAL&lt;/code&gt;.
2562      * The parameter number is indicated by an element&#39;s position in the array
2563      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2564      * with the first element being the value for the first placeholder parameter, the
2565      * second element being the value for the second placeholder parameter, and so on.
2566      * In other words, if the object being set is the value for the second
2567      * placeholder parameter, the array containing it will be the second element in
2568      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2569      *&lt;P&gt;
2570      * Note that because the numbering of elements in an array starts at zero,
2571      * the array element that corresponds to placeholder parameter number
2572      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2573      *
2574      *
2575      * @param parameterIndex the ordinal number of the placeholder parameter
2576      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2577      *        The first parameter is 1, the second is 2, and so on; must be
2578      *        &lt;code&gt;1&lt;/code&gt; or greater
2579      * @param x the &lt;code&gt;Object&lt;/code&gt; containing the input parameter value;
2580      *        must be an &lt;code&gt;Object&lt;/code&gt; type
2581      * @param targetSqlType the SQL type (as defined in &lt;code&gt;java.sql.Types&lt;/code&gt;)
2582      *        to be sent to the database. The &lt;code&gt;scale&lt;/code&gt; argument may
2583      *        further qualify this type. If a non-standard &lt;i&gt;targetSqlType&lt;/i&gt;
2584      *        is supplied, this method will not throw a &lt;code&gt;SQLException&lt;/code&gt;.
2585      *        This allows implicit support for non-standard SQL types.
2586      * @param scale for the types &lt;code&gt;java.sql.Types.DECIMAL&lt;/code&gt; and
2587      *        &lt;code&gt;java.sql.Types.NUMERIC&lt;/code&gt;, this is the number
2588      *        of digits after the decimal point.  For all other types, this
2589      *        value will be ignored.
2590      * @throws SQLException if an error occurs or the parameter index is out of bounds
2591      * @see #getParams
2592      */
2593     public void setObject(int parameterIndex, Object x, int targetSqlType, int scale) throws SQLException {
2594         Object obj[];
2595         checkParamIndex(parameterIndex);
2596 
2597         obj = new Object[3];
2598         obj[0] = x;
2599         obj[1] = Integer.valueOf(targetSqlType);
2600         obj[2] = Integer.valueOf(scale);
2601         if(params == null){
2602              throw new SQLException(&quot;Set initParams() before setObject&quot;);
2603         }
2604         params.put(Integer.valueOf(parameterIndex - 1), obj);
2605     }
2606 
2607     /**
2608      * Sets the value of the designated parameter with the given
2609      * &lt;code&gt;Object&lt;/code&gt; value.
2610      * This method is like &lt;code&gt;setObject(int parameterIndex, Object x, int
2611      * targetSqlType, int scale)&lt;/code&gt; except that it assumes a scale of zero.
2612      * &lt;P&gt;
2613      * The parameter value set by this method is stored internally and
2614      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2615      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2616      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2617      * provided in any class that extends this class and implements one or
2618      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2619      * &lt;P&gt;
2620      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2621      * as it is undefined in this class.
2622      * &lt;P&gt;
2623      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
2624      * &lt;code&gt;setObject&lt;/code&gt;
2625      * has been called will return an array containing the parameter values that
2626      * have been set.  In that array, the element that represents the values
2627      * set with this method will itself be an array. The first element of that array
2628      * is the given &lt;code&gt;Object&lt;/code&gt; instance.
2629      * The second element is the value set for &lt;i&gt;targetSqlType&lt;/i&gt;.
2630      * The parameter number is indicated by an element&#39;s position in the array
2631      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2632      * with the first element being the value for the first placeholder parameter, the
2633      * second element being the value for the second placeholder parameter, and so on.
2634      * In other words, if the object being set is the value for the second
2635      * placeholder parameter, the array containing it will be the second element in
2636      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2637      * &lt;P&gt;
2638      * Note that because the numbering of elements in an array starts at zero,
2639      * the array element that corresponds to placeholder parameter number
2640      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2641      *
2642      * @param parameterIndex the ordinal number of the placeholder parameter
2643      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2644      *        The first parameter is 1, the second is 2, and so on; must be
2645      *        &lt;code&gt;1&lt;/code&gt; or greater
2646      * @param x the &lt;code&gt;Object&lt;/code&gt; containing the input parameter value;
2647      *        must be an &lt;code&gt;Object&lt;/code&gt; type
2648      * @param targetSqlType the SQL type (as defined in &lt;code&gt;java.sql.Types&lt;/code&gt;)
2649      *        to be sent to the database. If a non-standard &lt;i&gt;targetSqlType&lt;/i&gt;
2650      *        is supplied, this method will not throw a &lt;code&gt;SQLException&lt;/code&gt;.
2651      *        This allows implicit support for non-standard SQL types.
2652      * @throws SQLException if an error occurs or the parameter index
2653      *        is out of bounds
2654      * @see #getParams
2655      */
2656     public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {
2657         Object obj[];
2658         checkParamIndex(parameterIndex);
2659 
2660         obj = new Object[2];
2661         obj[0] = x;
2662         obj[1] = Integer.valueOf(targetSqlType);
2663         if (params == null){
2664              throw new SQLException(&quot;Set initParams() before setObject&quot;);
2665         }
2666         params.put(Integer.valueOf(parameterIndex - 1), obj);
2667     }
2668 
2669     /**
2670      * Sets the designated parameter to an &lt;code&gt;Object&lt;/code&gt; in the Java
2671      * programming language. The second parameter must be an
2672      * &lt;code&gt;Object&lt;/code&gt;
2673      * type.  For integral values, the &lt;code&gt;java.lang&lt;/code&gt; equivalent
2674      * objects should be used. For example, use the class &lt;code&gt;Integer&lt;/code&gt;
2675      * for an &lt;code&gt;int&lt;/code&gt;.
2676      * &lt;P&gt;
2677      * The JDBC specification defines a standard mapping from
2678      * Java &lt;code&gt;Object&lt;/code&gt; types to SQL types.  The driver will
2679      * use this standard mapping to  convert the given object
2680      * to its corresponding SQL type before sending it to the database.
2681      * If the object has a custom mapping (is of a class implementing
2682      * &lt;code&gt;SQLData&lt;/code&gt;), the driver should call the method
2683      * &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write the object to the SQL
2684      * data stream.
2685      * &lt;P&gt;
2686      * If, on the other hand, the object is of a class
2687      * implementing &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;,
2688      * &lt;code&gt;Struct&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;,
2689      * the driver should pass it to the database as a value of the
2690      * corresponding SQL type.
2691      * &lt;P&gt;
2692      * This method throws an exception if there
2693      * is an ambiguity, for example, if the object is of a class
2694      * implementing more than one interface.
2695      * &lt;P&gt;
2696      * Note that this method may be used to pass database-specific
2697      * abstract data types.
2698      * &lt;P&gt;
2699      * The parameter value set by this method is stored internally and
2700      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2701      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2702      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2703      * provided in any class that extends this class and implements one or
2704      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2705      * &lt;p&gt;
2706      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2707      * as it is undefined in this class.
2708      * &lt;P&gt;
2709      * After this method has been called, a call to the
2710      * method &lt;code&gt;getParams&lt;/code&gt;
2711      * will return an object array of the current command parameters, which will
2712      * include the &lt;code&gt;Object&lt;/code&gt; set for placeholder parameter number
2713      * &lt;code&gt;parameterIndex&lt;/code&gt;.
2714      * Note that because the numbering of elements in an array starts at zero,
2715      * the array element that corresponds to placeholder parameter number
2716      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2717      *
2718      * @param parameterIndex the ordinal number of the placeholder parameter
2719      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2720      *        The first parameter is 1, the second is 2, and so on; must be
2721      *        &lt;code&gt;1&lt;/code&gt; or greater
2722      * @param x the object containing the input parameter value
2723      * @throws SQLException if an error occurs the
2724      *                         parameter index is out of bounds, or there
2725      *                         is ambiguity in the implementation of the
2726      *                         object being set
2727      * @see #getParams
2728      */
2729     public void setObject(int parameterIndex, Object x) throws SQLException {
2730         checkParamIndex(parameterIndex);
2731         if (params == null) {
2732              throw new SQLException(&quot;Set initParams() before setObject&quot;);
2733         }
2734         params.put(Integer.valueOf(parameterIndex - 1), x);
2735     }
2736 
2737     /**
2738      * Sets the designated parameter to the given &lt;code&gt;Ref&lt;/code&gt; object in
2739      * the Java programming language.  The driver converts this to an SQL
2740      * &lt;code&gt;REF&lt;/code&gt; value when it sends it to the database. Internally, the
2741      * &lt;code&gt;Ref&lt;/code&gt; is represented as a &lt;code&gt;SerialRef&lt;/code&gt; to ensure
2742      * serializability.
2743      * &lt;P&gt;
2744      * The parameter value set by this method is stored internally and
2745      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2746      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2747      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2748      * provided in any class that extends this class and implements one or
2749      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2750      * &lt;p&gt;
2751      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2752      * as it is undefined in this class.
2753      * &lt;p&gt;
2754      * After this method has been called, a call to the
2755      * method &lt;code&gt;getParams&lt;/code&gt;
2756      * will return an object array of the current command parameters, which will
2757      * include the &lt;code&gt;Ref&lt;/code&gt; object set for placeholder parameter number
2758      * &lt;code&gt;parameterIndex&lt;/code&gt;.
2759      * Note that because the numbering of elements in an array starts at zero,
2760      * the array element that corresponds to placeholder parameter number
2761      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2762      *
2763      * @param parameterIndex the ordinal number of the placeholder parameter
2764      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2765      *        The first parameter is 1, the second is 2, and so on; must be
2766      *        &lt;code&gt;1&lt;/code&gt; or greater
2767      * @param ref a &lt;code&gt;Ref&lt;/code&gt; object representing an SQL &lt;code&gt;REF&lt;/code&gt;
2768      *         value; cannot be null
2769      * @throws SQLException if an error occurs; the parameter index is out of
2770      *         bounds or the &lt;code&gt;Ref&lt;/code&gt; object is &lt;code&gt;null&lt;/code&gt;; or
2771      *         the &lt;code&gt;Ref&lt;/code&gt; object returns a &lt;code&gt;null&lt;/code&gt; base type
2772      *         name.
2773      * @see #getParams
2774      * @see javax.sql.rowset.serial.SerialRef
2775      */
2776     public void setRef (int parameterIndex, Ref ref) throws SQLException {
2777         checkParamIndex(parameterIndex);
2778         if (params == null) {
2779              throw new SQLException(&quot;Set initParams() before setRef&quot;);
2780         }
2781         params.put(Integer.valueOf(parameterIndex - 1), new SerialRef(ref));
2782     }
2783 
2784     /**
2785      * Sets the designated parameter to the given &lt;code&gt;Blob&lt;/code&gt; object in
2786      * the Java programming language.  The driver converts this to an SQL
2787      * &lt;code&gt;BLOB&lt;/code&gt; value when it sends it to the database. Internally,
2788      * the &lt;code&gt;Blob&lt;/code&gt; is represented as a &lt;code&gt;SerialBlob&lt;/code&gt;
2789      * to ensure serializability.
2790      * &lt;P&gt;
2791      * The parameter value set by this method is stored internally and
2792      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2793      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2794      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2795      * provided in any class that extends this class and implements one or
2796      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2797      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2798      * as it is undefined in this class.
2799      * &lt;p&gt;
2800      * After this method has been called, a call to the
2801      * method &lt;code&gt;getParams&lt;/code&gt;
2802      * will return an object array of the current command parameters, which will
2803      * include the &lt;code&gt;Blob&lt;/code&gt; object set for placeholder parameter number
2804      * &lt;code&gt;parameterIndex&lt;/code&gt;.
2805      * Note that because the numbering of elements in an array starts at zero,
2806      * the array element that corresponds to placeholder parameter number
2807      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2808      *
2809      * @param parameterIndex the ordinal number of the placeholder parameter
2810      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2811      *        The first parameter is 1, the second is 2, and so on; must be
2812      *        &lt;code&gt;1&lt;/code&gt; or greater
2813      * @param x a &lt;code&gt;Blob&lt;/code&gt; object representing an SQL
2814      *          &lt;code&gt;BLOB&lt;/code&gt; value
2815      * @throws SQLException if an error occurs or the
2816      *                         parameter index is out of bounds
2817      * @see #getParams
2818      * @see javax.sql.rowset.serial.SerialBlob
2819      */
2820     public void setBlob (int parameterIndex, Blob x) throws SQLException {
2821         checkParamIndex(parameterIndex);
2822         if(params == null){
2823              throw new SQLException(&quot;Set initParams() before setBlob&quot;);
2824         }
2825         params.put(Integer.valueOf(parameterIndex - 1), new SerialBlob(x));
2826     }
2827 
2828     /**
2829      * Sets the designated parameter to the given &lt;code&gt;Clob&lt;/code&gt; object in
2830      * the Java programming language.  The driver converts this to an SQL
2831      * &lt;code&gt;CLOB&lt;/code&gt; value when it sends it to the database. Internally, the
2832      * &lt;code&gt;Clob&lt;/code&gt; is represented as a &lt;code&gt;SerialClob&lt;/code&gt; to ensure
2833      * serializability.
2834      * &lt;P&gt;
2835      * The parameter value set by this method is stored internally and
2836      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2837      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2838      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2839      * provided in any class that extends this class and implements one or
2840      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2841      * &lt;p&gt;
2842      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2843      * as it is undefined in this class.
2844      * &lt;p&gt;
2845      * After this method has been called, a call to the
2846      * method &lt;code&gt;getParams&lt;/code&gt;
2847      * will return an object array of the current command parameters, which will
2848      * include the &lt;code&gt;Clob&lt;/code&gt; object set for placeholder parameter number
2849      * &lt;code&gt;parameterIndex&lt;/code&gt;.
2850      * Note that because the numbering of elements in an array starts at zero,
2851      * the array element that corresponds to placeholder parameter number
2852      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2853      *
2854      * @param parameterIndex the ordinal number of the placeholder parameter
2855      *     in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2856      *     The first parameter is 1, the second is 2, and so on; must be
2857      *     &lt;code&gt;1&lt;/code&gt; or greater
2858      * @param x a &lt;code&gt;Clob&lt;/code&gt; object representing an SQL
2859      *     &lt;code&gt;CLOB&lt;/code&gt; value; cannot be null
2860      * @throws SQLException if an error occurs; the parameter index is out of
2861      *     bounds or the &lt;code&gt;Clob&lt;/code&gt; is null
2862      * @see #getParams
2863      * @see javax.sql.rowset.serial.SerialBlob
2864      */
2865     public void setClob (int parameterIndex, Clob x) throws SQLException {
2866         checkParamIndex(parameterIndex);
2867         if(params == null){
2868              throw new SQLException(&quot;Set initParams() before setClob&quot;);
2869         }
2870         params.put(Integer.valueOf(parameterIndex - 1), new SerialClob(x));
2871     }
2872 
2873     /**
2874      * Sets the designated parameter to an &lt;code&gt;Array&lt;/code&gt; object in the
2875      * Java programming language.  The driver converts this to an SQL
2876      * &lt;code&gt;ARRAY&lt;/code&gt; value when it sends it to the database. Internally,
2877      * the &lt;code&gt;Array&lt;/code&gt; is represented as a &lt;code&gt;SerialArray&lt;/code&gt;
2878      * to ensure serializability.
2879      * &lt;P&gt;
2880      * The parameter value set by this method is stored internally and
2881      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2882      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2883      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2884      * provided in any class that extends this class and implements one or
2885      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2886      * &lt;P&gt;
2887      * Note: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2888      * as it is undefined in this class.
2889      * &lt;p&gt;
2890      * After this method has been called, a call to the
2891      * method &lt;code&gt;getParams&lt;/code&gt;
2892      * will return an object array of the current command parameters, which will
2893      * include the &lt;code&gt;Array&lt;/code&gt; object set for placeholder parameter number
2894      * &lt;code&gt;parameterIndex&lt;/code&gt;.
2895      * Note that because the numbering of elements in an array starts at zero,
2896      * the array element that corresponds to placeholder parameter number
2897      * &lt;i&gt;parameterIndex&lt;/i&gt; is element number &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2898      *
2899      * @param parameterIndex the ordinal number of the placeholder parameter
2900      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2901      *        The first parameter is 1, the second is 2, and so on; must be
2902      *        &lt;code&gt;1&lt;/code&gt; or greater
2903      * @param array an &lt;code&gt;Array&lt;/code&gt; object representing an SQL
2904      *        &lt;code&gt;ARRAY&lt;/code&gt; value; cannot be null. The &lt;code&gt;Array&lt;/code&gt; object
2905      *        passed to this method must return a non-null Object for all
2906      *        &lt;code&gt;getArray()&lt;/code&gt; method calls. A null value will cause a
2907      *        &lt;code&gt;SQLException&lt;/code&gt; to be thrown.
2908      * @throws SQLException if an error occurs; the parameter index is out of
2909      *        bounds or the &lt;code&gt;ARRAY&lt;/code&gt; is null
2910      * @see #getParams
2911      * @see javax.sql.rowset.serial.SerialArray
2912      */
2913     public void setArray (int parameterIndex, Array array) throws SQLException {
2914         checkParamIndex(parameterIndex);
2915         if (params == null){
2916              throw new SQLException(&quot;Set initParams() before setArray&quot;);
2917         }
2918         params.put(Integer.valueOf(parameterIndex - 1), new SerialArray(array));
2919     }
2920 
2921     /**
2922      * Sets the designated parameter to the given &lt;code&gt;java.sql.Date&lt;/code&gt;
2923      * object.
2924      * When the DBMS does not store time zone information, the driver will use
2925      * the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;DATE&lt;/code&gt;
2926      * value to send to the database. With a
2927      * &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the date
2928      * taking into account a custom time zone.  If no &lt;code&gt;Calendar&lt;/code&gt;
2929      * object is specified, the driver uses the time zone of the Virtual Machine
2930      * that is running the application.
2931      * &lt;P&gt;
2932      * The parameter value set by this method is stored internally and
2933      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
2934      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
2935      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
2936      * provided in any class that extends this class and implements one or
2937      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
2938      * &lt;P&gt;
2939      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
2940      * as it is undefined in this class.
2941      * &lt;P&gt;
2942      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
2943      * &lt;code&gt;setDate&lt;/code&gt;
2944      * has been called will return an array containing the parameter values that
2945      * have been set.  In that array, the element that represents the values
2946      * set with this method will itself be an array. The first element of that array
2947      * is the given &lt;code&gt;java.sql.Date&lt;/code&gt; object.
2948      * The second element is the value set for &lt;i&gt;cal&lt;/i&gt;.
2949      * The parameter number is indicated by an element&#39;s position in the array
2950      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
2951      * with the first element being the value for the first placeholder parameter, the
2952      * second element being the value for the second placeholder parameter, and so on.
2953      * In other words, if the date being set is the value for the second
2954      * placeholder parameter, the array containing it will be the second element in
2955      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
2956      * &lt;P&gt;
2957      * Note that because the numbering of elements in an array starts at zero,
2958      * the array element that corresponds to placeholder parameter number
2959      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
2960      *
2961      * @param parameterIndex the ordinal number of the placeholder parameter
2962      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
2963      *        The first parameter is 1, the second is 2, and so on; must be
2964      *        &lt;code&gt;1&lt;/code&gt; or greater
2965      * @param x a &lt;code&gt;java.sql.Date&lt;/code&gt; object representing an SQL
2966      *        &lt;code&gt;DATE&lt;/code&gt; value
2967      * @param cal a &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use when
2968      *        when constructing the date
2969      * @throws SQLException if an error occurs or the
2970      *                         parameter index is out of bounds
2971      * @see #getParams
2972      */
2973     public void setDate(int parameterIndex, java.sql.Date x, Calendar cal) throws SQLException {
2974         Object date[];
2975         checkParamIndex(parameterIndex);
2976 
2977         date = new Object[2];
2978         date[0] = x;
2979         date[1] = cal;
2980         if(params == null){
2981              throw new SQLException(&quot;Set initParams() before setDate&quot;);
2982         }
2983         params.put(Integer.valueOf(parameterIndex - 1), date);
2984     }
2985 
2986     /**
2987      * Sets the designated parameter to the given &lt;code&gt;java.sql.Time&lt;/code&gt;
2988      * object.  The driver converts this
2989      * to an SQL &lt;code&gt;TIME&lt;/code&gt; value when it sends it to the database.
2990      * &lt;P&gt;
2991      * When the DBMS does not store time zone information, the driver will use
2992      * the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;TIME&lt;/code&gt;
2993      * value to send to the database. With a
2994      * &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the date
2995      * taking into account a custom time zone.  If no &lt;code&gt;Calendar&lt;/code&gt;
2996      * object is specified, the driver uses the time zone of the Virtual Machine
2997      * that is running the application.
2998      * &lt;P&gt;
2999      * The parameter value set by this method is stored internally and
3000      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
3001      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
3002      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
3003      * provided in any class that extends this class and implements one or
3004      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
3005      * &lt;P&gt;
3006      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
3007      * as it is undefined in this class.
3008      * &lt;P&gt;
3009      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
3010      * &lt;code&gt;setTime&lt;/code&gt;
3011      * has been called will return an array containing the parameter values that
3012      * have been set.  In that array, the element that represents the values
3013      * set with this method will itself be an array. The first element of that array
3014      * is the given &lt;code&gt;java.sql.Time&lt;/code&gt; object.
3015      * The second element is the value set for &lt;i&gt;cal&lt;/i&gt;.
3016      * The parameter number is indicated by an element&#39;s position in the array
3017      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
3018      * with the first element being the value for the first placeholder parameter, the
3019      * second element being the value for the second placeholder parameter, and so on.
3020      * In other words, if the time being set is the value for the second
3021      * placeholder parameter, the array containing it will be the second element in
3022      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
3023      * &lt;P&gt;
3024      * Note that because the numbering of elements in an array starts at zero,
3025      * the array element that corresponds to placeholder parameter number
3026      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
3027      *
3028      * @param parameterIndex the ordinal number of the placeholder parameter
3029      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
3030      *        The first parameter is 1, the second is 2, and so on; must be
3031      *        &lt;code&gt;1&lt;/code&gt; or greater
3032      * @param x a &lt;code&gt;java.sql.Time&lt;/code&gt; object
3033      * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object the driver can use to
3034      *         construct the time
3035      * @throws SQLException if an error occurs or the
3036      *                         parameter index is out of bounds
3037      * @see #getParams
3038      */
3039     public void setTime(int parameterIndex, java.sql.Time x, Calendar cal) throws SQLException {
3040         Object time[];
3041         checkParamIndex(parameterIndex);
3042 
3043         time = new Object[2];
3044         time[0] = x;
3045         time[1] = cal;
3046         if(params == null){
3047              throw new SQLException(&quot;Set initParams() before setTime&quot;);
3048         }
3049         params.put(Integer.valueOf(parameterIndex - 1), time);
3050     }
3051 
3052     /**
3053      * Sets the designated parameter to the given
3054      * &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object.  The driver converts this
3055      * to an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value when it sends it to the database.
3056      * &lt;P&gt;
3057      * When the DBMS does not store time zone information, the driver will use
3058      * the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;TIMESTAMP&lt;/code&gt;
3059      * value to send to the database. With a
3060      * &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the timestamp
3061      * taking into account a custom time zone.  If no &lt;code&gt;Calendar&lt;/code&gt;
3062      * object is specified, the driver uses the time zone of the Virtual Machine
3063      * that is running the application.
3064      * &lt;P&gt;
3065      * The parameter value set by this method is stored internally and
3066      * will be supplied as the appropriate parameter in this &lt;code&gt;RowSet&lt;/code&gt;
3067      * object&#39;s command when the method &lt;code&gt;execute&lt;/code&gt; is called.
3068      * Methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt; must be
3069      * provided in any class that extends this class and implements one or
3070      * more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.
3071      * &lt;P&gt;
3072      * NOTE: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method
3073      * as it is undefined in this class.
3074      * &lt;P&gt;
3075      * Calls made to the method &lt;code&gt;getParams&lt;/code&gt; after this version of
3076      * &lt;code&gt;setTimestamp&lt;/code&gt;
3077      * has been called will return an array containing the parameter values that
3078      * have been set.  In that array, the element that represents the values
3079      * set with this method will itself be an array. The first element of that array
3080      * is the given &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object.
3081      * The second element is the value set for &lt;i&gt;cal&lt;/i&gt;.
3082      * The parameter number is indicated by an element&#39;s position in the array
3083      * returned by the method &lt;code&gt;getParams&lt;/code&gt;,
3084      * with the first element being the value for the first placeholder parameter, the
3085      * second element being the value for the second placeholder parameter, and so on.
3086      * In other words, if the timestamp being set is the value for the second
3087      * placeholder parameter, the array containing it will be the second element in
3088      * the array returned by &lt;code&gt;getParams&lt;/code&gt;.
3089      * &lt;P&gt;
3090      * Note that because the numbering of elements in an array starts at zero,
3091      * the array element that corresponds to placeholder parameter number
3092      * &lt;i&gt;parameterIndex&lt;/i&gt; is &lt;i&gt;parameterIndex&lt;/i&gt; -1.
3093      *
3094      * @param parameterIndex the ordinal number of the placeholder parameter
3095      *        in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command that is to be set.
3096      *        The first parameter is 1, the second is 2, and so on; must be
3097      *        &lt;code&gt;1&lt;/code&gt; or greater
3098      * @param x a &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object
3099      * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object the driver can use to
3100      *         construct the timestamp
3101      * @throws SQLException if an error occurs or the
3102      *                         parameter index is out of bounds
3103      * @see #getParams
3104      */
3105     public void setTimestamp(int parameterIndex, java.sql.Timestamp x, Calendar cal) throws SQLException {
3106         Object timestamp[];
3107         checkParamIndex(parameterIndex);
3108 
3109         timestamp = new Object[2];
3110         timestamp[0] = x;
3111         timestamp[1] = cal;
3112         if(params == null){
3113              throw new SQLException(&quot;Set initParams() before setTimestamp&quot;);
3114         }
3115         params.put(Integer.valueOf(parameterIndex - 1), timestamp);
3116     }
3117 
3118     /**
3119      * Clears all of the current parameter values in this &lt;code&gt;RowSet&lt;/code&gt;
3120      * object&#39;s internal representation of the parameters to be set in
3121      * this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command when it is executed.
3122      * &lt;P&gt;
3123      * In general, parameter values remain in force for repeated use in
3124      * this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command. Setting a parameter value with the
3125      * setter methods automatically clears the value of the
3126      * designated parameter and replaces it with the new specified value.
3127      * &lt;P&gt;
3128      * This method is called internally by the &lt;code&gt;setCommand&lt;/code&gt;
3129      * method to clear all of the parameters set for the previous command.
3130      * &lt;P&gt;
3131      * Furthermore, this method differs from the &lt;code&gt;initParams&lt;/code&gt;
3132      * method in that it maintains the schema of the &lt;code&gt;RowSet&lt;/code&gt; object.
3133      *
3134      * @throws SQLException if an error occurs clearing the parameters
3135      */
3136     public void clearParameters() throws SQLException {
3137         params.clear();
3138     }
3139 
3140     /**
3141      * Retrieves an array containing the parameter values (both Objects and
3142      * primitives) that have been set for this
3143      * &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command and throws an &lt;code&gt;SQLException&lt;/code&gt; object
3144      * if all parameters have not been set.   Before the command is sent to the
3145      * DBMS to be executed, these parameters will be substituted
3146      * for placeholder parameters in the  &lt;code&gt;PreparedStatement&lt;/code&gt; object
3147      * that is the command for a &lt;code&gt;RowSet&lt;/code&gt; implementation extending
3148      * the &lt;code&gt;BaseRowSet&lt;/code&gt; class.
3149      * &lt;P&gt;
3150      * Each element in the array that is returned is an &lt;code&gt;Object&lt;/code&gt; instance
3151      * that contains the values of the parameters supplied to a setter method.
3152      * The order of the elements is determined by the value supplied for
3153      * &lt;i&gt;parameterIndex&lt;/i&gt;.  If the setter method takes only the parameter index
3154      * and the value to be set (possibly null), the array element will contain the value to be set
3155      * (which will be expressed as an &lt;code&gt;Object&lt;/code&gt;).  If there are additional
3156      * parameters, the array element will itself be an array containing the value to be set
3157      * plus any additional parameter values supplied to the setter method. If the method
3158      * sets a stream, the array element includes the type of stream being supplied to the
3159      * method. These additional parameters are for the use of the driver or the DBMS and may or
3160      * may not be used.
3161      * &lt;P&gt;
3162      * NOTE: Stored parameter values of types &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;,
3163      * &lt;code&gt;Clob&lt;/code&gt; and &lt;code&gt;Ref&lt;/code&gt; are returned as &lt;code&gt;SerialArray&lt;/code&gt;,
3164      * &lt;code&gt;SerialBlob&lt;/code&gt;, &lt;code&gt;SerialClob&lt;/code&gt; and &lt;code&gt;SerialRef&lt;/code&gt;
3165      * respectively.
3166      *
3167      * @return an array of &lt;code&gt;Object&lt;/code&gt; instances that includes the
3168      *         parameter values that may be set in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s
3169      *         command; an empty array if no parameters have been set
3170      * @throws SQLException if an error occurs retrieving the object array of
3171      *         parameters of this &lt;code&gt;RowSet&lt;/code&gt; object or if not all parameters have
3172      *         been set
3173      */
3174     public Object[] getParams() throws SQLException {
3175         if (params == null) {
3176 
3177             initParams();
3178             Object [] paramsArray = new Object[params.size()];
3179             return paramsArray;
3180 
3181         } else {
3182             // The parameters may be set in random order
3183             // but all must be set, check to verify all
3184             // have been set till the last parameter
3185             // else throw exception.
3186 
3187             Object[] paramsArray = new Object[params.size()];
3188             for (int i = 0; i &lt; params.size(); i++) {
3189                paramsArray[i] = params.get(Integer.valueOf(i));
3190                if (paramsArray[i] == null) {
3191                  throw new SQLException(&quot;missing parameter: &quot; + (i + 1));
3192                } //end if
3193             } //end for
3194             return paramsArray;
3195 
3196         } //end if
3197 
3198     } //end getParams
3199 
3200 
3201    /**
3202     * Sets the designated parameter to SQL &lt;code&gt;NULL&lt;/code&gt;.
3203     *
3204     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; You must specify the parameter&#39;s SQL type.
3205     *
3206     * @param parameterName the name of the parameter
3207     * @param sqlType the SQL type code defined in &lt;code&gt;java.sql.Types&lt;/code&gt;
3208     * @exception SQLException if a database access error occurs or
3209     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3210     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3211     * this method
3212     */
3213    public void setNull(String parameterName, int sqlType) throws SQLException {
3214         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3215    }
3216 
3217    /**
3218     * Sets the designated parameter to SQL &lt;code&gt;NULL&lt;/code&gt;.
3219     * This version of the method &lt;code&gt;setNull&lt;/code&gt; should
3220     * be used for user-defined types and REF type parameters.  Examples
3221     * of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and
3222     * named array types.
3223     *
3224     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; To be portable, applications must give the
3225     * SQL type code and the fully-qualified SQL type name when specifying
3226     * a NULL user-defined or REF parameter.  In the case of a user-defined type
3227     * the name is the type name of the parameter itself.  For a REF
3228     * parameter, the name is the type name of the referenced type.  If
3229     * a JDBC driver does not need the type code or type name information,
3230     * it may ignore it.
3231     *
3232     * Although it is intended for user-defined and Ref parameters,
3233     * this method may be used to set a null parameter of any JDBC type.
3234     * If the parameter does not have a user-defined or REF type, the given
3235     * typeName is ignored.
3236     *
3237     *
3238     * @param parameterName the name of the parameter
3239     * @param sqlType a value from &lt;code&gt;java.sql.Types&lt;/code&gt;
3240     * @param typeName the fully-qualified name of an SQL user-defined type;
3241     *        ignored if the parameter is not a user-defined type or
3242     *        SQL &lt;code&gt;REF&lt;/code&gt; value
3243     * @exception SQLException if a database access error occurs or
3244     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3245     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3246     * this method
3247     */
3248    public void setNull (String parameterName, int sqlType, String typeName)
3249        throws SQLException{
3250         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3251    }
3252 
3253    /**
3254     * Sets the designated parameter to the given Java &lt;code&gt;boolean&lt;/code&gt; value.
3255     * The driver converts this
3256     * to an SQL &lt;code&gt;BIT&lt;/code&gt; or &lt;code&gt;BOOLEAN&lt;/code&gt; value when it sends it to the database.
3257     *
3258     * @param parameterName the name of the parameter
3259     * @param x the parameter value
3260     * @exception SQLException if a database access error occurs or
3261     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3262     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3263     * this method
3264     * @see #getParams
3265     */
3266    public void setBoolean(String parameterName, boolean x) throws SQLException{
3267         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3268    }
3269 
3270    /**
3271     * Sets the designated parameter to the given Java &lt;code&gt;byte&lt;/code&gt; value.
3272     * The driver converts this
3273     * to an SQL &lt;code&gt;TINYINT&lt;/code&gt; value when it sends it to the database.
3274     *
3275     * @param parameterName the name of the parameter
3276     * @param x the parameter value
3277     * @exception SQLException if a database access error occurs or
3278     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3279     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3280     * this method
3281     * @see #getParams
3282     */
3283    public void setByte(String parameterName, byte x) throws SQLException{
3284         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3285    }
3286 
3287    /**
3288     * Sets the designated parameter to the given Java &lt;code&gt;short&lt;/code&gt; value.
3289     * The driver converts this
3290     * to an SQL &lt;code&gt;SMALLINT&lt;/code&gt; value when it sends it to the database.
3291     *
3292     * @param parameterName the name of the parameter
3293     * @param x the parameter value
3294     * @exception SQLException if a database access error occurs or
3295     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3296     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3297     * this method
3298     * @see #getParams
3299     */
3300    public void setShort(String parameterName, short x) throws SQLException{
3301         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3302    }
3303 
3304    /**
3305     * Sets the designated parameter to the given Java &lt;code&gt;int&lt;/code&gt; value.
3306     * The driver converts this
3307     * to an SQL &lt;code&gt;INTEGER&lt;/code&gt; value when it sends it to the database.
3308     *
3309     * @param parameterName the name of the parameter
3310     * @param x the parameter value
3311     * @exception SQLException if a database access error occurs or
3312     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3313     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3314     * this method
3315     * @see #getParams
3316     */
3317    public void setInt(String parameterName, int x) throws SQLException{
3318         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3319    }
3320 
3321 
3322    /**
3323     * Sets the designated parameter to the given Java &lt;code&gt;long&lt;/code&gt; value.
3324     * The driver converts this
3325     * to an SQL &lt;code&gt;BIGINT&lt;/code&gt; value when it sends it to the database.
3326     *
3327     * @param parameterName the name of the parameter
3328     * @param x the parameter value
3329     * @exception SQLException if a database access error occurs or
3330     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3331     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3332     * this method
3333     * @see #getParams
3334     */
3335    public void setLong(String parameterName, long x) throws SQLException{
3336         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3337    }
3338 
3339    /**
3340     * Sets the designated parameter to the given Java &lt;code&gt;float&lt;/code&gt; value.
3341     * The driver converts this
3342     * to an SQL &lt;code&gt;FLOAT&lt;/code&gt; value when it sends it to the database.
3343     *
3344     * @param parameterName the name of the parameter
3345     * @param x the parameter value
3346     * @exception SQLException if a database access error occurs or
3347     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3348     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3349     * this method
3350     * @see #getParams
3351     */
3352    public void setFloat(String parameterName, float x) throws SQLException{
3353         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3354    }
3355 
3356    /**
3357     * Sets the designated parameter to the given Java &lt;code&gt;double&lt;/code&gt; value.
3358     * The driver converts this
3359     * to an SQL &lt;code&gt;DOUBLE&lt;/code&gt; value when it sends it to the database.
3360     *
3361     * @param parameterName the name of the parameter
3362     * @param x the parameter value
3363     * @exception SQLException if a database access error occurs or
3364     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3365     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3366     * this method
3367     * @see #getParams
3368     */
3369    public void setDouble(String parameterName, double x) throws SQLException{
3370         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3371    }
3372 
3373    /**
3374     * Sets the designated parameter to the given
3375     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; value.
3376     * The driver converts this to an SQL &lt;code&gt;NUMERIC&lt;/code&gt; value when
3377     * it sends it to the database.
3378     *
3379     * @param parameterName the name of the parameter
3380     * @param x the parameter value
3381     * @exception SQLException if a database access error occurs or
3382     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3383     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3384     * this method
3385     * @see #getParams
3386     */
3387    public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException{
3388         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3389    }
3390 
3391    /**
3392     * Sets the designated parameter to the given Java &lt;code&gt;String&lt;/code&gt; value.
3393     * The driver converts this
3394     * to an SQL &lt;code&gt;VARCHAR&lt;/code&gt; or &lt;code&gt;LONGVARCHAR&lt;/code&gt; value
3395     * (depending on the argument&#39;s
3396     * size relative to the driver&#39;s limits on &lt;code&gt;VARCHAR&lt;/code&gt; values)
3397     * when it sends it to the database.
3398     *
3399     * @param parameterName the name of the parameter
3400     * @param x the parameter value
3401     * @exception SQLException if a database access error occurs or
3402     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3403     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3404     * this method
3405     * @see #getParams
3406     */
3407    public void setString(String parameterName, String x) throws SQLException{
3408         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3409    }
3410 
3411    /**
3412     * Sets the designated parameter to the given Java array of bytes.
3413     * The driver converts this to an SQL &lt;code&gt;VARBINARY&lt;/code&gt; or
3414     * &lt;code&gt;LONGVARBINARY&lt;/code&gt; (depending on the argument&#39;s size relative
3415     * to the driver&#39;s limits on &lt;code&gt;VARBINARY&lt;/code&gt; values) when it sends
3416     * it to the database.
3417     *
3418     * @param parameterName the name of the parameter
3419     * @param x the parameter value
3420     * @exception SQLException if a database access error occurs or
3421     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3422     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3423     * this method
3424     * @see #getParams
3425     */
3426    public void setBytes(String parameterName, byte x[]) throws SQLException{
3427         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3428    }
3429 
3430    /**
3431     * Sets the designated parameter to the given &lt;code&gt;java.sql.Timestamp&lt;/code&gt; value.
3432     * The driver
3433     * converts this to an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value when it sends it to the
3434     * database.
3435     *
3436     * @param parameterName the name of the parameter
3437     * @param x the parameter value
3438     * @exception SQLException if a database access error occurs or
3439     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3440     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3441     * this method
3442     * @see #getParams
3443     */
3444    public void setTimestamp(String parameterName, java.sql.Timestamp x)
3445        throws SQLException{
3446         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3447    }
3448 
3449    /**
3450     * Sets the designated parameter to the given input stream, which will have
3451     * the specified number of bytes.
3452     * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
3453     * parameter, it may be more practical to send it via a
3454     * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
3455     * as needed until end-of-file is reached.  The JDBC driver will
3456     * do any necessary conversion from ASCII to the database char format.
3457     *
3458     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3459     * Java stream object or your own subclass that implements the
3460     * standard interface.
3461     *
3462     * @param parameterName the name of the parameter
3463     * @param x the Java input stream that contains the ASCII parameter value
3464     * @param length the number of bytes in the stream
3465     * @exception SQLException if a database access error occurs or
3466     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3467     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3468     * this method
3469     */
3470    public void setAsciiStream(String parameterName, java.io.InputStream x, int length)
3471        throws SQLException{
3472         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3473    }
3474 
3475    /**
3476     * Sets the designated parameter to the given input stream, which will have
3477     * the specified number of bytes.
3478     * When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt;
3479     * parameter, it may be more practical to send it via a
3480     * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The data will be read from the stream
3481     * as needed until end-of-file is reached.
3482     *
3483     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3484     * Java stream object or your own subclass that implements the
3485     * standard interface.
3486     *
3487     * @param parameterName the name of the parameter
3488     * @param x the java input stream which contains the binary parameter value
3489     * @param length the number of bytes in the stream
3490     * @exception SQLException if a database access error occurs or
3491     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3492     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3493     * this method
3494     */
3495    public void setBinaryStream(String parameterName, java.io.InputStream x,
3496                         int length) throws SQLException{
3497         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3498    }
3499 
3500    /**
3501     * Sets the designated parameter to the given &lt;code&gt;Reader&lt;/code&gt;
3502     * object, which is the given number of characters long.
3503     * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
3504     * parameter, it may be more practical to send it via a
3505     * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
3506     * as needed until end-of-file is reached.  The JDBC driver will
3507     * do any necessary conversion from UNICODE to the database char format.
3508     *
3509     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3510     * Java stream object or your own subclass that implements the
3511     * standard interface.
3512     *
3513     * @param parameterName the name of the parameter
3514     * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object that
3515     *        contains the UNICODE data used as the designated parameter
3516     * @param length the number of characters in the stream
3517     * @exception SQLException if a database access error occurs or
3518     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3519     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3520     * this method
3521     */
3522    public void setCharacterStream(String parameterName,
3523                            java.io.Reader reader,
3524                            int length) throws SQLException{
3525         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3526    }
3527 
3528   /**
3529    * Sets the designated parameter to the given input stream.
3530    * When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
3531    * parameter, it may be more practical to send it via a
3532    * &lt;code&gt;java.io.InputStream&lt;/code&gt;. Data will be read from the stream
3533    * as needed until end-of-file is reached.  The JDBC driver will
3534    * do any necessary conversion from ASCII to the database char format.
3535    *
3536    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3537    * Java stream object or your own subclass that implements the
3538    * standard interface.
3539    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3540    * it might be more efficient to use a version of
3541    * &lt;code&gt;setAsciiStream&lt;/code&gt; which takes a length parameter.
3542    *
3543    * @param parameterName the name of the parameter
3544    * @param x the Java input stream that contains the ASCII parameter value
3545    * @exception SQLException if a database access error occurs or
3546    * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3547    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3548    * @since 1.6
3549   */
3550   public void setAsciiStream(String parameterName, java.io.InputStream x)
3551           throws SQLException{
3552         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3553    }
3554 
3555    /**
3556     * Sets the designated parameter to the given input stream.
3557     * When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt;
3558     * parameter, it may be more practical to send it via a
3559     * &lt;code&gt;java.io.InputStream&lt;/code&gt; object. The data will be read from the
3560     * stream as needed until end-of-file is reached.
3561     *
3562     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3563     * Java stream object or your own subclass that implements the
3564     * standard interface.
3565     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3566     * it might be more efficient to use a version of
3567     * &lt;code&gt;setBinaryStream&lt;/code&gt; which takes a length parameter.
3568     *
3569     * @param parameterName the name of the parameter
3570     * @param x the java input stream which contains the binary parameter value
3571     * @exception SQLException if a database access error occurs or
3572     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3573     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3574     * @since 1.6
3575     */
3576    public void setBinaryStream(String parameterName, java.io.InputStream x)
3577    throws SQLException{
3578         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3579    }
3580 
3581    /**
3582     * Sets the designated parameter to the given &lt;code&gt;Reader&lt;/code&gt;
3583     * object.
3584     * When a very large UNICODE value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt;
3585     * parameter, it may be more practical to send it via a
3586     * &lt;code&gt;java.io.Reader&lt;/code&gt; object. The data will be read from the stream
3587     * as needed until end-of-file is reached.  The JDBC driver will
3588     * do any necessary conversion from UNICODE to the database char format.
3589     *
3590     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3591     * Java stream object or your own subclass that implements the
3592     * standard interface.
3593     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3594     * it might be more efficient to use a version of
3595     * &lt;code&gt;setCharacterStream&lt;/code&gt; which takes a length parameter.
3596     *
3597     * @param parameterName the name of the parameter
3598     * @param reader the &lt;code&gt;java.io.Reader&lt;/code&gt; object that contains the
3599     *        Unicode data
3600     * @exception SQLException if a database access error occurs or
3601     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3602     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3603     * @since 1.6
3604     */
3605    public void setCharacterStream(String parameterName,
3606                          java.io.Reader reader) throws SQLException{
3607         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3608    }
3609 
3610  /**
3611   * Sets the designated parameter in this &lt;code&gt;RowSet&lt;/code&gt; object&#39;s command
3612   * to a &lt;code&gt;Reader&lt;/code&gt; object. The
3613   * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
3614   * driver does the necessary conversion from Java character format to
3615   * the national character set in the database.
3616   *
3617   * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
3618   * Java stream object or your own subclass that implements the
3619   * standard interface.
3620   * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3621   * it might be more efficient to use a version of
3622   * &lt;code&gt;setNCharacterStream&lt;/code&gt; which takes a length parameter.
3623   *
3624   * @param parameterIndex of the first parameter is 1, the second is 2, ...
3625   * @param value the parameter value
3626   * @throws SQLException if the driver does not support national
3627   *         character sets;  if the driver can detect that a data conversion
3628   *  error could occur ; if a database access error occurs; or
3629   * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
3630   * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3631   * @since 1.6
3632   */
3633   public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException{
3634         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3635    }
3636 
3637    /**
3638     * Sets the value of the designated parameter with the given object. The second
3639     * argument must be an object type; for integral values, the
3640     * &lt;code&gt;java.lang&lt;/code&gt; equivalent objects should be used.
3641     *
3642     * &lt;p&gt;The given Java object will be converted to the given targetSqlType
3643     * before being sent to the database.
3644     *
3645     * If the object has a custom mapping (is of a class implementing the
3646     * interface &lt;code&gt;SQLData&lt;/code&gt;),
3647     * the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write it
3648     * to the SQL data stream.
3649     * If, on the other hand, the object is of a class implementing
3650     * &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;,  &lt;code&gt;NClob&lt;/code&gt;,
3651     *  &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;,
3652     * or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a
3653     * value of the corresponding SQL type.
3654     * &lt;P&gt;
3655     * Note that this method may be used to pass database-
3656     * specific abstract data types.
3657     *
3658     * @param parameterName the name of the parameter
3659     * @param x the object containing the input parameter value
3660     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
3661     * sent to the database. The scale argument may further qualify this type.
3662     * @param scale for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types,
3663     *          this is the number of digits after the decimal point.  For all other
3664     *          types, this value will be ignored.
3665     * @exception SQLException if a database access error occurs or
3666     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3667     * @exception SQLFeatureNotSupportedException if &lt;code&gt;targetSqlType&lt;/code&gt; is
3668     * a &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;BLOB&lt;/code&gt;, &lt;code&gt;CLOB&lt;/code&gt;,
3669     * &lt;code&gt;DATALINK&lt;/code&gt;, &lt;code&gt;JAVA_OBJECT&lt;/code&gt;, &lt;code&gt;NCHAR&lt;/code&gt;,
3670     * &lt;code&gt;NCLOB&lt;/code&gt;, &lt;code&gt;NVARCHAR&lt;/code&gt;, &lt;code&gt;LONGNVARCHAR&lt;/code&gt;,
3671     *  &lt;code&gt;REF&lt;/code&gt;, &lt;code&gt;ROWID&lt;/code&gt;, &lt;code&gt;SQLXML&lt;/code&gt;
3672     * or  &lt;code&gt;STRUCT&lt;/code&gt; data type and the JDBC driver does not support
3673     * this data type
3674     * @see Types
3675     * @see #getParams
3676     */
3677    public void setObject(String parameterName, Object x, int targetSqlType, int scale)
3678        throws SQLException{
3679         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3680    }
3681 
3682    /**
3683     * Sets the value of the designated parameter with the given object.
3684     * This method is like the method &lt;code&gt;setObject&lt;/code&gt;
3685     * above, except that it assumes a scale of zero.
3686     *
3687     * @param parameterName the name of the parameter
3688     * @param x the object containing the input parameter value
3689     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be
3690     *                      sent to the database
3691     * @exception SQLException if a database access error occurs or
3692     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3693     * @exception SQLFeatureNotSupportedException if &lt;code&gt;targetSqlType&lt;/code&gt; is
3694     * a &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;BLOB&lt;/code&gt;, &lt;code&gt;CLOB&lt;/code&gt;,
3695     * &lt;code&gt;DATALINK&lt;/code&gt;, &lt;code&gt;JAVA_OBJECT&lt;/code&gt;, &lt;code&gt;NCHAR&lt;/code&gt;,
3696     * &lt;code&gt;NCLOB&lt;/code&gt;, &lt;code&gt;NVARCHAR&lt;/code&gt;, &lt;code&gt;LONGNVARCHAR&lt;/code&gt;,
3697     *  &lt;code&gt;REF&lt;/code&gt;, &lt;code&gt;ROWID&lt;/code&gt;, &lt;code&gt;SQLXML&lt;/code&gt;
3698     * or  &lt;code&gt;STRUCT&lt;/code&gt; data type and the JDBC driver does not support
3699     * this data type
3700     * @see #getParams
3701     */
3702    public void setObject(String parameterName, Object x, int targetSqlType)
3703        throws SQLException{
3704         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3705    }
3706 
3707   /**
3708    * Sets the value of the designated parameter with the given object.
3709    * The second parameter must be of type &lt;code&gt;Object&lt;/code&gt;; therefore, the
3710    * &lt;code&gt;java.lang&lt;/code&gt; equivalent objects should be used for built-in types.
3711    *
3712    * &lt;p&gt;The JDBC specification specifies a standard mapping from
3713    * Java &lt;code&gt;Object&lt;/code&gt; types to SQL types.  The given argument
3714    * will be converted to the corresponding SQL type before being
3715    * sent to the database.
3716    *
3717    * &lt;p&gt;Note that this method may be used to pass database-
3718    * specific abstract data types, by using a driver-specific Java
3719    * type.
3720    *
3721    * If the object is of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;,
3722    * the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt;
3723    * to write it to the SQL data stream.
3724    * If, on the other hand, the object is of a class implementing
3725    * &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;,  &lt;code&gt;NClob&lt;/code&gt;,
3726    *  &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;,
3727    * or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a
3728    * value of the corresponding SQL type.
3729    * &lt;P&gt;
3730    * This method throws an exception if there is an ambiguity, for example, if the
3731    * object is of a class implementing more than one of the interfaces named above.
3732    *
3733    * @param parameterName the name of the parameter
3734    * @param x the object containing the input parameter value
3735    * @exception SQLException if a database access error occurs,
3736    * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt; or if the given
3737    *            &lt;code&gt;Object&lt;/code&gt; parameter is ambiguous
3738    * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3739    * this method
3740    * @see #getParams
3741    */
3742   public void setObject(String parameterName, Object x) throws SQLException{
3743         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3744    }
3745 
3746    /**
3747     * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.
3748     * The &lt;code&gt;InputStream&lt;/code&gt; must contain  the number
3749     * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
3750     * generated when the &lt;code&gt;PreparedStatement&lt;/code&gt; is executed.
3751     * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream, int)&lt;/code&gt;
3752     * method because it informs the driver that the parameter value should be
3753     * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
3754     * the driver may have to do extra work to determine whether the parameter
3755     * data should be sent to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
3756     * @param parameterIndex index of the first parameter is 1,
3757     * the second is 2, ...
3758     * @param inputStream An object that contains the data to set the parameter
3759     * value to.
3760     * @param length the number of bytes in the parameter data.
3761     * @throws SQLException if a database access error occurs,
3762     * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;,
3763     * if parameterIndex does not correspond
3764     * to a parameter marker in the SQL statement,  if the length specified
3765     * is less than zero or if the number of bytes in the
3766     * &lt;code&gt;InputStream&lt;/code&gt; does not match the specified length.
3767     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3768     *
3769     * @since 1.6
3770     */
3771     public void setBlob(int parameterIndex, InputStream inputStream, long length)
3772        throws SQLException{
3773         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3774    }
3775 
3776    /**
3777     * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.
3778     * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream)&lt;/code&gt;
3779     * method because it informs the driver that the parameter value should be
3780     * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
3781     * the driver may have to do extra work to determine whether the parameter
3782     * data should be sent to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
3783     *
3784     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3785     * it might be more efficient to use a version of
3786     * &lt;code&gt;setBlob&lt;/code&gt; which takes a length parameter.
3787     *
3788     * @param parameterIndex index of the first parameter is 1,
3789     * the second is 2, ...
3790     * @param inputStream An object that contains the data to set the parameter
3791     * value to.
3792     * @throws SQLException if a database access error occurs,
3793     * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt; or
3794     * if parameterIndex does not correspond
3795     * to a parameter marker in the SQL statement,
3796     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3797     *
3798     * @since 1.6
3799     */
3800     public void setBlob(int parameterIndex, InputStream inputStream)
3801        throws SQLException{
3802         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3803     }
3804 
3805     /**
3806      * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.
3807      * The &lt;code&gt;Inputstream&lt;/code&gt; must contain  the number
3808      * of characters specified by length, otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
3809      * generated when the &lt;code&gt;CallableStatement&lt;/code&gt; is executed.
3810      * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream, int)&lt;/code&gt;
3811      * method because it informs the driver that the parameter value should be
3812      * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
3813      * the driver may have to do extra work to determine whether the parameter
3814      * data should be sent to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
3815      *
3816      * @param parameterName the name of the parameter to be set
3817      * the second is 2, ...
3818      *
3819      * @param inputStream An object that contains the data to set the parameter
3820      * value to.
3821      * @param length the number of bytes in the parameter data.
3822      * @throws SQLException  if parameterIndex does not correspond
3823      * to a parameter marker in the SQL statement,  or if the length specified
3824      * is less than zero; if the number of bytes in the &lt;code&gt;InputStream&lt;/code&gt; does not match
3825      * the specified length; if a database access error occurs or
3826      * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3827      * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3828      * this method
3829      *
3830      * @since 1.6
3831      */
3832      public void setBlob(String parameterName, InputStream inputStream, long length)
3833         throws SQLException{
3834         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3835    }
3836 
3837    /**
3838     * Sets the designated parameter to the given &lt;code&gt;java.sql.Blob&lt;/code&gt; object.
3839     * The driver converts this to an SQL &lt;code&gt;BLOB&lt;/code&gt; value when it
3840     * sends it to the database.
3841     *
3842     * @param parameterName the name of the parameter
3843     * @param x a &lt;code&gt;Blob&lt;/code&gt; object that maps an SQL &lt;code&gt;BLOB&lt;/code&gt; value
3844     * @exception SQLException if a database access error occurs or
3845     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3846     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3847     * this method
3848     * @since 1.6
3849     */
3850    public void setBlob (String parameterName, Blob x) throws SQLException{
3851         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3852    }
3853 
3854    /**
3855     * Sets the designated parameter to a &lt;code&gt;InputStream&lt;/code&gt; object.
3856     * This method differs from the &lt;code&gt;setBinaryStream (int, InputStream)&lt;/code&gt;
3857     * method because it informs the driver that the parameter value should be
3858     * sent to the server as a &lt;code&gt;BLOB&lt;/code&gt;.  When the &lt;code&gt;setBinaryStream&lt;/code&gt; method is used,
3859     * the driver may have to do extra work to determine whether the parameter
3860     * data should be send to the server as a &lt;code&gt;LONGVARBINARY&lt;/code&gt; or a &lt;code&gt;BLOB&lt;/code&gt;
3861     *
3862     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3863     * it might be more efficient to use a version of
3864     * &lt;code&gt;setBlob&lt;/code&gt; which takes a length parameter.
3865     *
3866     * @param parameterName the name of the parameter
3867     * @param inputStream An object that contains the data to set the parameter
3868     * value to.
3869     * @throws SQLException if a database access error occurs or
3870     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3871     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3872     *
3873     * @since 1.6
3874     */
3875     public void setBlob(String parameterName, InputStream inputStream)
3876        throws SQLException{
3877         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3878     }
3879 
3880    /**
3881     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
3882     * The reader must contain  the number
3883     * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
3884     * generated when the &lt;code&gt;PreparedStatement&lt;/code&gt; is executed.
3885     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
3886     * because it informs the driver that the parameter value should be sent to
3887     * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
3888     * driver may have to do extra work to determine whether the parameter
3889     * data should be sent to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
3890     * @param parameterIndex index of the first parameter is 1, the second is 2, ...
3891     * @param reader An object that contains the data to set the parameter value to.
3892     * @param length the number of characters in the parameter data.
3893     * @throws SQLException if a database access error occurs, this method is called on
3894     * a closed &lt;code&gt;PreparedStatement&lt;/code&gt;, if parameterIndex does not correspond to a parameter
3895     * marker in the SQL statement, or if the length specified is less than zero.
3896     *
3897     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3898     * @since 1.6
3899     */
3900    public void setClob(int parameterIndex, Reader reader, long length)
3901      throws SQLException{
3902         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3903    }
3904 
3905   /**
3906    * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
3907    * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
3908    * because it informs the driver that the parameter value should be sent to
3909    * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
3910    * driver may have to do extra work to determine whether the parameter
3911    * data should be sent to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
3912    *
3913    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3914    * it might be more efficient to use a version of
3915    * &lt;code&gt;setClob&lt;/code&gt; which takes a length parameter.
3916    *
3917    * @param parameterIndex index of the first parameter is 1, the second is 2, ...
3918    * @param reader An object that contains the data to set the parameter value to.
3919    * @throws SQLException if a database access error occurs, this method is called on
3920    * a closed &lt;code&gt;PreparedStatement&lt;/code&gt;or if parameterIndex does not correspond to a parameter
3921    * marker in the SQL statement
3922    *
3923    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3924    * @since 1.6
3925    */
3926    public void setClob(int parameterIndex, Reader reader)
3927      throws SQLException{
3928         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3929    }
3930 
3931    /**
3932     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
3933     * The &lt;code&gt;reader&lt;/code&gt; must contain  the number
3934     * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
3935     * generated when the &lt;code&gt;CallableStatement&lt;/code&gt; is executed.
3936     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
3937     * because it informs the driver that the parameter value should be sent to
3938     * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
3939     * driver may have to do extra work to determine whether the parameter
3940     * data should be send to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
3941     * @param parameterName the name of the parameter to be set
3942     * @param reader An object that contains the data to set the parameter value to.
3943     * @param length the number of characters in the parameter data.
3944     * @throws SQLException if parameterIndex does not correspond to a parameter
3945     * marker in the SQL statement; if the length specified is less than zero;
3946     * a database access error occurs or
3947     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3948     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3949     * this method
3950     *
3951     * @since 1.6
3952     */
3953    public void setClob(String parameterName, Reader reader, long length)
3954       throws SQLException {
3955        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3956    }
3957 
3958    /**
3959     * Sets the designated parameter to the given &lt;code&gt;java.sql.Clob&lt;/code&gt; object.
3960     * The driver converts this to an SQL &lt;code&gt;CLOB&lt;/code&gt; value when it
3961     * sends it to the database.
3962     *
3963     * @param parameterName the name of the parameter
3964     * @param x a &lt;code&gt;Clob&lt;/code&gt; object that maps an SQL &lt;code&gt;CLOB&lt;/code&gt; value
3965     * @exception SQLException if a database access error occurs or
3966     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3967     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
3968     * this method
3969     * @since 1.6
3970     */
3971    public void setClob (String parameterName, Clob x) throws SQLException {
3972        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3973    }
3974 
3975    /**
3976     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
3977     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
3978     * because it informs the driver that the parameter value should be sent to
3979     * the server as a &lt;code&gt;CLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
3980     * driver may have to do extra work to determine whether the parameter
3981     * data should be send to the server as a &lt;code&gt;LONGVARCHAR&lt;/code&gt; or a &lt;code&gt;CLOB&lt;/code&gt;
3982     *
3983     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
3984     * it might be more efficient to use a version of
3985     * &lt;code&gt;setClob&lt;/code&gt; which takes a length parameter.
3986     *
3987     * @param parameterName the name of the parameter
3988     * @param reader An object that contains the data to set the parameter value to.
3989     * @throws SQLException if a database access error occurs or this method is called on
3990     * a closed &lt;code&gt;CallableStatement&lt;/code&gt;
3991     *
3992     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
3993     * @since 1.6
3994     */
3995     public void setClob(String parameterName, Reader reader) throws SQLException {
3996         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
3997     }
3998 
3999    /**
4000     * Sets the designated parameter to the given &lt;code&gt;java.sql.Date&lt;/code&gt; value
4001     * using the default time zone of the virtual machine that is running
4002     * the application.
4003     * The driver converts this
4004     * to an SQL &lt;code&gt;DATE&lt;/code&gt; value when it sends it to the database.
4005     *
4006     * @param parameterName the name of the parameter
4007     * @param x the parameter value
4008     * @exception SQLException if a database access error occurs or
4009     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4010     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
4011     * this method
4012     * @see #getParams
4013     */
4014    public void setDate(String parameterName, java.sql.Date x)
4015            throws SQLException {
4016        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4017    }
4018 
4019    /**
4020     * Sets the designated parameter to the given &lt;code&gt;java.sql.Date&lt;/code&gt; value,
4021     * using the given &lt;code&gt;Calendar&lt;/code&gt; object.  The driver uses
4022     * the &lt;code&gt;Calendar&lt;/code&gt; object to construct an SQL &lt;code&gt;DATE&lt;/code&gt; value,
4023     * which the driver then sends to the database.  With a
4024     * a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the date
4025     * taking into account a custom timezone.  If no
4026     * &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the default
4027     * timezone, which is that of the virtual machine running the application.
4028     *
4029     * @param parameterName the name of the parameter
4030     * @param x the parameter value
4031     * @param cal the &lt;code&gt;Calendar&lt;/code&gt; object the driver will use
4032     *            to construct the date
4033     * @exception SQLException if a database access error occurs or
4034     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4035     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
4036     * this method
4037     * @see #getParams
4038     */
4039    public void setDate(String parameterName, java.sql.Date x, Calendar cal)
4040            throws SQLException {
4041         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4042    }
4043 
4044    /**
4045     * Sets the designated parameter to the given &lt;code&gt;java.sql.Time&lt;/code&gt; value.
4046     * The driver converts this
4047     * to an SQL &lt;code&gt;TIME&lt;/code&gt; value when it sends it to the database.
4048     *
4049     * @param parameterName the name of the parameter
4050     * @param x the parameter value
4051     * @exception SQLException if a database access error occurs or
4052     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4053     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
4054     * this method
4055     * @see #getParams
4056     */
4057    public void setTime(String parameterName, java.sql.Time x)
4058            throws SQLException {
4059         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4060    }
4061 
4062    /**
4063     * Sets the designated parameter to the given &lt;code&gt;java.sql.Time&lt;/code&gt; value,
4064     * using the given &lt;code&gt;Calendar&lt;/code&gt; object.  The driver uses
4065     * the &lt;code&gt;Calendar&lt;/code&gt; object to construct an SQL &lt;code&gt;TIME&lt;/code&gt; value,
4066     * which the driver then sends to the database.  With a
4067     * a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the time
4068     * taking into account a custom timezone.  If no
4069     * &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the default
4070     * timezone, which is that of the virtual machine running the application.
4071     *
4072     * @param parameterName the name of the parameter
4073     * @param x the parameter value
4074     * @param cal the &lt;code&gt;Calendar&lt;/code&gt; object the driver will use
4075     *            to construct the time
4076     * @exception SQLException if a database access error occurs or
4077     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4078     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
4079     * this method
4080     * @see #getParams
4081     */
4082    public void setTime(String parameterName, java.sql.Time x, Calendar cal)
4083            throws SQLException {
4084         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4085    }
4086 
4087    /**
4088     * Sets the designated parameter to the given &lt;code&gt;java.sql.Timestamp&lt;/code&gt; value,
4089     * using the given &lt;code&gt;Calendar&lt;/code&gt; object.  The driver uses
4090     * the &lt;code&gt;Calendar&lt;/code&gt; object to construct an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value,
4091     * which the driver then sends to the database.  With a
4092     * a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the timestamp
4093     * taking into account a custom timezone.  If no
4094     * &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the default
4095     * timezone, which is that of the virtual machine running the application.
4096     *
4097     * @param parameterName the name of the parameter
4098     * @param x the parameter value
4099     * @param cal the &lt;code&gt;Calendar&lt;/code&gt; object the driver will use
4100     *            to construct the timestamp
4101     * @exception SQLException if a database access error occurs or
4102     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4103     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
4104     * this method
4105     * @see #getParams
4106     */
4107    public void setTimestamp(String parameterName, java.sql.Timestamp x, Calendar cal)
4108            throws SQLException {
4109         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4110    }
4111 
4112    /**
4113     * Sets the designated parameter to the given &lt;code&gt;java.sql.SQLXML&lt;/code&gt; object. The driver converts this to an
4114     * SQL &lt;code&gt;XML&lt;/code&gt; value when it sends it to the database.
4115     * @param parameterIndex index of the first parameter is 1, the second is 2, ...
4116     * @param xmlObject a &lt;code&gt;SQLXML&lt;/code&gt; object that maps an SQL &lt;code&gt;XML&lt;/code&gt; value
4117     * @throws SQLException if a database access error occurs, this method
4118     *  is called on a closed result set,
4119     * the &lt;code&gt;java.xml.transform.Result&lt;/code&gt;,
4120     *  &lt;code&gt;Writer&lt;/code&gt; or &lt;code&gt;OutputStream&lt;/code&gt; has not been closed
4121     * for the &lt;code&gt;SQLXML&lt;/code&gt; object  or
4122     *  if there is an error processing the XML value.  The &lt;code&gt;getCause&lt;/code&gt; method
4123     *  of the exception may provide a more detailed exception, for example, if the
4124     *  stream does not contain valid XML.
4125     * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4126     * support this method
4127     * @since 1.6
4128     */
4129    public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
4130        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4131    }
4132 
4133    /**
4134     * Sets the designated parameter to the given &lt;code&gt;java.sql.SQLXML&lt;/code&gt; object. The driver converts this to an
4135     * &lt;code&gt;SQL XML&lt;/code&gt; value when it sends it to the database.
4136     * @param parameterName the name of the parameter
4137     * @param xmlObject a &lt;code&gt;SQLXML&lt;/code&gt; object that maps an &lt;code&gt;SQL XML&lt;/code&gt; value
4138     * @throws SQLException if a database access error occurs, this method
4139     *  is called on a closed result set,
4140     * the &lt;code&gt;java.xml.transform.Result&lt;/code&gt;,
4141     *  &lt;code&gt;Writer&lt;/code&gt; or &lt;code&gt;OutputStream&lt;/code&gt; has not been closed
4142     * for the &lt;code&gt;SQLXML&lt;/code&gt; object  or
4143     *  if there is an error processing the XML value.  The &lt;code&gt;getCause&lt;/code&gt; method
4144     *  of the exception may provide a more detailed exception, for example, if the
4145     *  stream does not contain valid XML.
4146     * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4147     * support this method
4148     * @since 1.6
4149     */
4150    public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {
4151        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4152    }
4153 
4154    /**
4155    * Sets the designated parameter to the given &lt;code&gt;java.sql.RowId&lt;/code&gt; object. The
4156    * driver converts this to a SQL &lt;code&gt;ROWID&lt;/code&gt; value when it sends it
4157    * to the database
4158    *
4159    * @param parameterIndex the first parameter is 1, the second is 2, ...
4160    * @param x the parameter value
4161    * @throws SQLException if a database access error occurs
4162    * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4163    * support this method
4164    *
4165    * @since 1.6
4166    */
4167   public void setRowId(int parameterIndex, RowId x) throws SQLException {
4168       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4169   }
4170 
4171   /**
4172    * Sets the designated parameter to the given &lt;code&gt;java.sql.RowId&lt;/code&gt; object. The
4173    * driver converts this to a SQL &lt;code&gt;ROWID&lt;/code&gt; when it sends it to the
4174    * database.
4175    *
4176    * @param parameterName the name of the parameter
4177    * @param x the parameter value
4178    * @throws SQLException if a database access error occurs
4179    * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4180    * support this method
4181    * @since 1.6
4182    */
4183   public void setRowId(String parameterName, RowId x) throws SQLException {
4184       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4185   }
4186 
4187   /**
4188    * Sets the designated parameter to the given &lt;code&gt;String&lt;/code&gt; object.
4189    * The driver converts this to a SQL &lt;code&gt;NCHAR&lt;/code&gt; or
4190    * &lt;code&gt;NVARCHAR&lt;/code&gt; or &lt;code&gt;LONGNVARCHAR&lt;/code&gt; value
4191    * (depending on the argument&#39;s
4192    * size relative to the driver&#39;s limits on &lt;code&gt;NVARCHAR&lt;/code&gt; values)
4193    * when it sends it to the database.
4194    *
4195    * @param parameterIndex of the first parameter is 1, the second is 2, ...
4196    * @param value the parameter value
4197    * @throws SQLException if the driver does not support national
4198    * character sets;  if the driver can detect that a data conversion
4199    * error could occur ; or if a database access error occurs
4200    * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4201    * support this method
4202    * @since 1.6
4203    */
4204   public void setNString(int parameterIndex, String value) throws SQLException {
4205       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4206   }
4207 
4208   /**
4209    * Sets the designated parameter to the given &lt;code&gt;String&lt;/code&gt; object.
4210    * The driver converts this to a SQL &lt;code&gt;NCHAR&lt;/code&gt; or
4211    * &lt;code&gt;NVARCHAR&lt;/code&gt; or &lt;code&gt;LONGNVARCHAR&lt;/code&gt;
4212    * @param parameterName the name of the column to be set
4213    * @param value the parameter value
4214    * @throws SQLException if the driver does not support national
4215    * character sets;  if the driver can detect that a data conversion
4216    * error could occur; or if a database access error occurs
4217    * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4218    * support this method
4219    * @since 1.6
4220    */
4221   public void setNString(String parameterName, String value) throws SQLException {
4222      throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4223   }
4224 
4225   /**
4226    * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object. The
4227    * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
4228    * driver does the necessary conversion from Java character format to
4229    * the national character set in the database.
4230    * @param parameterIndex of the first parameter is 1, the second is 2, ...
4231    * @param value the parameter value
4232    * @param length the number of characters in the parameter data.
4233    * @throws SQLException if the driver does not support national
4234    *         character sets;  if the driver can detect that a data conversion
4235    *  error could occur ; or if a database access error occurs
4236    * @throws SQLFeatureNotSupportedException if the JDBC driver does not
4237    * support this method
4238    * @since 1.6
4239    */
4240   public void setNCharacterStream(int parameterIndex, Reader value, long length)
4241           throws SQLException {
4242       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4243   }
4244 
4245   /**
4246    * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object. The
4247    * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
4248    * driver does the necessary conversion from Java character format to
4249    * the national character set in the database.
4250    * @param parameterName the name of the column to be set
4251    * @param value the parameter value
4252    * @param length the number of characters in the parameter data.
4253    * @throws SQLException if the driver does not support national
4254    *         character sets;  if the driver can detect that a data conversion
4255    *  error could occur; or if a database access error occurs
4256    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not
4257    * support this method
4258    * @since 1.6
4259    */
4260   public void setNCharacterStream(String parameterName, Reader value, long length)
4261           throws SQLException {
4262       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4263   }
4264 
4265   /**
4266    * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object. The
4267    * &lt;code&gt;Reader&lt;/code&gt; reads the data till end-of-file is reached. The
4268    * driver does the necessary conversion from Java character format to
4269    * the national character set in the database.
4270    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This stream object can either be a standard
4271    * Java stream object or your own subclass that implements the
4272    * standard interface.
4273    * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
4274    * it might be more efficient to use a version of
4275    * &lt;code&gt;setNCharacterStream&lt;/code&gt; which takes a length parameter.
4276    *
4277    * @param parameterName the name of the parameter
4278    * @param value the parameter value
4279    * @throws SQLException if the driver does not support national
4280    *         character sets;  if the driver can detect that a data conversion
4281    *  error could occur ; if a database access error occurs; or
4282    * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4283    * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
4284    * @since 1.6
4285    */
4286   public void setNCharacterStream(String parameterName, Reader value)
4287           throws SQLException {
4288       throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4289    }
4290 
4291    /**
4292     * Sets the designated parameter to a &lt;code&gt;java.sql.NClob&lt;/code&gt; object. The object
4293     * implements the &lt;code&gt;java.sql.NClob&lt;/code&gt; interface. This &lt;code&gt;NClob&lt;/code&gt;
4294     * object maps to a SQL &lt;code&gt;NCLOB&lt;/code&gt;.
4295     * @param parameterName the name of the column to be set
4296     * @param value the parameter value
4297     * @throws SQLException if the driver does not support national
4298     *         character sets;  if the driver can detect that a data conversion
4299     *  error could occur; or if a database access error occurs
4300     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not
4301     * support this method
4302     * @since 1.6
4303     */
4304    public void setNClob(String parameterName, NClob value) throws SQLException {
4305        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4306    }
4307 
4308    /**
4309     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.  The &lt;code&gt;reader&lt;/code&gt; must contain
4310     * the number
4311     * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
4312     * generated when the &lt;code&gt;CallableStatement&lt;/code&gt; is executed.
4313     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
4314     * because it informs the driver that the parameter value should be sent to
4315     * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
4316     * driver may have to do extra work to determine whether the parameter
4317     * data should be send to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
4318     *
4319     * @param parameterName the name of the parameter to be set
4320     * @param reader An object that contains the data to set the parameter value to.
4321     * @param length the number of characters in the parameter data.
4322     * @throws SQLException if parameterIndex does not correspond to a parameter
4323     * marker in the SQL statement; if the length specified is less than zero;
4324     * if the driver does not support national
4325     *         character sets;  if the driver can detect that a data conversion
4326     *  error could occur; if a database access error occurs or
4327     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4328     * @exception SQLFeatureNotSupportedException if the JDBC driver does not support
4329     * this method
4330     * @since 1.6
4331     */
4332    public void setNClob(String parameterName, Reader reader, long length)
4333            throws SQLException {
4334        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4335    }
4336 
4337    /**
4338     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
4339     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
4340     * because it informs the driver that the parameter value should be sent to
4341     * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
4342     * driver may have to do extra work to determine whether the parameter
4343     * data should be send to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
4344     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
4345     * it might be more efficient to use a version of
4346     * &lt;code&gt;setNClob&lt;/code&gt; which takes a length parameter.
4347     *
4348     * @param parameterName the name of the parameter
4349     * @param reader An object that contains the data to set the parameter value to.
4350     * @throws SQLException if the driver does not support national character sets;
4351     * if the driver can detect that a data conversion
4352     *  error could occur;  if a database access error occurs or
4353     * this method is called on a closed &lt;code&gt;CallableStatement&lt;/code&gt;
4354     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
4355     *
4356     * @since 1.6
4357     */
4358    public void setNClob(String parameterName, Reader reader) throws SQLException {
4359        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4360    }
4361 
4362    /**
4363     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.  The reader must contain  the number
4364     * of characters specified by length otherwise a &lt;code&gt;SQLException&lt;/code&gt; will be
4365     * generated when the &lt;code&gt;PreparedStatement&lt;/code&gt; is executed.
4366     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader, int)&lt;/code&gt; method
4367     * because it informs the driver that the parameter value should be sent to
4368     * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
4369     * driver may have to do extra work to determine whether the parameter
4370     * data should be sent to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
4371     * @param parameterIndex index of the first parameter is 1, the second is 2, ...
4372     * @param reader An object that contains the data to set the parameter value to.
4373     * @param length the number of characters in the parameter data.
4374     * @throws SQLException if parameterIndex does not correspond to a parameter
4375     * marker in the SQL statement; if the length specified is less than zero;
4376     * if the driver does not support national character sets;
4377     * if the driver can detect that a data conversion
4378     *  error could occur;  if a database access error occurs or
4379     * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
4380     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not
4381     * support this method
4382     *
4383     * @since 1.6
4384     */
4385    public void setNClob(int parameterIndex, Reader reader, long length)
4386            throws SQLException {
4387        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4388    }
4389 
4390    /**
4391     * Sets the designated parameter to a &lt;code&gt;java.sql.NClob&lt;/code&gt; object. The driver converts this oa
4392     * SQL &lt;code&gt;NCLOB&lt;/code&gt; value when it sends it to the database.
4393     * @param parameterIndex of the first parameter is 1, the second is 2, ...
4394     * @param value the parameter value
4395     * @throws SQLException if the driver does not support national
4396     *         character sets;  if the driver can detect that a data conversion
4397     *  error could occur ; or if a database access error occurs
4398     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not
4399     * support this method
4400     * @since 1.6
4401     */
4402    public void setNClob(int parameterIndex, NClob value) throws SQLException {
4403         throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4404    }
4405 
4406    /**
4407     * Sets the designated parameter to a &lt;code&gt;Reader&lt;/code&gt; object.
4408     * This method differs from the &lt;code&gt;setCharacterStream (int, Reader)&lt;/code&gt; method
4409     * because it informs the driver that the parameter value should be sent to
4410     * the server as a &lt;code&gt;NCLOB&lt;/code&gt;.  When the &lt;code&gt;setCharacterStream&lt;/code&gt; method is used, the
4411     * driver may have to do extra work to determine whether the parameter
4412     * data should be sent to the server as a &lt;code&gt;LONGNVARCHAR&lt;/code&gt; or a &lt;code&gt;NCLOB&lt;/code&gt;
4413     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Consult your JDBC driver documentation to determine if
4414     * it might be more efficient to use a version of
4415     * &lt;code&gt;setNClob&lt;/code&gt; which takes a length parameter.
4416     *
4417     * @param parameterIndex index of the first parameter is 1, the second is 2, ...
4418     * @param reader An object that contains the data to set the parameter value to.
4419     * @throws SQLException if parameterIndex does not correspond to a parameter
4420     * marker in the SQL statement;
4421     * if the driver does not support national character sets;
4422     * if the driver can detect that a data conversion
4423     *  error could occur;  if a database access error occurs or
4424     * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
4425     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
4426     *
4427     * @since 1.6
4428     */
4429    public void setNClob(int parameterIndex, Reader reader)throws SQLException {
4430        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4431    }
4432 
4433    /**
4434     * Sets the designated parameter to the given &lt;code&gt;java.net.URL&lt;/code&gt; value.
4435     * The driver converts this to an SQL &lt;code&gt;DATALINK&lt;/code&gt; value
4436     * when it sends it to the database.
4437     *
4438     * @param parameterIndex the first parameter is 1, the second is 2, ...
4439     * @param x the &lt;code&gt;java.net.URL&lt;/code&gt; object to be set
4440     * @exception SQLException if a database access error occurs or
4441     * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;
4442     * @throws SQLFeatureNotSupportedException  if the JDBC driver does not support this method
4443     */
4444    public void setURL(int parameterIndex, java.net.URL x) throws SQLException {
4445        throw new SQLFeatureNotSupportedException(&quot;Feature not supported&quot;);
4446    }
4447 
4448    static final long serialVersionUID = 4886719666485113312L;
4449 
4450 } //end class
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
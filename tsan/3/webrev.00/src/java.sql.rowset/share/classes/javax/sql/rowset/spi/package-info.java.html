<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.sql.rowset/share/classes/javax/sql/rowset/spi/package-info.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /**
 27  * The standard classes and interfaces that a third party vendor has to
 28  * use in its implementation of a synchronization provider. These classes and
 29  * interfaces are referred to as the Service Provider Interface (SPI).  To make it possible
 30  * for a {@code RowSet} object to use an implementation, the vendor must register
 31  * it with the {@code SyncFactory} singleton. (See the class comment for
 32  * {@code SyncProvider} for a full explanation of the registration process and
 33  * the naming convention to be used.)
 34  *
 35  * &lt;h2&gt;Table of Contents&lt;/h2&gt;
 36  * &lt;ul&gt;
 37  * &lt;li&gt;&lt;a href=&quot;#pkgspec&quot;&gt;1.0 Package Specification&lt;/a&gt;
 38  * &lt;li&gt;&lt;a href=&quot;#arch&quot;&gt;2.0 Service Provider Architecture&lt;/a&gt;
 39  * &lt;li&gt;&lt;a href=&quot;#impl&quot;&gt;3.0 Implementer&#39;s Guide&lt;/a&gt;
 40  * &lt;li&gt;&lt;a href=&quot;#resolving&quot;&gt;4.0 Resolving Synchronization Conflicts&lt;/a&gt;
 41  * &lt;li&gt;&lt;a href=&quot;#relspec&quot;&gt;5.0 Related Specifications&lt;/a&gt;
 42  * &lt;li&gt;&lt;a href=&quot;#reldocs&quot;&gt;6.0 Related Documentation&lt;/a&gt;
 43  * &lt;/ul&gt;
 44  *
 45  * &lt;h3&gt;&lt;a id=&quot;pkgspec&quot;&gt;1.0 Package Specification&lt;/a&gt;&lt;/h3&gt;
 46  * &lt;P&gt;
 47  * The following classes and interfaces make up the {@code javax.sql.rowset.spi}
 48  * package:
 49  * &lt;UL&gt;
 50  *  &lt;LI&gt;{@code SyncFactory}
 51  *  &lt;LI&gt;{@code SyncProvider}
 52  *  &lt;LI&gt;{@code SyncFactoryException}
 53  *  &lt;LI&gt;{@code SyncProviderException}
 54  *  &lt;LI&gt;{@code SyncResolver}
 55  *  &lt;LI&gt;{@code XmlReader}
 56  *  &lt;LI&gt;{@code XmlWriter}
 57  *  &lt;LI&gt;{@code TransactionalWriter}
 58  * &lt;/UL&gt;
 59  * The following interfaces, in the {@code javax.sql} package, are also part of the SPI:
 60  * &lt;UL&gt;
 61  *  &lt;LI&gt;{@code RowSetReader}
 62  *  &lt;LI&gt;{@code RowSetWriter}
 63  * &lt;/UL&gt;
 64  * &lt;P&gt;
 65  * A {@code SyncProvider} implementation provides a disconnected {@code RowSet}
 66  * object with the mechanisms for reading data into it and for writing data that has been
 67  * modified in it
 68  * back to the underlying data source.  A &lt;i&gt;reader&lt;/i&gt;, a {@code RowSetReader} or
 69  * {@code XMLReader} object, reads data into a {@code RowSet} object when the
 70  * {@code CachedRowSet} methods {@code execute} or {@code populate}
 71  * are called.  A &lt;i&gt;writer&lt;/i&gt;, a {@code RowSetWriter} or {@code XMLWriter}
 72  * object, writes changes back to the underlying data source when the
 73  * {@code CachedRowSet} method {@code acceptChanges} is called.
 74  * &lt;P&gt;
 75  * The process of writing changes in a {@code RowSet} object to its data source
 76  * is known as &lt;i&gt;synchronization&lt;/i&gt;.  The {@code SyncProvider} implementation that a
 77  * {@code RowSet} object is using determines the level of synchronization that the
 78  * {@code RowSet} object&#39;s writer uses. The various levels of synchronization are
 79  * referred to as &lt;i&gt;grades&lt;/i&gt;.
 80  * &lt;P&gt;
 81  * The lower grades of synchronization are
 82  * known as &lt;i&gt;optimistic&lt;/i&gt; concurrency levels because they optimistically
 83  * assume that there will be no conflicts or very few conflicts.  A conflict exists when
 84  * the same data modified in the {@code RowSet} object has also been modified
 85  * in the data source. Using the optimistic concurrency model means that if there
 86  * is a conflict, modifications to either the data source or the {@code RowSet}
 87  * object will be lost.
 88  * &lt;P&gt;
 89  * Higher grades of synchronization are called &lt;i&gt;pessimistic&lt;/i&gt; because they assume
 90  * that others will be accessing the data source and making modifications.  These
 91  * grades set varying levels of locks to increase the chances that no conflicts
 92  * occur.
 93  * &lt;P&gt;
 94  * The lowest level of synchronization is simply writing any changes made to the
 95  * {@code RowSet} object to its underlying data source.  The writer does
 96  * nothing to check for conflicts.
 97  * If there is a conflict and the data
 98  * source values are overwritten, the changes other parties have made by to the data
 99  * source are lost.
100  * &lt;P&gt;
101  * The {@code RIXMLProvider} implementation uses the lowest level
102  * of synchronization and just writes {@code RowSet} changes to the data source.
103  *
104  * &lt;P&gt;
105  * For the next level up, the
106  * writer checks to see if there are any conflicts, and if there are,
107  * it does not write anything to the data source.  The problem with this concurrency
108  * level is that if another party has modified the corresponding data in the data source
109  * since the {@code RowSet} object got its data,
110  * the changes made to the {@code RowSet} object are lost. The
111  * {@code RIOptimisticProvider} implementation uses this level of synchronization.
112  * &lt;P&gt;
113  * At higher levels of synchronization, referred to as pessimistic concurrency,
114  * the writer take steps to avoid conflicts by setting locks. Setting locks
115  * can vary from setting a lock on a single row to setting a lock on a table
116  * or the entire data source. The level of synchronization is therefore a tradeoff
117  * between the ability of users to access the data source concurrently and the  ability
118  * of the writer to keep the data in the {@code RowSet} object and its data source
119  * synchronized.
120  * &lt;P&gt;
121  * It is a requirement that all disconnected {@code RowSet} objects
122  * ({@code CachedRowSet}, {@code FilteredRowSet}, {@code JoinRowSet},
123  * and {@code WebRowSet} objects) obtain their {@code SyncProvider} objects
124  * from the {@code SyncFactory} mechanism.
125  * &lt;P&gt;
126  * The reference implementation (RI) provides two synchronization providers.
127  *    &lt;UL&gt;
128  *       &lt;LI&gt;&lt;b&gt;{@code RIOptimisticProvider}&lt;/b&gt; &lt;br&gt;
129  *            The default provider that the {@code SyncFactory} instance will
130  *            supply to a disconnected {@code RowSet} object when no provider
131  *            implementation is specified.&lt;BR&gt;
132  *            This synchronization provider uses an optimistic concurrency model,
133  *            assuming that there will be few conflicts among users
134  *            who are accessing the same data in a database.  It avoids
135  *            using locks; rather, it checks to see if there is a conflict
136  *            before trying to synchronize the {@code RowSet} object and the
137  *            data source. If there is a conflict, it does nothing, meaning that
138  *            changes to the {@code RowSet} object are not persisted to the data
139  *            source.
140  *        &lt;LI&gt;&lt;B&gt;{@code RIXMLProvider}&lt;/B&gt; &lt;BR&gt;
141  *             A synchronization provider that can be used with a
142  *             {@code WebRowSet} object, which is a rowset that can be written
143  *             in XML format or read from XML format. The
144  *             {@code RIXMLProvider} implementation does no checking at all for
145  *             conflicts and simply writes any updated data in the
146  *             {@code WebRowSet} object to the underlying data source.
147  *             {@code WebRowSet} objects use this provider when they are
148  *             dealing with XML data.
149  *     &lt;/UL&gt;
150  *
151  *  These {@code SyncProvider} implementations
152  *  are bundled with the reference implementation, which makes them always available to
153  *  {@code RowSet} implementations.
154  *  {@code SyncProvider} implementations make themselves available by being
155  *  registered with the {@code SyncFactory} singleton.  When a {@code RowSet}
156  *  object requests a provider, by specifying it in the constructor or as an argument to the
157  *  {@code CachedRowSet} method {@code setSyncProvider},
158  *  the {@code SyncFactory} singleton
159  *  checks to see if the requested provider has been registered with it.
160  *  If it has, the {@code SyncFactory} creates an instance of it and passes it to the
161  *  requesting {@code RowSet} object.
162  *  If the {@code SyncProvider} implementation that is specified has not been registered,
163  *  the {@code SyncFactory} singleton causes a {@code SyncFactoryException} object
164  *  to be thrown.  If no provider is specified,
165  *  the {@code SyncFactory} singleton will create an instance of the default
166  *  provider implementation, {@code RIOptimisticProvider},
167  *  and pass it to the requesting {@code RowSet} object.
168  *
169  * &lt;P&gt;
170  * If a {@code WebRowSet} object does not specify a provider in its constructor, the
171  * {@code SyncFactory} will give it an instance of {@code RIOptimisticProvider}.
172  * However, the constructor for {@code WebRowSet} is implemented to set the provider
173  * to the {@code RIXMLProvider}, which reads and writes a {@code RowSet} object
174  *  in XML format.
175  *  &lt;P&gt;
176  * See the &lt;a href=&quot;SyncProvider.html&quot;&gt;SyncProvider&lt;/a&gt; class
177  *  specification for further details.
178  * &lt;p&gt;
179  * Vendors may develop a {@code SyncProvider} implementation with any one of the possible
180  * levels of synchronization, thus giving {@code RowSet} objects a choice of
181  * synchronization mechanisms.
182  *
183  * &lt;h3&gt;&lt;a id=&quot;arch&quot;&gt;2.0 Service Provider Interface Architecture&lt;/a&gt;&lt;/h3&gt;
184  * &lt;b&gt;2.1 Overview&lt;/b&gt;
185  * &lt;p&gt;
186  * The Service Provider Interface provides a pluggable mechanism by which
187  * {@code SyncProvider} implementations can be registered and then generated when
188  * required. The lazy reference mechanism employed by the {@code SyncFactory} limits
189  * unnecessary resource consumption by not creating an instance until it is
190  * required by a disconnected
191  * {@code RowSet} object. The {@code SyncFactory} class also provides
192  * a standard API to configure logging options and streams that &lt;b&gt;may&lt;/b&gt; be provided
193  * by a particular {@code SyncProvider} implementation.
194  * &lt;p&gt;
195  * &lt;b&gt;2.2 Registering with the {@code SyncFactory}&lt;/b&gt;
196  * &lt;p&gt;
197  * A third party {@code SyncProvider} implementation must be registered with the
198  * {@code SyncFactory} in order for a disconnected {@code RowSet} object
199  * to obtain it and thereby use its {@code javax.sql.RowSetReader} and
200  * {@code javax.sql.RowSetWriter}
201  * implementations. The following registration mechanisms are available to all
202  * {@code SyncProvider} implementations:
203  * &lt;ul&gt;
204  * &lt;li&gt;&lt;b&gt;System properties&lt;/b&gt; - Properties set at the command line. These
205  * properties are set at run time and apply system-wide per invocation of the Java
206  * application. See the section &lt;a href=&quot;#reldocs&quot;&gt;&quot;Related Documentation&quot;&lt;/a&gt;
207  * further related information.
208  *
209  * &lt;li&gt;&lt;b&gt;Property Files&lt;/b&gt; - Properties specified in a standard property file.
210  * This can be specified using a System Property or by modifying a standard
211  * property file located in the platform run-time. The
212  * reference implementation of this technology includes a standard property
213  * file than can be edited to add additional {@code SyncProvider} objects.
214  *
215  * &lt;li&gt;&lt;b&gt;JNDI Context&lt;/b&gt; - Available providers can be registered on a JNDI
216  * context. The {@code SyncFactory} will attempt to load {@code SyncProvider}
217  * objects bound to the context and register them with the factory. This
218  * context must be supplied to the {@code SyncFactory} for the mechanism to
219  * function correctly.
220  * &lt;/ul&gt;
221  * &lt;p&gt;
222  * Details on how to specify the system properties or properties in a property file
223  * and how to configure the JNDI Context are explained in detail in the
224  * &lt;a href=&quot;SyncFactory.html&quot;&gt;{@code SyncFactory}&lt;/a&gt; class description.
225  * &lt;p&gt;
226  * &lt;b&gt;2.3 SyncFactory Provider Instance Generation Policies&lt;/b&gt;
227  * &lt;p&gt;
228  * The {@code SyncFactory} generates a requested {@code SyncProvider}
229  * object if the provider has been correctly registered.  The
230  * following policies are adhered to when either a disconnected {@code RowSet} object
231  * is instantiated with a specified {@code SyncProvider} implementation or is
232  * reconfigured at runtime with an alternative {@code SyncProvider} object.
233  * &lt;ul&gt;
234  * &lt;li&gt; If a {@code SyncProvider} object is specified and the {@code SyncFactory}
235  * contains &lt;i&gt;no&lt;/i&gt; reference to the provider, a {@code SyncFactoryException} is
236  * thrown.
237  *
238  * &lt;li&gt; If a {@code SyncProvider} object is specified and the {@code SyncFactory}
239  * contains a reference to the provider, the requested provider is supplied.
240  *
241  * &lt;li&gt; If no {@code SyncProvider} object is specified, the reference
242  * implementation provider {@code RIOptimisticProvider} is supplied.
243  * &lt;/ul&gt;
244  * &lt;p&gt;
245  * These policies are explored in more detail in the &lt;a href=&quot;SyncFactory.html&quot;&gt;
246  * {@code SyncFactory}&lt;/a&gt; class.
247  *
248  * &lt;h3&gt;&lt;a id=&quot;impl&quot;&gt;3.0 SyncProvider Implementer&#39;s Guide&lt;/a&gt;&lt;/h3&gt;
249  *
250  * &lt;b&gt;3.1 Requirements&lt;/b&gt;
251  * &lt;p&gt;
252  * A compliant {@code SyncProvider} implementation that is fully pluggable
253  * into the {@code SyncFactory} &lt;b&gt;must&lt;/b&gt; extend and implement all
254  * abstract methods in the &lt;a href=&quot;SyncProvider.html&quot;&gt;{@code SyncProvider}&lt;/a&gt;
255  * class. In addition, an implementation &lt;b&gt;must&lt;/b&gt; determine the
256  * grade, locking and updatable view capabilities defined in the
257  * {@code SyncProvider} class definition. One or more of the
258  * {@code SyncProvider} description criteria &lt;b&gt;must&lt;/b&gt; be supported. It
259  * is expected that vendor implementations will offer a range of grade, locking, and
260  * updatable view capabilities.
261  * &lt;p&gt;
262  * Furthermore, the {@code SyncProvider} naming convention &lt;b&gt;must&lt;/b&gt; be followed as
263  * detailed in the &lt;a href=&quot;SyncProvider.html&quot;&gt;{@code SyncProvider}&lt;/a&gt; class
264  * description.
265  * &lt;p&gt;
266  * &lt;b&gt;3.2 Grades&lt;/b&gt;
267  * &lt;p&gt;
268  * JSR 114 defines a set of grades to describe the quality of synchronization
269  * a {@code SyncProvider} object can offer a disconnected {@code RowSet}
270  * object. These grades are listed from the lowest quality of service to the highest.
271  * &lt;ul&gt;
272  * &lt;li&gt;&lt;b&gt;GRADE_NONE&lt;/b&gt; - No synchronization with the originating data source is
273  * provided. A {@code SyncProvider} implementation returning this grade will simply
274  * attempt to write any data that has changed in the {@code RowSet} object to the
275  *underlying data source, overwriting whatever is there. No attempt is made to compare
276  * original values with current values to see if there is a conflict. The
277  * {@code RIXMLProvider} is implemented with this grade.
278  *
279  * &lt;li&gt;&lt;b&gt;GRADE_CHECK_MODIFIED_AT_COMMIT&lt;/b&gt; - A low grade of optimistic synchronization.
280  * A {@code SyncProvider} implementation returning this grade
281  * will check for conflicts in rows that have changed between the last synchronization
282  * and the current synchronization under way. Any changes in the originating data source
283  * that have been modified will not be reflected in the disconnected {@code RowSet}
284  * object. If there are no conflicts, changes in the {@code RowSet} object will be
285  * written to the data source. If there are conflicts, no changes are written.
286  * The {@code RIOptimisticProvider} implementation uses this grade.
287  *
288  * &lt;li&gt;&lt;b&gt;GRADE_CHECK_ALL_AT_COMMIT&lt;/b&gt; - A high grade of optimistic synchronization.
289  * A {@code SyncProvider} implementation   returning this grade
290  * will check all rows, including rows that have not changed in the disconnected
291  * {@code RowSet} object. In this way, any changes to rows in the underlying
292  * data source will be reflected in the disconnected {@code RowSet} object
293  * when the synchronization finishes successfully.
294  *
295  * &lt;li&gt;&lt;b&gt;GRADE_LOCK_WHEN_MODIFIED&lt;/b&gt; - A pessimistic grade of synchronization.
296  * {@code SyncProvider} implementations returning this grade will lock
297  * the row in the originating  data source that corresponds to the row being changed
298  * in the {@code RowSet} object to reduce the possibility of other
299  * processes modifying the same data in the data source.
300  *
301  * &lt;li&gt;&lt;b&gt;GRADE_LOCK_WHEN_LOADED&lt;/b&gt; - A higher pessimistic synchronization grade.
302  * A {@code SyncProvider} implementation returning this grade will lock
303  * the entire view and/or  table affected by the original query used to
304  * populate a {@code RowSet} object.
305  * &lt;/ul&gt;
306  * &lt;p&gt;
307  * &lt;b&gt;3.3 Locks&lt;/b&gt;
308  * &lt;p&gt;
309  * JSR 114 defines a set of constants that specify whether any locks have been
310  * placed on a {@code RowSet} object&#39;s underlying data source and, if so,
311  * on which constructs the locks are placed.  These locks will remain on the data
312  * source while the {@code RowSet} object is disconnected from the data source.
313  * &lt;P&gt;
314  * These constants &lt;b&gt;should&lt;/b&gt; be considered complementary to the
315  * grade constants. The default setting for the majority of grade settings requires
316  * that no data source locks remain when a {@code RowSet} object is disconnected
317  * from its data source.
318  * The grades {@code GRADE_LOCK_WHEN_MODIFIED} and
319  * {@code GRADE_LOCK_WHEN_LOADED} allow a disconnected {@code RowSet} object
320  * to have a fine-grained control over the degree of locking.
321  * &lt;ul&gt;
322  * &lt;li&gt;&lt;b&gt;DATASOURCE_NO_LOCK&lt;/b&gt; - No locks remain on the originating data source.
323  * This is the default lock setting for all {@code SyncProvider} implementations
324  * unless otherwise directed by a {@code RowSet} object.
325  *
326  * &lt;li&gt;&lt;b&gt;DATASOURCE_ROW_LOCK&lt;/b&gt; - A lock is placed on the rows that are touched by
327  * the original SQL query used to populate the {@code RowSet} object.
328  *
329  * &lt;li&gt;&lt;b&gt;DATASOURCE_TABLE_LOCK&lt;/b&gt; - A lock is placed on all tables that are touched
330  * by the query that was used to populate the {@code RowSet} object.
331  *
332  * &lt;li&gt;&lt;b&gt;DATASOURCE_DB_LOCK&lt;/b&gt;
333  * A lock is placed on the entire data source that is used by the {@code RowSet}
334  * object.
335  * &lt;/ul&gt;
336  * &lt;p&gt;
337  * &lt;b&gt;3.4 Updatable Views&lt;/b&gt;
338  * &lt;p&gt;
339  * A {@code RowSet} object may be populated with data from an SQL {@code VIEW}.
340  * The following constants indicate whether a {@code SyncProvider} object can
341  * update data in the table or tables from which the {@code VIEW} was derived.
342  * &lt;ul&gt;
343  * &lt;li&gt;&lt;b&gt;UPDATABLE_VIEW_SYNC&lt;/b&gt;
344  * Indicates that a {@code SyncProvider} implementation  supports synchronization
345  * to the table or tables from which the SQL {@code VIEW} used to populate
346  * a {@code RowSet} object is derived.
347  *
348  * &lt;li&gt;&lt;b&gt;NONUPDATABLE_VIEW_SYNC&lt;/b&gt;
349  * Indicates that a {@code SyncProvider} implementation  does &lt;b&gt;not&lt;/b&gt; support
350  * synchronization to the table or tables from which the SQL {@code VIEW}
351  * used to populate  a {@code RowSet} object is derived.
352  * &lt;/ul&gt;
353  * &lt;p&gt;
354  * &lt;b&gt;3.5 Usage of {@code SyncProvider} Grading and Locking&lt;/b&gt;
355  * &lt;p&gt;
356  * In the example below, the reference {@code CachedRowSetImpl} implementation
357  * reconfigures its current {@code SyncProvider} object by calling the
358  * {@code setSyncProvider} method.&lt;br&gt;
359  *
360  * &lt;PRE&gt;
361  *   CachedRowSetImpl crs = new CachedRowSetImpl();
362  *   crs.setSyncProvider(&quot;com.foo.bar.HASyncProvider&quot;);
363  * &lt;/PRE&gt;
364  *   An application can retrieve the {@code SyncProvider} object currently in use
365  * by a disconnected {@code RowSet} object. It can also retrieve the
366  * grade of synchronization with which the provider was implemented and the degree of
367  * locking currently in use.  In addition, an application has the flexibility to set
368  * the degree of locking to be used, which can increase the possibilities for successful
369  * synchronization.  These operation are shown in the following code fragment.
370  * &lt;PRE&gt;
371  *   SyncProvider sync = crs.getSyncProvider();
372  *
373  *   switch (sync.getProviderGrade()) {
374  *   case: SyncProvider.GRADE_CHECK_ALL_AT_COMMIT
375  *         //A high grade of optimistic synchronization
376  *    break;
377  *    case: SyncProvider.GRADE_CHECK_MODIFIED_AT_COMMIT
378  *         //A low grade of optimistic synchronization
379  *    break;
380  *    case: SyncProvider.GRADE_LOCK_WHEN_LOADED
381  *         // A pessimistic synchronization grade
382  *    break;
383  *    case: SyncProvider.GRADE_LOCK_WHEN_MODIFIED
384  *         // A pessimistic synchronization grade
385  *    break;
386  *    case: SyncProvider.GRADE_NONE
387  *      // No synchronization with the originating data source provided
388  *    break;
389  *    }
390  *
391  *    switch (sync.getDataSourceLock() {
392  *      case: SyncProvider.DATASOURCE_DB_LOCK
393  *       // A lock is placed on the entire datasource that is used by the
394  *       // {@code RowSet} object
395  *       break;
396  *
397  *      case: SyncProvider.DATASOURCE_NO_LOCK
398  *       // No locks remain on the  originating data source.
399  *      break;
400  *
401  *      case: SyncProvider.DATASOURCE_ROW_LOCK
402  *       // A lock is placed on the rows that are  touched by the original
403  *       // SQL statement used to populate
404  *       // the RowSet object that is using the SyncProvider
405  *       break;
406  *
407  *      case: DATASOURCE_TABLE_LOCK
408  *       // A lock is placed on  all tables that are touched by the original
409  *       // SQL statement used to populated
410  *       // the RowSet object that is using the SyncProvider
411  *      break;
412  *
413  * &lt;/PRE&gt;
414  *    It is also possible using the static utility method in the
415  * {@code SyncFactory} class to determine the list of {@code SyncProvider}
416  * implementations currently registered with the {@code SyncFactory}.
417  *
418  * &lt;pre&gt;
419  *       Enumeration e = SyncFactory.getRegisteredProviders();
420  * &lt;/pre&gt;
421  *
422  *
423  * &lt;h3&gt;&lt;a id=&quot;resolving&quot;&gt;4.0 Resolving Synchronization Conflicts&lt;/a&gt;&lt;/h3&gt;
424  *
425  * The interface {@code SyncResolver} provides a way for an application to
426  * decide manually what to do when a conflict occurs. When the {@code CachedRowSet}
427  * method {@code acceptChanges} finishes and has detected one or more conflicts,
428  * it throws a {@code SyncProviderException} object.  An application can
429  * catch the exception and
430  * have it retrieve a {@code SyncResolver} object by calling the method
431  * {@code SyncProviderException.getSyncResolver()}.
432  * &lt;P&gt;
433  * A {@code SyncResolver} object, which is a special kind of
434  * {@code CachedRowSet} object or
435  * a {@code JdbcRowSet} object that has implemented the {@code SyncResolver}
436  * interface,  examines the conflicts row by row. It is a duplicate of the
437  * {@code RowSet} object being synchronized except that it contains only the data
438  * from the data source this is causing a conflict. All of the other column values are
439  * set to {@code null}. To navigate from one conflict value to another, a
440  * {@code SyncResolver} object provides the methods {@code nextConflict} and
441  * {@code previousConflict}.
442  * &lt;P&gt;
443  * The {@code SyncResolver} interface also
444  * provides methods for doing the following:
445  * &lt;UL&gt;
446  *  &lt;LI&gt;finding out whether the conflict involved an update, a delete, or an insert
447  *  &lt;LI&gt;getting the value in the data source that caused the conflict
448  *  &lt;LI&gt;setting the value that should be in the data source if it needs to be changed
449  *      or setting the value that should be in the {@code RowSet} object if it needs
450  *      to be changed
451  * &lt;/UL&gt;
452  * &lt;P&gt;
453  * When the {@code CachedRowSet} method {@code acceptChanges} is called, it
454  * delegates to the {@code RowSet} object&#39;s  {@code SyncProvider} object.
455  * How the writer provided by that {@code SyncProvider} object is implemented
456  * determines what level (grade) of checking for conflicts will be done.  After all
457  * checking for conflicts is completed and one or more conflicts has been found, the method
458  * {@code acceptChanges} throws a {@code SyncProviderException} object. The
459  * application can catch the exception and use it to obtain a {@code SyncResolver} object.
460  * &lt;P&gt;
461  * The application can then use {@code SyncResolver} methods to get information
462  * about each conflict and decide what to do.  If the application logic or the user
463  * decides that a value in the {@code RowSet} object should be the one to
464  * persist, the application or user can overwrite the data source value with it.
465  * &lt;P&gt;
466  * The comment for the {@code SyncResolver} interface has more detail.
467  *
468  * &lt;h3&gt;&lt;a id=&quot;relspec&quot;&gt;5.0 Related Specifications&lt;/a&gt;&lt;/h3&gt;
469  * &lt;ul&gt;
470  * &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/jndi/tutorial/index.html&quot;&gt;JNDI&lt;/a&gt;
471  * &lt;li&gt;&lt;a href=&quot;{@docRoot}/java.logging/java/util/logging/package-summary.html&quot;&gt;Java Logging
472  * APIs&lt;/a&gt;
473  * &lt;/ul&gt;
474  * &lt;h3&gt;&lt;a id=&quot;reldocs&quot;&gt;6.0 Related Documentation&lt;/a&gt;&lt;/h3&gt;
475  * &lt;ul&gt;
476  * &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/jdbc/&quot;&gt;DataSource for JDBC
477  * Connections&lt;/a&gt;
478  * &lt;/ul&gt;
479  */
480 package javax.sql.rowset.spi;
    </pre>
  </body>
</html>
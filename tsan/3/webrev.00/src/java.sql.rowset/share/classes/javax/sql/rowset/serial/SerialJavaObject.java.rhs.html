<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.sql.rowset/share/classes/javax/sql/rowset/serial/SerialJavaObject.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.sql.rowset.serial;
 27 
 28 import java.io.*;
 29 import java.lang.reflect.*;
 30 import java.util.Arrays;
 31 import java.util.Vector;
 32 import javax.sql.rowset.RowSetWarning;
 33 import jdk.internal.reflect.CallerSensitive;
 34 import jdk.internal.reflect.Reflection;
 35 import sun.reflect.misc.ReflectUtil;
 36 
 37 /**
 38  * A serializable mapping in the Java programming language of an SQL
 39  * &lt;code&gt;JAVA_OBJECT&lt;/code&gt; value. Assuming the Java object
 40  * implements the &lt;code&gt;Serializable&lt;/code&gt; interface, this class simply wraps the
 41  * serialization process.
 42  * &lt;P&gt;
 43  * If however, the serialization is not possible because
 44  * the Java object is not immediately serializable, this class will
 45  * attempt to serialize all non-static members to permit the object
 46  * state to be serialized.
 47  * Static or transient fields cannot be serialized; an attempt to serialize
 48  * them will result in a &lt;code&gt;SerialException&lt;/code&gt; object being thrown.
 49  *
 50  * &lt;h2&gt; Thread safety &lt;/h2&gt;
 51  *
 52  * A SerialJavaObject is not safe for use by multiple concurrent threads.  If a
 53  * SerialJavaObject is to be used by more than one thread then access to the
 54  * SerialJavaObject should be controlled by appropriate synchronization.
 55  *
 56  * @author Jonathan Bruce
 57  * @since 1.5
 58  */
 59 public class SerialJavaObject implements Serializable, Cloneable {
 60 
 61     /**
 62      * Placeholder for object to be serialized.
 63      */
<a name="1" id="anc1"></a><span class="line-added"> 64     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 65     private Object obj;
 66 
 67 
 68    /**
 69     * Placeholder for all fields in the &lt;code&gt;JavaObject&lt;/code&gt; being serialized.
 70     */
 71     private transient Field[] fields;
 72 
 73     /**
 74      * Constructor for &lt;code&gt;SerialJavaObject&lt;/code&gt; helper class.
 75      *
 76      * @param obj the Java &lt;code&gt;Object&lt;/code&gt; to be serialized
 77      * @throws SerialException if the object is found not to be serializable
 78      */
 79     public SerialJavaObject(Object obj) throws SerialException {
 80 
 81         // if any static fields are found, an exception
 82         // should be thrown
 83 
 84 
 85         // get Class. Object instance should always be available
 86         Class&lt;?&gt; c = obj.getClass();
 87 
 88         // determine if object implements Serializable i/f
 89         if (!(obj instanceof java.io.Serializable)) {
 90             setWarning(new RowSetWarning(&quot;Warning, the object passed to the constructor does not implement Serializable&quot;));
 91         }
 92 
 93         // can only determine public fields (obviously). If
 94         // any of these are static, this should invalidate
 95         // the action of attempting to persist these fields
 96         // in a serialized form
 97         fields = c.getFields();
 98 
 99         if (hasStaticFields(fields)) {
100             throw new SerialException(&quot;Located static fields in &quot; +
101                 &quot;object instance. Cannot serialize&quot;);
102         }
103 
104         this.obj = obj;
105     }
106 
107     /**
108      * Returns an &lt;code&gt;Object&lt;/code&gt; that is a copy of this &lt;code&gt;SerialJavaObject&lt;/code&gt;
109      * object.
110      *
111      * @return a copy of this &lt;code&gt;SerialJavaObject&lt;/code&gt; object as an
112      *         &lt;code&gt;Object&lt;/code&gt; in the Java programming language
113      * @throws SerialException if the instance is corrupt
114      */
115     public Object getObject() throws SerialException {
116         return this.obj;
117     }
118 
119     /**
120      * Returns an array of &lt;code&gt;Field&lt;/code&gt; objects that contains each
121      * field of the object that this helper class is serializing.
122      *
123      * @return an array of &lt;code&gt;Field&lt;/code&gt; objects
124      * @throws SerialException if an error is encountered accessing
125      * the serialized object
126      * @throws  SecurityException  If a security manager, &lt;i&gt;s&lt;/i&gt;, is present
127      * and the caller&#39;s class loader is not the same as or an
128      * ancestor of the class loader for the class of the
129      * {@linkplain #getObject object} being serialized
130      * and invocation of {@link SecurityManager#checkPackageAccess
131      * s.checkPackageAccess()} denies access to the package
132      * of that class.
133      * @see Class#getFields
134      */
135     @CallerSensitive
136     public Field[] getFields() throws SerialException {
137         if (fields != null) {
138             Class&lt;?&gt; c = this.obj.getClass();
139             SecurityManager sm = System.getSecurityManager();
140             if (sm != null) {
141                 /*
142                  * Check if the caller is allowed to access the specified class&#39;s package.
143                  * If access is denied, throw a SecurityException.
144                  */
145                 Class&lt;?&gt; caller = Reflection.getCallerClass();
146                 if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(),
147                                                         c.getClassLoader())) {
148                     ReflectUtil.checkPackageAccess(c);
149                 }
150             }
151             return c.getFields();
152         } else {
153             throw new SerialException(&quot;SerialJavaObject does not contain&quot; +
154                 &quot; a serialized object instance&quot;);
155         }
156     }
157 
158     /**
159      * The identifier that assists in the serialization of this
160      * &lt;code&gt;SerialJavaObject&lt;/code&gt; object.
161      */
162     static final long serialVersionUID = -1465795139032831023L;
163 
164     /**
165      * A container for the warnings issued on this &lt;code&gt;SerialJavaObject&lt;/code&gt;
166      * object. When there are multiple warnings, each warning is chained to the
167      * previous warning.
168      */
169     Vector&lt;RowSetWarning&gt; chain;
170 
171     /**
172      * Compares this SerialJavaObject to the specified object.
173      * The result is {@code true} if and only if the argument
174      * is not {@code null} and is a {@code SerialJavaObject}
175      * object that is identical to this object
176      *
177      * @param  o The object to compare this {@code SerialJavaObject} against
178      *
179      * @return  {@code true} if the given object represents a {@code SerialJavaObject}
180      *          equivalent to this SerialJavaObject, {@code false} otherwise
181      *
182      */
183     public boolean equals(Object o) {
184         if (this == o) {
185             return true;
186         }
187         if (o instanceof SerialJavaObject) {
188             SerialJavaObject sjo = (SerialJavaObject) o;
189             return obj.equals(sjo.obj);
190         }
191         return false;
192     }
193 
194     /**
195      * Returns a hash code for this SerialJavaObject. The hash code for a
196      * {@code SerialJavaObject} object is taken as the hash code of
197      * the {@code Object} it stores
198      *
199      * @return  a hash code value for this object.
200      */
201     public int hashCode() {
202         return 31 + obj.hashCode();
203     }
204 
205     /**
206      * Returns a clone of this {@code SerialJavaObject}.
207      *
208      * @return  a clone of this SerialJavaObject
209      */
210 
211     public Object clone() {
212         try {
213             SerialJavaObject sjo = (SerialJavaObject) super.clone();
214             sjo.fields = Arrays.copyOf(fields, fields.length);
215             if (chain != null)
216                 sjo.chain = new Vector&lt;&gt;(chain);
217             return sjo;
218         } catch (CloneNotSupportedException ex) {
219             // this shouldn&#39;t happen, since we are Cloneable
220             throw new InternalError();
221         }
222     }
223 
224     /**
225      * Registers the given warning.
226      */
227     private void setWarning(RowSetWarning e) {
228         if (chain == null) {
229             chain = new Vector&lt;&gt;();
230         }
231         chain.add(e);
232     }
233 
234     /**
235      * readObject is called to restore the state of the {@code SerialJavaObject}
236      * from a stream.
237      */
238     private void readObject(ObjectInputStream s)
239             throws IOException, ClassNotFoundException {
240 
241         ObjectInputStream.GetField fields1 = s.readFields();
242         @SuppressWarnings(&quot;unchecked&quot;)
243         Vector&lt;RowSetWarning&gt; tmp = (Vector&lt;RowSetWarning&gt;)fields1.get(&quot;chain&quot;, null);
244         if (tmp != null)
245             chain = new Vector&lt;&gt;(tmp);
246 
247         obj = fields1.get(&quot;obj&quot;, null);
248         if (obj != null) {
249             fields = obj.getClass().getFields();
250             if(hasStaticFields(fields))
251                 throw new IOException(&quot;Located static fields in &quot; +
252                 &quot;object instance. Cannot serialize&quot;);
253         } else {
254             throw new IOException(&quot;Object cannot be null!&quot;);
255         }
256 
257     }
258 
259     /**
260      * writeObject is called to save the state of the {@code SerialJavaObject}
261      * to a stream.
262      */
263     private void writeObject(ObjectOutputStream s)
264             throws IOException {
265         ObjectOutputStream.PutField fields = s.putFields();
266         fields.put(&quot;obj&quot;, obj);
267         fields.put(&quot;chain&quot;, chain);
268         s.writeFields();
269     }
270 
271     /*
272      * Check to see if there are any Static Fields in this object
273      */
274     private static boolean hasStaticFields(Field[] fields) {
275         for (Field field : fields) {
276             if ( field.getModifiers() == Modifier.STATIC) {
277                 return true;
278             }
279         }
280         return false;
281     }
282 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
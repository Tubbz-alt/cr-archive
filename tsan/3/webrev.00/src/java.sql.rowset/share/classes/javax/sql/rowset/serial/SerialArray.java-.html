<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.sql.rowset/share/classes/javax/sql/rowset/serial/SerialArray.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.sql.rowset.serial;
 27 
 28 import java.sql.*;
 29 import java.io.*;
 30 import java.util.Map;
 31 import java.net.URL;
 32 import java.util.Arrays;
 33 
 34 
 35 /**
 36  * A serialized version of an &lt;code&gt;Array&lt;/code&gt;
 37  * object, which is the mapping in the Java programming language of an SQL
 38  * &lt;code&gt;ARRAY&lt;/code&gt; value.
 39  * &lt;P&gt;
 40  * The &lt;code&gt;SerialArray&lt;/code&gt; class provides a constructor for creating
 41  * a &lt;code&gt;SerialArray&lt;/code&gt; instance from an &lt;code&gt;Array&lt;/code&gt; object,
 42  * methods for getting the base type and the SQL name for the base type, and
 43  * methods for copying all or part of a &lt;code&gt;SerialArray&lt;/code&gt; object.
 44  * &lt;P&gt;
 45  *
 46  * Note: In order for this class to function correctly, a connection to the
 47  * data source
 48  * must be available in order for the SQL &lt;code&gt;Array&lt;/code&gt; object to be
 49  * materialized (have all of its elements brought to the client server)
 50  * if necessary. At this time, logical pointers to the data in the data source,
 51  * such as locators, are not currently supported.
 52  *
 53  * &lt;h2&gt; Thread safety &lt;/h2&gt;
 54  *
 55  * A SerialArray is not safe for use by multiple concurrent threads.  If a
 56  * SerialArray is to be used by more than one thread then access to the
 57  * SerialArray should be controlled by appropriate synchronization.
 58  *
 59  * @since 1.5
 60  */
 61 public class SerialArray implements Array, Serializable, Cloneable {
 62 
 63     /**
 64      * A serialized array in which each element is an &lt;code&gt;Object&lt;/code&gt;
 65      * in the Java programming language that represents an element
 66      * in the SQL &lt;code&gt;ARRAY&lt;/code&gt; value.
 67      * @serial
 68      */
 69     private Object[] elements;
 70 
 71     /**
 72      * The SQL type of the elements in this &lt;code&gt;SerialArray&lt;/code&gt; object.  The
 73      * type is expressed as one of the constants from the class
 74      * &lt;code&gt;java.sql.Types&lt;/code&gt;.
 75      * @serial
 76      */
 77     private int baseType;
 78 
 79     /**
 80      * The type name used by the DBMS for the elements in the SQL &lt;code&gt;ARRAY&lt;/code&gt;
 81      * value that this &lt;code&gt;SerialArray&lt;/code&gt; object represents.
 82      * @serial
 83      */
 84     private String baseTypeName;
 85 
 86     /**
 87      * The number of elements in this &lt;code&gt;SerialArray&lt;/code&gt; object, which
 88      * is also the number of elements in the SQL &lt;code&gt;ARRAY&lt;/code&gt; value
 89      * that this &lt;code&gt;SerialArray&lt;/code&gt; object represents.
 90      * @serial
 91      */
 92     private int len;
 93 
 94     /**
 95      * Constructs a new &lt;code&gt;SerialArray&lt;/code&gt; object from the given
 96      * &lt;code&gt;Array&lt;/code&gt; object, using the given type map for the custom
 97      * mapping of each element when the elements are SQL UDTs.
 98      * &lt;P&gt;
 99      * This method does custom mapping if the array elements are a UDT
100      * and the given type map has an entry for that UDT.
101      * Custom mapping is recursive,
102      * meaning that if, for instance, an element of an SQL structured type
103      * is an SQL structured type that itself has an element that is an SQL
104      * structured type, each structured type that has a custom mapping will be
105      * mapped according to the given type map.
106      * &lt;P&gt;
107      * The new &lt;code&gt;SerialArray&lt;/code&gt;
108      * object contains the same elements as the &lt;code&gt;Array&lt;/code&gt; object
109      * from which it is built, except when the base type is the SQL type
110      * &lt;code&gt;STRUCT&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;BLOB&lt;/code&gt;,
111      * &lt;code&gt;CLOB&lt;/code&gt;, &lt;code&gt;DATALINK&lt;/code&gt; or &lt;code&gt;JAVA_OBJECT&lt;/code&gt;.
112      * In this case, each element in the new
113      * &lt;code&gt;SerialArray&lt;/code&gt; object is the appropriate serialized form,
114      * that is, a &lt;code&gt;SerialStruct&lt;/code&gt;, &lt;code&gt;SerialArray&lt;/code&gt;,
115      * &lt;code&gt;SerialBlob&lt;/code&gt;, &lt;code&gt;SerialClob&lt;/code&gt;,
116      * &lt;code&gt;SerialDatalink&lt;/code&gt;, or &lt;code&gt;SerialJavaObject&lt;/code&gt; object.
117      * &lt;P&gt;
118      * Note: (1) The &lt;code&gt;Array&lt;/code&gt; object from which a &lt;code&gt;SerialArray&lt;/code&gt;
119      * object is created must have materialized the SQL &lt;code&gt;ARRAY&lt;/code&gt; value&#39;s
120      * data on the client before it is passed to the constructor.  Otherwise,
121      * the new &lt;code&gt;SerialArray&lt;/code&gt; object will contain no data.
122      * &lt;p&gt;
123      * Note: (2) If the &lt;code&gt;Array&lt;/code&gt; contains &lt;code&gt;java.sql.Types.JAVA_OBJECT&lt;/code&gt;
124      * types, the &lt;code&gt;SerialJavaObject&lt;/code&gt; constructor is called where checks
125      * are made to ensure this object is serializable.
126      * &lt;p&gt;
127      * Note: (3) The &lt;code&gt;Array&lt;/code&gt; object supplied to this constructor cannot
128      * return &lt;code&gt;null&lt;/code&gt; for any &lt;code&gt;Array.getArray()&lt;/code&gt; methods.
129      * &lt;code&gt;SerialArray&lt;/code&gt; cannot serialize null array values.
130      *
131      *
132      * @param array the &lt;code&gt;Array&lt;/code&gt; object to be serialized
133      * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object in which
134      *        each entry consists of 1) a &lt;code&gt;String&lt;/code&gt; object
135      *        giving the fully qualified name of a UDT (an SQL structured type or
136      *        distinct type) and 2) the
137      *        &lt;code&gt;Class&lt;/code&gt; object for the &lt;code&gt;SQLData&lt;/code&gt; implementation
138      *        that defines how the UDT is to be mapped. The &lt;i&gt;map&lt;/i&gt;
139      *        parameter does not have any effect for &lt;code&gt;Blob&lt;/code&gt;,
140      *        &lt;code&gt;Clob&lt;/code&gt;, &lt;code&gt;DATALINK&lt;/code&gt;, or
141      *        &lt;code&gt;JAVA_OBJECT&lt;/code&gt; types.
142      * @throws SerialException if an error occurs serializing the
143      *        &lt;code&gt;Array&lt;/code&gt; object
144      * @throws SQLException if a database access error occurs or if the
145      *        &lt;i&gt;array&lt;/i&gt; or the &lt;i&gt;map&lt;/i&gt; values are &lt;code&gt;null&lt;/code&gt;
146      */
147      public SerialArray(Array array, Map&lt;String,Class&lt;?&gt;&gt; map)
148          throws SerialException, SQLException
149      {
150 
151         if ((array == null) || (map == null)) {
152             throw new SQLException(&quot;Cannot instantiate a SerialArray &quot; +
153             &quot;object with null parameters&quot;);
154         }
155 
156         if ((elements = (Object[])array.getArray()) == null) {
157              throw new SQLException(&quot;Invalid Array object. Calls to Array.getArray() &quot; +
158                  &quot;return null value which cannot be serialized&quot;);
159          }
160 
161         elements = (Object[])array.getArray(map);
162         baseType = array.getBaseType();
163         baseTypeName = array.getBaseTypeName();
164         len = elements.length;
165 
166         switch (baseType) {
167             case java.sql.Types.STRUCT:
168                 for (int i = 0; i &lt; len; i++) {
169                     elements[i] = new SerialStruct((Struct)elements[i], map);
170                 }
171             break;
172 
173             case java.sql.Types.ARRAY:
174                 for (int i = 0; i &lt; len; i++) {
175                     elements[i] = new SerialArray((Array)elements[i], map);
176                 }
177             break;
178 
179             case java.sql.Types.BLOB:
180             for (int i = 0; i &lt; len; i++) {
181                 elements[i] = new SerialBlob((Blob)elements[i]);
182             }
183             break;
184 
185             case java.sql.Types.CLOB:
186                 for (int i = 0; i &lt; len; i++) {
187                     elements[i] = new SerialClob((Clob)elements[i]);
188                 }
189             break;
190 
191             case java.sql.Types.DATALINK:
192                 for (int i = 0; i &lt; len; i++) {
193                     elements[i] = new SerialDatalink((URL)elements[i]);
194                 }
195             break;
196 
197             case java.sql.Types.JAVA_OBJECT:
198                 for (int i = 0; i &lt; len; i++) {
199                 elements[i] = new SerialJavaObject(elements[i]);
200             }
201         }
202   }
203 
204     /**
205      * This method frees the {@code SerialArray} object and releases the
206      * resources that it holds. The object is invalid once the {@code free}
207      * method is called. &lt;p&gt; If {@code free} is called multiple times, the
208      * subsequent calls to {@code free} are treated as a no-op. &lt;/P&gt;
209      *
210      * @throws SQLException if an error occurs releasing the SerialArray&#39;s resources
211      * @since 1.6
212      */
213     public void free() throws SQLException {
214         if (elements != null) {
215             elements = null;
216             baseTypeName= null;
217         }
218     }
219 
220     /**
221      * Constructs a new &lt;code&gt;SerialArray&lt;/code&gt; object from the given
222      * &lt;code&gt;Array&lt;/code&gt; object.
223      * &lt;P&gt;
224      * This constructor does not do custom mapping.  If the base type of the array
225      * is an SQL structured type and custom mapping is desired, the constructor
226      * &lt;code&gt;SerialArray(Array array, Map map)&lt;/code&gt; should be used.
227      * &lt;P&gt;
228      * The new &lt;code&gt;SerialArray&lt;/code&gt;
229      * object contains the same elements as the &lt;code&gt;Array&lt;/code&gt; object
230      * from which it is built, except when the base type is the SQL type
231      * &lt;code&gt;BLOB&lt;/code&gt;,
232      * &lt;code&gt;CLOB&lt;/code&gt;, &lt;code&gt;DATALINK&lt;/code&gt; or &lt;code&gt;JAVA_OBJECT&lt;/code&gt;.
233      * In this case, each element in the new
234      * &lt;code&gt;SerialArray&lt;/code&gt; object is the appropriate serialized form,
235      * that is, a &lt;code&gt;SerialBlob&lt;/code&gt;, &lt;code&gt;SerialClob&lt;/code&gt;,
236      * &lt;code&gt;SerialDatalink&lt;/code&gt;, or &lt;code&gt;SerialJavaObject&lt;/code&gt; object.
237      * &lt;P&gt;
238      * Note: (1) The &lt;code&gt;Array&lt;/code&gt; object from which a &lt;code&gt;SerialArray&lt;/code&gt;
239      * object is created must have materialized the SQL &lt;code&gt;ARRAY&lt;/code&gt; value&#39;s
240      * data on the client before it is passed to the constructor.  Otherwise,
241      * the new &lt;code&gt;SerialArray&lt;/code&gt; object will contain no data.
242      * &lt;p&gt;
243      * Note: (2) The &lt;code&gt;Array&lt;/code&gt; object supplied to this constructor cannot
244      * return &lt;code&gt;null&lt;/code&gt; for any &lt;code&gt;Array.getArray()&lt;/code&gt; methods.
245      * &lt;code&gt;SerialArray&lt;/code&gt; cannot serialize &lt;code&gt;null&lt;/code&gt; array values.
246      *
247      * @param array the &lt;code&gt;Array&lt;/code&gt; object to be serialized
248      * @throws SerialException if an error occurs serializing the
249      *     &lt;code&gt;Array&lt;/code&gt; object
250      * @throws SQLException if a database access error occurs or the
251      *     &lt;i&gt;array&lt;/i&gt; parameter is &lt;code&gt;null&lt;/code&gt;.
252      */
253      public SerialArray(Array array) throws SerialException, SQLException {
254          if (array == null) {
255              throw new SQLException(&quot;Cannot instantiate a SerialArray &quot; +
256                  &quot;object with a null Array object&quot;);
257          }
258 
259          if ((elements = (Object[])array.getArray()) == null) {
260              throw new SQLException(&quot;Invalid Array object. Calls to Array.getArray() &quot; +
261                  &quot;return null value which cannot be serialized&quot;);
262          }
263 
264          //elements = (Object[])array.getArray();
265          baseType = array.getBaseType();
266          baseTypeName = array.getBaseTypeName();
267          len = elements.length;
268 
269         switch (baseType) {
270 
271         case java.sql.Types.BLOB:
272             for (int i = 0; i &lt; len; i++) {
273                 elements[i] = new SerialBlob((Blob)elements[i]);
274             }
275             break;
276 
277         case java.sql.Types.CLOB:
278             for (int i = 0; i &lt; len; i++) {
279                 elements[i] = new SerialClob((Clob)elements[i]);
280             }
281             break;
282 
283         case java.sql.Types.DATALINK:
284             for (int i = 0; i &lt; len; i++) {
285                 elements[i] = new SerialDatalink((URL)elements[i]);
286             }
287             break;
288 
289         case java.sql.Types.JAVA_OBJECT:
290             for (int i = 0; i &lt; len; i++) {
291                 elements[i] = new SerialJavaObject(elements[i]);
292             }
293             break;
294 
295         }
296 
297 
298     }
299 
300     /**
301      * Returns a new array that is a copy of this &lt;code&gt;SerialArray&lt;/code&gt;
302      * object.
303      *
304      * @return a copy of this &lt;code&gt;SerialArray&lt;/code&gt; object as an
305      *         &lt;code&gt;Object&lt;/code&gt; in the Java programming language
306      * @throws SerialException if an error occurs;
307      * if {@code free} had previously been called on this object
308      */
309     public Object getArray() throws SerialException {
310         isValid();
311         Object dst = new Object[len];
312         System.arraycopy((Object)elements, 0, dst, 0, len);
313         return dst;
314     }
315 
316     /**
317      * Returns a new array that is a copy of this &lt;code&gt;SerialArray&lt;/code&gt;
318      * object, using the given type map for the custom
319      * mapping of each element when the elements are SQL UDTs.
320      * &lt;P&gt;
321      * This method does custom mapping if the array elements are a UDT
322      * and the given type map has an entry for that UDT.
323      * Custom mapping is recursive,
324      * meaning that if, for instance, an element of an SQL structured type
325      * is an SQL structured type that itself has an element that is an SQL
326      * structured type, each structured type that has a custom mapping will be
327      * mapped according to the given type map.
328      *
329      * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object in which
330      *        each entry consists of 1) a &lt;code&gt;String&lt;/code&gt; object
331      *        giving the fully qualified name of a UDT and 2) the
332      *        &lt;code&gt;Class&lt;/code&gt; object for the &lt;code&gt;SQLData&lt;/code&gt; implementation
333      *        that defines how the UDT is to be mapped
334      * @return a copy of this &lt;code&gt;SerialArray&lt;/code&gt; object as an
335      *         &lt;code&gt;Object&lt;/code&gt; in the Java programming language
336      * @throws SerialException if an error occurs;
337      * if {@code free} had previously been called on this object
338      */
339     public Object getArray(Map&lt;String, Class&lt;?&gt;&gt; map) throws SerialException {
340         isValid();
341         Object dst[] = new Object[len];
342         System.arraycopy((Object)elements, 0, dst, 0, len);
343         return dst;
344     }
345 
346     /**
347      * Returns a new array that is a copy of a slice
348      * of this &lt;code&gt;SerialArray&lt;/code&gt; object, starting with the
349      * element at the given index and containing the given number
350      * of consecutive elements.
351      *
352      * @param index the index into this &lt;code&gt;SerialArray&lt;/code&gt; object
353      *              of the first element to be copied;
354      *              the index of the first element is &lt;code&gt;0&lt;/code&gt;
355      * @param count the number of consecutive elements to be copied, starting
356      *              at the given index
357      * @return a copy of the designated elements in this &lt;code&gt;SerialArray&lt;/code&gt;
358      *         object as an &lt;code&gt;Object&lt;/code&gt; in the Java programming language
359      * @throws SerialException if an error occurs;
360      * if {@code free} had previously been called on this object
361      */
362     public Object getArray(long index, int count) throws SerialException {
363         isValid();
364         Object dst = new Object[count];
365         System.arraycopy((Object)elements, (int)index, dst, 0, count);
366         return dst;
367     }
368 
369     /**
370      * Returns a new array that is a copy of a slice
371      * of this &lt;code&gt;SerialArray&lt;/code&gt; object, starting with the
372      * element at the given index and containing the given number
373      * of consecutive elements.
374      * &lt;P&gt;
375      * This method does custom mapping if the array elements are a UDT
376      * and the given type map has an entry for that UDT.
377      * Custom mapping is recursive,
378      * meaning that if, for instance, an element of an SQL structured type
379      * is an SQL structured type that itself has an element that is an SQL
380      * structured type, each structured type that has a custom mapping will be
381      * mapped according to the given type map.
382      *
383      * @param index the index into this &lt;code&gt;SerialArray&lt;/code&gt; object
384      *              of the first element to be copied; the index of the
385      *              first element in the array is &lt;code&gt;0&lt;/code&gt;
386      * @param count the number of consecutive elements to be copied, starting
387      *              at the given index
388      * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object in which
389      *        each entry consists of 1) a &lt;code&gt;String&lt;/code&gt; object
390      *        giving the fully qualified name of a UDT and 2) the
391      *        &lt;code&gt;Class&lt;/code&gt; object for the &lt;code&gt;SQLData&lt;/code&gt; implementation
392      *        that defines how the UDT is to be mapped
393      * @return a copy of the designated elements in this &lt;code&gt;SerialArray&lt;/code&gt;
394      *         object as an &lt;code&gt;Object&lt;/code&gt; in the Java programming language
395      * @throws SerialException if an error occurs;
396      * if {@code free} had previously been called on this object
397      */
398     public Object getArray(long index, int count, Map&lt;String,Class&lt;?&gt;&gt; map)
399         throws SerialException
400     {
401         isValid();
402         Object dst = new Object[count];
403         System.arraycopy((Object)elements, (int)index, dst, 0, count);
404         return dst;
405     }
406 
407     /**
408      * Retrieves the SQL type of the elements in this &lt;code&gt;SerialArray&lt;/code&gt;
409      * object.  The &lt;code&gt;int&lt;/code&gt; returned is one of the constants in the class
410      * &lt;code&gt;java.sql.Types&lt;/code&gt;.
411      *
412      * @return one of the constants in &lt;code&gt;java.sql.Types&lt;/code&gt;, indicating
413      *         the SQL type of the elements in this &lt;code&gt;SerialArray&lt;/code&gt; object
414      * @throws SerialException if an error occurs;
415      * if {@code free} had previously been called on this object
416      */
417     public int getBaseType() throws SerialException {
418         isValid();
419         return baseType;
420     }
421 
422     /**
423      * Retrieves the DBMS-specific type name for the elements in this
424      * &lt;code&gt;SerialArray&lt;/code&gt; object.
425      *
426      * @return the SQL type name used by the DBMS for the base type of this
427      *         &lt;code&gt;SerialArray&lt;/code&gt; object
428      * @throws SerialException if an error occurs;
429      * if {@code free} had previously been called on this object
430      */
431     public String getBaseTypeName() throws SerialException {
432         isValid();
433         return baseTypeName;
434     }
435 
436     /**
437      * Retrieves a &lt;code&gt;ResultSet&lt;/code&gt; object holding the elements of
438      * the subarray that starts at
439      * index &lt;i&gt;index&lt;/i&gt; and contains up to &lt;i&gt;count&lt;/i&gt; successive elements.
440      * This method uses the connection&#39;s type map to map the elements of
441      * the array if the map contains
442      * an entry for the base type. Otherwise, the standard mapping is used.
443      *
444      * @param index the index into this &lt;code&gt;SerialArray&lt;/code&gt; object
445      *         of the first element to be copied; the index of the
446      *         first element in the array is &lt;code&gt;0&lt;/code&gt;
447      * @param count the number of consecutive elements to be copied, starting
448      *         at the given index
449      * @return a &lt;code&gt;ResultSet&lt;/code&gt; object containing the designated
450      *         elements in this &lt;code&gt;SerialArray&lt;/code&gt; object, with a
451      *         separate row for each element
452      * @throws SerialException if called with the cause set to
453      *         {@code UnsupportedOperationException}
454      */
455     public ResultSet getResultSet(long index, int count) throws SerialException {
456         SerialException se = new SerialException();
457         se.initCause(new UnsupportedOperationException());
458         throw  se;
459     }
460 
461     /**
462      *
463      * Retrieves a &lt;code&gt;ResultSet&lt;/code&gt; object that contains all of
464      * the elements of the SQL &lt;code&gt;ARRAY&lt;/code&gt;
465      * value represented by this &lt;code&gt;SerialArray&lt;/code&gt; object. This method uses
466      * the specified map for type map customizations unless the base type of the
467      * array does not match a user-defined type (UDT) in &lt;i&gt;map&lt;/i&gt;, in
468      * which case it uses the
469      * standard mapping. This version of the method &lt;code&gt;getResultSet&lt;/code&gt;
470      * uses either the given type map or the standard mapping; it never uses the
471      * type map associated with the connection.
472      *
473      * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object in which
474      *        each entry consists of 1) a &lt;code&gt;String&lt;/code&gt; object
475      *        giving the fully qualified name of a UDT and 2) the
476      *        &lt;code&gt;Class&lt;/code&gt; object for the &lt;code&gt;SQLData&lt;/code&gt; implementation
477      *        that defines how the UDT is to be mapped
478      * @return a &lt;code&gt;ResultSet&lt;/code&gt; object containing all of the
479      *         elements in this &lt;code&gt;SerialArray&lt;/code&gt; object, with a
480      *         separate row for each element
481      * @throws SerialException if called with the cause set to
482      *         {@code UnsupportedOperationException}
483      */
484     public ResultSet getResultSet(Map&lt;String, Class&lt;?&gt;&gt; map)
485         throws SerialException
486     {
487         SerialException se = new SerialException();
488         se.initCause(new UnsupportedOperationException());
489         throw  se;
490     }
491 
492     /**
493      * Retrieves a &lt;code&gt;ResultSet&lt;/code&gt; object that contains all of
494      * the elements in the &lt;code&gt;ARRAY&lt;/code&gt; value that this
495      * &lt;code&gt;SerialArray&lt;/code&gt; object represents.
496      * If appropriate, the elements of the array are mapped using the connection&#39;s
497      * type map; otherwise, the standard mapping is used.
498      *
499      * @return a &lt;code&gt;ResultSet&lt;/code&gt; object containing all of the
500      *         elements in this &lt;code&gt;SerialArray&lt;/code&gt; object, with a
501      *         separate row for each element
502      * @throws SerialException if called with the cause set to
503      *         {@code UnsupportedOperationException}
504      */
505     public ResultSet getResultSet() throws SerialException {
506         SerialException se = new SerialException();
507         se.initCause(new UnsupportedOperationException());
508         throw  se;
509     }
510 
511 
512     /**
513      * Retrieves a result set holding the elements of the subarray that starts at
514      * Retrieves a &lt;code&gt;ResultSet&lt;/code&gt; object that contains a subarray of the
515      * elements in this &lt;code&gt;SerialArray&lt;/code&gt; object, starting at
516      * index &lt;i&gt;index&lt;/i&gt; and containing up to &lt;i&gt;count&lt;/i&gt; successive
517      * elements. This method uses
518      * the specified map for type map customizations unless the base type of the
519      * array does not match a user-defined type (UDT) in &lt;i&gt;map&lt;/i&gt;, in
520      * which case it uses the
521      * standard mapping. This version of the method &lt;code&gt;getResultSet&lt;/code&gt; uses
522      * either the given type map or the standard mapping; it never uses the type
523      * map associated with the connection.
524      *
525      * @param index the index into this &lt;code&gt;SerialArray&lt;/code&gt; object
526      *              of the first element to be copied; the index of the
527      *              first element in the array is &lt;code&gt;0&lt;/code&gt;
528      * @param count the number of consecutive elements to be copied, starting
529      *              at the given index
530      * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object in which
531      *        each entry consists of 1) a &lt;code&gt;String&lt;/code&gt; object
532      *        giving the fully qualified name of a UDT and 2) the
533      *        &lt;code&gt;Class&lt;/code&gt; object for the &lt;code&gt;SQLData&lt;/code&gt; implementation
534      *        that defines how the UDT is to be mapped
535      * @return a &lt;code&gt;ResultSet&lt;/code&gt; object containing the designated
536      *         elements in this &lt;code&gt;SerialArray&lt;/code&gt; object, with a
537      *         separate row for each element
538      * @throws SerialException if called with the cause set to
539      *         {@code UnsupportedOperationException}
540      */
541     public ResultSet getResultSet(long index, int count,
542                                   Map&lt;String,Class&lt;?&gt;&gt; map)
543         throws SerialException
544     {
545         SerialException se = new SerialException();
546         se.initCause(new UnsupportedOperationException());
547         throw  se;
548     }
549 
550 
551     /**
552      * Compares this SerialArray to the specified object.  The result is {@code
553      * true} if and only if the argument is not {@code null} and is a {@code
554      * SerialArray} object whose elements are identical to this object&#39;s elements
555      *
556      * @param  obj The object to compare this {@code SerialArray} against
557      *
558      * @return  {@code true} if the given object represents a {@code SerialArray}
559      *          equivalent to this SerialArray, {@code false} otherwise
560      *
561      */
562     public boolean equals(Object obj) {
563         if (this == obj) {
564             return true;
565         }
566 
567         if (obj instanceof SerialArray) {
568             SerialArray sa = (SerialArray)obj;
569             return baseType == sa.baseType &amp;&amp;
570                     baseTypeName.equals(sa.baseTypeName) &amp;&amp;
571                     Arrays.equals(elements, sa.elements);
572         }
573         return false;
574     }
575 
576     /**
577      * Returns a hash code for this SerialArray. The hash code for a
578      * {@code SerialArray} object is computed using the hash codes
579      * of the elements of the  {@code SerialArray} object
580      *
581      * @return  a hash code value for this object.
582      */
583     public int hashCode() {
584         return (((31 + Arrays.hashCode(elements)) * 31 + len)  * 31 +
585                 baseType) * 31 + baseTypeName.hashCode();
586     }
587 
588     /**
589      * Returns a clone of this {@code SerialArray}. The copy will contain a
590      * reference to a clone of the underlying objects array, not a reference
591      * to the original underlying object array of this {@code SerialArray} object.
592      *
593      * @return a clone of this SerialArray
594      */
595     public Object clone() {
596         try {
597             SerialArray sa = (SerialArray) super.clone();
598             sa.elements = (elements != null) ? Arrays.copyOf(elements, len) : null;
599             return sa;
600         } catch (CloneNotSupportedException ex) {
601             // this shouldn&#39;t happen, since we are Cloneable
602             throw new InternalError();
603         }
604 
605     }
606 
607     /**
608      * readObject is called to restore the state of the {@code SerialArray} from
609      * a stream.
610      */
611     private void readObject(ObjectInputStream s)
612             throws IOException, ClassNotFoundException {
613 
614        ObjectInputStream.GetField fields = s.readFields();
615        Object[] tmp = (Object[])fields.get(&quot;elements&quot;, null);
616        if (tmp == null)
617            throw new InvalidObjectException(&quot;elements is null and should not be!&quot;);
618        elements = tmp.clone();
619        len = fields.get(&quot;len&quot;, 0);
620        if(elements.length != len)
621            throw new InvalidObjectException(&quot;elements is not the expected size&quot;);
622 
623        baseType = fields.get(&quot;baseType&quot;, 0);
624        baseTypeName = (String)fields.get(&quot;baseTypeName&quot;, null);
625     }
626 
627     /**
628      * writeObject is called to save the state of the {@code SerialArray}
629      * to a stream.
630      */
631     private void writeObject(ObjectOutputStream s)
632             throws IOException {
633 
634         ObjectOutputStream.PutField fields = s.putFields();
635         fields.put(&quot;elements&quot;, elements);
636         fields.put(&quot;len&quot;, len);
637         fields.put(&quot;baseType&quot;, baseType);
638         fields.put(&quot;baseTypeName&quot;, baseTypeName);
639         s.writeFields();
640     }
641 
642     /**
643      * Check to see if this object had previously had its {@code free} method
644      * called
645      *
646      * @throws SerialException
647      */
648     private void isValid() throws SerialException {
649         if (elements == null) {
650             throw new SerialException(&quot;Error: You cannot call a method on a &quot;
651                     + &quot;SerialArray instance once free() has been called.&quot;);
652         }
653     }
654 
655     /**
656      * The identifier that assists in the serialization of this &lt;code&gt;SerialArray&lt;/code&gt;
657      * object.
658      */
659     static final long serialVersionUID = -8466174297270688520L;
660 }
    </pre>
  </body>
</html>
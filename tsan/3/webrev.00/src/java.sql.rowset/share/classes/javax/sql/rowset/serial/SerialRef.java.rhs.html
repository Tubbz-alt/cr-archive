<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.sql.rowset/share/classes/javax/sql/rowset/serial/SerialRef.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.sql.rowset.serial;
 27 
 28 import java.sql.*;
 29 import java.io.*;
 30 import java.util.*;
 31 
 32 /**
 33  * A serialized mapping of a &lt;code&gt;Ref&lt;/code&gt; object, which is the mapping in the
 34  * Java programming language of an SQL &lt;code&gt;REF&lt;/code&gt; value.
 35  * &lt;p&gt;
 36  * The &lt;code&gt;SerialRef&lt;/code&gt; class provides a constructor  for
 37  * creating a &lt;code&gt;SerialRef&lt;/code&gt; instance from a &lt;code&gt;Ref&lt;/code&gt;
 38  * object and provides methods for getting and setting the &lt;code&gt;Ref&lt;/code&gt; object.
 39  *
 40  * &lt;h2&gt; Thread safety &lt;/h2&gt;
 41  *
 42  * A SerialRef is not safe for use by multiple concurrent threads.  If a
 43  * SerialRef is to be used by more than one thread then access to the SerialRef
 44  * should be controlled by appropriate synchronization.
 45  *
 46  * @since 1.5
 47  */
 48 public class SerialRef implements Ref, Serializable, Cloneable {
 49 
 50     /**
 51      * String containing the base type name.
 52      * @serial
 53      */
 54     private String baseTypeName;
 55 
 56     /**
 57      * This will store the type &lt;code&gt;Ref&lt;/code&gt; as an &lt;code&gt;Object&lt;/code&gt;.
 58      */
<a name="1" id="anc1"></a><span class="line-added"> 59     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 60     private Object object;
 61 
 62     /**
 63      * Private copy of the Ref reference.
 64      */
<a name="2" id="anc2"></a><span class="line-added"> 65     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable; checked in writeObject</span>
 66     private Ref reference;
 67 
 68     /**
 69      * Constructs a &lt;code&gt;SerialRef&lt;/code&gt; object from the given &lt;code&gt;Ref&lt;/code&gt;
 70      * object.
 71      *
 72      * @param ref a Ref object; cannot be &lt;code&gt;null&lt;/code&gt;
 73      * @throws SQLException if a database access occurs; if &lt;code&gt;ref&lt;/code&gt;
 74      *     is &lt;code&gt;null&lt;/code&gt;; or if the &lt;code&gt;Ref&lt;/code&gt; object returns a
 75      *     &lt;code&gt;null&lt;/code&gt; value base type name.
 76      * @throws SerialException if an error occurs serializing the &lt;code&gt;Ref&lt;/code&gt;
 77      *     object
 78      */
 79     public SerialRef(Ref ref) throws SerialException, SQLException {
 80         if (ref == null) {
 81             throw new SQLException(&quot;Cannot instantiate a SerialRef object &quot; +
 82                 &quot;with a null Ref object&quot;);
 83         }
 84         reference = ref;
 85         object = ref;
 86         if (ref.getBaseTypeName() == null) {
 87             throw new SQLException(&quot;Cannot instantiate a SerialRef object &quot; +
 88                 &quot;that returns a null base type name&quot;);
 89         } else {
 90             baseTypeName = ref.getBaseTypeName();
 91         }
 92     }
 93 
 94     /**
 95      * Returns a string describing the base type name of the &lt;code&gt;Ref&lt;/code&gt;.
 96      *
 97      * @return a string of the base type name of the Ref
 98      * @throws SerialException in no Ref object has been set
 99      */
100     public String getBaseTypeName() throws SerialException {
101         return baseTypeName;
102     }
103 
104     /**
105      * Returns an &lt;code&gt;Object&lt;/code&gt; representing the SQL structured type
106      * to which this &lt;code&gt;SerialRef&lt;/code&gt; object refers.  The attributes
107      * of the structured type are mapped according to the given type map.
108      *
109      * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object containing zero or
110      *        more entries, with each entry consisting of 1) a &lt;code&gt;String&lt;/code&gt;
111      *        giving the fully qualified name of a UDT and 2) the
112      *        &lt;code&gt;Class&lt;/code&gt; object for the &lt;code&gt;SQLData&lt;/code&gt; implementation
113      *        that defines how the UDT is to be mapped
114      * @return an object instance resolved from the Ref reference and mapped
115      *        according to the supplied type map
116      * @throws SerialException if an error is encountered in the reference
117      *        resolution
118      */
119     public Object getObject(java.util.Map&lt;String,Class&lt;?&gt;&gt; map)
120         throws SerialException
121     {
122         map = new Hashtable&lt;String, Class&lt;?&gt;&gt;(map);
123         if (object != null) {
124             return map.get(object);
125         } else {
126             throw new SerialException(&quot;The object is not set&quot;);
127         }
128     }
129 
130     /**
131      * Returns an &lt;code&gt;Object&lt;/code&gt; representing the SQL structured type
132      * to which this &lt;code&gt;SerialRef&lt;/code&gt; object refers.
133      *
134      * @return an object instance resolved from the Ref reference
135      * @throws SerialException if an error is encountered in the reference
136      *         resolution
137      */
138     public Object getObject() throws SerialException {
139 
140         if (reference != null) {
141             try {
142                 return reference.getObject();
143             } catch (SQLException e) {
144                 throw new SerialException(&quot;SQLException: &quot; + e.getMessage());
145             }
146         }
147 
148         if (object != null) {
149             return object;
150         }
151 
152 
153         throw new SerialException(&quot;The object is not set&quot;);
154 
155     }
156 
157     /**
158      * Sets the SQL structured type that this &lt;code&gt;SerialRef&lt;/code&gt; object
159      * references to the given &lt;code&gt;Object&lt;/code&gt; object.
160      *
161      * @param obj an &lt;code&gt;Object&lt;/code&gt; representing the SQL structured type
162      *        to be referenced
163      * @throws SerialException if an error is encountered generating the
164      * the structured type referenced by this &lt;code&gt;SerialRef&lt;/code&gt; object
165      */
166     public void setObject(Object obj) throws SerialException {
167         try {
168             reference.setObject(obj);
169         } catch (SQLException e) {
170             throw new SerialException(&quot;SQLException: &quot; + e.getMessage());
171         }
172         object = obj;
173     }
174 
175     /**
176      * Compares this SerialRef to the specified object.  The result is {@code
177      * true} if and only if the argument is not {@code null} and is a {@code
178      * SerialRef} object that represents the same object as this
179      * object.
180      *
181      * @param  obj The object to compare this {@code SerialRef} against
182      *
183      * @return  {@code true} if the given object represents a {@code SerialRef}
184      *          equivalent to this SerialRef, {@code false} otherwise
185      *
186      */
187     public boolean equals(Object obj) {
188         if (this == obj) {
189             return true;
190         }
191         if(obj instanceof SerialRef) {
192             SerialRef ref = (SerialRef)obj;
193             return baseTypeName.equals(ref.baseTypeName) &amp;&amp;
194                     object.equals(ref.object);
195         }
196         return false;
197     }
198 
199     /**
200      * Returns a hash code for this {@code SerialRef}.
201      * @return  a hash code value for this object.
202      */
203     public int hashCode() {
204         return (31 + object.hashCode()) * 31 + baseTypeName.hashCode();
205     }
206 
207     /**
208      * Returns a clone of this {@code SerialRef}.
209      * The underlying {@code Ref} object will be set to null.
210      *
211      * @return  a clone of this SerialRef
212      */
213     public Object clone() {
214         try {
215             SerialRef ref = (SerialRef) super.clone();
216             ref.reference = null;
217             return ref;
218         } catch (CloneNotSupportedException ex) {
219             // this shouldn&#39;t happen, since we are Cloneable
220             throw new InternalError();
221         }
222 
223     }
224 
225     /**
226      * readObject is called to restore the state of the SerialRef from
227      * a stream.
228      */
229     private void readObject(ObjectInputStream s)
230             throws IOException, ClassNotFoundException {
231         ObjectInputStream.GetField fields = s.readFields();
232         object = fields.get(&quot;object&quot;, null);
233         baseTypeName = (String) fields.get(&quot;baseTypeName&quot;, null);
234         reference = (Ref) fields.get(&quot;reference&quot;, null);
235     }
236 
237     /**
238      * writeObject is called to save the state of the SerialRef
239      * to a stream.
240      */
241     private void writeObject(ObjectOutputStream s)
242             throws IOException {
243 
244         ObjectOutputStream.PutField fields = s.putFields();
245         fields.put(&quot;baseTypeName&quot;, baseTypeName);
246         fields.put(&quot;object&quot;, object);
247         // Note: this check to see if it is an instance of Serializable
248         // is for backwards compatibility
249         fields.put(&quot;reference&quot;, reference instanceof Serializable ? reference : null);
250         s.writeFields();
251     }
252 
253     /**
254      * The identifier that assists in the serialization of this &lt;code&gt;SerialRef&lt;/code&gt;
255      * object.
256      */
257     static final long serialVersionUID = -4727123500609662274L;
258 
259 
260 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
diff a/src/java.compiler/share/classes/javax/annotation/processing/AbstractProcessor.java b/src/java.compiler/share/classes/javax/annotation/processing/AbstractProcessor.java
--- a/src/java.compiler/share/classes/javax/annotation/processing/AbstractProcessor.java
+++ b/src/java.compiler/share/classes/javax/annotation/processing/AbstractProcessor.java
@@ -23,10 +23,11 @@
  * questions.
  */
 
 package javax.annotation.processing;
 
+import java.util.List;
 import java.util.Set;
 import java.util.HashSet;
 import java.util.Collections;
 import java.util.Objects;
 import javax.lang.model.element.*;
@@ -78,14 +79,13 @@
      * @return the options recognized by this processor, or an empty
      * set if none
      */
     public Set<String> getSupportedOptions() {
         SupportedOptions so = this.getClass().getAnnotation(SupportedOptions.class);
-        if  (so == null)
-            return Collections.emptySet();
-        else
-            return arrayToSet(so.value(), false);
+        return (so == null) ?
+            Set.of() :
+            arrayToSet(so.value(), false, "option value", "@SupportedOptions");
     }
 
     /**
      * If the processor class is annotated with {@link
      * SupportedAnnotationTypes}, return an unmodifiable set with the
@@ -108,16 +108,17 @@
                 if (initialized)
                     processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
                                                              "No SupportedAnnotationTypes annotation " +
                                                              "found on " + this.getClass().getName() +
                                                              ", returning an empty set.");
-                return Collections.emptySet();
+                return Set.of();
             } else {
                 boolean stripModulePrefixes =
                         initialized &&
                         processingEnv.getSourceVersion().compareTo(SourceVersion.RELEASE_8) <= 0;
-                return arrayToSet(sat.value(), stripModulePrefixes);
+                return arrayToSet(sat.value(), stripModulePrefixes,
+                                  "annotation type", "@SupportedAnnotationTypes");
             }
         }
 
     /**
      * If the processor class is annotated with {@link
@@ -179,11 +180,11 @@
      */
     public Iterable<? extends Completion> getCompletions(Element element,
                                                          AnnotationMirror annotation,
                                                          ExecutableElement member,
                                                          String userText) {
-        return Collections.emptyList();
+        return List.of();
     }
 
     /**
      * Returns {@code true} if this object has been {@linkplain #init
      * initialized}, {@code false} otherwise.
@@ -193,20 +194,36 @@
      */
     protected synchronized boolean isInitialized() {
         return initialized;
     }
 
-    private static Set<String> arrayToSet(String[] array,
-                                          boolean stripModulePrefixes) {
+    private Set<String> arrayToSet(String[] array,
+                                          boolean stripModulePrefixes,
+                                   String contentType,
+                                   String annotationName) {
         assert array != null;
-        Set<String> set = new HashSet<>(array.length);
+        Set<String> set = new HashSet<>();
         for (String s : array) {
+            boolean stripped = false;
             if (stripModulePrefixes) {
                 int index = s.indexOf('/');
-                if (index != -1)
+                if (index != -1) {
                     s = s.substring(index + 1);
+                    stripped = true;
+                }
+            }
+            boolean added = set.add(s);
+            // Don't issue a duplicate warning when the module name is
+            // stripped off to avoid spurious warnings in a case like
+            // "foo/a.B", "bar/a.B".
+            if (!added && !stripped && isInitialized() ) {
+                processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
+                                                         "Duplicate " + contentType  +
+                                                         " ``" + s  + "'' for processor " +
+                                                         this.getClass().getName() +
+                                                         " in its " + annotationName  +
+                                                         "annotation.");
             }
-            set.add(s);
         }
         return Collections.unmodifiableSet(set);
     }
 }

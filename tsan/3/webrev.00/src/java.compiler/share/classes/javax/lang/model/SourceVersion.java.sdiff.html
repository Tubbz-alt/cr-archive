<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.compiler/share/classes/javax/lang/model/SourceVersion.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="AnnotatedConstruct.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="element/Element.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.compiler/share/classes/javax/lang/model/SourceVersion.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 41  *
 42  * @author Joseph D. Darcy
 43  * @author Scott Seligman
 44  * @author Peter von der Ah&amp;eacute;
 45  * @since 1.6
 46  */
 47 public enum SourceVersion {
 48     /*
 49      * Summary of language evolution
 50      * 1.1: nested classes
 51      * 1.2: strictfp
 52      * 1.3: no changes
 53      * 1.4: assert
 54      * 1.5: annotations, generics, autoboxing, var-args...
 55      * 1.6: no changes
 56      * 1.7: diamond syntax, try-with-resources, etc.
 57      * 1.8: lambda expressions and default methods
 58      *   9: modules, small cleanups to 1.7 and 1.8 changes
 59      *  10: local-variable type inference (var)
 60      *  11: local-variable syntax for lambda parameters
<span class="line-modified"> 61      *  12: TBD</span>
<span class="line-modified"> 62      *  13: TBD</span>



 63      */
 64 
 65     /**
 66      * The original version.
 67      *
 68      * The language described in
 69      * &lt;cite&gt;The Java&amp;trade; Language Specification, First Edition&lt;/cite&gt;.
 70      */
 71     RELEASE_0,
 72 
 73     /**
 74      * The version recognized by the Java Platform 1.1.
 75      *
 76      * The language is {@code RELEASE_0} augmented with nested classes as described in the 1.1 update to
 77      * &lt;cite&gt;The Java&amp;trade; Language Specification, First Edition&lt;/cite&gt;.
 78      */
 79     RELEASE_1,
 80 
 81     /**
 82      * The version recognized by the Java 2 Platform, Standard Edition,
</pre>
<hr />
<pre>
175      * lambda parameters.
176      *
177      * @since 11
178      */
179      RELEASE_11,
180 
181     /**
182      * The version recognized by the Java Platform, Standard Edition
183      * 12.
184      *
185      * @since 12
186      */
187      RELEASE_12,
188 
189     /**
190      * The version recognized by the Java Platform, Standard Edition
191      * 13.
192      *
193      * @since 13
194      */
<span class="line-modified">195      RELEASE_13;</span>


















196 
197     // Note that when adding constants for newer releases, the
198     // behavior of latest() and latestSupported() must be updated too.
199 
200     /**
201      * Returns the latest source version that can be modeled.
202      *
203      * @return the latest source version that can be modeled
204      */
205     public static SourceVersion latest() {
<span class="line-modified">206         return RELEASE_13;</span>
207     }
208 
209     private static final SourceVersion latestSupported = getLatestSupported();
210 







211     private static SourceVersion getLatestSupported() {
<span class="line-modified">212         try {</span>
<span class="line-modified">213             String specVersion = System.getProperty(&quot;java.specification.version&quot;);</span>
<span class="line-modified">214 </span>
<span class="line-modified">215             switch (specVersion) {</span>
<span class="line-removed">216                 case &quot;13&quot;:</span>
<span class="line-removed">217                     return RELEASE_13;</span>
<span class="line-removed">218                 case &quot;12&quot;:</span>
<span class="line-removed">219                     return RELEASE_12;</span>
<span class="line-removed">220                 case &quot;11&quot;:</span>
<span class="line-removed">221                     return RELEASE_11;</span>
<span class="line-removed">222                 case &quot;10&quot;:</span>
<span class="line-removed">223                     return RELEASE_10;</span>
<span class="line-removed">224                 case &quot;9&quot;:</span>
<span class="line-removed">225                     return RELEASE_9;</span>
<span class="line-removed">226                 case &quot;1.8&quot;:</span>
<span class="line-removed">227                     return RELEASE_8;</span>
<span class="line-removed">228                 case &quot;1.7&quot;:</span>
<span class="line-removed">229                     return RELEASE_7;</span>
<span class="line-removed">230                 case &quot;1.6&quot;:</span>
<span class="line-removed">231                     return RELEASE_6;</span>
<span class="line-removed">232             }</span>
<span class="line-removed">233         } catch (SecurityException se) {}</span>
<span class="line-removed">234 </span>
<span class="line-removed">235         return RELEASE_5;</span>
236     }
237 
238     /**
239      * Returns the latest source version fully supported by the
<span class="line-modified">240      * current execution environment.  {@code RELEASE_5} or later must</span>
241      * be returned.
242      *















243      * @return the latest source version that is fully supported
244      */
245     public static SourceVersion latestSupported() {
246         return latestSupported;
247     }
248 
249     /**
250      * Returns whether or not {@code name} is a syntactically valid
251      * identifier (simple name) or keyword in the latest source
252      * version.  The method returns {@code true} if the name consists
253      * of an initial character for which {@link
254      * Character#isJavaIdentifierStart(int)} returns {@code true},
255      * followed only by characters for which {@link
256      * Character#isJavaIdentifierPart(int)} returns {@code true}.
257      * This pattern matches regular identifiers, keywords, restricted
<span class="line-modified">258      * keywords, and the literals {@code &quot;true&quot;}, {@code &quot;false&quot;},</span>
<span class="line-modified">259      * {@code &quot;null&quot;}, and {@code &quot;var&quot;}.</span>
260      *
261      * The method returns {@code false} for all other strings.
262      *
263      * @param name the string to check
264      * @return {@code true} if this string is a
265      * syntactically valid identifier or keyword, {@code false}
266      * otherwise.


267      */
268     public static boolean isIdentifier(CharSequence name) {
269         String id = name.toString();
270 
271         if (id.length() == 0) {
272             return false;
273         }
274         int cp = id.codePointAt(0);
275         if (!Character.isJavaIdentifierStart(cp)) {
276             return false;
277         }
278         for (int i = Character.charCount(cp);
279                 i &lt; id.length();
280                 i += Character.charCount(cp)) {
281             cp = id.codePointAt(i);
282             if (!Character.isJavaIdentifierPart(cp)) {
283                 return false;
284             }
285         }
286         return true;
287     }
288 
289     /**
290      * Returns whether or not {@code name} is a syntactically valid
<span class="line-modified">291      * qualified name in the latest source version.  Unlike {@link</span>
<span class="line-modified">292      * #isIdentifier isIdentifier}, this method returns {@code false}</span>
<span class="line-modified">293      * for keywords, boolean literals, and the null literal.</span>







294      *
295      * This method returns {@code true} for &lt;i&gt;restricted
<span class="line-modified">296      * keywords&lt;/i&gt; and {@code &quot;var&quot;}.</span>
297      *
298      * @param name the string to check
299      * @return {@code true} if this string is a
300      * syntactically valid name, {@code false} otherwise.
301      * @jls 3.9 Keywords
302      * @jls 6.2 Names and Identifiers
303      */
304     public static boolean isName(CharSequence name) {
305         return isName(name, latest());
306     }
307 
308     /**
309      * Returns whether or not {@code name} is a syntactically valid
<span class="line-modified">310      * qualified name in the given source version.  Unlike {@link</span>
<span class="line-modified">311      * #isIdentifier isIdentifier}, this method returns {@code false}</span>
<span class="line-modified">312      * for keywords, boolean literals, and the null literal.</span>







313      *
314      * This method returns {@code true} for &lt;i&gt;restricted
<span class="line-modified">315      * keywords&lt;/i&gt; and {@code &quot;var&quot;}.</span>
316      *
317      * @param name the string to check
318      * @param version the version to use
319      * @return {@code true} if this string is a
320      * syntactically valid name, {@code false} otherwise.
321      * @jls 3.9 Keywords
322      * @jls 6.2 Names and Identifiers
323      * @since 9
324      */
325     public static boolean isName(CharSequence name, SourceVersion version) {
326         String id = name.toString();
327 
328         for(String s : id.split(&quot;\\.&quot;, -1)) {
329             if (!isIdentifier(s) || isKeyword(s, version))
330                 return false;
331         }
332         return true;
333     }
334 
335     /**
336      * Returns whether or not {@code s} is a keyword, boolean literal,
337      * or null literal in the latest source version.
338      * This method returns {@code false} for &lt;i&gt;restricted
<span class="line-modified">339      * keywords&lt;/i&gt; and {@code &quot;var&quot;}.</span>
340      *
341      * @param s the string to check
342      * @return {@code true} if {@code s} is a keyword, or boolean
343      * literal, or null literal, {@code false} otherwise.
344      * @jls 3.9 Keywords
345      * @jls 3.10.3 Boolean Literals
346      * @jls 3.10.7 The Null Literal
347      */
348     public static boolean isKeyword(CharSequence s) {
349         return isKeyword(s, latest());
350     }
351 
352     /**
353      * Returns whether or not {@code s} is a keyword, boolean literal,
354      * or null literal in the given source version.
355      * This method returns {@code false} for &lt;i&gt;restricted
<span class="line-modified">356      * keywords&lt;/i&gt; and {@code &quot;var&quot;}.</span>
357      *
358      * @param s the string to check
359      * @param version the version to use
360      * @return {@code true} if {@code s} is a keyword, or boolean
361      * literal, or null literal, {@code false} otherwise.
362      * @jls 3.9 Keywords
363      * @jls 3.10.3 Boolean Literals
364      * @jls 3.10.7 The Null Literal
365      * @since 9
366      */
367     public static boolean isKeyword(CharSequence s, SourceVersion version) {
368         String id = s.toString();
369         switch(id) {
370             // A trip through history
371         case &quot;strictfp&quot;:
372             return version.compareTo(RELEASE_2) &gt;= 0;
373 
374         case &quot;assert&quot;:
375             return version.compareTo(RELEASE_4) &gt;= 0;
376 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 41  *
 42  * @author Joseph D. Darcy
 43  * @author Scott Seligman
 44  * @author Peter von der Ah&amp;eacute;
 45  * @since 1.6
 46  */
 47 public enum SourceVersion {
 48     /*
 49      * Summary of language evolution
 50      * 1.1: nested classes
 51      * 1.2: strictfp
 52      * 1.3: no changes
 53      * 1.4: assert
 54      * 1.5: annotations, generics, autoboxing, var-args...
 55      * 1.6: no changes
 56      * 1.7: diamond syntax, try-with-resources, etc.
 57      * 1.8: lambda expressions and default methods
 58      *   9: modules, small cleanups to 1.7 and 1.8 changes
 59      *  10: local-variable type inference (var)
 60      *  11: local-variable syntax for lambda parameters
<span class="line-modified"> 61      *  12: no changes (switch expressions in preview)</span>
<span class="line-modified"> 62      *  13: no changes (switch expressions and text blocks in preview)</span>
<span class="line-added"> 63      *  14: switch expressions (pattern matching and records in</span>
<span class="line-added"> 64      *      preview, text blocks in preview again)</span>
<span class="line-added"> 65      *  15: TBD</span>
 66      */
 67 
 68     /**
 69      * The original version.
 70      *
 71      * The language described in
 72      * &lt;cite&gt;The Java&amp;trade; Language Specification, First Edition&lt;/cite&gt;.
 73      */
 74     RELEASE_0,
 75 
 76     /**
 77      * The version recognized by the Java Platform 1.1.
 78      *
 79      * The language is {@code RELEASE_0} augmented with nested classes as described in the 1.1 update to
 80      * &lt;cite&gt;The Java&amp;trade; Language Specification, First Edition&lt;/cite&gt;.
 81      */
 82     RELEASE_1,
 83 
 84     /**
 85      * The version recognized by the Java 2 Platform, Standard Edition,
</pre>
<hr />
<pre>
178      * lambda parameters.
179      *
180      * @since 11
181      */
182      RELEASE_11,
183 
184     /**
185      * The version recognized by the Java Platform, Standard Edition
186      * 12.
187      *
188      * @since 12
189      */
190      RELEASE_12,
191 
192     /**
193      * The version recognized by the Java Platform, Standard Edition
194      * 13.
195      *
196      * @since 13
197      */
<span class="line-modified">198      RELEASE_13,</span>
<span class="line-added">199 </span>
<span class="line-added">200     /**</span>
<span class="line-added">201      * The version recognized by the Java Platform, Standard Edition</span>
<span class="line-added">202      * 14.</span>
<span class="line-added">203      *</span>
<span class="line-added">204      * Additions in this release include switch expressions.</span>
<span class="line-added">205      *</span>
<span class="line-added">206      * @since 14</span>
<span class="line-added">207      */</span>
<span class="line-added">208     RELEASE_14,</span>
<span class="line-added">209 </span>
<span class="line-added">210     /**</span>
<span class="line-added">211      * The version recognized by the Java Platform, Standard Edition</span>
<span class="line-added">212      * 15.</span>
<span class="line-added">213      *</span>
<span class="line-added">214      * @since 15</span>
<span class="line-added">215      */</span>
<span class="line-added">216      RELEASE_15;</span>
217 
218     // Note that when adding constants for newer releases, the
219     // behavior of latest() and latestSupported() must be updated too.
220 
221     /**
222      * Returns the latest source version that can be modeled.
223      *
224      * @return the latest source version that can be modeled
225      */
226     public static SourceVersion latest() {
<span class="line-modified">227         return RELEASE_15;</span>
228     }
229 
230     private static final SourceVersion latestSupported = getLatestSupported();
231 
<span class="line-added">232     /*</span>
<span class="line-added">233      * The integer version to enum constant mapping implemented by</span>
<span class="line-added">234      * this method assumes the JEP 322: &quot;Time-Based Release</span>
<span class="line-added">235      * Versioning&quot; scheme is in effect. This scheme began in JDK</span>
<span class="line-added">236      * 10. If the JDK versioning scheme is revised, this method may</span>
<span class="line-added">237      * need to be updated accordingly.</span>
<span class="line-added">238      */</span>
239     private static SourceVersion getLatestSupported() {
<span class="line-modified">240         int intVersion = Runtime.version().feature();</span>
<span class="line-modified">241         return (intVersion &gt;= 11) ?</span>
<span class="line-modified">242             valueOf(&quot;RELEASE_&quot; + Math.min(15, intVersion)):</span>
<span class="line-modified">243             RELEASE_10;</span>




















244     }
245 
246     /**
247      * Returns the latest source version fully supported by the
<span class="line-modified">248      * current execution environment.  {@code RELEASE_9} or later must</span>
249      * be returned.
250      *
<span class="line-added">251      * @apiNote This method is included alongside {@link latest} to</span>
<span class="line-added">252      * allow identification of situations where the language model API</span>
<span class="line-added">253      * is running on a platform version different than the latest</span>
<span class="line-added">254      * version modeled by the API. One way that sort of situation can</span>
<span class="line-added">255      * occur is if an IDE or similar tool is using the API to model</span>
<span class="line-added">256      * source version &lt;i&gt;N&lt;/i&gt; while running on platform version</span>
<span class="line-added">257      * (&lt;i&gt;N&lt;/i&gt;&amp;nbsp;-&amp;nbsp;1). Running in this configuration is</span>
<span class="line-added">258      * supported by the API. Running an API on platform versions</span>
<span class="line-added">259      * earlier than (&lt;i&gt;N&lt;/i&gt;&amp;nbsp;-&amp;nbsp;1) or later than &lt;i&gt;N&lt;/i&gt;</span>
<span class="line-added">260      * may or may not work as an implementation detail. If an</span>
<span class="line-added">261      * annotation processor was generating code to run under the</span>
<span class="line-added">262      * current execution environment, the processor should only use</span>
<span class="line-added">263      * platform features up to the {@code latestSupported} release,</span>
<span class="line-added">264      * which may be earlier than the {@code latest} release.</span>
<span class="line-added">265      *</span>
266      * @return the latest source version that is fully supported
267      */
268     public static SourceVersion latestSupported() {
269         return latestSupported;
270     }
271 
272     /**
273      * Returns whether or not {@code name} is a syntactically valid
274      * identifier (simple name) or keyword in the latest source
275      * version.  The method returns {@code true} if the name consists
276      * of an initial character for which {@link
277      * Character#isJavaIdentifierStart(int)} returns {@code true},
278      * followed only by characters for which {@link
279      * Character#isJavaIdentifierPart(int)} returns {@code true}.
280      * This pattern matches regular identifiers, keywords, restricted
<span class="line-modified">281      * keywords, restricted identifiers and the literals {@code &quot;true&quot;},</span>
<span class="line-modified">282      * {@code &quot;false&quot;}, {@code &quot;null&quot;}.</span>
283      *
284      * The method returns {@code false} for all other strings.
285      *
286      * @param name the string to check
287      * @return {@code true} if this string is a
288      * syntactically valid identifier or keyword, {@code false}
289      * otherwise.
<span class="line-added">290      *</span>
<span class="line-added">291      * @jls 3.8 Identifiers</span>
292      */
293     public static boolean isIdentifier(CharSequence name) {
294         String id = name.toString();
295 
296         if (id.length() == 0) {
297             return false;
298         }
299         int cp = id.codePointAt(0);
300         if (!Character.isJavaIdentifierStart(cp)) {
301             return false;
302         }
303         for (int i = Character.charCount(cp);
304                 i &lt; id.length();
305                 i += Character.charCount(cp)) {
306             cp = id.codePointAt(i);
307             if (!Character.isJavaIdentifierPart(cp)) {
308                 return false;
309             }
310         }
311         return true;
312     }
313 
314     /**
315      * Returns whether or not {@code name} is a syntactically valid
<span class="line-modified">316      * qualified name in the latest source version.</span>
<span class="line-modified">317      *</span>
<span class="line-modified">318      * Syntactically, a qualified name is a sequence of identifiers</span>
<span class="line-added">319      * separated by period characters (&quot;{@code .}&quot;). This method</span>
<span class="line-added">320      * splits the input string into period-separated segments and</span>
<span class="line-added">321      * applies checks to each segment in turn.</span>
<span class="line-added">322      *</span>
<span class="line-added">323      * Unlike {@link #isIdentifier isIdentifier}, this method returns</span>
<span class="line-added">324      * {@code false} for keywords, boolean literals, and the null</span>
<span class="line-added">325      * literal in any segment.</span>
326      *
327      * This method returns {@code true} for &lt;i&gt;restricted
<span class="line-modified">328      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;</span>
329      *
330      * @param name the string to check
331      * @return {@code true} if this string is a
332      * syntactically valid name, {@code false} otherwise.
333      * @jls 3.9 Keywords
334      * @jls 6.2 Names and Identifiers
335      */
336     public static boolean isName(CharSequence name) {
337         return isName(name, latest());
338     }
339 
340     /**
341      * Returns whether or not {@code name} is a syntactically valid
<span class="line-modified">342      * qualified name in the given source version.</span>
<span class="line-modified">343      *</span>
<span class="line-modified">344      * Syntactically, a qualified name is a sequence of identifiers</span>
<span class="line-added">345      * separated by period characters (&quot;{@code .}&quot;). This method</span>
<span class="line-added">346      * splits the input string into period-separated segments and</span>
<span class="line-added">347      * applies checks to each segment in turn.</span>
<span class="line-added">348      *</span>
<span class="line-added">349      * Unlike {@link #isIdentifier isIdentifier}, this method returns</span>
<span class="line-added">350      * {@code false} for keywords, boolean literals, and the null</span>
<span class="line-added">351      * literal in any segment.</span>
352      *
353      * This method returns {@code true} for &lt;i&gt;restricted
<span class="line-modified">354      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;</span>
355      *
356      * @param name the string to check
357      * @param version the version to use
358      * @return {@code true} if this string is a
359      * syntactically valid name, {@code false} otherwise.
360      * @jls 3.9 Keywords
361      * @jls 6.2 Names and Identifiers
362      * @since 9
363      */
364     public static boolean isName(CharSequence name, SourceVersion version) {
365         String id = name.toString();
366 
367         for(String s : id.split(&quot;\\.&quot;, -1)) {
368             if (!isIdentifier(s) || isKeyword(s, version))
369                 return false;
370         }
371         return true;
372     }
373 
374     /**
375      * Returns whether or not {@code s} is a keyword, boolean literal,
376      * or null literal in the latest source version.
377      * This method returns {@code false} for &lt;i&gt;restricted
<span class="line-modified">378      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;.</span>
379      *
380      * @param s the string to check
381      * @return {@code true} if {@code s} is a keyword, or boolean
382      * literal, or null literal, {@code false} otherwise.
383      * @jls 3.9 Keywords
384      * @jls 3.10.3 Boolean Literals
385      * @jls 3.10.7 The Null Literal
386      */
387     public static boolean isKeyword(CharSequence s) {
388         return isKeyword(s, latest());
389     }
390 
391     /**
392      * Returns whether or not {@code s} is a keyword, boolean literal,
393      * or null literal in the given source version.
394      * This method returns {@code false} for &lt;i&gt;restricted
<span class="line-modified">395      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;.</span>
396      *
397      * @param s the string to check
398      * @param version the version to use
399      * @return {@code true} if {@code s} is a keyword, or boolean
400      * literal, or null literal, {@code false} otherwise.
401      * @jls 3.9 Keywords
402      * @jls 3.10.3 Boolean Literals
403      * @jls 3.10.7 The Null Literal
404      * @since 9
405      */
406     public static boolean isKeyword(CharSequence s, SourceVersion version) {
407         String id = s.toString();
408         switch(id) {
409             // A trip through history
410         case &quot;strictfp&quot;:
411             return version.compareTo(RELEASE_2) &gt;= 0;
412 
413         case &quot;assert&quot;:
414             return version.compareTo(RELEASE_4) &gt;= 0;
415 
</pre>
</td>
</tr>
</table>
<center><a href="AnnotatedConstruct.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="element/Element.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.compiler/share/classes/javax/tools/StandardJavaFileManager.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.tools;
 27 
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.nio.file.Path;
<a name="1" id="anc1"></a>
 31 import java.util.Arrays;
 32 import java.util.Collection;
 33 import java.util.Iterator;
<a name="2" id="anc2"></a>
 34 
 35 /**
 36  * File manager based on {@linkplain File java.io.File} and {@linkplain Path java.nio.file.Path}.
 37  *
 38  * A common way to obtain an instance of this class is using
 39  * {@linkplain JavaCompiler#getStandardFileManager getStandardFileManager}, for example:
 40  *
 41  * &lt;pre&gt;
 42  *   JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
 43  *   {@code DiagnosticCollector&lt;JavaFileObject&gt;} diagnostics =
 44  *       new {@code DiagnosticCollector&lt;JavaFileObject&gt;()};
 45  *   StandardJavaFileManager fm = compiler.getStandardFileManager(diagnostics, null, null);
 46  * &lt;/pre&gt;
 47  *
 48  * This file manager creates file objects representing regular
 49  * {@linkplain File files},
 50  * {@linkplain java.util.zip.ZipEntry zip file entries}, or entries in
 51  * similar file system based containers.  Any file object returned
 52  * from a file manager implementing this interface must observe the
 53  * following behavior:
 54  *
 55  * &lt;ul&gt;
 56  *   &lt;li&gt;
 57  *     File names need not be canonical.
 58  *   &lt;/li&gt;
 59  *   &lt;li&gt;
 60  *     For file objects representing regular files
 61  *     &lt;ul&gt;
 62  *       &lt;li&gt;
 63  *         the method &lt;code&gt;{@linkplain FileObject#delete()}&lt;/code&gt;
 64  *         is equivalent to &lt;code&gt;{@linkplain File#delete()}&lt;/code&gt;,
 65  *       &lt;/li&gt;
 66  *       &lt;li&gt;
 67  *         the method &lt;code&gt;{@linkplain FileObject#getLastModified()}&lt;/code&gt;
 68  *         is equivalent to &lt;code&gt;{@linkplain File#lastModified()}&lt;/code&gt;,
 69  *       &lt;/li&gt;
 70  *       &lt;li&gt;
 71  *         the methods &lt;code&gt;{@linkplain FileObject#getCharContent(boolean)}&lt;/code&gt;,
 72  *         &lt;code&gt;{@linkplain FileObject#openInputStream()}&lt;/code&gt;, and
 73  *         &lt;code&gt;{@linkplain FileObject#openReader(boolean)}&lt;/code&gt;
 74  *         must succeed if the following would succeed (ignoring
 75  *         encoding issues):
 76  *         &lt;blockquote&gt;
 77  *           &lt;pre&gt;new {@linkplain java.io.FileInputStream#FileInputStream(File) FileInputStream}(new {@linkplain File#File(java.net.URI) File}({@linkplain FileObject fileObject}.{@linkplain FileObject#toUri() toUri}()))&lt;/pre&gt;
 78  *         &lt;/blockquote&gt;
 79  *       &lt;/li&gt;
 80  *       &lt;li&gt;
 81  *         and the methods
 82  *         &lt;code&gt;{@linkplain FileObject#openOutputStream()}&lt;/code&gt;, and
 83  *         &lt;code&gt;{@linkplain FileObject#openWriter()}&lt;/code&gt; must
 84  *         succeed if the following would succeed (ignoring encoding
 85  *         issues):
 86  *         &lt;blockquote&gt;
 87  *           &lt;pre&gt;new {@linkplain java.io.FileOutputStream#FileOutputStream(File) FileOutputStream}(new {@linkplain File#File(java.net.URI) File}({@linkplain FileObject fileObject}.{@linkplain FileObject#toUri() toUri}()))&lt;/pre&gt;
 88  *         &lt;/blockquote&gt;
 89  *       &lt;/li&gt;
 90  *     &lt;/ul&gt;
 91  *   &lt;/li&gt;
 92  *   &lt;li&gt;
 93  *     The {@linkplain java.net.URI URI} returned from
 94  *     &lt;code&gt;{@linkplain FileObject#toUri()}&lt;/code&gt;
 95  *     &lt;ul&gt;
 96  *       &lt;li&gt;
 97  *         must be {@linkplain java.net.URI#isAbsolute() absolute} (have a schema), and
 98  *       &lt;/li&gt;
 99  *       &lt;li&gt;
100  *         must have a {@linkplain java.net.URI#normalize() normalized}
101  *         {@linkplain java.net.URI#getPath() path component} which
102  *         can be resolved without any process-specific context such
103  *         as the current directory (file names must be absolute).
104  *       &lt;/li&gt;
105  *     &lt;/ul&gt;
106  *   &lt;/li&gt;
107  * &lt;/ul&gt;
108  *
109  * According to these rules, the following URIs, for example, are
110  * allowed:
111  * &lt;ul&gt;
112  *   &lt;li&gt;
113  *     &lt;code&gt;file:///C:/Documents%20and%20Settings/UncleBob/BobsApp/Test.java&lt;/code&gt;
114  *   &lt;/li&gt;
115  *   &lt;li&gt;
116  *     &lt;code&gt;jar:///C:/Documents%20and%20Settings/UncleBob/lib/vendorA.jar!/com/vendora/LibraryClass.class&lt;/code&gt;
117  *   &lt;/li&gt;
118  * &lt;/ul&gt;
119  * Whereas these are not (reason in parentheses):
120  * &lt;ul&gt;
121  *   &lt;li&gt;
122  *     &lt;code&gt;file:BobsApp/Test.java&lt;/code&gt; (the file name is relative
123  *     and depend on the current directory)
124  *   &lt;/li&gt;
125  *   &lt;li&gt;
126  *     &lt;code&gt;jar:lib/vendorA.jar!/com/vendora/LibraryClass.class&lt;/code&gt;
127  *     (the first half of the path depends on the current directory,
128  *     whereas the component after ! is legal)
129  *   &lt;/li&gt;
130  *   &lt;li&gt;
131  *     &lt;code&gt;Test.java&lt;/code&gt; (this URI depends on the current
132  *     directory and does not have a schema)
133  *   &lt;/li&gt;
134  *   &lt;li&gt;
135  *     &lt;code&gt;jar:///C:/Documents%20and%20Settings/UncleBob/BobsApp/../lib/vendorA.jar!com/vendora/LibraryClass.class&lt;/code&gt;
136  *     (the path is not normalized)
137  *   &lt;/li&gt;
138  * &lt;/ul&gt;
139  *
140  * &lt;p&gt;All implementations of this interface must support Path objects representing
141  * files in the {@linkplain java.nio.file.FileSystems#getDefault() default file system.}
142  * It is recommended that implementations should support Path objects from any filesystem.&lt;/p&gt;
143  *
144  *
145  * @apiNote
146  * Some methods on this interface take a {@code Collection&lt;? extends Path&gt;}
147  * instead of {@code Iterable&lt;? extends Path&gt;}.
148  * This is to prevent the possibility of accidentally calling the method
149  * with a single {@code Path} as such an argument, because although
150  * {@code Path} implements {@code Iterable&lt;Path&gt;}, it would almost never be
151  * correct to call these methods with a single {@code Path} and have it be treated as
152  * an {@code Iterable} of its components.
153  *
154  *
155  * @author Peter von der Ah&amp;eacute;
156  * @since 1.6
157  */
158 public interface StandardJavaFileManager extends JavaFileManager {
159 
160     /**
161      * Compares two file objects and return true if they represent the
162      * same canonical file, zip file entry, or entry in any file
163      * system based container.
164      *
165      * @param a a file object
166      * @param b a file object
167      * @return true if the given file objects represent the same
168      * canonical file, zip file entry or path; false otherwise
169      *
170      * @throws IllegalArgumentException if either of the arguments
171      * were created with another file manager implementation
172      */
173     @Override
174     boolean isSameFile(FileObject a, FileObject b);
175 
176     /**
177      * Returns file objects representing the given files.
178      *
179      * @param files a list of files
180      * @return a list of file objects
181      * @throws IllegalArgumentException if the list of files includes
182      * a directory
183      */
184     Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromFiles(
185         Iterable&lt;? extends File&gt; files);
186 
<a name="3" id="anc3"></a>





















187     /**
188      * Returns file objects representing the given paths.
189      *
190      * @implSpec
191      * The default implementation converts each path to a file and calls
192      * {@link #getJavaFileObjectsFromFiles getJavaObjectsFromFiles}.
193      * IllegalArgumentException will be thrown if any of the paths
194      * cannot be converted to a file.
195      *
196      * @param paths a list of paths
197      * @return a list of file objects
198      * @throws IllegalArgumentException if the list of paths includes
199      * a directory or if this file manager does not support any of the
200      * given paths.
201      *
202      * @since 9
<a name="4" id="anc4"></a>





203      */
<a name="5" id="anc5"></a>
204     default Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromPaths(
205             Iterable&lt;? extends Path&gt; paths) {
<a name="6" id="anc6"></a><span class="line-modified">206         return getJavaFileObjectsFromFiles(asFiles(paths));</span>
207     }
208 
209     /**
210      * Returns file objects representing the given files.
211      * Convenience method equivalent to:
212      *
213      * &lt;pre&gt;
214      *     getJavaFileObjectsFromFiles({@linkplain java.util.Arrays#asList Arrays.asList}(files))
215      * &lt;/pre&gt;
216      *
217      * @param files an array of files
218      * @return a list of file objects
219      * @throws IllegalArgumentException if the array of files includes
220      * a directory
221      * @throws NullPointerException if the given array contains null
222      * elements
223      */
224     Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(File... files);
225 
226     /**
227      * Returns file objects representing the given paths.
228      * Convenience method equivalent to:
229      *
230      * &lt;pre&gt;
231      *     getJavaFileObjectsFromPaths({@linkplain java.util.Arrays#asList Arrays.asList}(paths))
232      * &lt;/pre&gt;
233      *
234      * @param paths an array of paths
235      * @return a list of file objects
236      * @throws IllegalArgumentException if the array of files includes
237      * a directory
238      * @throws NullPointerException if the given array contains null
239      * elements
240      *
241      * @since 9
242      */
243     default Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(Path... paths) {
244         return getJavaFileObjectsFromPaths(Arrays.asList(paths));
245     }
246 
247     /**
248      * Returns file objects representing the given file names.
249      *
250      * @param names a list of file names
251      * @return a list of file objects
252      * @throws IllegalArgumentException if the list of file names
253      * includes a directory
254      */
255     Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromStrings(
256         Iterable&lt;String&gt; names);
257 
258     /**
259      * Returns file objects representing the given file names.
260      * Convenience method equivalent to:
261      *
262      * &lt;pre&gt;
263      *     getJavaFileObjectsFromStrings({@linkplain java.util.Arrays#asList Arrays.asList}(names))
264      * &lt;/pre&gt;
265      *
266      * @param names a list of file names
267      * @return a list of file objects
268      * @throws IllegalArgumentException if the array of file names
269      * includes a directory
270      * @throws NullPointerException if the given array contains null
271      * elements
272      */
273     Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(String... names);
274 
275     /**
276      * Associates the given search path with the given location.  Any
277      * previous value will be discarded.
278      *
279      * If the location is a module-oriented or output location, any module-specific
280      * associations set up by {@linkplain #setLocationForModule setLocationForModule}
281      * will be cancelled.
282      *
283      * @param location a location
284      * @param files a list of files, if {@code null} use the default
285      * search path for this location
286      * @see #getLocation
287      * @throws IllegalArgumentException if {@code location} is an output
288      * location and {@code files} does not contain exactly one element
289      * @throws IOException if {@code location} is an output location and
290      * does not represent an existing directory
291      */
292     void setLocation(Location location, Iterable&lt;? extends File&gt; files)
293         throws IOException;
294 
295     /**
296      * Associates the given search path with the given location.
297      * Any previous value will be discarded.
298      *
299      * If the location is a module-oriented or output location, any module-specific
300      * associations set up by {@linkplain #setLocationForModule setLocationForModule}
301      * will be cancelled.
302      *
303      * @implSpec
304      * The default implementation converts each path to a file and calls
305      * {@link #getJavaFileObjectsFromFiles getJavaObjectsFromFiles}.
306      * {@linkplain IllegalArgumentException IllegalArgumentException}
307      * will be thrown if any of the paths cannot be converted to a file.
308      *
309      * @param location a location
310      * @param paths a list of paths, if {@code null} use the default
311      * search path for this location
312      * @see #getLocation
313      * @throws IllegalArgumentException if {@code location} is an output
314      * location and {@code paths} does not contain exactly one element
315      * or if this file manager does not support any of the given paths
316      * @throws IOException if {@code location} is an output location and
317      * {@code paths} does not represent an existing directory
318      *
319      * @since 9
320      */
321     default void setLocationFromPaths(Location location, Collection&lt;? extends Path&gt; paths)
322             throws IOException {
323         setLocation(location, asFiles(paths));
324     }
325 
326     /**
327      * Associates the given search path with the given module and location,
328      * which must be a module-oriented or output location.
329      * Any previous value will be discarded.
330      * This overrides any default association derived from the search path
331      * associated with the location itself.
332      *
333      * All such module-specific associations will be cancelled if a
334      * new search path is associated with the location by calling
335      * {@linkplain #setLocation setLocation } or
336      * {@linkplain #setLocationFromPaths setLocationFromPaths}.
337      *
338      * @throws IllegalStateException if the location is not a module-oriented
339      *  or output location.
340      * @throws UnsupportedOperationException if this operation is not supported by
341      *  this file manager.
342      * @throws IOException if {@code location} is an output location and
343      * {@code paths} does not represent an existing directory
344      *
345      * @param location the location
346      * @param moduleName the name of the module
347      * @param paths the search path to associate with the location and module.
348      *
349      * @see setLocation
350      * @see setLocationFromPaths
351      *
352      * @since 9
353      */
354     default void setLocationForModule(Location location, String moduleName,
355             Collection&lt;? extends Path&gt; paths) throws IOException {
356         throw new UnsupportedOperationException();
357     }
358 
359     /**
360      * Returns the search path associated with the given location.
361      *
362      * @param location a location
363      * @return a list of files or {@code null} if this location has no
364      * associated search path
365      * @throws IllegalStateException if any element of the search path
366      * cannot be converted to a {@linkplain File}, or if the search path
367      * cannot be represented as a simple series of files.
368      *
369      * @see #setLocation
370      * @see Path#toFile
371      */
372     Iterable&lt;? extends File&gt; getLocation(Location location);
373 
374     /**
375      * Returns the search path associated with the given location.
376      *
377      * @implSpec
378      * The default implementation calls {@link #getLocation getLocation}
379      * and then returns an {@code Iterable} formed by calling {@code toPath()}
380      * on each {@code File} returned from {@code getLocation}.
381      *
382      * @param location a location
383      * @return a list of paths or {@code null} if this location has no
384      * associated search path
385      * @throws IllegalStateException if the search path cannot be represented
386      * as a simple series of paths.
387      *
388      * @see #setLocationFromPaths
389      * @since 9
390      */
391     default Iterable&lt;? extends Path&gt; getLocationAsPaths(Location location) {
392         return asPaths(getLocation(location));
393     }
394 
395     /**
396      * Returns the path, if any, underlying this file object (optional operation).
397      * File objects derived from a {@link java.nio.file.FileSystem FileSystem},
398      * including the default file system, typically have a corresponding underlying
399      * {@link java.nio.file.Path Path} object. In such cases, this method may be
400      * used to access that object.
401      *
402      * @implSpec
403      * The default implementation throws {@link UnsupportedOperationException}
404      * for all files.
405      *
406      * @param file a file object
407      * @return a path representing the same underlying file system artifact
408      * @throws IllegalArgumentException if the file object does not have an underlying path
409      * @throws UnsupportedOperationException if the operation is not supported by this file manager
410      *
411      * @since 9
412      */
413     default Path asPath(FileObject file) {
414         throw new UnsupportedOperationException();
415     }
416 
417     /**
418      * Factory to create {@code Path} objects from strings.
419      *
420      * @since 9
421      */
422     interface PathFactory {
423         /**
424          * Converts a path string, or a sequence of strings that when joined form a path string, to a Path.
425          *
426          * @param first  the path string or initial part of the path string
427          * @param more   additional strings to be joined to form the path string
428          * @return       the resulting {@code Path}
429          */
430         Path getPath(String first, String... more);
431     }
432 
433      /**
434       * Specify a factory that can be used to generate a path from a string, or series of strings.
435       *
436       * If this method is not called, a factory whose {@code getPath} method is
437       * equivalent to calling
438       * {@link java.nio.file.Paths#get(String, String...) java.nio.file.Paths.get(first, more)}
439       * will be used.
440       *
441       * @implSpec
442       * The default implementation of this method ignores the factory that is provided.
443       *
444       * @param f  the factory
445       *
446       * @since 9
447       */
448     default void setPathFactory(PathFactory f) { }
449 
450 
451     private static Iterable&lt;Path&gt; asPaths(final Iterable&lt;? extends File&gt; files) {
452         return () -&gt; new Iterator&lt;Path&gt;() {
453             Iterator&lt;? extends File&gt; iter = files.iterator();
454 
455             @Override
456             public boolean hasNext() {
457                 return iter.hasNext();
458             }
459 
460             @Override
461             public Path next() {
462                 return iter.next().toPath();
463             }
464         };
465     }
466 
467     private static Iterable&lt;File&gt; asFiles(final Iterable&lt;? extends Path&gt; paths) {
468         return () -&gt; new Iterator&lt;File&gt;() {
469             Iterator&lt;? extends Path&gt; iter = paths.iterator();
470 
471             @Override
472             public boolean hasNext() {
473                 return iter.hasNext();
474             }
475 
476             @Override
477             public File next() {
478                 Path p = iter.next();
479                 try {
480                     return p.toFile();
481                 } catch (UnsupportedOperationException e) {
482                     throw new IllegalArgumentException(p.toString(), e);
483                 }
484             }
485         };
486     }
<a name="7" id="anc7"></a>








487 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
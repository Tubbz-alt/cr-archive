<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.compiler/share/classes/javax/lang/model/util/ElementFilter.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.lang.model.util;
 27 
 28 import java.util.Collections;
 29 import java.util.List;
 30 import java.util.Set;
 31 import java.util.EnumSet;
 32 import java.util.ArrayList;
 33 import java.util.LinkedHashSet;
 34 
 35 import javax.lang.model.element.*;
 36 import javax.lang.model.element.ModuleElement.Directive;
 37 import javax.lang.model.element.ModuleElement.DirectiveKind;
 38 import javax.lang.model.element.ModuleElement.ExportsDirective;
 39 import javax.lang.model.element.ModuleElement.OpensDirective;
 40 import javax.lang.model.element.ModuleElement.ProvidesDirective;
 41 import javax.lang.model.element.ModuleElement.RequiresDirective;
 42 import javax.lang.model.element.ModuleElement.UsesDirective;
 43 
 44 
 45 /**
 46  * Filters for selecting just the elements of interest from a
 47  * collection of elements.  The returned sets and lists are new
 48  * collections and do use the argument as a backing store.  The
 49  * methods in this class do not make any attempts to guard against
 50  * concurrent modifications of the arguments.  The returned sets and
 51  * lists are mutable but unsafe for concurrent access.  A returned set
 52  * has the same iteration order as the argument set to a method.
 53  *
 54  * &lt;p&gt;If iterables and sets containing {@code null} are passed as
 55  * arguments to methods in this class, a {@code NullPointerException}
 56  * will be thrown.
 57  *
 58  * @author Joseph D. Darcy
 59  * @author Scott Seligman
 60  * @author Peter von der Ah&amp;eacute;
 61  * @author Martin Buchholz
 62  * @since 1.6
 63  */
 64 public class ElementFilter {
 65     private ElementFilter() {} // Do not instantiate.
 66 
 67     private static final Set&lt;ElementKind&gt; CONSTRUCTOR_KIND =
 68         Collections.unmodifiableSet(EnumSet.of(ElementKind.CONSTRUCTOR));
 69 
 70     private static final Set&lt;ElementKind&gt; FIELD_KINDS =
 71         Collections.unmodifiableSet(EnumSet.of(ElementKind.FIELD,
 72                                                ElementKind.ENUM_CONSTANT));
 73     private static final Set&lt;ElementKind&gt; METHOD_KIND =
 74         Collections.unmodifiableSet(EnumSet.of(ElementKind.METHOD));
 75 
 76     private static final Set&lt;ElementKind&gt; PACKAGE_KIND =
 77         Collections.unmodifiableSet(EnumSet.of(ElementKind.PACKAGE));
 78 
 79     private static final Set&lt;ElementKind&gt; MODULE_KIND =
 80         Collections.unmodifiableSet(EnumSet.of(ElementKind.MODULE));
 81 
 82     private static final Set&lt;ElementKind&gt; TYPE_KINDS =
 83         Collections.unmodifiableSet(EnumSet.of(ElementKind.CLASS,
 84                                                ElementKind.ENUM,
 85                                                ElementKind.INTERFACE,
 86                                                ElementKind.ANNOTATION_TYPE));
 87     /**
 88      * Returns a list of fields in {@code elements}.
 89      * @return a list of fields in {@code elements}
 90      * @param elements the elements to filter
 91      */
 92     public static List&lt;VariableElement&gt;
 93             fieldsIn(Iterable&lt;? extends Element&gt; elements) {
 94         return listFilter(elements, FIELD_KINDS, VariableElement.class);
 95     }
 96 
 97     /**
 98      * Returns a set of fields in {@code elements}.
 99      * @return a set of fields in {@code elements}
100      * @param elements the elements to filter
101      */
102     public static Set&lt;VariableElement&gt;
103             fieldsIn(Set&lt;? extends Element&gt; elements) {
104         return setFilter(elements, FIELD_KINDS, VariableElement.class);
105     }
106 
107     /**
108      * Returns a list of constructors in {@code elements}.
109      * @return a list of constructors in {@code elements}
110      * @param elements the elements to filter
111      */
112     public static List&lt;ExecutableElement&gt;
113             constructorsIn(Iterable&lt;? extends Element&gt; elements) {
114         return listFilter(elements, CONSTRUCTOR_KIND, ExecutableElement.class);
115     }
116 
117     /**
118      * Returns a set of constructors in {@code elements}.
119      * @return a set of constructors in {@code elements}
120      * @param elements the elements to filter
121      */
122     public static Set&lt;ExecutableElement&gt;
123             constructorsIn(Set&lt;? extends Element&gt; elements) {
124         return setFilter(elements, CONSTRUCTOR_KIND, ExecutableElement.class);
125     }
126 
127     /**
128      * Returns a list of methods in {@code elements}.
129      * @return a list of methods in {@code elements}
130      * @param elements the elements to filter
131      */
132     public static List&lt;ExecutableElement&gt;
133             methodsIn(Iterable&lt;? extends Element&gt; elements) {
134         return listFilter(elements, METHOD_KIND, ExecutableElement.class);
135     }
136 
137     /**
138      * Returns a set of methods in {@code elements}.
139      * @return a set of methods in {@code elements}
140      * @param elements the elements to filter
141      */
142     public static Set&lt;ExecutableElement&gt;
143             methodsIn(Set&lt;? extends Element&gt; elements) {
144         return setFilter(elements, METHOD_KIND, ExecutableElement.class);
145     }
146 
147     /**
148      * Returns a list of types in {@code elements}.
149      * @return a list of types in {@code elements}
150      * @param elements the elements to filter
151      */
152     public static List&lt;TypeElement&gt;
153             typesIn(Iterable&lt;? extends Element&gt; elements) {
154         return listFilter(elements, TYPE_KINDS, TypeElement.class);
155     }
156 
157     /**
158      * Returns a set of types in {@code elements}.
159      * @return a set of types in {@code elements}
160      * @param elements the elements to filter
161      */
162     public static Set&lt;TypeElement&gt;
163             typesIn(Set&lt;? extends Element&gt; elements) {
164         return setFilter(elements, TYPE_KINDS, TypeElement.class);
165     }
166 
167     /**
168      * Returns a list of packages in {@code elements}.
169      * @return a list of packages in {@code elements}
170      * @param elements the elements to filter
171      */
172     public static List&lt;PackageElement&gt;
173             packagesIn(Iterable&lt;? extends Element&gt; elements) {
174         return listFilter(elements, PACKAGE_KIND, PackageElement.class);
175     }
176 
177     /**
178      * Returns a set of packages in {@code elements}.
179      * @return a set of packages in {@code elements}
180      * @param elements the elements to filter
181      */
182     public static Set&lt;PackageElement&gt;
183             packagesIn(Set&lt;? extends Element&gt; elements) {
184         return setFilter(elements, PACKAGE_KIND, PackageElement.class);
185     }
186 
187     /**
188      * Returns a list of modules in {@code elements}.
189      * @return a list of modules in {@code elements}
190      * @param elements the elements to filter
191      * @since 9
192      * @spec JPMS
193      */
194     public static List&lt;ModuleElement&gt;
195             modulesIn(Iterable&lt;? extends Element&gt; elements) {
196         return listFilter(elements, MODULE_KIND, ModuleElement.class);
197     }
198 
199     /**
200      * Returns a set of modules in {@code elements}.
201      * @return a set of modules in {@code elements}
202      * @param elements the elements to filter
203      * @since 9
204      * @spec JPMS
205      */
206     public static Set&lt;ModuleElement&gt;
207             modulesIn(Set&lt;? extends Element&gt; elements) {
208         return setFilter(elements, MODULE_KIND, ModuleElement.class);
209     }
210 
211     // Assumes targetKinds and E are sensible.
212     private static &lt;E extends Element&gt; List&lt;E&gt; listFilter(Iterable&lt;? extends Element&gt; elements,
213                                                           Set&lt;ElementKind&gt; targetKinds,
214                                                           Class&lt;E&gt; clazz) {
215         List&lt;E&gt; list = new ArrayList&lt;&gt;();
216         for (Element e : elements) {
217             if (targetKinds.contains(e.getKind()))
218                 list.add(clazz.cast(e));
219         }
220         return list;
221     }
222 
223     // Assumes targetKinds and E are sensible.
224     private static &lt;E extends Element&gt; Set&lt;E&gt; setFilter(Set&lt;? extends Element&gt; elements,
225                                                         Set&lt;ElementKind&gt; targetKinds,
226                                                         Class&lt;E&gt; clazz) {
227         // Return set preserving iteration order of input set.
228         Set&lt;E&gt; set = new LinkedHashSet&lt;&gt;();
229         for (Element e : elements) {
230             if (targetKinds.contains(e.getKind()))
231                 set.add(clazz.cast(e));
232         }
233         return set;
234     }
235 
236     /**
237      * Returns a list of {@code exports} directives in {@code directives}.
238      * @return a list of {@code exports} directives in {@code directives}
239      * @param directives the directives to filter
240      * @since 9
241      * @spec JPMS
242      */
243     public static List&lt;ExportsDirective&gt;
244             exportsIn(Iterable&lt;? extends Directive&gt; directives) {
245         return listFilter(directives, DirectiveKind.EXPORTS, ExportsDirective.class);
246     }
247 
248     /**
249      * Returns a list of {@code opens} directives in {@code directives}.
250      * @return a list of {@code opens} directives in {@code directives}
251      * @param directives the directives to filter
252      * @since 9
253      */
254     public static List&lt;OpensDirective&gt;
255             opensIn(Iterable&lt;? extends Directive&gt; directives) {
256         return listFilter(directives, DirectiveKind.OPENS, OpensDirective.class);
257     }
258 
259     /**
260      * Returns a list of {@code provides} directives in {@code directives}.
261      * @return a list of {@code provides} directives in {@code directives}
262      * @param directives the directives to filter
263      * @since 9
264      * @spec JPMS
265      */
266     public static List&lt;ProvidesDirective&gt;
267             providesIn(Iterable&lt;? extends Directive&gt; directives) {
268         return listFilter(directives, DirectiveKind.PROVIDES, ProvidesDirective.class);
269     }
270 
271     /**
272      * Returns a list of {@code requires} directives in {@code directives}.
273      * @return a list of {@code requires} directives in {@code directives}
274      * @param directives the directives to filter
275      * @since 9
276      * @spec JPMS
277      */
278     public static List&lt;RequiresDirective&gt;
279             requiresIn(Iterable&lt;? extends Directive&gt; directives) {
280         return listFilter(directives, DirectiveKind.REQUIRES, RequiresDirective.class);
281     }
282 
283     /**
284      * Returns a list of {@code uses} directives in {@code directives}.
285      * @return a list of {@code uses} directives in {@code directives}
286      * @param directives the directives to filter
287      * @since 9
288      * @spec JPMS
289      */
290     public static List&lt;UsesDirective&gt;
291             usesIn(Iterable&lt;? extends Directive&gt; directives) {
292         return listFilter(directives, DirectiveKind.USES, UsesDirective.class);
293     }
294 
295     // Assumes directiveKind and D are sensible.
296     private static &lt;D extends Directive&gt; List&lt;D&gt; listFilter(Iterable&lt;? extends Directive&gt; directives,
297                                                           DirectiveKind directiveKind,
298                                                           Class&lt;D&gt; clazz) {
299         List&lt;D&gt; list = new ArrayList&lt;&gt;();
300         for (Directive d : directives) {
301             if (d.getKind() == directiveKind)
302                 list.add(clazz.cast(d));
303         }
304         return list;
305     }
306 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.compiler/share/classes/javax/lang/model/util/Elements.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.lang.model.util;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Collections;
 30 import java.util.List;
 31 import java.util.Map;
 32 import java.util.Set;
 33 import java.util.LinkedHashSet;
<a name="1" id="anc1"></a>
 34 
 35 import javax.lang.model.AnnotatedConstruct;
 36 import javax.lang.model.element.*;
 37 
 38 
 39 /**
 40  * Utility methods for operating on program elements.
 41  *
 42  * &lt;p&gt;&lt;b&gt;Compatibility Note:&lt;/b&gt; Methods may be added to this interface
 43  * in future releases of the platform.
 44  *
 45  * @author Joseph D. Darcy
 46  * @author Scott Seligman
 47  * @author Peter von der Ah&amp;eacute;
 48  * @see javax.annotation.processing.ProcessingEnvironment#getElementUtils
 49  * @since 1.6
 50  */
 51 public interface Elements {
 52 
 53     /**
 54      * Returns a package given its fully qualified name if the package is unique in the environment.
 55      * If running with modules, all modules in the modules graph are searched for matching packages.
 56      *
 57      * @param name  fully qualified package name, or an empty string for an unnamed package
 58      * @return the specified package, or {@code null} if it cannot be uniquely found
 59      */
 60     PackageElement getPackageElement(CharSequence name);
 61 
 62     /**
 63      * Returns a package given its fully qualified name, as seen from the given module.
 64      *
 65      * @implSpec The default implementation of this method returns
 66      * {@code null}.
 67      *
 68      * @param name  fully qualified package name, or an empty string for an unnamed package
 69      * @param module module relative to which the lookup should happen
 70      * @return the specified package, or {@code null} if it cannot be found
 71      * @see #getAllPackageElements
 72      * @since 9
 73      */
 74     default PackageElement getPackageElement(ModuleElement module, CharSequence name) {
 75         return null;
 76     }
 77 
 78     /**
 79      * Returns all package elements with the given canonical name.
 80      *
 81      * There may be more than one package element with the same canonical
 82      * name if the package elements are in different modules.
 83      *
 84      * @implSpec The default implementation of this method calls
 85      * {@link #getAllModuleElements() getAllModuleElements} and stores
 86      * the result. If the set of modules is empty, {@link
 87      * #getPackageElement(CharSequence) getPackageElement(name)} is
 88      * called passing through the name argument. If {@code
 89      * getPackageElement(name)} is {@code null}, an empty set of
 90      * package elements is returned; otherwise, a single-element set
 91      * with the found package element is returned. If the set of
 92      * modules is nonempty, the modules are iterated over and any
 93      * non-{@code null} results of {@link
 94      * #getPackageElement(ModuleElement, CharSequence)
 95      * getPackageElement(module, name)} are accumulated into a
 96      * set. The set is then returned.
 97      *
 98      * @param name  the canonical name
 99      * @return the package elements, or an empty set if no package with the name can be found
100      * @see #getPackageElement(ModuleElement, CharSequence)
101      * @since 9
102      */
103     default Set&lt;? extends PackageElement&gt; getAllPackageElements(CharSequence name) {
104         Set&lt;? extends ModuleElement&gt; modules = getAllModuleElements();
105         if (modules.isEmpty()) {
106             PackageElement packageElt = getPackageElement(name);
107             return (packageElt != null) ?
108                 Collections.singleton(packageElt):
109                 Collections.emptySet();
110         } else {
111             Set&lt;PackageElement&gt; result = new LinkedHashSet&lt;&gt;(1); // Usually expect at most 1 result
112             for (ModuleElement module: modules) {
113                 PackageElement packageElt = getPackageElement(module, name);
114                 if (packageElt != null)
115                     result.add(packageElt);
116             }
117             return Collections.unmodifiableSet(result);
118         }
119     }
120 
121     /**
122      * Returns a type element given its canonical name if the type element is unique in the environment.
123      * If running with modules, all modules in the modules graph are searched for matching
124      * type elements.
125      *
126      * @param name  the canonical name
127      * @return the named type element, or {@code null} if it cannot be uniquely found
128      */
129     TypeElement getTypeElement(CharSequence name);
130 
131     /**
132      * Returns a type element given its canonical name, as seen from the given module.
133      *
134      * @implSpec The default implementation of this method returns
135      * {@code null}.
136      *
137      * @param name  the canonical name
138      * @param module module relative to which the lookup should happen
139      * @return the named type element, or {@code null} if it cannot be found
140      * @see #getAllTypeElements
141      * @since 9
142      */
143     default TypeElement getTypeElement(ModuleElement module, CharSequence name) {
144         return null;
145     }
146 
147     /**
148      * Returns all type elements with the given canonical name.
149      *
150      * There may be more than one type element with the same canonical
151      * name if the type elements are in different modules.
152      *
153      * @implSpec The default implementation of this method calls
154      * {@link #getAllModuleElements() getAllModuleElements} and stores
155      * the result. If the set of modules is empty, {@link
156      * #getTypeElement(CharSequence) getTypeElement(name)} is called
157      * passing through the name argument. If {@code
158      * getTypeElement(name)} is {@code null}, an empty set of type
159      * elements is returned; otherwise, a single-element set with the
160      * found type element is returned. If the set of modules is
161      * nonempty, the modules are iterated over and any non-{@code null}
162      * results of {@link #getTypeElement(ModuleElement,
163      * CharSequence) getTypeElement(module, name)} are accumulated
164      * into a set. The set is then returned.
165      *
166      * @param name  the canonical name
167      * @return the type elements, or an empty set if no type with the name can be found
168      * @see #getTypeElement(ModuleElement, CharSequence)
169      * @since 9
170      */
171     default Set&lt;? extends TypeElement&gt; getAllTypeElements(CharSequence name) {
172         Set&lt;? extends ModuleElement&gt; modules = getAllModuleElements();
173         if (modules.isEmpty()) {
174             TypeElement typeElt = getTypeElement(name);
175             return (typeElt != null) ?
176                 Collections.singleton(typeElt):
177                 Collections.emptySet();
178         } else {
179             Set&lt;TypeElement&gt; result = new LinkedHashSet&lt;&gt;(1); // Usually expect at most 1 result
180             for (ModuleElement module: modules) {
181                 TypeElement typeElt = getTypeElement(module, name);
182                 if (typeElt != null)
183                     result.add(typeElt);
184             }
185             return Collections.unmodifiableSet(result);
186         }
187     }
188 
189     /**
190      * Returns a module element given its fully qualified name.
191      *
192      * If the requested module cannot be found, {@code null} is
193      * returned. One situation where a module cannot be found is if
194      * the environment does not include modules, such as an annotation
195      * processing environment configured for a {@linkplain
196      * javax.annotation.processing.ProcessingEnvironment#getSourceVersion
197      * source version} without modules.
198      *
199      * @implSpec The default implementation of this method returns
200      * {@code null}.
201      *
202      * @param name  the name, or an empty string for an unnamed module
203      * @return the named module element, or {@code null} if it cannot be found
204      * @see #getAllModuleElements
205      * @since 9
206      * @spec JPMS
207      */
208     default ModuleElement getModuleElement(CharSequence name) {
209         return null;
210     }
211 
212     /**
213      * Returns all module elements in the current environment.
214      *
215      * If no modules are present, an empty set is returned. One
216      * situation where no modules are present occurs when the
217      * environment does not include modules, such as an annotation
218      * processing environment configured for a {@linkplain
219      * javax.annotation.processing.ProcessingEnvironment#getSourceVersion
220      * source version} without modules.
221      *
222      * @implSpec The default implementation of this method returns
223      * an empty set.
224      *
225      * @return the known module elements, or an empty set if there are no modules
226      * @see #getModuleElement(CharSequence)
227      * @since 9
228      */
229     default Set&lt;? extends ModuleElement&gt; getAllModuleElements() {
230         return Collections.emptySet();
231     }
232 
233     /**
234      * Returns the values of an annotation&#39;s elements, including defaults.
235      *
236      * @see AnnotationMirror#getElementValues()
237      * @param a  annotation to examine
238      * @return the values of the annotation&#39;s elements, including defaults
239      */
240     Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt;
241             getElementValuesWithDefaults(AnnotationMirror a);
242 
243     /**
244      * Returns the text of the documentation (&amp;quot;Javadoc&amp;quot;)
245      * comment of an element.
246      *
247      * &lt;p&gt; A documentation comment of an element is a comment that
248      * begins with &quot;{@code /**}&quot; , ends with a separate
249      * &quot;&lt;code&gt;*&amp;#47;&lt;/code&gt;&quot;, and immediately precedes the element,
250      * ignoring white space.  Therefore, a documentation comment
251      * contains at least three&quot;{@code *}&quot; characters.  The text
252      * returned for the documentation comment is a processed form of
253      * the comment as it appears in source code.  The leading &quot;{@code
254      * /**}&quot; and trailing &quot;&lt;code&gt;*&amp;#47;&lt;/code&gt;&quot; are removed.  For lines
255      * of the comment starting after the initial &quot;{@code /**}&quot;,
256      * leading white space characters are discarded as are any
257      * consecutive &quot;{@code *}&quot; characters appearing after the white
258      * space or starting the line.  The processed lines are then
259      * concatenated together (including line terminators) and
260      * returned.
261      *
262      * @param e  the element being examined
263      * @return the documentation comment of the element, or {@code null}
264      *          if there is none
265      * @jls 3.6 White Space
266      */
267     String getDocComment(Element e);
268 
269     /**
270      * Returns {@code true} if the element is deprecated, {@code false} otherwise.
271      *
272      * @param e  the element being examined
273      * @return {@code true} if the element is deprecated, {@code false} otherwise
274      */
275     boolean isDeprecated(Element e);
276 
277     /**
278      * Returns the &lt;em&gt;origin&lt;/em&gt; of the given element.
279      *
280      * &lt;p&gt;Note that if this method returns {@link Origin#EXPLICIT
281      * EXPLICIT} and the element was created from a class file, then
282      * the element may not, in fact, correspond to an explicitly
283      * declared construct in source code. This is due to limitations
284      * of the fidelity of the class file format in preserving
285      * information from source code. For example, at least some
286      * versions of the class file format do not preserve whether a
287      * constructor was explicitly declared by the programmer or was
288      * implicitly declared as the &lt;em&gt;default constructor&lt;/em&gt;.
289      *
290      * @implSpec The default implementation of this method returns
291      * {@link Origin#EXPLICIT EXPLICIT}.
292      *
293      * @param e  the element being examined
294      * @return the origin of the given element
295      * @since 9
296      */
297     default Origin getOrigin(Element e) {
298         return Origin.EXPLICIT;
299     }
300 
301     /**
302      * Returns the &lt;em&gt;origin&lt;/em&gt; of the given annotation mirror.
303      *
304      * An annotation mirror is {@linkplain Origin#MANDATED mandated}
305      * if it is an implicitly declared &lt;em&gt;container annotation&lt;/em&gt;
306      * used to hold repeated annotations of a repeatable annotation
307      * type.
308      *
309      * &lt;p&gt;Note that if this method returns {@link Origin#EXPLICIT
310      * EXPLICIT} and the annotation mirror was created from a class
311      * file, then the element may not, in fact, correspond to an
312      * explicitly declared construct in source code. This is due to
313      * limitations of the fidelity of the class file format in
314      * preserving information from source code. For example, at least
315      * some versions of the class file format do not preserve whether
316      * an annotation was explicitly declared by the programmer or was
317      * implicitly declared as a &lt;em&gt;container annotation&lt;/em&gt;.
318      *
319      * @implSpec The default implementation of this method returns
320      * {@link Origin#EXPLICIT EXPLICIT}.
321      *
322      * @param c the construct the annotation mirror modifies
323      * @param a the annotation mirror being examined
324      * @return the origin of the given annotation mirror
325      * @jls 9.6.3 Repeatable Annotation Types
326      * @jls 9.7.5 Multiple Annotations of the Same Type
327      * @since 9
328      */
329     default Origin getOrigin(AnnotatedConstruct c,
330                              AnnotationMirror a) {
331         return Origin.EXPLICIT;
332     }
333 
334     /**
335      * Returns the &lt;em&gt;origin&lt;/em&gt; of the given module directive.
336      *
337      * &lt;p&gt;Note that if this method returns {@link Origin#EXPLICIT
338      * EXPLICIT} and the module directive was created from a class
339      * file, then the module directive may not, in fact, correspond to
340      * an explicitly declared construct in source code. This is due to
341      * limitations of the fidelity of the class file format in
342      * preserving information from source code. For example, at least
343      * some versions of the class file format do not preserve whether
344      * a {@code uses} directive was explicitly declared by the
345      * programmer or was added as a synthetic construct.
346      *
347      * &lt;p&gt;Note that an implementation may not be able to reliably
348      * determine the origin status of the directive if the directive
349      * is created from a class file due to limitations of the fidelity
350      * of the class file format in preserving information from source
351      * code.
352      *
353      * @implSpec The default implementation of this method returns
354      * {@link Origin#EXPLICIT EXPLICIT}.
355      *
356      * @param m the module of the directive
357      * @param directive  the module directive being examined
358      * @return the origin of the given directive
359      * @since 9
360      */
361     default Origin getOrigin(ModuleElement m,
362                              ModuleElement.Directive directive) {
363         return Origin.EXPLICIT;
364     }
365 
366     /**
367      * The &lt;em&gt;origin&lt;/em&gt; of an element or other language model
368      * item. The origin of an element or item models how a construct
369      * in a program is declared in the source code, explicitly,
370      * implicitly, etc.
371      *
372      * &lt;p&gt;Note that it is possible additional kinds of origin values
373      * will be added in future versions of the platform.
374      *
375      * @jls 13.1 The Form of a Binary
376      * @since 9
377      */
378     public enum Origin {
379         /**
380          * Describes a construct explicitly declared in source code.
381          */
382         EXPLICIT,
383 
384        /**
385          * A mandated construct is one that is not explicitly declared
386          * in the source code, but whose presence is mandated by the
387          * specification. Such a construct is said to be implicitly
388          * declared.
389          *
390          * One example of a mandated element is a &lt;em&gt;default
391          * constructor&lt;/em&gt; in a class that contains no explicit
392          * constructor declarations.
393          *
394          * Another example of a mandated construct is an implicitly
395          * declared &lt;em&gt;container annotation&lt;/em&gt; used to hold
396          * multiple annotations of a repeatable annotation type.
397          *
398          * @jls 8.8.9 Default Constructor
399          * @jls 8.9.3 Enum Members
400          * @jls 9.6.3 Repeatable Annotation Types
401          * @jls 9.7.5 Multiple Annotations of the Same Type
402          */
403         MANDATED,
404 
405        /**
406          * A synthetic construct is one that is neither implicitly nor
407          * explicitly declared in the source code. Such a construct is
408          * typically a translation artifact created by a compiler.
409          */
410         SYNTHETIC;
411 
412         /**
413          * Returns {@code true} for values corresponding to constructs
414          * that are implicitly or explicitly declared, {@code false}
415          * otherwise.
416          * @return {@code true} for {@link EXPLICIT} and {@link
417          * MANDATED}, {@code false} otherwise.
418          */
419         public boolean isDeclared() {
420             return this != SYNTHETIC;
421         }
422     }
423 
424     /**
425      * Returns {@code true} if the executable element is a bridge
426      * method, {@code false} otherwise.
427      *
428      * @implSpec The default implementation of this method returns {@code false}.
429      *
430      * @param e  the executable being examined
431      * @return {@code true} if the executable element is a bridge
432      * method, {@code false} otherwise
433      * @since 9
434      */
435     default boolean isBridge(ExecutableElement e) {
436         return false;
437     }
438 
439     /**
440      * Returns the &lt;i&gt;binary name&lt;/i&gt; of a type element.
441      *
442      * @param type  the type element being examined
443      * @return the binary name
444      *
445      * @see TypeElement#getQualifiedName
446      * @jls 13.1 The Form of a Binary
447      */
448     Name getBinaryName(TypeElement type);
449 
450 
451     /**
452      * Returns the package of an element.  The package of a package is
453      * itself.
454      * The package of a module is {@code null}.
455      *
<a name="2" id="anc2"></a><span class="line-modified">456      * @param type the element being examined</span>





457      * @return the package of an element
458      */
<a name="3" id="anc3"></a><span class="line-modified">459     PackageElement getPackageOf(Element type);</span>
460 
461     /**
462      * Returns the module of an element.  The module of a module is
463      * itself.
<a name="4" id="anc4"></a><span class="line-modified">464      * If there is no module for the element, null is returned. One situation where there is</span>
<span class="line-modified">465      * no module for an element is if the environment does not include modules, such as</span>
<span class="line-modified">466      * an annotation processing environment configured for</span>
<span class="line-modified">467      * a {@linkplain</span>






468      * javax.annotation.processing.ProcessingEnvironment#getSourceVersion
<a name="5" id="anc5"></a><span class="line-modified">469      * source version} without modules.</span>




470      *
471      * @implSpec The default implementation of this method returns
472      * {@code null}.
473      *
<a name="6" id="anc6"></a><span class="line-modified">474      * @param type the element being examined</span>
475      * @return the module of an element
476      * @since 9
477      * @spec JPMS
478      */
<a name="7" id="anc7"></a><span class="line-modified">479     default ModuleElement getModuleOf(Element type) {</span>
480         return null;
481     }
482 
483     /**
484      * Returns all members of a type element, whether inherited or
485      * declared directly.  For a class the result also includes its
486      * constructors, but not local or anonymous classes.
487      *
488      * @apiNote Elements of certain kinds can be isolated using
489      * methods in {@link ElementFilter}.
490      *
491      * @param type  the type being examined
492      * @return all members of the type
493      * @see Element#getEnclosedElements
494      */
495     List&lt;? extends Element&gt; getAllMembers(TypeElement type);
496 
497     /**
498      * Returns all annotations &lt;i&gt;present&lt;/i&gt; on an element, whether
499      * directly present or present via inheritance.
500      *
501      * @param e  the element being examined
502      * @return all annotations of the element
503      * @see Element#getAnnotationMirrors
504      * @see javax.lang.model.AnnotatedConstruct
505      */
506     List&lt;? extends AnnotationMirror&gt; getAllAnnotationMirrors(Element e);
507 
508     /**
509      * Tests whether one type, method, or field hides another.
510      *
511      * @param hider   the first element
512      * @param hidden  the second element
513      * @return {@code true} if and only if the first element hides
514      *          the second
515      * @jls 8.4.8 Inheritance, Overriding, and Hiding
516      */
517     boolean hides(Element hider, Element hidden);
518 
519     /**
520      * Tests whether one method, as a member of a given type,
521      * overrides another method.
522      * When a non-abstract method overrides an abstract one, the
523      * former is also said to &lt;i&gt;implement&lt;/i&gt; the latter.
524      *
525      * &lt;p&gt; In the simplest and most typical usage, the value of the
526      * {@code type} parameter will simply be the class or interface
527      * directly enclosing {@code overrider} (the possibly-overriding
528      * method).  For example, suppose {@code m1} represents the method
529      * {@code String.hashCode} and {@code m2} represents {@code
530      * Object.hashCode}.  We can then ask whether {@code m1} overrides
531      * {@code m2} within the class {@code String} (it does):
532      *
533      * &lt;blockquote&gt;
534      * {@code assert elements.overrides(m1, m2,
535      *          elements.getTypeElement(&quot;java.lang.String&quot;)); }
536      * &lt;/blockquote&gt;
537      *
538      * A more interesting case can be illustrated by the following example
539      * in which a method in type {@code A} does not override a
540      * like-named method in type {@code B}:
541      *
542      * &lt;blockquote&gt;
543      * {@code class A { public void m() {} } }&lt;br&gt;
544      * {@code interface B { void m(); } }&lt;br&gt;
545      * ...&lt;br&gt;
546      * {@code m1 = ...;  // A.m }&lt;br&gt;
547      * {@code m2 = ...;  // B.m }&lt;br&gt;
548      * {@code assert ! elements.overrides(m1, m2,
549      *          elements.getTypeElement(&quot;A&quot;)); }
550      * &lt;/blockquote&gt;
551      *
552      * When viewed as a member of a third type {@code C}, however,
553      * the method in {@code A} does override the one in {@code B}:
554      *
555      * &lt;blockquote&gt;
556      * {@code class C extends A implements B {} }&lt;br&gt;
557      * ...&lt;br&gt;
558      * {@code assert elements.overrides(m1, m2,
559      *          elements.getTypeElement(&quot;C&quot;)); }
560      * &lt;/blockquote&gt;
561      *
562      * @param overrider  the first method, possible overrider
563      * @param overridden  the second method, possibly being overridden
564      * @param type   the type of which the first method is a member
565      * @return {@code true} if and only if the first method overrides
566      *          the second
567      * @jls 8.4.8 Inheritance, Overriding, and Hiding
568      * @jls 9.4.1 Inheritance and Overriding
569      */
570     boolean overrides(ExecutableElement overrider, ExecutableElement overridden,
571                       TypeElement type);
572 
573     /**
574      * Returns the text of a &lt;i&gt;constant expression&lt;/i&gt; representing a
575      * primitive value or a string.
576      * The text returned is in a form suitable for representing the value
577      * in source code.
578      *
579      * @param value  a primitive value or string
580      * @return the text of a constant expression
581      * @throws IllegalArgumentException if the argument is not a primitive
582      *          value or string
583      *
584      * @see VariableElement#getConstantValue()
585      */
586     String getConstantExpression(Object value);
587 
588     /**
589      * Prints a representation of the elements to the given writer in
590      * the specified order.  The main purpose of this method is for
591      * diagnostics.  The exact format of the output is &lt;em&gt;not&lt;/em&gt;
592      * specified and is subject to change.
593      *
594      * @param w the writer to print the output to
595      * @param elements the elements to print
596      */
597     void printElements(java.io.Writer w, Element... elements);
598 
599     /**
600      * Return a name with the same sequence of characters as the
601      * argument.
602      *
603      * @param cs the character sequence to return as a name
604      * @return a name with the same sequence of characters as the argument
605      */
606     Name getName(CharSequence cs);
607 
608     /**
609      * Returns {@code true} if the type element is a functional interface, {@code false} otherwise.
610      *
611      * @param type the type element being examined
612      * @return {@code true} if the element is a functional interface, {@code false} otherwise
613      * @jls 9.8 Functional Interfaces
614      * @since 1.8
615      */
616     boolean isFunctionalInterface(TypeElement type);
<a name="8" id="anc8"></a>





































617 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
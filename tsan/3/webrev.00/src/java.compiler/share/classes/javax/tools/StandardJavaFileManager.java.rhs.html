<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.compiler/share/classes/javax/tools/StandardJavaFileManager.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.tools;
 27 
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.nio.file.Path;
<a name="1" id="anc1"></a><span class="line-added"> 31 import java.util.ArrayList;</span>
 32 import java.util.Arrays;
 33 import java.util.Collection;
 34 import java.util.Iterator;
<a name="2" id="anc2"></a><span class="line-added"> 35 import java.util.List;</span>
 36 
 37 /**
 38  * File manager based on {@linkplain File java.io.File} and {@linkplain Path java.nio.file.Path}.
 39  *
 40  * A common way to obtain an instance of this class is using
 41  * {@linkplain JavaCompiler#getStandardFileManager getStandardFileManager}, for example:
 42  *
 43  * &lt;pre&gt;
 44  *   JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
 45  *   {@code DiagnosticCollector&lt;JavaFileObject&gt;} diagnostics =
 46  *       new {@code DiagnosticCollector&lt;JavaFileObject&gt;()};
 47  *   StandardJavaFileManager fm = compiler.getStandardFileManager(diagnostics, null, null);
 48  * &lt;/pre&gt;
 49  *
 50  * This file manager creates file objects representing regular
 51  * {@linkplain File files},
 52  * {@linkplain java.util.zip.ZipEntry zip file entries}, or entries in
 53  * similar file system based containers.  Any file object returned
 54  * from a file manager implementing this interface must observe the
 55  * following behavior:
 56  *
 57  * &lt;ul&gt;
 58  *   &lt;li&gt;
 59  *     File names need not be canonical.
 60  *   &lt;/li&gt;
 61  *   &lt;li&gt;
 62  *     For file objects representing regular files
 63  *     &lt;ul&gt;
 64  *       &lt;li&gt;
 65  *         the method &lt;code&gt;{@linkplain FileObject#delete()}&lt;/code&gt;
 66  *         is equivalent to &lt;code&gt;{@linkplain File#delete()}&lt;/code&gt;,
 67  *       &lt;/li&gt;
 68  *       &lt;li&gt;
 69  *         the method &lt;code&gt;{@linkplain FileObject#getLastModified()}&lt;/code&gt;
 70  *         is equivalent to &lt;code&gt;{@linkplain File#lastModified()}&lt;/code&gt;,
 71  *       &lt;/li&gt;
 72  *       &lt;li&gt;
 73  *         the methods &lt;code&gt;{@linkplain FileObject#getCharContent(boolean)}&lt;/code&gt;,
 74  *         &lt;code&gt;{@linkplain FileObject#openInputStream()}&lt;/code&gt;, and
 75  *         &lt;code&gt;{@linkplain FileObject#openReader(boolean)}&lt;/code&gt;
 76  *         must succeed if the following would succeed (ignoring
 77  *         encoding issues):
 78  *         &lt;blockquote&gt;
 79  *           &lt;pre&gt;new {@linkplain java.io.FileInputStream#FileInputStream(File) FileInputStream}(new {@linkplain File#File(java.net.URI) File}({@linkplain FileObject fileObject}.{@linkplain FileObject#toUri() toUri}()))&lt;/pre&gt;
 80  *         &lt;/blockquote&gt;
 81  *       &lt;/li&gt;
 82  *       &lt;li&gt;
 83  *         and the methods
 84  *         &lt;code&gt;{@linkplain FileObject#openOutputStream()}&lt;/code&gt;, and
 85  *         &lt;code&gt;{@linkplain FileObject#openWriter()}&lt;/code&gt; must
 86  *         succeed if the following would succeed (ignoring encoding
 87  *         issues):
 88  *         &lt;blockquote&gt;
 89  *           &lt;pre&gt;new {@linkplain java.io.FileOutputStream#FileOutputStream(File) FileOutputStream}(new {@linkplain File#File(java.net.URI) File}({@linkplain FileObject fileObject}.{@linkplain FileObject#toUri() toUri}()))&lt;/pre&gt;
 90  *         &lt;/blockquote&gt;
 91  *       &lt;/li&gt;
 92  *     &lt;/ul&gt;
 93  *   &lt;/li&gt;
 94  *   &lt;li&gt;
 95  *     The {@linkplain java.net.URI URI} returned from
 96  *     &lt;code&gt;{@linkplain FileObject#toUri()}&lt;/code&gt;
 97  *     &lt;ul&gt;
 98  *       &lt;li&gt;
 99  *         must be {@linkplain java.net.URI#isAbsolute() absolute} (have a schema), and
100  *       &lt;/li&gt;
101  *       &lt;li&gt;
102  *         must have a {@linkplain java.net.URI#normalize() normalized}
103  *         {@linkplain java.net.URI#getPath() path component} which
104  *         can be resolved without any process-specific context such
105  *         as the current directory (file names must be absolute).
106  *       &lt;/li&gt;
107  *     &lt;/ul&gt;
108  *   &lt;/li&gt;
109  * &lt;/ul&gt;
110  *
111  * According to these rules, the following URIs, for example, are
112  * allowed:
113  * &lt;ul&gt;
114  *   &lt;li&gt;
115  *     &lt;code&gt;file:///C:/Documents%20and%20Settings/UncleBob/BobsApp/Test.java&lt;/code&gt;
116  *   &lt;/li&gt;
117  *   &lt;li&gt;
118  *     &lt;code&gt;jar:///C:/Documents%20and%20Settings/UncleBob/lib/vendorA.jar!/com/vendora/LibraryClass.class&lt;/code&gt;
119  *   &lt;/li&gt;
120  * &lt;/ul&gt;
121  * Whereas these are not (reason in parentheses):
122  * &lt;ul&gt;
123  *   &lt;li&gt;
124  *     &lt;code&gt;file:BobsApp/Test.java&lt;/code&gt; (the file name is relative
125  *     and depend on the current directory)
126  *   &lt;/li&gt;
127  *   &lt;li&gt;
128  *     &lt;code&gt;jar:lib/vendorA.jar!/com/vendora/LibraryClass.class&lt;/code&gt;
129  *     (the first half of the path depends on the current directory,
130  *     whereas the component after ! is legal)
131  *   &lt;/li&gt;
132  *   &lt;li&gt;
133  *     &lt;code&gt;Test.java&lt;/code&gt; (this URI depends on the current
134  *     directory and does not have a schema)
135  *   &lt;/li&gt;
136  *   &lt;li&gt;
137  *     &lt;code&gt;jar:///C:/Documents%20and%20Settings/UncleBob/BobsApp/../lib/vendorA.jar!com/vendora/LibraryClass.class&lt;/code&gt;
138  *     (the path is not normalized)
139  *   &lt;/li&gt;
140  * &lt;/ul&gt;
141  *
142  * &lt;p&gt;All implementations of this interface must support Path objects representing
143  * files in the {@linkplain java.nio.file.FileSystems#getDefault() default file system.}
144  * It is recommended that implementations should support Path objects from any filesystem.&lt;/p&gt;
145  *
146  *
147  * @apiNote
148  * Some methods on this interface take a {@code Collection&lt;? extends Path&gt;}
149  * instead of {@code Iterable&lt;? extends Path&gt;}.
150  * This is to prevent the possibility of accidentally calling the method
151  * with a single {@code Path} as such an argument, because although
152  * {@code Path} implements {@code Iterable&lt;Path&gt;}, it would almost never be
153  * correct to call these methods with a single {@code Path} and have it be treated as
154  * an {@code Iterable} of its components.
155  *
156  *
157  * @author Peter von der Ah&amp;eacute;
158  * @since 1.6
159  */
160 public interface StandardJavaFileManager extends JavaFileManager {
161 
162     /**
163      * Compares two file objects and return true if they represent the
164      * same canonical file, zip file entry, or entry in any file
165      * system based container.
166      *
167      * @param a a file object
168      * @param b a file object
169      * @return true if the given file objects represent the same
170      * canonical file, zip file entry or path; false otherwise
171      *
172      * @throws IllegalArgumentException if either of the arguments
173      * were created with another file manager implementation
174      */
175     @Override
176     boolean isSameFile(FileObject a, FileObject b);
177 
178     /**
179      * Returns file objects representing the given files.
180      *
181      * @param files a list of files
182      * @return a list of file objects
183      * @throws IllegalArgumentException if the list of files includes
184      * a directory
185      */
186     Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromFiles(
187         Iterable&lt;? extends File&gt; files);
188 
<a name="3" id="anc3"></a><span class="line-added">189     /**</span>
<span class="line-added">190      * Returns file objects representing the given paths.</span>
<span class="line-added">191      *</span>
<span class="line-added">192      * @implSpec</span>
<span class="line-added">193      * The default implementation converts each path to a file and calls</span>
<span class="line-added">194      * {@link #getJavaFileObjectsFromFiles getJavaObjectsFromFiles}.</span>
<span class="line-added">195      * IllegalArgumentException will be thrown if any of the paths</span>
<span class="line-added">196      * cannot be converted to a file.</span>
<span class="line-added">197      *</span>
<span class="line-added">198      * @param paths a list of paths</span>
<span class="line-added">199      * @return a list of file objects</span>
<span class="line-added">200      * @throws IllegalArgumentException if the list of paths includes</span>
<span class="line-added">201      * a directory or if this file manager does not support any of the</span>
<span class="line-added">202      * given paths.</span>
<span class="line-added">203      *</span>
<span class="line-added">204      * @since 13</span>
<span class="line-added">205      */</span>
<span class="line-added">206     default Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromPaths(</span>
<span class="line-added">207             Collection&lt;? extends Path&gt; paths) {</span>
<span class="line-added">208         return getJavaFileObjectsFromFiles(asFiles(paths));</span>
<span class="line-added">209     }</span>
<span class="line-added">210 </span>
211     /**
212      * Returns file objects representing the given paths.
213      *
214      * @implSpec
215      * The default implementation converts each path to a file and calls
216      * {@link #getJavaFileObjectsFromFiles getJavaObjectsFromFiles}.
217      * IllegalArgumentException will be thrown if any of the paths
218      * cannot be converted to a file.
219      *
220      * @param paths a list of paths
221      * @return a list of file objects
222      * @throws IllegalArgumentException if the list of paths includes
223      * a directory or if this file manager does not support any of the
224      * given paths.
225      *
226      * @since 9
<a name="4" id="anc4"></a><span class="line-added">227      * @deprecated use {@link #getJavaFileObjectsFromPaths(Collection)} instead,</span>
<span class="line-added">228      * to prevent the possibility of accidentally calling the method with a</span>
<span class="line-added">229      * single {@code Path} as such an argument. Although {@code Path} implements</span>
<span class="line-added">230      * {@code Iterable&lt;Path&gt;}, it would almost never be correct to pass a single</span>
<span class="line-added">231      * {@code Path} and have it be treated as an {@code Iterable} of its</span>
<span class="line-added">232      * components.</span>
233      */
<a name="5" id="anc5"></a><span class="line-added">234     @Deprecated(since = &quot;13&quot;)</span>
235     default Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromPaths(
236             Iterable&lt;? extends Path&gt; paths) {
<a name="6" id="anc6"></a><span class="line-modified">237         return getJavaFileObjectsFromPaths(asCollection(paths));</span>
238     }
239 
240     /**
241      * Returns file objects representing the given files.
242      * Convenience method equivalent to:
243      *
244      * &lt;pre&gt;
245      *     getJavaFileObjectsFromFiles({@linkplain java.util.Arrays#asList Arrays.asList}(files))
246      * &lt;/pre&gt;
247      *
248      * @param files an array of files
249      * @return a list of file objects
250      * @throws IllegalArgumentException if the array of files includes
251      * a directory
252      * @throws NullPointerException if the given array contains null
253      * elements
254      */
255     Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(File... files);
256 
257     /**
258      * Returns file objects representing the given paths.
259      * Convenience method equivalent to:
260      *
261      * &lt;pre&gt;
262      *     getJavaFileObjectsFromPaths({@linkplain java.util.Arrays#asList Arrays.asList}(paths))
263      * &lt;/pre&gt;
264      *
265      * @param paths an array of paths
266      * @return a list of file objects
267      * @throws IllegalArgumentException if the array of files includes
268      * a directory
269      * @throws NullPointerException if the given array contains null
270      * elements
271      *
272      * @since 9
273      */
274     default Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(Path... paths) {
275         return getJavaFileObjectsFromPaths(Arrays.asList(paths));
276     }
277 
278     /**
279      * Returns file objects representing the given file names.
280      *
281      * @param names a list of file names
282      * @return a list of file objects
283      * @throws IllegalArgumentException if the list of file names
284      * includes a directory
285      */
286     Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromStrings(
287         Iterable&lt;String&gt; names);
288 
289     /**
290      * Returns file objects representing the given file names.
291      * Convenience method equivalent to:
292      *
293      * &lt;pre&gt;
294      *     getJavaFileObjectsFromStrings({@linkplain java.util.Arrays#asList Arrays.asList}(names))
295      * &lt;/pre&gt;
296      *
297      * @param names a list of file names
298      * @return a list of file objects
299      * @throws IllegalArgumentException if the array of file names
300      * includes a directory
301      * @throws NullPointerException if the given array contains null
302      * elements
303      */
304     Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(String... names);
305 
306     /**
307      * Associates the given search path with the given location.  Any
308      * previous value will be discarded.
309      *
310      * If the location is a module-oriented or output location, any module-specific
311      * associations set up by {@linkplain #setLocationForModule setLocationForModule}
312      * will be cancelled.
313      *
314      * @param location a location
315      * @param files a list of files, if {@code null} use the default
316      * search path for this location
317      * @see #getLocation
318      * @throws IllegalArgumentException if {@code location} is an output
319      * location and {@code files} does not contain exactly one element
320      * @throws IOException if {@code location} is an output location and
321      * does not represent an existing directory
322      */
323     void setLocation(Location location, Iterable&lt;? extends File&gt; files)
324         throws IOException;
325 
326     /**
327      * Associates the given search path with the given location.
328      * Any previous value will be discarded.
329      *
330      * If the location is a module-oriented or output location, any module-specific
331      * associations set up by {@linkplain #setLocationForModule setLocationForModule}
332      * will be cancelled.
333      *
334      * @implSpec
335      * The default implementation converts each path to a file and calls
336      * {@link #getJavaFileObjectsFromFiles getJavaObjectsFromFiles}.
337      * {@linkplain IllegalArgumentException IllegalArgumentException}
338      * will be thrown if any of the paths cannot be converted to a file.
339      *
340      * @param location a location
341      * @param paths a list of paths, if {@code null} use the default
342      * search path for this location
343      * @see #getLocation
344      * @throws IllegalArgumentException if {@code location} is an output
345      * location and {@code paths} does not contain exactly one element
346      * or if this file manager does not support any of the given paths
347      * @throws IOException if {@code location} is an output location and
348      * {@code paths} does not represent an existing directory
349      *
350      * @since 9
351      */
352     default void setLocationFromPaths(Location location, Collection&lt;? extends Path&gt; paths)
353             throws IOException {
354         setLocation(location, asFiles(paths));
355     }
356 
357     /**
358      * Associates the given search path with the given module and location,
359      * which must be a module-oriented or output location.
360      * Any previous value will be discarded.
361      * This overrides any default association derived from the search path
362      * associated with the location itself.
363      *
364      * All such module-specific associations will be cancelled if a
365      * new search path is associated with the location by calling
366      * {@linkplain #setLocation setLocation } or
367      * {@linkplain #setLocationFromPaths setLocationFromPaths}.
368      *
369      * @throws IllegalStateException if the location is not a module-oriented
370      *  or output location.
371      * @throws UnsupportedOperationException if this operation is not supported by
372      *  this file manager.
373      * @throws IOException if {@code location} is an output location and
374      * {@code paths} does not represent an existing directory
375      *
376      * @param location the location
377      * @param moduleName the name of the module
378      * @param paths the search path to associate with the location and module.
379      *
380      * @see setLocation
381      * @see setLocationFromPaths
382      *
383      * @since 9
384      */
385     default void setLocationForModule(Location location, String moduleName,
386             Collection&lt;? extends Path&gt; paths) throws IOException {
387         throw new UnsupportedOperationException();
388     }
389 
390     /**
391      * Returns the search path associated with the given location.
392      *
393      * @param location a location
394      * @return a list of files or {@code null} if this location has no
395      * associated search path
396      * @throws IllegalStateException if any element of the search path
397      * cannot be converted to a {@linkplain File}, or if the search path
398      * cannot be represented as a simple series of files.
399      *
400      * @see #setLocation
401      * @see Path#toFile
402      */
403     Iterable&lt;? extends File&gt; getLocation(Location location);
404 
405     /**
406      * Returns the search path associated with the given location.
407      *
408      * @implSpec
409      * The default implementation calls {@link #getLocation getLocation}
410      * and then returns an {@code Iterable} formed by calling {@code toPath()}
411      * on each {@code File} returned from {@code getLocation}.
412      *
413      * @param location a location
414      * @return a list of paths or {@code null} if this location has no
415      * associated search path
416      * @throws IllegalStateException if the search path cannot be represented
417      * as a simple series of paths.
418      *
419      * @see #setLocationFromPaths
420      * @since 9
421      */
422     default Iterable&lt;? extends Path&gt; getLocationAsPaths(Location location) {
423         return asPaths(getLocation(location));
424     }
425 
426     /**
427      * Returns the path, if any, underlying this file object (optional operation).
428      * File objects derived from a {@link java.nio.file.FileSystem FileSystem},
429      * including the default file system, typically have a corresponding underlying
430      * {@link java.nio.file.Path Path} object. In such cases, this method may be
431      * used to access that object.
432      *
433      * @implSpec
434      * The default implementation throws {@link UnsupportedOperationException}
435      * for all files.
436      *
437      * @param file a file object
438      * @return a path representing the same underlying file system artifact
439      * @throws IllegalArgumentException if the file object does not have an underlying path
440      * @throws UnsupportedOperationException if the operation is not supported by this file manager
441      *
442      * @since 9
443      */
444     default Path asPath(FileObject file) {
445         throw new UnsupportedOperationException();
446     }
447 
448     /**
449      * Factory to create {@code Path} objects from strings.
450      *
451      * @since 9
452      */
453     interface PathFactory {
454         /**
455          * Converts a path string, or a sequence of strings that when joined form a path string, to a Path.
456          *
457          * @param first  the path string or initial part of the path string
458          * @param more   additional strings to be joined to form the path string
459          * @return       the resulting {@code Path}
460          */
461         Path getPath(String first, String... more);
462     }
463 
464      /**
465       * Specify a factory that can be used to generate a path from a string, or series of strings.
466       *
467       * If this method is not called, a factory whose {@code getPath} method is
468       * equivalent to calling
469       * {@link java.nio.file.Paths#get(String, String...) java.nio.file.Paths.get(first, more)}
470       * will be used.
471       *
472       * @implSpec
473       * The default implementation of this method ignores the factory that is provided.
474       *
475       * @param f  the factory
476       *
477       * @since 9
478       */
479     default void setPathFactory(PathFactory f) { }
480 
481 
482     private static Iterable&lt;Path&gt; asPaths(final Iterable&lt;? extends File&gt; files) {
483         return () -&gt; new Iterator&lt;Path&gt;() {
484             Iterator&lt;? extends File&gt; iter = files.iterator();
485 
486             @Override
487             public boolean hasNext() {
488                 return iter.hasNext();
489             }
490 
491             @Override
492             public Path next() {
493                 return iter.next().toPath();
494             }
495         };
496     }
497 
498     private static Iterable&lt;File&gt; asFiles(final Iterable&lt;? extends Path&gt; paths) {
499         return () -&gt; new Iterator&lt;File&gt;() {
500             Iterator&lt;? extends Path&gt; iter = paths.iterator();
501 
502             @Override
503             public boolean hasNext() {
504                 return iter.hasNext();
505             }
506 
507             @Override
508             public File next() {
509                 Path p = iter.next();
510                 try {
511                     return p.toFile();
512                 } catch (UnsupportedOperationException e) {
513                     throw new IllegalArgumentException(p.toString(), e);
514                 }
515             }
516         };
517     }
<a name="7" id="anc7"></a><span class="line-added">518 </span>
<span class="line-added">519     private static &lt;T&gt; Collection&lt;T&gt; asCollection(Iterable&lt;T&gt; iterable) {</span>
<span class="line-added">520         if (iterable instanceof Collection) {</span>
<span class="line-added">521             return (Collection&lt;T&gt;) iterable;</span>
<span class="line-added">522         }</span>
<span class="line-added">523         List&lt;T&gt; result = new ArrayList&lt;&gt;();</span>
<span class="line-added">524         for (T item : iterable) result.add(item);</span>
<span class="line-added">525         return result;</span>
<span class="line-added">526     }</span>
527 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.compiler/share/classes/javax/lang/model/element/Element.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../SourceVersion.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ElementKind.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.compiler/share/classes/javax/lang/model/element/Element.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 46  * always be represented by the same object.
 47  *
 48  * &lt;p&gt; To implement operations based on the class of an {@code
 49  * Element} object, either use a {@linkplain ElementVisitor visitor} or
 50  * use the result of the {@link #getKind} method.  Using {@code
 51  * instanceof} is &lt;em&gt;not&lt;/em&gt; necessarily a reliable idiom for
 52  * determining the effective class of an object in this modeling
 53  * hierarchy since an implementation may choose to have a single object
 54  * implement multiple {@code Element} subinterfaces.
 55  *
 56  * @author Joseph D. Darcy
 57  * @author Scott Seligman
 58  * @author Peter von der Ah&amp;eacute;
 59  * @see Elements
 60  * @see TypeMirror
 61  * @since 1.6
 62  */
 63 public interface Element extends javax.lang.model.AnnotatedConstruct {
 64     /**
 65      * Returns the type defined by this element.
<span class="line-modified"> 66      *</span>
<span class="line-removed"> 67      * &lt;p&gt; A generic element defines a family of types, not just one.</span>
<span class="line-removed"> 68      * If this is a generic element, a &lt;i&gt;prototypical&lt;/i&gt; type is</span>
<span class="line-removed"> 69      * returned.  This is the element&#39;s invocation on the</span>
<span class="line-removed"> 70      * type variables corresponding to its own formal type parameters.</span>
<span class="line-removed"> 71      * For example,</span>
<span class="line-removed"> 72      * for the generic class element {@code C&lt;N extends Number&gt;},</span>
<span class="line-removed"> 73      * the parameterized type {@code C&lt;N&gt;} is returned.</span>
<span class="line-removed"> 74      * The {@link Types} utility interface has more general methods</span>
<span class="line-removed"> 75      * for obtaining the full range of types defined by an element.</span>
 76      *
 77      * @see Types
<span class="line-modified"> 78      *</span>
<span class="line-modified"> 79      * @return the type defined by this element</span>




 80      */
 81     TypeMirror asType();
 82 
 83     /**
 84      * Returns the {@code kind} of this element.
 85      *





































 86      * @return the kind of this element
 87      */
 88     ElementKind getKind();
 89 
 90     /**
 91      * Returns the modifiers of this element, excluding annotations.
 92      * Implicit modifiers, such as the {@code public} and {@code static}
 93      * modifiers of interface members, are included.
 94      *
 95      * @return the modifiers of this element, or an empty set if there are none
 96      */
 97     Set&lt;Modifier&gt; getModifiers();
 98 
 99     /**
100      * Returns the simple (unqualified) name of this element.  The
101      * name of a generic type does not include any reference to its
102      * formal type parameters.
103      *
104      * For example, the simple name of the type element {@code
105      * java.util.Set&lt;E&gt;} is {@code &quot;Set&quot;}.
106      *
107      * If this element represents an unnamed {@linkplain
108      * PackageElement#getSimpleName package} or unnamed {@linkplain
109      * ModuleElement#getSimpleName module}, an empty name is returned.
110      *
111      * If it represents a {@linkplain ExecutableElement#getSimpleName
112      * constructor}, the name &quot;{@code &lt;init&gt;}&quot; is returned.  If it
113      * represents a {@linkplain ExecutableElement#getSimpleName static
114      * initializer}, the name &quot;{@code &lt;clinit&gt;}&quot; is returned.
115      *
116      * If it represents an {@linkplain TypeElement#getSimpleName
117      * anonymous class} or {@linkplain ExecutableElement#getSimpleName
118      * instance initializer}, an empty name is returned.
119      *
120      * @return the simple name of this element
121      * @see PackageElement#getSimpleName
122      * @see ExecutableElement#getSimpleName
123      * @see TypeElement#getSimpleName
124      * @see VariableElement#getSimpleName
125      * @see ModuleElement#getSimpleName

126      * @revised 9
127      * @spec JPMS
128      */
129     Name getSimpleName();
130 
131     /**
132      * Returns the innermost element
133      * within which this element is, loosely speaking, enclosed.
134      * &lt;ul&gt;
135      * &lt;li&gt; If this element is one whose declaration is lexically enclosed
136      * immediately within the declaration of another element, that other
137      * element is returned.
138      *
139      * &lt;li&gt; If this is a {@linkplain TypeElement#getEnclosingElement
140      * top-level type}, its package is returned.
141      *
142      * &lt;li&gt; If this is a {@linkplain
143      * PackageElement#getEnclosingElement package}, its module is
144      * returned if such a module exists. Otherwise, {@code null} is returned.
145      *
146      * &lt;li&gt; If this is a {@linkplain
147      * TypeParameterElement#getEnclosingElement type parameter},
148      * {@linkplain TypeParameterElement#getGenericElement the
149      * generic element} of the type parameter is returned.
150      *
151      * &lt;li&gt; If this is a {@linkplain
152      * VariableElement#getEnclosingElement method or constructor
153      * parameter}, {@linkplain ExecutableElement the executable
154      * element} which declares the parameter is returned.
155      *





156      * &lt;li&gt; If this is a {@linkplain ModuleElement#getEnclosingElement
157      * module}, {@code null} is returned.
158      *
159      * &lt;/ul&gt;
160      *
161      * @return the enclosing element, or {@code null} if there is none
162      * @see Elements#getPackageOf
163      * @revised 9
164      * @spec JPMS
165      */
166     Element getEnclosingElement();
167 
168     /**
169      * Returns the elements that are, loosely speaking, directly
170      * enclosed by this element.
171      *
172      * A {@linkplain TypeElement#getEnclosedElements class or
173      * interface} is considered to enclose the fields, methods,
<span class="line-modified">174      * constructors, and member types that it directly declares.</span>
175      *
176      * A {@linkplain PackageElement#getEnclosedElements package}
177      * encloses the top-level classes and interfaces within it, but is
178      * not considered to enclose subpackages.
179      *
180      * A {@linkplain ModuleElement#getEnclosedElements module}
181      * encloses packages within it.
182      *
183      * Enclosed elements may include implicitly declared {@linkplain
184      * Elements.Origin#MANDATED mandated} elements.
185      *
186      * Other kinds of elements are not currently considered to enclose
187      * any elements; however, that may change as this API or the
188      * programming language evolves.
189      *
190      * @apiNote Elements of certain kinds can be isolated using
191      * methods in {@link ElementFilter}.
192      *
193      * @return the enclosed elements, or an empty list if none
194      * @see TypeElement#getEnclosedElements
195      * @see PackageElement#getEnclosedElements
196      * @see ModuleElement#getEnclosedElements
197      * @see Elements#getAllMembers
198      * @jls 8.8.9 Default Constructor
<span class="line-modified">199      * @jls 8.9 Enums</span>
200      * @revised 9
201      * @spec JPMS
202      */
203     List&lt;? extends Element&gt; getEnclosedElements();
204 
205     /**
206      * Returns {@code true} if the argument represents the same
207      * element as {@code this}, or {@code false} otherwise.
208      *
209      * @apiNote The identity of an element involves implicit state
210      * not directly accessible from the element&#39;s methods, including
211      * state about the presence of unrelated types.  Element objects
212      * created by different implementations of these interfaces should
213      * &lt;i&gt;not&lt;/i&gt; be expected to be equal even if &amp;quot;the same&amp;quot;
214      * element is being modeled; this is analogous to the inequality
215      * of {@code Class} objects for the same class file loaded through
216      * different class loaders.
217      *
218      * @param obj  the object to be compared with this element
219      * @return {@code true} if the specified object represents the same
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 46  * always be represented by the same object.
 47  *
 48  * &lt;p&gt; To implement operations based on the class of an {@code
 49  * Element} object, either use a {@linkplain ElementVisitor visitor} or
 50  * use the result of the {@link #getKind} method.  Using {@code
 51  * instanceof} is &lt;em&gt;not&lt;/em&gt; necessarily a reliable idiom for
 52  * determining the effective class of an object in this modeling
 53  * hierarchy since an implementation may choose to have a single object
 54  * implement multiple {@code Element} subinterfaces.
 55  *
 56  * @author Joseph D. Darcy
 57  * @author Scott Seligman
 58  * @author Peter von der Ah&amp;eacute;
 59  * @see Elements
 60  * @see TypeMirror
 61  * @since 1.6
 62  */
 63 public interface Element extends javax.lang.model.AnnotatedConstruct {
 64     /**
 65      * Returns the type defined by this element.
<span class="line-modified"> 66      * @return the type defined by this element</span>









 67      *
 68      * @see Types
<span class="line-modified"> 69      * @see ExecutableElement#asType</span>
<span class="line-modified"> 70      * @see ModuleElement#asType</span>
<span class="line-added"> 71      * @see PackageElement#asType</span>
<span class="line-added"> 72      * @see TypeElement#asType</span>
<span class="line-added"> 73      * @see TypeParameterElement#asType</span>
<span class="line-added"> 74      * @see VariableElement#asType</span>
 75      */
 76     TypeMirror asType();
 77 
 78     /**
 79      * Returns the {@code kind} of this element.
 80      *
<span class="line-added"> 81      * &lt;ul&gt;</span>
<span class="line-added"> 82      *</span>
<span class="line-added"> 83      * &lt;li&gt; The kind of a {@linkplain PackageElement package} is</span>
<span class="line-added"> 84      * {@link ElementKind#PACKAGE PACKAGE}.</span>
<span class="line-added"> 85      *</span>
<span class="line-added"> 86      * &lt;li&gt; The kind of a {@linkplain ModuleElement module} is {@link</span>
<span class="line-added"> 87      * ElementKind#MODULE MODULE}.</span>
<span class="line-added"> 88      *</span>
<span class="line-added"> 89      * &lt;li&gt; The kind of a {@linkplain TypeElement type element} is one</span>
<span class="line-added"> 90      * of {@link ElementKind#ANNOTATION_TYPE ANNOTATION_TYPE}, {@link</span>
<span class="line-added"> 91      * ElementKind#CLASS CLASS}, {@link ElementKind#ENUM ENUM}, {@link</span>
<span class="line-added"> 92      * ElementKind#INTERFACE INTERFACE}, or {@link ElementKind#RECORD</span>
<span class="line-added"> 93      * RECORD}.</span>
<span class="line-added"> 94      *</span>
<span class="line-added"> 95      * &lt;li&gt; The kind of a {@linkplain VariableElement variable} is one</span>
<span class="line-added"> 96      * of {@link ElementKind#ENUM_CONSTANT ENUM_CONSTANT}, {@link</span>
<span class="line-added"> 97      * ElementKind#EXCEPTION_PARAMETER EXCEPTION_PARAMETER}, {@link</span>
<span class="line-added"> 98      * ElementKind#FIELD FIELD}, {@link ElementKind#LOCAL_VARIABLE</span>
<span class="line-added"> 99      * LOCAL_VARIABLE}, {@link ElementKind#PARAMETER PARAMETER},</span>
<span class="line-added">100      * {@link ElementKind#RESOURCE_VARIABLE RESOURCE_VARIABLE}, or</span>
<span class="line-added">101      * {@link ElementKind#BINDING_VARIABLE BINDING_VARIABLE}.</span>
<span class="line-added">102      *</span>
<span class="line-added">103      * &lt;li&gt; The kind of an {@linkplain ExecutableElement executable}</span>
<span class="line-added">104      * is one of {@link ElementKind#CONSTRUCTOR CONSTRUCTOR}, {@link</span>
<span class="line-added">105      * ElementKind#INSTANCE_INIT INSTANCE_INIT}, {@link</span>
<span class="line-added">106      * ElementKind#METHOD METHOD}, or {@link ElementKind#STATIC_INIT</span>
<span class="line-added">107      * STATIC_INIT}.</span>
<span class="line-added">108      *</span>
<span class="line-added">109      * &lt;li&gt; The kind of a {@linkplain TypeParameterElement type parameter} is</span>
<span class="line-added">110      * {@link ElementKind#TYPE_PARAMETER TYPE_PARAMETER}.</span>
<span class="line-added">111      *</span>
<span class="line-added">112      * &lt;li&gt; The kind of a {@linkplain RecordComponentElement record</span>
<span class="line-added">113      * component} is {@link ElementKind#RECORD_COMPONENT</span>
<span class="line-added">114      * RECORD_COMPONENT}.</span>
<span class="line-added">115      *</span>
<span class="line-added">116      * &lt;/ul&gt;</span>
<span class="line-added">117      *</span>
118      * @return the kind of this element
119      */
120     ElementKind getKind();
121 
122     /**
123      * Returns the modifiers of this element, excluding annotations.
124      * Implicit modifiers, such as the {@code public} and {@code static}
125      * modifiers of interface members, are included.
126      *
127      * @return the modifiers of this element, or an empty set if there are none
128      */
129     Set&lt;Modifier&gt; getModifiers();
130 
131     /**
132      * Returns the simple (unqualified) name of this element.  The
133      * name of a generic type does not include any reference to its
134      * formal type parameters.
135      *
136      * For example, the simple name of the type element {@code
137      * java.util.Set&lt;E&gt;} is {@code &quot;Set&quot;}.
138      *
139      * If this element represents an unnamed {@linkplain
140      * PackageElement#getSimpleName package} or unnamed {@linkplain
141      * ModuleElement#getSimpleName module}, an empty name is returned.
142      *
143      * If it represents a {@linkplain ExecutableElement#getSimpleName
144      * constructor}, the name &quot;{@code &lt;init&gt;}&quot; is returned.  If it
145      * represents a {@linkplain ExecutableElement#getSimpleName static
146      * initializer}, the name &quot;{@code &lt;clinit&gt;}&quot; is returned.
147      *
148      * If it represents an {@linkplain TypeElement#getSimpleName
149      * anonymous class} or {@linkplain ExecutableElement#getSimpleName
150      * instance initializer}, an empty name is returned.
151      *
152      * @return the simple name of this element
153      * @see PackageElement#getSimpleName
154      * @see ExecutableElement#getSimpleName
155      * @see TypeElement#getSimpleName
156      * @see VariableElement#getSimpleName
157      * @see ModuleElement#getSimpleName
<span class="line-added">158      * @see RecordComponentElement#getSimpleName</span>
159      * @revised 9
160      * @spec JPMS
161      */
162     Name getSimpleName();
163 
164     /**
165      * Returns the innermost element
166      * within which this element is, loosely speaking, enclosed.
167      * &lt;ul&gt;
168      * &lt;li&gt; If this element is one whose declaration is lexically enclosed
169      * immediately within the declaration of another element, that other
170      * element is returned.
171      *
172      * &lt;li&gt; If this is a {@linkplain TypeElement#getEnclosingElement
173      * top-level type}, its package is returned.
174      *
175      * &lt;li&gt; If this is a {@linkplain
176      * PackageElement#getEnclosingElement package}, its module is
177      * returned if such a module exists. Otherwise, {@code null} is returned.
178      *
179      * &lt;li&gt; If this is a {@linkplain
180      * TypeParameterElement#getEnclosingElement type parameter},
181      * {@linkplain TypeParameterElement#getGenericElement the
182      * generic element} of the type parameter is returned.
183      *
184      * &lt;li&gt; If this is a {@linkplain
185      * VariableElement#getEnclosingElement method or constructor
186      * parameter}, {@linkplain ExecutableElement the executable
187      * element} which declares the parameter is returned.
188      *
<span class="line-added">189      * &lt;li&gt; If this is a {@linkplain</span>
<span class="line-added">190      * RecordComponentElement#getEnclosingElement record component},</span>
<span class="line-added">191      * {@linkplain TypeElement the type} which declares the</span>
<span class="line-added">192      * record component is returned.</span>
<span class="line-added">193      *</span>
194      * &lt;li&gt; If this is a {@linkplain ModuleElement#getEnclosingElement
195      * module}, {@code null} is returned.
196      *
197      * &lt;/ul&gt;
198      *
199      * @return the enclosing element, or {@code null} if there is none
200      * @see Elements#getPackageOf
201      * @revised 9
202      * @spec JPMS
203      */
204     Element getEnclosingElement();
205 
206     /**
207      * Returns the elements that are, loosely speaking, directly
208      * enclosed by this element.
209      *
210      * A {@linkplain TypeElement#getEnclosedElements class or
211      * interface} is considered to enclose the fields, methods,
<span class="line-modified">212      * constructors, record components, and member types that it directly declares.</span>
213      *
214      * A {@linkplain PackageElement#getEnclosedElements package}
215      * encloses the top-level classes and interfaces within it, but is
216      * not considered to enclose subpackages.
217      *
218      * A {@linkplain ModuleElement#getEnclosedElements module}
219      * encloses packages within it.
220      *
221      * Enclosed elements may include implicitly declared {@linkplain
222      * Elements.Origin#MANDATED mandated} elements.
223      *
224      * Other kinds of elements are not currently considered to enclose
225      * any elements; however, that may change as this API or the
226      * programming language evolves.
227      *
228      * @apiNote Elements of certain kinds can be isolated using
229      * methods in {@link ElementFilter}.
230      *
231      * @return the enclosed elements, or an empty list if none
232      * @see TypeElement#getEnclosedElements
233      * @see PackageElement#getEnclosedElements
234      * @see ModuleElement#getEnclosedElements
235      * @see Elements#getAllMembers
236      * @jls 8.8.9 Default Constructor
<span class="line-modified">237      * @jls 8.9 Enum Types</span>
238      * @revised 9
239      * @spec JPMS
240      */
241     List&lt;? extends Element&gt; getEnclosedElements();
242 
243     /**
244      * Returns {@code true} if the argument represents the same
245      * element as {@code this}, or {@code false} otherwise.
246      *
247      * @apiNote The identity of an element involves implicit state
248      * not directly accessible from the element&#39;s methods, including
249      * state about the presence of unrelated types.  Element objects
250      * created by different implementations of these interfaces should
251      * &lt;i&gt;not&lt;/i&gt; be expected to be equal even if &amp;quot;the same&amp;quot;
252      * element is being modeled; this is analogous to the inequality
253      * of {@code Class} objects for the same class file loaded through
254      * different class loaders.
255      *
256      * @param obj  the object to be compared with this element
257      * @return {@code true} if the specified object represents the same
</pre>
</td>
</tr>
</table>
<center><a href="../SourceVersion.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ElementKind.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
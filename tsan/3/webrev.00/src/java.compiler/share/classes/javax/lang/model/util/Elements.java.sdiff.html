<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.compiler/share/classes/javax/lang/model/util/Elements.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ElementScanner9.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleAnnotationValueVisitor6.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.compiler/share/classes/javax/lang/model/util/Elements.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.lang.model.util;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Collections;
 30 import java.util.List;
 31 import java.util.Map;
 32 import java.util.Set;
 33 import java.util.LinkedHashSet;

 34 
 35 import javax.lang.model.AnnotatedConstruct;
 36 import javax.lang.model.element.*;
 37 
 38 
 39 /**
 40  * Utility methods for operating on program elements.
 41  *
 42  * &lt;p&gt;&lt;b&gt;Compatibility Note:&lt;/b&gt; Methods may be added to this interface
 43  * in future releases of the platform.
 44  *
 45  * @author Joseph D. Darcy
 46  * @author Scott Seligman
 47  * @author Peter von der Ah&amp;eacute;
 48  * @see javax.annotation.processing.ProcessingEnvironment#getElementUtils
 49  * @since 1.6
 50  */
 51 public interface Elements {
 52 
 53     /**
</pre>
<hr />
<pre>
436         return false;
437     }
438 
439     /**
440      * Returns the &lt;i&gt;binary name&lt;/i&gt; of a type element.
441      *
442      * @param type  the type element being examined
443      * @return the binary name
444      *
445      * @see TypeElement#getQualifiedName
446      * @jls 13.1 The Form of a Binary
447      */
448     Name getBinaryName(TypeElement type);
449 
450 
451     /**
452      * Returns the package of an element.  The package of a package is
453      * itself.
454      * The package of a module is {@code null}.
455      *
<span class="line-modified">456      * @param type the element being examined</span>





457      * @return the package of an element
458      */
<span class="line-modified">459     PackageElement getPackageOf(Element type);</span>
460 
461     /**
462      * Returns the module of an element.  The module of a module is
463      * itself.
<span class="line-modified">464      * If there is no module for the element, null is returned. One situation where there is</span>
<span class="line-modified">465      * no module for an element is if the environment does not include modules, such as</span>
<span class="line-modified">466      * an annotation processing environment configured for</span>
<span class="line-modified">467      * a {@linkplain</span>






468      * javax.annotation.processing.ProcessingEnvironment#getSourceVersion
<span class="line-modified">469      * source version} without modules.</span>




470      *
471      * @implSpec The default implementation of this method returns
472      * {@code null}.
473      *
<span class="line-modified">474      * @param type the element being examined</span>
475      * @return the module of an element
476      * @since 9
477      * @spec JPMS
478      */
<span class="line-modified">479     default ModuleElement getModuleOf(Element type) {</span>
480         return null;
481     }
482 
483     /**
484      * Returns all members of a type element, whether inherited or
485      * declared directly.  For a class the result also includes its
486      * constructors, but not local or anonymous classes.
487      *
488      * @apiNote Elements of certain kinds can be isolated using
489      * methods in {@link ElementFilter}.
490      *
491      * @param type  the type being examined
492      * @return all members of the type
493      * @see Element#getEnclosedElements
494      */
495     List&lt;? extends Element&gt; getAllMembers(TypeElement type);
496 
497     /**
498      * Returns all annotations &lt;i&gt;present&lt;/i&gt; on an element, whether
499      * directly present or present via inheritance.
</pre>
<hr />
<pre>
597     void printElements(java.io.Writer w, Element... elements);
598 
599     /**
600      * Return a name with the same sequence of characters as the
601      * argument.
602      *
603      * @param cs the character sequence to return as a name
604      * @return a name with the same sequence of characters as the argument
605      */
606     Name getName(CharSequence cs);
607 
608     /**
609      * Returns {@code true} if the type element is a functional interface, {@code false} otherwise.
610      *
611      * @param type the type element being examined
612      * @return {@code true} if the element is a functional interface, {@code false} otherwise
613      * @jls 9.8 Functional Interfaces
614      * @since 1.8
615      */
616     boolean isFunctionalInterface(TypeElement type);






































617 }
</pre>
</td>
<td>
<hr />
<pre>
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.lang.model.util;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Collections;
 30 import java.util.List;
 31 import java.util.Map;
 32 import java.util.Set;
 33 import java.util.LinkedHashSet;
<span class="line-added"> 34 import java.util.Objects;</span>
 35 
 36 import javax.lang.model.AnnotatedConstruct;
 37 import javax.lang.model.element.*;
 38 
 39 
 40 /**
 41  * Utility methods for operating on program elements.
 42  *
 43  * &lt;p&gt;&lt;b&gt;Compatibility Note:&lt;/b&gt; Methods may be added to this interface
 44  * in future releases of the platform.
 45  *
 46  * @author Joseph D. Darcy
 47  * @author Scott Seligman
 48  * @author Peter von der Ah&amp;eacute;
 49  * @see javax.annotation.processing.ProcessingEnvironment#getElementUtils
 50  * @since 1.6
 51  */
 52 public interface Elements {
 53 
 54     /**
</pre>
<hr />
<pre>
437         return false;
438     }
439 
440     /**
441      * Returns the &lt;i&gt;binary name&lt;/i&gt; of a type element.
442      *
443      * @param type  the type element being examined
444      * @return the binary name
445      *
446      * @see TypeElement#getQualifiedName
447      * @jls 13.1 The Form of a Binary
448      */
449     Name getBinaryName(TypeElement type);
450 
451 
452     /**
453      * Returns the package of an element.  The package of a package is
454      * itself.
455      * The package of a module is {@code null}.
456      *
<span class="line-modified">457      * The package of a top-level type is its {@linkplain</span>
<span class="line-added">458      * TypeElement#getEnclosingElement enclosing package}. Otherwise,</span>
<span class="line-added">459      * the package of an element is equal to the package of the</span>
<span class="line-added">460      * {@linkplain Element#getEnclosingElement enclosing element}.</span>
<span class="line-added">461      *</span>
<span class="line-added">462      * @param e the element being examined</span>
463      * @return the package of an element
464      */
<span class="line-modified">465     PackageElement getPackageOf(Element e);</span>
466 
467     /**
468      * Returns the module of an element.  The module of a module is
469      * itself.
<span class="line-modified">470      *</span>
<span class="line-modified">471      * If a package has a module as its {@linkplain</span>
<span class="line-modified">472      * PackageElement#getEnclosingElement enclosing element}, that</span>
<span class="line-modified">473      * module is the module of the package. If the enclosing element</span>
<span class="line-added">474      * of a package is {@code null}, {@code null} is returned for the</span>
<span class="line-added">475      * package&#39;s module.</span>
<span class="line-added">476      *</span>
<span class="line-added">477      * (One situation where a package may have a {@code null} module</span>
<span class="line-added">478      * is if the environment does not include modules, such as an</span>
<span class="line-added">479      * annotation processing environment configured for a {@linkplain</span>
480      * javax.annotation.processing.ProcessingEnvironment#getSourceVersion
<span class="line-modified">481      * source version} without modules.)</span>
<span class="line-added">482      *</span>
<span class="line-added">483      * Otherwise, the module of an element is equal to the module</span>
<span class="line-added">484      * {@linkplain #getPackageOf(Element) of the package} of the</span>
<span class="line-added">485      * element.</span>
486      *
487      * @implSpec The default implementation of this method returns
488      * {@code null}.
489      *
<span class="line-modified">490      * @param e the element being examined</span>
491      * @return the module of an element
492      * @since 9
493      * @spec JPMS
494      */
<span class="line-modified">495     default ModuleElement getModuleOf(Element e) {</span>
496         return null;
497     }
498 
499     /**
500      * Returns all members of a type element, whether inherited or
501      * declared directly.  For a class the result also includes its
502      * constructors, but not local or anonymous classes.
503      *
504      * @apiNote Elements of certain kinds can be isolated using
505      * methods in {@link ElementFilter}.
506      *
507      * @param type  the type being examined
508      * @return all members of the type
509      * @see Element#getEnclosedElements
510      */
511     List&lt;? extends Element&gt; getAllMembers(TypeElement type);
512 
513     /**
514      * Returns all annotations &lt;i&gt;present&lt;/i&gt; on an element, whether
515      * directly present or present via inheritance.
</pre>
<hr />
<pre>
613     void printElements(java.io.Writer w, Element... elements);
614 
615     /**
616      * Return a name with the same sequence of characters as the
617      * argument.
618      *
619      * @param cs the character sequence to return as a name
620      * @return a name with the same sequence of characters as the argument
621      */
622     Name getName(CharSequence cs);
623 
624     /**
625      * Returns {@code true} if the type element is a functional interface, {@code false} otherwise.
626      *
627      * @param type the type element being examined
628      * @return {@code true} if the element is a functional interface, {@code false} otherwise
629      * @jls 9.8 Functional Interfaces
630      * @since 1.8
631      */
632     boolean isFunctionalInterface(TypeElement type);
<span class="line-added">633 </span>
<span class="line-added">634     /**</span>
<span class="line-added">635      * {@preview Associated with records, a preview feature of the Java language.</span>
<span class="line-added">636      *</span>
<span class="line-added">637      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview</span>
<span class="line-added">638      *           feature of the Java language. Preview features</span>
<span class="line-added">639      *           may be removed in a future release, or upgraded to permanent</span>
<span class="line-added">640      *           features of the Java language.}</span>
<span class="line-added">641      *</span>
<span class="line-added">642      * Returns the record component for the given accessor. Returns null if the</span>
<span class="line-added">643      * given method is not a record component accessor.</span>
<span class="line-added">644      *</span>
<span class="line-added">645      * @implSpec The default implementation of this method checks if the element</span>
<span class="line-added">646      * enclosing the accessor has kind {@link ElementKind#RECORD RECORD} if that is</span>
<span class="line-added">647      * the case, then all the record components on the accessor&#39;s enclosing element</span>
<span class="line-added">648      * are retrieved by invoking {@link ElementFilter#recordComponentsIn(Iterable)}.</span>
<span class="line-added">649      * If the accessor of at least one of the record components retrieved happen to</span>
<span class="line-added">650      * be equal to the accessor passed as a parameter to this method, then that</span>
<span class="line-added">651      * record component is returned, in any other case {@code null} is returned.</span>
<span class="line-added">652      *</span>
<span class="line-added">653      * @param accessor the method for which the record component should be found.</span>
<span class="line-added">654      * @return the record component, or null if the given method is not an record</span>
<span class="line-added">655      * component accessor</span>
<span class="line-added">656      * @since 14</span>
<span class="line-added">657      */</span>
<span class="line-added">658     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,</span>
<span class="line-added">659                                  essentialAPI=false)</span>
<span class="line-added">660     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">661     default RecordComponentElement recordComponentFor(ExecutableElement accessor) {</span>
<span class="line-added">662         if (accessor.getEnclosingElement().getKind() == ElementKind.RECORD) {</span>
<span class="line-added">663             for (RecordComponentElement rec : ElementFilter.recordComponentsIn(accessor.getEnclosingElement().getEnclosedElements())) {</span>
<span class="line-added">664                 if (Objects.equals(rec.getAccessor(), accessor)) {</span>
<span class="line-added">665                     return rec;</span>
<span class="line-added">666                 }</span>
<span class="line-added">667             }</span>
<span class="line-added">668         }</span>
<span class="line-added">669         return null;</span>
<span class="line-added">670     }</span>
671 }
</pre>
</td>
</tr>
</table>
<center><a href="ElementScanner9.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleAnnotationValueVisitor6.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.compiler/share/classes/javax/annotation/processing/Processor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.annotation.processing;
 27 
 28 import java.util.Set;
 29 import javax.lang.model.util.Elements;
 30 import javax.lang.model.AnnotatedConstruct;
 31 import javax.lang.model.element.*;
 32 import javax.lang.model.SourceVersion;
 33 
 34 /**
 35  * The interface for an annotation processor.
 36  *
 37  * &lt;p&gt;Annotation processing happens in a sequence of {@linkplain
 38  * javax.annotation.processing.RoundEnvironment rounds}.  On each
 39  * round, a processor may be asked to {@linkplain #process process} a
 40  * subset of the annotations found on the source and class files
 41  * produced by a prior round.  The inputs to the first round of
 42  * processing are the initial inputs to a run of the tool; these
 43  * initial inputs can be regarded as the output of a virtual zeroth
 44  * round of processing.  If a processor was asked to process on a
 45  * given round, it will be asked to process on subsequent rounds,
 46  * including the last round, even if there are no annotations for it
 47  * to process.  The tool infrastructure may also ask a processor to
 48  * process files generated implicitly by the tool&#39;s operation.
 49  *
 50  * &lt;p&gt; Each implementation of a {@code Processor} must provide a
 51  * public no-argument constructor to be used by tools to instantiate
 52  * the processor.  The tool infrastructure will interact with classes
 53  * implementing this interface as follows:
 54  *
 55  * &lt;ol&gt;
 56  *
 57  * &lt;li&gt;If an existing {@code Processor} object is not being used, to
 58  * create an instance of a processor the tool calls the no-arg
 59  * constructor of the processor class.
 60  *
 61  * &lt;li&gt;Next, the tool calls the {@link #init init} method with
 62  * an appropriate {@link ProcessingEnvironment}.
 63  *
 64  * &lt;li&gt;Afterwards, the tool calls {@link #getSupportedAnnotationTypes
 65  * getSupportedAnnotationTypes}, {@link #getSupportedOptions
 66  * getSupportedOptions}, and {@link #getSupportedSourceVersion
 67  * getSupportedSourceVersion}.  These methods are only called once per
 68  * run, not on each round.
 69  *
 70  * &lt;li&gt;As appropriate, the tool calls the {@link #process process}
 71  * method on the {@code Processor} object; a new {@code Processor}
 72  * object is &lt;em&gt;not&lt;/em&gt; created for each round.
 73  *
 74  * &lt;/ol&gt;
 75  *
 76  * If a processor object is created and used without the above
 77  * protocol being followed, then the processor&#39;s behavior is not
 78  * defined by this interface specification.
 79  *
 80  * &lt;p&gt; The tool uses a &lt;i&gt;discovery process&lt;/i&gt; to find annotation
 81  * processors and decide whether or not they should be run.  By
 82  * configuring the tool, the set of potential processors can be
 83  * controlled.  For example, for a {@link javax.tools.JavaCompiler
 84  * JavaCompiler} the list of candidate processors to run can be
 85  * {@linkplain javax.tools.JavaCompiler.CompilationTask#setProcessors
 86  * set directly} or controlled by a {@linkplain
 87  * javax.tools.StandardLocation#ANNOTATION_PROCESSOR_PATH search path}
 88  * used for a {@linkplain java.util.ServiceLoader service-style}
 89  * lookup.  Other tool implementations may have different
 90  * configuration mechanisms, such as command line options; for
 91  * details, refer to the particular tool&#39;s documentation.  Which
 92  * processors the tool asks to {@linkplain #process run} is a function
 93  * of the types of the annotations &lt;em&gt;{@linkplain AnnotatedConstruct present}&lt;/em&gt;
 94  * on the {@linkplain
 95  * RoundEnvironment#getRootElements root elements}, what {@linkplain
 96  * #getSupportedAnnotationTypes annotation types a processor
 97  * supports}, and whether or not a processor {@linkplain #process
 98  * claims the annotation types it processes}.  A processor will be asked to
 99  * process a subset of the annotation types it supports, possibly an
100  * empty set.
101  *
102  * For a given round, the tool computes the set of annotation types
103  * that are present on the elements enclosed within the root elements.
104  * If there is at least one annotation type present, then as
105  * processors claim annotation types, they are removed from the set of
106  * unmatched annotation types.  When the set is empty or no more
107  * processors are available, the round has run to completion.  If
108  * there are no annotation types present, annotation processing still
109  * occurs but only &lt;i&gt;universal processors&lt;/i&gt; which support
110  * processing all annotation types, {@code &quot;*&quot;}, can claim the (empty)
111  * set of annotation types.
112  *
113  * &lt;p&gt;An annotation type is considered present if there is at least
114  * one annotation of that type present on an element enclosed within
115  * the root elements of a round. For this purpose, a type parameter is
116  * considered to be enclosed by its {@linkplain
117  * TypeParameterElement#getGenericElement generic
118  * element}.
119 
120  * For this purpose, a package element is &lt;em&gt;not&lt;/em&gt; considered to
121  * enclose the top-level types within that package. (A root element
122  * representing a package is created when a {@code package-info} file
123  * is processed.) Likewise, for this purpose, a module element is
124  * &lt;em&gt;not&lt;/em&gt; considered to enclose the packages within that
125  * module. (A root element representing a module is created when a
126  * {@code module-info} file is processed.)
127  *
128  * Annotations on {@linkplain
129  * java.lang.annotation.ElementType#TYPE_USE type uses}, as opposed to
130  * annotations on elements, are ignored when computing whether or not
131  * an annotation type is present.
132  *
<a name="2" id="anc2"></a><span class="line-modified">133  * &lt;p&gt;An annotation is present if it meets the definition of being</span>
134  * present given in {@link AnnotatedConstruct}. In brief, an
135  * annotation is considered present for the purposes of discovery if
136  * it is directly present or present via inheritance. An annotation is
137  * &lt;em&gt;not&lt;/em&gt; considered present by virtue of being wrapped by a
138  * container annotation. Operationally, this is equivalent to an
139  * annotation being present on an element if and only if it would be
140  * included in the results of {@link
141  * Elements#getAllAnnotationMirrors(Element)} called on that element. Since
142  * annotations inside container annotations are not considered
143  * present, to properly process {@linkplain
144  * java.lang.annotation.Repeatable repeatable annotation types},
145  * processors are advised to include both the repeatable annotation
146  * type and its containing annotation type in the set of {@linkplain
147  * #getSupportedAnnotationTypes() supported annotation types} of a
148  * processor.
149  *
150  * &lt;p&gt;Note that if a processor supports {@code &quot;*&quot;} and returns {@code
151  * true}, all annotations are claimed.  Therefore, a universal
152  * processor being used to, for example, implement additional validity
153  * checks should return {@code false} so as to not prevent other such
154  * checkers from being able to run.
155  *
156  * &lt;p&gt;If a processor throws an uncaught exception, the tool may cease
157  * other active annotation processors.  If a processor raises an
158  * error, the current round will run to completion and the subsequent
159  * round will indicate an {@linkplain RoundEnvironment#errorRaised
160  * error was raised}.  Since annotation processors are run in a
161  * cooperative environment, a processor should throw an uncaught
162  * exception only in situations where no error recovery or reporting
163  * is feasible.
164  *
165  * &lt;p&gt;The tool environment is not required to support annotation
166  * processors that access environmental resources, either {@linkplain
167  * RoundEnvironment per round} or {@linkplain ProcessingEnvironment
168  * cross-round}, in a multi-threaded fashion.
169  *
170  * &lt;p&gt;If the methods that return configuration information about the
171  * annotation processor return {@code null}, return other invalid
172  * input, or throw an exception, the tool infrastructure must treat
173  * this as an error condition.
174  *
175  * &lt;p&gt;To be robust when running in different tool implementations, an
176  * annotation processor should have the following properties:
177  *
178  * &lt;ol&gt;
179  *
180  * &lt;li&gt;The result of processing a given input is not a function of the presence or absence
181  * of other inputs (orthogonality).
182  *
183  * &lt;li&gt;Processing the same input produces the same output (consistency).
184  *
185  * &lt;li&gt;Processing input &lt;i&gt;A&lt;/i&gt; followed by processing input &lt;i&gt;B&lt;/i&gt;
186  * is equivalent to processing &lt;i&gt;B&lt;/i&gt; then &lt;i&gt;A&lt;/i&gt;
187  * (commutativity)
188  *
189  * &lt;li&gt;Processing an input does not rely on the presence of the output
190  * of other annotation processors (independence)
191  *
192  * &lt;/ol&gt;
193  *
194  * &lt;p&gt;The {@link Filer} interface discusses restrictions on how
195  * processors can operate on files.
196  *
197  * @apiNote Implementors of this interface may find it convenient
198  * to extend {@link AbstractProcessor} rather than implementing this
199  * interface directly.
200  *
201  * @author Joseph D. Darcy
202  * @author Scott Seligman
203  * @author Peter von der Ah&amp;eacute;
204  * @since 1.6
205  */
206 public interface Processor {
207     /**
208      * Returns the options recognized by this processor.  An
209      * implementation of the processing tool must provide a way to
210      * pass processor-specific options distinctly from options passed
211      * to the tool itself, see {@link ProcessingEnvironment#getOptions
212      * getOptions}.
213      *
214      * &lt;p&gt;Each string returned in the set must be a period separated
215      * sequence of {@linkplain
216      * javax.lang.model.SourceVersion#isIdentifier identifiers}:
217      *
218      * &lt;blockquote&gt;
219      * &lt;dl&gt;
220      * &lt;dt&gt;&lt;i&gt;SupportedOptionString:&lt;/i&gt;
221      * &lt;dd&gt;&lt;i&gt;Identifiers&lt;/i&gt;
222      *
223      * &lt;dt&gt;&lt;i&gt;Identifiers:&lt;/i&gt;
224      * &lt;dd&gt; &lt;i&gt;Identifier&lt;/i&gt;
225      * &lt;dd&gt; &lt;i&gt;Identifier&lt;/i&gt; {@code .} &lt;i&gt;Identifiers&lt;/i&gt;
226      *
227      * &lt;dt&gt;&lt;i&gt;Identifier:&lt;/i&gt;
228      * &lt;dd&gt;Syntactic identifier, including keywords and literals
229      * &lt;/dl&gt;
230      * &lt;/blockquote&gt;
231      *
232      * &lt;p&gt; A tool might use this information to determine if any
233      * options provided by a user are unrecognized by any processor,
234      * in which case it may wish to report a warning.
235      *
236      * @return the options recognized by this processor or an
237      *         empty collection if none
238      * @see javax.annotation.processing.SupportedOptions
239      */
240     Set&lt;String&gt; getSupportedOptions();
241 
242     /**
243      * Returns the names of the annotation types supported by this
244      * processor.  An element of the result may be the canonical
245      * (fully qualified) name of a supported annotation type.
246      * Alternately it may be of the form &amp;quot;&lt;code&gt;&lt;i&gt;name&lt;/i&gt;.*&lt;/code&gt;&amp;quot;
247      * representing the set of all annotation types with canonical
248      * names beginning with &amp;quot;&lt;code&gt;&lt;i&gt;name.&lt;/i&gt;&lt;/code&gt;&amp;quot;.
249      *
250      * In either of those cases, the name of the annotation type can
251      * be optionally preceded by a module name followed by a {@code
252      * &quot;/&quot;} character. For example, if a processor supports {@code
253      * &quot;a.B&quot;}, this can include multiple annotation types named {@code
254      * a.B} which reside in different modules. To only support {@code
<a name="3" id="anc3"></a><span class="line-modified">255      * a.B} in the {@code Foo} module, instead use {@code &quot;Foo/a.B&quot;}.</span>
256      *
257      * If a module name is included, only an annotation in that module
258      * is matched. In particular, if a module name is given in an
259      * environment where modules are not supported, such as an
260      * annotation processing environment configured for a {@linkplain
261      * javax.annotation.processing.ProcessingEnvironment#getSourceVersion
262      * source version} without modules, then the annotation types with
263      * a module name do &lt;em&gt;not&lt;/em&gt; match.
264      *
265      * Finally, {@code &quot;*&quot;} by itself represents the set of all
266      * annotation types, including the empty set.  Note that a
267      * processor should not claim {@code &quot;*&quot;} unless it is actually
268      * processing all files; claiming unnecessary annotations may
269      * cause a performance slowdown in some environments.
270      *
271      * &lt;p&gt;Each string returned in the set must be accepted by the
272      * following grammar:
273      *
274      * &lt;blockquote&gt;
275      * &lt;dl&gt;
276      * &lt;dt&gt;&lt;i&gt;SupportedAnnotationTypeString:&lt;/i&gt;
277      * &lt;dd&gt;&lt;i&gt;ModulePrefix&lt;/i&gt;&lt;sub&gt;&lt;i&gt;opt&lt;/i&gt;&lt;/sub&gt; &lt;i&gt;TypeName&lt;/i&gt; &lt;i&gt;DotStar&lt;/i&gt;&lt;sub&gt;&lt;i&gt;opt&lt;/i&gt;&lt;/sub&gt;
278      * &lt;dd&gt;&lt;code&gt;*&lt;/code&gt;
279      *
280      * &lt;dt&gt;&lt;i&gt;ModulePrefix:&lt;/i&gt;
281      * &lt;dd&gt;&lt;i&gt;ModuleName&lt;/i&gt; &lt;code&gt;/&lt;/code&gt;
282      *
283      * &lt;dt&gt;&lt;i&gt;DotStar:&lt;/i&gt;
284      * &lt;dd&gt;&lt;code&gt;.&lt;/code&gt; &lt;code&gt;*&lt;/code&gt;
285      * &lt;/dl&gt;
286      * &lt;/blockquote&gt;
287      *
288      * where &lt;i&gt;TypeName&lt;/i&gt; and &lt;i&gt;ModuleName&lt;/i&gt; are as defined in
289      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
290      *
291      * @apiNote When running in an environment which supports modules,
292      * processors are encouraged to include the module prefix when
293      * describing their supported annotation types. The method {@link
294      * AbstractProcessor#getSupportedAnnotationTypes
295      * AbstractProcessor.getSupportedAnnotationTypes} provides support
296      * for stripping off the module prefix when running in an
297      * environment without modules.
298      *
299      * @return the names of the annotation types supported by this processor
300      * @see javax.annotation.processing.SupportedAnnotationTypes
301      * @jls 3.8 Identifiers
302      * @jls 6.5 Determining the Meaning of a Name
303      */
304     Set&lt;String&gt; getSupportedAnnotationTypes();
305 
306     /**
307      * Returns the latest source version supported by this annotation
308      * processor.
309      *
310      * @return the latest source version supported by this annotation
311      * processor.
312      * @see javax.annotation.processing.SupportedSourceVersion
313      * @see ProcessingEnvironment#getSourceVersion
314      */
315     SourceVersion getSupportedSourceVersion();
316 
317     /**
318      * Initializes the processor with the processing environment.
319      *
320      * @param processingEnv environment for facilities the tool framework
321      * provides to the processor
322      */
323     void init(ProcessingEnvironment processingEnv);
324 
325     /**
326      * Processes a set of annotation types on type elements
327      * originating from the prior round and returns whether or not
328      * these annotation types are claimed by this processor.  If {@code
329      * true} is returned, the annotation types are claimed and subsequent
330      * processors will not be asked to process them; if {@code false}
331      * is returned, the annotation types are unclaimed and subsequent
332      * processors may be asked to process them.  A processor may
333      * always return the same boolean value or may vary the result
334      * based on its own chosen criteria.
335      *
336      * &lt;p&gt;The input set will be empty if the processor supports {@code
337      * &quot;*&quot;} and the root elements have no annotations.  A {@code
338      * Processor} must gracefully handle an empty set of annotations.
339      *
340      * @param annotations the annotation types requested to be processed
341      * @param roundEnv  environment for information about the current and prior round
342      * @return whether or not the set of annotation types are claimed by this processor
343      */
344     boolean process(Set&lt;? extends TypeElement&gt; annotations,
345                     RoundEnvironment roundEnv);
346 
347    /**
348     * Returns to the tool infrastructure an iterable of suggested
349     * completions to an annotation.  Since completions are being asked
350     * for, the information provided about the annotation may be
351     * incomplete, as if for a source code fragment. A processor may
352     * return an empty iterable.  Annotation processors should focus
353     * their efforts on providing completions for annotation members
354     * with additional validity constraints known to the processor, for
355     * example an {@code int} member whose value should lie between 1
356     * and 10 or a string member that should be recognized by a known
357     * grammar, such as a regular expression or a URL.
358     *
359     * &lt;p&gt;Since incomplete programs are being modeled, some of the
360     * parameters may only have partial information or may be {@code
361     * null}.  At least one of {@code element} and {@code userText}
362     * must be non-{@code null}.  If {@code element} is non-{@code null},
363     * {@code annotation} and {@code member} may be {@code
364     * null}.  Processors may not throw a {@code NullPointerException}
365     * if some parameters are {@code null}; if a processor has no
366     * completions to offer based on the provided information, an
367     * empty iterable can be returned.  The processor may also return
368     * a single completion with an empty value string and a message
369     * describing why there are no completions.
370     *
371     * &lt;p&gt;Completions are informative and may reflect additional
372     * validity checks performed by annotation processors.  For
373     * example, consider the simple annotation:
374     *
375     * &lt;blockquote&gt;
376     * &lt;pre&gt;
377     * &amp;#064;MersennePrime {
378     *    int value();
379     * }
380     * &lt;/pre&gt;
381     * &lt;/blockquote&gt;
382     *
383     * (A Mersenne prime is prime number of the form
384     * 2&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; - 1.) Given an {@code AnnotationMirror}
385     * for this annotation type, a list of all such primes in the
386     * {@code int} range could be returned without examining any other
387     * arguments to {@code getCompletions}:
388     *
389     * &lt;blockquote&gt;
390     * &lt;pre&gt;
391     * import static javax.annotation.processing.Completions.*;
392     * ...
393     * return Arrays.asList({@link Completions#of(String) of}(&amp;quot;3&amp;quot;),
394     *                      of(&amp;quot;7&amp;quot;),
395     *                      of(&amp;quot;31&amp;quot;),
396     *                      of(&amp;quot;127&amp;quot;),
397     *                      of(&amp;quot;8191&amp;quot;),
398     *                      of(&amp;quot;131071&amp;quot;),
399     *                      of(&amp;quot;524287&amp;quot;),
400     *                      of(&amp;quot;2147483647&amp;quot;));
401     * &lt;/pre&gt;
402     * &lt;/blockquote&gt;
403     *
404     * A more informative set of completions would include the number
405     * of each prime:
406     *
407     * &lt;blockquote&gt;
408     * &lt;pre&gt;
409     * return Arrays.asList({@link Completions#of(String, String) of}(&amp;quot;3&amp;quot;,          &amp;quot;M2&amp;quot;),
410     *                      of(&amp;quot;7&amp;quot;,          &amp;quot;M3&amp;quot;),
411     *                      of(&amp;quot;31&amp;quot;,         &amp;quot;M5&amp;quot;),
412     *                      of(&amp;quot;127&amp;quot;,        &amp;quot;M7&amp;quot;),
413     *                      of(&amp;quot;8191&amp;quot;,       &amp;quot;M13&amp;quot;),
414     *                      of(&amp;quot;131071&amp;quot;,     &amp;quot;M17&amp;quot;),
415     *                      of(&amp;quot;524287&amp;quot;,     &amp;quot;M19&amp;quot;),
416     *                      of(&amp;quot;2147483647&amp;quot;, &amp;quot;M31&amp;quot;));
417     * &lt;/pre&gt;
418     * &lt;/blockquote&gt;
419     *
420     * However, if the {@code userText} is available, it can be checked
421     * to see if only a subset of the Mersenne primes are valid.  For
422     * example, if the user has typed
423     *
424     * &lt;blockquote&gt;
425     * &lt;code&gt;
426     * &amp;#064;MersennePrime(1
427     * &lt;/code&gt;
428     * &lt;/blockquote&gt;
429     *
430     * the value of {@code userText} will be {@code &quot;1&quot;}; and only
431     * two of the primes are possible completions:
432     *
433     * &lt;blockquote&gt;
434     * &lt;pre&gt;
435     * return Arrays.asList(of(&amp;quot;127&amp;quot;,        &amp;quot;M7&amp;quot;),
436     *                      of(&amp;quot;131071&amp;quot;,     &amp;quot;M17&amp;quot;));
437     * &lt;/pre&gt;
438     * &lt;/blockquote&gt;
439     *
440     * Sometimes no valid completion is possible.  For example, there
441     * is no in-range Mersenne prime starting with 9:
442     *
443     * &lt;blockquote&gt;
444     * &lt;code&gt;
445     * &amp;#064;MersennePrime(9
446     * &lt;/code&gt;
447     * &lt;/blockquote&gt;
448     *
449     * An appropriate response in this case is to either return an
450     * empty list of completions,
451     *
452     * &lt;blockquote&gt;
453     * &lt;pre&gt;
454     * return Collections.emptyList();
455     * &lt;/pre&gt;
456     * &lt;/blockquote&gt;
457     *
458     * or a single empty completion with a helpful message
459     *
460     * &lt;blockquote&gt;
461     * &lt;pre&gt;
462     * return Arrays.asList(of(&amp;quot;&amp;quot;, &amp;quot;No in-range Mersenne primes start with 9&amp;quot;));
463     * &lt;/pre&gt;
464     * &lt;/blockquote&gt;
465     *
466     * @param element the element being annotated
467     * @param annotation the (perhaps partial) annotation being
468     *                   applied to the element
469     * @param member the annotation member to return possible completions for
470     * @param userText source code text to be completed
471     *
472     * @return suggested completions to the annotation
473     */
474     Iterable&lt;? extends Completion&gt; getCompletions(Element element,
475                                                   AnnotationMirror annotation,
476                                                   ExecutableElement member,
477                                                   String userText);
478 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.compiler/share/classes/javax/annotation/processing/AbstractProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../java.base/windows/native/libnio/fs/WindowsNativeDispatcher.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Filer.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.compiler/share/classes/javax/annotation/processing/AbstractProcessor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,10 ***</span>
<span class="line-new-header">--- 23,11 ---</span>
   * questions.
   */
  
  package javax.annotation.processing;
  
<span class="line-added">+ import java.util.List;</span>
  import java.util.Set;
  import java.util.HashSet;
  import java.util.Collections;
  import java.util.Objects;
  import javax.lang.model.element.*;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,14 ***</span>
       * @return the options recognized by this processor, or an empty
       * set if none
       */
      public Set&lt;String&gt; getSupportedOptions() {
          SupportedOptions so = this.getClass().getAnnotation(SupportedOptions.class);
<span class="line-modified">!         if  (so == null)</span>
<span class="line-modified">!             return Collections.emptySet();</span>
<span class="line-modified">!         else</span>
<span class="line-removed">-             return arrayToSet(so.value(), false);</span>
      }
  
      /**
       * If the processor class is annotated with {@link
       * SupportedAnnotationTypes}, return an unmodifiable set with the
<span class="line-new-header">--- 79,13 ---</span>
       * @return the options recognized by this processor, or an empty
       * set if none
       */
      public Set&lt;String&gt; getSupportedOptions() {
          SupportedOptions so = this.getClass().getAnnotation(SupportedOptions.class);
<span class="line-modified">!         return (so == null) ?</span>
<span class="line-modified">!             Set.of() :</span>
<span class="line-modified">!             arrayToSet(so.value(), false, &quot;option value&quot;, &quot;@SupportedOptions&quot;);</span>
      }
  
      /**
       * If the processor class is annotated with {@link
       * SupportedAnnotationTypes}, return an unmodifiable set with the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,16 ***</span>
                  if (initialized)
                      processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
                                                               &quot;No SupportedAnnotationTypes annotation &quot; +
                                                               &quot;found on &quot; + this.getClass().getName() +
                                                               &quot;, returning an empty set.&quot;);
<span class="line-modified">!                 return Collections.emptySet();</span>
              } else {
                  boolean stripModulePrefixes =
                          initialized &amp;&amp;
                          processingEnv.getSourceVersion().compareTo(SourceVersion.RELEASE_8) &lt;= 0;
<span class="line-modified">!                 return arrayToSet(sat.value(), stripModulePrefixes);</span>
              }
          }
  
      /**
       * If the processor class is annotated with {@link
<span class="line-new-header">--- 108,17 ---</span>
                  if (initialized)
                      processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
                                                               &quot;No SupportedAnnotationTypes annotation &quot; +
                                                               &quot;found on &quot; + this.getClass().getName() +
                                                               &quot;, returning an empty set.&quot;);
<span class="line-modified">!                 return Set.of();</span>
              } else {
                  boolean stripModulePrefixes =
                          initialized &amp;&amp;
                          processingEnv.getSourceVersion().compareTo(SourceVersion.RELEASE_8) &lt;= 0;
<span class="line-modified">!                 return arrayToSet(sat.value(), stripModulePrefixes,</span>
<span class="line-added">+                                   &quot;annotation type&quot;, &quot;@SupportedAnnotationTypes&quot;);</span>
              }
          }
  
      /**
       * If the processor class is annotated with {@link
</pre>
<hr />
<pre>
<span class="line-old-header">*** 179,11 ***</span>
       */
      public Iterable&lt;? extends Completion&gt; getCompletions(Element element,
                                                           AnnotationMirror annotation,
                                                           ExecutableElement member,
                                                           String userText) {
<span class="line-modified">!         return Collections.emptyList();</span>
      }
  
      /**
       * Returns {@code true} if this object has been {@linkplain #init
       * initialized}, {@code false} otherwise.
<span class="line-new-header">--- 180,11 ---</span>
       */
      public Iterable&lt;? extends Completion&gt; getCompletions(Element element,
                                                           AnnotationMirror annotation,
                                                           ExecutableElement member,
                                                           String userText) {
<span class="line-modified">!         return List.of();</span>
      }
  
      /**
       * Returns {@code true} if this object has been {@linkplain #init
       * initialized}, {@code false} otherwise.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,20 ***</span>
       */
      protected synchronized boolean isInitialized() {
          return initialized;
      }
  
<span class="line-modified">!     private static Set&lt;String&gt; arrayToSet(String[] array,</span>
<span class="line-modified">!                                           boolean stripModulePrefixes) {</span>
          assert array != null;
<span class="line-modified">!         Set&lt;String&gt; set = new HashSet&lt;&gt;(array.length);</span>
          for (String s : array) {
              if (stripModulePrefixes) {
                  int index = s.indexOf(&#39;/&#39;);
<span class="line-modified">!                 if (index != -1)</span>
                      s = s.substring(index + 1);
              }
<span class="line-removed">-             set.add(s);</span>
          }
          return Collections.unmodifiableSet(set);
      }
  }
<span class="line-new-header">--- 194,36 ---</span>
       */
      protected synchronized boolean isInitialized() {
          return initialized;
      }
  
<span class="line-modified">!     private Set&lt;String&gt; arrayToSet(String[] array,</span>
<span class="line-modified">!                                           boolean stripModulePrefixes,</span>
<span class="line-added">+                                    String contentType,</span>
<span class="line-added">+                                    String annotationName) {</span>
          assert array != null;
<span class="line-modified">!         Set&lt;String&gt; set = new HashSet&lt;&gt;();</span>
          for (String s : array) {
<span class="line-added">+             boolean stripped = false;</span>
              if (stripModulePrefixes) {
                  int index = s.indexOf(&#39;/&#39;);
<span class="line-modified">!                 if (index != -1) {</span>
                      s = s.substring(index + 1);
<span class="line-added">+                     stripped = true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             boolean added = set.add(s);</span>
<span class="line-added">+             // Don&#39;t issue a duplicate warning when the module name is</span>
<span class="line-added">+             // stripped off to avoid spurious warnings in a case like</span>
<span class="line-added">+             // &quot;foo/a.B&quot;, &quot;bar/a.B&quot;.</span>
<span class="line-added">+             if (!added &amp;&amp; !stripped &amp;&amp; isInitialized() ) {</span>
<span class="line-added">+                 processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,</span>
<span class="line-added">+                                                          &quot;Duplicate &quot; + contentType  +</span>
<span class="line-added">+                                                          &quot; ``&quot; + s  + &quot;&#39;&#39; for processor &quot; +</span>
<span class="line-added">+                                                          this.getClass().getName() +</span>
<span class="line-added">+                                                          &quot; in its &quot; + annotationName  +</span>
<span class="line-added">+                                                          &quot;annotation.&quot;);</span>
              }
          }
          return Collections.unmodifiableSet(set);
      }
  }
</pre>
<center><a href="../../../../../../java.base/windows/native/libnio/fs/WindowsNativeDispatcher.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Filer.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.compiler/share/classes/javax/lang/model/SourceVersion.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="AnnotatedConstruct.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="element/Element.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.compiler/share/classes/javax/lang/model/SourceVersion.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 56,12 ***</span>
       * 1.7: diamond syntax, try-with-resources, etc.
       * 1.8: lambda expressions and default methods
       *   9: modules, small cleanups to 1.7 and 1.8 changes
       *  10: local-variable type inference (var)
       *  11: local-variable syntax for lambda parameters
<span class="line-modified">!      *  12: TBD</span>
<span class="line-modified">!      *  13: TBD</span>
       */
  
      /**
       * The original version.
       *
<span class="line-new-header">--- 56,15 ---</span>
       * 1.7: diamond syntax, try-with-resources, etc.
       * 1.8: lambda expressions and default methods
       *   9: modules, small cleanups to 1.7 and 1.8 changes
       *  10: local-variable type inference (var)
       *  11: local-variable syntax for lambda parameters
<span class="line-modified">!      *  12: no changes (switch expressions in preview)</span>
<span class="line-modified">!      *  13: no changes (switch expressions and text blocks in preview)</span>
<span class="line-added">+      *  14: switch expressions (pattern matching and records in</span>
<span class="line-added">+      *      preview, text blocks in preview again)</span>
<span class="line-added">+      *  15: TBD</span>
       */
  
      /**
       * The original version.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,58 ***</span>
       * The version recognized by the Java Platform, Standard Edition
       * 13.
       *
       * @since 13
       */
<span class="line-modified">!      RELEASE_13;</span>
  
      // Note that when adding constants for newer releases, the
      // behavior of latest() and latestSupported() must be updated too.
  
      /**
       * Returns the latest source version that can be modeled.
       *
       * @return the latest source version that can be modeled
       */
      public static SourceVersion latest() {
<span class="line-modified">!         return RELEASE_13;</span>
      }
  
      private static final SourceVersion latestSupported = getLatestSupported();
  
      private static SourceVersion getLatestSupported() {
<span class="line-modified">!         try {</span>
<span class="line-modified">!             String specVersion = System.getProperty(&quot;java.specification.version&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             switch (specVersion) {</span>
<span class="line-removed">-                 case &quot;13&quot;:</span>
<span class="line-removed">-                     return RELEASE_13;</span>
<span class="line-removed">-                 case &quot;12&quot;:</span>
<span class="line-removed">-                     return RELEASE_12;</span>
<span class="line-removed">-                 case &quot;11&quot;:</span>
<span class="line-removed">-                     return RELEASE_11;</span>
<span class="line-removed">-                 case &quot;10&quot;:</span>
<span class="line-removed">-                     return RELEASE_10;</span>
<span class="line-removed">-                 case &quot;9&quot;:</span>
<span class="line-removed">-                     return RELEASE_9;</span>
<span class="line-removed">-                 case &quot;1.8&quot;:</span>
<span class="line-removed">-                     return RELEASE_8;</span>
<span class="line-removed">-                 case &quot;1.7&quot;:</span>
<span class="line-removed">-                     return RELEASE_7;</span>
<span class="line-removed">-                 case &quot;1.6&quot;:</span>
<span class="line-removed">-                     return RELEASE_6;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } catch (SecurityException se) {}</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return RELEASE_5;</span>
      }
  
      /**
       * Returns the latest source version fully supported by the
<span class="line-modified">!      * current execution environment.  {@code RELEASE_5} or later must</span>
       * be returned.
       *
       * @return the latest source version that is fully supported
       */
      public static SourceVersion latestSupported() {
          return latestSupported;
      }
<span class="line-new-header">--- 193,78 ---</span>
       * The version recognized by the Java Platform, Standard Edition
       * 13.
       *
       * @since 13
       */
<span class="line-modified">!      RELEASE_13,</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * The version recognized by the Java Platform, Standard Edition</span>
<span class="line-added">+      * 14.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Additions in this release include switch expressions.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @since 14</span>
<span class="line-added">+      */</span>
<span class="line-added">+     RELEASE_14,</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * The version recognized by the Java Platform, Standard Edition</span>
<span class="line-added">+      * 15.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @since 15</span>
<span class="line-added">+      */</span>
<span class="line-added">+      RELEASE_15;</span>
  
      // Note that when adding constants for newer releases, the
      // behavior of latest() and latestSupported() must be updated too.
  
      /**
       * Returns the latest source version that can be modeled.
       *
       * @return the latest source version that can be modeled
       */
      public static SourceVersion latest() {
<span class="line-modified">!         return RELEASE_15;</span>
      }
  
      private static final SourceVersion latestSupported = getLatestSupported();
  
<span class="line-added">+     /*</span>
<span class="line-added">+      * The integer version to enum constant mapping implemented by</span>
<span class="line-added">+      * this method assumes the JEP 322: &quot;Time-Based Release</span>
<span class="line-added">+      * Versioning&quot; scheme is in effect. This scheme began in JDK</span>
<span class="line-added">+      * 10. If the JDK versioning scheme is revised, this method may</span>
<span class="line-added">+      * need to be updated accordingly.</span>
<span class="line-added">+      */</span>
      private static SourceVersion getLatestSupported() {
<span class="line-modified">!         int intVersion = Runtime.version().feature();</span>
<span class="line-modified">!         return (intVersion &gt;= 11) ?</span>
<span class="line-modified">!             valueOf(&quot;RELEASE_&quot; + Math.min(15, intVersion)):</span>
<span class="line-modified">!             RELEASE_10;</span>
      }
  
      /**
       * Returns the latest source version fully supported by the
<span class="line-modified">!      * current execution environment.  {@code RELEASE_9} or later must</span>
       * be returned.
       *
<span class="line-added">+      * @apiNote This method is included alongside {@link latest} to</span>
<span class="line-added">+      * allow identification of situations where the language model API</span>
<span class="line-added">+      * is running on a platform version different than the latest</span>
<span class="line-added">+      * version modeled by the API. One way that sort of situation can</span>
<span class="line-added">+      * occur is if an IDE or similar tool is using the API to model</span>
<span class="line-added">+      * source version &lt;i&gt;N&lt;/i&gt; while running on platform version</span>
<span class="line-added">+      * (&lt;i&gt;N&lt;/i&gt;&amp;nbsp;-&amp;nbsp;1). Running in this configuration is</span>
<span class="line-added">+      * supported by the API. Running an API on platform versions</span>
<span class="line-added">+      * earlier than (&lt;i&gt;N&lt;/i&gt;&amp;nbsp;-&amp;nbsp;1) or later than &lt;i&gt;N&lt;/i&gt;</span>
<span class="line-added">+      * may or may not work as an implementation detail. If an</span>
<span class="line-added">+      * annotation processor was generating code to run under the</span>
<span class="line-added">+      * current execution environment, the processor should only use</span>
<span class="line-added">+      * platform features up to the {@code latestSupported} release,</span>
<span class="line-added">+      * which may be earlier than the {@code latest} release.</span>
<span class="line-added">+      *</span>
       * @return the latest source version that is fully supported
       */
      public static SourceVersion latestSupported() {
          return latestSupported;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,19 ***</span>
       * of an initial character for which {@link
       * Character#isJavaIdentifierStart(int)} returns {@code true},
       * followed only by characters for which {@link
       * Character#isJavaIdentifierPart(int)} returns {@code true}.
       * This pattern matches regular identifiers, keywords, restricted
<span class="line-modified">!      * keywords, and the literals {@code &quot;true&quot;}, {@code &quot;false&quot;},</span>
<span class="line-modified">!      * {@code &quot;null&quot;}, and {@code &quot;var&quot;}.</span>
       *
       * The method returns {@code false} for all other strings.
       *
       * @param name the string to check
       * @return {@code true} if this string is a
       * syntactically valid identifier or keyword, {@code false}
       * otherwise.
       */
      public static boolean isIdentifier(CharSequence name) {
          String id = name.toString();
  
          if (id.length() == 0) {
<span class="line-new-header">--- 276,21 ---</span>
       * of an initial character for which {@link
       * Character#isJavaIdentifierStart(int)} returns {@code true},
       * followed only by characters for which {@link
       * Character#isJavaIdentifierPart(int)} returns {@code true}.
       * This pattern matches regular identifiers, keywords, restricted
<span class="line-modified">!      * keywords, restricted identifiers and the literals {@code &quot;true&quot;},</span>
<span class="line-modified">!      * {@code &quot;false&quot;}, {@code &quot;null&quot;}.</span>
       *
       * The method returns {@code false} for all other strings.
       *
       * @param name the string to check
       * @return {@code true} if this string is a
       * syntactically valid identifier or keyword, {@code false}
       * otherwise.
<span class="line-added">+      *</span>
<span class="line-added">+      * @jls 3.8 Identifiers</span>
       */
      public static boolean isIdentifier(CharSequence name) {
          String id = name.toString();
  
          if (id.length() == 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,16 ***</span>
          return true;
      }
  
      /**
       * Returns whether or not {@code name} is a syntactically valid
<span class="line-modified">!      * qualified name in the latest source version.  Unlike {@link</span>
<span class="line-modified">!      * #isIdentifier isIdentifier}, this method returns {@code false}</span>
<span class="line-modified">!      * for keywords, boolean literals, and the null literal.</span>
       *
       * This method returns {@code true} for &lt;i&gt;restricted
<span class="line-modified">!      * keywords&lt;/i&gt; and {@code &quot;var&quot;}.</span>
       *
       * @param name the string to check
       * @return {@code true} if this string is a
       * syntactically valid name, {@code false} otherwise.
       * @jls 3.9 Keywords
<span class="line-new-header">--- 311,23 ---</span>
          return true;
      }
  
      /**
       * Returns whether or not {@code name} is a syntactically valid
<span class="line-modified">!      * qualified name in the latest source version.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * Syntactically, a qualified name is a sequence of identifiers</span>
<span class="line-added">+      * separated by period characters (&quot;{@code .}&quot;). This method</span>
<span class="line-added">+      * splits the input string into period-separated segments and</span>
<span class="line-added">+      * applies checks to each segment in turn.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Unlike {@link #isIdentifier isIdentifier}, this method returns</span>
<span class="line-added">+      * {@code false} for keywords, boolean literals, and the null</span>
<span class="line-added">+      * literal in any segment.</span>
       *
       * This method returns {@code true} for &lt;i&gt;restricted
<span class="line-modified">!      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;</span>
       *
       * @param name the string to check
       * @return {@code true} if this string is a
       * syntactically valid name, {@code false} otherwise.
       * @jls 3.9 Keywords
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,16 ***</span>
          return isName(name, latest());
      }
  
      /**
       * Returns whether or not {@code name} is a syntactically valid
<span class="line-modified">!      * qualified name in the given source version.  Unlike {@link</span>
<span class="line-modified">!      * #isIdentifier isIdentifier}, this method returns {@code false}</span>
<span class="line-modified">!      * for keywords, boolean literals, and the null literal.</span>
       *
       * This method returns {@code true} for &lt;i&gt;restricted
<span class="line-modified">!      * keywords&lt;/i&gt; and {@code &quot;var&quot;}.</span>
       *
       * @param name the string to check
       * @param version the version to use
       * @return {@code true} if this string is a
       * syntactically valid name, {@code false} otherwise.
<span class="line-new-header">--- 337,23 ---</span>
          return isName(name, latest());
      }
  
      /**
       * Returns whether or not {@code name} is a syntactically valid
<span class="line-modified">!      * qualified name in the given source version.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * Syntactically, a qualified name is a sequence of identifiers</span>
<span class="line-added">+      * separated by period characters (&quot;{@code .}&quot;). This method</span>
<span class="line-added">+      * splits the input string into period-separated segments and</span>
<span class="line-added">+      * applies checks to each segment in turn.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Unlike {@link #isIdentifier isIdentifier}, this method returns</span>
<span class="line-added">+      * {@code false} for keywords, boolean literals, and the null</span>
<span class="line-added">+      * literal in any segment.</span>
       *
       * This method returns {@code true} for &lt;i&gt;restricted
<span class="line-modified">!      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;</span>
       *
       * @param name the string to check
       * @param version the version to use
       * @return {@code true} if this string is a
       * syntactically valid name, {@code false} otherwise.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 334,11 ***</span>
  
      /**
       * Returns whether or not {@code s} is a keyword, boolean literal,
       * or null literal in the latest source version.
       * This method returns {@code false} for &lt;i&gt;restricted
<span class="line-modified">!      * keywords&lt;/i&gt; and {@code &quot;var&quot;}.</span>
       *
       * @param s the string to check
       * @return {@code true} if {@code s} is a keyword, or boolean
       * literal, or null literal, {@code false} otherwise.
       * @jls 3.9 Keywords
<span class="line-new-header">--- 373,11 ---</span>
  
      /**
       * Returns whether or not {@code s} is a keyword, boolean literal,
       * or null literal in the latest source version.
       * This method returns {@code false} for &lt;i&gt;restricted
<span class="line-modified">!      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;.</span>
       *
       * @param s the string to check
       * @return {@code true} if {@code s} is a keyword, or boolean
       * literal, or null literal, {@code false} otherwise.
       * @jls 3.9 Keywords
</pre>
<hr />
<pre>
<span class="line-old-header">*** 351,11 ***</span>
  
      /**
       * Returns whether or not {@code s} is a keyword, boolean literal,
       * or null literal in the given source version.
       * This method returns {@code false} for &lt;i&gt;restricted
<span class="line-modified">!      * keywords&lt;/i&gt; and {@code &quot;var&quot;}.</span>
       *
       * @param s the string to check
       * @param version the version to use
       * @return {@code true} if {@code s} is a keyword, or boolean
       * literal, or null literal, {@code false} otherwise.
<span class="line-new-header">--- 390,11 ---</span>
  
      /**
       * Returns whether or not {@code s} is a keyword, boolean literal,
       * or null literal in the given source version.
       * This method returns {@code false} for &lt;i&gt;restricted
<span class="line-modified">!      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;.</span>
       *
       * @param s the string to check
       * @param version the version to use
       * @return {@code true} if {@code s} is a keyword, or boolean
       * literal, or null literal, {@code false} otherwise.
</pre>
<center><a href="AnnotatedConstruct.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="element/Element.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
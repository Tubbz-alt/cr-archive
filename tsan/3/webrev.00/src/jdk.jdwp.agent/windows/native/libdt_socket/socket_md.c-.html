<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdwp.agent/windows/native/libdt_socket/socket_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 #include &lt;windows.h&gt;
 26 #include &lt;winsock2.h&gt;
 27 #include &lt;ws2tcpip.h&gt;
 28 
 29 #include &quot;sysSocket.h&quot;
 30 #include &quot;socketTransport.h&quot;
 31 
 32 typedef jboolean bool_t;
 33 
 34 /*
 35  * Table of Windows Sockets errors, the specific exception we
 36  * throw for the error, and the error text.
 37  *
 38  * Note that this table excludes OS dependent errors.
 39  */
 40 static struct {
 41     int errCode;
 42     const char *errString;
 43 } const winsock_errors[] = {
 44     { WSAEPROVIDERFAILEDINIT,   &quot;Provider initialization failed (check %SystemRoot%)&quot; },
 45     { WSAEACCES,                &quot;Permission denied&quot; },
 46     { WSAEADDRINUSE,            &quot;Address already in use&quot; },
 47     { WSAEADDRNOTAVAIL,         &quot;Cannot assign requested address&quot; },
 48     { WSAEAFNOSUPPORT,          &quot;Address family not supported by protocol family&quot; },
 49     { WSAEALREADY,              &quot;Operation already in progress&quot; },
 50     { WSAECONNABORTED,          &quot;Software caused connection abort&quot; },
 51     { WSAECONNREFUSED,          &quot;Connection refused&quot; },
 52     { WSAECONNRESET,            &quot;Connection reset by peer&quot; },
 53     { WSAEDESTADDRREQ,          &quot;Destination address required&quot; },
 54     { WSAEFAULT,                &quot;Bad address&quot; },
 55     { WSAEHOSTDOWN,             &quot;Host is down&quot; },
 56     { WSAEHOSTUNREACH,          &quot;No route to host&quot; },
 57     { WSAEINPROGRESS,           &quot;Operation now in progress&quot; },
 58     { WSAEINTR,                 &quot;Interrupted function call&quot; },
 59     { WSAEINVAL,                &quot;Invalid argument&quot; },
 60     { WSAEISCONN,               &quot;Socket is already connected&quot; },
 61     { WSAEMFILE,                &quot;Too many open files&quot; },
 62     { WSAEMSGSIZE,              &quot;The message is larger than the maximum supported by the underlying transport&quot; },
 63     { WSAENETDOWN,              &quot;Network is down&quot; },
 64     { WSAENETRESET,             &quot;Network dropped connection on reset&quot; },
 65     { WSAENETUNREACH,           &quot;Network is unreachable&quot; },
 66     { WSAENOBUFS,               &quot;No buffer space available (maximum connections reached?)&quot; },
 67     { WSAENOPROTOOPT,           &quot;Bad protocol option&quot; },
 68     { WSAENOTCONN,              &quot;Socket is not connected&quot; },
 69     { WSAENOTSOCK,              &quot;Socket operation on nonsocket&quot; },
 70     { WSAEOPNOTSUPP,            &quot;Operation not supported&quot; },
 71     { WSAEPFNOSUPPORT,          &quot;Protocol family not supported&quot; },
 72     { WSAEPROCLIM,              &quot;Too many processes&quot; },
 73     { WSAEPROTONOSUPPORT,       &quot;Protocol not supported&quot; },
 74     { WSAEPROTOTYPE,            &quot;Protocol wrong type for socket&quot; },
 75     { WSAESHUTDOWN,             &quot;Cannot send after socket shutdown&quot; },
 76     { WSAESOCKTNOSUPPORT,       &quot;Socket type not supported&quot; },
 77     { WSAETIMEDOUT,             &quot;Connection timed out&quot; },
 78     { WSATYPE_NOT_FOUND,        &quot;Class type not found&quot; },
 79     { WSAEWOULDBLOCK,           &quot;Resource temporarily unavailable&quot; },
 80     { WSAHOST_NOT_FOUND,        &quot;Host not found&quot; },
 81     { WSA_NOT_ENOUGH_MEMORY,    &quot;Insufficient memory available&quot; },
 82     { WSANOTINITIALISED,        &quot;Successful WSAStartup not yet performed&quot; },
 83     { WSANO_DATA,               &quot;Valid name, no data record of requested type&quot; },
 84     { WSANO_RECOVERY,           &quot;This is a nonrecoverable error&quot; },
 85     { WSASYSNOTREADY,           &quot;Network subsystem is unavailable&quot; },
 86     { WSATRY_AGAIN,             &quot;Nonauthoritative host not found&quot; },
 87     { WSAVERNOTSUPPORTED,       &quot;Winsock.dll version out of range&quot; },
 88     { WSAEDISCON,               &quot;Graceful shutdown in progress&quot; },
 89     { WSA_OPERATION_ABORTED,    &quot;Overlapped operation aborted&quot; },
 90 };
 91 
 92 
 93 /*
 94  * Initialize Windows Sockets API support
 95  */
 96 BOOL WINAPI
 97 DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved)
 98 {
 99     WSADATA wsadata;
100 
101     switch (reason) {
102         case DLL_PROCESS_ATTACH:
103             if (WSAStartup(MAKEWORD(2,2), &amp;wsadata) != 0) {
104                 return FALSE;
105             }
106             break;
107 
108         case DLL_PROCESS_DETACH:
109             WSACleanup();
110             break;
111 
112         default:
113             break;
114     }
115     return TRUE;
116 }
117 
118 /*
119  * If we get a nonnull function pointer it might still be the case
120  * that some other thread is in the process of initializing the socket
121  * function pointer table, but our pointer should still be good.
122  */
123 int
124 dbgsysListen(int fd, int backlog) {
125     return listen(fd, backlog);
126 }
127 
128 int
129 dbgsysConnect(int fd, struct sockaddr *name, socklen_t namelen) {
130     int rv = connect(fd, name, namelen);
131     if (rv == SOCKET_ERROR) {
132         if (WSAGetLastError() == WSAEINPROGRESS || WSAGetLastError() == WSAEWOULDBLOCK) {
133             return DBG_EINPROGRESS;
134         }
135     }
136     return rv;
137 }
138 
139 int dbgsysFinishConnect(int fd, int timeout) {
140     int rv;
141     struct timeval t;
142     fd_set wr, ex;
143 
144     t.tv_sec = timeout / 1000;
145     t.tv_usec = (timeout % 1000) * 1000;
146 
147     FD_ZERO(&amp;wr);
148     FD_ZERO(&amp;ex);
149     FD_SET((unsigned int)fd, &amp;wr);
150     FD_SET((unsigned int)fd, &amp;ex);
151 
152     rv = select(fd+1, 0, &amp;wr, &amp;ex, &amp;t);
153     if (rv == 0) {
154         return SYS_ERR;     /* timeout */
155     }
156 
157     /*
158      * Check if there was an error - this is preferable to check if
159      * the socket is writable because some versions of Windows don&#39;t
160      * report a connected socket as being writable.
161      */
162     if (!FD_ISSET(fd, &amp;ex)) {
163         return SYS_OK;
164     }
165 
166     /*
167      * Unable to establish connection - to get the reason we must
168      * call getsockopt.
169      */
170     return SYS_ERR;
171 }
172 
173 
174 int
175 dbgsysAccept(int fd, struct sockaddr *name, socklen_t *namelen) {
176     return (int)accept(fd, name, namelen);
177 }
178 
179 int
180 dbgsysRecvFrom(int fd, char *buf, size_t nBytes,
181                   int flags, struct sockaddr *from, socklen_t *fromlen) {
182     return recvfrom(fd, buf, (int)nBytes, flags, from, fromlen);
183 }
184 
185 int
186 dbgsysSendTo(int fd, char *buf, size_t len,
187                 int flags, struct sockaddr *to, socklen_t tolen) {
188     return sendto(fd, buf, (int)len, flags, to, tolen);
189 }
190 
191 int
192 dbgsysRecv(int fd, char *buf, size_t nBytes, int flags) {
193     return recv(fd, buf, (int) nBytes, flags);
194 }
195 
196 int
197 dbgsysSend(int fd, char *buf, size_t nBytes, int flags) {
198     return send(fd, buf, (int)nBytes, flags);
199 }
200 
201 int
202 dbgsysGetAddrInfo(char *hostname, char *service,
203                   struct addrinfo *hints,
204                   struct addrinfo **result) {
205   return getaddrinfo(hostname, service, hints, result);
206 }
207 
208 unsigned short
209 dbgsysHostToNetworkShort(unsigned short hostshort) {
210     return htons(hostshort);
211 }
212 
213 int
214 dbgsysSocket(int domain, int type, int protocol) {
215   int fd = (int)socket(domain, type, protocol);
216   if (fd != SOCKET_ERROR) {
217       SetHandleInformation((HANDLE)(UINT_PTR)fd, HANDLE_FLAG_INHERIT, FALSE);
218   }
219   return fd;
220 }
221 
222 int
223 dbgsysSocketClose(int fd) {
224     struct linger l;
225     int len = sizeof(l);
226 
227     if (getsockopt(fd, SOL_SOCKET, SO_LINGER, (char *)&amp;l, &amp;len) == 0) {
228         if (l.l_onoff == 0) {
229             shutdown(fd, SD_SEND);
230         }
231     }
232     return closesocket(fd);
233 }
234 
235 /* Additions to original follow */
236 
237 int
238 dbgsysBind(int fd, struct sockaddr *name, socklen_t namelen) {
239     return bind(fd, name, namelen);
240 }
241 
242 
243 uint32_t
244 dbgsysInetAddr(const char* cp) {
245     uint32_t addr;
246     if (inet_pton(AF_INET, cp, &amp;addr) &lt; 1) {
247       return -1;
248     }
249     return addr;
250 }
251 
252 uint32_t
253 dbgsysHostToNetworkLong(uint32_t hostlong) {
254     return (uint32_t)htonl((u_long)hostlong);
255 }
256 
257 unsigned short
258 dbgsysNetworkToHostShort(unsigned short netshort) {
259     return ntohs(netshort);
260 }
261 
262 int
263 dbgsysGetSocketName(int fd, struct sockaddr *name, socklen_t *namelen) {
264     return getsockname(fd, name, namelen);
265 }
266 
267 uint32_t
268 dbgsysNetworkToHostLong(uint32_t netlong) {
269     return (uint32_t)ntohl((u_long)netlong);
270 }
271 
272 /*
273  * Below Adapted from PlainSocketImpl.c, win32 version 1.18. Changed exception
274  * throws to returns of SYS_ERR; we should improve the error codes
275  * eventually. Changed java objects to values the debugger back end can
276  * more easily deal with.
277  */
278 
279 int
280 dbgsysSetSocketOption(int fd, jint cmd, jboolean on, jvalue value)
281 {
282     if (cmd == TCP_NODELAY) {
283         struct protoent *proto = getprotobyname(&quot;TCP&quot;);
284         int tcp_level = (proto == 0 ? IPPROTO_TCP: proto-&gt;p_proto);
285         long onl = (long)on;
286 
287         if (setsockopt(fd, tcp_level, TCP_NODELAY,
288                        (char *)&amp;onl, sizeof(long)) &lt; 0) {
289                 return SYS_ERR;
290         }
291     } else if (cmd == SO_LINGER) {
292         struct linger arg;
293         arg.l_onoff = on;
294 
295         if(on) {
296             arg.l_linger = (unsigned short)value.i;
297             if(setsockopt(fd, SOL_SOCKET, SO_LINGER,
298                           (char*)&amp;arg, sizeof(arg)) &lt; 0) {
299                 return SYS_ERR;
300             }
301         } else {
302             if (setsockopt(fd, SOL_SOCKET, SO_LINGER,
303                            (char*)&amp;arg, sizeof(arg)) &lt; 0) {
304                 return SYS_ERR;
305             }
306         }
307     } else if (cmd == SO_SNDBUF) {
308         jint buflen = value.i;
309         if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF,
310                        (char *)&amp;buflen, sizeof(buflen)) &lt; 0) {
311             return SYS_ERR;
312         }
313     } else if (cmd == SO_REUSEADDR) {
314         /*
315          * On Windows the SO_REUSEADDR socket option doesn&#39;t implement
316          * BSD semantics. Specifically, the socket option allows multiple
317          * processes to bind to the same address/port rather than allowing
318          * a process to bind with a previous connection in the TIME_WAIT
319          * state. Hence on Windows we never enable this option for TCP
320          * option.
321          */
322         int sotype, arglen=sizeof(sotype);
323         if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&amp;sotype, &amp;arglen) == SOCKET_ERROR) {
324             return SYS_ERR;
325         }
326         if (sotype != SOCK_STREAM) {
327             int oni = (int)on;
328             if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,
329                        (char *)&amp;oni, sizeof(oni)) == SOCKET_ERROR) {
330                 return SYS_ERR;
331             }
332         }
333     } else {
334         return SYS_ERR;
335     }
336     return SYS_OK;
337 }
338 
339 int dbgsysConfigureBlocking(int fd, jboolean blocking) {
340     u_long argp;
341     int result = 0;
342 
343     if (blocking == JNI_FALSE) {
344         argp = 1;
345     } else {
346         argp = 0;
347     }
348     result = ioctlsocket(fd, FIONBIO, &amp;argp);
349     if (result == SOCKET_ERROR) {
350         return SYS_ERR;
351     } else {
352         return SYS_OK;
353     }
354 }
355 
356 int
357 dbgsysPoll(int fd, jboolean rd, jboolean wr, long timeout) {
358     int rv;
359     struct timeval t;
360     fd_set rd_tbl, wr_tbl;
361 
362     t.tv_sec = timeout / 1000;
363     t.tv_usec = (timeout % 1000) * 1000;
364 
365     FD_ZERO(&amp;rd_tbl);
366     if (rd) {
367         FD_SET((unsigned int)fd, &amp;rd_tbl);
368     }
369 
370     FD_ZERO(&amp;wr_tbl);
371     if (wr) {
372         FD_SET((unsigned int)fd, &amp;wr_tbl);
373     }
374 
375     rv = select(fd+1, &amp;rd_tbl, &amp;wr_tbl, 0, &amp;t);
376     if (rv &gt;= 0) {
377         rv = 0;
378         if (FD_ISSET(fd, &amp;rd_tbl)) {
379             rv |= DBG_POLLIN;
380         }
381         if (FD_ISSET(fd, &amp;wr_tbl)) {
382             rv |= DBG_POLLOUT;
383         }
384     }
385     return rv;
386 }
387 
388 int
389 dbgsysGetLastIOError(char *buf, jint size) {
390     int table_size = sizeof(winsock_errors) /
391                      sizeof(winsock_errors[0]);
392     int i;
393     int error = WSAGetLastError();
394 
395     /*
396      * Check table for known winsock errors
397      */
398     i=0;
399     while (i &lt; table_size) {
400         if (error == winsock_errors[i].errCode) {
401             break;
402         }
403         i++;
404     }
405 
406     if (i &lt; table_size) {
407         strcpy(buf, winsock_errors[i].errString);
408     } else {
409         sprintf(buf, &quot;winsock error %d&quot;, error);
410     }
411     return 0;
412 }
413 
414 
415 int
416 dbgsysTlsAlloc() {
417     return TlsAlloc();
418 }
419 
420 void
421 dbgsysTlsFree(int index) {
422     TlsFree(index);
423 }
424 
425 void
426 dbgsysTlsPut(int index, void *value) {
427     TlsSetValue(index, value);
428 }
429 
430 void *
431 dbgsysTlsGet(int index) {
432     return TlsGetValue(index);
433 }
434 
435 #define FT2INT64(ft) \
436         ((INT64)(ft).dwHighDateTime &lt;&lt; 32 | (INT64)(ft).dwLowDateTime)
437 
438 long
439 dbgsysCurrentTimeMillis() {
440     static long fileTime_1_1_70 = 0;    /* midnight 1/1/70 */
441     SYSTEMTIME st0;
442     FILETIME   ft0;
443 
444     /* initialize on first usage */
445     if (fileTime_1_1_70 == 0) {
446         memset(&amp;st0, 0, sizeof(st0));
447         st0.wYear  = 1970;
448         st0.wMonth = 1;
449         st0.wDay   = 1;
450         SystemTimeToFileTime(&amp;st0, &amp;ft0);
451         fileTime_1_1_70 = FT2INT64(ft0);
452     }
453 
454     GetSystemTime(&amp;st0);
455     SystemTimeToFileTime(&amp;st0, &amp;ft0);
456 
457     return (FT2INT64(ft0) - fileTime_1_1_70) / 10000;
458 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jdwp.agent/share/native/libdt_socket/socketTransport.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;stdio.h&gt;
  26 #include &lt;string.h&gt;
  27 #include &lt;errno.h&gt;
  28 #include &lt;stdlib.h&gt;
  29 #include &lt;ctype.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jdwpTransport.h&quot;
  33 #include &quot;sysSocket.h&quot;
  34 
  35 #ifdef _WIN32
  36  #include &lt;winsock2.h&gt;
  37  #include &lt;ws2tcpip.h&gt;
<a name="2" id="anc2"></a>
  38 #else
  39  #include &lt;arpa/inet.h&gt;
  40  #include &lt;sys/socket.h&gt;
<a name="3" id="anc3"></a>
  41 #endif
  42 
  43 /*
  44  * The Socket Transport Library.
  45  *
  46  * This module is an implementation of the Java Debug Wire Protocol Transport
  47  * Service Provider Interface - see src/share/javavm/export/jdwpTransport.h.
  48  */
  49 
<a name="4" id="anc4"></a><span class="line-modified">  50 static int serverSocketFD;</span>
  51 static int socketFD = -1;
  52 static jdwpTransportCallback *callback;
  53 static JavaVM *jvm;
  54 static int tlsIndex;
  55 static jboolean initialized;
  56 static struct jdwpTransportNativeInterface_ interface;
  57 static jdwpTransportEnv single_env = (jdwpTransportEnv)&amp;interface;
  58 
  59 #define RETURN_ERROR(err, msg) \
  60         if (1==1) { \
  61             setLastError(err, msg); \
  62             return err; \
  63         }
  64 
  65 #define RETURN_IO_ERROR(msg)    RETURN_ERROR(JDWPTRANSPORT_ERROR_IO_ERROR, msg);
  66 
  67 #define RETURN_RECV_ERROR(n) \
  68         if (n == 0) { \
  69             RETURN_ERROR(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;premature EOF&quot;); \
  70         } else { \
  71             RETURN_IO_ERROR(&quot;recv error&quot;); \
  72         }
  73 
  74 #define MAX_DATA_SIZE 1000
  75 
  76 static jint recv_fully(int, char *, int);
  77 static jint send_fully(int, char *, int);
  78 
  79 /* version &gt;= JDWPTRANSPORT_VERSION_1_1 */
  80 typedef struct {
<a name="5" id="anc5"></a><span class="line-modified">  81     uint32_t subnet;</span>
<span class="line-modified">  82     uint32_t netmask;</span>

  83 } AllowedPeerInfo;
  84 
  85 #define STR(x) #x
  86 #define MAX_PEER_ENTRIES 32
  87 #define MAX_PEERS_STR STR(MAX_PEER_ENTRIES)
  88 static AllowedPeerInfo _peers[MAX_PEER_ENTRIES];
  89 static int _peers_cnt = 0;
  90 
  91 
<a name="6" id="anc6"></a>


  92 /*
  93  * Record the last error for this thread.
  94  */
  95 static void
  96 setLastError(jdwpTransportError err, char *newmsg) {
  97     char buf[255];
  98     char *msg;
  99 
 100     /* get any I/O first in case any system calls override errno */
 101     if (err == JDWPTRANSPORT_ERROR_IO_ERROR) {
 102         dbgsysGetLastIOError(buf, sizeof(buf));
 103     }
 104 
 105     msg = (char *)dbgsysTlsGet(tlsIndex);
 106     if (msg != NULL) {
 107         (*callback-&gt;free)(msg);
 108     }
 109 
 110     if (err == JDWPTRANSPORT_ERROR_IO_ERROR) {
 111         char *join_str = &quot;: &quot;;
 112         int msg_len = (int)strlen(newmsg) + (int)strlen(join_str) +
 113                       (int)strlen(buf) + 3;
 114         msg = (*callback-&gt;alloc)(msg_len);
 115         if (msg != NULL) {
 116             strcpy(msg, newmsg);
 117             strcat(msg, join_str);
 118             strcat(msg, buf);
 119         }
 120     } else {
 121         msg = (*callback-&gt;alloc)((int)strlen(newmsg)+1);
 122         if (msg != NULL) {
 123             strcpy(msg, newmsg);
 124         }
 125     }
 126 
 127     dbgsysTlsPut(tlsIndex, msg);
 128 }
 129 
 130 /*
 131  * Return the last error for this thread (may be NULL)
 132  */
 133 static char*
 134 getLastError() {
 135     return (char *)dbgsysTlsGet(tlsIndex);
 136 }
 137 
 138 /* Set options common to client and server sides */
 139 static jdwpTransportError
<a name="7" id="anc7"></a><span class="line-modified"> 140 setOptionsCommon(int fd)</span>
 141 {
 142     jvalue dontcare;
 143     int err;
 144 
<a name="8" id="anc8"></a><span class="line-modified"> 145     dontcare.i = 0;  /* keep compiler happy */</span>





 146 
<a name="9" id="anc9"></a>
 147     err = dbgsysSetSocketOption(fd, TCP_NODELAY, JNI_TRUE, dontcare);
 148     if (err &lt; 0) {
 149         RETURN_IO_ERROR(&quot;setsockopt TCPNODELAY failed&quot;);
 150     }
 151 
 152     return JDWPTRANSPORT_ERROR_NONE;
 153 }
 154 
 155 /* Set the SO_REUSEADDR option */
 156 static jdwpTransportError
 157 setReuseAddrOption(int fd)
 158 {
 159     jvalue dontcare;
 160     int err;
 161 
 162     dontcare.i = 0;  /* keep compiler happy */
 163 
 164     err = dbgsysSetSocketOption(fd, SO_REUSEADDR, JNI_TRUE, dontcare);
 165     if (err &lt; 0) {
 166         RETURN_IO_ERROR(&quot;setsockopt SO_REUSEADDR failed&quot;);
 167     }
 168 
 169     return JDWPTRANSPORT_ERROR_NONE;
 170 }
 171 
 172 static jdwpTransportError
 173 handshake(int fd, jlong timeout) {
 174     const char *hello = &quot;JDWP-Handshake&quot;;
 175     char b[16];
 176     int rv, helloLen, received;
 177 
 178     if (timeout &gt; 0) {
 179         dbgsysConfigureBlocking(fd, JNI_FALSE);
 180     }
 181     helloLen = (int)strlen(hello);
 182     received = 0;
 183     while (received &lt; helloLen) {
 184         int n;
 185         char *buf;
 186         if (timeout &gt; 0) {
 187             rv = dbgsysPoll(fd, JNI_TRUE, JNI_FALSE, (long)timeout);
 188             if (rv &lt;= 0) {
 189                 setLastError(0, &quot;timeout during handshake&quot;);
 190                 return JDWPTRANSPORT_ERROR_IO_ERROR;
 191             }
 192         }
 193         buf = b;
 194         buf += received;
 195         n = recv_fully(fd, buf, helloLen-received);
 196         if (n == 0) {
 197             setLastError(0, &quot;handshake failed - connection prematurally closed&quot;);
 198             return JDWPTRANSPORT_ERROR_IO_ERROR;
 199         }
 200         if (n &lt; 0) {
 201             RETURN_IO_ERROR(&quot;recv failed during handshake&quot;);
 202         }
 203         received += n;
 204     }
 205     if (timeout &gt; 0) {
 206         dbgsysConfigureBlocking(fd, JNI_TRUE);
 207     }
 208     if (strncmp(b, hello, received) != 0) {
 209         char msg[80+2*16];
 210         b[received] = &#39;\0&#39;;
 211         /*
 212          * We should really use snprintf here but it&#39;s not available on Windows.
 213          * We can&#39;t use jio_snprintf without linking the transport against the VM.
 214          */
 215         sprintf(msg, &quot;handshake failed - received &gt;%s&lt; - expected &gt;%s&lt;&quot;, b, hello);
 216         setLastError(0, msg);
 217         return JDWPTRANSPORT_ERROR_IO_ERROR;
 218     }
 219 
 220     if (send_fully(fd, (char*)hello, helloLen) != helloLen) {
 221         RETURN_IO_ERROR(&quot;send failed during handshake&quot;);
 222     }
 223     return JDWPTRANSPORT_ERROR_NONE;
 224 }
 225 
<a name="10" id="anc10"></a><span class="line-removed"> 226 static uint32_t</span>
<span class="line-removed"> 227 getLocalHostAddress() {</span>
<span class="line-removed"> 228     // Simple routine to guess localhost address.</span>
<span class="line-removed"> 229     // it looks up &quot;localhost&quot; and returns 127.0.0.1 if lookup</span>
<span class="line-removed"> 230     // fails.</span>
<span class="line-removed"> 231     struct addrinfo hints, *res = NULL;</span>
<span class="line-removed"> 232     uint32_t addr;</span>
<span class="line-removed"> 233     int err;</span>
<span class="line-removed"> 234 </span>
<span class="line-removed"> 235     // Use portable way to initialize the structure</span>
<span class="line-removed"> 236     memset((void *)&amp;hints, 0, sizeof(hints));</span>
<span class="line-removed"> 237     hints.ai_family = AF_INET;</span>
<span class="line-removed"> 238 </span>
<span class="line-removed"> 239     err = getaddrinfo(&quot;localhost&quot;, NULL, &amp;hints, &amp;res);</span>
<span class="line-removed"> 240     if (err &lt; 0 || res == NULL) {</span>
<span class="line-removed"> 241         return dbgsysHostToNetworkLong(INADDR_LOOPBACK);</span>
<span class="line-removed"> 242     }</span>
<span class="line-removed"> 243 </span>
<span class="line-removed"> 244     // getaddrinfo might return more than one address</span>
<span class="line-removed"> 245     // but we are using first one only</span>
<span class="line-removed"> 246     addr = ((struct sockaddr_in *)(res-&gt;ai_addr))-&gt;sin_addr.s_addr;</span>
<span class="line-removed"> 247     freeaddrinfo(res);</span>
<span class="line-removed"> 248     return addr;</span>
<span class="line-removed"> 249 }</span>
<span class="line-removed"> 250 </span>
 251 static int
 252 getPortNumber(const char *s_port) {
 253     u_long n;
 254     char *eptr;
 255 
 256     if (*s_port == 0) {
 257         // bad address - colon with no port number in parameters
 258         return -1;
 259     }
 260 
 261     n = strtoul(s_port, &amp;eptr, 10);
 262     if (eptr != s_port + strlen(s_port)) {
 263         // incomplete conversion - port number contains non-digit
 264         return -1;
 265     }
 266 
 267     if (n &gt; (u_short) -1) {
 268         // check that value supplied by user is less than
 269         // maximum possible u_short value (65535) and
 270         // will not be truncated later.
 271         return -1;
 272     }
 273 
 274     return n;
 275 }
 276 
<a name="11" id="anc11"></a><span class="line-modified"> 277 static jdwpTransportError</span>
<span class="line-modified"> 278 parseAddress(const char *address, struct sockaddr_in *sa) {</span>
<span class="line-modified"> 279     char *colon;</span>
<span class="line-modified"> 280     int port;</span>
<span class="line-modified"> 281 </span>
<span class="line-modified"> 282     memset((void *)sa, 0, sizeof(struct sockaddr_in));</span>
<span class="line-removed"> 283     sa-&gt;sin_family = AF_INET;</span>
 284 
<a name="12" id="anc12"></a><span class="line-modified"> 285     /* check for host:port or port */</span>
<span class="line-modified"> 286     colon = strchr(address, &#39;:&#39;);</span>
<span class="line-modified"> 287     port = getPortNumber((colon == NULL) ? address : colon +1);</span>
<span class="line-modified"> 288     if (port &lt; 0) {</span>
<span class="line-modified"> 289         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;invalid port number specified&quot;);</span>











 290     }
<a name="13" id="anc13"></a><span class="line-modified"> 291     sa-&gt;sin_port = dbgsysHostToNetworkShort((u_short)port);</span>
<span class="line-modified"> 292 </span>
<span class="line-modified"> 293     if (colon == NULL) {</span>
<span class="line-modified"> 294         // bind to localhost only if no address specified</span>
<span class="line-modified"> 295         sa-&gt;sin_addr.s_addr = getLocalHostAddress();</span>
<span class="line-modified"> 296     } else if (strncmp(address, &quot;localhost:&quot;, 10) == 0) {</span>
<span class="line-modified"> 297         // optimize for common case</span>
<span class="line-modified"> 298         sa-&gt;sin_addr.s_addr = getLocalHostAddress();</span>
<span class="line-modified"> 299     } else if (*address == &#39;*&#39; &amp;&amp; *(address+1) == &#39;:&#39;) {</span>
<span class="line-modified"> 300         // we are explicitly asked to bind server to all available IP addresses</span>
<span class="line-modified"> 301         // has no meaning for client.</span>
<span class="line-modified"> 302         sa-&gt;sin_addr.s_addr = dbgsysHostToNetworkLong(INADDR_ANY);</span>
<span class="line-modified"> 303      } else {</span>
<span class="line-modified"> 304         char *buf;</span>
<span class="line-modified"> 305         char *hostname;</span>
<span class="line-modified"> 306         uint32_t addr;</span>
<span class="line-modified"> 307         int ai;</span>
<span class="line-modified"> 308         buf = (*callback-&gt;alloc)((int)strlen(address) + 1);</span>
<span class="line-modified"> 309         if (buf == NULL) {</span>












 310             RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
 311         }
<a name="14" id="anc14"></a><span class="line-modified"> 312         strcpy(buf, address);</span>
<span class="line-modified"> 313         buf[colon - address] = &#39;\0&#39;;</span>
<span class="line-modified"> 314         hostname = buf;</span>
<span class="line-modified"> 315 </span>
<span class="line-modified"> 316         /*</span>
<span class="line-modified"> 317          * First see if the host is a literal IP address.</span>
<span class="line-modified"> 318          * If not then try to resolve it.</span>
<span class="line-modified"> 319          */</span>
<span class="line-modified"> 320         addr = dbgsysInetAddr(hostname);</span>
<span class="line-modified"> 321         if (addr == 0xffffffff) {</span>
<span class="line-modified"> 322             struct addrinfo hints;</span>
<span class="line-modified"> 323             struct addrinfo *results = NULL;</span>
<span class="line-removed"> 324             memset (&amp;hints, 0, sizeof(hints));</span>
<span class="line-removed"> 325             hints.ai_family = AF_INET;</span>
<span class="line-removed"> 326             hints.ai_socktype = SOCK_STREAM;</span>
<span class="line-removed"> 327             hints.ai_protocol = IPPROTO_TCP;</span>
<span class="line-removed"> 328 </span>
<span class="line-removed"> 329             ai = dbgsysGetAddrInfo(hostname, NULL, &amp;hints, &amp;results);</span>
<span class="line-removed"> 330 </span>
<span class="line-removed"> 331             if (ai != 0) {</span>
<span class="line-removed"> 332                 /* don&#39;t use RETURN_IO_ERROR as unknown host is normal */</span>
<span class="line-removed"> 333                 setLastError(0, &quot;getaddrinfo: unknown host&quot;);</span>
<span class="line-removed"> 334                 (*callback-&gt;free)(buf);</span>
<span class="line-removed"> 335                 return JDWPTRANSPORT_ERROR_IO_ERROR;</span>
 336             }
<a name="15" id="anc15"></a>

 337 
<a name="16" id="anc16"></a><span class="line-modified"> 338             /* lookup was successful */</span>
<span class="line-modified"> 339             sa-&gt;sin_addr =  ((struct sockaddr_in *)results-&gt;ai_addr)-&gt;sin_addr;</span>
<span class="line-modified"> 340             freeaddrinfo(results);</span>
<span class="line-modified"> 341         } else {</span>
<span class="line-modified"> 342             sa-&gt;sin_addr.s_addr = addr;</span>








 343         }
 344 
<a name="17" id="anc17"></a><span class="line-modified"> 345         (*callback-&gt;free)(buf);</span>
 346     }
 347 
 348     return JDWPTRANSPORT_ERROR_NONE;
 349 }
 350 
<a name="18" id="anc18"></a><span class="line-modified"> 351 static const char *</span>
<span class="line-modified"> 352 ip_s2u(const char *instr, uint32_t *ip) {</span>
<span class="line-modified"> 353     // Convert string representation of ip to integer</span>
<span class="line-modified"> 354     // in network byte order (big-endian)</span>
<span class="line-modified"> 355     char t[4] = { 0, 0, 0, 0 };</span>
<span class="line-modified"> 356     const char *s = instr;</span>
<span class="line-modified"> 357     int i = 0;</span>
<span class="line-modified"> 358 </span>
<span class="line-modified"> 359     while (1) {</span>
<span class="line-modified"> 360         if (*s == &#39;.&#39;) {</span>
<span class="line-modified"> 361             ++i;</span>
<span class="line-modified"> 362             ++s;</span>
<span class="line-modified"> 363             continue;</span>
<span class="line-modified"> 364         }</span>
<span class="line-modified"> 365         if (*s == 0 || *s == &#39;+&#39; || *s == &#39;/&#39;) {</span>
<span class="line-modified"> 366             break;</span>
<span class="line-modified"> 367         }</span>
<span class="line-modified"> 368         if (*s &lt; &#39;0&#39; || *s &gt; &#39;9&#39;) {</span>
<span class="line-modified"> 369             return instr;</span>
<span class="line-modified"> 370         }</span>
<span class="line-modified"> 371         t[i] = (t[i] * 10) + (*s - &#39;0&#39;);</span>
<span class="line-modified"> 372         ++s;</span>

















 373     }
 374 
<a name="19" id="anc19"></a><span class="line-modified"> 375     *ip = *(uint32_t*)(t);</span>
<span class="line-removed"> 376     return s;</span>
 377 }
 378 
<a name="20" id="anc20"></a><span class="line-modified"> 379 static const char *</span>
<span class="line-modified"> 380 mask_s2u(const char *instr, uint32_t *mask) {</span>
<span class="line-modified"> 381     // Convert the number of bits to a netmask</span>
<span class="line-modified"> 382     // in network byte order (big-endian)</span>
<span class="line-modified"> 383     unsigned char m = 0;</span>
<span class="line-modified"> 384     const char *s = instr;</span>







 385 
<a name="21" id="anc21"></a><span class="line-modified"> 386     while (1) {</span>
<span class="line-modified"> 387         if (*s == 0 || *s == &#39;+&#39;) {</span>
<span class="line-modified"> 388             break;</span>



















































 389         }
<a name="22" id="anc22"></a><span class="line-modified"> 390         if (*s &lt; &#39;0&#39; || *s &gt; &#39;9&#39;) {</span>
<span class="line-modified"> 391             return instr;</span>

 392         }
<a name="23" id="anc23"></a><span class="line-modified"> 393         m = (m * 10) + (*s - &#39;0&#39;);</span>
<span class="line-modified"> 394         ++s;</span>




 395     }
 396 
<a name="24" id="anc24"></a><span class="line-modified"> 397     if (m == 0 || m &gt; 32) {</span>
<span class="line-modified"> 398        // Drop invalid input</span>
<span class="line-removed"> 399        return instr;</span>
 400     }
 401 
<a name="25" id="anc25"></a><span class="line-modified"> 402     *mask = htonl((uint32_t)(~0) &lt;&lt; (32 - m));</span>
<span class="line-modified"> 403     return s;</span>
<span class="line-removed"> 404 }</span>
 405 
<a name="26" id="anc26"></a><span class="line-modified"> 406 static int</span>
<span class="line-modified"> 407 ip_in_subnet(uint32_t subnet, uint32_t mask, uint32_t ipaddr) {</span>
<span class="line-modified"> 408     return (ipaddr &amp; mask) == subnet;</span>









 409 }
 410 
<a name="27" id="anc27"></a>


 411 static jdwpTransportError
<a name="28" id="anc28"></a><span class="line-modified"> 412 parseAllowedPeers(const char *allowed_peers) {</span>
<span class="line-modified"> 413     // Build a list of allowed peers from char string</span>
<span class="line-modified"> 414     // of format 192.168.0.10+192.168.0.0/24</span>
<span class="line-modified"> 415     const char *s = NULL;</span>
<span class="line-modified"> 416     const char *p = allowed_peers;</span>
<span class="line-modified"> 417     uint32_t   ip = 0;</span>
<span class="line-modified"> 418     uint32_t mask = 0xFFFFFFFF;</span>
<span class="line-modified"> 419 </span>
<span class="line-modified"> 420     while (1) {</span>
<span class="line-modified"> 421         s = ip_s2u(p, &amp;ip);</span>
<span class="line-modified"> 422         if (s == p) {</span>


















 423             _peers_cnt = 0;
<a name="29" id="anc29"></a><span class="line-modified"> 424             fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, s);</span>
 425             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
 426                          &quot;invalid IP address in allow option&quot;);
 427         }
<a name="30" id="anc30"></a><span class="line-modified"> 428 </span>
<span class="line-modified"> 429         if (*s == &#39;/&#39;) {</span>
<span class="line-modified"> 430             // netmask specified</span>
<span class="line-removed"> 431             s = mask_s2u(s + 1, &amp;mask);</span>
<span class="line-removed"> 432             if (*(s - 1) == &#39;/&#39;) {</span>
<span class="line-removed"> 433                 // Input is not consumed, something bad happened</span>
 434                 _peers_cnt = 0;
<a name="31" id="anc31"></a><span class="line-modified"> 435                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, s);</span>
 436                 RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
 437                              &quot;invalid netmask in allow option&quot;);
 438             }
<a name="32" id="anc32"></a>



 439         } else {
<a name="33" id="anc33"></a><span class="line-modified"> 440             // reset netmask</span>
<span class="line-removed"> 441             mask = 0xFFFFFFFF;</span>
 442         }
<a name="34" id="anc34"></a>


 443 
<a name="35" id="anc35"></a><span class="line-modified"> 444         if (*s == &#39;+&#39; || *s == 0) {</span>
<span class="line-modified"> 445             if (_peers_cnt &gt;= MAX_PEER_ENTRIES) {</span>
<span class="line-modified"> 446                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);</span>
<span class="line-modified"> 447                 RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,</span>
<span class="line-modified"> 448                              &quot;exceeded max number of allowed peers: &quot; MAX_PEERS_STR);</span>
<span class="line-modified"> 449             }</span>
<span class="line-modified"> 450             _peers[_peers_cnt].subnet = ip;</span>
<span class="line-modified"> 451             _peers[_peers_cnt].netmask = mask;</span>
<span class="line-modified"> 452             _peers_cnt++;</span>
<span class="line-modified"> 453             if (*s == 0) {</span>
<span class="line-modified"> 454                 // end of options</span>
<span class="line-modified"> 455                 break;</span>
<span class="line-modified"> 456             }</span>
<span class="line-modified"> 457             // advance to next IP block</span>
<span class="line-modified"> 458             p = s + 1;</span>






















 459         }
 460     }
<a name="36" id="anc36"></a><span class="line-modified"> 461     return JDWPTRANSPORT_ERROR_NONE;</span>
 462 }
 463 
 464 static int
<a name="37" id="anc37"></a><span class="line-modified"> 465 isPeerAllowed(struct sockaddr_in *peer) {</span>


 466     int i;
<a name="38" id="anc38"></a>







 467     for (i = 0; i &lt; _peers_cnt; ++i) {
<a name="39" id="anc39"></a><span class="line-modified"> 468         int peer_ip = peer-&gt;sin_addr.s_addr;</span>
<span class="line-removed"> 469         if (ip_in_subnet(_peers[i].subnet, _peers[i].netmask, peer_ip)) {</span>
 470             return 1;
 471         }
 472     }
 473 
 474     return 0;
 475 }
 476 
 477 static jdwpTransportError JNICALL
 478 socketTransport_getCapabilities(jdwpTransportEnv* env,
 479         JDWPTransportCapabilities* capabilitiesPtr)
 480 {
 481     JDWPTransportCapabilities result;
 482 
 483     memset(&amp;result, 0, sizeof(result));
 484     result.can_timeout_attach = JNI_TRUE;
 485     result.can_timeout_accept = JNI_TRUE;
 486     result.can_timeout_handshake = JNI_TRUE;
 487 
 488     *capabilitiesPtr = result;
 489 
 490     return JDWPTRANSPORT_ERROR_NONE;
 491 }
 492 
<a name="40" id="anc40"></a><span class="line-modified"> 493 </span>
<span class="line-modified"> 494 static jdwpTransportError JNICALL</span>
<span class="line-modified"> 495 socketTransport_startListening(jdwpTransportEnv* env, const char* address,</span>
<span class="line-modified"> 496                                char** actualAddress)</span>


 497 {
<a name="41" id="anc41"></a><span class="line-removed"> 498     struct sockaddr_in sa;</span>
 499     int err;
 500 
<a name="42" id="anc42"></a><span class="line-modified"> 501     memset((void *)&amp;sa,0,sizeof(struct sockaddr_in));</span>
<span class="line-modified"> 502     sa.sin_family = AF_INET;</span>
<span class="line-removed"> 503 </span>
<span class="line-removed"> 504     /* no address provided */</span>
<span class="line-removed"> 505     if ((address == NULL) || (address[0] == &#39;\0&#39;)) {</span>
<span class="line-removed"> 506         address = &quot;0&quot;;</span>
<span class="line-removed"> 507     }</span>
<span class="line-removed"> 508 </span>
<span class="line-removed"> 509     err = parseAddress(address, &amp;sa);</span>
<span class="line-removed"> 510     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-removed"> 511         return err;</span>
<span class="line-removed"> 512     }</span>
<span class="line-removed"> 513 </span>
<span class="line-removed"> 514     serverSocketFD = dbgsysSocket(AF_INET, SOCK_STREAM, 0);</span>
<span class="line-removed"> 515     if (serverSocketFD &lt; 0) {</span>
 516         RETURN_IO_ERROR(&quot;socket creation failed&quot;);
 517     }
 518 
<a name="43" id="anc43"></a><span class="line-modified"> 519     err = setOptionsCommon(serverSocketFD);</span>
 520     if (err) {
 521         return err;
 522     }
<a name="44" id="anc44"></a><span class="line-modified"> 523     if (sa.sin_port != 0) {</span>

 524         /*
 525          * Only need SO_REUSEADDR if we&#39;re using a fixed port. If we
 526          * start seeing EADDRINUSE due to collisions in free ports
 527          * then we should retry the dbgsysBind() a few times.
 528          */
<a name="45" id="anc45"></a><span class="line-modified"> 529         err = setReuseAddrOption(serverSocketFD);</span>
 530         if (err) {
 531             return err;
 532         }
 533     }
 534 
<a name="46" id="anc46"></a><span class="line-modified"> 535     err = dbgsysBind(serverSocketFD, (struct sockaddr *)&amp;sa, sizeof(sa));</span>
 536     if (err &lt; 0) {
 537         RETURN_IO_ERROR(&quot;bind failed&quot;);
 538     }
 539 
<a name="47" id="anc47"></a><span class="line-modified"> 540     err = dbgsysListen(serverSocketFD, 1);</span>
 541     if (err &lt; 0) {
 542         RETURN_IO_ERROR(&quot;listen failed&quot;);
 543     }
 544 
 545     {
 546         char buf[20];
<a name="48" id="anc48"></a><span class="line-modified"> 547         socklen_t len = sizeof(sa);</span>

 548         jint portNum;
<a name="49" id="anc49"></a><span class="line-modified"> 549         err = dbgsysGetSocketName(serverSocketFD,</span>
<span class="line-modified"> 550                                (struct sockaddr *)&amp;sa, &amp;len);</span>
<span class="line-modified"> 551         portNum = dbgsysNetworkToHostShort(sa.sin_port);</span>



 552         sprintf(buf, &quot;%d&quot;, portNum);
 553         *actualAddress = (*callback-&gt;alloc)((int)strlen(buf) + 1);
 554         if (*actualAddress == NULL) {
 555             RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
 556         } else {
 557             strcpy(*actualAddress, buf);
 558         }
 559     }
 560 
 561     return JDWPTRANSPORT_ERROR_NONE;
 562 }
 563 
<a name="50" id="anc50"></a>



















































 564 static jdwpTransportError JNICALL
 565 socketTransport_accept(jdwpTransportEnv* env, jlong acceptTimeout, jlong handshakeTimeout)
 566 {
<a name="51" id="anc51"></a><span class="line-removed"> 567     socklen_t socketLen;</span>
 568     int err = JDWPTRANSPORT_ERROR_NONE;
<a name="52" id="anc52"></a><span class="line-modified"> 569     struct sockaddr_in socket;</span>
<span class="line-modified"> 570     jlong startTime = (jlong)0;</span>

 571 
 572     /*
 573      * Use a default handshake timeout if not specified - this avoids an indefinite
 574      * hang in cases where something other than a debugger connects to our port.
 575      */
 576     if (handshakeTimeout == 0) {
 577         handshakeTimeout = 2000;
 578     }
 579 
 580     do {
 581         /*
 582          * If there is an accept timeout then we put the socket in non-blocking
 583          * mode and poll for a connection.
 584          */
 585         if (acceptTimeout &gt; 0) {
 586             int rv;
 587             dbgsysConfigureBlocking(serverSocketFD, JNI_FALSE);
 588             startTime = dbgsysCurrentTimeMillis();
 589             rv = dbgsysPoll(serverSocketFD, JNI_TRUE, JNI_FALSE, (long)acceptTimeout);
 590             if (rv &lt;= 0) {
 591                 /* set the last error here as could be overridden by configureBlocking */
 592                 if (rv == 0) {
 593                     setLastError(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;poll failed&quot;);
 594                 }
 595                 /* restore blocking state */
 596                 dbgsysConfigureBlocking(serverSocketFD, JNI_TRUE);
 597                 if (rv == 0) {
 598                     RETURN_ERROR(JDWPTRANSPORT_ERROR_TIMEOUT, &quot;timed out waiting for connection&quot;);
 599                 } else {
 600                     return JDWPTRANSPORT_ERROR_IO_ERROR;
 601                 }
 602             }
 603         }
 604 
 605         /*
 606          * Accept the connection
 607          */
<a name="53" id="anc53"></a><span class="line-modified"> 608         memset((void *)&amp;socket,0,sizeof(struct sockaddr_in));</span>
<span class="line-removed"> 609         socketLen = sizeof(socket);</span>
 610         socketFD = dbgsysAccept(serverSocketFD,
<a name="54" id="anc54"></a><span class="line-modified"> 611                                 (struct sockaddr *)&amp;socket,</span>
<span class="line-modified"> 612                                 &amp;socketLen);</span>
 613         /* set the last error here as could be overridden by configureBlocking */
 614         if (socketFD &lt; 0) {
 615             setLastError(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;accept failed&quot;);
 616         }
 617         /*
 618          * Restore the blocking state - note that the accepted socket may be in
 619          * blocking or non-blocking mode (platform dependent). However as there
 620          * is a handshake timeout set then it will go into non-blocking mode
 621          * anyway for the handshake.
 622          */
 623         if (acceptTimeout &gt; 0) {
 624             dbgsysConfigureBlocking(serverSocketFD, JNI_TRUE);
 625         }
 626         if (socketFD &lt; 0) {
 627             return JDWPTRANSPORT_ERROR_IO_ERROR;
 628         }
 629 
 630         /*
 631          * version &gt;= JDWPTRANSPORT_VERSION_1_1:
 632          * Verify that peer is allowed to connect.
 633          */
 634         if (_peers_cnt &gt; 0) {
<a name="55" id="anc55"></a><span class="line-modified"> 635             if (!isPeerAllowed(&amp;socket)) {</span>
 636                 char ebuf[64] = { 0 };
<a name="56" id="anc56"></a><span class="line-modified"> 637                 char buf[INET_ADDRSTRLEN] = { 0 };</span>
<span class="line-modified"> 638                 const char* addr_str = inet_ntop(AF_INET, &amp;(socket.sin_addr), buf, INET_ADDRSTRLEN);</span>


 639                 sprintf(ebuf, &quot;ERROR: Peer not allowed to connect: %s\n&quot;,
<a name="57" id="anc57"></a><span class="line-modified"> 640                         (addr_str == NULL) ? &quot;&lt;bad address&gt;&quot; : addr_str);</span>
 641                 dbgsysSocketClose(socketFD);
 642                 socketFD = -1;
 643                 err = JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;
 644                 setLastError(err, ebuf);
 645             }
 646         }
 647 
 648         if (socketFD &gt; 0) {
 649           /* handshake with the debugger */
 650           err = handshake(socketFD, handshakeTimeout);
 651         }
 652 
 653         /*
 654          * If the handshake fails then close the connection. If there if an accept
 655          * timeout then we must adjust the timeout for the next poll.
 656          */
 657         if (err != JDWPTRANSPORT_ERROR_NONE) {
 658             fprintf(stderr, &quot;Debugger failed to attach: %s\n&quot;, getLastError());
 659             dbgsysSocketClose(socketFD);
 660             socketFD = -1;
 661             if (acceptTimeout &gt; 0) {
 662                 long endTime = dbgsysCurrentTimeMillis();
 663                 acceptTimeout -= (endTime - startTime);
 664                 if (acceptTimeout &lt;= 0) {
 665                     setLastError(JDWPTRANSPORT_ERROR_IO_ERROR,
 666                         &quot;timeout waiting for debugger to connect&quot;);
 667                     return JDWPTRANSPORT_ERROR_IO_ERROR;
 668                 }
 669             }
 670         }
 671     } while (socketFD &lt; 0);
 672 
 673     return JDWPTRANSPORT_ERROR_NONE;
 674 }
 675 
 676 static jdwpTransportError JNICALL
 677 socketTransport_stopListening(jdwpTransportEnv *env)
 678 {
 679     if (serverSocketFD &lt; 0) {
 680         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_STATE, &quot;connection not open&quot;);
 681     }
 682     if (dbgsysSocketClose(serverSocketFD) &lt; 0) {
 683         RETURN_IO_ERROR(&quot;close failed&quot;);
 684     }
 685     serverSocketFD = -1;
 686     return JDWPTRANSPORT_ERROR_NONE;
 687 }
 688 
<a name="58" id="anc58"></a><span class="line-modified"> 689 static jdwpTransportError JNICALL</span>
<span class="line-modified"> 690 socketTransport_attach(jdwpTransportEnv* env, const char* addressString, jlong attachTimeout,</span>
<span class="line-modified"> 691                        jlong handshakeTimeout)</span>
<span class="line-modified"> 692 {</span>
<span class="line-modified"> 693     struct sockaddr_in sa;</span>
 694     int err;
 695 
<a name="59" id="anc59"></a><span class="line-modified"> 696     if (addressString == NULL || addressString[0] == &#39;\0&#39;) {</span>
<span class="line-modified"> 697         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;address is missing&quot;);</span>
<span class="line-removed"> 698     }</span>
<span class="line-removed"> 699 </span>
<span class="line-removed"> 700     err = parseAddress(addressString, &amp;sa);</span>
<span class="line-removed"> 701     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-removed"> 702         return err;</span>
<span class="line-removed"> 703     }</span>
<span class="line-removed"> 704 </span>
<span class="line-removed"> 705     socketFD = dbgsysSocket(AF_INET, SOCK_STREAM, 0);</span>
<span class="line-removed"> 706     if (socketFD &lt; 0) {</span>
 707         RETURN_IO_ERROR(&quot;unable to create socket&quot;);
 708     }
 709 
<a name="60" id="anc60"></a><span class="line-modified"> 710     err = setOptionsCommon(socketFD);</span>
 711     if (err) {
 712         return err;
 713     }
 714 
 715     /*
 716      * We don&#39;t call setReuseAddrOption() for the non-server socket
 717      * case. If we start seeing EADDRINUSE due to collisions in free
 718      * ports then we should retry the dbgsysConnect() a few times.
 719      */
 720 
 721     /*
 722      * To do a timed connect we make the socket non-blocking
 723      * and poll with a timeout;
 724      */
<a name="61" id="anc61"></a><span class="line-modified"> 725     if (attachTimeout &gt; 0) {</span>
 726         dbgsysConfigureBlocking(socketFD, JNI_FALSE);
 727     }
 728 
<a name="62" id="anc62"></a><span class="line-modified"> 729     err = dbgsysConnect(socketFD, (struct sockaddr *)&amp;sa, sizeof(sa));</span>
<span class="line-modified"> 730     if (err == DBG_EINPROGRESS &amp;&amp; attachTimeout &gt; 0) {</span>
<span class="line-modified"> 731         err = dbgsysFinishConnect(socketFD, (long)attachTimeout);</span>

 732 
 733         if (err == DBG_ETIMEOUT) {
 734             dbgsysConfigureBlocking(socketFD, JNI_TRUE);
 735             RETURN_ERROR(JDWPTRANSPORT_ERROR_TIMEOUT, &quot;connect timed out&quot;);
 736         }
 737     }
 738 
<a name="63" id="anc63"></a><span class="line-modified"> 739     if (err &lt; 0) {</span>
 740         RETURN_IO_ERROR(&quot;connect failed&quot;);
 741     }
 742 
<a name="64" id="anc64"></a>














































 743     if (attachTimeout &gt; 0) {
 744         dbgsysConfigureBlocking(socketFD, JNI_TRUE);
 745     }
 746 
 747     err = handshake(socketFD, handshakeTimeout);
 748     if (err) {
 749         dbgsysSocketClose(socketFD);
 750         socketFD = -1;
 751         return err;
 752     }
 753 
 754     return JDWPTRANSPORT_ERROR_NONE;
 755 }
 756 
 757 static jboolean JNICALL
 758 socketTransport_isOpen(jdwpTransportEnv* env)
 759 {
 760     if (socketFD &gt;= 0) {
 761         return JNI_TRUE;
 762     } else {
 763         return JNI_FALSE;
 764     }
 765 }
 766 
 767 static jdwpTransportError JNICALL
 768 socketTransport_close(jdwpTransportEnv* env)
 769 {
 770     int fd = socketFD;
 771     socketFD = -1;
 772     if (fd &lt; 0) {
 773         return JDWPTRANSPORT_ERROR_NONE;
 774     }
 775 #ifdef _AIX
 776     /*
 777       AIX needs a workaround for I/O cancellation, see:
 778       http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/close.htm
 779       ...
 780       The close subroutine is blocked until all subroutines which use the file
 781       descriptor return to usr space. For example, when a thread is calling close
 782       and another thread is calling select with the same file descriptor, the
 783       close subroutine does not return until the select call returns.
 784       ...
 785     */
 786     shutdown(fd, 2);
 787 #endif
 788     if (dbgsysSocketClose(fd) &lt; 0) {
 789         /*
 790          * close failed - it&#39;s pointless to restore socketFD here because
 791          * any subsequent close will likely fail as well.
 792          */
 793         RETURN_IO_ERROR(&quot;close failed&quot;);
 794     }
 795     return JDWPTRANSPORT_ERROR_NONE;
 796 }
 797 
 798 static jdwpTransportError JNICALL
 799 socketTransport_writePacket(jdwpTransportEnv* env, const jdwpPacket *packet)
 800 {
 801     jint len, data_len, id;
 802     /*
 803      * room for header and up to MAX_DATA_SIZE data bytes
 804      */
 805     char header[JDWP_HEADER_SIZE + MAX_DATA_SIZE];
 806     jbyte *data;
 807 
 808     /* packet can&#39;t be null */
 809     if (packet == NULL) {
 810         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;packet is NULL&quot;);
 811     }
 812 
 813     len = packet-&gt;type.cmd.len;         /* includes header */
 814     data_len = len - JDWP_HEADER_SIZE;
 815 
 816     /* bad packet */
 817     if (data_len &lt; 0) {
 818         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;invalid length&quot;);
 819     }
 820 
 821     /* prepare the header for transmission */
 822     len = (jint)dbgsysHostToNetworkLong(len);
 823     id = (jint)dbgsysHostToNetworkLong(packet-&gt;type.cmd.id);
 824 
 825     memcpy(header + 0, &amp;len, 4);
 826     memcpy(header + 4, &amp;id, 4);
 827     header[8] = packet-&gt;type.cmd.flags;
 828     if (packet-&gt;type.cmd.flags &amp; JDWPTRANSPORT_FLAGS_REPLY) {
 829         jshort errorCode =
 830             dbgsysHostToNetworkShort(packet-&gt;type.reply.errorCode);
 831         memcpy(header + 9, &amp;errorCode, 2);
 832     } else {
 833         header[9] = packet-&gt;type.cmd.cmdSet;
 834         header[10] = packet-&gt;type.cmd.cmd;
 835     }
 836 
 837     data = packet-&gt;type.cmd.data;
 838     /* Do one send for short packets, two for longer ones */
 839     if (data_len &lt;= MAX_DATA_SIZE) {
 840         memcpy(header + JDWP_HEADER_SIZE, data, data_len);
 841         if (send_fully(socketFD, (char *)&amp;header, JDWP_HEADER_SIZE + data_len) !=
 842             JDWP_HEADER_SIZE + data_len) {
 843             RETURN_IO_ERROR(&quot;send failed&quot;);
 844         }
 845     } else {
 846         memcpy(header + JDWP_HEADER_SIZE, data, MAX_DATA_SIZE);
 847         if (send_fully(socketFD, (char *)&amp;header, JDWP_HEADER_SIZE + MAX_DATA_SIZE) !=
 848             JDWP_HEADER_SIZE + MAX_DATA_SIZE) {
 849             RETURN_IO_ERROR(&quot;send failed&quot;);
 850         }
 851         /* Send the remaining data bytes right out of the data area. */
 852         if (send_fully(socketFD, (char *)data + MAX_DATA_SIZE,
 853                        data_len - MAX_DATA_SIZE) != data_len - MAX_DATA_SIZE) {
 854             RETURN_IO_ERROR(&quot;send failed&quot;);
 855         }
 856     }
 857 
 858     return JDWPTRANSPORT_ERROR_NONE;
 859 }
 860 
 861 static jint
 862 recv_fully(int f, char *buf, int len)
 863 {
 864     int nbytes = 0;
 865     while (nbytes &lt; len) {
 866         int res = dbgsysRecv(f, buf + nbytes, len - nbytes, 0);
 867         if (res &lt; 0) {
 868             return res;
 869         } else if (res == 0) {
 870             break; /* eof, return nbytes which is less than len */
 871         }
 872         nbytes += res;
 873     }
 874     return nbytes;
 875 }
 876 
 877 jint
 878 send_fully(int f, char *buf, int len)
 879 {
 880     int nbytes = 0;
 881     while (nbytes &lt; len) {
 882         int res = dbgsysSend(f, buf + nbytes, len - nbytes, 0);
 883         if (res &lt; 0) {
 884             return res;
 885         } else if (res == 0) {
 886             break; /* eof, return nbytes which is less than len */
 887         }
 888         nbytes += res;
 889     }
 890     return nbytes;
 891 }
 892 
 893 static jdwpTransportError JNICALL
 894 socketTransport_readPacket(jdwpTransportEnv* env, jdwpPacket* packet) {
 895     jint length, data_len;
 896     jint n;
 897 
 898     /* packet can&#39;t be null */
 899     if (packet == NULL) {
 900         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;packet is null&quot;);
 901     }
 902 
 903     /* read the length field */
 904     n = recv_fully(socketFD, (char *)&amp;length, sizeof(jint));
 905 
 906     /* check for EOF */
 907     if (n == 0) {
 908         packet-&gt;type.cmd.len = 0;
 909         return JDWPTRANSPORT_ERROR_NONE;
 910     }
 911     if (n != sizeof(jint)) {
 912         RETURN_RECV_ERROR(n);
 913     }
 914 
 915     length = (jint)dbgsysNetworkToHostLong(length);
 916     packet-&gt;type.cmd.len = length;
 917 
 918 
 919     n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.cmd.id), sizeof(jint));
 920     if (n &lt; (int)sizeof(jint)) {
 921         RETURN_RECV_ERROR(n);
 922     }
 923 
 924     packet-&gt;type.cmd.id = (jint)dbgsysNetworkToHostLong(packet-&gt;type.cmd.id);
 925 
 926     n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.cmd.flags), sizeof(jbyte));
 927     if (n &lt; (int)sizeof(jbyte)) {
 928         RETURN_RECV_ERROR(n);
 929     }
 930 
 931     if (packet-&gt;type.cmd.flags &amp; JDWPTRANSPORT_FLAGS_REPLY) {
 932         n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.reply.errorCode), sizeof(jbyte));
 933         if (n &lt; (int)sizeof(jshort)) {
 934             RETURN_RECV_ERROR(n);
 935         }
 936 
 937         /* FIXME - should the error be converted to host order?? */
 938 
 939 
 940     } else {
 941         n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.cmd.cmdSet), sizeof(jbyte));
 942         if (n &lt; (int)sizeof(jbyte)) {
 943             RETURN_RECV_ERROR(n);
 944         }
 945 
 946         n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.cmd.cmd), sizeof(jbyte));
 947         if (n &lt; (int)sizeof(jbyte)) {
 948             RETURN_RECV_ERROR(n);
 949         }
 950     }
 951 
 952     data_len = length - ((sizeof(jint) * 2) + (sizeof(jbyte) * 3));
 953 
 954     if (data_len &lt; 0) {
 955         setLastError(0, &quot;Badly formed packet received - invalid length&quot;);
 956         return JDWPTRANSPORT_ERROR_IO_ERROR;
 957     } else if (data_len == 0) {
 958         packet-&gt;type.cmd.data = NULL;
 959     } else {
 960         packet-&gt;type.cmd.data= (*callback-&gt;alloc)(data_len);
 961 
 962         if (packet-&gt;type.cmd.data == NULL) {
 963             RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
 964         }
 965 
 966         n = recv_fully(socketFD,(char *)packet-&gt;type.cmd.data, data_len);
 967         if (n &lt; data_len) {
 968             (*callback-&gt;free)(packet-&gt;type.cmd.data);
 969             RETURN_RECV_ERROR(n);
 970         }
 971     }
 972 
 973     return JDWPTRANSPORT_ERROR_NONE;
 974 }
 975 
 976 static jdwpTransportError JNICALL
 977 socketTransport_getLastError(jdwpTransportEnv* env, char** msgP) {
 978     char *msg = (char *)dbgsysTlsGet(tlsIndex);
 979     if (msg == NULL) {
 980         return JDWPTRANSPORT_ERROR_MSG_NOT_AVAILABLE;
 981     }
 982     *msgP = (*callback-&gt;alloc)((int)strlen(msg)+1);
 983     if (*msgP == NULL) {
 984         return JDWPTRANSPORT_ERROR_OUT_OF_MEMORY;
 985     }
 986     strcpy(*msgP, msg);
 987     return JDWPTRANSPORT_ERROR_NONE;
 988 }
 989 
 990 static jdwpTransportError JNICALL
 991 socketTransport_setConfiguration(jdwpTransportEnv* env, jdwpTransportConfiguration* cfg) {
 992     const char* allowed_peers = NULL;
 993 
 994     if (cfg == NULL) {
 995         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
 996                      &quot;NULL pointer to transport configuration is invalid&quot;);
 997     }
 998     allowed_peers = cfg-&gt;allowed_peers;
 999     _peers_cnt = 0;
1000     if (allowed_peers != NULL) {
1001         size_t len = strlen(allowed_peers);
1002         if (len == 0) { /* Impossible: parseOptions() would reject it */
1003             fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);
1004             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
1005                          &quot;allow option should not be empty&quot;);
1006         } else if (*allowed_peers == &#39;*&#39;) {
1007             if (len != 1) {
1008                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);
1009                 RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
1010                              &quot;allow option &#39;*&#39; cannot be expanded&quot;);
1011             }
1012         } else {
<a name="65" id="anc65"></a><span class="line-modified">1013             int err = parseAllowedPeers(allowed_peers);</span>
1014             if (err != JDWPTRANSPORT_ERROR_NONE) {
1015                 return err;
1016             }
1017         }
1018     }
1019     return JDWPTRANSPORT_ERROR_NONE;
1020 }
1021 
<a name="66" id="anc66"></a>

































1022 JNIEXPORT jint JNICALL
1023 jdwpTransport_OnLoad(JavaVM *vm, jdwpTransportCallback* cbTablePtr,
1024                      jint version, jdwpTransportEnv** env)
1025 {
<a name="67" id="anc67"></a>

1026     if (version &lt; JDWPTRANSPORT_VERSION_1_0 ||
1027         version &gt; JDWPTRANSPORT_VERSION_1_1) {
1028         return JNI_EVERSION;
1029     }
1030     if (initialized) {
1031         /*
1032          * This library doesn&#39;t support multiple environments (yet)
1033          */
1034         return JNI_EEXIST;
1035     }
1036     initialized = JNI_TRUE;
1037     jvm = vm;
1038     callback = cbTablePtr;
1039 
1040     /* initialize interface table */
1041     interface.GetCapabilities = &amp;socketTransport_getCapabilities;
1042     interface.Attach = &amp;socketTransport_attach;
1043     interface.StartListening = &amp;socketTransport_startListening;
1044     interface.StopListening = &amp;socketTransport_stopListening;
1045     interface.Accept = &amp;socketTransport_accept;
1046     interface.IsOpen = &amp;socketTransport_isOpen;
1047     interface.Close = &amp;socketTransport_close;
1048     interface.ReadPacket = &amp;socketTransport_readPacket;
1049     interface.WritePacket = &amp;socketTransport_writePacket;
1050     interface.GetLastError = &amp;socketTransport_getLastError;
1051     if (version &gt;= JDWPTRANSPORT_VERSION_1_1) {
1052         interface.SetTransportConfiguration = &amp;socketTransport_setConfiguration;
1053     }
1054     *env = &amp;single_env;
1055 
1056     /* initialized TLS */
1057     tlsIndex = dbgsysTlsAlloc();
<a name="68" id="anc68"></a>



























1058     return JNI_OK;
1059 }
<a name="69" id="anc69"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="69" type="hidden" />
</body>
</html>
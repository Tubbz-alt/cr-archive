<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jdwp.agent/share/native/libdt_socket/socketTransport.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;stdio.h&gt;
  26 #include &lt;string.h&gt;
  27 #include &lt;errno.h&gt;
  28 #include &lt;stdlib.h&gt;
  29 #include &lt;ctype.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jdwpTransport.h&quot;
  33 #include &quot;sysSocket.h&quot;
  34 
  35 #ifdef _WIN32
  36  #include &lt;winsock2.h&gt;
  37  #include &lt;ws2tcpip.h&gt;
<a name="2" id="anc2"></a><span class="line-added">  38  #include &lt;iphlpapi.h&gt;</span>
  39 #else
  40  #include &lt;arpa/inet.h&gt;
  41  #include &lt;sys/socket.h&gt;
<a name="3" id="anc3"></a><span class="line-added">  42  #include &lt;net/if.h&gt;</span>
  43 #endif
  44 
  45 /*
  46  * The Socket Transport Library.
  47  *
  48  * This module is an implementation of the Java Debug Wire Protocol Transport
  49  * Service Provider Interface - see src/share/javavm/export/jdwpTransport.h.
  50  */
  51 
<a name="4" id="anc4"></a><span class="line-modified">  52 static int serverSocketFD = -1;</span>
  53 static int socketFD = -1;
  54 static jdwpTransportCallback *callback;
  55 static JavaVM *jvm;
  56 static int tlsIndex;
  57 static jboolean initialized;
  58 static struct jdwpTransportNativeInterface_ interface;
  59 static jdwpTransportEnv single_env = (jdwpTransportEnv)&amp;interface;
  60 
  61 #define RETURN_ERROR(err, msg) \
  62         if (1==1) { \
  63             setLastError(err, msg); \
  64             return err; \
  65         }
  66 
  67 #define RETURN_IO_ERROR(msg)    RETURN_ERROR(JDWPTRANSPORT_ERROR_IO_ERROR, msg);
  68 
  69 #define RETURN_RECV_ERROR(n) \
  70         if (n == 0) { \
  71             RETURN_ERROR(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;premature EOF&quot;); \
  72         } else { \
  73             RETURN_IO_ERROR(&quot;recv error&quot;); \
  74         }
  75 
  76 #define MAX_DATA_SIZE 1000
  77 
  78 static jint recv_fully(int, char *, int);
  79 static jint send_fully(int, char *, int);
  80 
  81 /* version &gt;= JDWPTRANSPORT_VERSION_1_1 */
  82 typedef struct {
<a name="5" id="anc5"></a><span class="line-modified">  83     /* subnet and mask are stored as IPv6 addresses, IPv4 is stored as mapped IPv6 */</span>
<span class="line-modified">  84     struct in6_addr subnet;</span>
<span class="line-added">  85     struct in6_addr netmask;</span>
  86 } AllowedPeerInfo;
  87 
  88 #define STR(x) #x
  89 #define MAX_PEER_ENTRIES 32
  90 #define MAX_PEERS_STR STR(MAX_PEER_ENTRIES)
  91 static AllowedPeerInfo _peers[MAX_PEER_ENTRIES];
  92 static int _peers_cnt = 0;
  93 
  94 
<a name="6" id="anc6"></a><span class="line-added">  95 static int allowOnlyIPv4 = 0;                  // reflects &quot;java.net.preferIPv4Stack&quot; sys. property</span>
<span class="line-added">  96 static int preferredAddressFamily = AF_INET;   // &quot;java.net.preferIPv6Addresses&quot;</span>
<span class="line-added">  97 </span>
  98 /*
  99  * Record the last error for this thread.
 100  */
 101 static void
 102 setLastError(jdwpTransportError err, char *newmsg) {
 103     char buf[255];
 104     char *msg;
 105 
 106     /* get any I/O first in case any system calls override errno */
 107     if (err == JDWPTRANSPORT_ERROR_IO_ERROR) {
 108         dbgsysGetLastIOError(buf, sizeof(buf));
 109     }
 110 
 111     msg = (char *)dbgsysTlsGet(tlsIndex);
 112     if (msg != NULL) {
 113         (*callback-&gt;free)(msg);
 114     }
 115 
 116     if (err == JDWPTRANSPORT_ERROR_IO_ERROR) {
 117         char *join_str = &quot;: &quot;;
 118         int msg_len = (int)strlen(newmsg) + (int)strlen(join_str) +
 119                       (int)strlen(buf) + 3;
 120         msg = (*callback-&gt;alloc)(msg_len);
 121         if (msg != NULL) {
 122             strcpy(msg, newmsg);
 123             strcat(msg, join_str);
 124             strcat(msg, buf);
 125         }
 126     } else {
 127         msg = (*callback-&gt;alloc)((int)strlen(newmsg)+1);
 128         if (msg != NULL) {
 129             strcpy(msg, newmsg);
 130         }
 131     }
 132 
 133     dbgsysTlsPut(tlsIndex, msg);
 134 }
 135 
 136 /*
 137  * Return the last error for this thread (may be NULL)
 138  */
 139 static char*
 140 getLastError() {
 141     return (char *)dbgsysTlsGet(tlsIndex);
 142 }
 143 
 144 /* Set options common to client and server sides */
 145 static jdwpTransportError
<a name="7" id="anc7"></a><span class="line-modified"> 146 setOptionsCommon(int domain, int fd)</span>
 147 {
 148     jvalue dontcare;
 149     int err;
 150 
<a name="8" id="anc8"></a><span class="line-modified"> 151     if (domain == AF_INET6) {</span>
<span class="line-added"> 152         int off = 0;</span>
<span class="line-added"> 153         // make the socket a dual mode socket</span>
<span class="line-added"> 154         // this may fail if IPv4 is not supported - it&#39;s ok</span>
<span class="line-added"> 155         setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&amp;off, sizeof(off));</span>
<span class="line-added"> 156     }</span>
 157 
<a name="9" id="anc9"></a><span class="line-added"> 158     dontcare.i = 0;  /* keep compiler happy */</span>
 159     err = dbgsysSetSocketOption(fd, TCP_NODELAY, JNI_TRUE, dontcare);
 160     if (err &lt; 0) {
 161         RETURN_IO_ERROR(&quot;setsockopt TCPNODELAY failed&quot;);
 162     }
 163 
 164     return JDWPTRANSPORT_ERROR_NONE;
 165 }
 166 
 167 /* Set the SO_REUSEADDR option */
 168 static jdwpTransportError
 169 setReuseAddrOption(int fd)
 170 {
 171     jvalue dontcare;
 172     int err;
 173 
 174     dontcare.i = 0;  /* keep compiler happy */
 175 
 176     err = dbgsysSetSocketOption(fd, SO_REUSEADDR, JNI_TRUE, dontcare);
 177     if (err &lt; 0) {
 178         RETURN_IO_ERROR(&quot;setsockopt SO_REUSEADDR failed&quot;);
 179     }
 180 
 181     return JDWPTRANSPORT_ERROR_NONE;
 182 }
 183 
 184 static jdwpTransportError
 185 handshake(int fd, jlong timeout) {
 186     const char *hello = &quot;JDWP-Handshake&quot;;
 187     char b[16];
 188     int rv, helloLen, received;
 189 
 190     if (timeout &gt; 0) {
 191         dbgsysConfigureBlocking(fd, JNI_FALSE);
 192     }
 193     helloLen = (int)strlen(hello);
 194     received = 0;
 195     while (received &lt; helloLen) {
 196         int n;
 197         char *buf;
 198         if (timeout &gt; 0) {
 199             rv = dbgsysPoll(fd, JNI_TRUE, JNI_FALSE, (long)timeout);
 200             if (rv &lt;= 0) {
 201                 setLastError(0, &quot;timeout during handshake&quot;);
 202                 return JDWPTRANSPORT_ERROR_IO_ERROR;
 203             }
 204         }
 205         buf = b;
 206         buf += received;
 207         n = recv_fully(fd, buf, helloLen-received);
 208         if (n == 0) {
 209             setLastError(0, &quot;handshake failed - connection prematurally closed&quot;);
 210             return JDWPTRANSPORT_ERROR_IO_ERROR;
 211         }
 212         if (n &lt; 0) {
 213             RETURN_IO_ERROR(&quot;recv failed during handshake&quot;);
 214         }
 215         received += n;
 216     }
 217     if (timeout &gt; 0) {
 218         dbgsysConfigureBlocking(fd, JNI_TRUE);
 219     }
 220     if (strncmp(b, hello, received) != 0) {
 221         char msg[80+2*16];
 222         b[received] = &#39;\0&#39;;
 223         /*
 224          * We should really use snprintf here but it&#39;s not available on Windows.
 225          * We can&#39;t use jio_snprintf without linking the transport against the VM.
 226          */
 227         sprintf(msg, &quot;handshake failed - received &gt;%s&lt; - expected &gt;%s&lt;&quot;, b, hello);
 228         setLastError(0, msg);
 229         return JDWPTRANSPORT_ERROR_IO_ERROR;
 230     }
 231 
 232     if (send_fully(fd, (char*)hello, helloLen) != helloLen) {
 233         RETURN_IO_ERROR(&quot;send failed during handshake&quot;);
 234     }
 235     return JDWPTRANSPORT_ERROR_NONE;
 236 }
 237 
<a name="10" id="anc10"></a>
























 238 static int
 239 getPortNumber(const char *s_port) {
 240     u_long n;
 241     char *eptr;
 242 
 243     if (*s_port == 0) {
 244         // bad address - colon with no port number in parameters
 245         return -1;
 246     }
 247 
 248     n = strtoul(s_port, &amp;eptr, 10);
 249     if (eptr != s_port + strlen(s_port)) {
 250         // incomplete conversion - port number contains non-digit
 251         return -1;
 252     }
 253 
 254     if (n &gt; (u_short) -1) {
 255         // check that value supplied by user is less than
 256         // maximum possible u_short value (65535) and
 257         // will not be truncated later.
 258         return -1;
 259     }
 260 
 261     return n;
 262 }
 263 
<a name="11" id="anc11"></a><span class="line-modified"> 264 static unsigned short getPort(struct sockaddr *sa)</span>
<span class="line-modified"> 265 {</span>
<span class="line-modified"> 266     return dbgsysNetworkToHostShort(sa-&gt;sa_family == AF_INET</span>
<span class="line-modified"> 267                                     ? (((struct sockaddr_in*)sa)-&gt;sin_port)</span>
<span class="line-modified"> 268                                     : (((struct sockaddr_in6*)sa)-&gt;sin6_port));</span>
<span class="line-modified"> 269 }</span>

 270 
<a name="12" id="anc12"></a><span class="line-modified"> 271 /*</span>
<span class="line-modified"> 272  * Parses scope id.</span>
<span class="line-modified"> 273  * Scope id is ulong on Windows, uint32 on unix, so returns long which can be cast to uint32.</span>
<span class="line-modified"> 274  * On error sets last error and returns -1.</span>
<span class="line-modified"> 275  */</span>
<span class="line-added"> 276 static long parseScopeId(const char *str) {</span>
<span class="line-added"> 277     // try to handle scope as interface name</span>
<span class="line-added"> 278     unsigned long scopeId = if_nametoindex(str);</span>
<span class="line-added"> 279     if (scopeId == 0) {</span>
<span class="line-added"> 280         // try to parse integer value</span>
<span class="line-added"> 281         char *end;</span>
<span class="line-added"> 282         scopeId = strtoul(str, &amp;end, 10);</span>
<span class="line-added"> 283         if (*end != &#39;\0&#39;) {</span>
<span class="line-added"> 284             setLastError(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;failed to parse scope&quot;);</span>
<span class="line-added"> 285             return -1;</span>
<span class="line-added"> 286         }</span>
 287     }
<a name="13" id="anc13"></a><span class="line-modified"> 288     // ensure parsed value is in uint32 range</span>
<span class="line-modified"> 289     if (scopeId &gt; 0xFFFFFFFF) {</span>
<span class="line-modified"> 290         setLastError(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;scope is out of range&quot;);</span>
<span class="line-modified"> 291         return -1;</span>
<span class="line-modified"> 292     }</span>
<span class="line-modified"> 293     return (long)scopeId;</span>
<span class="line-modified"> 294 }</span>
<span class="line-modified"> 295 </span>
<span class="line-modified"> 296 /*</span>
<span class="line-modified"> 297  * Wrapper for dbgsysGetAddrInfo (getaddrinfo).</span>
<span class="line-modified"> 298  * Handles enclosing square brackets and scopes.</span>
<span class="line-modified"> 299  */</span>
<span class="line-modified"> 300 static jdwpTransportError</span>
<span class="line-modified"> 301 getAddrInfo(const char *hostname, size_t hostnameLen,</span>
<span class="line-modified"> 302             const char *service,</span>
<span class="line-modified"> 303             const struct addrinfo *hints,</span>
<span class="line-modified"> 304             struct addrinfo **result)</span>
<span class="line-modified"> 305 {</span>
<span class="line-modified"> 306     int err = 0;</span>
<span class="line-added"> 307     char *buffer = NULL;</span>
<span class="line-added"> 308     long scopeId = 0;</span>
<span class="line-added"> 309 </span>
<span class="line-added"> 310     if (hostname != NULL) {</span>
<span class="line-added"> 311         char *scope = NULL;</span>
<span class="line-added"> 312         // skip surrounding</span>
<span class="line-added"> 313         if (hostnameLen &gt; 2 &amp;&amp; hostname[0] == &#39;[&#39; &amp;&amp; hostname[hostnameLen - 1] == &#39;]&#39;) {</span>
<span class="line-added"> 314             hostname++;</span>
<span class="line-added"> 315             hostnameLen -= 2;</span>
<span class="line-added"> 316         }</span>
<span class="line-added"> 317         buffer = (*callback-&gt;alloc)((int)hostnameLen + 1);</span>
<span class="line-added"> 318         if (buffer == NULL) {</span>
 319             RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
 320         }
<a name="14" id="anc14"></a><span class="line-modified"> 321         memcpy(buffer, hostname, hostnameLen);</span>
<span class="line-modified"> 322         buffer[hostnameLen] = &#39;\0&#39;;</span>
<span class="line-modified"> 323 </span>
<span class="line-modified"> 324         scope = strchr(buffer, &#39;%&#39;);</span>
<span class="line-modified"> 325         if (scope != NULL) {</span>
<span class="line-modified"> 326             // drop scope from the address</span>
<span class="line-modified"> 327             *scope = &#39;\0&#39;;</span>
<span class="line-modified"> 328             // and parse the value</span>
<span class="line-modified"> 329             scopeId = parseScopeId(scope + 1);</span>
<span class="line-modified"> 330             if (scopeId &lt; 0) {</span>
<span class="line-modified"> 331                 (*callback-&gt;free)(buffer);</span>
<span class="line-modified"> 332                 return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;</span>












 333             }
<a name="15" id="anc15"></a><span class="line-added"> 334         }</span>
<span class="line-added"> 335     }</span>
 336 
<a name="16" id="anc16"></a><span class="line-modified"> 337     err = dbgsysGetAddrInfo(buffer, service, hints, result);</span>
<span class="line-modified"> 338 </span>
<span class="line-modified"> 339     if (buffer != NULL) {</span>
<span class="line-modified"> 340         (*callback-&gt;free)(buffer);</span>
<span class="line-modified"> 341     }</span>
<span class="line-added"> 342     if (err != 0) {</span>
<span class="line-added"> 343         setLastError(err, &quot;getaddrinfo: failed to parse address&quot;);</span>
<span class="line-added"> 344         return JDWPTRANSPORT_ERROR_IO_ERROR;</span>
<span class="line-added"> 345     }</span>
<span class="line-added"> 346 </span>
<span class="line-added"> 347     if (scopeId &gt; 0) {</span>
<span class="line-added"> 348         if ((*result)-&gt;ai_family != AF_INET6) {</span>
<span class="line-added"> 349             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;IPv4 address cannot contain scope&quot;);</span>
 350         }
 351 
<a name="17" id="anc17"></a><span class="line-modified"> 352         ((struct sockaddr_in6 *)((*result)-&gt;ai_addr))-&gt;sin6_scope_id = (uint32_t)scopeId;</span>
 353     }
 354 
 355     return JDWPTRANSPORT_ERROR_NONE;
 356 }
 357 
<a name="18" id="anc18"></a><span class="line-modified"> 358 /*</span>
<span class="line-modified"> 359  * Result must be released with dbgsysFreeAddrInfo.</span>
<span class="line-modified"> 360  */</span>
<span class="line-modified"> 361 static jdwpTransportError</span>
<span class="line-modified"> 362 parseAddress(const char *address, struct addrinfo **result) {</span>
<span class="line-modified"> 363     const char *colon;</span>
<span class="line-modified"> 364     size_t hostnameLen;</span>
<span class="line-modified"> 365     const char *port;</span>
<span class="line-modified"> 366     struct addrinfo hints;</span>
<span class="line-modified"> 367 </span>
<span class="line-modified"> 368     *result = NULL;</span>
<span class="line-modified"> 369 </span>
<span class="line-modified"> 370     /* check for host:port or port */</span>
<span class="line-modified"> 371     colon = strrchr(address, &#39;:&#39;);</span>
<span class="line-modified"> 372     port = (colon == NULL ? address : colon + 1);</span>
<span class="line-modified"> 373 </span>
<span class="line-modified"> 374     /* ensure the port is valid (getaddrinfo allows port to be empty) */</span>
<span class="line-modified"> 375     if (getPortNumber(port) &lt; 0) {</span>
<span class="line-modified"> 376         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;invalid port number specified&quot;);</span>
<span class="line-modified"> 377     }</span>
<span class="line-modified"> 378 </span>
<span class="line-modified"> 379     memset (&amp;hints, 0, sizeof(hints));</span>
<span class="line-added"> 380     hints.ai_family = allowOnlyIPv4 ? AF_INET : AF_UNSPEC;</span>
<span class="line-added"> 381     hints.ai_socktype = SOCK_STREAM;</span>
<span class="line-added"> 382     hints.ai_protocol = IPPROTO_TCP;</span>
<span class="line-added"> 383     hints.ai_flags = AI_NUMERICSERV;    // port must be a number</span>
<span class="line-added"> 384 </span>
<span class="line-added"> 385     hostnameLen = (colon == NULL ? 0 : colon - address);</span>
<span class="line-added"> 386     if (hostnameLen == 0) {</span>
<span class="line-added"> 387         /* no hostname - use localhost address (pass NULL to getaddrinfo) */</span>
<span class="line-added"> 388         address = NULL;</span>
<span class="line-added"> 389     } else  if (*address == &#39;*&#39; &amp;&amp; hostnameLen == 1) {</span>
<span class="line-added"> 390         /* *:port - listen on all interfaces</span>
<span class="line-added"> 391          * use IPv6 socket (to accept IPv6 and mapped IPv4),</span>
<span class="line-added"> 392          * pass hostname == NULL to getaddrinfo.</span>
<span class="line-added"> 393          */</span>
<span class="line-added"> 394         hints.ai_family = allowOnlyIPv4 ? AF_INET : AF_INET6;</span>
<span class="line-added"> 395         hints.ai_flags |= AI_PASSIVE | (allowOnlyIPv4 ? 0 : AI_V4MAPPED | AI_ALL);</span>
<span class="line-added"> 396         address = NULL;</span>
 397     }
 398 
<a name="19" id="anc19"></a><span class="line-modified"> 399     return getAddrInfo(address, hostnameLen, port, &amp;hints, result);</span>

 400 }
 401 
<a name="20" id="anc20"></a><span class="line-modified"> 402 /*</span>
<span class="line-modified"> 403  * Input is sockaddr just because all clients have it.</span>
<span class="line-modified"> 404  */</span>
<span class="line-modified"> 405 static void convertIPv4ToIPv6(const struct sockaddr *addr4, struct in6_addr *addr6) {</span>
<span class="line-modified"> 406     // Implement in a platform-independent way.</span>
<span class="line-modified"> 407     // Spec requires in_addr has s_addr member, in6_addr has s6_addr[16] member.</span>
<span class="line-added"> 408     struct in_addr *a4 = &amp;(((struct sockaddr_in*)addr4)-&gt;sin_addr);</span>
<span class="line-added"> 409     memset(addr6, 0, sizeof(*addr6));   // for safety</span>
<span class="line-added"> 410 </span>
<span class="line-added"> 411     // Mapped address contains 80 zero bits, then 16 &quot;1&quot; bits, then IPv4 address (4 bytes).</span>
<span class="line-added"> 412     addr6-&gt;s6_addr[10] = addr6-&gt;s6_addr[11] = 0xFF;</span>
<span class="line-added"> 413     memcpy(&amp;(addr6-&gt;s6_addr[12]), &amp;(a4-&gt;s_addr), 4);</span>
<span class="line-added"> 414 }</span>
 415 
<a name="21" id="anc21"></a><span class="line-modified"> 416 /*</span>
<span class="line-modified"> 417  * Parses address (IPv4 or IPv6), fills in result by parsed address.</span>
<span class="line-modified"> 418  * For IPv4 mapped IPv6 is returned in result, isIPv4 is set.</span>
<span class="line-added"> 419  */</span>
<span class="line-added"> 420 static jdwpTransportError</span>
<span class="line-added"> 421 parseAllowedAddr(const char *buffer, struct in6_addr *result, int *isIPv4) {</span>
<span class="line-added"> 422     struct addrinfo hints;</span>
<span class="line-added"> 423     struct addrinfo *addrInfo = NULL;</span>
<span class="line-added"> 424     jdwpTransportError err;</span>
<span class="line-added"> 425 </span>
<span class="line-added"> 426     /*</span>
<span class="line-added"> 427      * To parse both IPv4 and IPv6 need to specify AF_UNSPEC family</span>
<span class="line-added"> 428      * (with AF_INET6 IPv4 addresses are not parsed even with AI_V4MAPPED and AI_ALL flags).</span>
<span class="line-added"> 429      */</span>
<span class="line-added"> 430     memset (&amp;hints, 0, sizeof(hints));</span>
<span class="line-added"> 431     hints.ai_family = AF_UNSPEC;            // IPv6 or mapped IPv4</span>
<span class="line-added"> 432     hints.ai_socktype = SOCK_STREAM;</span>
<span class="line-added"> 433     hints.ai_protocol = IPPROTO_TCP;</span>
<span class="line-added"> 434     hints.ai_flags = AI_NUMERICHOST;        // only numeric addresses, no resolution</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436     err = getAddrInfo(buffer, strlen(buffer), NULL, &amp;hints, &amp;addrInfo);</span>
<span class="line-added"> 437 </span>
<span class="line-added"> 438     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-added"> 439         return err;</span>
<span class="line-added"> 440     }</span>
<span class="line-added"> 441 </span>
<span class="line-added"> 442     if (addrInfo-&gt;ai_family == AF_INET6) {</span>
<span class="line-added"> 443         memcpy(result, &amp;(((struct sockaddr_in6 *)(addrInfo-&gt;ai_addr))-&gt;sin6_addr), sizeof(*result));</span>
<span class="line-added"> 444         *isIPv4 = 0;</span>
<span class="line-added"> 445     } else {    // IPv4 address - convert to mapped IPv6</span>
<span class="line-added"> 446         struct in6_addr addr6;</span>
<span class="line-added"> 447         convertIPv4ToIPv6(addrInfo-&gt;ai_addr, &amp;addr6);</span>
<span class="line-added"> 448         memcpy(result, &amp;addr6, sizeof(*result));</span>
<span class="line-added"> 449         *isIPv4 = 1;</span>
<span class="line-added"> 450     }</span>
<span class="line-added"> 451 </span>
<span class="line-added"> 452     dbgsysFreeAddrInfo(addrInfo);</span>
<span class="line-added"> 453 </span>
<span class="line-added"> 454     return JDWPTRANSPORT_ERROR_NONE;</span>
<span class="line-added"> 455 }</span>
<span class="line-added"> 456 </span>
<span class="line-added"> 457 /*</span>
<span class="line-added"> 458  * Parses prefix length from buffer (integer value), fills in result with corresponding net mask.</span>
<span class="line-added"> 459  * For IPv4 (isIPv4 is set), maximum prefix length is 32 bit, for IPv6 - 128 bit.</span>
<span class="line-added"> 460  */</span>
<span class="line-added"> 461 static jdwpTransportError</span>
<span class="line-added"> 462 parseAllowedMask(const char *buffer, int isIPv4, struct in6_addr *result) {</span>
<span class="line-added"> 463     int prefixLen = 0;</span>
<span class="line-added"> 464     int maxValue = isIPv4 ? 32 : 128;</span>
<span class="line-added"> 465     int i;</span>
<span class="line-added"> 466 </span>
<span class="line-added"> 467     do {</span>
<span class="line-added"> 468         if (*buffer &lt; &#39;0&#39; || *buffer &gt; &#39;9&#39;) {</span>
<span class="line-added"> 469             return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;</span>
 470         }
<a name="22" id="anc22"></a><span class="line-modified"> 471         prefixLen = prefixLen * 10 + (*buffer - &#39;0&#39;);</span>
<span class="line-modified"> 472         if (prefixLen &gt; maxValue) {  // avoid overflow</span>
<span class="line-added"> 473             return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;</span>
 474         }
<a name="23" id="anc23"></a><span class="line-modified"> 475         buffer++;</span>
<span class="line-modified"> 476     } while (*buffer != &#39;\0&#39;);</span>
<span class="line-added"> 477 </span>
<span class="line-added"> 478     if (isIPv4) {</span>
<span class="line-added"> 479         // IPv4 are stored as mapped IPv6, prefixLen needs to be converted too</span>
<span class="line-added"> 480         prefixLen += 96;</span>
 481     }
 482 
<a name="24" id="anc24"></a><span class="line-modified"> 483     if (prefixLen == 0) {</span>
<span class="line-modified"> 484         return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;</span>

 485     }
 486 
<a name="25" id="anc25"></a><span class="line-modified"> 487     // generate mask for prefix length</span>
<span class="line-modified"> 488     memset(result, 0, sizeof(*result));</span>

 489 
<a name="26" id="anc26"></a><span class="line-modified"> 490     // prefixLen &lt;= 128, so we won&#39;t go over result&#39;s size</span>
<span class="line-modified"> 491     for (i = 0; prefixLen &gt; 0; i++, prefixLen -= 8) {</span>
<span class="line-modified"> 492         if (prefixLen &gt;= 8) {</span>
<span class="line-added"> 493             // set the whole byte</span>
<span class="line-added"> 494             result-&gt;s6_addr[i] = 0xFF;</span>
<span class="line-added"> 495         } else {</span>
<span class="line-added"> 496             // set only &quot;prefixLen&quot; bits</span>
<span class="line-added"> 497             result-&gt;s6_addr[i] = (char)(0xFF &lt;&lt; (8 - prefixLen));</span>
<span class="line-added"> 498         }</span>
<span class="line-added"> 499     }</span>
<span class="line-added"> 500 </span>
<span class="line-added"> 501     return JDWPTRANSPORT_ERROR_NONE;</span>
 502 }
 503 
<a name="27" id="anc27"></a><span class="line-added"> 504 /*</span>
<span class="line-added"> 505  * Internal implementation of parseAllowedPeers (requires writable buffer).</span>
<span class="line-added"> 506  */</span>
 507 static jdwpTransportError
<a name="28" id="anc28"></a><span class="line-modified"> 508 parseAllowedPeersInternal(char *buffer) {</span>
<span class="line-modified"> 509     char *next;</span>
<span class="line-modified"> 510     int isIPv4 = 0;</span>
<span class="line-modified"> 511 </span>
<span class="line-modified"> 512     do {</span>
<span class="line-modified"> 513         char *mask = NULL;</span>
<span class="line-modified"> 514         char *endOfAddr = strpbrk(buffer, &quot;/+&quot;);</span>
<span class="line-modified"> 515         if (endOfAddr == NULL) {</span>
<span class="line-modified"> 516             // this is the last address and there is no prefix length</span>
<span class="line-modified"> 517             next = NULL;</span>
<span class="line-modified"> 518         } else {</span>
<span class="line-added"> 519             next = endOfAddr + 1;</span>
<span class="line-added"> 520             if (*endOfAddr == &#39;/&#39;) {</span>
<span class="line-added"> 521                 // mask (prefix length) presents</span>
<span class="line-added"> 522                 char *endOfMask = strchr(next, &#39;+&#39;);</span>
<span class="line-added"> 523                 mask = next;</span>
<span class="line-added"> 524                 if (endOfMask == NULL) {</span>
<span class="line-added"> 525                     // no more addresses</span>
<span class="line-added"> 526                     next = NULL;</span>
<span class="line-added"> 527                 } else {</span>
<span class="line-added"> 528                     next = endOfMask + 1;</span>
<span class="line-added"> 529                     *endOfMask = &#39;\0&#39;;</span>
<span class="line-added"> 530                 }</span>
<span class="line-added"> 531             }</span>
<span class="line-added"> 532             *endOfAddr = &#39;\0&#39;;</span>
<span class="line-added"> 533         }</span>
<span class="line-added"> 534 </span>
<span class="line-added"> 535         // parse subnet address (IPv4 is stored as mapped IPv6)</span>
<span class="line-added"> 536         if (parseAllowedAddr(buffer, &amp;(_peers[_peers_cnt].subnet), &amp;isIPv4) != JDWPTRANSPORT_ERROR_NONE) {</span>
 537             _peers_cnt = 0;
<a name="29" id="anc29"></a><span class="line-modified"> 538             fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, buffer);</span>
 539             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
 540                          &quot;invalid IP address in allow option&quot;);
 541         }
<a name="30" id="anc30"></a><span class="line-modified"> 542         if (mask != NULL) {</span>
<span class="line-modified"> 543             size_t i;</span>
<span class="line-modified"> 544             if (parseAllowedMask(mask, isIPv4, &amp;(_peers[_peers_cnt].netmask)) != JDWPTRANSPORT_ERROR_NONE) {</span>



 545                 _peers_cnt = 0;
<a name="31" id="anc31"></a><span class="line-modified"> 546                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, mask);</span>
 547                 RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
 548                              &quot;invalid netmask in allow option&quot;);
 549             }
<a name="32" id="anc32"></a><span class="line-added"> 550             // for safety update subnet to satisfy the mask</span>
<span class="line-added"> 551             for (i = 0; i &lt; sizeof(_peers[_peers_cnt].subnet); i++) {</span>
<span class="line-added"> 552                 _peers[_peers_cnt].subnet.s6_addr[i] &amp;= _peers[_peers_cnt].netmask.s6_addr[i];</span>
<span class="line-added"> 553             }</span>
 554         } else {
<a name="33" id="anc33"></a><span class="line-modified"> 555             memset(&amp;(_peers[_peers_cnt].netmask), 0xFF, sizeof(_peers[_peers_cnt].netmask));</span>

 556         }
<a name="34" id="anc34"></a><span class="line-added"> 557         _peers_cnt++;</span>
<span class="line-added"> 558         buffer = next;</span>
<span class="line-added"> 559     } while (next != NULL);</span>
 560 
<a name="35" id="anc35"></a><span class="line-modified"> 561     return JDWPTRANSPORT_ERROR_NONE;</span>
<span class="line-modified"> 562 }</span>
<span class="line-modified"> 563 </span>
<span class="line-modified"> 564 /*</span>
<span class="line-modified"> 565  * Parses &#39;allow&#39; argument (fills in list of allowed peers (global _peers variable)).</span>
<span class="line-modified"> 566  * &#39;Allow&#39; value consists of tokens separated by &#39;+&#39;,</span>
<span class="line-modified"> 567  * each token contains IP address (IPv4 or IPv6) and optional prefixLength:</span>
<span class="line-modified"> 568  * &#39;&lt;addr&gt;[/&lt;prefixLength&gt;]&#39;.</span>
<span class="line-modified"> 569  * Example: &#39;192.168.1.10+192.168.0.0/24&#39;</span>
<span class="line-modified"> 570  *   - connections are allowed from 192.168.1.10 and subnet 192.168.0.XX.</span>
<span class="line-modified"> 571  */</span>
<span class="line-modified"> 572 static jdwpTransportError</span>
<span class="line-modified"> 573 parseAllowedPeers(const char *allowed_peers, size_t len) {</span>
<span class="line-modified"> 574     // Build a list of allowed peers from char string</span>
<span class="line-modified"> 575     // of format 192.168.0.10+192.168.0.0/24</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577     // writable copy of the value</span>
<span class="line-added"> 578     char *buffer = (*callback-&gt;alloc)((int)len + 1);</span>
<span class="line-added"> 579     if (buffer == NULL) {</span>
<span class="line-added"> 580         RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);</span>
<span class="line-added"> 581     }</span>
<span class="line-added"> 582     memcpy(buffer, allowed_peers, len);</span>
<span class="line-added"> 583     buffer[len] = &#39;\0&#39;;</span>
<span class="line-added"> 584 </span>
<span class="line-added"> 585     jdwpTransportError err = parseAllowedPeersInternal(buffer);</span>
<span class="line-added"> 586 </span>
<span class="line-added"> 587     (*callback-&gt;free)(buffer);</span>
<span class="line-added"> 588 </span>
<span class="line-added"> 589     return err;</span>
<span class="line-added"> 590 }</span>
<span class="line-added"> 591 </span>
<span class="line-added"> 592 static int</span>
<span class="line-added"> 593 isAddressInSubnet(const struct in6_addr *address, const struct in6_addr *subnet, const struct in6_addr *mask) {</span>
<span class="line-added"> 594     size_t i;</span>
<span class="line-added"> 595     for (i = 0; i &lt; sizeof(struct in6_addr); i++) {</span>
<span class="line-added"> 596         if ((address-&gt;s6_addr[i] &amp; mask-&gt;s6_addr[i]) != subnet-&gt;s6_addr[i]) {</span>
<span class="line-added"> 597             return 0;</span>
 598         }
 599     }
<a name="36" id="anc36"></a><span class="line-modified"> 600     return 1;</span>
 601 }
 602 
 603 static int
<a name="37" id="anc37"></a><span class="line-modified"> 604 isPeerAllowed(struct sockaddr_storage *peer) {</span>
<span class="line-added"> 605     struct in6_addr tmp;</span>
<span class="line-added"> 606     struct in6_addr *addr6;</span>
 607     int i;
<a name="38" id="anc38"></a><span class="line-added"> 608     // _peers contains IPv6 subnet and mask (IPv4 is converted to mapped IPv6)</span>
<span class="line-added"> 609     if (peer-&gt;ss_family == AF_INET) {</span>
<span class="line-added"> 610         convertIPv4ToIPv6((struct sockaddr *)peer, &amp;tmp);</span>
<span class="line-added"> 611         addr6 = &amp;tmp;</span>
<span class="line-added"> 612     } else {</span>
<span class="line-added"> 613         addr6 = &amp;(((struct sockaddr_in6 *)peer)-&gt;sin6_addr);</span>
<span class="line-added"> 614     }</span>
<span class="line-added"> 615 </span>
 616     for (i = 0; i &lt; _peers_cnt; ++i) {
<a name="39" id="anc39"></a><span class="line-modified"> 617         if (isAddressInSubnet(addr6, &amp;(_peers[i].subnet), &amp;(_peers[i].netmask))) {</span>

 618             return 1;
 619         }
 620     }
 621 
 622     return 0;
 623 }
 624 
 625 static jdwpTransportError JNICALL
 626 socketTransport_getCapabilities(jdwpTransportEnv* env,
 627         JDWPTransportCapabilities* capabilitiesPtr)
 628 {
 629     JDWPTransportCapabilities result;
 630 
 631     memset(&amp;result, 0, sizeof(result));
 632     result.can_timeout_attach = JNI_TRUE;
 633     result.can_timeout_accept = JNI_TRUE;
 634     result.can_timeout_handshake = JNI_TRUE;
 635 
 636     *capabilitiesPtr = result;
 637 
 638     return JDWPTRANSPORT_ERROR_NONE;
 639 }
 640 
<a name="40" id="anc40"></a><span class="line-modified"> 641 /*</span>
<span class="line-modified"> 642  * Starts listening on the specified addrinfo,</span>
<span class="line-modified"> 643  * returns listening socket and actual listening port.</span>
<span class="line-modified"> 644  * If the function fails and returned socket != -1, the socket should be closed.</span>
<span class="line-added"> 645  */</span>
<span class="line-added"> 646 static jdwpTransportError startListening(struct addrinfo *ai, int *socket, char** actualAddress)</span>
 647 {
<a name="41" id="anc41"></a>
 648     int err;
 649 
<a name="42" id="anc42"></a><span class="line-modified"> 650     *socket = dbgsysSocket(ai-&gt;ai_family, SOCK_STREAM, IPPROTO_TCP);</span>
<span class="line-modified"> 651     if (*socket &lt; 0) {</span>













 652         RETURN_IO_ERROR(&quot;socket creation failed&quot;);
 653     }
 654 
<a name="43" id="anc43"></a><span class="line-modified"> 655     err = setOptionsCommon(ai-&gt;ai_family, *socket);</span>
 656     if (err) {
 657         return err;
 658     }
<a name="44" id="anc44"></a><span class="line-modified"> 659 </span>
<span class="line-added"> 660     if (getPort(ai-&gt;ai_addr) != 0) {</span>
 661         /*
 662          * Only need SO_REUSEADDR if we&#39;re using a fixed port. If we
 663          * start seeing EADDRINUSE due to collisions in free ports
 664          * then we should retry the dbgsysBind() a few times.
 665          */
<a name="45" id="anc45"></a><span class="line-modified"> 666         err = setReuseAddrOption(*socket);</span>
 667         if (err) {
 668             return err;
 669         }
 670     }
 671 
<a name="46" id="anc46"></a><span class="line-modified"> 672     err = dbgsysBind(*socket, ai-&gt;ai_addr, (socklen_t)ai-&gt;ai_addrlen);</span>
 673     if (err &lt; 0) {
 674         RETURN_IO_ERROR(&quot;bind failed&quot;);
 675     }
 676 
<a name="47" id="anc47"></a><span class="line-modified"> 677     err = dbgsysListen(*socket, 1); // only 1 debugger can attach</span>
 678     if (err &lt; 0) {
 679         RETURN_IO_ERROR(&quot;listen failed&quot;);
 680     }
 681 
 682     {
 683         char buf[20];
<a name="48" id="anc48"></a><span class="line-modified"> 684         struct sockaddr_storage addr;</span>
<span class="line-added"> 685         socklen_t len = sizeof(addr);</span>
 686         jint portNum;
<a name="49" id="anc49"></a><span class="line-modified"> 687         err = dbgsysGetSocketName(*socket, (struct sockaddr *)&amp;addr, &amp;len);</span>
<span class="line-modified"> 688         if (err != 0) {</span>
<span class="line-modified"> 689             RETURN_IO_ERROR(&quot;getsockname failed&quot;);</span>
<span class="line-added"> 690         }</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692         portNum = getPort((struct sockaddr *)&amp;addr);</span>
 693         sprintf(buf, &quot;%d&quot;, portNum);
 694         *actualAddress = (*callback-&gt;alloc)((int)strlen(buf) + 1);
 695         if (*actualAddress == NULL) {
 696             RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
 697         } else {
 698             strcpy(*actualAddress, buf);
 699         }
 700     }
 701 
 702     return JDWPTRANSPORT_ERROR_NONE;
 703 }
 704 
<a name="50" id="anc50"></a><span class="line-added"> 705 static jdwpTransportError JNICALL</span>
<span class="line-added"> 706 socketTransport_startListening(jdwpTransportEnv* env, const char* address,</span>
<span class="line-added"> 707                                char** actualAddress)</span>
<span class="line-added"> 708 {</span>
<span class="line-added"> 709     int err;</span>
<span class="line-added"> 710     int pass;</span>
<span class="line-added"> 711     struct addrinfo *addrInfo = NULL;</span>
<span class="line-added"> 712     struct addrinfo *listenAddr = NULL;</span>
<span class="line-added"> 713     struct addrinfo *ai = NULL;</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715     /* no address provided */</span>
<span class="line-added"> 716     if ((address == NULL) || (address[0] == &#39;\0&#39;)) {</span>
<span class="line-added"> 717         address = &quot;0&quot;;</span>
<span class="line-added"> 718     }</span>
<span class="line-added"> 719 </span>
<span class="line-added"> 720     err = parseAddress(address, &amp;addrInfo);</span>
<span class="line-added"> 721     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-added"> 722         return err;</span>
<span class="line-added"> 723     }</span>
<span class="line-added"> 724 </span>
<span class="line-added"> 725     /* 1st pass - preferredAddressFamily (by default IPv4), 2nd pass - the rest */</span>
<span class="line-added"> 726     for (pass = 0; pass &lt; 2 &amp;&amp; listenAddr == NULL; pass++) {</span>
<span class="line-added"> 727         for (ai = addrInfo; ai != NULL; ai = ai-&gt;ai_next) {</span>
<span class="line-added"> 728             if ((pass == 0 &amp;&amp; ai-&gt;ai_family == preferredAddressFamily) ||</span>
<span class="line-added"> 729                 (pass == 1 &amp;&amp; ai-&gt;ai_family != preferredAddressFamily))</span>
<span class="line-added"> 730             {</span>
<span class="line-added"> 731                 listenAddr = ai;</span>
<span class="line-added"> 732                 break;</span>
<span class="line-added"> 733             }</span>
<span class="line-added"> 734         }</span>
<span class="line-added"> 735     }</span>
<span class="line-added"> 736 </span>
<span class="line-added"> 737     if (listenAddr == NULL) {</span>
<span class="line-added"> 738         dbgsysFreeAddrInfo(addrInfo);</span>
<span class="line-added"> 739         RETURN_ERROR(JDWPTRANSPORT_ERROR_INTERNAL, &quot;listen failed: wrong address&quot;);</span>
<span class="line-added"> 740     }</span>
<span class="line-added"> 741 </span>
<span class="line-added"> 742     err = startListening(listenAddr, &amp;serverSocketFD, actualAddress);</span>
<span class="line-added"> 743 </span>
<span class="line-added"> 744     dbgsysFreeAddrInfo(addrInfo);</span>
<span class="line-added"> 745 </span>
<span class="line-added"> 746     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-added"> 747         if (serverSocketFD &gt;= 0) {</span>
<span class="line-added"> 748             dbgsysSocketClose(serverSocketFD);</span>
<span class="line-added"> 749             serverSocketFD = -1;</span>
<span class="line-added"> 750         }</span>
<span class="line-added"> 751         return err;</span>
<span class="line-added"> 752     }</span>
<span class="line-added"> 753 </span>
<span class="line-added"> 754     return JDWPTRANSPORT_ERROR_NONE;</span>
<span class="line-added"> 755 }</span>
<span class="line-added"> 756 </span>
 757 static jdwpTransportError JNICALL
 758 socketTransport_accept(jdwpTransportEnv* env, jlong acceptTimeout, jlong handshakeTimeout)
 759 {
<a name="51" id="anc51"></a>
 760     int err = JDWPTRANSPORT_ERROR_NONE;
<a name="52" id="anc52"></a><span class="line-modified"> 761     struct sockaddr_storage clientAddr;</span>
<span class="line-modified"> 762     socklen_t clientAddrLen;</span>
<span class="line-added"> 763     jlong startTime = 0;</span>
 764 
 765     /*
 766      * Use a default handshake timeout if not specified - this avoids an indefinite
 767      * hang in cases where something other than a debugger connects to our port.
 768      */
 769     if (handshakeTimeout == 0) {
 770         handshakeTimeout = 2000;
 771     }
 772 
 773     do {
 774         /*
 775          * If there is an accept timeout then we put the socket in non-blocking
 776          * mode and poll for a connection.
 777          */
 778         if (acceptTimeout &gt; 0) {
 779             int rv;
 780             dbgsysConfigureBlocking(serverSocketFD, JNI_FALSE);
 781             startTime = dbgsysCurrentTimeMillis();
 782             rv = dbgsysPoll(serverSocketFD, JNI_TRUE, JNI_FALSE, (long)acceptTimeout);
 783             if (rv &lt;= 0) {
 784                 /* set the last error here as could be overridden by configureBlocking */
 785                 if (rv == 0) {
 786                     setLastError(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;poll failed&quot;);
 787                 }
 788                 /* restore blocking state */
 789                 dbgsysConfigureBlocking(serverSocketFD, JNI_TRUE);
 790                 if (rv == 0) {
 791                     RETURN_ERROR(JDWPTRANSPORT_ERROR_TIMEOUT, &quot;timed out waiting for connection&quot;);
 792                 } else {
 793                     return JDWPTRANSPORT_ERROR_IO_ERROR;
 794                 }
 795             }
 796         }
 797 
 798         /*
 799          * Accept the connection
 800          */
<a name="53" id="anc53"></a><span class="line-modified"> 801         clientAddrLen = sizeof(clientAddr);</span>

 802         socketFD = dbgsysAccept(serverSocketFD,
<a name="54" id="anc54"></a><span class="line-modified"> 803                                 (struct sockaddr *)&amp;clientAddr,</span>
<span class="line-modified"> 804                                 &amp;clientAddrLen);</span>
 805         /* set the last error here as could be overridden by configureBlocking */
 806         if (socketFD &lt; 0) {
 807             setLastError(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;accept failed&quot;);
 808         }
 809         /*
 810          * Restore the blocking state - note that the accepted socket may be in
 811          * blocking or non-blocking mode (platform dependent). However as there
 812          * is a handshake timeout set then it will go into non-blocking mode
 813          * anyway for the handshake.
 814          */
 815         if (acceptTimeout &gt; 0) {
 816             dbgsysConfigureBlocking(serverSocketFD, JNI_TRUE);
 817         }
 818         if (socketFD &lt; 0) {
 819             return JDWPTRANSPORT_ERROR_IO_ERROR;
 820         }
 821 
 822         /*
 823          * version &gt;= JDWPTRANSPORT_VERSION_1_1:
 824          * Verify that peer is allowed to connect.
 825          */
 826         if (_peers_cnt &gt; 0) {
<a name="55" id="anc55"></a><span class="line-modified"> 827             if (!isPeerAllowed(&amp;clientAddr)) {</span>
 828                 char ebuf[64] = { 0 };
<a name="56" id="anc56"></a><span class="line-modified"> 829                 char addrStr[INET_ADDRSTRLEN] = { 0 };</span>
<span class="line-modified"> 830                 int err2 = getnameinfo((struct sockaddr *)&amp;clientAddr, clientAddrLen,</span>
<span class="line-added"> 831                                        addrStr, sizeof(addrStr), NULL, 0,</span>
<span class="line-added"> 832                                        NI_NUMERICHOST);</span>
 833                 sprintf(ebuf, &quot;ERROR: Peer not allowed to connect: %s\n&quot;,
<a name="57" id="anc57"></a><span class="line-modified"> 834                         (err2 != 0) ? &quot;&lt;bad address&gt;&quot; : addrStr);</span>
 835                 dbgsysSocketClose(socketFD);
 836                 socketFD = -1;
 837                 err = JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;
 838                 setLastError(err, ebuf);
 839             }
 840         }
 841 
 842         if (socketFD &gt; 0) {
 843           /* handshake with the debugger */
 844           err = handshake(socketFD, handshakeTimeout);
 845         }
 846 
 847         /*
 848          * If the handshake fails then close the connection. If there if an accept
 849          * timeout then we must adjust the timeout for the next poll.
 850          */
 851         if (err != JDWPTRANSPORT_ERROR_NONE) {
 852             fprintf(stderr, &quot;Debugger failed to attach: %s\n&quot;, getLastError());
 853             dbgsysSocketClose(socketFD);
 854             socketFD = -1;
 855             if (acceptTimeout &gt; 0) {
 856                 long endTime = dbgsysCurrentTimeMillis();
 857                 acceptTimeout -= (endTime - startTime);
 858                 if (acceptTimeout &lt;= 0) {
 859                     setLastError(JDWPTRANSPORT_ERROR_IO_ERROR,
 860                         &quot;timeout waiting for debugger to connect&quot;);
 861                     return JDWPTRANSPORT_ERROR_IO_ERROR;
 862                 }
 863             }
 864         }
 865     } while (socketFD &lt; 0);
 866 
 867     return JDWPTRANSPORT_ERROR_NONE;
 868 }
 869 
 870 static jdwpTransportError JNICALL
 871 socketTransport_stopListening(jdwpTransportEnv *env)
 872 {
 873     if (serverSocketFD &lt; 0) {
 874         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_STATE, &quot;connection not open&quot;);
 875     }
 876     if (dbgsysSocketClose(serverSocketFD) &lt; 0) {
 877         RETURN_IO_ERROR(&quot;close failed&quot;);
 878     }
 879     serverSocketFD = -1;
 880     return JDWPTRANSPORT_ERROR_NONE;
 881 }
 882 
<a name="58" id="anc58"></a><span class="line-modified"> 883 /*</span>
<span class="line-modified"> 884  * Tries to connect to the specified addrinfo, returns connected socket.</span>
<span class="line-modified"> 885  * If the function fails and returned socket != -1, the socket should be closed.</span>
<span class="line-modified"> 886  */</span>
<span class="line-modified"> 887 static jdwpTransportError connectToAddr(struct addrinfo *ai, jlong timeout, int *socket) {</span>
 888     int err;
 889 
<a name="59" id="anc59"></a><span class="line-modified"> 890     *socket = dbgsysSocket(ai-&gt;ai_family, ai-&gt;ai_socktype, ai-&gt;ai_protocol);</span>
<span class="line-modified"> 891     if (*socket &lt; 0) {</span>









 892         RETURN_IO_ERROR(&quot;unable to create socket&quot;);
 893     }
 894 
<a name="60" id="anc60"></a><span class="line-modified"> 895     err = setOptionsCommon(ai-&gt;ai_family, socketFD);</span>
 896     if (err) {
 897         return err;
 898     }
 899 
 900     /*
 901      * We don&#39;t call setReuseAddrOption() for the non-server socket
 902      * case. If we start seeing EADDRINUSE due to collisions in free
 903      * ports then we should retry the dbgsysConnect() a few times.
 904      */
 905 
 906     /*
 907      * To do a timed connect we make the socket non-blocking
 908      * and poll with a timeout;
 909      */
<a name="61" id="anc61"></a><span class="line-modified"> 910     if (timeout &gt; 0) {</span>
 911         dbgsysConfigureBlocking(socketFD, JNI_FALSE);
 912     }
 913 
<a name="62" id="anc62"></a><span class="line-modified"> 914     err = dbgsysConnect(socketFD, ai-&gt;ai_addr, (socklen_t)ai-&gt;ai_addrlen);</span>
<span class="line-modified"> 915 </span>
<span class="line-modified"> 916     if (err == DBG_EINPROGRESS &amp;&amp; timeout &gt; 0) {</span>
<span class="line-added"> 917         err = dbgsysFinishConnect(socketFD, (long)timeout);</span>
 918 
 919         if (err == DBG_ETIMEOUT) {
 920             dbgsysConfigureBlocking(socketFD, JNI_TRUE);
 921             RETURN_ERROR(JDWPTRANSPORT_ERROR_TIMEOUT, &quot;connect timed out&quot;);
 922         }
 923     }
 924 
<a name="63" id="anc63"></a><span class="line-modified"> 925     if (err) {</span>
 926         RETURN_IO_ERROR(&quot;connect failed&quot;);
 927     }
 928 
<a name="64" id="anc64"></a><span class="line-added"> 929     return err;</span>
<span class="line-added"> 930 }</span>
<span class="line-added"> 931 </span>
<span class="line-added"> 932 </span>
<span class="line-added"> 933 static jdwpTransportError JNICALL</span>
<span class="line-added"> 934 socketTransport_attach(jdwpTransportEnv* env, const char* addressString, jlong attachTimeout,</span>
<span class="line-added"> 935                        jlong handshakeTimeout)</span>
<span class="line-added"> 936 {</span>
<span class="line-added"> 937     int err;</span>
<span class="line-added"> 938     int pass;</span>
<span class="line-added"> 939     struct addrinfo *addrInfo = NULL;</span>
<span class="line-added"> 940     struct addrinfo *ai;</span>
<span class="line-added"> 941 </span>
<span class="line-added"> 942     if (addressString == NULL || addressString[0] == &#39;\0&#39;) {</span>
<span class="line-added"> 943         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;address is missing&quot;);</span>
<span class="line-added"> 944     }</span>
<span class="line-added"> 945 </span>
<span class="line-added"> 946     err = parseAddress(addressString, &amp;addrInfo);</span>
<span class="line-added"> 947     if (err) {</span>
<span class="line-added"> 948         return err;</span>
<span class="line-added"> 949     }</span>
<span class="line-added"> 950 </span>
<span class="line-added"> 951     /* 1st pass - preferredAddressFamily (by default IPv4), 2nd pass - the rest */</span>
<span class="line-added"> 952     for (pass = 0; pass &lt; 2 &amp;&amp; socketFD &lt; 0; pass++) {</span>
<span class="line-added"> 953         for (ai = addrInfo; ai != NULL; ai = ai-&gt;ai_next) {</span>
<span class="line-added"> 954             if ((pass == 0 &amp;&amp; ai-&gt;ai_family == preferredAddressFamily) ||</span>
<span class="line-added"> 955                 (pass == 1 &amp;&amp; ai-&gt;ai_family != preferredAddressFamily))</span>
<span class="line-added"> 956             {</span>
<span class="line-added"> 957                 err = connectToAddr(ai, attachTimeout, &amp;socketFD);</span>
<span class="line-added"> 958                 if (err == JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-added"> 959                     break;</span>
<span class="line-added"> 960                 }</span>
<span class="line-added"> 961                 if (socketFD &gt;= 0) {</span>
<span class="line-added"> 962                     dbgsysSocketClose(socketFD);</span>
<span class="line-added"> 963                     socketFD = -1;</span>
<span class="line-added"> 964                 }</span>
<span class="line-added"> 965             }</span>
<span class="line-added"> 966         }</span>
<span class="line-added"> 967     }</span>
<span class="line-added"> 968 </span>
<span class="line-added"> 969     freeaddrinfo(addrInfo);</span>
<span class="line-added"> 970 </span>
<span class="line-added"> 971     /* err from the last connectToAddr() call */</span>
<span class="line-added"> 972     if (err != 0) {</span>
<span class="line-added"> 973         return err;</span>
<span class="line-added"> 974     }</span>
<span class="line-added"> 975 </span>
 976     if (attachTimeout &gt; 0) {
 977         dbgsysConfigureBlocking(socketFD, JNI_TRUE);
 978     }
 979 
 980     err = handshake(socketFD, handshakeTimeout);
 981     if (err) {
 982         dbgsysSocketClose(socketFD);
 983         socketFD = -1;
 984         return err;
 985     }
 986 
 987     return JDWPTRANSPORT_ERROR_NONE;
 988 }
 989 
 990 static jboolean JNICALL
 991 socketTransport_isOpen(jdwpTransportEnv* env)
 992 {
 993     if (socketFD &gt;= 0) {
 994         return JNI_TRUE;
 995     } else {
 996         return JNI_FALSE;
 997     }
 998 }
 999 
1000 static jdwpTransportError JNICALL
1001 socketTransport_close(jdwpTransportEnv* env)
1002 {
1003     int fd = socketFD;
1004     socketFD = -1;
1005     if (fd &lt; 0) {
1006         return JDWPTRANSPORT_ERROR_NONE;
1007     }
1008 #ifdef _AIX
1009     /*
1010       AIX needs a workaround for I/O cancellation, see:
1011       http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/close.htm
1012       ...
1013       The close subroutine is blocked until all subroutines which use the file
1014       descriptor return to usr space. For example, when a thread is calling close
1015       and another thread is calling select with the same file descriptor, the
1016       close subroutine does not return until the select call returns.
1017       ...
1018     */
1019     shutdown(fd, 2);
1020 #endif
1021     if (dbgsysSocketClose(fd) &lt; 0) {
1022         /*
1023          * close failed - it&#39;s pointless to restore socketFD here because
1024          * any subsequent close will likely fail as well.
1025          */
1026         RETURN_IO_ERROR(&quot;close failed&quot;);
1027     }
1028     return JDWPTRANSPORT_ERROR_NONE;
1029 }
1030 
1031 static jdwpTransportError JNICALL
1032 socketTransport_writePacket(jdwpTransportEnv* env, const jdwpPacket *packet)
1033 {
1034     jint len, data_len, id;
1035     /*
1036      * room for header and up to MAX_DATA_SIZE data bytes
1037      */
1038     char header[JDWP_HEADER_SIZE + MAX_DATA_SIZE];
1039     jbyte *data;
1040 
1041     /* packet can&#39;t be null */
1042     if (packet == NULL) {
1043         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;packet is NULL&quot;);
1044     }
1045 
1046     len = packet-&gt;type.cmd.len;         /* includes header */
1047     data_len = len - JDWP_HEADER_SIZE;
1048 
1049     /* bad packet */
1050     if (data_len &lt; 0) {
1051         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;invalid length&quot;);
1052     }
1053 
1054     /* prepare the header for transmission */
1055     len = (jint)dbgsysHostToNetworkLong(len);
1056     id = (jint)dbgsysHostToNetworkLong(packet-&gt;type.cmd.id);
1057 
1058     memcpy(header + 0, &amp;len, 4);
1059     memcpy(header + 4, &amp;id, 4);
1060     header[8] = packet-&gt;type.cmd.flags;
1061     if (packet-&gt;type.cmd.flags &amp; JDWPTRANSPORT_FLAGS_REPLY) {
1062         jshort errorCode =
1063             dbgsysHostToNetworkShort(packet-&gt;type.reply.errorCode);
1064         memcpy(header + 9, &amp;errorCode, 2);
1065     } else {
1066         header[9] = packet-&gt;type.cmd.cmdSet;
1067         header[10] = packet-&gt;type.cmd.cmd;
1068     }
1069 
1070     data = packet-&gt;type.cmd.data;
1071     /* Do one send for short packets, two for longer ones */
1072     if (data_len &lt;= MAX_DATA_SIZE) {
1073         memcpy(header + JDWP_HEADER_SIZE, data, data_len);
1074         if (send_fully(socketFD, (char *)&amp;header, JDWP_HEADER_SIZE + data_len) !=
1075             JDWP_HEADER_SIZE + data_len) {
1076             RETURN_IO_ERROR(&quot;send failed&quot;);
1077         }
1078     } else {
1079         memcpy(header + JDWP_HEADER_SIZE, data, MAX_DATA_SIZE);
1080         if (send_fully(socketFD, (char *)&amp;header, JDWP_HEADER_SIZE + MAX_DATA_SIZE) !=
1081             JDWP_HEADER_SIZE + MAX_DATA_SIZE) {
1082             RETURN_IO_ERROR(&quot;send failed&quot;);
1083         }
1084         /* Send the remaining data bytes right out of the data area. */
1085         if (send_fully(socketFD, (char *)data + MAX_DATA_SIZE,
1086                        data_len - MAX_DATA_SIZE) != data_len - MAX_DATA_SIZE) {
1087             RETURN_IO_ERROR(&quot;send failed&quot;);
1088         }
1089     }
1090 
1091     return JDWPTRANSPORT_ERROR_NONE;
1092 }
1093 
1094 static jint
1095 recv_fully(int f, char *buf, int len)
1096 {
1097     int nbytes = 0;
1098     while (nbytes &lt; len) {
1099         int res = dbgsysRecv(f, buf + nbytes, len - nbytes, 0);
1100         if (res &lt; 0) {
1101             return res;
1102         } else if (res == 0) {
1103             break; /* eof, return nbytes which is less than len */
1104         }
1105         nbytes += res;
1106     }
1107     return nbytes;
1108 }
1109 
1110 jint
1111 send_fully(int f, char *buf, int len)
1112 {
1113     int nbytes = 0;
1114     while (nbytes &lt; len) {
1115         int res = dbgsysSend(f, buf + nbytes, len - nbytes, 0);
1116         if (res &lt; 0) {
1117             return res;
1118         } else if (res == 0) {
1119             break; /* eof, return nbytes which is less than len */
1120         }
1121         nbytes += res;
1122     }
1123     return nbytes;
1124 }
1125 
1126 static jdwpTransportError JNICALL
1127 socketTransport_readPacket(jdwpTransportEnv* env, jdwpPacket* packet) {
1128     jint length, data_len;
1129     jint n;
1130 
1131     /* packet can&#39;t be null */
1132     if (packet == NULL) {
1133         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;packet is null&quot;);
1134     }
1135 
1136     /* read the length field */
1137     n = recv_fully(socketFD, (char *)&amp;length, sizeof(jint));
1138 
1139     /* check for EOF */
1140     if (n == 0) {
1141         packet-&gt;type.cmd.len = 0;
1142         return JDWPTRANSPORT_ERROR_NONE;
1143     }
1144     if (n != sizeof(jint)) {
1145         RETURN_RECV_ERROR(n);
1146     }
1147 
1148     length = (jint)dbgsysNetworkToHostLong(length);
1149     packet-&gt;type.cmd.len = length;
1150 
1151 
1152     n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.cmd.id), sizeof(jint));
1153     if (n &lt; (int)sizeof(jint)) {
1154         RETURN_RECV_ERROR(n);
1155     }
1156 
1157     packet-&gt;type.cmd.id = (jint)dbgsysNetworkToHostLong(packet-&gt;type.cmd.id);
1158 
1159     n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.cmd.flags), sizeof(jbyte));
1160     if (n &lt; (int)sizeof(jbyte)) {
1161         RETURN_RECV_ERROR(n);
1162     }
1163 
1164     if (packet-&gt;type.cmd.flags &amp; JDWPTRANSPORT_FLAGS_REPLY) {
1165         n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.reply.errorCode), sizeof(jbyte));
1166         if (n &lt; (int)sizeof(jshort)) {
1167             RETURN_RECV_ERROR(n);
1168         }
1169 
1170         /* FIXME - should the error be converted to host order?? */
1171 
1172 
1173     } else {
1174         n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.cmd.cmdSet), sizeof(jbyte));
1175         if (n &lt; (int)sizeof(jbyte)) {
1176             RETURN_RECV_ERROR(n);
1177         }
1178 
1179         n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.cmd.cmd), sizeof(jbyte));
1180         if (n &lt; (int)sizeof(jbyte)) {
1181             RETURN_RECV_ERROR(n);
1182         }
1183     }
1184 
1185     data_len = length - ((sizeof(jint) * 2) + (sizeof(jbyte) * 3));
1186 
1187     if (data_len &lt; 0) {
1188         setLastError(0, &quot;Badly formed packet received - invalid length&quot;);
1189         return JDWPTRANSPORT_ERROR_IO_ERROR;
1190     } else if (data_len == 0) {
1191         packet-&gt;type.cmd.data = NULL;
1192     } else {
1193         packet-&gt;type.cmd.data= (*callback-&gt;alloc)(data_len);
1194 
1195         if (packet-&gt;type.cmd.data == NULL) {
1196             RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
1197         }
1198 
1199         n = recv_fully(socketFD,(char *)packet-&gt;type.cmd.data, data_len);
1200         if (n &lt; data_len) {
1201             (*callback-&gt;free)(packet-&gt;type.cmd.data);
1202             RETURN_RECV_ERROR(n);
1203         }
1204     }
1205 
1206     return JDWPTRANSPORT_ERROR_NONE;
1207 }
1208 
1209 static jdwpTransportError JNICALL
1210 socketTransport_getLastError(jdwpTransportEnv* env, char** msgP) {
1211     char *msg = (char *)dbgsysTlsGet(tlsIndex);
1212     if (msg == NULL) {
1213         return JDWPTRANSPORT_ERROR_MSG_NOT_AVAILABLE;
1214     }
1215     *msgP = (*callback-&gt;alloc)((int)strlen(msg)+1);
1216     if (*msgP == NULL) {
1217         return JDWPTRANSPORT_ERROR_OUT_OF_MEMORY;
1218     }
1219     strcpy(*msgP, msg);
1220     return JDWPTRANSPORT_ERROR_NONE;
1221 }
1222 
1223 static jdwpTransportError JNICALL
1224 socketTransport_setConfiguration(jdwpTransportEnv* env, jdwpTransportConfiguration* cfg) {
1225     const char* allowed_peers = NULL;
1226 
1227     if (cfg == NULL) {
1228         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
1229                      &quot;NULL pointer to transport configuration is invalid&quot;);
1230     }
1231     allowed_peers = cfg-&gt;allowed_peers;
1232     _peers_cnt = 0;
1233     if (allowed_peers != NULL) {
1234         size_t len = strlen(allowed_peers);
1235         if (len == 0) { /* Impossible: parseOptions() would reject it */
1236             fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);
1237             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
1238                          &quot;allow option should not be empty&quot;);
1239         } else if (*allowed_peers == &#39;*&#39;) {
1240             if (len != 1) {
1241                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);
1242                 RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
1243                              &quot;allow option &#39;*&#39; cannot be expanded&quot;);
1244             }
1245         } else {
<a name="65" id="anc65"></a><span class="line-modified">1246             int err = parseAllowedPeers(allowed_peers, len);</span>
1247             if (err != JDWPTRANSPORT_ERROR_NONE) {
1248                 return err;
1249             }
1250         }
1251     }
1252     return JDWPTRANSPORT_ERROR_NONE;
1253 }
1254 
<a name="66" id="anc66"></a><span class="line-added">1255 /*</span>
<span class="line-added">1256  * Reads boolean system value, sets *result to</span>
<span class="line-added">1257  *  - trueValue if the property is &quot;true&quot;;</span>
<span class="line-added">1258  *  - falseValue if the property is &quot;false&quot;.</span>
<span class="line-added">1259  * Doesn&#39;t change *result if the property is not set or failed to read.</span>
<span class="line-added">1260  */</span>
<span class="line-added">1261 static int readBooleanSysProp(int *result, int trueValue, int falseValue,</span>
<span class="line-added">1262     JNIEnv* jniEnv, jclass sysClass, jmethodID getPropMethod, const char *propName)</span>
<span class="line-added">1263 {</span>
<span class="line-added">1264     jstring value;</span>
<span class="line-added">1265     jstring name = (*jniEnv)-&gt;NewStringUTF(jniEnv, propName);</span>
<span class="line-added">1266 </span>
<span class="line-added">1267     if (name == NULL) {</span>
<span class="line-added">1268         return JNI_ERR;</span>
<span class="line-added">1269     }</span>
<span class="line-added">1270     value = (jstring)(*jniEnv)-&gt;CallStaticObjectMethod(jniEnv, sysClass, getPropMethod, name);</span>
<span class="line-added">1271     if ((*jniEnv)-&gt;ExceptionCheck(jniEnv)) {</span>
<span class="line-added">1272         return JNI_ERR;</span>
<span class="line-added">1273     }</span>
<span class="line-added">1274     if (value != NULL) {</span>
<span class="line-added">1275         const char *theValue = (*jniEnv)-&gt;GetStringUTFChars(jniEnv, value, NULL);</span>
<span class="line-added">1276         if (theValue == NULL) {</span>
<span class="line-added">1277             return JNI_ERR;</span>
<span class="line-added">1278         }</span>
<span class="line-added">1279         if (strcmp(theValue, &quot;true&quot;) == 0) {</span>
<span class="line-added">1280             *result = trueValue;</span>
<span class="line-added">1281         } else if (strcmp(theValue, &quot;false&quot;) == 0) {</span>
<span class="line-added">1282             *result = falseValue;</span>
<span class="line-added">1283         }</span>
<span class="line-added">1284         (*jniEnv)-&gt;ReleaseStringUTFChars(jniEnv, value, theValue);</span>
<span class="line-added">1285     }</span>
<span class="line-added">1286     return JNI_OK;</span>
<span class="line-added">1287 }</span>
<span class="line-added">1288 </span>
1289 JNIEXPORT jint JNICALL
1290 jdwpTransport_OnLoad(JavaVM *vm, jdwpTransportCallback* cbTablePtr,
1291                      jint version, jdwpTransportEnv** env)
1292 {
<a name="67" id="anc67"></a><span class="line-added">1293     JNIEnv* jniEnv = NULL;</span>
<span class="line-added">1294 </span>
1295     if (version &lt; JDWPTRANSPORT_VERSION_1_0 ||
1296         version &gt; JDWPTRANSPORT_VERSION_1_1) {
1297         return JNI_EVERSION;
1298     }
1299     if (initialized) {
1300         /*
1301          * This library doesn&#39;t support multiple environments (yet)
1302          */
1303         return JNI_EEXIST;
1304     }
1305     initialized = JNI_TRUE;
1306     jvm = vm;
1307     callback = cbTablePtr;
1308 
1309     /* initialize interface table */
1310     interface.GetCapabilities = &amp;socketTransport_getCapabilities;
1311     interface.Attach = &amp;socketTransport_attach;
1312     interface.StartListening = &amp;socketTransport_startListening;
1313     interface.StopListening = &amp;socketTransport_stopListening;
1314     interface.Accept = &amp;socketTransport_accept;
1315     interface.IsOpen = &amp;socketTransport_isOpen;
1316     interface.Close = &amp;socketTransport_close;
1317     interface.ReadPacket = &amp;socketTransport_readPacket;
1318     interface.WritePacket = &amp;socketTransport_writePacket;
1319     interface.GetLastError = &amp;socketTransport_getLastError;
1320     if (version &gt;= JDWPTRANSPORT_VERSION_1_1) {
1321         interface.SetTransportConfiguration = &amp;socketTransport_setConfiguration;
1322     }
1323     *env = &amp;single_env;
1324 
1325     /* initialized TLS */
1326     tlsIndex = dbgsysTlsAlloc();
<a name="68" id="anc68"></a><span class="line-added">1327 </span>
<span class="line-added">1328     // retrieve network-related system properties</span>
<span class="line-added">1329     do {</span>
<span class="line-added">1330         jclass sysClass;</span>
<span class="line-added">1331         jmethodID getPropMethod;</span>
<span class="line-added">1332         if ((*vm)-&gt;GetEnv(vm, (void **)&amp;jniEnv, JNI_VERSION_9) != JNI_OK) {</span>
<span class="line-added">1333             break;</span>
<span class="line-added">1334         }</span>
<span class="line-added">1335         sysClass = (*jniEnv)-&gt;FindClass(jniEnv, &quot;java/lang/System&quot;);</span>
<span class="line-added">1336         if (sysClass == NULL) {</span>
<span class="line-added">1337             break;</span>
<span class="line-added">1338         }</span>
<span class="line-added">1339         getPropMethod = (*jniEnv)-&gt;GetStaticMethodID(jniEnv, sysClass,</span>
<span class="line-added">1340             &quot;getProperty&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);</span>
<span class="line-added">1341         if (getPropMethod == NULL) {</span>
<span class="line-added">1342             break;</span>
<span class="line-added">1343         }</span>
<span class="line-added">1344         readBooleanSysProp(&amp;allowOnlyIPv4, 1, 0,</span>
<span class="line-added">1345             jniEnv, sysClass, getPropMethod, &quot;java.net.preferIPv4Stack&quot;);</span>
<span class="line-added">1346         readBooleanSysProp(&amp;preferredAddressFamily, AF_INET6, AF_INET,</span>
<span class="line-added">1347             jniEnv, sysClass, getPropMethod, &quot;java.net.preferIPv6Addresses&quot;);</span>
<span class="line-added">1348     } while (0);</span>
<span class="line-added">1349 </span>
<span class="line-added">1350     if (jniEnv != NULL &amp;&amp; (*jniEnv)-&gt;ExceptionCheck(jniEnv)) {</span>
<span class="line-added">1351         (*jniEnv)-&gt;ExceptionClear(jniEnv);</span>
<span class="line-added">1352     }</span>
<span class="line-added">1353 </span>
<span class="line-added">1354 </span>
1355     return JNI_OK;
1356 }
<a name="69" id="anc69"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="69" type="hidden" />
</body>
</html>
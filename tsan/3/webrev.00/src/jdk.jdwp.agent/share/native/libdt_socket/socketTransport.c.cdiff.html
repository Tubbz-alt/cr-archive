<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.jdwp.agent/share/native/libdt_socket/socketTransport.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../jdk.jdi/share/man/jdb.1.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="sysSocket.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdwp.agent/share/native/libdt_socket/socketTransport.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 33,23 ***</span>
  #include &quot;sysSocket.h&quot;
  
  #ifdef _WIN32
   #include &lt;winsock2.h&gt;
   #include &lt;ws2tcpip.h&gt;
  #else
   #include &lt;arpa/inet.h&gt;
   #include &lt;sys/socket.h&gt;
  #endif
  
  /*
   * The Socket Transport Library.
   *
   * This module is an implementation of the Java Debug Wire Protocol Transport
   * Service Provider Interface - see src/share/javavm/export/jdwpTransport.h.
   */
  
<span class="line-modified">! static int serverSocketFD;</span>
  static int socketFD = -1;
  static jdwpTransportCallback *callback;
  static JavaVM *jvm;
  static int tlsIndex;
  static jboolean initialized;
<span class="line-new-header">--- 33,25 ---</span>
  #include &quot;sysSocket.h&quot;
  
  #ifdef _WIN32
   #include &lt;winsock2.h&gt;
   #include &lt;ws2tcpip.h&gt;
<span class="line-added">+  #include &lt;iphlpapi.h&gt;</span>
  #else
   #include &lt;arpa/inet.h&gt;
   #include &lt;sys/socket.h&gt;
<span class="line-added">+  #include &lt;net/if.h&gt;</span>
  #endif
  
  /*
   * The Socket Transport Library.
   *
   * This module is an implementation of the Java Debug Wire Protocol Transport
   * Service Provider Interface - see src/share/javavm/export/jdwpTransport.h.
   */
  
<span class="line-modified">! static int serverSocketFD = -1;</span>
  static int socketFD = -1;
  static jdwpTransportCallback *callback;
  static JavaVM *jvm;
  static int tlsIndex;
  static jboolean initialized;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 76,21 ***</span>
  static jint recv_fully(int, char *, int);
  static jint send_fully(int, char *, int);
  
  /* version &gt;= JDWPTRANSPORT_VERSION_1_1 */
  typedef struct {
<span class="line-modified">!     uint32_t subnet;</span>
<span class="line-modified">!     uint32_t netmask;</span>
  } AllowedPeerInfo;
  
  #define STR(x) #x
  #define MAX_PEER_ENTRIES 32
  #define MAX_PEERS_STR STR(MAX_PEER_ENTRIES)
  static AllowedPeerInfo _peers[MAX_PEER_ENTRIES];
  static int _peers_cnt = 0;
  
  
  /*
   * Record the last error for this thread.
   */
  static void
  setLastError(jdwpTransportError err, char *newmsg) {
<span class="line-new-header">--- 78,25 ---</span>
  static jint recv_fully(int, char *, int);
  static jint send_fully(int, char *, int);
  
  /* version &gt;= JDWPTRANSPORT_VERSION_1_1 */
  typedef struct {
<span class="line-modified">!     /* subnet and mask are stored as IPv6 addresses, IPv4 is stored as mapped IPv6 */</span>
<span class="line-modified">!     struct in6_addr subnet;</span>
<span class="line-added">+     struct in6_addr netmask;</span>
  } AllowedPeerInfo;
  
  #define STR(x) #x
  #define MAX_PEER_ENTRIES 32
  #define MAX_PEERS_STR STR(MAX_PEER_ENTRIES)
  static AllowedPeerInfo _peers[MAX_PEER_ENTRIES];
  static int _peers_cnt = 0;
  
  
<span class="line-added">+ static int allowOnlyIPv4 = 0;                  // reflects &quot;java.net.preferIPv4Stack&quot; sys. property</span>
<span class="line-added">+ static int preferredAddressFamily = AF_INET;   // &quot;java.net.preferIPv6Addresses&quot;</span>
<span class="line-added">+ </span>
  /*
   * Record the last error for this thread.
   */
  static void
  setLastError(jdwpTransportError err, char *newmsg) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,17 ***</span>
      return (char *)dbgsysTlsGet(tlsIndex);
  }
  
  /* Set options common to client and server sides */
  static jdwpTransportError
<span class="line-modified">! setOptionsCommon(int fd)</span>
  {
      jvalue dontcare;
      int err;
  
<span class="line-modified">!     dontcare.i = 0;  /* keep compiler happy */</span>
  
      err = dbgsysSetSocketOption(fd, TCP_NODELAY, JNI_TRUE, dontcare);
      if (err &lt; 0) {
          RETURN_IO_ERROR(&quot;setsockopt TCPNODELAY failed&quot;);
      }
  
<span class="line-new-header">--- 141,23 ---</span>
      return (char *)dbgsysTlsGet(tlsIndex);
  }
  
  /* Set options common to client and server sides */
  static jdwpTransportError
<span class="line-modified">! setOptionsCommon(int domain, int fd)</span>
  {
      jvalue dontcare;
      int err;
  
<span class="line-modified">!     if (domain == AF_INET6) {</span>
<span class="line-added">+         int off = 0;</span>
<span class="line-added">+         // make the socket a dual mode socket</span>
<span class="line-added">+         // this may fail if IPv4 is not supported - it&#39;s ok</span>
<span class="line-added">+         setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&amp;off, sizeof(off));</span>
<span class="line-added">+     }</span>
  
<span class="line-added">+     dontcare.i = 0;  /* keep compiler happy */</span>
      err = dbgsysSetSocketOption(fd, TCP_NODELAY, JNI_TRUE, dontcare);
      if (err &lt; 0) {
          RETURN_IO_ERROR(&quot;setsockopt TCPNODELAY failed&quot;);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,35 ***</span>
          RETURN_IO_ERROR(&quot;send failed during handshake&quot;);
      }
      return JDWPTRANSPORT_ERROR_NONE;
  }
  
<span class="line-removed">- static uint32_t</span>
<span class="line-removed">- getLocalHostAddress() {</span>
<span class="line-removed">-     // Simple routine to guess localhost address.</span>
<span class="line-removed">-     // it looks up &quot;localhost&quot; and returns 127.0.0.1 if lookup</span>
<span class="line-removed">-     // fails.</span>
<span class="line-removed">-     struct addrinfo hints, *res = NULL;</span>
<span class="line-removed">-     uint32_t addr;</span>
<span class="line-removed">-     int err;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Use portable way to initialize the structure</span>
<span class="line-removed">-     memset((void *)&amp;hints, 0, sizeof(hints));</span>
<span class="line-removed">-     hints.ai_family = AF_INET;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     err = getaddrinfo(&quot;localhost&quot;, NULL, &amp;hints, &amp;res);</span>
<span class="line-removed">-     if (err &lt; 0 || res == NULL) {</span>
<span class="line-removed">-         return dbgsysHostToNetworkLong(INADDR_LOOPBACK);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // getaddrinfo might return more than one address</span>
<span class="line-removed">-     // but we are using first one only</span>
<span class="line-removed">-     addr = ((struct sockaddr_in *)(res-&gt;ai_addr))-&gt;sin_addr.s_addr;</span>
<span class="line-removed">-     freeaddrinfo(res);</span>
<span class="line-removed">-     return addr;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static int
  getPortNumber(const char *s_port) {
      u_long n;
      char *eptr;
  
<span class="line-new-header">--- 233,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,203 ***</span>
      }
  
      return n;
  }
  
<span class="line-modified">! static jdwpTransportError</span>
<span class="line-modified">! parseAddress(const char *address, struct sockaddr_in *sa) {</span>
<span class="line-modified">!     char *colon;</span>
<span class="line-modified">!     int port;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     memset((void *)sa, 0, sizeof(struct sockaddr_in));</span>
<span class="line-removed">-     sa-&gt;sin_family = AF_INET;</span>
  
<span class="line-modified">!     /* check for host:port or port */</span>
<span class="line-modified">!     colon = strchr(address, &#39;:&#39;);</span>
<span class="line-modified">!     port = getPortNumber((colon == NULL) ? address : colon +1);</span>
<span class="line-modified">!     if (port &lt; 0) {</span>
<span class="line-modified">!         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;invalid port number specified&quot;);</span>
      }
<span class="line-modified">!     sa-&gt;sin_port = dbgsysHostToNetworkShort((u_short)port);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (colon == NULL) {</span>
<span class="line-modified">!         // bind to localhost only if no address specified</span>
<span class="line-modified">!         sa-&gt;sin_addr.s_addr = getLocalHostAddress();</span>
<span class="line-modified">!     } else if (strncmp(address, &quot;localhost:&quot;, 10) == 0) {</span>
<span class="line-modified">!         // optimize for common case</span>
<span class="line-modified">!         sa-&gt;sin_addr.s_addr = getLocalHostAddress();</span>
<span class="line-modified">!     } else if (*address == &#39;*&#39; &amp;&amp; *(address+1) == &#39;:&#39;) {</span>
<span class="line-modified">!         // we are explicitly asked to bind server to all available IP addresses</span>
<span class="line-modified">!         // has no meaning for client.</span>
<span class="line-modified">!         sa-&gt;sin_addr.s_addr = dbgsysHostToNetworkLong(INADDR_ANY);</span>
<span class="line-modified">!      } else {</span>
<span class="line-modified">!         char *buf;</span>
<span class="line-modified">!         char *hostname;</span>
<span class="line-modified">!         uint32_t addr;</span>
<span class="line-modified">!         int ai;</span>
<span class="line-modified">!         buf = (*callback-&gt;alloc)((int)strlen(address) + 1);</span>
<span class="line-modified">!         if (buf == NULL) {</span>
              RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
          }
<span class="line-modified">!         strcpy(buf, address);</span>
<span class="line-modified">!         buf[colon - address] = &#39;\0&#39;;</span>
<span class="line-modified">!         hostname = buf;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /*</span>
<span class="line-modified">!          * First see if the host is a literal IP address.</span>
<span class="line-modified">!          * If not then try to resolve it.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         addr = dbgsysInetAddr(hostname);</span>
<span class="line-modified">!         if (addr == 0xffffffff) {</span>
<span class="line-modified">!             struct addrinfo hints;</span>
<span class="line-modified">!             struct addrinfo *results = NULL;</span>
<span class="line-removed">-             memset (&amp;hints, 0, sizeof(hints));</span>
<span class="line-removed">-             hints.ai_family = AF_INET;</span>
<span class="line-removed">-             hints.ai_socktype = SOCK_STREAM;</span>
<span class="line-removed">-             hints.ai_protocol = IPPROTO_TCP;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             ai = dbgsysGetAddrInfo(hostname, NULL, &amp;hints, &amp;results);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (ai != 0) {</span>
<span class="line-removed">-                 /* don&#39;t use RETURN_IO_ERROR as unknown host is normal */</span>
<span class="line-removed">-                 setLastError(0, &quot;getaddrinfo: unknown host&quot;);</span>
<span class="line-removed">-                 (*callback-&gt;free)(buf);</span>
<span class="line-removed">-                 return JDWPTRANSPORT_ERROR_IO_ERROR;</span>
              }
  
<span class="line-modified">!             /* lookup was successful */</span>
<span class="line-modified">!             sa-&gt;sin_addr =  ((struct sockaddr_in *)results-&gt;ai_addr)-&gt;sin_addr;</span>
<span class="line-modified">!             freeaddrinfo(results);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             sa-&gt;sin_addr.s_addr = addr;</span>
          }
  
<span class="line-modified">!         (*callback-&gt;free)(buf);</span>
      }
  
      return JDWPTRANSPORT_ERROR_NONE;
  }
  
<span class="line-modified">! static const char *</span>
<span class="line-modified">! ip_s2u(const char *instr, uint32_t *ip) {</span>
<span class="line-modified">!     // Convert string representation of ip to integer</span>
<span class="line-modified">!     // in network byte order (big-endian)</span>
<span class="line-modified">!     char t[4] = { 0, 0, 0, 0 };</span>
<span class="line-modified">!     const char *s = instr;</span>
<span class="line-modified">!     int i = 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     while (1) {</span>
<span class="line-modified">!         if (*s == &#39;.&#39;) {</span>
<span class="line-modified">!             ++i;</span>
<span class="line-modified">!             ++s;</span>
<span class="line-modified">!             continue;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (*s == 0 || *s == &#39;+&#39; || *s == &#39;/&#39;) {</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (*s &lt; &#39;0&#39; || *s &gt; &#39;9&#39;) {</span>
<span class="line-modified">!             return instr;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         t[i] = (t[i] * 10) + (*s - &#39;0&#39;);</span>
<span class="line-modified">!         ++s;</span>
      }
  
<span class="line-modified">!     *ip = *(uint32_t*)(t);</span>
<span class="line-removed">-     return s;</span>
  }
  
<span class="line-modified">! static const char *</span>
<span class="line-modified">! mask_s2u(const char *instr, uint32_t *mask) {</span>
<span class="line-modified">!     // Convert the number of bits to a netmask</span>
<span class="line-modified">!     // in network byte order (big-endian)</span>
<span class="line-modified">!     unsigned char m = 0;</span>
<span class="line-modified">!     const char *s = instr;</span>
  
<span class="line-modified">!     while (1) {</span>
<span class="line-modified">!         if (*s == 0 || *s == &#39;+&#39;) {</span>
<span class="line-modified">!             break;</span>
          }
<span class="line-modified">!         if (*s &lt; &#39;0&#39; || *s &gt; &#39;9&#39;) {</span>
<span class="line-modified">!             return instr;</span>
          }
<span class="line-modified">!         m = (m * 10) + (*s - &#39;0&#39;);</span>
<span class="line-modified">!         ++s;</span>
      }
  
<span class="line-modified">!     if (m == 0 || m &gt; 32) {</span>
<span class="line-modified">!        // Drop invalid input</span>
<span class="line-removed">-        return instr;</span>
      }
  
<span class="line-modified">!     *mask = htonl((uint32_t)(~0) &lt;&lt; (32 - m));</span>
<span class="line-modified">!     return s;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! static int</span>
<span class="line-modified">! ip_in_subnet(uint32_t subnet, uint32_t mask, uint32_t ipaddr) {</span>
<span class="line-modified">!     return (ipaddr &amp; mask) == subnet;</span>
  }
  
  static jdwpTransportError
<span class="line-modified">! parseAllowedPeers(const char *allowed_peers) {</span>
<span class="line-modified">!     // Build a list of allowed peers from char string</span>
<span class="line-modified">!     // of format 192.168.0.10+192.168.0.0/24</span>
<span class="line-modified">!     const char *s = NULL;</span>
<span class="line-modified">!     const char *p = allowed_peers;</span>
<span class="line-modified">!     uint32_t   ip = 0;</span>
<span class="line-modified">!     uint32_t mask = 0xFFFFFFFF;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     while (1) {</span>
<span class="line-modified">!         s = ip_s2u(p, &amp;ip);</span>
<span class="line-modified">!         if (s == p) {</span>
              _peers_cnt = 0;
<span class="line-modified">!             fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, s);</span>
              RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
                           &quot;invalid IP address in allow option&quot;);
          }
<span class="line-modified">! </span>
<span class="line-modified">!         if (*s == &#39;/&#39;) {</span>
<span class="line-modified">!             // netmask specified</span>
<span class="line-removed">-             s = mask_s2u(s + 1, &amp;mask);</span>
<span class="line-removed">-             if (*(s - 1) == &#39;/&#39;) {</span>
<span class="line-removed">-                 // Input is not consumed, something bad happened</span>
                  _peers_cnt = 0;
<span class="line-modified">!                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, s);</span>
                  RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
                               &quot;invalid netmask in allow option&quot;);
              }
          } else {
<span class="line-modified">!             // reset netmask</span>
<span class="line-removed">-             mask = 0xFFFFFFFF;</span>
          }
  
<span class="line-modified">!         if (*s == &#39;+&#39; || *s == 0) {</span>
<span class="line-modified">!             if (_peers_cnt &gt;= MAX_PEER_ENTRIES) {</span>
<span class="line-modified">!                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);</span>
<span class="line-modified">!                 RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,</span>
<span class="line-modified">!                              &quot;exceeded max number of allowed peers: &quot; MAX_PEERS_STR);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             _peers[_peers_cnt].subnet = ip;</span>
<span class="line-modified">!             _peers[_peers_cnt].netmask = mask;</span>
<span class="line-modified">!             _peers_cnt++;</span>
<span class="line-modified">!             if (*s == 0) {</span>
<span class="line-modified">!                 // end of options</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             // advance to next IP block</span>
<span class="line-modified">!             p = s + 1;</span>
          }
      }
<span class="line-modified">!     return JDWPTRANSPORT_ERROR_NONE;</span>
  }
  
  static int
<span class="line-modified">! isPeerAllowed(struct sockaddr_in *peer) {</span>
      int i;
      for (i = 0; i &lt; _peers_cnt; ++i) {
<span class="line-modified">!         int peer_ip = peer-&gt;sin_addr.s_addr;</span>
<span class="line-removed">-         if (ip_in_subnet(_peers[i].subnet, _peers[i].netmask, peer_ip)) {</span>
              return 1;
          }
      }
  
      return 0;
<span class="line-new-header">--- 259,364 ---</span>
      }
  
      return n;
  }
  
<span class="line-modified">! static unsigned short getPort(struct sockaddr *sa)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     return dbgsysNetworkToHostShort(sa-&gt;sa_family == AF_INET</span>
<span class="line-modified">!                                     ? (((struct sockaddr_in*)sa)-&gt;sin_port)</span>
<span class="line-modified">!                                     : (((struct sockaddr_in6*)sa)-&gt;sin6_port));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! /*</span>
<span class="line-modified">!  * Parses scope id.</span>
<span class="line-modified">!  * Scope id is ulong on Windows, uint32 on unix, so returns long which can be cast to uint32.</span>
<span class="line-modified">!  * On error sets last error and returns -1.</span>
<span class="line-modified">!  */</span>
<span class="line-added">+ static long parseScopeId(const char *str) {</span>
<span class="line-added">+     // try to handle scope as interface name</span>
<span class="line-added">+     unsigned long scopeId = if_nametoindex(str);</span>
<span class="line-added">+     if (scopeId == 0) {</span>
<span class="line-added">+         // try to parse integer value</span>
<span class="line-added">+         char *end;</span>
<span class="line-added">+         scopeId = strtoul(str, &amp;end, 10);</span>
<span class="line-added">+         if (*end != &#39;\0&#39;) {</span>
<span class="line-added">+             setLastError(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;failed to parse scope&quot;);</span>
<span class="line-added">+             return -1;</span>
<span class="line-added">+         }</span>
      }
<span class="line-modified">!     // ensure parsed value is in uint32 range</span>
<span class="line-modified">!     if (scopeId &gt; 0xFFFFFFFF) {</span>
<span class="line-modified">!         setLastError(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;scope is out of range&quot;);</span>
<span class="line-modified">!         return -1;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     return (long)scopeId;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! /*</span>
<span class="line-modified">!  * Wrapper for dbgsysGetAddrInfo (getaddrinfo).</span>
<span class="line-modified">!  * Handles enclosing square brackets and scopes.</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! static jdwpTransportError</span>
<span class="line-modified">! getAddrInfo(const char *hostname, size_t hostnameLen,</span>
<span class="line-modified">!             const char *service,</span>
<span class="line-modified">!             const struct addrinfo *hints,</span>
<span class="line-modified">!             struct addrinfo **result)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     int err = 0;</span>
<span class="line-added">+     char *buffer = NULL;</span>
<span class="line-added">+     long scopeId = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (hostname != NULL) {</span>
<span class="line-added">+         char *scope = NULL;</span>
<span class="line-added">+         // skip surrounding</span>
<span class="line-added">+         if (hostnameLen &gt; 2 &amp;&amp; hostname[0] == &#39;[&#39; &amp;&amp; hostname[hostnameLen - 1] == &#39;]&#39;) {</span>
<span class="line-added">+             hostname++;</span>
<span class="line-added">+             hostnameLen -= 2;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         buffer = (*callback-&gt;alloc)((int)hostnameLen + 1);</span>
<span class="line-added">+         if (buffer == NULL) {</span>
              RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
          }
<span class="line-modified">!         memcpy(buffer, hostname, hostnameLen);</span>
<span class="line-modified">!         buffer[hostnameLen] = &#39;\0&#39;;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         scope = strchr(buffer, &#39;%&#39;);</span>
<span class="line-modified">!         if (scope != NULL) {</span>
<span class="line-modified">!             // drop scope from the address</span>
<span class="line-modified">!             *scope = &#39;\0&#39;;</span>
<span class="line-modified">!             // and parse the value</span>
<span class="line-modified">!             scopeId = parseScopeId(scope + 1);</span>
<span class="line-modified">!             if (scopeId &lt; 0) {</span>
<span class="line-modified">!                 (*callback-&gt;free)(buffer);</span>
<span class="line-modified">!                 return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;</span>
              }
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     err = dbgsysGetAddrInfo(buffer, service, hints, result);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (buffer != NULL) {</span>
<span class="line-modified">!         (*callback-&gt;free)(buffer);</span>
<span class="line-modified">!     }</span>
<span class="line-added">+     if (err != 0) {</span>
<span class="line-added">+         setLastError(err, &quot;getaddrinfo: failed to parse address&quot;);</span>
<span class="line-added">+         return JDWPTRANSPORT_ERROR_IO_ERROR;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (scopeId &gt; 0) {</span>
<span class="line-added">+         if ((*result)-&gt;ai_family != AF_INET6) {</span>
<span class="line-added">+             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;IPv4 address cannot contain scope&quot;);</span>
          }
  
<span class="line-modified">!         ((struct sockaddr_in6 *)((*result)-&gt;ai_addr))-&gt;sin6_scope_id = (uint32_t)scopeId;</span>
      }
  
      return JDWPTRANSPORT_ERROR_NONE;
  }
  
<span class="line-modified">! /*</span>
<span class="line-modified">!  * Result must be released with dbgsysFreeAddrInfo.</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! static jdwpTransportError</span>
<span class="line-modified">! parseAddress(const char *address, struct addrinfo **result) {</span>
<span class="line-modified">!     const char *colon;</span>
<span class="line-modified">!     size_t hostnameLen;</span>
<span class="line-modified">!     const char *port;</span>
<span class="line-modified">!     struct addrinfo hints;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     *result = NULL;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /* check for host:port or port */</span>
<span class="line-modified">!     colon = strrchr(address, &#39;:&#39;);</span>
<span class="line-modified">!     port = (colon == NULL ? address : colon + 1);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /* ensure the port is valid (getaddrinfo allows port to be empty) */</span>
<span class="line-modified">!     if (getPortNumber(port) &lt; 0) {</span>
<span class="line-modified">!         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;invalid port number specified&quot;);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     memset (&amp;hints, 0, sizeof(hints));</span>
<span class="line-added">+     hints.ai_family = allowOnlyIPv4 ? AF_INET : AF_UNSPEC;</span>
<span class="line-added">+     hints.ai_socktype = SOCK_STREAM;</span>
<span class="line-added">+     hints.ai_protocol = IPPROTO_TCP;</span>
<span class="line-added">+     hints.ai_flags = AI_NUMERICSERV;    // port must be a number</span>
<span class="line-added">+ </span>
<span class="line-added">+     hostnameLen = (colon == NULL ? 0 : colon - address);</span>
<span class="line-added">+     if (hostnameLen == 0) {</span>
<span class="line-added">+         /* no hostname - use localhost address (pass NULL to getaddrinfo) */</span>
<span class="line-added">+         address = NULL;</span>
<span class="line-added">+     } else  if (*address == &#39;*&#39; &amp;&amp; hostnameLen == 1) {</span>
<span class="line-added">+         /* *:port - listen on all interfaces</span>
<span class="line-added">+          * use IPv6 socket (to accept IPv6 and mapped IPv4),</span>
<span class="line-added">+          * pass hostname == NULL to getaddrinfo.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         hints.ai_family = allowOnlyIPv4 ? AF_INET : AF_INET6;</span>
<span class="line-added">+         hints.ai_flags |= AI_PASSIVE | (allowOnlyIPv4 ? 0 : AI_V4MAPPED | AI_ALL);</span>
<span class="line-added">+         address = NULL;</span>
      }
  
<span class="line-modified">!     return getAddrInfo(address, hostnameLen, port, &amp;hints, result);</span>
  }
  
<span class="line-modified">! /*</span>
<span class="line-modified">!  * Input is sockaddr just because all clients have it.</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! static void convertIPv4ToIPv6(const struct sockaddr *addr4, struct in6_addr *addr6) {</span>
<span class="line-modified">!     // Implement in a platform-independent way.</span>
<span class="line-modified">!     // Spec requires in_addr has s_addr member, in6_addr has s6_addr[16] member.</span>
<span class="line-added">+     struct in_addr *a4 = &amp;(((struct sockaddr_in*)addr4)-&gt;sin_addr);</span>
<span class="line-added">+     memset(addr6, 0, sizeof(*addr6));   // for safety</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Mapped address contains 80 zero bits, then 16 &quot;1&quot; bits, then IPv4 address (4 bytes).</span>
<span class="line-added">+     addr6-&gt;s6_addr[10] = addr6-&gt;s6_addr[11] = 0xFF;</span>
<span class="line-added">+     memcpy(&amp;(addr6-&gt;s6_addr[12]), &amp;(a4-&gt;s_addr), 4);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! /*</span>
<span class="line-modified">!  * Parses address (IPv4 or IPv6), fills in result by parsed address.</span>
<span class="line-modified">!  * For IPv4 mapped IPv6 is returned in result, isIPv4 is set.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static jdwpTransportError</span>
<span class="line-added">+ parseAllowedAddr(const char *buffer, struct in6_addr *result, int *isIPv4) {</span>
<span class="line-added">+     struct addrinfo hints;</span>
<span class="line-added">+     struct addrinfo *addrInfo = NULL;</span>
<span class="line-added">+     jdwpTransportError err;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /*</span>
<span class="line-added">+      * To parse both IPv4 and IPv6 need to specify AF_UNSPEC family</span>
<span class="line-added">+      * (with AF_INET6 IPv4 addresses are not parsed even with AI_V4MAPPED and AI_ALL flags).</span>
<span class="line-added">+      */</span>
<span class="line-added">+     memset (&amp;hints, 0, sizeof(hints));</span>
<span class="line-added">+     hints.ai_family = AF_UNSPEC;            // IPv6 or mapped IPv4</span>
<span class="line-added">+     hints.ai_socktype = SOCK_STREAM;</span>
<span class="line-added">+     hints.ai_protocol = IPPROTO_TCP;</span>
<span class="line-added">+     hints.ai_flags = AI_NUMERICHOST;        // only numeric addresses, no resolution</span>
<span class="line-added">+ </span>
<span class="line-added">+     err = getAddrInfo(buffer, strlen(buffer), NULL, &amp;hints, &amp;addrInfo);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-added">+         return err;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (addrInfo-&gt;ai_family == AF_INET6) {</span>
<span class="line-added">+         memcpy(result, &amp;(((struct sockaddr_in6 *)(addrInfo-&gt;ai_addr))-&gt;sin6_addr), sizeof(*result));</span>
<span class="line-added">+         *isIPv4 = 0;</span>
<span class="line-added">+     } else {    // IPv4 address - convert to mapped IPv6</span>
<span class="line-added">+         struct in6_addr addr6;</span>
<span class="line-added">+         convertIPv4ToIPv6(addrInfo-&gt;ai_addr, &amp;addr6);</span>
<span class="line-added">+         memcpy(result, &amp;addr6, sizeof(*result));</span>
<span class="line-added">+         *isIPv4 = 1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     dbgsysFreeAddrInfo(addrInfo);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JDWPTRANSPORT_ERROR_NONE;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /*</span>
<span class="line-added">+  * Parses prefix length from buffer (integer value), fills in result with corresponding net mask.</span>
<span class="line-added">+  * For IPv4 (isIPv4 is set), maximum prefix length is 32 bit, for IPv6 - 128 bit.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static jdwpTransportError</span>
<span class="line-added">+ parseAllowedMask(const char *buffer, int isIPv4, struct in6_addr *result) {</span>
<span class="line-added">+     int prefixLen = 0;</span>
<span class="line-added">+     int maxValue = isIPv4 ? 32 : 128;</span>
<span class="line-added">+     int i;</span>
<span class="line-added">+ </span>
<span class="line-added">+     do {</span>
<span class="line-added">+         if (*buffer &lt; &#39;0&#39; || *buffer &gt; &#39;9&#39;) {</span>
<span class="line-added">+             return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;</span>
          }
<span class="line-modified">!         prefixLen = prefixLen * 10 + (*buffer - &#39;0&#39;);</span>
<span class="line-modified">!         if (prefixLen &gt; maxValue) {  // avoid overflow</span>
<span class="line-added">+             return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;</span>
          }
<span class="line-modified">!         buffer++;</span>
<span class="line-modified">!     } while (*buffer != &#39;\0&#39;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (isIPv4) {</span>
<span class="line-added">+         // IPv4 are stored as mapped IPv6, prefixLen needs to be converted too</span>
<span class="line-added">+         prefixLen += 96;</span>
      }
  
<span class="line-modified">!     if (prefixLen == 0) {</span>
<span class="line-modified">!         return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;</span>
      }
  
<span class="line-modified">!     // generate mask for prefix length</span>
<span class="line-modified">!     memset(result, 0, sizeof(*result));</span>
  
<span class="line-modified">!     // prefixLen &lt;= 128, so we won&#39;t go over result&#39;s size</span>
<span class="line-modified">!     for (i = 0; prefixLen &gt; 0; i++, prefixLen -= 8) {</span>
<span class="line-modified">!         if (prefixLen &gt;= 8) {</span>
<span class="line-added">+             // set the whole byte</span>
<span class="line-added">+             result-&gt;s6_addr[i] = 0xFF;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             // set only &quot;prefixLen&quot; bits</span>
<span class="line-added">+             result-&gt;s6_addr[i] = (char)(0xFF &lt;&lt; (8 - prefixLen));</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JDWPTRANSPORT_ERROR_NONE;</span>
  }
  
<span class="line-added">+ /*</span>
<span class="line-added">+  * Internal implementation of parseAllowedPeers (requires writable buffer).</span>
<span class="line-added">+  */</span>
  static jdwpTransportError
<span class="line-modified">! parseAllowedPeersInternal(char *buffer) {</span>
<span class="line-modified">!     char *next;</span>
<span class="line-modified">!     int isIPv4 = 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     do {</span>
<span class="line-modified">!         char *mask = NULL;</span>
<span class="line-modified">!         char *endOfAddr = strpbrk(buffer, &quot;/+&quot;);</span>
<span class="line-modified">!         if (endOfAddr == NULL) {</span>
<span class="line-modified">!             // this is the last address and there is no prefix length</span>
<span class="line-modified">!             next = NULL;</span>
<span class="line-modified">!         } else {</span>
<span class="line-added">+             next = endOfAddr + 1;</span>
<span class="line-added">+             if (*endOfAddr == &#39;/&#39;) {</span>
<span class="line-added">+                 // mask (prefix length) presents</span>
<span class="line-added">+                 char *endOfMask = strchr(next, &#39;+&#39;);</span>
<span class="line-added">+                 mask = next;</span>
<span class="line-added">+                 if (endOfMask == NULL) {</span>
<span class="line-added">+                     // no more addresses</span>
<span class="line-added">+                     next = NULL;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     next = endOfMask + 1;</span>
<span class="line-added">+                     *endOfMask = &#39;\0&#39;;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             *endOfAddr = &#39;\0&#39;;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // parse subnet address (IPv4 is stored as mapped IPv6)</span>
<span class="line-added">+         if (parseAllowedAddr(buffer, &amp;(_peers[_peers_cnt].subnet), &amp;isIPv4) != JDWPTRANSPORT_ERROR_NONE) {</span>
              _peers_cnt = 0;
<span class="line-modified">!             fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, buffer);</span>
              RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
                           &quot;invalid IP address in allow option&quot;);
          }
<span class="line-modified">!         if (mask != NULL) {</span>
<span class="line-modified">!             size_t i;</span>
<span class="line-modified">!             if (parseAllowedMask(mask, isIPv4, &amp;(_peers[_peers_cnt].netmask)) != JDWPTRANSPORT_ERROR_NONE) {</span>
                  _peers_cnt = 0;
<span class="line-modified">!                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, mask);</span>
                  RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
                               &quot;invalid netmask in allow option&quot;);
              }
<span class="line-added">+             // for safety update subnet to satisfy the mask</span>
<span class="line-added">+             for (i = 0; i &lt; sizeof(_peers[_peers_cnt].subnet); i++) {</span>
<span class="line-added">+                 _peers[_peers_cnt].subnet.s6_addr[i] &amp;= _peers[_peers_cnt].netmask.s6_addr[i];</span>
<span class="line-added">+             }</span>
          } else {
<span class="line-modified">!             memset(&amp;(_peers[_peers_cnt].netmask), 0xFF, sizeof(_peers[_peers_cnt].netmask));</span>
          }
<span class="line-added">+         _peers_cnt++;</span>
<span class="line-added">+         buffer = next;</span>
<span class="line-added">+     } while (next != NULL);</span>
  
<span class="line-modified">!     return JDWPTRANSPORT_ERROR_NONE;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! /*</span>
<span class="line-modified">!  * Parses &#39;allow&#39; argument (fills in list of allowed peers (global _peers variable)).</span>
<span class="line-modified">!  * &#39;Allow&#39; value consists of tokens separated by &#39;+&#39;,</span>
<span class="line-modified">!  * each token contains IP address (IPv4 or IPv6) and optional prefixLength:</span>
<span class="line-modified">!  * &#39;&lt;addr&gt;[/&lt;prefixLength&gt;]&#39;.</span>
<span class="line-modified">!  * Example: &#39;192.168.1.10+192.168.0.0/24&#39;</span>
<span class="line-modified">!  *   - connections are allowed from 192.168.1.10 and subnet 192.168.0.XX.</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! static jdwpTransportError</span>
<span class="line-modified">! parseAllowedPeers(const char *allowed_peers, size_t len) {</span>
<span class="line-modified">!     // Build a list of allowed peers from char string</span>
<span class="line-modified">!     // of format 192.168.0.10+192.168.0.0/24</span>
<span class="line-added">+ </span>
<span class="line-added">+     // writable copy of the value</span>
<span class="line-added">+     char *buffer = (*callback-&gt;alloc)((int)len + 1);</span>
<span class="line-added">+     if (buffer == NULL) {</span>
<span class="line-added">+         RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     memcpy(buffer, allowed_peers, len);</span>
<span class="line-added">+     buffer[len] = &#39;\0&#39;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     jdwpTransportError err = parseAllowedPeersInternal(buffer);</span>
<span class="line-added">+ </span>
<span class="line-added">+     (*callback-&gt;free)(buffer);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return err;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static int</span>
<span class="line-added">+ isAddressInSubnet(const struct in6_addr *address, const struct in6_addr *subnet, const struct in6_addr *mask) {</span>
<span class="line-added">+     size_t i;</span>
<span class="line-added">+     for (i = 0; i &lt; sizeof(struct in6_addr); i++) {</span>
<span class="line-added">+         if ((address-&gt;s6_addr[i] &amp; mask-&gt;s6_addr[i]) != subnet-&gt;s6_addr[i]) {</span>
<span class="line-added">+             return 0;</span>
          }
      }
<span class="line-modified">!     return 1;</span>
  }
  
  static int
<span class="line-modified">! isPeerAllowed(struct sockaddr_storage *peer) {</span>
<span class="line-added">+     struct in6_addr tmp;</span>
<span class="line-added">+     struct in6_addr *addr6;</span>
      int i;
<span class="line-added">+     // _peers contains IPv6 subnet and mask (IPv4 is converted to mapped IPv6)</span>
<span class="line-added">+     if (peer-&gt;ss_family == AF_INET) {</span>
<span class="line-added">+         convertIPv4ToIPv6((struct sockaddr *)peer, &amp;tmp);</span>
<span class="line-added">+         addr6 = &amp;tmp;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         addr6 = &amp;(((struct sockaddr_in6 *)peer)-&gt;sin6_addr);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      for (i = 0; i &lt; _peers_cnt; ++i) {
<span class="line-modified">!         if (isAddressInSubnet(addr6, &amp;(_peers[i].subnet), &amp;(_peers[i].netmask))) {</span>
              return 1;
          }
      }
  
      return 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 488,69 ***</span>
      *capabilitiesPtr = result;
  
      return JDWPTRANSPORT_ERROR_NONE;
  }
  
<span class="line-modified">! </span>
<span class="line-modified">! static jdwpTransportError JNICALL</span>
<span class="line-modified">! socketTransport_startListening(jdwpTransportEnv* env, const char* address,</span>
<span class="line-modified">!                                char** actualAddress)</span>
  {
<span class="line-removed">-     struct sockaddr_in sa;</span>
      int err;
  
<span class="line-modified">!     memset((void *)&amp;sa,0,sizeof(struct sockaddr_in));</span>
<span class="line-modified">!     sa.sin_family = AF_INET;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* no address provided */</span>
<span class="line-removed">-     if ((address == NULL) || (address[0] == &#39;\0&#39;)) {</span>
<span class="line-removed">-         address = &quot;0&quot;;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     err = parseAddress(address, &amp;sa);</span>
<span class="line-removed">-     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-removed">-         return err;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     serverSocketFD = dbgsysSocket(AF_INET, SOCK_STREAM, 0);</span>
<span class="line-removed">-     if (serverSocketFD &lt; 0) {</span>
          RETURN_IO_ERROR(&quot;socket creation failed&quot;);
      }
  
<span class="line-modified">!     err = setOptionsCommon(serverSocketFD);</span>
      if (err) {
          return err;
      }
<span class="line-modified">!     if (sa.sin_port != 0) {</span>
          /*
           * Only need SO_REUSEADDR if we&#39;re using a fixed port. If we
           * start seeing EADDRINUSE due to collisions in free ports
           * then we should retry the dbgsysBind() a few times.
           */
<span class="line-modified">!         err = setReuseAddrOption(serverSocketFD);</span>
          if (err) {
              return err;
          }
      }
  
<span class="line-modified">!     err = dbgsysBind(serverSocketFD, (struct sockaddr *)&amp;sa, sizeof(sa));</span>
      if (err &lt; 0) {
          RETURN_IO_ERROR(&quot;bind failed&quot;);
      }
  
<span class="line-modified">!     err = dbgsysListen(serverSocketFD, 1);</span>
      if (err &lt; 0) {
          RETURN_IO_ERROR(&quot;listen failed&quot;);
      }
  
      {
          char buf[20];
<span class="line-modified">!         socklen_t len = sizeof(sa);</span>
          jint portNum;
<span class="line-modified">!         err = dbgsysGetSocketName(serverSocketFD,</span>
<span class="line-modified">!                                (struct sockaddr *)&amp;sa, &amp;len);</span>
<span class="line-modified">!         portNum = dbgsysNetworkToHostShort(sa.sin_port);</span>
          sprintf(buf, &quot;%d&quot;, portNum);
          *actualAddress = (*callback-&gt;alloc)((int)strlen(buf) + 1);
          if (*actualAddress == NULL) {
              RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
          } else {
<span class="line-new-header">--- 636,62 ---</span>
      *capabilitiesPtr = result;
  
      return JDWPTRANSPORT_ERROR_NONE;
  }
  
<span class="line-modified">! /*</span>
<span class="line-modified">!  * Starts listening on the specified addrinfo,</span>
<span class="line-modified">!  * returns listening socket and actual listening port.</span>
<span class="line-modified">!  * If the function fails and returned socket != -1, the socket should be closed.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static jdwpTransportError startListening(struct addrinfo *ai, int *socket, char** actualAddress)</span>
  {
      int err;
  
<span class="line-modified">!     *socket = dbgsysSocket(ai-&gt;ai_family, SOCK_STREAM, IPPROTO_TCP);</span>
<span class="line-modified">!     if (*socket &lt; 0) {</span>
          RETURN_IO_ERROR(&quot;socket creation failed&quot;);
      }
  
<span class="line-modified">!     err = setOptionsCommon(ai-&gt;ai_family, *socket);</span>
      if (err) {
          return err;
      }
<span class="line-modified">! </span>
<span class="line-added">+     if (getPort(ai-&gt;ai_addr) != 0) {</span>
          /*
           * Only need SO_REUSEADDR if we&#39;re using a fixed port. If we
           * start seeing EADDRINUSE due to collisions in free ports
           * then we should retry the dbgsysBind() a few times.
           */
<span class="line-modified">!         err = setReuseAddrOption(*socket);</span>
          if (err) {
              return err;
          }
      }
  
<span class="line-modified">!     err = dbgsysBind(*socket, ai-&gt;ai_addr, (socklen_t)ai-&gt;ai_addrlen);</span>
      if (err &lt; 0) {
          RETURN_IO_ERROR(&quot;bind failed&quot;);
      }
  
<span class="line-modified">!     err = dbgsysListen(*socket, 1); // only 1 debugger can attach</span>
      if (err &lt; 0) {
          RETURN_IO_ERROR(&quot;listen failed&quot;);
      }
  
      {
          char buf[20];
<span class="line-modified">!         struct sockaddr_storage addr;</span>
<span class="line-added">+         socklen_t len = sizeof(addr);</span>
          jint portNum;
<span class="line-modified">!         err = dbgsysGetSocketName(*socket, (struct sockaddr *)&amp;addr, &amp;len);</span>
<span class="line-modified">!         if (err != 0) {</span>
<span class="line-modified">!             RETURN_IO_ERROR(&quot;getsockname failed&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         portNum = getPort((struct sockaddr *)&amp;addr);</span>
          sprintf(buf, &quot;%d&quot;, portNum);
          *actualAddress = (*callback-&gt;alloc)((int)strlen(buf) + 1);
          if (*actualAddress == NULL) {
              RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 559,17 ***</span>
      }
  
      return JDWPTRANSPORT_ERROR_NONE;
  }
  
  static jdwpTransportError JNICALL
  socketTransport_accept(jdwpTransportEnv* env, jlong acceptTimeout, jlong handshakeTimeout)
  {
<span class="line-removed">-     socklen_t socketLen;</span>
      int err = JDWPTRANSPORT_ERROR_NONE;
<span class="line-modified">!     struct sockaddr_in socket;</span>
<span class="line-modified">!     jlong startTime = (jlong)0;</span>
  
      /*
       * Use a default handshake timeout if not specified - this avoids an indefinite
       * hang in cases where something other than a debugger connects to our port.
       */
<span class="line-new-header">--- 700,69 ---</span>
      }
  
      return JDWPTRANSPORT_ERROR_NONE;
  }
  
<span class="line-added">+ static jdwpTransportError JNICALL</span>
<span class="line-added">+ socketTransport_startListening(jdwpTransportEnv* env, const char* address,</span>
<span class="line-added">+                                char** actualAddress)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     int err;</span>
<span class="line-added">+     int pass;</span>
<span class="line-added">+     struct addrinfo *addrInfo = NULL;</span>
<span class="line-added">+     struct addrinfo *listenAddr = NULL;</span>
<span class="line-added">+     struct addrinfo *ai = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* no address provided */</span>
<span class="line-added">+     if ((address == NULL) || (address[0] == &#39;\0&#39;)) {</span>
<span class="line-added">+         address = &quot;0&quot;;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     err = parseAddress(address, &amp;addrInfo);</span>
<span class="line-added">+     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-added">+         return err;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* 1st pass - preferredAddressFamily (by default IPv4), 2nd pass - the rest */</span>
<span class="line-added">+     for (pass = 0; pass &lt; 2 &amp;&amp; listenAddr == NULL; pass++) {</span>
<span class="line-added">+         for (ai = addrInfo; ai != NULL; ai = ai-&gt;ai_next) {</span>
<span class="line-added">+             if ((pass == 0 &amp;&amp; ai-&gt;ai_family == preferredAddressFamily) ||</span>
<span class="line-added">+                 (pass == 1 &amp;&amp; ai-&gt;ai_family != preferredAddressFamily))</span>
<span class="line-added">+             {</span>
<span class="line-added">+                 listenAddr = ai;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (listenAddr == NULL) {</span>
<span class="line-added">+         dbgsysFreeAddrInfo(addrInfo);</span>
<span class="line-added">+         RETURN_ERROR(JDWPTRANSPORT_ERROR_INTERNAL, &quot;listen failed: wrong address&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     err = startListening(listenAddr, &amp;serverSocketFD, actualAddress);</span>
<span class="line-added">+ </span>
<span class="line-added">+     dbgsysFreeAddrInfo(addrInfo);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-added">+         if (serverSocketFD &gt;= 0) {</span>
<span class="line-added">+             dbgsysSocketClose(serverSocketFD);</span>
<span class="line-added">+             serverSocketFD = -1;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return err;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JDWPTRANSPORT_ERROR_NONE;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static jdwpTransportError JNICALL
  socketTransport_accept(jdwpTransportEnv* env, jlong acceptTimeout, jlong handshakeTimeout)
  {
      int err = JDWPTRANSPORT_ERROR_NONE;
<span class="line-modified">!     struct sockaddr_storage clientAddr;</span>
<span class="line-modified">!     socklen_t clientAddrLen;</span>
<span class="line-added">+     jlong startTime = 0;</span>
  
      /*
       * Use a default handshake timeout if not specified - this avoids an indefinite
       * hang in cases where something other than a debugger connects to our port.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 603,15 ***</span>
          }
  
          /*
           * Accept the connection
           */
<span class="line-modified">!         memset((void *)&amp;socket,0,sizeof(struct sockaddr_in));</span>
<span class="line-removed">-         socketLen = sizeof(socket);</span>
          socketFD = dbgsysAccept(serverSocketFD,
<span class="line-modified">!                                 (struct sockaddr *)&amp;socket,</span>
<span class="line-modified">!                                 &amp;socketLen);</span>
          /* set the last error here as could be overridden by configureBlocking */
          if (socketFD &lt; 0) {
              setLastError(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;accept failed&quot;);
          }
          /*
<span class="line-new-header">--- 796,14 ---</span>
          }
  
          /*
           * Accept the connection
           */
<span class="line-modified">!         clientAddrLen = sizeof(clientAddr);</span>
          socketFD = dbgsysAccept(serverSocketFD,
<span class="line-modified">!                                 (struct sockaddr *)&amp;clientAddr,</span>
<span class="line-modified">!                                 &amp;clientAddrLen);</span>
          /* set the last error here as could be overridden by configureBlocking */
          if (socketFD &lt; 0) {
              setLastError(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;accept failed&quot;);
          }
          /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 630,16 ***</span>
          /*
           * version &gt;= JDWPTRANSPORT_VERSION_1_1:
           * Verify that peer is allowed to connect.
           */
          if (_peers_cnt &gt; 0) {
<span class="line-modified">!             if (!isPeerAllowed(&amp;socket)) {</span>
                  char ebuf[64] = { 0 };
<span class="line-modified">!                 char buf[INET_ADDRSTRLEN] = { 0 };</span>
<span class="line-modified">!                 const char* addr_str = inet_ntop(AF_INET, &amp;(socket.sin_addr), buf, INET_ADDRSTRLEN);</span>
                  sprintf(ebuf, &quot;ERROR: Peer not allowed to connect: %s\n&quot;,
<span class="line-modified">!                         (addr_str == NULL) ? &quot;&lt;bad address&gt;&quot; : addr_str);</span>
                  dbgsysSocketClose(socketFD);
                  socketFD = -1;
                  err = JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;
                  setLastError(err, ebuf);
              }
<span class="line-new-header">--- 822,18 ---</span>
          /*
           * version &gt;= JDWPTRANSPORT_VERSION_1_1:
           * Verify that peer is allowed to connect.
           */
          if (_peers_cnt &gt; 0) {
<span class="line-modified">!             if (!isPeerAllowed(&amp;clientAddr)) {</span>
                  char ebuf[64] = { 0 };
<span class="line-modified">!                 char addrStr[INET_ADDRSTRLEN] = { 0 };</span>
<span class="line-modified">!                 int err2 = getnameinfo((struct sockaddr *)&amp;clientAddr, clientAddrLen,</span>
<span class="line-added">+                                        addrStr, sizeof(addrStr), NULL, 0,</span>
<span class="line-added">+                                        NI_NUMERICHOST);</span>
                  sprintf(ebuf, &quot;ERROR: Peer not allowed to connect: %s\n&quot;,
<span class="line-modified">!                         (err2 != 0) ? &quot;&lt;bad address&gt;&quot; : addrStr);</span>
                  dbgsysSocketClose(socketFD);
                  socketFD = -1;
                  err = JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;
                  setLastError(err, ebuf);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 684,32 ***</span>
      }
      serverSocketFD = -1;
      return JDWPTRANSPORT_ERROR_NONE;
  }
  
<span class="line-modified">! static jdwpTransportError JNICALL</span>
<span class="line-modified">! socketTransport_attach(jdwpTransportEnv* env, const char* addressString, jlong attachTimeout,</span>
<span class="line-modified">!                        jlong handshakeTimeout)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     struct sockaddr_in sa;</span>
      int err;
  
<span class="line-modified">!     if (addressString == NULL || addressString[0] == &#39;\0&#39;) {</span>
<span class="line-modified">!         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;address is missing&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     err = parseAddress(addressString, &amp;sa);</span>
<span class="line-removed">-     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-removed">-         return err;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     socketFD = dbgsysSocket(AF_INET, SOCK_STREAM, 0);</span>
<span class="line-removed">-     if (socketFD &lt; 0) {</span>
          RETURN_IO_ERROR(&quot;unable to create socket&quot;);
      }
  
<span class="line-modified">!     err = setOptionsCommon(socketFD);</span>
      if (err) {
          return err;
      }
  
      /*
<span class="line-new-header">--- 878,23 ---</span>
      }
      serverSocketFD = -1;
      return JDWPTRANSPORT_ERROR_NONE;
  }
  
<span class="line-modified">! /*</span>
<span class="line-modified">!  * Tries to connect to the specified addrinfo, returns connected socket.</span>
<span class="line-modified">!  * If the function fails and returned socket != -1, the socket should be closed.</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! static jdwpTransportError connectToAddr(struct addrinfo *ai, jlong timeout, int *socket) {</span>
      int err;
  
<span class="line-modified">!     *socket = dbgsysSocket(ai-&gt;ai_family, ai-&gt;ai_socktype, ai-&gt;ai_protocol);</span>
<span class="line-modified">!     if (*socket &lt; 0) {</span>
          RETURN_IO_ERROR(&quot;unable to create socket&quot;);
      }
  
<span class="line-modified">!     err = setOptionsCommon(ai-&gt;ai_family, socketFD);</span>
      if (err) {
          return err;
      }
  
      /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 720,28 ***</span>
  
      /*
       * To do a timed connect we make the socket non-blocking
       * and poll with a timeout;
       */
<span class="line-modified">!     if (attachTimeout &gt; 0) {</span>
          dbgsysConfigureBlocking(socketFD, JNI_FALSE);
      }
  
<span class="line-modified">!     err = dbgsysConnect(socketFD, (struct sockaddr *)&amp;sa, sizeof(sa));</span>
<span class="line-modified">!     if (err == DBG_EINPROGRESS &amp;&amp; attachTimeout &gt; 0) {</span>
<span class="line-modified">!         err = dbgsysFinishConnect(socketFD, (long)attachTimeout);</span>
  
          if (err == DBG_ETIMEOUT) {
              dbgsysConfigureBlocking(socketFD, JNI_TRUE);
              RETURN_ERROR(JDWPTRANSPORT_ERROR_TIMEOUT, &quot;connect timed out&quot;);
          }
      }
  
<span class="line-modified">!     if (err &lt; 0) {</span>
          RETURN_IO_ERROR(&quot;connect failed&quot;);
      }
  
      if (attachTimeout &gt; 0) {
          dbgsysConfigureBlocking(socketFD, JNI_TRUE);
      }
  
      err = handshake(socketFD, handshakeTimeout);
<span class="line-new-header">--- 905,76 ---</span>
  
      /*
       * To do a timed connect we make the socket non-blocking
       * and poll with a timeout;
       */
<span class="line-modified">!     if (timeout &gt; 0) {</span>
          dbgsysConfigureBlocking(socketFD, JNI_FALSE);
      }
  
<span class="line-modified">!     err = dbgsysConnect(socketFD, ai-&gt;ai_addr, (socklen_t)ai-&gt;ai_addrlen);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (err == DBG_EINPROGRESS &amp;&amp; timeout &gt; 0) {</span>
<span class="line-added">+         err = dbgsysFinishConnect(socketFD, (long)timeout);</span>
  
          if (err == DBG_ETIMEOUT) {
              dbgsysConfigureBlocking(socketFD, JNI_TRUE);
              RETURN_ERROR(JDWPTRANSPORT_ERROR_TIMEOUT, &quot;connect timed out&quot;);
          }
      }
  
<span class="line-modified">!     if (err) {</span>
          RETURN_IO_ERROR(&quot;connect failed&quot;);
      }
  
<span class="line-added">+     return err;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ static jdwpTransportError JNICALL</span>
<span class="line-added">+ socketTransport_attach(jdwpTransportEnv* env, const char* addressString, jlong attachTimeout,</span>
<span class="line-added">+                        jlong handshakeTimeout)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     int err;</span>
<span class="line-added">+     int pass;</span>
<span class="line-added">+     struct addrinfo *addrInfo = NULL;</span>
<span class="line-added">+     struct addrinfo *ai;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (addressString == NULL || addressString[0] == &#39;\0&#39;) {</span>
<span class="line-added">+         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;address is missing&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     err = parseAddress(addressString, &amp;addrInfo);</span>
<span class="line-added">+     if (err) {</span>
<span class="line-added">+         return err;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* 1st pass - preferredAddressFamily (by default IPv4), 2nd pass - the rest */</span>
<span class="line-added">+     for (pass = 0; pass &lt; 2 &amp;&amp; socketFD &lt; 0; pass++) {</span>
<span class="line-added">+         for (ai = addrInfo; ai != NULL; ai = ai-&gt;ai_next) {</span>
<span class="line-added">+             if ((pass == 0 &amp;&amp; ai-&gt;ai_family == preferredAddressFamily) ||</span>
<span class="line-added">+                 (pass == 1 &amp;&amp; ai-&gt;ai_family != preferredAddressFamily))</span>
<span class="line-added">+             {</span>
<span class="line-added">+                 err = connectToAddr(ai, attachTimeout, &amp;socketFD);</span>
<span class="line-added">+                 if (err == JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (socketFD &gt;= 0) {</span>
<span class="line-added">+                     dbgsysSocketClose(socketFD);</span>
<span class="line-added">+                     socketFD = -1;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     freeaddrinfo(addrInfo);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* err from the last connectToAddr() call */</span>
<span class="line-added">+     if (err != 0) {</span>
<span class="line-added">+         return err;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (attachTimeout &gt; 0) {
          dbgsysConfigureBlocking(socketFD, JNI_TRUE);
      }
  
      err = handshake(socketFD, handshakeTimeout);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1008,23 ***</span>
                  fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);
                  RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
                               &quot;allow option &#39;*&#39; cannot be expanded&quot;);
              }
          } else {
<span class="line-modified">!             int err = parseAllowedPeers(allowed_peers);</span>
              if (err != JDWPTRANSPORT_ERROR_NONE) {
                  return err;
              }
          }
      }
      return JDWPTRANSPORT_ERROR_NONE;
  }
  
  JNIEXPORT jint JNICALL
  jdwpTransport_OnLoad(JavaVM *vm, jdwpTransportCallback* cbTablePtr,
                       jint version, jdwpTransportEnv** env)
  {
      if (version &lt; JDWPTRANSPORT_VERSION_1_0 ||
          version &gt; JDWPTRANSPORT_VERSION_1_1) {
          return JNI_EVERSION;
      }
      if (initialized) {
<span class="line-new-header">--- 1241,59 ---</span>
                  fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);
                  RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
                               &quot;allow option &#39;*&#39; cannot be expanded&quot;);
              }
          } else {
<span class="line-modified">!             int err = parseAllowedPeers(allowed_peers, len);</span>
              if (err != JDWPTRANSPORT_ERROR_NONE) {
                  return err;
              }
          }
      }
      return JDWPTRANSPORT_ERROR_NONE;
  }
  
<span class="line-added">+ /*</span>
<span class="line-added">+  * Reads boolean system value, sets *result to</span>
<span class="line-added">+  *  - trueValue if the property is &quot;true&quot;;</span>
<span class="line-added">+  *  - falseValue if the property is &quot;false&quot;.</span>
<span class="line-added">+  * Doesn&#39;t change *result if the property is not set or failed to read.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static int readBooleanSysProp(int *result, int trueValue, int falseValue,</span>
<span class="line-added">+     JNIEnv* jniEnv, jclass sysClass, jmethodID getPropMethod, const char *propName)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     jstring value;</span>
<span class="line-added">+     jstring name = (*jniEnv)-&gt;NewStringUTF(jniEnv, propName);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (name == NULL) {</span>
<span class="line-added">+         return JNI_ERR;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     value = (jstring)(*jniEnv)-&gt;CallStaticObjectMethod(jniEnv, sysClass, getPropMethod, name);</span>
<span class="line-added">+     if ((*jniEnv)-&gt;ExceptionCheck(jniEnv)) {</span>
<span class="line-added">+         return JNI_ERR;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (value != NULL) {</span>
<span class="line-added">+         const char *theValue = (*jniEnv)-&gt;GetStringUTFChars(jniEnv, value, NULL);</span>
<span class="line-added">+         if (theValue == NULL) {</span>
<span class="line-added">+             return JNI_ERR;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (strcmp(theValue, &quot;true&quot;) == 0) {</span>
<span class="line-added">+             *result = trueValue;</span>
<span class="line-added">+         } else if (strcmp(theValue, &quot;false&quot;) == 0) {</span>
<span class="line-added">+             *result = falseValue;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         (*jniEnv)-&gt;ReleaseStringUTFChars(jniEnv, value, theValue);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return JNI_OK;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  JNIEXPORT jint JNICALL
  jdwpTransport_OnLoad(JavaVM *vm, jdwpTransportCallback* cbTablePtr,
                       jint version, jdwpTransportEnv** env)
  {
<span class="line-added">+     JNIEnv* jniEnv = NULL;</span>
<span class="line-added">+ </span>
      if (version &lt; JDWPTRANSPORT_VERSION_1_0 ||
          version &gt; JDWPTRANSPORT_VERSION_1_1) {
          return JNI_EVERSION;
      }
      if (initialized) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1053,7 ***</span>
<span class="line-new-header">--- 1322,35 ---</span>
      }
      *env = &amp;single_env;
  
      /* initialized TLS */
      tlsIndex = dbgsysTlsAlloc();
<span class="line-added">+ </span>
<span class="line-added">+     // retrieve network-related system properties</span>
<span class="line-added">+     do {</span>
<span class="line-added">+         jclass sysClass;</span>
<span class="line-added">+         jmethodID getPropMethod;</span>
<span class="line-added">+         if ((*vm)-&gt;GetEnv(vm, (void **)&amp;jniEnv, JNI_VERSION_9) != JNI_OK) {</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         sysClass = (*jniEnv)-&gt;FindClass(jniEnv, &quot;java/lang/System&quot;);</span>
<span class="line-added">+         if (sysClass == NULL) {</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         getPropMethod = (*jniEnv)-&gt;GetStaticMethodID(jniEnv, sysClass,</span>
<span class="line-added">+             &quot;getProperty&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);</span>
<span class="line-added">+         if (getPropMethod == NULL) {</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         readBooleanSysProp(&amp;allowOnlyIPv4, 1, 0,</span>
<span class="line-added">+             jniEnv, sysClass, getPropMethod, &quot;java.net.preferIPv4Stack&quot;);</span>
<span class="line-added">+         readBooleanSysProp(&amp;preferredAddressFamily, AF_INET6, AF_INET,</span>
<span class="line-added">+             jniEnv, sysClass, getPropMethod, &quot;java.net.preferIPv6Addresses&quot;);</span>
<span class="line-added">+     } while (0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (jniEnv != NULL &amp;&amp; (*jniEnv)-&gt;ExceptionCheck(jniEnv)) {</span>
<span class="line-added">+         (*jniEnv)-&gt;ExceptionClear(jniEnv);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
      return JNI_OK;
  }
</pre>
<center><a href="../../../../jdk.jdi/share/man/jdb.1.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="sysSocket.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
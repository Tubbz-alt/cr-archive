<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jdwp.agent/share/native/libdt_socket/socketTransport.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../jdk.jdi/share/man/jdb.1.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="sysSocket.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdwp.agent/share/native/libdt_socket/socketTransport.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;stdio.h&gt;
  26 #include &lt;string.h&gt;
  27 #include &lt;errno.h&gt;
  28 #include &lt;stdlib.h&gt;
  29 #include &lt;ctype.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jdwpTransport.h&quot;
  33 #include &quot;sysSocket.h&quot;
  34 
  35 #ifdef _WIN32
  36  #include &lt;winsock2.h&gt;
  37  #include &lt;ws2tcpip.h&gt;

  38 #else
  39  #include &lt;arpa/inet.h&gt;
  40  #include &lt;sys/socket.h&gt;

  41 #endif
  42 
  43 /*
  44  * The Socket Transport Library.
  45  *
  46  * This module is an implementation of the Java Debug Wire Protocol Transport
  47  * Service Provider Interface - see src/share/javavm/export/jdwpTransport.h.
  48  */
  49 
<span class="line-modified">  50 static int serverSocketFD;</span>
  51 static int socketFD = -1;
  52 static jdwpTransportCallback *callback;
  53 static JavaVM *jvm;
  54 static int tlsIndex;
  55 static jboolean initialized;
  56 static struct jdwpTransportNativeInterface_ interface;
  57 static jdwpTransportEnv single_env = (jdwpTransportEnv)&amp;interface;
  58 
  59 #define RETURN_ERROR(err, msg) \
  60         if (1==1) { \
  61             setLastError(err, msg); \
  62             return err; \
  63         }
  64 
  65 #define RETURN_IO_ERROR(msg)    RETURN_ERROR(JDWPTRANSPORT_ERROR_IO_ERROR, msg);
  66 
  67 #define RETURN_RECV_ERROR(n) \
  68         if (n == 0) { \
  69             RETURN_ERROR(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;premature EOF&quot;); \
  70         } else { \
  71             RETURN_IO_ERROR(&quot;recv error&quot;); \
  72         }
  73 
  74 #define MAX_DATA_SIZE 1000
  75 
  76 static jint recv_fully(int, char *, int);
  77 static jint send_fully(int, char *, int);
  78 
  79 /* version &gt;= JDWPTRANSPORT_VERSION_1_1 */
  80 typedef struct {
<span class="line-modified">  81     uint32_t subnet;</span>
<span class="line-modified">  82     uint32_t netmask;</span>

  83 } AllowedPeerInfo;
  84 
  85 #define STR(x) #x
  86 #define MAX_PEER_ENTRIES 32
  87 #define MAX_PEERS_STR STR(MAX_PEER_ENTRIES)
  88 static AllowedPeerInfo _peers[MAX_PEER_ENTRIES];
  89 static int _peers_cnt = 0;
  90 
  91 



  92 /*
  93  * Record the last error for this thread.
  94  */
  95 static void
  96 setLastError(jdwpTransportError err, char *newmsg) {
  97     char buf[255];
  98     char *msg;
  99 
 100     /* get any I/O first in case any system calls override errno */
 101     if (err == JDWPTRANSPORT_ERROR_IO_ERROR) {
 102         dbgsysGetLastIOError(buf, sizeof(buf));
 103     }
 104 
 105     msg = (char *)dbgsysTlsGet(tlsIndex);
 106     if (msg != NULL) {
 107         (*callback-&gt;free)(msg);
 108     }
 109 
 110     if (err == JDWPTRANSPORT_ERROR_IO_ERROR) {
 111         char *join_str = &quot;: &quot;;
</pre>
<hr />
<pre>
 120     } else {
 121         msg = (*callback-&gt;alloc)((int)strlen(newmsg)+1);
 122         if (msg != NULL) {
 123             strcpy(msg, newmsg);
 124         }
 125     }
 126 
 127     dbgsysTlsPut(tlsIndex, msg);
 128 }
 129 
 130 /*
 131  * Return the last error for this thread (may be NULL)
 132  */
 133 static char*
 134 getLastError() {
 135     return (char *)dbgsysTlsGet(tlsIndex);
 136 }
 137 
 138 /* Set options common to client and server sides */
 139 static jdwpTransportError
<span class="line-modified"> 140 setOptionsCommon(int fd)</span>
 141 {
 142     jvalue dontcare;
 143     int err;
 144 
<span class="line-modified"> 145     dontcare.i = 0;  /* keep compiler happy */</span>





 146 

 147     err = dbgsysSetSocketOption(fd, TCP_NODELAY, JNI_TRUE, dontcare);
 148     if (err &lt; 0) {
 149         RETURN_IO_ERROR(&quot;setsockopt TCPNODELAY failed&quot;);
 150     }
 151 
 152     return JDWPTRANSPORT_ERROR_NONE;
 153 }
 154 
 155 /* Set the SO_REUSEADDR option */
 156 static jdwpTransportError
 157 setReuseAddrOption(int fd)
 158 {
 159     jvalue dontcare;
 160     int err;
 161 
 162     dontcare.i = 0;  /* keep compiler happy */
 163 
 164     err = dbgsysSetSocketOption(fd, SO_REUSEADDR, JNI_TRUE, dontcare);
 165     if (err &lt; 0) {
 166         RETURN_IO_ERROR(&quot;setsockopt SO_REUSEADDR failed&quot;);
</pre>
<hr />
<pre>
 206         dbgsysConfigureBlocking(fd, JNI_TRUE);
 207     }
 208     if (strncmp(b, hello, received) != 0) {
 209         char msg[80+2*16];
 210         b[received] = &#39;\0&#39;;
 211         /*
 212          * We should really use snprintf here but it&#39;s not available on Windows.
 213          * We can&#39;t use jio_snprintf without linking the transport against the VM.
 214          */
 215         sprintf(msg, &quot;handshake failed - received &gt;%s&lt; - expected &gt;%s&lt;&quot;, b, hello);
 216         setLastError(0, msg);
 217         return JDWPTRANSPORT_ERROR_IO_ERROR;
 218     }
 219 
 220     if (send_fully(fd, (char*)hello, helloLen) != helloLen) {
 221         RETURN_IO_ERROR(&quot;send failed during handshake&quot;);
 222     }
 223     return JDWPTRANSPORT_ERROR_NONE;
 224 }
 225 
<span class="line-removed"> 226 static uint32_t</span>
<span class="line-removed"> 227 getLocalHostAddress() {</span>
<span class="line-removed"> 228     // Simple routine to guess localhost address.</span>
<span class="line-removed"> 229     // it looks up &quot;localhost&quot; and returns 127.0.0.1 if lookup</span>
<span class="line-removed"> 230     // fails.</span>
<span class="line-removed"> 231     struct addrinfo hints, *res = NULL;</span>
<span class="line-removed"> 232     uint32_t addr;</span>
<span class="line-removed"> 233     int err;</span>
<span class="line-removed"> 234 </span>
<span class="line-removed"> 235     // Use portable way to initialize the structure</span>
<span class="line-removed"> 236     memset((void *)&amp;hints, 0, sizeof(hints));</span>
<span class="line-removed"> 237     hints.ai_family = AF_INET;</span>
<span class="line-removed"> 238 </span>
<span class="line-removed"> 239     err = getaddrinfo(&quot;localhost&quot;, NULL, &amp;hints, &amp;res);</span>
<span class="line-removed"> 240     if (err &lt; 0 || res == NULL) {</span>
<span class="line-removed"> 241         return dbgsysHostToNetworkLong(INADDR_LOOPBACK);</span>
<span class="line-removed"> 242     }</span>
<span class="line-removed"> 243 </span>
<span class="line-removed"> 244     // getaddrinfo might return more than one address</span>
<span class="line-removed"> 245     // but we are using first one only</span>
<span class="line-removed"> 246     addr = ((struct sockaddr_in *)(res-&gt;ai_addr))-&gt;sin_addr.s_addr;</span>
<span class="line-removed"> 247     freeaddrinfo(res);</span>
<span class="line-removed"> 248     return addr;</span>
<span class="line-removed"> 249 }</span>
<span class="line-removed"> 250 </span>
 251 static int
 252 getPortNumber(const char *s_port) {
 253     u_long n;
 254     char *eptr;
 255 
 256     if (*s_port == 0) {
 257         // bad address - colon with no port number in parameters
 258         return -1;
 259     }
 260 
 261     n = strtoul(s_port, &amp;eptr, 10);
 262     if (eptr != s_port + strlen(s_port)) {
 263         // incomplete conversion - port number contains non-digit
 264         return -1;
 265     }
 266 
 267     if (n &gt; (u_short) -1) {
 268         // check that value supplied by user is less than
 269         // maximum possible u_short value (65535) and
 270         // will not be truncated later.
 271         return -1;
 272     }
 273 
 274     return n;
 275 }
 276 
<span class="line-modified"> 277 static jdwpTransportError</span>
<span class="line-modified"> 278 parseAddress(const char *address, struct sockaddr_in *sa) {</span>
<span class="line-modified"> 279     char *colon;</span>
<span class="line-modified"> 280     int port;</span>
<span class="line-modified"> 281 </span>
<span class="line-modified"> 282     memset((void *)sa, 0, sizeof(struct sockaddr_in));</span>
<span class="line-removed"> 283     sa-&gt;sin_family = AF_INET;</span>
 284 
<span class="line-modified"> 285     /* check for host:port or port */</span>
<span class="line-modified"> 286     colon = strchr(address, &#39;:&#39;);</span>
<span class="line-modified"> 287     port = getPortNumber((colon == NULL) ? address : colon +1);</span>
<span class="line-modified"> 288     if (port &lt; 0) {</span>
<span class="line-modified"> 289         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;invalid port number specified&quot;);</span>











 290     }
<span class="line-modified"> 291     sa-&gt;sin_port = dbgsysHostToNetworkShort((u_short)port);</span>
<span class="line-modified"> 292 </span>
<span class="line-modified"> 293     if (colon == NULL) {</span>
<span class="line-modified"> 294         // bind to localhost only if no address specified</span>
<span class="line-modified"> 295         sa-&gt;sin_addr.s_addr = getLocalHostAddress();</span>
<span class="line-modified"> 296     } else if (strncmp(address, &quot;localhost:&quot;, 10) == 0) {</span>
<span class="line-modified"> 297         // optimize for common case</span>
<span class="line-modified"> 298         sa-&gt;sin_addr.s_addr = getLocalHostAddress();</span>
<span class="line-modified"> 299     } else if (*address == &#39;*&#39; &amp;&amp; *(address+1) == &#39;:&#39;) {</span>
<span class="line-modified"> 300         // we are explicitly asked to bind server to all available IP addresses</span>
<span class="line-modified"> 301         // has no meaning for client.</span>
<span class="line-modified"> 302         sa-&gt;sin_addr.s_addr = dbgsysHostToNetworkLong(INADDR_ANY);</span>
<span class="line-modified"> 303      } else {</span>
<span class="line-modified"> 304         char *buf;</span>
<span class="line-modified"> 305         char *hostname;</span>
<span class="line-modified"> 306         uint32_t addr;</span>
<span class="line-modified"> 307         int ai;</span>
<span class="line-modified"> 308         buf = (*callback-&gt;alloc)((int)strlen(address) + 1);</span>
<span class="line-modified"> 309         if (buf == NULL) {</span>












 310             RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
 311         }
<span class="line-modified"> 312         strcpy(buf, address);</span>
<span class="line-modified"> 313         buf[colon - address] = &#39;\0&#39;;</span>
<span class="line-modified"> 314         hostname = buf;</span>
<span class="line-modified"> 315 </span>
<span class="line-modified"> 316         /*</span>
<span class="line-modified"> 317          * First see if the host is a literal IP address.</span>
<span class="line-modified"> 318          * If not then try to resolve it.</span>
<span class="line-modified"> 319          */</span>
<span class="line-modified"> 320         addr = dbgsysInetAddr(hostname);</span>
<span class="line-modified"> 321         if (addr == 0xffffffff) {</span>
<span class="line-modified"> 322             struct addrinfo hints;</span>
<span class="line-modified"> 323             struct addrinfo *results = NULL;</span>
<span class="line-removed"> 324             memset (&amp;hints, 0, sizeof(hints));</span>
<span class="line-removed"> 325             hints.ai_family = AF_INET;</span>
<span class="line-removed"> 326             hints.ai_socktype = SOCK_STREAM;</span>
<span class="line-removed"> 327             hints.ai_protocol = IPPROTO_TCP;</span>
<span class="line-removed"> 328 </span>
<span class="line-removed"> 329             ai = dbgsysGetAddrInfo(hostname, NULL, &amp;hints, &amp;results);</span>
<span class="line-removed"> 330 </span>
<span class="line-removed"> 331             if (ai != 0) {</span>
<span class="line-removed"> 332                 /* don&#39;t use RETURN_IO_ERROR as unknown host is normal */</span>
<span class="line-removed"> 333                 setLastError(0, &quot;getaddrinfo: unknown host&quot;);</span>
<span class="line-removed"> 334                 (*callback-&gt;free)(buf);</span>
<span class="line-removed"> 335                 return JDWPTRANSPORT_ERROR_IO_ERROR;</span>
 336             }


 337 
<span class="line-modified"> 338             /* lookup was successful */</span>
<span class="line-modified"> 339             sa-&gt;sin_addr =  ((struct sockaddr_in *)results-&gt;ai_addr)-&gt;sin_addr;</span>
<span class="line-modified"> 340             freeaddrinfo(results);</span>
<span class="line-modified"> 341         } else {</span>
<span class="line-modified"> 342             sa-&gt;sin_addr.s_addr = addr;</span>








 343         }
 344 
<span class="line-modified"> 345         (*callback-&gt;free)(buf);</span>
 346     }
 347 
 348     return JDWPTRANSPORT_ERROR_NONE;
 349 }
 350 
<span class="line-modified"> 351 static const char *</span>
<span class="line-modified"> 352 ip_s2u(const char *instr, uint32_t *ip) {</span>
<span class="line-modified"> 353     // Convert string representation of ip to integer</span>
<span class="line-modified"> 354     // in network byte order (big-endian)</span>
<span class="line-modified"> 355     char t[4] = { 0, 0, 0, 0 };</span>
<span class="line-modified"> 356     const char *s = instr;</span>
<span class="line-modified"> 357     int i = 0;</span>
<span class="line-modified"> 358 </span>
<span class="line-modified"> 359     while (1) {</span>
<span class="line-modified"> 360         if (*s == &#39;.&#39;) {</span>
<span class="line-modified"> 361             ++i;</span>
<span class="line-modified"> 362             ++s;</span>
<span class="line-modified"> 363             continue;</span>
<span class="line-modified"> 364         }</span>
<span class="line-modified"> 365         if (*s == 0 || *s == &#39;+&#39; || *s == &#39;/&#39;) {</span>
<span class="line-modified"> 366             break;</span>
<span class="line-modified"> 367         }</span>
<span class="line-modified"> 368         if (*s &lt; &#39;0&#39; || *s &gt; &#39;9&#39;) {</span>
<span class="line-modified"> 369             return instr;</span>
<span class="line-modified"> 370         }</span>
<span class="line-modified"> 371         t[i] = (t[i] * 10) + (*s - &#39;0&#39;);</span>
<span class="line-modified"> 372         ++s;</span>

















 373     }
 374 
<span class="line-modified"> 375     *ip = *(uint32_t*)(t);</span>
<span class="line-removed"> 376     return s;</span>
 377 }
 378 
<span class="line-modified"> 379 static const char *</span>
<span class="line-modified"> 380 mask_s2u(const char *instr, uint32_t *mask) {</span>
<span class="line-modified"> 381     // Convert the number of bits to a netmask</span>
<span class="line-modified"> 382     // in network byte order (big-endian)</span>
<span class="line-modified"> 383     unsigned char m = 0;</span>
<span class="line-modified"> 384     const char *s = instr;</span>







 385 
<span class="line-modified"> 386     while (1) {</span>
<span class="line-modified"> 387         if (*s == 0 || *s == &#39;+&#39;) {</span>
<span class="line-modified"> 388             break;</span>



















































 389         }
<span class="line-modified"> 390         if (*s &lt; &#39;0&#39; || *s &gt; &#39;9&#39;) {</span>
<span class="line-modified"> 391             return instr;</span>

 392         }
<span class="line-modified"> 393         m = (m * 10) + (*s - &#39;0&#39;);</span>
<span class="line-modified"> 394         ++s;</span>




 395     }
 396 
<span class="line-modified"> 397     if (m == 0 || m &gt; 32) {</span>
<span class="line-modified"> 398        // Drop invalid input</span>
<span class="line-removed"> 399        return instr;</span>
 400     }
 401 
<span class="line-modified"> 402     *mask = htonl((uint32_t)(~0) &lt;&lt; (32 - m));</span>
<span class="line-modified"> 403     return s;</span>
<span class="line-removed"> 404 }</span>
 405 
<span class="line-modified"> 406 static int</span>
<span class="line-modified"> 407 ip_in_subnet(uint32_t subnet, uint32_t mask, uint32_t ipaddr) {</span>
<span class="line-modified"> 408     return (ipaddr &amp; mask) == subnet;</span>









 409 }
 410 



 411 static jdwpTransportError
<span class="line-modified"> 412 parseAllowedPeers(const char *allowed_peers) {</span>
<span class="line-modified"> 413     // Build a list of allowed peers from char string</span>
<span class="line-modified"> 414     // of format 192.168.0.10+192.168.0.0/24</span>
<span class="line-modified"> 415     const char *s = NULL;</span>
<span class="line-modified"> 416     const char *p = allowed_peers;</span>
<span class="line-modified"> 417     uint32_t   ip = 0;</span>
<span class="line-modified"> 418     uint32_t mask = 0xFFFFFFFF;</span>
<span class="line-modified"> 419 </span>
<span class="line-modified"> 420     while (1) {</span>
<span class="line-modified"> 421         s = ip_s2u(p, &amp;ip);</span>
<span class="line-modified"> 422         if (s == p) {</span>


















 423             _peers_cnt = 0;
<span class="line-modified"> 424             fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, s);</span>
 425             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
 426                          &quot;invalid IP address in allow option&quot;);
 427         }
<span class="line-modified"> 428 </span>
<span class="line-modified"> 429         if (*s == &#39;/&#39;) {</span>
<span class="line-modified"> 430             // netmask specified</span>
<span class="line-removed"> 431             s = mask_s2u(s + 1, &amp;mask);</span>
<span class="line-removed"> 432             if (*(s - 1) == &#39;/&#39;) {</span>
<span class="line-removed"> 433                 // Input is not consumed, something bad happened</span>
 434                 _peers_cnt = 0;
<span class="line-modified"> 435                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, s);</span>
 436                 RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
 437                              &quot;invalid netmask in allow option&quot;);
 438             }




 439         } else {
<span class="line-modified"> 440             // reset netmask</span>
<span class="line-removed"> 441             mask = 0xFFFFFFFF;</span>
 442         }



 443 
<span class="line-modified"> 444         if (*s == &#39;+&#39; || *s == 0) {</span>
<span class="line-modified"> 445             if (_peers_cnt &gt;= MAX_PEER_ENTRIES) {</span>
<span class="line-modified"> 446                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);</span>
<span class="line-modified"> 447                 RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,</span>
<span class="line-modified"> 448                              &quot;exceeded max number of allowed peers: &quot; MAX_PEERS_STR);</span>
<span class="line-modified"> 449             }</span>
<span class="line-modified"> 450             _peers[_peers_cnt].subnet = ip;</span>
<span class="line-modified"> 451             _peers[_peers_cnt].netmask = mask;</span>
<span class="line-modified"> 452             _peers_cnt++;</span>
<span class="line-modified"> 453             if (*s == 0) {</span>
<span class="line-modified"> 454                 // end of options</span>
<span class="line-modified"> 455                 break;</span>
<span class="line-modified"> 456             }</span>
<span class="line-modified"> 457             // advance to next IP block</span>
<span class="line-modified"> 458             p = s + 1;</span>






















 459         }
 460     }
<span class="line-modified"> 461     return JDWPTRANSPORT_ERROR_NONE;</span>
 462 }
 463 
 464 static int
<span class="line-modified"> 465 isPeerAllowed(struct sockaddr_in *peer) {</span>


 466     int i;








 467     for (i = 0; i &lt; _peers_cnt; ++i) {
<span class="line-modified"> 468         int peer_ip = peer-&gt;sin_addr.s_addr;</span>
<span class="line-removed"> 469         if (ip_in_subnet(_peers[i].subnet, _peers[i].netmask, peer_ip)) {</span>
 470             return 1;
 471         }
 472     }
 473 
 474     return 0;
 475 }
 476 
 477 static jdwpTransportError JNICALL
 478 socketTransport_getCapabilities(jdwpTransportEnv* env,
 479         JDWPTransportCapabilities* capabilitiesPtr)
 480 {
 481     JDWPTransportCapabilities result;
 482 
 483     memset(&amp;result, 0, sizeof(result));
 484     result.can_timeout_attach = JNI_TRUE;
 485     result.can_timeout_accept = JNI_TRUE;
 486     result.can_timeout_handshake = JNI_TRUE;
 487 
 488     *capabilitiesPtr = result;
 489 
 490     return JDWPTRANSPORT_ERROR_NONE;
 491 }
 492 
<span class="line-modified"> 493 </span>
<span class="line-modified"> 494 static jdwpTransportError JNICALL</span>
<span class="line-modified"> 495 socketTransport_startListening(jdwpTransportEnv* env, const char* address,</span>
<span class="line-modified"> 496                                char** actualAddress)</span>


 497 {
<span class="line-removed"> 498     struct sockaddr_in sa;</span>
 499     int err;
 500 
<span class="line-modified"> 501     memset((void *)&amp;sa,0,sizeof(struct sockaddr_in));</span>
<span class="line-modified"> 502     sa.sin_family = AF_INET;</span>
<span class="line-removed"> 503 </span>
<span class="line-removed"> 504     /* no address provided */</span>
<span class="line-removed"> 505     if ((address == NULL) || (address[0] == &#39;\0&#39;)) {</span>
<span class="line-removed"> 506         address = &quot;0&quot;;</span>
<span class="line-removed"> 507     }</span>
<span class="line-removed"> 508 </span>
<span class="line-removed"> 509     err = parseAddress(address, &amp;sa);</span>
<span class="line-removed"> 510     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-removed"> 511         return err;</span>
<span class="line-removed"> 512     }</span>
<span class="line-removed"> 513 </span>
<span class="line-removed"> 514     serverSocketFD = dbgsysSocket(AF_INET, SOCK_STREAM, 0);</span>
<span class="line-removed"> 515     if (serverSocketFD &lt; 0) {</span>
 516         RETURN_IO_ERROR(&quot;socket creation failed&quot;);
 517     }
 518 
<span class="line-modified"> 519     err = setOptionsCommon(serverSocketFD);</span>
 520     if (err) {
 521         return err;
 522     }
<span class="line-modified"> 523     if (sa.sin_port != 0) {</span>

 524         /*
 525          * Only need SO_REUSEADDR if we&#39;re using a fixed port. If we
 526          * start seeing EADDRINUSE due to collisions in free ports
 527          * then we should retry the dbgsysBind() a few times.
 528          */
<span class="line-modified"> 529         err = setReuseAddrOption(serverSocketFD);</span>
 530         if (err) {
 531             return err;
 532         }
 533     }
 534 
<span class="line-modified"> 535     err = dbgsysBind(serverSocketFD, (struct sockaddr *)&amp;sa, sizeof(sa));</span>
 536     if (err &lt; 0) {
 537         RETURN_IO_ERROR(&quot;bind failed&quot;);
 538     }
 539 
<span class="line-modified"> 540     err = dbgsysListen(serverSocketFD, 1);</span>
 541     if (err &lt; 0) {
 542         RETURN_IO_ERROR(&quot;listen failed&quot;);
 543     }
 544 
 545     {
 546         char buf[20];
<span class="line-modified"> 547         socklen_t len = sizeof(sa);</span>

 548         jint portNum;
<span class="line-modified"> 549         err = dbgsysGetSocketName(serverSocketFD,</span>
<span class="line-modified"> 550                                (struct sockaddr *)&amp;sa, &amp;len);</span>
<span class="line-modified"> 551         portNum = dbgsysNetworkToHostShort(sa.sin_port);</span>



 552         sprintf(buf, &quot;%d&quot;, portNum);
 553         *actualAddress = (*callback-&gt;alloc)((int)strlen(buf) + 1);
 554         if (*actualAddress == NULL) {
 555             RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
 556         } else {
 557             strcpy(*actualAddress, buf);
 558         }
 559     }
 560 
 561     return JDWPTRANSPORT_ERROR_NONE;
 562 }
 563 




















































 564 static jdwpTransportError JNICALL
 565 socketTransport_accept(jdwpTransportEnv* env, jlong acceptTimeout, jlong handshakeTimeout)
 566 {
<span class="line-removed"> 567     socklen_t socketLen;</span>
 568     int err = JDWPTRANSPORT_ERROR_NONE;
<span class="line-modified"> 569     struct sockaddr_in socket;</span>
<span class="line-modified"> 570     jlong startTime = (jlong)0;</span>

 571 
 572     /*
 573      * Use a default handshake timeout if not specified - this avoids an indefinite
 574      * hang in cases where something other than a debugger connects to our port.
 575      */
 576     if (handshakeTimeout == 0) {
 577         handshakeTimeout = 2000;
 578     }
 579 
 580     do {
 581         /*
 582          * If there is an accept timeout then we put the socket in non-blocking
 583          * mode and poll for a connection.
 584          */
 585         if (acceptTimeout &gt; 0) {
 586             int rv;
 587             dbgsysConfigureBlocking(serverSocketFD, JNI_FALSE);
 588             startTime = dbgsysCurrentTimeMillis();
 589             rv = dbgsysPoll(serverSocketFD, JNI_TRUE, JNI_FALSE, (long)acceptTimeout);
 590             if (rv &lt;= 0) {
 591                 /* set the last error here as could be overridden by configureBlocking */
 592                 if (rv == 0) {
 593                     setLastError(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;poll failed&quot;);
 594                 }
 595                 /* restore blocking state */
 596                 dbgsysConfigureBlocking(serverSocketFD, JNI_TRUE);
 597                 if (rv == 0) {
 598                     RETURN_ERROR(JDWPTRANSPORT_ERROR_TIMEOUT, &quot;timed out waiting for connection&quot;);
 599                 } else {
 600                     return JDWPTRANSPORT_ERROR_IO_ERROR;
 601                 }
 602             }
 603         }
 604 
 605         /*
 606          * Accept the connection
 607          */
<span class="line-modified"> 608         memset((void *)&amp;socket,0,sizeof(struct sockaddr_in));</span>
<span class="line-removed"> 609         socketLen = sizeof(socket);</span>
 610         socketFD = dbgsysAccept(serverSocketFD,
<span class="line-modified"> 611                                 (struct sockaddr *)&amp;socket,</span>
<span class="line-modified"> 612                                 &amp;socketLen);</span>
 613         /* set the last error here as could be overridden by configureBlocking */
 614         if (socketFD &lt; 0) {
 615             setLastError(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;accept failed&quot;);
 616         }
 617         /*
 618          * Restore the blocking state - note that the accepted socket may be in
 619          * blocking or non-blocking mode (platform dependent). However as there
 620          * is a handshake timeout set then it will go into non-blocking mode
 621          * anyway for the handshake.
 622          */
 623         if (acceptTimeout &gt; 0) {
 624             dbgsysConfigureBlocking(serverSocketFD, JNI_TRUE);
 625         }
 626         if (socketFD &lt; 0) {
 627             return JDWPTRANSPORT_ERROR_IO_ERROR;
 628         }
 629 
 630         /*
 631          * version &gt;= JDWPTRANSPORT_VERSION_1_1:
 632          * Verify that peer is allowed to connect.
 633          */
 634         if (_peers_cnt &gt; 0) {
<span class="line-modified"> 635             if (!isPeerAllowed(&amp;socket)) {</span>
 636                 char ebuf[64] = { 0 };
<span class="line-modified"> 637                 char buf[INET_ADDRSTRLEN] = { 0 };</span>
<span class="line-modified"> 638                 const char* addr_str = inet_ntop(AF_INET, &amp;(socket.sin_addr), buf, INET_ADDRSTRLEN);</span>


 639                 sprintf(ebuf, &quot;ERROR: Peer not allowed to connect: %s\n&quot;,
<span class="line-modified"> 640                         (addr_str == NULL) ? &quot;&lt;bad address&gt;&quot; : addr_str);</span>
 641                 dbgsysSocketClose(socketFD);
 642                 socketFD = -1;
 643                 err = JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;
 644                 setLastError(err, ebuf);
 645             }
 646         }
 647 
 648         if (socketFD &gt; 0) {
 649           /* handshake with the debugger */
 650           err = handshake(socketFD, handshakeTimeout);
 651         }
 652 
 653         /*
 654          * If the handshake fails then close the connection. If there if an accept
 655          * timeout then we must adjust the timeout for the next poll.
 656          */
 657         if (err != JDWPTRANSPORT_ERROR_NONE) {
 658             fprintf(stderr, &quot;Debugger failed to attach: %s\n&quot;, getLastError());
 659             dbgsysSocketClose(socketFD);
 660             socketFD = -1;
</pre>
<hr />
<pre>
 669             }
 670         }
 671     } while (socketFD &lt; 0);
 672 
 673     return JDWPTRANSPORT_ERROR_NONE;
 674 }
 675 
 676 static jdwpTransportError JNICALL
 677 socketTransport_stopListening(jdwpTransportEnv *env)
 678 {
 679     if (serverSocketFD &lt; 0) {
 680         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_STATE, &quot;connection not open&quot;);
 681     }
 682     if (dbgsysSocketClose(serverSocketFD) &lt; 0) {
 683         RETURN_IO_ERROR(&quot;close failed&quot;);
 684     }
 685     serverSocketFD = -1;
 686     return JDWPTRANSPORT_ERROR_NONE;
 687 }
 688 
<span class="line-modified"> 689 static jdwpTransportError JNICALL</span>
<span class="line-modified"> 690 socketTransport_attach(jdwpTransportEnv* env, const char* addressString, jlong attachTimeout,</span>
<span class="line-modified"> 691                        jlong handshakeTimeout)</span>
<span class="line-modified"> 692 {</span>
<span class="line-modified"> 693     struct sockaddr_in sa;</span>
 694     int err;
 695 
<span class="line-modified"> 696     if (addressString == NULL || addressString[0] == &#39;\0&#39;) {</span>
<span class="line-modified"> 697         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;address is missing&quot;);</span>
<span class="line-removed"> 698     }</span>
<span class="line-removed"> 699 </span>
<span class="line-removed"> 700     err = parseAddress(addressString, &amp;sa);</span>
<span class="line-removed"> 701     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-removed"> 702         return err;</span>
<span class="line-removed"> 703     }</span>
<span class="line-removed"> 704 </span>
<span class="line-removed"> 705     socketFD = dbgsysSocket(AF_INET, SOCK_STREAM, 0);</span>
<span class="line-removed"> 706     if (socketFD &lt; 0) {</span>
 707         RETURN_IO_ERROR(&quot;unable to create socket&quot;);
 708     }
 709 
<span class="line-modified"> 710     err = setOptionsCommon(socketFD);</span>
 711     if (err) {
 712         return err;
 713     }
 714 
 715     /*
 716      * We don&#39;t call setReuseAddrOption() for the non-server socket
 717      * case. If we start seeing EADDRINUSE due to collisions in free
 718      * ports then we should retry the dbgsysConnect() a few times.
 719      */
 720 
 721     /*
 722      * To do a timed connect we make the socket non-blocking
 723      * and poll with a timeout;
 724      */
<span class="line-modified"> 725     if (attachTimeout &gt; 0) {</span>
 726         dbgsysConfigureBlocking(socketFD, JNI_FALSE);
 727     }
 728 
<span class="line-modified"> 729     err = dbgsysConnect(socketFD, (struct sockaddr *)&amp;sa, sizeof(sa));</span>
<span class="line-modified"> 730     if (err == DBG_EINPROGRESS &amp;&amp; attachTimeout &gt; 0) {</span>
<span class="line-modified"> 731         err = dbgsysFinishConnect(socketFD, (long)attachTimeout);</span>

 732 
 733         if (err == DBG_ETIMEOUT) {
 734             dbgsysConfigureBlocking(socketFD, JNI_TRUE);
 735             RETURN_ERROR(JDWPTRANSPORT_ERROR_TIMEOUT, &quot;connect timed out&quot;);
 736         }
 737     }
 738 
<span class="line-modified"> 739     if (err &lt; 0) {</span>
 740         RETURN_IO_ERROR(&quot;connect failed&quot;);
 741     }
 742 















































 743     if (attachTimeout &gt; 0) {
 744         dbgsysConfigureBlocking(socketFD, JNI_TRUE);
 745     }
 746 
 747     err = handshake(socketFD, handshakeTimeout);
 748     if (err) {
 749         dbgsysSocketClose(socketFD);
 750         socketFD = -1;
 751         return err;
 752     }
 753 
 754     return JDWPTRANSPORT_ERROR_NONE;
 755 }
 756 
 757 static jboolean JNICALL
 758 socketTransport_isOpen(jdwpTransportEnv* env)
 759 {
 760     if (socketFD &gt;= 0) {
 761         return JNI_TRUE;
 762     } else {
</pre>
<hr />
<pre>
 993 
 994     if (cfg == NULL) {
 995         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
 996                      &quot;NULL pointer to transport configuration is invalid&quot;);
 997     }
 998     allowed_peers = cfg-&gt;allowed_peers;
 999     _peers_cnt = 0;
1000     if (allowed_peers != NULL) {
1001         size_t len = strlen(allowed_peers);
1002         if (len == 0) { /* Impossible: parseOptions() would reject it */
1003             fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);
1004             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
1005                          &quot;allow option should not be empty&quot;);
1006         } else if (*allowed_peers == &#39;*&#39;) {
1007             if (len != 1) {
1008                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);
1009                 RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
1010                              &quot;allow option &#39;*&#39; cannot be expanded&quot;);
1011             }
1012         } else {
<span class="line-modified">1013             int err = parseAllowedPeers(allowed_peers);</span>
1014             if (err != JDWPTRANSPORT_ERROR_NONE) {
1015                 return err;
1016             }
1017         }
1018     }
1019     return JDWPTRANSPORT_ERROR_NONE;
1020 }
1021 


































1022 JNIEXPORT jint JNICALL
1023 jdwpTransport_OnLoad(JavaVM *vm, jdwpTransportCallback* cbTablePtr,
1024                      jint version, jdwpTransportEnv** env)
1025 {


1026     if (version &lt; JDWPTRANSPORT_VERSION_1_0 ||
1027         version &gt; JDWPTRANSPORT_VERSION_1_1) {
1028         return JNI_EVERSION;
1029     }
1030     if (initialized) {
1031         /*
1032          * This library doesn&#39;t support multiple environments (yet)
1033          */
1034         return JNI_EEXIST;
1035     }
1036     initialized = JNI_TRUE;
1037     jvm = vm;
1038     callback = cbTablePtr;
1039 
1040     /* initialize interface table */
1041     interface.GetCapabilities = &amp;socketTransport_getCapabilities;
1042     interface.Attach = &amp;socketTransport_attach;
1043     interface.StartListening = &amp;socketTransport_startListening;
1044     interface.StopListening = &amp;socketTransport_stopListening;
1045     interface.Accept = &amp;socketTransport_accept;
1046     interface.IsOpen = &amp;socketTransport_isOpen;
1047     interface.Close = &amp;socketTransport_close;
1048     interface.ReadPacket = &amp;socketTransport_readPacket;
1049     interface.WritePacket = &amp;socketTransport_writePacket;
1050     interface.GetLastError = &amp;socketTransport_getLastError;
1051     if (version &gt;= JDWPTRANSPORT_VERSION_1_1) {
1052         interface.SetTransportConfiguration = &amp;socketTransport_setConfiguration;
1053     }
1054     *env = &amp;single_env;
1055 
1056     /* initialized TLS */
1057     tlsIndex = dbgsysTlsAlloc();




























1058     return JNI_OK;
1059 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;stdio.h&gt;
  26 #include &lt;string.h&gt;
  27 #include &lt;errno.h&gt;
  28 #include &lt;stdlib.h&gt;
  29 #include &lt;ctype.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jdwpTransport.h&quot;
  33 #include &quot;sysSocket.h&quot;
  34 
  35 #ifdef _WIN32
  36  #include &lt;winsock2.h&gt;
  37  #include &lt;ws2tcpip.h&gt;
<span class="line-added">  38  #include &lt;iphlpapi.h&gt;</span>
  39 #else
  40  #include &lt;arpa/inet.h&gt;
  41  #include &lt;sys/socket.h&gt;
<span class="line-added">  42  #include &lt;net/if.h&gt;</span>
  43 #endif
  44 
  45 /*
  46  * The Socket Transport Library.
  47  *
  48  * This module is an implementation of the Java Debug Wire Protocol Transport
  49  * Service Provider Interface - see src/share/javavm/export/jdwpTransport.h.
  50  */
  51 
<span class="line-modified">  52 static int serverSocketFD = -1;</span>
  53 static int socketFD = -1;
  54 static jdwpTransportCallback *callback;
  55 static JavaVM *jvm;
  56 static int tlsIndex;
  57 static jboolean initialized;
  58 static struct jdwpTransportNativeInterface_ interface;
  59 static jdwpTransportEnv single_env = (jdwpTransportEnv)&amp;interface;
  60 
  61 #define RETURN_ERROR(err, msg) \
  62         if (1==1) { \
  63             setLastError(err, msg); \
  64             return err; \
  65         }
  66 
  67 #define RETURN_IO_ERROR(msg)    RETURN_ERROR(JDWPTRANSPORT_ERROR_IO_ERROR, msg);
  68 
  69 #define RETURN_RECV_ERROR(n) \
  70         if (n == 0) { \
  71             RETURN_ERROR(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;premature EOF&quot;); \
  72         } else { \
  73             RETURN_IO_ERROR(&quot;recv error&quot;); \
  74         }
  75 
  76 #define MAX_DATA_SIZE 1000
  77 
  78 static jint recv_fully(int, char *, int);
  79 static jint send_fully(int, char *, int);
  80 
  81 /* version &gt;= JDWPTRANSPORT_VERSION_1_1 */
  82 typedef struct {
<span class="line-modified">  83     /* subnet and mask are stored as IPv6 addresses, IPv4 is stored as mapped IPv6 */</span>
<span class="line-modified">  84     struct in6_addr subnet;</span>
<span class="line-added">  85     struct in6_addr netmask;</span>
  86 } AllowedPeerInfo;
  87 
  88 #define STR(x) #x
  89 #define MAX_PEER_ENTRIES 32
  90 #define MAX_PEERS_STR STR(MAX_PEER_ENTRIES)
  91 static AllowedPeerInfo _peers[MAX_PEER_ENTRIES];
  92 static int _peers_cnt = 0;
  93 
  94 
<span class="line-added">  95 static int allowOnlyIPv4 = 0;                  // reflects &quot;java.net.preferIPv4Stack&quot; sys. property</span>
<span class="line-added">  96 static int preferredAddressFamily = AF_INET;   // &quot;java.net.preferIPv6Addresses&quot;</span>
<span class="line-added">  97 </span>
  98 /*
  99  * Record the last error for this thread.
 100  */
 101 static void
 102 setLastError(jdwpTransportError err, char *newmsg) {
 103     char buf[255];
 104     char *msg;
 105 
 106     /* get any I/O first in case any system calls override errno */
 107     if (err == JDWPTRANSPORT_ERROR_IO_ERROR) {
 108         dbgsysGetLastIOError(buf, sizeof(buf));
 109     }
 110 
 111     msg = (char *)dbgsysTlsGet(tlsIndex);
 112     if (msg != NULL) {
 113         (*callback-&gt;free)(msg);
 114     }
 115 
 116     if (err == JDWPTRANSPORT_ERROR_IO_ERROR) {
 117         char *join_str = &quot;: &quot;;
</pre>
<hr />
<pre>
 126     } else {
 127         msg = (*callback-&gt;alloc)((int)strlen(newmsg)+1);
 128         if (msg != NULL) {
 129             strcpy(msg, newmsg);
 130         }
 131     }
 132 
 133     dbgsysTlsPut(tlsIndex, msg);
 134 }
 135 
 136 /*
 137  * Return the last error for this thread (may be NULL)
 138  */
 139 static char*
 140 getLastError() {
 141     return (char *)dbgsysTlsGet(tlsIndex);
 142 }
 143 
 144 /* Set options common to client and server sides */
 145 static jdwpTransportError
<span class="line-modified"> 146 setOptionsCommon(int domain, int fd)</span>
 147 {
 148     jvalue dontcare;
 149     int err;
 150 
<span class="line-modified"> 151     if (domain == AF_INET6) {</span>
<span class="line-added"> 152         int off = 0;</span>
<span class="line-added"> 153         // make the socket a dual mode socket</span>
<span class="line-added"> 154         // this may fail if IPv4 is not supported - it&#39;s ok</span>
<span class="line-added"> 155         setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&amp;off, sizeof(off));</span>
<span class="line-added"> 156     }</span>
 157 
<span class="line-added"> 158     dontcare.i = 0;  /* keep compiler happy */</span>
 159     err = dbgsysSetSocketOption(fd, TCP_NODELAY, JNI_TRUE, dontcare);
 160     if (err &lt; 0) {
 161         RETURN_IO_ERROR(&quot;setsockopt TCPNODELAY failed&quot;);
 162     }
 163 
 164     return JDWPTRANSPORT_ERROR_NONE;
 165 }
 166 
 167 /* Set the SO_REUSEADDR option */
 168 static jdwpTransportError
 169 setReuseAddrOption(int fd)
 170 {
 171     jvalue dontcare;
 172     int err;
 173 
 174     dontcare.i = 0;  /* keep compiler happy */
 175 
 176     err = dbgsysSetSocketOption(fd, SO_REUSEADDR, JNI_TRUE, dontcare);
 177     if (err &lt; 0) {
 178         RETURN_IO_ERROR(&quot;setsockopt SO_REUSEADDR failed&quot;);
</pre>
<hr />
<pre>
 218         dbgsysConfigureBlocking(fd, JNI_TRUE);
 219     }
 220     if (strncmp(b, hello, received) != 0) {
 221         char msg[80+2*16];
 222         b[received] = &#39;\0&#39;;
 223         /*
 224          * We should really use snprintf here but it&#39;s not available on Windows.
 225          * We can&#39;t use jio_snprintf without linking the transport against the VM.
 226          */
 227         sprintf(msg, &quot;handshake failed - received &gt;%s&lt; - expected &gt;%s&lt;&quot;, b, hello);
 228         setLastError(0, msg);
 229         return JDWPTRANSPORT_ERROR_IO_ERROR;
 230     }
 231 
 232     if (send_fully(fd, (char*)hello, helloLen) != helloLen) {
 233         RETURN_IO_ERROR(&quot;send failed during handshake&quot;);
 234     }
 235     return JDWPTRANSPORT_ERROR_NONE;
 236 }
 237 

























 238 static int
 239 getPortNumber(const char *s_port) {
 240     u_long n;
 241     char *eptr;
 242 
 243     if (*s_port == 0) {
 244         // bad address - colon with no port number in parameters
 245         return -1;
 246     }
 247 
 248     n = strtoul(s_port, &amp;eptr, 10);
 249     if (eptr != s_port + strlen(s_port)) {
 250         // incomplete conversion - port number contains non-digit
 251         return -1;
 252     }
 253 
 254     if (n &gt; (u_short) -1) {
 255         // check that value supplied by user is less than
 256         // maximum possible u_short value (65535) and
 257         // will not be truncated later.
 258         return -1;
 259     }
 260 
 261     return n;
 262 }
 263 
<span class="line-modified"> 264 static unsigned short getPort(struct sockaddr *sa)</span>
<span class="line-modified"> 265 {</span>
<span class="line-modified"> 266     return dbgsysNetworkToHostShort(sa-&gt;sa_family == AF_INET</span>
<span class="line-modified"> 267                                     ? (((struct sockaddr_in*)sa)-&gt;sin_port)</span>
<span class="line-modified"> 268                                     : (((struct sockaddr_in6*)sa)-&gt;sin6_port));</span>
<span class="line-modified"> 269 }</span>

 270 
<span class="line-modified"> 271 /*</span>
<span class="line-modified"> 272  * Parses scope id.</span>
<span class="line-modified"> 273  * Scope id is ulong on Windows, uint32 on unix, so returns long which can be cast to uint32.</span>
<span class="line-modified"> 274  * On error sets last error and returns -1.</span>
<span class="line-modified"> 275  */</span>
<span class="line-added"> 276 static long parseScopeId(const char *str) {</span>
<span class="line-added"> 277     // try to handle scope as interface name</span>
<span class="line-added"> 278     unsigned long scopeId = if_nametoindex(str);</span>
<span class="line-added"> 279     if (scopeId == 0) {</span>
<span class="line-added"> 280         // try to parse integer value</span>
<span class="line-added"> 281         char *end;</span>
<span class="line-added"> 282         scopeId = strtoul(str, &amp;end, 10);</span>
<span class="line-added"> 283         if (*end != &#39;\0&#39;) {</span>
<span class="line-added"> 284             setLastError(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;failed to parse scope&quot;);</span>
<span class="line-added"> 285             return -1;</span>
<span class="line-added"> 286         }</span>
 287     }
<span class="line-modified"> 288     // ensure parsed value is in uint32 range</span>
<span class="line-modified"> 289     if (scopeId &gt; 0xFFFFFFFF) {</span>
<span class="line-modified"> 290         setLastError(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;scope is out of range&quot;);</span>
<span class="line-modified"> 291         return -1;</span>
<span class="line-modified"> 292     }</span>
<span class="line-modified"> 293     return (long)scopeId;</span>
<span class="line-modified"> 294 }</span>
<span class="line-modified"> 295 </span>
<span class="line-modified"> 296 /*</span>
<span class="line-modified"> 297  * Wrapper for dbgsysGetAddrInfo (getaddrinfo).</span>
<span class="line-modified"> 298  * Handles enclosing square brackets and scopes.</span>
<span class="line-modified"> 299  */</span>
<span class="line-modified"> 300 static jdwpTransportError</span>
<span class="line-modified"> 301 getAddrInfo(const char *hostname, size_t hostnameLen,</span>
<span class="line-modified"> 302             const char *service,</span>
<span class="line-modified"> 303             const struct addrinfo *hints,</span>
<span class="line-modified"> 304             struct addrinfo **result)</span>
<span class="line-modified"> 305 {</span>
<span class="line-modified"> 306     int err = 0;</span>
<span class="line-added"> 307     char *buffer = NULL;</span>
<span class="line-added"> 308     long scopeId = 0;</span>
<span class="line-added"> 309 </span>
<span class="line-added"> 310     if (hostname != NULL) {</span>
<span class="line-added"> 311         char *scope = NULL;</span>
<span class="line-added"> 312         // skip surrounding</span>
<span class="line-added"> 313         if (hostnameLen &gt; 2 &amp;&amp; hostname[0] == &#39;[&#39; &amp;&amp; hostname[hostnameLen - 1] == &#39;]&#39;) {</span>
<span class="line-added"> 314             hostname++;</span>
<span class="line-added"> 315             hostnameLen -= 2;</span>
<span class="line-added"> 316         }</span>
<span class="line-added"> 317         buffer = (*callback-&gt;alloc)((int)hostnameLen + 1);</span>
<span class="line-added"> 318         if (buffer == NULL) {</span>
 319             RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
 320         }
<span class="line-modified"> 321         memcpy(buffer, hostname, hostnameLen);</span>
<span class="line-modified"> 322         buffer[hostnameLen] = &#39;\0&#39;;</span>
<span class="line-modified"> 323 </span>
<span class="line-modified"> 324         scope = strchr(buffer, &#39;%&#39;);</span>
<span class="line-modified"> 325         if (scope != NULL) {</span>
<span class="line-modified"> 326             // drop scope from the address</span>
<span class="line-modified"> 327             *scope = &#39;\0&#39;;</span>
<span class="line-modified"> 328             // and parse the value</span>
<span class="line-modified"> 329             scopeId = parseScopeId(scope + 1);</span>
<span class="line-modified"> 330             if (scopeId &lt; 0) {</span>
<span class="line-modified"> 331                 (*callback-&gt;free)(buffer);</span>
<span class="line-modified"> 332                 return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;</span>












 333             }
<span class="line-added"> 334         }</span>
<span class="line-added"> 335     }</span>
 336 
<span class="line-modified"> 337     err = dbgsysGetAddrInfo(buffer, service, hints, result);</span>
<span class="line-modified"> 338 </span>
<span class="line-modified"> 339     if (buffer != NULL) {</span>
<span class="line-modified"> 340         (*callback-&gt;free)(buffer);</span>
<span class="line-modified"> 341     }</span>
<span class="line-added"> 342     if (err != 0) {</span>
<span class="line-added"> 343         setLastError(err, &quot;getaddrinfo: failed to parse address&quot;);</span>
<span class="line-added"> 344         return JDWPTRANSPORT_ERROR_IO_ERROR;</span>
<span class="line-added"> 345     }</span>
<span class="line-added"> 346 </span>
<span class="line-added"> 347     if (scopeId &gt; 0) {</span>
<span class="line-added"> 348         if ((*result)-&gt;ai_family != AF_INET6) {</span>
<span class="line-added"> 349             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;IPv4 address cannot contain scope&quot;);</span>
 350         }
 351 
<span class="line-modified"> 352         ((struct sockaddr_in6 *)((*result)-&gt;ai_addr))-&gt;sin6_scope_id = (uint32_t)scopeId;</span>
 353     }
 354 
 355     return JDWPTRANSPORT_ERROR_NONE;
 356 }
 357 
<span class="line-modified"> 358 /*</span>
<span class="line-modified"> 359  * Result must be released with dbgsysFreeAddrInfo.</span>
<span class="line-modified"> 360  */</span>
<span class="line-modified"> 361 static jdwpTransportError</span>
<span class="line-modified"> 362 parseAddress(const char *address, struct addrinfo **result) {</span>
<span class="line-modified"> 363     const char *colon;</span>
<span class="line-modified"> 364     size_t hostnameLen;</span>
<span class="line-modified"> 365     const char *port;</span>
<span class="line-modified"> 366     struct addrinfo hints;</span>
<span class="line-modified"> 367 </span>
<span class="line-modified"> 368     *result = NULL;</span>
<span class="line-modified"> 369 </span>
<span class="line-modified"> 370     /* check for host:port or port */</span>
<span class="line-modified"> 371     colon = strrchr(address, &#39;:&#39;);</span>
<span class="line-modified"> 372     port = (colon == NULL ? address : colon + 1);</span>
<span class="line-modified"> 373 </span>
<span class="line-modified"> 374     /* ensure the port is valid (getaddrinfo allows port to be empty) */</span>
<span class="line-modified"> 375     if (getPortNumber(port) &lt; 0) {</span>
<span class="line-modified"> 376         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;invalid port number specified&quot;);</span>
<span class="line-modified"> 377     }</span>
<span class="line-modified"> 378 </span>
<span class="line-modified"> 379     memset (&amp;hints, 0, sizeof(hints));</span>
<span class="line-added"> 380     hints.ai_family = allowOnlyIPv4 ? AF_INET : AF_UNSPEC;</span>
<span class="line-added"> 381     hints.ai_socktype = SOCK_STREAM;</span>
<span class="line-added"> 382     hints.ai_protocol = IPPROTO_TCP;</span>
<span class="line-added"> 383     hints.ai_flags = AI_NUMERICSERV;    // port must be a number</span>
<span class="line-added"> 384 </span>
<span class="line-added"> 385     hostnameLen = (colon == NULL ? 0 : colon - address);</span>
<span class="line-added"> 386     if (hostnameLen == 0) {</span>
<span class="line-added"> 387         /* no hostname - use localhost address (pass NULL to getaddrinfo) */</span>
<span class="line-added"> 388         address = NULL;</span>
<span class="line-added"> 389     } else  if (*address == &#39;*&#39; &amp;&amp; hostnameLen == 1) {</span>
<span class="line-added"> 390         /* *:port - listen on all interfaces</span>
<span class="line-added"> 391          * use IPv6 socket (to accept IPv6 and mapped IPv4),</span>
<span class="line-added"> 392          * pass hostname == NULL to getaddrinfo.</span>
<span class="line-added"> 393          */</span>
<span class="line-added"> 394         hints.ai_family = allowOnlyIPv4 ? AF_INET : AF_INET6;</span>
<span class="line-added"> 395         hints.ai_flags |= AI_PASSIVE | (allowOnlyIPv4 ? 0 : AI_V4MAPPED | AI_ALL);</span>
<span class="line-added"> 396         address = NULL;</span>
 397     }
 398 
<span class="line-modified"> 399     return getAddrInfo(address, hostnameLen, port, &amp;hints, result);</span>

 400 }
 401 
<span class="line-modified"> 402 /*</span>
<span class="line-modified"> 403  * Input is sockaddr just because all clients have it.</span>
<span class="line-modified"> 404  */</span>
<span class="line-modified"> 405 static void convertIPv4ToIPv6(const struct sockaddr *addr4, struct in6_addr *addr6) {</span>
<span class="line-modified"> 406     // Implement in a platform-independent way.</span>
<span class="line-modified"> 407     // Spec requires in_addr has s_addr member, in6_addr has s6_addr[16] member.</span>
<span class="line-added"> 408     struct in_addr *a4 = &amp;(((struct sockaddr_in*)addr4)-&gt;sin_addr);</span>
<span class="line-added"> 409     memset(addr6, 0, sizeof(*addr6));   // for safety</span>
<span class="line-added"> 410 </span>
<span class="line-added"> 411     // Mapped address contains 80 zero bits, then 16 &quot;1&quot; bits, then IPv4 address (4 bytes).</span>
<span class="line-added"> 412     addr6-&gt;s6_addr[10] = addr6-&gt;s6_addr[11] = 0xFF;</span>
<span class="line-added"> 413     memcpy(&amp;(addr6-&gt;s6_addr[12]), &amp;(a4-&gt;s_addr), 4);</span>
<span class="line-added"> 414 }</span>
 415 
<span class="line-modified"> 416 /*</span>
<span class="line-modified"> 417  * Parses address (IPv4 or IPv6), fills in result by parsed address.</span>
<span class="line-modified"> 418  * For IPv4 mapped IPv6 is returned in result, isIPv4 is set.</span>
<span class="line-added"> 419  */</span>
<span class="line-added"> 420 static jdwpTransportError</span>
<span class="line-added"> 421 parseAllowedAddr(const char *buffer, struct in6_addr *result, int *isIPv4) {</span>
<span class="line-added"> 422     struct addrinfo hints;</span>
<span class="line-added"> 423     struct addrinfo *addrInfo = NULL;</span>
<span class="line-added"> 424     jdwpTransportError err;</span>
<span class="line-added"> 425 </span>
<span class="line-added"> 426     /*</span>
<span class="line-added"> 427      * To parse both IPv4 and IPv6 need to specify AF_UNSPEC family</span>
<span class="line-added"> 428      * (with AF_INET6 IPv4 addresses are not parsed even with AI_V4MAPPED and AI_ALL flags).</span>
<span class="line-added"> 429      */</span>
<span class="line-added"> 430     memset (&amp;hints, 0, sizeof(hints));</span>
<span class="line-added"> 431     hints.ai_family = AF_UNSPEC;            // IPv6 or mapped IPv4</span>
<span class="line-added"> 432     hints.ai_socktype = SOCK_STREAM;</span>
<span class="line-added"> 433     hints.ai_protocol = IPPROTO_TCP;</span>
<span class="line-added"> 434     hints.ai_flags = AI_NUMERICHOST;        // only numeric addresses, no resolution</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436     err = getAddrInfo(buffer, strlen(buffer), NULL, &amp;hints, &amp;addrInfo);</span>
<span class="line-added"> 437 </span>
<span class="line-added"> 438     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-added"> 439         return err;</span>
<span class="line-added"> 440     }</span>
<span class="line-added"> 441 </span>
<span class="line-added"> 442     if (addrInfo-&gt;ai_family == AF_INET6) {</span>
<span class="line-added"> 443         memcpy(result, &amp;(((struct sockaddr_in6 *)(addrInfo-&gt;ai_addr))-&gt;sin6_addr), sizeof(*result));</span>
<span class="line-added"> 444         *isIPv4 = 0;</span>
<span class="line-added"> 445     } else {    // IPv4 address - convert to mapped IPv6</span>
<span class="line-added"> 446         struct in6_addr addr6;</span>
<span class="line-added"> 447         convertIPv4ToIPv6(addrInfo-&gt;ai_addr, &amp;addr6);</span>
<span class="line-added"> 448         memcpy(result, &amp;addr6, sizeof(*result));</span>
<span class="line-added"> 449         *isIPv4 = 1;</span>
<span class="line-added"> 450     }</span>
<span class="line-added"> 451 </span>
<span class="line-added"> 452     dbgsysFreeAddrInfo(addrInfo);</span>
<span class="line-added"> 453 </span>
<span class="line-added"> 454     return JDWPTRANSPORT_ERROR_NONE;</span>
<span class="line-added"> 455 }</span>
<span class="line-added"> 456 </span>
<span class="line-added"> 457 /*</span>
<span class="line-added"> 458  * Parses prefix length from buffer (integer value), fills in result with corresponding net mask.</span>
<span class="line-added"> 459  * For IPv4 (isIPv4 is set), maximum prefix length is 32 bit, for IPv6 - 128 bit.</span>
<span class="line-added"> 460  */</span>
<span class="line-added"> 461 static jdwpTransportError</span>
<span class="line-added"> 462 parseAllowedMask(const char *buffer, int isIPv4, struct in6_addr *result) {</span>
<span class="line-added"> 463     int prefixLen = 0;</span>
<span class="line-added"> 464     int maxValue = isIPv4 ? 32 : 128;</span>
<span class="line-added"> 465     int i;</span>
<span class="line-added"> 466 </span>
<span class="line-added"> 467     do {</span>
<span class="line-added"> 468         if (*buffer &lt; &#39;0&#39; || *buffer &gt; &#39;9&#39;) {</span>
<span class="line-added"> 469             return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;</span>
 470         }
<span class="line-modified"> 471         prefixLen = prefixLen * 10 + (*buffer - &#39;0&#39;);</span>
<span class="line-modified"> 472         if (prefixLen &gt; maxValue) {  // avoid overflow</span>
<span class="line-added"> 473             return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;</span>
 474         }
<span class="line-modified"> 475         buffer++;</span>
<span class="line-modified"> 476     } while (*buffer != &#39;\0&#39;);</span>
<span class="line-added"> 477 </span>
<span class="line-added"> 478     if (isIPv4) {</span>
<span class="line-added"> 479         // IPv4 are stored as mapped IPv6, prefixLen needs to be converted too</span>
<span class="line-added"> 480         prefixLen += 96;</span>
 481     }
 482 
<span class="line-modified"> 483     if (prefixLen == 0) {</span>
<span class="line-modified"> 484         return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;</span>

 485     }
 486 
<span class="line-modified"> 487     // generate mask for prefix length</span>
<span class="line-modified"> 488     memset(result, 0, sizeof(*result));</span>

 489 
<span class="line-modified"> 490     // prefixLen &lt;= 128, so we won&#39;t go over result&#39;s size</span>
<span class="line-modified"> 491     for (i = 0; prefixLen &gt; 0; i++, prefixLen -= 8) {</span>
<span class="line-modified"> 492         if (prefixLen &gt;= 8) {</span>
<span class="line-added"> 493             // set the whole byte</span>
<span class="line-added"> 494             result-&gt;s6_addr[i] = 0xFF;</span>
<span class="line-added"> 495         } else {</span>
<span class="line-added"> 496             // set only &quot;prefixLen&quot; bits</span>
<span class="line-added"> 497             result-&gt;s6_addr[i] = (char)(0xFF &lt;&lt; (8 - prefixLen));</span>
<span class="line-added"> 498         }</span>
<span class="line-added"> 499     }</span>
<span class="line-added"> 500 </span>
<span class="line-added"> 501     return JDWPTRANSPORT_ERROR_NONE;</span>
 502 }
 503 
<span class="line-added"> 504 /*</span>
<span class="line-added"> 505  * Internal implementation of parseAllowedPeers (requires writable buffer).</span>
<span class="line-added"> 506  */</span>
 507 static jdwpTransportError
<span class="line-modified"> 508 parseAllowedPeersInternal(char *buffer) {</span>
<span class="line-modified"> 509     char *next;</span>
<span class="line-modified"> 510     int isIPv4 = 0;</span>
<span class="line-modified"> 511 </span>
<span class="line-modified"> 512     do {</span>
<span class="line-modified"> 513         char *mask = NULL;</span>
<span class="line-modified"> 514         char *endOfAddr = strpbrk(buffer, &quot;/+&quot;);</span>
<span class="line-modified"> 515         if (endOfAddr == NULL) {</span>
<span class="line-modified"> 516             // this is the last address and there is no prefix length</span>
<span class="line-modified"> 517             next = NULL;</span>
<span class="line-modified"> 518         } else {</span>
<span class="line-added"> 519             next = endOfAddr + 1;</span>
<span class="line-added"> 520             if (*endOfAddr == &#39;/&#39;) {</span>
<span class="line-added"> 521                 // mask (prefix length) presents</span>
<span class="line-added"> 522                 char *endOfMask = strchr(next, &#39;+&#39;);</span>
<span class="line-added"> 523                 mask = next;</span>
<span class="line-added"> 524                 if (endOfMask == NULL) {</span>
<span class="line-added"> 525                     // no more addresses</span>
<span class="line-added"> 526                     next = NULL;</span>
<span class="line-added"> 527                 } else {</span>
<span class="line-added"> 528                     next = endOfMask + 1;</span>
<span class="line-added"> 529                     *endOfMask = &#39;\0&#39;;</span>
<span class="line-added"> 530                 }</span>
<span class="line-added"> 531             }</span>
<span class="line-added"> 532             *endOfAddr = &#39;\0&#39;;</span>
<span class="line-added"> 533         }</span>
<span class="line-added"> 534 </span>
<span class="line-added"> 535         // parse subnet address (IPv4 is stored as mapped IPv6)</span>
<span class="line-added"> 536         if (parseAllowedAddr(buffer, &amp;(_peers[_peers_cnt].subnet), &amp;isIPv4) != JDWPTRANSPORT_ERROR_NONE) {</span>
 537             _peers_cnt = 0;
<span class="line-modified"> 538             fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, buffer);</span>
 539             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
 540                          &quot;invalid IP address in allow option&quot;);
 541         }
<span class="line-modified"> 542         if (mask != NULL) {</span>
<span class="line-modified"> 543             size_t i;</span>
<span class="line-modified"> 544             if (parseAllowedMask(mask, isIPv4, &amp;(_peers[_peers_cnt].netmask)) != JDWPTRANSPORT_ERROR_NONE) {</span>



 545                 _peers_cnt = 0;
<span class="line-modified"> 546                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, mask);</span>
 547                 RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
 548                              &quot;invalid netmask in allow option&quot;);
 549             }
<span class="line-added"> 550             // for safety update subnet to satisfy the mask</span>
<span class="line-added"> 551             for (i = 0; i &lt; sizeof(_peers[_peers_cnt].subnet); i++) {</span>
<span class="line-added"> 552                 _peers[_peers_cnt].subnet.s6_addr[i] &amp;= _peers[_peers_cnt].netmask.s6_addr[i];</span>
<span class="line-added"> 553             }</span>
 554         } else {
<span class="line-modified"> 555             memset(&amp;(_peers[_peers_cnt].netmask), 0xFF, sizeof(_peers[_peers_cnt].netmask));</span>

 556         }
<span class="line-added"> 557         _peers_cnt++;</span>
<span class="line-added"> 558         buffer = next;</span>
<span class="line-added"> 559     } while (next != NULL);</span>
 560 
<span class="line-modified"> 561     return JDWPTRANSPORT_ERROR_NONE;</span>
<span class="line-modified"> 562 }</span>
<span class="line-modified"> 563 </span>
<span class="line-modified"> 564 /*</span>
<span class="line-modified"> 565  * Parses &#39;allow&#39; argument (fills in list of allowed peers (global _peers variable)).</span>
<span class="line-modified"> 566  * &#39;Allow&#39; value consists of tokens separated by &#39;+&#39;,</span>
<span class="line-modified"> 567  * each token contains IP address (IPv4 or IPv6) and optional prefixLength:</span>
<span class="line-modified"> 568  * &#39;&lt;addr&gt;[/&lt;prefixLength&gt;]&#39;.</span>
<span class="line-modified"> 569  * Example: &#39;192.168.1.10+192.168.0.0/24&#39;</span>
<span class="line-modified"> 570  *   - connections are allowed from 192.168.1.10 and subnet 192.168.0.XX.</span>
<span class="line-modified"> 571  */</span>
<span class="line-modified"> 572 static jdwpTransportError</span>
<span class="line-modified"> 573 parseAllowedPeers(const char *allowed_peers, size_t len) {</span>
<span class="line-modified"> 574     // Build a list of allowed peers from char string</span>
<span class="line-modified"> 575     // of format 192.168.0.10+192.168.0.0/24</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577     // writable copy of the value</span>
<span class="line-added"> 578     char *buffer = (*callback-&gt;alloc)((int)len + 1);</span>
<span class="line-added"> 579     if (buffer == NULL) {</span>
<span class="line-added"> 580         RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);</span>
<span class="line-added"> 581     }</span>
<span class="line-added"> 582     memcpy(buffer, allowed_peers, len);</span>
<span class="line-added"> 583     buffer[len] = &#39;\0&#39;;</span>
<span class="line-added"> 584 </span>
<span class="line-added"> 585     jdwpTransportError err = parseAllowedPeersInternal(buffer);</span>
<span class="line-added"> 586 </span>
<span class="line-added"> 587     (*callback-&gt;free)(buffer);</span>
<span class="line-added"> 588 </span>
<span class="line-added"> 589     return err;</span>
<span class="line-added"> 590 }</span>
<span class="line-added"> 591 </span>
<span class="line-added"> 592 static int</span>
<span class="line-added"> 593 isAddressInSubnet(const struct in6_addr *address, const struct in6_addr *subnet, const struct in6_addr *mask) {</span>
<span class="line-added"> 594     size_t i;</span>
<span class="line-added"> 595     for (i = 0; i &lt; sizeof(struct in6_addr); i++) {</span>
<span class="line-added"> 596         if ((address-&gt;s6_addr[i] &amp; mask-&gt;s6_addr[i]) != subnet-&gt;s6_addr[i]) {</span>
<span class="line-added"> 597             return 0;</span>
 598         }
 599     }
<span class="line-modified"> 600     return 1;</span>
 601 }
 602 
 603 static int
<span class="line-modified"> 604 isPeerAllowed(struct sockaddr_storage *peer) {</span>
<span class="line-added"> 605     struct in6_addr tmp;</span>
<span class="line-added"> 606     struct in6_addr *addr6;</span>
 607     int i;
<span class="line-added"> 608     // _peers contains IPv6 subnet and mask (IPv4 is converted to mapped IPv6)</span>
<span class="line-added"> 609     if (peer-&gt;ss_family == AF_INET) {</span>
<span class="line-added"> 610         convertIPv4ToIPv6((struct sockaddr *)peer, &amp;tmp);</span>
<span class="line-added"> 611         addr6 = &amp;tmp;</span>
<span class="line-added"> 612     } else {</span>
<span class="line-added"> 613         addr6 = &amp;(((struct sockaddr_in6 *)peer)-&gt;sin6_addr);</span>
<span class="line-added"> 614     }</span>
<span class="line-added"> 615 </span>
 616     for (i = 0; i &lt; _peers_cnt; ++i) {
<span class="line-modified"> 617         if (isAddressInSubnet(addr6, &amp;(_peers[i].subnet), &amp;(_peers[i].netmask))) {</span>

 618             return 1;
 619         }
 620     }
 621 
 622     return 0;
 623 }
 624 
 625 static jdwpTransportError JNICALL
 626 socketTransport_getCapabilities(jdwpTransportEnv* env,
 627         JDWPTransportCapabilities* capabilitiesPtr)
 628 {
 629     JDWPTransportCapabilities result;
 630 
 631     memset(&amp;result, 0, sizeof(result));
 632     result.can_timeout_attach = JNI_TRUE;
 633     result.can_timeout_accept = JNI_TRUE;
 634     result.can_timeout_handshake = JNI_TRUE;
 635 
 636     *capabilitiesPtr = result;
 637 
 638     return JDWPTRANSPORT_ERROR_NONE;
 639 }
 640 
<span class="line-modified"> 641 /*</span>
<span class="line-modified"> 642  * Starts listening on the specified addrinfo,</span>
<span class="line-modified"> 643  * returns listening socket and actual listening port.</span>
<span class="line-modified"> 644  * If the function fails and returned socket != -1, the socket should be closed.</span>
<span class="line-added"> 645  */</span>
<span class="line-added"> 646 static jdwpTransportError startListening(struct addrinfo *ai, int *socket, char** actualAddress)</span>
 647 {

 648     int err;
 649 
<span class="line-modified"> 650     *socket = dbgsysSocket(ai-&gt;ai_family, SOCK_STREAM, IPPROTO_TCP);</span>
<span class="line-modified"> 651     if (*socket &lt; 0) {</span>













 652         RETURN_IO_ERROR(&quot;socket creation failed&quot;);
 653     }
 654 
<span class="line-modified"> 655     err = setOptionsCommon(ai-&gt;ai_family, *socket);</span>
 656     if (err) {
 657         return err;
 658     }
<span class="line-modified"> 659 </span>
<span class="line-added"> 660     if (getPort(ai-&gt;ai_addr) != 0) {</span>
 661         /*
 662          * Only need SO_REUSEADDR if we&#39;re using a fixed port. If we
 663          * start seeing EADDRINUSE due to collisions in free ports
 664          * then we should retry the dbgsysBind() a few times.
 665          */
<span class="line-modified"> 666         err = setReuseAddrOption(*socket);</span>
 667         if (err) {
 668             return err;
 669         }
 670     }
 671 
<span class="line-modified"> 672     err = dbgsysBind(*socket, ai-&gt;ai_addr, (socklen_t)ai-&gt;ai_addrlen);</span>
 673     if (err &lt; 0) {
 674         RETURN_IO_ERROR(&quot;bind failed&quot;);
 675     }
 676 
<span class="line-modified"> 677     err = dbgsysListen(*socket, 1); // only 1 debugger can attach</span>
 678     if (err &lt; 0) {
 679         RETURN_IO_ERROR(&quot;listen failed&quot;);
 680     }
 681 
 682     {
 683         char buf[20];
<span class="line-modified"> 684         struct sockaddr_storage addr;</span>
<span class="line-added"> 685         socklen_t len = sizeof(addr);</span>
 686         jint portNum;
<span class="line-modified"> 687         err = dbgsysGetSocketName(*socket, (struct sockaddr *)&amp;addr, &amp;len);</span>
<span class="line-modified"> 688         if (err != 0) {</span>
<span class="line-modified"> 689             RETURN_IO_ERROR(&quot;getsockname failed&quot;);</span>
<span class="line-added"> 690         }</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692         portNum = getPort((struct sockaddr *)&amp;addr);</span>
 693         sprintf(buf, &quot;%d&quot;, portNum);
 694         *actualAddress = (*callback-&gt;alloc)((int)strlen(buf) + 1);
 695         if (*actualAddress == NULL) {
 696             RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
 697         } else {
 698             strcpy(*actualAddress, buf);
 699         }
 700     }
 701 
 702     return JDWPTRANSPORT_ERROR_NONE;
 703 }
 704 
<span class="line-added"> 705 static jdwpTransportError JNICALL</span>
<span class="line-added"> 706 socketTransport_startListening(jdwpTransportEnv* env, const char* address,</span>
<span class="line-added"> 707                                char** actualAddress)</span>
<span class="line-added"> 708 {</span>
<span class="line-added"> 709     int err;</span>
<span class="line-added"> 710     int pass;</span>
<span class="line-added"> 711     struct addrinfo *addrInfo = NULL;</span>
<span class="line-added"> 712     struct addrinfo *listenAddr = NULL;</span>
<span class="line-added"> 713     struct addrinfo *ai = NULL;</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715     /* no address provided */</span>
<span class="line-added"> 716     if ((address == NULL) || (address[0] == &#39;\0&#39;)) {</span>
<span class="line-added"> 717         address = &quot;0&quot;;</span>
<span class="line-added"> 718     }</span>
<span class="line-added"> 719 </span>
<span class="line-added"> 720     err = parseAddress(address, &amp;addrInfo);</span>
<span class="line-added"> 721     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-added"> 722         return err;</span>
<span class="line-added"> 723     }</span>
<span class="line-added"> 724 </span>
<span class="line-added"> 725     /* 1st pass - preferredAddressFamily (by default IPv4), 2nd pass - the rest */</span>
<span class="line-added"> 726     for (pass = 0; pass &lt; 2 &amp;&amp; listenAddr == NULL; pass++) {</span>
<span class="line-added"> 727         for (ai = addrInfo; ai != NULL; ai = ai-&gt;ai_next) {</span>
<span class="line-added"> 728             if ((pass == 0 &amp;&amp; ai-&gt;ai_family == preferredAddressFamily) ||</span>
<span class="line-added"> 729                 (pass == 1 &amp;&amp; ai-&gt;ai_family != preferredAddressFamily))</span>
<span class="line-added"> 730             {</span>
<span class="line-added"> 731                 listenAddr = ai;</span>
<span class="line-added"> 732                 break;</span>
<span class="line-added"> 733             }</span>
<span class="line-added"> 734         }</span>
<span class="line-added"> 735     }</span>
<span class="line-added"> 736 </span>
<span class="line-added"> 737     if (listenAddr == NULL) {</span>
<span class="line-added"> 738         dbgsysFreeAddrInfo(addrInfo);</span>
<span class="line-added"> 739         RETURN_ERROR(JDWPTRANSPORT_ERROR_INTERNAL, &quot;listen failed: wrong address&quot;);</span>
<span class="line-added"> 740     }</span>
<span class="line-added"> 741 </span>
<span class="line-added"> 742     err = startListening(listenAddr, &amp;serverSocketFD, actualAddress);</span>
<span class="line-added"> 743 </span>
<span class="line-added"> 744     dbgsysFreeAddrInfo(addrInfo);</span>
<span class="line-added"> 745 </span>
<span class="line-added"> 746     if (err != JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-added"> 747         if (serverSocketFD &gt;= 0) {</span>
<span class="line-added"> 748             dbgsysSocketClose(serverSocketFD);</span>
<span class="line-added"> 749             serverSocketFD = -1;</span>
<span class="line-added"> 750         }</span>
<span class="line-added"> 751         return err;</span>
<span class="line-added"> 752     }</span>
<span class="line-added"> 753 </span>
<span class="line-added"> 754     return JDWPTRANSPORT_ERROR_NONE;</span>
<span class="line-added"> 755 }</span>
<span class="line-added"> 756 </span>
 757 static jdwpTransportError JNICALL
 758 socketTransport_accept(jdwpTransportEnv* env, jlong acceptTimeout, jlong handshakeTimeout)
 759 {

 760     int err = JDWPTRANSPORT_ERROR_NONE;
<span class="line-modified"> 761     struct sockaddr_storage clientAddr;</span>
<span class="line-modified"> 762     socklen_t clientAddrLen;</span>
<span class="line-added"> 763     jlong startTime = 0;</span>
 764 
 765     /*
 766      * Use a default handshake timeout if not specified - this avoids an indefinite
 767      * hang in cases where something other than a debugger connects to our port.
 768      */
 769     if (handshakeTimeout == 0) {
 770         handshakeTimeout = 2000;
 771     }
 772 
 773     do {
 774         /*
 775          * If there is an accept timeout then we put the socket in non-blocking
 776          * mode and poll for a connection.
 777          */
 778         if (acceptTimeout &gt; 0) {
 779             int rv;
 780             dbgsysConfigureBlocking(serverSocketFD, JNI_FALSE);
 781             startTime = dbgsysCurrentTimeMillis();
 782             rv = dbgsysPoll(serverSocketFD, JNI_TRUE, JNI_FALSE, (long)acceptTimeout);
 783             if (rv &lt;= 0) {
 784                 /* set the last error here as could be overridden by configureBlocking */
 785                 if (rv == 0) {
 786                     setLastError(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;poll failed&quot;);
 787                 }
 788                 /* restore blocking state */
 789                 dbgsysConfigureBlocking(serverSocketFD, JNI_TRUE);
 790                 if (rv == 0) {
 791                     RETURN_ERROR(JDWPTRANSPORT_ERROR_TIMEOUT, &quot;timed out waiting for connection&quot;);
 792                 } else {
 793                     return JDWPTRANSPORT_ERROR_IO_ERROR;
 794                 }
 795             }
 796         }
 797 
 798         /*
 799          * Accept the connection
 800          */
<span class="line-modified"> 801         clientAddrLen = sizeof(clientAddr);</span>

 802         socketFD = dbgsysAccept(serverSocketFD,
<span class="line-modified"> 803                                 (struct sockaddr *)&amp;clientAddr,</span>
<span class="line-modified"> 804                                 &amp;clientAddrLen);</span>
 805         /* set the last error here as could be overridden by configureBlocking */
 806         if (socketFD &lt; 0) {
 807             setLastError(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;accept failed&quot;);
 808         }
 809         /*
 810          * Restore the blocking state - note that the accepted socket may be in
 811          * blocking or non-blocking mode (platform dependent). However as there
 812          * is a handshake timeout set then it will go into non-blocking mode
 813          * anyway for the handshake.
 814          */
 815         if (acceptTimeout &gt; 0) {
 816             dbgsysConfigureBlocking(serverSocketFD, JNI_TRUE);
 817         }
 818         if (socketFD &lt; 0) {
 819             return JDWPTRANSPORT_ERROR_IO_ERROR;
 820         }
 821 
 822         /*
 823          * version &gt;= JDWPTRANSPORT_VERSION_1_1:
 824          * Verify that peer is allowed to connect.
 825          */
 826         if (_peers_cnt &gt; 0) {
<span class="line-modified"> 827             if (!isPeerAllowed(&amp;clientAddr)) {</span>
 828                 char ebuf[64] = { 0 };
<span class="line-modified"> 829                 char addrStr[INET_ADDRSTRLEN] = { 0 };</span>
<span class="line-modified"> 830                 int err2 = getnameinfo((struct sockaddr *)&amp;clientAddr, clientAddrLen,</span>
<span class="line-added"> 831                                        addrStr, sizeof(addrStr), NULL, 0,</span>
<span class="line-added"> 832                                        NI_NUMERICHOST);</span>
 833                 sprintf(ebuf, &quot;ERROR: Peer not allowed to connect: %s\n&quot;,
<span class="line-modified"> 834                         (err2 != 0) ? &quot;&lt;bad address&gt;&quot; : addrStr);</span>
 835                 dbgsysSocketClose(socketFD);
 836                 socketFD = -1;
 837                 err = JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;
 838                 setLastError(err, ebuf);
 839             }
 840         }
 841 
 842         if (socketFD &gt; 0) {
 843           /* handshake with the debugger */
 844           err = handshake(socketFD, handshakeTimeout);
 845         }
 846 
 847         /*
 848          * If the handshake fails then close the connection. If there if an accept
 849          * timeout then we must adjust the timeout for the next poll.
 850          */
 851         if (err != JDWPTRANSPORT_ERROR_NONE) {
 852             fprintf(stderr, &quot;Debugger failed to attach: %s\n&quot;, getLastError());
 853             dbgsysSocketClose(socketFD);
 854             socketFD = -1;
</pre>
<hr />
<pre>
 863             }
 864         }
 865     } while (socketFD &lt; 0);
 866 
 867     return JDWPTRANSPORT_ERROR_NONE;
 868 }
 869 
 870 static jdwpTransportError JNICALL
 871 socketTransport_stopListening(jdwpTransportEnv *env)
 872 {
 873     if (serverSocketFD &lt; 0) {
 874         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_STATE, &quot;connection not open&quot;);
 875     }
 876     if (dbgsysSocketClose(serverSocketFD) &lt; 0) {
 877         RETURN_IO_ERROR(&quot;close failed&quot;);
 878     }
 879     serverSocketFD = -1;
 880     return JDWPTRANSPORT_ERROR_NONE;
 881 }
 882 
<span class="line-modified"> 883 /*</span>
<span class="line-modified"> 884  * Tries to connect to the specified addrinfo, returns connected socket.</span>
<span class="line-modified"> 885  * If the function fails and returned socket != -1, the socket should be closed.</span>
<span class="line-modified"> 886  */</span>
<span class="line-modified"> 887 static jdwpTransportError connectToAddr(struct addrinfo *ai, jlong timeout, int *socket) {</span>
 888     int err;
 889 
<span class="line-modified"> 890     *socket = dbgsysSocket(ai-&gt;ai_family, ai-&gt;ai_socktype, ai-&gt;ai_protocol);</span>
<span class="line-modified"> 891     if (*socket &lt; 0) {</span>









 892         RETURN_IO_ERROR(&quot;unable to create socket&quot;);
 893     }
 894 
<span class="line-modified"> 895     err = setOptionsCommon(ai-&gt;ai_family, socketFD);</span>
 896     if (err) {
 897         return err;
 898     }
 899 
 900     /*
 901      * We don&#39;t call setReuseAddrOption() for the non-server socket
 902      * case. If we start seeing EADDRINUSE due to collisions in free
 903      * ports then we should retry the dbgsysConnect() a few times.
 904      */
 905 
 906     /*
 907      * To do a timed connect we make the socket non-blocking
 908      * and poll with a timeout;
 909      */
<span class="line-modified"> 910     if (timeout &gt; 0) {</span>
 911         dbgsysConfigureBlocking(socketFD, JNI_FALSE);
 912     }
 913 
<span class="line-modified"> 914     err = dbgsysConnect(socketFD, ai-&gt;ai_addr, (socklen_t)ai-&gt;ai_addrlen);</span>
<span class="line-modified"> 915 </span>
<span class="line-modified"> 916     if (err == DBG_EINPROGRESS &amp;&amp; timeout &gt; 0) {</span>
<span class="line-added"> 917         err = dbgsysFinishConnect(socketFD, (long)timeout);</span>
 918 
 919         if (err == DBG_ETIMEOUT) {
 920             dbgsysConfigureBlocking(socketFD, JNI_TRUE);
 921             RETURN_ERROR(JDWPTRANSPORT_ERROR_TIMEOUT, &quot;connect timed out&quot;);
 922         }
 923     }
 924 
<span class="line-modified"> 925     if (err) {</span>
 926         RETURN_IO_ERROR(&quot;connect failed&quot;);
 927     }
 928 
<span class="line-added"> 929     return err;</span>
<span class="line-added"> 930 }</span>
<span class="line-added"> 931 </span>
<span class="line-added"> 932 </span>
<span class="line-added"> 933 static jdwpTransportError JNICALL</span>
<span class="line-added"> 934 socketTransport_attach(jdwpTransportEnv* env, const char* addressString, jlong attachTimeout,</span>
<span class="line-added"> 935                        jlong handshakeTimeout)</span>
<span class="line-added"> 936 {</span>
<span class="line-added"> 937     int err;</span>
<span class="line-added"> 938     int pass;</span>
<span class="line-added"> 939     struct addrinfo *addrInfo = NULL;</span>
<span class="line-added"> 940     struct addrinfo *ai;</span>
<span class="line-added"> 941 </span>
<span class="line-added"> 942     if (addressString == NULL || addressString[0] == &#39;\0&#39;) {</span>
<span class="line-added"> 943         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;address is missing&quot;);</span>
<span class="line-added"> 944     }</span>
<span class="line-added"> 945 </span>
<span class="line-added"> 946     err = parseAddress(addressString, &amp;addrInfo);</span>
<span class="line-added"> 947     if (err) {</span>
<span class="line-added"> 948         return err;</span>
<span class="line-added"> 949     }</span>
<span class="line-added"> 950 </span>
<span class="line-added"> 951     /* 1st pass - preferredAddressFamily (by default IPv4), 2nd pass - the rest */</span>
<span class="line-added"> 952     for (pass = 0; pass &lt; 2 &amp;&amp; socketFD &lt; 0; pass++) {</span>
<span class="line-added"> 953         for (ai = addrInfo; ai != NULL; ai = ai-&gt;ai_next) {</span>
<span class="line-added"> 954             if ((pass == 0 &amp;&amp; ai-&gt;ai_family == preferredAddressFamily) ||</span>
<span class="line-added"> 955                 (pass == 1 &amp;&amp; ai-&gt;ai_family != preferredAddressFamily))</span>
<span class="line-added"> 956             {</span>
<span class="line-added"> 957                 err = connectToAddr(ai, attachTimeout, &amp;socketFD);</span>
<span class="line-added"> 958                 if (err == JDWPTRANSPORT_ERROR_NONE) {</span>
<span class="line-added"> 959                     break;</span>
<span class="line-added"> 960                 }</span>
<span class="line-added"> 961                 if (socketFD &gt;= 0) {</span>
<span class="line-added"> 962                     dbgsysSocketClose(socketFD);</span>
<span class="line-added"> 963                     socketFD = -1;</span>
<span class="line-added"> 964                 }</span>
<span class="line-added"> 965             }</span>
<span class="line-added"> 966         }</span>
<span class="line-added"> 967     }</span>
<span class="line-added"> 968 </span>
<span class="line-added"> 969     freeaddrinfo(addrInfo);</span>
<span class="line-added"> 970 </span>
<span class="line-added"> 971     /* err from the last connectToAddr() call */</span>
<span class="line-added"> 972     if (err != 0) {</span>
<span class="line-added"> 973         return err;</span>
<span class="line-added"> 974     }</span>
<span class="line-added"> 975 </span>
 976     if (attachTimeout &gt; 0) {
 977         dbgsysConfigureBlocking(socketFD, JNI_TRUE);
 978     }
 979 
 980     err = handshake(socketFD, handshakeTimeout);
 981     if (err) {
 982         dbgsysSocketClose(socketFD);
 983         socketFD = -1;
 984         return err;
 985     }
 986 
 987     return JDWPTRANSPORT_ERROR_NONE;
 988 }
 989 
 990 static jboolean JNICALL
 991 socketTransport_isOpen(jdwpTransportEnv* env)
 992 {
 993     if (socketFD &gt;= 0) {
 994         return JNI_TRUE;
 995     } else {
</pre>
<hr />
<pre>
1226 
1227     if (cfg == NULL) {
1228         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
1229                      &quot;NULL pointer to transport configuration is invalid&quot;);
1230     }
1231     allowed_peers = cfg-&gt;allowed_peers;
1232     _peers_cnt = 0;
1233     if (allowed_peers != NULL) {
1234         size_t len = strlen(allowed_peers);
1235         if (len == 0) { /* Impossible: parseOptions() would reject it */
1236             fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);
1237             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
1238                          &quot;allow option should not be empty&quot;);
1239         } else if (*allowed_peers == &#39;*&#39;) {
1240             if (len != 1) {
1241                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);
1242                 RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
1243                              &quot;allow option &#39;*&#39; cannot be expanded&quot;);
1244             }
1245         } else {
<span class="line-modified">1246             int err = parseAllowedPeers(allowed_peers, len);</span>
1247             if (err != JDWPTRANSPORT_ERROR_NONE) {
1248                 return err;
1249             }
1250         }
1251     }
1252     return JDWPTRANSPORT_ERROR_NONE;
1253 }
1254 
<span class="line-added">1255 /*</span>
<span class="line-added">1256  * Reads boolean system value, sets *result to</span>
<span class="line-added">1257  *  - trueValue if the property is &quot;true&quot;;</span>
<span class="line-added">1258  *  - falseValue if the property is &quot;false&quot;.</span>
<span class="line-added">1259  * Doesn&#39;t change *result if the property is not set or failed to read.</span>
<span class="line-added">1260  */</span>
<span class="line-added">1261 static int readBooleanSysProp(int *result, int trueValue, int falseValue,</span>
<span class="line-added">1262     JNIEnv* jniEnv, jclass sysClass, jmethodID getPropMethod, const char *propName)</span>
<span class="line-added">1263 {</span>
<span class="line-added">1264     jstring value;</span>
<span class="line-added">1265     jstring name = (*jniEnv)-&gt;NewStringUTF(jniEnv, propName);</span>
<span class="line-added">1266 </span>
<span class="line-added">1267     if (name == NULL) {</span>
<span class="line-added">1268         return JNI_ERR;</span>
<span class="line-added">1269     }</span>
<span class="line-added">1270     value = (jstring)(*jniEnv)-&gt;CallStaticObjectMethod(jniEnv, sysClass, getPropMethod, name);</span>
<span class="line-added">1271     if ((*jniEnv)-&gt;ExceptionCheck(jniEnv)) {</span>
<span class="line-added">1272         return JNI_ERR;</span>
<span class="line-added">1273     }</span>
<span class="line-added">1274     if (value != NULL) {</span>
<span class="line-added">1275         const char *theValue = (*jniEnv)-&gt;GetStringUTFChars(jniEnv, value, NULL);</span>
<span class="line-added">1276         if (theValue == NULL) {</span>
<span class="line-added">1277             return JNI_ERR;</span>
<span class="line-added">1278         }</span>
<span class="line-added">1279         if (strcmp(theValue, &quot;true&quot;) == 0) {</span>
<span class="line-added">1280             *result = trueValue;</span>
<span class="line-added">1281         } else if (strcmp(theValue, &quot;false&quot;) == 0) {</span>
<span class="line-added">1282             *result = falseValue;</span>
<span class="line-added">1283         }</span>
<span class="line-added">1284         (*jniEnv)-&gt;ReleaseStringUTFChars(jniEnv, value, theValue);</span>
<span class="line-added">1285     }</span>
<span class="line-added">1286     return JNI_OK;</span>
<span class="line-added">1287 }</span>
<span class="line-added">1288 </span>
1289 JNIEXPORT jint JNICALL
1290 jdwpTransport_OnLoad(JavaVM *vm, jdwpTransportCallback* cbTablePtr,
1291                      jint version, jdwpTransportEnv** env)
1292 {
<span class="line-added">1293     JNIEnv* jniEnv = NULL;</span>
<span class="line-added">1294 </span>
1295     if (version &lt; JDWPTRANSPORT_VERSION_1_0 ||
1296         version &gt; JDWPTRANSPORT_VERSION_1_1) {
1297         return JNI_EVERSION;
1298     }
1299     if (initialized) {
1300         /*
1301          * This library doesn&#39;t support multiple environments (yet)
1302          */
1303         return JNI_EEXIST;
1304     }
1305     initialized = JNI_TRUE;
1306     jvm = vm;
1307     callback = cbTablePtr;
1308 
1309     /* initialize interface table */
1310     interface.GetCapabilities = &amp;socketTransport_getCapabilities;
1311     interface.Attach = &amp;socketTransport_attach;
1312     interface.StartListening = &amp;socketTransport_startListening;
1313     interface.StopListening = &amp;socketTransport_stopListening;
1314     interface.Accept = &amp;socketTransport_accept;
1315     interface.IsOpen = &amp;socketTransport_isOpen;
1316     interface.Close = &amp;socketTransport_close;
1317     interface.ReadPacket = &amp;socketTransport_readPacket;
1318     interface.WritePacket = &amp;socketTransport_writePacket;
1319     interface.GetLastError = &amp;socketTransport_getLastError;
1320     if (version &gt;= JDWPTRANSPORT_VERSION_1_1) {
1321         interface.SetTransportConfiguration = &amp;socketTransport_setConfiguration;
1322     }
1323     *env = &amp;single_env;
1324 
1325     /* initialized TLS */
1326     tlsIndex = dbgsysTlsAlloc();
<span class="line-added">1327 </span>
<span class="line-added">1328     // retrieve network-related system properties</span>
<span class="line-added">1329     do {</span>
<span class="line-added">1330         jclass sysClass;</span>
<span class="line-added">1331         jmethodID getPropMethod;</span>
<span class="line-added">1332         if ((*vm)-&gt;GetEnv(vm, (void **)&amp;jniEnv, JNI_VERSION_9) != JNI_OK) {</span>
<span class="line-added">1333             break;</span>
<span class="line-added">1334         }</span>
<span class="line-added">1335         sysClass = (*jniEnv)-&gt;FindClass(jniEnv, &quot;java/lang/System&quot;);</span>
<span class="line-added">1336         if (sysClass == NULL) {</span>
<span class="line-added">1337             break;</span>
<span class="line-added">1338         }</span>
<span class="line-added">1339         getPropMethod = (*jniEnv)-&gt;GetStaticMethodID(jniEnv, sysClass,</span>
<span class="line-added">1340             &quot;getProperty&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);</span>
<span class="line-added">1341         if (getPropMethod == NULL) {</span>
<span class="line-added">1342             break;</span>
<span class="line-added">1343         }</span>
<span class="line-added">1344         readBooleanSysProp(&amp;allowOnlyIPv4, 1, 0,</span>
<span class="line-added">1345             jniEnv, sysClass, getPropMethod, &quot;java.net.preferIPv4Stack&quot;);</span>
<span class="line-added">1346         readBooleanSysProp(&amp;preferredAddressFamily, AF_INET6, AF_INET,</span>
<span class="line-added">1347             jniEnv, sysClass, getPropMethod, &quot;java.net.preferIPv6Addresses&quot;);</span>
<span class="line-added">1348     } while (0);</span>
<span class="line-added">1349 </span>
<span class="line-added">1350     if (jniEnv != NULL &amp;&amp; (*jniEnv)-&gt;ExceptionCheck(jniEnv)) {</span>
<span class="line-added">1351         (*jniEnv)-&gt;ExceptionClear(jniEnv);</span>
<span class="line-added">1352     }</span>
<span class="line-added">1353 </span>
<span class="line-added">1354 </span>
1355     return JNI_OK;
1356 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../jdk.jdi/share/man/jdb.1.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="sysSocket.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
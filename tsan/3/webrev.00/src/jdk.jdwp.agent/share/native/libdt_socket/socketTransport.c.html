<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jdwp.agent/share/native/libdt_socket/socketTransport.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;stdio.h&gt;
  26 #include &lt;string.h&gt;
  27 #include &lt;errno.h&gt;
  28 #include &lt;stdlib.h&gt;
  29 #include &lt;ctype.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jdwpTransport.h&quot;
  33 #include &quot;sysSocket.h&quot;
  34 
  35 #ifdef _WIN32
  36  #include &lt;winsock2.h&gt;
  37  #include &lt;ws2tcpip.h&gt;
  38  #include &lt;iphlpapi.h&gt;
  39 #else
  40  #include &lt;arpa/inet.h&gt;
  41  #include &lt;sys/socket.h&gt;
  42  #include &lt;net/if.h&gt;
  43 #endif
  44 
  45 /*
  46  * The Socket Transport Library.
  47  *
  48  * This module is an implementation of the Java Debug Wire Protocol Transport
  49  * Service Provider Interface - see src/share/javavm/export/jdwpTransport.h.
  50  */
  51 
  52 static int serverSocketFD = -1;
  53 static int socketFD = -1;
  54 static jdwpTransportCallback *callback;
  55 static JavaVM *jvm;
  56 static int tlsIndex;
  57 static jboolean initialized;
  58 static struct jdwpTransportNativeInterface_ interface;
  59 static jdwpTransportEnv single_env = (jdwpTransportEnv)&amp;interface;
  60 
  61 #define RETURN_ERROR(err, msg) \
  62         if (1==1) { \
  63             setLastError(err, msg); \
  64             return err; \
  65         }
  66 
  67 #define RETURN_IO_ERROR(msg)    RETURN_ERROR(JDWPTRANSPORT_ERROR_IO_ERROR, msg);
  68 
  69 #define RETURN_RECV_ERROR(n) \
  70         if (n == 0) { \
  71             RETURN_ERROR(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;premature EOF&quot;); \
  72         } else { \
  73             RETURN_IO_ERROR(&quot;recv error&quot;); \
  74         }
  75 
  76 #define MAX_DATA_SIZE 1000
  77 
  78 static jint recv_fully(int, char *, int);
  79 static jint send_fully(int, char *, int);
  80 
  81 /* version &gt;= JDWPTRANSPORT_VERSION_1_1 */
  82 typedef struct {
  83     /* subnet and mask are stored as IPv6 addresses, IPv4 is stored as mapped IPv6 */
  84     struct in6_addr subnet;
  85     struct in6_addr netmask;
  86 } AllowedPeerInfo;
  87 
  88 #define STR(x) #x
  89 #define MAX_PEER_ENTRIES 32
  90 #define MAX_PEERS_STR STR(MAX_PEER_ENTRIES)
  91 static AllowedPeerInfo _peers[MAX_PEER_ENTRIES];
  92 static int _peers_cnt = 0;
  93 
  94 
  95 static int allowOnlyIPv4 = 0;                  // reflects &quot;java.net.preferIPv4Stack&quot; sys. property
  96 static int preferredAddressFamily = AF_INET;   // &quot;java.net.preferIPv6Addresses&quot;
  97 
  98 /*
  99  * Record the last error for this thread.
 100  */
 101 static void
 102 setLastError(jdwpTransportError err, char *newmsg) {
 103     char buf[255];
 104     char *msg;
 105 
 106     /* get any I/O first in case any system calls override errno */
 107     if (err == JDWPTRANSPORT_ERROR_IO_ERROR) {
 108         dbgsysGetLastIOError(buf, sizeof(buf));
 109     }
 110 
 111     msg = (char *)dbgsysTlsGet(tlsIndex);
 112     if (msg != NULL) {
 113         (*callback-&gt;free)(msg);
 114     }
 115 
 116     if (err == JDWPTRANSPORT_ERROR_IO_ERROR) {
 117         char *join_str = &quot;: &quot;;
 118         int msg_len = (int)strlen(newmsg) + (int)strlen(join_str) +
 119                       (int)strlen(buf) + 3;
 120         msg = (*callback-&gt;alloc)(msg_len);
 121         if (msg != NULL) {
 122             strcpy(msg, newmsg);
 123             strcat(msg, join_str);
 124             strcat(msg, buf);
 125         }
 126     } else {
 127         msg = (*callback-&gt;alloc)((int)strlen(newmsg)+1);
 128         if (msg != NULL) {
 129             strcpy(msg, newmsg);
 130         }
 131     }
 132 
 133     dbgsysTlsPut(tlsIndex, msg);
 134 }
 135 
 136 /*
 137  * Return the last error for this thread (may be NULL)
 138  */
 139 static char*
 140 getLastError() {
 141     return (char *)dbgsysTlsGet(tlsIndex);
 142 }
 143 
 144 /* Set options common to client and server sides */
 145 static jdwpTransportError
 146 setOptionsCommon(int domain, int fd)
 147 {
 148     jvalue dontcare;
 149     int err;
 150 
 151     if (domain == AF_INET6) {
 152         int off = 0;
 153         // make the socket a dual mode socket
 154         // this may fail if IPv4 is not supported - it&#39;s ok
 155         setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&amp;off, sizeof(off));
 156     }
 157 
 158     dontcare.i = 0;  /* keep compiler happy */
 159     err = dbgsysSetSocketOption(fd, TCP_NODELAY, JNI_TRUE, dontcare);
 160     if (err &lt; 0) {
 161         RETURN_IO_ERROR(&quot;setsockopt TCPNODELAY failed&quot;);
 162     }
 163 
 164     return JDWPTRANSPORT_ERROR_NONE;
 165 }
 166 
 167 /* Set the SO_REUSEADDR option */
 168 static jdwpTransportError
 169 setReuseAddrOption(int fd)
 170 {
 171     jvalue dontcare;
 172     int err;
 173 
 174     dontcare.i = 0;  /* keep compiler happy */
 175 
 176     err = dbgsysSetSocketOption(fd, SO_REUSEADDR, JNI_TRUE, dontcare);
 177     if (err &lt; 0) {
 178         RETURN_IO_ERROR(&quot;setsockopt SO_REUSEADDR failed&quot;);
 179     }
 180 
 181     return JDWPTRANSPORT_ERROR_NONE;
 182 }
 183 
 184 static jdwpTransportError
 185 handshake(int fd, jlong timeout) {
 186     const char *hello = &quot;JDWP-Handshake&quot;;
 187     char b[16];
 188     int rv, helloLen, received;
 189 
 190     if (timeout &gt; 0) {
 191         dbgsysConfigureBlocking(fd, JNI_FALSE);
 192     }
 193     helloLen = (int)strlen(hello);
 194     received = 0;
 195     while (received &lt; helloLen) {
 196         int n;
 197         char *buf;
 198         if (timeout &gt; 0) {
 199             rv = dbgsysPoll(fd, JNI_TRUE, JNI_FALSE, (long)timeout);
 200             if (rv &lt;= 0) {
 201                 setLastError(0, &quot;timeout during handshake&quot;);
 202                 return JDWPTRANSPORT_ERROR_IO_ERROR;
 203             }
 204         }
 205         buf = b;
 206         buf += received;
 207         n = recv_fully(fd, buf, helloLen-received);
 208         if (n == 0) {
 209             setLastError(0, &quot;handshake failed - connection prematurally closed&quot;);
 210             return JDWPTRANSPORT_ERROR_IO_ERROR;
 211         }
 212         if (n &lt; 0) {
 213             RETURN_IO_ERROR(&quot;recv failed during handshake&quot;);
 214         }
 215         received += n;
 216     }
 217     if (timeout &gt; 0) {
 218         dbgsysConfigureBlocking(fd, JNI_TRUE);
 219     }
 220     if (strncmp(b, hello, received) != 0) {
 221         char msg[80+2*16];
 222         b[received] = &#39;\0&#39;;
 223         /*
 224          * We should really use snprintf here but it&#39;s not available on Windows.
 225          * We can&#39;t use jio_snprintf without linking the transport against the VM.
 226          */
 227         sprintf(msg, &quot;handshake failed - received &gt;%s&lt; - expected &gt;%s&lt;&quot;, b, hello);
 228         setLastError(0, msg);
 229         return JDWPTRANSPORT_ERROR_IO_ERROR;
 230     }
 231 
 232     if (send_fully(fd, (char*)hello, helloLen) != helloLen) {
 233         RETURN_IO_ERROR(&quot;send failed during handshake&quot;);
 234     }
 235     return JDWPTRANSPORT_ERROR_NONE;
 236 }
 237 
 238 static int
 239 getPortNumber(const char *s_port) {
 240     u_long n;
 241     char *eptr;
 242 
 243     if (*s_port == 0) {
 244         // bad address - colon with no port number in parameters
 245         return -1;
 246     }
 247 
 248     n = strtoul(s_port, &amp;eptr, 10);
 249     if (eptr != s_port + strlen(s_port)) {
 250         // incomplete conversion - port number contains non-digit
 251         return -1;
 252     }
 253 
 254     if (n &gt; (u_short) -1) {
 255         // check that value supplied by user is less than
 256         // maximum possible u_short value (65535) and
 257         // will not be truncated later.
 258         return -1;
 259     }
 260 
 261     return n;
 262 }
 263 
 264 static unsigned short getPort(struct sockaddr *sa)
 265 {
 266     return dbgsysNetworkToHostShort(sa-&gt;sa_family == AF_INET
 267                                     ? (((struct sockaddr_in*)sa)-&gt;sin_port)
 268                                     : (((struct sockaddr_in6*)sa)-&gt;sin6_port));
 269 }
 270 
 271 /*
 272  * Parses scope id.
 273  * Scope id is ulong on Windows, uint32 on unix, so returns long which can be cast to uint32.
 274  * On error sets last error and returns -1.
 275  */
 276 static long parseScopeId(const char *str) {
 277     // try to handle scope as interface name
 278     unsigned long scopeId = if_nametoindex(str);
 279     if (scopeId == 0) {
 280         // try to parse integer value
 281         char *end;
 282         scopeId = strtoul(str, &amp;end, 10);
 283         if (*end != &#39;\0&#39;) {
 284             setLastError(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;failed to parse scope&quot;);
 285             return -1;
 286         }
 287     }
 288     // ensure parsed value is in uint32 range
 289     if (scopeId &gt; 0xFFFFFFFF) {
 290         setLastError(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;scope is out of range&quot;);
 291         return -1;
 292     }
 293     return (long)scopeId;
 294 }
 295 
 296 /*
 297  * Wrapper for dbgsysGetAddrInfo (getaddrinfo).
 298  * Handles enclosing square brackets and scopes.
 299  */
 300 static jdwpTransportError
 301 getAddrInfo(const char *hostname, size_t hostnameLen,
 302             const char *service,
 303             const struct addrinfo *hints,
 304             struct addrinfo **result)
 305 {
 306     int err = 0;
 307     char *buffer = NULL;
 308     long scopeId = 0;
 309 
 310     if (hostname != NULL) {
 311         char *scope = NULL;
 312         // skip surrounding
 313         if (hostnameLen &gt; 2 &amp;&amp; hostname[0] == &#39;[&#39; &amp;&amp; hostname[hostnameLen - 1] == &#39;]&#39;) {
 314             hostname++;
 315             hostnameLen -= 2;
 316         }
 317         buffer = (*callback-&gt;alloc)((int)hostnameLen + 1);
 318         if (buffer == NULL) {
 319             RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
 320         }
 321         memcpy(buffer, hostname, hostnameLen);
 322         buffer[hostnameLen] = &#39;\0&#39;;
 323 
 324         scope = strchr(buffer, &#39;%&#39;);
 325         if (scope != NULL) {
 326             // drop scope from the address
 327             *scope = &#39;\0&#39;;
 328             // and parse the value
 329             scopeId = parseScopeId(scope + 1);
 330             if (scopeId &lt; 0) {
 331                 (*callback-&gt;free)(buffer);
 332                 return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;
 333             }
 334         }
 335     }
 336 
 337     err = dbgsysGetAddrInfo(buffer, service, hints, result);
 338 
 339     if (buffer != NULL) {
 340         (*callback-&gt;free)(buffer);
 341     }
 342     if (err != 0) {
 343         setLastError(err, &quot;getaddrinfo: failed to parse address&quot;);
 344         return JDWPTRANSPORT_ERROR_IO_ERROR;
 345     }
 346 
 347     if (scopeId &gt; 0) {
 348         if ((*result)-&gt;ai_family != AF_INET6) {
 349             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;IPv4 address cannot contain scope&quot;);
 350         }
 351 
 352         ((struct sockaddr_in6 *)((*result)-&gt;ai_addr))-&gt;sin6_scope_id = (uint32_t)scopeId;
 353     }
 354 
 355     return JDWPTRANSPORT_ERROR_NONE;
 356 }
 357 
 358 /*
 359  * Result must be released with dbgsysFreeAddrInfo.
 360  */
 361 static jdwpTransportError
 362 parseAddress(const char *address, struct addrinfo **result) {
 363     const char *colon;
 364     size_t hostnameLen;
 365     const char *port;
 366     struct addrinfo hints;
 367 
 368     *result = NULL;
 369 
 370     /* check for host:port or port */
 371     colon = strrchr(address, &#39;:&#39;);
 372     port = (colon == NULL ? address : colon + 1);
 373 
 374     /* ensure the port is valid (getaddrinfo allows port to be empty) */
 375     if (getPortNumber(port) &lt; 0) {
 376         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;invalid port number specified&quot;);
 377     }
 378 
 379     memset (&amp;hints, 0, sizeof(hints));
 380     hints.ai_family = allowOnlyIPv4 ? AF_INET : AF_UNSPEC;
 381     hints.ai_socktype = SOCK_STREAM;
 382     hints.ai_protocol = IPPROTO_TCP;
 383     hints.ai_flags = AI_NUMERICSERV;    // port must be a number
 384 
 385     hostnameLen = (colon == NULL ? 0 : colon - address);
 386     if (hostnameLen == 0) {
 387         /* no hostname - use localhost address (pass NULL to getaddrinfo) */
 388         address = NULL;
 389     } else  if (*address == &#39;*&#39; &amp;&amp; hostnameLen == 1) {
 390         /* *:port - listen on all interfaces
 391          * use IPv6 socket (to accept IPv6 and mapped IPv4),
 392          * pass hostname == NULL to getaddrinfo.
 393          */
 394         hints.ai_family = allowOnlyIPv4 ? AF_INET : AF_INET6;
 395         hints.ai_flags |= AI_PASSIVE | (allowOnlyIPv4 ? 0 : AI_V4MAPPED | AI_ALL);
 396         address = NULL;
 397     }
 398 
 399     return getAddrInfo(address, hostnameLen, port, &amp;hints, result);
 400 }
 401 
 402 /*
 403  * Input is sockaddr just because all clients have it.
 404  */
 405 static void convertIPv4ToIPv6(const struct sockaddr *addr4, struct in6_addr *addr6) {
 406     // Implement in a platform-independent way.
 407     // Spec requires in_addr has s_addr member, in6_addr has s6_addr[16] member.
 408     struct in_addr *a4 = &amp;(((struct sockaddr_in*)addr4)-&gt;sin_addr);
 409     memset(addr6, 0, sizeof(*addr6));   // for safety
 410 
 411     // Mapped address contains 80 zero bits, then 16 &quot;1&quot; bits, then IPv4 address (4 bytes).
 412     addr6-&gt;s6_addr[10] = addr6-&gt;s6_addr[11] = 0xFF;
 413     memcpy(&amp;(addr6-&gt;s6_addr[12]), &amp;(a4-&gt;s_addr), 4);
 414 }
 415 
 416 /*
 417  * Parses address (IPv4 or IPv6), fills in result by parsed address.
 418  * For IPv4 mapped IPv6 is returned in result, isIPv4 is set.
 419  */
 420 static jdwpTransportError
 421 parseAllowedAddr(const char *buffer, struct in6_addr *result, int *isIPv4) {
 422     struct addrinfo hints;
 423     struct addrinfo *addrInfo = NULL;
 424     jdwpTransportError err;
 425 
 426     /*
 427      * To parse both IPv4 and IPv6 need to specify AF_UNSPEC family
 428      * (with AF_INET6 IPv4 addresses are not parsed even with AI_V4MAPPED and AI_ALL flags).
 429      */
 430     memset (&amp;hints, 0, sizeof(hints));
 431     hints.ai_family = AF_UNSPEC;            // IPv6 or mapped IPv4
 432     hints.ai_socktype = SOCK_STREAM;
 433     hints.ai_protocol = IPPROTO_TCP;
 434     hints.ai_flags = AI_NUMERICHOST;        // only numeric addresses, no resolution
 435 
 436     err = getAddrInfo(buffer, strlen(buffer), NULL, &amp;hints, &amp;addrInfo);
 437 
 438     if (err != JDWPTRANSPORT_ERROR_NONE) {
 439         return err;
 440     }
 441 
 442     if (addrInfo-&gt;ai_family == AF_INET6) {
 443         memcpy(result, &amp;(((struct sockaddr_in6 *)(addrInfo-&gt;ai_addr))-&gt;sin6_addr), sizeof(*result));
 444         *isIPv4 = 0;
 445     } else {    // IPv4 address - convert to mapped IPv6
 446         struct in6_addr addr6;
 447         convertIPv4ToIPv6(addrInfo-&gt;ai_addr, &amp;addr6);
 448         memcpy(result, &amp;addr6, sizeof(*result));
 449         *isIPv4 = 1;
 450     }
 451 
 452     dbgsysFreeAddrInfo(addrInfo);
 453 
 454     return JDWPTRANSPORT_ERROR_NONE;
 455 }
 456 
 457 /*
 458  * Parses prefix length from buffer (integer value), fills in result with corresponding net mask.
 459  * For IPv4 (isIPv4 is set), maximum prefix length is 32 bit, for IPv6 - 128 bit.
 460  */
 461 static jdwpTransportError
 462 parseAllowedMask(const char *buffer, int isIPv4, struct in6_addr *result) {
 463     int prefixLen = 0;
 464     int maxValue = isIPv4 ? 32 : 128;
 465     int i;
 466 
 467     do {
 468         if (*buffer &lt; &#39;0&#39; || *buffer &gt; &#39;9&#39;) {
 469             return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;
 470         }
 471         prefixLen = prefixLen * 10 + (*buffer - &#39;0&#39;);
 472         if (prefixLen &gt; maxValue) {  // avoid overflow
 473             return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;
 474         }
 475         buffer++;
 476     } while (*buffer != &#39;\0&#39;);
 477 
 478     if (isIPv4) {
 479         // IPv4 are stored as mapped IPv6, prefixLen needs to be converted too
 480         prefixLen += 96;
 481     }
 482 
 483     if (prefixLen == 0) {
 484         return JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;
 485     }
 486 
 487     // generate mask for prefix length
 488     memset(result, 0, sizeof(*result));
 489 
 490     // prefixLen &lt;= 128, so we won&#39;t go over result&#39;s size
 491     for (i = 0; prefixLen &gt; 0; i++, prefixLen -= 8) {
 492         if (prefixLen &gt;= 8) {
 493             // set the whole byte
 494             result-&gt;s6_addr[i] = 0xFF;
 495         } else {
 496             // set only &quot;prefixLen&quot; bits
 497             result-&gt;s6_addr[i] = (char)(0xFF &lt;&lt; (8 - prefixLen));
 498         }
 499     }
 500 
 501     return JDWPTRANSPORT_ERROR_NONE;
 502 }
 503 
 504 /*
 505  * Internal implementation of parseAllowedPeers (requires writable buffer).
 506  */
 507 static jdwpTransportError
 508 parseAllowedPeersInternal(char *buffer) {
 509     char *next;
 510     int isIPv4 = 0;
 511 
 512     do {
 513         char *mask = NULL;
 514         char *endOfAddr = strpbrk(buffer, &quot;/+&quot;);
 515         if (endOfAddr == NULL) {
 516             // this is the last address and there is no prefix length
 517             next = NULL;
 518         } else {
 519             next = endOfAddr + 1;
 520             if (*endOfAddr == &#39;/&#39;) {
 521                 // mask (prefix length) presents
 522                 char *endOfMask = strchr(next, &#39;+&#39;);
 523                 mask = next;
 524                 if (endOfMask == NULL) {
 525                     // no more addresses
 526                     next = NULL;
 527                 } else {
 528                     next = endOfMask + 1;
 529                     *endOfMask = &#39;\0&#39;;
 530                 }
 531             }
 532             *endOfAddr = &#39;\0&#39;;
 533         }
 534 
 535         // parse subnet address (IPv4 is stored as mapped IPv6)
 536         if (parseAllowedAddr(buffer, &amp;(_peers[_peers_cnt].subnet), &amp;isIPv4) != JDWPTRANSPORT_ERROR_NONE) {
 537             _peers_cnt = 0;
 538             fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, buffer);
 539             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
 540                          &quot;invalid IP address in allow option&quot;);
 541         }
 542         if (mask != NULL) {
 543             size_t i;
 544             if (parseAllowedMask(mask, isIPv4, &amp;(_peers[_peers_cnt].netmask)) != JDWPTRANSPORT_ERROR_NONE) {
 545                 _peers_cnt = 0;
 546                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, mask);
 547                 RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
 548                              &quot;invalid netmask in allow option&quot;);
 549             }
 550             // for safety update subnet to satisfy the mask
 551             for (i = 0; i &lt; sizeof(_peers[_peers_cnt].subnet); i++) {
 552                 _peers[_peers_cnt].subnet.s6_addr[i] &amp;= _peers[_peers_cnt].netmask.s6_addr[i];
 553             }
 554         } else {
 555             memset(&amp;(_peers[_peers_cnt].netmask), 0xFF, sizeof(_peers[_peers_cnt].netmask));
 556         }
 557         _peers_cnt++;
 558         buffer = next;
 559     } while (next != NULL);
 560 
 561     return JDWPTRANSPORT_ERROR_NONE;
 562 }
 563 
 564 /*
 565  * Parses &#39;allow&#39; argument (fills in list of allowed peers (global _peers variable)).
 566  * &#39;Allow&#39; value consists of tokens separated by &#39;+&#39;,
 567  * each token contains IP address (IPv4 or IPv6) and optional prefixLength:
 568  * &#39;&lt;addr&gt;[/&lt;prefixLength&gt;]&#39;.
 569  * Example: &#39;192.168.1.10+192.168.0.0/24&#39;
 570  *   - connections are allowed from 192.168.1.10 and subnet 192.168.0.XX.
 571  */
 572 static jdwpTransportError
 573 parseAllowedPeers(const char *allowed_peers, size_t len) {
 574     // Build a list of allowed peers from char string
 575     // of format 192.168.0.10+192.168.0.0/24
 576 
 577     // writable copy of the value
 578     char *buffer = (*callback-&gt;alloc)((int)len + 1);
 579     if (buffer == NULL) {
 580         RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
 581     }
 582     memcpy(buffer, allowed_peers, len);
 583     buffer[len] = &#39;\0&#39;;
 584 
 585     jdwpTransportError err = parseAllowedPeersInternal(buffer);
 586 
 587     (*callback-&gt;free)(buffer);
 588 
 589     return err;
 590 }
 591 
 592 static int
 593 isAddressInSubnet(const struct in6_addr *address, const struct in6_addr *subnet, const struct in6_addr *mask) {
 594     size_t i;
 595     for (i = 0; i &lt; sizeof(struct in6_addr); i++) {
 596         if ((address-&gt;s6_addr[i] &amp; mask-&gt;s6_addr[i]) != subnet-&gt;s6_addr[i]) {
 597             return 0;
 598         }
 599     }
 600     return 1;
 601 }
 602 
 603 static int
 604 isPeerAllowed(struct sockaddr_storage *peer) {
 605     struct in6_addr tmp;
 606     struct in6_addr *addr6;
 607     int i;
 608     // _peers contains IPv6 subnet and mask (IPv4 is converted to mapped IPv6)
 609     if (peer-&gt;ss_family == AF_INET) {
 610         convertIPv4ToIPv6((struct sockaddr *)peer, &amp;tmp);
 611         addr6 = &amp;tmp;
 612     } else {
 613         addr6 = &amp;(((struct sockaddr_in6 *)peer)-&gt;sin6_addr);
 614     }
 615 
 616     for (i = 0; i &lt; _peers_cnt; ++i) {
 617         if (isAddressInSubnet(addr6, &amp;(_peers[i].subnet), &amp;(_peers[i].netmask))) {
 618             return 1;
 619         }
 620     }
 621 
 622     return 0;
 623 }
 624 
 625 static jdwpTransportError JNICALL
 626 socketTransport_getCapabilities(jdwpTransportEnv* env,
 627         JDWPTransportCapabilities* capabilitiesPtr)
 628 {
 629     JDWPTransportCapabilities result;
 630 
 631     memset(&amp;result, 0, sizeof(result));
 632     result.can_timeout_attach = JNI_TRUE;
 633     result.can_timeout_accept = JNI_TRUE;
 634     result.can_timeout_handshake = JNI_TRUE;
 635 
 636     *capabilitiesPtr = result;
 637 
 638     return JDWPTRANSPORT_ERROR_NONE;
 639 }
 640 
 641 /*
 642  * Starts listening on the specified addrinfo,
 643  * returns listening socket and actual listening port.
 644  * If the function fails and returned socket != -1, the socket should be closed.
 645  */
 646 static jdwpTransportError startListening(struct addrinfo *ai, int *socket, char** actualAddress)
 647 {
 648     int err;
 649 
 650     *socket = dbgsysSocket(ai-&gt;ai_family, SOCK_STREAM, IPPROTO_TCP);
 651     if (*socket &lt; 0) {
 652         RETURN_IO_ERROR(&quot;socket creation failed&quot;);
 653     }
 654 
 655     err = setOptionsCommon(ai-&gt;ai_family, *socket);
 656     if (err) {
 657         return err;
 658     }
 659 
 660     if (getPort(ai-&gt;ai_addr) != 0) {
 661         /*
 662          * Only need SO_REUSEADDR if we&#39;re using a fixed port. If we
 663          * start seeing EADDRINUSE due to collisions in free ports
 664          * then we should retry the dbgsysBind() a few times.
 665          */
 666         err = setReuseAddrOption(*socket);
 667         if (err) {
 668             return err;
 669         }
 670     }
 671 
 672     err = dbgsysBind(*socket, ai-&gt;ai_addr, (socklen_t)ai-&gt;ai_addrlen);
 673     if (err &lt; 0) {
 674         RETURN_IO_ERROR(&quot;bind failed&quot;);
 675     }
 676 
 677     err = dbgsysListen(*socket, 1); // only 1 debugger can attach
 678     if (err &lt; 0) {
 679         RETURN_IO_ERROR(&quot;listen failed&quot;);
 680     }
 681 
 682     {
 683         char buf[20];
 684         struct sockaddr_storage addr;
 685         socklen_t len = sizeof(addr);
 686         jint portNum;
 687         err = dbgsysGetSocketName(*socket, (struct sockaddr *)&amp;addr, &amp;len);
 688         if (err != 0) {
 689             RETURN_IO_ERROR(&quot;getsockname failed&quot;);
 690         }
 691 
 692         portNum = getPort((struct sockaddr *)&amp;addr);
 693         sprintf(buf, &quot;%d&quot;, portNum);
 694         *actualAddress = (*callback-&gt;alloc)((int)strlen(buf) + 1);
 695         if (*actualAddress == NULL) {
 696             RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
 697         } else {
 698             strcpy(*actualAddress, buf);
 699         }
 700     }
 701 
 702     return JDWPTRANSPORT_ERROR_NONE;
 703 }
 704 
 705 static jdwpTransportError JNICALL
 706 socketTransport_startListening(jdwpTransportEnv* env, const char* address,
 707                                char** actualAddress)
 708 {
 709     int err;
 710     int pass;
 711     struct addrinfo *addrInfo = NULL;
 712     struct addrinfo *listenAddr = NULL;
 713     struct addrinfo *ai = NULL;
 714 
 715     /* no address provided */
 716     if ((address == NULL) || (address[0] == &#39;\0&#39;)) {
 717         address = &quot;0&quot;;
 718     }
 719 
 720     err = parseAddress(address, &amp;addrInfo);
 721     if (err != JDWPTRANSPORT_ERROR_NONE) {
 722         return err;
 723     }
 724 
 725     /* 1st pass - preferredAddressFamily (by default IPv4), 2nd pass - the rest */
 726     for (pass = 0; pass &lt; 2 &amp;&amp; listenAddr == NULL; pass++) {
 727         for (ai = addrInfo; ai != NULL; ai = ai-&gt;ai_next) {
 728             if ((pass == 0 &amp;&amp; ai-&gt;ai_family == preferredAddressFamily) ||
 729                 (pass == 1 &amp;&amp; ai-&gt;ai_family != preferredAddressFamily))
 730             {
 731                 listenAddr = ai;
 732                 break;
 733             }
 734         }
 735     }
 736 
 737     if (listenAddr == NULL) {
 738         dbgsysFreeAddrInfo(addrInfo);
 739         RETURN_ERROR(JDWPTRANSPORT_ERROR_INTERNAL, &quot;listen failed: wrong address&quot;);
 740     }
 741 
 742     err = startListening(listenAddr, &amp;serverSocketFD, actualAddress);
 743 
 744     dbgsysFreeAddrInfo(addrInfo);
 745 
 746     if (err != JDWPTRANSPORT_ERROR_NONE) {
 747         if (serverSocketFD &gt;= 0) {
 748             dbgsysSocketClose(serverSocketFD);
 749             serverSocketFD = -1;
 750         }
 751         return err;
 752     }
 753 
 754     return JDWPTRANSPORT_ERROR_NONE;
 755 }
 756 
 757 static jdwpTransportError JNICALL
 758 socketTransport_accept(jdwpTransportEnv* env, jlong acceptTimeout, jlong handshakeTimeout)
 759 {
 760     int err = JDWPTRANSPORT_ERROR_NONE;
 761     struct sockaddr_storage clientAddr;
 762     socklen_t clientAddrLen;
 763     jlong startTime = 0;
 764 
 765     /*
 766      * Use a default handshake timeout if not specified - this avoids an indefinite
 767      * hang in cases where something other than a debugger connects to our port.
 768      */
 769     if (handshakeTimeout == 0) {
 770         handshakeTimeout = 2000;
 771     }
 772 
 773     do {
 774         /*
 775          * If there is an accept timeout then we put the socket in non-blocking
 776          * mode and poll for a connection.
 777          */
 778         if (acceptTimeout &gt; 0) {
 779             int rv;
 780             dbgsysConfigureBlocking(serverSocketFD, JNI_FALSE);
 781             startTime = dbgsysCurrentTimeMillis();
 782             rv = dbgsysPoll(serverSocketFD, JNI_TRUE, JNI_FALSE, (long)acceptTimeout);
 783             if (rv &lt;= 0) {
 784                 /* set the last error here as could be overridden by configureBlocking */
 785                 if (rv == 0) {
 786                     setLastError(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;poll failed&quot;);
 787                 }
 788                 /* restore blocking state */
 789                 dbgsysConfigureBlocking(serverSocketFD, JNI_TRUE);
 790                 if (rv == 0) {
 791                     RETURN_ERROR(JDWPTRANSPORT_ERROR_TIMEOUT, &quot;timed out waiting for connection&quot;);
 792                 } else {
 793                     return JDWPTRANSPORT_ERROR_IO_ERROR;
 794                 }
 795             }
 796         }
 797 
 798         /*
 799          * Accept the connection
 800          */
 801         clientAddrLen = sizeof(clientAddr);
 802         socketFD = dbgsysAccept(serverSocketFD,
 803                                 (struct sockaddr *)&amp;clientAddr,
 804                                 &amp;clientAddrLen);
 805         /* set the last error here as could be overridden by configureBlocking */
 806         if (socketFD &lt; 0) {
 807             setLastError(JDWPTRANSPORT_ERROR_IO_ERROR, &quot;accept failed&quot;);
 808         }
 809         /*
 810          * Restore the blocking state - note that the accepted socket may be in
 811          * blocking or non-blocking mode (platform dependent). However as there
 812          * is a handshake timeout set then it will go into non-blocking mode
 813          * anyway for the handshake.
 814          */
 815         if (acceptTimeout &gt; 0) {
 816             dbgsysConfigureBlocking(serverSocketFD, JNI_TRUE);
 817         }
 818         if (socketFD &lt; 0) {
 819             return JDWPTRANSPORT_ERROR_IO_ERROR;
 820         }
 821 
 822         /*
 823          * version &gt;= JDWPTRANSPORT_VERSION_1_1:
 824          * Verify that peer is allowed to connect.
 825          */
 826         if (_peers_cnt &gt; 0) {
 827             if (!isPeerAllowed(&amp;clientAddr)) {
 828                 char ebuf[64] = { 0 };
 829                 char addrStr[INET_ADDRSTRLEN] = { 0 };
 830                 int err2 = getnameinfo((struct sockaddr *)&amp;clientAddr, clientAddrLen,
 831                                        addrStr, sizeof(addrStr), NULL, 0,
 832                                        NI_NUMERICHOST);
 833                 sprintf(ebuf, &quot;ERROR: Peer not allowed to connect: %s\n&quot;,
 834                         (err2 != 0) ? &quot;&lt;bad address&gt;&quot; : addrStr);
 835                 dbgsysSocketClose(socketFD);
 836                 socketFD = -1;
 837                 err = JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT;
 838                 setLastError(err, ebuf);
 839             }
 840         }
 841 
 842         if (socketFD &gt; 0) {
 843           /* handshake with the debugger */
 844           err = handshake(socketFD, handshakeTimeout);
 845         }
 846 
 847         /*
 848          * If the handshake fails then close the connection. If there if an accept
 849          * timeout then we must adjust the timeout for the next poll.
 850          */
 851         if (err != JDWPTRANSPORT_ERROR_NONE) {
 852             fprintf(stderr, &quot;Debugger failed to attach: %s\n&quot;, getLastError());
 853             dbgsysSocketClose(socketFD);
 854             socketFD = -1;
 855             if (acceptTimeout &gt; 0) {
 856                 long endTime = dbgsysCurrentTimeMillis();
 857                 acceptTimeout -= (endTime - startTime);
 858                 if (acceptTimeout &lt;= 0) {
 859                     setLastError(JDWPTRANSPORT_ERROR_IO_ERROR,
 860                         &quot;timeout waiting for debugger to connect&quot;);
 861                     return JDWPTRANSPORT_ERROR_IO_ERROR;
 862                 }
 863             }
 864         }
 865     } while (socketFD &lt; 0);
 866 
 867     return JDWPTRANSPORT_ERROR_NONE;
 868 }
 869 
 870 static jdwpTransportError JNICALL
 871 socketTransport_stopListening(jdwpTransportEnv *env)
 872 {
 873     if (serverSocketFD &lt; 0) {
 874         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_STATE, &quot;connection not open&quot;);
 875     }
 876     if (dbgsysSocketClose(serverSocketFD) &lt; 0) {
 877         RETURN_IO_ERROR(&quot;close failed&quot;);
 878     }
 879     serverSocketFD = -1;
 880     return JDWPTRANSPORT_ERROR_NONE;
 881 }
 882 
 883 /*
 884  * Tries to connect to the specified addrinfo, returns connected socket.
 885  * If the function fails and returned socket != -1, the socket should be closed.
 886  */
 887 static jdwpTransportError connectToAddr(struct addrinfo *ai, jlong timeout, int *socket) {
 888     int err;
 889 
 890     *socket = dbgsysSocket(ai-&gt;ai_family, ai-&gt;ai_socktype, ai-&gt;ai_protocol);
 891     if (*socket &lt; 0) {
 892         RETURN_IO_ERROR(&quot;unable to create socket&quot;);
 893     }
 894 
 895     err = setOptionsCommon(ai-&gt;ai_family, socketFD);
 896     if (err) {
 897         return err;
 898     }
 899 
 900     /*
 901      * We don&#39;t call setReuseAddrOption() for the non-server socket
 902      * case. If we start seeing EADDRINUSE due to collisions in free
 903      * ports then we should retry the dbgsysConnect() a few times.
 904      */
 905 
 906     /*
 907      * To do a timed connect we make the socket non-blocking
 908      * and poll with a timeout;
 909      */
 910     if (timeout &gt; 0) {
 911         dbgsysConfigureBlocking(socketFD, JNI_FALSE);
 912     }
 913 
 914     err = dbgsysConnect(socketFD, ai-&gt;ai_addr, (socklen_t)ai-&gt;ai_addrlen);
 915 
 916     if (err == DBG_EINPROGRESS &amp;&amp; timeout &gt; 0) {
 917         err = dbgsysFinishConnect(socketFD, (long)timeout);
 918 
 919         if (err == DBG_ETIMEOUT) {
 920             dbgsysConfigureBlocking(socketFD, JNI_TRUE);
 921             RETURN_ERROR(JDWPTRANSPORT_ERROR_TIMEOUT, &quot;connect timed out&quot;);
 922         }
 923     }
 924 
 925     if (err) {
 926         RETURN_IO_ERROR(&quot;connect failed&quot;);
 927     }
 928 
 929     return err;
 930 }
 931 
 932 
 933 static jdwpTransportError JNICALL
 934 socketTransport_attach(jdwpTransportEnv* env, const char* addressString, jlong attachTimeout,
 935                        jlong handshakeTimeout)
 936 {
 937     int err;
 938     int pass;
 939     struct addrinfo *addrInfo = NULL;
 940     struct addrinfo *ai;
 941 
 942     if (addressString == NULL || addressString[0] == &#39;\0&#39;) {
 943         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;address is missing&quot;);
 944     }
 945 
 946     err = parseAddress(addressString, &amp;addrInfo);
 947     if (err) {
 948         return err;
 949     }
 950 
 951     /* 1st pass - preferredAddressFamily (by default IPv4), 2nd pass - the rest */
 952     for (pass = 0; pass &lt; 2 &amp;&amp; socketFD &lt; 0; pass++) {
 953         for (ai = addrInfo; ai != NULL; ai = ai-&gt;ai_next) {
 954             if ((pass == 0 &amp;&amp; ai-&gt;ai_family == preferredAddressFamily) ||
 955                 (pass == 1 &amp;&amp; ai-&gt;ai_family != preferredAddressFamily))
 956             {
 957                 err = connectToAddr(ai, attachTimeout, &amp;socketFD);
 958                 if (err == JDWPTRANSPORT_ERROR_NONE) {
 959                     break;
 960                 }
 961                 if (socketFD &gt;= 0) {
 962                     dbgsysSocketClose(socketFD);
 963                     socketFD = -1;
 964                 }
 965             }
 966         }
 967     }
 968 
 969     freeaddrinfo(addrInfo);
 970 
 971     /* err from the last connectToAddr() call */
 972     if (err != 0) {
 973         return err;
 974     }
 975 
 976     if (attachTimeout &gt; 0) {
 977         dbgsysConfigureBlocking(socketFD, JNI_TRUE);
 978     }
 979 
 980     err = handshake(socketFD, handshakeTimeout);
 981     if (err) {
 982         dbgsysSocketClose(socketFD);
 983         socketFD = -1;
 984         return err;
 985     }
 986 
 987     return JDWPTRANSPORT_ERROR_NONE;
 988 }
 989 
 990 static jboolean JNICALL
 991 socketTransport_isOpen(jdwpTransportEnv* env)
 992 {
 993     if (socketFD &gt;= 0) {
 994         return JNI_TRUE;
 995     } else {
 996         return JNI_FALSE;
 997     }
 998 }
 999 
1000 static jdwpTransportError JNICALL
1001 socketTransport_close(jdwpTransportEnv* env)
1002 {
1003     int fd = socketFD;
1004     socketFD = -1;
1005     if (fd &lt; 0) {
1006         return JDWPTRANSPORT_ERROR_NONE;
1007     }
1008 #ifdef _AIX
1009     /*
1010       AIX needs a workaround for I/O cancellation, see:
1011       http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.basetechref/doc/basetrf1/close.htm
1012       ...
1013       The close subroutine is blocked until all subroutines which use the file
1014       descriptor return to usr space. For example, when a thread is calling close
1015       and another thread is calling select with the same file descriptor, the
1016       close subroutine does not return until the select call returns.
1017       ...
1018     */
1019     shutdown(fd, 2);
1020 #endif
1021     if (dbgsysSocketClose(fd) &lt; 0) {
1022         /*
1023          * close failed - it&#39;s pointless to restore socketFD here because
1024          * any subsequent close will likely fail as well.
1025          */
1026         RETURN_IO_ERROR(&quot;close failed&quot;);
1027     }
1028     return JDWPTRANSPORT_ERROR_NONE;
1029 }
1030 
1031 static jdwpTransportError JNICALL
1032 socketTransport_writePacket(jdwpTransportEnv* env, const jdwpPacket *packet)
1033 {
1034     jint len, data_len, id;
1035     /*
1036      * room for header and up to MAX_DATA_SIZE data bytes
1037      */
1038     char header[JDWP_HEADER_SIZE + MAX_DATA_SIZE];
1039     jbyte *data;
1040 
1041     /* packet can&#39;t be null */
1042     if (packet == NULL) {
1043         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;packet is NULL&quot;);
1044     }
1045 
1046     len = packet-&gt;type.cmd.len;         /* includes header */
1047     data_len = len - JDWP_HEADER_SIZE;
1048 
1049     /* bad packet */
1050     if (data_len &lt; 0) {
1051         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;invalid length&quot;);
1052     }
1053 
1054     /* prepare the header for transmission */
1055     len = (jint)dbgsysHostToNetworkLong(len);
1056     id = (jint)dbgsysHostToNetworkLong(packet-&gt;type.cmd.id);
1057 
1058     memcpy(header + 0, &amp;len, 4);
1059     memcpy(header + 4, &amp;id, 4);
1060     header[8] = packet-&gt;type.cmd.flags;
1061     if (packet-&gt;type.cmd.flags &amp; JDWPTRANSPORT_FLAGS_REPLY) {
1062         jshort errorCode =
1063             dbgsysHostToNetworkShort(packet-&gt;type.reply.errorCode);
1064         memcpy(header + 9, &amp;errorCode, 2);
1065     } else {
1066         header[9] = packet-&gt;type.cmd.cmdSet;
1067         header[10] = packet-&gt;type.cmd.cmd;
1068     }
1069 
1070     data = packet-&gt;type.cmd.data;
1071     /* Do one send for short packets, two for longer ones */
1072     if (data_len &lt;= MAX_DATA_SIZE) {
1073         memcpy(header + JDWP_HEADER_SIZE, data, data_len);
1074         if (send_fully(socketFD, (char *)&amp;header, JDWP_HEADER_SIZE + data_len) !=
1075             JDWP_HEADER_SIZE + data_len) {
1076             RETURN_IO_ERROR(&quot;send failed&quot;);
1077         }
1078     } else {
1079         memcpy(header + JDWP_HEADER_SIZE, data, MAX_DATA_SIZE);
1080         if (send_fully(socketFD, (char *)&amp;header, JDWP_HEADER_SIZE + MAX_DATA_SIZE) !=
1081             JDWP_HEADER_SIZE + MAX_DATA_SIZE) {
1082             RETURN_IO_ERROR(&quot;send failed&quot;);
1083         }
1084         /* Send the remaining data bytes right out of the data area. */
1085         if (send_fully(socketFD, (char *)data + MAX_DATA_SIZE,
1086                        data_len - MAX_DATA_SIZE) != data_len - MAX_DATA_SIZE) {
1087             RETURN_IO_ERROR(&quot;send failed&quot;);
1088         }
1089     }
1090 
1091     return JDWPTRANSPORT_ERROR_NONE;
1092 }
1093 
1094 static jint
1095 recv_fully(int f, char *buf, int len)
1096 {
1097     int nbytes = 0;
1098     while (nbytes &lt; len) {
1099         int res = dbgsysRecv(f, buf + nbytes, len - nbytes, 0);
1100         if (res &lt; 0) {
1101             return res;
1102         } else if (res == 0) {
1103             break; /* eof, return nbytes which is less than len */
1104         }
1105         nbytes += res;
1106     }
1107     return nbytes;
1108 }
1109 
1110 jint
1111 send_fully(int f, char *buf, int len)
1112 {
1113     int nbytes = 0;
1114     while (nbytes &lt; len) {
1115         int res = dbgsysSend(f, buf + nbytes, len - nbytes, 0);
1116         if (res &lt; 0) {
1117             return res;
1118         } else if (res == 0) {
1119             break; /* eof, return nbytes which is less than len */
1120         }
1121         nbytes += res;
1122     }
1123     return nbytes;
1124 }
1125 
1126 static jdwpTransportError JNICALL
1127 socketTransport_readPacket(jdwpTransportEnv* env, jdwpPacket* packet) {
1128     jint length, data_len;
1129     jint n;
1130 
1131     /* packet can&#39;t be null */
1132     if (packet == NULL) {
1133         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT, &quot;packet is null&quot;);
1134     }
1135 
1136     /* read the length field */
1137     n = recv_fully(socketFD, (char *)&amp;length, sizeof(jint));
1138 
1139     /* check for EOF */
1140     if (n == 0) {
1141         packet-&gt;type.cmd.len = 0;
1142         return JDWPTRANSPORT_ERROR_NONE;
1143     }
1144     if (n != sizeof(jint)) {
1145         RETURN_RECV_ERROR(n);
1146     }
1147 
1148     length = (jint)dbgsysNetworkToHostLong(length);
1149     packet-&gt;type.cmd.len = length;
1150 
1151 
1152     n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.cmd.id), sizeof(jint));
1153     if (n &lt; (int)sizeof(jint)) {
1154         RETURN_RECV_ERROR(n);
1155     }
1156 
1157     packet-&gt;type.cmd.id = (jint)dbgsysNetworkToHostLong(packet-&gt;type.cmd.id);
1158 
1159     n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.cmd.flags), sizeof(jbyte));
1160     if (n &lt; (int)sizeof(jbyte)) {
1161         RETURN_RECV_ERROR(n);
1162     }
1163 
1164     if (packet-&gt;type.cmd.flags &amp; JDWPTRANSPORT_FLAGS_REPLY) {
1165         n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.reply.errorCode), sizeof(jbyte));
1166         if (n &lt; (int)sizeof(jshort)) {
1167             RETURN_RECV_ERROR(n);
1168         }
1169 
1170         /* FIXME - should the error be converted to host order?? */
1171 
1172 
1173     } else {
1174         n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.cmd.cmdSet), sizeof(jbyte));
1175         if (n &lt; (int)sizeof(jbyte)) {
1176             RETURN_RECV_ERROR(n);
1177         }
1178 
1179         n = recv_fully(socketFD,(char *)&amp;(packet-&gt;type.cmd.cmd), sizeof(jbyte));
1180         if (n &lt; (int)sizeof(jbyte)) {
1181             RETURN_RECV_ERROR(n);
1182         }
1183     }
1184 
1185     data_len = length - ((sizeof(jint) * 2) + (sizeof(jbyte) * 3));
1186 
1187     if (data_len &lt; 0) {
1188         setLastError(0, &quot;Badly formed packet received - invalid length&quot;);
1189         return JDWPTRANSPORT_ERROR_IO_ERROR;
1190     } else if (data_len == 0) {
1191         packet-&gt;type.cmd.data = NULL;
1192     } else {
1193         packet-&gt;type.cmd.data= (*callback-&gt;alloc)(data_len);
1194 
1195         if (packet-&gt;type.cmd.data == NULL) {
1196             RETURN_ERROR(JDWPTRANSPORT_ERROR_OUT_OF_MEMORY, &quot;out of memory&quot;);
1197         }
1198 
1199         n = recv_fully(socketFD,(char *)packet-&gt;type.cmd.data, data_len);
1200         if (n &lt; data_len) {
1201             (*callback-&gt;free)(packet-&gt;type.cmd.data);
1202             RETURN_RECV_ERROR(n);
1203         }
1204     }
1205 
1206     return JDWPTRANSPORT_ERROR_NONE;
1207 }
1208 
1209 static jdwpTransportError JNICALL
1210 socketTransport_getLastError(jdwpTransportEnv* env, char** msgP) {
1211     char *msg = (char *)dbgsysTlsGet(tlsIndex);
1212     if (msg == NULL) {
1213         return JDWPTRANSPORT_ERROR_MSG_NOT_AVAILABLE;
1214     }
1215     *msgP = (*callback-&gt;alloc)((int)strlen(msg)+1);
1216     if (*msgP == NULL) {
1217         return JDWPTRANSPORT_ERROR_OUT_OF_MEMORY;
1218     }
1219     strcpy(*msgP, msg);
1220     return JDWPTRANSPORT_ERROR_NONE;
1221 }
1222 
1223 static jdwpTransportError JNICALL
1224 socketTransport_setConfiguration(jdwpTransportEnv* env, jdwpTransportConfiguration* cfg) {
1225     const char* allowed_peers = NULL;
1226 
1227     if (cfg == NULL) {
1228         RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
1229                      &quot;NULL pointer to transport configuration is invalid&quot;);
1230     }
1231     allowed_peers = cfg-&gt;allowed_peers;
1232     _peers_cnt = 0;
1233     if (allowed_peers != NULL) {
1234         size_t len = strlen(allowed_peers);
1235         if (len == 0) { /* Impossible: parseOptions() would reject it */
1236             fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);
1237             RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
1238                          &quot;allow option should not be empty&quot;);
1239         } else if (*allowed_peers == &#39;*&#39;) {
1240             if (len != 1) {
1241                 fprintf(stderr, &quot;Error in allow option: &#39;%s&#39;\n&quot;, allowed_peers);
1242                 RETURN_ERROR(JDWPTRANSPORT_ERROR_ILLEGAL_ARGUMENT,
1243                              &quot;allow option &#39;*&#39; cannot be expanded&quot;);
1244             }
1245         } else {
1246             int err = parseAllowedPeers(allowed_peers, len);
1247             if (err != JDWPTRANSPORT_ERROR_NONE) {
1248                 return err;
1249             }
1250         }
1251     }
1252     return JDWPTRANSPORT_ERROR_NONE;
1253 }
1254 
1255 /*
1256  * Reads boolean system value, sets *result to
1257  *  - trueValue if the property is &quot;true&quot;;
1258  *  - falseValue if the property is &quot;false&quot;.
1259  * Doesn&#39;t change *result if the property is not set or failed to read.
1260  */
1261 static int readBooleanSysProp(int *result, int trueValue, int falseValue,
1262     JNIEnv* jniEnv, jclass sysClass, jmethodID getPropMethod, const char *propName)
1263 {
1264     jstring value;
1265     jstring name = (*jniEnv)-&gt;NewStringUTF(jniEnv, propName);
1266 
1267     if (name == NULL) {
1268         return JNI_ERR;
1269     }
1270     value = (jstring)(*jniEnv)-&gt;CallStaticObjectMethod(jniEnv, sysClass, getPropMethod, name);
1271     if ((*jniEnv)-&gt;ExceptionCheck(jniEnv)) {
1272         return JNI_ERR;
1273     }
1274     if (value != NULL) {
1275         const char *theValue = (*jniEnv)-&gt;GetStringUTFChars(jniEnv, value, NULL);
1276         if (theValue == NULL) {
1277             return JNI_ERR;
1278         }
1279         if (strcmp(theValue, &quot;true&quot;) == 0) {
1280             *result = trueValue;
1281         } else if (strcmp(theValue, &quot;false&quot;) == 0) {
1282             *result = falseValue;
1283         }
1284         (*jniEnv)-&gt;ReleaseStringUTFChars(jniEnv, value, theValue);
1285     }
1286     return JNI_OK;
1287 }
1288 
1289 JNIEXPORT jint JNICALL
1290 jdwpTransport_OnLoad(JavaVM *vm, jdwpTransportCallback* cbTablePtr,
1291                      jint version, jdwpTransportEnv** env)
1292 {
1293     JNIEnv* jniEnv = NULL;
1294 
1295     if (version &lt; JDWPTRANSPORT_VERSION_1_0 ||
1296         version &gt; JDWPTRANSPORT_VERSION_1_1) {
1297         return JNI_EVERSION;
1298     }
1299     if (initialized) {
1300         /*
1301          * This library doesn&#39;t support multiple environments (yet)
1302          */
1303         return JNI_EEXIST;
1304     }
1305     initialized = JNI_TRUE;
1306     jvm = vm;
1307     callback = cbTablePtr;
1308 
1309     /* initialize interface table */
1310     interface.GetCapabilities = &amp;socketTransport_getCapabilities;
1311     interface.Attach = &amp;socketTransport_attach;
1312     interface.StartListening = &amp;socketTransport_startListening;
1313     interface.StopListening = &amp;socketTransport_stopListening;
1314     interface.Accept = &amp;socketTransport_accept;
1315     interface.IsOpen = &amp;socketTransport_isOpen;
1316     interface.Close = &amp;socketTransport_close;
1317     interface.ReadPacket = &amp;socketTransport_readPacket;
1318     interface.WritePacket = &amp;socketTransport_writePacket;
1319     interface.GetLastError = &amp;socketTransport_getLastError;
1320     if (version &gt;= JDWPTRANSPORT_VERSION_1_1) {
1321         interface.SetTransportConfiguration = &amp;socketTransport_setConfiguration;
1322     }
1323     *env = &amp;single_env;
1324 
1325     /* initialized TLS */
1326     tlsIndex = dbgsysTlsAlloc();
1327 
1328     // retrieve network-related system properties
1329     do {
1330         jclass sysClass;
1331         jmethodID getPropMethod;
1332         if ((*vm)-&gt;GetEnv(vm, (void **)&amp;jniEnv, JNI_VERSION_9) != JNI_OK) {
1333             break;
1334         }
1335         sysClass = (*jniEnv)-&gt;FindClass(jniEnv, &quot;java/lang/System&quot;);
1336         if (sysClass == NULL) {
1337             break;
1338         }
1339         getPropMethod = (*jniEnv)-&gt;GetStaticMethodID(jniEnv, sysClass,
1340             &quot;getProperty&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);
1341         if (getPropMethod == NULL) {
1342             break;
1343         }
1344         readBooleanSysProp(&amp;allowOnlyIPv4, 1, 0,
1345             jniEnv, sysClass, getPropMethod, &quot;java.net.preferIPv4Stack&quot;);
1346         readBooleanSysProp(&amp;preferredAddressFamily, AF_INET6, AF_INET,
1347             jniEnv, sysClass, getPropMethod, &quot;java.net.preferIPv6Addresses&quot;);
1348     } while (0);
1349 
1350     if (jniEnv != NULL &amp;&amp; (*jniEnv)-&gt;ExceptionCheck(jniEnv)) {
1351         (*jniEnv)-&gt;ExceptionClear(jniEnv);
1352     }
1353 
1354 
1355     return JNI_OK;
1356 }
    </pre>
  </body>
</html>
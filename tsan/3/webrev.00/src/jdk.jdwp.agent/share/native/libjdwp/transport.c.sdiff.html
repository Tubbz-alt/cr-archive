<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jdwp.agent/share/native/libjdwp/transport.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="debugLoop.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="util.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdwp.agent/share/native/libjdwp/transport.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32 static jdwpTransportEnv *transport = NULL;
 33 static unsigned transportVersion = JDWPTRANSPORT_VERSION_1_0;
 34 
 35 static jrawMonitorID listenerLock;
 36 static jrawMonitorID sendLock;
 37 
 38 /*
 39  * data structure used for passing transport info from thread to thread
 40  */
 41 typedef struct TransportInfo {
 42     char *name;
 43     jdwpTransportEnv *transport;
 44     char *address;
 45     long timeout;
 46     char *allowed_peers;
 47     unsigned transportVersion;
 48 } TransportInfo;
 49 
 50 static struct jdwpTransportCallback callback = {jvmtiAllocate, jvmtiDeallocate};
 51 









 52 /*
 53  * Print the last transport error
 54  */
 55 static void
 56 printLastError(jdwpTransportEnv *t, jdwpTransportError err)
 57 {
 58     char  *msg;
 59     jbyte *utf8msg;
 60     jdwpTransportError rv;
 61 
 62     msg     = NULL;
 63     utf8msg = NULL;
 64     rv = (*t)-&gt;GetLastError(t, &amp;msg); /* This is a platform encoded string */
 65     if ( msg != NULL ) {
 66         int len;
 67         int maxlen;
 68 
 69         /* Convert this string to UTF8 */
 70         len = (int)strlen(msg);
 71         maxlen = len+len/2+2; /* Should allow for plenty of room */
</pre>
<hr />
<pre>
328      * to run. The debugger may not attach until much later.
329      */
330     if (debugInit_suspendOnInit()) {
331         debugMonitorEnter(listenerLock);
332         while (transport == NULL) {
333             debugMonitorWait(listenerLock);
334         }
335         debugMonitorExit(listenerLock);
336     }
337 }
338 
339 static void JNICALL
340 acceptThread(jvmtiEnv* jvmti_env, JNIEnv* jni_env, void* arg)
341 {
342     TransportInfo *info;
343     jdwpTransportEnv *t;
344     jdwpTransportError rc;
345 
346     LOG_MISC((&quot;Begin accept thread&quot;));
347 
<span class="line-modified">348     info = (TransportInfo*)(void*)arg;</span>
349     t = info-&gt;transport;
350     rc = (*t)-&gt;Accept(t, info-&gt;timeout, 0);
351 
352     /* System property no longer needed */
353     setTransportProperty(jni_env, NULL);


354 
355     if (rc != JDWPTRANSPORT_ERROR_NONE) {
356         /*
357          * If accept fails it probably means a timeout, or another fatal error
358          * We thus exit the VM after stopping the listener.
359          */
360         printLastError(t, rc);
361         (*t)-&gt;StopListening(t);
362         EXIT_ERROR(JVMTI_ERROR_NONE, &quot;could not connect, timeout or fatal error&quot;);
363     } else {
364         (*t)-&gt;StopListening(t);
365         connectionInitiated(t);
366     }
367 
368     LOG_MISC((&quot;End accept thread&quot;));
369 }
370 
371 static void JNICALL
372 attachThread(jvmtiEnv* jvmti_env, JNIEnv* jni_env, void* arg)
373 {
<span class="line-modified">374     TransportInfo *info = (TransportInfo*)(void*)arg;</span>




375 
376     LOG_MISC((&quot;Begin attach thread&quot;));
<span class="line-modified">377     connectionInitiated(info-&gt;transport);</span>
378     LOG_MISC((&quot;End attach thread&quot;));
379 }
380 
381 void
382 transport_initialize(void)
383 {
384     transport = NULL;
385     listenerLock = debugMonitorCreate(&quot;JDWP Transport Listener Monitor&quot;);
386     sendLock = debugMonitorCreate(&quot;JDWP Transport Send Monitor&quot;);
387 }
388 
389 void
390 transport_reset(void)
391 {
392     /*
393      * Reset the transport by closing any listener (will silently fail
394      * with JDWPTRANSPORT_ERROR_ILLEGAL_STATE if not listening), and
395      * closing any connection (will also fail silently if not
396      * connected).
397      *
</pre>
<hr />
<pre>
467         return JDWP_ERROR(OUT_OF_MEMORY);
468     }
469 
470     info-&gt;transport = transport;
471     info-&gt;transportVersion = transportVersion;
472     info-&gt;name = NULL;
473     info-&gt;address = NULL;
474     info-&gt;allowed_peers = NULL;
475 
476     /*
477      * If the transport is already loaded then use it
478      * Note: We&#39;re assuming here that we don&#39;t support multiple
479      * transports - when we do then we need to handle the case
480      * where the transport library only supports a single environment.
481      * That probably means we have a bag a transport environments
482      * to correspond to the transports bag.
483      */
484     if (info-&gt;transport == NULL) {
485         serror = loadTransport(name, info);
486         if (serror != JDWP_ERROR(NONE)) {
<span class="line-modified">487             jvmtiDeallocate(info);</span>
488             return serror;
489         }
490     }
491 
492     // Cache the value
493     trans = info-&gt;transport;
494 
495     if (isServer) {
496         char *retAddress;
497         char *launchCommand;
498         jvmtiError error;
499         int len;
500         char* prop_value;
501 
502         info-&gt;timeout = timeout;
503 
504         info-&gt;name = jvmtiAllocate((int)strlen(name)+1);
505         if (info-&gt;name == NULL) {
506             serror = JDWP_ERROR(OUT_OF_MEMORY);
507             goto handleError;
</pre>
<hr />
<pre>
560             serror = JDWP_ERROR(OUT_OF_MEMORY);
561             goto handleError;
562         }
563         strcpy(prop_value, name);
564         strcat(prop_value, &quot;:&quot;);
565         strcat(prop_value, retAddress);
566         setTransportProperty(getEnv(), prop_value);
567         jvmtiDeallocate(prop_value);
568 
569 
570         (void)strcpy(threadName, &quot;JDWP Transport Listener: &quot;);
571         (void)strcat(threadName, name);
572 
573         func = &amp;acceptThread;
574         error = spawnNewThread(func, (void*)info, threadName);
575         if (error != JVMTI_ERROR_NONE) {
576             serror = map2jdwpError(error);
577             goto handleError;
578         }
579 



580         launchCommand = debugInit_launchOnInit();
581         if (launchCommand != NULL) {
582             serror = launch(launchCommand, name, retAddress);
583             if (serror != JDWP_ERROR(NONE)) {
584                 goto handleError;
585             }
586         } else {
587             if ( ! gdata-&gt;quiet ) {
588                 TTY_MESSAGE((&quot;Listening for transport %s at address: %s&quot;,
589                     name, retAddress));
590             }
591         }
592         return JDWP_ERROR(NONE);
593 
594 handleError:
<span class="line-modified">595         jvmtiDeallocate(info-&gt;name);</span>
<span class="line-removed">596         jvmtiDeallocate(info-&gt;address);</span>
<span class="line-removed">597         jvmtiDeallocate(info-&gt;allowed_peers);</span>
<span class="line-removed">598         jvmtiDeallocate(info);</span>
599     } else {
600         /*
601          * Note that we don&#39;t attempt to do a launch here. Launching
602          * is currently supported only in server mode.
603          */
604 
605         /*
606          * If we&#39;re connecting to another process, there shouldn&#39;t be
607          * any concurrent listens, so its ok if we block here in this
608          * thread, waiting for the attach to finish.
609          */
610          err = (*trans)-&gt;Attach(trans, address, timeout, 0);
611          if (err != JDWPTRANSPORT_ERROR_NONE) {
612              printLastError(trans, err);
613              serror = JDWP_ERROR(TRANSPORT_INIT);
614              /* The name, address and allowed_peers fields in &#39;info&#39;
615               * are not allocated in the non-server case so
616               * they do not need to be freed. */
<span class="line-modified">617              jvmtiDeallocate(info);</span>
618              return serror;
619          }
620 
621          /*
622           * Start the transport loop in a separate thread
623           */
624          (void)strcpy(threadName, &quot;JDWP Transport Listener: &quot;);
625          (void)strcat(threadName, name);
626 
627          func = &amp;attachThread;
628          err = spawnNewThread(func, (void*)info, threadName);
629          serror = map2jdwpError(err);
630     }
631     return serror;
632 }
633 
634 void
635 transport_close(void)
636 {
637     if ( transport != NULL ) {
</pre>
</td>
<td>
<hr />
<pre>
 32 static jdwpTransportEnv *transport = NULL;
 33 static unsigned transportVersion = JDWPTRANSPORT_VERSION_1_0;
 34 
 35 static jrawMonitorID listenerLock;
 36 static jrawMonitorID sendLock;
 37 
 38 /*
 39  * data structure used for passing transport info from thread to thread
 40  */
 41 typedef struct TransportInfo {
 42     char *name;
 43     jdwpTransportEnv *transport;
 44     char *address;
 45     long timeout;
 46     char *allowed_peers;
 47     unsigned transportVersion;
 48 } TransportInfo;
 49 
 50 static struct jdwpTransportCallback callback = {jvmtiAllocate, jvmtiDeallocate};
 51 
<span class="line-added"> 52 static void freeTransportInfo(TransportInfo *info) {</span>
<span class="line-added"> 53     if (info) {</span>
<span class="line-added"> 54         jvmtiDeallocate(info-&gt;name);</span>
<span class="line-added"> 55         jvmtiDeallocate(info-&gt;address);</span>
<span class="line-added"> 56         jvmtiDeallocate(info-&gt;allowed_peers);</span>
<span class="line-added"> 57         jvmtiDeallocate(info);</span>
<span class="line-added"> 58     }</span>
<span class="line-added"> 59 }</span>
<span class="line-added"> 60 </span>
 61 /*
 62  * Print the last transport error
 63  */
 64 static void
 65 printLastError(jdwpTransportEnv *t, jdwpTransportError err)
 66 {
 67     char  *msg;
 68     jbyte *utf8msg;
 69     jdwpTransportError rv;
 70 
 71     msg     = NULL;
 72     utf8msg = NULL;
 73     rv = (*t)-&gt;GetLastError(t, &amp;msg); /* This is a platform encoded string */
 74     if ( msg != NULL ) {
 75         int len;
 76         int maxlen;
 77 
 78         /* Convert this string to UTF8 */
 79         len = (int)strlen(msg);
 80         maxlen = len+len/2+2; /* Should allow for plenty of room */
</pre>
<hr />
<pre>
337      * to run. The debugger may not attach until much later.
338      */
339     if (debugInit_suspendOnInit()) {
340         debugMonitorEnter(listenerLock);
341         while (transport == NULL) {
342             debugMonitorWait(listenerLock);
343         }
344         debugMonitorExit(listenerLock);
345     }
346 }
347 
348 static void JNICALL
349 acceptThread(jvmtiEnv* jvmti_env, JNIEnv* jni_env, void* arg)
350 {
351     TransportInfo *info;
352     jdwpTransportEnv *t;
353     jdwpTransportError rc;
354 
355     LOG_MISC((&quot;Begin accept thread&quot;));
356 
<span class="line-modified">357     info = (TransportInfo*)arg;</span>
358     t = info-&gt;transport;
359     rc = (*t)-&gt;Accept(t, info-&gt;timeout, 0);
360 
361     /* System property no longer needed */
362     setTransportProperty(jni_env, NULL);
<span class="line-added">363     /* TransportInfo data no longer needed */</span>
<span class="line-added">364     freeTransportInfo(info);</span>
365 
366     if (rc != JDWPTRANSPORT_ERROR_NONE) {
367         /*
368          * If accept fails it probably means a timeout, or another fatal error
369          * We thus exit the VM after stopping the listener.
370          */
371         printLastError(t, rc);
372         (*t)-&gt;StopListening(t);
373         EXIT_ERROR(JVMTI_ERROR_NONE, &quot;could not connect, timeout or fatal error&quot;);
374     } else {
375         (*t)-&gt;StopListening(t);
376         connectionInitiated(t);
377     }
378 
379     LOG_MISC((&quot;End accept thread&quot;));
380 }
381 
382 static void JNICALL
383 attachThread(jvmtiEnv* jvmti_env, JNIEnv* jni_env, void* arg)
384 {
<span class="line-modified">385     TransportInfo *info = (TransportInfo*)arg;</span>
<span class="line-added">386     jdwpTransportEnv *t = info-&gt;transport;</span>
<span class="line-added">387 </span>
<span class="line-added">388     /* TransportInfo data no longer needed */</span>
<span class="line-added">389     freeTransportInfo(info);</span>
390 
391     LOG_MISC((&quot;Begin attach thread&quot;));
<span class="line-modified">392     connectionInitiated(t);</span>
393     LOG_MISC((&quot;End attach thread&quot;));
394 }
395 
396 void
397 transport_initialize(void)
398 {
399     transport = NULL;
400     listenerLock = debugMonitorCreate(&quot;JDWP Transport Listener Monitor&quot;);
401     sendLock = debugMonitorCreate(&quot;JDWP Transport Send Monitor&quot;);
402 }
403 
404 void
405 transport_reset(void)
406 {
407     /*
408      * Reset the transport by closing any listener (will silently fail
409      * with JDWPTRANSPORT_ERROR_ILLEGAL_STATE if not listening), and
410      * closing any connection (will also fail silently if not
411      * connected).
412      *
</pre>
<hr />
<pre>
482         return JDWP_ERROR(OUT_OF_MEMORY);
483     }
484 
485     info-&gt;transport = transport;
486     info-&gt;transportVersion = transportVersion;
487     info-&gt;name = NULL;
488     info-&gt;address = NULL;
489     info-&gt;allowed_peers = NULL;
490 
491     /*
492      * If the transport is already loaded then use it
493      * Note: We&#39;re assuming here that we don&#39;t support multiple
494      * transports - when we do then we need to handle the case
495      * where the transport library only supports a single environment.
496      * That probably means we have a bag a transport environments
497      * to correspond to the transports bag.
498      */
499     if (info-&gt;transport == NULL) {
500         serror = loadTransport(name, info);
501         if (serror != JDWP_ERROR(NONE)) {
<span class="line-modified">502             freeTransportInfo(info);</span>
503             return serror;
504         }
505     }
506 
507     // Cache the value
508     trans = info-&gt;transport;
509 
510     if (isServer) {
511         char *retAddress;
512         char *launchCommand;
513         jvmtiError error;
514         int len;
515         char* prop_value;
516 
517         info-&gt;timeout = timeout;
518 
519         info-&gt;name = jvmtiAllocate((int)strlen(name)+1);
520         if (info-&gt;name == NULL) {
521             serror = JDWP_ERROR(OUT_OF_MEMORY);
522             goto handleError;
</pre>
<hr />
<pre>
575             serror = JDWP_ERROR(OUT_OF_MEMORY);
576             goto handleError;
577         }
578         strcpy(prop_value, name);
579         strcat(prop_value, &quot;:&quot;);
580         strcat(prop_value, retAddress);
581         setTransportProperty(getEnv(), prop_value);
582         jvmtiDeallocate(prop_value);
583 
584 
585         (void)strcpy(threadName, &quot;JDWP Transport Listener: &quot;);
586         (void)strcat(threadName, name);
587 
588         func = &amp;acceptThread;
589         error = spawnNewThread(func, (void*)info, threadName);
590         if (error != JVMTI_ERROR_NONE) {
591             serror = map2jdwpError(error);
592             goto handleError;
593         }
594 
<span class="line-added">595         /* reset info - it will be deallocated by acceptThread */</span>
<span class="line-added">596         info = NULL;</span>
<span class="line-added">597 </span>
598         launchCommand = debugInit_launchOnInit();
599         if (launchCommand != NULL) {
600             serror = launch(launchCommand, name, retAddress);
601             if (serror != JDWP_ERROR(NONE)) {
602                 goto handleError;
603             }
604         } else {
605             if ( ! gdata-&gt;quiet ) {
606                 TTY_MESSAGE((&quot;Listening for transport %s at address: %s&quot;,
607                     name, retAddress));
608             }
609         }
610         return JDWP_ERROR(NONE);
611 
612 handleError:
<span class="line-modified">613         freeTransportInfo(info);</span>



614     } else {
615         /*
616          * Note that we don&#39;t attempt to do a launch here. Launching
617          * is currently supported only in server mode.
618          */
619 
620         /*
621          * If we&#39;re connecting to another process, there shouldn&#39;t be
622          * any concurrent listens, so its ok if we block here in this
623          * thread, waiting for the attach to finish.
624          */
625          err = (*trans)-&gt;Attach(trans, address, timeout, 0);
626          if (err != JDWPTRANSPORT_ERROR_NONE) {
627              printLastError(trans, err);
628              serror = JDWP_ERROR(TRANSPORT_INIT);
629              /* The name, address and allowed_peers fields in &#39;info&#39;
630               * are not allocated in the non-server case so
631               * they do not need to be freed. */
<span class="line-modified">632              freeTransportInfo(info);</span>
633              return serror;
634          }
635 
636          /*
637           * Start the transport loop in a separate thread
638           */
639          (void)strcpy(threadName, &quot;JDWP Transport Listener: &quot;);
640          (void)strcat(threadName, name);
641 
642          func = &amp;attachThread;
643          err = spawnNewThread(func, (void*)info, threadName);
644          serror = map2jdwpError(err);
645     }
646     return serror;
647 }
648 
649 void
650 transport_close(void)
651 {
652     if ( transport != NULL ) {
</pre>
</td>
</tr>
</table>
<center><a href="debugLoop.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="util.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdwp.agent/share/native/libjdwp/debugInit.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;ctype.h&gt;
  27 
  28 #include &quot;util.h&quot;
  29 #include &quot;commonRef.h&quot;
  30 #include &quot;debugDispatch.h&quot;
  31 #include &quot;eventHandler.h&quot;
  32 #include &quot;eventHelper.h&quot;
  33 #include &quot;threadControl.h&quot;
  34 #include &quot;stepControl.h&quot;
  35 #include &quot;transport.h&quot;
  36 #include &quot;classTrack.h&quot;
  37 #include &quot;debugLoop.h&quot;
  38 #include &quot;bag.h&quot;
  39 #include &quot;invoker.h&quot;
  40 #include &quot;sys.h&quot;
  41 
  42 /* How the options get to OnLoad: */
  43 #define XDEBUG &quot;-Xdebug&quot;
  44 #define XRUN &quot;-Xrunjdwp&quot;
  45 #define AGENTLIB &quot;-agentlib:jdwp&quot;
  46 
  47 /* Debug version defaults */
  48 #ifdef DEBUG
  49     #define DEFAULT_ASSERT_ON           JNI_TRUE
  50     #define DEFAULT_ASSERT_FATAL        JNI_TRUE
  51     #define DEFAULT_LOGFILE             &quot;jdwp.log&quot;
  52 #else
  53     #define DEFAULT_ASSERT_ON           JNI_FALSE
  54     #define DEFAULT_ASSERT_FATAL        JNI_FALSE
  55     #define DEFAULT_LOGFILE             NULL
  56 #endif
  57 
  58 static jboolean vmInitialized;
  59 static jrawMonitorID initMonitor;
  60 static jboolean initComplete;
  61 static jbyte currentSessionID;
  62 
  63 /*
  64  * Options set through the OnLoad options string. All of these values
  65  * are set once at VM startup and never reset.
  66  */
  67 static jboolean isServer = JNI_FALSE;     /* Listens for connecting debuggers? */
  68 static jboolean isStrict = JNI_FALSE;     /* Unused */
  69 static jboolean useStandardAlloc = JNI_FALSE;  /* Use standard malloc/free? */
  70 static struct bag *transports;            /* of TransportSpec */
  71 
  72 static jboolean initOnStartup = JNI_TRUE;   /* init immediately */
  73 static char *initOnException = NULL;        /* init when this exception thrown */
  74 static jboolean initOnUncaught = JNI_FALSE; /* init when uncaught exc thrown */
  75 
  76 static char *launchOnInit = NULL;           /* launch this app during init */
  77 static jboolean suspendOnInit = JNI_TRUE;   /* suspend all app threads after init */
  78 static jboolean dopause = JNI_FALSE;        /* pause for debugger attach */
  79 static jboolean docoredump = JNI_FALSE;     /* core dump on exit */
  80 static char *logfile = NULL;                /* Name of logfile (if logging) */
  81 static unsigned logflags = 0;               /* Log flags */
  82 
  83 static char *names;                         /* strings derived from OnLoad options */
  84 
  85 static jboolean allowStartViaJcmd = JNI_FALSE;  /* if true we allow the debugging to be started via a jcmd */
  86 static jboolean startedViaJcmd = JNI_FALSE;     /* if false, we have not yet started debugging via a jcmd */
  87 
  88 /*
  89  * Elements of the transports bag
  90  */
  91 typedef struct TransportSpec {
  92     char *name;
  93     char *address;
  94     long timeout;
  95     char *allow;
  96 } TransportSpec;
  97 
  98 /*
  99  * Forward Refs
 100  */
 101 static void JNICALL cbEarlyVMInit(jvmtiEnv*, JNIEnv *, jthread);
 102 static void JNICALL cbEarlyVMDeath(jvmtiEnv*, JNIEnv *);
 103 static void JNICALL cbEarlyException(jvmtiEnv*, JNIEnv *,
 104             jthread, jmethodID, jlocation, jobject, jmethodID, jlocation);
 105 
 106 static void initialize(JNIEnv *env, jthread thread, EventIndex triggering_ei);
 107 static jboolean parseOptions(char *str);
 108 
 109 /*
 110  * Phase 1: Initial load.
 111  *
 112  * OnLoad is called by the VM immediately after the back-end
 113  * library is loaded. We can do very little in this function since
 114  * the VM has not completed initialization. So, we parse the JDWP
 115  * options and set up a simple initial event callbacks for JVMTI events.
 116  * When a triggering event occurs, that callback will begin debugger initialization.
 117  */
 118 
 119 /* Get a static area to hold the Global Data */
 120 static BackendGlobalData *
 121 get_gdata(void)
 122 {
 123     static BackendGlobalData s;
 124     (void)memset(&amp;s, 0, sizeof(BackendGlobalData));
 125     return &amp;s;
 126 }
 127 
 128 static jvmtiError
 129 set_event_notification(jvmtiEventMode mode, EventIndex ei)
 130 {
 131     jvmtiError error;
 132     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,SetEventNotificationMode)
 133                 (gdata-&gt;jvmti, mode, eventIndex2jvmti(ei), NULL);
 134     if (error != JVMTI_ERROR_NONE) {
 135         ERROR_MESSAGE((&quot;JDWP unable to configure initial JVMTI event %s: %s(%d)&quot;,
 136                     eventText(ei), jvmtiErrorText(error), error));
 137     }
 138     return error;
 139 }
 140 
 141 typedef struct {
 142     int major;
 143     int minor;
 144 } version_type;
 145 
 146 typedef struct {
 147     version_type runtime;
 148     version_type compiletime;
 149 } compatible_versions_type;
 150 
 151 /*
 152  * List of explicitly compatible JVMTI versions, specified as
 153  * { runtime version, compile-time version } pairs. -1 is a wildcard.
 154  */
 155 static int nof_compatible_versions = 3;
 156 static compatible_versions_type compatible_versions_list[] = {
 157     /*
 158      * FIXUP: Allow version 0 to be compatible with anything
 159      * Special check for FCS of 1.0.
 160      */
 161     { {  0, -1 }, { -1, -1 } },
 162     { { -1, -1 }, {  0, -1 } },
 163     /*
 164      * 1.2 is runtime compatible with 1.1 -- just make sure to check the
 165      * version before using any new 1.2 features
 166      */
 167     { {  1,  1 }, {  1,  2 } }
 168 };
 169 
 170 
 171 /* Logic to determine JVMTI version compatibility */
 172 static jboolean
 173 compatible_versions(jint major_runtime,     jint minor_runtime,
 174                     jint major_compiletime, jint minor_compiletime)
 175 {
 176     /*
 177      * First check to see if versions are explicitly compatible via the
 178      * list specified above.
 179      */
 180     int i;
 181     for (i = 0; i &lt; nof_compatible_versions; ++i) {
 182         version_type runtime = compatible_versions_list[i].runtime;
 183         version_type comptime = compatible_versions_list[i].compiletime;
 184 
 185         if ((major_runtime     == runtime.major  || runtime.major  == -1) &amp;&amp;
 186             (minor_runtime     == runtime.minor  || runtime.minor  == -1) &amp;&amp;
 187             (major_compiletime == comptime.major || comptime.major == -1) &amp;&amp;
 188             (minor_compiletime == comptime.minor || comptime.minor == -1)) {
 189             return JNI_TRUE;
 190         }
 191     }
 192 
 193     return major_runtime == major_compiletime &amp;&amp;
 194            minor_runtime &gt;= minor_compiletime;
 195 }
 196 
 197 /* OnLoad startup:
 198  *   Returning JNI_ERR will cause the java_g VM to core dump, be careful.
 199  */
 200 JNIEXPORT jint JNICALL
 201 DEF_Agent_OnLoad(JavaVM *vm, char *options, void *reserved)
 202 {
 203     jvmtiError error;
 204     jvmtiCapabilities needed_capabilities;
 205     jvmtiCapabilities potential_capabilities;
 206     jint              jvmtiCompileTimeMajorVersion;
 207     jint              jvmtiCompileTimeMinorVersion;
 208     jint              jvmtiCompileTimeMicroVersion;
 209 
 210     /* See if it&#39;s already loaded */
 211     if ( gdata!=NULL &amp;&amp; gdata-&gt;isLoaded==JNI_TRUE ) {
 212         ERROR_MESSAGE((&quot;Cannot load this JVM TI agent twice, check your java command line for duplicate jdwp options.&quot;));
 213         return JNI_ERR;
 214     }
 215 
 216     /* If gdata is defined and the VM died, why are we here? */
 217     if ( gdata!=NULL &amp;&amp; gdata-&gt;vmDead ) {
 218         ERROR_MESSAGE((&quot;JDWP unable to load, VM died&quot;));
 219         return JNI_ERR;
 220     }
 221 
 222     /* Get global data area */
 223     gdata = get_gdata();
 224     if (gdata == NULL) {
 225         ERROR_MESSAGE((&quot;JDWP unable to allocate memory&quot;));
 226         return JNI_ERR;
 227     }
 228     gdata-&gt;isLoaded = JNI_TRUE;
 229 
 230     /* Start filling in gdata */
 231     gdata-&gt;jvm = vm;
 232     vmInitialized = JNI_FALSE;
 233     gdata-&gt;vmDead = JNI_FALSE;
 234 
 235     /* Get the JVMTI Env, IMPORTANT: Do this first! For jvmtiAllocate(). */
 236     error = JVM_FUNC_PTR(vm,GetEnv)
 237                 (vm, (void **)&amp;(gdata-&gt;jvmti), JVMTI_VERSION_1);
 238     if (error != JNI_OK) {
 239         ERROR_MESSAGE((&quot;JDWP unable to access JVMTI Version 1 (0x%x),&quot;
 240                          &quot; is your J2SE a 1.5 or newer version?&quot;
 241                          &quot; JNIEnv&#39;s GetEnv() returned %d&quot;,
 242                          JVMTI_VERSION_1, error));
 243         forceExit(1); /* Kill entire process, no core dump */
 244     }
 245 
 246     /* Check to make sure the version of jvmti.h we compiled with
 247      *      matches the runtime version we are using.
 248      */
 249     jvmtiCompileTimeMajorVersion  = ( JVMTI_VERSION &amp; JVMTI_VERSION_MASK_MAJOR )
 250                                         &gt;&gt; JVMTI_VERSION_SHIFT_MAJOR;
 251     jvmtiCompileTimeMinorVersion  = ( JVMTI_VERSION &amp; JVMTI_VERSION_MASK_MINOR )
 252                                         &gt;&gt; JVMTI_VERSION_SHIFT_MINOR;
 253     jvmtiCompileTimeMicroVersion  = ( JVMTI_VERSION &amp; JVMTI_VERSION_MASK_MICRO )
 254                                         &gt;&gt; JVMTI_VERSION_SHIFT_MICRO;
 255 
 256     /* Check for compatibility */
 257     if ( !compatible_versions(jvmtiMajorVersion(), jvmtiMinorVersion(),
 258                 jvmtiCompileTimeMajorVersion, jvmtiCompileTimeMinorVersion) ) {
 259 
 260         ERROR_MESSAGE((&quot;This jdwp native library will not work with this VM&#39;s &quot;
 261                        &quot;version of JVMTI (%d.%d.%d), it needs JVMTI %d.%d[.%d].&quot;,
 262                        jvmtiMajorVersion(),
 263                        jvmtiMinorVersion(),
 264                        jvmtiMicroVersion(),
 265                        jvmtiCompileTimeMajorVersion,
 266                        jvmtiCompileTimeMinorVersion,
 267                        jvmtiCompileTimeMicroVersion));
 268 
 269         /* Do not let VM get a fatal error, we don&#39;t want a core dump here. */
 270         forceExit(1); /* Kill entire process, no core dump wanted */
 271     }
 272 
 273     /* Parse input options */
 274     if (!parseOptions(options)) {
 275         /* No message necessary, should have been printed out already */
 276         /* Do not let VM get a fatal error, we don&#39;t want a core dump here. */
 277         forceExit(1); /* Kill entire process, no core dump wanted */
 278     }
 279 
 280     LOG_MISC((&quot;Onload: %s&quot;, options));
 281 
 282     /* Get potential capabilities */
 283     (void)memset(&amp;potential_capabilities,0,sizeof(potential_capabilities));
 284     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetPotentialCapabilities)
 285                 (gdata-&gt;jvmti, &amp;potential_capabilities);
 286     if (error != JVMTI_ERROR_NONE) {
 287         ERROR_MESSAGE((&quot;JDWP unable to get potential JVMTI capabilities: %s(%d)&quot;,
 288                         jvmtiErrorText(error), error));
 289         return JNI_ERR;
 290     }
 291 
 292     /* Fill in ones that we must have */
 293     (void)memset(&amp;needed_capabilities,0,sizeof(needed_capabilities));
 294     needed_capabilities.can_access_local_variables              = 1;
 295     needed_capabilities.can_generate_single_step_events         = 1;
 296     needed_capabilities.can_generate_exception_events           = 1;
 297     needed_capabilities.can_generate_frame_pop_events           = 1;
 298     needed_capabilities.can_generate_breakpoint_events          = 1;
 299     needed_capabilities.can_suspend                             = 1;
 300     needed_capabilities.can_generate_method_entry_events        = 1;
 301     needed_capabilities.can_generate_method_exit_events         = 1;
 302     needed_capabilities.can_generate_garbage_collection_events  = 1;
 303     needed_capabilities.can_maintain_original_method_order      = 1;
 304     needed_capabilities.can_generate_monitor_events             = 1;
 305     needed_capabilities.can_tag_objects                         = 1;
 306 
 307     /* And what potential ones that would be nice to have */
 308     needed_capabilities.can_force_early_return
 309                 = potential_capabilities.can_force_early_return;
 310     needed_capabilities.can_generate_field_modification_events
 311                 = potential_capabilities.can_generate_field_modification_events;
 312     needed_capabilities.can_generate_field_access_events
 313                 = potential_capabilities.can_generate_field_access_events;
 314     needed_capabilities.can_get_bytecodes
 315                 = potential_capabilities.can_get_bytecodes;
 316     needed_capabilities.can_get_synthetic_attribute
 317                 = potential_capabilities.can_get_synthetic_attribute;
 318     needed_capabilities.can_get_owned_monitor_info
 319                 = potential_capabilities.can_get_owned_monitor_info;
 320     needed_capabilities.can_get_current_contended_monitor
 321                 = potential_capabilities.can_get_current_contended_monitor;
 322     needed_capabilities.can_get_monitor_info
 323                 = potential_capabilities.can_get_monitor_info;
 324     needed_capabilities.can_pop_frame
 325                 = potential_capabilities.can_pop_frame;
 326     needed_capabilities.can_redefine_classes
 327                 = potential_capabilities.can_redefine_classes;
 328     needed_capabilities.can_redefine_any_class
 329                 = potential_capabilities.can_redefine_any_class;
 330     needed_capabilities.can_get_owned_monitor_stack_depth_info
 331         = potential_capabilities.can_get_owned_monitor_stack_depth_info;
 332     needed_capabilities.can_get_constant_pool
 333                 = potential_capabilities.can_get_constant_pool;
 334     {
 335         needed_capabilities.can_get_source_debug_extension      = 1;
 336         needed_capabilities.can_get_source_file_name            = 1;
 337         needed_capabilities.can_get_line_numbers                = 1;
 338         needed_capabilities.can_signal_thread
 339                 = potential_capabilities.can_signal_thread;
 340     }
 341 
 342     /* Add the capabilities */
 343     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,AddCapabilities)
 344                 (gdata-&gt;jvmti, &amp;needed_capabilities);
 345     if (error != JVMTI_ERROR_NONE) {
 346         ERROR_MESSAGE((&quot;JDWP unable to get necessary JVMTI capabilities.&quot;));
 347         forceExit(1); /* Kill entire process, no core dump wanted */
 348     }
 349 
 350     /* Initialize event number mapping tables */
 351     eventIndexInit();
 352 
 353     /* Set the initial JVMTI event notifications */
 354     error = set_event_notification(JVMTI_ENABLE, EI_VM_DEATH);
 355     if (error != JVMTI_ERROR_NONE) {
 356         return JNI_ERR;
 357     }
 358     error = set_event_notification(JVMTI_ENABLE, EI_VM_INIT);
 359     if (error != JVMTI_ERROR_NONE) {
 360         return JNI_ERR;
 361     }
 362     if (initOnUncaught || (initOnException != NULL)) {
 363         error = set_event_notification(JVMTI_ENABLE, EI_EXCEPTION);
 364         if (error != JVMTI_ERROR_NONE) {
 365             return JNI_ERR;
 366         }
 367     }
 368 
 369     /* Set callbacks just for 3 functions */
 370     (void)memset(&amp;(gdata-&gt;callbacks),0,sizeof(gdata-&gt;callbacks));
 371     gdata-&gt;callbacks.VMInit             = &amp;cbEarlyVMInit;
 372     gdata-&gt;callbacks.VMDeath            = &amp;cbEarlyVMDeath;
 373     gdata-&gt;callbacks.Exception  = &amp;cbEarlyException;
 374     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,SetEventCallbacks)
 375                 (gdata-&gt;jvmti, &amp;(gdata-&gt;callbacks), sizeof(gdata-&gt;callbacks));
 376     if (error != JVMTI_ERROR_NONE) {
 377         ERROR_MESSAGE((&quot;JDWP unable to set JVMTI event callbacks: %s(%d)&quot;,
 378                         jvmtiErrorText(error), error));
 379         return JNI_ERR;
 380     }
 381 
 382     LOG_MISC((&quot;OnLoad: DONE&quot;));
 383     return JNI_OK;
 384 }
 385 
 386 JNIEXPORT void JNICALL
 387 DEF_Agent_OnUnload(JavaVM *vm)
 388 {
 389 
 390     gdata-&gt;isLoaded = JNI_FALSE;
 391 
 392     /* Cleanup, but make sure VM is alive before using JNI, and
 393      *   make sure JVMTI environment is ok before deallocating
 394      *   memory allocated through JVMTI, which all of it is.
 395      */
 396 
 397     /*
 398      * Close transport before exit
 399      */
 400     if (transport_is_open()) {
 401         transport_close();
 402     }
 403 }
 404 
 405 /*
 406  * Phase 2: Initial events. Phase 2 consists of waiting for the
 407  * event that triggers full initialization. Under normal circumstances
 408  * (initOnStartup == TRUE) this is the JVMTI_EVENT_VM_INIT event.
 409  * Otherwise, we delay initialization until the app throws a
 410  * particular exception. The triggering event invokes
 411  * the bulk of the initialization, including creation of threads and
 412  * monitors, transport setup, and installation of a new event callback which
 413  * handles the complete set of events.
 414  *
 415  * Since the triggering event comes in on an application thread, some of the
 416  * initialization is difficult to do here. Specifically, this thread along
 417  * with all other app threads may need to be suspended until a debugger
 418  * connects. These kinds of tasks are left to the third phase which is
 419  * invoked by one of the spawned debugger threads, the event handler.
 420  */
 421 
 422 /*
 423  * Wait for a triggering event; then kick off debugger
 424  * initialization. A different event callback will be installed by
 425  * debugger initialization, and this function will not be called
 426  * again.
 427  */
 428 
 429     /*
 430      * TO DO: Decide whether we need to protect this code with
 431      * a lock. It might be too early to create a monitor safely (?).
 432      */
 433 
 434 static void JNICALL
 435 cbEarlyVMInit(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread)
 436 {
 437     LOG_CB((&quot;cbEarlyVMInit&quot;));
 438     if ( gdata-&gt;vmDead ) {
 439         EXIT_ERROR(AGENT_ERROR_INTERNAL,&quot;VM dead at VM_INIT time&quot;);
 440     }
 441     if (initOnStartup)
 442         initialize(env, thread, EI_VM_INIT);
 443     vmInitialized = JNI_TRUE;
 444     LOG_MISC((&quot;END cbEarlyVMInit&quot;));
 445 }
 446 
 447 static void
 448 disposeEnvironment(jvmtiEnv *jvmti_env)
 449 {
 450     jvmtiError error;
 451 
 452     error = JVMTI_FUNC_PTR(jvmti_env,DisposeEnvironment)(jvmti_env);
 453     if ( error == JVMTI_ERROR_MUST_POSSESS_CAPABILITY )
 454         error = JVMTI_ERROR_NONE;  /* Hack!  FIXUP when JVMTI has disposeEnv */
 455     /* What should error return say? */
 456     if (error != JVMTI_ERROR_NONE) {
 457         ERROR_MESSAGE((&quot;JDWP unable to dispose of JVMTI environment: %s(%d)&quot;,
 458                         jvmtiErrorText(error), error));
 459     }
 460     gdata-&gt;jvmti = NULL;
 461 }
 462 
 463 static void JNICALL
 464 cbEarlyVMDeath(jvmtiEnv *jvmti_env, JNIEnv *env)
 465 {
 466     LOG_CB((&quot;cbEarlyVMDeath&quot;));
 467     if ( gdata-&gt;vmDead ) {
 468         EXIT_ERROR(AGENT_ERROR_INTERNAL,&quot;VM died more than once&quot;);
 469     }
 470     disposeEnvironment(jvmti_env);
 471     gdata-&gt;jvmti = NULL;
 472     gdata-&gt;jvm = NULL;
 473     gdata-&gt;vmDead = JNI_TRUE;
 474     LOG_MISC((&quot;END cbEarlyVMDeath&quot;));
 475 }
 476 
 477 static void JNICALL
 478 cbEarlyException(jvmtiEnv *jvmti_env, JNIEnv *env,
 479         jthread thread, jmethodID method, jlocation location,
 480         jobject exception,
 481         jmethodID catch_method, jlocation catch_location)
 482 {
 483     jvmtiError error;
 484     jthrowable currentException;
 485 
 486     LOG_CB((&quot;cbEarlyException: thread=%p&quot;, thread));
 487 
 488     if ( gdata-&gt;vmDead ) {
 489         EXIT_ERROR(AGENT_ERROR_INTERNAL,&quot;VM dead at initial Exception event&quot;);
 490     }
 491     if (!vmInitialized)  {
 492         LOG_MISC((&quot;VM is not initialized yet&quot;));
 493         return;
 494     }
 495 
 496     /*
 497      * We want to preserve any current exception that might get wiped
 498      * out during event handling (e.g. JNI calls). We have to rely on
 499      * space for the local reference on the current frame because
 500      * doing a PushLocalFrame here might itself generate an exception.
 501      */
 502 
 503     currentException = JNI_FUNC_PTR(env,ExceptionOccurred)(env);
 504     JNI_FUNC_PTR(env,ExceptionClear)(env);
 505 
 506     if (initOnUncaught &amp;&amp; catch_method == NULL) {
 507 
 508         LOG_MISC((&quot;Initializing on uncaught exception&quot;));
 509         initialize(env, thread, EI_EXCEPTION);
 510 
 511     } else if (initOnException != NULL) {
 512 
 513         jclass clazz;
 514 
 515         /* Get class of exception thrown */
 516         clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, exception);
 517         if ( clazz != NULL ) {
 518             char *signature = NULL;
 519             /* initing on throw, check */
 520             error = classSignature(clazz, &amp;signature, NULL);
 521             LOG_MISC((&quot;Checking specific exception: looking for %s, got %s&quot;,
 522                         initOnException, signature));
 523             if ( (error==JVMTI_ERROR_NONE) &amp;&amp;
 524                 (strcmp(signature, initOnException) == 0)) {
 525                 LOG_MISC((&quot;Initializing on specific exception&quot;));
 526                 initialize(env, thread, EI_EXCEPTION);
 527             } else {
 528                 error = AGENT_ERROR_INTERNAL; /* Just to cause restore */
 529             }
 530             if ( signature != NULL ) {
 531                 jvmtiDeallocate(signature);
 532             }
 533         } else {
 534             error = AGENT_ERROR_INTERNAL; /* Just to cause restore */
 535         }
 536 
 537         /* If initialize didn&#39;t happen, we need to restore things */
 538         if ( error != JVMTI_ERROR_NONE ) {
 539             /*
 540              * Restore exception state from before callback call
 541              */
 542             LOG_MISC((&quot;No initialization, didn&#39;t find right exception&quot;));
 543             if (currentException != NULL) {
 544                 JNI_FUNC_PTR(env,Throw)(env, currentException);
 545             } else {
 546                 JNI_FUNC_PTR(env,ExceptionClear)(env);
 547             }
 548         }
 549 
 550     }
 551 
 552     LOG_MISC((&quot;END cbEarlyException&quot;));
 553 
 554 }
 555 
 556 typedef struct EnumerateArg {
 557     jboolean isServer;
 558     jdwpError error;
 559     jint startCount;
 560 } EnumerateArg;
 561 
 562 static jboolean
 563 startTransport(void *item, void *arg)
 564 {
 565     TransportSpec *transport = item;
 566     EnumerateArg *enumArg = arg;
 567     jdwpError serror;
 568 
 569     LOG_MISC((&quot;Begin startTransport&quot;));
 570     serror = transport_startTransport(enumArg-&gt;isServer, transport-&gt;name,
 571                                       transport-&gt;address, transport-&gt;timeout,
 572                                       transport-&gt;allow);
 573     if (serror != JDWP_ERROR(NONE)) {
 574         ERROR_MESSAGE((&quot;JDWP Transport %s failed to initialize, %s(%d)&quot;,
 575                 transport-&gt;name, jdwpErrorText(serror), serror));
 576         enumArg-&gt;error = serror;
 577     } else {
 578         /* (Don&#39;t overwrite any previous error) */
 579 
 580         enumArg-&gt;startCount++;
 581     }
 582 
 583     LOG_MISC((&quot;End startTransport&quot;));
 584 
 585     return JNI_TRUE;   /* Always continue, even if there was an error */
 586 }
 587 
 588 static void
 589 signalInitComplete(void)
 590 {
 591     /*
 592      * Initialization is complete
 593      */
 594     LOG_MISC((&quot;signal initialization complete&quot;));
 595     debugMonitorEnter(initMonitor);
 596     initComplete = JNI_TRUE;
 597     debugMonitorNotifyAll(initMonitor);
 598     debugMonitorExit(initMonitor);
 599 }
 600 
 601 /*
 602  * Determine if  initialization is complete.
 603  */
 604 jboolean
 605 debugInit_isInitComplete(void)
 606 {
 607     return initComplete;
 608 }
 609 
 610 /*
 611  * Wait for all initialization to complete.
 612  */
 613 void
 614 debugInit_waitInitComplete(void)
 615 {
 616     debugMonitorEnter(initMonitor);
 617     while (!initComplete) {
 618         debugMonitorWait(initMonitor);
 619     }
 620     debugMonitorExit(initMonitor);
 621 }
 622 
 623 /* All process exit() calls come from here */
 624 void
 625 forceExit(int exit_code)
 626 {
 627     /* make sure the transport is closed down before we exit() */
 628     transport_close();
 629     exit(exit_code);
 630 }
 631 
 632 /* All JVM fatal error exits lead here (e.g. we need to kill the VM). */
 633 static void
 634 jniFatalError(JNIEnv *env, const char *msg, jvmtiError error, int exit_code)
 635 {
 636     JavaVM *vm;
 637     char buf[512];
 638 
 639     gdata-&gt;vmDead = JNI_TRUE;
 640     if ( msg==NULL )
 641         msg = &quot;UNKNOWN REASON&quot;;
 642     vm = gdata-&gt;jvm;
 643     if ( env==NULL &amp;&amp; vm!=NULL ) {
 644         jint rc = (*((*vm)-&gt;GetEnv))(vm, (void **)&amp;env, JNI_VERSION_1_2);
 645         if (rc != JNI_OK ) {
 646             env = NULL;
 647         }
 648     }
 649     if ( error != JVMTI_ERROR_NONE ) {
 650         (void)snprintf(buf, sizeof(buf), &quot;JDWP %s, jvmtiError=%s(%d)&quot;,
 651                     msg, jvmtiErrorText(error), error);
 652     } else {
 653         (void)snprintf(buf, sizeof(buf), &quot;JDWP %s&quot;, msg);
 654     }
 655     if (env != NULL) {
 656         (*((*env)-&gt;FatalError))(env, buf);
 657     } else {
 658         /* Should rarely ever reach here, means VM is really dead */
 659         print_message(stderr, &quot;ERROR: JDWP: &quot;, &quot;\n&quot;,
 660                 &quot;Can&#39;t call JNI FatalError(NULL, \&quot;%s\&quot;)&quot;, buf);
 661     }
 662     forceExit(exit_code);
 663 }
 664 
 665 /*
 666  * Initialize debugger back end modules
 667  */
 668 static void
 669 initialize(JNIEnv *env, jthread thread, EventIndex triggering_ei)
 670 {
 671     jvmtiError error;
 672     EnumerateArg arg;
 673     jbyte suspendPolicy;
 674 
 675     LOG_MISC((&quot;Begin initialize()&quot;));
 676     currentSessionID = 0;
 677     initComplete = JNI_FALSE;
 678 
 679     if ( gdata-&gt;vmDead ) {
 680         EXIT_ERROR(AGENT_ERROR_INTERNAL,&quot;VM dead at initialize() time&quot;);
 681     }
 682 
 683     /* Turn off the initial JVMTI event notifications */
 684     error = set_event_notification(JVMTI_DISABLE, EI_EXCEPTION);
 685     if (error != JVMTI_ERROR_NONE) {
 686         EXIT_ERROR(error, &quot;unable to disable JVMTI event notification&quot;);
 687     }
 688     error = set_event_notification(JVMTI_DISABLE, EI_VM_INIT);
 689     if (error != JVMTI_ERROR_NONE) {
 690         EXIT_ERROR(error, &quot;unable to disable JVMTI event notification&quot;);
 691     }
 692     error = set_event_notification(JVMTI_DISABLE, EI_VM_DEATH);
 693     if (error != JVMTI_ERROR_NONE) {
 694         EXIT_ERROR(error, &quot;unable to disable JVMTI event notification&quot;);
 695     }
 696 
 697     /* Remove initial event callbacks */
 698     (void)memset(&amp;(gdata-&gt;callbacks),0,sizeof(gdata-&gt;callbacks));
 699     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,SetEventCallbacks)
 700                 (gdata-&gt;jvmti, &amp;(gdata-&gt;callbacks), sizeof(gdata-&gt;callbacks));
 701     if (error != JVMTI_ERROR_NONE) {
 702         EXIT_ERROR(error, &quot;unable to clear JVMTI callbacks&quot;);
 703     }
 704 
 705     commonRef_initialize();
 706     util_initialize(env);
 707     threadControl_initialize();
 708     stepControl_initialize();
 709     invoker_initialize();
 710     debugDispatch_initialize();
 711     classTrack_initialize(env);
 712     debugLoop_initialize();
 713 
 714     initMonitor = debugMonitorCreate(&quot;JDWP Initialization Monitor&quot;);
 715 
 716 
 717     /*
 718      * Initialize transports
 719      */
 720     arg.isServer = isServer;
 721     arg.error = JDWP_ERROR(NONE);
 722     arg.startCount = 0;
 723 
 724     transport_initialize();
 725     (void)bagEnumerateOver(transports, startTransport, &amp;arg);
 726 
 727     /*
 728      * Exit with an error only if
 729      * 1) none of the transports was successfully started, and
 730      * 2) the application has not yet started running
 731      */
 732     if ((arg.error != JDWP_ERROR(NONE)) &amp;&amp;
 733         (arg.startCount == 0) &amp;&amp;
 734         initOnStartup) {
 735         EXIT_ERROR(map2jvmtiError(arg.error), &quot;No transports initialized&quot;);
 736     }
 737 
 738     eventHandler_initialize(currentSessionID);
 739 
 740     signalInitComplete();
 741 
 742     transport_waitForConnection();
 743 
 744     suspendPolicy = suspendOnInit ? JDWP_SUSPEND_POLICY(ALL)
 745                                   : JDWP_SUSPEND_POLICY(NONE);
 746     if (triggering_ei == EI_VM_INIT) {
 747         LOG_MISC((&quot;triggering_ei == EI_VM_INIT&quot;));
 748         eventHelper_reportVMInit(env, currentSessionID, thread, suspendPolicy);
 749     } else {
 750         /*
 751          * TO DO: Kludgy way of getting the triggering event to the
 752          * just-attached debugger. It would be nice to make this a little
 753          * cleaner. There is also a race condition where other events
 754          * can get in the queue (from other not-yet-suspended threads)
 755          * before this one does. (Also need to handle allocation error below?)
 756          */
 757         EventInfo info;
 758         struct bag *initEventBag;
 759         LOG_MISC((&quot;triggering_ei != EI_VM_INIT&quot;));
 760         initEventBag = eventHelper_createEventBag();
 761         (void)memset(&amp;info,0,sizeof(info));
 762         info.ei = triggering_ei;
 763         eventHelper_recordEvent(&amp;info, 0, suspendPolicy, initEventBag);
 764         (void)eventHelper_reportEvents(currentSessionID, initEventBag);
 765         bagDestroyBag(initEventBag);
 766     }
 767 
 768     if ( gdata-&gt;vmDead ) {
 769         EXIT_ERROR(AGENT_ERROR_INTERNAL,&quot;VM dead before initialize() completes&quot;);
 770     }
 771     LOG_MISC((&quot;End initialize()&quot;));
 772 }
 773 
 774 /*
 775  * Restore all static data to the initialized state so that another
 776  * debugger can connect properly later.
 777  */
 778 void
 779 debugInit_reset(JNIEnv *env)
 780 {
 781     EnumerateArg arg;
 782 
 783     LOG_MISC((&quot;debugInit_reset() beginning&quot;));
 784 
 785     currentSessionID++;
 786     initComplete = JNI_FALSE;
 787 
 788     eventHandler_reset(currentSessionID);
 789     transport_reset();
 790     debugDispatch_reset();
 791     invoker_reset();
 792     stepControl_reset();
 793     threadControl_reset();
 794     util_reset();
 795     commonRef_reset(env);
 796     classTrack_reset();
 797 
 798     /*
 799      * If this is a server, we are now ready to accept another connection.
 800      * If it&#39;s a client, then we&#39;ve cleaned up some (more should be added
 801      * later) and we&#39;re done.
 802      */
 803     if (isServer) {
 804         arg.isServer = JNI_TRUE;
 805         arg.error = JDWP_ERROR(NONE);
 806         arg.startCount = 0;
 807         (void)bagEnumerateOver(transports, startTransport, &amp;arg);
 808 
 809         signalInitComplete();
 810 
 811         transport_waitForConnection();
 812     } else {
 813         signalInitComplete(); /* Why? */
 814     }
 815 
 816     LOG_MISC((&quot;debugInit_reset() completed.&quot;));
 817 }
 818 
 819 
 820 char *
 821 debugInit_launchOnInit(void)
 822 {
 823     return launchOnInit;
 824 }
 825 
 826 jboolean
 827 debugInit_suspendOnInit(void)
 828 {
 829     return suspendOnInit;
 830 }
 831 
 832 /*
 833  * code below is shamelessly swiped from hprof.
 834  */
 835 
 836 static int
 837 get_tok(char **src, char *buf, int buflen, char sep)
 838 {
 839     int i;
 840     char *p = *src;
 841     for (i = 0; i &lt; buflen; i++) {
 842         if (p[i] == 0 || p[i] == sep) {
 843             buf[i] = 0;
 844             if (p[i] == sep) {
 845                 i++;
 846             }
 847             *src += i;
 848             return i;
 849         }
 850         buf[i] = p[i];
 851     }
 852     /* overflow */
 853     return 0;
 854 }
 855 
 856 static void
 857 printUsage(void)
 858 {
 859      TTY_MESSAGE((
 860  &quot;               Java Debugger JDWP Agent Library\n&quot;
 861  &quot;               --------------------------------\n&quot;
 862  &quot;\n&quot;
 863  &quot;  (see http://java.sun.com/products/jpda for more information)\n&quot;
 864  &quot;\n&quot;
 865  &quot;jdwp usage: java &quot; AGENTLIB &quot;=[help]|[&lt;option&gt;=&lt;value&gt;, ...]\n&quot;
 866  &quot;\n&quot;
 867  &quot;Option Name and Value            Description                       Default\n&quot;
 868  &quot;---------------------            -----------                       -------\n&quot;
 869  &quot;suspend=y|n                      wait on startup?                  y\n&quot;
 870  &quot;transport=&lt;name&gt;                 transport spec                    none\n&quot;
 871  &quot;address=&lt;listen/attach address&gt;  transport spec                    \&quot;\&quot;\n&quot;
 872  &quot;server=y|n                       listen for debugger?              n\n&quot;
 873  &quot;launch=&lt;command line&gt;            run debugger on event             none\n&quot;
 874  &quot;onthrow=&lt;exception name&gt;         debug on throw                    none\n&quot;
 875  &quot;onuncaught=y|n                   debug on any uncaught?            n\n&quot;
 876  &quot;onjcmd=y|n                       start debug via jcmd?             n\n&quot;
 877  &quot;timeout=&lt;timeout value&gt;          for listen/attach in milliseconds n\n&quot;
 878  &quot;mutf8=y|n                        output modified utf-8             n\n&quot;
 879  &quot;quiet=y|n                        control over terminal messages    n\n&quot;));
 880 
 881     TTY_MESSAGE((
 882  &quot;Obsolete Options\n&quot;
 883  &quot;----------------\n&quot;
 884  &quot;strict=y|n\n&quot;
 885  &quot;stdalloc=y|n\n&quot;
 886  &quot;\n&quot;
 887  &quot;Examples\n&quot;
 888  &quot;--------\n&quot;
 889  &quot;  - Using sockets connect to a debugger at a specific address:\n&quot;
 890  &quot;    java &quot; AGENTLIB &quot;=transport=dt_socket,address=localhost:8000 ...\n&quot;
 891  &quot;  - Using sockets listen for a debugger to attach:\n&quot;
 892  &quot;    java &quot; AGENTLIB &quot;=transport=dt_socket,server=y,suspend=y ...\n&quot;
 893  &quot;\n&quot;
 894  &quot;Notes\n&quot;
 895  &quot;-----\n&quot;
 896  &quot;  - A timeout value of 0 (the default) is no timeout.\n&quot;
 897  &quot;\n&quot;
 898  &quot;Warnings\n&quot;
 899  &quot;--------\n&quot;
 900  &quot;  - The older &quot; XRUN &quot; interface can still be used, but will be removed in\n&quot;
 901  &quot;    a future release, for example:\n&quot;
 902  &quot;        java &quot; XDEBUG &quot; &quot; XRUN &quot;:[help]|[&lt;option&gt;=&lt;value&gt;, ...]\n&quot;
 903     ));
 904 
 905 #ifdef DEBUG
 906 
 907      TTY_MESSAGE((
 908  &quot;\n&quot;
 909  &quot;Debugging Options            Description                       Default\n&quot;
 910  &quot;-----------------            -----------                       -------\n&quot;
 911  &quot;pause=y|n                    pause to debug PID                n\n&quot;
 912  &quot;coredump=y|n                 coredump at exit                  n\n&quot;
 913  &quot;errorexit=y|n                exit on any error                 n\n&quot;
 914  &quot;logfile=filename             name of log file                  none\n&quot;
 915  &quot;logflags=flags               log flags (bitmask)               none\n&quot;
 916  &quot;                               JVM calls     = 0x001\n&quot;
 917  &quot;                               JNI calls     = 0x002\n&quot;
 918  &quot;                               JVMTI calls   = 0x004\n&quot;
 919  &quot;                               misc events   = 0x008\n&quot;
 920  &quot;                               step logs     = 0x010\n&quot;
 921  &quot;                               locations     = 0x020\n&quot;
 922  &quot;                               callbacks     = 0x040\n&quot;
 923  &quot;                               errors        = 0x080\n&quot;
 924  &quot;                               everything    = 0xfff&quot;));
 925 
 926     TTY_MESSAGE((
 927  &quot;debugflags=flags             debug flags (bitmask)           none\n&quot;
 928  &quot;                               USE_ITERATE_THROUGH_HEAP 0x01\n&quot;
 929  &quot;\n&quot;
 930  &quot;Environment Variables\n&quot;
 931  &quot;---------------------\n&quot;
 932  &quot;_JAVA_JDWP_OPTIONS\n&quot;
 933  &quot;    Options can be added externally via this environment variable.\n&quot;
 934  &quot;    Anything contained in it will get a comma prepended to it (if needed),\n&quot;
 935  &quot;    then it will be added to the end of the options supplied via the\n&quot;
 936  &quot;    &quot; XRUN &quot; or &quot; AGENTLIB &quot; command line option.\n&quot;
 937     ));
 938 
 939 #endif
 940 
 941 
 942 
 943 }
 944 
 945 static jboolean checkAddress(void *bagItem, void *arg)
 946 {
 947     TransportSpec *spec = (TransportSpec *)bagItem;
 948     if (spec-&gt;address == NULL) {
 949         ERROR_MESSAGE((&quot;JDWP Non-server transport %s must have a connection &quot;
 950                 &quot;address specified through the &#39;address=&#39; option&quot;,
 951                 spec-&gt;name));
 952         return JNI_FALSE;
 953     } else {
 954         return JNI_TRUE;
 955     }
 956 }
 957 
 958 static  char *
 959 add_to_options(char *options, char *new_options)
 960 {
 961     size_t originalLength;
 962     char *combinedOptions;
 963 
 964     /*
 965      * Allocate enough space for both strings and
 966      * comma in between.
 967      */
 968     originalLength = strlen(options);
 969     combinedOptions = jvmtiAllocate((jint)originalLength + 1 +
 970                                 (jint)strlen(new_options) + 1);
 971     if (combinedOptions == NULL) {
 972         return NULL;
 973     }
 974 
 975     (void)strcpy(combinedOptions, options);
 976     (void)strcat(combinedOptions, &quot;,&quot;);
 977     (void)strcat(combinedOptions, new_options);
 978 
 979     return combinedOptions;
 980 }
 981 
 982 static jboolean
 983 get_boolean(char **pstr, jboolean *answer)
 984 {
 985     char buf[80];
 986     *answer = JNI_FALSE;
 987     /*LINTED*/
 988     if (get_tok(pstr, buf, (int)sizeof(buf), &#39;,&#39;)) {
 989         if (strcmp(buf, &quot;y&quot;) == 0) {
 990             *answer = JNI_TRUE;
 991             return JNI_TRUE;
 992         } else if (strcmp(buf, &quot;n&quot;) == 0) {
 993             *answer = JNI_FALSE;
 994             return JNI_TRUE;
 995         }
 996     }
 997     return JNI_FALSE;
 998 }
 999 
1000 /* atexit() callback */
1001 static void
1002 atexit_finish_logging(void)
1003 {
1004     /* Normal exit(0) (not _exit()) may only reach here */
1005     finish_logging();  /* Only first call matters */
1006 }
1007 
1008 static jboolean
1009 parseOptions(char *options)
1010 {
1011     TransportSpec *currentTransport = NULL;
1012     char *end;
1013     char *current;
1014     int length;
1015     char *str;
1016     char *errmsg;
1017     jboolean onJcmd = JNI_FALSE;
1018 
1019     /* Set defaults */
1020     gdata-&gt;assertOn     = DEFAULT_ASSERT_ON;
1021     gdata-&gt;assertFatal  = DEFAULT_ASSERT_FATAL;
1022     logfile             = DEFAULT_LOGFILE;
1023 
1024     /* Options being NULL will end up being an error. */
1025     if (options == NULL) {
1026         options = &quot;&quot;;
1027     }
1028 
1029     /* Check for &quot;help&quot; BEFORE we add any environmental settings */
1030     if ((strcmp(options, &quot;help&quot;)) == 0) {
1031         printUsage();
1032         forceExit(0); /* Kill entire process, no core dump wanted */
1033     }
1034 
1035     /* These buffers are never freed */
1036     {
1037         char *envOptions;
1038 
1039         /*
1040          * Add environmentally specified options.
1041          */
1042         envOptions = getenv(&quot;_JAVA_JDWP_OPTIONS&quot;);
1043         if (envOptions != NULL) {
1044             options = add_to_options(options, envOptions);
1045             if ( options==NULL ) {
1046                 EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;options&quot;);
1047             }
1048         }
1049 
1050         /*
1051          * Allocate a buffer for names derived from option strings. It should
1052          * never be longer than the original options string itself.
1053          * Also keep a copy of the options in gdata-&gt;options.
1054          */
1055         length = (int)strlen(options);
1056         gdata-&gt;options = jvmtiAllocate(length + 1);
1057         if (gdata-&gt;options == NULL) {
1058             EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;options&quot;);
1059         }
1060         (void)strcpy(gdata-&gt;options, options);
1061         names = jvmtiAllocate(length + 1);
1062         if (names == NULL) {
1063             EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;options&quot;);
1064         }
1065 
1066         transports = bagCreateBag(sizeof(TransportSpec), 3);
1067         if (transports == NULL) {
1068             EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;transports&quot;);
1069         }
1070     }
1071 
1072     current = names;
1073     end = names + length;
1074     str = options;
1075 
1076     while (*str) {
1077         char buf[100];
1078         /*LINTED*/
1079         if (!get_tok(&amp;str, buf, (int)sizeof(buf), &#39;=&#39;)) {
1080             goto syntax_error;
1081         }
1082         if (strcmp(buf, &quot;transport&quot;) == 0) {
1083             currentTransport = bagAdd(transports);
1084             /*LINTED*/
1085             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1086                 goto syntax_error;
1087             }
1088             currentTransport-&gt;name = current;
1089             currentTransport-&gt;address = NULL;
1090             currentTransport-&gt;allow = NULL;
1091             currentTransport-&gt;timeout = 0L;
1092             current += strlen(current) + 1;
1093         } else if (strcmp(buf, &quot;address&quot;) == 0) {
1094             if (currentTransport == NULL) {
1095                 errmsg = &quot;address specified without transport&quot;;
1096                 goto bad_option_with_errmsg;
1097             }
1098             /*LINTED*/
1099             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1100                 goto syntax_error;
1101             }
1102             currentTransport-&gt;address = current;
1103             current += strlen(current) + 1;
1104         } else if (strcmp(buf, &quot;allow&quot;) == 0) {
1105             if (currentTransport == NULL) {
1106                 errmsg = &quot;allow specified without transport&quot;;
1107                 goto bad_option_with_errmsg;
1108             }
1109             /*LINTED*/
1110             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1111                 goto syntax_error;
1112             }
1113             currentTransport-&gt;allow = current;
1114             current += strlen(current) + 1;
1115          } else if (strcmp(buf, &quot;timeout&quot;) == 0) {
1116             if (currentTransport == NULL) {
1117                 errmsg = &quot;timeout specified without transport&quot;;
1118                 goto bad_option_with_errmsg;
1119             }
1120             /*LINTED*/
1121             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1122                 goto syntax_error;
1123             }
1124             currentTransport-&gt;timeout = atol(current);
1125             current += strlen(current) + 1;
1126         } else if (strcmp(buf, &quot;launch&quot;) == 0) {
1127             /*LINTED*/
1128             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1129                 goto syntax_error;
1130             }
1131             launchOnInit = current;
1132             current += strlen(current) + 1;
1133         } else if (strcmp(buf, &quot;onthrow&quot;) == 0) {
1134             /* Read class name and convert in place to a signature */
1135             *current = &#39;L&#39;;
1136             /*LINTED*/
1137             if (!get_tok(&amp;str, current + 1, (int)(end - current - 1), &#39;,&#39;)) {
1138                 goto syntax_error;
1139             }
1140             initOnException = current;
1141             while (*current != &#39;\0&#39;) {
1142                 if (*current == &#39;.&#39;) {
1143                     *current = &#39;/&#39;;
1144                 }
1145                 current++;
1146             }
1147             *current++ = &#39;;&#39;;
1148             *current++ = &#39;\0&#39;;
1149         } else if (strcmp(buf, &quot;assert&quot;) == 0) {
1150             /*LINTED*/
1151             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1152                 goto syntax_error;
1153             }
1154             if (strcmp(current, &quot;y&quot;) == 0) {
1155                 gdata-&gt;assertOn = JNI_TRUE;
1156                 gdata-&gt;assertFatal = JNI_FALSE;
1157             } else if (strcmp(current, &quot;fatal&quot;) == 0) {
1158                 gdata-&gt;assertOn = JNI_TRUE;
1159                 gdata-&gt;assertFatal = JNI_TRUE;
1160             } else if (strcmp(current, &quot;n&quot;) == 0) {
1161                 gdata-&gt;assertOn = JNI_FALSE;
1162                 gdata-&gt;assertFatal = JNI_FALSE;
1163             } else {
1164                 goto syntax_error;
1165             }
1166             current += strlen(current) + 1;
1167         } else if (strcmp(buf, &quot;pause&quot;) == 0) {
1168             if ( !get_boolean(&amp;str, &amp;dopause) ) {
1169                 goto syntax_error;
1170             }
1171             if ( dopause ) {
1172                 do_pause();
1173             }
1174         } else if (strcmp(buf, &quot;coredump&quot;) == 0) {
1175             if ( !get_boolean(&amp;str, &amp;docoredump) ) {
1176                 goto syntax_error;
1177             }
1178         } else if (strcmp(buf, &quot;errorexit&quot;) == 0) {
1179             if ( !get_boolean(&amp;str, &amp;(gdata-&gt;doerrorexit)) ) {
1180                 goto syntax_error;
1181             }
1182         } else if (strcmp(buf, &quot;exitpause&quot;) == 0) {
1183             errmsg = &quot;The exitpause option removed, use -XX:OnError&quot;;
1184             goto bad_option_with_errmsg;
1185         } else if (strcmp(buf, &quot;precrash&quot;) == 0) {
1186             errmsg = &quot;The precrash option removed, use -XX:OnError&quot;;
1187             goto bad_option_with_errmsg;
1188         } else if (strcmp(buf, &quot;logfile&quot;) == 0) {
1189             /*LINTED*/
1190             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1191                 goto syntax_error;
1192             }
1193             logfile = current;
1194             current += strlen(current) + 1;
1195         } else if (strcmp(buf, &quot;logflags&quot;) == 0) {
1196             /*LINTED*/
1197             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1198                 goto syntax_error;
1199             }
1200             /*LINTED*/
1201             logflags = (unsigned)strtol(current, NULL, 0);
1202         } else if (strcmp(buf, &quot;debugflags&quot;) == 0) {
1203             /*LINTED*/
1204             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1205                 goto syntax_error;
1206             }
1207             /*LINTED*/
1208             gdata-&gt;debugflags = (unsigned)strtol(current, NULL, 0);
1209         } else if ( strcmp(buf, &quot;suspend&quot;)==0 ) {
1210             if ( !get_boolean(&amp;str, &amp;suspendOnInit) ) {
1211                 goto syntax_error;
1212             }
1213         } else if ( strcmp(buf, &quot;server&quot;)==0 ) {
1214             if ( !get_boolean(&amp;str, &amp;isServer) ) {
1215                 goto syntax_error;
1216             }
1217         } else if ( strcmp(buf, &quot;strict&quot;)==0 ) { /* Obsolete, but accept it */
1218             if ( !get_boolean(&amp;str, &amp;isStrict) ) {
1219                 goto syntax_error;
1220             }
1221         } else if ( strcmp(buf, &quot;quiet&quot;)==0 ) {
1222             if ( !get_boolean(&amp;str, &amp;(gdata-&gt;quiet)) ) {
1223                 goto syntax_error;
1224             }
1225         } else if ( strcmp(buf, &quot;onuncaught&quot;)==0 ) {
1226             if ( !get_boolean(&amp;str, &amp;initOnUncaught) ) {
1227                 goto syntax_error;
1228             }
1229         } else if ( strcmp(buf, &quot;mutf8&quot;)==0 ) {
1230             if ( !get_boolean(&amp;str, &amp;(gdata-&gt;modifiedUtf8)) ) {
1231                 goto syntax_error;
1232             }
1233         } else if ( strcmp(buf, &quot;stdalloc&quot;)==0 ) { /* Obsolete, but accept it */
1234             if ( !get_boolean(&amp;str, &amp;useStandardAlloc) ) {
1235                 goto syntax_error;
1236             }
1237         } else if (strcmp(buf, &quot;onjcmd&quot;) == 0) {
1238             if (!get_boolean(&amp;str, &amp;onJcmd)) {
1239                 goto syntax_error;
1240             }
1241         } else {
1242             goto syntax_error;
1243         }
1244     }
1245 
1246     /* Setup logging now */
1247     if ( logfile!=NULL ) {
1248         setup_logging(logfile, logflags);
1249         (void)atexit(&amp;atexit_finish_logging);
1250     }
1251 
1252     if (bagSize(transports) == 0) {
1253         errmsg = &quot;no transport specified&quot;;
1254         goto bad_option_with_errmsg;
1255     }
1256 
1257     /*
1258      * TO DO: Remove when multiple transports are allowed. (replace with
1259      * check below.
1260      */
1261     if (bagSize(transports) &gt; 1) {
1262         errmsg = &quot;multiple transports are not supported in this release&quot;;
1263         goto bad_option_with_errmsg;
1264     }
1265 
1266     if (!isServer) {
1267         jboolean specified = bagEnumerateOver(transports, checkAddress, NULL);
1268         if (!specified) {
1269             /* message already printed */
1270             goto bad_option_no_msg;
1271         }
1272     }
1273 
1274     /*
1275      * The user has selected to wait for an exception before init happens
1276      */
1277     if ((initOnException != NULL) || (initOnUncaught)) {
1278         initOnStartup = JNI_FALSE;
1279 
1280         if (launchOnInit == NULL) {
1281             /*
1282              * These rely on the launch=/usr/bin/foo
1283              * suboption, so it is an error if user did not
1284              * provide one.
1285              */
1286             errmsg = &quot;Specify launch=&lt;command line&gt; when using onthrow or onuncaught suboption&quot;;
1287             goto bad_option_with_errmsg;
1288         }
1289     }
1290 
1291     if (onJcmd) {
1292         if (launchOnInit != NULL) {
1293             errmsg = &quot;Cannot combine onjcmd and launch suboptions&quot;;
1294             goto bad_option_with_errmsg;
1295         }
1296         if (!isServer) {
1297             errmsg = &quot;Can only use onjcmd with server=y&quot;;
1298             goto bad_option_with_errmsg;
1299         }
1300         suspendOnInit = JNI_FALSE;
1301         initOnStartup = JNI_FALSE;
1302         allowStartViaJcmd = JNI_TRUE;
1303     }
1304 
1305     return JNI_TRUE;
1306 
1307 syntax_error:
1308     ERROR_MESSAGE((&quot;JDWP option syntax error: %s=%s&quot;, AGENTLIB, options));
1309     return JNI_FALSE;
1310 
1311 bad_option_with_errmsg:
1312     ERROR_MESSAGE((&quot;JDWP %s: %s=%s&quot;, errmsg, AGENTLIB, options));
1313     return JNI_FALSE;
1314 
1315 bad_option_no_msg:
1316     ERROR_MESSAGE((&quot;JDWP %s: %s=%s&quot;, &quot;invalid option&quot;, AGENTLIB, options));
1317     return JNI_FALSE;
1318 }
1319 
1320 /* All normal exit doors lead here */
1321 void
1322 debugInit_exit(jvmtiError error, const char *msg)
1323 {
1324     enum exit_codes { EXIT_NO_ERRORS = 0, EXIT_JVMTI_ERROR = 1, EXIT_TRANSPORT_ERROR = 2 };
1325 
1326     // Release commandLoop vmDeathLock if necessary
1327     commandLoop_exitVmDeathLockOnError();
1328 
1329     // Prepare to exit. Log error and finish logging
1330     LOG_MISC((&quot;Exiting with error %s(%d): %s&quot;, jvmtiErrorText(error), error,
1331                                                ((msg == NULL) ? &quot;&quot; : msg)));
1332 
1333     // coredump requested by command line. Keep JVMTI data dirty
1334     if (error != JVMTI_ERROR_NONE &amp;&amp; docoredump) {
1335         LOG_MISC((&quot;Dumping core as requested by command line&quot;));
1336         finish_logging();
1337         abort();
1338     }
1339 
1340     finish_logging();
1341 
1342     // Cleanup the JVMTI if we have one
1343     if (gdata != NULL) {
1344         gdata-&gt;vmDead = JNI_TRUE;
1345         if (gdata-&gt;jvmti != NULL) {
1346             // Dispose of jvmti (gdata-&gt;jvmti becomes NULL)
1347             disposeEnvironment(gdata-&gt;jvmti);
1348         }
1349     }
1350 
1351     // We are here with no errors. Kill entire process and exit with zero exit code
1352     if (error == JVMTI_ERROR_NONE) {
1353         forceExit(EXIT_NO_ERRORS);
1354         return;
1355     }
1356 
1357     // No transport initilized.
1358     // As we don&#39;t have any details here exiting with separate exit code
1359     if (error == AGENT_ERROR_TRANSPORT_INIT) {
1360         forceExit(EXIT_TRANSPORT_ERROR);
1361         return;
1362     }
1363 
1364     // We have JVMTI error. Call hotspot jni_FatalError handler
1365     jniFatalError(NULL, msg, error, EXIT_JVMTI_ERROR);
1366 
1367     // hotspot calls os:abort() so we should never reach code below,
1368     // but guard against possible hotspot changes
1369 
1370     // Last chance to die, this kills the entire process.
1371     forceExit(EXIT_JVMTI_ERROR);
1372 }
1373 
1374 static jboolean getFirstTransport(void *item, void *arg)
1375 {
1376     TransportSpec** store = arg;
1377     *store = item;
1378 
1379     return JNI_FALSE; /* Want the first */
1380 }
1381 
1382 /* Call to start up debugging. */
1383 JNIEXPORT char const* JNICALL debugInit_startDebuggingViaCommand(JNIEnv* env, jthread thread, char const** transport_name,
1384                                                                 char const** address, jboolean* first_start) {
1385     jboolean is_first_start = JNI_FALSE;
1386     TransportSpec* spec = NULL;
1387 
1388     if (!vmInitialized) {
1389         return &quot;Not yet initialized. Try again later.&quot;;
1390     }
1391 
1392     if (!allowStartViaJcmd) {
1393         return &quot;Starting debugging via jcmd was not enabled via the onjcmd option of the jdwp agent.&quot;;
1394     }
1395 
1396     if (!startedViaJcmd) {
1397         startedViaJcmd = JNI_TRUE;
1398         is_first_start = JNI_TRUE;
1399         initialize(env, thread, EI_VM_INIT);
1400     }
1401 
1402     bagEnumerateOver(transports, getFirstTransport, &amp;spec);
1403 
1404     if ((spec != NULL) &amp;&amp; (transport_name != NULL) &amp;&amp; (address != NULL)) {
1405         *transport_name = spec-&gt;name;
1406         *address = spec-&gt;address;
1407     }
1408 
1409     if (first_start != NULL) {
1410         *first_start = is_first_start;
1411     }
1412 
1413     return NULL;
1414 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jdwp.agent/share/native/libjdwp/debugLoop.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="debugInit.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="transport.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdwp.agent/share/native/libjdwp/debugLoop.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
100 
101     /* Okay, start reading cmds! */
102     while (shouldListen) {
103         if (!dequeue(&amp;p)) {
104             break;
105         }
106 
107         if (p.type.cmd.flags &amp; JDWPTRANSPORT_FLAGS_REPLY) {
108             /*
109              * Its a reply packet.
110              */
111            continue;
112         } else {
113             /*
114              * Its a cmd packet.
115              */
116             jdwpCmdPacket *cmd = &amp;p.type.cmd;
117             PacketInputStream in;
118             PacketOutputStream out;
119             CommandHandler func;


120 
121             /* Should reply be sent to sender.
122              * For error handling, assume yes, since
123              * only VM/exit does not reply
124              */
125             jboolean replyToSender = JNI_TRUE;
126 
127             /*
128              * For all commands we hold the vmDeathLock
129              * while executing and replying to the command. This ensures
130              * that a command after VM_DEATH will be allowed to complete
131              * before the thread posting the VM_DEATH continues VM
132              * termination.
133              */
134             debugMonitorEnter(vmDeathLock);
135 
136             /* Initialize the input and output streams */
137             inStream_init(&amp;in, p);
138             outStream_initReply(&amp;out, inStream_id(&amp;in));
139 
<span class="line-modified">140             LOG_MISC((&quot;Command set %d, command %d&quot;, cmd-&gt;cmdSet, cmd-&gt;cmd));</span>
<span class="line-modified">141 </span>
<span class="line-modified">142             func = debugDispatch_getHandler(cmd-&gt;cmdSet,cmd-&gt;cmd);</span>
143             if (func == NULL) {
144                 /* we&#39;ve never heard of this, so I guess we
145                  * haven&#39;t implemented it.
146                  * Handle gracefully for future expansion
147                  * and platform / vendor expansion.
148                  */
149                 outStream_setError(&amp;out, JDWP_ERROR(NOT_IMPLEMENTED));
150             } else if (gdata-&gt;vmDead &amp;&amp;
151              ((cmd-&gt;cmdSet) != JDWP_COMMAND_SET(VirtualMachine))) {
152                 /* Protect the VM from calls while dead.
153                  * VirtualMachine cmdSet quietly ignores some cmds
154                  * after VM death, so, it sends it&#39;s own errors.
155                  */
156                 outStream_setError(&amp;out, JDWP_ERROR(VM_DEAD));
157             } else {
158                 /* Call the command handler */
159                 replyToSender = func(&amp;in, &amp;out);
160             }
161 
162             /* Reply to the sender */
</pre>
<hr />
<pre>
212 
213         /* I/O error or EOF */
214         if (rc != 0 || (rc == 0 &amp;&amp; packet.type.cmd.len == 0)) {
215             shouldListen = JNI_FALSE;
216             notifyTransportError();
217         } else if (packet.type.cmd.flags != JDWPTRANSPORT_FLAGS_NONE) {
218             /*
219              * Close the connection when we get a jdwpCmdPacket with an
220              * invalid flags field value. This is a protocol violation
221              * so we drop the connection. Also this could be a web
222              * browser generating an HTTP request that passes the JDWP
223              * handshake. HTTP requests requires that everything be in
224              * the ASCII printable range so a flags value of
225              * JDWPTRANSPORT_FLAGS_NONE(0) cannot be generated via HTTP.
226              */
227             ERROR_MESSAGE((&quot;Received jdwpPacket with flags != 0x%d (actual=0x%x) when a jdwpCmdPacket was expected.&quot;,
228                            JDWPTRANSPORT_FLAGS_NONE, packet.type.cmd.flags));
229             shouldListen = JNI_FALSE;
230             notifyTransportError();
231         } else {


232             cmd = &amp;packet.type.cmd;
233 
<span class="line-modified">234             LOG_MISC((&quot;Command set %d, command %d&quot;, cmd-&gt;cmdSet, cmd-&gt;cmd));</span>


235 
236             /*
237              * FIXME! We need to deal with high priority
238              * packets and queue flushes!
239              */
240             enqueue(&amp;packet);
241 
242             shouldListen = !lastCommand(cmd);
243         }
244     }
245     LOG_MISC((&quot;End reader thread&quot;));
246 }
247 
248 /*
249  * The current system for queueing packets is highly
250  * inefficient, and should be rewritten! It&#39;d be nice
251  * to avoid any additional memory allocations.
252  */
253 
254 static void
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
100 
101     /* Okay, start reading cmds! */
102     while (shouldListen) {
103         if (!dequeue(&amp;p)) {
104             break;
105         }
106 
107         if (p.type.cmd.flags &amp; JDWPTRANSPORT_FLAGS_REPLY) {
108             /*
109              * Its a reply packet.
110              */
111            continue;
112         } else {
113             /*
114              * Its a cmd packet.
115              */
116             jdwpCmdPacket *cmd = &amp;p.type.cmd;
117             PacketInputStream in;
118             PacketOutputStream out;
119             CommandHandler func;
<span class="line-added">120             const char *cmdSetName;</span>
<span class="line-added">121             const char *cmdName;</span>
122 
123             /* Should reply be sent to sender.
124              * For error handling, assume yes, since
125              * only VM/exit does not reply
126              */
127             jboolean replyToSender = JNI_TRUE;
128 
129             /*
130              * For all commands we hold the vmDeathLock
131              * while executing and replying to the command. This ensures
132              * that a command after VM_DEATH will be allowed to complete
133              * before the thread posting the VM_DEATH continues VM
134              * termination.
135              */
136             debugMonitorEnter(vmDeathLock);
137 
138             /* Initialize the input and output streams */
139             inStream_init(&amp;in, p);
140             outStream_initReply(&amp;out, inStream_id(&amp;in));
141 
<span class="line-modified">142             func = debugDispatch_getHandler(cmd-&gt;cmdSet, cmd-&gt;cmd, &amp;cmdSetName, &amp;cmdName);</span>
<span class="line-modified">143             LOG_MISC((&quot;Command set %s(%d), command %s(%d)&quot;,</span>
<span class="line-modified">144                       cmdSetName, cmd-&gt;cmdSet, cmdName, cmd-&gt;cmd));</span>
145             if (func == NULL) {
146                 /* we&#39;ve never heard of this, so I guess we
147                  * haven&#39;t implemented it.
148                  * Handle gracefully for future expansion
149                  * and platform / vendor expansion.
150                  */
151                 outStream_setError(&amp;out, JDWP_ERROR(NOT_IMPLEMENTED));
152             } else if (gdata-&gt;vmDead &amp;&amp;
153              ((cmd-&gt;cmdSet) != JDWP_COMMAND_SET(VirtualMachine))) {
154                 /* Protect the VM from calls while dead.
155                  * VirtualMachine cmdSet quietly ignores some cmds
156                  * after VM death, so, it sends it&#39;s own errors.
157                  */
158                 outStream_setError(&amp;out, JDWP_ERROR(VM_DEAD));
159             } else {
160                 /* Call the command handler */
161                 replyToSender = func(&amp;in, &amp;out);
162             }
163 
164             /* Reply to the sender */
</pre>
<hr />
<pre>
214 
215         /* I/O error or EOF */
216         if (rc != 0 || (rc == 0 &amp;&amp; packet.type.cmd.len == 0)) {
217             shouldListen = JNI_FALSE;
218             notifyTransportError();
219         } else if (packet.type.cmd.flags != JDWPTRANSPORT_FLAGS_NONE) {
220             /*
221              * Close the connection when we get a jdwpCmdPacket with an
222              * invalid flags field value. This is a protocol violation
223              * so we drop the connection. Also this could be a web
224              * browser generating an HTTP request that passes the JDWP
225              * handshake. HTTP requests requires that everything be in
226              * the ASCII printable range so a flags value of
227              * JDWPTRANSPORT_FLAGS_NONE(0) cannot be generated via HTTP.
228              */
229             ERROR_MESSAGE((&quot;Received jdwpPacket with flags != 0x%d (actual=0x%x) when a jdwpCmdPacket was expected.&quot;,
230                            JDWPTRANSPORT_FLAGS_NONE, packet.type.cmd.flags));
231             shouldListen = JNI_FALSE;
232             notifyTransportError();
233         } else {
<span class="line-added">234             const char *cmdSetName;</span>
<span class="line-added">235             const char *cmdName;</span>
236             cmd = &amp;packet.type.cmd;
237 
<span class="line-modified">238             debugDispatch_getHandler(cmd-&gt;cmdSet, cmd-&gt;cmd, &amp;cmdSetName, &amp;cmdName);</span>
<span class="line-added">239             LOG_MISC((&quot;Command set %s(%d), command %s(%d)&quot;,</span>
<span class="line-added">240                       cmdSetName, cmd-&gt;cmdSet, cmdName, cmd-&gt;cmd));</span>
241 
242             /*
243              * FIXME! We need to deal with high priority
244              * packets and queue flushes!
245              */
246             enqueue(&amp;packet);
247 
248             shouldListen = !lastCommand(cmd);
249         }
250     }
251     LOG_MISC((&quot;End reader thread&quot;));
252 }
253 
254 /*
255  * The current system for queueing packets is highly
256  * inefficient, and should be rewritten! It&#39;d be nice
257  * to avoid any additional memory allocations.
258  */
259 
260 static void
</pre>
</td>
</tr>
</table>
<center><a href="debugInit.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="transport.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
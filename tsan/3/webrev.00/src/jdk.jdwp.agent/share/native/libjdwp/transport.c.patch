diff a/src/jdk.jdwp.agent/share/native/libjdwp/transport.c b/src/jdk.jdwp.agent/share/native/libjdwp/transport.c
--- a/src/jdk.jdwp.agent/share/native/libjdwp/transport.c
+++ b/src/jdk.jdwp.agent/share/native/libjdwp/transport.c
@@ -47,10 +47,19 @@
     unsigned transportVersion;
 } TransportInfo;
 
 static struct jdwpTransportCallback callback = {jvmtiAllocate, jvmtiDeallocate};
 
+static void freeTransportInfo(TransportInfo *info) {
+    if (info) {
+        jvmtiDeallocate(info->name);
+        jvmtiDeallocate(info->address);
+        jvmtiDeallocate(info->allowed_peers);
+        jvmtiDeallocate(info);
+    }
+}
+
 /*
  * Print the last transport error
  */
 static void
 printLastError(jdwpTransportEnv *t, jdwpTransportError err)
@@ -343,16 +352,18 @@
     jdwpTransportEnv *t;
     jdwpTransportError rc;
 
     LOG_MISC(("Begin accept thread"));
 
-    info = (TransportInfo*)(void*)arg;
+    info = (TransportInfo*)arg;
     t = info->transport;
     rc = (*t)->Accept(t, info->timeout, 0);
 
     /* System property no longer needed */
     setTransportProperty(jni_env, NULL);
+    /* TransportInfo data no longer needed */
+    freeTransportInfo(info);
 
     if (rc != JDWPTRANSPORT_ERROR_NONE) {
         /*
          * If accept fails it probably means a timeout, or another fatal error
          * We thus exit the VM after stopping the listener.
@@ -369,14 +380,18 @@
 }
 
 static void JNICALL
 attachThread(jvmtiEnv* jvmti_env, JNIEnv* jni_env, void* arg)
 {
-    TransportInfo *info = (TransportInfo*)(void*)arg;
+    TransportInfo *info = (TransportInfo*)arg;
+    jdwpTransportEnv *t = info->transport;
+
+    /* TransportInfo data no longer needed */
+    freeTransportInfo(info);
 
     LOG_MISC(("Begin attach thread"));
-    connectionInitiated(info->transport);
+    connectionInitiated(t);
     LOG_MISC(("End attach thread"));
 }
 
 void
 transport_initialize(void)
@@ -482,11 +497,11 @@
      * to correspond to the transports bag.
      */
     if (info->transport == NULL) {
         serror = loadTransport(name, info);
         if (serror != JDWP_ERROR(NONE)) {
-            jvmtiDeallocate(info);
+            freeTransportInfo(info);
             return serror;
         }
     }
 
     // Cache the value
@@ -575,10 +590,13 @@
         if (error != JVMTI_ERROR_NONE) {
             serror = map2jdwpError(error);
             goto handleError;
         }
 
+        /* reset info - it will be deallocated by acceptThread */
+        info = NULL;
+
         launchCommand = debugInit_launchOnInit();
         if (launchCommand != NULL) {
             serror = launch(launchCommand, name, retAddress);
             if (serror != JDWP_ERROR(NONE)) {
                 goto handleError;
@@ -590,14 +608,11 @@
             }
         }
         return JDWP_ERROR(NONE);
 
 handleError:
-        jvmtiDeallocate(info->name);
-        jvmtiDeallocate(info->address);
-        jvmtiDeallocate(info->allowed_peers);
-        jvmtiDeallocate(info);
+        freeTransportInfo(info);
     } else {
         /*
          * Note that we don't attempt to do a launch here. Launching
          * is currently supported only in server mode.
          */
@@ -612,11 +627,11 @@
              printLastError(trans, err);
              serror = JDWP_ERROR(TRANSPORT_INIT);
              /* The name, address and allowed_peers fields in 'info'
               * are not allocated in the non-server case so
               * they do not need to be freed. */
-             jvmtiDeallocate(info);
+             freeTransportInfo(info);
              return serror;
          }
 
          /*
           * Start the transport loop in a separate thread

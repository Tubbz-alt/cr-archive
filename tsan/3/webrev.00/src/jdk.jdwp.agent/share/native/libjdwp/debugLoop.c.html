<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jdwp.agent/share/native/libjdwp/debugLoop.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;util.h&quot;
 27 #include &quot;transport.h&quot;
 28 #include &quot;debugLoop.h&quot;
 29 #include &quot;debugDispatch.h&quot;
 30 #include &quot;standardHandlers.h&quot;
 31 #include &quot;inStream.h&quot;
 32 #include &quot;outStream.h&quot;
 33 #include &quot;threadControl.h&quot;
 34 
 35 
 36 static void JNICALL reader(jvmtiEnv* jvmti_env, JNIEnv* jni_env, void* arg);
 37 static void enqueue(jdwpPacket *p);
 38 static jboolean dequeue(jdwpPacket *p);
 39 static void notifyTransportError(void);
 40 
 41 struct PacketList {
 42     jdwpPacket packet;
 43     struct PacketList *next;
 44 };
 45 
 46 static volatile struct PacketList *cmdQueue;
 47 static jrawMonitorID cmdQueueLock;
 48 static jrawMonitorID vmDeathLock;
 49 static jboolean transportError;
 50 
 51 static jboolean
 52 lastCommand(jdwpCmdPacket *cmd)
 53 {
 54     if ((cmd-&gt;cmdSet == JDWP_COMMAND_SET(VirtualMachine)) &amp;&amp;
 55         ((cmd-&gt;cmd == JDWP_COMMAND(VirtualMachine, Dispose)) ||
 56          (cmd-&gt;cmd == JDWP_COMMAND(VirtualMachine, Exit)))) {
 57         return JNI_TRUE;
 58     } else {
 59         return JNI_FALSE;
 60     }
 61 }
 62 
 63 void
 64 debugLoop_initialize(void)
 65 {
 66     vmDeathLock = debugMonitorCreate(&quot;JDWP VM_DEATH Lock&quot;);
 67 }
 68 
 69 void
 70 debugLoop_sync(void)
 71 {
 72     debugMonitorEnter(vmDeathLock);
 73     debugMonitorExit(vmDeathLock);
 74 }
 75 
 76 /*
 77  * This is where all the work gets done.
 78  */
 79 
 80 void
 81 debugLoop_run(void)
 82 {
 83     jboolean shouldListen;
 84     jdwpPacket p;
 85     jvmtiStartFunction func;
 86 
 87     /* Initialize all statics */
 88     /* We may be starting a new connection after an error */
 89     cmdQueue = NULL;
 90     cmdQueueLock = debugMonitorCreate(&quot;JDWP Command Queue Lock&quot;);
 91     transportError = JNI_FALSE;
 92 
 93     shouldListen = JNI_TRUE;
 94 
 95     func = &amp;reader;
 96     (void)spawnNewThread(func, NULL, &quot;JDWP Command Reader&quot;);
 97 
 98     standardHandlers_onConnect();
 99     threadControl_onConnect();
100 
101     /* Okay, start reading cmds! */
102     while (shouldListen) {
103         if (!dequeue(&amp;p)) {
104             break;
105         }
106 
107         if (p.type.cmd.flags &amp; JDWPTRANSPORT_FLAGS_REPLY) {
108             /*
109              * Its a reply packet.
110              */
111            continue;
112         } else {
113             /*
114              * Its a cmd packet.
115              */
116             jdwpCmdPacket *cmd = &amp;p.type.cmd;
117             PacketInputStream in;
118             PacketOutputStream out;
119             CommandHandler func;
120             const char *cmdSetName;
121             const char *cmdName;
122 
123             /* Should reply be sent to sender.
124              * For error handling, assume yes, since
125              * only VM/exit does not reply
126              */
127             jboolean replyToSender = JNI_TRUE;
128 
129             /*
130              * For all commands we hold the vmDeathLock
131              * while executing and replying to the command. This ensures
132              * that a command after VM_DEATH will be allowed to complete
133              * before the thread posting the VM_DEATH continues VM
134              * termination.
135              */
136             debugMonitorEnter(vmDeathLock);
137 
138             /* Initialize the input and output streams */
139             inStream_init(&amp;in, p);
140             outStream_initReply(&amp;out, inStream_id(&amp;in));
141 
142             func = debugDispatch_getHandler(cmd-&gt;cmdSet, cmd-&gt;cmd, &amp;cmdSetName, &amp;cmdName);
143             LOG_MISC((&quot;Command set %s(%d), command %s(%d)&quot;,
144                       cmdSetName, cmd-&gt;cmdSet, cmdName, cmd-&gt;cmd));
145             if (func == NULL) {
146                 /* we&#39;ve never heard of this, so I guess we
147                  * haven&#39;t implemented it.
148                  * Handle gracefully for future expansion
149                  * and platform / vendor expansion.
150                  */
151                 outStream_setError(&amp;out, JDWP_ERROR(NOT_IMPLEMENTED));
152             } else if (gdata-&gt;vmDead &amp;&amp;
153              ((cmd-&gt;cmdSet) != JDWP_COMMAND_SET(VirtualMachine))) {
154                 /* Protect the VM from calls while dead.
155                  * VirtualMachine cmdSet quietly ignores some cmds
156                  * after VM death, so, it sends it&#39;s own errors.
157                  */
158                 outStream_setError(&amp;out, JDWP_ERROR(VM_DEAD));
159             } else {
160                 /* Call the command handler */
161                 replyToSender = func(&amp;in, &amp;out);
162             }
163 
164             /* Reply to the sender */
165             if (replyToSender) {
166                 if (inStream_error(&amp;in)) {
167                     outStream_setError(&amp;out, inStream_error(&amp;in));
168                 }
169                 outStream_sendReply(&amp;out);
170             }
171 
172             /*
173              * Release the vmDeathLock as the reply has been posted.
174              */
175             debugMonitorExit(vmDeathLock);
176 
177             inStream_destroy(&amp;in);
178             outStream_destroy(&amp;out);
179 
180             shouldListen = !lastCommand(cmd);
181         }
182     }
183     threadControl_onDisconnect();
184     standardHandlers_onDisconnect();
185 
186     /*
187      * Cut off the transport immediately. This has the effect of
188      * cutting off any events that the eventHelper thread might
189      * be trying to send.
190      */
191     transport_close();
192     debugMonitorDestroy(cmdQueueLock);
193 
194     /* Reset for a new connection to this VM if it&#39;s still alive */
195     if ( ! gdata-&gt;vmDead ) {
196         debugInit_reset(getEnv());
197     }
198 }
199 
200 /* Command reader */
201 static void JNICALL
202 reader(jvmtiEnv* jvmti_env, JNIEnv* jni_env, void* arg)
203 {
204     jdwpPacket packet;
205     jdwpCmdPacket *cmd;
206     jboolean shouldListen = JNI_TRUE;
207 
208     LOG_MISC((&quot;Begin reader thread&quot;));
209 
210     while (shouldListen) {
211         jint rc;
212 
213         rc = transport_receivePacket(&amp;packet);
214 
215         /* I/O error or EOF */
216         if (rc != 0 || (rc == 0 &amp;&amp; packet.type.cmd.len == 0)) {
217             shouldListen = JNI_FALSE;
218             notifyTransportError();
219         } else if (packet.type.cmd.flags != JDWPTRANSPORT_FLAGS_NONE) {
220             /*
221              * Close the connection when we get a jdwpCmdPacket with an
222              * invalid flags field value. This is a protocol violation
223              * so we drop the connection. Also this could be a web
224              * browser generating an HTTP request that passes the JDWP
225              * handshake. HTTP requests requires that everything be in
226              * the ASCII printable range so a flags value of
227              * JDWPTRANSPORT_FLAGS_NONE(0) cannot be generated via HTTP.
228              */
229             ERROR_MESSAGE((&quot;Received jdwpPacket with flags != 0x%d (actual=0x%x) when a jdwpCmdPacket was expected.&quot;,
230                            JDWPTRANSPORT_FLAGS_NONE, packet.type.cmd.flags));
231             shouldListen = JNI_FALSE;
232             notifyTransportError();
233         } else {
234             const char *cmdSetName;
235             const char *cmdName;
236             cmd = &amp;packet.type.cmd;
237 
238             debugDispatch_getHandler(cmd-&gt;cmdSet, cmd-&gt;cmd, &amp;cmdSetName, &amp;cmdName);
239             LOG_MISC((&quot;Command set %s(%d), command %s(%d)&quot;,
240                       cmdSetName, cmd-&gt;cmdSet, cmdName, cmd-&gt;cmd));
241 
242             /*
243              * FIXME! We need to deal with high priority
244              * packets and queue flushes!
245              */
246             enqueue(&amp;packet);
247 
248             shouldListen = !lastCommand(cmd);
249         }
250     }
251     LOG_MISC((&quot;End reader thread&quot;));
252 }
253 
254 /*
255  * The current system for queueing packets is highly
256  * inefficient, and should be rewritten! It&#39;d be nice
257  * to avoid any additional memory allocations.
258  */
259 
260 static void
261 enqueue(jdwpPacket *packet)
262 {
263     struct PacketList *pL;
264     struct PacketList *walker;
265 
266     pL = jvmtiAllocate((jint)sizeof(struct PacketList));
267     if (pL == NULL) {
268         EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;packet list&quot;);
269     }
270 
271     pL-&gt;packet = *packet;
272     pL-&gt;next = NULL;
273 
274     debugMonitorEnter(cmdQueueLock);
275 
276     if (cmdQueue == NULL) {
277         cmdQueue = pL;
278         debugMonitorNotify(cmdQueueLock);
279     } else {
280         walker = (struct PacketList *)cmdQueue;
281         while (walker-&gt;next != NULL)
282             walker = walker-&gt;next;
283 
284         walker-&gt;next = pL;
285     }
286 
287     debugMonitorExit(cmdQueueLock);
288 }
289 
290 static jboolean
291 dequeue(jdwpPacket *packet) {
292     struct PacketList *node = NULL;
293 
294     debugMonitorEnter(cmdQueueLock);
295 
296     while (!transportError &amp;&amp; (cmdQueue == NULL)) {
297         debugMonitorWait(cmdQueueLock);
298     }
299 
300     if (cmdQueue != NULL) {
301         node = (struct PacketList *)cmdQueue;
302         cmdQueue = node-&gt;next;
303     }
304     debugMonitorExit(cmdQueueLock);
305 
306     if (node != NULL) {
307         *packet = node-&gt;packet;
308         jvmtiDeallocate(node);
309     }
310     return (node != NULL);
311 }
312 
313 static void
314 notifyTransportError(void) {
315     debugMonitorEnter(cmdQueueLock);
316     transportError = JNI_TRUE;
317     debugMonitorNotify(cmdQueueLock);
318     debugMonitorExit(cmdQueueLock);
319 }
    </pre>
  </body>
</html>
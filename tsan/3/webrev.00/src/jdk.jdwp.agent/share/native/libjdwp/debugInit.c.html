<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jdwp.agent/share/native/libjdwp/debugInit.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;ctype.h&gt;
  27 
  28 #include &quot;util.h&quot;
  29 #include &quot;commonRef.h&quot;
  30 #include &quot;debugDispatch.h&quot;
  31 #include &quot;eventHandler.h&quot;
  32 #include &quot;eventHelper.h&quot;
  33 #include &quot;threadControl.h&quot;
  34 #include &quot;stepControl.h&quot;
  35 #include &quot;transport.h&quot;
  36 #include &quot;classTrack.h&quot;
  37 #include &quot;debugLoop.h&quot;
  38 #include &quot;bag.h&quot;
  39 #include &quot;invoker.h&quot;
  40 #include &quot;sys.h&quot;
  41 
  42 /* How the options get to OnLoad: */
  43 #define XRUN &quot;-Xrunjdwp&quot;
  44 #define AGENTLIB &quot;-agentlib:jdwp&quot;
  45 
  46 /* Debug version defaults */
  47 #ifdef DEBUG
  48     #define DEFAULT_ASSERT_ON           JNI_TRUE
  49     #define DEFAULT_ASSERT_FATAL        JNI_TRUE
  50     #define DEFAULT_LOGFILE             &quot;jdwp.log&quot;
  51 #else
  52     #define DEFAULT_ASSERT_ON           JNI_FALSE
  53     #define DEFAULT_ASSERT_FATAL        JNI_FALSE
  54     #define DEFAULT_LOGFILE             NULL
  55 #endif
  56 
  57 static jboolean vmInitialized;
  58 static jrawMonitorID initMonitor;
  59 static jboolean initComplete;
  60 static jbyte currentSessionID;
  61 
  62 /*
  63  * Options set through the OnLoad options string. All of these values
  64  * are set once at VM startup and never reset.
  65  */
  66 static jboolean isServer = JNI_FALSE;     /* Listens for connecting debuggers? */
  67 static jboolean isStrict = JNI_FALSE;     /* Unused */
  68 static jboolean useStandardAlloc = JNI_FALSE;  /* Use standard malloc/free? */
  69 static struct bag *transports;            /* of TransportSpec */
  70 
  71 static jboolean initOnStartup = JNI_TRUE;   /* init immediately */
  72 static char *initOnException = NULL;        /* init when this exception thrown */
  73 static jboolean initOnUncaught = JNI_FALSE; /* init when uncaught exc thrown */
  74 
  75 static char *launchOnInit = NULL;           /* launch this app during init */
  76 static jboolean suspendOnInit = JNI_TRUE;   /* suspend all app threads after init */
  77 static jboolean dopause = JNI_FALSE;        /* pause for debugger attach */
  78 static jboolean docoredump = JNI_FALSE;     /* core dump on exit */
  79 static char *logfile = NULL;                /* Name of logfile (if logging) */
  80 static unsigned logflags = 0;               /* Log flags */
  81 
  82 static char *names;                         /* strings derived from OnLoad options */
  83 
  84 static jboolean allowStartViaJcmd = JNI_FALSE;  /* if true we allow the debugging to be started via a jcmd */
  85 static jboolean startedViaJcmd = JNI_FALSE;     /* if false, we have not yet started debugging via a jcmd */
  86 
  87 /*
  88  * Elements of the transports bag
  89  */
  90 typedef struct TransportSpec {
  91     char *name;
  92     char *address;
  93     long timeout;
  94     char *allow;
  95 } TransportSpec;
  96 
  97 /*
  98  * Forward Refs
  99  */
 100 static void JNICALL cbEarlyVMInit(jvmtiEnv*, JNIEnv *, jthread);
 101 static void JNICALL cbEarlyVMDeath(jvmtiEnv*, JNIEnv *);
 102 static void JNICALL cbEarlyException(jvmtiEnv*, JNIEnv *,
 103             jthread, jmethodID, jlocation, jobject, jmethodID, jlocation);
 104 
 105 static void initialize(JNIEnv *env, jthread thread, EventIndex triggering_ei);
 106 static jboolean parseOptions(char *str);
 107 
 108 /*
 109  * Phase 1: Initial load.
 110  *
 111  * OnLoad is called by the VM immediately after the back-end
 112  * library is loaded. We can do very little in this function since
 113  * the VM has not completed initialization. So, we parse the JDWP
 114  * options and set up a simple initial event callbacks for JVMTI events.
 115  * When a triggering event occurs, that callback will begin debugger initialization.
 116  */
 117 
 118 /* Get a static area to hold the Global Data */
 119 static BackendGlobalData *
 120 get_gdata(void)
 121 {
 122     static BackendGlobalData s;
 123     (void)memset(&amp;s, 0, sizeof(BackendGlobalData));
 124     return &amp;s;
 125 }
 126 
 127 static jvmtiError
 128 set_event_notification(jvmtiEventMode mode, EventIndex ei)
 129 {
 130     jvmtiError error;
 131     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,SetEventNotificationMode)
 132                 (gdata-&gt;jvmti, mode, eventIndex2jvmti(ei), NULL);
 133     if (error != JVMTI_ERROR_NONE) {
 134         ERROR_MESSAGE((&quot;JDWP unable to configure initial JVMTI event %s: %s(%d)&quot;,
 135                     eventText(ei), jvmtiErrorText(error), error));
 136     }
 137     return error;
 138 }
 139 
 140 typedef struct {
 141     int major;
 142     int minor;
 143 } version_type;
 144 
 145 typedef struct {
 146     version_type runtime;
 147     version_type compiletime;
 148 } compatible_versions_type;
 149 
 150 /*
 151  * List of explicitly compatible JVMTI versions, specified as
 152  * { runtime version, compile-time version } pairs. -1 is a wildcard.
 153  */
 154 static int nof_compatible_versions = 3;
 155 static compatible_versions_type compatible_versions_list[] = {
 156     /*
 157      * FIXUP: Allow version 0 to be compatible with anything
 158      * Special check for FCS of 1.0.
 159      */
 160     { {  0, -1 }, { -1, -1 } },
 161     { { -1, -1 }, {  0, -1 } },
 162     /*
 163      * 1.2 is runtime compatible with 1.1 -- just make sure to check the
 164      * version before using any new 1.2 features
 165      */
 166     { {  1,  1 }, {  1,  2 } }
 167 };
 168 
 169 
 170 /* Logic to determine JVMTI version compatibility */
 171 static jboolean
 172 compatible_versions(jint major_runtime,     jint minor_runtime,
 173                     jint major_compiletime, jint minor_compiletime)
 174 {
 175     /*
 176      * First check to see if versions are explicitly compatible via the
 177      * list specified above.
 178      */
 179     int i;
 180     for (i = 0; i &lt; nof_compatible_versions; ++i) {
 181         version_type runtime = compatible_versions_list[i].runtime;
 182         version_type comptime = compatible_versions_list[i].compiletime;
 183 
 184         if ((major_runtime     == runtime.major  || runtime.major  == -1) &amp;&amp;
 185             (minor_runtime     == runtime.minor  || runtime.minor  == -1) &amp;&amp;
 186             (major_compiletime == comptime.major || comptime.major == -1) &amp;&amp;
 187             (minor_compiletime == comptime.minor || comptime.minor == -1)) {
 188             return JNI_TRUE;
 189         }
 190     }
 191 
 192     return major_runtime == major_compiletime &amp;&amp;
 193            minor_runtime &gt;= minor_compiletime;
 194 }
 195 
 196 /* OnLoad startup:
 197  *   Returning JNI_ERR will cause the java_g VM to core dump, be careful.
 198  */
 199 JNIEXPORT jint JNICALL
 200 DEF_Agent_OnLoad(JavaVM *vm, char *options, void *reserved)
 201 {
 202     jvmtiError error;
 203     jvmtiCapabilities needed_capabilities;
 204     jvmtiCapabilities potential_capabilities;
 205     jint              jvmtiCompileTimeMajorVersion;
 206     jint              jvmtiCompileTimeMinorVersion;
 207     jint              jvmtiCompileTimeMicroVersion;
 208 
 209     /* See if it&#39;s already loaded */
 210     if ( gdata!=NULL &amp;&amp; gdata-&gt;isLoaded==JNI_TRUE ) {
 211         ERROR_MESSAGE((&quot;Cannot load this JVM TI agent twice, check your java command line for duplicate jdwp options.&quot;));
 212         return JNI_ERR;
 213     }
 214 
 215     /* If gdata is defined and the VM died, why are we here? */
 216     if ( gdata!=NULL &amp;&amp; gdata-&gt;vmDead ) {
 217         ERROR_MESSAGE((&quot;JDWP unable to load, VM died&quot;));
 218         return JNI_ERR;
 219     }
 220 
 221     /* Get global data area */
 222     gdata = get_gdata();
 223     if (gdata == NULL) {
 224         ERROR_MESSAGE((&quot;JDWP unable to allocate memory&quot;));
 225         return JNI_ERR;
 226     }
 227     gdata-&gt;isLoaded = JNI_TRUE;
 228 
 229     /* Start filling in gdata */
 230     gdata-&gt;jvm = vm;
 231     vmInitialized = JNI_FALSE;
 232     gdata-&gt;vmDead = JNI_FALSE;
 233 
 234     /* Get the JVMTI Env, IMPORTANT: Do this first! For jvmtiAllocate(). */
 235     error = JVM_FUNC_PTR(vm,GetEnv)
 236                 (vm, (void **)&amp;(gdata-&gt;jvmti), JVMTI_VERSION_1);
 237     if (error != JNI_OK) {
 238         ERROR_MESSAGE((&quot;JDWP unable to access JVMTI Version 1 (0x%x),&quot;
 239                          &quot; is your J2SE a 1.5 or newer version?&quot;
 240                          &quot; JNIEnv&#39;s GetEnv() returned %d&quot;,
 241                          JVMTI_VERSION_1, error));
 242         forceExit(1); /* Kill entire process, no core dump */
 243     }
 244 
 245     /* Check to make sure the version of jvmti.h we compiled with
 246      *      matches the runtime version we are using.
 247      */
 248     jvmtiCompileTimeMajorVersion  = ( JVMTI_VERSION &amp; JVMTI_VERSION_MASK_MAJOR )
 249                                         &gt;&gt; JVMTI_VERSION_SHIFT_MAJOR;
 250     jvmtiCompileTimeMinorVersion  = ( JVMTI_VERSION &amp; JVMTI_VERSION_MASK_MINOR )
 251                                         &gt;&gt; JVMTI_VERSION_SHIFT_MINOR;
 252     jvmtiCompileTimeMicroVersion  = ( JVMTI_VERSION &amp; JVMTI_VERSION_MASK_MICRO )
 253                                         &gt;&gt; JVMTI_VERSION_SHIFT_MICRO;
 254 
 255     /* Check for compatibility */
 256     if ( !compatible_versions(jvmtiMajorVersion(), jvmtiMinorVersion(),
 257                 jvmtiCompileTimeMajorVersion, jvmtiCompileTimeMinorVersion) ) {
 258 
 259         ERROR_MESSAGE((&quot;This jdwp native library will not work with this VM&#39;s &quot;
 260                        &quot;version of JVMTI (%d.%d.%d), it needs JVMTI %d.%d[.%d].&quot;,
 261                        jvmtiMajorVersion(),
 262                        jvmtiMinorVersion(),
 263                        jvmtiMicroVersion(),
 264                        jvmtiCompileTimeMajorVersion,
 265                        jvmtiCompileTimeMinorVersion,
 266                        jvmtiCompileTimeMicroVersion));
 267 
 268         /* Do not let VM get a fatal error, we don&#39;t want a core dump here. */
 269         forceExit(1); /* Kill entire process, no core dump wanted */
 270     }
 271 
 272     /* Parse input options */
 273     if (!parseOptions(options)) {
 274         /* No message necessary, should have been printed out already */
 275         /* Do not let VM get a fatal error, we don&#39;t want a core dump here. */
 276         forceExit(1); /* Kill entire process, no core dump wanted */
 277     }
 278 
 279     LOG_MISC((&quot;Onload: %s&quot;, options));
 280 
 281     /* Get potential capabilities */
 282     (void)memset(&amp;potential_capabilities,0,sizeof(potential_capabilities));
 283     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetPotentialCapabilities)
 284                 (gdata-&gt;jvmti, &amp;potential_capabilities);
 285     if (error != JVMTI_ERROR_NONE) {
 286         ERROR_MESSAGE((&quot;JDWP unable to get potential JVMTI capabilities: %s(%d)&quot;,
 287                         jvmtiErrorText(error), error));
 288         return JNI_ERR;
 289     }
 290 
 291     /* Fill in ones that we must have */
 292     (void)memset(&amp;needed_capabilities,0,sizeof(needed_capabilities));
 293     needed_capabilities.can_access_local_variables              = 1;
 294     needed_capabilities.can_generate_single_step_events         = 1;
 295     needed_capabilities.can_generate_exception_events           = 1;
 296     needed_capabilities.can_generate_frame_pop_events           = 1;
 297     needed_capabilities.can_generate_breakpoint_events          = 1;
 298     needed_capabilities.can_suspend                             = 1;
 299     needed_capabilities.can_generate_method_entry_events        = 1;
 300     needed_capabilities.can_generate_method_exit_events         = 1;
 301     needed_capabilities.can_generate_garbage_collection_events  = 1;
 302     needed_capabilities.can_maintain_original_method_order      = 1;
 303     needed_capabilities.can_generate_monitor_events             = 1;
 304     needed_capabilities.can_tag_objects                         = 1;
 305 
 306     /* And what potential ones that would be nice to have */
 307     needed_capabilities.can_force_early_return
 308                 = potential_capabilities.can_force_early_return;
 309     needed_capabilities.can_generate_field_modification_events
 310                 = potential_capabilities.can_generate_field_modification_events;
 311     needed_capabilities.can_generate_field_access_events
 312                 = potential_capabilities.can_generate_field_access_events;
 313     needed_capabilities.can_get_bytecodes
 314                 = potential_capabilities.can_get_bytecodes;
 315     needed_capabilities.can_get_synthetic_attribute
 316                 = potential_capabilities.can_get_synthetic_attribute;
 317     needed_capabilities.can_get_owned_monitor_info
 318                 = potential_capabilities.can_get_owned_monitor_info;
 319     needed_capabilities.can_get_current_contended_monitor
 320                 = potential_capabilities.can_get_current_contended_monitor;
 321     needed_capabilities.can_get_monitor_info
 322                 = potential_capabilities.can_get_monitor_info;
 323     needed_capabilities.can_pop_frame
 324                 = potential_capabilities.can_pop_frame;
 325     needed_capabilities.can_redefine_classes
 326                 = potential_capabilities.can_redefine_classes;
 327     needed_capabilities.can_redefine_any_class
 328                 = potential_capabilities.can_redefine_any_class;
 329     needed_capabilities.can_get_owned_monitor_stack_depth_info
 330         = potential_capabilities.can_get_owned_monitor_stack_depth_info;
 331     needed_capabilities.can_get_constant_pool
 332                 = potential_capabilities.can_get_constant_pool;
 333     {
 334         needed_capabilities.can_get_source_debug_extension      = 1;
 335         needed_capabilities.can_get_source_file_name            = 1;
 336         needed_capabilities.can_get_line_numbers                = 1;
 337         needed_capabilities.can_signal_thread
 338                 = potential_capabilities.can_signal_thread;
 339     }
 340 
 341     /* Add the capabilities */
 342     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,AddCapabilities)
 343                 (gdata-&gt;jvmti, &amp;needed_capabilities);
 344     if (error != JVMTI_ERROR_NONE) {
 345         ERROR_MESSAGE((&quot;JDWP unable to get necessary JVMTI capabilities.&quot;));
 346         forceExit(1); /* Kill entire process, no core dump wanted */
 347     }
 348 
 349     /* Initialize event number mapping tables */
 350     eventIndexInit();
 351 
 352     /* Set the initial JVMTI event notifications */
 353     error = set_event_notification(JVMTI_ENABLE, EI_VM_DEATH);
 354     if (error != JVMTI_ERROR_NONE) {
 355         return JNI_ERR;
 356     }
 357     error = set_event_notification(JVMTI_ENABLE, EI_VM_INIT);
 358     if (error != JVMTI_ERROR_NONE) {
 359         return JNI_ERR;
 360     }
 361     if (initOnUncaught || (initOnException != NULL)) {
 362         error = set_event_notification(JVMTI_ENABLE, EI_EXCEPTION);
 363         if (error != JVMTI_ERROR_NONE) {
 364             return JNI_ERR;
 365         }
 366     }
 367 
 368     /* Set callbacks just for 3 functions */
 369     (void)memset(&amp;(gdata-&gt;callbacks),0,sizeof(gdata-&gt;callbacks));
 370     gdata-&gt;callbacks.VMInit             = &amp;cbEarlyVMInit;
 371     gdata-&gt;callbacks.VMDeath            = &amp;cbEarlyVMDeath;
 372     gdata-&gt;callbacks.Exception  = &amp;cbEarlyException;
 373     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,SetEventCallbacks)
 374                 (gdata-&gt;jvmti, &amp;(gdata-&gt;callbacks), sizeof(gdata-&gt;callbacks));
 375     if (error != JVMTI_ERROR_NONE) {
 376         ERROR_MESSAGE((&quot;JDWP unable to set JVMTI event callbacks: %s(%d)&quot;,
 377                         jvmtiErrorText(error), error));
 378         return JNI_ERR;
 379     }
 380 
 381     LOG_MISC((&quot;OnLoad: DONE&quot;));
 382     return JNI_OK;
 383 }
 384 
 385 JNIEXPORT void JNICALL
 386 DEF_Agent_OnUnload(JavaVM *vm)
 387 {
 388 
 389     gdata-&gt;isLoaded = JNI_FALSE;
 390 
 391     /* Cleanup, but make sure VM is alive before using JNI, and
 392      *   make sure JVMTI environment is ok before deallocating
 393      *   memory allocated through JVMTI, which all of it is.
 394      */
 395 
 396     /*
 397      * Close transport before exit
 398      */
 399     if (transport_is_open()) {
 400         transport_close();
 401     }
 402 }
 403 
 404 /*
 405  * Phase 2: Initial events. Phase 2 consists of waiting for the
 406  * event that triggers full initialization. Under normal circumstances
 407  * (initOnStartup == TRUE) this is the JVMTI_EVENT_VM_INIT event.
 408  * Otherwise, we delay initialization until the app throws a
 409  * particular exception. The triggering event invokes
 410  * the bulk of the initialization, including creation of threads and
 411  * monitors, transport setup, and installation of a new event callback which
 412  * handles the complete set of events.
 413  *
 414  * Since the triggering event comes in on an application thread, some of the
 415  * initialization is difficult to do here. Specifically, this thread along
 416  * with all other app threads may need to be suspended until a debugger
 417  * connects. These kinds of tasks are left to the third phase which is
 418  * invoked by one of the spawned debugger threads, the event handler.
 419  */
 420 
 421 /*
 422  * Wait for a triggering event; then kick off debugger
 423  * initialization. A different event callback will be installed by
 424  * debugger initialization, and this function will not be called
 425  * again.
 426  */
 427 
 428     /*
 429      * TO DO: Decide whether we need to protect this code with
 430      * a lock. It might be too early to create a monitor safely (?).
 431      */
 432 
 433 static void JNICALL
 434 cbEarlyVMInit(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread)
 435 {
 436     LOG_CB((&quot;cbEarlyVMInit&quot;));
 437     if ( gdata-&gt;vmDead ) {
 438         EXIT_ERROR(AGENT_ERROR_INTERNAL,&quot;VM dead at VM_INIT time&quot;);
 439     }
 440     if (initOnStartup)
 441         initialize(env, thread, EI_VM_INIT);
 442     vmInitialized = JNI_TRUE;
 443     LOG_MISC((&quot;END cbEarlyVMInit&quot;));
 444 }
 445 
 446 static void
 447 disposeEnvironment(jvmtiEnv *jvmti_env)
 448 {
 449     jvmtiError error;
 450 
 451     error = JVMTI_FUNC_PTR(jvmti_env,DisposeEnvironment)(jvmti_env);
 452     if ( error == JVMTI_ERROR_MUST_POSSESS_CAPABILITY )
 453         error = JVMTI_ERROR_NONE;  /* Hack!  FIXUP when JVMTI has disposeEnv */
 454     /* What should error return say? */
 455     if (error != JVMTI_ERROR_NONE) {
 456         ERROR_MESSAGE((&quot;JDWP unable to dispose of JVMTI environment: %s(%d)&quot;,
 457                         jvmtiErrorText(error), error));
 458     }
 459     gdata-&gt;jvmti = NULL;
 460 }
 461 
 462 static void JNICALL
 463 cbEarlyVMDeath(jvmtiEnv *jvmti_env, JNIEnv *env)
 464 {
 465     LOG_CB((&quot;cbEarlyVMDeath&quot;));
 466     if ( gdata-&gt;vmDead ) {
 467         EXIT_ERROR(AGENT_ERROR_INTERNAL,&quot;VM died more than once&quot;);
 468     }
 469     disposeEnvironment(jvmti_env);
 470     gdata-&gt;jvmti = NULL;
 471     gdata-&gt;jvm = NULL;
 472     gdata-&gt;vmDead = JNI_TRUE;
 473     LOG_MISC((&quot;END cbEarlyVMDeath&quot;));
 474 }
 475 
 476 static void JNICALL
 477 cbEarlyException(jvmtiEnv *jvmti_env, JNIEnv *env,
 478         jthread thread, jmethodID method, jlocation location,
 479         jobject exception,
 480         jmethodID catch_method, jlocation catch_location)
 481 {
 482     jvmtiError error;
 483     jthrowable currentException;
 484 
 485     LOG_CB((&quot;cbEarlyException: thread=%p&quot;, thread));
 486 
 487     if ( gdata-&gt;vmDead ) {
 488         EXIT_ERROR(AGENT_ERROR_INTERNAL,&quot;VM dead at initial Exception event&quot;);
 489     }
 490     if (!vmInitialized)  {
 491         LOG_MISC((&quot;VM is not initialized yet&quot;));
 492         return;
 493     }
 494 
 495     /*
 496      * We want to preserve any current exception that might get wiped
 497      * out during event handling (e.g. JNI calls). We have to rely on
 498      * space for the local reference on the current frame because
 499      * doing a PushLocalFrame here might itself generate an exception.
 500      */
 501 
 502     currentException = JNI_FUNC_PTR(env,ExceptionOccurred)(env);
 503     JNI_FUNC_PTR(env,ExceptionClear)(env);
 504 
 505     if (initOnUncaught &amp;&amp; catch_method == NULL) {
 506 
 507         LOG_MISC((&quot;Initializing on uncaught exception&quot;));
 508         initialize(env, thread, EI_EXCEPTION);
 509 
 510     } else if (initOnException != NULL) {
 511 
 512         jclass clazz;
 513 
 514         /* Get class of exception thrown */
 515         clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, exception);
 516         if ( clazz != NULL ) {
 517             char *signature = NULL;
 518             /* initing on throw, check */
 519             error = classSignature(clazz, &amp;signature, NULL);
 520             LOG_MISC((&quot;Checking specific exception: looking for %s, got %s&quot;,
 521                         initOnException, signature));
 522             if ( (error==JVMTI_ERROR_NONE) &amp;&amp;
 523                 (strcmp(signature, initOnException) == 0)) {
 524                 LOG_MISC((&quot;Initializing on specific exception&quot;));
 525                 initialize(env, thread, EI_EXCEPTION);
 526             } else {
 527                 error = AGENT_ERROR_INTERNAL; /* Just to cause restore */
 528             }
 529             if ( signature != NULL ) {
 530                 jvmtiDeallocate(signature);
 531             }
 532         } else {
 533             error = AGENT_ERROR_INTERNAL; /* Just to cause restore */
 534         }
 535 
 536         /* If initialize didn&#39;t happen, we need to restore things */
 537         if ( error != JVMTI_ERROR_NONE ) {
 538             /*
 539              * Restore exception state from before callback call
 540              */
 541             LOG_MISC((&quot;No initialization, didn&#39;t find right exception&quot;));
 542             if (currentException != NULL) {
 543                 JNI_FUNC_PTR(env,Throw)(env, currentException);
 544             } else {
 545                 JNI_FUNC_PTR(env,ExceptionClear)(env);
 546             }
 547         }
 548 
 549     }
 550 
 551     LOG_MISC((&quot;END cbEarlyException&quot;));
 552 
 553 }
 554 
 555 typedef struct EnumerateArg {
 556     jboolean isServer;
 557     jdwpError error;
 558     jint startCount;
 559 } EnumerateArg;
 560 
 561 static jboolean
 562 startTransport(void *item, void *arg)
 563 {
 564     TransportSpec *transport = item;
 565     EnumerateArg *enumArg = arg;
 566     jdwpError serror;
 567 
 568     LOG_MISC((&quot;Begin startTransport&quot;));
 569     serror = transport_startTransport(enumArg-&gt;isServer, transport-&gt;name,
 570                                       transport-&gt;address, transport-&gt;timeout,
 571                                       transport-&gt;allow);
 572     if (serror != JDWP_ERROR(NONE)) {
 573         ERROR_MESSAGE((&quot;JDWP Transport %s failed to initialize, %s(%d)&quot;,
 574                 transport-&gt;name, jdwpErrorText(serror), serror));
 575         enumArg-&gt;error = serror;
 576     } else {
 577         /* (Don&#39;t overwrite any previous error) */
 578 
 579         enumArg-&gt;startCount++;
 580     }
 581 
 582     LOG_MISC((&quot;End startTransport&quot;));
 583 
 584     return JNI_TRUE;   /* Always continue, even if there was an error */
 585 }
 586 
 587 static void
 588 signalInitComplete(void)
 589 {
 590     /*
 591      * Initialization is complete
 592      */
 593     LOG_MISC((&quot;signal initialization complete&quot;));
 594     debugMonitorEnter(initMonitor);
 595     initComplete = JNI_TRUE;
 596     debugMonitorNotifyAll(initMonitor);
 597     debugMonitorExit(initMonitor);
 598 }
 599 
 600 /*
 601  * Determine if  initialization is complete.
 602  */
 603 jboolean
 604 debugInit_isInitComplete(void)
 605 {
 606     return initComplete;
 607 }
 608 
 609 /*
 610  * Wait for all initialization to complete.
 611  */
 612 void
 613 debugInit_waitInitComplete(void)
 614 {
 615     debugMonitorEnter(initMonitor);
 616     while (!initComplete) {
 617         debugMonitorWait(initMonitor);
 618     }
 619     debugMonitorExit(initMonitor);
 620 }
 621 
 622 /* All process exit() calls come from here */
 623 void
 624 forceExit(int exit_code)
 625 {
 626     /* make sure the transport is closed down before we exit() */
 627     transport_close();
 628     exit(exit_code);
 629 }
 630 
 631 /* All JVM fatal error exits lead here (e.g. we need to kill the VM). */
 632 static void
 633 jniFatalError(JNIEnv *env, const char *msg, jvmtiError error, int exit_code)
 634 {
 635     JavaVM *vm;
 636     char buf[512];
 637 
 638     gdata-&gt;vmDead = JNI_TRUE;
 639     if ( msg==NULL )
 640         msg = &quot;UNKNOWN REASON&quot;;
 641     vm = gdata-&gt;jvm;
 642     if ( env==NULL &amp;&amp; vm!=NULL ) {
 643         jint rc = (*((*vm)-&gt;GetEnv))(vm, (void **)&amp;env, JNI_VERSION_1_2);
 644         if (rc != JNI_OK ) {
 645             env = NULL;
 646         }
 647     }
 648     if ( error != JVMTI_ERROR_NONE ) {
 649         (void)snprintf(buf, sizeof(buf), &quot;JDWP %s, jvmtiError=%s(%d)&quot;,
 650                     msg, jvmtiErrorText(error), error);
 651     } else {
 652         (void)snprintf(buf, sizeof(buf), &quot;JDWP %s&quot;, msg);
 653     }
 654     if (env != NULL) {
 655         (*((*env)-&gt;FatalError))(env, buf);
 656     } else {
 657         /* Should rarely ever reach here, means VM is really dead */
 658         print_message(stderr, &quot;ERROR: JDWP: &quot;, &quot;\n&quot;,
 659                 &quot;Can&#39;t call JNI FatalError(NULL, \&quot;%s\&quot;)&quot;, buf);
 660     }
 661     forceExit(exit_code);
 662 }
 663 
 664 /*
 665  * Initialize debugger back end modules
 666  */
 667 static void
 668 initialize(JNIEnv *env, jthread thread, EventIndex triggering_ei)
 669 {
 670     jvmtiError error;
 671     EnumerateArg arg;
 672     jbyte suspendPolicy;
 673 
 674     LOG_MISC((&quot;Begin initialize()&quot;));
 675     currentSessionID = 0;
 676     initComplete = JNI_FALSE;
 677 
 678     if ( gdata-&gt;vmDead ) {
 679         EXIT_ERROR(AGENT_ERROR_INTERNAL,&quot;VM dead at initialize() time&quot;);
 680     }
 681 
 682     /* Turn off the initial JVMTI event notifications */
 683     error = set_event_notification(JVMTI_DISABLE, EI_EXCEPTION);
 684     if (error != JVMTI_ERROR_NONE) {
 685         EXIT_ERROR(error, &quot;unable to disable JVMTI event notification&quot;);
 686     }
 687     error = set_event_notification(JVMTI_DISABLE, EI_VM_INIT);
 688     if (error != JVMTI_ERROR_NONE) {
 689         EXIT_ERROR(error, &quot;unable to disable JVMTI event notification&quot;);
 690     }
 691     error = set_event_notification(JVMTI_DISABLE, EI_VM_DEATH);
 692     if (error != JVMTI_ERROR_NONE) {
 693         EXIT_ERROR(error, &quot;unable to disable JVMTI event notification&quot;);
 694     }
 695 
 696     /* Remove initial event callbacks */
 697     (void)memset(&amp;(gdata-&gt;callbacks),0,sizeof(gdata-&gt;callbacks));
 698     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,SetEventCallbacks)
 699                 (gdata-&gt;jvmti, &amp;(gdata-&gt;callbacks), sizeof(gdata-&gt;callbacks));
 700     if (error != JVMTI_ERROR_NONE) {
 701         EXIT_ERROR(error, &quot;unable to clear JVMTI callbacks&quot;);
 702     }
 703 
 704     commonRef_initialize();
 705     util_initialize(env);
 706     threadControl_initialize();
 707     stepControl_initialize();
 708     invoker_initialize();
 709     debugDispatch_initialize();
 710     classTrack_initialize(env);
 711     debugLoop_initialize();
 712 
 713     initMonitor = debugMonitorCreate(&quot;JDWP Initialization Monitor&quot;);
 714 
 715 
 716     /*
 717      * Initialize transports
 718      */
 719     arg.isServer = isServer;
 720     arg.error = JDWP_ERROR(NONE);
 721     arg.startCount = 0;
 722 
 723     transport_initialize();
 724     (void)bagEnumerateOver(transports, startTransport, &amp;arg);
 725 
 726     /*
 727      * Exit with an error only if
 728      * 1) none of the transports was successfully started, and
 729      * 2) the application has not yet started running
 730      */
 731     if ((arg.error != JDWP_ERROR(NONE)) &amp;&amp;
 732         (arg.startCount == 0) &amp;&amp;
 733         initOnStartup) {
 734         EXIT_ERROR(map2jvmtiError(arg.error), &quot;No transports initialized&quot;);
 735     }
 736 
 737     eventHandler_initialize(currentSessionID);
 738 
 739     signalInitComplete();
 740 
 741     transport_waitForConnection();
 742 
 743     suspendPolicy = suspendOnInit ? JDWP_SUSPEND_POLICY(ALL)
 744                                   : JDWP_SUSPEND_POLICY(NONE);
 745     if (triggering_ei == EI_VM_INIT) {
 746         LOG_MISC((&quot;triggering_ei == EI_VM_INIT&quot;));
 747         eventHelper_reportVMInit(env, currentSessionID, thread, suspendPolicy);
 748     } else {
 749         /*
 750          * TO DO: Kludgy way of getting the triggering event to the
 751          * just-attached debugger. It would be nice to make this a little
 752          * cleaner. There is also a race condition where other events
 753          * can get in the queue (from other not-yet-suspended threads)
 754          * before this one does. (Also need to handle allocation error below?)
 755          */
 756         EventInfo info;
 757         struct bag *initEventBag;
 758         LOG_MISC((&quot;triggering_ei != EI_VM_INIT&quot;));
 759         initEventBag = eventHelper_createEventBag();
 760         (void)memset(&amp;info,0,sizeof(info));
 761         info.ei = triggering_ei;
 762         eventHelper_recordEvent(&amp;info, 0, suspendPolicy, initEventBag);
 763         (void)eventHelper_reportEvents(currentSessionID, initEventBag);
 764         bagDestroyBag(initEventBag);
 765     }
 766 
 767     if ( gdata-&gt;vmDead ) {
 768         EXIT_ERROR(AGENT_ERROR_INTERNAL,&quot;VM dead before initialize() completes&quot;);
 769     }
 770     LOG_MISC((&quot;End initialize()&quot;));
 771 }
 772 
 773 /*
 774  * Restore all static data to the initialized state so that another
 775  * debugger can connect properly later.
 776  */
 777 void
 778 debugInit_reset(JNIEnv *env)
 779 {
 780     EnumerateArg arg;
 781 
 782     LOG_MISC((&quot;debugInit_reset() beginning&quot;));
 783 
 784     currentSessionID++;
 785     initComplete = JNI_FALSE;
 786 
 787     eventHandler_reset(currentSessionID);
 788     transport_reset();
 789     debugDispatch_reset();
 790     invoker_reset();
 791     stepControl_reset();
 792     threadControl_reset();
 793     util_reset();
 794     commonRef_reset(env);
 795     classTrack_reset();
 796 
 797     /*
 798      * If this is a server, we are now ready to accept another connection.
 799      * If it&#39;s a client, then we&#39;ve cleaned up some (more should be added
 800      * later) and we&#39;re done.
 801      */
 802     if (isServer) {
 803         arg.isServer = JNI_TRUE;
 804         arg.error = JDWP_ERROR(NONE);
 805         arg.startCount = 0;
 806         (void)bagEnumerateOver(transports, startTransport, &amp;arg);
 807 
 808         signalInitComplete();
 809 
 810         transport_waitForConnection();
 811     } else {
 812         signalInitComplete(); /* Why? */
 813     }
 814 
 815     LOG_MISC((&quot;debugInit_reset() completed.&quot;));
 816 }
 817 
 818 
 819 char *
 820 debugInit_launchOnInit(void)
 821 {
 822     return launchOnInit;
 823 }
 824 
 825 jboolean
 826 debugInit_suspendOnInit(void)
 827 {
 828     return suspendOnInit;
 829 }
 830 
 831 /*
 832  * code below is shamelessly swiped from hprof.
 833  */
 834 
 835 static int
 836 get_tok(char **src, char *buf, int buflen, char sep)
 837 {
 838     int i;
 839     char *p = *src;
 840     for (i = 0; i &lt; buflen; i++) {
 841         if (p[i] == 0 || p[i] == sep) {
 842             buf[i] = 0;
 843             if (p[i] == sep) {
 844                 i++;
 845             }
 846             *src += i;
 847             return i;
 848         }
 849         buf[i] = p[i];
 850     }
 851     /* overflow */
 852     return 0;
 853 }
 854 
 855 static void
 856 printUsage(void)
 857 {
 858      TTY_MESSAGE((
 859  &quot;               Java Debugger JDWP Agent Library\n&quot;
 860  &quot;               --------------------------------\n&quot;
 861  &quot;\n&quot;
 862  &quot;  (see http://java.sun.com/products/jpda for more information)\n&quot;
 863  &quot;\n&quot;
 864  &quot;jdwp usage: java &quot; AGENTLIB &quot;=[help]|[&lt;option&gt;=&lt;value&gt;, ...]\n&quot;
 865  &quot;\n&quot;
 866  &quot;Option Name and Value            Description                       Default\n&quot;
 867  &quot;---------------------            -----------                       -------\n&quot;
 868  &quot;suspend=y|n                      wait on startup?                  y\n&quot;
 869  &quot;transport=&lt;name&gt;                 transport spec                    none\n&quot;
 870  &quot;address=&lt;listen/attach address&gt;  transport spec                    \&quot;\&quot;\n&quot;
 871  &quot;server=y|n                       listen for debugger?              n\n&quot;
 872  &quot;launch=&lt;command line&gt;            run debugger on event             none\n&quot;
 873  &quot;onthrow=&lt;exception name&gt;         debug on throw                    none\n&quot;
 874  &quot;onuncaught=y|n                   debug on any uncaught?            n\n&quot;
 875  &quot;timeout=&lt;timeout value&gt;          for listen/attach in milliseconds n\n&quot;
 876  &quot;mutf8=y|n                        output modified utf-8             n\n&quot;
 877  &quot;quiet=y|n                        control over terminal messages    n\n&quot;));
 878 
 879     TTY_MESSAGE((
 880  &quot;Obsolete Options\n&quot;
 881  &quot;----------------\n&quot;
 882  &quot;strict=y|n\n&quot;
 883  &quot;stdalloc=y|n\n&quot;
 884  &quot;\n&quot;
 885  &quot;Examples\n&quot;
 886  &quot;--------\n&quot;
 887  &quot;  - Using sockets connect to a debugger at a specific address:\n&quot;
 888  &quot;    java &quot; AGENTLIB &quot;=transport=dt_socket,address=localhost:8000 ...\n&quot;
 889  &quot;  - Using sockets listen for a debugger to attach:\n&quot;
 890  &quot;    java &quot; AGENTLIB &quot;=transport=dt_socket,server=y,suspend=y ...\n&quot;
 891  &quot;\n&quot;
 892  &quot;Notes\n&quot;
 893  &quot;-----\n&quot;
 894  &quot;  - A timeout value of 0 (the default) is no timeout.\n&quot;
 895  &quot;\n&quot;
 896  &quot;Warnings\n&quot;
 897  &quot;--------\n&quot;
 898  &quot;  - The older &quot; XRUN &quot; interface can still be used, but will be removed in\n&quot;
 899  &quot;    a future release, for example:\n&quot;
 900  &quot;        java &quot; XRUN &quot;:[help]|[&lt;option&gt;=&lt;value&gt;, ...]\n&quot;
 901     ));
 902 
 903 #ifdef DEBUG
 904 
 905      TTY_MESSAGE((
 906  &quot;\n&quot;
 907  &quot;Debugging Options            Description                       Default\n&quot;
 908  &quot;-----------------            -----------                       -------\n&quot;
 909  &quot;pause=y|n                    pause to debug PID                n\n&quot;
 910  &quot;coredump=y|n                 coredump at exit                  n\n&quot;
 911  &quot;errorexit=y|n                exit on any error                 n\n&quot;
 912  &quot;logfile=filename             name of log file                  none\n&quot;
 913  &quot;logflags=flags               log flags (bitmask)               none\n&quot;
 914  &quot;                               JVM calls     = 0x001\n&quot;
 915  &quot;                               JNI calls     = 0x002\n&quot;
 916  &quot;                               JVMTI calls   = 0x004\n&quot;
 917  &quot;                               misc events   = 0x008\n&quot;
 918  &quot;                               step logs     = 0x010\n&quot;
 919  &quot;                               locations     = 0x020\n&quot;
 920  &quot;                               callbacks     = 0x040\n&quot;
 921  &quot;                               errors        = 0x080\n&quot;
 922  &quot;                               everything    = 0xfff&quot;));
 923 
 924     TTY_MESSAGE((
 925  &quot;debugflags=flags             debug flags (bitmask)           none\n&quot;
 926  &quot;                               USE_ITERATE_THROUGH_HEAP 0x01\n&quot;
 927  &quot;\n&quot;
 928  &quot;Environment Variables\n&quot;
 929  &quot;---------------------\n&quot;
 930  &quot;_JAVA_JDWP_OPTIONS\n&quot;
 931  &quot;    Options can be added externally via this environment variable.\n&quot;
 932  &quot;    Anything contained in it will get a comma prepended to it (if needed),\n&quot;
 933  &quot;    then it will be added to the end of the options supplied via the\n&quot;
 934  &quot;    &quot; XRUN &quot; or &quot; AGENTLIB &quot; command line option.\n&quot;
 935     ));
 936 
 937 #endif
 938 
 939 
 940 
 941 }
 942 
 943 static jboolean checkAddress(void *bagItem, void *arg)
 944 {
 945     TransportSpec *spec = (TransportSpec *)bagItem;
 946     if (spec-&gt;address == NULL) {
 947         ERROR_MESSAGE((&quot;JDWP Non-server transport %s must have a connection &quot;
 948                 &quot;address specified through the &#39;address=&#39; option&quot;,
 949                 spec-&gt;name));
 950         return JNI_FALSE;
 951     } else {
 952         return JNI_TRUE;
 953     }
 954 }
 955 
 956 static  char *
 957 add_to_options(char *options, char *new_options)
 958 {
 959     size_t originalLength;
 960     char *combinedOptions;
 961 
 962     /*
 963      * Allocate enough space for both strings and
 964      * comma in between.
 965      */
 966     originalLength = strlen(options);
 967     combinedOptions = jvmtiAllocate((jint)originalLength + 1 +
 968                                 (jint)strlen(new_options) + 1);
 969     if (combinedOptions == NULL) {
 970         return NULL;
 971     }
 972 
 973     (void)strcpy(combinedOptions, options);
 974     (void)strcat(combinedOptions, &quot;,&quot;);
 975     (void)strcat(combinedOptions, new_options);
 976 
 977     return combinedOptions;
 978 }
 979 
 980 static jboolean
 981 get_boolean(char **pstr, jboolean *answer)
 982 {
 983     char buf[80];
 984     *answer = JNI_FALSE;
 985     /*LINTED*/
 986     if (get_tok(pstr, buf, (int)sizeof(buf), &#39;,&#39;)) {
 987         if (strcmp(buf, &quot;y&quot;) == 0) {
 988             *answer = JNI_TRUE;
 989             return JNI_TRUE;
 990         } else if (strcmp(buf, &quot;n&quot;) == 0) {
 991             *answer = JNI_FALSE;
 992             return JNI_TRUE;
 993         }
 994     }
 995     return JNI_FALSE;
 996 }
 997 
 998 /* atexit() callback */
 999 static void
1000 atexit_finish_logging(void)
1001 {
1002     /* Normal exit(0) (not _exit()) may only reach here */
1003     finish_logging();  /* Only first call matters */
1004 }
1005 
1006 static jboolean
1007 parseOptions(char *options)
1008 {
1009     TransportSpec *currentTransport = NULL;
1010     char *end;
1011     char *current;
1012     int length;
1013     char *str;
1014     char *errmsg;
1015     jboolean onJcmd = JNI_FALSE;
1016 
1017     /* Set defaults */
1018     gdata-&gt;assertOn     = DEFAULT_ASSERT_ON;
1019     gdata-&gt;assertFatal  = DEFAULT_ASSERT_FATAL;
1020     logfile             = DEFAULT_LOGFILE;
1021 
1022     /* Options being NULL will end up being an error. */
1023     if (options == NULL) {
1024         options = &quot;&quot;;
1025     }
1026 
1027     /* Check for &quot;help&quot; BEFORE we add any environmental settings */
1028     if ((strcmp(options, &quot;help&quot;)) == 0) {
1029         printUsage();
1030         forceExit(0); /* Kill entire process, no core dump wanted */
1031     }
1032 
1033     /* These buffers are never freed */
1034     {
1035         char *envOptions;
1036 
1037         /*
1038          * Add environmentally specified options.
1039          */
1040         envOptions = getenv(&quot;_JAVA_JDWP_OPTIONS&quot;);
1041         if (envOptions != NULL) {
1042             options = add_to_options(options, envOptions);
1043             if ( options==NULL ) {
1044                 EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;options&quot;);
1045             }
1046         }
1047 
1048         /*
1049          * Allocate a buffer for names derived from option strings. It should
1050          * never be longer than the original options string itself.
1051          * Also keep a copy of the options in gdata-&gt;options.
1052          */
1053         length = (int)strlen(options);
1054         gdata-&gt;options = jvmtiAllocate(length + 1);
1055         if (gdata-&gt;options == NULL) {
1056             EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;options&quot;);
1057         }
1058         (void)strcpy(gdata-&gt;options, options);
1059         names = jvmtiAllocate(length + 1);
1060         if (names == NULL) {
1061             EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;options&quot;);
1062         }
1063 
1064         transports = bagCreateBag(sizeof(TransportSpec), 3);
1065         if (transports == NULL) {
1066             EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;transports&quot;);
1067         }
1068     }
1069 
1070     current = names;
1071     end = names + length;
1072     str = options;
1073 
1074     while (*str) {
1075         char buf[100];
1076         /*LINTED*/
1077         if (!get_tok(&amp;str, buf, (int)sizeof(buf), &#39;=&#39;)) {
1078             goto syntax_error;
1079         }
1080         if (strcmp(buf, &quot;transport&quot;) == 0) {
1081             currentTransport = bagAdd(transports);
1082             /*LINTED*/
1083             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1084                 goto syntax_error;
1085             }
1086             currentTransport-&gt;name = current;
1087             currentTransport-&gt;address = NULL;
1088             currentTransport-&gt;allow = NULL;
1089             currentTransport-&gt;timeout = 0L;
1090             current += strlen(current) + 1;
1091         } else if (strcmp(buf, &quot;address&quot;) == 0) {
1092             if (currentTransport == NULL) {
1093                 errmsg = &quot;address specified without transport&quot;;
1094                 goto bad_option_with_errmsg;
1095             }
1096             /*LINTED*/
1097             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1098                 goto syntax_error;
1099             }
1100             currentTransport-&gt;address = current;
1101             current += strlen(current) + 1;
1102         } else if (strcmp(buf, &quot;allow&quot;) == 0) {
1103             if (currentTransport == NULL) {
1104                 errmsg = &quot;allow specified without transport&quot;;
1105                 goto bad_option_with_errmsg;
1106             }
1107             /*LINTED*/
1108             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1109                 goto syntax_error;
1110             }
1111             currentTransport-&gt;allow = current;
1112             current += strlen(current) + 1;
1113          } else if (strcmp(buf, &quot;timeout&quot;) == 0) {
1114             if (currentTransport == NULL) {
1115                 errmsg = &quot;timeout specified without transport&quot;;
1116                 goto bad_option_with_errmsg;
1117             }
1118             /*LINTED*/
1119             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1120                 goto syntax_error;
1121             }
1122             currentTransport-&gt;timeout = atol(current);
1123             current += strlen(current) + 1;
1124         } else if (strcmp(buf, &quot;launch&quot;) == 0) {
1125             /*LINTED*/
1126             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1127                 goto syntax_error;
1128             }
1129             launchOnInit = current;
1130             current += strlen(current) + 1;
1131         } else if (strcmp(buf, &quot;onthrow&quot;) == 0) {
1132             /* Read class name and convert in place to a signature */
1133             *current = &#39;L&#39;;
1134             /*LINTED*/
1135             if (!get_tok(&amp;str, current + 1, (int)(end - current - 1), &#39;,&#39;)) {
1136                 goto syntax_error;
1137             }
1138             initOnException = current;
1139             while (*current != &#39;\0&#39;) {
1140                 if (*current == &#39;.&#39;) {
1141                     *current = &#39;/&#39;;
1142                 }
1143                 current++;
1144             }
1145             *current++ = &#39;;&#39;;
1146             *current++ = &#39;\0&#39;;
1147         } else if (strcmp(buf, &quot;assert&quot;) == 0) {
1148             /*LINTED*/
1149             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1150                 goto syntax_error;
1151             }
1152             if (strcmp(current, &quot;y&quot;) == 0) {
1153                 gdata-&gt;assertOn = JNI_TRUE;
1154                 gdata-&gt;assertFatal = JNI_FALSE;
1155             } else if (strcmp(current, &quot;fatal&quot;) == 0) {
1156                 gdata-&gt;assertOn = JNI_TRUE;
1157                 gdata-&gt;assertFatal = JNI_TRUE;
1158             } else if (strcmp(current, &quot;n&quot;) == 0) {
1159                 gdata-&gt;assertOn = JNI_FALSE;
1160                 gdata-&gt;assertFatal = JNI_FALSE;
1161             } else {
1162                 goto syntax_error;
1163             }
1164             current += strlen(current) + 1;
1165         } else if (strcmp(buf, &quot;pause&quot;) == 0) {
1166             if ( !get_boolean(&amp;str, &amp;dopause) ) {
1167                 goto syntax_error;
1168             }
1169             if ( dopause ) {
1170                 do_pause();
1171             }
1172         } else if (strcmp(buf, &quot;coredump&quot;) == 0) {
1173             if ( !get_boolean(&amp;str, &amp;docoredump) ) {
1174                 goto syntax_error;
1175             }
1176         } else if (strcmp(buf, &quot;errorexit&quot;) == 0) {
1177             if ( !get_boolean(&amp;str, &amp;(gdata-&gt;doerrorexit)) ) {
1178                 goto syntax_error;
1179             }
1180         } else if (strcmp(buf, &quot;exitpause&quot;) == 0) {
1181             errmsg = &quot;The exitpause option removed, use -XX:OnError&quot;;
1182             goto bad_option_with_errmsg;
1183         } else if (strcmp(buf, &quot;precrash&quot;) == 0) {
1184             errmsg = &quot;The precrash option removed, use -XX:OnError&quot;;
1185             goto bad_option_with_errmsg;
1186         } else if (strcmp(buf, &quot;logfile&quot;) == 0) {
1187             /*LINTED*/
1188             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1189                 goto syntax_error;
1190             }
1191             logfile = current;
1192             current += strlen(current) + 1;
1193         } else if (strcmp(buf, &quot;logflags&quot;) == 0) {
1194             /*LINTED*/
1195             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1196                 goto syntax_error;
1197             }
1198             /*LINTED*/
1199             logflags = (unsigned)strtol(current, NULL, 0);
1200         } else if (strcmp(buf, &quot;debugflags&quot;) == 0) {
1201             /*LINTED*/
1202             if (!get_tok(&amp;str, current, (int)(end - current), &#39;,&#39;)) {
1203                 goto syntax_error;
1204             }
1205             /*LINTED*/
1206             gdata-&gt;debugflags = (unsigned)strtol(current, NULL, 0);
1207         } else if ( strcmp(buf, &quot;suspend&quot;)==0 ) {
1208             if ( !get_boolean(&amp;str, &amp;suspendOnInit) ) {
1209                 goto syntax_error;
1210             }
1211         } else if ( strcmp(buf, &quot;server&quot;)==0 ) {
1212             if ( !get_boolean(&amp;str, &amp;isServer) ) {
1213                 goto syntax_error;
1214             }
1215         } else if ( strcmp(buf, &quot;strict&quot;)==0 ) { /* Obsolete, but accept it */
1216             if ( !get_boolean(&amp;str, &amp;isStrict) ) {
1217                 goto syntax_error;
1218             }
1219         } else if ( strcmp(buf, &quot;quiet&quot;)==0 ) {
1220             if ( !get_boolean(&amp;str, &amp;(gdata-&gt;quiet)) ) {
1221                 goto syntax_error;
1222             }
1223         } else if ( strcmp(buf, &quot;onuncaught&quot;)==0 ) {
1224             if ( !get_boolean(&amp;str, &amp;initOnUncaught) ) {
1225                 goto syntax_error;
1226             }
1227         } else if ( strcmp(buf, &quot;mutf8&quot;)==0 ) {
1228             if ( !get_boolean(&amp;str, &amp;(gdata-&gt;modifiedUtf8)) ) {
1229                 goto syntax_error;
1230             }
1231         } else if ( strcmp(buf, &quot;stdalloc&quot;)==0 ) { /* Obsolete, but accept it */
1232             if ( !get_boolean(&amp;str, &amp;useStandardAlloc) ) {
1233                 goto syntax_error;
1234             }
1235         } else if (strcmp(buf, &quot;onjcmd&quot;) == 0) {
1236             if (!get_boolean(&amp;str, &amp;onJcmd)) {
1237                 goto syntax_error;
1238             }
1239         } else {
1240             goto syntax_error;
1241         }
1242     }
1243 
1244     /* Setup logging now */
1245     if ( logfile!=NULL ) {
1246         setup_logging(logfile, logflags);
1247         (void)atexit(&amp;atexit_finish_logging);
1248     }
1249 
1250     if (bagSize(transports) == 0) {
1251         errmsg = &quot;no transport specified&quot;;
1252         goto bad_option_with_errmsg;
1253     }
1254 
1255     /*
1256      * TO DO: Remove when multiple transports are allowed. (replace with
1257      * check below.
1258      */
1259     if (bagSize(transports) &gt; 1) {
1260         errmsg = &quot;multiple transports are not supported in this release&quot;;
1261         goto bad_option_with_errmsg;
1262     }
1263 
1264     if (!isServer) {
1265         jboolean specified = bagEnumerateOver(transports, checkAddress, NULL);
1266         if (!specified) {
1267             /* message already printed */
1268             goto bad_option_no_msg;
1269         }
1270     }
1271 
1272     /*
1273      * The user has selected to wait for an exception before init happens
1274      */
1275     if ((initOnException != NULL) || (initOnUncaught)) {
1276         initOnStartup = JNI_FALSE;
1277 
1278         if (launchOnInit == NULL) {
1279             /*
1280              * These rely on the launch=/usr/bin/foo
1281              * suboption, so it is an error if user did not
1282              * provide one.
1283              */
1284             errmsg = &quot;Specify launch=&lt;command line&gt; when using onthrow or onuncaught suboption&quot;;
1285             goto bad_option_with_errmsg;
1286         }
1287     }
1288 
1289     if (onJcmd) {
1290         if (launchOnInit != NULL) {
1291             errmsg = &quot;Cannot combine onjcmd and launch suboptions&quot;;
1292             goto bad_option_with_errmsg;
1293         }
1294         if (!isServer) {
1295             errmsg = &quot;Can only use onjcmd with server=y&quot;;
1296             goto bad_option_with_errmsg;
1297         }
1298         suspendOnInit = JNI_FALSE;
1299         initOnStartup = JNI_FALSE;
1300         allowStartViaJcmd = JNI_TRUE;
1301     }
1302 
1303     return JNI_TRUE;
1304 
1305 syntax_error:
1306     ERROR_MESSAGE((&quot;JDWP option syntax error: %s=%s&quot;, AGENTLIB, options));
1307     return JNI_FALSE;
1308 
1309 bad_option_with_errmsg:
1310     ERROR_MESSAGE((&quot;JDWP %s: %s=%s&quot;, errmsg, AGENTLIB, options));
1311     return JNI_FALSE;
1312 
1313 bad_option_no_msg:
1314     ERROR_MESSAGE((&quot;JDWP %s: %s=%s&quot;, &quot;invalid option&quot;, AGENTLIB, options));
1315     return JNI_FALSE;
1316 }
1317 
1318 /* All normal exit doors lead here */
1319 void
1320 debugInit_exit(jvmtiError error, const char *msg)
1321 {
1322     enum exit_codes { EXIT_NO_ERRORS = 0, EXIT_JVMTI_ERROR = 1, EXIT_TRANSPORT_ERROR = 2 };
1323 
1324     // Release commandLoop vmDeathLock if necessary
1325     commandLoop_exitVmDeathLockOnError();
1326 
1327     // Prepare to exit. Log error and finish logging
1328     LOG_MISC((&quot;Exiting with error %s(%d): %s&quot;, jvmtiErrorText(error), error,
1329                                                ((msg == NULL) ? &quot;&quot; : msg)));
1330 
1331     // coredump requested by command line. Keep JVMTI data dirty
1332     if (error != JVMTI_ERROR_NONE &amp;&amp; docoredump) {
1333         LOG_MISC((&quot;Dumping core as requested by command line&quot;));
1334         finish_logging();
1335         abort();
1336     }
1337 
1338     finish_logging();
1339 
1340     // Cleanup the JVMTI if we have one
1341     if (gdata != NULL) {
1342         gdata-&gt;vmDead = JNI_TRUE;
1343         if (gdata-&gt;jvmti != NULL) {
1344             // Dispose of jvmti (gdata-&gt;jvmti becomes NULL)
1345             disposeEnvironment(gdata-&gt;jvmti);
1346         }
1347     }
1348 
1349     // We are here with no errors. Kill entire process and exit with zero exit code
1350     if (error == JVMTI_ERROR_NONE) {
1351         forceExit(EXIT_NO_ERRORS);
1352         return;
1353     }
1354 
1355     // No transport initilized.
1356     // As we don&#39;t have any details here exiting with separate exit code
1357     if (error == AGENT_ERROR_TRANSPORT_INIT) {
1358         forceExit(EXIT_TRANSPORT_ERROR);
1359         return;
1360     }
1361 
1362     // We have JVMTI error. Call hotspot jni_FatalError handler
1363     jniFatalError(NULL, msg, error, EXIT_JVMTI_ERROR);
1364 
1365     // hotspot calls os:abort() so we should never reach code below,
1366     // but guard against possible hotspot changes
1367 
1368     // Last chance to die, this kills the entire process.
1369     forceExit(EXIT_JVMTI_ERROR);
1370 }
1371 
1372 static jboolean getFirstTransport(void *item, void *arg)
1373 {
1374     TransportSpec** store = arg;
1375     *store = item;
1376 
1377     return JNI_FALSE; /* Want the first */
1378 }
1379 
1380 /* Call to start up debugging. */
1381 JNIEXPORT char const* JNICALL debugInit_startDebuggingViaCommand(JNIEnv* env, jthread thread, char const** transport_name,
1382                                                                 char const** address, jboolean* first_start) {
1383     jboolean is_first_start = JNI_FALSE;
1384     TransportSpec* spec = NULL;
1385 
1386     if (!vmInitialized) {
1387         return &quot;Not yet initialized. Try again later.&quot;;
1388     }
1389 
1390     if (!allowStartViaJcmd) {
1391         return &quot;Starting debugging via jcmd was not enabled via the onjcmd option of the jdwp agent.&quot;;
1392     }
1393 
1394     if (!startedViaJcmd) {
1395         startedViaJcmd = JNI_TRUE;
1396         is_first_start = JNI_TRUE;
1397         initialize(env, thread, EI_VM_INIT);
1398     }
1399 
1400     bagEnumerateOver(transports, getFirstTransport, &amp;spec);
1401 
1402     if ((spec != NULL) &amp;&amp; (transport_name != NULL) &amp;&amp; (address != NULL)) {
1403         *transport_name = spec-&gt;name;
1404         *address = spec-&gt;address;
1405     }
1406 
1407     if (first_start != NULL) {
1408         *first_start = is_first_start;
1409     }
1410 
1411     return NULL;
1412 }
    </pre>
  </body>
</html>
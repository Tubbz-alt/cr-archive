<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.management/share/classes/javax/management/MXBean.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="InvalidApplicationException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NotificationBroadcaster.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.management/share/classes/javax/management/MXBean.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  62     public interface WhatsitMXBean {}
  63 
  64     &amp;#64;MXBean
  65     public interface Whatsit1Interface {}
  66 
  67     &amp;#64;MXBean(true)
  68     public interface Whatsit2Interface {}
  69     &lt;/pre&gt;
  70 
  71     &lt;p&gt;The following interfaces are not MXBean interfaces:&lt;/p&gt;
  72 
  73     &lt;pre&gt;
  74     interface NonPublicInterfaceNotMXBean{}
  75 
  76     public interface Whatsit3Interface{}
  77 
  78     &amp;#64;MXBean(false)
  79     public interface MisleadingMXBean {}
  80     &lt;/pre&gt;
  81 
<span class="line-modified">  82     &lt;h3 id=&quot;MXBean-spec&quot;&gt;MXBean specification&lt;/h3&gt;</span>
  83 
  84     &lt;p&gt;The MXBean concept provides a simple way to code an MBean
  85       that only references a predefined set of types, the ones defined
  86       by {@link javax.management.openmbean}.  In this way, you can be
  87       sure that your MBean will be usable by any client, including
  88       remote clients, without any requirement that the client have
  89       access to &lt;em&gt;model-specific classes&lt;/em&gt; representing the types
  90       of your MBeans.&lt;/p&gt;
  91 
  92     &lt;p&gt;The concepts are easier to understand by comparison with the
  93       Standard MBean concept.  Here is how a managed object might be
  94       represented as a Standard MBean, and as an MXBean:&lt;/p&gt;
  95 
  96     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified">  97         &lt;h4&gt;Standard MBean&lt;/h4&gt;</span>
  98         &lt;pre&gt;
  99 public interface MemoryPool&lt;b&gt;MBean&lt;/b&gt; {
 100     String getName();
 101     MemoryUsage getUsage();
 102     // ...
 103 }
 104           &lt;/pre&gt;
 105     &lt;/div&gt;
 106     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 107         &lt;h4&gt;MXBean&lt;/h4&gt;</span>
 108         &lt;pre&gt;
 109 public interface MemoryPool&lt;b&gt;MXBean&lt;/b&gt; {
 110     String getName();
 111     MemoryUsage getUsage();
 112     // ...
 113 }
 114           &lt;/pre&gt;
 115     &lt;/div&gt;
 116 
 117     &lt;p&gt;As you can see, the definitions are very similar.  The only
 118       difference is that the convention for naming the interface is to use
 119       &lt;code&gt;&lt;em&gt;Something&lt;/em&gt;MXBean&lt;/code&gt; for MXBeans, rather than
 120       &lt;code&gt;&lt;em&gt;Something&lt;/em&gt;MBean&lt;/code&gt; for Standard MBeans.&lt;/p&gt;
 121 
 122     &lt;p&gt;In this managed object, there is an attribute called
 123       &lt;code&gt;Usage&lt;/code&gt; of type {@link MemoryUsage}.  The point of an
 124       attribute like this is that it gives a coherent snapshot of a set
 125       of data items.  For example, it might include the current amount
 126       of used memory in the memory pool, and the current maximum of the
 127       memory pool.  If these were separate items, obtained with separate
 128       {@link MBeanServer#getAttribute getAttribute} calls, then we could
 129       get values seen at different times that were not consistent.  We
 130       might get a &lt;code&gt;used&lt;/code&gt; value that was greater than the
 131       &lt;code&gt;max&lt;/code&gt; value.&lt;/p&gt;
 132 
 133     &lt;p&gt;So, we might define &lt;code&gt;MemoryUsage&lt;/code&gt; like this:&lt;/p&gt;
 134 
 135     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 136         &lt;h4&gt;Standard MBean&lt;/h4&gt;</span>
 137         &lt;pre&gt;
 138 public class MemoryUsage &lt;b&gt;implements Serializable&lt;/b&gt; {
 139     // standard JavaBean conventions with getters
 140 
 141     public MemoryUsage(long init, long used,
 142                        long committed, long max) {...}
 143     long getInit() {...}
 144     long getUsed() {...}
 145     long getCommitted() {...}
 146     long getMax() {...}
 147 }
 148         &lt;/pre&gt;
 149     &lt;/div&gt;
 150     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 151         &lt;h4&gt;MXBean&lt;/h4&gt;</span>
 152         &lt;pre&gt;
 153 public class MemoryUsage {
 154     // standard JavaBean conventions with getters
 155     &lt;b&gt;&amp;#64;ConstructorParameters({&quot;init&quot;, &quot;used&quot;, &quot;committed&quot;, &quot;max&quot;})&lt;/b&gt;
 156     public MemoryUsage(long init, long used,
 157                        long committed, long max) {...}
 158     long getInit() {...}
 159     long getUsed() {...}
 160     long getCommitted() {...}
 161     long getMax() {...}
 162 }
 163         &lt;/pre&gt;
 164     &lt;/div&gt;
 165 
 166     &lt;p&gt;The definitions are the same in the two cases, except
 167       that with the MXBean, &lt;code&gt;MemoryUsage&lt;/code&gt; no longer needs to
 168       be marked &lt;code&gt;Serializable&lt;/code&gt; (though it can be).  On
 169       the other hand, we have added a {@link ConstructorParameters &amp;#64;ConstructorParameters}
 170       annotation to link the constructor parameters to the corresponding getters.
 171       We will see more about this below.&lt;/p&gt;
</pre>
<hr />
<pre>
 177       based on JMX technology.  Then the console would have to be
 178       configured with the model-specific classes of every application it
 179       might connect to.  The problem is even worse for clients that are
 180       not written in the Java language.  Then there may not be any way
 181       to tell the client what a &lt;code&gt;MemoryUsage&lt;/code&gt; looks like.&lt;/p&gt;
 182 
 183     &lt;p&gt;This is where MXBeans differ from Standard MBeans.  Although we
 184       define the management interface in almost exactly the same way,
 185       the MXBean framework &lt;em&gt;converts&lt;/em&gt; model-specific classes into
 186       standard classes from the Java platform.  Using arrays and the
 187       {@link javax.management.openmbean.CompositeData CompositeData} and
 188       {@link javax.management.openmbean.TabularData TabularData} classes
 189       from the standard {@link javax.management.openmbean} package, it
 190       is possible to build data structures of arbitrary complexity
 191       using only standard classes.&lt;/p&gt;
 192 
 193     &lt;p&gt;This becomes clearer if we compare what the clients of the two
 194       models might look like:&lt;/p&gt;
 195 
 196     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 197         &lt;h4&gt;Standard MBean&lt;/h4&gt;</span>
 198         &lt;pre&gt;
 199 String name = (String)
 200     mbeanServer.{@link MBeanServer#getAttribute
 201     getAttribute}(objectName, &quot;Name&quot;);
 202 &lt;b&gt;MemoryUsage&lt;/b&gt; usage = (&lt;b&gt;MemoryUsage&lt;/b&gt;)
 203     mbeanServer.getAttribute(objectName, &quot;Usage&quot;);
 204 &lt;b&gt;long used = usage.getUsed();&lt;/b&gt;
 205         &lt;/pre&gt;
 206     &lt;/div&gt;
 207     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 208         &lt;h4&gt;MXBean&lt;/h4&gt;</span>
 209         &lt;pre&gt;
 210 String name = (String)
 211     mbeanServer.{@link MBeanServer#getAttribute
 212     getAttribute}(objectName, &quot;Name&quot;);
 213 &lt;b&gt;{@link CompositeData}&lt;/b&gt; usage = (&lt;b&gt;CompositeData&lt;/b&gt;)
 214     mbeanServer.getAttribute(objectName, &quot;Usage&quot;);
 215 &lt;b&gt;long used = (Long) usage.{@link CompositeData#get get}(&quot;used&quot;);&lt;/b&gt;
 216         &lt;/pre&gt;
 217     &lt;/div&gt;
 218 
 219     &lt;p&gt;For attributes with simple types like &lt;code&gt;String&lt;/code&gt;, the
 220       code is the same.  But for attributes with complex types, the
 221       Standard MBean code requires the client to know the model-specific
 222       class &lt;code&gt;MemoryUsage&lt;/code&gt;, while the MXBean code requires no
 223       non-standard classes.&lt;/p&gt;
 224 
 225     &lt;p&gt;The client code shown here is slightly more complicated for the
 226       MXBean client.  But, if the client does in fact know the model,
 227       here the interface &lt;code&gt;MemoryPoolMXBean&lt;/code&gt; and the
 228       class &lt;code&gt;MemoryUsage&lt;/code&gt;, then it can construct a
 229       &lt;em&gt;proxy&lt;/em&gt;.  This is the recommended way to interact with
 230       managed objects when you know the model beforehand, regardless
 231       of whether you are using Standard MBeans or MXBeans:&lt;/p&gt;
 232 
 233     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 234         &lt;h4&gt;Standard MBean&lt;/h4&gt;</span>
 235         &lt;pre&gt;
 236 MemoryPool&lt;b&gt;MBean&lt;/b&gt; proxy =
 237     JMX.&lt;b&gt;{@link JMX#newMBeanProxy(MBeanServerConnection, ObjectName,
 238               Class) newMBeanProxy}&lt;/b&gt;(
 239         mbeanServer,
 240         objectName,
 241         MemoryPool&lt;b&gt;MBean&lt;/b&gt;.class);
 242 String name = proxy.getName();
 243 MemoryUsage usage = proxy.getUsage();
 244 long used = usage.getUsed();
 245           &lt;/pre&gt;
 246     &lt;/div&gt;
 247     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 248         &lt;h4&gt;MXBean&lt;/h4&gt;</span>
 249         &lt;pre&gt;
 250 MemoryPool&lt;b&gt;MXBean&lt;/b&gt; proxy =
 251     JMX.&lt;b&gt;{@link JMX#newMXBeanProxy(MBeanServerConnection, ObjectName,
 252               Class) newMXBeanProxy}&lt;/b&gt;(
 253         mbeanServer,
 254         objectName,
 255         MemoryPool&lt;b&gt;MXBean&lt;/b&gt;.class);
 256 String name = proxy.getName();
 257 MemoryUsage usage = proxy.getUsage();
 258 long used = usage.getUsed();
 259           &lt;/pre&gt;
 260     &lt;/div&gt;
 261 
 262     &lt;p&gt;Implementing the MemoryPool object works similarly for both
 263       Standard MBeans and MXBeans.&lt;/p&gt;
 264 
 265     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 266         &lt;h4&gt;Standard MBean&lt;/h4&gt;</span>
 267         &lt;pre&gt;
 268 public class MemoryPool
 269         implements MemoryPool&lt;b&gt;MBean&lt;/b&gt; {
 270     public String getName() {...}
 271     public MemoryUsage getUsage() {...}
 272     // ...
 273 }
 274         &lt;/pre&gt;
 275     &lt;/div&gt;
 276     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 277         &lt;h4&gt;MXBean&lt;/h4&gt;</span>
 278         &lt;pre&gt;
 279 public class MemoryPool
 280         implements MemoryPool&lt;b&gt;MXBean&lt;/b&gt; {
 281     public String getName() {...}
 282     public MemoryUsage getUsage() {...}
 283     // ...
 284 }
 285         &lt;/pre&gt;
 286     &lt;/div&gt;
 287 
 288     &lt;p&gt;Registering the MBean in the MBean Server works in the same way
 289       in both cases:&lt;/p&gt;
 290 
 291     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 292         &lt;h4&gt;Standard MBean&lt;/h4&gt;</span>
 293         &lt;pre&gt;
 294 {
 295     MemoryPool&lt;b&gt;MBean&lt;/b&gt; pool = new MemoryPool();
 296     mbeanServer.{@link MBeanServer#registerMBean
 297     registerMBean}(pool, objectName);
 298 }
 299         &lt;/pre&gt;
 300     &lt;/div&gt;
 301     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 302         &lt;h4&gt;MXBean&lt;/h4&gt;</span>
 303         &lt;pre&gt;
 304 {
 305     MemoryPool&lt;b&gt;MXBean&lt;/b&gt; pool = new MemoryPool();
 306     mbeanServer.{@link MBeanServer#registerMBean
 307     registerMBean}(pool, objectName);
 308 }
 309         &lt;/pre&gt;
 310     &lt;/div&gt;
 311 
 312 
 313     &lt;h2 id=&quot;mxbean-def&quot;&gt;Definition of an MXBean&lt;/h2&gt;
 314 
 315     &lt;p&gt;An MXBean is a kind of MBean.  An MXBean object can be
 316       registered directly in the MBean Server, or it can be used as an
 317       argument to {@link StandardMBean} and the resultant MBean
 318       registered in the MBean Server.&lt;/p&gt;
 319 
 320     &lt;p&gt;When an object is registered in the MBean Server using the
 321       {@code registerMBean} or {@code createMBean} methods of the
 322       {@link MBeanServer} interface, the object&#39;s class is examined
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  62     public interface WhatsitMXBean {}
  63 
  64     &amp;#64;MXBean
  65     public interface Whatsit1Interface {}
  66 
  67     &amp;#64;MXBean(true)
  68     public interface Whatsit2Interface {}
  69     &lt;/pre&gt;
  70 
  71     &lt;p&gt;The following interfaces are not MXBean interfaces:&lt;/p&gt;
  72 
  73     &lt;pre&gt;
  74     interface NonPublicInterfaceNotMXBean{}
  75 
  76     public interface Whatsit3Interface{}
  77 
  78     &amp;#64;MXBean(false)
  79     public interface MisleadingMXBean {}
  80     &lt;/pre&gt;
  81 
<span class="line-modified">  82     &lt;h2 id=&quot;MXBean-spec&quot;&gt;MXBean specification&lt;/h2&gt;</span>
  83 
  84     &lt;p&gt;The MXBean concept provides a simple way to code an MBean
  85       that only references a predefined set of types, the ones defined
  86       by {@link javax.management.openmbean}.  In this way, you can be
  87       sure that your MBean will be usable by any client, including
  88       remote clients, without any requirement that the client have
  89       access to &lt;em&gt;model-specific classes&lt;/em&gt; representing the types
  90       of your MBeans.&lt;/p&gt;
  91 
  92     &lt;p&gt;The concepts are easier to understand by comparison with the
  93       Standard MBean concept.  Here is how a managed object might be
  94       represented as a Standard MBean, and as an MXBean:&lt;/p&gt;
  95 
  96     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified">  97         &lt;h3&gt;Standard MBean&lt;/h3&gt;</span>
  98         &lt;pre&gt;
  99 public interface MemoryPool&lt;b&gt;MBean&lt;/b&gt; {
 100     String getName();
 101     MemoryUsage getUsage();
 102     // ...
 103 }
 104           &lt;/pre&gt;
 105     &lt;/div&gt;
 106     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 107         &lt;h3&gt;MXBean&lt;/h3&gt;</span>
 108         &lt;pre&gt;
 109 public interface MemoryPool&lt;b&gt;MXBean&lt;/b&gt; {
 110     String getName();
 111     MemoryUsage getUsage();
 112     // ...
 113 }
 114           &lt;/pre&gt;
 115     &lt;/div&gt;
 116 
 117     &lt;p&gt;As you can see, the definitions are very similar.  The only
 118       difference is that the convention for naming the interface is to use
 119       &lt;code&gt;&lt;em&gt;Something&lt;/em&gt;MXBean&lt;/code&gt; for MXBeans, rather than
 120       &lt;code&gt;&lt;em&gt;Something&lt;/em&gt;MBean&lt;/code&gt; for Standard MBeans.&lt;/p&gt;
 121 
 122     &lt;p&gt;In this managed object, there is an attribute called
 123       &lt;code&gt;Usage&lt;/code&gt; of type {@link MemoryUsage}.  The point of an
 124       attribute like this is that it gives a coherent snapshot of a set
 125       of data items.  For example, it might include the current amount
 126       of used memory in the memory pool, and the current maximum of the
 127       memory pool.  If these were separate items, obtained with separate
 128       {@link MBeanServer#getAttribute getAttribute} calls, then we could
 129       get values seen at different times that were not consistent.  We
 130       might get a &lt;code&gt;used&lt;/code&gt; value that was greater than the
 131       &lt;code&gt;max&lt;/code&gt; value.&lt;/p&gt;
 132 
 133     &lt;p&gt;So, we might define &lt;code&gt;MemoryUsage&lt;/code&gt; like this:&lt;/p&gt;
 134 
 135     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 136         &lt;h3&gt;Standard MBean&lt;/h3&gt;</span>
 137         &lt;pre&gt;
 138 public class MemoryUsage &lt;b&gt;implements Serializable&lt;/b&gt; {
 139     // standard JavaBean conventions with getters
 140 
 141     public MemoryUsage(long init, long used,
 142                        long committed, long max) {...}
 143     long getInit() {...}
 144     long getUsed() {...}
 145     long getCommitted() {...}
 146     long getMax() {...}
 147 }
 148         &lt;/pre&gt;
 149     &lt;/div&gt;
 150     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 151         &lt;h3&gt;MXBean&lt;/h3&gt;</span>
 152         &lt;pre&gt;
 153 public class MemoryUsage {
 154     // standard JavaBean conventions with getters
 155     &lt;b&gt;&amp;#64;ConstructorParameters({&quot;init&quot;, &quot;used&quot;, &quot;committed&quot;, &quot;max&quot;})&lt;/b&gt;
 156     public MemoryUsage(long init, long used,
 157                        long committed, long max) {...}
 158     long getInit() {...}
 159     long getUsed() {...}
 160     long getCommitted() {...}
 161     long getMax() {...}
 162 }
 163         &lt;/pre&gt;
 164     &lt;/div&gt;
 165 
 166     &lt;p&gt;The definitions are the same in the two cases, except
 167       that with the MXBean, &lt;code&gt;MemoryUsage&lt;/code&gt; no longer needs to
 168       be marked &lt;code&gt;Serializable&lt;/code&gt; (though it can be).  On
 169       the other hand, we have added a {@link ConstructorParameters &amp;#64;ConstructorParameters}
 170       annotation to link the constructor parameters to the corresponding getters.
 171       We will see more about this below.&lt;/p&gt;
</pre>
<hr />
<pre>
 177       based on JMX technology.  Then the console would have to be
 178       configured with the model-specific classes of every application it
 179       might connect to.  The problem is even worse for clients that are
 180       not written in the Java language.  Then there may not be any way
 181       to tell the client what a &lt;code&gt;MemoryUsage&lt;/code&gt; looks like.&lt;/p&gt;
 182 
 183     &lt;p&gt;This is where MXBeans differ from Standard MBeans.  Although we
 184       define the management interface in almost exactly the same way,
 185       the MXBean framework &lt;em&gt;converts&lt;/em&gt; model-specific classes into
 186       standard classes from the Java platform.  Using arrays and the
 187       {@link javax.management.openmbean.CompositeData CompositeData} and
 188       {@link javax.management.openmbean.TabularData TabularData} classes
 189       from the standard {@link javax.management.openmbean} package, it
 190       is possible to build data structures of arbitrary complexity
 191       using only standard classes.&lt;/p&gt;
 192 
 193     &lt;p&gt;This becomes clearer if we compare what the clients of the two
 194       models might look like:&lt;/p&gt;
 195 
 196     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 197         &lt;h3&gt;Standard MBean&lt;/h3&gt;</span>
 198         &lt;pre&gt;
 199 String name = (String)
 200     mbeanServer.{@link MBeanServer#getAttribute
 201     getAttribute}(objectName, &quot;Name&quot;);
 202 &lt;b&gt;MemoryUsage&lt;/b&gt; usage = (&lt;b&gt;MemoryUsage&lt;/b&gt;)
 203     mbeanServer.getAttribute(objectName, &quot;Usage&quot;);
 204 &lt;b&gt;long used = usage.getUsed();&lt;/b&gt;
 205         &lt;/pre&gt;
 206     &lt;/div&gt;
 207     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 208         &lt;h3&gt;MXBean&lt;/h3&gt;</span>
 209         &lt;pre&gt;
 210 String name = (String)
 211     mbeanServer.{@link MBeanServer#getAttribute
 212     getAttribute}(objectName, &quot;Name&quot;);
 213 &lt;b&gt;{@link CompositeData}&lt;/b&gt; usage = (&lt;b&gt;CompositeData&lt;/b&gt;)
 214     mbeanServer.getAttribute(objectName, &quot;Usage&quot;);
 215 &lt;b&gt;long used = (Long) usage.{@link CompositeData#get get}(&quot;used&quot;);&lt;/b&gt;
 216         &lt;/pre&gt;
 217     &lt;/div&gt;
 218 
 219     &lt;p&gt;For attributes with simple types like &lt;code&gt;String&lt;/code&gt;, the
 220       code is the same.  But for attributes with complex types, the
 221       Standard MBean code requires the client to know the model-specific
 222       class &lt;code&gt;MemoryUsage&lt;/code&gt;, while the MXBean code requires no
 223       non-standard classes.&lt;/p&gt;
 224 
 225     &lt;p&gt;The client code shown here is slightly more complicated for the
 226       MXBean client.  But, if the client does in fact know the model,
 227       here the interface &lt;code&gt;MemoryPoolMXBean&lt;/code&gt; and the
 228       class &lt;code&gt;MemoryUsage&lt;/code&gt;, then it can construct a
 229       &lt;em&gt;proxy&lt;/em&gt;.  This is the recommended way to interact with
 230       managed objects when you know the model beforehand, regardless
 231       of whether you are using Standard MBeans or MXBeans:&lt;/p&gt;
 232 
 233     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 234         &lt;h3&gt;Standard MBean&lt;/h3&gt;</span>
 235         &lt;pre&gt;
 236 MemoryPool&lt;b&gt;MBean&lt;/b&gt; proxy =
 237     JMX.&lt;b&gt;{@link JMX#newMBeanProxy(MBeanServerConnection, ObjectName,
 238               Class) newMBeanProxy}&lt;/b&gt;(
 239         mbeanServer,
 240         objectName,
 241         MemoryPool&lt;b&gt;MBean&lt;/b&gt;.class);
 242 String name = proxy.getName();
 243 MemoryUsage usage = proxy.getUsage();
 244 long used = usage.getUsed();
 245           &lt;/pre&gt;
 246     &lt;/div&gt;
 247     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 248         &lt;h3&gt;MXBean&lt;/h3&gt;</span>
 249         &lt;pre&gt;
 250 MemoryPool&lt;b&gt;MXBean&lt;/b&gt; proxy =
 251     JMX.&lt;b&gt;{@link JMX#newMXBeanProxy(MBeanServerConnection, ObjectName,
 252               Class) newMXBeanProxy}&lt;/b&gt;(
 253         mbeanServer,
 254         objectName,
 255         MemoryPool&lt;b&gt;MXBean&lt;/b&gt;.class);
 256 String name = proxy.getName();
 257 MemoryUsage usage = proxy.getUsage();
 258 long used = usage.getUsed();
 259           &lt;/pre&gt;
 260     &lt;/div&gt;
 261 
 262     &lt;p&gt;Implementing the MemoryPool object works similarly for both
 263       Standard MBeans and MXBeans.&lt;/p&gt;
 264 
 265     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 266         &lt;h3&gt;Standard MBean&lt;/h3&gt;</span>
 267         &lt;pre&gt;
 268 public class MemoryPool
 269         implements MemoryPool&lt;b&gt;MBean&lt;/b&gt; {
 270     public String getName() {...}
 271     public MemoryUsage getUsage() {...}
 272     // ...
 273 }
 274         &lt;/pre&gt;
 275     &lt;/div&gt;
 276     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 277         &lt;h3&gt;MXBean&lt;/h3&gt;</span>
 278         &lt;pre&gt;
 279 public class MemoryPool
 280         implements MemoryPool&lt;b&gt;MXBean&lt;/b&gt; {
 281     public String getName() {...}
 282     public MemoryUsage getUsage() {...}
 283     // ...
 284 }
 285         &lt;/pre&gt;
 286     &lt;/div&gt;
 287 
 288     &lt;p&gt;Registering the MBean in the MBean Server works in the same way
 289       in both cases:&lt;/p&gt;
 290 
 291     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 292         &lt;h3&gt;Standard MBean&lt;/h3&gt;</span>
 293         &lt;pre&gt;
 294 {
 295     MemoryPool&lt;b&gt;MBean&lt;/b&gt; pool = new MemoryPool();
 296     mbeanServer.{@link MBeanServer#registerMBean
 297     registerMBean}(pool, objectName);
 298 }
 299         &lt;/pre&gt;
 300     &lt;/div&gt;
 301     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
<span class="line-modified"> 302         &lt;h3&gt;MXBean&lt;/h3&gt;</span>
 303         &lt;pre&gt;
 304 {
 305     MemoryPool&lt;b&gt;MXBean&lt;/b&gt; pool = new MemoryPool();
 306     mbeanServer.{@link MBeanServer#registerMBean
 307     registerMBean}(pool, objectName);
 308 }
 309         &lt;/pre&gt;
 310     &lt;/div&gt;
 311 
 312 
 313     &lt;h2 id=&quot;mxbean-def&quot;&gt;Definition of an MXBean&lt;/h2&gt;
 314 
 315     &lt;p&gt;An MXBean is a kind of MBean.  An MXBean object can be
 316       registered directly in the MBean Server, or it can be used as an
 317       argument to {@link StandardMBean} and the resultant MBean
 318       registered in the MBean Server.&lt;/p&gt;
 319 
 320     &lt;p&gt;When an object is registered in the MBean Server using the
 321       {@code registerMBean} or {@code createMBean} methods of the
 322       {@link MBeanServer} interface, the object&#39;s class is examined
</pre>
</td>
</tr>
</table>
<center><a href="InvalidApplicationException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NotificationBroadcaster.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.management/share/classes/javax/management/openmbean/TabularType.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 package javax.management.openmbean;
 28 
 29 
 30 // java import
 31 //
 32 import java.util.ArrayList;
 33 import java.util.Collections;
 34 import java.util.Iterator;
 35 import java.util.List;
 36 
 37 // jmx import
 38 //
 39 
 40 
 41 /**
 42  * The &lt;code&gt;TabularType&lt;/code&gt; class is the &lt;i&gt; open type&lt;/i&gt; class
 43  * whose instances describe the types of {@link TabularData TabularData} values.
 44  *
 45  * @since 1.5
 46  */
 47 public class TabularType extends OpenType&lt;TabularData&gt; {
 48 
 49     /* Serial version */
 50     static final long serialVersionUID = 6554071860220659261L;
 51 
 52 
 53     /**
 54      * @serial The composite type of rows
 55      */
 56     private CompositeType  rowType;
 57 
 58     /**
 59      * @serial The items used to index each row element, kept in the order the user gave
 60      *         This is an unmodifiable {@link ArrayList}
 61      */
 62     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
 63     private List&lt;String&gt; indexNames;
 64 
 65 
 66     private transient Integer myHashCode = null; // As this instance is immutable, these two values
 67     private transient String  myToString = null; // need only be calculated once.
 68 
 69 
 70     /* *** Constructor *** */
 71 
 72     /**
 73      * Constructs a &lt;code&gt;TabularType&lt;/code&gt; instance, checking for the validity of the given parameters.
 74      * The validity constraints are described below for each parameter.
 75      * &lt;p&gt;
 76      * The Java class name of tabular data values this tabular type represents
 77      * (ie the class name returned by the {@link OpenType#getClassName() getClassName} method)
 78      * is set to the string value returned by &lt;code&gt;TabularData.class.getName()&lt;/code&gt;.
 79      *
 80      * @param  typeName  The name given to the tabular type this instance represents; cannot be a null or empty string.
 81      * &lt;br&gt;&amp;nbsp;
 82      * @param  description  The human readable description of the tabular type this instance represents;
 83      *                      cannot be a null or empty string.
 84      * &lt;br&gt;&amp;nbsp;
 85      * @param  rowType  The type of the row elements of tabular data values described by this tabular type instance;
 86      *                  cannot be null.
 87      * &lt;br&gt;&amp;nbsp;
 88      * @param  indexNames  The names of the items the values of which are used to uniquely index each row element in the
 89      *                     tabular data values described by this tabular type instance;
 90      *                     cannot be null or empty. Each element should be an item name defined in &lt;var&gt;rowType&lt;/var&gt;
 91      *                     (no null or empty string allowed).
 92      *                     It is important to note that the &lt;b&gt;order&lt;/b&gt; of the item names in &lt;var&gt;indexNames&lt;/var&gt;
 93      *                     is used by the methods {@link TabularData#get(java.lang.Object[]) get} and
 94      *                     {@link TabularData#remove(java.lang.Object[]) remove} of class
 95      *                     &lt;code&gt;TabularData&lt;/code&gt; to match their array of values parameter to items.
 96      * &lt;br&gt;&amp;nbsp;
 97      * @throws IllegalArgumentException  if &lt;var&gt;rowType&lt;/var&gt; is null,
 98      *                                   or &lt;var&gt;indexNames&lt;/var&gt; is a null or empty array,
 99      *                                   or an element in &lt;var&gt;indexNames&lt;/var&gt; is a null or empty string,
100      *                                   or &lt;var&gt;typeName&lt;/var&gt; or &lt;var&gt;description&lt;/var&gt; is a null or empty string.
101      * &lt;br&gt;&amp;nbsp;
102      * @throws OpenDataException  if an element&#39;s value of &lt;var&gt;indexNames&lt;/var&gt;
103      *                            is not an item name defined in &lt;var&gt;rowType&lt;/var&gt;.
104      */
105     public TabularType(String         typeName,
106                        String         description,
107                        CompositeType  rowType,
108                        String[]       indexNames) throws OpenDataException {
109 
110         // Check and initialize state defined by parent.
111         //
112         super(TabularData.class.getName(), typeName, description, false);
113 
114         // Check rowType is not null
115         //
116         if (rowType == null) {
117             throw new IllegalArgumentException(&quot;Argument rowType cannot be null.&quot;);
118         }
119 
120         // Check indexNames is neither null nor empty and does not contain any null element or empty string
121         //
122         checkForNullElement(indexNames, &quot;indexNames&quot;);
123         checkForEmptyString(indexNames, &quot;indexNames&quot;);
124 
125         // Check all indexNames values are valid item names for rowType
126         //
127         for (int i=0; i&lt;indexNames.length; i++) {
128             if ( ! rowType.containsKey(indexNames[i]) ) {
129                 throw new OpenDataException(&quot;Argument&#39;s element value indexNames[&quot;+ i +&quot;]=\&quot;&quot;+ indexNames[i] +
130                                             &quot;\&quot; is not a valid item name for rowType.&quot;);
131             }
132         }
133 
134         // initialize rowType
135         //
136         this.rowType    = rowType;
137 
138         // initialize indexNames (copy content so that subsequent
139         // modifs to the array referenced by the indexNames parameter
140         // have no impact)
141         //
142         List&lt;String&gt; tmpList = new ArrayList&lt;String&gt;(indexNames.length + 1);
143         for (int i=0; i&lt;indexNames.length; i++) {
144             tmpList.add(indexNames[i]);
145         }
146         this.indexNames = Collections.unmodifiableList(tmpList);
147     }
148 
149     /**
150      * Checks that Object[] arg is neither null nor empty (ie length==0)
151      * and that it does not contain any null element.
152      */
153     private static void checkForNullElement(Object[] arg, String argName) {
154         if ( (arg == null) || (arg.length == 0) ) {
155             throw new IllegalArgumentException(&quot;Argument &quot;+ argName +&quot;[] cannot be null or empty.&quot;);
156         }
157         for (int i=0; i&lt;arg.length; i++) {
158             if (arg[i] == null) {
159                 throw new IllegalArgumentException(&quot;Argument&#39;s element &quot;+ argName +&quot;[&quot;+ i +&quot;] cannot be null.&quot;);
160             }
161         }
162     }
163 
164     /**
165      * Checks that String[] does not contain any empty (or blank characters only) string.
166      */
167     private static void checkForEmptyString(String[] arg, String argName) {
168         for (int i=0; i&lt;arg.length; i++) {
169             if (arg[i].trim().isEmpty()) {
170                 throw new IllegalArgumentException(&quot;Argument&#39;s element &quot;+ argName +&quot;[&quot;+ i +&quot;] cannot be an empty string.&quot;);
171             }
172         }
173     }
174 
175 
176     /* *** Tabular type specific information methods *** */
177 
178     /**
179      * Returns the type of the row elements of tabular data values
180      * described by this &lt;code&gt;TabularType&lt;/code&gt; instance.
181      *
182      * @return the type of each row.
183      */
184     public CompositeType getRowType() {
185 
186         return rowType;
187     }
188 
189     /**
190      * &lt;p&gt;Returns, in the same order as was given to this instance&#39;s
191      * constructor, an unmodifiable List of the names of the items the
192      * values of which are used to uniquely index each row element of
193      * tabular data values described by this &lt;code&gt;TabularType&lt;/code&gt;
194      * instance.&lt;/p&gt;
195      *
196      * @return a List of String representing the names of the index
197      * items.
198      *
199      */
200     public List&lt;String&gt; getIndexNames() {
201 
202         return indexNames;
203     }
204 
205     /**
206      * Tests whether &lt;var&gt;obj&lt;/var&gt; is a value which could be
207      * described by this &lt;code&gt;TabularType&lt;/code&gt; instance.
208      *
209      * &lt;p&gt;If &lt;var&gt;obj&lt;/var&gt; is null or is not an instance of
210      * &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;,
211      * &lt;code&gt;isValue&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
212      *
213      * &lt;p&gt;If &lt;var&gt;obj&lt;/var&gt; is an instance of
214      * &lt;code&gt;javax.management.openmbean.TabularData&lt;/code&gt;, say {@code
215      * td}, the result is true if this {@code TabularType} is
216      * &lt;em&gt;assignable from&lt;/em&gt; {@link TabularData#getTabularType()
217      * td.getTabularType()}, as defined in {@link
218      * CompositeType#isValue CompositeType.isValue}.&lt;/p&gt;
219      *
220      * @param obj the value whose open type is to be tested for
221      * compatibility with this &lt;code&gt;TabularType&lt;/code&gt; instance.
222      *
223      * @return &lt;code&gt;true&lt;/code&gt; if &lt;var&gt;obj&lt;/var&gt; is a value for this
224      * tabular type, &lt;code&gt;false&lt;/code&gt; otherwise.
225      */
226     public boolean isValue(Object obj) {
227 
228         // if obj is null or not a TabularData, return false
229         //
230         if (!(obj instanceof TabularData))
231             return false;
232 
233         // if obj is not a TabularData, return false
234         //
235         TabularData value = (TabularData) obj;
236         TabularType valueType = value.getTabularType();
237         return isAssignableFrom(valueType);
238     }
239 
240     @Override
241     boolean isAssignableFrom(OpenType&lt;?&gt; ot) {
242         if (!(ot instanceof TabularType))
243             return false;
244         TabularType tt = (TabularType) ot;
245         if (!getTypeName().equals(tt.getTypeName()) ||
246                 !getIndexNames().equals(tt.getIndexNames()))
247             return false;
248         return getRowType().isAssignableFrom(tt.getRowType());
249     }
250 
251 
252     /* *** Methods overriden from class Object *** */
253 
254     /**
255      * Compares the specified &lt;code&gt;obj&lt;/code&gt; parameter with this &lt;code&gt;TabularType&lt;/code&gt; instance for equality.
256      * &lt;p&gt;
257      * Two &lt;code&gt;TabularType&lt;/code&gt; instances are equal if and only if all of the following statements are true:
258      * &lt;ul&gt;
259      * &lt;li&gt;their type names are equal&lt;/li&gt;
260      * &lt;li&gt;their row types are equal&lt;/li&gt;
261      * &lt;li&gt;they use the same index names, in the same order&lt;/li&gt;
262      * &lt;/ul&gt;
263      * &lt;br&gt;&amp;nbsp;
264      * @param  obj  the object to be compared for equality with this &lt;code&gt;TabularType&lt;/code&gt; instance;
265      *              if &lt;var&gt;obj&lt;/var&gt; is &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;equals&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.
266      *
267      * @return  &lt;code&gt;true&lt;/code&gt; if the specified object is equal to this &lt;code&gt;TabularType&lt;/code&gt; instance.
268      */
269     public boolean equals(Object obj) {
270 
271         // if obj is null, return false
272         //
273         if (obj == null) {
274             return false;
275         }
276 
277         // if obj is not a TabularType, return false
278         //
279         TabularType other;
280         try {
281             other = (TabularType) obj;
282         } catch (ClassCastException e) {
283             return false;
284         }
285 
286         // Now, really test for equality between this TabularType instance and the other:
287         //
288 
289         // their names should be equal
290         if ( ! this.getTypeName().equals(other.getTypeName()) ) {
291             return false;
292         }
293 
294         // their row types should be equal
295         if ( ! this.rowType.equals(other.rowType) ) {
296             return false;
297         }
298 
299         // their index names should be equal and in the same order (ensured by List.equals())
300         if ( ! this.indexNames.equals(other.indexNames) ) {
301             return false;
302         }
303 
304         // All tests for equality were successfull
305         //
306         return true;
307     }
308 
309     /**
310      * Returns the hash code value for this &lt;code&gt;TabularType&lt;/code&gt; instance.
311      * &lt;p&gt;
312      * The hash code of a &lt;code&gt;TabularType&lt;/code&gt; instance is the sum of the hash codes
313      * of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons
314      * (ie: name, row type, index names).
315      * This ensures that &lt;code&gt; t1.equals(t2) &lt;/code&gt; implies that &lt;code&gt; t1.hashCode()==t2.hashCode() &lt;/code&gt;
316      * for any two &lt;code&gt;TabularType&lt;/code&gt; instances &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;,
317      * as required by the general contract of the method
318      * {@link Object#hashCode() Object.hashCode()}.
319      * &lt;p&gt;
320      * As &lt;code&gt;TabularType&lt;/code&gt; instances are immutable, the hash code for this instance is calculated once,
321      * on the first call to &lt;code&gt;hashCode&lt;/code&gt;, and then the same value is returned for subsequent calls.
322      *
323      * @return  the hash code value for this &lt;code&gt;TabularType&lt;/code&gt; instance
324      */
325     public int hashCode() {
326 
327         // Calculate the hash code value if it has not yet been done (ie 1st call to hashCode())
328         //
329         if (myHashCode == null) {
330             int value = 0;
331             value += this.getTypeName().hashCode();
332             value += this.rowType.hashCode();
333             for (String index : indexNames)
334                 value += index.hashCode();
335             myHashCode = Integer.valueOf(value);
336         }
337 
338         // return always the same hash code for this instance (immutable)
339         //
340         return myHashCode.intValue();
341     }
342 
343     /**
344      * Returns a string representation of this &lt;code&gt;TabularType&lt;/code&gt; instance.
345      * &lt;p&gt;
346      * The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.TabularType&lt;/code&gt;),
347      * the type name for this instance, the row type string representation of this instance,
348      * and the index names of this instance.
349      * &lt;p&gt;
350      * As &lt;code&gt;TabularType&lt;/code&gt; instances are immutable, the string representation for this instance is calculated once,
351      * on the first call to &lt;code&gt;toString&lt;/code&gt;, and then the same value is returned for subsequent calls.
352      *
353      * @return  a string representation of this &lt;code&gt;TabularType&lt;/code&gt; instance
354      */
355     public String toString() {
356 
357         // Calculate the string representation if it has not yet been done (ie 1st call to toString())
358         //
359         if (myToString == null) {
360             final StringBuilder result = new StringBuilder()
361                 .append(this.getClass().getName())
362                 .append(&quot;(name=&quot;)
363                 .append(getTypeName())
364                 .append(&quot;,rowType=&quot;)
365                 .append(rowType.toString())
366                 .append(&quot;,indexNames=(&quot;);
367             String sep = &quot;&quot;;
368             for (String index : indexNames) {
369                 result.append(sep).append(index);
370                 sep = &quot;,&quot;;
371             }
372             result.append(&quot;))&quot;);
373             myToString = result.toString();
374         }
375 
376         // return always the same string representation for this instance (immutable)
377         //
378         return myToString;
379     }
380 
381 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.management/share/classes/javax/management/openmbean/OpenMBeanAttributeInfoSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 package javax.management.openmbean;
  28 
  29 
  30 // java import
  31 //
  32 import java.lang.reflect.Array;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.Method;
  35 import java.lang.reflect.Modifier;
  36 import java.util.Arrays;
  37 import java.util.Collection;
  38 import java.util.Collections;
  39 import java.util.HashMap;
  40 import java.util.HashSet;
  41 import java.util.Map;
  42 import java.util.Set;
  43 import javax.management.Descriptor;
  44 import javax.management.DescriptorRead;
  45 import javax.management.ImmutableDescriptor;
  46 import javax.management.MBeanAttributeInfo;
  47 import com.sun.jmx.remote.util.EnvHelp;
  48 import sun.reflect.misc.MethodUtil;
  49 import sun.reflect.misc.ReflectUtil;
  50 
  51 /**
  52  * Describes an attribute of an open MBean.
  53  *
  54  *
  55  * @since 1.5
  56  */
  57 public class OpenMBeanAttributeInfoSupport
  58     extends MBeanAttributeInfo
  59     implements OpenMBeanAttributeInfo {
  60 
  61     /* Serial version */
  62     static final long serialVersionUID = -4867215622149721849L;
  63 
  64     /**
  65      * @serial The open mbean attribute&#39;s &lt;i&gt;open type&lt;/i&gt;
  66      */
  67     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
  68     private OpenType&lt;?&gt; openType;
  69 
  70     /**
  71      * @serial The open mbean attribute&#39;s default value
  72      */
  73     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
  74     private final Object defaultValue;
  75 
  76     /**
  77      * @serial The open mbean attribute&#39;s legal values. This {@link
  78      * Set} is unmodifiable
  79      */
  80     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
  81     private final Set&lt;?&gt; legalValues;  // to be constructed unmodifiable
  82 
  83     /**
  84      * @serial The open mbean attribute&#39;s min value
  85      */
  86     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
  87     private final Comparable&lt;?&gt; minValue;
  88 
  89     /**
  90      * @serial The open mbean attribute&#39;s max value
  91      */
  92     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
  93     private final Comparable&lt;?&gt; maxValue;
  94 
  95 
  96     // As this instance is immutable, these two values need only
  97     // be calculated once.
  98     private transient Integer myHashCode = null;
  99     private transient String  myToString = null;
 100 
 101 
 102     /**
 103      * Constructs an {@code OpenMBeanAttributeInfoSupport} instance,
 104      * which describes the attribute of an open MBean with the
 105      * specified {@code name}, {@code openType} and {@code
 106      * description}, and the specified read/write access properties.
 107      *
 108      * @param name  cannot be a null or empty string.
 109      *
 110      * @param description  cannot be a null or empty string.
 111      *
 112      * @param openType  cannot be null.
 113      *
 114      * @param isReadable {@code true} if the attribute has a getter
 115      * exposed for management.
 116      *
 117      * @param isWritable {@code true} if the attribute has a setter
 118      * exposed for management.
 119      *
 120      * @param isIs {@code true} if the attribute&#39;s getter is of the
 121      * form &lt;code&gt;is&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt;.
 122      *
 123      * @throws IllegalArgumentException if {@code name} or {@code
 124      * description} are null or empty string, or {@code openType} is
 125      * null.
 126      */
 127     public OpenMBeanAttributeInfoSupport(String name,
 128                                          String description,
 129                                          OpenType&lt;?&gt; openType,
 130                                          boolean isReadable,
 131                                          boolean isWritable,
 132                                          boolean isIs) {
 133         this(name, description, openType, isReadable, isWritable, isIs,
 134              (Descriptor) null);
 135     }
 136 
 137     /**
 138      * &lt;p&gt;Constructs an {@code OpenMBeanAttributeInfoSupport} instance,
 139      * which describes the attribute of an open MBean with the
 140      * specified {@code name}, {@code openType}, {@code
 141      * description}, read/write access properties, and {@code Descriptor}.&lt;/p&gt;
 142      *
 143      * &lt;p&gt;The {@code descriptor} can contain entries that will define
 144      * the values returned by certain methods of this class, as
 145      * explained in the &lt;a href=&quot;package-summary.html#constraints&quot;&gt;
 146      * package description&lt;/a&gt;.
 147      *
 148      * @param name  cannot be a null or empty string.
 149      *
 150      * @param description  cannot be a null or empty string.
 151      *
 152      * @param openType  cannot be null.
 153      *
 154      * @param isReadable {@code true} if the attribute has a getter
 155      * exposed for management.
 156      *
 157      * @param isWritable {@code true} if the attribute has a setter
 158      * exposed for management.
 159      *
 160      * @param isIs {@code true} if the attribute&#39;s getter is of the
 161      * form &lt;code&gt;is&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt;.
 162      *
 163      * @param descriptor The descriptor for the attribute.  This may be null
 164      * which is equivalent to an empty descriptor.
 165      *
 166      * @throws IllegalArgumentException if {@code name} or {@code
 167      * description} are null or empty string, or {@code openType} is
 168      * null, or the descriptor entries are invalid as described in the
 169      * &lt;a href=&quot;package-summary.html#constraints&quot;&gt;package description&lt;/a&gt;.
 170      *
 171      * @since 1.6
 172      */
 173     public OpenMBeanAttributeInfoSupport(String name,
 174                                          String description,
 175                                          OpenType&lt;?&gt; openType,
 176                                          boolean isReadable,
 177                                          boolean isWritable,
 178                                          boolean isIs,
 179                                          Descriptor descriptor) {
 180         // Construct parent&#39;s state
 181         //
 182         super(name,
 183               (openType==null) ? null : openType.getClassName(),
 184               description,
 185               isReadable,
 186               isWritable,
 187               isIs,
 188               ImmutableDescriptor.union(descriptor, (openType==null)?null:
 189                 openType.getDescriptor()));
 190 
 191         // Initialize this instance&#39;s specific state
 192         //
 193         this.openType = openType;
 194 
 195         descriptor = getDescriptor();  // replace null by empty
 196         this.defaultValue = valueFrom(descriptor, &quot;defaultValue&quot;, openType);
 197         this.legalValues = valuesFrom(descriptor, &quot;legalValues&quot;, openType);
 198         this.minValue = comparableValueFrom(descriptor, &quot;minValue&quot;, openType);
 199         this.maxValue = comparableValueFrom(descriptor, &quot;maxValue&quot;, openType);
 200 
 201         try {
 202             check(this);
 203         } catch (OpenDataException e) {
 204             throw new IllegalArgumentException(e.getMessage(), e);
 205         }
 206     }
 207 
 208     /**
 209      * Constructs an {@code OpenMBeanAttributeInfoSupport} instance,
 210      * which describes the attribute of an open MBean with the
 211      * specified {@code name}, {@code openType}, {@code description}
 212      * and {@code defaultValue}, and the specified read/write access
 213      * properties.
 214      *
 215      * @param name  cannot be a null or empty string.
 216      *
 217      * @param description  cannot be a null or empty string.
 218      *
 219      * @param openType  cannot be null.
 220      *
 221      * @param isReadable {@code true} if the attribute has a getter
 222      * exposed for management.
 223      *
 224      * @param isWritable {@code true} if the attribute has a setter
 225      * exposed for management.
 226      *
 227      * @param isIs {@code true} if the attribute&#39;s getter is of the
 228      * form &lt;code&gt;is&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt;.
 229      *
 230      * @param defaultValue must be a valid value for the {@code
 231      * openType} specified for this attribute; default value not
 232      * supported for {@code ArrayType} and {@code TabularType}; can
 233      * be null, in which case it means that no default value is set.
 234      *
 235      * @param &lt;T&gt; allows the compiler to check that the {@code defaultValue},
 236      * if non-null, has the correct Java type for the given {@code openType}.
 237      *
 238      * @throws IllegalArgumentException if {@code name} or {@code
 239      * description} are null or empty string, or {@code openType} is
 240      * null.
 241      *
 242      * @throws OpenDataException if {@code defaultValue} is not a
 243      * valid value for the specified {@code openType}, or {@code
 244      * defaultValue} is non null and {@code openType} is an {@code
 245      * ArrayType} or a {@code TabularType}.
 246      */
 247     public &lt;T&gt; OpenMBeanAttributeInfoSupport(String   name,
 248                                              String   description,
 249                                              OpenType&lt;T&gt; openType,
 250                                              boolean  isReadable,
 251                                              boolean  isWritable,
 252                                              boolean  isIs,
 253                                              T        defaultValue)
 254             throws OpenDataException {
 255         this(name, description, openType, isReadable, isWritable, isIs,
 256              defaultValue, (T[]) null);
 257     }
 258 
 259 
 260     /**
 261      * &lt;p&gt;Constructs an {@code OpenMBeanAttributeInfoSupport} instance,
 262      * which describes the attribute of an open MBean with the
 263      * specified {@code name}, {@code openType}, {@code description},
 264      * {@code defaultValue} and {@code legalValues}, and the specified
 265      * read/write access properties.&lt;/p&gt;
 266      *
 267      * &lt;p&gt;The contents of {@code legalValues} are copied, so subsequent
 268      * modifications of the array referenced by {@code legalValues}
 269      * have no impact on this {@code OpenMBeanAttributeInfoSupport}
 270      * instance.&lt;/p&gt;
 271      *
 272      * @param name  cannot be a null or empty string.
 273      *
 274      * @param description  cannot be a null or empty string.
 275      *
 276      * @param openType  cannot be null.
 277      *
 278      * @param isReadable {@code true} if the attribute has a getter
 279      * exposed for management.
 280      *
 281      * @param isWritable {@code true} if the attribute has a setter
 282      * exposed for management.
 283      *
 284      * @param isIs {@code true} if the attribute&#39;s getter is of the
 285      * form &lt;code&gt;is&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt;.
 286      *
 287      * @param defaultValue must be a valid value
 288      * for the {@code
 289      * openType} specified for this attribute; default value not
 290      * supported for {@code ArrayType} and {@code TabularType}; can
 291      * be null, in which case it means that no default value is set.
 292      *
 293      * @param legalValues each contained value must be valid for the
 294      * {@code openType} specified for this attribute; legal values
 295      * not supported for {@code ArrayType} and {@code TabularType};
 296      * can be null or empty.
 297      *
 298      * @param &lt;T&gt; allows the compiler to check that the {@code
 299      * defaultValue} and {@code legalValues}, if non-null, have the
 300      * correct Java type for the given {@code openType}.
 301      *
 302      * @throws IllegalArgumentException if {@code name} or {@code
 303      * description} are null or empty string, or {@code openType} is
 304      * null.
 305      *
 306      * @throws OpenDataException if {@code defaultValue} is not a
 307      * valid value for the specified {@code openType}, or one value in
 308      * {@code legalValues} is not valid for the specified {@code
 309      * openType}, or {@code defaultValue} is non null and {@code
 310      * openType} is an {@code ArrayType} or a {@code TabularType}, or
 311      * {@code legalValues} is non null and non empty and {@code
 312      * openType} is an {@code ArrayType} or a {@code TabularType}, or
 313      * {@code legalValues} is non null and non empty and {@code
 314      * defaultValue} is not contained in {@code legalValues}.
 315      */
 316     public &lt;T&gt; OpenMBeanAttributeInfoSupport(String   name,
 317                                              String   description,
 318                                              OpenType&lt;T&gt; openType,
 319                                              boolean  isReadable,
 320                                              boolean  isWritable,
 321                                              boolean  isIs,
 322                                              T        defaultValue,
 323                                              T[]      legalValues)
 324             throws OpenDataException {
 325         this(name, description, openType, isReadable, isWritable, isIs,
 326              defaultValue, legalValues, null, null);
 327     }
 328 
 329 
 330     /**
 331      * Constructs an {@code OpenMBeanAttributeInfoSupport} instance,
 332      * which describes the attribute of an open MBean, with the
 333      * specified {@code name}, {@code openType}, {@code description},
 334      * {@code defaultValue}, {@code minValue} and {@code maxValue}.
 335      *
 336      * It is possible to specify minimal and maximal values only for
 337      * an open type whose values are {@code Comparable}.
 338      *
 339      * @param name  cannot be a null or empty string.
 340      *
 341      * @param description  cannot be a null or empty string.
 342      *
 343      * @param openType  cannot be null.
 344      *
 345      * @param isReadable {@code true} if the attribute has a getter
 346      * exposed for management.
 347      *
 348      * @param isWritable {@code true} if the attribute has a setter
 349      * exposed for management.
 350      *
 351      * @param isIs {@code true} if the attribute&#39;s getter is of the
 352      * form &lt;code&gt;is&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt;.
 353      *
 354      * @param defaultValue must be a valid value for the {@code
 355      * openType} specified for this attribute; default value not
 356      * supported for {@code ArrayType} and {@code TabularType}; can be
 357      * null, in which case it means that no default value is set.
 358      *
 359      * @param minValue must be valid for the {@code openType}
 360      * specified for this attribute; can be null, in which case it
 361      * means that no minimal value is set.
 362      *
 363      * @param maxValue must be valid for the {@code openType}
 364      * specified for this attribute; can be null, in which case it
 365      * means that no maximal value is set.
 366      *
 367      * @param &lt;T&gt; allows the compiler to check that the {@code
 368      * defaultValue}, {@code minValue}, and {@code maxValue}, if
 369      * non-null, have the correct Java type for the given {@code
 370      * openType}.
 371      *
 372      * @throws IllegalArgumentException if {@code name} or {@code
 373      * description} are null or empty string, or {@code openType} is
 374      * null.
 375      *
 376      * @throws OpenDataException if {@code defaultValue}, {@code
 377      * minValue} or {@code maxValue} is not a valid value for the
 378      * specified {@code openType}, or {@code defaultValue} is non null
 379      * and {@code openType} is an {@code ArrayType} or a {@code
 380      * TabularType}, or both {@code minValue} and {@code maxValue} are
 381      * non-null and {@code minValue.compareTo(maxValue) &gt; 0} is {@code
 382      * true}, or both {@code defaultValue} and {@code minValue} are
 383      * non-null and {@code minValue.compareTo(defaultValue) &gt; 0} is
 384      * {@code true}, or both {@code defaultValue} and {@code maxValue}
 385      * are non-null and {@code defaultValue.compareTo(maxValue) &gt; 0}
 386      * is {@code true}.
 387      */
 388     public &lt;T&gt; OpenMBeanAttributeInfoSupport(String     name,
 389                                              String     description,
 390                                              OpenType&lt;T&gt;   openType,
 391                                              boolean    isReadable,
 392                                              boolean    isWritable,
 393                                              boolean    isIs,
 394                                              T          defaultValue,
 395                                              Comparable&lt;T&gt; minValue,
 396                                              Comparable&lt;T&gt; maxValue)
 397             throws OpenDataException {
 398         this(name, description, openType, isReadable, isWritable, isIs,
 399              defaultValue, null, minValue, maxValue);
 400     }
 401 
 402     private &lt;T&gt; OpenMBeanAttributeInfoSupport(String name,
 403                                               String description,
 404                                               OpenType&lt;T&gt; openType,
 405                                               boolean isReadable,
 406                                               boolean isWritable,
 407                                               boolean isIs,
 408                                               T defaultValue,
 409                                               T[] legalValues,
 410                                               Comparable&lt;T&gt; minValue,
 411                                               Comparable&lt;T&gt; maxValue)
 412             throws OpenDataException {
 413         super(name,
 414               (openType==null) ? null : openType.getClassName(),
 415               description,
 416               isReadable,
 417               isWritable,
 418               isIs,
 419               makeDescriptor(openType,
 420                              defaultValue, legalValues, minValue, maxValue));
 421 
 422         this.openType = openType;
 423 
 424         Descriptor d = getDescriptor();
 425         this.defaultValue = defaultValue;
 426         this.minValue = minValue;
 427         this.maxValue = maxValue;
 428         // We already converted the array into an unmodifiable Set
 429         // in the descriptor.
 430         this.legalValues = (Set&lt;?&gt;) d.getFieldValue(&quot;legalValues&quot;);
 431 
 432         check(this);
 433     }
 434 
 435     /**
 436      * An object serialized in a version of the API before Descriptors were
 437      * added to this class will have an empty or null Descriptor.
 438      * For consistency with our
 439      * behavior in this version, we must replace the object with one
 440      * where the Descriptors reflect the same values of openType, defaultValue,
 441      * etc.
 442      **/
 443     private Object readResolve() {
 444         if (getDescriptor().getFieldNames().length == 0) {
 445             OpenType&lt;Object&gt; xopenType = cast(openType);
 446             Set&lt;Object&gt; xlegalValues = cast(legalValues);
 447             Comparable&lt;Object&gt; xminValue = cast(minValue);
 448             Comparable&lt;Object&gt; xmaxValue = cast(maxValue);
 449             return new OpenMBeanAttributeInfoSupport(
 450                     name, description, openType,
 451                     isReadable(), isWritable(), isIs(),
 452                     makeDescriptor(xopenType, defaultValue, xlegalValues,
 453                                    xminValue, xmaxValue));
 454         } else
 455             return this;
 456     }
 457 
 458     static void check(OpenMBeanParameterInfo info) throws OpenDataException {
 459         OpenType&lt;?&gt; openType = info.getOpenType();
 460         if (openType == null)
 461             throw new IllegalArgumentException(&quot;OpenType cannot be null&quot;);
 462 
 463         if (info.getName() == null ||
 464                 info.getName().trim().isEmpty())
 465             throw new IllegalArgumentException(&quot;Name cannot be null or empty&quot;);
 466 
 467         if (info.getDescription() == null ||
 468                 info.getDescription().trim().isEmpty())
 469             throw new IllegalArgumentException(&quot;Description cannot be null or empty&quot;);
 470 
 471         // Check and initialize defaultValue
 472         //
 473         if (info.hasDefaultValue()) {
 474             // Default value not supported for ArrayType and TabularType
 475             // Cast to Object because &quot;OpenType&lt;T&gt; instanceof&quot; is illegal
 476             if (openType.isArray() || (Object)openType instanceof TabularType) {
 477                 throw new OpenDataException(&quot;Default value not supported &quot; +
 478                                             &quot;for ArrayType and TabularType&quot;);
 479             }
 480             // Check defaultValue&#39;s class
 481             if (!openType.isValue(info.getDefaultValue())) {
 482                 final String msg =
 483                     &quot;Argument defaultValue&#39;s class [\&quot;&quot; +
 484                     info.getDefaultValue().getClass().getName() +
 485                     &quot;\&quot;] does not match the one defined in openType[\&quot;&quot; +
 486                     openType.getClassName() +&quot;\&quot;]&quot;;
 487                 throw new OpenDataException(msg);
 488             }
 489         }
 490 
 491         // Check that we don&#39;t have both legalValues and min or max
 492         //
 493         if (info.hasLegalValues() &amp;&amp;
 494                 (info.hasMinValue() || info.hasMaxValue())) {
 495             throw new OpenDataException(&quot;cannot have both legalValue and &quot; +
 496                                         &quot;minValue or maxValue&quot;);
 497         }
 498 
 499         // Check minValue and maxValue
 500         if (info.hasMinValue() &amp;&amp; !openType.isValue(info.getMinValue())) {
 501             final String msg =
 502                 &quot;Type of minValue [&quot; + info.getMinValue().getClass().getName() +
 503                 &quot;] does not match OpenType [&quot; + openType.getClassName() + &quot;]&quot;;
 504             throw new OpenDataException(msg);
 505         }
 506         if (info.hasMaxValue() &amp;&amp; !openType.isValue(info.getMaxValue())) {
 507             final String msg =
 508                 &quot;Type of maxValue [&quot; + info.getMaxValue().getClass().getName() +
 509                 &quot;] does not match OpenType [&quot; + openType.getClassName() + &quot;]&quot;;
 510             throw new OpenDataException(msg);
 511         }
 512 
 513         // Check that defaultValue is a legal value
 514         //
 515         if (info.hasDefaultValue()) {
 516             Object defaultValue = info.getDefaultValue();
 517             if (info.hasLegalValues() &amp;&amp;
 518                     !info.getLegalValues().contains(defaultValue)) {
 519                 throw new OpenDataException(&quot;defaultValue is not contained &quot; +
 520                                             &quot;in legalValues&quot;);
 521             }
 522 
 523             // Check that minValue &lt;= defaultValue &lt;= maxValue
 524             //
 525             if (info.hasMinValue()) {
 526                 if (compare(info.getMinValue(), defaultValue) &gt; 0) {
 527                     throw new OpenDataException(&quot;minValue cannot be greater &quot; +
 528                                                 &quot;than defaultValue&quot;);
 529                 }
 530             }
 531             if (info.hasMaxValue()) {
 532                 if (compare(info.getMaxValue(), defaultValue) &lt; 0) {
 533                     throw new OpenDataException(&quot;maxValue cannot be less &quot; +
 534                                                 &quot;than defaultValue&quot;);
 535                 }
 536             }
 537         }
 538 
 539         // Check legalValues
 540         //
 541         if (info.hasLegalValues()) {
 542             // legalValues not supported for TabularType and arrays
 543             if ((Object)openType instanceof TabularType || openType.isArray()) {
 544                 throw new OpenDataException(&quot;Legal values not supported &quot; +
 545                                             &quot;for TabularType and arrays&quot;);
 546             }
 547             // Check legalValues are valid with openType
 548             for (Object v : info.getLegalValues()) {
 549                 if (!openType.isValue(v)) {
 550                     final String msg =
 551                         &quot;Element of legalValues [&quot; + v +
 552                         &quot;] is not a valid value for the specified openType [&quot; +
 553                         openType.toString() +&quot;]&quot;;
 554                     throw new OpenDataException(msg);
 555                 }
 556             }
 557         }
 558 
 559 
 560         // Check that, if both specified, minValue &lt;= maxValue
 561         //
 562         if (info.hasMinValue() &amp;&amp; info.hasMaxValue()) {
 563             if (compare(info.getMinValue(), info.getMaxValue()) &gt; 0) {
 564                 throw new OpenDataException(&quot;minValue cannot be greater &quot; +
 565                                             &quot;than maxValue&quot;);
 566             }
 567         }
 568 
 569     }
 570 
 571     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
 572     static int compare(Object x, Object y) {
 573         return ((Comparable) x).compareTo(y);
 574     }
 575 
 576     static &lt;T&gt; Descriptor makeDescriptor(OpenType&lt;T&gt; openType,
 577                                          T defaultValue,
 578                                          T[] legalValues,
 579                                          Comparable&lt;T&gt; minValue,
 580                                          Comparable&lt;T&gt; maxValue) {
 581         Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
 582         if (defaultValue != null)
 583             map.put(&quot;defaultValue&quot;, defaultValue);
 584         if (legalValues != null) {
 585             Set&lt;T&gt; set = new HashSet&lt;T&gt;();
 586             for (T v : legalValues)
 587                 set.add(v);
 588             set = Collections.unmodifiableSet(set);
 589             map.put(&quot;legalValues&quot;, set);
 590         }
 591         if (minValue != null)
 592             map.put(&quot;minValue&quot;, minValue);
 593         if (maxValue != null)
 594             map.put(&quot;maxValue&quot;, maxValue);
 595         if (map.isEmpty()) {
 596             return openType.getDescriptor();
 597         } else {
 598             map.put(&quot;openType&quot;, openType);
 599             return new ImmutableDescriptor(map);
 600         }
 601     }
 602 
 603     static &lt;T&gt; Descriptor makeDescriptor(OpenType&lt;T&gt; openType,
 604                                          T defaultValue,
 605                                          Set&lt;T&gt; legalValues,
 606                                          Comparable&lt;T&gt; minValue,
 607                                          Comparable&lt;T&gt; maxValue) {
 608         T[] legals;
 609         if (legalValues == null)
 610             legals = null;
 611         else {
 612             legals = cast(new Object[legalValues.size()]);
 613             legalValues.toArray(legals);
 614         }
 615         return makeDescriptor(openType, defaultValue, legals, minValue, maxValue);
 616     }
 617 
 618 
 619     static &lt;T&gt; T valueFrom(Descriptor d, String name, OpenType&lt;T&gt; openType) {
 620         Object x = d.getFieldValue(name);
 621         if (x == null)
 622             return null;
 623         try {
 624             return convertFrom(x, openType);
 625         } catch (Exception e) {
 626             final String msg =
 627                 &quot;Cannot convert descriptor field &quot; + name + &quot;  to &quot; +
 628                 openType.getTypeName();
 629             throw EnvHelp.initCause(new IllegalArgumentException(msg), e);
 630         }
 631     }
 632 
 633     static &lt;T&gt; Set&lt;T&gt; valuesFrom(Descriptor d, String name,
 634                                  OpenType&lt;T&gt; openType) {
 635         Object x = d.getFieldValue(name);
 636         if (x == null)
 637             return null;
 638         Collection&lt;?&gt; coll;
 639         if (x instanceof Set&lt;?&gt;) {
 640             Set&lt;?&gt; set = (Set&lt;?&gt;) x;
 641             boolean asis = true;
 642             for (Object element : set) {
 643                 if (!openType.isValue(element)) {
 644                     asis = false;
 645                     break;
 646                 }
 647             }
 648             if (asis)
 649                 return cast(set);
 650             coll = set;
 651         } else if (x instanceof Object[]) {
 652             coll = Arrays.asList((Object[]) x);
 653         } else {
 654             final String msg =
 655                 &quot;Descriptor value for &quot; + name + &quot; must be a Set or &quot; +
 656                 &quot;an array: &quot; + x.getClass().getName();
 657             throw new IllegalArgumentException(msg);
 658         }
 659 
 660         Set&lt;T&gt; result = new HashSet&lt;T&gt;();
 661         for (Object element : coll)
 662             result.add(convertFrom(element, openType));
 663         return result;
 664     }
 665 
 666     static &lt;T&gt; Comparable&lt;?&gt; comparableValueFrom(Descriptor d, String name,
 667                                                  OpenType&lt;T&gt; openType) {
 668         T t = valueFrom(d, name, openType);
 669         if (t == null || t instanceof Comparable&lt;?&gt;)
 670             return (Comparable&lt;?&gt;) t;
 671         final String msg =
 672             &quot;Descriptor field &quot; + name + &quot; with value &quot; + t +
 673             &quot; is not Comparable&quot;;
 674         throw new IllegalArgumentException(msg);
 675     }
 676 
 677     private static &lt;T&gt; T convertFrom(Object x, OpenType&lt;T&gt; openType) {
 678         if (openType.isValue(x)) {
 679             T t = OpenMBeanAttributeInfoSupport.&lt;T&gt;cast(x);
 680             return t;
 681         }
 682         return convertFromStrings(x, openType);
 683     }
 684 
 685     private static &lt;T&gt; T convertFromStrings(Object x, OpenType&lt;T&gt; openType) {
 686         if (openType instanceof ArrayType&lt;?&gt;)
 687             return convertFromStringArray(x, openType);
 688         else if (x instanceof String)
 689             return convertFromString((String) x, openType);
 690         final String msg =
 691             &quot;Cannot convert value &quot; + x + &quot; of type &quot; +
 692             x.getClass().getName() + &quot; to type &quot; + openType.getTypeName();
 693         throw new IllegalArgumentException(msg);
 694     }
 695 
 696     private static &lt;T&gt; T convertFromString(String s, OpenType&lt;T&gt; openType) {
 697         Class&lt;T&gt; c;
 698         try {
 699             String className = openType.safeGetClassName();
 700             ReflectUtil.checkPackageAccess(className);
 701             c = cast(Class.forName(className));
 702         } catch (ClassNotFoundException e) {
 703             throw new NoClassDefFoundError(e.toString());  // can&#39;t happen
 704         }
 705 
 706         // Look for: public static T valueOf(String)
 707         Method valueOf;
 708         try {
 709             // It is safe to call this plain Class.getMethod because the class &quot;c&quot;
 710             // was checked before by ReflectUtil.checkPackageAccess(openType.safeGetClassName());
 711             valueOf = c.getMethod(&quot;valueOf&quot;, String.class);
 712             if (!Modifier.isStatic(valueOf.getModifiers()) ||
 713                     valueOf.getReturnType() != c)
 714                 valueOf = null;
 715         } catch (NoSuchMethodException e) {
 716             valueOf = null;
 717         }
 718         if (valueOf != null) {
 719             try {
 720                 return c.cast(MethodUtil.invoke(valueOf, null, new Object[] {s}));
 721             } catch (Exception e) {
 722                 final String msg =
 723                     &quot;Could not convert \&quot;&quot; + s + &quot;\&quot; using method: &quot; + valueOf;
 724                 throw new IllegalArgumentException(msg, e);
 725             }
 726         }
 727 
 728         // Look for: public T(String)
 729         Constructor&lt;T&gt; con;
 730         try {
 731             // It is safe to call this plain Class.getConstructor because the class &quot;c&quot;
 732             // was checked before by ReflectUtil.checkPackageAccess(openType.safeGetClassName());
 733             con = c.getConstructor(String.class);
 734         } catch (NoSuchMethodException e) {
 735             con = null;
 736         }
 737         if (con != null) {
 738             try {
 739                 return con.newInstance(s);
 740             } catch (Exception e) {
 741                 final String msg =
 742                     &quot;Could not convert \&quot;&quot; + s + &quot;\&quot; using constructor: &quot; + con;
 743                 throw new IllegalArgumentException(msg, e);
 744             }
 745         }
 746 
 747         throw new IllegalArgumentException(&quot;Don&#39;t know how to convert &quot; +
 748                                            &quot;string to &quot; +
 749                                            openType.getTypeName());
 750     }
 751 
 752 
 753     /* A Descriptor contained an array value encoded as Strings.  The
 754        Strings must be organized in an array corresponding to the desired
 755        array.  If the desired array has n dimensions, so must the String
 756        array.  We will convert element by element from String to desired
 757        component type. */
 758     private static &lt;T&gt; T convertFromStringArray(Object x,
 759                                                 OpenType&lt;T&gt; openType) {
 760         ArrayType&lt;?&gt; arrayType = (ArrayType&lt;?&gt;) openType;
 761         OpenType&lt;?&gt; baseType = arrayType.getElementOpenType();
 762         int dim = arrayType.getDimension();
 763         String squareBrackets = &quot;[&quot;;
 764         for (int i = 1; i &lt; dim; i++)
 765             squareBrackets += &quot;[&quot;;
 766         Class&lt;?&gt; stringArrayClass;
 767         Class&lt;?&gt; targetArrayClass;
 768         try {
 769             String baseClassName = baseType.safeGetClassName();
 770 
 771             // check access to the provided base type class name and bail out early
 772             ReflectUtil.checkPackageAccess(baseClassName);
 773 
 774             stringArrayClass =
 775                 Class.forName(squareBrackets + &quot;Ljava.lang.String;&quot;);
 776             targetArrayClass =
 777                 Class.forName(squareBrackets + &quot;L&quot; + baseClassName + &quot;;&quot;);
 778         } catch (ClassNotFoundException e) {
 779             throw new NoClassDefFoundError(e.toString());  // can&#39;t happen
 780         }
 781         if (!stringArrayClass.isInstance(x)) {
 782             final String msg =
 783                 &quot;Value for &quot; + dim + &quot;-dimensional array of &quot; +
 784                 baseType.getTypeName() + &quot; must be same type or a String &quot; +
 785                 &quot;array with same dimensions&quot;;
 786             throw new IllegalArgumentException(msg);
 787         }
 788         OpenType&lt;?&gt; componentOpenType;
 789         if (dim == 1)
 790             componentOpenType = baseType;
 791         else {
 792             try {
 793                 componentOpenType = new ArrayType&lt;T&gt;(dim - 1, baseType);
 794             } catch (OpenDataException e) {
 795                 throw new IllegalArgumentException(e.getMessage(), e);
 796                 // can&#39;t happen
 797             }
 798         }
 799         int n = Array.getLength(x);
 800         Object[] targetArray = (Object[])
 801             Array.newInstance(targetArrayClass.getComponentType(), n);
 802         for (int i = 0; i &lt; n; i++) {
 803             Object stringish = Array.get(x, i);  // String or String[] etc
 804             Object converted =
 805                 convertFromStrings(stringish, componentOpenType);
 806             Array.set(targetArray, i, converted);
 807         }
 808         return OpenMBeanAttributeInfoSupport.&lt;T&gt;cast(targetArray);
 809     }
 810 
 811     @SuppressWarnings(&quot;unchecked&quot;)
 812     static &lt;T&gt; T cast(Object x) {
 813         return (T) x;
 814     }
 815 
 816     /**
 817      * Returns the open type for the values of the attribute described
 818      * by this {@code OpenMBeanAttributeInfoSupport} instance.
 819      */
 820     public OpenType&lt;?&gt; getOpenType() {
 821         return openType;
 822     }
 823 
 824     /**
 825      * Returns the default value for the attribute described by this
 826      * {@code OpenMBeanAttributeInfoSupport} instance, if specified,
 827      * or {@code null} otherwise.
 828      */
 829     public Object getDefaultValue() {
 830 
 831         // Special case for ArrayType and TabularType
 832         // [JF] TODO: clone it so that it cannot be altered,
 833         // [JF] TODO: if we decide to support defaultValue as an array itself.
 834         // [JF] As of today (oct 2000) it is not supported so
 835         // defaultValue is null for arrays. Nothing to do.
 836 
 837         return defaultValue;
 838     }
 839 
 840     /**
 841      * Returns an unmodifiable Set of legal values for the attribute
 842      * described by this {@code OpenMBeanAttributeInfoSupport}
 843      * instance, if specified, or {@code null} otherwise.
 844      */
 845     public Set&lt;?&gt; getLegalValues() {
 846 
 847         // Special case for ArrayType and TabularType
 848         // [JF] TODO: clone values so that they cannot be altered,
 849         // [JF] TODO: if we decide to support LegalValues as an array itself.
 850         // [JF] As of today (oct 2000) it is not supported so
 851         // legalValues is null for arrays. Nothing to do.
 852 
 853         // Returns our legalValues Set (set was constructed unmodifiable)
 854         return (legalValues);
 855     }
 856 
 857     /**
 858      * Returns the minimal value for the attribute described by this
 859      * {@code OpenMBeanAttributeInfoSupport} instance, if specified,
 860      * or {@code null} otherwise.
 861      */
 862     public Comparable&lt;?&gt; getMinValue() {
 863 
 864         // Note: only comparable values have a minValue,
 865         // so that&#39;s not the case of arrays and tabulars (always null).
 866 
 867         return minValue;
 868     }
 869 
 870     /**
 871      * Returns the maximal value for the attribute described by this
 872      * {@code OpenMBeanAttributeInfoSupport} instance, if specified,
 873      * or {@code null} otherwise.
 874      */
 875     public Comparable&lt;?&gt; getMaxValue() {
 876 
 877         // Note: only comparable values have a maxValue,
 878         // so that&#39;s not the case of arrays and tabulars (always null).
 879 
 880         return maxValue;
 881     }
 882 
 883     /**
 884      * Returns {@code true} if this {@code
 885      * OpenMBeanAttributeInfoSupport} instance specifies a non-null
 886      * default value for the described attribute, {@code false}
 887      * otherwise.
 888      */
 889     public boolean hasDefaultValue() {
 890 
 891         return (defaultValue != null);
 892     }
 893 
 894     /**
 895      * Returns {@code true} if this {@code
 896      * OpenMBeanAttributeInfoSupport} instance specifies a non-null
 897      * set of legal values for the described attribute, {@code false}
 898      * otherwise.
 899      */
 900     public boolean hasLegalValues() {
 901 
 902         return (legalValues != null);
 903     }
 904 
 905     /**
 906      * Returns {@code true} if this {@code
 907      * OpenMBeanAttributeInfoSupport} instance specifies a non-null
 908      * minimal value for the described attribute, {@code false}
 909      * otherwise.
 910      */
 911     public boolean hasMinValue() {
 912 
 913         return (minValue != null);
 914     }
 915 
 916     /**
 917      * Returns {@code true} if this {@code
 918      * OpenMBeanAttributeInfoSupport} instance specifies a non-null
 919      * maximal value for the described attribute, {@code false}
 920      * otherwise.
 921      */
 922     public boolean hasMaxValue() {
 923 
 924         return (maxValue != null);
 925     }
 926 
 927 
 928     /**
 929      * Tests whether {@code obj} is a valid value for the attribute
 930      * described by this {@code OpenMBeanAttributeInfoSupport}
 931      * instance.
 932      *
 933      * @param obj the object to be tested.
 934      *
 935      * @return {@code true} if {@code obj} is a valid value for
 936      * the parameter described by this {@code
 937      * OpenMBeanAttributeInfoSupport} instance, {@code false}
 938      * otherwise.
 939      */
 940     public boolean isValue(Object obj) {
 941         return isValue(this, obj);
 942     }
 943 
 944     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})  // cast to Comparable
 945     static boolean isValue(OpenMBeanParameterInfo info, Object obj) {
 946         if (info.hasDefaultValue() &amp;&amp; obj == null)
 947             return true;
 948         return
 949             info.getOpenType().isValue(obj) &amp;&amp;
 950             (!info.hasLegalValues() || info.getLegalValues().contains(obj)) &amp;&amp;
 951             (!info.hasMinValue() ||
 952             ((Comparable) info.getMinValue()).compareTo(obj) &lt;= 0) &amp;&amp;
 953             (!info.hasMaxValue() ||
 954             ((Comparable) info.getMaxValue()).compareTo(obj) &gt;= 0);
 955     }
 956 
 957     /* ***  Commodity methods from java.lang.Object  *** */
 958 
 959 
 960     /**
 961      * Compares the specified {@code obj} parameter with this {@code
 962      * OpenMBeanAttributeInfoSupport} instance for equality.
 963      * &lt;p&gt;
 964      * Returns {@code true} if and only if all of the following statements are true:
 965      * &lt;ul&gt;
 966      * &lt;li&gt;{@code obj} is non null,&lt;/li&gt;
 967      * &lt;li&gt;{@code obj} also implements the {@code OpenMBeanAttributeInfo} interface,&lt;/li&gt;
 968      * &lt;li&gt;their names are equal&lt;/li&gt;
 969      * &lt;li&gt;their open types are equal&lt;/li&gt;
 970      * &lt;li&gt;their access properties (isReadable, isWritable and isIs) are equal&lt;/li&gt;
 971      * &lt;li&gt;their default, min, max and legal values are equal.&lt;/li&gt;
 972      * &lt;/ul&gt;
 973      * This ensures that this {@code equals} method works properly for
 974      * {@code obj} parameters which are different implementations of
 975      * the {@code OpenMBeanAttributeInfo} interface.
 976      *
 977      * &lt;p&gt;If {@code obj} also implements {@link DescriptorRead}, then its
 978      * {@link DescriptorRead#getDescriptor() getDescriptor()} method must
 979      * also return the same value as for this object.&lt;/p&gt;
 980      *
 981      * @param obj the object to be compared for equality with this
 982      * {@code OpenMBeanAttributeInfoSupport} instance.
 983      *
 984      * @return {@code true} if the specified object is equal to this
 985      * {@code OpenMBeanAttributeInfoSupport} instance.
 986      */
 987     public boolean equals(Object obj) {
 988         if (!(obj instanceof OpenMBeanAttributeInfo))
 989             return false;
 990 
 991         OpenMBeanAttributeInfo other = (OpenMBeanAttributeInfo) obj;
 992 
 993         return
 994             this.isReadable() == other.isReadable() &amp;&amp;
 995             this.isWritable() == other.isWritable() &amp;&amp;
 996             this.isIs() == other.isIs() &amp;&amp;
 997             equal(this, other);
 998     }
 999 
1000     static boolean equal(OpenMBeanParameterInfo x1, OpenMBeanParameterInfo x2) {
1001         if (x1 instanceof DescriptorRead) {
1002             if (!(x2 instanceof DescriptorRead))
1003                 return false;
1004             Descriptor d1 = ((DescriptorRead) x1).getDescriptor();
1005             Descriptor d2 = ((DescriptorRead) x2).getDescriptor();
1006             if (!d1.equals(d2))
1007                 return false;
1008         } else if (x2 instanceof DescriptorRead)
1009             return false;
1010 
1011         return
1012             x1.getName().equals(x2.getName()) &amp;&amp;
1013             x1.getOpenType().equals(x2.getOpenType()) &amp;&amp;
1014             (x1.hasDefaultValue() ?
1015                 x1.getDefaultValue().equals(x2.getDefaultValue()) :
1016                 !x2.hasDefaultValue()) &amp;&amp;
1017             (x1.hasMinValue() ?
1018                 x1.getMinValue().equals(x2.getMinValue()) :
1019                 !x2.hasMinValue()) &amp;&amp;
1020             (x1.hasMaxValue() ?
1021                 x1.getMaxValue().equals(x2.getMaxValue()) :
1022                 !x2.hasMaxValue()) &amp;&amp;
1023             (x1.hasLegalValues() ?
1024                 x1.getLegalValues().equals(x2.getLegalValues()) :
1025                 !x2.hasLegalValues());
1026     }
1027 
1028     /**
1029      * &lt;p&gt;Returns the hash code value for this {@code
1030      * OpenMBeanAttributeInfoSupport} instance.&lt;/p&gt;
1031      *
1032      * &lt;p&gt;The hash code of an {@code OpenMBeanAttributeInfoSupport}
1033      * instance is the sum of the hash codes of all elements of
1034      * information used in {@code equals} comparisons (ie: its name,
1035      * its &lt;i&gt;open type&lt;/i&gt;, its default, min, max and legal
1036      * values, and its Descriptor).
1037      *
1038      * &lt;p&gt;This ensures that {@code t1.equals(t2)} implies that {@code
1039      * t1.hashCode()==t2.hashCode()} for any two {@code
1040      * OpenMBeanAttributeInfoSupport} instances {@code t1} and {@code
1041      * t2}, as required by the general contract of the method {@link
1042      * Object#hashCode() Object.hashCode()}.
1043      *
1044      * &lt;p&gt;However, note that another instance of a class implementing
1045      * the {@code OpenMBeanAttributeInfo} interface may be equal to
1046      * this {@code OpenMBeanAttributeInfoSupport} instance as defined
1047      * by {@link #equals(java.lang.Object)}, but may have a different
1048      * hash code if it is calculated differently.
1049      *
1050      * &lt;p&gt;As {@code OpenMBeanAttributeInfoSupport} instances are
1051      * immutable, the hash code for this instance is calculated once,
1052      * on the first call to {@code hashCode}, and then the same value
1053      * is returned for subsequent calls.
1054      *
1055      * @return the hash code value for this {@code
1056      * OpenMBeanAttributeInfoSupport} instance
1057      */
1058     public int hashCode() {
1059 
1060         // Calculate the hash code value if it has not yet been done
1061         // (ie 1st call to hashCode())
1062         //
1063         if (myHashCode == null)
1064             myHashCode = hashCode(this);
1065 
1066         // return always the same hash code for this instance (immutable)
1067         //
1068         return myHashCode.intValue();
1069     }
1070 
1071     static int hashCode(OpenMBeanParameterInfo info) {
1072         int value = 0;
1073         value += info.getName().hashCode();
1074         value += info.getOpenType().hashCode();
1075         if (info.hasDefaultValue())
1076             value += info.getDefaultValue().hashCode();
1077         if (info.hasMinValue())
1078             value += info.getMinValue().hashCode();
1079         if (info.hasMaxValue())
1080             value += info.getMaxValue().hashCode();
1081         if (info.hasLegalValues())
1082             value += info.getLegalValues().hashCode();
1083         if (info instanceof DescriptorRead)
1084             value += ((DescriptorRead) info).getDescriptor().hashCode();
1085         return value;
1086     }
1087 
1088     /**
1089      * Returns a string representation of this
1090      * {@code OpenMBeanAttributeInfoSupport} instance.
1091      * &lt;p&gt;
1092      * The string representation consists of the name of this class (i.e.
1093      * {@code javax.management.openmbean.OpenMBeanAttributeInfoSupport}),
1094      * the string representation of the name and open type of the
1095      * described parameter, the string representation of its
1096      * default, min, max and legal values and the string
1097      * representation of its descriptor.
1098      *
1099      * &lt;p&gt;As {@code OpenMBeanAttributeInfoSupport} instances are
1100      * immutable, the string representation for this instance is
1101      * calculated once, on the first call to {@code toString}, and
1102      * then the same value is returned for subsequent calls.
1103      *
1104      * @return a string representation of this
1105      * {@code OpenMBeanAttributeInfoSupport} instance.
1106      */
1107     public String toString() {
1108 
1109         // Calculate the string value if it has not yet been done
1110         // (ie 1st call to toString())
1111         //
1112         if (myToString == null)
1113             myToString = toString(this);
1114 
1115         // return always the same string representation for this
1116         // instance (immutable)
1117         //
1118         return myToString;
1119     }
1120 
1121     static String toString(OpenMBeanParameterInfo info) {
1122         Descriptor d = (info instanceof DescriptorRead) ?
1123             ((DescriptorRead) info).getDescriptor() : null;
1124         return
1125             info.getClass().getName() +
1126             &quot;(name=&quot; + info.getName() +
1127             &quot;,openType=&quot; + info.getOpenType() +
1128             &quot;,default=&quot; + info.getDefaultValue() +
1129             &quot;,minValue=&quot; + info.getMinValue() +
1130             &quot;,maxValue=&quot; + info.getMaxValue() +
1131             &quot;,legalValues=&quot; + info.getLegalValues() +
1132             ((d == null) ? &quot;&quot; : &quot;,descriptor=&quot; + d) +
1133             &quot;)&quot;;
1134     }
1135 }
    </pre>
  </body>
</html>
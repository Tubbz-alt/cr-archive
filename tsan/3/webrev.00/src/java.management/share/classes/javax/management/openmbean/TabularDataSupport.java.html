<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.management/share/classes/javax/management/openmbean/TabularDataSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 package javax.management.openmbean;
 28 
 29 
 30 // java import
 31 //
 32 import com.sun.jmx.mbeanserver.GetPropertyAction;
 33 import com.sun.jmx.mbeanserver.Util;
 34 import java.io.IOException;
 35 import java.io.ObjectInputStream;
 36 import java.io.Serializable;
 37 import java.security.AccessController;
 38 import java.util.ArrayList;
 39 import java.util.Arrays;
 40 import java.util.Collection;
 41 import java.util.Collections;
 42 import java.util.HashMap;
 43 import java.util.Iterator;
 44 import java.util.LinkedHashMap;
 45 import java.util.List;
 46 import java.util.Map;
 47 import java.util.Set;
 48 import jdk.internal.access.SharedSecrets;
 49 
 50 // jmx import
 51 //
 52 
 53 
 54 /**
 55  * The {@code TabularDataSupport} class is the &lt;i&gt;open data&lt;/i&gt;
 56  * class which implements the {@code TabularData}
 57  * and the {@code Map} interfaces, and which is internally based on a hash map data structure.
 58  *
 59  * @since 1.5
 60  */
 61 /* It would make much more sense to implement
 62    Map&lt;List&lt;?&gt;,CompositeData&gt; here, but unfortunately we cannot for
 63    compatibility reasons.  If we did that, then we would have to
 64    define e.g.
 65    CompositeData remove(Object)
 66    instead of
 67    Object remove(Object).
 68 
 69    That would mean that if any existing code subclassed
 70    TabularDataSupport and overrode
 71    Object remove(Object),
 72    it would (a) no longer compile and (b) not actually override
 73    CompositeData remove(Object)
 74    in binaries compiled before the change.
 75 */
 76 public class TabularDataSupport
 77     implements TabularData, Map&lt;Object,Object&gt;,
 78                Cloneable, Serializable {
 79 
 80 
 81     /* Serial version */
 82     static final long serialVersionUID = 5720150593236309827L;
 83 
 84 
 85     /**
 86      * @serial This tabular data instance&#39;s contents: a {@link HashMap}
 87      */
 88     // field cannot be final because of clone method
 89     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
 90     private Map&lt;Object,CompositeData&gt; dataMap;
 91 
 92     /**
 93      * @serial This tabular data instance&#39;s tabular type
 94      */
 95     private final TabularType tabularType;
 96 
 97     /**
 98      * The array of item names that define the index used for rows (convenience field)
 99      */
100     private transient String[] indexNamesArray;
101 
102 
103 
104     /* *** Constructors *** */
105 
106 
107     /**
108      * Creates an empty {@code TabularDataSupport} instance
109      * whose open-type is &lt;var&gt;tabularType&lt;/var&gt;,
110      * and whose underlying {@code HashMap} has a default
111      * initial capacity (101) and default load factor (0.75).
112      * &lt;p&gt;
113      * This constructor simply calls {@code this(tabularType, 101, 0.75f);}
114      *
115      * @param  tabularType the &lt;i&gt;tabular type&lt;/i&gt; describing this
116      *         {@code TabularData} instance; cannot be null.
117      *
118      * @throws IllegalArgumentException  if the tabular type is null.
119      */
120     public TabularDataSupport(TabularType tabularType) {
121 
122         this(tabularType, 16, 0.75f);
123     }
124 
125     /**
126      * Creates an empty {@code TabularDataSupport} instance whose open-type is &lt;var&gt;tabularType&lt;/var&gt;,
127      * and whose underlying {@code HashMap} has the specified initial capacity and load factor.
128      *
129      * @param  tabularType               the &lt;i&gt;tabular type&lt;/i&gt; describing this {@code TabularData} instance;
130      *                           cannot be null.
131      *
132      * @param  initialCapacity   the initial capacity of the HashMap.
133      *
134      * @param  loadFactor        the load factor of the HashMap
135      *
136      * @throws IllegalArgumentException  if the initial capacity is less than zero,
137      *                                   or the load factor is nonpositive,
138      *                                   or the tabular type is null.
139      */
140     public TabularDataSupport(TabularType tabularType, int initialCapacity, float loadFactor) {
141 
142         // Check tabularType is not null
143         //
144         if (tabularType == null) {
145             throw new IllegalArgumentException(&quot;Argument tabularType cannot be null.&quot;);
146         }
147 
148         // Initialize this.tabularType (and indexNamesArray for convenience)
149         //
150         this.tabularType = tabularType;
151         List&lt;String&gt; tmpNames = tabularType.getIndexNames();
152         this.indexNamesArray = tmpNames.toArray(new String[tmpNames.size()]);
153 
154         // Since LinkedHashMap was introduced in SE 1.4, it&#39;s conceivable even
155         // if very unlikely that we might be the server of a 1.3 client.  In
156         // that case you&#39;ll need to set this property.  See CR 6334663.
157         String useHashMapProp = AccessController.doPrivileged(
158                 new GetPropertyAction(&quot;jmx.tabular.data.hash.map&quot;));
159         boolean useHashMap = &quot;true&quot;.equalsIgnoreCase(useHashMapProp);
160 
161         // Construct the empty contents HashMap
162         //
163         this.dataMap = useHashMap ?
164             new HashMap&lt;Object,CompositeData&gt;(initialCapacity, loadFactor) :
165             new LinkedHashMap&lt;Object, CompositeData&gt;(initialCapacity, loadFactor);
166     }
167 
168 
169 
170 
171     /* *** TabularData specific information methods *** */
172 
173 
174     /**
175      * Returns the &lt;i&gt;tabular type&lt;/i&gt; describing this {@code TabularData} instance.
176      */
177     public TabularType getTabularType() {
178 
179         return tabularType;
180     }
181 
182     /**
183      * Calculates the index that would be used in this {@code TabularData} instance to refer
184      * to the specified composite data &lt;var&gt;value&lt;/var&gt; parameter if it were added to this instance.
185      * This method checks for the type validity of the specified &lt;var&gt;value&lt;/var&gt;,
186      * but does not check if the calculated index is already used
187      * to refer to a value in this {@code TabularData} instance.
188      *
189      * @param  value                      the composite data value whose index in this
190      *                                    {@code TabularData} instance is to be calculated;
191      *                                    must be of the same composite type as this instance&#39;s row type;
192      *                                    must not be null.
193      *
194      * @return the index that the specified &lt;var&gt;value&lt;/var&gt; would have in this {@code TabularData} instance.
195      *
196      * @throws NullPointerException       if &lt;var&gt;value&lt;/var&gt; is {@code null}.
197      *
198      * @throws InvalidOpenTypeException   if &lt;var&gt;value&lt;/var&gt; does not conform to this {@code TabularData} instance&#39;s
199      *                                    row type definition.
200      */
201     public Object[] calculateIndex(CompositeData value) {
202 
203         // Check value is valid
204         //
205         checkValueType(value);
206 
207         // Return its calculated index
208         //
209         return internalCalculateIndex(value).toArray();
210     }
211 
212 
213 
214 
215     /* *** Content information query methods *** */
216 
217 
218     /**
219      * Returns {@code true} if and only if this {@code TabularData} instance contains a {@code CompositeData} value
220      * (ie a row) whose index is the specified &lt;var&gt;key&lt;/var&gt;. If &lt;var&gt;key&lt;/var&gt; cannot be cast to a one dimension array
221      * of Object instances, this method simply returns {@code false}; otherwise it returns the result of the call to
222      * {@code this.containsKey((Object[]) key)}.
223      *
224      * @param  key  the index value whose presence in this {@code TabularData} instance is to be tested.
225      *
226      * @return  {@code true} if this {@code TabularData} indexes a row value with the specified key.
227      */
228     public boolean containsKey(Object key) {
229 
230         // if key is not an array of Object instances, return false
231         //
232         Object[] k;
233         try {
234             k = (Object[]) key;
235         } catch (ClassCastException e) {
236             return false;
237         }
238 
239         return  this.containsKey(k);
240     }
241 
242     /**
243      * Returns {@code true} if and only if this {@code TabularData} instance contains a {@code CompositeData} value
244      * (ie a row) whose index is the specified &lt;var&gt;key&lt;/var&gt;. If &lt;var&gt;key&lt;/var&gt; is {@code null} or does not conform to
245      * this {@code TabularData} instance&#39;s {@code TabularType} definition, this method simply returns {@code false}.
246      *
247      * @param  key  the index value whose presence in this {@code TabularData} instance is to be tested.
248      *
249      * @return  {@code true} if this {@code TabularData} indexes a row value with the specified key.
250      */
251     public boolean containsKey(Object[] key) {
252 
253         return  ( key == null ? false : dataMap.containsKey(Arrays.asList(key)));
254     }
255 
256     /**
257      * Returns {@code true} if and only if this {@code TabularData} instance contains the specified
258      * {@code CompositeData} value. If &lt;var&gt;value&lt;/var&gt; is {@code null} or does not conform to
259      * this {@code TabularData} instance&#39;s row type definition, this method simply returns {@code false}.
260      *
261      * @param  value  the row value whose presence in this {@code TabularData} instance is to be tested.
262      *
263      * @return  {@code true} if this {@code TabularData} instance contains the specified row value.
264      */
265     public boolean containsValue(CompositeData value) {
266 
267         return dataMap.containsValue(value);
268     }
269 
270     /**
271      * Returns {@code true} if and only if this {@code TabularData} instance contains the specified
272      * value.
273      *
274      * @param  value  the row value whose presence in this {@code TabularData} instance is to be tested.
275      *
276      * @return  {@code true} if this {@code TabularData} instance contains the specified row value.
277      */
278     public boolean containsValue(Object value) {
279 
280         return dataMap.containsValue(value);
281     }
282 
283     /**
284      * This method simply calls {@code get((Object[]) key)}.
285      *
286      * @throws NullPointerException  if the &lt;var&gt;key&lt;/var&gt; is {@code null}
287      * @throws ClassCastException    if the &lt;var&gt;key&lt;/var&gt; is not of the type {@code Object[]}
288      * @throws InvalidKeyException   if the &lt;var&gt;key&lt;/var&gt; does not conform
289      *                               to this {@code TabularData} instance&#39;s
290      *                               {@code TabularType} definition
291      */
292     public Object get(Object key) {
293 
294         return get((Object[]) key);
295     }
296 
297     /**
298      * Returns the {@code CompositeData} value whose index is
299      * &lt;var&gt;key&lt;/var&gt;, or {@code null} if there is no value mapping
300      * to &lt;var&gt;key&lt;/var&gt;, in this {@code TabularData} instance.
301      *
302      * @param key the index of the value to get in this
303      * {@code TabularData} instance; must be valid with this
304      * {@code TabularData} instance&#39;s row type definition; must not
305      * be null.
306      *
307      * @return the value corresponding to &lt;var&gt;key&lt;/var&gt;.
308      *
309      * @throws NullPointerException  if the &lt;var&gt;key&lt;/var&gt; is {@code null}
310      * @throws InvalidKeyException   if the &lt;var&gt;key&lt;/var&gt; does not conform
311      *                               to this {@code TabularData} instance&#39;s
312      *                               {@code TabularType} type definition.
313      */
314     public CompositeData get(Object[] key) {
315 
316         // Check key is not null and valid with tabularType
317         // (throws NullPointerException, InvalidKeyException)
318         //
319         checkKeyType(key);
320 
321         // Return the mapping stored in the parent HashMap
322         //
323         return dataMap.get(Arrays.asList(key));
324     }
325 
326 
327 
328 
329     /* *** Content modification operations (one element at a time) *** */
330 
331 
332     /**
333      * This method simply calls {@code put((CompositeData) value)} and
334      * therefore ignores its &lt;var&gt;key&lt;/var&gt; parameter which can be {@code null}.
335      *
336      * @param key an ignored parameter.
337      * @param value the {@link CompositeData} to put.
338      *
339      * @return the value which is put
340      *
341      * @throws NullPointerException  if the &lt;var&gt;value&lt;/var&gt; is {@code null}
342      * @throws ClassCastException if the &lt;var&gt;value&lt;/var&gt; is not of
343      * the type {@code CompositeData}
344      * @throws InvalidOpenTypeException if the &lt;var&gt;value&lt;/var&gt; does
345      * not conform to this {@code TabularData} instance&#39;s
346      * {@code TabularType} definition
347      * @throws KeyAlreadyExistsException if the key for the
348      * &lt;var&gt;value&lt;/var&gt; parameter, calculated according to this
349      * {@code TabularData} instance&#39;s {@code TabularType} definition
350      * already maps to an existing value
351      */
352     public Object put(Object key, Object value) {
353         internalPut((CompositeData) value);
354         return value; // should be return internalPut(...); (5090566)
355     }
356 
357     public void put(CompositeData value) {
358         internalPut(value);
359     }
360 
361     private CompositeData internalPut(CompositeData value) {
362         // Check value is not null, value&#39;s type is the same as this instance&#39;s row type,
363         // and calculate the value&#39;s index according to this instance&#39;s tabularType and
364         // check it is not already used for a mapping in the parent HashMap
365         //
366         List&lt;?&gt; index = checkValueAndIndex(value);
367 
368         // store the (key, value) mapping in the dataMap HashMap
369         //
370         return dataMap.put(index, value);
371     }
372 
373     /**
374      * This method simply calls {@code remove((Object[]) key)}.
375      *
376      * @param key an {@code Object[]} representing the key to remove.
377      *
378      * @return previous value associated with specified key, or {@code null}
379      *         if there was no mapping for key.
380      *
381      * @throws NullPointerException  if the &lt;var&gt;key&lt;/var&gt; is {@code null}
382      * @throws ClassCastException    if the &lt;var&gt;key&lt;/var&gt; is not of the type {@code Object[]}
383      * @throws InvalidKeyException   if the &lt;var&gt;key&lt;/var&gt; does not conform to this {@code TabularData} instance&#39;s
384      *                               {@code TabularType} definition
385      */
386     public Object remove(Object key) {
387 
388         return remove((Object[]) key);
389     }
390 
391     /**
392      * Removes the {@code CompositeData} value whose index is &lt;var&gt;key&lt;/var&gt; from this {@code TabularData} instance,
393      * and returns the removed value, or returns {@code null} if there is no value whose index is &lt;var&gt;key&lt;/var&gt;.
394      *
395      * @param  key  the index of the value to get in this {@code TabularData} instance;
396      *              must be valid with this {@code TabularData} instance&#39;s row type definition;
397      *              must not be null.
398      *
399      * @return previous value associated with specified key, or {@code null}
400      *         if there was no mapping for key.
401      *
402      * @throws NullPointerException  if the &lt;var&gt;key&lt;/var&gt; is {@code null}
403      * @throws InvalidKeyException   if the &lt;var&gt;key&lt;/var&gt; does not conform to this {@code TabularData} instance&#39;s
404      *                               {@code TabularType} definition
405      */
406     public CompositeData remove(Object[] key) {
407 
408         // Check key is not null and valid with tabularType
409         // (throws NullPointerException, InvalidKeyException)
410         //
411         checkKeyType(key);
412 
413         // Removes the (key, value) mapping in the parent HashMap
414         //
415         return dataMap.remove(Arrays.asList(key));
416     }
417 
418 
419 
420     /* ***   Content modification bulk operations   *** */
421 
422 
423     /**
424      * Add all the values contained in the specified map &lt;var&gt;t&lt;/var&gt;
425      * to this {@code TabularData} instance.  This method converts
426      * the collection of values contained in this map into an array of
427      * {@code CompositeData} values, if possible, and then call the
428      * method {@code putAll(CompositeData[])}. Note that the keys
429      * used in the specified map &lt;var&gt;t&lt;/var&gt; are ignored. This method
430      * allows, for example to add the content of another
431      * {@code TabularData} instance with the same row type (but
432      * possibly different index names) into this instance.
433      *
434      * @param t the map whose values are to be added as new rows to
435      * this {@code TabularData} instance; if &lt;var&gt;t&lt;/var&gt; is
436      * {@code null} or empty, this method returns without doing
437      * anything.
438      *
439      * @throws NullPointerException if a value in &lt;var&gt;t&lt;/var&gt; is
440      * {@code null}.
441      * @throws ClassCastException if a value in &lt;var&gt;t&lt;/var&gt; is not an
442      * instance of {@code CompositeData}.
443      * @throws InvalidOpenTypeException if a value in &lt;var&gt;t&lt;/var&gt;
444      * does not conform to this {@code TabularData} instance&#39;s row
445      * type definition.
446      * @throws KeyAlreadyExistsException if the index for a value in
447      * &lt;var&gt;t&lt;/var&gt;, calculated according to this
448      * {@code TabularData} instance&#39;s {@code TabularType} definition
449      * already maps to an existing value in this instance, or two
450      * values in &lt;var&gt;t&lt;/var&gt; have the same index.
451      */
452     public void putAll(Map&lt;?,?&gt; t) {
453 
454         // if t is null or empty, just return
455         //
456         if ( (t == null) || (t.size() == 0) ) {
457             return;
458         }
459 
460         // Convert the values in t into an array of {@code CompositeData}
461         //
462         CompositeData[] values;
463         try {
464             values =
465                 t.values().toArray(new CompositeData[t.size()]);
466         } catch (java.lang.ArrayStoreException e) {
467             throw new ClassCastException(&quot;Map argument t contains values which are not instances of {@code CompositeData}&quot;);
468         }
469 
470         // Add the array of values
471         //
472         putAll(values);
473     }
474 
475     /**
476      * Add all the elements in &lt;var&gt;values&lt;/var&gt; to this
477      * {@code TabularData} instance.  If any element in
478      * &lt;var&gt;values&lt;/var&gt; does not satisfy the constraints defined in
479      * {@link #put(CompositeData) put}, or if any two
480      * elements in &lt;var&gt;values&lt;/var&gt; have the same index calculated
481      * according to this {@code TabularData} instance&#39;s
482      * {@code TabularType} definition, then an exception describing
483      * the failure is thrown and no element of &lt;var&gt;values&lt;/var&gt; is
484      * added, thus leaving this {@code TabularData} instance
485      * unchanged.
486      *
487      * @param values the array of composite data values to be added as
488      * new rows to this {@code TabularData} instance; if
489      * &lt;var&gt;values&lt;/var&gt; is {@code null} or empty, this method
490      * returns without doing anything.
491      *
492      * @throws NullPointerException if an element of &lt;var&gt;values&lt;/var&gt;
493      * is {@code null}
494      * @throws InvalidOpenTypeException if an element of
495      * &lt;var&gt;values&lt;/var&gt; does not conform to this
496      * {@code TabularData} instance&#39;s row type definition (ie its
497      * {@code TabularType} definition)
498      * @throws KeyAlreadyExistsException if the index for an element
499      * of &lt;var&gt;values&lt;/var&gt;, calculated according to this
500      * {@code TabularData} instance&#39;s {@code TabularType} definition
501      * already maps to an existing value in this instance, or two
502      * elements of &lt;var&gt;values&lt;/var&gt; have the same index
503      */
504     public void putAll(CompositeData[] values) {
505 
506         // if values is null or empty, just return
507         //
508         if ( (values == null) || (values.length == 0) ) {
509             return;
510         }
511 
512         // create the list of indexes corresponding to each value
513         List&lt;List&lt;?&gt;&gt; indexes =
514             new ArrayList&lt;List&lt;?&gt;&gt;(values.length + 1);
515 
516         // Check all elements in values and build index list
517         //
518         List&lt;?&gt; index;
519         for (int i=0; i&lt;values.length; i++) {
520             // check value and calculate index
521             index = checkValueAndIndex(values[i]);
522             // check index is different of those previously calculated
523             if (indexes.contains(index)) {
524                 throw new KeyAlreadyExistsException(&quot;Argument elements values[&quot;+ i +&quot;] and values[&quot;+ indexes.indexOf(index) +
525                                                     &quot;] have the same indexes, &quot;+
526                                                     &quot;calculated according to this TabularData instance&#39;s tabularType.&quot;);
527             }
528             // add to index list
529             indexes.add(index);
530         }
531 
532         // store all (index, value) mappings in the dataMap HashMap
533         //
534         for (int i=0; i&lt;values.length; i++) {
535             dataMap.put(indexes.get(i), values[i]);
536         }
537     }
538 
539     /**
540      * Removes all rows from this {@code TabularDataSupport} instance.
541      */
542     public void clear() {
543 
544         dataMap.clear();
545     }
546 
547 
548 
549     /* ***  Informational methods from java.util.Map  *** */
550 
551     /**
552      * Returns the number of rows in this {@code TabularDataSupport} instance.
553      *
554      * @return the number of rows in this {@code TabularDataSupport} instance.
555      */
556     public int size() {
557 
558         return dataMap.size();
559     }
560 
561     /**
562      * Returns {@code true} if this {@code TabularDataSupport} instance contains no rows.
563      *
564      * @return {@code true} if this {@code TabularDataSupport} instance contains no rows.
565      */
566     public boolean isEmpty() {
567 
568         return (this.size() == 0);
569     }
570 
571 
572 
573     /* ***  Collection views from java.util.Map  *** */
574 
575     /**
576      * Returns a set view of the keys contained in the underlying map of this
577      * {@code TabularDataSupport} instance used to index the rows.
578      * Each key contained in this {@code Set} is an unmodifiable {@code List&lt;?&gt;}
579      * so the returned set view is a {@code Set&lt;List&lt;?&gt;&gt;} but is declared as a
580      * {@code Set&lt;Object&gt;} for compatibility reasons.
581      * The set is backed by the underlying map of this
582      * {@code TabularDataSupport} instance, so changes to the
583      * {@code TabularDataSupport} instance are reflected in the
584      * set, and vice-versa.
585      *
586      * The set supports element removal, which removes the corresponding
587      * row from this {@code TabularDataSupport} instance, via the
588      * {@link Iterator#remove}, {@link Set#remove}, {@link Set#removeAll},
589      * {@link Set#retainAll}, and {@link Set#clear} operations. It does
590      *  not support the {@link Set#add} or {@link Set#addAll} operations.
591      *
592      * @return a set view ({@code Set&lt;List&lt;?&gt;&gt;}) of the keys used to index
593      * the rows of this {@code TabularDataSupport} instance.
594      */
595     public Set&lt;Object&gt; keySet() {
596 
597         return dataMap.keySet() ;
598     }
599 
600     /**
601      * Returns a collection view of the rows contained in this
602      * {@code TabularDataSupport} instance. The returned {@code Collection}
603      * is a {@code Collection&lt;CompositeData&gt;} but is declared as a
604      * {@code Collection&lt;Object&gt;} for compatibility reasons.
605      * The returned collection can be used to iterate over the values.
606      * The collection is backed by the underlying map, so changes to the
607      * {@code TabularDataSupport} instance are reflected in the collection,
608      * and vice-versa.
609      *
610      * The collection supports element removal, which removes the corresponding
611      * index to row mapping from this {@code TabularDataSupport} instance, via
612      * the {@link Iterator#remove}, {@link Collection#remove},
613      * {@link Collection#removeAll}, {@link Collection#retainAll},
614      * and {@link Collection#clear} operations. It does not support
615      * the {@link Collection#add} or {@link Collection#addAll} operations.
616      *
617      * @return a collection view ({@code Collection&lt;CompositeData&gt;}) of
618      * the values contained in this {@code TabularDataSupport} instance.
619      */
620     @SuppressWarnings(&quot;unchecked&quot;)  // historical confusion about the return type
621     public Collection&lt;Object&gt; values() {
622 
623         return Util.cast(dataMap.values());
624     }
625 
626 
627     /**
628      * Returns a collection view of the index to row mappings
629      * contained in this {@code TabularDataSupport} instance.
630      * Each element in the returned collection is
631      * a {@code Map.Entry&lt;List&lt;?&gt;,CompositeData&gt;} but
632      * is declared as a {@code Map.Entry&lt;Object,Object&gt;}
633      * for compatibility reasons. Each of the map entry
634      * keys is an unmodifiable {@code List&lt;?&gt;}.
635      * The collection is backed by the underlying map of this
636      * {@code TabularDataSupport} instance, so changes to the
637      * {@code TabularDataSupport} instance are reflected in
638      * the collection, and vice-versa.
639      * The collection supports element removal, which removes
640      * the corresponding mapping from the map, via the
641      * {@link Iterator#remove}, {@link Collection#remove},
642      * {@link Collection#removeAll}, {@link Collection#retainAll},
643      * and {@link Collection#clear} operations. It does not support
644      * the {@link Collection#add} or {@link Collection#addAll}
645      * operations.
646      * &lt;p&gt;
647      * &lt;b&gt;IMPORTANT NOTICE&lt;/b&gt;: Do not use the {@code setValue} method of the
648      * {@code Map.Entry} elements contained in the returned collection view.
649      * Doing so would corrupt the index to row mappings contained in this
650      * {@code TabularDataSupport} instance.
651      *
652      * @return a collection view ({@code Set&lt;Map.Entry&lt;List&lt;?&gt;,CompositeData&gt;&gt;})
653      * of the mappings contained in this map.
654      * @see java.util.Map.Entry
655      */
656     @SuppressWarnings(&quot;unchecked&quot;)  // historical confusion about the return type
657     public Set&lt;Map.Entry&lt;Object,Object&gt;&gt; entrySet() {
658 
659         return Util.cast(dataMap.entrySet());
660     }
661 
662 
663     /* ***  Commodity methods from java.lang.Object  *** */
664 
665 
666     /**
667      * Returns a clone of this {@code TabularDataSupport} instance:
668      * the clone is obtained by calling {@code super.clone()}, and then cloning the underlying map.
669      * Only a shallow clone of the underlying map is made, i.e.
670      * no cloning of the indexes and row values is made as they are immutable.
671      */
672     /* We cannot use covariance here and return TabularDataSupport
673        because this would fail with existing code that subclassed
674        TabularDataSupport and overrode Object clone().  It would not
675        override the new clone().  */
676     public Object clone() {
677         try {
678             TabularDataSupport c = (TabularDataSupport) super.clone();
679             c.dataMap = new HashMap&lt;Object,CompositeData&gt;(c.dataMap);
680             return c;
681         }
682         catch (CloneNotSupportedException e) {
683             throw new InternalError(e.toString(), e);
684         }
685     }
686 
687 
688     /**
689      * Compares the specified &lt;var&gt;obj&lt;/var&gt; parameter with this {@code TabularDataSupport} instance for equality.
690      * &lt;p&gt;
691      * Returns {@code true} if and only if all of the following statements are true:
692      * &lt;ul&gt;
693      * &lt;li&gt;&lt;var&gt;obj&lt;/var&gt; is non null,&lt;/li&gt;
694      * &lt;li&gt;&lt;var&gt;obj&lt;/var&gt; also implements the {@code TabularData} interface,&lt;/li&gt;
695      * &lt;li&gt;their tabular types are equal&lt;/li&gt;
696      * &lt;li&gt;their contents (ie all CompositeData values) are equal.&lt;/li&gt;
697      * &lt;/ul&gt;
698      * This ensures that this {@code equals} method works properly for &lt;var&gt;obj&lt;/var&gt; parameters which are
699      * different implementations of the {@code TabularData} interface.
700      * &lt;br&gt;&amp;nbsp;
701      * @param  obj  the object to be compared for equality with this {@code TabularDataSupport} instance;
702      *
703      * @return  {@code true} if the specified object is equal to this {@code TabularDataSupport} instance.
704      */
705     public boolean equals(Object obj) {
706 
707         // if obj is null, return false
708         //
709         if (obj == null) {
710             return false;
711         }
712 
713         // if obj is not a TabularData, return false
714         //
715         TabularData other;
716         try {
717             other = (TabularData) obj;
718         } catch (ClassCastException e) {
719             return false;
720         }
721 
722         // Now, really test for equality between this TabularData implementation and the other:
723         //
724 
725         // their tabularType should be equal
726         if ( ! this.getTabularType().equals(other.getTabularType()) ) {
727             return false;
728         }
729 
730         // their contents should be equal:
731         // . same size
732         // . values in this instance are in the other (we know there are no duplicate elements possible)
733         // (row values comparison is enough, because keys are calculated according to tabularType)
734 
735         if (this.size() != other.size()) {
736             return false;
737         }
738         for (CompositeData value : dataMap.values()) {
739             if ( ! other.containsValue(value) ) {
740                 return false;
741             }
742         }
743 
744         // All tests for equality were successfull
745         //
746         return true;
747     }
748 
749     /**
750      * Returns the hash code value for this {@code TabularDataSupport} instance.
751      * &lt;p&gt;
752      * The hash code of a {@code TabularDataSupport} instance is the sum of the hash codes
753      * of all elements of information used in {@code equals} comparisons
754      * (ie: its &lt;i&gt;tabular type&lt;/i&gt; and its content, where the content is defined as all the CompositeData values).
755      * &lt;p&gt;
756      * This ensures that {@code t1.equals(t2)} implies that {@code t1.hashCode()==t2.hashCode()}
757      * for any two {@code TabularDataSupport} instances {@code t1} and {@code t2},
758      * as required by the general contract of the method
759      * {@link Object#hashCode() Object.hashCode()}.
760      * &lt;p&gt;
761      * However, note that another instance of a class implementing the {@code TabularData} interface
762      * may be equal to this {@code TabularDataSupport} instance as defined by {@link #equals},
763      * but may have a different hash code if it is calculated differently.
764      *
765      * @return  the hash code value for this {@code TabularDataSupport} instance
766      */
767    public int hashCode() {
768 
769         int result = 0;
770 
771         result += this.tabularType.hashCode();
772         for (Object value : values())
773             result += value.hashCode();
774 
775         return result;
776 
777     }
778 
779     /**
780      * Returns a string representation of this {@code TabularDataSupport} instance.
781      * &lt;p&gt;
782      * The string representation consists of the name of this class
783      * (ie {@code javax.management.openmbean.TabularDataSupport}),
784      * the string representation of the tabular type of this instance, and the string representation of the contents
785      * (ie list the key=value mappings as returned by a call to
786      * {@code dataMap.}{@link java.util.HashMap#toString() toString()}).
787      *
788      * @return  a string representation of this {@code TabularDataSupport} instance
789      */
790     public String toString() {
791 
792         return new StringBuilder()
793             .append(this.getClass().getName())
794             .append(&quot;(tabularType=&quot;)
795             .append(tabularType.toString())
796             .append(&quot;,contents=&quot;)
797             .append(dataMap.toString())
798             .append(&quot;)&quot;)
799             .toString();
800     }
801 
802 
803 
804 
805     /* *** TabularDataSupport internal utility methods *** */
806 
807 
808     /**
809      * Returns the index for value, assuming value is valid for this {@code TabularData} instance
810      * (ie value is not null, and its composite type is equal to row type).
811      *
812      * The index is a List, and not an array, so that an
813      * index.equals(otherIndex) call will actually compare contents,
814      * not just the objects references as is done for an array object.
815      *
816      * The returned List is unmodifiable so that once a row has been put
817      * into the dataMap, its index cannot be modified,
818      * for example by a user that would attempt to modify an
819      * index contained in the Set returned by keySet().
820      */
821     private List&lt;?&gt; internalCalculateIndex(CompositeData value) {
822 
823         return Collections.unmodifiableList(Arrays.asList(value.getAll(this.indexNamesArray)));
824     }
825 
826     /**
827      * Checks if the specified key is valid for this {@code TabularData} instance.
828      *
829      * @throws  NullPointerException
830      * @throws  InvalidOpenTypeException
831      */
832     private void checkKeyType(Object[] key) {
833 
834         // Check key is neither null nor empty
835         //
836         if ( (key == null) || (key.length == 0) ) {
837             throw new NullPointerException(&quot;Argument key cannot be null or empty.&quot;);
838         }
839 
840         /* Now check key is valid with tabularType index and row type definitions: */
841 
842         // key[] should have the size expected for an index
843         //
844         if (key.length != this.indexNamesArray.length) {
845             throw new InvalidKeyException(&quot;Argument key&#39;s length=&quot;+ key.length +
846                                           &quot; is different from the number of item values, which is &quot;+ indexNamesArray.length +
847                                           &quot;, specified for the indexing rows in this TabularData instance.&quot;);
848         }
849 
850         // each element in key[] should be a value for its corresponding open type specified in rowType
851         //
852         OpenType&lt;?&gt; keyElementType;
853         for (int i=0; i&lt;key.length; i++) {
854             keyElementType = tabularType.getRowType().getType(this.indexNamesArray[i]);
855             if ( (key[i] != null) &amp;&amp; (! keyElementType.isValue(key[i])) ) {
856                 throw new InvalidKeyException(&quot;Argument element key[&quot;+ i +&quot;] is not a value for the open type expected for &quot;+
857                                               &quot;this element of the index, whose name is \&quot;&quot;+ indexNamesArray[i] +
858                                               &quot;\&quot; and whose open type is &quot;+ keyElementType);
859             }
860         }
861     }
862 
863     /**
864      * Checks the specified value&#39;s type is valid for this {@code TabularData} instance
865      * (ie value is not null, and its composite type is equal to row type).
866      *
867      * @throws  NullPointerException
868      * @throws  InvalidOpenTypeException
869      */
870     private void checkValueType(CompositeData value) {
871 
872         // Check value is not null
873         //
874         if (value == null) {
875             throw new NullPointerException(&quot;Argument value cannot be null.&quot;);
876         }
877 
878         // if value&#39;s type is not the same as this instance&#39;s row type, throw InvalidOpenTypeException
879         //
880         if (!tabularType.getRowType().isValue(value)) {
881             throw new InvalidOpenTypeException(&quot;Argument value&#39;s composite type [&quot;+ value.getCompositeType() +
882                                                &quot;] is not assignable to &quot;+
883                                                &quot;this TabularData instance&#39;s row type [&quot;+ tabularType.getRowType() +&quot;].&quot;);
884         }
885     }
886 
887     /**
888      * Checks if the specified value can be put (ie added) in this {@code TabularData} instance
889      * (ie value is not null, its composite type is equal to row type, and its index is not already used),
890      * and returns the index calculated for this value.
891      *
892      * The index is a List, and not an array, so that an index.equals(otherIndex) call will actually compare contents,
893      * not just the objects references as is done for an array object.
894      *
895      * @throws  NullPointerException
896      * @throws  InvalidOpenTypeException
897      * @throws  KeyAlreadyExistsException
898      */
899     private List&lt;?&gt; checkValueAndIndex(CompositeData value) {
900 
901         // Check value is valid
902         //
903         checkValueType(value);
904 
905         // Calculate value&#39;s index according to this instance&#39;s tabularType
906         // and check it is not already used for a mapping in the parent HashMap
907         //
908         List&lt;?&gt; index = internalCalculateIndex(value);
909 
910         if (dataMap.containsKey(index)) {
911             throw new KeyAlreadyExistsException(&quot;Argument value&#39;s index, calculated according to this TabularData &quot;+
912                                                 &quot;instance&#39;s tabularType, already refers to a value in this table.&quot;);
913         }
914 
915         // The check is OK, so return the index
916         //
917         return index;
918     }
919 
920     /**
921      * Deserializes a {@link TabularDataSupport} from an {@link ObjectInputStream}.
922      */
923     private void readObject(ObjectInputStream in)
924             throws IOException, ClassNotFoundException {
925       in.defaultReadObject();
926       List&lt;String&gt; tmpNames = tabularType.getIndexNames();
927       int size = tmpNames.size();
928       SharedSecrets.getJavaObjectInputStreamAccess().checkArray(in, String[].class, size);
929       indexNamesArray = tmpNames.toArray(new String[size]);
930     }
931 }
    </pre>
  </body>
</html>
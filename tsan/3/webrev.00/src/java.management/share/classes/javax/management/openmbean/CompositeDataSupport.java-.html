<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.management/share/classes/javax/management/openmbean/CompositeDataSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 package javax.management.openmbean;
 28 
 29 
 30 // java import
 31 //
 32 import java.io.Serializable;
 33 import java.util.Arrays;
 34 import java.util.Collection;
 35 import java.util.Collections;
 36 import java.util.LinkedHashMap;
 37 import java.util.Map;
 38 import java.util.Set;
 39 import java.util.SortedMap;
 40 import java.util.TreeMap;
 41 
 42 // jmx import
 43 import java.util.TreeSet;
 44 //
 45 
 46 
 47 /**
 48  * The {@code CompositeDataSupport} class is the &lt;i&gt;open data&lt;/i&gt; class which
 49  * implements the {@code CompositeData} interface.
 50  *
 51  *
 52  * @since 1.5
 53  */
 54 public class CompositeDataSupport
 55     implements CompositeData, Serializable {
 56 
 57     /* Serial version */
 58     static final long serialVersionUID = 8003518976613702244L;
 59 
 60     /**
 61      * @serial Internal representation of the mapping of item names to their
 62      * respective values.
 63      *         A {@link SortedMap} is used for faster retrieval of elements.
 64      */
 65     private final SortedMap&lt;String, Object&gt; contents;
 66 
 67     /**
 68      * @serial The &lt;i&gt;composite type &lt;/i&gt; of this &lt;i&gt;composite data&lt;/i&gt; instance.
 69      */
 70     private final CompositeType compositeType;
 71 
 72     /**
 73      * &lt;p&gt;Constructs a {@code CompositeDataSupport} instance with the specified
 74      * {@code compositeType}, whose item values
 75      * are specified by {@code itemValues[]}, in the same order as in
 76      * {@code itemNames[]}.
 77      * As a {@code CompositeType} does not specify any order on its items,
 78      * the {@code itemNames[]} parameter is used
 79      * to specify the order in which the values are given in {@code itemValues[]}.
 80      * The items contained in this {@code CompositeDataSupport} instance are
 81      * internally stored in a {@code TreeMap},
 82      * thus sorted in ascending lexicographic order of their names, for faster
 83      * retrieval of individual item values.&lt;/p&gt;
 84      *
 85      * &lt;p&gt;The constructor checks that all the constraints listed below for each
 86      * parameter are satisfied,
 87      * and throws the appropriate exception if they are not.&lt;/p&gt;
 88      *
 89      * @param compositeType the &lt;i&gt;composite type &lt;/i&gt; of this &lt;i&gt;composite
 90      * data&lt;/i&gt; instance; must not be null.
 91      *
 92      * @param itemNames {@code itemNames} must list, in any order, all the
 93      * item names defined in {@code compositeType}; the order in which the
 94      * names are listed, is used to match values in {@code itemValues[]}; must
 95      * not be null or empty.
 96      *
 97      * @param itemValues the values of the items, listed in the same order as
 98      * their respective names in {@code itemNames}; each item value can be
 99      * null, but if it is non-null it must be a valid value for the open type
100      * defined in {@code compositeType} for the corresponding item; must be of
101      * the same size as {@code itemNames}; must not be null or empty.
102      *
103      * @throws IllegalArgumentException {@code compositeType} is null, or
104      * {@code itemNames[]} or {@code itemValues[]} is null or empty, or one
105      * of the elements in {@code itemNames[]} is a null or empty string, or
106      * {@code itemNames[]} and {@code itemValues[]} are not of the same size.
107      *
108      * @throws OpenDataException {@code itemNames[]} or
109      * {@code itemValues[]}&#39;s size differs from the number of items defined in
110      * {@code compositeType}, or one of the elements in {@code itemNames[]}
111      * does not exist as an item name defined in {@code compositeType}, or one
112      * of the elements in {@code itemValues[]} is not a valid value for the
113      * corresponding item as defined in {@code compositeType}.
114      */
115     public CompositeDataSupport(
116             CompositeType compositeType, String[] itemNames, Object[] itemValues)
117             throws OpenDataException {
118         this(makeMap(itemNames, itemValues), compositeType);
119     }
120 
121     private static SortedMap&lt;String, Object&gt; makeMap(
122             String[] itemNames, Object[] itemValues)
123             throws OpenDataException {
124 
125         if (itemNames == null || itemValues == null)
126             throw new IllegalArgumentException(&quot;Null itemNames or itemValues&quot;);
127         if (itemNames.length == 0 || itemValues.length == 0)
128             throw new IllegalArgumentException(&quot;Empty itemNames or itemValues&quot;);
129         if (itemNames.length != itemValues.length) {
130             throw new IllegalArgumentException(
131                     &quot;Different lengths: itemNames[&quot; + itemNames.length +
132                     &quot;], itemValues[&quot; + itemValues.length + &quot;]&quot;);
133         }
134 
135         SortedMap&lt;String, Object&gt; map = new TreeMap&lt;String, Object&gt;();
136         for (int i = 0; i &lt; itemNames.length; i++) {
137             String name = itemNames[i];
138             if (name == null || name.equals(&quot;&quot;))
139                 throw new IllegalArgumentException(&quot;Null or empty item name&quot;);
140             if (map.containsKey(name))
141                 throw new OpenDataException(&quot;Duplicate item name &quot; + name);
142             map.put(itemNames[i], itemValues[i]);
143         }
144 
145         return map;
146     }
147 
148     /**
149      * &lt;p&gt;
150      * Constructs a {@code CompositeDataSupport} instance with the specified {@code compositeType},
151      * whose item names and corresponding values
152      * are given by the mappings in the map {@code items}.
153      * This constructor converts the keys to a string array and the values to an object array and calls
154      * {@code CompositeDataSupport(javax.management.openmbean.CompositeType, java.lang.String[], java.lang.Object[])}.
155      *
156      * @param  compositeType  the &lt;i&gt;composite type &lt;/i&gt; of this &lt;i&gt;composite data&lt;/i&gt; instance;
157      *                        must not be null.
158      * @param  items  the mappings of all the item names to their values;
159      *                {@code items} must contain all the item names defined in {@code compositeType};
160      *                must not be null or empty.
161      *
162      * @throws IllegalArgumentException {@code compositeType} is null, or
163      * {@code items} is null or empty, or one of the keys in {@code items} is a null
164      * or empty string.
165      * @throws OpenDataException {@code items}&#39; size differs from the
166      * number of items defined in {@code compositeType}, or one of the
167      * keys in {@code items} does not exist as an item name defined in
168      * {@code compositeType}, or one of the values in {@code items}
169      * is not a valid value for the corresponding item as defined in
170      * {@code compositeType}.
171      * @throws ArrayStoreException one or more keys in {@code items} is not of
172      * the class {@code java.lang.String}.
173      */
174     public CompositeDataSupport(CompositeType compositeType,
175                                 Map&lt;String,?&gt; items)
176             throws OpenDataException {
177         this(makeMap(items), compositeType);
178     }
179 
180     private static SortedMap&lt;String, Object&gt; makeMap(Map&lt;String, ?&gt; items) {
181         if (items == null || items.isEmpty())
182             throw new IllegalArgumentException(&quot;Null or empty items map&quot;);
183 
184         SortedMap&lt;String, Object&gt; map = new TreeMap&lt;String, Object&gt;();
185         for (Object key : items.keySet()) {
186             if (key == null || key.equals(&quot;&quot;))
187                 throw new IllegalArgumentException(&quot;Null or empty item name&quot;);
188             if (!(key instanceof String)) {
189                 throw new ArrayStoreException(&quot;Item name is not string: &quot; + key);
190                 // This can happen because of erasure.  The particular
191                 // exception is a historical artifact - an implementation
192                 // detail that leaked into the API.
193             }
194             map.put((String) key, items.get(key));
195         }
196         return map;
197     }
198 
199     private CompositeDataSupport(
200             SortedMap&lt;String, Object&gt; items, CompositeType compositeType)
201             throws OpenDataException {
202 
203         // Check compositeType is not null
204         //
205         if (compositeType == null) {
206             throw new IllegalArgumentException(&quot;Argument compositeType cannot be null.&quot;);
207         }
208 
209         // item names defined in compositeType:
210         Set&lt;String&gt; namesFromType = compositeType.keySet();
211         Set&lt;String&gt; namesFromItems = items.keySet();
212 
213         // This is just a comparison, but we do it this way for a better
214         // exception message.
215         if (!namesFromType.equals(namesFromItems)) {
216             Set&lt;String&gt; extraFromType = new TreeSet&lt;String&gt;(namesFromType);
217             extraFromType.removeAll(namesFromItems);
218             Set&lt;String&gt; extraFromItems = new TreeSet&lt;String&gt;(namesFromItems);
219             extraFromItems.removeAll(namesFromType);
220             if (!extraFromType.isEmpty() || !extraFromItems.isEmpty()) {
221                 throw new OpenDataException(
222                         &quot;Item names do not match CompositeType: &quot; +
223                         &quot;names in items but not in CompositeType: &quot; + extraFromItems +
224                         &quot;; names in CompositeType but not in items: &quot; + extraFromType);
225             }
226         }
227 
228         // Check each value, if not null, is of the open type defined for the
229         // corresponding item
230         for (String name : namesFromType) {
231             Object value = items.get(name);
232             if (value != null) {
233                 OpenType&lt;?&gt; itemType = compositeType.getType(name);
234                 if (!itemType.isValue(value)) {
235                     throw new OpenDataException(
236                             &quot;Argument value of wrong type for item &quot; + name +
237                             &quot;: value &quot; + value + &quot;, type &quot; + itemType);
238                 }
239             }
240         }
241 
242         // Initialize internal fields: compositeType and contents
243         //
244         this.compositeType = compositeType;
245         this.contents = items;
246     }
247 
248     /**
249      * Returns the &lt;i&gt;composite type &lt;/i&gt; of this &lt;i&gt;composite data&lt;/i&gt; instance.
250      */
251     public CompositeType getCompositeType() {
252 
253         return compositeType;
254     }
255 
256     /**
257      * Returns the value of the item whose name is {@code key}.
258      *
259      * @throws IllegalArgumentException  if {@code key} is a null or empty String.
260      *
261      * @throws InvalidKeyException  if {@code key} is not an existing item name for
262      * this {@code CompositeData} instance.
263      */
264     public Object get(String key) {
265 
266         if ( (key == null) || (key.trim().equals(&quot;&quot;)) ) {
267             throw new IllegalArgumentException(&quot;Argument key cannot be a null or empty String.&quot;);
268         }
269         if ( ! contents.containsKey(key.trim())) {
270             throw new InvalidKeyException(&quot;Argument key=\&quot;&quot;+ key.trim() +&quot;\&quot; is not an existing item name for this CompositeData instance.&quot;);
271         }
272         return contents.get(key.trim());
273     }
274 
275     /**
276      * Returns an array of the values of the items whose names are specified by
277      * {@code keys}, in the same order as {@code keys}.
278      *
279      * @throws IllegalArgumentException  if an element in {@code keys} is a null
280      * or empty String.
281      *
282      * @throws InvalidKeyException  if an element in {@code keys} is not an existing
283      * item name for this {@code CompositeData} instance.
284      */
285     public Object[] getAll(String[] keys) {
286 
287         if ( (keys == null) || (keys.length == 0) ) {
288             return new Object[0];
289         }
290         Object[] results = new Object[keys.length];
291         for (int i=0; i&lt;keys.length; i++) {
292             results[i] = this.get(keys[i]);
293         }
294         return results;
295     }
296 
297     /**
298      * Returns {@code true} if and only if this {@code CompositeData} instance contains
299      * an item whose name is {@code key}.
300      * If {@code key} is a null or empty String, this method simply returns false.
301      */
302     public boolean containsKey(String key) {
303 
304         if ( (key == null) || (key.trim().equals(&quot;&quot;)) ) {
305             return false;
306         }
307         return contents.containsKey(key);
308     }
309 
310     /**
311      * Returns {@code true} if and only if this {@code CompositeData} instance
312      * contains an item
313      * whose value is {@code value}.
314      */
315     public boolean containsValue(Object value) {
316 
317         return contents.containsValue(value);
318     }
319 
320     /**
321      * Returns an unmodifiable Collection view of the item values contained in this
322      * {@code CompositeData} instance.
323      * The returned collection&#39;s iterator will return the values in the ascending
324      * lexicographic order of the corresponding
325      * item names.
326      */
327     public Collection&lt;?&gt; values() {
328 
329         return Collections.unmodifiableCollection(contents.values());
330     }
331 
332     /**
333      * Compares the specified &lt;var&gt;obj&lt;/var&gt; parameter with this
334      * &lt;code&gt;CompositeDataSupport&lt;/code&gt; instance for equality.
335      * &lt;p&gt;
336      * Returns {@code true} if and only if all of the following statements are true:
337      * &lt;ul&gt;
338      * &lt;li&gt;&lt;var&gt;obj&lt;/var&gt; is non null,&lt;/li&gt;
339      * &lt;li&gt;&lt;var&gt;obj&lt;/var&gt; also implements the &lt;code&gt;CompositeData&lt;/code&gt; interface,&lt;/li&gt;
340      * &lt;li&gt;their composite types are equal&lt;/li&gt;
341      * &lt;li&gt;their contents, i.e. (name, value) pairs are equal. If a value contained in
342      * the content is an array, the value comparison is done as if by calling
343      * the {@link java.util.Arrays#deepEquals(Object[], Object[]) deepEquals} method
344      * for arrays of object reference types or the appropriate overloading of
345      * {@code Arrays.equals(e1,e2)} for arrays of primitive types&lt;/li&gt;
346      * &lt;/ul&gt;
347      * &lt;p&gt;
348      * This ensures that this {@code equals} method works properly for
349      * &lt;var&gt;obj&lt;/var&gt; parameters which are different implementations of the
350      * &lt;code&gt;CompositeData&lt;/code&gt; interface, with the restrictions mentioned in the
351      * {@link java.util.Collection#equals(Object) equals}
352      * method of the {@code java.util.Collection} interface.
353      *
354      * @param  obj  the object to be compared for equality with this
355      * &lt;code&gt;CompositeDataSupport&lt;/code&gt; instance.
356      * @return  &lt;code&gt;true&lt;/code&gt; if the specified object is equal to this
357      * &lt;code&gt;CompositeDataSupport&lt;/code&gt; instance.
358      */
359     @Override
360     public boolean equals(Object obj) {
361         if (this == obj) {
362             return true;
363         }
364 
365         // if obj is not a CompositeData, return false
366         if (!(obj instanceof CompositeData)) {
367             return false;
368         }
369 
370         CompositeData other = (CompositeData) obj;
371 
372         // their compositeType should be equal
373         if (!this.getCompositeType().equals(other.getCompositeType()) ) {
374             return false;
375         }
376 
377         if (contents.size() != other.values().size()) {
378             return false;
379         }
380 
381         for (Map.Entry&lt;String,Object&gt; entry : contents.entrySet()) {
382             Object e1 = entry.getValue();
383             Object e2 = other.get(entry.getKey());
384 
385             if (e1 == e2)
386                 continue;
387             if (e1 == null)
388                 return false;
389 
390             boolean eq = e1.getClass().isArray() ?
391                 Arrays.deepEquals(new Object[] {e1}, new Object[] {e2}) :
392                 e1.equals(e2);
393 
394             if (!eq)
395                 return false;
396         }
397 
398         // All tests for equality were successful
399         //
400         return true;
401     }
402 
403     /**
404      * Returns the hash code value for this &lt;code&gt;CompositeDataSupport&lt;/code&gt; instance.
405      * &lt;p&gt;
406      * The hash code of a &lt;code&gt;CompositeDataSupport&lt;/code&gt; instance is the sum of the hash codes
407      * of all elements of information used in &lt;code&gt;equals&lt;/code&gt; comparisons
408      * (ie: its &lt;i&gt;composite type&lt;/i&gt; and all the item values).
409      * &lt;p&gt;
410      * This ensures that &lt;code&gt; t1.equals(t2) &lt;/code&gt; implies that &lt;code&gt; t1.hashCode()==t2.hashCode() &lt;/code&gt;
411      * for any two &lt;code&gt;CompositeDataSupport&lt;/code&gt; instances &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;,
412      * as required by the general contract of the method
413      * {@link Object#hashCode() Object.hashCode()}.
414      * &lt;p&gt;
415      * Each item value&#39;s hash code is added to the returned hash code.
416      * If an item value is an array,
417      * its hash code is obtained as if by calling the
418      * {@link java.util.Arrays#deepHashCode(Object[]) deepHashCode} method
419      * for arrays of object reference types or the appropriate overloading
420      * of {@code Arrays.hashCode(e)} for arrays of primitive types.
421      *
422      * @return the hash code value for this &lt;code&gt;CompositeDataSupport&lt;/code&gt; instance
423      */
424     @Override
425     public int hashCode() {
426         int hashcode = compositeType.hashCode();
427 
428         for (Object o : contents.values()) {
429             if (o instanceof Object[])
430                 hashcode += Arrays.deepHashCode((Object[]) o);
431             else if (o instanceof byte[])
432                 hashcode += Arrays.hashCode((byte[]) o);
433             else if (o instanceof short[])
434                 hashcode += Arrays.hashCode((short[]) o);
435             else if (o instanceof int[])
436                 hashcode += Arrays.hashCode((int[]) o);
437             else if (o instanceof long[])
438                 hashcode += Arrays.hashCode((long[]) o);
439             else if (o instanceof char[])
440                 hashcode += Arrays.hashCode((char[]) o);
441             else if (o instanceof float[])
442                 hashcode += Arrays.hashCode((float[]) o);
443             else if (o instanceof double[])
444                 hashcode += Arrays.hashCode((double[]) o);
445             else if (o instanceof boolean[])
446                 hashcode += Arrays.hashCode((boolean[]) o);
447             else if (o != null)
448                 hashcode += o.hashCode();
449         }
450 
451         return hashcode;
452     }
453 
454     /**
455      * Returns a string representation of this &lt;code&gt;CompositeDataSupport&lt;/code&gt; instance.
456      * &lt;p&gt;
457      * The string representation consists of the name of this class (ie &lt;code&gt;javax.management.openmbean.CompositeDataSupport&lt;/code&gt;),
458      * the string representation of the composite type of this instance, and the string representation of the contents
459      * (ie list the itemName=itemValue mappings).
460      *
461      * @return  a string representation of this &lt;code&gt;CompositeDataSupport&lt;/code&gt; instance
462      */
463     @Override
464     public String toString() {
465         return new StringBuilder()
466             .append(this.getClass().getName())
467             .append(&quot;(compositeType=&quot;)
468             .append(compositeType.toString())
469             .append(&quot;,contents=&quot;)
470             .append(contentString())
471             .append(&quot;)&quot;)
472             .toString();
473     }
474 
475     private String contentString() {
476         StringBuilder sb = new StringBuilder(&quot;{&quot;);
477         String sep = &quot;&quot;;
478         for (Map.Entry&lt;String, Object&gt; entry : contents.entrySet()) {
479             sb.append(sep).append(entry.getKey()).append(&quot;=&quot;);
480             String s = Arrays.deepToString(new Object[] {entry.getValue()});
481             sb.append(s.substring(1, s.length() - 1));
482             sep = &quot;, &quot;;
483         }
484         sb.append(&quot;}&quot;);
485         return sb.toString();
486     }
487 }
    </pre>
  </body>
</html>
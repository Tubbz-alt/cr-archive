<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.management/share/classes/javax/management/MXBean.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javax.management;
  27 
  28 import java.lang.annotation.Documented;
  29 import java.lang.annotation.ElementType;
  30 import java.lang.annotation.Retention;
  31 import java.lang.annotation.RetentionPolicy;
  32 import java.lang.annotation.Target;
  33 
  34 // remaining imports are for Javadoc
  35 import java.io.InvalidObjectException;
  36 import java.lang.management.MemoryUsage;
  37 import java.lang.reflect.UndeclaredThrowableException;
  38 import java.util.Arrays;
  39 import java.util.List;
  40 import javax.management.openmbean.ArrayType;
  41 import javax.management.openmbean.CompositeData;
  42 import javax.management.openmbean.CompositeDataInvocationHandler;
  43 import javax.management.openmbean.CompositeDataSupport;
  44 import javax.management.openmbean.CompositeDataView;
  45 import javax.management.openmbean.CompositeType;
  46 import javax.management.openmbean.OpenDataException;
  47 import javax.management.openmbean.OpenMBeanInfo;
  48 import javax.management.openmbean.OpenType;
  49 import javax.management.openmbean.SimpleType;
  50 import javax.management.openmbean.TabularData;
  51 import javax.management.openmbean.TabularDataSupport;
  52 import javax.management.openmbean.TabularType;
  53 
  54 /**
  55     &lt;p&gt;Annotation to mark an interface explicitly as being an MXBean
  56     interface, or as not being an MXBean interface.  By default, an
  57     interface is an MXBean interface if it is public and its name ends
  58     with {@code MXBean}, as in {@code SomethingMXBean}.  The following
  59     interfaces are MXBean interfaces:&lt;/p&gt;
  60 
  61     &lt;pre&gt;
  62     public interface WhatsitMXBean {}
  63 
  64     &amp;#64;MXBean
  65     public interface Whatsit1Interface {}
  66 
  67     &amp;#64;MXBean(true)
  68     public interface Whatsit2Interface {}
  69     &lt;/pre&gt;
  70 
  71     &lt;p&gt;The following interfaces are not MXBean interfaces:&lt;/p&gt;
  72 
  73     &lt;pre&gt;
  74     interface NonPublicInterfaceNotMXBean{}
  75 
  76     public interface Whatsit3Interface{}
  77 
  78     &amp;#64;MXBean(false)
  79     public interface MisleadingMXBean {}
  80     &lt;/pre&gt;
  81 
  82     &lt;h2 id=&quot;MXBean-spec&quot;&gt;MXBean specification&lt;/h2&gt;
  83 
  84     &lt;p&gt;The MXBean concept provides a simple way to code an MBean
  85       that only references a predefined set of types, the ones defined
  86       by {@link javax.management.openmbean}.  In this way, you can be
  87       sure that your MBean will be usable by any client, including
  88       remote clients, without any requirement that the client have
  89       access to &lt;em&gt;model-specific classes&lt;/em&gt; representing the types
  90       of your MBeans.&lt;/p&gt;
  91 
  92     &lt;p&gt;The concepts are easier to understand by comparison with the
  93       Standard MBean concept.  Here is how a managed object might be
  94       represented as a Standard MBean, and as an MXBean:&lt;/p&gt;
  95 
  96     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
  97         &lt;h3&gt;Standard MBean&lt;/h3&gt;
  98         &lt;pre&gt;
  99 public interface MemoryPool&lt;b&gt;MBean&lt;/b&gt; {
 100     String getName();
 101     MemoryUsage getUsage();
 102     // ...
 103 }
 104           &lt;/pre&gt;
 105     &lt;/div&gt;
 106     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
 107         &lt;h3&gt;MXBean&lt;/h3&gt;
 108         &lt;pre&gt;
 109 public interface MemoryPool&lt;b&gt;MXBean&lt;/b&gt; {
 110     String getName();
 111     MemoryUsage getUsage();
 112     // ...
 113 }
 114           &lt;/pre&gt;
 115     &lt;/div&gt;
 116 
 117     &lt;p&gt;As you can see, the definitions are very similar.  The only
 118       difference is that the convention for naming the interface is to use
 119       &lt;code&gt;&lt;em&gt;Something&lt;/em&gt;MXBean&lt;/code&gt; for MXBeans, rather than
 120       &lt;code&gt;&lt;em&gt;Something&lt;/em&gt;MBean&lt;/code&gt; for Standard MBeans.&lt;/p&gt;
 121 
 122     &lt;p&gt;In this managed object, there is an attribute called
 123       &lt;code&gt;Usage&lt;/code&gt; of type {@link MemoryUsage}.  The point of an
 124       attribute like this is that it gives a coherent snapshot of a set
 125       of data items.  For example, it might include the current amount
 126       of used memory in the memory pool, and the current maximum of the
 127       memory pool.  If these were separate items, obtained with separate
 128       {@link MBeanServer#getAttribute getAttribute} calls, then we could
 129       get values seen at different times that were not consistent.  We
 130       might get a &lt;code&gt;used&lt;/code&gt; value that was greater than the
 131       &lt;code&gt;max&lt;/code&gt; value.&lt;/p&gt;
 132 
 133     &lt;p&gt;So, we might define &lt;code&gt;MemoryUsage&lt;/code&gt; like this:&lt;/p&gt;
 134 
 135     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
 136         &lt;h3&gt;Standard MBean&lt;/h3&gt;
 137         &lt;pre&gt;
 138 public class MemoryUsage &lt;b&gt;implements Serializable&lt;/b&gt; {
 139     // standard JavaBean conventions with getters
 140 
 141     public MemoryUsage(long init, long used,
 142                        long committed, long max) {...}
 143     long getInit() {...}
 144     long getUsed() {...}
 145     long getCommitted() {...}
 146     long getMax() {...}
 147 }
 148         &lt;/pre&gt;
 149     &lt;/div&gt;
 150     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
 151         &lt;h3&gt;MXBean&lt;/h3&gt;
 152         &lt;pre&gt;
 153 public class MemoryUsage {
 154     // standard JavaBean conventions with getters
 155     &lt;b&gt;&amp;#64;ConstructorParameters({&quot;init&quot;, &quot;used&quot;, &quot;committed&quot;, &quot;max&quot;})&lt;/b&gt;
 156     public MemoryUsage(long init, long used,
 157                        long committed, long max) {...}
 158     long getInit() {...}
 159     long getUsed() {...}
 160     long getCommitted() {...}
 161     long getMax() {...}
 162 }
 163         &lt;/pre&gt;
 164     &lt;/div&gt;
 165 
 166     &lt;p&gt;The definitions are the same in the two cases, except
 167       that with the MXBean, &lt;code&gt;MemoryUsage&lt;/code&gt; no longer needs to
 168       be marked &lt;code&gt;Serializable&lt;/code&gt; (though it can be).  On
 169       the other hand, we have added a {@link ConstructorParameters &amp;#64;ConstructorParameters}
 170       annotation to link the constructor parameters to the corresponding getters.
 171       We will see more about this below.&lt;/p&gt;
 172 
 173     &lt;p&gt;&lt;code&gt;MemoryUsage&lt;/code&gt; is a &lt;em&gt;model-specific class&lt;/em&gt;.
 174       With Standard MBeans, a client of the MBean Server cannot access the
 175       &lt;code&gt;Usage&lt;/code&gt; attribute if it does not know the class
 176       &lt;code&gt;MemoryUsage&lt;/code&gt;.  Suppose the client is a generic console
 177       based on JMX technology.  Then the console would have to be
 178       configured with the model-specific classes of every application it
 179       might connect to.  The problem is even worse for clients that are
 180       not written in the Java language.  Then there may not be any way
 181       to tell the client what a &lt;code&gt;MemoryUsage&lt;/code&gt; looks like.&lt;/p&gt;
 182 
 183     &lt;p&gt;This is where MXBeans differ from Standard MBeans.  Although we
 184       define the management interface in almost exactly the same way,
 185       the MXBean framework &lt;em&gt;converts&lt;/em&gt; model-specific classes into
 186       standard classes from the Java platform.  Using arrays and the
 187       {@link javax.management.openmbean.CompositeData CompositeData} and
 188       {@link javax.management.openmbean.TabularData TabularData} classes
 189       from the standard {@link javax.management.openmbean} package, it
 190       is possible to build data structures of arbitrary complexity
 191       using only standard classes.&lt;/p&gt;
 192 
 193     &lt;p&gt;This becomes clearer if we compare what the clients of the two
 194       models might look like:&lt;/p&gt;
 195 
 196     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
 197         &lt;h3&gt;Standard MBean&lt;/h3&gt;
 198         &lt;pre&gt;
 199 String name = (String)
 200     mbeanServer.{@link MBeanServer#getAttribute
 201     getAttribute}(objectName, &quot;Name&quot;);
 202 &lt;b&gt;MemoryUsage&lt;/b&gt; usage = (&lt;b&gt;MemoryUsage&lt;/b&gt;)
 203     mbeanServer.getAttribute(objectName, &quot;Usage&quot;);
 204 &lt;b&gt;long used = usage.getUsed();&lt;/b&gt;
 205         &lt;/pre&gt;
 206     &lt;/div&gt;
 207     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
 208         &lt;h3&gt;MXBean&lt;/h3&gt;
 209         &lt;pre&gt;
 210 String name = (String)
 211     mbeanServer.{@link MBeanServer#getAttribute
 212     getAttribute}(objectName, &quot;Name&quot;);
 213 &lt;b&gt;{@link CompositeData}&lt;/b&gt; usage = (&lt;b&gt;CompositeData&lt;/b&gt;)
 214     mbeanServer.getAttribute(objectName, &quot;Usage&quot;);
 215 &lt;b&gt;long used = (Long) usage.{@link CompositeData#get get}(&quot;used&quot;);&lt;/b&gt;
 216         &lt;/pre&gt;
 217     &lt;/div&gt;
 218 
 219     &lt;p&gt;For attributes with simple types like &lt;code&gt;String&lt;/code&gt;, the
 220       code is the same.  But for attributes with complex types, the
 221       Standard MBean code requires the client to know the model-specific
 222       class &lt;code&gt;MemoryUsage&lt;/code&gt;, while the MXBean code requires no
 223       non-standard classes.&lt;/p&gt;
 224 
 225     &lt;p&gt;The client code shown here is slightly more complicated for the
 226       MXBean client.  But, if the client does in fact know the model,
 227       here the interface &lt;code&gt;MemoryPoolMXBean&lt;/code&gt; and the
 228       class &lt;code&gt;MemoryUsage&lt;/code&gt;, then it can construct a
 229       &lt;em&gt;proxy&lt;/em&gt;.  This is the recommended way to interact with
 230       managed objects when you know the model beforehand, regardless
 231       of whether you are using Standard MBeans or MXBeans:&lt;/p&gt;
 232 
 233     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
 234         &lt;h3&gt;Standard MBean&lt;/h3&gt;
 235         &lt;pre&gt;
 236 MemoryPool&lt;b&gt;MBean&lt;/b&gt; proxy =
 237     JMX.&lt;b&gt;{@link JMX#newMBeanProxy(MBeanServerConnection, ObjectName,
 238               Class) newMBeanProxy}&lt;/b&gt;(
 239         mbeanServer,
 240         objectName,
 241         MemoryPool&lt;b&gt;MBean&lt;/b&gt;.class);
 242 String name = proxy.getName();
 243 MemoryUsage usage = proxy.getUsage();
 244 long used = usage.getUsed();
 245           &lt;/pre&gt;
 246     &lt;/div&gt;
 247     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
 248         &lt;h3&gt;MXBean&lt;/h3&gt;
 249         &lt;pre&gt;
 250 MemoryPool&lt;b&gt;MXBean&lt;/b&gt; proxy =
 251     JMX.&lt;b&gt;{@link JMX#newMXBeanProxy(MBeanServerConnection, ObjectName,
 252               Class) newMXBeanProxy}&lt;/b&gt;(
 253         mbeanServer,
 254         objectName,
 255         MemoryPool&lt;b&gt;MXBean&lt;/b&gt;.class);
 256 String name = proxy.getName();
 257 MemoryUsage usage = proxy.getUsage();
 258 long used = usage.getUsed();
 259           &lt;/pre&gt;
 260     &lt;/div&gt;
 261 
 262     &lt;p&gt;Implementing the MemoryPool object works similarly for both
 263       Standard MBeans and MXBeans.&lt;/p&gt;
 264 
 265     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
 266         &lt;h3&gt;Standard MBean&lt;/h3&gt;
 267         &lt;pre&gt;
 268 public class MemoryPool
 269         implements MemoryPool&lt;b&gt;MBean&lt;/b&gt; {
 270     public String getName() {...}
 271     public MemoryUsage getUsage() {...}
 272     // ...
 273 }
 274         &lt;/pre&gt;
 275     &lt;/div&gt;
 276     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
 277         &lt;h3&gt;MXBean&lt;/h3&gt;
 278         &lt;pre&gt;
 279 public class MemoryPool
 280         implements MemoryPool&lt;b&gt;MXBean&lt;/b&gt; {
 281     public String getName() {...}
 282     public MemoryUsage getUsage() {...}
 283     // ...
 284 }
 285         &lt;/pre&gt;
 286     &lt;/div&gt;
 287 
 288     &lt;p&gt;Registering the MBean in the MBean Server works in the same way
 289       in both cases:&lt;/p&gt;
 290 
 291     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
 292         &lt;h3&gt;Standard MBean&lt;/h3&gt;
 293         &lt;pre&gt;
 294 {
 295     MemoryPool&lt;b&gt;MBean&lt;/b&gt; pool = new MemoryPool();
 296     mbeanServer.{@link MBeanServer#registerMBean
 297     registerMBean}(pool, objectName);
 298 }
 299         &lt;/pre&gt;
 300     &lt;/div&gt;
 301     &lt;div style=&quot;display:inline-block; margin: 0 3em&quot;&gt;
 302         &lt;h3&gt;MXBean&lt;/h3&gt;
 303         &lt;pre&gt;
 304 {
 305     MemoryPool&lt;b&gt;MXBean&lt;/b&gt; pool = new MemoryPool();
 306     mbeanServer.{@link MBeanServer#registerMBean
 307     registerMBean}(pool, objectName);
 308 }
 309         &lt;/pre&gt;
 310     &lt;/div&gt;
 311 
 312 
 313     &lt;h2 id=&quot;mxbean-def&quot;&gt;Definition of an MXBean&lt;/h2&gt;
 314 
 315     &lt;p&gt;An MXBean is a kind of MBean.  An MXBean object can be
 316       registered directly in the MBean Server, or it can be used as an
 317       argument to {@link StandardMBean} and the resultant MBean
 318       registered in the MBean Server.&lt;/p&gt;
 319 
 320     &lt;p&gt;When an object is registered in the MBean Server using the
 321       {@code registerMBean} or {@code createMBean} methods of the
 322       {@link MBeanServer} interface, the object&#39;s class is examined
 323       to determine what type of MBean it is:&lt;/p&gt;
 324 
 325     &lt;ul&gt;
 326       &lt;li&gt;If the class implements the interface {@link DynamicMBean}
 327         then the MBean is a Dynamic MBean.  Note that the class
 328         {@code StandardMBean} implements this interface, so this
 329         case applies to a Standard MBean or MXBean created using
 330         the class {@code StandardMBean}.&lt;/li&gt;
 331 
 332       &lt;li&gt;Otherwise, if the class matches the Standard MBean naming
 333         conventions, then the MBean is a Standard MBean.&lt;/li&gt;
 334 
 335       &lt;li&gt;Otherwise, it may be an MXBean.  The set of interfaces
 336         implemented by the object is examined for interfaces that:
 337 
 338         &lt;ul&gt;
 339           &lt;li&gt;have a class name &lt;code&gt;&lt;em&gt;S&lt;/em&gt;MXBean&lt;/code&gt; where
 340             &lt;code&gt;&lt;em&gt;S&lt;/em&gt;&lt;/code&gt; is any non-empty string, and
 341             do not have an annotation {@code @MXBean(false)}; and/or&lt;/li&gt;
 342           &lt;li&gt;have an annotation {@code @MXBean(true)}
 343             or just {@code @MXBean}.&lt;/li&gt;
 344         &lt;/ul&gt;
 345 
 346         If there is exactly one such interface, or if there is one
 347         such interface that is a subinterface of all the others, then
 348         the object is an MXBean.  The interface in question is the
 349         &lt;em&gt;MXBean interface&lt;/em&gt;.  In the example above, the MXBean
 350         interface is {@code MemoryPoolMXBean}.
 351 
 352       &lt;li&gt;If none of these conditions is met, the MBean is invalid and
 353         the attempt to register it will generate {@link
 354         NotCompliantMBeanException}.
 355     &lt;/ul&gt;
 356 
 357     &lt;p&gt;Every Java type that appears as the parameter or return type of a
 358       method in an MXBean interface must be &lt;em&gt;convertible&lt;/em&gt; using
 359       the rules below.  Additionally, parameters must be
 360       &lt;em&gt;reconstructible&lt;/em&gt; as defined below.&lt;/p&gt;
 361 
 362     &lt;p&gt;An attempt to construct an MXBean that does not conform to the
 363       above rules will produce an exception.&lt;/p&gt;
 364 
 365 
 366     &lt;h2 id=&quot;naming-conv&quot;&gt;Naming conventions&lt;/h2&gt;
 367 
 368     &lt;p&gt;The same naming conventions are applied to the methods in an
 369       MXBean as in a Standard MBean:&lt;/p&gt;
 370 
 371     &lt;ol&gt;
 372       &lt;li&gt;A method &lt;code&gt;&lt;em&gt;T&lt;/em&gt; get&lt;em&gt;N&lt;/em&gt;()&lt;/code&gt;, where
 373         &lt;code&gt;&lt;em&gt;T&lt;/em&gt;&lt;/code&gt; is a Java type (not &lt;code&gt;void&lt;/code&gt;)
 374         and &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; is a non-empty string, specifies
 375         that there is a readable attribute called
 376         &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt;.  The Java type and Open type of the
 377         attribute are determined by the mapping rules below.
 378         The method {@code final Class getClass()} inherited from {@code
 379         Object} is ignored when looking for getters.&lt;/li&gt;
 380 
 381       &lt;li&gt;A method &lt;code&gt;boolean is&lt;em&gt;N&lt;/em&gt;()&lt;/code&gt; specifies that
 382         there is a readable attribute called &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt;
 383         with Java type &lt;code&gt;boolean&lt;/code&gt; and Open type
 384         &lt;code&gt;SimpleType.Boolean&lt;/code&gt;.&lt;/li&gt;
 385 
 386       &lt;li&gt;A method &lt;code&gt;void set&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T&lt;/em&gt; x)&lt;/code&gt;
 387         specifies that there is a writeable attribute called
 388         &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt;.  The Java type and Open type of the
 389         attribute are determined by the mapping rules below.  (Of
 390         course, the name &lt;code&gt;x&lt;/code&gt; of the parameter is
 391         irrelevant.)&lt;/li&gt;
 392 
 393       &lt;li&gt;Every other method specifies that there is an operation with
 394         the same name as the method.  The Java type and Open type of the
 395         return value and of each parameter are determined by the mapping
 396         rules below.&lt;/li&gt;
 397     &lt;/ol&gt;
 398 
 399     &lt;p&gt;The rules for &lt;code&gt;get&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; and
 400       &lt;code&gt;is&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; collectively define the notion of a
 401       &lt;em&gt;getter&lt;/em&gt;.  The rule for &lt;code&gt;set&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; defines
 402       the notion of a &lt;em&gt;setter&lt;/em&gt;.&lt;/p&gt;
 403 
 404     &lt;p&gt;It is an error for there to be two getters with the same name, or
 405       two setters with the same name.  If there is a getter and a setter
 406       for the same name, then the type &lt;code&gt;&lt;em&gt;T&lt;/em&gt;&lt;/code&gt; in both
 407       must be the same.  In this case the attribute is read/write.  If
 408       there is only a getter or only a setter, the attribute is
 409       read-only or write-only respectively.&lt;/p&gt;
 410 
 411 
 412     &lt;h2 id=&quot;mapping-rules&quot;&gt;Type mapping rules&lt;/h2&gt;
 413 
 414     &lt;p&gt;An MXBean is a kind of Open MBean, as defined by the {@link
 415       javax.management.openmbean} package.  This means that the types of
 416       attributes, operation parameters, and operation return values must
 417       all be describable using &lt;em&gt;Open Types&lt;/em&gt;, that is the four
 418       standard subclasses of {@link javax.management.openmbean.OpenType}.
 419       MXBeans achieve this by mapping Java types into Open Types.&lt;/p&gt;
 420 
 421     &lt;p&gt;For every Java type &lt;em&gt;J&lt;/em&gt;, the MXBean mapping is described
 422       by the following information:&lt;/p&gt;
 423 
 424     &lt;ul&gt;
 425       &lt;li&gt;The corresponding Open Type, &lt;em&gt;opentype(J)&lt;/em&gt;.  This is
 426         an instance of a subclass of {@link
 427         javax.management.openmbean.OpenType}.&lt;/li&gt;
 428       &lt;li&gt;The &lt;em&gt;mapped&lt;/em&gt; Java type, &lt;em&gt;opendata(J)&lt;/em&gt;, which is
 429         always the same for any given &lt;em&gt;opentype(J)&lt;/em&gt;.  This is a Java
 430         class.&lt;/li&gt;
 431       &lt;li&gt;How a value is converted from type &lt;em&gt;J&lt;/em&gt; to type
 432         &lt;em&gt;opendata(J)&lt;/em&gt;.&lt;/li&gt;
 433       &lt;li&gt;How a value is converted from type &lt;em&gt;opendata(J)&lt;/em&gt; to
 434         type &lt;em&gt;J&lt;/em&gt;, if it can be.&lt;/li&gt;
 435     &lt;/ul&gt;
 436 
 437     &lt;p&gt;For example, for the Java type {@code List&lt;String&gt;}:&lt;/p&gt;
 438 
 439     &lt;ul&gt;
 440       &lt;li&gt;The Open Type, &lt;em&gt;opentype(&lt;/em&gt;{@code
 441         List&lt;String&gt;}&lt;em&gt;)&lt;/em&gt;, is {@link ArrayType}&lt;code&gt;(1, &lt;/code&gt;{@link
 442           SimpleType#STRING}&lt;code&gt;)&lt;/code&gt;, representing a 1-dimensional
 443           array of &lt;code&gt;String&lt;/code&gt;s.&lt;/li&gt;
 444       &lt;li&gt;The mapped Java type, &lt;em&gt;opendata(&lt;/em&gt;{@code
 445         List&lt;String&gt;}&lt;em&gt;)&lt;/em&gt;, is {@code String[]}.&lt;/li&gt;
 446       &lt;li&gt;A {@code List&lt;String&gt;} can be converted to a {@code String[]}
 447           using {@link List#toArray(Object[]) List.toArray(new
 448           String[0])}.&lt;/li&gt;
 449       &lt;li&gt;A {@code String[]} can be converted to a {@code List&lt;String&gt;}
 450           using {@link Arrays#asList Arrays.asList}.&lt;/li&gt;
 451     &lt;/ul&gt;
 452 
 453     &lt;p&gt;If no mapping rules exist to derive &lt;em&gt;opentype(J)&lt;/em&gt; from
 454       &lt;em&gt;J&lt;/em&gt;, then &lt;em&gt;J&lt;/em&gt; cannot be the type of a method
 455       parameter or return value in an MXBean interface.&lt;/p&gt;
 456 
 457     &lt;p id=&quot;reconstructible-def&quot;&gt;If there is a way to convert
 458       &lt;em&gt;opendata(J)&lt;/em&gt; back to &lt;em&gt;J&lt;/em&gt; then we say that &lt;em&gt;J&lt;/em&gt; is
 459       &lt;em&gt;reconstructible&lt;/em&gt;.  All method parameters in an MXBean
 460       interface must be reconstructible, because when the MXBean
 461       framework is invoking a method it will need to convert those
 462       parameters from &lt;em&gt;opendata(J)&lt;/em&gt; to &lt;em&gt;J&lt;/em&gt;.  In a proxy
 463       generated by {@link JMX#newMXBeanProxy(MBeanServerConnection,
 464       ObjectName, Class) JMX.newMXBeanProxy}, it is the return values
 465       of the methods in the MXBean interface that must be
 466       reconstructible.&lt;/p&gt;
 467 
 468     &lt;p&gt;Null values are allowed for all Java types and Open Types,
 469       except primitive Java types where they are not possible.  When
 470       converting from type &lt;em&gt;J&lt;/em&gt; to type &lt;em&gt;opendata(J)&lt;/em&gt; or
 471       from type &lt;em&gt;opendata(J)&lt;/em&gt; to type &lt;em&gt;J&lt;/em&gt;, a null value is
 472       mapped to a null value.&lt;/p&gt;
 473 
 474     &lt;p&gt;The following table summarizes the type mapping rules.&lt;/p&gt;
 475 
 476     &lt;table class=&quot;striped&quot;&gt;
 477     &lt;caption style=&quot;display:none&quot;&gt;Type Mapping Rules&lt;/caption&gt;
 478       &lt;thead&gt;
 479       &lt;tr&gt;
 480         &lt;th scope=&quot;col&quot;&gt;Java type &lt;em&gt;J&lt;/em&gt;&lt;/th&gt;
 481         &lt;th scope=&quot;col&quot;&gt;&lt;em&gt;opentype(J)&lt;/em&gt;&lt;/th&gt;
 482         &lt;th scope=&quot;col&quot;&gt;&lt;em&gt;opendata(J)&lt;/em&gt;&lt;/th&gt;
 483       &lt;/tr&gt;
 484       &lt;/thead&gt;
 485       &lt;tbody style=&quot;text-align:left; vertical-align:top&quot;&gt;
 486         &lt;tr&gt;
 487           &lt;th scope=&quot;row&quot;&gt;{@code int}, {@code boolean}, etc&lt;br&gt;
 488             (the 8 primitive Java types)&lt;/th&gt;
 489           &lt;td&gt;{@code SimpleType.INTEGER},&lt;br&gt;
 490             {@code SimpleType.BOOLEAN}, etc&lt;/td&gt;
 491           &lt;td&gt;{@code Integer}, {@code Boolean}, etc&lt;br&gt;
 492             (the corresponding boxed types)&lt;/td&gt;
 493         &lt;/tr&gt;
 494         &lt;tr&gt;
 495           &lt;th scope=&quot;row&quot;&gt;{@code Integer}, {@code ObjectName}, etc&lt;br&gt;
 496             (the types covered by {@link SimpleType})&lt;/th&gt;
 497           &lt;td&gt;the corresponding {@code SimpleType}&lt;/td&gt;
 498           &lt;td&gt;&lt;em&gt;J&lt;/em&gt;, the same type&lt;/td&gt;
 499         &lt;/tr&gt;
 500         &lt;tr&gt;
 501           &lt;th scope=&quot;row&quot;&gt;{@code int[]} etc&lt;br&gt;
 502             (a one-dimensional array with primitive element type)&lt;/th&gt;
 503           &lt;td&gt;{@code ArrayType.getPrimitiveArrayType(int[].class)} etc&lt;/td&gt;
 504           &lt;td&gt;&lt;em&gt;J&lt;/em&gt;, the same type&lt;/td&gt;
 505         &lt;tr&gt;
 506           &lt;th scope=&quot;row&quot;&gt;&lt;em&gt;E&lt;/em&gt;{@code []}&lt;br&gt;
 507             (an array with non-primitive element type &lt;em&gt;E&lt;/em&gt;;
 508               this includes {@code int[][]}, where &lt;em&gt;E&lt;/em&gt; is {@code int[]})&lt;/th&gt;
 509           &lt;td&gt;{@code ArrayType.getArrayType(}&lt;em&gt;opentype(E)&lt;/em&gt;{@code )}&lt;/td&gt;
 510           &lt;td&gt;&lt;em&gt;opendata(E)&lt;/em&gt;{@code []}&lt;/td&gt;
 511         &lt;/tr&gt;
 512         &lt;tr&gt;
 513           &lt;th scope=&quot;row&quot;&gt;{@code List&lt;}&lt;em&gt;E&lt;/em&gt;{@code &gt;}&lt;br&gt;
 514             {@code Set&lt;}&lt;em&gt;E&lt;/em&gt;{@code &gt;}&lt;br&gt;
 515             {@code SortedSet&lt;}&lt;em&gt;E&lt;/em&gt;{@code &gt;} (see below)&lt;/th&gt;
 516           &lt;td&gt;same as for &lt;em&gt;E&lt;/em&gt;{@code []}&lt;/td&gt;
 517           &lt;td&gt;same as for &lt;em&gt;E&lt;/em&gt;{@code []}&lt;/td&gt;
 518         &lt;/tr&gt;
 519         &lt;tr&gt;
 520           &lt;th scope=&quot;row&quot;&gt;An enumeration &lt;em&gt;E&lt;/em&gt;&lt;br&gt;
 521             (declared in Java as {@code enum }&lt;em&gt;E&lt;/em&gt;
 522             {@code {...}})&lt;/th&gt;
 523           &lt;td&gt;{@code SimpleType.STRING}&lt;/td&gt;
 524           &lt;td&gt;{@code String}&lt;/td&gt;
 525         &lt;/tr&gt;
 526         &lt;tr&gt;
 527           &lt;th scope=&quot;row&quot;&gt;{@code Map&lt;}&lt;em&gt;K&lt;/em&gt;,&lt;em&gt;V&lt;/em&gt;{@code &gt;}&lt;br&gt;
 528             {@code SortedMap&lt;}&lt;em&gt;K&lt;/em&gt;,&lt;em&gt;V&lt;/em&gt;{@code &gt;}&lt;/th&gt;
 529           &lt;td&gt;{@link TabularType}&lt;br&gt;
 530             (see below)&lt;/td&gt;
 531           &lt;td&gt;{@link TabularData}&lt;br&gt;
 532             (see below)&lt;/td&gt;
 533         &lt;/tr&gt;
 534         &lt;tr&gt;
 535           &lt;th scope=&quot;row&quot;&gt;An MXBean interface&lt;/th&gt;
 536           &lt;td&gt;{@code SimpleType.OBJECTNAME}&lt;br&gt;
 537             (see below)&lt;/td&gt;
 538           &lt;td&gt;{@link ObjectName}&lt;br&gt;
 539             (see below)&lt;/td&gt;
 540         &lt;/tr&gt;
 541         &lt;tr&gt;
 542           &lt;th scope=&quot;row&quot;&gt;Any other type&lt;/th&gt;
 543           &lt;td&gt;{@link CompositeType},
 544             if possible&lt;br&gt;
 545             (see below)&lt;/td&gt;
 546           &lt;td&gt;{@link CompositeData}&lt;/td&gt;
 547       &lt;/tbody&gt;
 548     &lt;/table&gt;
 549 
 550     &lt;p&gt;The following sections give further details of these rules.&lt;/p&gt;
 551 
 552 
 553     &lt;h3&gt;Mappings for primitive types&lt;/h3&gt;
 554 
 555     &lt;p&gt;The 8 primitive Java types
 556       ({@code boolean}, {@code byte}, {@code short}, {@code int}, {@code
 557       long}, {@code float}, {@code double}, {@code char}) are mapped to the
 558       corresponding boxed types from {@code java.lang}, namely {@code
 559       Boolean}, {@code Byte}, etc.  The Open Type is the corresponding
 560       {@code SimpleType}.  Thus, &lt;em&gt;opentype(&lt;/em&gt;{@code
 561       long}&lt;em&gt;)&lt;/em&gt; is {@code SimpleType.LONG}, and
 562       &lt;em&gt;opendata(&lt;/em&gt;{@code long}&lt;em&gt;)&lt;/em&gt; is {@code
 563       java.lang.Long}.&lt;/p&gt;
 564 
 565     &lt;p&gt;An array of primitive type such as {@code long[]} can be represented
 566       directly as an Open Type.  Thus, &lt;em&gt;openType(&lt;/em&gt;{@code
 567       long[]}&lt;em&gt;)&lt;/em&gt; is {@code
 568       ArrayType.getPrimitiveArrayType(long[].class)}, and
 569       &lt;em&gt;opendata(&lt;/em&gt;{@code long[]}&lt;em&gt;)&lt;/em&gt; is {@code
 570       long[]}.&lt;/p&gt;
 571 
 572     &lt;p&gt;In practice, the difference between a plain {@code int} and {@code
 573       Integer}, etc, does not show up because operations in the JMX API
 574       are always on Java objects, not primitives.  However, the
 575       difference &lt;em&gt;does&lt;/em&gt; show up with arrays.&lt;/p&gt;
 576 
 577 
 578     &lt;h3&gt;Mappings for collections ({@code List&lt;}&lt;em&gt;E&lt;/em&gt;{@code &gt;} etc)&lt;/h3&gt;
 579 
 580     &lt;p&gt;A {@code List&lt;}&lt;em&gt;E&lt;/em&gt;{@code &gt;} or {@code
 581       Set&lt;}&lt;em&gt;E&lt;/em&gt;{@code &gt;}, such as {@code List&lt;String&gt;} or {@code
 582         Set&lt;ObjectName&gt;}, is mapped in the same way as an array of the
 583           same element type, such as {@code String[]} or {@code
 584           ObjectName[]}.&lt;/p&gt;
 585 
 586     &lt;p&gt;A {@code SortedSet&lt;}&lt;em&gt;E&lt;/em&gt;{@code &gt;} is also mapped in the
 587       same way as an &lt;em&gt;E&lt;/em&gt;{@code []}, but it is only convertible if
 588       &lt;em&gt;E&lt;/em&gt; is a class or interface that implements {@link
 589       java.lang.Comparable}.  Thus, a {@code SortedSet&lt;String&gt;} or
 590         {@code SortedSet&lt;Integer&gt;} is convertible, but a {@code
 591           SortedSet&lt;int[]&gt;} or {@code SortedSet&lt;List&lt;String&gt;&gt;} is not.  The
 592                 conversion of a {@code SortedSet} instance will fail with an
 593                 {@code IllegalArgumentException} if it has a
 594                 non-null {@link java.util.SortedSet#comparator()
 595                 comparator()}.&lt;/p&gt;
 596 
 597     &lt;p&gt;A {@code List&lt;}&lt;em&gt;E&lt;/em&gt;{@code &gt;} is reconstructed as a
 598       {@code java.util.ArrayList&lt;}&lt;em&gt;E&lt;/em&gt;{@code &gt;};
 599       a {@code Set&lt;}&lt;em&gt;E&lt;/em&gt;{@code &gt;} as a
 600       {@code java.util.HashSet&lt;}&lt;em&gt;E&lt;/em&gt;{@code &gt;};
 601       a {@code SortedSet&lt;}&lt;em&gt;E&lt;/em&gt;{@code &gt;} as a
 602       {@code java.util.TreeSet&lt;}&lt;em&gt;E&lt;/em&gt;{@code &gt;}.&lt;/p&gt;
 603 
 604 
 605     &lt;h3&gt;Mappings for maps ({@code Map&lt;}&lt;em&gt;K&lt;/em&gt;,&lt;em&gt;V&lt;/em&gt;{@code &gt;} etc)&lt;/h3&gt;
 606 
 607     &lt;p&gt;A {@code Map&lt;}&lt;em&gt;K&lt;/em&gt;,&lt;em&gt;V&lt;/em&gt;{@code &gt;} or {@code
 608       SortedMap&lt;}&lt;em&gt;K&lt;/em&gt;,&lt;em&gt;V&lt;/em&gt;{@code &gt;}, for example {@code
 609       Map&lt;String,ObjectName&gt;}, has Open Type {@link TabularType} and is mapped
 610         to a {@link TabularData}.
 611         The {@code TabularType} has two items called {@code key} and
 612         {@code value}.  The Open Type of {@code key} is
 613         &lt;em&gt;opentype(K)&lt;/em&gt;, and the Open Type of {@code value} is
 614         &lt;em&gt;opentype(V)&lt;/em&gt;.  The index of the {@code TabularType} is the
 615         single item {@code key}.&lt;/p&gt;
 616 
 617     &lt;p&gt;For example, the {@code TabularType} for a {@code
 618       Map&lt;String,ObjectName&gt;} might be constructed with code like
 619         this:&lt;/p&gt;
 620 
 621     &lt;pre&gt;
 622 String typeName =
 623     &quot;java.util.Map&amp;lt;java.lang.String, javax.management.ObjectName&amp;gt;&quot;;
 624 String[] keyValue =
 625     new String[] {&quot;key&quot;, &quot;value&quot;};
 626 OpenType[] openTypes =
 627     new OpenType[] {SimpleType.STRING, SimpleType.OBJECTNAME};
 628 CompositeType rowType =
 629     new CompositeType(typeName, typeName, keyValue, keyValue, openTypes);
 630 TabularType tabularType =
 631     new TabularType(typeName, typeName, rowType, new String[] {&quot;key&quot;});
 632     &lt;/pre&gt;
 633 
 634     &lt;p&gt;The {@code typeName} here is determined by the &lt;a href=&quot;#type-names&quot;&gt;
 635       type name rules&lt;/a&gt; detailed below.
 636 
 637     &lt;p&gt;A {@code SortedMap&lt;}&lt;em&gt;K&lt;/em&gt;,&lt;em&gt;V&lt;/em&gt;{@code &gt;} is mapped in the
 638       same way, but it is only convertible if
 639       &lt;em&gt;K&lt;/em&gt; is a class or interface that implements {@link
 640       java.lang.Comparable}.  Thus, a {@code SortedMap&lt;String,int[]&gt;}
 641         is convertible, but a
 642         {@code SortedMap&lt;int[],String&gt;} is not.  The conversion of a
 643           {@code SortedMap} instance will fail with an {@code
 644           IllegalArgumentException} if it has a non-null {@link
 645           java.util.SortedMap#comparator() comparator()}.&lt;/p&gt;
 646 
 647     &lt;p&gt;A {@code Map&lt;}&lt;em&gt;K&lt;/em&gt;,&lt;em&gt;V&lt;/em&gt;{@code &gt;} is reconstructed as
 648       a {@code java.util.HashMap&lt;}&lt;em&gt;K&lt;/em&gt;,&lt;em&gt;V&lt;/em&gt;{@code &gt;};
 649       a {@code SortedMap&lt;}&lt;em&gt;K&lt;/em&gt;,&lt;em&gt;V&lt;/em&gt;{@code &gt;} as
 650       a {@code java.util.TreeMap&lt;}&lt;em&gt;K&lt;/em&gt;,&lt;em&gt;V&lt;/em&gt;{@code &gt;}.&lt;/p&gt;
 651 
 652     &lt;p&gt;{@code TabularData} is an interface.  The concrete class that is
 653       used to represent a {@code Map&lt;}&lt;em&gt;K&lt;/em&gt;,&lt;em&gt;V&lt;/em&gt;{@code &gt;} as
 654       Open Data is {@link TabularDataSupport},
 655       or another class implementing {@code
 656       TabularData} that serializes as {@code TabularDataSupport}.&lt;/p&gt;
 657 
 658 
 659     &lt;h3 id=&quot;mxbean-map&quot;&gt;Mappings for MXBean interfaces&lt;/h3&gt;
 660 
 661     &lt;p&gt;An MXBean interface, or a type referenced within an MXBean
 662       interface, can reference another MXBean interface, &lt;em&gt;J&lt;/em&gt;.
 663       Then &lt;em&gt;opentype(J)&lt;/em&gt; is {@code SimpleType.OBJECTNAME} and
 664       &lt;em&gt;opendata(J)&lt;/em&gt; is {@code ObjectName}.&lt;/p&gt;
 665 
 666     &lt;p&gt;For example, suppose you have two MXBean interfaces like this:&lt;/p&gt;
 667 
 668     &lt;pre&gt;
 669 public interface ProductMXBean {
 670     public ModuleMXBean[] getModules();
 671 }
 672 
 673 public interface ModuleMXBean {
 674     public ProductMXBean getProduct();
 675 }
 676     &lt;/pre&gt;
 677 
 678     &lt;p&gt;The object implementing the {@code ModuleMXBean} interface
 679       returns from its {@code getProduct} method an object
 680       implementing the {@code ProductMXBean} interface.  The
 681       {@code ModuleMXBean} object and the returned {@code
 682       ProductMXBean} objects must both be registered as MXBeans in the
 683       same MBean Server.&lt;/p&gt;
 684 
 685     &lt;p&gt;The method {@code ModuleMXBean.getProduct()} defines an
 686       attribute called {@code Product}.  The Open Type for this
 687       attribute is {@code SimpleType.OBJECTNAME}, and the corresponding
 688       {@code ObjectName} value will be the name under which the
 689       referenced {@code ProductMXBean} is registered in the MBean
 690       Server.&lt;/p&gt;
 691 
 692     &lt;p&gt;If you make an MXBean proxy for a {@code ModuleMXBean} and
 693       call its {@code getProduct()} method, the proxy will map the
 694       {@code ObjectName} back into a {@code ProductMXBean} by making
 695       another MXBean proxy.  More formally, when a proxy made with
 696       {@link JMX#newMXBeanProxy(MBeanServerConnection, ObjectName,
 697        Class)
 698       JMX.newMXBeanProxy(mbeanServerConnection, objectNameX,
 699       interfaceX)} needs to map {@code objectNameY} back into {@code
 700       interfaceY}, another MXBean interface, it does so with {@code
 701       JMX.newMXBeanProxy(mbeanServerConnection, objectNameY,
 702       interfaceY)}.  The implementation may return a proxy that was
 703       previously created by a call to {@code JMX.newMXBeanProxy}
 704       with the same parameters, or it may create a new proxy.&lt;/p&gt;
 705 
 706     &lt;p&gt;The reverse mapping is illustrated by the following change to the
 707       {@code ModuleMXBean} interface:&lt;/p&gt;
 708 
 709     &lt;pre&gt;
 710 public interface ModuleMXBean {
 711     public ProductMXBean getProduct();
 712     public void setProduct(ProductMXBean c);
 713 }
 714     &lt;/pre&gt;
 715 
 716     &lt;p&gt;The presence of the {@code setProduct} method now means that the
 717       {@code Product} attribute is read/write.  As before, the value
 718       of this attribute is an {@code ObjectName}.  When the attribute is
 719       set, the {@code ObjectName} must be converted into the
 720       {@code ProductMXBean} object that the {@code setProduct} method
 721       expects.  This object will be an MXBean proxy for the given
 722       {@code ObjectName} in the same MBean Server.&lt;/p&gt;
 723 
 724     &lt;p&gt;If you make an MXBean proxy for a {@code ModuleMXBean} and
 725       call its {@code setProduct} method, the proxy will map its
 726       {@code ProductMXBean} argument back into an {@code ObjectName}.
 727       This will only work if the argument is in fact another proxy,
 728       for a {@code ProductMXBean} in the same {@code
 729       MBeanServerConnection}.  The proxy can have been returned from
 730       another proxy (like {@code ModuleMXBean.getProduct()} which
 731       returns a proxy for a {@code ProductMXBean}); or it can have
 732       been created by {@link
 733       JMX#newMXBeanProxy(MBeanServerConnection, ObjectName, Class)
 734       JMX.newMXBeanProxy}; or it can have been created using {@link
 735       java.lang.reflect.Proxy Proxy} with an invocation handler that
 736       is {@link MBeanServerInvocationHandler} or a subclass.&lt;/p&gt;
 737 
 738     &lt;p&gt;If the same MXBean were registered under two different
 739       {@code ObjectName}s, a reference to that MXBean from another
 740       MXBean would be ambiguous.  Therefore, if an MXBean object is
 741       already registered in an MBean Server and an attempt is made to
 742       register it in the same MBean Server under another name, the
 743       result is an {@link InstanceAlreadyExistsException}.  Registering
 744       the same MBean object under more than one name is discouraged in
 745       general, notably because it does not work well for MBeans that are
 746       {@link NotificationBroadcaster}s.&lt;/p&gt;
 747 
 748     &lt;h3 id=&quot;composite-map&quot;&gt;Mappings for other types&lt;/h3&gt;
 749 
 750     &lt;p&gt;Given a Java class or interface &lt;em&gt;J&lt;/em&gt; that does not match the other
 751       rules in the table above, the MXBean framework will attempt to map
 752       it to a {@link CompositeType} as follows.  The type name of this
 753       {@code CompositeType} is determined by the &lt;a href=&quot;#type-names&quot;&gt;
 754       type name rules&lt;/a&gt; below.&lt;/p&gt;
 755 
 756     &lt;p&gt;The class is examined for getters using the conventions
 757       &lt;a href=&quot;#naming-conv&quot;&gt;above&lt;/a&gt;.  (Getters must be public
 758       instance methods.)  If there are no getters, or if
 759       any getter has a type that is not convertible, then &lt;em&gt;J&lt;/em&gt; is
 760       not convertible.&lt;/p&gt;
 761 
 762     &lt;p&gt;If there is at least one getter and every getter has a
 763       convertible type, then &lt;em&gt;opentype(J)&lt;/em&gt; is a {@code
 764       CompositeType} with one item for every getter.  If the getter is
 765 
 766     &lt;blockquote&gt;
 767       &lt;code&gt;&lt;em&gt;T&lt;/em&gt; get&lt;em&gt;Name&lt;/em&gt;()&lt;/code&gt;
 768     &lt;/blockquote&gt;
 769 
 770     then the item in the {@code CompositeType} is called {@code name}
 771     and has type &lt;em&gt;opentype(T)&lt;/em&gt;.  For example, if the item is
 772 
 773     &lt;blockquote&gt;
 774       &lt;code&gt;String getOwner()&lt;/code&gt;
 775     &lt;/blockquote&gt;
 776 
 777     then the item is called {@code owner} and has Open Type {@code
 778     SimpleType.STRING}.  If the getter is
 779 
 780     &lt;blockquote&gt;
 781       &lt;code&gt;boolean is&lt;em&gt;Name&lt;/em&gt;()&lt;/code&gt;
 782     &lt;/blockquote&gt;
 783 
 784     then the item in the {@code CompositeType} is called {@code name}
 785     and has type {@code SimpleType.BOOLEAN}.
 786 
 787     &lt;p&gt;Notice that the first character (or code point) is converted to
 788       lower case.  This follows the Java Beans convention, which for
 789       historical reasons is different from the Standard MBean
 790       convention.  In a Standard MBean or MXBean interface, a method
 791       {@code getOwner} defines an attribute called {@code Owner}, while
 792       in a Java Bean or mapped {@code CompositeType}, a method {@code
 793       getOwner} defines a property or item called {@code owner}.&lt;/p&gt;
 794 
 795     &lt;p&gt;If two methods produce the same item name (for example, {@code
 796       getOwner} and {@code isOwner}, or {@code getOwner} and {@code
 797       getowner}) then the type is not convertible.&lt;/p&gt;
 798 
 799     &lt;p&gt;When the Open Type is {@code CompositeType}, the corresponding
 800       mapped Java type (&lt;em&gt;opendata(J)&lt;/em&gt;) is {@link
 801       CompositeData}.  The mapping from an instance of &lt;em&gt;J&lt;/em&gt; to a
 802       {@code CompositeData} corresponding to the {@code CompositeType}
 803       just described is done as follows.  First, if &lt;em&gt;J&lt;/em&gt;
 804       implements the interface {@link CompositeDataView}, then that
 805       interface&#39;s {@link CompositeDataView#toCompositeData
 806       toCompositeData} method is called to do the conversion.
 807       Otherwise, the {@code CompositeData} is constructed by calling
 808       the getter for each item and converting it to the corresponding
 809       Open Data type.  Thus, a getter such as&lt;/p&gt;
 810 
 811     &lt;blockquote&gt;
 812       {@code List&lt;String&gt; getNames()}
 813     &lt;/blockquote&gt;
 814 
 815     &lt;p&gt;will have been mapped to an item with name &quot;{@code names}&quot; and
 816       Open Type {@code ArrayType(1, SimpleType.STRING)}.  The conversion
 817       to {@code CompositeData} will call {@code getNames()} and convert
 818       the resultant {@code List&lt;String&gt;} into a {@code String[]} for the
 819         item &quot;{@code names}&quot;.&lt;/p&gt;
 820 
 821     &lt;p&gt;{@code CompositeData} is an interface.  The concrete class that is
 822       used to represent a type as Open Data is {@link
 823       CompositeDataSupport}, or another class implementing {@code
 824       CompositeData} that serializes as {@code
 825       CompositeDataSupport}.&lt;/p&gt;
 826 
 827 
 828     &lt;h4&gt;Reconstructing an instance of Java type &lt;em&gt;J&lt;/em&gt; from
 829       a {@code CompositeData}&lt;/h4&gt;
 830 
 831     &lt;p&gt;If &lt;em&gt;opendata(J)&lt;/em&gt; is {@code CompositeData} for a Java type
 832       &lt;em&gt;J&lt;/em&gt;, then either an instance of &lt;em&gt;J&lt;/em&gt; can be
 833       reconstructed from a {@code CompositeData}, or &lt;em&gt;J&lt;/em&gt; is not
 834       reconstructible.  If any item in the {@code CompositeData} is not
 835       reconstructible, then &lt;em&gt;J&lt;/em&gt; is not reconstructible either.&lt;/p&gt;
 836 
 837     &lt;p&gt;For any given &lt;em&gt;J&lt;/em&gt;, the following rules are consulted to
 838       determine how to reconstruct instances of &lt;em&gt;J&lt;/em&gt; from
 839       {@code CompositeData}.  The first applicable rule in the list is
 840       the one that will be used.&lt;/p&gt;
 841 
 842     &lt;ol&gt;
 843 
 844       &lt;li&gt;&lt;p&gt;If &lt;em&gt;J&lt;/em&gt; has a method&lt;br&gt;
 845         {@code public static }&lt;em&gt;J &lt;/em&gt;{@code from(CompositeData cd)}&lt;br&gt;
 846         then that method is called to reconstruct an instance of
 847         &lt;em&gt;J&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
 848 
 849       &lt;li&gt;&lt;p&gt;Otherwise, if &lt;em&gt;J&lt;/em&gt; has at least one public
 850         constructor with either {@link javax.management.ConstructorParameters
 851         &amp;#64;javax.management.ConstructorParameters} or
 852         {@code @java.beans.ConstructoProperties} annotation, then one of those
 853         constructors (not necessarily always the same one) will be called to
 854         reconstruct an instance of &lt;em&gt;J&lt;/em&gt;.
 855         If a constructor is annotated with both
 856         {@code @javax.management.ConstructorParameters} and
 857         {@code @java.beans.ConstructorProperties},
 858         {@code @javax.management.ConstructorParameters} will be used and
 859         {@code @java.beans.ConstructorProperties} will be ignored.
 860         Every such annotation must list as many strings as the
 861         constructor has parameters; each string must name a property
 862         corresponding to a getter of &lt;em&gt;J&lt;/em&gt;; and the type of this
 863         getter must be the same as the corresponding constructor
 864         parameter.  It is not an error for there to be getters that
 865         are not mentioned in the {@code @ConstructorParameters} or
 866         {@code @ConstructorProperties} annotations (these may correspond to
 867         information that is not needed to reconstruct the object).&lt;/p&gt;
 868 
 869         &lt;p&gt;An instance of &lt;em&gt;J&lt;/em&gt; is reconstructed by calling a
 870         constructor with the appropriate reconstructed items from the
 871         {@code CompositeData}.  The constructor to be called will be
 872         determined at runtime based on the items actually present in
 873         the {@code CompositeData}, given that this {@code
 874         CompositeData} might come from an earlier version of
 875         &lt;em&gt;J&lt;/em&gt; where not all the items were present.  A
 876         constructor is &lt;em&gt;applicable&lt;/em&gt; if all the properties named
 877         in its {@code @ConstructorParameters} or {@code @ConstructorProperties}
 878         annotation are present as items in the {@code CompositeData}.
 879         If no constructor is applicable, then the attempt to reconstruct
 880         &lt;em&gt;J&lt;/em&gt; fails.&lt;/p&gt;
 881 
 882         &lt;p&gt;For any possible combination of properties, it must be the
 883         case that either (a) there are no applicable constructors, or
 884         (b) there is exactly one applicable constructor, or (c) one of
 885         the applicable constructors names a proper superset of the
 886         properties named by each other applicable constructor.  (In
 887         other words, there should never be ambiguity over which
 888         constructor to choose.)  If this condition is not true, then
 889         &lt;em&gt;J&lt;/em&gt; is not reconstructible.&lt;/p&gt;&lt;/li&gt;
 890 
 891       &lt;li&gt;&lt;p&gt;Otherwise, if &lt;em&gt;J&lt;/em&gt; has a public no-arg constructor, and
 892         for every getter in &lt;em&gt;J&lt;/em&gt; with type
 893         &lt;em&gt;T&lt;/em&gt; and name &lt;em&gt;N&lt;/em&gt; there is a corresponding setter
 894         with the same name and type, then an instance of &lt;em&gt;J&lt;/em&gt; is
 895         constructed with the no-arg constructor and the setters are
 896         called with the reconstructed items from the {@code CompositeData}
 897         to restore the values.  For example, if there is a method&lt;br&gt;
 898         {@code public List&lt;String&gt; getNames()}&lt;br&gt;
 899           then there must also be a method&lt;br&gt;
 900           {@code public void setNames(List&lt;String&gt; names)}&lt;br&gt;
 901             for this rule to apply.&lt;/p&gt;
 902 
 903         &lt;p&gt;If the {@code CompositeData} came from an earlier version of
 904         &lt;em&gt;J&lt;/em&gt;, some items might not be present.  In this case,
 905         the corresponding setters will not be called.&lt;/p&gt;&lt;/li&gt;
 906 
 907       &lt;li&gt;&lt;p&gt;Otherwise, if &lt;em&gt;J&lt;/em&gt; is an interface that has no methods
 908         other than getters, an instance of &lt;em&gt;J&lt;/em&gt; is constructed
 909         using a {@link java.lang.reflect.Proxy} with a {@link
 910         CompositeDataInvocationHandler} backed by the {@code
 911         CompositeData} being converted.&lt;/p&gt;&lt;/li&gt;
 912 
 913       &lt;li&gt;&lt;p&gt;Otherwise, &lt;em&gt;J&lt;/em&gt; is not reconstructible.&lt;/p&gt;&lt;/li&gt;
 914     &lt;/ol&gt;
 915 
 916     &lt;p&gt;Rule 2 is not applicable when {@code java.beans.ConstructorProperties}
 917     is not visible (e.g. when the java.desktop module is not readable or when
 918     the runtime image does not contain the java.desktop module). When
 919     targeting a runtime that does not include the {@code java.beans} package,
 920     and where there is a mismatch between the compile-time and runtime
 921     environment whereby &lt;em&gt;J&lt;/em&gt; is compiled with a public constructor
 922     and the {@code ConstructorProperties} annotation, then &lt;em&gt;J&lt;/em&gt; is
 923     not reconstructible unless another rule applies.&lt;/p&gt;
 924 
 925     &lt;p&gt;Here are examples showing different ways to code a type {@code
 926       NamedNumber} that consists of an {@code int} and a {@code
 927       String}.  In each case, the {@code CompositeType} looks like this:&lt;/p&gt;
 928 
 929     &lt;blockquote&gt;
 930       &lt;pre&gt;
 931 {@link CompositeType}(
 932     &quot;NamedNumber&quot;,                      // typeName
 933     &quot;NamedNumber&quot;,                      // description
 934     new String[] {&quot;number&quot;, &quot;name&quot;},    // itemNames
 935     new String[] {&quot;number&quot;, &quot;name&quot;},    // itemDescriptions
 936     new OpenType[] {SimpleType.INTEGER,
 937                     SimpleType.STRING}  // itemTypes
 938 );
 939       &lt;/pre&gt;
 940     &lt;/blockquote&gt;
 941 
 942     &lt;ol&gt;
 943       &lt;li&gt;Static {@code from} method:
 944 
 945         &lt;blockquote&gt;
 946           &lt;pre&gt;
 947 public class NamedNumber {
 948     public int getNumber() {return number;}
 949     public String getName() {return name;}
 950     private NamedNumber(int number, String name) {
 951         this.number = number;
 952         this.name = name;
 953     }
 954     &lt;b&gt;public static NamedNumber from(CompositeData cd)&lt;/b&gt; {
 955         return new NamedNumber((Integer) cd.get(&quot;number&quot;),
 956                                (String) cd.get(&quot;name&quot;));
 957     }
 958     private final int number;
 959     private final String name;
 960 }
 961           &lt;/pre&gt;
 962         &lt;/blockquote&gt;
 963       &lt;/li&gt;
 964 
 965       &lt;li&gt;Public constructor with &lt;code&gt;&amp;#64;ConstructorParameters&lt;/code&gt; annotation:
 966 
 967         &lt;blockquote&gt;
 968           &lt;pre&gt;
 969 public class NamedNumber {
 970     public int getNumber() {return number;}
 971     public String getName() {return name;}
 972     &lt;b&gt;&amp;#64;ConstructorParameters({&quot;number&quot;, &quot;name&quot;})
 973     public NamedNumber(int number, String name)&lt;/b&gt; {
 974         this.number = number;
 975         this.name = name;
 976     }
 977     private final int number;
 978     private final String name;
 979 }
 980           &lt;/pre&gt;
 981         &lt;/blockquote&gt;
 982       &lt;/li&gt;
 983 
 984       &lt;li&gt;Setter for every getter:
 985 
 986         &lt;blockquote&gt;
 987           &lt;pre&gt;
 988 public class NamedNumber {
 989     public int getNumber() {return number;}
 990     public void &lt;b&gt;setNumber&lt;/b&gt;(int number) {this.number = number;}
 991     public String getName() {return name;}
 992     public void &lt;b&gt;setName&lt;/b&gt;(String name) {this.name = name;}
 993     &lt;b&gt;public NamedNumber()&lt;/b&gt; {}
 994     private int number;
 995     private String name;
 996 }
 997           &lt;/pre&gt;
 998         &lt;/blockquote&gt;
 999       &lt;/li&gt;
1000 
1001       &lt;li&gt;Interface with only getters:
1002 
1003         &lt;blockquote&gt;
1004           &lt;pre&gt;
1005 public interface NamedNumber {
1006     public int getNumber();
1007     public String getName();
1008 }
1009           &lt;/pre&gt;
1010         &lt;/blockquote&gt;
1011       &lt;/li&gt;
1012     &lt;/ol&gt;
1013 
1014     &lt;p&gt;It is usually better for classes that simply represent a
1015       collection of data to be &lt;em&gt;immutable&lt;/em&gt;.  An instance of an
1016       immutable class cannot be changed after it has been constructed.
1017       Notice that {@code CompositeData} itself is immutable.
1018       Immutability has many advantages, notably with regard to
1019       thread-safety and security.  So the approach using setters should
1020       generally be avoided if possible.&lt;/p&gt;
1021 
1022 
1023     &lt;h3&gt;Recursive types&lt;/h3&gt;
1024 
1025     &lt;p&gt;Recursive (self-referential) types cannot be used in MXBean
1026       interfaces.  This is a consequence of the immutability of {@link
1027       CompositeType}.  For example, the following type could not be the
1028       type of an attribute, because it refers to itself:&lt;/p&gt;
1029 
1030     &lt;pre&gt;
1031 public interface &lt;b&gt;Node&lt;/b&gt; {
1032     public String getName();
1033     public int getPriority();
1034     public &lt;b&gt;Node&lt;/b&gt; getNext();
1035 }
1036 &lt;/pre&gt;
1037 
1038     &lt;p&gt;It is always possible to rewrite recursive types like this so
1039       they are no longer recursive.  Doing so may require introducing
1040       new types.  For example:&lt;/p&gt;
1041 
1042     &lt;pre&gt;
1043 public interface &lt;b&gt;NodeList&lt;/b&gt; {
1044     public List&amp;lt;Node&amp;gt; getNodes();
1045 }
1046 
1047 public interface Node {
1048     public String getName();
1049     public int getPriority();
1050 }
1051 &lt;/pre&gt;
1052 
1053     &lt;h3&gt;MBeanInfo contents for an MXBean&lt;/h3&gt;
1054 
1055     &lt;p&gt;An MXBean is a type of Open MBean.  However, for compatibility
1056       reasons, its {@link MBeanInfo} is not an {@link OpenMBeanInfo}.
1057       In particular, when the type of an attribute, parameter, or
1058       operation return value is a primitive type such as {@code int},
1059       or is {@code void} (for a return type), then the attribute,
1060       parameter, or operation will be represented respectively by an
1061       {@link MBeanAttributeInfo}, {@link MBeanParameterInfo}, or
1062       {@link MBeanOperationInfo} whose {@code getType()} or {@code
1063       getReturnType()} returns the primitive name (&quot;{@code int}&quot; etc).
1064       This is so even though the mapping rules above specify that the
1065       &lt;em&gt;opendata&lt;/em&gt; mapping is the wrapped type ({@code Integer}
1066       etc).&lt;/p&gt;
1067 
1068     &lt;p&gt;The array of public constructors returned by {@link
1069       MBeanInfo#getConstructors()} for an MXBean that is directly
1070       registered in the MBean Server will contain all of the public
1071       constructors of that MXBean.  If the class of the MXBean is not
1072       public then its constructors are not considered public either.
1073       The list returned for an MXBean that is constructed using the
1074       {@link StandardMBean} class is derived in the same way as for
1075       Standard MBeans.  Regardless of how the MXBean was constructed,
1076       its constructor parameters are not subject to MXBean mapping
1077       rules and do not have a corresponding {@code OpenType}.&lt;/p&gt;
1078 
1079     &lt;p&gt;The array of notification types returned by {@link
1080       MBeanInfo#getNotifications()} for an MXBean that is directly
1081       registered in the MBean Server will be empty if the MXBean does
1082       not implement the {@link NotificationBroadcaster} interface.
1083       Otherwise, it will be the result of calling {@link
1084       NotificationBroadcaster#getNotificationInfo()} at the time the MXBean
1085       was registered.  Even if the result of this method changes
1086       subsequently, the result of {@code MBeanInfo.getNotifications()}
1087       will not.  The list returned for an MXBean that is constructed
1088       using the {@link StandardMBean} or {@link StandardEmitterMBean}
1089       class is derived in the same way as for Standard MBeans.&lt;/p&gt;
1090 
1091     &lt;p&gt;The {@link Descriptor} for all of the
1092       {@code MBeanAttributeInfo}, {@code MBeanParameterInfo}, and
1093       {@code MBeanOperationInfo} objects contained in the {@code MBeanInfo}
1094       will have a field {@code openType} whose value is the {@link OpenType}
1095       specified by the mapping rules above.  So even when {@code getType()}
1096       is &quot;{@code int}&quot;, {@code getDescriptor().getField(&quot;openType&quot;)} will
1097       be {@link SimpleType#INTEGER}.&lt;/p&gt;
1098 
1099     &lt;p&gt;The {@code Descriptor} for each of these objects will also have a
1100       field {@code originalType} that is a string representing the Java type
1101       that appeared in the MXBean interface.  The format of this string
1102       is described in the section &lt;a href=&quot;#type-names&quot;&gt;Type Names&lt;/a&gt;
1103       below.&lt;/p&gt;
1104 
1105     &lt;p&gt;The {@code Descriptor} for the {@code MBeanInfo} will have a field
1106       {@code mxbean} whose value is the string &quot;{@code true}&quot;.&lt;/p&gt;
1107 
1108 
1109     &lt;h3 id=&quot;type-names&quot;&gt;Type Names&lt;/h3&gt;
1110 
1111     &lt;p&gt;Sometimes the unmapped type &lt;em&gt;T&lt;/em&gt; of a method parameter or
1112     return value in an MXBean must be represented as a string.  If
1113     &lt;em&gt;T&lt;/em&gt; is a non-generic type, this string is the value
1114     returned by {@link Class#getName()}.  Otherwise it is the value of
1115     &lt;em&gt;genericstring(T)&lt;/em&gt;, defined as follows:
1116 
1117     &lt;ul&gt;
1118 
1119       &lt;li&gt;If &lt;em&gt;T&lt;/em&gt; is a non-generic non-array type,
1120       &lt;em&gt;genericstring(T)&lt;/em&gt; is the value returned by {@link
1121       Class#getName()}, for example {@code &quot;int&quot;} or {@code
1122       &quot;java.lang.String&quot;}.
1123 
1124       &lt;li&gt;If &lt;em&gt;T&lt;/em&gt; is an array &lt;em&gt;E[]&lt;/em&gt;,
1125       &lt;em&gt;genericstring(T)&lt;/em&gt; is &lt;em&gt;genericstring(E)&lt;/em&gt; followed
1126       by {@code &quot;[]&quot;}.  For example, &lt;em&gt;genericstring({@code int[]})&lt;/em&gt;
1127       is {@code &quot;int[]&quot;}, and &lt;em&gt;genericstring({@code
1128       List&lt;String&gt;[][]})&lt;/em&gt; is {@code
1129       &quot;java.util.List&lt;java.lang.String&gt;[][]&quot;}.
1130 
1131     &lt;li&gt;Otherwise, &lt;em&gt;T&lt;/em&gt; is a parameterized type such as {@code
1132     List&lt;String&gt;} and &lt;em&gt;genericstring(T)&lt;/em&gt; consists of the
1133     following: the fully-qualified name of the parameterized type as
1134     returned by {@code Class.getName()}; a left angle bracket ({@code
1135     &quot;&lt;&quot;}); &lt;em&gt;genericstring(A)&lt;/em&gt; where &lt;em&gt;A&lt;/em&gt; is the first
1136     type parameter; if there is a second type parameter &lt;em&gt;B&lt;/em&gt;
1137     then {@code &quot;, &quot;} (a comma and a single space) followed by
1138     &lt;em&gt;genericstring(B)&lt;/em&gt;; a right angle bracket ({@code &quot;&gt;&quot;}).
1139 
1140     &lt;/ul&gt;
1141 
1142     &lt;p&gt;Note that if a method returns {@code int[]}, this will be
1143       represented by the string {@code &quot;[I&quot;} returned by {@code
1144       Class.getName()}, but if a method returns {@code List&lt;int[]&gt;},
1145       this will be represented by the string {@code
1146       &quot;java.util.List&lt;int[]&gt;&quot;}.
1147 
1148     &lt;h3&gt;Exceptions&lt;/h3&gt;
1149 
1150     &lt;p&gt;A problem with mapping &lt;em&gt;from&lt;/em&gt; Java types &lt;em&gt;to&lt;/em&gt;
1151       Open types is signaled with an {@link OpenDataException}.  This
1152       can happen when an MXBean interface is being analyzed, for
1153       example if it references a type like {@link java.util.Random
1154       java.util.Random} that has no getters.  Or it can happen when an
1155       instance is being converted (a return value from a method in an
1156       MXBean or a parameter to a method in an MXBean proxy), for
1157       example when converting from {@code SortedSet&lt;String&gt;} to {@code
1158       String[]} if the {@code SortedSet} has a non-null {@code
1159       Comparator}.&lt;/p&gt;
1160 
1161     &lt;p&gt;A problem with mapping &lt;em&gt;to&lt;/em&gt; Java types &lt;em&gt;from&lt;/em&gt;
1162       Open types is signaled with an {@link InvalidObjectException}.
1163       This can happen when an MXBean interface is being analyzed, for
1164       example if it references a type that is not
1165       &lt;em&gt;reconstructible&lt;/em&gt; according to the rules above, in a
1166       context where a reconstructible type is required.  Or it can
1167       happen when an instance is being converted (a parameter to a
1168       method in an MXBean or a return value from a method in an MXBean
1169       proxy), for example from a String to an Enum if there is no Enum
1170       constant with that name.&lt;/p&gt;
1171 
1172     &lt;p&gt;Depending on the context, the {@code OpenDataException} or
1173       {@code InvalidObjectException} may be wrapped in another
1174       exception such as {@link RuntimeMBeanException} or {@link
1175       UndeclaredThrowableException}.  For every thrown exception,
1176       the condition &lt;em&gt;C&lt;/em&gt; will be true: &quot;&lt;em&gt;e&lt;/em&gt; is {@code
1177       OpenDataException} or {@code InvalidObjectException} (as
1178       appropriate), or &lt;em&gt;C&lt;/em&gt; is true of &lt;em&gt;e&lt;/em&gt;.{@link
1179       Throwable#getCause() getCause()}&quot;.&lt;/p&gt;
1180 
1181    @since 1.6
1182 */
1183 
1184 @Documented
1185 @Retention(RetentionPolicy.RUNTIME)
1186 @Target(ElementType.TYPE)
1187 public @interface MXBean {
1188     /**
1189        True if the annotated interface is an MXBean interface.
1190        @return true if the annotated interface is an MXBean interface.
1191     */
1192     boolean value() default true;
1193 }
    </pre>
  </body>
</html>
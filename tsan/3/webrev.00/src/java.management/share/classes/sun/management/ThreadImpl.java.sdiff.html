<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.management/share/classes/sun/management/ThreadImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="MonitorInfoCompositeData.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ThreadInfoCompositeData.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.management/share/classes/sun/management/ThreadImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.management;
 27 
 28 import java.lang.management.ManagementFactory;
 29 import java.lang.management.ThreadInfo;
 30 import java.lang.management.ThreadMXBean;
 31 import javax.management.ObjectName;

 32 
 33 /**
 34  * Implementation for java.lang.management.ThreadMXBean as well as providing the
 35  * supporting method for com.sun.management.ThreadMXBean.
 36  * The supporting method for com.sun.management.ThreadMXBean can be moved to
 37  * jdk.management in the future.
 38  */
 39 
 40 public class ThreadImpl implements ThreadMXBean {
 41     private final VMManagement jvm;
 42 
 43     // default for thread contention monitoring is disabled.
 44     private boolean contentionMonitoringEnabled = false;
 45     private boolean cpuTimeEnabled;
 46     private boolean allocatedMemoryEnabled;
 47 
 48     /**
 49      * Constructor of ThreadImpl class.
 50      */
 51     protected ThreadImpl(VMManagement vm) {
</pre>
<hr />
<pre>
 95 
 96     @Override
 97     public boolean isCurrentThreadCpuTimeSupported() {
 98         return jvm.isCurrentThreadCpuTimeSupported();
 99     }
100 
101     protected boolean isThreadAllocatedMemorySupported() {
102         return jvm.isThreadAllocatedMemorySupported();
103     }
104 
105     @Override
106     public boolean isThreadCpuTimeEnabled() {
107         if (!isThreadCpuTimeSupported() &amp;&amp;
108             !isCurrentThreadCpuTimeSupported()) {
109             throw new UnsupportedOperationException(
110                 &quot;Thread CPU time measurement is not supported&quot;);
111         }
112         return cpuTimeEnabled;
113     }
114 
<span class="line-modified">115     protected boolean isThreadAllocatedMemoryEnabled() {</span>
116         if (!isThreadAllocatedMemorySupported()) {
117             throw new UnsupportedOperationException(
<span class="line-modified">118                 &quot;Thread allocated memory measurement is not supported&quot;);</span>
119         }




120         return allocatedMemoryEnabled;
121     }
122 
123     @Override
124     public long[] getAllThreadIds() {
125         Util.checkMonitorAccess();
126 
127         Thread[] threads = getThreads();
128         int length = threads.length;
129         long[] ids = new long[length];
130         for (int i = 0; i &lt; length; i++) {
131             Thread t = threads[i];
132             ids[i] = t.getId();
133         }
134         return ids;
135     }
136 
137     @Override
138     public ThreadInfo getThreadInfo(long id) {
139         long[] ids = new long[1];
140         ids[0] = id;
141         final ThreadInfo[] infos = getThreadInfo(ids, 0);
142         return infos[0];
143     }
144 
145     @Override
146     public ThreadInfo getThreadInfo(long id, int maxDepth) {
147         long[] ids = new long[1];
148         ids[0] = id;
149         final ThreadInfo[] infos = getThreadInfo(ids, maxDepth);
150         return infos[0];
151     }
152 
153     @Override
154     public ThreadInfo[] getThreadInfo(long[] ids) {
155         return getThreadInfo(ids, 0);
156     }
157 
<span class="line-modified">158     private void verifyThreadIds(long[] ids) {</span>
<span class="line-modified">159         if (ids == null) {</span>
<span class="line-modified">160             throw new NullPointerException(&quot;Null ids parameter.&quot;);</span>

161         }




162 
163         for (int i = 0; i &lt; ids.length; i++) {
<span class="line-modified">164             if (ids[i] &lt;= 0) {</span>
<span class="line-removed">165                 throw new IllegalArgumentException(</span>
<span class="line-removed">166                     &quot;Invalid thread ID parameter: &quot; + ids[i]);</span>
<span class="line-removed">167             }</span>
168         }
169     }
170 
171     @Override
172     public ThreadInfo[] getThreadInfo(long[] ids, int maxDepth) {
173         verifyThreadIds(ids);
174 
175         if (maxDepth &lt; 0) {
176             throw new IllegalArgumentException(
177                 &quot;Invalid maxDepth parameter: &quot; + maxDepth);
178         }
179 
180         // ids has been verified to be non-null
181         // an empty array of ids should return an empty array of ThreadInfos
182         if (ids.length == 0) return new ThreadInfo[0];
183 
184         Util.checkMonitorAccess();
185 
186         ThreadInfo[] infos = new ThreadInfo[ids.length]; // nulls
187         if (maxDepth == Integer.MAX_VALUE) {
</pre>
<hr />
<pre>
325     }
326 
327     @Override
328     public void setThreadCpuTimeEnabled(boolean enable) {
329         if (!isThreadCpuTimeSupported() &amp;&amp;
330             !isCurrentThreadCpuTimeSupported()) {
331             throw new UnsupportedOperationException(
332                 &quot;Thread CPU time measurement is not supported&quot;);
333         }
334 
335         Util.checkControlAccess();
336         synchronized (this) {
337             if (cpuTimeEnabled != enable) {
338                 // notify VM of the state change
339                 setThreadCpuTimeEnabled0(enable);
340                 cpuTimeEnabled = enable;
341             }
342         }
343     }
344 
<span class="line-modified">345     protected long getThreadAllocatedBytes(long id) {</span>
<span class="line-modified">346         long[] ids = new long[1];</span>
<span class="line-modified">347         ids[0] = id;</span>
<span class="line-modified">348         final long[] sizes = getThreadAllocatedBytes(ids);</span>
<span class="line-modified">349         return sizes[0];</span>
350     }
351 
<span class="line-modified">352     private boolean verifyThreadAllocatedMemory(long[] ids) {</span>
<span class="line-modified">353         verifyThreadIds(ids);</span>


354 
<span class="line-modified">355         // check if Thread allocated memory measurement is supported.</span>
<span class="line-modified">356         if (!isThreadAllocatedMemorySupported()) {</span>
<span class="line-modified">357             throw new UnsupportedOperationException(</span>
<span class="line-modified">358                 &quot;Thread allocated memory measurement is not supported.&quot;);</span>


359         }


360 


361         return isThreadAllocatedMemoryEnabled();
362     }
363 
364     protected long[] getThreadAllocatedBytes(long[] ids) {







365         boolean verified = verifyThreadAllocatedMemory(ids);
366 
367         long[] sizes = new long[ids.length];
368         java.util.Arrays.fill(sizes, -1);
369 
370         if (verified) {
371             getThreadAllocatedMemory1(ids, sizes);
372         }
373         return sizes;
374     }
375 
376     protected void setThreadAllocatedMemoryEnabled(boolean enable) {
<span class="line-modified">377         if (!isThreadAllocatedMemorySupported()) {</span>
<span class="line-removed">378             throw new UnsupportedOperationException(</span>
<span class="line-removed">379                 &quot;Thread allocated memory measurement is not supported.&quot;);</span>
<span class="line-removed">380         }</span>
381 
382         Util.checkControlAccess();
383         synchronized (this) {
384             if (allocatedMemoryEnabled != enable) {
385                 // notify VM of the state change
386                 setThreadAllocatedMemoryEnabled0(enable);
387                 allocatedMemoryEnabled = enable;
388             }
389         }
390     }
391 
392     @Override
393     public long[] findMonitorDeadlockedThreads() {
394         Util.checkMonitorAccess();
395 
396         Thread[] threads = findMonitorDeadlockedThreads0();
397         if (threads == null) {
398             return null;
399         }
400 
</pre>
<hr />
<pre>
494     public ThreadInfo[] dumpAllThreads(boolean lockedMonitors,
495                                        boolean lockedSynchronizers,
496                                        int maxDepth) {
497         if (maxDepth &lt; 0) {
498             throw new IllegalArgumentException(
499                     &quot;Invalid maxDepth parameter: &quot; + maxDepth);
500         }
501         verifyDumpThreads(lockedMonitors, lockedSynchronizers);
502         return dumpThreads0(null, lockedMonitors, lockedSynchronizers, maxDepth);
503     }
504 
505     // VM support where maxDepth == -1 to request entire stack dump
506     private static native Thread[] getThreads();
507     private static native void getThreadInfo1(long[] ids,
508                                               int maxDepth,
509                                               ThreadInfo[] result);
510     private static native long getThreadTotalCpuTime0(long id);
511     private static native void getThreadTotalCpuTime1(long[] ids, long[] result);
512     private static native long getThreadUserCpuTime0(long id);
513     private static native void getThreadUserCpuTime1(long[] ids, long[] result);

514     private static native void getThreadAllocatedMemory1(long[] ids, long[] result);
515     private static native void setThreadCpuTimeEnabled0(boolean enable);
516     private static native void setThreadAllocatedMemoryEnabled0(boolean enable);
517     private static native void setThreadContentionMonitoringEnabled0(boolean enable);
518     private static native Thread[] findMonitorDeadlockedThreads0();
519     private static native Thread[] findDeadlockedThreads0();
520     private static native void resetPeakThreadCount0();
521     private static native ThreadInfo[] dumpThreads0(long[] ids,
522                                                     boolean lockedMonitors,
523                                                     boolean lockedSynchronizers,
524                                                     int maxDepth);
525 
526     // tid == 0 to reset contention times for all threads
527     private static native void resetContentionTimes0(long tid);
528 
529     @Override
530     public ObjectName getObjectName() {
531         return Util.newObjectName(ManagementFactory.THREAD_MXBEAN_NAME);
532     }
533 
</pre>
</td>
<td>
<hr />
<pre>
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.management;
 27 
 28 import java.lang.management.ManagementFactory;
 29 import java.lang.management.ThreadInfo;
 30 import java.lang.management.ThreadMXBean;
 31 import javax.management.ObjectName;
<span class="line-added"> 32 import java.util.Objects;</span>
 33 
 34 /**
 35  * Implementation for java.lang.management.ThreadMXBean as well as providing the
 36  * supporting method for com.sun.management.ThreadMXBean.
 37  * The supporting method for com.sun.management.ThreadMXBean can be moved to
 38  * jdk.management in the future.
 39  */
 40 
 41 public class ThreadImpl implements ThreadMXBean {
 42     private final VMManagement jvm;
 43 
 44     // default for thread contention monitoring is disabled.
 45     private boolean contentionMonitoringEnabled = false;
 46     private boolean cpuTimeEnabled;
 47     private boolean allocatedMemoryEnabled;
 48 
 49     /**
 50      * Constructor of ThreadImpl class.
 51      */
 52     protected ThreadImpl(VMManagement vm) {
</pre>
<hr />
<pre>
 96 
 97     @Override
 98     public boolean isCurrentThreadCpuTimeSupported() {
 99         return jvm.isCurrentThreadCpuTimeSupported();
100     }
101 
102     protected boolean isThreadAllocatedMemorySupported() {
103         return jvm.isThreadAllocatedMemorySupported();
104     }
105 
106     @Override
107     public boolean isThreadCpuTimeEnabled() {
108         if (!isThreadCpuTimeSupported() &amp;&amp;
109             !isCurrentThreadCpuTimeSupported()) {
110             throw new UnsupportedOperationException(
111                 &quot;Thread CPU time measurement is not supported&quot;);
112         }
113         return cpuTimeEnabled;
114     }
115 
<span class="line-modified">116     private void ensureThreadAllocatedMemorySupported() {</span>
117         if (!isThreadAllocatedMemorySupported()) {
118             throw new UnsupportedOperationException(
<span class="line-modified">119                 &quot;Thread allocated memory measurement is not supported.&quot;);</span>
120         }
<span class="line-added">121     }</span>
<span class="line-added">122 </span>
<span class="line-added">123     protected boolean isThreadAllocatedMemoryEnabled() {</span>
<span class="line-added">124         ensureThreadAllocatedMemorySupported();</span>
125         return allocatedMemoryEnabled;
126     }
127 
128     @Override
129     public long[] getAllThreadIds() {
130         Util.checkMonitorAccess();
131 
132         Thread[] threads = getThreads();
133         int length = threads.length;
134         long[] ids = new long[length];
135         for (int i = 0; i &lt; length; i++) {
136             Thread t = threads[i];
137             ids[i] = t.getId();
138         }
139         return ids;
140     }
141 
142     @Override
143     public ThreadInfo getThreadInfo(long id) {
144         long[] ids = new long[1];
145         ids[0] = id;
146         final ThreadInfo[] infos = getThreadInfo(ids, 0);
147         return infos[0];
148     }
149 
150     @Override
151     public ThreadInfo getThreadInfo(long id, int maxDepth) {
152         long[] ids = new long[1];
153         ids[0] = id;
154         final ThreadInfo[] infos = getThreadInfo(ids, maxDepth);
155         return infos[0];
156     }
157 
158     @Override
159     public ThreadInfo[] getThreadInfo(long[] ids) {
160         return getThreadInfo(ids, 0);
161     }
162 
<span class="line-modified">163     private void verifyThreadId(long id) {</span>
<span class="line-modified">164         if (id &lt;= 0) {</span>
<span class="line-modified">165             throw new IllegalArgumentException(</span>
<span class="line-added">166                 &quot;Invalid thread ID parameter: &quot; + id);</span>
167         }
<span class="line-added">168     }</span>
<span class="line-added">169 </span>
<span class="line-added">170     private void verifyThreadIds(long[] ids) {</span>
<span class="line-added">171         Objects.requireNonNull(ids);</span>
172 
173         for (int i = 0; i &lt; ids.length; i++) {
<span class="line-modified">174             verifyThreadId(ids[i]);</span>



175         }
176     }
177 
178     @Override
179     public ThreadInfo[] getThreadInfo(long[] ids, int maxDepth) {
180         verifyThreadIds(ids);
181 
182         if (maxDepth &lt; 0) {
183             throw new IllegalArgumentException(
184                 &quot;Invalid maxDepth parameter: &quot; + maxDepth);
185         }
186 
187         // ids has been verified to be non-null
188         // an empty array of ids should return an empty array of ThreadInfos
189         if (ids.length == 0) return new ThreadInfo[0];
190 
191         Util.checkMonitorAccess();
192 
193         ThreadInfo[] infos = new ThreadInfo[ids.length]; // nulls
194         if (maxDepth == Integer.MAX_VALUE) {
</pre>
<hr />
<pre>
332     }
333 
334     @Override
335     public void setThreadCpuTimeEnabled(boolean enable) {
336         if (!isThreadCpuTimeSupported() &amp;&amp;
337             !isCurrentThreadCpuTimeSupported()) {
338             throw new UnsupportedOperationException(
339                 &quot;Thread CPU time measurement is not supported&quot;);
340         }
341 
342         Util.checkControlAccess();
343         synchronized (this) {
344             if (cpuTimeEnabled != enable) {
345                 // notify VM of the state change
346                 setThreadCpuTimeEnabled0(enable);
347                 cpuTimeEnabled = enable;
348             }
349         }
350     }
351 
<span class="line-modified">352     protected long getCurrentThreadAllocatedBytes() {</span>
<span class="line-modified">353         if (isThreadAllocatedMemoryEnabled()) {</span>
<span class="line-modified">354             return getThreadAllocatedMemory0(0);</span>
<span class="line-modified">355         }</span>
<span class="line-modified">356         return -1;</span>
357     }
358 
<span class="line-modified">359     private boolean verifyThreadAllocatedMemory(long id) {</span>
<span class="line-modified">360         verifyThreadId(id);</span>
<span class="line-added">361         return isThreadAllocatedMemoryEnabled();</span>
<span class="line-added">362     }</span>
363 
<span class="line-modified">364     protected long getThreadAllocatedBytes(long id) {</span>
<span class="line-modified">365         boolean verified = verifyThreadAllocatedMemory(id);</span>
<span class="line-modified">366 </span>
<span class="line-modified">367         if (verified) {</span>
<span class="line-added">368             return getThreadAllocatedMemory0(</span>
<span class="line-added">369                 Thread.currentThread().getId() == id ? 0 : id);</span>
370         }
<span class="line-added">371         return -1;</span>
<span class="line-added">372     }</span>
373 
<span class="line-added">374     private boolean verifyThreadAllocatedMemory(long[] ids) {</span>
<span class="line-added">375         verifyThreadIds(ids);</span>
376         return isThreadAllocatedMemoryEnabled();
377     }
378 
379     protected long[] getThreadAllocatedBytes(long[] ids) {
<span class="line-added">380         Objects.requireNonNull(ids);</span>
<span class="line-added">381 </span>
<span class="line-added">382         if (ids.length == 1) {</span>
<span class="line-added">383             long size = getThreadAllocatedBytes(ids[0]);</span>
<span class="line-added">384             return new long[] { size };</span>
<span class="line-added">385         }</span>
<span class="line-added">386 </span>
387         boolean verified = verifyThreadAllocatedMemory(ids);
388 
389         long[] sizes = new long[ids.length];
390         java.util.Arrays.fill(sizes, -1);
391 
392         if (verified) {
393             getThreadAllocatedMemory1(ids, sizes);
394         }
395         return sizes;
396     }
397 
398     protected void setThreadAllocatedMemoryEnabled(boolean enable) {
<span class="line-modified">399         ensureThreadAllocatedMemorySupported();</span>



400 
401         Util.checkControlAccess();
402         synchronized (this) {
403             if (allocatedMemoryEnabled != enable) {
404                 // notify VM of the state change
405                 setThreadAllocatedMemoryEnabled0(enable);
406                 allocatedMemoryEnabled = enable;
407             }
408         }
409     }
410 
411     @Override
412     public long[] findMonitorDeadlockedThreads() {
413         Util.checkMonitorAccess();
414 
415         Thread[] threads = findMonitorDeadlockedThreads0();
416         if (threads == null) {
417             return null;
418         }
419 
</pre>
<hr />
<pre>
513     public ThreadInfo[] dumpAllThreads(boolean lockedMonitors,
514                                        boolean lockedSynchronizers,
515                                        int maxDepth) {
516         if (maxDepth &lt; 0) {
517             throw new IllegalArgumentException(
518                     &quot;Invalid maxDepth parameter: &quot; + maxDepth);
519         }
520         verifyDumpThreads(lockedMonitors, lockedSynchronizers);
521         return dumpThreads0(null, lockedMonitors, lockedSynchronizers, maxDepth);
522     }
523 
524     // VM support where maxDepth == -1 to request entire stack dump
525     private static native Thread[] getThreads();
526     private static native void getThreadInfo1(long[] ids,
527                                               int maxDepth,
528                                               ThreadInfo[] result);
529     private static native long getThreadTotalCpuTime0(long id);
530     private static native void getThreadTotalCpuTime1(long[] ids, long[] result);
531     private static native long getThreadUserCpuTime0(long id);
532     private static native void getThreadUserCpuTime1(long[] ids, long[] result);
<span class="line-added">533     private static native long getThreadAllocatedMemory0(long id);</span>
534     private static native void getThreadAllocatedMemory1(long[] ids, long[] result);
535     private static native void setThreadCpuTimeEnabled0(boolean enable);
536     private static native void setThreadAllocatedMemoryEnabled0(boolean enable);
537     private static native void setThreadContentionMonitoringEnabled0(boolean enable);
538     private static native Thread[] findMonitorDeadlockedThreads0();
539     private static native Thread[] findDeadlockedThreads0();
540     private static native void resetPeakThreadCount0();
541     private static native ThreadInfo[] dumpThreads0(long[] ids,
542                                                     boolean lockedMonitors,
543                                                     boolean lockedSynchronizers,
544                                                     int maxDepth);
545 
546     // tid == 0 to reset contention times for all threads
547     private static native void resetContentionTimes0(long tid);
548 
549     @Override
550     public ObjectName getObjectName() {
551         return Util.newObjectName(ManagementFactory.THREAD_MXBEAN_NAME);
552     }
553 
</pre>
</td>
</tr>
</table>
<center><a href="MonitorInfoCompositeData.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ThreadInfoCompositeData.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
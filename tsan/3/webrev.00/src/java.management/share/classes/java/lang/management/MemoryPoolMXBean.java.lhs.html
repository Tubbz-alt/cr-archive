<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.management/share/classes/java/lang/management/MemoryPoolMXBean.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.management;
 27 
 28 /**
 29  * The management interface for a memory pool.  A memory pool
 30  * represents the memory resource managed by the Java virtual machine
 31  * and is managed by one or more {@link MemoryManagerMXBean memory managers}.
 32  *
 33  * &lt;p&gt; A Java virtual machine has one or more instances of the
 34  * implementation class of this interface.  An instance
 35  * implementing this interface is
 36  * an &lt;a href=&quot;ManagementFactory.html#MXBean&quot;&gt;MXBean&lt;/a&gt;
 37  * that can be obtained by calling
 38  * the {@link ManagementFactory#getMemoryPoolMXBeans} method or
 39  * from the {@link ManagementFactory#getPlatformMBeanServer
 40  * platform MBeanServer} method.
 41  *
 42  * &lt;p&gt;The {@code ObjectName} for uniquely identifying the MXBean for
 43  * a memory pool within an {@code MBeanServer} is:
 44  * &lt;blockquote&gt;
 45  *    {@link ManagementFactory#MEMORY_POOL_MXBEAN_DOMAIN_TYPE
 46  *    java.lang:type=MemoryPool}{@code ,name=}&lt;i&gt;pool&#39;s name&lt;/i&gt;
 47  * &lt;/blockquote&gt;
 48  *
 49  * It can be obtained by calling the
 50  * {@link PlatformManagedObject#getObjectName} method.
 51  *
<a name="2" id="anc2"></a><span class="line-modified"> 52  * &lt;h3&gt;Memory Type&lt;/h3&gt;</span>
 53  * &lt;p&gt;The Java virtual machine has a heap for object allocation and also
 54  * maintains non-heap memory for the method area and the Java virtual
 55  * machine execution.  The Java virtual machine can have one or more
 56  * memory pools.  Each memory pool represents a memory area
 57  * of one of the following types:
 58  * &lt;ul&gt;
 59  *   &lt;li&gt;{@link MemoryType#HEAP heap}&lt;/li&gt;
 60  *   &lt;li&gt;{@link MemoryType#NON_HEAP non-heap}&lt;/li&gt;
 61  * &lt;/ul&gt;
 62  *
<a name="3" id="anc3"></a><span class="line-modified"> 63  * &lt;h3&gt;Memory Usage Monitoring&lt;/h3&gt;</span>
 64  *
 65  * A memory pool has the following attributes:
 66  * &lt;ul&gt;
 67  *   &lt;li&gt;&lt;a href=&quot;#Usage&quot;&gt;Memory usage&lt;/a&gt;&lt;/li&gt;
 68  *   &lt;li&gt;&lt;a href=&quot;#PeakUsage&quot;&gt;Peak memory usage&lt;/a&gt;&lt;/li&gt;
 69  *   &lt;li&gt;&lt;a href=&quot;#UsageThreshold&quot;&gt;Usage Threshold&lt;/a&gt;&lt;/li&gt;
 70  *   &lt;li&gt;&lt;a href=&quot;#CollectionThreshold&quot;&gt;Collection Usage Threshold&lt;/a&gt;
 71  *       (only supported by some &lt;em&gt;garbage-collected&lt;/em&gt; memory pools)&lt;/li&gt;
 72  * &lt;/ul&gt;
 73  *
 74  * &lt;h3&gt;&lt;a id=&quot;Usage&quot;&gt;1. Memory Usage&lt;/a&gt;&lt;/h3&gt;
 75  *
 76  * The {@link #getUsage} method provides an estimate
 77  * of the current usage of a memory pool.
 78  * For a garbage-collected memory pool, the amount of used memory
 79  * includes the memory occupied by all objects in the pool
 80  * including both &lt;em&gt;reachable&lt;/em&gt; and &lt;em&gt;unreachable&lt;/em&gt; objects.
 81  *
 82  * &lt;p&gt;In general, this method is a lightweight operation for getting
 83  * an approximate memory usage.  For some memory pools, for example,
 84  * when objects are not packed contiguously, this method may be
 85  * an expensive operation that requires some computation to determine
 86  * the current memory usage.  An implementation should document when
 87  * this is the case.
 88  *
 89  * &lt;h3&gt;&lt;a id=&quot;PeakUsage&quot;&gt;2. Peak Memory Usage&lt;/a&gt;&lt;/h3&gt;
 90  *
 91  * The Java virtual machine maintains the peak memory usage of a memory
 92  * pool since the virtual machine was started or the peak was reset.
 93  * The peak memory usage is returned by the {@link #getPeakUsage} method
 94  * and reset by calling the {@link #resetPeakUsage} method.
 95  *
 96  * &lt;h3&gt;&lt;a id=&quot;UsageThreshold&quot;&gt;3. Usage Threshold&lt;/a&gt;&lt;/h3&gt;
 97  *
 98  * Each memory pool has a manageable attribute
 99  * called the &lt;i&gt;usage threshold&lt;/i&gt; which has a default value supplied
100  * by the Java virtual machine.  The default value is platform-dependent.
101  * The usage threshold can be set via the
102  * {@link #setUsageThreshold setUsageThreshold} method.
103  * If the threshold is set to a positive value, the usage threshold crossing
104  * checking is enabled in this memory pool.
105  * If the usage threshold is set to zero, usage
106  * threshold crossing checking on this memory pool is disabled.
107  * The {@link MemoryPoolMXBean#isUsageThresholdSupported} method can
108  * be used to determine if this functionality is supported.
109  * &lt;p&gt;
110  * A Java virtual machine performs usage threshold crossing checking on a
111  * memory pool basis at its best appropriate time, typically,
112  * at garbage collection time.
113  * Each memory pool maintains a {@link #getUsageThresholdCount
114  * usage threshold count} that will get incremented
115  * every time when the Java virtual machine
116  * detects that the memory pool usage is crossing the threshold.
117  * &lt;p&gt;
118  * This manageable usage threshold attribute is designed for monitoring the
119  * increasing trend of memory usage with low overhead.
120  * Usage threshold may not be appropriate for some memory pools.
121  * For example, a generational garbage collector, a common garbage collection
122  * algorithm used in many Java virtual machine implementations,
123  * manages two or more generations segregating objects by age.
124  * Most of the objects are allocated in
125  * the &lt;em&gt;youngest generation&lt;/em&gt; (say a nursery memory pool).
126  * The nursery memory pool is designed to be filled up and
127  * collecting the nursery memory pool will free most of its memory space
128  * since it is expected to contain mostly short-lived objects
129  * and mostly are unreachable at garbage collection time.
130  * In this case, it is more appropriate for the nursery memory pool
131  * not to support a usage threshold.  In addition,
132  * if the cost of an object allocation
133  * in one memory pool is very low (for example, just atomic pointer exchange),
134  * the Java virtual machine would probably not support the usage threshold
135  * for that memory pool since the overhead in comparing the usage with
136  * the threshold is higher than the cost of object allocation.
137  *
138  * &lt;p&gt;
139  * The memory usage of the system can be monitored using
140  * &lt;a href=&quot;#Polling&quot;&gt;polling&lt;/a&gt; or
141  * &lt;a href=&quot;#ThresholdNotification&quot;&gt;threshold notification&lt;/a&gt; mechanisms.
142  *
143  * &lt;ol type=&quot;a&quot;&gt;
144  *   &lt;li&gt;&lt;a id=&quot;Polling&quot;&gt;&lt;b&gt;Polling&lt;/b&gt;&lt;/a&gt;
145  *       &lt;p&gt;
146  *       An application can continuously monitor its memory usage
147  *       by calling either the {@link #getUsage} method for all
148  *       memory pools or the {@link #isUsageThresholdExceeded} method
149  *       for those memory pools that support a usage threshold.
150  *       Below is example code that has a thread dedicated for
151  *       task distribution and processing.  At every interval,
152  *       it will determine if it should receive and process new tasks based
153  *       on its memory usage.  If the memory usage exceeds its usage threshold,
154  *       it will redistribute all outstanding tasks to other VMs and
155  *       stop receiving new tasks until the memory usage returns
156  *       below its usage threshold.
157  *
158  *       &lt;pre&gt;
159  *       // Assume the usage threshold is supported for this pool.
160  *       // Set the threshold to myThreshold above which no new tasks
161  *       // should be taken.
162  *       pool.setUsageThreshold(myThreshold);
163  *       ....
164  *
165  *       boolean lowMemory = false;
166  *       while (true) {
167  *          if (pool.isUsageThresholdExceeded()) {
168  *              // potential low memory, so redistribute tasks to other VMs
169  *              lowMemory = true;
170  *              redistributeTasks();
171  *              // stop receiving new tasks
172  *              stopReceivingTasks();
173  *          } else {
174  *              if (lowMemory) {
175  *                  // resume receiving tasks
176  *                  lowMemory = false;
177  *                  resumeReceivingTasks();
178  *              }
179  *              // processing outstanding task
180  *              ...
181  *          }
182  *          // sleep for sometime
183  *          try {
184  *              Thread.sleep(sometime);
185  *          } catch (InterruptedException e) {
186  *              ...
187  *          }
188  *       }
189  *       &lt;/pre&gt;
190  *
191  * &lt;hr&gt;
192  *       The above example does not differentiate the case where
193  *       the memory usage has temporarily dropped below the usage threshold
194  *       from the case where the memory usage remains above the threshold
195  *       between two iterations.  The usage threshold count returned by
196  *       the {@link #getUsageThresholdCount} method
197  *       can be used to determine
198  *       if the memory usage has returned below the threshold
199  *       between two polls.
200  *       &lt;p&gt;
201  *       Below shows another example that takes some action if a
202  *       memory pool is under low memory and ignores the memory usage
203  *       changes during the action processing time.
204  *
205  *       &lt;pre&gt;
206  *       // Assume the usage threshold is supported for this pool.
207  *       // Set the threshold to myThreshold which determines if
208  *       // the application will take some action under low memory condition.
209  *       pool.setUsageThreshold(myThreshold);
210  *
211  *       int prevCrossingCount = 0;
212  *       while (true) {
213  *           // A busy loop to detect when the memory usage
214  *           // has exceeded the threshold.
215  *           while (!pool.isUsageThresholdExceeded() ||
216  *                  pool.getUsageThresholdCount() == prevCrossingCount) {
217  *               try {
218  *                   Thread.sleep(sometime)
219  *               } catch (InterruptException e) {
220  *                   ....
221  *               }
222  *           }
223  *
224  *           // Do some processing such as check for memory usage
225  *           // and issue a warning
226  *           ....
227  *
228  *           // Gets the current threshold count. The busy loop will then
229  *           // ignore any crossing of threshold happens during the processing.
230  *           prevCrossingCount = pool.getUsageThresholdCount();
231  *       }
232  *       &lt;/pre&gt;&lt;hr&gt;
233  *   &lt;/li&gt;
234  *   &lt;li&gt;&lt;a id=&quot;ThresholdNotification&quot;&gt;&lt;b&gt;Usage Threshold Notifications&lt;/b&gt;&lt;/a&gt;
235  *       &lt;p&gt;
236  *       Usage threshold notification will be emitted by {@link MemoryMXBean}.
237  *       When the Java virtual machine detects that the memory usage of
238  *       a memory pool has reached or exceeded the usage threshold
239  *       the virtual machine will trigger the {@code MemoryMXBean} to emit an
240  *       {@link MemoryNotificationInfo#MEMORY_THRESHOLD_EXCEEDED
241  *       usage threshold exceeded notification}.
242  *       Another usage threshold exceeded notification will not be
243  *       generated until the usage has fallen below the threshold and
244  *       then exceeded it again.
245  *       &lt;p&gt;
246  *       Below is an example code implementing the same logic as the
247  *       first example above but using the usage threshold notification
248  *       mechanism to detect low memory conditions instead of polling.
249  *       In this example code, upon receiving notification, the notification
250  *       listener notifies another thread to perform the actual action
251  *       such as to redistribute outstanding tasks, stop receiving tasks,
252  *       or resume receiving tasks.
253  *       The {@code handleNotification} method should be designed to
254  *       do a very minimal amount of work and return without delay to avoid
255  *       causing delay in delivering subsequent notifications.  Time-consuming
256  *       actions should be performed by a separate thread.
257  *       The notification listener may be invoked by multiple threads
258  *       concurrently; so the tasks performed by the listener
259  *       should be properly synchronized.
260  *
261  *       &lt;pre&gt;
262  *       class MyListener implements javax.management.NotificationListener {
263  *            public void handleNotification(Notification notification, Object handback)  {
264  *                String notifType = notification.getType();
265  *                if (notifType.equals(MemoryNotificationInfo.MEMORY_THRESHOLD_EXCEEDED)) {
266  *                    // potential low memory, notify another thread
267  *                    // to redistribute outstanding tasks to other VMs
268  *                    // and stop receiving new tasks.
269  *                    lowMemory = true;
270  *                    notifyAnotherThread(lowMemory);
271  *                }
272  *            }
273  *       }
274  *
275  *       // Register MyListener with MemoryMXBean
276  *       MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();
277  *       NotificationEmitter emitter = (NotificationEmitter) mbean;
278  *       MyListener listener = new MyListener();
279  *       emitter.addNotificationListener(listener, null, null);
280  *
281  *       // Assume this pool supports a usage threshold.
282  *       // Set the threshold to myThreshold above which no new tasks
283  *       // should be taken.
284  *       pool.setUsageThreshold(myThreshold);
285  *
286  *       // Usage threshold detection is enabled and notification will be
287  *       // handled by MyListener.  Continue for other processing.
288  *       ....
289  *
290  *       &lt;/pre&gt;
291  * &lt;hr&gt;
292  *       &lt;p&gt;
293  *       There is no guarantee about when the {@code MemoryMXBean} will emit
294  *       a threshold notification and when the notification will be delivered.
295  *       When a notification listener is invoked, the memory usage of
296  *       the memory pool may have crossed the usage threshold more
297  *       than once.
298  *       The {@link MemoryNotificationInfo#getCount} method returns the number
299  *       of times that the memory usage has crossed the usage threshold
300  *       at the point in time when the notification was constructed.
301  *       It can be compared with the current usage threshold count returned
302  *       by the {@link #getUsageThresholdCount} method to determine if
303  *       such situation has occurred.
304  *   &lt;/li&gt;
305  * &lt;/ol&gt;
306  *
307  * &lt;h3&gt;&lt;a id=&quot;CollectionThreshold&quot;&gt;4. Collection Usage Threshold&lt;/a&gt;&lt;/h3&gt;
308  *
309  * Collection usage threshold is a manageable attribute only applicable
310  * to some garbage-collected memory pools.
311  * After a Java virtual machine has expended effort in reclaiming memory
312  * space by recycling unused objects in a memory pool at garbage collection
313  * time, some number of bytes in the memory pools that are garbaged
314  * collected will still be in use.  The collection usage threshold
315  * allows a value to be set for this number of bytes such
316  * that if the threshold is exceeded,
317  * a {@link MemoryNotificationInfo#MEMORY_THRESHOLD_EXCEEDED
318  * collection usage threshold exceeded notification}
319  * will be emitted by the {@link MemoryMXBean}.
320  * In addition, the {@link #getCollectionUsageThresholdCount
321  * collection usage threshold count} will then be incremented.
322  *
323  * &lt;p&gt;
324  * The {@link MemoryPoolMXBean#isCollectionUsageThresholdSupported} method can
325  * be used to determine if this functionality is supported.
326  *
327  * &lt;p&gt;
328  * A Java virtual machine performs collection usage threshold checking
329  * on a memory pool basis.  This checking is enabled if the collection
330  * usage threshold is set to a positive value.
331  * If the collection usage threshold is set to zero, this checking
332  * is disabled on this memory pool.  Default value is zero.
333  * The Java virtual machine performs the collection usage threshold
334  * checking at garbage collection time.
335  *
336  * &lt;p&gt;
337  * Some garbage-collected memory pools may
338  * choose not to support the collection usage threshold.  For example,
339  * a memory pool is only managed by a continuous concurrent garbage
340  * collector.  Objects can be allocated in this memory pool by some thread
341  * while the unused objects are reclaimed by the concurrent garbage
342  * collector simultaneously.  Unless there is a well-defined
343  * garbage collection time which is the best appropriate time
344  * to check the memory usage, the collection usage threshold should not
345  * be supported.
346  *
347  * &lt;p&gt;
348  * The collection usage threshold is designed for monitoring the memory usage
349  * after the Java virtual machine has expended effort in reclaiming
350  * memory space.  The collection usage could also be monitored
351  * by the polling and threshold notification mechanism
352  * described above for the &lt;a href=&quot;#UsageThreshold&quot;&gt;usage threshold&lt;/a&gt;
353  * in a similar fashion.
354  *
355  * @see ManagementFactory#getPlatformMXBeans(Class)
356  * @see &lt;a href=&quot;../../../javax/management/package-summary.html&quot;&gt;
357  *      JMX Specification.&lt;/a&gt;
358  * @see &lt;a href=&quot;package-summary.html#examples&quot;&gt;
359  *      Ways to Access MXBeans&lt;/a&gt;
360  *
361  * @author  Mandy Chung
362  * @since   1.5
363  */
364 public interface MemoryPoolMXBean extends PlatformManagedObject {
365     /**
366      * Returns the name representing this memory pool.
367      *
368      * @return the name of this memory pool.
369      */
370     public String getName();
371 
372     /**
373      * Returns the type of this memory pool.
374      *
375      * &lt;p&gt;
376      * &lt;b&gt;MBeanServer access&lt;/b&gt;:&lt;br&gt;
377      * The mapped type of {@code MemoryType} is {@code String}
378      * and the value is the name of the {@code MemoryType}.
379      *
380      * @return the type of this memory pool.
381      */
382     public MemoryType getType();
383 
384     /**
385      * Returns an estimate of the memory usage of this memory pool.
386      * This method returns {@code null}
387      * if this memory pool is not valid (i.e. no longer exists).
388      *
389      * &lt;p&gt;
390      * This method requests the Java virtual machine to make
391      * a best-effort estimate of the current memory usage of this
392      * memory pool. For some memory pools, this method may be an
393      * expensive operation that requires some computation to determine
394      * the estimate.  An implementation should document when
395      * this is the case.
396      *
397      * &lt;p&gt;This method is designed for use in monitoring system
398      * memory usage and detecting low memory condition.
399      *
400      * &lt;p&gt;
401      * &lt;b&gt;MBeanServer access&lt;/b&gt;:&lt;br&gt;
402      * The mapped type of {@code MemoryUsage} is
403      * {@code CompositeData} with attributes as specified in
404      * {@link MemoryUsage#from MemoryUsage}.
405      *
406      * @return a {@link MemoryUsage} object; or {@code null} if
407      * this pool not valid.
408      */
409     public MemoryUsage getUsage();
410 
411     /**
412      * Returns the peak memory usage of this memory pool since the
413      * Java virtual machine was started or since the peak was reset.
414      * This method returns {@code null}
415      * if this memory pool is not valid (i.e. no longer exists).
416      *
417      * &lt;p&gt;
418      * &lt;b&gt;MBeanServer access&lt;/b&gt;:&lt;br&gt;
419      * The mapped type of {@code MemoryUsage} is
420      * {@code CompositeData} with attributes as specified in
421      * {@link MemoryUsage#from MemoryUsage}.
422      *
423      * @return a {@link MemoryUsage} object representing the peak
424      * memory usage; or {@code null} if this pool is not valid.
425      *
426      */
427     public MemoryUsage getPeakUsage();
428 
429     /**
430      * Resets the peak memory usage statistic of this memory pool
431      * to the current memory usage.
432      *
433      * @throws java.lang.SecurityException if a security manager
434      *         exists and the caller does not have
435      *         ManagementPermission(&quot;control&quot;).
436      */
437     public void resetPeakUsage();
438 
439     /**
440      * Tests if this memory pool is valid in the Java virtual
441      * machine.  A memory pool becomes invalid once the Java virtual
442      * machine removes it from the memory system.
443      *
444      * @return {@code true} if the memory pool is valid in the running
445      *              Java virtual machine;
446      *         {@code false} otherwise.
447      */
448     public boolean isValid();
449 
450     /**
451      * Returns the name of memory managers that manages this memory pool.
452      * Each memory pool will be managed by at least one memory manager.
453      *
454      * @return an array of {@code String} objects, each is the name of
455      * a memory manager managing this memory pool.
456      */
457     public String[] getMemoryManagerNames();
458 
459     /**
460      * Returns the usage threshold value of this memory pool in bytes.
461      * Each memory pool has a platform-dependent default threshold value.
462      * The current usage threshold can be changed via the
463      * {@link #setUsageThreshold setUsageThreshold} method.
464      *
465      * @return the usage threshold value of this memory pool in bytes.
466      *
467      * @throws UnsupportedOperationException if this memory pool
468      *         does not support a usage threshold.
469      *
470      * @see #isUsageThresholdSupported
471      */
472     public long getUsageThreshold();
473 
474     /**
475      * Sets the threshold of this memory pool to the given {@code threshold}
476      * value if this memory pool supports the usage threshold.
477      * The usage threshold crossing checking is enabled in this memory pool
478      * if the threshold is set to a positive value.
479      * The usage threshold crossing checking is disabled
480      * if it is set to zero.
481      *
482      * @param threshold the new threshold value in bytes. Must be non-negative.
483      *
484      * @throws IllegalArgumentException if {@code threshold} is negative
485      *         or greater than the maximum amount of memory for
486      *         this memory pool if defined.
487      *
488      * @throws UnsupportedOperationException if this memory pool
489      *         does not support a usage threshold.
490      *
491      * @throws java.lang.SecurityException if a security manager
492      *         exists and the caller does not have
493      *         ManagementPermission(&quot;control&quot;).
494      *
495      * @see #isUsageThresholdSupported
496      * @see &lt;a href=&quot;#UsageThreshold&quot;&gt;Usage threshold&lt;/a&gt;
497      */
498     public void setUsageThreshold(long threshold);
499 
500     /**
501      * Tests if the memory usage of this memory pool
502      * reaches or exceeds its usage threshold value.
503      *
504      * @return {@code true} if the memory usage of
505      * this memory pool reaches or exceeds the threshold value;
506      * {@code false} otherwise.
507      *
508      * @throws UnsupportedOperationException if this memory pool
509      *         does not support a usage threshold.
510      */
511     public boolean isUsageThresholdExceeded();
512 
513     /**
514      * Returns the number of times that the memory usage has crossed
515      * the usage threshold.
516      *
517      * @return the number of times that the memory usage
518      * has crossed its usage threshold value.
519      *
520      * @throws UnsupportedOperationException if this memory pool
521      * does not support a usage threshold.
522      */
523     public long getUsageThresholdCount();
524 
525     /**
526      * Tests if this memory pool supports usage threshold.
527      *
528      * @return {@code true} if this memory pool supports usage threshold;
529      * {@code false} otherwise.
530      */
531     public boolean isUsageThresholdSupported();
532 
533     /**
534      * Returns the collection usage threshold value of this memory pool
535      * in bytes.  The default value is zero. The collection usage
536      * threshold can be changed via the
537      * {@link #setCollectionUsageThreshold setCollectionUsageThreshold} method.
538      *
539      * @return the collection usage threshold of this memory pool in bytes.
540      *
541      * @throws UnsupportedOperationException if this memory pool
542      *         does not support a collection usage threshold.
543      *
544      * @see #isCollectionUsageThresholdSupported
545      */
546     public long getCollectionUsageThreshold();
547 
548     /**
549      * Sets the collection usage threshold of this memory pool to
550      * the given {@code threshold} value.
551      * When this threshold is set to positive, the Java virtual machine
552      * will check the memory usage at its best appropriate time after it has
553      * expended effort in recycling unused objects in this memory pool.
554      * &lt;p&gt;
555      * The collection usage threshold crossing checking is enabled
556      * in this memory pool if the threshold is set to a positive value.
557      * The collection usage threshold crossing checking is disabled
558      * if it is set to zero.
559      *
560      * @param threshold the new collection usage threshold value in bytes.
561      *              Must be non-negative.
562      *
563      * @throws IllegalArgumentException if {@code threshold} is negative
564      *         or greater than the maximum amount of memory for
565      *         this memory pool if defined.
566      *
567      * @throws UnsupportedOperationException if this memory pool
568      *         does not support a collection usage threshold.
569      *
570      * @throws java.lang.SecurityException if a security manager
571      *         exists and the caller does not have
572      *         ManagementPermission(&quot;control&quot;).
573      *
574      * @see #isCollectionUsageThresholdSupported
575      * @see &lt;a href=&quot;#CollectionThreshold&quot;&gt;Collection usage threshold&lt;/a&gt;
576      */
577     public void setCollectionUsageThreshold(long threshold);
578 
579     /**
580      * Tests if the memory usage of this memory pool after
581      * the most recent collection on which the Java virtual
582      * machine has expended effort has reached or
583      * exceeded its collection usage threshold.
584      * This method does not request the Java virtual
585      * machine to perform any garbage collection other than its normal
586      * automatic memory management.
587      *
588      * @return {@code true} if the memory usage of this memory pool
589      * reaches or exceeds the collection usage threshold value
590      * in the most recent collection;
591      * {@code false} otherwise.
592      *
593      * @throws UnsupportedOperationException if this memory pool
594      *         does not support a usage threshold.
595      */
596     public boolean isCollectionUsageThresholdExceeded();
597 
598     /**
599      * Returns the number of times that the Java virtual machine
600      * has detected that the memory usage has reached or
601      * exceeded the collection usage threshold.
602      *
603      * @return the number of times that the memory
604      * usage has reached or exceeded the collection usage threshold.
605      *
606      * @throws UnsupportedOperationException if this memory pool
607      *         does not support a collection usage threshold.
608      *
609      * @see #isCollectionUsageThresholdSupported
610      */
611     public long getCollectionUsageThresholdCount();
612 
613     /**
614      * Returns the memory usage after the Java virtual machine
615      * most recently expended effort in recycling unused objects
616      * in this memory pool.
617      * This method does not request the Java virtual
618      * machine to perform any garbage collection other than its normal
619      * automatic memory management.
620      * This method returns {@code null} if the Java virtual
621      * machine does not support this method.
622      *
623      * &lt;p&gt;
624      * &lt;b&gt;MBeanServer access&lt;/b&gt;:&lt;br&gt;
625      * The mapped type of {@code MemoryUsage} is
626      * {@code CompositeData} with attributes as specified in
627      * {@link MemoryUsage#from MemoryUsage}.
628      *
629      * @return a {@link MemoryUsage} representing the memory usage of
630      * this memory pool after the Java virtual machine most recently
631      * expended effort in recycling unused objects;
632      * {@code null} if this method is not supported.
633      */
634     public MemoryUsage getCollectionUsage();
635 
636     /**
637      * Tests if this memory pool supports a collection usage threshold.
638      *
639      * @return {@code true} if this memory pool supports the
640      * collection usage threshold; {@code false} otherwise.
641      */
642     public boolean isCollectionUsageThresholdSupported();
643 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
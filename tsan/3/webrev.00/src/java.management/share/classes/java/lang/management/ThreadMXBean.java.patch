diff a/src/java.management/share/classes/java/lang/management/ThreadMXBean.java b/src/java.management/share/classes/java/lang/management/ThreadMXBean.java
--- a/src/java.management/share/classes/java/lang/management/ThreadMXBean.java
+++ b/src/java.management/share/classes/java/lang/management/ThreadMXBean.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -47,20 +47,20 @@
  * </blockquote>
  *
  * It can be obtained by calling the
  * {@link PlatformManagedObject#getObjectName} method.
  *
- * <h3>Thread ID</h3>
+ * <h2>Thread ID</h2>
  * Thread ID is a positive long value returned by calling the
  * {@link java.lang.Thread#getId} method for a thread.
  * The thread ID is unique during its lifetime.  When a thread
  * is terminated, this thread ID may be reused.
  *
  * <p> Some methods in this interface take a thread ID or an array
  * of thread IDs as the input parameter and return per-thread information.
  *
- * <h3>Thread CPU time</h3>
+ * <h2>Thread CPU time</h2>
  * A Java virtual machine implementation may support measuring
  * the CPU time for the current thread, for any thread, or for no threads.
  *
  * <p>
  * The {@link #isThreadCpuTimeSupported} method can be used to determine
@@ -81,11 +81,11 @@
  * methods can be used to test if CPU time measurement is enabled
  * and to enable/disable this support respectively.
  * Enabling thread CPU measurement could be expensive in some
  * Java virtual machine implementations.
  *
- * <h3>Thread Contention Monitoring</h3>
+ * <h2>Thread Contention Monitoring</h2>
  * Some Java virtual machines may support thread contention monitoring.
  * When thread contention monitoring is enabled, the accumulated elapsed
  * time that the thread has blocked for synchronization or waited for
  * notification will be collected and returned in the
  * <a href="ThreadInfo.html#SyncStats">{@code ThreadInfo}</a> object.
@@ -94,11 +94,11 @@
  * determine if a Java virtual machine supports thread contention monitoring.
  * The thread contention monitoring is disabled by default.  The
  * {@link #setThreadContentionMonitoringEnabled} method can be used to enable
  * thread contention monitoring.
  *
- * <h3>Synchronization Information and Deadlock Detection</h3>
+ * <h2>Synchronization Information and Deadlock Detection</h2>
  * Some Java virtual machines may support monitoring of
  * {@linkplain #isObjectMonitorUsageSupported object monitor usage} and
  * {@linkplain #isSynchronizerUsageSupported ownable synchronizer usage}.
  * The {@link #getThreadInfo(long[], boolean, boolean)} and
  * {@link #dumpAllThreads} methods can be used to obtain the thread stack trace
@@ -158,11 +158,11 @@
      * Some threads included in the returned array
      * may have been terminated when this method returns.
      *
      * @return an array of {@code long}, each is a thread ID.
      *
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("monitor").
      */
     public long[] getAllThreadIds();
 
@@ -197,11 +197,11 @@
      * with no stack trace, no locked monitor and no synchronizer info;
      * {@code null} if the thread of the given ID is not alive or
      * it does not exist.
      *
      * @throws IllegalArgumentException if {@code id <= 0}.
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("monitor").
      */
     public ThreadInfo getThreadInfo(long id);
 
@@ -235,11 +235,11 @@
      * element of the input array of IDs
      * with no stack trace, no locked monitor and no synchronizer info.
      *
      * @throws IllegalArgumentException if any element in the input array
      *         {@code ids} is {@code <= 0}.
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("monitor").
      */
     public ThreadInfo[] getThreadInfo(long[] ids);
 
@@ -282,11 +282,11 @@
      * {@code null} if the thread of the given ID is not alive or
      * it does not exist.
      *
      * @throws IllegalArgumentException if {@code id <= 0}.
      * @throws IllegalArgumentException if {@code maxDepth is negative}.
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("monitor").
      *
      */
     public ThreadInfo getThreadInfo(long id, int maxDepth);
@@ -335,11 +335,11 @@
      * synchronizer info.
      *
      * @throws IllegalArgumentException if {@code maxDepth is negative}.
      * @throws IllegalArgumentException if any element in the input array
      *      {@code ids} is {@code <= 0}.
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("monitor").
      *
      */
     public ThreadInfo[] getThreadInfo(long[] ids, int maxDepth);
@@ -358,11 +358,11 @@
      * Tests if thread contention monitoring is enabled.
      *
      * @return {@code true} if thread contention monitoring is enabled;
      *         {@code false} otherwise.
      *
-     * @throws java.lang.UnsupportedOperationException if the Java virtual
+     * @throws UnsupportedOperationException if the Java virtual
      * machine does not support thread contention monitoring.
      *
      * @see #isThreadContentionMonitoringSupported
      */
     public boolean isThreadContentionMonitoringEnabled();
@@ -372,14 +372,14 @@
      * Thread contention monitoring is disabled by default.
      *
      * @param enable {@code true} to enable;
      *               {@code false} to disable.
      *
-     * @throws java.lang.UnsupportedOperationException if the Java
+     * @throws UnsupportedOperationException if the Java
      * virtual machine does not support thread contention monitoring.
      *
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("control").
      *
      * @see #isThreadContentionMonitoringSupported
      */
@@ -392,20 +392,20 @@
      * If the implementation distinguishes between user mode time and system
      * mode time, the returned CPU time is the amount of time that
      * the current thread has executed in user mode or system mode.
      *
      * <p>
-     * This is a convenient method for local management use and is
+     * This is a convenience method for local management use and is
      * equivalent to calling:
      * <blockquote><pre>
      *   {@link #getThreadCpuTime getThreadCpuTime}(Thread.currentThread().getId());
      * </pre></blockquote>
      *
      * @return the total CPU time for the current thread if CPU time
      * measurement is enabled; {@code -1} otherwise.
      *
-     * @throws java.lang.UnsupportedOperationException if the Java
+     * @throws UnsupportedOperationException if the Java
      * virtual machine does not support CPU time measurement for
      * the current thread.
      *
      * @see #getCurrentThreadUserTime
      * @see #isCurrentThreadCpuTimeSupported
@@ -419,20 +419,20 @@
      * in user mode in nanoseconds.
      * The returned value is of nanoseconds precision but
      * not necessarily nanoseconds accuracy.
      *
      * <p>
-     * This is a convenient method for local management use and is
+     * This is a convenience method for local management use and is
      * equivalent to calling:
      * <blockquote><pre>
      *   {@link #getThreadUserTime getThreadUserTime}(Thread.currentThread().getId());
      * </pre></blockquote>
      *
      * @return the user-level CPU time for the current thread if CPU time
      * measurement is enabled; {@code -1} otherwise.
      *
-     * @throws java.lang.UnsupportedOperationException if the Java
+     * @throws UnsupportedOperationException if the Java
      * virtual machine does not support CPU time measurement for
      * the current thread.
      *
      * @see #getCurrentThreadCpuTime
      * @see #isCurrentThreadCpuTimeSupported
@@ -465,11 +465,11 @@
      * if the thread of the specified ID exists, the thread is alive,
      * and CPU time measurement is enabled;
      * {@code -1} otherwise.
      *
      * @throws IllegalArgumentException if {@code id <= 0}.
-     * @throws java.lang.UnsupportedOperationException if the Java
+     * @throws UnsupportedOperationException if the Java
      * virtual machine does not support CPU time measurement for
      * other threads.
      *
      * @see #getThreadUserTime
      * @see #isThreadCpuTimeSupported
@@ -500,11 +500,11 @@
      * if the thread of the specified ID exists, the thread is alive,
      * and CPU time measurement is enabled;
      * {@code -1} otherwise.
      *
      * @throws IllegalArgumentException if {@code id <= 0}.
-     * @throws java.lang.UnsupportedOperationException if the Java
+     * @throws UnsupportedOperationException if the Java
      * virtual machine does not support CPU time measurement for
      * other threads.
      *
      * @see #getThreadCpuTime
      * @see #isThreadCpuTimeSupported
@@ -546,11 +546,11 @@
      * Tests if thread CPU time measurement is enabled.
      *
      * @return {@code true} if thread CPU time measurement is enabled;
      *         {@code false} otherwise.
      *
-     * @throws java.lang.UnsupportedOperationException if the Java virtual
+     * @throws UnsupportedOperationException if the Java virtual
      * machine does not support CPU time measurement for other threads
      * nor for the current thread.
      *
      * @see #isThreadCpuTimeSupported
      * @see #isCurrentThreadCpuTimeSupported
@@ -562,15 +562,15 @@
      * is platform dependent.
      *
      * @param enable {@code true} to enable;
      *               {@code false} to disable.
      *
-     * @throws java.lang.UnsupportedOperationException if the Java
+     * @throws UnsupportedOperationException if the Java
      * virtual machine does not support CPU time measurement for
      * any threads nor for the current thread.
      *
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("control").
      *
      * @see #isThreadCpuTimeSupported
      * @see #isCurrentThreadCpuTimeSupported
@@ -602,11 +602,11 @@
      * should be used.
      *
      * @return an array of IDs of the threads that are monitor
      * deadlocked, if any; {@code null} otherwise.
      *
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("monitor").
      *
      * @see #findDeadlockedThreads
      */
@@ -614,11 +614,11 @@
 
     /**
      * Resets the peak thread count to the current number of
      * live threads.
      *
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("control").
      *
      * @see #getPeakThreadCount
      * @see #getThreadCount
@@ -640,14 +640,14 @@
      *
      * @return an array of IDs of the threads that are
      * deadlocked waiting for object monitors or ownable synchronizers, if any;
      * {@code null} otherwise.
      *
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("monitor").
-     * @throws java.lang.UnsupportedOperationException if the Java virtual
+     * @throws UnsupportedOperationException if the Java virtual
      * machine does not support monitoring of ownable synchronizer usage.
      *
      * @see #isSynchronizerUsageSupported
      * @see #findMonitorDeadlockedThreads
      * @since 1.6
@@ -702,14 +702,14 @@
      *
      * @return an array of the {@link ThreadInfo} objects, each containing
      * information about a thread whose ID is in the corresponding
      * element of the input array of IDs.
      *
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("monitor").
-     * @throws java.lang.UnsupportedOperationException
+     * @throws UnsupportedOperationException
      *         <ul>
      *           <li>if {@code lockedMonitors} is {@code true} but
      *               the Java virtual machine does not support monitoring
      *               of {@linkplain #isObjectMonitorUsageSupported
      *               object monitor usage}; or</li>
@@ -792,14 +792,14 @@
      * @return an array of the {@link ThreadInfo} objects, each containing
      * information about a thread whose ID is in the corresponding
      * element of the input array of IDs.
      *
      * @throws IllegalArgumentException if {@code maxDepth} is negative.
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("monitor").
-     * @throws java.lang.UnsupportedOperationException
+     * @throws UnsupportedOperationException
      *         <ul>
      *           <li>if {@code lockedMonitors} is {@code true} but
      *               the Java virtual machine does not support monitoring
      *               of {@linkplain #isObjectMonitorUsageSupported
      *               object monitor usage}; or</li>
@@ -833,14 +833,14 @@
      * @param  lockedSynchronizers if {@code true}, dump all locked
      *             ownable synchronizers.
      *
      * @return an array of {@link ThreadInfo} for all live threads.
      *
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("monitor").
-     * @throws java.lang.UnsupportedOperationException
+     * @throws UnsupportedOperationException
      *         <ul>
      *           <li>if {@code lockedMonitors} is {@code true} but
      *               the Java virtual machine does not support monitoring
      *               of {@linkplain #isObjectMonitorUsageSupported
      *               object monitor usage}; or</li>
@@ -882,14 +882,14 @@
      * {@link StackTraceElement} to be retrieved from the stack trace.
      *
      * @return an array of {@link ThreadInfo} for all live threads.
      *
      * @throws IllegalArgumentException if {@code maxDepth} is negative.
-     * @throws java.lang.SecurityException if a security manager
+     * @throws SecurityException if a security manager
      *         exists and the caller does not have
      *         ManagementPermission("monitor").
-     * @throws java.lang.UnsupportedOperationException
+     * @throws UnsupportedOperationException
      *         <ul>
      *           <li>if {@code lockedMonitors} is {@code true} but
      *               the Java virtual machine does not support monitoring
      *               of {@linkplain #isObjectMonitorUsageSupported
      *               object monitor usage}; or</li>

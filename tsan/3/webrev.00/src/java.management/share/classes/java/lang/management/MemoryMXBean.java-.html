<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.management/share/classes/java/lang/management/MemoryMXBean.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.management;
 27 
 28 import javax.management.openmbean.CompositeData;
 29 
 30 /**
 31  * The management interface for the memory system of
 32  * the Java virtual machine.
 33  *
 34  * &lt;p&gt; A Java virtual machine has a single instance of the implementation
 35  * class of this interface.  This instance implementing this interface is
 36  * an &lt;a href=&quot;ManagementFactory.html#MXBean&quot;&gt;MXBean&lt;/a&gt;
 37  * that can be obtained by calling
 38  * the {@link ManagementFactory#getMemoryMXBean} method or
 39  * from the {@link ManagementFactory#getPlatformMBeanServer
 40  * platform MBeanServer} method.
 41  *
 42  * &lt;p&gt;The {@code ObjectName} for uniquely identifying the MXBean for
 43  * the memory system within an MBeanServer is:
 44  * &lt;blockquote&gt;
 45  *    {@link ManagementFactory#MEMORY_MXBEAN_NAME
 46  *           java.lang:type=Memory}
 47  * &lt;/blockquote&gt;
 48  *
 49  * It can be obtained by calling the
 50  * {@link PlatformManagedObject#getObjectName} method.
 51  *
 52  * &lt;h3&gt; Memory &lt;/h3&gt;
 53  * The memory system of the Java virtual machine manages
 54  * the following kinds of memory:
 55  *
 56  * &lt;h3&gt; 1. Heap &lt;/h3&gt;
 57  * The Java virtual machine has a &lt;i&gt;heap&lt;/i&gt; that is the runtime
 58  * data area from which memory for all class instances and arrays
 59  * are allocated.  It is created at the Java virtual machine start-up.
 60  * Heap memory for objects is reclaimed by an automatic memory management
 61  * system which is known as a &lt;i&gt;garbage collector&lt;/i&gt;.
 62  *
 63  * &lt;p&gt;The heap may be of a fixed size or may be expanded and shrunk.
 64  * The memory for the heap does not need to be contiguous.
 65  *
 66  * &lt;h3&gt; 2. Non-Heap Memory&lt;/h3&gt;
 67  * The Java virtual machine manages memory other than the heap
 68  * (referred as &lt;i&gt;non-heap memory&lt;/i&gt;).
 69  *
 70  * &lt;p&gt; The Java virtual machine has a &lt;i&gt;method area&lt;/i&gt; that is shared
 71  * among all threads.
 72  * The method area belongs to non-heap memory.  It stores per-class structures
 73  * such as a runtime constant pool, field and method data, and the code for
 74  * methods and constructors.  It is created at the Java virtual machine
 75  * start-up.
 76  *
 77  * &lt;p&gt; The method area is logically part of the heap but a Java virtual
 78  * machine implementation may choose not to either garbage collect
 79  * or compact it.  Similar to the heap, the method area may be of a
 80  * fixed size or may be expanded and shrunk.  The memory for the
 81  * method area does not need to be contiguous.
 82  *
 83  * &lt;p&gt;In addition to the method area, a Java virtual machine
 84  * implementation may require memory for internal processing or
 85  * optimization which also belongs to non-heap memory.
 86  * For example, the JIT compiler requires memory for storing the native
 87  * machine code translated from the Java virtual machine code for
 88  * high performance.
 89  *
 90  * &lt;h3&gt;Memory Pools and Memory Managers&lt;/h3&gt;
 91  * {@link MemoryPoolMXBean Memory pools} and
 92  * {@link MemoryManagerMXBean memory managers} are the abstract entities
 93  * that monitor and manage the memory system
 94  * of the Java virtual machine.
 95  *
 96  * &lt;p&gt;A memory pool represents a memory area that the Java virtual machine
 97  * manages.  The Java virtual machine has at least one memory pool
 98  * and it may create or remove memory pools during execution.
 99  * A memory pool can belong to either the heap or the non-heap memory.
100  *
101  * &lt;p&gt;A memory manager is responsible for managing one or more memory pools.
102  * The garbage collector is one type of memory manager responsible
103  * for reclaiming memory occupied by unreachable objects.  A Java virtual
104  * machine may have one or more memory managers.   It may
105  * add or remove memory managers during execution.
106  * A memory pool can be managed by more than one memory manager.
107  *
108  * &lt;h3&gt;Memory Usage Monitoring&lt;/h3&gt;
109  *
110  * Memory usage is a very important monitoring attribute for the memory system.
111  * The memory usage, for example, could indicate:
112  * &lt;ul&gt;
113  *   &lt;li&gt;the memory usage of an application,&lt;/li&gt;
114  *   &lt;li&gt;the workload being imposed on the automatic memory management system,&lt;/li&gt;
115  *   &lt;li&gt;potential memory leakage.&lt;/li&gt;
116  * &lt;/ul&gt;
117  *
118  * &lt;p&gt;
119  * The memory usage can be monitored in three ways:
120  * &lt;ul&gt;
121  *   &lt;li&gt;Polling&lt;/li&gt;
122  *   &lt;li&gt;Usage Threshold Notification&lt;/li&gt;
123  *   &lt;li&gt;Collection Usage Threshold Notification&lt;/li&gt;
124  * &lt;/ul&gt;
125  *
126  * Details are specified in the {@link MemoryPoolMXBean} interface.
127  *
128  * &lt;p&gt;The memory usage monitoring mechanism is intended for load-balancing
129  * or workload distribution use.  For example, an application would stop
130  * receiving any new workload when its memory usage exceeds a
131  * certain threshold. It is not intended for an application to detect
132  * and recover from a low memory condition.
133  *
134  * &lt;h3&gt;Notifications&lt;/h3&gt;
135  *
136  * &lt;p&gt;This {@code MemoryMXBean} is a
137  * {@link javax.management.NotificationEmitter NotificationEmitter}
138  * that emits two types of memory {@link javax.management.Notification
139  * notifications} if any one of the memory pools
140  * supports a &lt;a href=&quot;MemoryPoolMXBean.html#UsageThreshold&quot;&gt;usage threshold&lt;/a&gt;
141  * or a &lt;a href=&quot;MemoryPoolMXBean.html#CollectionThreshold&quot;&gt;collection usage
142  * threshold&lt;/a&gt; which can be determined by calling the
143  * {@link MemoryPoolMXBean#isUsageThresholdSupported} and
144  * {@link MemoryPoolMXBean#isCollectionUsageThresholdSupported} methods.
145  * &lt;ul&gt;
146  *   &lt;li&gt;{@link MemoryNotificationInfo#MEMORY_THRESHOLD_EXCEEDED
147  *       usage threshold exceeded notification} - for notifying that
148  *       the memory usage of a memory pool is increased and has reached
149  *       or exceeded its
150  *       &lt;a href=&quot;MemoryPoolMXBean.html#UsageThreshold&quot;&gt; usage threshold&lt;/a&gt; value.
151  *       &lt;/li&gt;
152  *   &lt;li&gt;{@link MemoryNotificationInfo#MEMORY_COLLECTION_THRESHOLD_EXCEEDED
153  *       collection usage threshold exceeded notification} - for notifying that
154  *       the memory usage of a memory pool is greater than or equal to its
155  *       &lt;a href=&quot;MemoryPoolMXBean.html#CollectionThreshold&quot;&gt;
156  *       collection usage threshold&lt;/a&gt; after the Java virtual machine
157  *       has expended effort in recycling unused objects in that
158  *       memory pool.&lt;/li&gt;
159  * &lt;/ul&gt;
160  *
161  * &lt;p&gt;
162  * The notification emitted is a {@link javax.management.Notification}
163  * instance whose {@link javax.management.Notification#setUserData
164  * user data} is set to a {@link CompositeData CompositeData}
165  * that represents a {@link MemoryNotificationInfo} object
166  * containing information about the memory pool when the notification
167  * was constructed. The {@code CompositeData} contains the attributes
168  * as described in {@link MemoryNotificationInfo#from
169  * MemoryNotificationInfo}.
170  *
171  * &lt;hr&gt;
172  * &lt;h3&gt;NotificationEmitter&lt;/h3&gt;
173  * The {@code MemoryMXBean} object returned by
174  * {@link ManagementFactory#getMemoryMXBean} implements
175  * the {@link javax.management.NotificationEmitter NotificationEmitter}
176  * interface that allows a listener to be registered within the
177  * {@code MemoryMXBean} as a notification listener.
178  *
179  * Below is an example code that registers a {@code MyListener} to handle
180  * notification emitted by the {@code MemoryMXBean}.
181  *
182  * &lt;blockquote&gt;&lt;pre&gt;
183  * class MyListener implements javax.management.NotificationListener {
184  *     public void handleNotification(Notification notif, Object handback) {
185  *         // handle notification
186  *         ....
187  *     }
188  * }
189  *
190  * MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();
191  * NotificationEmitter emitter = (NotificationEmitter) mbean;
192  * MyListener listener = new MyListener();
193  * emitter.addNotificationListener(listener, null, null);
194  * &lt;/pre&gt;&lt;/blockquote&gt;
195  *
196  * @see ManagementFactory#getPlatformMXBeans(Class)
197  * @see &lt;a href=&quot;../../../javax/management/package-summary.html&quot;&gt;
198  *      JMX Specification.&lt;/a&gt;
199  * @see &lt;a href=&quot;package-summary.html#examples&quot;&gt;
200  *      Ways to Access MXBeans&lt;/a&gt;
201  *
202  * @author  Mandy Chung
203  * @since   1.5
204  */
205 public interface MemoryMXBean extends PlatformManagedObject {
206     /**
207      * Returns the approximate number of objects for which
208      * finalization is pending.
209      *
210      * @return the approximate number objects for which finalization
211      * is pending.
212      */
213     public int getObjectPendingFinalizationCount();
214 
215     /**
216      * Returns the current memory usage of the heap that
217      * is used for object allocation.  The heap consists
218      * of one or more memory pools.  The {@code used}
219      * and {@code committed} size of the returned memory
220      * usage is the sum of those values of all heap memory pools
221      * whereas the {@code init} and {@code max} size of the
222      * returned memory usage represents the setting of the heap
223      * memory which may not be the sum of those of all heap
224      * memory pools.
225      * &lt;p&gt;
226      * The amount of used memory in the returned memory usage
227      * is the amount of memory occupied by both live objects
228      * and garbage objects that have not been collected, if any.
229      *
230      * &lt;p&gt;
231      * &lt;b&gt;MBeanServer access&lt;/b&gt;:&lt;br&gt;
232      * The mapped type of {@code MemoryUsage} is
233      * {@code CompositeData} with attributes as specified in
234      * {@link MemoryUsage#from MemoryUsage}.
235      *
236      * @return a {@link MemoryUsage} object representing
237      * the heap memory usage.
238      */
239     public MemoryUsage getHeapMemoryUsage();
240 
241     /**
242      * Returns the current memory usage of non-heap memory that
243      * is used by the Java virtual machine.
244      * The non-heap memory consists of one or more memory pools.
245      * The {@code used} and {@code committed} size of the
246      * returned memory usage is the sum of those values of
247      * all non-heap memory pools whereas the {@code init}
248      * and {@code max} size of the returned memory usage
249      * represents the setting of the non-heap
250      * memory which may not be the sum of those of all non-heap
251      * memory pools.
252      *
253      * &lt;p&gt;
254      * &lt;b&gt;MBeanServer access&lt;/b&gt;:&lt;br&gt;
255      * The mapped type of {@code MemoryUsage} is
256      * {@code CompositeData} with attributes as specified in
257      * {@link MemoryUsage#from MemoryUsage}.
258      *
259      * @return a {@link MemoryUsage} object representing
260      * the non-heap memory usage.
261      */
262     public MemoryUsage getNonHeapMemoryUsage();
263 
264     /**
265      * Tests if verbose output for the memory system is enabled.
266      *
267      * @return {@code true} if verbose output for the memory
268      * system is enabled; {@code false} otherwise.
269      */
270     public boolean isVerbose();
271 
272     /**
273      * Enables or disables verbose output for the memory
274      * system.  The verbose output information and the output stream
275      * to which the verbose information is emitted are implementation
276      * dependent.  Typically, a Java virtual machine implementation
277      * prints a message whenever it frees memory at garbage collection.
278      *
279      * &lt;p&gt;
280      * Each invocation of this method enables or disables verbose
281      * output globally.
282      *
283      * @param value {@code true} to enable verbose output;
284      *              {@code false} to disable.
285      *
286      * @exception  java.lang.SecurityException if a security manager
287      *             exists and the caller does not have
288      *             ManagementPermission(&quot;control&quot;).
289      */
290     public void setVerbose(boolean value);
291 
292     /**
293      * Runs the garbage collector.
294      * The call &lt;code&gt;gc()&lt;/code&gt; is effectively equivalent to the
295      * call:
296      * &lt;blockquote&gt;&lt;pre&gt;
297      * System.gc()
298      * &lt;/pre&gt;&lt;/blockquote&gt;
299      *
300      * @see     java.lang.System#gc()
301      */
302     public void gc();
303 
304 }
    </pre>
  </body>
</html>
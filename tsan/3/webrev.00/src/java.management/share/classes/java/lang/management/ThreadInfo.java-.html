<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.management/share/classes/java/lang/management/ThreadInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.management;
 27 
 28 import javax.management.openmbean.ArrayType;
 29 import javax.management.openmbean.CompositeData;
 30 import sun.management.ManagementFactoryHelper;
 31 import sun.management.ThreadInfoCompositeData;
 32 import static java.lang.Thread.State.*;
 33 
 34 /**
 35  * Thread information. {@code ThreadInfo} contains the information
 36  * about a thread including:
 37  * &lt;h3&gt;General thread information&lt;/h3&gt;
 38  * &lt;ul&gt;
 39  *   &lt;li&gt;Thread ID.&lt;/li&gt;
 40  *   &lt;li&gt;Name of the thread.&lt;/li&gt;
 41  *   &lt;li&gt;Whether a thread is a daemon thread&lt;/li&gt;
 42  * &lt;/ul&gt;
 43  *
 44  * &lt;h3&gt;Execution information&lt;/h3&gt;
 45  * &lt;ul&gt;
 46  *   &lt;li&gt;Thread state.&lt;/li&gt;
 47  *   &lt;li&gt;The object upon which the thread is blocked due to:
 48  *       &lt;ul&gt;
 49  *       &lt;li&gt;waiting to enter a synchronization block/method, or&lt;/li&gt;
 50  *       &lt;li&gt;waiting to be notified in a {@link Object#wait Object.wait} method,
 51  *           or&lt;/li&gt;
 52  *       &lt;li&gt;parking due to a {@link java.util.concurrent.locks.LockSupport#park
 53  *           LockSupport.park} call.&lt;/li&gt;
 54  *       &lt;/ul&gt;
 55  *   &lt;/li&gt;
 56  *   &lt;li&gt;The ID of the thread that owns the object
 57  *       that the thread is blocked.&lt;/li&gt;
 58  *   &lt;li&gt;Stack trace of the thread.&lt;/li&gt;
 59  *   &lt;li&gt;List of object monitors locked by the thread.&lt;/li&gt;
 60  *   &lt;li&gt;List of &lt;a href=&quot;LockInfo.html#OwnableSynchronizer&quot;&gt;
 61  *       ownable synchronizers&lt;/a&gt; locked by the thread.&lt;/li&gt;
 62  *   &lt;li&gt;Thread priority&lt;/li&gt;
 63  * &lt;/ul&gt;
 64  *
 65  * &lt;h4&gt;&lt;a id=&quot;SyncStats&quot;&gt;Synchronization Statistics&lt;/a&gt;&lt;/h4&gt;
 66  * &lt;ul&gt;
 67  *   &lt;li&gt;The number of times that the thread has blocked for
 68  *       synchronization or waited for notification.&lt;/li&gt;
 69  *   &lt;li&gt;The accumulated elapsed time that the thread has blocked
 70  *       for synchronization or waited for notification
 71  *       since {@link ThreadMXBean#setThreadContentionMonitoringEnabled
 72  *       thread contention monitoring}
 73  *       was enabled. Some Java virtual machine implementation
 74  *       may not support this.  The
 75  *       {@link ThreadMXBean#isThreadContentionMonitoringSupported()}
 76  *       method can be used to determine if a Java virtual machine
 77  *       supports this.&lt;/li&gt;
 78  * &lt;/ul&gt;
 79  *
 80  * &lt;p&gt;This thread information class is designed for use in monitoring of
 81  * the system, not for synchronization control.
 82  *
 83  * &lt;h4&gt;MXBean Mapping&lt;/h4&gt;
 84  * {@code ThreadInfo} is mapped to a {@link CompositeData CompositeData}
 85  * with attributes as specified in
 86  * the {@link #from from} method.
 87  *
 88  * @see ThreadMXBean#getThreadInfo
 89  * @see ThreadMXBean#dumpAllThreads
 90  *
 91  * @author  Mandy Chung
 92  * @since   1.5
 93  */
 94 
 95 public class ThreadInfo {
 96     private String       threadName;
 97     private long         threadId;
 98     private long         blockedTime;
 99     private long         blockedCount;
100     private long         waitedTime;
101     private long         waitedCount;
102     private LockInfo     lock;
103     private String       lockName;
104     private long         lockOwnerId;
105     private String       lockOwnerName;
106     private boolean      daemon;
107     private boolean      inNative;
108     private boolean      suspended;
109     private Thread.State threadState;
110     private int          priority;
111     private StackTraceElement[] stackTrace;
112     private MonitorInfo[]       lockedMonitors;
113     private LockInfo[]          lockedSynchronizers;
114     private static MonitorInfo[] EMPTY_MONITORS = new MonitorInfo[0];
115     private static LockInfo[] EMPTY_SYNCS = new LockInfo[0];
116 
117     /**
118      * Constructor of ThreadInfo created by the JVM
119      *
120      * @param t             Thread
121      * @param state         Thread state
122      * @param lockObj       Object on which the thread is blocked
123      * @param lockOwner     the thread holding the lock
124      * @param blockedCount  Number of times blocked to enter a lock
125      * @param blockedTime   Approx time blocked to enter a lock
126      * @param waitedCount   Number of times waited on a lock
127      * @param waitedTime    Approx time waited on a lock
128      * @param stackTrace    Thread stack trace
129      */
130     private ThreadInfo(Thread t, int state, Object lockObj, Thread lockOwner,
131                        long blockedCount, long blockedTime,
132                        long waitedCount, long waitedTime,
133                        StackTraceElement[] stackTrace) {
134         initialize(t, state, lockObj, lockOwner,
135                    blockedCount, blockedTime,
136                    waitedCount, waitedTime, stackTrace,
137                    EMPTY_MONITORS, EMPTY_SYNCS);
138     }
139 
140     /**
141      * Constructor of ThreadInfo created by the JVM
142      * for {@link ThreadMXBean#getThreadInfo(long[],boolean,boolean)}
143      * and {@link ThreadMXBean#dumpAllThreads}
144      *
145      * @param t             Thread
146      * @param state         Thread state
147      * @param lockObj       Object on which the thread is blocked
148      * @param lockOwner     the thread holding the lock
149      * @param blockedCount  Number of times blocked to enter a lock
150      * @param blockedTime   Approx time blocked to enter a lock
151      * @param waitedCount   Number of times waited on a lock
152      * @param waitedTime    Approx time waited on a lock
153      * @param stackTrace    Thread stack trace
154      * @param monitors      List of locked monitors
155      * @param stackDepths   List of stack depths
156      * @param synchronizers List of locked synchronizers
157      */
158     private ThreadInfo(Thread t, int state, Object lockObj, Thread lockOwner,
159                        long blockedCount, long blockedTime,
160                        long waitedCount, long waitedTime,
161                        StackTraceElement[] stackTrace,
162                        Object[] monitors,
163                        int[] stackDepths,
164                        Object[] synchronizers) {
165         int numMonitors = (monitors == null ? 0 : monitors.length);
166         MonitorInfo[] lockedMonitors;
167         if (numMonitors == 0) {
168             lockedMonitors = EMPTY_MONITORS;
169         } else {
170             lockedMonitors = new MonitorInfo[numMonitors];
171             for (int i = 0; i &lt; numMonitors; i++) {
172                 Object lock = monitors[i];
173                 String className = lock.getClass().getName();
174                 int identityHashCode = System.identityHashCode(lock);
175                 int depth = stackDepths[i];
176                 StackTraceElement ste = (depth &gt;= 0 ? stackTrace[depth]
177                                                     : null);
178                 lockedMonitors[i] = new MonitorInfo(className,
179                                                     identityHashCode,
180                                                     depth,
181                                                     ste);
182             }
183         }
184 
185         int numSyncs = (synchronizers == null ? 0 : synchronizers.length);
186         LockInfo[] lockedSynchronizers;
187         if (numSyncs == 0) {
188             lockedSynchronizers = EMPTY_SYNCS;
189         } else {
190             lockedSynchronizers = new LockInfo[numSyncs];
191             for (int i = 0; i &lt; numSyncs; i++) {
192                 Object lock = synchronizers[i];
193                 String className = lock.getClass().getName();
194                 int identityHashCode = System.identityHashCode(lock);
195                 lockedSynchronizers[i] = new LockInfo(className,
196                                                       identityHashCode);
197             }
198         }
199 
200         initialize(t, state, lockObj, lockOwner,
201                    blockedCount, blockedTime,
202                    waitedCount, waitedTime, stackTrace,
203                    lockedMonitors, lockedSynchronizers);
204     }
205 
206     /**
207      * Initialize ThreadInfo object
208      *
209      * @param t             Thread
210      * @param state         Thread state
211      * @param lockObj       Object on which the thread is blocked
212      * @param lockOwner     the thread holding the lock
213      * @param blockedCount  Number of times blocked to enter a lock
214      * @param blockedTime   Approx time blocked to enter a lock
215      * @param waitedCount   Number of times waited on a lock
216      * @param waitedTime    Approx time waited on a lock
217      * @param stackTrace    Thread stack trace
218      * @param lockedMonitors List of locked monitors
219      * @param lockedSynchronizers List of locked synchronizers
220      */
221     private void initialize(Thread t, int state, Object lockObj, Thread lockOwner,
222                             long blockedCount, long blockedTime,
223                             long waitedCount, long waitedTime,
224                             StackTraceElement[] stackTrace,
225                             MonitorInfo[] lockedMonitors,
226                             LockInfo[] lockedSynchronizers) {
227         this.threadId = t.getId();
228         this.threadName = t.getName();
229         this.threadState = ManagementFactoryHelper.toThreadState(state);
230         this.suspended = ManagementFactoryHelper.isThreadSuspended(state);
231         this.inNative = ManagementFactoryHelper.isThreadRunningNative(state);
232         this.blockedCount = blockedCount;
233         this.blockedTime = blockedTime;
234         this.waitedCount = waitedCount;
235         this.waitedTime = waitedTime;
236         this.daemon = t.isDaemon();
237         this.priority = t.getPriority();
238 
239         if (lockObj == null) {
240             this.lock = null;
241             this.lockName = null;
242         } else {
243             this.lock = new LockInfo(lockObj);
244             this.lockName =
245                 lock.getClassName() + &#39;@&#39; +
246                     Integer.toHexString(lock.getIdentityHashCode());
247         }
248         if (lockOwner == null) {
249             this.lockOwnerId = -1;
250             this.lockOwnerName = null;
251         } else {
252             this.lockOwnerId = lockOwner.getId();
253             this.lockOwnerName = lockOwner.getName();
254         }
255         if (stackTrace == null) {
256             this.stackTrace = NO_STACK_TRACE;
257         } else {
258             this.stackTrace = stackTrace;
259         }
260         this.lockedMonitors = lockedMonitors;
261         this.lockedSynchronizers = lockedSynchronizers;
262     }
263 
264     /*
265      * Constructs a {@code ThreadInfo} object from a
266      * {@link CompositeData CompositeData}.
267      *
268      * @throws IllegalArgumentException if the given CompositeData does not
269      * contain all of the attributes defined for ThreadInfo of version &lt;= N.
270      *
271      * @see ThreadInfo#from
272      */
273     private ThreadInfo(CompositeData cd) {
274         ThreadInfoCompositeData ticd = ThreadInfoCompositeData.getInstance(cd);
275 
276         threadId = ticd.threadId();
277         threadName = ticd.threadName();
278         blockedTime = ticd.blockedTime();
279         blockedCount = ticd.blockedCount();
280         waitedTime = ticd.waitedTime();
281         waitedCount = ticd.waitedCount();
282         lockName = ticd.lockName();
283         lockOwnerId = ticd.lockOwnerId();
284         lockOwnerName = ticd.lockOwnerName();
285         threadState = ticd.threadState();
286         suspended = ticd.suspended();
287         inNative = ticd.inNative();
288         stackTrace = ticd.stackTrace();
289         lock = ticd.lockInfo();
290         lockedMonitors = ticd.lockedMonitors();
291         lockedSynchronizers = ticd.lockedSynchronizers();
292         daemon = ticd.isDaemon();
293         priority = ticd.getPriority();
294     }
295 
296     /**
297      * Returns the ID of the thread associated with this {@code ThreadInfo}.
298      *
299      * @return the ID of the associated thread.
300      */
301     public long getThreadId() {
302         return threadId;
303     }
304 
305     /**
306      * Returns the name of the thread associated with this {@code ThreadInfo}.
307      *
308      * @return the name of the associated thread.
309      */
310     public String getThreadName() {
311         return threadName;
312     }
313 
314     /**
315      * Returns the state of the thread associated with this {@code ThreadInfo}.
316      *
317      * @return {@code Thread.State} of the associated thread.
318      */
319     public Thread.State getThreadState() {
320          return threadState;
321     }
322 
323     /**
324      * Returns the approximate accumulated elapsed time (in milliseconds)
325      * that the thread associated with this {@code ThreadInfo}
326      * has blocked to enter or reenter a monitor
327      * since thread contention monitoring is enabled.
328      * I.e. the total accumulated time the thread has been in the
329      * {@link java.lang.Thread.State#BLOCKED BLOCKED} state since thread
330      * contention monitoring was last enabled.
331      * This method returns {@code -1} if thread contention monitoring
332      * is disabled.
333      *
334      * &lt;p&gt;The Java virtual machine may measure the time with a high
335      * resolution timer.  This statistic is reset when
336      * the thread contention monitoring is reenabled.
337      *
338      * @return the approximate accumulated elapsed time in milliseconds
339      * that a thread entered the {@code BLOCKED} state;
340      * {@code -1} if thread contention monitoring is disabled.
341      *
342      * @throws java.lang.UnsupportedOperationException if the Java
343      * virtual machine does not support this operation.
344      *
345      * @see ThreadMXBean#isThreadContentionMonitoringSupported
346      * @see ThreadMXBean#setThreadContentionMonitoringEnabled
347      */
348     public long getBlockedTime() {
349         return blockedTime;
350     }
351 
352     /**
353      * Returns the total number of times that
354      * the thread associated with this {@code ThreadInfo}
355      * blocked to enter or reenter a monitor.
356      * I.e. the number of times a thread has been in the
357      * {@link java.lang.Thread.State#BLOCKED BLOCKED} state.
358      *
359      * @return the total number of times that the thread
360      * entered the {@code BLOCKED} state.
361      */
362     public long getBlockedCount() {
363         return blockedCount;
364     }
365 
366     /**
367      * Returns the approximate accumulated elapsed time (in milliseconds)
368      * that the thread associated with this {@code ThreadInfo}
369      * has waited for notification
370      * since thread contention monitoring is enabled.
371      * I.e. the total accumulated time the thread has been in the
372      * {@link java.lang.Thread.State#WAITING WAITING}
373      * or {@link java.lang.Thread.State#TIMED_WAITING TIMED_WAITING} state
374      * since thread contention monitoring is enabled.
375      * This method returns {@code -1} if thread contention monitoring
376      * is disabled.
377      *
378      * &lt;p&gt;The Java virtual machine may measure the time with a high
379      * resolution timer.  This statistic is reset when
380      * the thread contention monitoring is reenabled.
381      *
382      * @return the approximate accumulated elapsed time in milliseconds
383      * that a thread has been in the {@code WAITING} or
384      * {@code TIMED_WAITING} state;
385      * {@code -1} if thread contention monitoring is disabled.
386      *
387      * @throws java.lang.UnsupportedOperationException if the Java
388      * virtual machine does not support this operation.
389      *
390      * @see ThreadMXBean#isThreadContentionMonitoringSupported
391      * @see ThreadMXBean#setThreadContentionMonitoringEnabled
392      */
393     public long getWaitedTime() {
394         return waitedTime;
395     }
396 
397     /**
398      * Returns the total number of times that
399      * the thread associated with this {@code ThreadInfo}
400      * waited for notification.
401      * I.e. the number of times that a thread has been
402      * in the {@link java.lang.Thread.State#WAITING WAITING}
403      * or {@link java.lang.Thread.State#TIMED_WAITING TIMED_WAITING} state.
404      *
405      * @return the total number of times that the thread
406      * was in the {@code WAITING} or {@code TIMED_WAITING} state.
407      */
408     public long getWaitedCount() {
409         return waitedCount;
410     }
411 
412     /**
413      * Returns the {@code LockInfo} of an object for which
414      * the thread associated with this {@code ThreadInfo}
415      * is blocked waiting.
416      * A thread can be blocked waiting for one of the following:
417      * &lt;ul&gt;
418      * &lt;li&gt;an object monitor to be acquired for entering or reentering
419      *     a synchronization block/method.
420      *     &lt;br&gt;The thread is in the {@link java.lang.Thread.State#BLOCKED BLOCKED}
421      *     state waiting to enter the {@code synchronized} statement
422      *     or method.
423      *     &lt;/li&gt;
424      * &lt;li&gt;an object monitor to be notified by another thread.
425      *     &lt;br&gt;The thread is in the {@link java.lang.Thread.State#WAITING WAITING}
426      *     or {@link java.lang.Thread.State#TIMED_WAITING TIMED_WAITING} state
427      *     due to a call to the {@link Object#wait Object.wait} method.
428      *     &lt;/li&gt;
429      * &lt;li&gt;a synchronization object responsible for the thread parking.
430      *     &lt;br&gt;The thread is in the {@link java.lang.Thread.State#WAITING WAITING}
431      *     or {@link java.lang.Thread.State#TIMED_WAITING TIMED_WAITING} state
432      *     due to a call to the
433      *     {@link java.util.concurrent.locks.LockSupport#park(Object)
434      *     LockSupport.park} method.  The synchronization object
435      *     is the object returned from
436      *     {@link java.util.concurrent.locks.LockSupport#getBlocker
437      *     LockSupport.getBlocker} method. Typically it is an
438      *     &lt;a href=&quot;LockInfo.html#OwnableSynchronizer&quot;&gt; ownable synchronizer&lt;/a&gt;
439      *     or a {@link java.util.concurrent.locks.Condition Condition}.&lt;/li&gt;
440      * &lt;/ul&gt;
441      *
442      * &lt;p&gt;This method returns {@code null} if the thread is not in any of
443      * the above conditions.
444      *
445      * @return {@code LockInfo} of an object for which the thread
446      *         is blocked waiting if any; {@code null} otherwise.
447      * @since 1.6
448      */
449     public LockInfo getLockInfo() {
450         return lock;
451     }
452 
453     /**
454      * Returns the {@link LockInfo#toString string representation}
455      * of an object for which the thread associated with this
456      * {@code ThreadInfo} is blocked waiting.
457      * This method is equivalent to calling:
458      * &lt;blockquote&gt;
459      * &lt;pre&gt;
460      * getLockInfo().toString()
461      * &lt;/pre&gt;&lt;/blockquote&gt;
462      *
463      * &lt;p&gt;This method will return {@code null} if this thread is not blocked
464      * waiting for any object or if the object is not owned by any thread.
465      *
466      * @return the string representation of the object on which
467      * the thread is blocked if any;
468      * {@code null} otherwise.
469      *
470      * @see #getLockInfo
471      */
472     public String getLockName() {
473         return lockName;
474     }
475 
476     /**
477      * Returns the ID of the thread which owns the object
478      * for which the thread associated with this {@code ThreadInfo}
479      * is blocked waiting.
480      * This method will return {@code -1} if this thread is not blocked
481      * waiting for any object or if the object is not owned by any thread.
482      *
483      * @return the thread ID of the owner thread of the object
484      * this thread is blocked on;
485      * {@code -1} if this thread is not blocked
486      * or if the object is not owned by any thread.
487      *
488      * @see #getLockInfo
489      */
490     public long getLockOwnerId() {
491         return lockOwnerId;
492     }
493 
494     /**
495      * Returns the name of the thread which owns the object
496      * for which the thread associated with this {@code ThreadInfo}
497      * is blocked waiting.
498      * This method will return {@code null} if this thread is not blocked
499      * waiting for any object or if the object is not owned by any thread.
500      *
501      * @return the name of the thread that owns the object
502      * this thread is blocked on;
503      * {@code null} if this thread is not blocked
504      * or if the object is not owned by any thread.
505      *
506      * @see #getLockInfo
507      */
508     public String getLockOwnerName() {
509         return lockOwnerName;
510     }
511 
512     /**
513      * Returns the stack trace of the thread
514      * associated with this {@code ThreadInfo}.
515      * If no stack trace was requested for this thread info, this method
516      * will return a zero-length array.
517      * If the returned array is of non-zero length then the first element of
518      * the array represents the top of the stack, which is the most recent
519      * method invocation in the sequence.  The last element of the array
520      * represents the bottom of the stack, which is the least recent method
521      * invocation in the sequence.
522      *
523      * &lt;p&gt;Some Java virtual machines may, under some circumstances, omit one
524      * or more stack frames from the stack trace.  In the extreme case,
525      * a virtual machine that has no stack trace information concerning
526      * the thread associated with this {@code ThreadInfo}
527      * is permitted to return a zero-length array from this method.
528      *
529      * @return an array of {@code StackTraceElement} objects of the thread.
530      */
531     public StackTraceElement[] getStackTrace() {
532         return stackTrace.clone();
533     }
534 
535     /**
536      * Tests if the thread associated with this {@code ThreadInfo}
537      * is suspended.  This method returns {@code true} if
538      * {@link Thread#suspend} has been called.
539      *
540      * @return {@code true} if the thread is suspended;
541      *         {@code false} otherwise.
542      */
543     public boolean isSuspended() {
544          return suspended;
545     }
546 
547     /**
548      * Tests if the thread associated with this {@code ThreadInfo}
549      * is executing native code via the Java Native Interface (JNI).
550      * The JNI native code does not include
551      * the virtual machine support code or the compiled native
552      * code generated by the virtual machine.
553      *
554      * @return {@code true} if the thread is executing native code;
555      *         {@code false} otherwise.
556      */
557     public boolean isInNative() {
558          return inNative;
559     }
560 
561     /**
562      * Tests if the thread associated with this {@code ThreadInfo} is
563      * a {@linkplain Thread#isDaemon daemon thread}.
564      *
565      * @return {@code true} if the thread is a daemon thread,
566      *         {@code false} otherwise.
567      * @see Thread#isDaemon
568      * @since 9
569      */
570     public boolean isDaemon() {
571          return daemon;
572     }
573 
574     /**
575      * Returns the {@linkplain Thread#getPriority() thread priority} of the
576      * thread associated with this {@code ThreadInfo}.
577      *
578      * @return The priority of the thread associated with this
579      *         {@code ThreadInfo}.
580      * @since 9
581      */
582     public int getPriority() {
583          return priority;
584     }
585 
586     /**
587      * Returns a string representation of this thread info.
588      * The format of this string depends on the implementation.
589      * The returned string will typically include
590      * the {@linkplain #getThreadName thread name},
591      * the {@linkplain #getThreadId thread ID},
592      * its {@linkplain #getThreadState state},
593      * and a {@linkplain #getStackTrace stack trace} if any.
594      *
595      * @return a string representation of this thread info.
596      */
597     public String toString() {
598         StringBuilder sb = new StringBuilder(&quot;\&quot;&quot; + getThreadName() + &quot;\&quot;&quot; +
599                                              (daemon ? &quot; daemon&quot; : &quot;&quot;) +
600                                              &quot; prio=&quot; + priority +
601                                              &quot; Id=&quot; + getThreadId() + &quot; &quot; +
602                                              getThreadState());
603         if (getLockName() != null) {
604             sb.append(&quot; on &quot; + getLockName());
605         }
606         if (getLockOwnerName() != null) {
607             sb.append(&quot; owned by \&quot;&quot; + getLockOwnerName() +
608                       &quot;\&quot; Id=&quot; + getLockOwnerId());
609         }
610         if (isSuspended()) {
611             sb.append(&quot; (suspended)&quot;);
612         }
613         if (isInNative()) {
614             sb.append(&quot; (in native)&quot;);
615         }
616         sb.append(&#39;\n&#39;);
617         int i = 0;
618         for (; i &lt; stackTrace.length &amp;&amp; i &lt; MAX_FRAMES; i++) {
619             StackTraceElement ste = stackTrace[i];
620             sb.append(&quot;\tat &quot; + ste.toString());
621             sb.append(&#39;\n&#39;);
622             if (i == 0 &amp;&amp; getLockInfo() != null) {
623                 Thread.State ts = getThreadState();
624                 switch (ts) {
625                     case BLOCKED:
626                         sb.append(&quot;\t-  blocked on &quot; + getLockInfo());
627                         sb.append(&#39;\n&#39;);
628                         break;
629                     case WAITING:
630                         sb.append(&quot;\t-  waiting on &quot; + getLockInfo());
631                         sb.append(&#39;\n&#39;);
632                         break;
633                     case TIMED_WAITING:
634                         sb.append(&quot;\t-  waiting on &quot; + getLockInfo());
635                         sb.append(&#39;\n&#39;);
636                         break;
637                     default:
638                 }
639             }
640 
641             for (MonitorInfo mi : lockedMonitors) {
642                 if (mi.getLockedStackDepth() == i) {
643                     sb.append(&quot;\t-  locked &quot; + mi);
644                     sb.append(&#39;\n&#39;);
645                 }
646             }
647        }
648        if (i &lt; stackTrace.length) {
649            sb.append(&quot;\t...&quot;);
650            sb.append(&#39;\n&#39;);
651        }
652 
653        LockInfo[] locks = getLockedSynchronizers();
654        if (locks.length &gt; 0) {
655            sb.append(&quot;\n\tNumber of locked synchronizers = &quot; + locks.length);
656            sb.append(&#39;\n&#39;);
657            for (LockInfo li : locks) {
658                sb.append(&quot;\t- &quot; + li);
659                sb.append(&#39;\n&#39;);
660            }
661        }
662        sb.append(&#39;\n&#39;);
663        return sb.toString();
664     }
665     private static final int MAX_FRAMES = 8;
666 
667     /**
668      * Returns a {@code ThreadInfo} object represented by the
669      * given {@code CompositeData}.
670      *
671      * &lt;a id=&quot;attributes&quot;&gt;&lt;/a&gt;
672      * A {@code CompositeData} representing a {@code ThreadInfo} of
673      * version &lt;em&gt;N&lt;/em&gt; must contain all of the attributes defined
674      * in version &amp;le; &lt;em&gt;N&lt;/em&gt; unless specified otherwise.
675      * The same rule applies the composite type of the given
676      * {@code CompositeData} and transitively to attributes whose
677      * {@linkplain CompositeData#getCompositeType() type} or
678      * {@linkplain ArrayType#getElementOpenType() component type} is
679      * {@code CompositeType}.
680      * &lt;p&gt;
681      * A {@code CompositeData} representing {@code ThreadInfo} of
682      * version &lt;em&gt;N&lt;/em&gt; contains {@code &quot;stackTrace&quot;} attribute and
683      * {@code &quot;lockedMonitors&quot;} attribute representing
684      * an array of {@code StackTraceElement} and
685      * an array of {@link MonitorInfo} respectively
686      * and their types are of version &lt;em&gt;N&lt;/em&gt;.
687      * The {@code &quot;lockedStackFrame&quot;} attribute in
688      * {@link MonitorInfo#from(CompositeData) MonitorInfo}&#39;s composite type
689      * must represent {@code StackTraceElement} of the same version &lt;em&gt;N&lt;/em&gt;.
690      * Otherwise, this method will throw {@code IllegalArgumentException}.
691      *
692      * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
693      * &lt;caption style=&quot;display:none&quot;&gt;The attributes and their types for ThreadInfo&#39;s composite data&lt;/caption&gt;
694      * &lt;thead&gt;
695      * &lt;tr&gt;
696      *   &lt;th scope=&quot;col&quot;&gt;Attribute Name&lt;/th&gt;
697      *   &lt;th scope=&quot;col&quot;&gt;Type&lt;/th&gt;
698      *   &lt;th scope=&quot;col&quot;&gt;Since&lt;/th&gt;
699      * &lt;/tr&gt;
700      * &lt;/thead&gt;
701      * &lt;tbody style=&quot;text-align:left&quot;&gt;
702      * &lt;tr&gt;
703      *   &lt;th scope=&quot;row&quot;&gt;threadId&lt;/th&gt;
704      *   &lt;td&gt;{@code java.lang.Long}&lt;/td&gt;
705      *   &lt;td&gt;5&lt;/td&gt;
706      * &lt;/tr&gt;
707      * &lt;tr&gt;
708      *   &lt;th scope=&quot;row&quot;&gt;threadName&lt;/th&gt;
709      *   &lt;td&gt;{@code java.lang.String}&lt;/td&gt;
710      *   &lt;td&gt;5&lt;/td&gt;
711      * &lt;/tr&gt;
712      * &lt;tr&gt;
713      *   &lt;th scope=&quot;row&quot;&gt;threadState&lt;/th&gt;
714      *   &lt;td&gt;{@code java.lang.String}&lt;/td&gt;
715      *   &lt;td&gt;5&lt;/td&gt;
716      * &lt;/tr&gt;
717      * &lt;tr&gt;
718      *   &lt;th scope=&quot;row&quot;&gt;suspended&lt;/th&gt;
719      *   &lt;td&gt;{@code java.lang.Boolean}&lt;/td&gt;
720      *   &lt;td&gt;5&lt;/td&gt;
721      * &lt;/tr&gt;
722      * &lt;tr&gt;
723      *   &lt;th scope=&quot;row&quot;&gt;inNative&lt;/th&gt;
724      *   &lt;td&gt;{@code java.lang.Boolean}&lt;/td&gt;
725      *   &lt;td&gt;5&lt;/td&gt;
726      * &lt;/tr&gt;
727      * &lt;tr&gt;
728      *   &lt;th scope=&quot;row&quot;&gt;blockedCount&lt;/th&gt;
729      *   &lt;td&gt;{@code java.lang.Long}&lt;/td&gt;
730      *   &lt;td&gt;5&lt;/td&gt;
731      * &lt;/tr&gt;
732      * &lt;tr&gt;
733      *   &lt;th scope=&quot;row&quot;&gt;blockedTime&lt;/th&gt;
734      *   &lt;td&gt;{@code java.lang.Long}&lt;/td&gt;
735      *   &lt;td&gt;5&lt;/td&gt;
736      * &lt;/tr&gt;
737      * &lt;tr&gt;
738      *   &lt;th scope=&quot;row&quot;&gt;waitedCount&lt;/th&gt;
739      *   &lt;td&gt;{@code java.lang.Long}&lt;/td&gt;
740      *   &lt;td&gt;5&lt;/td&gt;
741      * &lt;/tr&gt;
742      * &lt;tr&gt;
743      *   &lt;th scope=&quot;row&quot;&gt;waitedTime&lt;/th&gt;
744      *   &lt;td&gt;{@code java.lang.Long}&lt;/td&gt;
745      *   &lt;td&gt;5&lt;/td&gt;
746      * &lt;/tr&gt;
747      * &lt;tr&gt;
748      *   &lt;th scope=&quot;row&quot;&gt;lockName&lt;/th&gt;
749      *   &lt;td&gt;{@code java.lang.String}&lt;/td&gt;
750      *   &lt;td&gt;5&lt;/td&gt;
751      * &lt;/tr&gt;
752      * &lt;tr&gt;
753      *   &lt;th scope=&quot;row&quot;&gt;lockOwnerId&lt;/th&gt;
754      *   &lt;td&gt;{@code java.lang.Long}&lt;/td&gt;
755      *   &lt;td&gt;5&lt;/td&gt;
756      * &lt;/tr&gt;
757      * &lt;tr&gt;
758      *   &lt;th scope=&quot;row&quot;&gt;lockOwnerName&lt;/th&gt;
759      *   &lt;td&gt;{@code java.lang.String}&lt;/td&gt;
760      *   &lt;td&gt;5&lt;/td&gt;
761      * &lt;/tr&gt;
762      * &lt;tr&gt;
763      *   &lt;th scope=&quot;row&quot;&gt;&lt;a id=&quot;StackTrace&quot;&gt;stackTrace&lt;/a&gt;&lt;/th&gt;
764      *   &lt;td&gt;{@code javax.management.openmbean.CompositeData[]}, each element
765      *       is a {@code CompositeData} representing {@code StackTraceElement}
766      *       as specified &lt;a href=&quot;#stackTraceElement&quot;&gt;below&lt;/a&gt;.
767      *   &lt;/td&gt;
768      *   &lt;td&gt;5&lt;/td&gt;
769      * &lt;/tr&gt;
770      * &lt;tr&gt;
771      *   &lt;th scope=&quot;row&quot;&gt;lockInfo&lt;/th&gt;
772      *   &lt;td&gt;{@code javax.management.openmbean.CompositeData}
773      *       - the mapped type for {@link LockInfo} as specified in the
774      *         {@link LockInfo#from} method.
775      *       &lt;p&gt;
776      *       If the given {@code CompositeData} does not contain this attribute,
777      *       the {@code LockInfo} object will be constructed from
778      *       the value of the {@code lockName} attribute.&lt;/td&gt;
779      *    &lt;td&gt;6&lt;/td&gt;
780      * &lt;/tr&gt;
781      * &lt;tr&gt;
782      *   &lt;th scope=&quot;row&quot;&gt;lockedMonitors&lt;/th&gt;
783      *   &lt;td&gt;{@code javax.management.openmbean.CompositeData[]}
784      *       whose element type is the mapped type for
785      *       {@link MonitorInfo} as specified in the
786      *       {@link MonitorInfo#from MonitorInfo.from} method.
787      *       &lt;p&gt;
788      *       If the given {@code CompositeData} does not contain this attribute,
789      *       this attribute will be set to an empty array.&lt;/td&gt;
790      *    &lt;td&gt;6&lt;/td&gt;
791      * &lt;/tr&gt;
792      * &lt;tr&gt;
793      *   &lt;th scope=&quot;row&quot;&gt;lockedSynchronizers&lt;/th&gt;
794      *   &lt;td&gt;{@code javax.management.openmbean.CompositeData[]}
795      *       whose element type is the mapped type for
796      *       {@link LockInfo} as specified in the {@link LockInfo#from} method.
797      *       &lt;p&gt;
798      *       If the given {@code CompositeData} does not contain this attribute,
799      *       this attribute will be set to an empty array.&lt;/td&gt;
800      *    &lt;td&gt;6&lt;/td&gt;
801      * &lt;/tr&gt;
802      * &lt;tr&gt;
803      *   &lt;th scope=&quot;row&quot;&gt;daemon&lt;/th&gt;
804      *   &lt;td&gt;{@code java.lang.Boolean}
805      *       &lt;p&gt;
806      *       If the given {@code CompositeData} does not contain this attribute,
807      *       this attribute will be set to {@code false}.&lt;/td&gt;
808      *    &lt;td&gt;9&lt;/td&gt;
809      * &lt;/tr&gt;
810      * &lt;tr&gt;
811      *   &lt;th scope=&quot;row&quot;&gt;priority&lt;/th&gt;
812      *   &lt;td&gt;{@code java.lang.Integer}
813      *       &lt;p&gt;
814      *       If the given {@code CompositeData} does not contain this attribute,
815      *       This attribute will be set to {@link Thread#NORM_PRIORITY}.&lt;/td&gt;
816      *    &lt;td&gt;9&lt;/td&gt;
817      * &lt;/tr&gt;
818      * &lt;/tbody&gt;
819      * &lt;/table&gt;
820      *
821      * &lt;a id=&quot;stackTraceElement&quot;&gt;A {@code CompositeData} representing
822      * {@code StackTraceElement}&lt;/a&gt; of version &lt;em&gt;N&lt;/em&gt; must contain
823      * all of the attributes defined in version &amp;le; &lt;em&gt;N&lt;/em&gt;
824      * unless specified otherwise.
825      *
826      * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
827      * &lt;caption style=&quot;display:none&quot;&gt;The attributes and their types for StackTraceElement&#39;s composite data&lt;/caption&gt;
828      * &lt;thead style=&quot;text-align:center&quot;&gt;
829      * &lt;tr&gt;
830      *   &lt;th scope=&quot;col&quot;&gt;Attribute Name&lt;/th&gt;
831      *   &lt;th scope=&quot;col&quot;&gt;Type&lt;/th&gt;
832      *   &lt;th scope=&quot;col&quot;&gt;Since&lt;/th&gt;
833      * &lt;/tr&gt;
834      * &lt;/thead&gt;
835      * &lt;tbody style=&quot;text-align:left&quot;&gt;
836      * &lt;tr&gt;
837      *   &lt;th scope=&quot;row&quot;&gt;classLoaderName&lt;/th&gt;
838      *   &lt;td&gt;{@code java.lang.String}&lt;/td&gt;
839      *   &lt;td&gt;9&lt;/td&gt;
840      * &lt;/tr&gt;
841      * &lt;tr&gt;
842      *   &lt;th scope=&quot;row&quot;&gt;moduleName&lt;/th&gt;
843      *   &lt;td&gt;{@code java.lang.String}&lt;/td&gt;
844      *   &lt;td&gt;9&lt;/td&gt;
845      * &lt;/tr&gt;
846      * &lt;tr&gt;
847      *   &lt;th scope=&quot;row&quot;&gt;moduleVersion&lt;/th&gt;
848      *   &lt;td&gt;{@code java.lang.String}&lt;/td&gt;
849      *   &lt;td&gt;9&lt;/td&gt;
850      * &lt;/tr&gt;
851      * &lt;tr&gt;
852      *   &lt;th scope=&quot;row&quot;&gt;className&lt;/th&gt;
853      *   &lt;td&gt;{@code java.lang.String}&lt;/td&gt;
854      *   &lt;td&gt;5&lt;/td&gt;
855      * &lt;/tr&gt;
856      * &lt;tr&gt;
857      *   &lt;th scope=&quot;row&quot;&gt;methodName&lt;/th&gt;
858      *   &lt;td&gt;{@code java.lang.String}&lt;/td&gt;
859      *   &lt;td&gt;5&lt;/td&gt;
860      * &lt;/tr&gt;
861      * &lt;tr&gt;
862      *   &lt;th scope=&quot;row&quot;&gt;fileName&lt;/th&gt;
863      *   &lt;td&gt;{@code java.lang.String}&lt;/td&gt;
864      *   &lt;td&gt;5&lt;/td&gt;
865      * &lt;/tr&gt;
866      * &lt;tr&gt;
867      *   &lt;th scope=&quot;row&quot;&gt;lineNumber&lt;/th&gt;
868      *   &lt;td&gt;{@code java.lang.Integer}&lt;/td&gt;
869      *   &lt;td&gt;5&lt;/td&gt;
870      * &lt;/tr&gt;
871      * &lt;tr&gt;
872      *   &lt;th scope=&quot;row&quot;&gt;nativeMethod&lt;/th&gt;
873      *   &lt;td&gt;{@code java.lang.Boolean}&lt;/td&gt;
874      *   &lt;td&gt;5&lt;/td&gt;
875      * &lt;/tr&gt;
876      * &lt;/tbody&gt;
877      * &lt;/table&gt;
878      *
879      * @param cd {@code CompositeData} representing a {@code ThreadInfo}
880      *
881      * @throws IllegalArgumentException if the given {@code cd} and
882      *         its composite type does not contain all of
883      *         &lt;a href=&quot;#attributes&quot;&gt;the attributes&lt;/a&gt; defined for a
884      *         {@code ThreadInfo} of a specific runtime version.
885      *
886      * @return a {@code ThreadInfo} object represented
887      *         by {@code cd} if {@code cd} is not {@code null};
888      *         {@code null} otherwise.
889      *
890      * @revised 9
891      * @spec JPMS
892      */
893     public static ThreadInfo from(CompositeData cd) {
894         if (cd == null) {
895             return null;
896         }
897 
898         if (cd instanceof ThreadInfoCompositeData) {
899             return ((ThreadInfoCompositeData) cd).getThreadInfo();
900         } else {
901             return new ThreadInfo(cd);
902         }
903     }
904 
905     /**
906      * Returns an array of {@link MonitorInfo} objects, each of which
907      * represents an object monitor currently locked by the thread
908      * associated with this {@code ThreadInfo}.
909      * If no locked monitor was requested for this thread info or
910      * no monitor is locked by the thread, this method
911      * will return a zero-length array.
912      *
913      * @return an array of {@code MonitorInfo} objects representing
914      *         the object monitors locked by the thread.
915      *
916      * @since 1.6
917      */
918     public MonitorInfo[] getLockedMonitors() {
919         return lockedMonitors.clone();
920     }
921 
922     /**
923      * Returns an array of {@link LockInfo} objects, each of which
924      * represents an &lt;a href=&quot;LockInfo.html#OwnableSynchronizer&quot;&gt;ownable
925      * synchronizer&lt;/a&gt; currently locked by the thread associated with
926      * this {@code ThreadInfo}.  If no locked synchronizer was
927      * requested for this thread info or no synchronizer is locked by
928      * the thread, this method will return a zero-length array.
929      *
930      * @return an array of {@code LockInfo} objects representing
931      *         the ownable synchronizers locked by the thread.
932      *
933      * @since 1.6
934      */
935     public LockInfo[] getLockedSynchronizers() {
936         return lockedSynchronizers.clone();
937     }
938 
939     private static final StackTraceElement[] NO_STACK_TRACE =
940         new StackTraceElement[0];
941 }
    </pre>
  </body>
</html>
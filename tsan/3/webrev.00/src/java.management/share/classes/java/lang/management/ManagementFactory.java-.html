<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.management/share/classes/java/lang/management/ManagementFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.management;
  27 import java.io.FilePermission;
  28 import java.io.IOException;
  29 import javax.management.DynamicMBean;
  30 import javax.management.MBeanServer;
  31 import javax.management.MBeanServerConnection;
  32 import javax.management.MBeanServerFactory;
  33 import javax.management.MBeanServerPermission;
  34 import javax.management.NotificationEmitter;
  35 import javax.management.ObjectName;
  36 import javax.management.InstanceNotFoundException;
  37 import javax.management.MalformedObjectNameException;
  38 import javax.management.StandardEmitterMBean;
  39 import javax.management.StandardMBean;
  40 import java.util.Collections;
  41 import java.util.List;
  42 import java.util.Set;
  43 import java.util.Map;
  44 import java.security.AccessController;
  45 import java.security.Permission;
  46 import java.security.PrivilegedAction;
  47 import java.security.PrivilegedActionException;
  48 import java.security.PrivilegedExceptionAction;
  49 import java.util.ArrayList;
  50 import java.util.Collection;
  51 import java.util.Optional;
  52 import java.util.ServiceLoader;
  53 import java.util.function.Function;
  54 import java.util.stream.Collectors;
  55 import static java.util.stream.Collectors.toMap;
  56 import java.util.stream.Stream;
  57 import javax.management.JMX;
  58 import sun.management.Util;
  59 import sun.management.spi.PlatformMBeanProvider;
  60 import sun.management.spi.PlatformMBeanProvider.PlatformComponent;
  61 
  62 /**
  63  * The {@code ManagementFactory} class is a factory class for getting
  64  * managed beans for the Java platform.
  65  * This class consists of static methods each of which returns
  66  * one or more &lt;i&gt;platform MXBeans&lt;/i&gt; representing
  67  * the management interface of a component of the Java virtual
  68  * machine.
  69  *
  70  * &lt;h3&gt;&lt;a id=&quot;MXBean&quot;&gt;Platform MXBeans&lt;/a&gt;&lt;/h3&gt;
  71  * &lt;p&gt;
  72  * A platform MXBean is a &lt;i&gt;managed bean&lt;/i&gt; that
  73  * conforms to the &lt;a href=&quot;../../../javax/management/package-summary.html&quot;&gt;JMX&lt;/a&gt;
  74  * Instrumentation Specification and only uses a set of basic data types.
  75  * A JMX management application and the {@linkplain
  76  * #getPlatformMBeanServer platform MBeanServer}
  77  * can interoperate without requiring classes for MXBean specific
  78  * data types.
  79  * The data types being transmitted between the JMX connector
  80  * server and the connector client are
  81  * {@linkplain javax.management.openmbean.OpenType open types}
  82  * and this allows interoperation across versions.
  83  * See &lt;a href=&quot;../../../javax/management/MXBean.html#MXBean-spec&quot;&gt;
  84  * the specification of MXBeans&lt;/a&gt; for details.
  85  *
  86  * &lt;a id=&quot;MXBeanNames&quot;&gt;&lt;/a&gt;
  87  * &lt;p&gt;Each platform MXBean is a {@link PlatformManagedObject}
  88  * and it has a unique
  89  * {@link javax.management.ObjectName ObjectName} for
  90  * registration in the platform {@code MBeanServer} as returned by
  91  * by the {@link PlatformManagedObject#getObjectName getObjectName}
  92  * method.
  93  *
  94  * &lt;p&gt;
  95  * An application can access a platform MXBean in the following ways:
  96  * &lt;h4&gt;1. Direct access to an MXBean interface&lt;/h4&gt;
  97  * &lt;blockquote&gt;
  98  * &lt;ul&gt;
  99  *     &lt;li&gt;Get an MXBean instance by calling the
 100  *         {@link #getPlatformMXBean(Class) getPlatformMXBean} or
 101  *         {@link #getPlatformMXBeans(Class) getPlatformMXBeans} method
 102  *         and access the MXBean locally in the running
 103  *         virtual machine.
 104  *         &lt;/li&gt;
 105  *     &lt;li&gt;Construct an MXBean proxy instance that forwards the
 106  *         method calls to a given {@link MBeanServer MBeanServer} by calling
 107  *         the {@link #getPlatformMXBean(MBeanServerConnection, Class)} or
 108  *         {@link #getPlatformMXBeans(MBeanServerConnection, Class)} method.
 109  *         The {@link #newPlatformMXBeanProxy newPlatformMXBeanProxy} method
 110  *         can also be used to construct an MXBean proxy instance of
 111  *         a given {@code ObjectName}.
 112  *         A proxy is typically constructed to remotely access
 113  *         an MXBean of another running virtual machine.
 114  *         &lt;/li&gt;
 115  * &lt;/ul&gt;
 116  * &lt;h4&gt;2. Indirect access to an MXBean interface via MBeanServer&lt;/h4&gt;
 117  * &lt;ul&gt;
 118  *     &lt;li&gt;Go through the platform {@code MBeanServer} to access MXBeans
 119  *         locally or a specific {@code MBeanServerConnection} to access
 120  *         MXBeans remotely.
 121  *         The attributes and operations of an MXBean use only
 122  *         &lt;em&gt;JMX open types&lt;/em&gt; which include basic data types,
 123  *         {@link javax.management.openmbean.CompositeData CompositeData},
 124  *         and {@link javax.management.openmbean.TabularData TabularData}
 125  *         defined in
 126  *         {@link javax.management.openmbean.OpenType OpenType}.
 127  *         The mapping is specified in
 128  *         the {@linkplain javax.management.MXBean MXBean} specification
 129  *         for details.
 130  *        &lt;/li&gt;
 131  * &lt;/ul&gt;
 132  * &lt;/blockquote&gt;
 133  *
 134  * &lt;p&gt;
 135  * The {@link #getPlatformManagementInterfaces getPlatformManagementInterfaces}
 136  * method returns all management interfaces supported in the Java virtual machine
 137  * including the standard management interfaces listed in the tables
 138  * below as well as the management interfaces extended by the JDK implementation.
 139  * &lt;p&gt;
 140  * A Java virtual machine has a single instance of the following management
 141  * interfaces:
 142  *
 143  * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
 144  * &lt;caption style=&quot;display:none&quot;&gt;The list of Management Interfaces and their single instances&lt;/caption&gt;
 145  * &lt;thead&gt;
 146  * &lt;tr&gt;
 147  * &lt;th scope=&quot;col&quot;&gt;Management Interface&lt;/th&gt;
 148  * &lt;th scope=&quot;col&quot;&gt;ObjectName&lt;/th&gt;
 149  * &lt;/tr&gt;
 150  * &lt;/thead&gt;
 151  * &lt;tbody style=&quot;text-align:left;&quot;&gt;
 152  * &lt;tr&gt;
 153  * &lt;th scope=&quot;row&quot;&gt; {@link ClassLoadingMXBean} &lt;/th&gt;
 154  * &lt;td&gt; {@link #CLASS_LOADING_MXBEAN_NAME
 155  *             java.lang:type=ClassLoading}&lt;/td&gt;
 156  * &lt;/tr&gt;
 157  * &lt;tr&gt;
 158  * &lt;th scope=&quot;row&quot;&gt; {@link MemoryMXBean} &lt;/th&gt;
 159  * &lt;td&gt; {@link #MEMORY_MXBEAN_NAME
 160  *             java.lang:type=Memory}&lt;/td&gt;
 161  * &lt;/tr&gt;
 162  * &lt;tr&gt;
 163  * &lt;th scope=&quot;row&quot;&gt; {@link ThreadMXBean} &lt;/th&gt;
 164  * &lt;td&gt; {@link #THREAD_MXBEAN_NAME
 165  *             java.lang:type=Threading}&lt;/td&gt;
 166  * &lt;/tr&gt;
 167  * &lt;tr&gt;
 168  * &lt;th scope=&quot;row&quot;&gt; {@link RuntimeMXBean} &lt;/th&gt;
 169  * &lt;td&gt; {@link #RUNTIME_MXBEAN_NAME
 170  *             java.lang:type=Runtime}&lt;/td&gt;
 171  * &lt;/tr&gt;
 172  * &lt;tr&gt;
 173  * &lt;th scope=&quot;row&quot;&gt; {@link OperatingSystemMXBean} &lt;/th&gt;
 174  * &lt;td&gt; {@link #OPERATING_SYSTEM_MXBEAN_NAME
 175  *             java.lang:type=OperatingSystem}&lt;/td&gt;
 176  * &lt;/tr&gt;
 177  * &lt;tr&gt;
 178  * &lt;th scope=&quot;row&quot;&gt; {@link PlatformLoggingMXBean} &lt;/th&gt;
 179  * &lt;td&gt; {@link java.util.logging.LogManager#LOGGING_MXBEAN_NAME
 180  *             java.util.logging:type=Logging}&lt;/td&gt;
 181  * &lt;/tr&gt;
 182  * &lt;/tbody&gt;
 183  * &lt;/table&gt;
 184  *
 185  * &lt;p&gt;
 186  * A Java virtual machine has zero or a single instance of
 187  * the following management interfaces.
 188  *
 189  * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
 190  * &lt;caption style=&quot;display:none&quot;&gt;The list of Management Interfaces and their single instances&lt;/caption&gt;
 191  * &lt;thead&gt;
 192  * &lt;tr&gt;
 193  * &lt;th scope=&quot;col&quot;&gt;Management Interface&lt;/th&gt;
 194  * &lt;th scope=&quot;col&quot;&gt;ObjectName&lt;/th&gt;
 195  * &lt;/tr&gt;
 196  * &lt;/thead&gt;
 197  * &lt;tbody style=&quot;text-align:left;&quot;&gt;
 198  * &lt;tr&gt;
 199  * &lt;th scope=&quot;row&quot;&gt; {@link CompilationMXBean} &lt;/th&gt;
 200  * &lt;td&gt; {@link #COMPILATION_MXBEAN_NAME
 201  *             java.lang:type=Compilation}&lt;/td&gt;
 202  * &lt;/tr&gt;
 203  * &lt;/tbody&gt;
 204  * &lt;/table&gt;
 205  *
 206  * &lt;p&gt;
 207  * A Java virtual machine may have one or more instances of the following
 208  * management interfaces.
 209  * &lt;table class=&quot;striped&quot; style=&quot;margin-left:2em&quot;&gt;
 210  * &lt;caption style=&quot;display:none&quot;&gt;The list of Management Interfaces and their single instances&lt;/caption&gt;
 211  * &lt;thead&gt;
 212  * &lt;tr&gt;
 213  * &lt;th scope=&quot;col&quot;&gt;Management Interface&lt;/th&gt;
 214  * &lt;th scope=&quot;col&quot;&gt;ObjectName&lt;/th&gt;
 215  * &lt;/tr&gt;
 216  * &lt;/thead&gt;
 217  * &lt;tbody style=&quot;text-align:left;&quot;&gt;
 218  * &lt;tr&gt;
 219  * &lt;th scope=&quot;row&quot;&gt; {@link GarbageCollectorMXBean} &lt;/th&gt;
 220  * &lt;td&gt; {@link #GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE
 221  *             java.lang:type=GarbageCollector}{@code ,name=}&lt;i&gt;collector&#39;s name&lt;/i&gt;&lt;/td&gt;
 222  * &lt;/tr&gt;
 223  * &lt;tr&gt;
 224  * &lt;th scope=&quot;row&quot;&gt; {@link MemoryManagerMXBean} &lt;/th&gt;
 225  * &lt;td&gt; {@link #MEMORY_MANAGER_MXBEAN_DOMAIN_TYPE
 226  *             java.lang:type=MemoryManager}{@code ,name=}&lt;i&gt;manager&#39;s name&lt;/i&gt;&lt;/td&gt;
 227  * &lt;/tr&gt;
 228  * &lt;tr&gt;
 229  * &lt;th scope=&quot;row&quot;&gt; {@link MemoryPoolMXBean} &lt;/th&gt;
 230  * &lt;td&gt; {@link #MEMORY_POOL_MXBEAN_DOMAIN_TYPE
 231  *             java.lang:type=MemoryPool}{@code ,name=}&lt;i&gt;pool&#39;s name&lt;/i&gt;&lt;/td&gt;
 232  * &lt;/tr&gt;
 233  * &lt;tr&gt;
 234  * &lt;th scope=&quot;row&quot;&gt; {@link BufferPoolMXBean} &lt;/th&gt;
 235  * &lt;td&gt; {@code java.nio:type=BufferPool,name=}&lt;i&gt;pool name&lt;/i&gt;&lt;/td&gt;
 236  * &lt;/tr&gt;
 237  * &lt;/tbody&gt;
 238  * &lt;/table&gt;
 239  *
 240  * @see &lt;a href=&quot;../../../javax/management/package-summary.html&quot;&gt;
 241  *      JMX Specification&lt;/a&gt;
 242  * @see &lt;a href=&quot;package-summary.html#examples&quot;&gt;
 243  *      Ways to Access Management Metrics&lt;/a&gt;
 244  * @see javax.management.MXBean
 245  *
 246  * @author  Mandy Chung
 247  * @since   1.5
 248  */
 249 public class ManagementFactory {
 250     // A class with only static fields and methods.
 251     private ManagementFactory() {};
 252 
 253     /**
 254      * String representation of the
 255      * {@code ObjectName} for the {@link ClassLoadingMXBean}.
 256      */
 257     public final static String CLASS_LOADING_MXBEAN_NAME =
 258         &quot;java.lang:type=ClassLoading&quot;;
 259 
 260     /**
 261      * String representation of the
 262      * {@code ObjectName} for the {@link CompilationMXBean}.
 263      */
 264     public final static String COMPILATION_MXBEAN_NAME =
 265         &quot;java.lang:type=Compilation&quot;;
 266 
 267     /**
 268      * String representation of the
 269      * {@code ObjectName} for the {@link MemoryMXBean}.
 270      */
 271     public final static String MEMORY_MXBEAN_NAME =
 272         &quot;java.lang:type=Memory&quot;;
 273 
 274     /**
 275      * String representation of the
 276      * {@code ObjectName} for the {@link OperatingSystemMXBean}.
 277      */
 278     public final static String OPERATING_SYSTEM_MXBEAN_NAME =
 279         &quot;java.lang:type=OperatingSystem&quot;;
 280 
 281     /**
 282      * String representation of the
 283      * {@code ObjectName} for the {@link RuntimeMXBean}.
 284      */
 285     public final static String RUNTIME_MXBEAN_NAME =
 286         &quot;java.lang:type=Runtime&quot;;
 287 
 288     /**
 289      * String representation of the
 290      * {@code ObjectName} for the {@link ThreadMXBean}.
 291      */
 292     public final static String THREAD_MXBEAN_NAME =
 293         &quot;java.lang:type=Threading&quot;;
 294 
 295     /**
 296      * The domain name and the type key property in
 297      * the {@code ObjectName} for a {@link GarbageCollectorMXBean}.
 298      * The unique {@code ObjectName} for a {@code GarbageCollectorMXBean}
 299      * can be formed by appending this string with
 300      * &quot;{@code ,name=}&lt;i&gt;collector&#39;s name&lt;/i&gt;&quot;.
 301      */
 302     public final static String GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE =
 303         &quot;java.lang:type=GarbageCollector&quot;;
 304 
 305     /**
 306      * The domain name and the type key property in
 307      * the {@code ObjectName} for a {@link MemoryManagerMXBean}.
 308      * The unique {@code ObjectName} for a {@code MemoryManagerMXBean}
 309      * can be formed by appending this string with
 310      * &quot;{@code ,name=}&lt;i&gt;manager&#39;s name&lt;/i&gt;&quot;.
 311      */
 312     public final static String MEMORY_MANAGER_MXBEAN_DOMAIN_TYPE=
 313         &quot;java.lang:type=MemoryManager&quot;;
 314 
 315     /**
 316      * The domain name and the type key property in
 317      * the {@code ObjectName} for a {@link MemoryPoolMXBean}.
 318      * The unique {@code ObjectName} for a {@code MemoryPoolMXBean}
 319      * can be formed by appending this string with
 320      * {@code ,name=}&lt;i&gt;pool&#39;s name&lt;/i&gt;.
 321      */
 322     public final static String MEMORY_POOL_MXBEAN_DOMAIN_TYPE=
 323         &quot;java.lang:type=MemoryPool&quot;;
 324 
 325     /**
 326      * Returns the managed bean for the class loading system of
 327      * the Java virtual machine.
 328      *
 329      * @return a {@link ClassLoadingMXBean} object for
 330      * the Java virtual machine.
 331      */
 332     public static ClassLoadingMXBean getClassLoadingMXBean() {
 333         return getPlatformMXBean(ClassLoadingMXBean.class);
 334     }
 335 
 336     /**
 337      * Returns the managed bean for the memory system of
 338      * the Java virtual machine.
 339      *
 340      * @return a {@link MemoryMXBean} object for the Java virtual machine.
 341      */
 342     public static MemoryMXBean getMemoryMXBean() {
 343         return getPlatformMXBean(MemoryMXBean.class);
 344     }
 345 
 346     /**
 347      * Returns the managed bean for the thread system of
 348      * the Java virtual machine.
 349      *
 350      * @return a {@link ThreadMXBean} object for the Java virtual machine.
 351      */
 352     public static ThreadMXBean getThreadMXBean() {
 353         return getPlatformMXBean(ThreadMXBean.class);
 354     }
 355 
 356     /**
 357      * Returns the managed bean for the runtime system of
 358      * the Java virtual machine.
 359      *
 360      * @return a {@link RuntimeMXBean} object for the Java virtual machine.
 361 
 362      */
 363     public static RuntimeMXBean getRuntimeMXBean() {
 364         return getPlatformMXBean(RuntimeMXBean.class);
 365     }
 366 
 367     /**
 368      * Returns the managed bean for the compilation system of
 369      * the Java virtual machine.  This method returns {@code null}
 370      * if the Java virtual machine has no compilation system.
 371      *
 372      * @return a {@link CompilationMXBean} object for the Java virtual
 373      *   machine or {@code null} if the Java virtual machine has
 374      *   no compilation system.
 375      */
 376     public static CompilationMXBean getCompilationMXBean() {
 377         return getPlatformMXBean(CompilationMXBean.class);
 378     }
 379 
 380     /**
 381      * Returns the managed bean for the operating system on which
 382      * the Java virtual machine is running.
 383      *
 384      * @return an {@link OperatingSystemMXBean} object for
 385      * the Java virtual machine.
 386      */
 387     public static OperatingSystemMXBean getOperatingSystemMXBean() {
 388         return getPlatformMXBean(OperatingSystemMXBean.class);
 389     }
 390 
 391     /**
 392      * Returns a list of {@link MemoryPoolMXBean} objects in the
 393      * Java virtual machine.
 394      * The Java virtual machine can have one or more memory pools.
 395      * It may add or remove memory pools during execution.
 396      *
 397      * @return a list of {@code MemoryPoolMXBean} objects.
 398      *
 399      */
 400     public static List&lt;MemoryPoolMXBean&gt; getMemoryPoolMXBeans() {
 401         return getPlatformMXBeans(MemoryPoolMXBean.class);
 402     }
 403 
 404     /**
 405      * Returns a list of {@link MemoryManagerMXBean} objects
 406      * in the Java virtual machine.
 407      * The Java virtual machine can have one or more memory managers.
 408      * It may add or remove memory managers during execution.
 409      *
 410      * @return a list of {@code MemoryManagerMXBean} objects.
 411      *
 412      */
 413     public static List&lt;MemoryManagerMXBean&gt; getMemoryManagerMXBeans() {
 414         return getPlatformMXBeans(MemoryManagerMXBean.class);
 415     }
 416 
 417 
 418     /**
 419      * Returns a list of {@link GarbageCollectorMXBean} objects
 420      * in the Java virtual machine.
 421      * The Java virtual machine may have one or more
 422      * {@code GarbageCollectorMXBean} objects.
 423      * It may add or remove {@code GarbageCollectorMXBean}
 424      * during execution.
 425      *
 426      * @return a list of {@code GarbageCollectorMXBean} objects.
 427      *
 428      */
 429     public static List&lt;GarbageCollectorMXBean&gt; getGarbageCollectorMXBeans() {
 430         return getPlatformMXBeans(GarbageCollectorMXBean.class);
 431     }
 432 
 433     private static MBeanServer platformMBeanServer;
 434     /**
 435      * Returns the platform {@link javax.management.MBeanServer MBeanServer}.
 436      * On the first call to this method, it first creates the platform
 437      * {@code MBeanServer} by calling the
 438      * {@link javax.management.MBeanServerFactory#createMBeanServer
 439      * MBeanServerFactory.createMBeanServer}
 440      * method and registers each platform MXBean in this platform
 441      * {@code MBeanServer} with its
 442      * {@link PlatformManagedObject#getObjectName ObjectName}.
 443      * This method, in subsequent calls, will simply return the
 444      * initially created platform {@code MBeanServer}.
 445      * &lt;p&gt;
 446      * MXBeans that get created and destroyed dynamically, for example,
 447      * memory {@link MemoryPoolMXBean pools} and
 448      * {@link MemoryManagerMXBean managers},
 449      * will automatically be registered and deregistered into the platform
 450      * {@code MBeanServer}.
 451      * &lt;p&gt;
 452      * If the system property {@code javax.management.builder.initial}
 453      * is set, the platform {@code MBeanServer} creation will be done
 454      * by the specified {@link javax.management.MBeanServerBuilder}.
 455      * &lt;p&gt;
 456      * It is recommended that this platform MBeanServer also be used
 457      * to register other application managed beans
 458      * besides the platform MXBeans.
 459      * This will allow all MBeans to be published through the same
 460      * {@code MBeanServer} and hence allow for easier network publishing
 461      * and discovery.
 462      * Name conflicts with the platform MXBeans should be avoided.
 463      *
 464      * @return the platform {@code MBeanServer}; the platform
 465      *         MXBeans are registered into the platform {@code MBeanServer}
 466      *         at the first time this method is called.
 467      *
 468      * @exception SecurityException if there is a security manager
 469      * and the caller does not have the permission required by
 470      * {@link javax.management.MBeanServerFactory#createMBeanServer}.
 471      *
 472      * @see javax.management.MBeanServerFactory
 473      * @see javax.management.MBeanServerFactory#createMBeanServer
 474      */
 475     public static synchronized MBeanServer getPlatformMBeanServer() {
 476         SecurityManager sm = System.getSecurityManager();
 477         if (sm != null) {
 478             Permission perm = new MBeanServerPermission(&quot;createMBeanServer&quot;);
 479             sm.checkPermission(perm);
 480         }
 481 
 482         if (platformMBeanServer == null) {
 483             platformMBeanServer = MBeanServerFactory.createMBeanServer();
 484             platformComponents()
 485                     .stream()
 486                     .filter(PlatformComponent::shouldRegister)
 487                     .flatMap(pc -&gt; pc.nameToMBeanMap().entrySet().stream())
 488                     .forEach(entry -&gt; addMXBean(platformMBeanServer, entry.getKey(), entry.getValue()));
 489         }
 490         return platformMBeanServer;
 491     }
 492 
 493     /**
 494      * Returns a proxy for a platform MXBean interface of a
 495      * given &lt;a href=&quot;#MXBeanNames&quot;&gt;MXBean name&lt;/a&gt;
 496      * that forwards its method calls through the given
 497      * {@code MBeanServerConnection}.
 498      *
 499      * &lt;p&gt;This method is equivalent to:
 500      * &lt;blockquote&gt;
 501      * {@link java.lang.reflect.Proxy#newProxyInstance
 502      *        Proxy.newProxyInstance}{@code (mxbeanInterface.getClassLoader(),
 503      *        new Class[] { mxbeanInterface }, handler)}
 504      * &lt;/blockquote&gt;
 505      *
 506      * where {@code handler} is an {@link java.lang.reflect.InvocationHandler
 507      * InvocationHandler} to which method invocations to the MXBean interface
 508      * are dispatched. This {@code handler} converts an input parameter
 509      * from an MXBean data type to its mapped open type before forwarding
 510      * to the {@code MBeanServer} and converts a return value from
 511      * an MXBean method call through the {@code MBeanServer}
 512      * from an open type to the corresponding return type declared in
 513      * the MXBean interface.
 514      *
 515      * &lt;p&gt;
 516      * If the MXBean is a notification emitter (i.e.,
 517      * it implements
 518      * {@link javax.management.NotificationEmitter NotificationEmitter}),
 519      * both the {@code mxbeanInterface} and {@code NotificationEmitter}
 520      * will be implemented by this proxy.
 521      *
 522      * &lt;p&gt;
 523      * &lt;b&gt;Notes:&lt;/b&gt;
 524      * &lt;ol&gt;
 525      * &lt;li&gt;Using an MXBean proxy is a convenience remote access to
 526      * a platform MXBean of a running virtual machine.  All method
 527      * calls to the MXBean proxy are forwarded to an
 528      * {@code MBeanServerConnection} where
 529      * {@link java.io.IOException IOException} may be thrown
 530      * when the communication problem occurs with the connector server.
 531      * If thrown, {@link java.io.IOException IOException} will be wrappped in
 532      * {@link java.lang.reflect.UndeclaredThrowableException UndeclaredThrowableException}.
 533      * An application remotely accessing the platform MXBeans using
 534      * proxy should prepare to catch {@code UndeclaredThrowableException} and
 535      * handle its {@linkplain java.lang.reflect.UndeclaredThrowableException#getCause() cause}
 536      * as if that cause had been thrown by the {@code MBeanServerConnection}
 537      * interface.&lt;/li&gt;
 538      *
 539      * &lt;li&gt;When a client application is designed to remotely access MXBeans
 540      * for a running virtual machine whose version is different than
 541      * the version on which the application is running,
 542      * it should prepare to catch
 543      * {@link java.io.InvalidObjectException InvalidObjectException}
 544      * which is thrown when an MXBean proxy receives a name of an
 545      * enum constant which is missing in the enum class loaded in
 546      * the client application.   If thrown,
 547      * {@link java.io.InvalidObjectException InvalidObjectException} will be
 548      * wrappped in
 549      * {@link java.lang.reflect.UndeclaredThrowableException UndeclaredThrowableException}.
 550      * &lt;/li&gt;
 551      *
 552      * &lt;li&gt;{@link javax.management.MBeanServerInvocationHandler
 553      * MBeanServerInvocationHandler} or its
 554      * {@link javax.management.MBeanServerInvocationHandler#newProxyInstance
 555      * newProxyInstance} method cannot be used to create
 556      * a proxy for a platform MXBean. The proxy object created
 557      * by {@code MBeanServerInvocationHandler} does not handle
 558      * the properties of the platform MXBeans described in
 559      * the &lt;a href=&quot;#MXBean&quot;&gt;class specification&lt;/a&gt;.
 560      *&lt;/li&gt;
 561      * &lt;/ol&gt;
 562      *
 563      * @param connection the {@code MBeanServerConnection} to forward to.
 564      * @param mxbeanName the name of a platform MXBean within
 565      * {@code connection} to forward to. {@code mxbeanName} must be
 566      * in the format of {@link ObjectName ObjectName}.
 567      * @param mxbeanInterface the MXBean interface to be implemented
 568      * by the proxy.
 569      * @param &lt;T&gt; an {@code mxbeanInterface} type parameter
 570      *
 571      * @return a proxy for a platform MXBean interface of a
 572      * given &lt;a href=&quot;#MXBeanNames&quot;&gt;MXBean name&lt;/a&gt;
 573      * that forwards its method calls through the given
 574      * {@code MBeanServerConnection}, or {@code null} if not exist.
 575      *
 576      * @throws IllegalArgumentException if
 577      * &lt;ul&gt;
 578      * &lt;li&gt;{@code mxbeanName} is not with a valid
 579      *     {@link ObjectName ObjectName} format, or&lt;/li&gt;
 580      * &lt;li&gt;the named MXBean in the {@code connection} is
 581      *     not a MXBean provided by the platform, or&lt;/li&gt;
 582      * &lt;li&gt;the named MXBean is not registered in the
 583      *     {@code MBeanServerConnection}, or&lt;/li&gt;
 584      * &lt;li&gt;the named MXBean is not an instance of the given
 585      *     {@code mxbeanInterface}&lt;/li&gt;
 586      * &lt;/ul&gt;
 587      *
 588      * @throws java.io.IOException if a communication problem
 589      * occurred when accessing the {@code MBeanServerConnection}.
 590      */
 591     public static &lt;T&gt; T
 592         newPlatformMXBeanProxy(MBeanServerConnection connection,
 593                                String mxbeanName,
 594                                Class&lt;T&gt; mxbeanInterface)
 595             throws java.io.IOException {
 596 
 597         // Only allow MXBean interfaces from the platform modules loaded by the
 598         // bootstrap or platform class loader
 599         final Class&lt;?&gt; cls = mxbeanInterface;
 600         ClassLoader loader =
 601             AccessController.doPrivileged(
 602                 (PrivilegedAction&lt;ClassLoader&gt;) () -&gt; cls.getClassLoader());
 603         if (!jdk.internal.misc.VM.isSystemDomainLoader(loader)) {
 604             throw new IllegalArgumentException(mxbeanName +
 605                 &quot; is not a platform MXBean&quot;);
 606         }
 607 
 608         try {
 609             final ObjectName objName = new ObjectName(mxbeanName);
 610             String intfName = mxbeanInterface.getName();
 611             if (!isInstanceOf(connection, objName, intfName)) {
 612                 throw new IllegalArgumentException(mxbeanName +
 613                     &quot; is not an instance of &quot; + mxbeanInterface);
 614             }
 615 
 616             // check if the registered MBean is a notification emitter
 617             boolean emitter = connection.isInstanceOf(objName, NOTIF_EMITTER);
 618 
 619             // create an MXBean proxy
 620             return JMX.newMXBeanProxy(connection, objName, mxbeanInterface,
 621                                       emitter);
 622         } catch (InstanceNotFoundException|MalformedObjectNameException e) {
 623             throw new IllegalArgumentException(e);
 624         }
 625     }
 626 
 627     // This makes it possible to obtain an instance of LoggingMXBean
 628     // using newPlatformMXBeanProxy(mbs, on, LoggingMXBean.class)
 629     // even though the underlying MXBean no longer implements
 630     // java.util.logging.LoggingMXBean.
 631     // Altough java.util.logging.LoggingMXBean is deprecated, an application
 632     // that uses newPlatformMXBeanProxy(mbs, on, LoggingMXBean.class) will
 633     // continue to work.
 634     //
 635     private static boolean isInstanceOf(MBeanServerConnection connection,
 636             ObjectName objName, String intfName)
 637             throws InstanceNotFoundException, IOException
 638     {
 639         // special case for java.util.logging.LoggingMXBean.
 640         // java.util.logging.LoggingMXBean is deprecated and
 641         // replaced with java.lang.management.PlatformLoggingMXBean,
 642         // so we will consider that any MBean implementing
 643         // java.lang.management.PlatformLoggingMXBean also implements
 644         // java.util.logging.LoggingMXBean.
 645         if (&quot;java.util.logging.LoggingMXBean&quot;.equals(intfName)) {
 646             if (connection.isInstanceOf(objName,
 647                     PlatformLoggingMXBean.class.getName())) {
 648                 return true;
 649             }
 650         }
 651         return connection.isInstanceOf(objName, intfName);
 652     }
 653 
 654     /**
 655      * Returns the platform MXBean implementing
 656      * the given {@code mxbeanInterface} which is specified
 657      * to have one single instance in the Java virtual machine.
 658      * This method may return {@code null} if the management interface
 659      * is not implemented in the Java virtual machine (for example,
 660      * a Java virtual machine with no compilation system does not
 661      * implement {@link CompilationMXBean});
 662      * otherwise, this method is equivalent to calling:
 663      * &lt;pre&gt;
 664      *    {@link #getPlatformMXBeans(Class)
 665      *      getPlatformMXBeans(mxbeanInterface)}.get(0);
 666      * &lt;/pre&gt;
 667      *
 668      * @param mxbeanInterface a management interface for a platform
 669      *     MXBean with one single instance in the Java virtual machine
 670      *     if implemented.
 671      * @param &lt;T&gt; an {@code mxbeanInterface} type parameter
 672      *
 673      * @return the platform MXBean that implements
 674      * {@code mxbeanInterface}, or {@code null} if not exist.
 675      *
 676      * @throws IllegalArgumentException if {@code mxbeanInterface}
 677      * is not a platform management interface or
 678      * not a singleton platform MXBean.
 679      *
 680      * @since 1.7
 681      */
 682     public static &lt;T extends PlatformManagedObject&gt;
 683             T getPlatformMXBean(Class&lt;T&gt; mxbeanInterface) {
 684         PlatformComponent&lt;?&gt; pc = PlatformMBeanFinder.findSingleton(mxbeanInterface);
 685 
 686         List&lt;? extends T&gt; mbeans = pc.getMBeans(mxbeanInterface);
 687         assert mbeans.isEmpty() || mbeans.size() == 1;
 688         return mbeans.isEmpty() ? null : mbeans.get(0);
 689     }
 690 
 691     /**
 692      * Returns the list of platform MXBeans implementing
 693      * the given {@code mxbeanInterface} in the Java
 694      * virtual machine.
 695      * The returned list may contain zero, one, or more instances.
 696      * The number of instances in the returned list is defined
 697      * in the specification of the given management interface.
 698      * The order is undefined and there is no guarantee that
 699      * the list returned is in the same order as previous invocations.
 700      *
 701      * @param mxbeanInterface a management interface for a platform
 702      *                        MXBean
 703      * @param &lt;T&gt; an {@code mxbeanInterface} type parameter
 704      *
 705      * @return the list of platform MXBeans that implement
 706      * {@code mxbeanInterface}.
 707      *
 708      * @throws IllegalArgumentException if {@code mxbeanInterface}
 709      * is not a platform management interface.
 710      *
 711      * @since 1.7
 712      */
 713     public static &lt;T extends PlatformManagedObject&gt; List&lt;T&gt;
 714             getPlatformMXBeans(Class&lt;T&gt; mxbeanInterface) {
 715         // Validates at first the specified interface by finding at least one
 716         // PlatformComponent whose MXBean implements this interface.
 717         // An interface can be implemented by different MBeans, provided by
 718         // different platform components.
 719         PlatformComponent&lt;?&gt; pc = PlatformMBeanFinder.findFirst(mxbeanInterface);
 720         if (pc == null) {
 721             throw new IllegalArgumentException(mxbeanInterface.getName()
 722                     + &quot; is not a platform management interface&quot;);
 723         }
 724 
 725         return platformComponents().stream()
 726                 .flatMap(p -&gt; p.getMBeans(mxbeanInterface).stream())
 727                 .collect(Collectors.toList());
 728     }
 729 
 730     /**
 731      * Returns the platform MXBean proxy for
 732      * {@code mxbeanInterface} which is specified to have one single
 733      * instance in a Java virtual machine and the proxy will
 734      * forward the method calls through the given {@code MBeanServerConnection}.
 735      * This method may return {@code null} if the management interface
 736      * is not implemented in the Java virtual machine being monitored
 737      * (for example, a Java virtual machine with no compilation system
 738      * does not implement {@link CompilationMXBean});
 739      * otherwise, this method is equivalent to calling:
 740      * &lt;pre&gt;
 741      *     {@link #getPlatformMXBeans(MBeanServerConnection, Class)
 742      *        getPlatformMXBeans(connection, mxbeanInterface)}.get(0);
 743      * &lt;/pre&gt;
 744      *
 745      * @param connection the {@code MBeanServerConnection} to forward to.
 746      * @param mxbeanInterface a management interface for a platform
 747      *     MXBean with one single instance in the Java virtual machine
 748      *     being monitored, if implemented.
 749      * @param &lt;T&gt; an {@code mxbeanInterface} type parameter
 750      *
 751      * @return the platform MXBean proxy for
 752      * forwarding the method calls of the {@code mxbeanInterface}
 753      * through the given {@code MBeanServerConnection},
 754      * or {@code null} if not exist.
 755      *
 756      * @throws IllegalArgumentException if {@code mxbeanInterface}
 757      * is not a platform management interface or
 758      * not a singleton platform MXBean.
 759      * @throws java.io.IOException if a communication problem
 760      * occurred when accessing the {@code MBeanServerConnection}.
 761      *
 762      * @see #newPlatformMXBeanProxy
 763      * @since 1.7
 764      */
 765     public static &lt;T extends PlatformManagedObject&gt;
 766             T getPlatformMXBean(MBeanServerConnection connection,
 767                                 Class&lt;T&gt; mxbeanInterface)
 768         throws java.io.IOException
 769     {
 770         PlatformComponent&lt;?&gt; pc = PlatformMBeanFinder.findSingleton(mxbeanInterface);
 771         return newPlatformMXBeanProxy(connection, pc.getObjectNamePattern(), mxbeanInterface);
 772     }
 773 
 774     /**
 775      * Returns the list of the platform MXBean proxies for
 776      * forwarding the method calls of the {@code mxbeanInterface}
 777      * through the given {@code MBeanServerConnection}.
 778      * The returned list may contain zero, one, or more instances.
 779      * The number of instances in the returned list is defined
 780      * in the specification of the given management interface.
 781      * The order is undefined and there is no guarantee that
 782      * the list returned is in the same order as previous invocations.
 783      *
 784      * @param connection the {@code MBeanServerConnection} to forward to.
 785      * @param mxbeanInterface a management interface for a platform
 786      *                        MXBean
 787      * @param &lt;T&gt; an {@code mxbeanInterface} type parameter
 788      *
 789      * @return the list of platform MXBean proxies for
 790      * forwarding the method calls of the {@code mxbeanInterface}
 791      * through the given {@code MBeanServerConnection}.
 792      *
 793      * @throws IllegalArgumentException if {@code mxbeanInterface}
 794      * is not a platform management interface.
 795      *
 796      * @throws java.io.IOException if a communication problem
 797      * occurred when accessing the {@code MBeanServerConnection}.
 798      *
 799      * @see #newPlatformMXBeanProxy
 800      * @since 1.7
 801      */
 802     public static &lt;T extends PlatformManagedObject&gt;
 803             List&lt;T&gt; getPlatformMXBeans(MBeanServerConnection connection,
 804                                        Class&lt;T&gt; mxbeanInterface)
 805         throws java.io.IOException
 806     {
 807         // Validates at first the specified interface by finding at least one
 808         // PlatformComponent whose MXBean implements this interface.
 809         // An interface can be implemented by different MBeans, provided by
 810         // different platform components.
 811         PlatformComponent&lt;?&gt; pc = PlatformMBeanFinder.findFirst(mxbeanInterface);
 812         if (pc == null) {
 813             throw new IllegalArgumentException(mxbeanInterface.getName()
 814                     + &quot; is not a platform management interface&quot;);
 815         }
 816 
 817         // Collect all names, eliminate duplicates.
 818         Stream&lt;String&gt; names = Stream.empty();
 819         for (PlatformComponent&lt;?&gt; p : platformComponents()) {
 820             names = Stream.concat(names, getProxyNames(p, connection, mxbeanInterface));
 821         }
 822         Set&lt;String&gt; objectNames = names.collect(Collectors.toSet());
 823         if (objectNames.isEmpty()) return Collections.emptyList();
 824 
 825         // Map names on proxies.
 826         List&lt;T&gt; proxies = new ArrayList&lt;&gt;();
 827         for (String name : objectNames) {
 828             proxies.add(newPlatformMXBeanProxy(connection, name, mxbeanInterface));
 829         }
 830         return proxies;
 831     }
 832 
 833     // Returns a stream containing all ObjectNames of the MBeans represented by
 834     // the specified PlatformComponent and implementing the specified interface.
 835     // If the PlatformComponent is a singleton, the name returned by
 836     // PlatformComponent.getObjectNamePattern() will be used, otherwise
 837     // we will query the specified MBeanServerConnection (conn.queryNames)
 838     // with the pattern returned by PlatformComponent.getObjectNamePattern()
 839     // in order to find the names of matching MBeans.
 840     // In case of singleton, we do not check whether the MBean is registered
 841     // in the connection because the caller &quot;getPlatformMXBeans&quot; will do the check
 842     // when creating a proxy.
 843     private static Stream&lt;String&gt; getProxyNames(PlatformComponent&lt;?&gt; pc,
 844                                                 MBeanServerConnection conn,
 845                                                 Class&lt;?&gt; intf)
 846             throws IOException
 847     {
 848         if (pc.mbeanInterfaceNames().contains(intf.getName())) {
 849             if (pc.isSingleton()) {
 850                 return Stream.of(pc.getObjectNamePattern());
 851             } else {
 852                 return conn.queryNames(Util.newObjectName(pc.getObjectNamePattern()), null)
 853                         .stream().map(ObjectName::getCanonicalName);
 854             }
 855         }
 856         return Stream.empty();
 857     }
 858 
 859     /**
 860      * Returns the set of {@code Class} objects, subinterface of
 861      * {@link PlatformManagedObject}, representing
 862      * all management interfaces for
 863      * monitoring and managing the Java platform.
 864      *
 865      * @return the set of {@code Class} objects, subinterface of
 866      * {@link PlatformManagedObject} representing
 867      * the management interfaces for
 868      * monitoring and managing the Java platform.
 869      *
 870      * @since 1.7
 871      */
 872     public static Set&lt;Class&lt;? extends PlatformManagedObject&gt;&gt;
 873            getPlatformManagementInterfaces()
 874     {
 875         return platformComponents()
 876                 .stream()
 877                 .flatMap(pc -&gt; pc.mbeanInterfaces().stream())
 878                 .filter(clazz -&gt; PlatformManagedObject.class.isAssignableFrom(clazz))
 879                 .map(clazz -&gt; clazz.asSubclass(PlatformManagedObject.class))
 880                 .collect(Collectors.toSet());
 881     }
 882 
 883     private static final String NOTIF_EMITTER =
 884         &quot;javax.management.NotificationEmitter&quot;;
 885 
 886     private static void addMXBean(final MBeanServer mbs, String name, final Object pmo)
 887     {
 888         try {
 889             ObjectName oname = ObjectName.getInstance(name);
 890             // Make DynamicMBean out of MXBean by wrapping it with a StandardMBean
 891             AccessController.doPrivileged((PrivilegedExceptionAction&lt;Void&gt;) () -&gt; {
 892                 final DynamicMBean dmbean;
 893                 if (pmo instanceof DynamicMBean) {
 894                     dmbean = DynamicMBean.class.cast(pmo);
 895                 } else if (pmo instanceof NotificationEmitter) {
 896                     dmbean = new StandardEmitterMBean(pmo, null, true, (NotificationEmitter) pmo);
 897                 } else {
 898                     dmbean = new StandardMBean(pmo, null, true);
 899                 }
 900 
 901                 mbs.registerMBean(dmbean, oname);
 902                 return null;
 903             });
 904         } catch (MalformedObjectNameException mone) {
 905             throw new IllegalArgumentException(mone);
 906         } catch (PrivilegedActionException e) {
 907             throw new RuntimeException(e.getException());
 908         }
 909     }
 910 
 911     private static Collection&lt;PlatformComponent&lt;?&gt;&gt; platformComponents()
 912     {
 913         return PlatformMBeanFinder.getMap().values();
 914     }
 915 
 916     private static class PlatformMBeanFinder
 917     {
 918         private static final Map&lt;String, PlatformComponent&lt;?&gt;&gt; componentMap;
 919         static {
 920             // get all providers
 921             List&lt;PlatformMBeanProvider&gt; providers = AccessController.doPrivileged(
 922                 (PrivilegedAction&lt;List&lt;PlatformMBeanProvider&gt;&gt;) () -&gt; {
 923                      List&lt;PlatformMBeanProvider&gt; all = new ArrayList&lt;&gt;();
 924                      ServiceLoader.loadInstalled(PlatformMBeanProvider.class)
 925                                   .forEach(all::add);
 926                      all.add(new DefaultPlatformMBeanProvider());
 927                      return all;
 928                 }, null, new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;),
 929                          new RuntimePermission(&quot;sun.management.spi.PlatformMBeanProvider.subclass&quot;));
 930 
 931             // load all platform components into a map
 932             componentMap = providers.stream()
 933                 .flatMap(p -&gt; toPlatformComponentStream(p))
 934                 // The first one wins if multiple PlatformComponents
 935                 // with same ObjectName pattern,
 936                 .collect(toMap(PlatformComponent::getObjectNamePattern,
 937                                Function.identity(),
 938                               (p1, p2) -&gt; p1));
 939         }
 940 
 941         static Map&lt;String, PlatformComponent&lt;?&gt;&gt; getMap() {
 942             return componentMap;
 943         }
 944 
 945         // Loads all platform components from a provider into a stream
 946         // Ensures that two different components are not declared with the same
 947         // object name pattern. Throws InternalError if the provider incorrectly
 948         // declares two platform components with the same pattern.
 949         private static Stream&lt;PlatformComponent&lt;?&gt;&gt;
 950             toPlatformComponentStream(PlatformMBeanProvider provider)
 951         {
 952             return provider.getPlatformComponentList()
 953                            .stream()
 954                            .collect(toMap(PlatformComponent::getObjectNamePattern,
 955                                           Function.identity(),
 956                                           (p1, p2) -&gt; {
 957                                               throw new InternalError(
 958                                                  p1.getObjectNamePattern() +
 959                                                  &quot; has been used as key for &quot; + p1 +
 960                                                  &quot;, it cannot be reused for &quot; + p2);
 961                                           }))
 962                            .values().stream();
 963         }
 964 
 965         // Finds the first PlatformComponent whose mbeanInterfaceNames() list
 966         // contains the specified class name. An MBean interface can be implemented
 967         // by different MBeans, provided by different platform components.
 968         // For instance the MemoryManagerMXBean interface is implemented both by
 969         // regular memory managers, and garbage collector MXBeans. This method is
 970         // mainly used to verify that there is at least one PlatformComponent
 971         // which provides an implementation of the desired interface.
 972         static PlatformComponent&lt;?&gt; findFirst(Class&lt;?&gt; mbeanIntf)
 973         {
 974             String name = mbeanIntf.getName();
 975             Optional&lt;PlatformComponent&lt;?&gt;&gt; op = getMap().values()
 976                 .stream()
 977                 .filter(pc -&gt; pc.mbeanInterfaceNames().contains(name))
 978                 .findFirst();
 979 
 980             if (op.isPresent()) {
 981                 return op.get();
 982             } else {
 983                 return null;
 984             }
 985         }
 986 
 987         // Finds a PlatformComponent whose mbeanInterface name list contains
 988         // the specified class name, and make sure that one and only one exists.
 989         static PlatformComponent&lt;?&gt; findSingleton(Class&lt;?&gt; mbeanIntf)
 990         {
 991             String name = mbeanIntf.getName();
 992             Optional&lt;PlatformComponent&lt;?&gt;&gt; op = getMap().values()
 993                 .stream()
 994                 .filter(pc -&gt; pc.mbeanInterfaceNames().contains(name))
 995                 .reduce((p1, p2) -&gt; {
 996                     if (p2 != null) {
 997                         throw new IllegalArgumentException(mbeanIntf.getName() +
 998                             &quot; can have more than one instance&quot;);
 999                     } else {
1000                         return p1;
1001                     }
1002                 });
1003 
1004             PlatformComponent&lt;?&gt; singleton = op.isPresent() ? op.get() : null;
1005             if (singleton == null) {
1006                 throw new IllegalArgumentException(mbeanIntf.getName() +
1007                     &quot; is not a platform management interface&quot;);
1008             }
1009             if (!singleton.isSingleton()) {
1010                 throw new IllegalArgumentException(mbeanIntf.getName() +
1011                     &quot; can have more than one instance&quot;);
1012             }
1013             return singleton;
1014         }
1015     }
1016 
1017     static {
1018         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
1019             System.loadLibrary(&quot;management&quot;);
1020             return null;
1021         });
1022     }
1023 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.management/share/classes/java/lang/management/MemoryMXBean.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ManagementFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemoryPoolMXBean.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.management/share/classes/java/lang/management/MemoryMXBean.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 32  * the Java virtual machine.
 33  *
 34  * &lt;p&gt; A Java virtual machine has a single instance of the implementation
 35  * class of this interface.  This instance implementing this interface is
 36  * an &lt;a href=&quot;ManagementFactory.html#MXBean&quot;&gt;MXBean&lt;/a&gt;
 37  * that can be obtained by calling
 38  * the {@link ManagementFactory#getMemoryMXBean} method or
 39  * from the {@link ManagementFactory#getPlatformMBeanServer
 40  * platform MBeanServer} method.
 41  *
 42  * &lt;p&gt;The {@code ObjectName} for uniquely identifying the MXBean for
 43  * the memory system within an MBeanServer is:
 44  * &lt;blockquote&gt;
 45  *    {@link ManagementFactory#MEMORY_MXBEAN_NAME
 46  *           java.lang:type=Memory}
 47  * &lt;/blockquote&gt;
 48  *
 49  * It can be obtained by calling the
 50  * {@link PlatformManagedObject#getObjectName} method.
 51  *
<span class="line-modified"> 52  * &lt;h3&gt; Memory &lt;/h3&gt;</span>
 53  * The memory system of the Java virtual machine manages
 54  * the following kinds of memory:
 55  *
 56  * &lt;h3&gt; 1. Heap &lt;/h3&gt;
 57  * The Java virtual machine has a &lt;i&gt;heap&lt;/i&gt; that is the runtime
 58  * data area from which memory for all class instances and arrays
 59  * are allocated.  It is created at the Java virtual machine start-up.
 60  * Heap memory for objects is reclaimed by an automatic memory management
 61  * system which is known as a &lt;i&gt;garbage collector&lt;/i&gt;.
 62  *
 63  * &lt;p&gt;The heap may be of a fixed size or may be expanded and shrunk.
 64  * The memory for the heap does not need to be contiguous.
 65  *
 66  * &lt;h3&gt; 2. Non-Heap Memory&lt;/h3&gt;
 67  * The Java virtual machine manages memory other than the heap
 68  * (referred as &lt;i&gt;non-heap memory&lt;/i&gt;).
 69  *
 70  * &lt;p&gt; The Java virtual machine has a &lt;i&gt;method area&lt;/i&gt; that is shared
 71  * among all threads.
 72  * The method area belongs to non-heap memory.  It stores per-class structures
 73  * such as a runtime constant pool, field and method data, and the code for
 74  * methods and constructors.  It is created at the Java virtual machine
 75  * start-up.
 76  *
 77  * &lt;p&gt; The method area is logically part of the heap but a Java virtual
 78  * machine implementation may choose not to either garbage collect
 79  * or compact it.  Similar to the heap, the method area may be of a
 80  * fixed size or may be expanded and shrunk.  The memory for the
 81  * method area does not need to be contiguous.
 82  *
 83  * &lt;p&gt;In addition to the method area, a Java virtual machine
 84  * implementation may require memory for internal processing or
 85  * optimization which also belongs to non-heap memory.
 86  * For example, the JIT compiler requires memory for storing the native
 87  * machine code translated from the Java virtual machine code for
 88  * high performance.
 89  *
<span class="line-modified"> 90  * &lt;h3&gt;Memory Pools and Memory Managers&lt;/h3&gt;</span>
 91  * {@link MemoryPoolMXBean Memory pools} and
 92  * {@link MemoryManagerMXBean memory managers} are the abstract entities
 93  * that monitor and manage the memory system
 94  * of the Java virtual machine.
 95  *
 96  * &lt;p&gt;A memory pool represents a memory area that the Java virtual machine
 97  * manages.  The Java virtual machine has at least one memory pool
 98  * and it may create or remove memory pools during execution.
 99  * A memory pool can belong to either the heap or the non-heap memory.
100  *
101  * &lt;p&gt;A memory manager is responsible for managing one or more memory pools.
102  * The garbage collector is one type of memory manager responsible
103  * for reclaiming memory occupied by unreachable objects.  A Java virtual
104  * machine may have one or more memory managers.   It may
105  * add or remove memory managers during execution.
106  * A memory pool can be managed by more than one memory manager.
107  *
<span class="line-modified">108  * &lt;h3&gt;Memory Usage Monitoring&lt;/h3&gt;</span>
109  *
110  * Memory usage is a very important monitoring attribute for the memory system.
111  * The memory usage, for example, could indicate:
112  * &lt;ul&gt;
113  *   &lt;li&gt;the memory usage of an application,&lt;/li&gt;
114  *   &lt;li&gt;the workload being imposed on the automatic memory management system,&lt;/li&gt;
115  *   &lt;li&gt;potential memory leakage.&lt;/li&gt;
116  * &lt;/ul&gt;
117  *
118  * &lt;p&gt;
119  * The memory usage can be monitored in three ways:
120  * &lt;ul&gt;
121  *   &lt;li&gt;Polling&lt;/li&gt;
122  *   &lt;li&gt;Usage Threshold Notification&lt;/li&gt;
123  *   &lt;li&gt;Collection Usage Threshold Notification&lt;/li&gt;
124  * &lt;/ul&gt;
125  *
126  * Details are specified in the {@link MemoryPoolMXBean} interface.
127  *
128  * &lt;p&gt;The memory usage monitoring mechanism is intended for load-balancing
129  * or workload distribution use.  For example, an application would stop
130  * receiving any new workload when its memory usage exceeds a
131  * certain threshold. It is not intended for an application to detect
132  * and recover from a low memory condition.
133  *
<span class="line-modified">134  * &lt;h3&gt;Notifications&lt;/h3&gt;</span>
135  *
136  * &lt;p&gt;This {@code MemoryMXBean} is a
137  * {@link javax.management.NotificationEmitter NotificationEmitter}
138  * that emits two types of memory {@link javax.management.Notification
139  * notifications} if any one of the memory pools
140  * supports a &lt;a href=&quot;MemoryPoolMXBean.html#UsageThreshold&quot;&gt;usage threshold&lt;/a&gt;
141  * or a &lt;a href=&quot;MemoryPoolMXBean.html#CollectionThreshold&quot;&gt;collection usage
142  * threshold&lt;/a&gt; which can be determined by calling the
143  * {@link MemoryPoolMXBean#isUsageThresholdSupported} and
144  * {@link MemoryPoolMXBean#isCollectionUsageThresholdSupported} methods.
145  * &lt;ul&gt;
146  *   &lt;li&gt;{@link MemoryNotificationInfo#MEMORY_THRESHOLD_EXCEEDED
147  *       usage threshold exceeded notification} - for notifying that
148  *       the memory usage of a memory pool is increased and has reached
149  *       or exceeded its
150  *       &lt;a href=&quot;MemoryPoolMXBean.html#UsageThreshold&quot;&gt; usage threshold&lt;/a&gt; value.
151  *       &lt;/li&gt;
152  *   &lt;li&gt;{@link MemoryNotificationInfo#MEMORY_COLLECTION_THRESHOLD_EXCEEDED
153  *       collection usage threshold exceeded notification} - for notifying that
154  *       the memory usage of a memory pool is greater than or equal to its
155  *       &lt;a href=&quot;MemoryPoolMXBean.html#CollectionThreshold&quot;&gt;
156  *       collection usage threshold&lt;/a&gt; after the Java virtual machine
157  *       has expended effort in recycling unused objects in that
158  *       memory pool.&lt;/li&gt;
159  * &lt;/ul&gt;
160  *
161  * &lt;p&gt;
162  * The notification emitted is a {@link javax.management.Notification}
163  * instance whose {@link javax.management.Notification#setUserData
164  * user data} is set to a {@link CompositeData CompositeData}
165  * that represents a {@link MemoryNotificationInfo} object
166  * containing information about the memory pool when the notification
167  * was constructed. The {@code CompositeData} contains the attributes
168  * as described in {@link MemoryNotificationInfo#from
169  * MemoryNotificationInfo}.
170  *
171  * &lt;hr&gt;
<span class="line-modified">172  * &lt;h3&gt;NotificationEmitter&lt;/h3&gt;</span>
173  * The {@code MemoryMXBean} object returned by
174  * {@link ManagementFactory#getMemoryMXBean} implements
175  * the {@link javax.management.NotificationEmitter NotificationEmitter}
176  * interface that allows a listener to be registered within the
177  * {@code MemoryMXBean} as a notification listener.
178  *
179  * Below is an example code that registers a {@code MyListener} to handle
180  * notification emitted by the {@code MemoryMXBean}.
181  *
182  * &lt;blockquote&gt;&lt;pre&gt;
183  * class MyListener implements javax.management.NotificationListener {
184  *     public void handleNotification(Notification notif, Object handback) {
185  *         // handle notification
186  *         ....
187  *     }
188  * }
189  *
190  * MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();
191  * NotificationEmitter emitter = (NotificationEmitter) mbean;
192  * MyListener listener = new MyListener();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 32  * the Java virtual machine.
 33  *
 34  * &lt;p&gt; A Java virtual machine has a single instance of the implementation
 35  * class of this interface.  This instance implementing this interface is
 36  * an &lt;a href=&quot;ManagementFactory.html#MXBean&quot;&gt;MXBean&lt;/a&gt;
 37  * that can be obtained by calling
 38  * the {@link ManagementFactory#getMemoryMXBean} method or
 39  * from the {@link ManagementFactory#getPlatformMBeanServer
 40  * platform MBeanServer} method.
 41  *
 42  * &lt;p&gt;The {@code ObjectName} for uniquely identifying the MXBean for
 43  * the memory system within an MBeanServer is:
 44  * &lt;blockquote&gt;
 45  *    {@link ManagementFactory#MEMORY_MXBEAN_NAME
 46  *           java.lang:type=Memory}
 47  * &lt;/blockquote&gt;
 48  *
 49  * It can be obtained by calling the
 50  * {@link PlatformManagedObject#getObjectName} method.
 51  *
<span class="line-modified"> 52  * &lt;h2&gt; Memory &lt;/h2&gt;</span>
 53  * The memory system of the Java virtual machine manages
 54  * the following kinds of memory:
 55  *
 56  * &lt;h3&gt; 1. Heap &lt;/h3&gt;
 57  * The Java virtual machine has a &lt;i&gt;heap&lt;/i&gt; that is the runtime
 58  * data area from which memory for all class instances and arrays
 59  * are allocated.  It is created at the Java virtual machine start-up.
 60  * Heap memory for objects is reclaimed by an automatic memory management
 61  * system which is known as a &lt;i&gt;garbage collector&lt;/i&gt;.
 62  *
 63  * &lt;p&gt;The heap may be of a fixed size or may be expanded and shrunk.
 64  * The memory for the heap does not need to be contiguous.
 65  *
 66  * &lt;h3&gt; 2. Non-Heap Memory&lt;/h3&gt;
 67  * The Java virtual machine manages memory other than the heap
 68  * (referred as &lt;i&gt;non-heap memory&lt;/i&gt;).
 69  *
 70  * &lt;p&gt; The Java virtual machine has a &lt;i&gt;method area&lt;/i&gt; that is shared
 71  * among all threads.
 72  * The method area belongs to non-heap memory.  It stores per-class structures
 73  * such as a runtime constant pool, field and method data, and the code for
 74  * methods and constructors.  It is created at the Java virtual machine
 75  * start-up.
 76  *
 77  * &lt;p&gt; The method area is logically part of the heap but a Java virtual
 78  * machine implementation may choose not to either garbage collect
 79  * or compact it.  Similar to the heap, the method area may be of a
 80  * fixed size or may be expanded and shrunk.  The memory for the
 81  * method area does not need to be contiguous.
 82  *
 83  * &lt;p&gt;In addition to the method area, a Java virtual machine
 84  * implementation may require memory for internal processing or
 85  * optimization which also belongs to non-heap memory.
 86  * For example, the JIT compiler requires memory for storing the native
 87  * machine code translated from the Java virtual machine code for
 88  * high performance.
 89  *
<span class="line-modified"> 90  * &lt;h2&gt;Memory Pools and Memory Managers&lt;/h2&gt;</span>
 91  * {@link MemoryPoolMXBean Memory pools} and
 92  * {@link MemoryManagerMXBean memory managers} are the abstract entities
 93  * that monitor and manage the memory system
 94  * of the Java virtual machine.
 95  *
 96  * &lt;p&gt;A memory pool represents a memory area that the Java virtual machine
 97  * manages.  The Java virtual machine has at least one memory pool
 98  * and it may create or remove memory pools during execution.
 99  * A memory pool can belong to either the heap or the non-heap memory.
100  *
101  * &lt;p&gt;A memory manager is responsible for managing one or more memory pools.
102  * The garbage collector is one type of memory manager responsible
103  * for reclaiming memory occupied by unreachable objects.  A Java virtual
104  * machine may have one or more memory managers.   It may
105  * add or remove memory managers during execution.
106  * A memory pool can be managed by more than one memory manager.
107  *
<span class="line-modified">108  * &lt;h2&gt;Memory Usage Monitoring&lt;/h2&gt;</span>
109  *
110  * Memory usage is a very important monitoring attribute for the memory system.
111  * The memory usage, for example, could indicate:
112  * &lt;ul&gt;
113  *   &lt;li&gt;the memory usage of an application,&lt;/li&gt;
114  *   &lt;li&gt;the workload being imposed on the automatic memory management system,&lt;/li&gt;
115  *   &lt;li&gt;potential memory leakage.&lt;/li&gt;
116  * &lt;/ul&gt;
117  *
118  * &lt;p&gt;
119  * The memory usage can be monitored in three ways:
120  * &lt;ul&gt;
121  *   &lt;li&gt;Polling&lt;/li&gt;
122  *   &lt;li&gt;Usage Threshold Notification&lt;/li&gt;
123  *   &lt;li&gt;Collection Usage Threshold Notification&lt;/li&gt;
124  * &lt;/ul&gt;
125  *
126  * Details are specified in the {@link MemoryPoolMXBean} interface.
127  *
128  * &lt;p&gt;The memory usage monitoring mechanism is intended for load-balancing
129  * or workload distribution use.  For example, an application would stop
130  * receiving any new workload when its memory usage exceeds a
131  * certain threshold. It is not intended for an application to detect
132  * and recover from a low memory condition.
133  *
<span class="line-modified">134  * &lt;h2&gt;Notifications&lt;/h2&gt;</span>
135  *
136  * &lt;p&gt;This {@code MemoryMXBean} is a
137  * {@link javax.management.NotificationEmitter NotificationEmitter}
138  * that emits two types of memory {@link javax.management.Notification
139  * notifications} if any one of the memory pools
140  * supports a &lt;a href=&quot;MemoryPoolMXBean.html#UsageThreshold&quot;&gt;usage threshold&lt;/a&gt;
141  * or a &lt;a href=&quot;MemoryPoolMXBean.html#CollectionThreshold&quot;&gt;collection usage
142  * threshold&lt;/a&gt; which can be determined by calling the
143  * {@link MemoryPoolMXBean#isUsageThresholdSupported} and
144  * {@link MemoryPoolMXBean#isCollectionUsageThresholdSupported} methods.
145  * &lt;ul&gt;
146  *   &lt;li&gt;{@link MemoryNotificationInfo#MEMORY_THRESHOLD_EXCEEDED
147  *       usage threshold exceeded notification} - for notifying that
148  *       the memory usage of a memory pool is increased and has reached
149  *       or exceeded its
150  *       &lt;a href=&quot;MemoryPoolMXBean.html#UsageThreshold&quot;&gt; usage threshold&lt;/a&gt; value.
151  *       &lt;/li&gt;
152  *   &lt;li&gt;{@link MemoryNotificationInfo#MEMORY_COLLECTION_THRESHOLD_EXCEEDED
153  *       collection usage threshold exceeded notification} - for notifying that
154  *       the memory usage of a memory pool is greater than or equal to its
155  *       &lt;a href=&quot;MemoryPoolMXBean.html#CollectionThreshold&quot;&gt;
156  *       collection usage threshold&lt;/a&gt; after the Java virtual machine
157  *       has expended effort in recycling unused objects in that
158  *       memory pool.&lt;/li&gt;
159  * &lt;/ul&gt;
160  *
161  * &lt;p&gt;
162  * The notification emitted is a {@link javax.management.Notification}
163  * instance whose {@link javax.management.Notification#setUserData
164  * user data} is set to a {@link CompositeData CompositeData}
165  * that represents a {@link MemoryNotificationInfo} object
166  * containing information about the memory pool when the notification
167  * was constructed. The {@code CompositeData} contains the attributes
168  * as described in {@link MemoryNotificationInfo#from
169  * MemoryNotificationInfo}.
170  *
171  * &lt;hr&gt;
<span class="line-modified">172  * &lt;h2&gt;NotificationEmitter&lt;/h2&gt;</span>
173  * The {@code MemoryMXBean} object returned by
174  * {@link ManagementFactory#getMemoryMXBean} implements
175  * the {@link javax.management.NotificationEmitter NotificationEmitter}
176  * interface that allows a listener to be registered within the
177  * {@code MemoryMXBean} as a notification listener.
178  *
179  * Below is an example code that registers a {@code MyListener} to handle
180  * notification emitted by the {@code MemoryMXBean}.
181  *
182  * &lt;blockquote&gt;&lt;pre&gt;
183  * class MyListener implements javax.management.NotificationListener {
184  *     public void handleNotification(Notification notif, Object handback) {
185  *         // handle notification
186  *         ....
187  *     }
188  * }
189  *
190  * MemoryMXBean mbean = ManagementFactory.getMemoryMXBean();
191  * NotificationEmitter emitter = (NotificationEmitter) mbean;
192  * MyListener listener = new MyListener();
</pre>
</td>
</tr>
</table>
<center><a href="ManagementFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemoryPoolMXBean.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
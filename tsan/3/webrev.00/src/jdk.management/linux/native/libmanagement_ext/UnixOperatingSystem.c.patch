diff a/src/jdk.management/linux/native/libmanagement_ext/UnixOperatingSystem.c b/src/jdk.management/linux/native/libmanagement_ext/UnixOperatingSystem.c
--- a/src/jdk.management/linux/native/libmanagement_ext/UnixOperatingSystem.c
+++ b/src/jdk.management/linux/native/libmanagement_ext/UnixOperatingSystem.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -36,10 +36,12 @@
 #include <dlfcn.h>
 #include <pthread.h>
 #include <inttypes.h>
 #include "com_sun_management_internal_OperatingSystemImpl.h"
 
+#include <assert.h>
+
 struct ticks {
     uint64_t  used;
     uint64_t  usedKernel;
     uint64_t  total;
 };
@@ -196,21 +198,23 @@
 
 /**
  * This method must be called first, before any data can be gathererd.
  */
 int perfInit() {
-    static int initialized=1;
+    static int initialized = 0;
 
     if (!initialized) {
         int  i;
-
-        int n = sysconf(_SC_NPROCESSORS_ONLN);
+        // We need to allocate counters for all CPUs, including ones that
+        // are currently offline as they could be turned online later.
+        int n = sysconf(_SC_NPROCESSORS_CONF);
         if (n <= 0) {
             n = 1;
         }
 
         counters.cpus = calloc(n,sizeof(ticks));
+        counters.nProcs = n;
         if (counters.cpus != NULL)  {
             // For the CPU load
             get_totalticks(-1, &counters.cpuTicks);
 
             for (i = 0; i < n; i++) {
@@ -246,11 +250,11 @@
 
     *pkernelLoad = 0.0;
 
     pthread_mutex_lock(&lock);
 
-    if(perfInit() == 0) {
+    if (perfInit() == 0) {
 
         if (target == CPU_LOAD_VM_ONLY) {
             pticks = &counters.jvmTicks;
         } else if (which == -1) {
             pticks = &counters.cpuTicks;
@@ -266,18 +270,14 @@
             }
         } else if (get_totalticks(which, pticks) < 0) {
             failed = 1;
         }
 
-        if(!failed) {
-            // seems like we sometimes end up with less kernel ticks when
-            // reading /proc/self/stat a second time, timing issue between cpus?
-            if (pticks->usedKernel < tmp.usedKernel) {
-                kdiff = 0;
-            } else {
-                kdiff = pticks->usedKernel - tmp.usedKernel;
-            }
+        if (!failed) {
+
+            assert(pticks->usedKernel >= tmp.usedKernel);
+            kdiff = pticks->usedKernel - tmp.usedKernel;
             tdiff = pticks->total - tmp.total;
             udiff = pticks->used - tmp.used;
 
             if (tdiff == 0) {
                 user_load = 0;
@@ -318,25 +318,47 @@
     }
     return u + s;
 }
 
 JNIEXPORT jdouble JNICALL
-Java_com_sun_management_internal_OperatingSystemImpl_getSystemCpuLoad0
+Java_com_sun_management_internal_OperatingSystemImpl_getCpuLoad0
 (JNIEnv *env, jobject dummy)
 {
-    if(perfInit() == 0) {
+    if (perfInit() == 0) {
         return get_cpu_load(-1);
     } else {
         return -1.0;
     }
 }
 
 JNIEXPORT jdouble JNICALL
 Java_com_sun_management_internal_OperatingSystemImpl_getProcessCpuLoad0
 (JNIEnv *env, jobject dummy)
 {
-    if(perfInit() == 0) {
+    if (perfInit() == 0) {
         return get_process_load();
     } else {
         return -1.0;
     }
 }
+
+JNIEXPORT jdouble JNICALL
+Java_com_sun_management_internal_OperatingSystemImpl_getSingleCpuLoad0
+(JNIEnv *env, jobject mbean, jint cpu_number)
+{
+    if (perfInit() == 0 && cpu_number >= 0 && cpu_number < counters.nProcs) {
+        return get_cpu_load(cpu_number);
+    } else {
+        return -1.0;
+    }
+}
+
+JNIEXPORT jint JNICALL
+Java_com_sun_management_internal_OperatingSystemImpl_getHostConfiguredCpuCount0
+(JNIEnv *env, jobject mbean)
+{
+    if (perfInit() == 0) {
+        return counters.nProcs;
+    } else {
+       return -1;
+    }
+}

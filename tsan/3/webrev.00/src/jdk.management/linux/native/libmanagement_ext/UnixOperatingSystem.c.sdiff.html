<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.management/linux/native/libmanagement_ext/UnixOperatingSystem.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../aix/native/libmanagement_ext/UnixOperatingSystem.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../macosx/native/libmanagement_ext/UnixOperatingSystem.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.management/linux/native/libmanagement_ext/UnixOperatingSystem.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;stdio.h&gt;
 27 #include &lt;stdint.h&gt;
 28 #include &lt;stdarg.h&gt;
 29 #include &lt;unistd.h&gt;
 30 #include &lt;errno.h&gt;
 31 #include &lt;string.h&gt;
 32 #include &lt;sys/resource.h&gt;
 33 #include &lt;sys/types.h&gt;
 34 #include &lt;dirent.h&gt;
 35 #include &lt;stdlib.h&gt;
 36 #include &lt;dlfcn.h&gt;
 37 #include &lt;pthread.h&gt;
 38 #include &lt;inttypes.h&gt;
 39 #include &quot;com_sun_management_internal_OperatingSystemImpl.h&quot;
 40 


 41 struct ticks {
 42     uint64_t  used;
 43     uint64_t  usedKernel;
 44     uint64_t  total;
 45 };
 46 
 47 typedef struct ticks ticks;
 48 
 49 typedef enum {
 50     CPU_LOAD_VM_ONLY,
 51     CPU_LOAD_GLOBAL,
 52 } CpuLoadTarget;
 53 
 54 static struct perfbuf {
 55     int   nProcs;
 56     ticks jvmTicks;
 57     ticks cpuTicks;
 58     ticks *cpus;
 59 } counters;
 60 
</pre>
<hr />
<pre>
181 
182     if (read_ticks(&quot;/proc/self/stat&quot;, &amp;userTicks, &amp;systemTicks) &lt; 0) {
183         return -1;
184     }
185 
186     // get the total
187     if (get_totalticks(-1, pticks) &lt; 0) {
188         return -1;
189     }
190 
191     pticks-&gt;used       = userTicks;
192     pticks-&gt;usedKernel = systemTicks;
193 
194     return 0;
195 }
196 
197 /**
198  * This method must be called first, before any data can be gathererd.
199  */
200 int perfInit() {
<span class="line-modified">201     static int initialized=1;</span>
202 
203     if (!initialized) {
204         int  i;
<span class="line-modified">205 </span>
<span class="line-modified">206         int n = sysconf(_SC_NPROCESSORS_ONLN);</span>

207         if (n &lt;= 0) {
208             n = 1;
209         }
210 
211         counters.cpus = calloc(n,sizeof(ticks));

212         if (counters.cpus != NULL)  {
213             // For the CPU load
214             get_totalticks(-1, &amp;counters.cpuTicks);
215 
216             for (i = 0; i &lt; n; i++) {
217                 get_totalticks(i, &amp;counters.cpus[i]);
218             }
219             // For JVM load
220             get_jvmticks(&amp;counters.jvmTicks);
221             initialized = 1;
222         }
223     }
224 
225     return initialized ? 0 : -1;
226 }
227 
228 #define MAX(a,b) (a&gt;b?a:b)
229 #define MIN(a,b) (a&lt;b?a:b)
230 
231 static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
232 
233 /**
234  * Return the load of the CPU as a double. 1.0 means the CPU process uses all
235  * available time for user or system processes, 0.0 means the CPU uses all time
236  * being idle.
237  *
238  * Returns a negative value if there is a problem in determining the CPU load.
239  */
240 
241 static double get_cpuload_internal(int which, double *pkernelLoad, CpuLoadTarget target) {
242     uint64_t udiff, kdiff, tdiff;
243     ticks *pticks, tmp;
244     double user_load = -1.0;
245     int failed = 0;
246 
247     *pkernelLoad = 0.0;
248 
249     pthread_mutex_lock(&amp;lock);
250 
<span class="line-modified">251     if(perfInit() == 0) {</span>
252 
253         if (target == CPU_LOAD_VM_ONLY) {
254             pticks = &amp;counters.jvmTicks;
255         } else if (which == -1) {
256             pticks = &amp;counters.cpuTicks;
257         } else {
258             pticks = &amp;counters.cpus[which];
259         }
260 
261         tmp = *pticks;
262 
263         if (target == CPU_LOAD_VM_ONLY) {
264             if (get_jvmticks(pticks) != 0) {
265                 failed = 1;
266             }
267         } else if (get_totalticks(which, pticks) &lt; 0) {
268             failed = 1;
269         }
270 
<span class="line-modified">271         if(!failed) {</span>
<span class="line-modified">272             // seems like we sometimes end up with less kernel ticks when</span>
<span class="line-modified">273             // reading /proc/self/stat a second time, timing issue between cpus?</span>
<span class="line-modified">274             if (pticks-&gt;usedKernel &lt; tmp.usedKernel) {</span>
<span class="line-removed">275                 kdiff = 0;</span>
<span class="line-removed">276             } else {</span>
<span class="line-removed">277                 kdiff = pticks-&gt;usedKernel - tmp.usedKernel;</span>
<span class="line-removed">278             }</span>
279             tdiff = pticks-&gt;total - tmp.total;
280             udiff = pticks-&gt;used - tmp.used;
281 
282             if (tdiff == 0) {
283                 user_load = 0;
284             } else {
285                 if (tdiff &lt; (udiff + kdiff)) {
286                     tdiff = udiff + kdiff;
287                 }
288                 *pkernelLoad = (kdiff / (double)tdiff);
289                 // BUG9044876, normalize return values to sane values
290                 *pkernelLoad = MAX(*pkernelLoad, 0.0);
291                 *pkernelLoad = MIN(*pkernelLoad, 1.0);
292 
293                 user_load = (udiff / (double)tdiff);
294                 user_load = MAX(user_load, 0.0);
295                 user_load = MIN(user_load, 1.0);
296             }
297         }
298     }
</pre>
<hr />
<pre>
303 double get_cpu_load(int which) {
304     double u, s;
305     u = get_cpuload_internal(which, &amp;s, CPU_LOAD_GLOBAL);
306     if (u &lt; 0) {
307         return -1.0;
308     }
309     // Cap total systemload to 1.0
310     return MIN((u + s), 1.0);
311 }
312 
313 double get_process_load() {
314     double u, s;
315     u = get_cpuload_internal(-1, &amp;s, CPU_LOAD_VM_ONLY);
316     if (u &lt; 0) {
317         return -1.0;
318     }
319     return u + s;
320 }
321 
322 JNIEXPORT jdouble JNICALL
<span class="line-modified">323 Java_com_sun_management_internal_OperatingSystemImpl_getSystemCpuLoad0</span>
324 (JNIEnv *env, jobject dummy)
325 {
<span class="line-modified">326     if(perfInit() == 0) {</span>
327         return get_cpu_load(-1);
328     } else {
329         return -1.0;
330     }
331 }
332 
333 JNIEXPORT jdouble JNICALL
334 Java_com_sun_management_internal_OperatingSystemImpl_getProcessCpuLoad0
335 (JNIEnv *env, jobject dummy)
336 {
<span class="line-modified">337     if(perfInit() == 0) {</span>
338         return get_process_load();
339     } else {
340         return -1.0;
341     }
342 }






















</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;stdio.h&gt;
 27 #include &lt;stdint.h&gt;
 28 #include &lt;stdarg.h&gt;
 29 #include &lt;unistd.h&gt;
 30 #include &lt;errno.h&gt;
 31 #include &lt;string.h&gt;
 32 #include &lt;sys/resource.h&gt;
 33 #include &lt;sys/types.h&gt;
 34 #include &lt;dirent.h&gt;
 35 #include &lt;stdlib.h&gt;
 36 #include &lt;dlfcn.h&gt;
 37 #include &lt;pthread.h&gt;
 38 #include &lt;inttypes.h&gt;
 39 #include &quot;com_sun_management_internal_OperatingSystemImpl.h&quot;
 40 
<span class="line-added"> 41 #include &lt;assert.h&gt;</span>
<span class="line-added"> 42 </span>
 43 struct ticks {
 44     uint64_t  used;
 45     uint64_t  usedKernel;
 46     uint64_t  total;
 47 };
 48 
 49 typedef struct ticks ticks;
 50 
 51 typedef enum {
 52     CPU_LOAD_VM_ONLY,
 53     CPU_LOAD_GLOBAL,
 54 } CpuLoadTarget;
 55 
 56 static struct perfbuf {
 57     int   nProcs;
 58     ticks jvmTicks;
 59     ticks cpuTicks;
 60     ticks *cpus;
 61 } counters;
 62 
</pre>
<hr />
<pre>
183 
184     if (read_ticks(&quot;/proc/self/stat&quot;, &amp;userTicks, &amp;systemTicks) &lt; 0) {
185         return -1;
186     }
187 
188     // get the total
189     if (get_totalticks(-1, pticks) &lt; 0) {
190         return -1;
191     }
192 
193     pticks-&gt;used       = userTicks;
194     pticks-&gt;usedKernel = systemTicks;
195 
196     return 0;
197 }
198 
199 /**
200  * This method must be called first, before any data can be gathererd.
201  */
202 int perfInit() {
<span class="line-modified">203     static int initialized = 0;</span>
204 
205     if (!initialized) {
206         int  i;
<span class="line-modified">207         // We need to allocate counters for all CPUs, including ones that</span>
<span class="line-modified">208         // are currently offline as they could be turned online later.</span>
<span class="line-added">209         int n = sysconf(_SC_NPROCESSORS_CONF);</span>
210         if (n &lt;= 0) {
211             n = 1;
212         }
213 
214         counters.cpus = calloc(n,sizeof(ticks));
<span class="line-added">215         counters.nProcs = n;</span>
216         if (counters.cpus != NULL)  {
217             // For the CPU load
218             get_totalticks(-1, &amp;counters.cpuTicks);
219 
220             for (i = 0; i &lt; n; i++) {
221                 get_totalticks(i, &amp;counters.cpus[i]);
222             }
223             // For JVM load
224             get_jvmticks(&amp;counters.jvmTicks);
225             initialized = 1;
226         }
227     }
228 
229     return initialized ? 0 : -1;
230 }
231 
232 #define MAX(a,b) (a&gt;b?a:b)
233 #define MIN(a,b) (a&lt;b?a:b)
234 
235 static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
236 
237 /**
238  * Return the load of the CPU as a double. 1.0 means the CPU process uses all
239  * available time for user or system processes, 0.0 means the CPU uses all time
240  * being idle.
241  *
242  * Returns a negative value if there is a problem in determining the CPU load.
243  */
244 
245 static double get_cpuload_internal(int which, double *pkernelLoad, CpuLoadTarget target) {
246     uint64_t udiff, kdiff, tdiff;
247     ticks *pticks, tmp;
248     double user_load = -1.0;
249     int failed = 0;
250 
251     *pkernelLoad = 0.0;
252 
253     pthread_mutex_lock(&amp;lock);
254 
<span class="line-modified">255     if (perfInit() == 0) {</span>
256 
257         if (target == CPU_LOAD_VM_ONLY) {
258             pticks = &amp;counters.jvmTicks;
259         } else if (which == -1) {
260             pticks = &amp;counters.cpuTicks;
261         } else {
262             pticks = &amp;counters.cpus[which];
263         }
264 
265         tmp = *pticks;
266 
267         if (target == CPU_LOAD_VM_ONLY) {
268             if (get_jvmticks(pticks) != 0) {
269                 failed = 1;
270             }
271         } else if (get_totalticks(which, pticks) &lt; 0) {
272             failed = 1;
273         }
274 
<span class="line-modified">275         if (!failed) {</span>
<span class="line-modified">276 </span>
<span class="line-modified">277             assert(pticks-&gt;usedKernel &gt;= tmp.usedKernel);</span>
<span class="line-modified">278             kdiff = pticks-&gt;usedKernel - tmp.usedKernel;</span>




279             tdiff = pticks-&gt;total - tmp.total;
280             udiff = pticks-&gt;used - tmp.used;
281 
282             if (tdiff == 0) {
283                 user_load = 0;
284             } else {
285                 if (tdiff &lt; (udiff + kdiff)) {
286                     tdiff = udiff + kdiff;
287                 }
288                 *pkernelLoad = (kdiff / (double)tdiff);
289                 // BUG9044876, normalize return values to sane values
290                 *pkernelLoad = MAX(*pkernelLoad, 0.0);
291                 *pkernelLoad = MIN(*pkernelLoad, 1.0);
292 
293                 user_load = (udiff / (double)tdiff);
294                 user_load = MAX(user_load, 0.0);
295                 user_load = MIN(user_load, 1.0);
296             }
297         }
298     }
</pre>
<hr />
<pre>
303 double get_cpu_load(int which) {
304     double u, s;
305     u = get_cpuload_internal(which, &amp;s, CPU_LOAD_GLOBAL);
306     if (u &lt; 0) {
307         return -1.0;
308     }
309     // Cap total systemload to 1.0
310     return MIN((u + s), 1.0);
311 }
312 
313 double get_process_load() {
314     double u, s;
315     u = get_cpuload_internal(-1, &amp;s, CPU_LOAD_VM_ONLY);
316     if (u &lt; 0) {
317         return -1.0;
318     }
319     return u + s;
320 }
321 
322 JNIEXPORT jdouble JNICALL
<span class="line-modified">323 Java_com_sun_management_internal_OperatingSystemImpl_getCpuLoad0</span>
324 (JNIEnv *env, jobject dummy)
325 {
<span class="line-modified">326     if (perfInit() == 0) {</span>
327         return get_cpu_load(-1);
328     } else {
329         return -1.0;
330     }
331 }
332 
333 JNIEXPORT jdouble JNICALL
334 Java_com_sun_management_internal_OperatingSystemImpl_getProcessCpuLoad0
335 (JNIEnv *env, jobject dummy)
336 {
<span class="line-modified">337     if (perfInit() == 0) {</span>
338         return get_process_load();
339     } else {
340         return -1.0;
341     }
342 }
<span class="line-added">343 </span>
<span class="line-added">344 JNIEXPORT jdouble JNICALL</span>
<span class="line-added">345 Java_com_sun_management_internal_OperatingSystemImpl_getSingleCpuLoad0</span>
<span class="line-added">346 (JNIEnv *env, jobject mbean, jint cpu_number)</span>
<span class="line-added">347 {</span>
<span class="line-added">348     if (perfInit() == 0 &amp;&amp; cpu_number &gt;= 0 &amp;&amp; cpu_number &lt; counters.nProcs) {</span>
<span class="line-added">349         return get_cpu_load(cpu_number);</span>
<span class="line-added">350     } else {</span>
<span class="line-added">351         return -1.0;</span>
<span class="line-added">352     }</span>
<span class="line-added">353 }</span>
<span class="line-added">354 </span>
<span class="line-added">355 JNIEXPORT jint JNICALL</span>
<span class="line-added">356 Java_com_sun_management_internal_OperatingSystemImpl_getHostConfiguredCpuCount0</span>
<span class="line-added">357 (JNIEnv *env, jobject mbean)</span>
<span class="line-added">358 {</span>
<span class="line-added">359     if (perfInit() == 0) {</span>
<span class="line-added">360         return counters.nProcs;</span>
<span class="line-added">361     } else {</span>
<span class="line-added">362        return -1;</span>
<span class="line-added">363     }</span>
<span class="line-added">364 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="../../../aix/native/libmanagement_ext/UnixOperatingSystem.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../macosx/native/libmanagement_ext/UnixOperatingSystem.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
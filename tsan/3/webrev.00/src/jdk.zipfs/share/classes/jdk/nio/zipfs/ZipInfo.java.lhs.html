<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nio.zipfs;
 27 
 28 import java.nio.file.Paths;
 29 import java.util.Collections;
 30 import java.util.Map;
<a name="2" id="anc2"></a>
 31 
 32 import static jdk.nio.zipfs.ZipConstants.*;
 33 import static jdk.nio.zipfs.ZipUtils.dosToJavaTime;
 34 import static jdk.nio.zipfs.ZipUtils.unixToJavaTime;
 35 import static jdk.nio.zipfs.ZipUtils.winToJavaTime;
 36 
 37 /**
 38  * Print all loc and cen headers of the ZIP file
 39  *
 40  * @author Xueming Shen
 41  */
 42 public class ZipInfo {
 43 
 44     public static void main(String[] args) throws Throwable {
 45         if (args.length &lt; 1) {
 46             print(&quot;Usage: java ZipInfo zfname&quot;);
 47         } else {
 48             Map&lt;String, ?&gt; env = Collections.emptyMap();
 49             ZipFileSystem zfs = (ZipFileSystem)(new ZipFileSystemProvider()
 50                                     .newFileSystem(Paths.get(args[0]), env));
 51             byte[] cen = zfs.cen;
 52             if (cen == null) {
 53                 print(&quot;zip file is empty%n&quot;);
 54                 return;
 55             }
 56             int    pos = 0;
 57             byte[] buf = new byte[1024];
 58             int    no = 1;
 59             while (pos + CENHDR &lt; cen.length) {
 60                 print(&quot;----------------#%d--------------------%n&quot;, no++);
 61                 printCEN(cen, pos);
 62 
 63                 // use size CENHDR as the extra bytes to read, just in case the
 64                 // loc.extra is bigger than the cen.extra, try to avoid to read
 65                 // twice
 66                 long len = LOCHDR + CENNAM(cen, pos) + CENEXT(cen, pos) + CENHDR;
 67                 if (zfs.readFullyAt(buf, 0, len, locoff(cen, pos)) != len)
<a name="3" id="anc3"></a><span class="line-modified"> 68                     ZipFileSystem.zerror(&quot;read loc header failed&quot;);</span>
 69                 if (LOCEXT(buf) &gt; CENEXT(cen, pos) + CENHDR) {
 70                     // have to read the second time;
 71                     len = LOCHDR + LOCNAM(buf) + LOCEXT(buf);
 72                     if (zfs.readFullyAt(buf, 0, len, locoff(cen, pos)) != len)
<a name="4" id="anc4"></a><span class="line-modified"> 73                         ZipFileSystem.zerror(&quot;read loc header failed&quot;);</span>
 74                 }
 75                 printLOC(buf);
 76                 pos += CENHDR + CENNAM(cen, pos) + CENEXT(cen, pos) + CENCOM(cen, pos);
 77             }
 78             zfs.close();
 79         }
 80     }
 81 
<a name="5" id="anc5"></a><span class="line-modified"> 82     static void print(String fmt, Object... objs) {</span>
 83         System.out.printf(fmt, objs);
 84     }
 85 
<a name="6" id="anc6"></a><span class="line-modified"> 86     static void printLOC(byte[] loc) {</span>
 87         print(&quot;%n&quot;);
 88         print(&quot;[Local File Header]%n&quot;);
 89         print(&quot;    Signature   :   %#010x%n&quot;, LOCSIG(loc));
 90         if (LOCSIG(loc) != LOCSIG) {
 91            print(&quot;    Wrong signature!&quot;);
 92            return;
 93         }
 94         print(&quot;    Version     :       %#6x    [%d.%d]%n&quot;,
 95                   LOCVER(loc), LOCVER(loc) / 10, LOCVER(loc) % 10);
 96         print(&quot;    Flag        :       %#6x%n&quot;, LOCFLG(loc));
 97         print(&quot;    Method      :       %#6x%n&quot;, LOCHOW(loc));
 98         print(&quot;    LastMTime   :   %#10x    [%tc]%n&quot;,
 99               LOCTIM(loc), dosToJavaTime(LOCTIM(loc)));
100         print(&quot;    CRC         :   %#10x%n&quot;, LOCCRC(loc));
101         print(&quot;    CSize       :   %#10x%n&quot;, LOCSIZ(loc));
102         print(&quot;    Size        :   %#10x%n&quot;, LOCLEN(loc));
103         print(&quot;    NameLength  :       %#6x    [%s]%n&quot;,
104                   LOCNAM(loc), new String(loc, LOCHDR, LOCNAM(loc)));
105         print(&quot;    ExtraLength :       %#6x%n&quot;, LOCEXT(loc));
106         if (LOCEXT(loc) != 0)
107             printExtra(loc, LOCHDR + LOCNAM(loc), LOCEXT(loc));
108     }
109 
<a name="7" id="anc7"></a><span class="line-modified">110     static void printCEN(byte[] cen, int off) {</span>
111         print(&quot;[Central Directory Header]%n&quot;);
112         print(&quot;    Signature   :   %#010x%n&quot;, CENSIG(cen, off));
113         if (CENSIG(cen, off) != CENSIG) {
114            print(&quot;    Wrong signature!&quot;);
115            return;
116         }
117         print(&quot;    VerMadeby   :       %#6x    [%d, %d.%d]%n&quot;,
118               CENVEM(cen, off), (CENVEM(cen, off) &gt;&gt; 8),
119               (CENVEM(cen, off) &amp; 0xff) / 10,
120               (CENVEM(cen, off) &amp; 0xff) % 10);
121         print(&quot;    VerExtract  :       %#6x    [%d.%d]%n&quot;,
122               CENVER(cen, off), CENVER(cen, off) / 10, CENVER(cen, off) % 10);
123         print(&quot;    Flag        :       %#6x%n&quot;, CENFLG(cen, off));
124         print(&quot;    Method      :       %#6x%n&quot;, CENHOW(cen, off));
125         print(&quot;    LastMTime   :   %#10x    [%tc]%n&quot;,
126               CENTIM(cen, off), dosToJavaTime(CENTIM(cen, off)));
127         print(&quot;    CRC         :   %#10x%n&quot;, CENCRC(cen, off));
128         print(&quot;    CSize       :   %#10x%n&quot;, CENSIZ(cen, off));
129         print(&quot;    Size        :   %#10x%n&quot;, CENLEN(cen, off));
130         print(&quot;    NameLen     :       %#6x    [%s]%n&quot;,
131               CENNAM(cen, off), new String(cen, off + CENHDR, CENNAM(cen, off)));
132         print(&quot;    ExtraLen    :       %#6x%n&quot;, CENEXT(cen, off));
133         if (CENEXT(cen, off) != 0)
134             printExtra(cen, off + CENHDR + CENNAM(cen, off), CENEXT(cen, off));
135         print(&quot;    CommentLen  :       %#6x%n&quot;, CENCOM(cen, off));
136         print(&quot;    DiskStart   :       %#6x%n&quot;, CENDSK(cen, off));
137         print(&quot;    Attrs       :       %#6x%n&quot;, CENATT(cen, off));
138         print(&quot;    AttrsEx     :   %#10x%n&quot;, CENATX(cen, off));
139         print(&quot;    LocOff      :   %#10x%n&quot;, CENOFF(cen, off));
140 
141     }
142 
<a name="8" id="anc8"></a><span class="line-modified">143     static long locoff(byte[] cen, int pos) {</span>
144         long locoff = CENOFF(cen, pos);
145         if (locoff == ZIP64_MINVAL) {    //ZIP64
146             int off = pos + CENHDR + CENNAM(cen, pos);
147             int end = off + CENEXT(cen, pos);
148             while (off + 4 &lt; end) {
149                 int tag = SH(cen, off);
150                 int sz = SH(cen, off + 2);
151                 if (tag != EXTID_ZIP64) {
152                     off += 4 + sz;
153                     continue;
154                 }
155                 off += 4;
156                 if (CENLEN(cen, pos) == ZIP64_MINVAL)
157                     off += 8;
158                 if (CENSIZ(cen, pos) == ZIP64_MINVAL)
159                     off += 8;
160                 return LL(cen, off);
161             }
162             // should never be here
163         }
164         return locoff;
165     }
166 
<a name="9" id="anc9"></a><span class="line-modified">167     static void printExtra(byte[] extra, int off, int len) {</span>
168         int end = off + len;
169         while (off + 4 &lt;= end) {
170             int tag = SH(extra, off);
171             int sz = SH(extra, off + 2);
172             print(&quot;        [tag=0x%04x, sz=%d, data= &quot;, tag, sz);
173             if (off + sz &gt; end) {
174                 print(&quot;    Error: Invalid extra data, beyond extra length&quot;);
175                 break;
176             }
177             off += 4;
178             for (int i = 0; i &lt; sz; i++)
179                 print(&quot;%02x &quot;, extra[off + i]);
180             print(&quot;]%n&quot;);
181             switch (tag) {
182             case EXTID_ZIP64 :
183                 print(&quot;         -&gt;ZIP64: &quot;);
184                 int pos = off;
185                 while (pos + 8 &lt;= off + sz) {
186                     print(&quot; *0x%x &quot;, LL(extra, pos));
187                     pos += 8;
188                 }
189                 print(&quot;%n&quot;);
190                 break;
191             case EXTID_NTFS:
192                 print(&quot;         -&gt;PKWare NTFS%n&quot;);
193                 // 4 bytes reserved
194                 if (SH(extra, off + 4) !=  0x0001 || SH(extra, off + 6) !=  24)
195                     print(&quot;    Error: Invalid NTFS sub-tag or subsz&quot;);
196                 print(&quot;            mtime:%tc%n&quot;,
197                       winToJavaTime(LL(extra, off + 8)));
198                 print(&quot;            atime:%tc%n&quot;,
199                       winToJavaTime(LL(extra, off + 16)));
200                 print(&quot;            ctime:%tc%n&quot;,
201                       winToJavaTime(LL(extra, off + 24)));
202                 break;
203             case EXTID_EXTT:
204                 print(&quot;         -&gt;Info-ZIP Extended Timestamp: flag=%x%n&quot;,extra[off]);
205                 pos = off + 1 ;
206                 while (pos + 4 &lt;= off + sz) {
207                     print(&quot;            *%tc%n&quot;,
208                           unixToJavaTime(LG(extra, pos)));
209                     pos += 4;
210                 }
211                 break;
212             default:
213                 print(&quot;         -&gt;[tag=%x, size=%d]%n&quot;, tag, sz);
214             }
215             off += sz;
216         }
217     }
218 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZipFileSystemProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipPath.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipInfo.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nio.zipfs;
 27 
 28 import java.nio.file.Paths;
 29 import java.util.Collections;
 30 import java.util.Map;

 31 
 32 import static jdk.nio.zipfs.ZipConstants.*;
 33 import static jdk.nio.zipfs.ZipUtils.dosToJavaTime;
 34 import static jdk.nio.zipfs.ZipUtils.unixToJavaTime;
 35 import static jdk.nio.zipfs.ZipUtils.winToJavaTime;
 36 
 37 /**
 38  * Print all loc and cen headers of the ZIP file
 39  *
 40  * @author Xueming Shen
 41  */
 42 public class ZipInfo {
 43 
 44     public static void main(String[] args) throws Throwable {
 45         if (args.length &lt; 1) {
 46             print(&quot;Usage: java ZipInfo zfname&quot;);
 47         } else {
 48             Map&lt;String, ?&gt; env = Collections.emptyMap();
 49             ZipFileSystem zfs = (ZipFileSystem)(new ZipFileSystemProvider()
 50                                     .newFileSystem(Paths.get(args[0]), env));
 51             byte[] cen = zfs.cen;
 52             if (cen == null) {
 53                 print(&quot;zip file is empty%n&quot;);
 54                 return;
 55             }
 56             int    pos = 0;
 57             byte[] buf = new byte[1024];
 58             int    no = 1;
 59             while (pos + CENHDR &lt; cen.length) {
 60                 print(&quot;----------------#%d--------------------%n&quot;, no++);
 61                 printCEN(cen, pos);
 62 
 63                 // use size CENHDR as the extra bytes to read, just in case the
 64                 // loc.extra is bigger than the cen.extra, try to avoid to read
 65                 // twice
 66                 long len = LOCHDR + CENNAM(cen, pos) + CENEXT(cen, pos) + CENHDR;
 67                 if (zfs.readFullyAt(buf, 0, len, locoff(cen, pos)) != len)
<span class="line-modified"> 68                     ZipFileSystem.zerror(&quot;read loc header failed&quot;);</span>
 69                 if (LOCEXT(buf) &gt; CENEXT(cen, pos) + CENHDR) {
 70                     // have to read the second time;
 71                     len = LOCHDR + LOCNAM(buf) + LOCEXT(buf);
 72                     if (zfs.readFullyAt(buf, 0, len, locoff(cen, pos)) != len)
<span class="line-modified"> 73                         ZipFileSystem.zerror(&quot;read loc header failed&quot;);</span>
 74                 }
 75                 printLOC(buf);
 76                 pos += CENHDR + CENNAM(cen, pos) + CENEXT(cen, pos) + CENCOM(cen, pos);
 77             }
 78             zfs.close();
 79         }
 80     }
 81 
<span class="line-modified"> 82     static void print(String fmt, Object... objs) {</span>
 83         System.out.printf(fmt, objs);
 84     }
 85 
<span class="line-modified"> 86     static void printLOC(byte[] loc) {</span>
 87         print(&quot;%n&quot;);
 88         print(&quot;[Local File Header]%n&quot;);
 89         print(&quot;    Signature   :   %#010x%n&quot;, LOCSIG(loc));
 90         if (LOCSIG(loc) != LOCSIG) {
 91            print(&quot;    Wrong signature!&quot;);
 92            return;
 93         }
 94         print(&quot;    Version     :       %#6x    [%d.%d]%n&quot;,
 95                   LOCVER(loc), LOCVER(loc) / 10, LOCVER(loc) % 10);
 96         print(&quot;    Flag        :       %#6x%n&quot;, LOCFLG(loc));
 97         print(&quot;    Method      :       %#6x%n&quot;, LOCHOW(loc));
 98         print(&quot;    LastMTime   :   %#10x    [%tc]%n&quot;,
 99               LOCTIM(loc), dosToJavaTime(LOCTIM(loc)));
100         print(&quot;    CRC         :   %#10x%n&quot;, LOCCRC(loc));
101         print(&quot;    CSize       :   %#10x%n&quot;, LOCSIZ(loc));
102         print(&quot;    Size        :   %#10x%n&quot;, LOCLEN(loc));
103         print(&quot;    NameLength  :       %#6x    [%s]%n&quot;,
104                   LOCNAM(loc), new String(loc, LOCHDR, LOCNAM(loc)));
105         print(&quot;    ExtraLength :       %#6x%n&quot;, LOCEXT(loc));
106         if (LOCEXT(loc) != 0)
107             printExtra(loc, LOCHDR + LOCNAM(loc), LOCEXT(loc));
108     }
109 
<span class="line-modified">110     static void printCEN(byte[] cen, int off) {</span>
111         print(&quot;[Central Directory Header]%n&quot;);
112         print(&quot;    Signature   :   %#010x%n&quot;, CENSIG(cen, off));
113         if (CENSIG(cen, off) != CENSIG) {
114            print(&quot;    Wrong signature!&quot;);
115            return;
116         }
117         print(&quot;    VerMadeby   :       %#6x    [%d, %d.%d]%n&quot;,
118               CENVEM(cen, off), (CENVEM(cen, off) &gt;&gt; 8),
119               (CENVEM(cen, off) &amp; 0xff) / 10,
120               (CENVEM(cen, off) &amp; 0xff) % 10);
121         print(&quot;    VerExtract  :       %#6x    [%d.%d]%n&quot;,
122               CENVER(cen, off), CENVER(cen, off) / 10, CENVER(cen, off) % 10);
123         print(&quot;    Flag        :       %#6x%n&quot;, CENFLG(cen, off));
124         print(&quot;    Method      :       %#6x%n&quot;, CENHOW(cen, off));
125         print(&quot;    LastMTime   :   %#10x    [%tc]%n&quot;,
126               CENTIM(cen, off), dosToJavaTime(CENTIM(cen, off)));
127         print(&quot;    CRC         :   %#10x%n&quot;, CENCRC(cen, off));
128         print(&quot;    CSize       :   %#10x%n&quot;, CENSIZ(cen, off));
129         print(&quot;    Size        :   %#10x%n&quot;, CENLEN(cen, off));
130         print(&quot;    NameLen     :       %#6x    [%s]%n&quot;,
131               CENNAM(cen, off), new String(cen, off + CENHDR, CENNAM(cen, off)));
132         print(&quot;    ExtraLen    :       %#6x%n&quot;, CENEXT(cen, off));
133         if (CENEXT(cen, off) != 0)
134             printExtra(cen, off + CENHDR + CENNAM(cen, off), CENEXT(cen, off));
135         print(&quot;    CommentLen  :       %#6x%n&quot;, CENCOM(cen, off));
136         print(&quot;    DiskStart   :       %#6x%n&quot;, CENDSK(cen, off));
137         print(&quot;    Attrs       :       %#6x%n&quot;, CENATT(cen, off));
138         print(&quot;    AttrsEx     :   %#10x%n&quot;, CENATX(cen, off));
139         print(&quot;    LocOff      :   %#10x%n&quot;, CENOFF(cen, off));
140 
141     }
142 
<span class="line-modified">143     static long locoff(byte[] cen, int pos) {</span>
144         long locoff = CENOFF(cen, pos);
145         if (locoff == ZIP64_MINVAL) {    //ZIP64
146             int off = pos + CENHDR + CENNAM(cen, pos);
147             int end = off + CENEXT(cen, pos);
148             while (off + 4 &lt; end) {
149                 int tag = SH(cen, off);
150                 int sz = SH(cen, off + 2);
151                 if (tag != EXTID_ZIP64) {
152                     off += 4 + sz;
153                     continue;
154                 }
155                 off += 4;
156                 if (CENLEN(cen, pos) == ZIP64_MINVAL)
157                     off += 8;
158                 if (CENSIZ(cen, pos) == ZIP64_MINVAL)
159                     off += 8;
160                 return LL(cen, off);
161             }
162             // should never be here
163         }
164         return locoff;
165     }
166 
<span class="line-modified">167     static void printExtra(byte[] extra, int off, int len) {</span>
168         int end = off + len;
169         while (off + 4 &lt;= end) {
170             int tag = SH(extra, off);
171             int sz = SH(extra, off + 2);
172             print(&quot;        [tag=0x%04x, sz=%d, data= &quot;, tag, sz);
173             if (off + sz &gt; end) {
174                 print(&quot;    Error: Invalid extra data, beyond extra length&quot;);
175                 break;
176             }
177             off += 4;
178             for (int i = 0; i &lt; sz; i++)
179                 print(&quot;%02x &quot;, extra[off + i]);
180             print(&quot;]%n&quot;);
181             switch (tag) {
182             case EXTID_ZIP64 :
183                 print(&quot;         -&gt;ZIP64: &quot;);
184                 int pos = off;
185                 while (pos + 8 &lt;= off + sz) {
186                     print(&quot; *0x%x &quot;, LL(extra, pos));
187                     pos += 8;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nio.zipfs;
 27 
 28 import java.nio.file.Paths;
 29 import java.util.Collections;
 30 import java.util.Map;
<span class="line-added"> 31 import java.util.zip.ZipException;</span>
 32 
 33 import static jdk.nio.zipfs.ZipConstants.*;
 34 import static jdk.nio.zipfs.ZipUtils.dosToJavaTime;
 35 import static jdk.nio.zipfs.ZipUtils.unixToJavaTime;
 36 import static jdk.nio.zipfs.ZipUtils.winToJavaTime;
 37 
 38 /**
 39  * Print all loc and cen headers of the ZIP file
 40  *
 41  * @author Xueming Shen
 42  */
 43 public class ZipInfo {
 44 
 45     public static void main(String[] args) throws Throwable {
 46         if (args.length &lt; 1) {
 47             print(&quot;Usage: java ZipInfo zfname&quot;);
 48         } else {
 49             Map&lt;String, ?&gt; env = Collections.emptyMap();
 50             ZipFileSystem zfs = (ZipFileSystem)(new ZipFileSystemProvider()
 51                                     .newFileSystem(Paths.get(args[0]), env));
 52             byte[] cen = zfs.cen;
 53             if (cen == null) {
 54                 print(&quot;zip file is empty%n&quot;);
 55                 return;
 56             }
 57             int    pos = 0;
 58             byte[] buf = new byte[1024];
 59             int    no = 1;
 60             while (pos + CENHDR &lt; cen.length) {
 61                 print(&quot;----------------#%d--------------------%n&quot;, no++);
 62                 printCEN(cen, pos);
 63 
 64                 // use size CENHDR as the extra bytes to read, just in case the
 65                 // loc.extra is bigger than the cen.extra, try to avoid to read
 66                 // twice
 67                 long len = LOCHDR + CENNAM(cen, pos) + CENEXT(cen, pos) + CENHDR;
 68                 if (zfs.readFullyAt(buf, 0, len, locoff(cen, pos)) != len)
<span class="line-modified"> 69                     throw new ZipException(&quot;read loc header failed&quot;);</span>
 70                 if (LOCEXT(buf) &gt; CENEXT(cen, pos) + CENHDR) {
 71                     // have to read the second time;
 72                     len = LOCHDR + LOCNAM(buf) + LOCEXT(buf);
 73                     if (zfs.readFullyAt(buf, 0, len, locoff(cen, pos)) != len)
<span class="line-modified"> 74                         throw new ZipException(&quot;read loc header failed&quot;);</span>
 75                 }
 76                 printLOC(buf);
 77                 pos += CENHDR + CENNAM(cen, pos) + CENEXT(cen, pos) + CENCOM(cen, pos);
 78             }
 79             zfs.close();
 80         }
 81     }
 82 
<span class="line-modified"> 83     private static void print(String fmt, Object... objs) {</span>
 84         System.out.printf(fmt, objs);
 85     }
 86 
<span class="line-modified"> 87     private static void printLOC(byte[] loc) {</span>
 88         print(&quot;%n&quot;);
 89         print(&quot;[Local File Header]%n&quot;);
 90         print(&quot;    Signature   :   %#010x%n&quot;, LOCSIG(loc));
 91         if (LOCSIG(loc) != LOCSIG) {
 92            print(&quot;    Wrong signature!&quot;);
 93            return;
 94         }
 95         print(&quot;    Version     :       %#6x    [%d.%d]%n&quot;,
 96                   LOCVER(loc), LOCVER(loc) / 10, LOCVER(loc) % 10);
 97         print(&quot;    Flag        :       %#6x%n&quot;, LOCFLG(loc));
 98         print(&quot;    Method      :       %#6x%n&quot;, LOCHOW(loc));
 99         print(&quot;    LastMTime   :   %#10x    [%tc]%n&quot;,
100               LOCTIM(loc), dosToJavaTime(LOCTIM(loc)));
101         print(&quot;    CRC         :   %#10x%n&quot;, LOCCRC(loc));
102         print(&quot;    CSize       :   %#10x%n&quot;, LOCSIZ(loc));
103         print(&quot;    Size        :   %#10x%n&quot;, LOCLEN(loc));
104         print(&quot;    NameLength  :       %#6x    [%s]%n&quot;,
105                   LOCNAM(loc), new String(loc, LOCHDR, LOCNAM(loc)));
106         print(&quot;    ExtraLength :       %#6x%n&quot;, LOCEXT(loc));
107         if (LOCEXT(loc) != 0)
108             printExtra(loc, LOCHDR + LOCNAM(loc), LOCEXT(loc));
109     }
110 
<span class="line-modified">111     private static void printCEN(byte[] cen, int off) {</span>
112         print(&quot;[Central Directory Header]%n&quot;);
113         print(&quot;    Signature   :   %#010x%n&quot;, CENSIG(cen, off));
114         if (CENSIG(cen, off) != CENSIG) {
115            print(&quot;    Wrong signature!&quot;);
116            return;
117         }
118         print(&quot;    VerMadeby   :       %#6x    [%d, %d.%d]%n&quot;,
119               CENVEM(cen, off), (CENVEM(cen, off) &gt;&gt; 8),
120               (CENVEM(cen, off) &amp; 0xff) / 10,
121               (CENVEM(cen, off) &amp; 0xff) % 10);
122         print(&quot;    VerExtract  :       %#6x    [%d.%d]%n&quot;,
123               CENVER(cen, off), CENVER(cen, off) / 10, CENVER(cen, off) % 10);
124         print(&quot;    Flag        :       %#6x%n&quot;, CENFLG(cen, off));
125         print(&quot;    Method      :       %#6x%n&quot;, CENHOW(cen, off));
126         print(&quot;    LastMTime   :   %#10x    [%tc]%n&quot;,
127               CENTIM(cen, off), dosToJavaTime(CENTIM(cen, off)));
128         print(&quot;    CRC         :   %#10x%n&quot;, CENCRC(cen, off));
129         print(&quot;    CSize       :   %#10x%n&quot;, CENSIZ(cen, off));
130         print(&quot;    Size        :   %#10x%n&quot;, CENLEN(cen, off));
131         print(&quot;    NameLen     :       %#6x    [%s]%n&quot;,
132               CENNAM(cen, off), new String(cen, off + CENHDR, CENNAM(cen, off)));
133         print(&quot;    ExtraLen    :       %#6x%n&quot;, CENEXT(cen, off));
134         if (CENEXT(cen, off) != 0)
135             printExtra(cen, off + CENHDR + CENNAM(cen, off), CENEXT(cen, off));
136         print(&quot;    CommentLen  :       %#6x%n&quot;, CENCOM(cen, off));
137         print(&quot;    DiskStart   :       %#6x%n&quot;, CENDSK(cen, off));
138         print(&quot;    Attrs       :       %#6x%n&quot;, CENATT(cen, off));
139         print(&quot;    AttrsEx     :   %#10x%n&quot;, CENATX(cen, off));
140         print(&quot;    LocOff      :   %#10x%n&quot;, CENOFF(cen, off));
141 
142     }
143 
<span class="line-modified">144     private static long locoff(byte[] cen, int pos) {</span>
145         long locoff = CENOFF(cen, pos);
146         if (locoff == ZIP64_MINVAL) {    //ZIP64
147             int off = pos + CENHDR + CENNAM(cen, pos);
148             int end = off + CENEXT(cen, pos);
149             while (off + 4 &lt; end) {
150                 int tag = SH(cen, off);
151                 int sz = SH(cen, off + 2);
152                 if (tag != EXTID_ZIP64) {
153                     off += 4 + sz;
154                     continue;
155                 }
156                 off += 4;
157                 if (CENLEN(cen, pos) == ZIP64_MINVAL)
158                     off += 8;
159                 if (CENSIZ(cen, pos) == ZIP64_MINVAL)
160                     off += 8;
161                 return LL(cen, off);
162             }
163             // should never be here
164         }
165         return locoff;
166     }
167 
<span class="line-modified">168     private static void printExtra(byte[] extra, int off, int len) {</span>
169         int end = off + len;
170         while (off + 4 &lt;= end) {
171             int tag = SH(extra, off);
172             int sz = SH(extra, off + 2);
173             print(&quot;        [tag=0x%04x, sz=%d, data= &quot;, tag, sz);
174             if (off + sz &gt; end) {
175                 print(&quot;    Error: Invalid extra data, beyond extra length&quot;);
176                 break;
177             }
178             off += 4;
179             for (int i = 0; i &lt; sz; i++)
180                 print(&quot;%02x &quot;, extra[off + i]);
181             print(&quot;]%n&quot;);
182             switch (tag) {
183             case EXTID_ZIP64 :
184                 print(&quot;         -&gt;ZIP64: &quot;);
185                 int pos = off;
186                 while (pos + 8 &lt;= off + sz) {
187                     print(&quot; *0x%x &quot;, LL(extra, pos));
188                     pos += 8;
</pre>
</td>
</tr>
</table>
<center><a href="ZipFileSystemProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipPath.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
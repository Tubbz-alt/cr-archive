<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipFileSystem.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.nio.zipfs;
  27 
  28 import java.io.BufferedOutputStream;
  29 import java.io.ByteArrayInputStream;
  30 import java.io.ByteArrayOutputStream;
  31 import java.io.EOFException;
  32 import java.io.FilterOutputStream;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.OutputStream;
<a name="2" id="anc2"></a><span class="line-added">  36 import java.lang.Runtime.Version;</span>
  37 import java.nio.ByteBuffer;
  38 import java.nio.MappedByteBuffer;
  39 import java.nio.channels.FileChannel;
  40 import java.nio.channels.FileLock;
  41 import java.nio.channels.ReadableByteChannel;
  42 import java.nio.channels.SeekableByteChannel;
  43 import java.nio.channels.WritableByteChannel;
  44 import java.nio.file.*;
<a name="3" id="anc3"></a><span class="line-modified">  45 import java.nio.file.attribute.*;</span>


  46 import java.nio.file.spi.FileSystemProvider;
  47 import java.security.AccessController;
  48 import java.security.PrivilegedAction;
  49 import java.security.PrivilegedActionException;
  50 import java.security.PrivilegedExceptionAction;
  51 import java.util.*;
  52 import java.util.concurrent.locks.ReadWriteLock;
  53 import java.util.concurrent.locks.ReentrantReadWriteLock;
<a name="4" id="anc4"></a><span class="line-added">  54 import java.util.function.Consumer;</span>
<span class="line-added">  55 import java.util.function.Function;</span>
<span class="line-added">  56 import java.util.jar.Attributes;</span>
<span class="line-added">  57 import java.util.jar.Manifest;</span>
  58 import java.util.regex.Pattern;
  59 import java.util.zip.CRC32;
  60 import java.util.zip.Deflater;
  61 import java.util.zip.DeflaterOutputStream;
  62 import java.util.zip.Inflater;
  63 import java.util.zip.InflaterInputStream;
  64 import java.util.zip.ZipException;
  65 
  66 import static java.lang.Boolean.TRUE;
  67 import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;
  68 import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
  69 import static java.nio.file.StandardOpenOption.APPEND;
  70 import static java.nio.file.StandardOpenOption.CREATE;
  71 import static java.nio.file.StandardOpenOption.CREATE_NEW;
  72 import static java.nio.file.StandardOpenOption.READ;
  73 import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;
  74 import static java.nio.file.StandardOpenOption.WRITE;
  75 import static jdk.nio.zipfs.ZipConstants.*;
  76 import static jdk.nio.zipfs.ZipUtils.*;
  77 
  78 /**
  79  * A FileSystem built on a zip file
  80  *
  81  * @author Xueming Shen
  82  */
  83 class ZipFileSystem extends FileSystem {
<a name="5" id="anc5"></a><span class="line-added">  84     // statics</span>
<span class="line-added">  85     private static final boolean isWindows = AccessController.doPrivileged(</span>
<span class="line-added">  86         (PrivilegedAction&lt;Boolean&gt;)()-&gt;System.getProperty(&quot;os.name&quot;)</span>
<span class="line-added">  87                                              .startsWith(&quot;Windows&quot;));</span>
<span class="line-added">  88     private static final byte[] ROOTPATH = new byte[] { &#39;/&#39; };</span>
<span class="line-added">  89     private static final String PROPERTY_POSIX = &quot;enablePosixFileAttributes&quot;;</span>
<span class="line-added">  90     private static final String PROPERTY_DEFAULT_OWNER = &quot;defaultOwner&quot;;</span>
<span class="line-added">  91     private static final String PROPERTY_DEFAULT_GROUP = &quot;defaultGroup&quot;;</span>
<span class="line-added">  92     private static final String PROPERTY_DEFAULT_PERMISSIONS = &quot;defaultPermissions&quot;;</span>
<span class="line-added">  93     // Property used to specify the entry version to use for a multi-release JAR</span>
<span class="line-added">  94     private static final String PROPERTY_RELEASE_VERSION = &quot;releaseVersion&quot;;</span>
<span class="line-added">  95     // Original property used to specify the entry version to use for a</span>
<span class="line-added">  96     // multi-release JAR which is kept for backwards compatibility.</span>
<span class="line-added">  97     private static final String PROPERTY_MULTI_RELEASE = &quot;multi-release&quot;;</span>
<span class="line-added">  98 </span>
<span class="line-added">  99     private static final Set&lt;PosixFilePermission&gt; DEFAULT_PERMISSIONS =</span>
<span class="line-added"> 100         PosixFilePermissions.fromString(&quot;rwxrwxrwx&quot;);</span>
<span class="line-added"> 101     // Property used to specify the compression mode to use</span>
<span class="line-added"> 102     private static final String PROPERTY_COMPRESSION_METHOD = &quot;compressionMethod&quot;;</span>
<span class="line-added"> 103     // Value specified for compressionMethod property to compress Zip entries</span>
<span class="line-added"> 104     private static final String COMPRESSION_METHOD_DEFLATED = &quot;DEFLATED&quot;;</span>
<span class="line-added"> 105     // Value specified for compressionMethod property to not compress Zip entries</span>
<span class="line-added"> 106     private static final String COMPRESSION_METHOD_STORED = &quot;STORED&quot;;</span>
<span class="line-added"> 107 </span>
 108     private final ZipFileSystemProvider provider;
 109     private final Path zfpath;
 110     final ZipCoder zc;
 111     private final ZipPath rootdir;
<a name="6" id="anc6"></a><span class="line-modified"> 112     private boolean readOnly; // readonly file system, false by default</span>
<span class="line-added"> 113 </span>
<span class="line-added"> 114     // default time stamp for pseudo entries</span>
<span class="line-added"> 115     private final long zfsDefaultTimeStamp = System.currentTimeMillis();</span>
 116 
 117     // configurable by env map
 118     private final boolean noExtt;        // see readExtra()
 119     private final boolean useTempFile;   // use a temp file for newOS, default
 120                                          // is to use BAOS for better performance
<a name="7" id="anc7"></a>


 121     private final boolean forceEnd64;
<a name="8" id="anc8"></a><span class="line-modified"> 122     private final int defaultCompressionMethod; // METHOD_STORED if &quot;noCompression=true&quot;</span>
<span class="line-modified"> 123                                                 // METHOD_DEFLATED otherwise</span>
<span class="line-added"> 124 </span>
<span class="line-added"> 125     // entryLookup is identity by default, will be overridden for multi-release jars</span>
<span class="line-added"> 126     private Function&lt;byte[], byte[]&gt; entryLookup = Function.identity();</span>
<span class="line-added"> 127 </span>
<span class="line-added"> 128     // POSIX support</span>
<span class="line-added"> 129     final boolean supportPosix;</span>
<span class="line-added"> 130     private final UserPrincipal defaultOwner;</span>
<span class="line-added"> 131     private final GroupPrincipal defaultGroup;</span>
<span class="line-added"> 132     private final Set&lt;PosixFilePermission&gt; defaultPermissions;</span>
<span class="line-added"> 133 </span>
<span class="line-added"> 134     private final Set&lt;String&gt; supportedFileAttributeViews;</span>
 135 
 136     ZipFileSystem(ZipFileSystemProvider provider,
 137                   Path zfpath,
 138                   Map&lt;String, ?&gt; env) throws IOException
 139     {
 140         // default encoding for name/comment
 141         String nameEncoding = env.containsKey(&quot;encoding&quot;) ?
<a name="9" id="anc9"></a><span class="line-modified"> 142             (String)env.get(&quot;encoding&quot;) : &quot;UTF-8&quot;;</span>
 143         this.noExtt = &quot;false&quot;.equals(env.get(&quot;zipinfo-time&quot;));
 144         this.useTempFile  = isTrue(env, &quot;useTempFile&quot;);
 145         this.forceEnd64 = isTrue(env, &quot;forceZIP64End&quot;);
<a name="10" id="anc10"></a><span class="line-modified"> 146         this.defaultCompressionMethod = getDefaultCompressionMethod(env);</span>
<span class="line-added"> 147         this.supportPosix = isTrue(env, PROPERTY_POSIX);</span>
<span class="line-added"> 148         this.defaultOwner = initOwner(zfpath, env);</span>
<span class="line-added"> 149         this.defaultGroup = initGroup(zfpath, env);</span>
<span class="line-added"> 150         this.defaultPermissions = initPermissions(env);</span>
<span class="line-added"> 151         this.supportedFileAttributeViews = supportPosix ?</span>
<span class="line-added"> 152             Set.of(&quot;basic&quot;, &quot;posix&quot;, &quot;zip&quot;) : Set.of(&quot;basic&quot;, &quot;zip&quot;);</span>
 153         if (Files.notExists(zfpath)) {
<a name="11" id="anc11"></a><span class="line-modified"> 154             // create a new zip if it doesn&#39;t exist</span>
 155             if (isTrue(env, &quot;create&quot;)) {
 156                 try (OutputStream os = Files.newOutputStream(zfpath, CREATE_NEW, WRITE)) {
 157                     new END().write(os, 0, forceEnd64);
 158                 }
 159             } else {
<a name="12" id="anc12"></a><span class="line-modified"> 160                 throw new NoSuchFileException(zfpath.toString());</span>
 161             }
 162         }
 163         // sm and existence check
 164         zfpath.getFileSystem().provider().checkAccess(zfpath, AccessMode.READ);
 165         boolean writeable = AccessController.doPrivileged(
<a name="13" id="anc13"></a><span class="line-modified"> 166             (PrivilegedAction&lt;Boolean&gt;)()-&gt;Files.isWritable(zfpath));</span>
 167         this.readOnly = !writeable;
 168         this.zc = ZipCoder.get(nameEncoding);
 169         this.rootdir = new ZipPath(this, new byte[]{&#39;/&#39;});
 170         this.ch = Files.newByteChannel(zfpath, READ);
 171         try {
 172             this.cen = initCEN();
 173         } catch (IOException x) {
 174             try {
 175                 this.ch.close();
 176             } catch (IOException xx) {
 177                 x.addSuppressed(xx);
 178             }
 179             throw x;
 180         }
 181         this.provider = provider;
 182         this.zfpath = zfpath;
<a name="14" id="anc14"></a><span class="line-added"> 183 </span>
<span class="line-added"> 184         initializeReleaseVersion(env);</span>
<span class="line-added"> 185     }</span>
<span class="line-added"> 186 </span>
<span class="line-added"> 187     /**</span>
<span class="line-added"> 188      * Return the compression method to use (STORED or DEFLATED).  If the</span>
<span class="line-added"> 189      * property {@code commpressionMethod} is set use its value to determine</span>
<span class="line-added"> 190      * the compression method to use.  If the property is not set, then the</span>
<span class="line-added"> 191      * default compression is DEFLATED unless the property {@code noCompression}</span>
<span class="line-added"> 192      * is set which is supported for backwards compatibility.</span>
<span class="line-added"> 193      * @param env Zip FS map of properties</span>
<span class="line-added"> 194      * @return The Compression method to use</span>
<span class="line-added"> 195      */</span>
<span class="line-added"> 196     private int getDefaultCompressionMethod(Map&lt;String, ?&gt; env) {</span>
<span class="line-added"> 197         int result =</span>
<span class="line-added"> 198                 isTrue(env, &quot;noCompression&quot;) ? METHOD_STORED : METHOD_DEFLATED;</span>
<span class="line-added"> 199         if (env.containsKey(PROPERTY_COMPRESSION_METHOD)) {</span>
<span class="line-added"> 200             Object compressionMethod =  env.get(PROPERTY_COMPRESSION_METHOD);</span>
<span class="line-added"> 201             if (compressionMethod != null) {</span>
<span class="line-added"> 202                 if (compressionMethod instanceof String) {</span>
<span class="line-added"> 203                     switch (((String) compressionMethod).toUpperCase()) {</span>
<span class="line-added"> 204                         case COMPRESSION_METHOD_STORED:</span>
<span class="line-added"> 205                             result = METHOD_STORED;</span>
<span class="line-added"> 206                             break;</span>
<span class="line-added"> 207                         case COMPRESSION_METHOD_DEFLATED:</span>
<span class="line-added"> 208                             result = METHOD_DEFLATED;</span>
<span class="line-added"> 209                             break;</span>
<span class="line-added"> 210                         default:</span>
<span class="line-added"> 211                             throw new IllegalArgumentException(String.format(</span>
<span class="line-added"> 212                                     &quot;The value for the %s property must be %s or %s&quot;,</span>
<span class="line-added"> 213                                     PROPERTY_COMPRESSION_METHOD, COMPRESSION_METHOD_STORED,</span>
<span class="line-added"> 214                                     COMPRESSION_METHOD_DEFLATED));</span>
<span class="line-added"> 215                     }</span>
<span class="line-added"> 216                 } else {</span>
<span class="line-added"> 217                     throw new IllegalArgumentException(String.format(</span>
<span class="line-added"> 218                             &quot;The Object type for the %s property must be a String&quot;,</span>
<span class="line-added"> 219                             PROPERTY_COMPRESSION_METHOD));</span>
<span class="line-added"> 220                 }</span>
<span class="line-added"> 221             } else {</span>
<span class="line-added"> 222                 throw new IllegalArgumentException(String.format(</span>
<span class="line-added"> 223                         &quot;The value for the %s property must be %s or %s&quot;,</span>
<span class="line-added"> 224                         PROPERTY_COMPRESSION_METHOD, COMPRESSION_METHOD_STORED,</span>
<span class="line-added"> 225                         COMPRESSION_METHOD_DEFLATED));</span>
<span class="line-added"> 226             }</span>
<span class="line-added"> 227         }</span>
<span class="line-added"> 228         return result;</span>
 229     }
 230 
 231     // returns true if there is a name=true/&quot;true&quot; setting in env
 232     private static boolean isTrue(Map&lt;String, ?&gt; env, String name) {
 233         return &quot;true&quot;.equals(env.get(name)) || TRUE.equals(env.get(name));
 234     }
 235 
<a name="15" id="anc15"></a><span class="line-added"> 236     // Initialize the default owner for files inside the zip archive.</span>
<span class="line-added"> 237     // If not specified in env, it is the owner of the archive. If no owner can</span>
<span class="line-added"> 238     // be determined, we try to go with system property &quot;user.name&quot;. If that&#39;s not</span>
<span class="line-added"> 239     // accessible, we return &quot;&lt;zipfs_default&gt;&quot;.</span>
<span class="line-added"> 240     private UserPrincipal initOwner(Path zfpath, Map&lt;String, ?&gt; env) throws IOException {</span>
<span class="line-added"> 241         Object o = env.get(PROPERTY_DEFAULT_OWNER);</span>
<span class="line-added"> 242         if (o == null) {</span>
<span class="line-added"> 243             try {</span>
<span class="line-added"> 244                 PrivilegedExceptionAction&lt;UserPrincipal&gt; pa = ()-&gt;Files.getOwner(zfpath);</span>
<span class="line-added"> 245                 return AccessController.doPrivileged(pa);</span>
<span class="line-added"> 246             } catch (UnsupportedOperationException | PrivilegedActionException e) {</span>
<span class="line-added"> 247                 if (e instanceof UnsupportedOperationException ||</span>
<span class="line-added"> 248                     e.getCause() instanceof NoSuchFileException)</span>
<span class="line-added"> 249                 {</span>
<span class="line-added"> 250                     PrivilegedAction&lt;String&gt; pa = ()-&gt;System.getProperty(&quot;user.name&quot;);</span>
<span class="line-added"> 251                     String userName = AccessController.doPrivileged(pa);</span>
<span class="line-added"> 252                     return ()-&gt;userName;</span>
<span class="line-added"> 253                 } else {</span>
<span class="line-added"> 254                     throw new IOException(e);</span>
<span class="line-added"> 255                 }</span>
<span class="line-added"> 256             }</span>
<span class="line-added"> 257         }</span>
<span class="line-added"> 258         if (o instanceof String) {</span>
<span class="line-added"> 259             if (((String)o).isEmpty()) {</span>
<span class="line-added"> 260                 throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added"> 261                         PROPERTY_DEFAULT_OWNER + &quot; must not be empty.&quot;);</span>
<span class="line-added"> 262             }</span>
<span class="line-added"> 263             return ()-&gt;(String)o;</span>
<span class="line-added"> 264         }</span>
<span class="line-added"> 265         if (o instanceof UserPrincipal) {</span>
<span class="line-added"> 266             return (UserPrincipal)o;</span>
<span class="line-added"> 267         }</span>
<span class="line-added"> 268         throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added"> 269                 PROPERTY_DEFAULT_OWNER + &quot; must be of type &quot; + String.class +</span>
<span class="line-added"> 270             &quot; or &quot; + UserPrincipal.class);</span>
<span class="line-added"> 271     }</span>
<span class="line-added"> 272 </span>
<span class="line-added"> 273     // Initialize the default group for files inside the zip archive.</span>
<span class="line-added"> 274     // If not specified in env, we try to determine the group of the zip archive itself.</span>
<span class="line-added"> 275     // If this is not possible/unsupported, we will return a group principal going by</span>
<span class="line-added"> 276     // the same name as the default owner.</span>
<span class="line-added"> 277     private GroupPrincipal initGroup(Path zfpath, Map&lt;String, ?&gt; env) throws IOException {</span>
<span class="line-added"> 278         Object o = env.get(PROPERTY_DEFAULT_GROUP);</span>
<span class="line-added"> 279         if (o == null) {</span>
<span class="line-added"> 280             try {</span>
<span class="line-added"> 281                 PosixFileAttributeView zfpv = Files.getFileAttributeView(zfpath, PosixFileAttributeView.class);</span>
<span class="line-added"> 282                 if (zfpv == null) {</span>
<span class="line-added"> 283                     return defaultOwner::getName;</span>
<span class="line-added"> 284                 }</span>
<span class="line-added"> 285                 PrivilegedExceptionAction&lt;GroupPrincipal&gt; pa = ()-&gt;zfpv.readAttributes().group();</span>
<span class="line-added"> 286                 return AccessController.doPrivileged(pa);</span>
<span class="line-added"> 287             } catch (UnsupportedOperationException | PrivilegedActionException e) {</span>
<span class="line-added"> 288                 if (e instanceof UnsupportedOperationException ||</span>
<span class="line-added"> 289                     e.getCause() instanceof NoSuchFileException)</span>
<span class="line-added"> 290                 {</span>
<span class="line-added"> 291                     return defaultOwner::getName;</span>
<span class="line-added"> 292                 } else {</span>
<span class="line-added"> 293                     throw new IOException(e);</span>
<span class="line-added"> 294                 }</span>
<span class="line-added"> 295             }</span>
<span class="line-added"> 296         }</span>
<span class="line-added"> 297         if (o instanceof String) {</span>
<span class="line-added"> 298             if (((String)o).isEmpty()) {</span>
<span class="line-added"> 299                 throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added"> 300                         PROPERTY_DEFAULT_GROUP + &quot; must not be empty.&quot;);</span>
<span class="line-added"> 301             }</span>
<span class="line-added"> 302             return ()-&gt;(String)o;</span>
<span class="line-added"> 303         }</span>
<span class="line-added"> 304         if (o instanceof GroupPrincipal) {</span>
<span class="line-added"> 305             return (GroupPrincipal)o;</span>
<span class="line-added"> 306         }</span>
<span class="line-added"> 307         throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added"> 308                 PROPERTY_DEFAULT_GROUP + &quot; must be of type &quot; + String.class +</span>
<span class="line-added"> 309             &quot; or &quot; + GroupPrincipal.class);</span>
<span class="line-added"> 310     }</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312     // Initialize the default permissions for files inside the zip archive.</span>
<span class="line-added"> 313     // If not specified in env, it will return 777.</span>
<span class="line-added"> 314     private Set&lt;PosixFilePermission&gt; initPermissions(Map&lt;String, ?&gt; env) {</span>
<span class="line-added"> 315         Object o = env.get(PROPERTY_DEFAULT_PERMISSIONS);</span>
<span class="line-added"> 316         if (o == null) {</span>
<span class="line-added"> 317             return DEFAULT_PERMISSIONS;</span>
<span class="line-added"> 318         }</span>
<span class="line-added"> 319         if (o instanceof String) {</span>
<span class="line-added"> 320             return PosixFilePermissions.fromString((String)o);</span>
<span class="line-added"> 321         }</span>
<span class="line-added"> 322         if (!(o instanceof Set)) {</span>
<span class="line-added"> 323             throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added"> 324                 PROPERTY_DEFAULT_PERMISSIONS + &quot; must be of type &quot; + String.class +</span>
<span class="line-added"> 325                 &quot; or &quot; + Set.class);</span>
<span class="line-added"> 326         }</span>
<span class="line-added"> 327         Set&lt;PosixFilePermission&gt; perms = new HashSet&lt;&gt;();</span>
<span class="line-added"> 328         for (Object o2 : (Set&lt;?&gt;)o) {</span>
<span class="line-added"> 329             if (o2 instanceof PosixFilePermission) {</span>
<span class="line-added"> 330                 perms.add((PosixFilePermission)o2);</span>
<span class="line-added"> 331             } else {</span>
<span class="line-added"> 332                 throw new IllegalArgumentException(PROPERTY_DEFAULT_PERMISSIONS +</span>
<span class="line-added"> 333                     &quot; must only contain objects of type &quot; + PosixFilePermission.class);</span>
<span class="line-added"> 334             }</span>
<span class="line-added"> 335         }</span>
<span class="line-added"> 336         return perms;</span>
<span class="line-added"> 337     }</span>
<span class="line-added"> 338 </span>
 339     @Override
 340     public FileSystemProvider provider() {
 341         return provider;
 342     }
 343 
 344     @Override
 345     public String getSeparator() {
 346         return &quot;/&quot;;
 347     }
 348 
 349     @Override
 350     public boolean isOpen() {
 351         return isOpen;
 352     }
 353 
 354     @Override
 355     public boolean isReadOnly() {
 356         return readOnly;
 357     }
 358 
<a name="16" id="anc16"></a><span class="line-modified"> 359     private void checkWritable() {</span>
<span class="line-modified"> 360         if (readOnly) {</span>
 361             throw new ReadOnlyFileSystemException();
<a name="17" id="anc17"></a><span class="line-added"> 362         }</span>
 363     }
 364 
 365     void setReadOnly() {
 366         this.readOnly = true;
 367     }
 368 
 369     @Override
 370     public Iterable&lt;Path&gt; getRootDirectories() {
 371         return List.of(rootdir);
 372     }
 373 
 374     ZipPath getRootDir() {
 375         return rootdir;
 376     }
 377 
 378     @Override
 379     public ZipPath getPath(String first, String... more) {
 380         if (more.length == 0) {
 381             return new ZipPath(this, first);
 382         }
 383         StringBuilder sb = new StringBuilder();
 384         sb.append(first);
 385         for (String path : more) {
 386             if (path.length() &gt; 0) {
 387                 if (sb.length() &gt; 0) {
 388                     sb.append(&#39;/&#39;);
 389                 }
 390                 sb.append(path);
 391             }
 392         }
 393         return new ZipPath(this, sb.toString());
 394     }
 395 
 396     @Override
 397     public UserPrincipalLookupService getUserPrincipalLookupService() {
 398         throw new UnsupportedOperationException();
 399     }
 400 
 401     @Override
 402     public WatchService newWatchService() {
 403         throw new UnsupportedOperationException();
 404     }
 405 
 406     FileStore getFileStore(ZipPath path) {
 407         return new ZipFileStore(path);
 408     }
 409 
 410     @Override
 411     public Iterable&lt;FileStore&gt; getFileStores() {
 412         return List.of(new ZipFileStore(rootdir));
 413     }
 414 
<a name="18" id="anc18"></a>


 415     @Override
 416     public Set&lt;String&gt; supportedFileAttributeViews() {
 417         return supportedFileAttributeViews;
 418     }
 419 
 420     @Override
 421     public String toString() {
 422         return zfpath.toString();
 423     }
 424 
 425     Path getZipFile() {
 426         return zfpath;
 427     }
 428 
 429     private static final String GLOB_SYNTAX = &quot;glob&quot;;
 430     private static final String REGEX_SYNTAX = &quot;regex&quot;;
 431 
 432     @Override
 433     public PathMatcher getPathMatcher(String syntaxAndInput) {
 434         int pos = syntaxAndInput.indexOf(&#39;:&#39;);
 435         if (pos &lt;= 0 || pos == syntaxAndInput.length()) {
 436             throw new IllegalArgumentException();
 437         }
 438         String syntax = syntaxAndInput.substring(0, pos);
 439         String input = syntaxAndInput.substring(pos + 1);
 440         String expr;
 441         if (syntax.equalsIgnoreCase(GLOB_SYNTAX)) {
 442             expr = toRegexPattern(input);
 443         } else {
 444             if (syntax.equalsIgnoreCase(REGEX_SYNTAX)) {
 445                 expr = input;
 446             } else {
 447                 throw new UnsupportedOperationException(&quot;Syntax &#39;&quot; + syntax +
 448                     &quot;&#39; not recognized&quot;);
 449             }
 450         }
 451         // return matcher
 452         final Pattern pattern = Pattern.compile(expr);
<a name="19" id="anc19"></a><span class="line-modified"> 453         return (path)-&gt;pattern.matcher(path.toString()).matches();</span>





 454     }
 455 
 456     @Override
 457     public void close() throws IOException {
 458         beginWrite();
 459         try {
 460             if (!isOpen)
 461                 return;
 462             isOpen = false;          // set closed
 463         } finally {
 464             endWrite();
 465         }
 466         if (!streams.isEmpty()) {    // unlock and close all remaining streams
 467             Set&lt;InputStream&gt; copy = new HashSet&lt;&gt;(streams);
 468             for (InputStream is : copy)
 469                 is.close();
 470         }
 471         beginWrite();                // lock and sync
 472         try {
 473             AccessController.doPrivileged((PrivilegedExceptionAction&lt;Void&gt;)() -&gt; {
 474                 sync(); return null;
 475             });
 476             ch.close();              // close the ch just in case no update
 477                                      // and sync didn&#39;t close the ch
 478         } catch (PrivilegedActionException e) {
 479             throw (IOException)e.getException();
 480         } finally {
 481             endWrite();
 482         }
 483 
 484         synchronized (inflaters) {
 485             for (Inflater inf : inflaters)
 486                 inf.end();
 487         }
 488         synchronized (deflaters) {
 489             for (Deflater def : deflaters)
 490                 def.end();
 491         }
 492 
<a name="20" id="anc20"></a><span class="line-added"> 493         beginWrite();                // lock and sync</span>
<span class="line-added"> 494         try {</span>
<span class="line-added"> 495             // Clear the map so that its keys &amp; values can be garbage collected</span>
<span class="line-added"> 496             inodes = null;</span>
<span class="line-added"> 497         } finally {</span>
<span class="line-added"> 498             endWrite();</span>
<span class="line-added"> 499         }</span>
<span class="line-added"> 500 </span>
 501         IOException ioe = null;
 502         synchronized (tmppaths) {
 503             for (Path p : tmppaths) {
 504                 try {
 505                     AccessController.doPrivileged(
 506                         (PrivilegedExceptionAction&lt;Boolean&gt;)() -&gt; Files.deleteIfExists(p));
 507                 } catch (PrivilegedActionException e) {
 508                     IOException x = (IOException)e.getException();
 509                     if (ioe == null)
 510                         ioe = x;
 511                     else
 512                         ioe.addSuppressed(x);
 513                 }
 514             }
 515         }
 516         provider.removeFileSystem(zfpath, this);
 517         if (ioe != null)
 518            throw ioe;
 519     }
 520 
 521     ZipFileAttributes getFileAttributes(byte[] path)
 522         throws IOException
 523     {
<a name="21" id="anc21"></a>
 524         beginRead();
 525         try {
 526             ensureOpen();
<a name="22" id="anc22"></a><span class="line-modified"> 527             IndexNode inode = getInode(path);</span>
<span class="line-modified"> 528             if (inode == null) {</span>
<span class="line-modified"> 529                 return null;</span>
<span class="line-modified"> 530             } else if (inode instanceof Entry) {</span>
<span class="line-modified"> 531                 return (Entry)inode;</span>
<span class="line-added"> 532             } else if (inode.pos == -1) {</span>
 533                 // pseudo directory, uses METHOD_STORED
<a name="23" id="anc23"></a><span class="line-modified"> 534                 Entry e = supportPosix ?</span>
<span class="line-added"> 535                     new PosixEntry(inode.name, inode.isdir, METHOD_STORED) :</span>
<span class="line-added"> 536                     new Entry(inode.name, inode.isdir, METHOD_STORED);</span>
 537                 e.mtime = e.atime = e.ctime = zfsDefaultTimeStamp;
<a name="24" id="anc24"></a><span class="line-added"> 538                 return e;</span>
<span class="line-added"> 539             } else {</span>
<span class="line-added"> 540                 return supportPosix ? new PosixEntry(this, inode) : new Entry(this, inode);</span>
 541             }
 542         } finally {
 543             endRead();
 544         }
<a name="25" id="anc25"></a>
 545     }
 546 
 547     void checkAccess(byte[] path) throws IOException {
 548         beginRead();
 549         try {
 550             ensureOpen();
 551             // is it necessary to readCEN as a sanity check?
 552             if (getInode(path) == null) {
 553                 throw new NoSuchFileException(toString());
 554             }
 555 
 556         } finally {
 557             endRead();
 558         }
 559     }
 560 
 561     void setTimes(byte[] path, FileTime mtime, FileTime atime, FileTime ctime)
 562         throws IOException
 563     {
 564         checkWritable();
 565         beginWrite();
 566         try {
 567             ensureOpen();
 568             Entry e = getEntry(path);    // ensureOpen checked
 569             if (e == null)
 570                 throw new NoSuchFileException(getString(path));
 571             if (e.type == Entry.CEN)
<a name="26" id="anc26"></a><span class="line-modified"> 572                 e.type = Entry.COPY;     // copy e</span>
 573             if (mtime != null)
 574                 e.mtime = mtime.toMillis();
 575             if (atime != null)
 576                 e.atime = atime.toMillis();
 577             if (ctime != null)
 578                 e.ctime = ctime.toMillis();
 579             update(e);
 580         } finally {
 581             endWrite();
 582         }
 583     }
 584 
<a name="27" id="anc27"></a><span class="line-modified"> 585     void setOwner(byte[] path, UserPrincipal owner) throws IOException {</span>
<span class="line-modified"> 586         checkWritable();</span>
<span class="line-modified"> 587         beginWrite();</span>
<span class="line-added"> 588         try {</span>
<span class="line-added"> 589             ensureOpen();</span>
<span class="line-added"> 590             Entry e = getEntry(path);    // ensureOpen checked</span>
<span class="line-added"> 591             if (e == null) {</span>
<span class="line-added"> 592                 throw new NoSuchFileException(getString(path));</span>
<span class="line-added"> 593             }</span>
<span class="line-added"> 594             // as the owner information is not persistent, we don&#39;t need to</span>
<span class="line-added"> 595             // change e.type to Entry.COPY</span>
<span class="line-added"> 596             if (e instanceof PosixEntry) {</span>
<span class="line-added"> 597                 ((PosixEntry)e).owner = owner;</span>
<span class="line-added"> 598                 update(e);</span>
<span class="line-added"> 599             }</span>
<span class="line-added"> 600         } finally {</span>
<span class="line-added"> 601             endWrite();</span>
<span class="line-added"> 602         }</span>
<span class="line-added"> 603     }</span>
<span class="line-added"> 604 </span>
<span class="line-added"> 605     void setGroup(byte[] path, GroupPrincipal group) throws IOException {</span>
<span class="line-added"> 606         checkWritable();</span>
<span class="line-added"> 607         beginWrite();</span>
<span class="line-added"> 608         try {</span>
<span class="line-added"> 609             ensureOpen();</span>
<span class="line-added"> 610             Entry e = getEntry(path);    // ensureOpen checked</span>
<span class="line-added"> 611             if (e == null) {</span>
<span class="line-added"> 612                 throw new NoSuchFileException(getString(path));</span>
<span class="line-added"> 613             }</span>
<span class="line-added"> 614             // as the group information is not persistent, we don&#39;t need to</span>
<span class="line-added"> 615             // change e.type to Entry.COPY</span>
<span class="line-added"> 616             if (e instanceof PosixEntry) {</span>
<span class="line-added"> 617                 ((PosixEntry)e).group = group;</span>
<span class="line-added"> 618                 update(e);</span>
<span class="line-added"> 619             }</span>
<span class="line-added"> 620         } finally {</span>
<span class="line-added"> 621             endWrite();</span>
<span class="line-added"> 622         }</span>
<span class="line-added"> 623     }</span>
<span class="line-added"> 624 </span>
<span class="line-added"> 625     void setPermissions(byte[] path, Set&lt;PosixFilePermission&gt; perms) throws IOException {</span>
<span class="line-added"> 626         checkWritable();</span>
<span class="line-added"> 627         beginWrite();</span>
<span class="line-added"> 628         try {</span>
<span class="line-added"> 629             ensureOpen();</span>
<span class="line-added"> 630             Entry e = getEntry(path);    // ensureOpen checked</span>
<span class="line-added"> 631             if (e == null) {</span>
<span class="line-added"> 632                 throw new NoSuchFileException(getString(path));</span>
<span class="line-added"> 633             }</span>
<span class="line-added"> 634             if (e.type == Entry.CEN) {</span>
<span class="line-added"> 635                 e.type = Entry.COPY;     // copy e</span>
<span class="line-added"> 636             }</span>
<span class="line-added"> 637             e.posixPerms = perms == null ? -1 : ZipUtils.permsToFlags(perms);</span>
<span class="line-added"> 638             update(e);</span>
<span class="line-added"> 639         } finally {</span>
<span class="line-added"> 640             endWrite();</span>
<span class="line-added"> 641         }</span>
<span class="line-added"> 642     }</span>
<span class="line-added"> 643 </span>
<span class="line-added"> 644     boolean exists(byte[] path) {</span>
 645         beginRead();
 646         try {
 647             ensureOpen();
 648             return getInode(path) != null;
 649         } finally {
 650             endRead();
 651         }
 652     }
 653 
<a name="28" id="anc28"></a><span class="line-modified"> 654     boolean isDirectory(byte[] path) {</span>


 655         beginRead();
 656         try {
 657             IndexNode n = getInode(path);
 658             return n != null &amp;&amp; n.isDir();
 659         } finally {
 660             endRead();
 661         }
 662     }
 663 
 664     // returns the list of child paths of &quot;path&quot;
 665     Iterator&lt;Path&gt; iteratorOf(ZipPath dir,
 666                               DirectoryStream.Filter&lt;? super Path&gt; filter)
 667         throws IOException
 668     {
 669         beginWrite();    // iteration of inodes needs exclusive lock
 670         try {
 671             ensureOpen();
 672             byte[] path = dir.getResolvedPath();
 673             IndexNode inode = getInode(path);
 674             if (inode == null)
 675                 throw new NotDirectoryException(getString(path));
 676             List&lt;Path&gt; list = new ArrayList&lt;&gt;();
 677             IndexNode child = inode.child;
 678             while (child != null) {
 679                 // (1) Assume each path from the zip file itself is &quot;normalized&quot;
 680                 // (2) IndexNode.name is absolute. see IndexNode(byte[],int,int)
 681                 // (3) If parent &quot;dir&quot; is relative when ZipDirectoryStream
 682                 //     is created, the returned child path needs to be relative
 683                 //     as well.
<a name="29" id="anc29"></a><span class="line-modified"> 684                 ZipPath childPath = new ZipPath(this, child.name, true);</span>

 685                 ZipPath childFileName = childPath.getFileName();
 686                 ZipPath zpath = dir.resolve(childFileName);
 687                 if (filter == null || filter.accept(zpath))
 688                     list.add(zpath);
 689                 child = child.sibling;
 690             }
 691             return list.iterator();
 692         } finally {
 693             endWrite();
 694         }
 695     }
 696 
<a name="30" id="anc30"></a><span class="line-modified"> 697     void createDirectory(byte[] dir, FileAttribute&lt;?&gt;... attrs) throws IOException {</span>


 698         checkWritable();
<a name="31" id="anc31"></a>
 699         beginWrite();
 700         try {
 701             ensureOpen();
<a name="32" id="anc32"></a><span class="line-modified"> 702             if (dir.length == 0 || exists(dir))  // root dir, or existing dir</span>
 703                 throw new FileAlreadyExistsException(getString(dir));
 704             checkParents(dir);
<a name="33" id="anc33"></a><span class="line-modified"> 705             Entry e = supportPosix ?</span>
<span class="line-added"> 706                 new PosixEntry(dir, Entry.NEW, true, METHOD_STORED, attrs) :</span>
<span class="line-added"> 707                 new Entry(dir, Entry.NEW, true, METHOD_STORED, attrs);</span>
 708             update(e);
 709         } finally {
 710             endWrite();
 711         }
 712     }
 713 
 714     void copyFile(boolean deletesrc, byte[]src, byte[] dst, CopyOption... options)
 715         throws IOException
 716     {
 717         checkWritable();
 718         if (Arrays.equals(src, dst))
 719             return;    // do nothing, src and dst are the same
 720 
 721         beginWrite();
 722         try {
 723             ensureOpen();
 724             Entry eSrc = getEntry(src);  // ensureOpen checked
 725 
 726             if (eSrc == null)
 727                 throw new NoSuchFileException(getString(src));
 728             if (eSrc.isDir()) {    // spec says to create dst dir
 729                 createDirectory(dst);
 730                 return;
 731             }
 732             boolean hasReplace = false;
 733             boolean hasCopyAttrs = false;
 734             for (CopyOption opt : options) {
 735                 if (opt == REPLACE_EXISTING)
 736                     hasReplace = true;
 737                 else if (opt == COPY_ATTRIBUTES)
 738                     hasCopyAttrs = true;
 739             }
 740             Entry eDst = getEntry(dst);
 741             if (eDst != null) {
 742                 if (!hasReplace)
 743                     throw new FileAlreadyExistsException(getString(dst));
 744             } else {
 745                 checkParents(dst);
 746             }
<a name="34" id="anc34"></a><span class="line-modified"> 747             // copy eSrc entry and change name</span>
<span class="line-modified"> 748             Entry u = supportPosix ?</span>
<span class="line-modified"> 749                 new PosixEntry((PosixEntry)eSrc, Entry.COPY) :</span>
<span class="line-modified"> 750                 new Entry(eSrc, Entry.COPY);</span>
<span class="line-added"> 751             u.name(dst);</span>
<span class="line-added"> 752             if (eSrc.type == Entry.NEW || eSrc.type == Entry.FILECH) {</span>
 753                 u.type = eSrc.type;    // make it the same type
 754                 if (deletesrc) {       // if it&#39;s a &quot;rename&quot;, take the data
 755                     u.bytes = eSrc.bytes;
 756                     u.file = eSrc.file;
 757                 } else {               // if it&#39;s not &quot;rename&quot;, copy the data
 758                     if (eSrc.bytes != null)
 759                         u.bytes = Arrays.copyOf(eSrc.bytes, eSrc.bytes.length);
 760                     else if (eSrc.file != null) {
 761                         u.file = getTempPathForEntry(null);
 762                         Files.copy(eSrc.file, u.file, REPLACE_EXISTING);
 763                     }
 764                 }
<a name="35" id="anc35"></a><span class="line-added"> 765             } else if (eSrc.type == Entry.CEN &amp;&amp; eSrc.method != defaultCompressionMethod) {</span>
<span class="line-added"> 766 </span>
<span class="line-added"> 767                 /**</span>
<span class="line-added"> 768                  * We are copying a file within the same Zip file using a</span>
<span class="line-added"> 769                  * different compression method.</span>
<span class="line-added"> 770                  */</span>
<span class="line-added"> 771                 try (InputStream in = newInputStream(src);</span>
<span class="line-added"> 772                      OutputStream out = newOutputStream(dst,</span>
<span class="line-added"> 773                              CREATE, TRUNCATE_EXISTING, WRITE)) {</span>
<span class="line-added"> 774                     in.transferTo(out);</span>
<span class="line-added"> 775                 }</span>
<span class="line-added"> 776                 u = getEntry(dst);</span>
 777             }
<a name="36" id="anc36"></a><span class="line-added"> 778 </span>
 779             if (!hasCopyAttrs)
 780                 u.mtime = u.atime= u.ctime = System.currentTimeMillis();
 781             update(u);
 782             if (deletesrc)
 783                 updateDelete(eSrc);
 784         } finally {
 785             endWrite();
 786         }
 787     }
 788 
 789     // Returns an output stream for writing the contents into the specified
 790     // entry.
 791     OutputStream newOutputStream(byte[] path, OpenOption... options)
 792         throws IOException
 793     {
 794         checkWritable();
 795         boolean hasCreateNew = false;
 796         boolean hasCreate = false;
 797         boolean hasAppend = false;
 798         boolean hasTruncate = false;
 799         for (OpenOption opt : options) {
 800             if (opt == READ)
 801                 throw new IllegalArgumentException(&quot;READ not allowed&quot;);
 802             if (opt == CREATE_NEW)
 803                 hasCreateNew = true;
 804             if (opt == CREATE)
 805                 hasCreate = true;
 806             if (opt == APPEND)
 807                 hasAppend = true;
 808             if (opt == TRUNCATE_EXISTING)
 809                 hasTruncate = true;
 810         }
 811         if (hasAppend &amp;&amp; hasTruncate)
 812             throw new IllegalArgumentException(&quot;APPEND + TRUNCATE_EXISTING not allowed&quot;);
 813         beginRead();                 // only need a readlock, the &quot;update()&quot; will
 814         try {                        // try to obtain a writelock when the os is
 815             ensureOpen();            // being closed.
 816             Entry e = getEntry(path);
 817             if (e != null) {
 818                 if (e.isDir() || hasCreateNew)
 819                     throw new FileAlreadyExistsException(getString(path));
 820                 if (hasAppend) {
<a name="37" id="anc37"></a>
 821                     OutputStream os = getOutputStream(new Entry(e, Entry.NEW));
<a name="38" id="anc38"></a><span class="line-modified"> 822                     try (InputStream is = getInputStream(e)) {</span>
<span class="line-modified"> 823                         is.transferTo(os);</span>
<span class="line-added"> 824                     }</span>
 825                     return os;
 826                 }
<a name="39" id="anc39"></a><span class="line-modified"> 827                 return getOutputStream(supportPosix ?</span>
<span class="line-added"> 828                     new PosixEntry((PosixEntry)e, Entry.NEW, defaultCompressionMethod)</span>
<span class="line-added"> 829                         : new Entry(e, Entry.NEW, defaultCompressionMethod));</span>
 830             } else {
 831                 if (!hasCreate &amp;&amp; !hasCreateNew)
 832                     throw new NoSuchFileException(getString(path));
 833                 checkParents(path);
<a name="40" id="anc40"></a><span class="line-modified"> 834                 return getOutputStream(supportPosix ?</span>
<span class="line-added"> 835                     new PosixEntry(path, Entry.NEW, false, defaultCompressionMethod) :</span>
<span class="line-added"> 836                     new Entry(path, Entry.NEW, false, defaultCompressionMethod));</span>
 837             }
 838         } finally {
 839             endRead();
 840         }
 841     }
 842 
 843     // Returns an input stream for reading the contents of the specified
 844     // file entry.
 845     InputStream newInputStream(byte[] path) throws IOException {
 846         beginRead();
 847         try {
 848             ensureOpen();
 849             Entry e = getEntry(path);
 850             if (e == null)
 851                 throw new NoSuchFileException(getString(path));
 852             if (e.isDir())
 853                 throw new FileSystemException(getString(path), &quot;is a directory&quot;, null);
 854             return getInputStream(e);
 855         } finally {
 856             endRead();
 857         }
 858     }
 859 
 860     private void checkOptions(Set&lt;? extends OpenOption&gt; options) {
 861         // check for options of null type and option is an intance of StandardOpenOption
 862         for (OpenOption option : options) {
 863             if (option == null)
 864                 throw new NullPointerException();
 865             if (!(option instanceof StandardOpenOption))
 866                 throw new IllegalArgumentException();
 867         }
 868         if (options.contains(APPEND) &amp;&amp; options.contains(TRUNCATE_EXISTING))
 869             throw new IllegalArgumentException(&quot;APPEND + TRUNCATE_EXISTING not allowed&quot;);
 870     }
 871 
<a name="41" id="anc41"></a>
 872     // Returns an output SeekableByteChannel for either
<a name="42" id="anc42"></a><span class="line-modified"> 873     // (1) writing the contents of a new entry, if the entry doesn&#39;t exist, or</span>
 874     // (2) updating/replacing the contents of an existing entry.
<a name="43" id="anc43"></a><span class="line-modified"> 875     // Note: The content of the channel is not compressed until the</span>
<span class="line-added"> 876     // channel is closed</span>
 877     private class EntryOutputChannel extends ByteArrayChannel {
<a name="44" id="anc44"></a><span class="line-modified"> 878         final Entry e;</span>
 879 
<a name="45" id="anc45"></a><span class="line-modified"> 880         EntryOutputChannel(Entry e) {</span>
 881             super(e.size &gt; 0? (int)e.size : 8192, false);
 882             this.e = e;
 883             if (e.mtime == -1)
 884                 e.mtime = System.currentTimeMillis();
 885             if (e.method == -1)
<a name="46" id="anc46"></a><span class="line-modified"> 886                 e.method = defaultCompressionMethod;</span>
 887             // store size, compressed size, and crc-32 in datadescriptor
 888             e.flag = FLAG_DATADESCR;
 889             if (zc.isUTF8())
 890                 e.flag |= FLAG_USE_UTF8;
 891         }
 892 
 893         @Override
 894         public void close() throws IOException {
<a name="47" id="anc47"></a><span class="line-modified"> 895             // will update the entry</span>
<span class="line-modified"> 896             try (OutputStream os = getOutputStream(e)) {</span>
<span class="line-modified"> 897                 os.write(toByteArray());</span>
<span class="line-added"> 898             }</span>
 899             super.close();
<a name="48" id="anc48"></a>
 900         }
 901     }
 902 
<a name="49" id="anc49"></a><span class="line-modified"> 903     // Returns a Writable/ReadByteChannel for now. Might consider to use</span>




 904     // newFileChannel() instead, which dump the entry data into a regular
<a name="50" id="anc50"></a><span class="line-modified"> 905     // file on the default file system and create a FileChannel on top of it.</span>

 906     SeekableByteChannel newByteChannel(byte[] path,
 907                                        Set&lt;? extends OpenOption&gt; options,
 908                                        FileAttribute&lt;?&gt;... attrs)
 909         throws IOException
 910     {
 911         checkOptions(options);
 912         if (options.contains(StandardOpenOption.WRITE) ||
 913             options.contains(StandardOpenOption.APPEND)) {
 914             checkWritable();
<a name="51" id="anc51"></a><span class="line-modified"> 915             beginRead();    // only need a read lock, the &quot;update()&quot; will obtain</span>
<span class="line-modified"> 916                             // the write lock when the channel is closed</span>
 917             try {
<a name="52" id="anc52"></a>
 918                 Entry e = getEntry(path);
 919                 if (e != null) {
 920                     if (e.isDir() || options.contains(CREATE_NEW))
 921                         throw new FileAlreadyExistsException(getString(path));
 922                     SeekableByteChannel sbc =
<a name="53" id="anc53"></a><span class="line-modified"> 923                             new EntryOutputChannel(supportPosix ?</span>
<span class="line-added"> 924                                 new PosixEntry((PosixEntry)e, Entry.NEW) :</span>
<span class="line-added"> 925                                 new Entry(e, Entry.NEW));</span>
 926                     if (options.contains(APPEND)) {
 927                         try (InputStream is = getInputStream(e)) {  // copyover
 928                             byte[] buf = new byte[8192];
 929                             ByteBuffer bb = ByteBuffer.wrap(buf);
 930                             int n;
 931                             while ((n = is.read(buf)) != -1) {
 932                                 bb.position(0);
 933                                 bb.limit(n);
 934                                 sbc.write(bb);
 935                             }
 936                         }
 937                     }
 938                     return sbc;
 939                 }
 940                 if (!options.contains(CREATE) &amp;&amp; !options.contains(CREATE_NEW))
 941                     throw new NoSuchFileException(getString(path));
 942                 checkParents(path);
 943                 return new EntryOutputChannel(
<a name="54" id="anc54"></a><span class="line-modified"> 944                     supportPosix ?</span>
<span class="line-modified"> 945                         new PosixEntry(path, Entry.NEW, false, defaultCompressionMethod, attrs) :</span>
<span class="line-added"> 946                         new Entry(path, Entry.NEW, false, defaultCompressionMethod, attrs));</span>
 947             } finally {
 948                 endRead();
 949             }
 950         } else {
 951             beginRead();
 952             try {
 953                 ensureOpen();
 954                 Entry e = getEntry(path);
 955                 if (e == null || e.isDir())
 956                     throw new NoSuchFileException(getString(path));
 957                 try (InputStream is = getInputStream(e)) {
 958                     // TBD: if (e.size &lt; NNNNN);
 959                     return new ByteArrayChannel(is.readAllBytes(), true);
 960                 }
 961             } finally {
 962                 endRead();
 963             }
 964         }
 965     }
 966 
 967     // Returns a FileChannel of the specified entry.
 968     //
 969     // This implementation creates a temporary file on the default file system,
 970     // copy the entry data into it if the entry exists, and then create a
 971     // FileChannel on top of it.
 972     FileChannel newFileChannel(byte[] path,
 973                                Set&lt;? extends OpenOption&gt; options,
 974                                FileAttribute&lt;?&gt;... attrs)
 975         throws IOException
 976     {
 977         checkOptions(options);
 978         final  boolean forWrite = (options.contains(StandardOpenOption.WRITE) ||
 979                                    options.contains(StandardOpenOption.APPEND));
 980         beginRead();
 981         try {
 982             ensureOpen();
 983             Entry e = getEntry(path);
 984             if (forWrite) {
 985                 checkWritable();
 986                 if (e == null) {
 987                     if (!options.contains(StandardOpenOption.CREATE) &amp;&amp;
 988                         !options.contains(StandardOpenOption.CREATE_NEW)) {
 989                         throw new NoSuchFileException(getString(path));
 990                     }
 991                 } else {
 992                     if (options.contains(StandardOpenOption.CREATE_NEW)) {
 993                         throw new FileAlreadyExistsException(getString(path));
 994                     }
 995                     if (e.isDir())
 996                         throw new FileAlreadyExistsException(&quot;directory &lt;&quot;
 997                             + getString(path) + &quot;&gt; exists&quot;);
 998                 }
 999                 options = new HashSet&lt;&gt;(options);
1000                 options.remove(StandardOpenOption.CREATE_NEW); // for tmpfile
1001             } else if (e == null || e.isDir()) {
1002                 throw new NoSuchFileException(getString(path));
1003             }
1004 
1005             final boolean isFCH = (e != null &amp;&amp; e.type == Entry.FILECH);
1006             final Path tmpfile = isFCH ? e.file : getTempPathForEntry(path);
1007             final FileChannel fch = tmpfile.getFileSystem()
1008                                            .provider()
1009                                            .newFileChannel(tmpfile, options, attrs);
<a name="55" id="anc55"></a><span class="line-modified">1010             final Entry u = isFCH ? e : (</span>
<span class="line-added">1011                 supportPosix ?</span>
<span class="line-added">1012                 new PosixEntry(path, tmpfile, Entry.FILECH, attrs) :</span>
<span class="line-added">1013                 new Entry(path, tmpfile, Entry.FILECH, attrs));</span>
1014             if (forWrite) {
1015                 u.flag = FLAG_DATADESCR;
<a name="56" id="anc56"></a><span class="line-modified">1016                 u.method = defaultCompressionMethod;</span>
1017             }
1018             // is there a better way to hook into the FileChannel&#39;s close method?
1019             return new FileChannel() {
1020                 public int write(ByteBuffer src) throws IOException {
1021                     return fch.write(src);
1022                 }
1023                 public long write(ByteBuffer[] srcs, int offset, int length)
1024                     throws IOException
1025                 {
1026                     return fch.write(srcs, offset, length);
1027                 }
1028                 public long position() throws IOException {
1029                     return fch.position();
1030                 }
1031                 public FileChannel position(long newPosition)
1032                     throws IOException
1033                 {
1034                     fch.position(newPosition);
1035                     return this;
1036                 }
1037                 public long size() throws IOException {
1038                     return fch.size();
1039                 }
1040                 public FileChannel truncate(long size)
1041                     throws IOException
1042                 {
1043                     fch.truncate(size);
1044                     return this;
1045                 }
1046                 public void force(boolean metaData)
1047                     throws IOException
1048                 {
1049                     fch.force(metaData);
1050                 }
1051                 public long transferTo(long position, long count,
1052                                        WritableByteChannel target)
1053                     throws IOException
1054                 {
1055                     return fch.transferTo(position, count, target);
1056                 }
1057                 public long transferFrom(ReadableByteChannel src,
1058                                          long position, long count)
1059                     throws IOException
1060                 {
1061                     return fch.transferFrom(src, position, count);
1062                 }
1063                 public int read(ByteBuffer dst) throws IOException {
1064                     return fch.read(dst);
1065                 }
1066                 public int read(ByteBuffer dst, long position)
1067                     throws IOException
1068                 {
1069                     return fch.read(dst, position);
1070                 }
1071                 public long read(ByteBuffer[] dsts, int offset, int length)
1072                     throws IOException
1073                 {
1074                     return fch.read(dsts, offset, length);
1075                 }
1076                 public int write(ByteBuffer src, long position)
1077                     throws IOException
1078                     {
1079                    return fch.write(src, position);
1080                 }
1081                 public MappedByteBuffer map(MapMode mode,
1082                                             long position, long size)
<a name="57" id="anc57"></a>
1083                 {
1084                     throw new UnsupportedOperationException();
1085                 }
1086                 public FileLock lock(long position, long size, boolean shared)
1087                     throws IOException
1088                 {
1089                     return fch.lock(position, size, shared);
1090                 }
1091                 public FileLock tryLock(long position, long size, boolean shared)
1092                     throws IOException
1093                 {
1094                     return fch.tryLock(position, size, shared);
1095                 }
1096                 protected void implCloseChannel() throws IOException {
1097                     fch.close();
1098                     if (forWrite) {
1099                         u.mtime = System.currentTimeMillis();
1100                         u.size = Files.size(u.file);
<a name="58" id="anc58"></a>
1101                         update(u);
1102                     } else {
1103                         if (!isFCH)    // if this is a new fch for reading
1104                             removeTempPathForEntry(tmpfile);
1105                     }
1106                }
1107             };
1108         } finally {
1109             endRead();
1110         }
1111     }
1112 
1113     // the outstanding input streams that need to be closed
1114     private Set&lt;InputStream&gt; streams =
<a name="59" id="anc59"></a><span class="line-modified">1115         Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
<span class="line-added">1116 </span>
<span class="line-added">1117     // the ex-channel and ex-path that need to close when their outstanding</span>
<span class="line-added">1118     // input streams are all closed by the obtainers.</span>
<span class="line-added">1119     private final Set&lt;ExistingChannelCloser&gt; exChClosers = new HashSet&lt;&gt;();</span>
1120 
<a name="60" id="anc60"></a><span class="line-modified">1121     private final Set&lt;Path&gt; tmppaths = Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
1122     private Path getTempPathForEntry(byte[] path) throws IOException {
1123         Path tmpPath = createTempFileInSameDirectoryAs(zfpath);
1124         if (path != null) {
1125             Entry e = getEntry(path);
1126             if (e != null) {
1127                 try (InputStream is = newInputStream(path)) {
1128                     Files.copy(is, tmpPath, REPLACE_EXISTING);
1129                 }
1130             }
1131         }
1132         return tmpPath;
1133     }
1134 
1135     private void removeTempPathForEntry(Path path) throws IOException {
1136         Files.delete(path);
1137         tmppaths.remove(path);
1138     }
1139 
<a name="61" id="anc61"></a><span class="line-modified">1140     // check if all parents really exist. ZIP spec does not require</span>
1141     // the existence of any &quot;parent directory&quot;.
1142     private void checkParents(byte[] path) throws IOException {
1143         beginRead();
1144         try {
1145             while ((path = getParent(path)) != null &amp;&amp;
1146                     path != ROOTPATH) {
1147                 if (!inodes.containsKey(IndexNode.keyOf(path))) {
1148                     throw new NoSuchFileException(getString(path));
1149                 }
1150             }
1151         } finally {
1152             endRead();
1153         }
1154     }
1155 
<a name="62" id="anc62"></a>
1156     private static byte[] getParent(byte[] path) {
1157         int off = getParentOff(path);
1158         if (off &lt;= 1)
1159             return ROOTPATH;
1160         return Arrays.copyOf(path, off);
1161     }
1162 
1163     private static int getParentOff(byte[] path) {
1164         int off = path.length - 1;
1165         if (off &gt; 0 &amp;&amp; path[off] == &#39;/&#39;)  // isDirectory
1166             off--;
1167         while (off &gt; 0 &amp;&amp; path[off] != &#39;/&#39;) { off--; }
1168         return off;
1169     }
1170 
<a name="63" id="anc63"></a><span class="line-modified">1171     private void beginWrite() {</span>
1172         rwlock.writeLock().lock();
1173     }
1174 
<a name="64" id="anc64"></a><span class="line-modified">1175     private void endWrite() {</span>
1176         rwlock.writeLock().unlock();
1177     }
1178 
<a name="65" id="anc65"></a><span class="line-modified">1179     private void beginRead() {</span>
1180         rwlock.readLock().lock();
1181     }
1182 
<a name="66" id="anc66"></a><span class="line-modified">1183     private void endRead() {</span>
1184         rwlock.readLock().unlock();
1185     }
1186 
1187     ///////////////////////////////////////////////////////////////////
1188 
1189     private volatile boolean isOpen = true;
1190     private final SeekableByteChannel ch; // channel to the zipfile
1191     final byte[]  cen;     // CEN &amp; ENDHDR
1192     private END  end;
1193     private long locpos;   // position of first LOC header (usually 0)
1194 
1195     private final ReadWriteLock rwlock = new ReentrantReadWriteLock();
1196 
1197     // name -&gt; pos (in cen), IndexNode itself can be used as a &quot;key&quot;
1198     private LinkedHashMap&lt;IndexNode, IndexNode&gt; inodes;
1199 
1200     final byte[] getBytes(String name) {
1201         return zc.getBytes(name);
1202     }
1203 
1204     final String getString(byte[] name) {
1205         return zc.toString(name);
1206     }
1207 
1208     @SuppressWarnings(&quot;deprecation&quot;)
1209     protected void finalize() throws IOException {
1210         close();
1211     }
1212 
1213     // Reads len bytes of data from the specified offset into buf.
1214     // Returns the total number of bytes read.
1215     // Each/every byte read from here (except the cen, which is mapped).
1216     final long readFullyAt(byte[] buf, int off, long len, long pos)
1217         throws IOException
1218     {
1219         ByteBuffer bb = ByteBuffer.wrap(buf);
1220         bb.position(off);
1221         bb.limit((int)(off + len));
1222         return readFullyAt(bb, pos);
1223     }
1224 
<a name="67" id="anc67"></a><span class="line-modified">1225     private long readFullyAt(ByteBuffer bb, long pos) throws IOException {</span>


1226         synchronized(ch) {
1227             return ch.position(pos).read(bb);
1228         }
1229     }
1230 
1231     // Searches for end of central directory (END) header. The contents of
1232     // the END header will be read and placed in endbuf. Returns the file
1233     // position of the END header, otherwise returns -1 if the END header
1234     // was not found or an error occurred.
<a name="68" id="anc68"></a><span class="line-modified">1235     private END findEND() throws IOException {</span>

1236         byte[] buf = new byte[READBLOCKSZ];
1237         long ziplen = ch.size();
1238         long minHDR = (ziplen - END_MAXLEN) &gt; 0 ? ziplen - END_MAXLEN : 0;
1239         long minPos = minHDR - (buf.length - ENDHDR);
1240 
<a name="69" id="anc69"></a><span class="line-modified">1241         for (long pos = ziplen - buf.length; pos &gt;= minPos; pos -= (buf.length - ENDHDR)) {</span>

1242             int off = 0;
1243             if (pos &lt; 0) {
1244                 // Pretend there are some NUL bytes before start of file
1245                 off = (int)-pos;
1246                 Arrays.fill(buf, 0, off, (byte)0);
1247             }
1248             int len = buf.length - off;
1249             if (readFullyAt(buf, off, len, pos + off) != len)
<a name="70" id="anc70"></a><span class="line-modified">1250                 throw new ZipException(&quot;zip END header not found&quot;);</span>
1251 
1252             // Now scan the block backwards for END header signature
1253             for (int i = buf.length - ENDHDR; i &gt;= 0; i--) {
<a name="71" id="anc71"></a><span class="line-modified">1254                 if (buf[i]   == (byte)&#39;P&#39;    &amp;&amp;</span>
1255                     buf[i+1] == (byte)&#39;K&#39;    &amp;&amp;
1256                     buf[i+2] == (byte)&#39;\005&#39; &amp;&amp;
1257                     buf[i+3] == (byte)&#39;\006&#39; &amp;&amp;
1258                     (pos + i + ENDHDR + ENDCOM(buf, i) == ziplen)) {
1259                     // Found END header
1260                     buf = Arrays.copyOfRange(buf, i, i + ENDHDR);
1261                     END end = new END();
<a name="72" id="anc72"></a><span class="line-modified">1262                     // end.endsub = ENDSUB(buf); // not used</span>
1263                     end.centot = ENDTOT(buf);
1264                     end.cenlen = ENDSIZ(buf);
1265                     end.cenoff = ENDOFF(buf);
<a name="73" id="anc73"></a><span class="line-modified">1266                     // end.comlen = ENDCOM(buf); // not used</span>
1267                     end.endpos = pos + i;
1268                     // try if there is zip64 end;
1269                     byte[] loc64 = new byte[ZIP64_LOCHDR];
1270                     if (end.endpos &lt; ZIP64_LOCHDR ||
1271                         readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)
1272                         != loc64.length ||
1273                         !locator64SigAt(loc64, 0)) {
1274                         return end;
1275                     }
1276                     long end64pos = ZIP64_LOCOFF(loc64);
1277                     byte[] end64buf = new byte[ZIP64_ENDHDR];
1278                     if (readFullyAt(end64buf, 0, end64buf.length, end64pos)
1279                         != end64buf.length ||
1280                         !end64SigAt(end64buf, 0)) {
1281                         return end;
1282                     }
1283                     // end64 found,
1284                     long cenlen64 = ZIP64_ENDSIZ(end64buf);
1285                     long cenoff64 = ZIP64_ENDOFF(end64buf);
1286                     long centot64 = ZIP64_ENDTOT(end64buf);
1287                     // double-check
1288                     if (cenlen64 != end.cenlen &amp;&amp; end.cenlen != ZIP64_MINVAL ||
1289                         cenoff64 != end.cenoff &amp;&amp; end.cenoff != ZIP64_MINVAL ||
1290                         centot64 != end.centot &amp;&amp; end.centot != ZIP64_MINVAL32) {
1291                         return end;
1292                     }
1293                     // to use the end64 values
1294                     end.cenlen = cenlen64;
1295                     end.cenoff = cenoff64;
1296                     end.centot = (int)centot64; // assume total &lt; 2g
1297                     end.endpos = end64pos;
1298                     return end;
1299                 }
1300             }
1301         }
<a name="74" id="anc74"></a><span class="line-modified">1302         throw new ZipException(&quot;zip END header not found&quot;);</span>
<span class="line-modified">1303     }</span>
<span class="line-added">1304 </span>
<span class="line-added">1305     private void makeParentDirs(IndexNode node, IndexNode root) {</span>
<span class="line-added">1306         IndexNode parent;</span>
<span class="line-added">1307         ParentLookup lookup = new ParentLookup();</span>
<span class="line-added">1308         while (true) {</span>
<span class="line-added">1309             int off = getParentOff(node.name);</span>
<span class="line-added">1310             // parent is root</span>
<span class="line-added">1311             if (off &lt;= 1) {</span>
<span class="line-added">1312                 node.sibling = root.child;</span>
<span class="line-added">1313                 root.child = node;</span>
<span class="line-added">1314                 break;</span>
<span class="line-added">1315             }</span>
<span class="line-added">1316             // parent exists</span>
<span class="line-added">1317             lookup = lookup.as(node.name, off);</span>
<span class="line-added">1318             if (inodes.containsKey(lookup)) {</span>
<span class="line-added">1319                 parent = inodes.get(lookup);</span>
<span class="line-added">1320                 node.sibling = parent.child;</span>
<span class="line-added">1321                 parent.child = node;</span>
<span class="line-added">1322                 break;</span>
<span class="line-added">1323             }</span>
<span class="line-added">1324             // parent does not exist, add new pseudo directory entry</span>
<span class="line-added">1325             parent = new IndexNode(Arrays.copyOf(node.name, off), true);</span>
<span class="line-added">1326             inodes.put(parent, parent);</span>
<span class="line-added">1327             node.sibling = parent.child;</span>
<span class="line-added">1328             parent.child = node;</span>
<span class="line-added">1329             node = parent;</span>
<span class="line-added">1330         }</span>
<span class="line-added">1331     }</span>
<span class="line-added">1332 </span>
<span class="line-added">1333     // ZIP directory has two issues:</span>
<span class="line-added">1334     // (1) ZIP spec does not require the ZIP file to include</span>
<span class="line-added">1335     //     directory entry</span>
<span class="line-added">1336     // (2) all entries are not stored/organized in a &quot;tree&quot;</span>
<span class="line-added">1337     //     structure.</span>
<span class="line-added">1338     // A possible solution is to build the node tree ourself as</span>
<span class="line-added">1339     // implemented below.</span>
<span class="line-added">1340     private void buildNodeTree() {</span>
<span class="line-added">1341         beginWrite();</span>
<span class="line-added">1342         try {</span>
<span class="line-added">1343             IndexNode root = inodes.remove(LOOKUPKEY.as(ROOTPATH));</span>
<span class="line-added">1344             if (root == null) {</span>
<span class="line-added">1345                 root = new IndexNode(ROOTPATH, true);</span>
<span class="line-added">1346             }</span>
<span class="line-added">1347             IndexNode[] nodes = inodes.values().toArray(new IndexNode[0]);</span>
<span class="line-added">1348             inodes.put(root, root);</span>
<span class="line-added">1349             for (IndexNode node : nodes) {</span>
<span class="line-added">1350                 makeParentDirs(node, root);</span>
<span class="line-added">1351             }</span>
<span class="line-added">1352         } finally {</span>
<span class="line-added">1353             endWrite();</span>
<span class="line-added">1354         }</span>
<span class="line-added">1355     }</span>
<span class="line-added">1356 </span>
<span class="line-added">1357     private void removeFromTree(IndexNode inode) {</span>
<span class="line-added">1358         IndexNode parent = inodes.get(LOOKUPKEY.as(getParent(inode.name)));</span>
<span class="line-added">1359         IndexNode child = parent.child;</span>
<span class="line-added">1360         if (child.equals(inode)) {</span>
<span class="line-added">1361             parent.child = child.sibling;</span>
<span class="line-added">1362         } else {</span>
<span class="line-added">1363             IndexNode last = child;</span>
<span class="line-added">1364             while ((child = child.sibling) != null) {</span>
<span class="line-added">1365                 if (child.equals(inode)) {</span>
<span class="line-added">1366                     last.sibling = child.sibling;</span>
<span class="line-added">1367                     break;</span>
<span class="line-added">1368                 } else {</span>
<span class="line-added">1369                     last = child;</span>
<span class="line-added">1370                 }</span>
<span class="line-added">1371             }</span>
<span class="line-added">1372         }</span>
<span class="line-added">1373     }</span>
<span class="line-added">1374 </span>
<span class="line-added">1375     /**</span>
<span class="line-added">1376      * If a version property has been specified and the file represents a multi-release JAR,</span>
<span class="line-added">1377      * determine the requested runtime version and initialize the ZipFileSystem instance accordingly.</span>
<span class="line-added">1378      *</span>
<span class="line-added">1379      * Checks if the Zip File System property &quot;releaseVersion&quot; has been specified. If it has,</span>
<span class="line-added">1380      * use its value to determine the requested version. If not use the value of the &quot;multi-release&quot; property.</span>
<span class="line-added">1381      */</span>
<span class="line-added">1382     private void initializeReleaseVersion(Map&lt;String, ?&gt; env) throws IOException {</span>
<span class="line-added">1383         Object o = env.containsKey(PROPERTY_RELEASE_VERSION) ?</span>
<span class="line-added">1384             env.get(PROPERTY_RELEASE_VERSION) :</span>
<span class="line-added">1385             env.get(PROPERTY_MULTI_RELEASE);</span>
<span class="line-added">1386 </span>
<span class="line-added">1387         if (o != null &amp;&amp; isMultiReleaseJar()) {</span>
<span class="line-added">1388             int version;</span>
<span class="line-added">1389             if (o instanceof String) {</span>
<span class="line-added">1390                 String s = (String)o;</span>
<span class="line-added">1391                 if (s.equals(&quot;runtime&quot;)) {</span>
<span class="line-added">1392                     version = Runtime.version().feature();</span>
<span class="line-added">1393                 } else if (s.matches(&quot;^[1-9][0-9]*$&quot;)) {</span>
<span class="line-added">1394                     version = Version.parse(s).feature();</span>
<span class="line-added">1395                 } else {</span>
<span class="line-added">1396                     throw new IllegalArgumentException(&quot;Invalid runtime version&quot;);</span>
<span class="line-added">1397                 }</span>
<span class="line-added">1398             } else if (o instanceof Integer) {</span>
<span class="line-added">1399                 version = Version.parse(((Integer)o).toString()).feature();</span>
<span class="line-added">1400             } else if (o instanceof Version) {</span>
<span class="line-added">1401                 version = ((Version)o).feature();</span>
<span class="line-added">1402             } else {</span>
<span class="line-added">1403                 throw new IllegalArgumentException(&quot;env parameter must be String, &quot; +</span>
<span class="line-added">1404                     &quot;Integer, or Version&quot;);</span>
<span class="line-added">1405             }</span>
<span class="line-added">1406             createVersionedLinks(version &lt; 0 ? 0 : version);</span>
<span class="line-added">1407             setReadOnly();</span>
<span class="line-added">1408         }</span>
<span class="line-added">1409     }</span>
<span class="line-added">1410 </span>
<span class="line-added">1411     /**</span>
<span class="line-added">1412      * Returns true if the Manifest main attribute &quot;Multi-Release&quot; is set to true; false otherwise.</span>
<span class="line-added">1413      */</span>
<span class="line-added">1414     private boolean isMultiReleaseJar() throws IOException {</span>
<span class="line-added">1415         try (InputStream is = newInputStream(getBytes(&quot;/META-INF/MANIFEST.MF&quot;))) {</span>
<span class="line-added">1416             String multiRelease = new Manifest(is).getMainAttributes()</span>
<span class="line-added">1417                 .getValue(Attributes.Name.MULTI_RELEASE);</span>
<span class="line-added">1418             return &quot;true&quot;.equalsIgnoreCase(multiRelease);</span>
<span class="line-added">1419         } catch (NoSuchFileException x) {</span>
<span class="line-added">1420             return false;</span>
<span class="line-added">1421         }</span>
<span class="line-added">1422     }</span>
<span class="line-added">1423 </span>
<span class="line-added">1424     /**</span>
<span class="line-added">1425      * Create a map of aliases for versioned entries, for example:</span>
<span class="line-added">1426      *   version/PackagePrivate.class -&gt; META-INF/versions/9/version/PackagePrivate.class</span>
<span class="line-added">1427      *   version/PackagePrivate.java -&gt; META-INF/versions/9/version/PackagePrivate.java</span>
<span class="line-added">1428      *   version/Version.class -&gt; META-INF/versions/10/version/Version.class</span>
<span class="line-added">1429      *   version/Version.java -&gt; META-INF/versions/10/version/Version.java</span>
<span class="line-added">1430      *</span>
<span class="line-added">1431      * Then wrap the map in a function that getEntry can use to override root</span>
<span class="line-added">1432      * entry lookup for entries that have corresponding versioned entries.</span>
<span class="line-added">1433      */</span>
<span class="line-added">1434     private void createVersionedLinks(int version) {</span>
<span class="line-added">1435         IndexNode verdir = getInode(getBytes(&quot;/META-INF/versions&quot;));</span>
<span class="line-added">1436         // nothing to do, if no /META-INF/versions</span>
<span class="line-added">1437         if (verdir == null) {</span>
<span class="line-added">1438             return;</span>
<span class="line-added">1439         }</span>
<span class="line-added">1440         // otherwise, create a map and for each META-INF/versions/{n} directory</span>
<span class="line-added">1441         // put all the leaf inodes, i.e. entries, into the alias map</span>
<span class="line-added">1442         // possibly shadowing lower versioned entries</span>
<span class="line-added">1443         HashMap&lt;IndexNode, byte[]&gt; aliasMap = new HashMap&lt;&gt;();</span>
<span class="line-added">1444         getVersionMap(version, verdir).values().forEach(versionNode -&gt;</span>
<span class="line-added">1445             walk(versionNode.child, entryNode -&gt;</span>
<span class="line-added">1446                 aliasMap.put(</span>
<span class="line-added">1447                     getOrCreateInode(getRootName(entryNode, versionNode), entryNode.isdir),</span>
<span class="line-added">1448                     entryNode.name))</span>
<span class="line-added">1449         );</span>
<span class="line-added">1450         entryLookup = path -&gt; {</span>
<span class="line-added">1451             byte[] entry = aliasMap.get(IndexNode.keyOf(path));</span>
<span class="line-added">1452             return entry == null ? path : entry;</span>
<span class="line-added">1453         };</span>
<span class="line-added">1454     }</span>
<span class="line-added">1455 </span>
<span class="line-added">1456     /**</span>
<span class="line-added">1457      * Create a sorted version map of version -&gt; inode, for inodes &lt;= max version.</span>
<span class="line-added">1458      *   9 -&gt; META-INF/versions/9</span>
<span class="line-added">1459      *  10 -&gt; META-INF/versions/10</span>
<span class="line-added">1460      */</span>
<span class="line-added">1461     private TreeMap&lt;Integer, IndexNode&gt; getVersionMap(int version, IndexNode metaInfVersions) {</span>
<span class="line-added">1462         TreeMap&lt;Integer,IndexNode&gt; map = new TreeMap&lt;&gt;();</span>
<span class="line-added">1463         IndexNode child = metaInfVersions.child;</span>
<span class="line-added">1464         while (child != null) {</span>
<span class="line-added">1465             Integer key = getVersion(child, metaInfVersions);</span>
<span class="line-added">1466             if (key != null &amp;&amp; key &lt;= version) {</span>
<span class="line-added">1467                 map.put(key, child);</span>
<span class="line-added">1468             }</span>
<span class="line-added">1469             child = child.sibling;</span>
<span class="line-added">1470         }</span>
<span class="line-added">1471         return map;</span>
<span class="line-added">1472     }</span>
<span class="line-added">1473 </span>
<span class="line-added">1474     /**</span>
<span class="line-added">1475      * Extract the integer version number -- META-INF/versions/9 returns 9.</span>
<span class="line-added">1476      */</span>
<span class="line-added">1477     private Integer getVersion(IndexNode inode, IndexNode metaInfVersions) {</span>
<span class="line-added">1478         try {</span>
<span class="line-added">1479             byte[] fullName = inode.name;</span>
<span class="line-added">1480             return Integer.parseInt(getString(Arrays</span>
<span class="line-added">1481                 .copyOfRange(fullName, metaInfVersions.name.length + 1, fullName.length)));</span>
<span class="line-added">1482         } catch (NumberFormatException x) {</span>
<span class="line-added">1483             // ignore this even though it might indicate issues with the JAR structure</span>
<span class="line-added">1484             return null;</span>
<span class="line-added">1485         }</span>
<span class="line-added">1486     }</span>
<span class="line-added">1487 </span>
<span class="line-added">1488     /**</span>
<span class="line-added">1489      * Walk the IndexNode tree processing all leaf nodes.</span>
<span class="line-added">1490      */</span>
<span class="line-added">1491     private void walk(IndexNode inode, Consumer&lt;IndexNode&gt; consumer) {</span>
<span class="line-added">1492         if (inode == null) return;</span>
<span class="line-added">1493         if (inode.isDir()) {</span>
<span class="line-added">1494             walk(inode.child, consumer);</span>
<span class="line-added">1495         } else {</span>
<span class="line-added">1496             consumer.accept(inode);</span>
<span class="line-added">1497         }</span>
<span class="line-added">1498         walk(inode.sibling, consumer);</span>
<span class="line-added">1499     }</span>
<span class="line-added">1500 </span>
<span class="line-added">1501     /**</span>
<span class="line-added">1502      * Extract the root name from a versioned entry name.</span>
<span class="line-added">1503      * E.g. given inode &#39;META-INF/versions/9/foo/bar.class&#39;</span>
<span class="line-added">1504      * and prefix &#39;META-INF/versions/9/&#39; returns &#39;foo/bar.class&#39;.</span>
<span class="line-added">1505      */</span>
<span class="line-added">1506     private byte[] getRootName(IndexNode inode, IndexNode prefix) {</span>
<span class="line-added">1507         byte[] fullName = inode.name;</span>
<span class="line-added">1508         return Arrays.copyOfRange(fullName, prefix.name.length, fullName.length);</span>
1509     }
1510 
1511     // Reads zip file central directory. Returns the file position of first
1512     // CEN header, otherwise returns -1 if an error occurred. If zip-&gt;msg != NULL
1513     // then the error was a zip format error and zip-&gt;msg has the error text.
1514     // Always pass in -1 for knownTotal; it&#39;s used for a recursive call.
1515     private byte[] initCEN() throws IOException {
1516         end = findEND();
1517         if (end.endpos == 0) {
1518             inodes = new LinkedHashMap&lt;&gt;(10);
1519             locpos = 0;
1520             buildNodeTree();
1521             return null;         // only END header present
1522         }
1523         if (end.cenlen &gt; end.endpos)
<a name="75" id="anc75"></a><span class="line-modified">1524             throw new ZipException(&quot;invalid END header (bad central directory size)&quot;);</span>
1525         long cenpos = end.endpos - end.cenlen;     // position of CEN table
1526 
1527         // Get position of first local file (LOC) header, taking into
1528         // account that there may be a stub prefixed to the zip file.
1529         locpos = cenpos - end.cenoff;
1530         if (locpos &lt; 0)
<a name="76" id="anc76"></a><span class="line-modified">1531             throw new ZipException(&quot;invalid END header (bad central directory offset)&quot;);</span>
1532 
1533         // read in the CEN and END
1534         byte[] cen = new byte[(int)(end.cenlen + ENDHDR)];
1535         if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
<a name="77" id="anc77"></a><span class="line-modified">1536             throw new ZipException(&quot;read CEN tables failed&quot;);</span>
1537         }
1538         // Iterate through the entries in the central directory
1539         inodes = new LinkedHashMap&lt;&gt;(end.centot + 1);
1540         int pos = 0;
1541         int limit = cen.length - ENDHDR;
1542         while (pos &lt; limit) {
1543             if (!cenSigAt(cen, pos))
<a name="78" id="anc78"></a><span class="line-modified">1544                 throw new ZipException(&quot;invalid CEN header (bad signature)&quot;);</span>
1545             int method = CENHOW(cen, pos);
1546             int nlen   = CENNAM(cen, pos);
1547             int elen   = CENEXT(cen, pos);
1548             int clen   = CENCOM(cen, pos);
1549             if ((CENFLG(cen, pos) &amp; 1) != 0) {
<a name="79" id="anc79"></a><span class="line-modified">1550                 throw new ZipException(&quot;invalid CEN header (encrypted entry)&quot;);</span>
1551             }
1552             if (method != METHOD_STORED &amp;&amp; method != METHOD_DEFLATED) {
<a name="80" id="anc80"></a><span class="line-modified">1553                 throw new ZipException(&quot;invalid CEN header (unsupported compression method: &quot; + method + &quot;)&quot;);</span>
1554             }
1555             if (pos + CENHDR + nlen &gt; limit) {
<a name="81" id="anc81"></a><span class="line-modified">1556                 throw new ZipException(&quot;invalid CEN header (bad header size)&quot;);</span>
1557             }
1558             IndexNode inode = new IndexNode(cen, pos, nlen);
1559             inodes.put(inode, inode);
1560 
1561             // skip ext and comment
1562             pos += (CENHDR + nlen + elen + clen);
1563         }
1564         if (pos + ENDHDR != cen.length) {
<a name="82" id="anc82"></a><span class="line-modified">1565             throw new ZipException(&quot;invalid CEN header (bad header size)&quot;);</span>
1566         }
1567         buildNodeTree();
1568         return cen;
1569     }
1570 
<a name="83" id="anc83"></a><span class="line-modified">1571     private void ensureOpen() {</span>
1572         if (!isOpen)
1573             throw new ClosedFileSystemException();
1574     }
1575 
1576     // Creates a new empty temporary file in the same directory as the
1577     // specified file.  A variant of Files.createTempFile.
<a name="84" id="anc84"></a><span class="line-modified">1578     private Path createTempFileInSameDirectoryAs(Path path) throws IOException {</span>


1579         Path parent = path.toAbsolutePath().getParent();
1580         Path dir = (parent == null) ? path.getFileSystem().getPath(&quot;.&quot;) : parent;
1581         Path tmpPath = Files.createTempFile(dir, &quot;zipfstmp&quot;, null);
1582         tmppaths.add(tmpPath);
1583         return tmpPath;
1584     }
1585 
1586     ////////////////////update &amp; sync //////////////////////////////////////
1587 
1588     private boolean hasUpdate = false;
1589 
1590     // shared key. consumer guarantees the &quot;writeLock&quot; before use it.
1591     private final IndexNode LOOKUPKEY = new IndexNode(null, -1);
1592 
1593     private void updateDelete(IndexNode inode) {
1594         beginWrite();
1595         try {
1596             removeFromTree(inode);
1597             inodes.remove(inode);
1598             hasUpdate = true;
1599         } finally {
1600              endWrite();
1601         }
1602     }
1603 
1604     private void update(Entry e) {
1605         beginWrite();
1606         try {
1607             IndexNode old = inodes.put(e, e);
1608             if (old != null) {
1609                 removeFromTree(old);
1610             }
1611             if (e.type == Entry.NEW || e.type == Entry.FILECH || e.type == Entry.COPY) {
1612                 IndexNode parent = inodes.get(LOOKUPKEY.as(getParent(e.name)));
1613                 e.sibling = parent.child;
1614                 parent.child = e;
1615             }
1616             hasUpdate = true;
1617         } finally {
1618             endWrite();
1619         }
1620     }
1621 
1622     // copy over the whole LOC entry (header if necessary, data and ext) from
1623     // old zip to the new one.
1624     private long copyLOCEntry(Entry e, boolean updateHeader,
1625                               OutputStream os,
1626                               long written, byte[] buf)
1627         throws IOException
1628     {
1629         long locoff = e.locoff;  // where to read
1630         e.locoff = written;      // update the e.locoff with new value
1631 
1632         // calculate the size need to write out
1633         long size = 0;
1634         //  if there is A ext
1635         if ((e.flag &amp; FLAG_DATADESCR) != 0) {
1636             if (e.size &gt;= ZIP64_MINVAL || e.csize &gt;= ZIP64_MINVAL)
1637                 size = 24;
1638             else
1639                 size = 16;
1640         }
1641         // read loc, use the original loc.elen/nlen
1642         //
1643         // an extra byte after loc is read, which should be the first byte of the
1644         // &#39;name&#39; field of the loc. if this byte is &#39;/&#39;, which means the original
1645         // entry has an absolute path in original zip/jar file, the e.writeLOC()
1646         // is used to output the loc, in which the leading &quot;/&quot; will be removed
1647         if (readFullyAt(buf, 0, LOCHDR + 1 , locoff) != LOCHDR + 1)
1648             throw new ZipException(&quot;loc: reading failed&quot;);
1649 
1650         if (updateHeader || LOCNAM(buf) &gt; 0 &amp;&amp; buf[LOCHDR] == &#39;/&#39;) {
1651             locoff += LOCHDR + LOCNAM(buf) + LOCEXT(buf);  // skip header
1652             size += e.csize;
1653             written = e.writeLOC(os) + size;
1654         } else {
1655             os.write(buf, 0, LOCHDR);    // write out the loc header
1656             locoff += LOCHDR;
1657             // use e.csize,  LOCSIZ(buf) is zero if FLAG_DATADESCR is on
1658             // size += LOCNAM(buf) + LOCEXT(buf) + LOCSIZ(buf);
1659             size += LOCNAM(buf) + LOCEXT(buf) + e.csize;
1660             written = LOCHDR + size;
1661         }
1662         int n;
1663         while (size &gt; 0 &amp;&amp;
1664             (n = (int)readFullyAt(buf, 0, buf.length, locoff)) != -1)
1665         {
1666             if (size &lt; n)
1667                 n = (int)size;
1668             os.write(buf, 0, n);
1669             size -= n;
1670             locoff += n;
1671         }
1672         return written;
1673     }
1674 
<a name="85" id="anc85"></a><span class="line-modified">1675     private long writeEntry(Entry e, OutputStream os)</span>
1676         throws IOException {
1677 
1678         if (e.bytes == null &amp;&amp; e.file == null)    // dir, 0-length data
1679             return 0;
1680 
1681         long written = 0;
<a name="86" id="anc86"></a><span class="line-modified">1682         if (e.method != METHOD_STORED &amp;&amp; e.csize &gt; 0 &amp;&amp; (e.crc != 0 || e.size == 0)) {</span>
<span class="line-modified">1683             // pre-compressed entry, write directly to output stream</span>
<span class="line-modified">1684             writeTo(e, os);</span>
<span class="line-modified">1685         } else {</span>
<span class="line-modified">1686             try (OutputStream os2 = (e.method == METHOD_STORED) ?</span>
<span class="line-modified">1687                     new EntryOutputStreamCRC32(e, os) : new EntryOutputStreamDef(e, os)) {</span>
<span class="line-modified">1688                 writeTo(e, os2);</span>





1689             }
1690         }
1691         written += e.csize;
1692         if ((e.flag &amp; FLAG_DATADESCR) != 0) {
1693             written += e.writeEXT(os);
1694         }
1695         return written;
1696     }
1697 
<a name="87" id="anc87"></a><span class="line-modified">1698     private void writeTo(Entry e, OutputStream os) throws IOException {</span>
<span class="line-modified">1699         if (e.bytes != null) {</span>
<span class="line-added">1700             os.write(e.bytes, 0, e.bytes.length);</span>
<span class="line-added">1701         } else if (e.file != null) {</span>
<span class="line-added">1702             if (e.type == Entry.NEW || e.type == Entry.FILECH) {</span>
<span class="line-added">1703                 try (InputStream is = Files.newInputStream(e.file)) {</span>
<span class="line-added">1704                     is.transferTo(os);</span>
<span class="line-added">1705                 }</span>
<span class="line-added">1706             }</span>
<span class="line-added">1707             Files.delete(e.file);</span>
<span class="line-added">1708             tmppaths.remove(e.file);</span>
<span class="line-added">1709         }</span>
<span class="line-added">1710     }</span>
1711 
<a name="88" id="anc88"></a><span class="line-added">1712     // sync the zip file system, if there is any update</span>
<span class="line-added">1713     private void sync() throws IOException {</span>
<span class="line-added">1714         // check ex-closer</span>
<span class="line-added">1715         if (!exChClosers.isEmpty()) {</span>
<span class="line-added">1716             for (ExistingChannelCloser ecc : exChClosers) {</span>
<span class="line-added">1717                 if (ecc.closeAndDeleteIfDone()) {</span>
<span class="line-added">1718                     exChClosers.remove(ecc);</span>
<span class="line-added">1719                 }</span>
<span class="line-added">1720             }</span>
<span class="line-added">1721         }</span>
1722         if (!hasUpdate)
1723             return;
<a name="89" id="anc89"></a><span class="line-added">1724         PosixFileAttributes attrs = getPosixAttributes(zfpath);</span>
1725         Path tmpFile = createTempFileInSameDirectoryAs(zfpath);
<a name="90" id="anc90"></a><span class="line-modified">1726         try (OutputStream os = new BufferedOutputStream(Files.newOutputStream(tmpFile, WRITE))) {</span>

1727             ArrayList&lt;Entry&gt; elist = new ArrayList&lt;&gt;(inodes.size());
1728             long written = 0;
<a name="91" id="anc91"></a><span class="line-modified">1729             byte[] buf = null;</span>
<span class="line-modified">1730             Entry e;</span>
1731 
1732             // write loc
1733             for (IndexNode inode : inodes.values()) {
1734                 if (inode instanceof Entry) {    // an updated inode
1735                     e = (Entry)inode;
1736                     try {
1737                         if (e.type == Entry.COPY) {
1738                             // entry copy: the only thing changed is the &quot;name&quot;
<a name="92" id="anc92"></a><span class="line-modified">1739                             // and &quot;nlen&quot; in LOC header, so we update/rewrite the</span>
1740                             // LOC in new file and simply copy the rest (data and
1741                             // ext) without enflating/deflating from the old zip
1742                             // file LOC entry.
<a name="93" id="anc93"></a><span class="line-added">1743                             if (buf == null)</span>
<span class="line-added">1744                                 buf = new byte[8192];</span>
1745                             written += copyLOCEntry(e, true, os, written, buf);
1746                         } else {                          // NEW, FILECH or CEN
1747                             e.locoff = written;
1748                             written += e.writeLOC(os);    // write loc header
<a name="94" id="anc94"></a><span class="line-modified">1749                             written += writeEntry(e, os);</span>
1750                         }
1751                         elist.add(e);
1752                     } catch (IOException x) {
1753                         x.printStackTrace();    // skip any in-accurate entry
1754                     }
1755                 } else {                        // unchanged inode
1756                     if (inode.pos == -1) {
1757                         continue;               // pseudo directory node
1758                     }
1759                     if (inode.name.length == 1 &amp;&amp; inode.name[0] == &#39;/&#39;) {
<a name="95" id="anc95"></a><span class="line-modified">1760                         continue;               // no root &#39;/&#39; directory even if it</span>
<span class="line-modified">1761                                                 // exists in original zip/jar file.</span>
1762                     }
<a name="96" id="anc96"></a><span class="line-modified">1763                     e = supportPosix ? new PosixEntry(this, inode) : new Entry(this, inode);</span>
1764                     try {
<a name="97" id="anc97"></a><span class="line-added">1765                         if (buf == null)</span>
<span class="line-added">1766                             buf = new byte[8192];</span>
1767                         written += copyLOCEntry(e, false, os, written, buf);
1768                         elist.add(e);
1769                     } catch (IOException x) {
1770                         x.printStackTrace();    // skip any wrong entry
1771                     }
1772                 }
1773             }
1774 
1775             // now write back the cen and end table
1776             end.cenoff = written;
1777             for (Entry entry : elist) {
1778                 written += entry.writeCEN(os);
1779             }
1780             end.centot = elist.size();
1781             end.cenlen = written - end.cenoff;
1782             end.write(os, written, forceEnd64);
1783         }
<a name="98" id="anc98"></a><span class="line-added">1784         if (!streams.isEmpty()) {</span>
<span class="line-added">1785             //</span>
<span class="line-added">1786             // There are outstanding input streams open on existing &quot;ch&quot;,</span>
<span class="line-added">1787             // so, don&#39;t close the &quot;cha&quot; and delete the &quot;file for now, let</span>
<span class="line-added">1788             // the &quot;ex-channel-closer&quot; to handle them</span>
<span class="line-added">1789             Path path = createTempFileInSameDirectoryAs(zfpath);</span>
<span class="line-added">1790             ExistingChannelCloser ecc = new ExistingChannelCloser(path,</span>
<span class="line-added">1791                                                                   ch,</span>
<span class="line-added">1792                                                                   streams);</span>
<span class="line-added">1793             Files.move(zfpath, path, REPLACE_EXISTING);</span>
<span class="line-added">1794             exChClosers.add(ecc);</span>
<span class="line-added">1795             streams = Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
<span class="line-added">1796         } else {</span>
<span class="line-added">1797             ch.close();</span>
<span class="line-added">1798             Files.delete(zfpath);</span>
<span class="line-added">1799         }</span>
1800 
<a name="99" id="anc99"></a><span class="line-modified">1801         // Set the POSIX permissions of the original Zip File if available</span>
<span class="line-modified">1802         // before moving the temp file</span>
<span class="line-added">1803         if (attrs != null) {</span>
<span class="line-added">1804             Files.setPosixFilePermissions(tmpFile, attrs.permissions());</span>
<span class="line-added">1805         }</span>
1806         Files.move(tmpFile, zfpath, REPLACE_EXISTING);
1807         hasUpdate = false;    // clear
1808     }
1809 
<a name="100" id="anc100"></a><span class="line-modified">1810     /**</span>
<span class="line-modified">1811      * Returns a file&#39;s POSIX file attributes.</span>
<span class="line-modified">1812      * @param path The path to the file</span>
<span class="line-modified">1813      * @return The POSIX file attributes for the specified file or</span>
<span class="line-added">1814      *         null if the POSIX attribute view is not available</span>
<span class="line-added">1815      * @throws IOException If an error occurs obtaining the POSIX attributes for</span>
<span class="line-added">1816      *                    the specified file</span>
<span class="line-added">1817      */</span>
<span class="line-added">1818     private PosixFileAttributes getPosixAttributes(Path path) throws IOException {</span>
<span class="line-added">1819         try {</span>
<span class="line-added">1820             PosixFileAttributeView view =</span>
<span class="line-added">1821                     Files.getFileAttributeView(path, PosixFileAttributeView.class);</span>
<span class="line-added">1822             // Return if the attribute view is not supported</span>
<span class="line-added">1823             if (view == null) {</span>
<span class="line-added">1824                 return null;</span>
<span class="line-added">1825             }</span>
<span class="line-added">1826             return view.readAttributes();</span>
<span class="line-added">1827         } catch (UnsupportedOperationException e) {</span>
<span class="line-added">1828             // PosixFileAttributes not available</span>
<span class="line-added">1829             return null;</span>
<span class="line-added">1830         }</span>
<span class="line-added">1831     }</span>
<span class="line-added">1832 </span>
<span class="line-added">1833     private IndexNode getInode(byte[] path) {</span>
<span class="line-added">1834         return inodes.get(IndexNode.keyOf(Objects.requireNonNull(entryLookup.apply(path), &quot;path&quot;)));</span>
<span class="line-added">1835     }</span>
<span class="line-added">1836 </span>
<span class="line-added">1837     /**</span>
<span class="line-added">1838      * Return the IndexNode from the root tree. If it doesn&#39;t exist,</span>
<span class="line-added">1839      * it gets created along with all parent directory IndexNodes.</span>
<span class="line-added">1840      */</span>
<span class="line-added">1841     private IndexNode getOrCreateInode(byte[] path, boolean isdir) {</span>
<span class="line-added">1842         IndexNode node = getInode(path);</span>
<span class="line-added">1843         // if node exists, return it</span>
<span class="line-added">1844         if (node != null) {</span>
<span class="line-added">1845             return node;</span>
<span class="line-added">1846         }</span>
<span class="line-added">1847 </span>
<span class="line-added">1848         // otherwise create new pseudo node and parent directory hierarchy</span>
<span class="line-added">1849         node = new IndexNode(path, isdir);</span>
<span class="line-added">1850         beginWrite();</span>
<span class="line-added">1851         try {</span>
<span class="line-added">1852             makeParentDirs(node, Objects.requireNonNull(inodes.get(IndexNode.keyOf(ROOTPATH)), &quot;no root node found&quot;));</span>
<span class="line-added">1853             return node;</span>
<span class="line-added">1854         } finally {</span>
<span class="line-added">1855             endWrite();</span>
<span class="line-added">1856         }</span>
1857     }
1858 
<a name="101" id="anc101"></a><span class="line-modified">1859     private Entry getEntry(byte[] path) throws IOException {</span>
1860         IndexNode inode = getInode(path);
1861         if (inode instanceof Entry)
1862             return (Entry)inode;
1863         if (inode == null || inode.pos == -1)
1864             return null;
<a name="102" id="anc102"></a><span class="line-modified">1865         return supportPosix ? new PosixEntry(this, inode): new Entry(this, inode);</span>
1866     }
1867 
1868     public void deleteFile(byte[] path, boolean failIfNotExists)
1869         throws IOException
1870     {
1871         checkWritable();
<a name="103" id="anc103"></a>
1872         IndexNode inode = getInode(path);
1873         if (inode == null) {
1874             if (path != null &amp;&amp; path.length == 0)
1875                 throw new ZipException(&quot;root directory &lt;/&gt; can&#39;t not be delete&quot;);
1876             if (failIfNotExists)
1877                 throw new NoSuchFileException(getString(path));
1878         } else {
1879             if (inode.isDir() &amp;&amp; inode.child != null)
1880                 throw new DirectoryNotEmptyException(getString(path));
1881             updateDelete(inode);
1882         }
1883     }
1884 
1885     // Returns an out stream for either
<a name="104" id="anc104"></a><span class="line-modified">1886     // (1) writing the contents of a new entry, if the entry exists, or</span>
1887     // (2) updating/replacing the contents of the specified existing entry.
1888     private OutputStream getOutputStream(Entry e) throws IOException {
<a name="105" id="anc105"></a>
1889         if (e.mtime == -1)
1890             e.mtime = System.currentTimeMillis();
1891         if (e.method == -1)
<a name="106" id="anc106"></a><span class="line-modified">1892             e.method = defaultCompressionMethod;</span>
1893         // store size, compressed size, and crc-32 in datadescr
1894         e.flag = FLAG_DATADESCR;
1895         if (zc.isUTF8())
1896             e.flag |= FLAG_USE_UTF8;
1897         OutputStream os;
1898         if (useTempFile) {
1899             e.file = getTempPathForEntry(null);
1900             os = Files.newOutputStream(e.file, WRITE);
1901         } else {
1902             os = new ByteArrayOutputStream((e.size &gt; 0)? (int)e.size : 8192);
1903         }
<a name="107" id="anc107"></a><span class="line-modified">1904         if (e.method == METHOD_DEFLATED) {</span>
<span class="line-added">1905             return new DeflatingEntryOutputStream(e, os);</span>
<span class="line-added">1906         } else {</span>
<span class="line-added">1907             return new EntryOutputStream(e, os);</span>
<span class="line-added">1908         }</span>
1909     }
1910 
1911     private class EntryOutputStream extends FilterOutputStream {
<a name="108" id="anc108"></a><span class="line-modified">1912         private final Entry e;</span>
1913         private long written;
1914         private boolean isClosed;
1915 
<a name="109" id="anc109"></a><span class="line-modified">1916         EntryOutputStream(Entry e, OutputStream os) {</span>
1917             super(os);
1918             this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
1919             // this.written = 0;
1920         }
1921 
1922         @Override
1923         public synchronized void write(int b) throws IOException {
1924             out.write(b);
1925             written += 1;
1926         }
1927 
1928         @Override
<a name="110" id="anc110"></a><span class="line-modified">1929         public synchronized void write(byte[] b, int off, int len)</span>
1930                 throws IOException {
1931             out.write(b, off, len);
1932             written += len;
1933         }
1934 
1935         @Override
1936         public synchronized void close() throws IOException {
1937             if (isClosed) {
1938                 return;
1939             }
1940             isClosed = true;
1941             e.size = written;
1942             if (out instanceof ByteArrayOutputStream)
1943                 e.bytes = ((ByteArrayOutputStream)out).toByteArray();
1944             super.close();
1945             update(e);
1946         }
1947     }
1948 
<a name="111" id="anc111"></a><span class="line-added">1949     // Output stream returned when writing &quot;deflated&quot; entries into memory,</span>
<span class="line-added">1950     // to enable eager (possibly parallel) deflation and reduce memory required.</span>
<span class="line-added">1951     private class DeflatingEntryOutputStream extends DeflaterOutputStream {</span>
<span class="line-added">1952         private final CRC32 crc;</span>
<span class="line-added">1953         private final Entry e;</span>
<span class="line-added">1954         private boolean isClosed;</span>
<span class="line-added">1955 </span>
<span class="line-added">1956         DeflatingEntryOutputStream(Entry e, OutputStream os) {</span>
<span class="line-added">1957             super(os, getDeflater());</span>
<span class="line-added">1958             this.e = Objects.requireNonNull(e, &quot;Zip entry is null&quot;);</span>
<span class="line-added">1959             this.crc = new CRC32();</span>
<span class="line-added">1960         }</span>
<span class="line-added">1961 </span>
<span class="line-added">1962         @Override</span>
<span class="line-added">1963         public synchronized void write(byte[] b, int off, int len)</span>
<span class="line-added">1964                 throws IOException {</span>
<span class="line-added">1965             super.write(b, off, len);</span>
<span class="line-added">1966             crc.update(b, off, len);</span>
<span class="line-added">1967         }</span>
<span class="line-added">1968 </span>
<span class="line-added">1969         @Override</span>
<span class="line-added">1970         public synchronized void close() throws IOException {</span>
<span class="line-added">1971             if (isClosed)</span>
<span class="line-added">1972                 return;</span>
<span class="line-added">1973             isClosed = true;</span>
<span class="line-added">1974             finish();</span>
<span class="line-added">1975             e.size  = def.getBytesRead();</span>
<span class="line-added">1976             e.csize = def.getBytesWritten();</span>
<span class="line-added">1977             e.crc = crc.getValue();</span>
<span class="line-added">1978             if (out instanceof ByteArrayOutputStream)</span>
<span class="line-added">1979                 e.bytes = ((ByteArrayOutputStream)out).toByteArray();</span>
<span class="line-added">1980             super.close();</span>
<span class="line-added">1981             update(e);</span>
<span class="line-added">1982             releaseDeflater(def);</span>
<span class="line-added">1983         }</span>
<span class="line-added">1984     }</span>
<span class="line-added">1985 </span>
1986     // Wrapper output stream class to write out a &quot;stored&quot; entry.
1987     // (1) this class does not close the underlying out stream when
1988     //     being closed.
1989     // (2) no need to be &quot;synchronized&quot;, only used by sync()
1990     private class EntryOutputStreamCRC32 extends FilterOutputStream {
<a name="112" id="anc112"></a><span class="line-modified">1991         private final CRC32 crc;</span>
<span class="line-modified">1992         private final Entry e;</span>
1993         private long written;
1994         private boolean isClosed;
1995 
<a name="113" id="anc113"></a><span class="line-modified">1996         EntryOutputStreamCRC32(Entry e, OutputStream os) {</span>
1997             super(os);
1998             this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
1999             this.crc = new CRC32();
2000         }
2001 
2002         @Override
2003         public void write(int b) throws IOException {
2004             out.write(b);
2005             crc.update(b);
2006             written += 1;
2007         }
2008 
2009         @Override
<a name="114" id="anc114"></a><span class="line-modified">2010         public void write(byte[] b, int off, int len)</span>
2011                 throws IOException {
2012             out.write(b, off, len);
2013             crc.update(b, off, len);
2014             written += len;
2015         }
2016 
2017         @Override
<a name="115" id="anc115"></a><span class="line-modified">2018         public void close() {</span>
2019             if (isClosed)
2020                 return;
2021             isClosed = true;
2022             e.size = e.csize = written;
2023             e.crc = crc.getValue();
2024         }
2025     }
2026 
2027     // Wrapper output stream class to write out a &quot;deflated&quot; entry.
2028     // (1) this class does not close the underlying out stream when
2029     //     being closed.
2030     // (2) no need to be &quot;synchronized&quot;, only used by sync()
2031     private class EntryOutputStreamDef extends DeflaterOutputStream {
<a name="116" id="anc116"></a><span class="line-modified">2032         private final CRC32 crc;</span>
<span class="line-modified">2033         private final Entry e;</span>
2034         private boolean isClosed;
2035 
<a name="117" id="anc117"></a><span class="line-modified">2036         EntryOutputStreamDef(Entry e, OutputStream os) {</span>
2037             super(os, getDeflater());
<a name="118" id="anc118"></a><span class="line-modified">2038             this.e = Objects.requireNonNull(e, &quot;Zip entry is null&quot;);</span>
2039             this.crc = new CRC32();
2040         }
2041 
2042         @Override
<a name="119" id="anc119"></a><span class="line-modified">2043         public void write(byte[] b, int off, int len) throws IOException {</span>

2044             super.write(b, off, len);
2045             crc.update(b, off, len);
2046         }
2047 
2048         @Override
2049         public void close() throws IOException {
2050             if (isClosed)
2051                 return;
2052             isClosed = true;
2053             finish();
<a name="120" id="anc120"></a><span class="line-modified">2054             e.size = def.getBytesRead();</span>
2055             e.csize = def.getBytesWritten();
2056             e.crc = crc.getValue();
2057             releaseDeflater(def);
2058         }
2059     }
2060 
2061     private InputStream getInputStream(Entry e)
2062         throws IOException
2063     {
<a name="121" id="anc121"></a><span class="line-modified">2064         InputStream eis;</span>

2065         if (e.type == Entry.NEW) {
<a name="122" id="anc122"></a>
2066             if (e.bytes != null)
<a name="123" id="anc123"></a><span class="line-modified">2067                 eis = new ByteArrayInputStream(e.bytes);</span>
2068             else if (e.file != null)
<a name="124" id="anc124"></a><span class="line-modified">2069                 eis = Files.newInputStream(e.file);</span>
2070             else
2071                 throw new ZipException(&quot;update entry data is missing&quot;);
2072         } else if (e.type == Entry.FILECH) {
2073             // FILECH result is un-compressed.
2074             eis = Files.newInputStream(e.file);
2075             // TBD: wrap to hook close()
2076             // streams.add(eis);
2077             return eis;
2078         } else {  // untouched CEN or COPY
2079             eis = new EntryInputStream(e, ch);
2080         }
2081         if (e.method == METHOD_DEFLATED) {
2082             // MORE: Compute good size for inflater stream:
2083             long bufSize = e.size + 2; // Inflater likes a bit of slack
2084             if (bufSize &gt; 65536)
2085                 bufSize = 8192;
2086             final long size = e.size;
2087             eis = new InflaterInputStream(eis, getInflater(), (int)bufSize) {
2088                 private boolean isClosed = false;
2089                 public void close() throws IOException {
2090                     if (!isClosed) {
2091                         releaseInflater(inf);
2092                         this.in.close();
2093                         isClosed = true;
2094                         streams.remove(this);
2095                     }
2096                 }
2097                 // Override fill() method to provide an extra &quot;dummy&quot; byte
2098                 // at the end of the input stream. This is required when
2099                 // using the &quot;nowrap&quot; Inflater option. (it appears the new
2100                 // zlib in 7 does not need it, but keep it for now)
2101                 protected void fill() throws IOException {
2102                     if (eof) {
2103                         throw new EOFException(
2104                             &quot;Unexpected end of ZLIB input stream&quot;);
2105                     }
2106                     len = this.in.read(buf, 0, buf.length);
2107                     if (len == -1) {
2108                         buf[0] = 0;
2109                         len = 1;
2110                         eof = true;
2111                     }
2112                     inf.setInput(buf, 0, len);
2113                 }
2114                 private boolean eof;
2115 
<a name="125" id="anc125"></a><span class="line-modified">2116                 public int available() {</span>
2117                     if (isClosed)
2118                         return 0;
2119                     long avail = size - inf.getBytesWritten();
2120                     return avail &gt; (long) Integer.MAX_VALUE ?
2121                         Integer.MAX_VALUE : (int) avail;
2122                 }
2123             };
2124         } else if (e.method == METHOD_STORED) {
2125             // TBD: wrap/ it does not seem necessary
2126         } else {
2127             throw new ZipException(&quot;invalid compression method&quot;);
2128         }
2129         streams.add(eis);
2130         return eis;
2131     }
2132 
2133     // Inner class implementing the input stream used to read
2134     // a (possibly compressed) zip file entry.
2135     private class EntryInputStream extends InputStream {
2136         private final SeekableByteChannel zfch; // local ref to zipfs&#39;s &quot;ch&quot;. zipfs.ch might
<a name="126" id="anc126"></a><span class="line-modified">2137                                                 // point to a new channel after sync()</span>
<span class="line-modified">2138         private long pos;                       // current position within entry data</span>
<span class="line-modified">2139         private long rem;                       // number of remaining bytes within entry</span>
2140 
2141         EntryInputStream(Entry e, SeekableByteChannel zfch)
2142             throws IOException
2143         {
2144             this.zfch = zfch;
2145             rem = e.csize;
2146             pos = e.locoff;
2147             if (pos == -1) {
2148                 Entry e2 = getEntry(e.name);
2149                 if (e2 == null) {
<a name="127" id="anc127"></a><span class="line-modified">2150                     throw new ZipException(&quot;invalid loc for entry &lt;&quot; + getString(e.name) + &quot;&gt;&quot;);</span>
2151                 }
2152                 pos = e2.locoff;
2153             }
2154             pos = -pos;  // lazy initialize the real data offset
2155         }
2156 
<a name="128" id="anc128"></a><span class="line-modified">2157         public int read(byte[] b, int off, int len) throws IOException {</span>
2158             ensureOpen();
2159             initDataPos();
2160             if (rem == 0) {
2161                 return -1;
2162             }
2163             if (len &lt;= 0) {
2164                 return 0;
2165             }
2166             if (len &gt; rem) {
2167                 len = (int) rem;
2168             }
2169             // readFullyAt()
<a name="129" id="anc129"></a><span class="line-modified">2170             long n;</span>
2171             ByteBuffer bb = ByteBuffer.wrap(b);
2172             bb.position(off);
2173             bb.limit(off + len);
2174             synchronized(zfch) {
2175                 n = zfch.position(pos).read(bb);
2176             }
2177             if (n &gt; 0) {
2178                 pos += n;
2179                 rem -= n;
2180             }
2181             if (rem == 0) {
2182                 close();
2183             }
2184             return (int)n;
2185         }
2186 
2187         public int read() throws IOException {
2188             byte[] b = new byte[1];
2189             if (read(b, 0, 1) == 1) {
2190                 return b[0] &amp; 0xff;
2191             } else {
2192                 return -1;
2193             }
2194         }
2195 
<a name="130" id="anc130"></a><span class="line-modified">2196         public long skip(long n) {</span>
2197             ensureOpen();
2198             if (n &gt; rem)
2199                 n = rem;
2200             pos += n;
2201             rem -= n;
2202             if (rem == 0) {
2203                 close();
2204             }
2205             return n;
2206         }
2207 
2208         public int available() {
2209             return rem &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;
2210         }
2211 
2212         public void close() {
2213             rem = 0;
2214             streams.remove(this);
2215         }
2216 
2217         private void initDataPos() throws IOException {
2218             if (pos &lt;= 0) {
2219                 pos = -pos + locpos;
2220                 byte[] buf = new byte[LOCHDR];
2221                 if (readFullyAt(buf, 0, buf.length, pos) != LOCHDR) {
2222                     throw new ZipException(&quot;invalid loc &quot; + pos + &quot; for entry reading&quot;);
2223                 }
2224                 pos += LOCHDR + LOCNAM(buf) + LOCEXT(buf);
2225             }
2226         }
2227     }
2228 
<a name="131" id="anc131"></a>



2229     // Maxmum number of de/inflater we cache
2230     private final int MAX_FLATER = 20;
2231     // List of available Inflater objects for decompression
2232     private final List&lt;Inflater&gt; inflaters = new ArrayList&lt;&gt;();
2233 
2234     // Gets an inflater from the list of available inflaters or allocates
2235     // a new one.
2236     private Inflater getInflater() {
2237         synchronized (inflaters) {
2238             int size = inflaters.size();
2239             if (size &gt; 0) {
<a name="132" id="anc132"></a><span class="line-modified">2240                 return inflaters.remove(size - 1);</span>

2241             } else {
2242                 return new Inflater(true);
2243             }
2244         }
2245     }
2246 
2247     // Releases the specified inflater to the list of available inflaters.
2248     private void releaseInflater(Inflater inf) {
2249         synchronized (inflaters) {
2250             if (inflaters.size() &lt; MAX_FLATER) {
2251                 inf.reset();
2252                 inflaters.add(inf);
2253             } else {
2254                 inf.end();
2255             }
2256         }
2257     }
2258 
2259     // List of available Deflater objects for compression
2260     private final List&lt;Deflater&gt; deflaters = new ArrayList&lt;&gt;();
2261 
2262     // Gets a deflater from the list of available deflaters or allocates
2263     // a new one.
2264     private Deflater getDeflater() {
2265         synchronized (deflaters) {
2266             int size = deflaters.size();
2267             if (size &gt; 0) {
<a name="133" id="anc133"></a><span class="line-modified">2268                 return deflaters.remove(size - 1);</span>

2269             } else {
2270                 return new Deflater(Deflater.DEFAULT_COMPRESSION, true);
2271             }
2272         }
2273     }
2274 
2275     // Releases the specified inflater to the list of available inflaters.
2276     private void releaseDeflater(Deflater def) {
2277         synchronized (deflaters) {
<a name="134" id="anc134"></a><span class="line-modified">2278             if (deflaters.size() &lt; MAX_FLATER) {</span>
2279                def.reset();
2280                deflaters.add(def);
2281             } else {
2282                def.end();
2283             }
2284         }
2285     }
2286 
2287     // End of central directory record
2288     static class END {
<a name="135" id="anc135"></a><span class="line-modified">2289         // The fields that are commented out below are not used by anyone and write() uses &quot;0&quot;</span>
2290         // int  disknum;
2291         // int  sdisknum;
<a name="136" id="anc136"></a><span class="line-modified">2292         // int  endsub;</span>
<span class="line-modified">2293         int  centot;        // 4 bytes</span>
<span class="line-modified">2294         long cenlen;        // 4 bytes</span>
<span class="line-modified">2295         long cenoff;        // 4 bytes</span>
<span class="line-modified">2296         // int  comlen;     // comment length</span>
<span class="line-modified">2297         // byte[] comment;</span>
<span class="line-modified">2298 </span>
<span class="line-modified">2299         // members of Zip64 end of central directory locator</span>
2300         // int diskNum;
2301         long endpos;
2302         // int disktot;
2303 
2304         void write(OutputStream os, long offset, boolean forceEnd64) throws IOException {
2305             boolean hasZip64 = forceEnd64; // false;
2306             long xlen = cenlen;
2307             long xoff = cenoff;
2308             if (xlen &gt;= ZIP64_MINVAL) {
2309                 xlen = ZIP64_MINVAL;
2310                 hasZip64 = true;
2311             }
2312             if (xoff &gt;= ZIP64_MINVAL) {
2313                 xoff = ZIP64_MINVAL;
2314                 hasZip64 = true;
2315             }
2316             int count = centot;
2317             if (count &gt;= ZIP64_MINVAL32) {
2318                 count = ZIP64_MINVAL32;
2319                 hasZip64 = true;
2320             }
2321             if (hasZip64) {
<a name="137" id="anc137"></a>
2322                 //zip64 end of central directory record
2323                 writeInt(os, ZIP64_ENDSIG);       // zip64 END record signature
2324                 writeLong(os, ZIP64_ENDHDR - 12); // size of zip64 end
2325                 writeShort(os, 45);               // version made by
2326                 writeShort(os, 45);               // version needed to extract
2327                 writeInt(os, 0);                  // number of this disk
2328                 writeInt(os, 0);                  // central directory start disk
2329                 writeLong(os, centot);            // number of directory entries on disk
2330                 writeLong(os, centot);            // number of directory entries
2331                 writeLong(os, cenlen);            // length of central directory
2332                 writeLong(os, cenoff);            // offset of central directory
2333 
2334                 //zip64 end of central directory locator
2335                 writeInt(os, ZIP64_LOCSIG);       // zip64 END locator signature
2336                 writeInt(os, 0);                  // zip64 END start disk
<a name="138" id="anc138"></a><span class="line-modified">2337                 writeLong(os, offset);            // offset of zip64 END</span>
2338                 writeInt(os, 1);                  // total number of disks (?)
2339             }
2340             writeInt(os, ENDSIG);                 // END record signature
2341             writeShort(os, 0);                    // number of this disk
2342             writeShort(os, 0);                    // central directory start disk
2343             writeShort(os, count);                // number of directory entries on disk
2344             writeShort(os, count);                // total number of directory entries
2345             writeInt(os, xlen);                   // length of central directory
2346             writeInt(os, xoff);                   // offset of central directory
<a name="139" id="anc139"></a><span class="line-modified">2347             writeShort(os, 0);                    // zip file comment, not used</span>





2348         }
2349     }
2350 
2351     // Internal node that links a &quot;name&quot; to its pos in cen table.
2352     // The node itself can be used as a &quot;key&quot; to lookup itself in
2353     // the HashMap inodes.
2354     static class IndexNode {
<a name="140" id="anc140"></a><span class="line-modified">2355         byte[]  name;</span>
<span class="line-modified">2356         int     hashcode;    // node is hashable/hashed by its name</span>


2357         boolean isdir;
<a name="141" id="anc141"></a><span class="line-added">2358         int     pos = -1;    // position in cen table, -1 means the</span>
<span class="line-added">2359                              // entry does not exist in zip file</span>
<span class="line-added">2360         IndexNode child;     // first child</span>
<span class="line-added">2361         IndexNode sibling;   // next sibling</span>
<span class="line-added">2362 </span>
<span class="line-added">2363         IndexNode() {}</span>
2364 
2365         IndexNode(byte[] name, boolean isdir) {
2366             name(name);
2367             this.isdir = isdir;
2368             this.pos = -1;
2369         }
2370 
2371         IndexNode(byte[] name, int pos) {
2372             name(name);
2373             this.pos = pos;
2374         }
2375 
<a name="142" id="anc142"></a><span class="line-modified">2376         // constructor for initCEN() (1) remove trailing &#39;/&#39; (2) pad leading &#39;/&#39;</span>
2377         IndexNode(byte[] cen, int pos, int nlen) {
2378             int noff = pos + CENHDR;
2379             if (cen[noff + nlen - 1] == &#39;/&#39;) {
2380                 isdir = true;
2381                 nlen--;
2382             }
2383             if (nlen &gt; 0 &amp;&amp; cen[noff] == &#39;/&#39;) {
2384                 name = Arrays.copyOfRange(cen, noff, noff + nlen);
2385             } else {
2386                 name = new byte[nlen + 1];
2387                 System.arraycopy(cen, noff, name, 1, nlen);
2388                 name[0] = &#39;/&#39;;
2389             }
<a name="143" id="anc143"></a><span class="line-modified">2390             name(normalize(name));</span>
2391             this.pos = pos;
2392         }
2393 
<a name="144" id="anc144"></a><span class="line-added">2394         // Normalize the IndexNode.name field.</span>
<span class="line-added">2395         private byte[] normalize(byte[] path) {</span>
<span class="line-added">2396             int len = path.length;</span>
<span class="line-added">2397             if (len == 0)</span>
<span class="line-added">2398                 return path;</span>
<span class="line-added">2399             byte prevC = 0;</span>
<span class="line-added">2400             for (int pathPos = 0; pathPos &lt; len; pathPos++) {</span>
<span class="line-added">2401                 byte c = path[pathPos];</span>
<span class="line-added">2402                 if (c == &#39;/&#39; &amp;&amp; prevC == &#39;/&#39;)</span>
<span class="line-added">2403                     return normalize(path, pathPos - 1);</span>
<span class="line-added">2404                 prevC = c;</span>
<span class="line-added">2405             }</span>
<span class="line-added">2406             if (len &gt; 1 &amp;&amp; prevC == &#39;/&#39;) {</span>
<span class="line-added">2407                 return Arrays.copyOf(path, len - 1);</span>
<span class="line-added">2408             }</span>
<span class="line-added">2409             return path;</span>
<span class="line-added">2410         }</span>
<span class="line-added">2411 </span>
<span class="line-added">2412         private byte[] normalize(byte[] path, int off) {</span>
<span class="line-added">2413             // As we know we have at least one / to trim, we can reduce</span>
<span class="line-added">2414             // the size of the resulting array</span>
<span class="line-added">2415             byte[] to = new byte[path.length - 1];</span>
<span class="line-added">2416             int pathPos = 0;</span>
<span class="line-added">2417             while (pathPos &lt; off) {</span>
<span class="line-added">2418                 to[pathPos] = path[pathPos];</span>
<span class="line-added">2419                 pathPos++;</span>
<span class="line-added">2420             }</span>
<span class="line-added">2421             int toPos = pathPos;</span>
<span class="line-added">2422             byte prevC = 0;</span>
<span class="line-added">2423             while (pathPos &lt; path.length) {</span>
<span class="line-added">2424                 byte c = path[pathPos++];</span>
<span class="line-added">2425                 if (c == &#39;/&#39; &amp;&amp; prevC == &#39;/&#39;)</span>
<span class="line-added">2426                     continue;</span>
<span class="line-added">2427                 to[toPos++] = c;</span>
<span class="line-added">2428                 prevC = c;</span>
<span class="line-added">2429             }</span>
<span class="line-added">2430             if (toPos &gt; 1 &amp;&amp; to[toPos - 1] == &#39;/&#39;)</span>
<span class="line-added">2431                 toPos--;</span>
<span class="line-added">2432             return (toPos == to.length) ? to : Arrays.copyOf(to, toPos);</span>
<span class="line-added">2433         }</span>
<span class="line-added">2434 </span>
2435         private static final ThreadLocal&lt;IndexNode&gt; cachedKey = new ThreadLocal&lt;&gt;();
2436 
<a name="145" id="anc145"></a><span class="line-modified">2437         static final IndexNode keyOf(byte[] name) { // get a lookup key;</span>
2438             IndexNode key = cachedKey.get();
2439             if (key == null) {
2440                 key = new IndexNode(name, -1);
2441                 cachedKey.set(key);
2442             }
2443             return key.as(name);
2444         }
2445 
2446         final void name(byte[] name) {
2447             this.name = name;
2448             this.hashcode = Arrays.hashCode(name);
2449         }
2450 
2451         final IndexNode as(byte[] name) {           // reuse the node, mostly
2452             name(name);                             // as a lookup &quot;key&quot;
2453             return this;
2454         }
2455 
2456         boolean isDir() {
2457             return isdir;
2458         }
2459 
<a name="146" id="anc146"></a><span class="line-added">2460         @Override</span>
2461         public boolean equals(Object other) {
2462             if (!(other instanceof IndexNode)) {
2463                 return false;
2464             }
2465             if (other instanceof ParentLookup) {
2466                 return ((ParentLookup)other).equals(this);
2467             }
2468             return Arrays.equals(name, ((IndexNode)other).name);
2469         }
2470 
<a name="147" id="anc147"></a><span class="line-added">2471         @Override</span>
2472         public int hashCode() {
2473             return hashcode;
2474         }
2475 
<a name="148" id="anc148"></a><span class="line-modified">2476         @Override</span>
<span class="line-modified">2477         public String toString() {</span>
<span class="line-modified">2478             return new String(name) + (isdir ? &quot; (dir)&quot; : &quot; &quot;) + &quot;, index: &quot; + pos;</span>
<span class="line-added">2479         }</span>
2480     }
2481 
2482     static class Entry extends IndexNode implements ZipFileAttributes {
<a name="149" id="anc149"></a>
2483         static final int CEN    = 1;  // entry read from cen
2484         static final int NEW    = 2;  // updated contents in bytes or file
2485         static final int FILECH = 3;  // fch update in &quot;file&quot;
2486         static final int COPY   = 4;  // copy of a CEN entry
2487 
2488         byte[] bytes;                 // updated content bytes
2489         Path   file;                  // use tmp file to store bytes;
2490         int    type = CEN;            // default is the entry read from cen
2491 
2492         // entry attributes
2493         int    version;
2494         int    flag;
<a name="150" id="anc150"></a><span class="line-added">2495         int    posixPerms = -1; // posix permissions</span>
2496         int    method = -1;    // compression method
2497         long   mtime  = -1;    // last modification time (in DOS time)
2498         long   atime  = -1;    // last access time
2499         long   ctime  = -1;    // create time
2500         long   crc    = -1;    // crc-32 of entry data
2501         long   csize  = -1;    // compressed size of entry data
2502         long   size   = -1;    // uncompressed size of entry data
2503         byte[] extra;
2504 
<a name="151" id="anc151"></a><span class="line-modified">2505         // CEN</span>
<span class="line-modified">2506         // The fields that are commented out below are not used by anyone and write() uses &quot;0&quot;</span>

2507         // int    versionMade;
2508         // int    disk;
2509         // int    attrs;
2510         // long   attrsEx;
2511         long   locoff;
2512         byte[] comment;
2513 
<a name="152" id="anc152"></a>

2514         Entry(byte[] name, boolean isdir, int method) {
2515             name(name);
2516             this.isdir = isdir;
2517             this.mtime  = this.ctime = this.atime = System.currentTimeMillis();
2518             this.crc    = 0;
2519             this.size   = 0;
2520             this.csize  = 0;
2521             this.method = method;
2522         }
2523 
<a name="153" id="anc153"></a><span class="line-modified">2524         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">2525         Entry(byte[] name, int type, boolean isdir, int method, FileAttribute&lt;?&gt;... attrs) {</span>
2526             this(name, isdir, method);
2527             this.type = type;
<a name="154" id="anc154"></a><span class="line-added">2528             for (FileAttribute&lt;?&gt; attr : attrs) {</span>
<span class="line-added">2529                 String attrName = attr.name();</span>
<span class="line-added">2530                 if (attrName.equals(&quot;posix:permissions&quot;)) {</span>
<span class="line-added">2531                     posixPerms = ZipUtils.permsToFlags((Set&lt;PosixFilePermission&gt;)attr.value());</span>
<span class="line-added">2532                 }</span>
<span class="line-added">2533             }</span>
<span class="line-added">2534         }</span>
<span class="line-added">2535 </span>
<span class="line-added">2536         Entry(byte[] name, Path file, int type, FileAttribute&lt;?&gt;... attrs) {</span>
<span class="line-added">2537             this(name, type, false, METHOD_STORED, attrs);</span>
<span class="line-added">2538             this.file = file;</span>
<span class="line-added">2539         }</span>
<span class="line-added">2540 </span>
<span class="line-added">2541         Entry(Entry e, int type, int compressionMethod) {</span>
<span class="line-added">2542             this(e, type);</span>
<span class="line-added">2543             this.method = compressionMethod;</span>
2544         }
2545 
<a name="155" id="anc155"></a><span class="line-modified">2546         Entry(Entry e, int type) {</span>
2547             name(e.name);
2548             this.isdir     = e.isdir;
2549             this.version   = e.version;
2550             this.ctime     = e.ctime;
2551             this.atime     = e.atime;
2552             this.mtime     = e.mtime;
2553             this.crc       = e.crc;
2554             this.size      = e.size;
2555             this.csize     = e.csize;
2556             this.method    = e.method;
2557             this.extra     = e.extra;
2558             /*
2559             this.versionMade = e.versionMade;
2560             this.disk      = e.disk;
2561             this.attrs     = e.attrs;
2562             this.attrsEx   = e.attrsEx;
2563             */
2564             this.locoff    = e.locoff;
2565             this.comment   = e.comment;
<a name="156" id="anc156"></a><span class="line-added">2566             this.posixPerms = e.posixPerms;</span>
2567             this.type      = type;
2568         }
2569 
<a name="157" id="anc157"></a><span class="line-modified">2570         Entry(ZipFileSystem zipfs, IndexNode inode) throws IOException {</span>
<span class="line-modified">2571             readCEN(zipfs, inode);</span>

2572         }
2573 
<a name="158" id="anc158"></a><span class="line-modified">2574         // Calculates a suitable base for the version number to</span>
<span class="line-added">2575         // be used for fields version made by/version needed to extract.</span>
<span class="line-added">2576         // The lower bytes of these 2 byte fields hold the version number</span>
<span class="line-added">2577         // (value/10 = major; value%10 = minor)</span>
<span class="line-added">2578         // For different features certain minimum versions apply:</span>
<span class="line-added">2579         // stored = 10 (1.0), deflated = 20 (2.0), zip64 = 45 (4.5)</span>
<span class="line-added">2580         private int version(boolean zip64) throws ZipException {</span>
<span class="line-added">2581             if (zip64) {</span>
<span class="line-added">2582                 return 45;</span>
<span class="line-added">2583             }</span>
2584             if (method == METHOD_DEFLATED)
2585                 return 20;
2586             else if (method == METHOD_STORED)
2587                 return 10;
2588             throw new ZipException(&quot;unsupported compression method&quot;);
2589         }
2590 
<a name="159" id="anc159"></a><span class="line-modified">2591         /**</span>
<span class="line-modified">2592          * Adds information about compatibility of file attribute information</span>
<span class="line-modified">2593          * to a version value.</span>
<span class="line-modified">2594          */</span>
<span class="line-modified">2595         private int versionMadeBy(int version) {</span>
<span class="line-added">2596             return (posixPerms &lt; 0) ? version :</span>
<span class="line-added">2597                 VERSION_MADE_BY_BASE_UNIX | (version &amp; 0xff);</span>
2598         }
2599 
<a name="160" id="anc160"></a><span class="line-modified">2600         ///////////////////// CEN //////////////////////</span>
<span class="line-modified">2601         private void readCEN(ZipFileSystem zipfs, IndexNode inode) throws IOException {</span>

2602             byte[] cen = zipfs.cen;
2603             int pos = inode.pos;
2604             if (!cenSigAt(cen, pos))
<a name="161" id="anc161"></a><span class="line-modified">2605                 throw new ZipException(&quot;invalid CEN header (bad signature)&quot;);</span>
2606             version     = CENVER(cen, pos);
2607             flag        = CENFLG(cen, pos);
2608             method      = CENHOW(cen, pos);
2609             mtime       = dosToJavaTime(CENTIM(cen, pos));
2610             crc         = CENCRC(cen, pos);
2611             csize       = CENSIZ(cen, pos);
2612             size        = CENLEN(cen, pos);
2613             int nlen    = CENNAM(cen, pos);
2614             int elen    = CENEXT(cen, pos);
2615             int clen    = CENCOM(cen, pos);
2616             /*
2617             versionMade = CENVEM(cen, pos);
2618             disk        = CENDSK(cen, pos);
2619             attrs       = CENATT(cen, pos);
2620             attrsEx     = CENATX(cen, pos);
2621             */
<a name="162" id="anc162"></a><span class="line-added">2622             if (CENVEM_FA(cen, pos) == FILE_ATTRIBUTES_UNIX) {</span>
<span class="line-added">2623                 posixPerms = CENATX_PERMS(cen, pos) &amp; 0xFFF; // 12 bits for setuid, setgid, sticky + perms</span>
<span class="line-added">2624             }</span>
2625             locoff      = CENOFF(cen, pos);
2626             pos += CENHDR;
2627             this.name = inode.name;
2628             this.isdir = inode.isdir;
2629             this.hashcode = inode.hashcode;
2630 
2631             pos += nlen;
2632             if (elen &gt; 0) {
2633                 extra = Arrays.copyOfRange(cen, pos, pos + elen);
2634                 pos += elen;
2635                 readExtra(zipfs);
2636             }
2637             if (clen &gt; 0) {
2638                 comment = Arrays.copyOfRange(cen, pos, pos + clen);
2639             }
<a name="163" id="anc163"></a>
2640         }
2641 
<a name="164" id="anc164"></a><span class="line-modified">2642         private int writeCEN(OutputStream os) throws IOException {</span>

2643             long csize0  = csize;
2644             long size0   = size;
2645             long locoff0 = locoff;
2646             int elen64   = 0;                // extra for ZIP64
2647             int elenNTFS = 0;                // extra for NTFS (a/c/mtime)
2648             int elenEXTT = 0;                // extra for Extended Timestamp
2649             boolean foundExtraTime = false;  // if time stamp NTFS, EXTT present
2650 
2651             byte[] zname = isdir ? toDirectoryPath(name) : name;
2652 
2653             // confirm size/length
2654             int nlen = (zname != null) ? zname.length - 1 : 0;  // name has [0] as &quot;slash&quot;
2655             int elen = (extra != null) ? extra.length : 0;
2656             int eoff = 0;
2657             int clen = (comment != null) ? comment.length : 0;
2658             if (csize &gt;= ZIP64_MINVAL) {
2659                 csize0 = ZIP64_MINVAL;
2660                 elen64 += 8;                 // csize(8)
2661             }
2662             if (size &gt;= ZIP64_MINVAL) {
2663                 size0 = ZIP64_MINVAL;        // size(8)
2664                 elen64 += 8;
2665             }
2666             if (locoff &gt;= ZIP64_MINVAL) {
2667                 locoff0 = ZIP64_MINVAL;
2668                 elen64 += 8;                 // offset(8)
2669             }
2670             if (elen64 != 0) {
2671                 elen64 += 4;                 // header and data sz 4 bytes
2672             }
<a name="165" id="anc165"></a><span class="line-added">2673             boolean zip64 = (elen64 != 0);</span>
<span class="line-added">2674             int version0 = version(zip64);</span>
2675             while (eoff + 4 &lt; elen) {
2676                 int tag = SH(extra, eoff);
2677                 int sz = SH(extra, eoff + 2);
2678                 if (tag == EXTID_EXTT || tag == EXTID_NTFS) {
2679                     foundExtraTime = true;
2680                 }
2681                 eoff += (4 + sz);
2682             }
2683             if (!foundExtraTime) {
2684                 if (isWindows) {             // use NTFS
2685                     elenNTFS = 36;           // total 36 bytes
2686                 } else {                     // Extended Timestamp otherwise
2687                     elenEXTT = 9;            // only mtime in cen
2688                 }
2689             }
2690             writeInt(os, CENSIG);            // CEN header signature
<a name="166" id="anc166"></a><span class="line-modified">2691             writeShort(os, versionMadeBy(version0)); // version made by</span>
<span class="line-modified">2692             writeShort(os, version0);        // version needed to extract</span>





2693             writeShort(os, flag);            // general purpose bit flag
2694             writeShort(os, method);          // compression method
2695                                              // last modification time
2696             writeInt(os, (int)javaToDosTime(mtime));
2697             writeInt(os, crc);               // crc-32
2698             writeInt(os, csize0);            // compressed size
2699             writeInt(os, size0);             // uncompressed size
2700             writeShort(os, nlen);
2701             writeShort(os, elen + elen64 + elenNTFS + elenEXTT);
2702 
2703             if (comment != null) {
2704                 writeShort(os, Math.min(clen, 0xffff));
2705             } else {
2706                 writeShort(os, 0);
2707             }
2708             writeShort(os, 0);              // starting disk number
2709             writeShort(os, 0);              // internal file attributes (unused)
<a name="167" id="anc167"></a><span class="line-modified">2710             writeInt(os, posixPerms &gt; 0 ? posixPerms &lt;&lt; 16 : 0); // external file</span>
<span class="line-added">2711                                             // attributes, used for storing posix</span>
<span class="line-added">2712                                             // permissions</span>
2713             writeInt(os, locoff0);          // relative offset of local header
2714             writeBytes(os, zname, 1, nlen);
<a name="168" id="anc168"></a><span class="line-modified">2715             if (zip64) {</span>
2716                 writeShort(os, EXTID_ZIP64);// Zip64 extra
2717                 writeShort(os, elen64 - 4); // size of &quot;this&quot; extra block
2718                 if (size0 == ZIP64_MINVAL)
2719                     writeLong(os, size);
2720                 if (csize0 == ZIP64_MINVAL)
2721                     writeLong(os, csize);
2722                 if (locoff0 == ZIP64_MINVAL)
2723                     writeLong(os, locoff);
2724             }
2725             if (elenNTFS != 0) {
2726                 writeShort(os, EXTID_NTFS);
2727                 writeShort(os, elenNTFS - 4);
2728                 writeInt(os, 0);            // reserved
2729                 writeShort(os, 0x0001);     // NTFS attr tag
2730                 writeShort(os, 24);
2731                 writeLong(os, javaToWinTime(mtime));
2732                 writeLong(os, javaToWinTime(atime));
2733                 writeLong(os, javaToWinTime(ctime));
2734             }
2735             if (elenEXTT != 0) {
2736                 writeShort(os, EXTID_EXTT);
2737                 writeShort(os, elenEXTT - 4);
2738                 if (ctime == -1)
2739                     os.write(0x3);          // mtime and atime
2740                 else
2741                     os.write(0x7);          // mtime, atime and ctime
2742                 writeInt(os, javaToUnixTime(mtime));
2743             }
2744             if (extra != null)              // whatever not recognized
2745                 writeBytes(os, extra);
2746             if (comment != null)            //TBD: 0, Math.min(commentBytes.length, 0xffff));
2747                 writeBytes(os, comment);
2748             return CENHDR + nlen + elen + clen + elen64 + elenNTFS + elenEXTT;
2749         }
2750 
2751         ///////////////////// LOC //////////////////////
2752 
<a name="169" id="anc169"></a><span class="line-modified">2753         private int writeLOC(OutputStream os) throws IOException {</span>

2754             byte[] zname = isdir ? toDirectoryPath(name) : name;
2755             int nlen = (zname != null) ? zname.length - 1 : 0; // [0] is slash
2756             int elen = (extra != null) ? extra.length : 0;
2757             boolean foundExtraTime = false;     // if extra timestamp present
2758             int eoff = 0;
2759             int elen64 = 0;
<a name="170" id="anc170"></a><span class="line-added">2760             boolean zip64 = false;</span>
2761             int elenEXTT = 0;
2762             int elenNTFS = 0;
2763             writeInt(os, LOCSIG);               // LOC header signature
2764             if ((flag &amp; FLAG_DATADESCR) != 0) {
<a name="171" id="anc171"></a><span class="line-modified">2765                 writeShort(os, version(false)); // version needed to extract</span>
2766                 writeShort(os, flag);           // general purpose bit flag
2767                 writeShort(os, method);         // compression method
2768                 // last modification time
2769                 writeInt(os, (int)javaToDosTime(mtime));
2770                 // store size, uncompressed size, and crc-32 in data descriptor
2771                 // immediately following compressed entry data
2772                 writeInt(os, 0);
2773                 writeInt(os, 0);
2774                 writeInt(os, 0);
2775             } else {
2776                 if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
2777                     elen64 = 20;    //headid(2) + size(2) + size(8) + csize(8)
<a name="172" id="anc172"></a><span class="line-modified">2778                     zip64 = true;</span>


2779                 }
<a name="173" id="anc173"></a><span class="line-added">2780                 writeShort(os, version(zip64)); // version needed to extract</span>
2781                 writeShort(os, flag);           // general purpose bit flag
2782                 writeShort(os, method);         // compression method
2783                                                 // last modification time
2784                 writeInt(os, (int)javaToDosTime(mtime));
2785                 writeInt(os, crc);              // crc-32
<a name="174" id="anc174"></a><span class="line-modified">2786                 if (zip64) {</span>
2787                     writeInt(os, ZIP64_MINVAL);
2788                     writeInt(os, ZIP64_MINVAL);
2789                 } else {
2790                     writeInt(os, csize);        // compressed size
2791                     writeInt(os, size);         // uncompressed size
2792                 }
2793             }
2794             while (eoff + 4 &lt; elen) {
2795                 int tag = SH(extra, eoff);
2796                 int sz = SH(extra, eoff + 2);
2797                 if (tag == EXTID_EXTT || tag == EXTID_NTFS) {
2798                     foundExtraTime = true;
2799                 }
2800                 eoff += (4 + sz);
2801             }
2802             if (!foundExtraTime) {
2803                 if (isWindows) {
2804                     elenNTFS = 36;              // NTFS, total 36 bytes
2805                 } else {                        // on unix use &quot;ext time&quot;
2806                     elenEXTT = 9;
2807                     if (atime != -1)
2808                         elenEXTT += 4;
2809                     if (ctime != -1)
2810                         elenEXTT += 4;
2811                 }
2812             }
2813             writeShort(os, nlen);
2814             writeShort(os, elen + elen64 + elenNTFS + elenEXTT);
2815             writeBytes(os, zname, 1, nlen);
<a name="175" id="anc175"></a><span class="line-modified">2816             if (zip64) {</span>
2817                 writeShort(os, EXTID_ZIP64);
2818                 writeShort(os, 16);
2819                 writeLong(os, size);
2820                 writeLong(os, csize);
2821             }
2822             if (elenNTFS != 0) {
2823                 writeShort(os, EXTID_NTFS);
2824                 writeShort(os, elenNTFS - 4);
2825                 writeInt(os, 0);            // reserved
2826                 writeShort(os, 0x0001);     // NTFS attr tag
2827                 writeShort(os, 24);
2828                 writeLong(os, javaToWinTime(mtime));
2829                 writeLong(os, javaToWinTime(atime));
2830                 writeLong(os, javaToWinTime(ctime));
2831             }
2832             if (elenEXTT != 0) {
2833                 writeShort(os, EXTID_EXTT);
2834                 writeShort(os, elenEXTT - 4);// size for the folowing data block
2835                 int fbyte = 0x1;
2836                 if (atime != -1)           // mtime and atime
2837                     fbyte |= 0x2;
2838                 if (ctime != -1)           // mtime, atime and ctime
2839                     fbyte |= 0x4;
2840                 os.write(fbyte);           // flags byte
2841                 writeInt(os, javaToUnixTime(mtime));
2842                 if (atime != -1)
2843                     writeInt(os, javaToUnixTime(atime));
2844                 if (ctime != -1)
2845                     writeInt(os, javaToUnixTime(ctime));
2846             }
2847             if (extra != null) {
2848                 writeBytes(os, extra);
2849             }
2850             return LOCHDR + nlen + elen + elen64 + elenNTFS + elenEXTT;
2851         }
2852 
<a name="176" id="anc176"></a><span class="line-modified">2853         // Data Descriptor</span>
<span class="line-modified">2854         private int writeEXT(OutputStream os) throws IOException {</span>
2855             writeInt(os, EXTSIG);           // EXT header signature
2856             writeInt(os, crc);              // crc-32
2857             if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
2858                 writeLong(os, csize);
2859                 writeLong(os, size);
2860                 return 24;
2861             } else {
2862                 writeInt(os, csize);        // compressed size
2863                 writeInt(os, size);         // uncompressed size
2864                 return 16;
2865             }
2866         }
2867 
2868         // read NTFS, UNIX and ZIP64 data from cen.extra
<a name="177" id="anc177"></a><span class="line-modified">2869         private void readExtra(ZipFileSystem zipfs) throws IOException {</span>
2870             if (extra == null)
2871                 return;
2872             int elen = extra.length;
2873             int off = 0;
2874             int newOff = 0;
2875             while (off + 4 &lt; elen) {
2876                 // extra spec: HeaderID+DataSize+Data
2877                 int pos = off;
2878                 int tag = SH(extra, pos);
2879                 int sz = SH(extra, pos + 2);
2880                 pos += 4;
2881                 if (pos + sz &gt; elen)         // invalid data
2882                     break;
2883                 switch (tag) {
2884                 case EXTID_ZIP64 :
2885                     if (size == ZIP64_MINVAL) {
2886                         if (pos + 8 &gt; elen)  // invalid zip64 extra
2887                             break;           // fields, just skip
2888                         size = LL(extra, pos);
2889                         pos += 8;
2890                     }
2891                     if (csize == ZIP64_MINVAL) {
2892                         if (pos + 8 &gt; elen)
2893                             break;
2894                         csize = LL(extra, pos);
2895                         pos += 8;
2896                     }
2897                     if (locoff == ZIP64_MINVAL) {
2898                         if (pos + 8 &gt; elen)
2899                             break;
2900                         locoff = LL(extra, pos);
<a name="178" id="anc178"></a>
2901                     }
2902                     break;
2903                 case EXTID_NTFS:
2904                     if (sz &lt; 32)
2905                         break;
2906                     pos += 4;    // reserved 4 bytes
2907                     if (SH(extra, pos) !=  0x0001)
2908                         break;
2909                     if (SH(extra, pos + 2) != 24)
2910                         break;
2911                     // override the loc field, datatime here is
2912                     // more &quot;accurate&quot;
2913                     mtime  = winToJavaTime(LL(extra, pos + 4));
2914                     atime  = winToJavaTime(LL(extra, pos + 12));
2915                     ctime  = winToJavaTime(LL(extra, pos + 20));
2916                     break;
2917                 case EXTID_EXTT:
2918                     // spec says the Extened timestamp in cen only has mtime
2919                     // need to read the loc to get the extra a/ctime, if flag
2920                     // &quot;zipinfo-time&quot; is not specified to false;
2921                     // there is performance cost (move up to loc and read) to
2922                     // access the loc table foreach entry;
2923                     if (zipfs.noExtt) {
2924                         if (sz == 5)
2925                             mtime = unixToJavaTime(LG(extra, pos + 1));
2926                          break;
2927                     }
2928                     byte[] buf = new byte[LOCHDR];
2929                     if (zipfs.readFullyAt(buf, 0, buf.length , locoff)
2930                         != buf.length)
2931                         throw new ZipException(&quot;loc: reading failed&quot;);
2932                     if (!locSigAt(buf, 0))
2933                         throw new ZipException(&quot;loc: wrong sig -&gt;&quot;
2934                                            + Long.toString(getSig(buf, 0), 16));
2935                     int locElen = LOCEXT(buf);
<a name="179" id="anc179"></a><span class="line-modified">2936                     if (locElen &lt; 9)    // EXTT is at least 9 bytes</span>
2937                         break;
2938                     int locNlen = LOCNAM(buf);
2939                     buf = new byte[locElen];
2940                     if (zipfs.readFullyAt(buf, 0, buf.length , locoff + LOCHDR + locNlen)
2941                         != buf.length)
2942                         throw new ZipException(&quot;loc extra: reading failed&quot;);
2943                     int locPos = 0;
2944                     while (locPos + 4 &lt; buf.length) {
2945                         int locTag = SH(buf, locPos);
2946                         int locSZ  = SH(buf, locPos + 2);
2947                         locPos += 4;
2948                         if (locTag  != EXTID_EXTT) {
2949                             locPos += locSZ;
2950                              continue;
2951                         }
2952                         int end = locPos + locSZ - 4;
2953                         int flag = CH(buf, locPos++);
2954                         if ((flag &amp; 0x1) != 0 &amp;&amp; locPos &lt;= end) {
2955                             mtime = unixToJavaTime(LG(buf, locPos));
2956                             locPos += 4;
2957                         }
2958                         if ((flag &amp; 0x2) != 0 &amp;&amp; locPos &lt;= end) {
2959                             atime = unixToJavaTime(LG(buf, locPos));
2960                             locPos += 4;
2961                         }
2962                         if ((flag &amp; 0x4) != 0 &amp;&amp; locPos &lt;= end) {
2963                             ctime = unixToJavaTime(LG(buf, locPos));
<a name="180" id="anc180"></a>
2964                         }
2965                         break;
2966                     }
2967                     break;
2968                 default:    // unknown tag
2969                     System.arraycopy(extra, off, extra, newOff, sz + 4);
2970                     newOff += (sz + 4);
2971                 }
2972                 off += (sz + 4);
2973             }
2974             if (newOff != 0 &amp;&amp; newOff != extra.length)
2975                 extra = Arrays.copyOf(extra, newOff);
2976             else
2977                 extra = null;
2978         }
2979 
<a name="181" id="anc181"></a><span class="line-added">2980         @Override</span>
<span class="line-added">2981         public String toString() {</span>
<span class="line-added">2982             StringBuilder sb = new StringBuilder(1024);</span>
<span class="line-added">2983             Formatter fm = new Formatter(sb);</span>
<span class="line-added">2984             fm.format(&quot;    name            : %s%n&quot;, new String(name));</span>
<span class="line-added">2985             fm.format(&quot;    creationTime    : %tc%n&quot;, creationTime().toMillis());</span>
<span class="line-added">2986             fm.format(&quot;    lastAccessTime  : %tc%n&quot;, lastAccessTime().toMillis());</span>
<span class="line-added">2987             fm.format(&quot;    lastModifiedTime: %tc%n&quot;, lastModifiedTime().toMillis());</span>
<span class="line-added">2988             fm.format(&quot;    isRegularFile   : %b%n&quot;, isRegularFile());</span>
<span class="line-added">2989             fm.format(&quot;    isDirectory     : %b%n&quot;, isDirectory());</span>
<span class="line-added">2990             fm.format(&quot;    isSymbolicLink  : %b%n&quot;, isSymbolicLink());</span>
<span class="line-added">2991             fm.format(&quot;    isOther         : %b%n&quot;, isOther());</span>
<span class="line-added">2992             fm.format(&quot;    fileKey         : %s%n&quot;, fileKey());</span>
<span class="line-added">2993             fm.format(&quot;    size            : %d%n&quot;, size());</span>
<span class="line-added">2994             fm.format(&quot;    compressedSize  : %d%n&quot;, compressedSize());</span>
<span class="line-added">2995             fm.format(&quot;    crc             : %x%n&quot;, crc());</span>
<span class="line-added">2996             fm.format(&quot;    method          : %d%n&quot;, method());</span>
<span class="line-added">2997             Set&lt;PosixFilePermission&gt; permissions = storedPermissions().orElse(null);</span>
<span class="line-added">2998             if (permissions != null) {</span>
<span class="line-added">2999                 fm.format(&quot;    permissions     : %s%n&quot;, permissions);</span>
<span class="line-added">3000             }</span>
<span class="line-added">3001             fm.close();</span>
<span class="line-added">3002             return sb.toString();</span>
<span class="line-added">3003         }</span>
<span class="line-added">3004 </span>
3005         ///////// basic file attributes ///////////
3006         @Override
3007         public FileTime creationTime() {
3008             return FileTime.fromMillis(ctime == -1 ? mtime : ctime);
3009         }
3010 
3011         @Override
3012         public boolean isDirectory() {
3013             return isDir();
3014         }
3015 
3016         @Override
3017         public boolean isOther() {
3018             return false;
3019         }
3020 
3021         @Override
3022         public boolean isRegularFile() {
3023             return !isDir();
3024         }
3025 
3026         @Override
3027         public FileTime lastAccessTime() {
3028             return FileTime.fromMillis(atime == -1 ? mtime : atime);
3029         }
3030 
3031         @Override
3032         public FileTime lastModifiedTime() {
3033             return FileTime.fromMillis(mtime);
3034         }
3035 
3036         @Override
3037         public long size() {
3038             return size;
3039         }
3040 
3041         @Override
3042         public boolean isSymbolicLink() {
3043             return false;
3044         }
3045 
3046         @Override
3047         public Object fileKey() {
3048             return null;
3049         }
3050 
<a name="182" id="anc182"></a><span class="line-modified">3051         ///////// zip file attributes ///////////</span>
<span class="line-added">3052 </span>
<span class="line-added">3053         @Override</span>
3054         public long compressedSize() {
3055             return csize;
3056         }
3057 
<a name="183" id="anc183"></a><span class="line-added">3058         @Override</span>
3059         public long crc() {
3060             return crc;
3061         }
3062 
<a name="184" id="anc184"></a><span class="line-added">3063         @Override</span>
3064         public int method() {
3065             return method;
3066         }
3067 
<a name="185" id="anc185"></a><span class="line-added">3068         @Override</span>
3069         public byte[] extra() {
3070             if (extra != null)
3071                 return Arrays.copyOf(extra, extra.length);
3072             return null;
3073         }
3074 
<a name="186" id="anc186"></a><span class="line-added">3075         @Override</span>
3076         public byte[] comment() {
3077             if (comment != null)
3078                 return Arrays.copyOf(comment, comment.length);
3079             return null;
3080         }
3081 
<a name="187" id="anc187"></a><span class="line-modified">3082         @Override</span>
<span class="line-modified">3083         public Optional&lt;Set&lt;PosixFilePermission&gt;&gt; storedPermissions() {</span>
<span class="line-modified">3084             Set&lt;PosixFilePermission&gt; perms = null;</span>
<span class="line-modified">3085             if (posixPerms != -1) {</span>
<span class="line-modified">3086                 perms = new HashSet&lt;&gt;(PosixFilePermission.values().length);</span>
<span class="line-modified">3087                 for (PosixFilePermission perm : PosixFilePermission.values()) {</span>
<span class="line-modified">3088                     if ((posixPerms &amp; ZipUtils.permToFlag(perm)) != 0) {</span>
<span class="line-modified">3089                         perms.add(perm);</span>
<span class="line-modified">3090                     }</span>
<span class="line-modified">3091                 }</span>
<span class="line-modified">3092             }</span>
<span class="line-modified">3093             return Optional.ofNullable(perms);</span>






3094         }
3095     }
3096 
<a name="188" id="anc188"></a><span class="line-modified">3097     final class PosixEntry extends Entry implements PosixFileAttributes {</span>
<span class="line-modified">3098         private UserPrincipal owner = defaultOwner;</span>
<span class="line-modified">3099         private GroupPrincipal group = defaultGroup;</span>




3100 
<a name="189" id="anc189"></a><span class="line-modified">3101         PosixEntry(byte[] name, boolean isdir, int method) {</span>
<span class="line-modified">3102             super(name, isdir, method);</span>
<span class="line-added">3103         }</span>
3104 
<a name="190" id="anc190"></a><span class="line-modified">3105         PosixEntry(byte[] name, int type, boolean isdir, int method, FileAttribute&lt;?&gt;... attrs) {</span>
<span class="line-modified">3106             super(name, type, isdir, method, attrs);</span>
<span class="line-modified">3107         }</span>
<span class="line-modified">3108 </span>
<span class="line-modified">3109         PosixEntry(byte[] name, Path file, int type, FileAttribute&lt;?&gt;... attrs) {</span>
<span class="line-modified">3110             super(name, file, type, attrs);</span>
<span class="line-modified">3111         }</span>
<span class="line-modified">3112 </span>
<span class="line-modified">3113         PosixEntry(PosixEntry e, int type, int compressionMethod) {</span>
<span class="line-modified">3114             super(e, type);</span>
<span class="line-modified">3115             this.method = compressionMethod;</span>
<span class="line-modified">3116         }</span>
<span class="line-modified">3117 </span>
<span class="line-modified">3118         PosixEntry(PosixEntry e, int type) {</span>
<span class="line-added">3119             super(e, type);</span>
<span class="line-added">3120             this.owner = e.owner;</span>
<span class="line-added">3121             this.group = e.group;</span>
<span class="line-added">3122         }</span>
<span class="line-added">3123 </span>
<span class="line-added">3124         PosixEntry(ZipFileSystem zipfs, IndexNode inode) throws IOException {</span>
<span class="line-added">3125             super(zipfs, inode);</span>
<span class="line-added">3126         }</span>
<span class="line-added">3127 </span>
<span class="line-added">3128         @Override</span>
<span class="line-added">3129         public UserPrincipal owner() {</span>
<span class="line-added">3130             return owner;</span>
<span class="line-added">3131         }</span>
<span class="line-added">3132 </span>
<span class="line-added">3133         @Override</span>
<span class="line-added">3134         public GroupPrincipal group() {</span>
<span class="line-added">3135             return group;</span>
<span class="line-added">3136         }</span>
<span class="line-added">3137 </span>
<span class="line-added">3138         @Override</span>
<span class="line-added">3139         public Set&lt;PosixFilePermission&gt; permissions() {</span>
<span class="line-added">3140             return storedPermissions().orElse(Set.copyOf(defaultPermissions));</span>
<span class="line-added">3141         }</span>
<span class="line-added">3142     }</span>
<span class="line-added">3143 </span>
<span class="line-added">3144     private static class ExistingChannelCloser {</span>
<span class="line-added">3145         private final Path path;</span>
<span class="line-added">3146         private final SeekableByteChannel ch;</span>
<span class="line-added">3147         private final Set&lt;InputStream&gt; streams;</span>
<span class="line-added">3148         ExistingChannelCloser(Path path,</span>
<span class="line-added">3149                               SeekableByteChannel ch,</span>
<span class="line-added">3150                               Set&lt;InputStream&gt; streams) {</span>
<span class="line-added">3151             this.path = path;</span>
<span class="line-added">3152             this.ch = ch;</span>
<span class="line-added">3153             this.streams = streams;</span>
<span class="line-added">3154         }</span>
<span class="line-added">3155 </span>
<span class="line-added">3156         /**</span>
<span class="line-added">3157          * If there are no more outstanding streams, close the channel and</span>
<span class="line-added">3158          * delete the backing file</span>
<span class="line-added">3159          *</span>
<span class="line-added">3160          * @return true if we&#39;re done and closed the backing file,</span>
<span class="line-added">3161          *         otherwise false</span>
<span class="line-added">3162          * @throws IOException</span>
<span class="line-added">3163          */</span>
<span class="line-added">3164         private boolean closeAndDeleteIfDone() throws IOException {</span>
<span class="line-added">3165             if (streams.isEmpty()) {</span>
<span class="line-added">3166                 ch.close();</span>
<span class="line-added">3167                 Files.delete(path);</span>
<span class="line-added">3168                 return true;</span>
3169             }
<a name="191" id="anc191"></a><span class="line-added">3170             return false;</span>
3171         }
3172     }
3173 
3174     // purely for parent lookup, so we don&#39;t have to copy the parent
3175     // name every time
3176     static class ParentLookup extends IndexNode {
3177         int len;
3178         ParentLookup() {}
3179 
3180         final ParentLookup as(byte[] name, int len) { // as a lookup &quot;key&quot;
3181             name(name, len);
3182             return this;
3183         }
3184 
3185         void name(byte[] name, int len) {
3186             this.name = name;
3187             this.len = len;
3188             // calculate the hashcode the same way as Arrays.hashCode() does
3189             int result = 1;
3190             for (int i = 0; i &lt; len; i++)
3191                 result = 31 * result + name[i];
3192             this.hashcode = result;
3193         }
3194 
3195         @Override
3196         public boolean equals(Object other) {
3197             if (!(other instanceof IndexNode)) {
3198                 return false;
3199             }
3200             byte[] oname = ((IndexNode)other).name;
3201             return Arrays.equals(name, 0, len,
3202                                  oname, 0, oname.length);
3203         }
<a name="192" id="anc192"></a>









































3204     }
3205 }
<a name="193" id="anc193"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="193" type="hidden" />
</body>
</html>
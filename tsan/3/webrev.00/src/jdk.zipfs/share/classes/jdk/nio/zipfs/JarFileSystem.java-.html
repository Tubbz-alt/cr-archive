<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.zipfs/share/classes/jdk/nio/zipfs/JarFileSystem.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nio.zipfs;
 27 
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.lang.Runtime.Version;
 31 import java.nio.file.NoSuchFileException;
 32 import java.nio.file.Path;
 33 import java.util.Arrays;
 34 import java.util.HashMap;
 35 import java.util.Map;
 36 import java.util.TreeMap;
 37 import java.util.function.Consumer;
 38 import java.util.function.Function;
 39 import java.util.jar.Attributes;
 40 import java.util.jar.Manifest;
 41 
 42 /**
 43  * Adds aliasing to ZipFileSystem to support multi-release jar files.  An alias map
 44  * is created by {@link JarFileSystem#createVersionedLinks(int)}.  The map is then
 45  * consulted when an entry is looked up in {@link JarFileSystem#getEntry(byte[])}
 46  * to determine if the entry has a corresponding versioned entry.  If so, the
 47  * versioned entry is returned.
 48  *
 49  * @author Steve Drach
 50  */
 51 class JarFileSystem extends ZipFileSystem {
 52     private Function&lt;byte[],byte[]&gt; lookup;
 53 
 54     @Override
 55     IndexNode getInode(byte[] path) {
 56         // check for an alias to a versioned entry
 57         byte[] versionedPath = lookup.apply(path);
 58         return versionedPath == null ? super.getInode(path) : super.getInode(versionedPath);
 59     }
 60 
 61     JarFileSystem(ZipFileSystemProvider provider, Path zfpath, Map&lt;String,?&gt; env)
 62             throws IOException {
 63         super(provider, zfpath, env);
 64         lookup = path -&gt; path;  // lookup needs to be set before isMultiReleaseJar is called
 65                                 // because it eventually calls getEntry
 66         if (isMultiReleaseJar()) {
 67             int version;
 68             Object o = env.get(&quot;multi-release&quot;);
 69             if (o instanceof String) {
 70                 String s = (String)o;
 71                 if (s.equals(&quot;runtime&quot;)) {
 72                     version = Runtime.version().feature();
 73                 } else {
 74                     version = Integer.parseInt(s);
 75                 }
 76             } else if (o instanceof Integer) {
 77                 version = (Integer)o;
 78             } else if (o instanceof Version) {
 79                 version = ((Version)o).feature();
 80             } else {
 81                 throw new IllegalArgumentException(&quot;env parameter must be String, Integer, &quot;
 82                         + &quot;or Version&quot;);
 83             }
 84             lookup = createVersionedLinks(version &lt; 0 ? 0 : version);
 85             setReadOnly();
 86         }
 87     }
 88 
 89     private boolean isMultiReleaseJar() throws IOException {
 90         try (InputStream is = newInputStream(getBytes(&quot;/META-INF/MANIFEST.MF&quot;))) {
 91             String multiRelease = new Manifest(is).getMainAttributes()
 92                     .getValue(Attributes.Name.MULTI_RELEASE);
 93             return &quot;true&quot;.equalsIgnoreCase(multiRelease);
 94         } catch (NoSuchFileException x) {
 95             return false;
 96         }
 97     }
 98 
 99     /**
100      * create a map of aliases for versioned entries, for example:
101      *   version/PackagePrivate.class -&gt; META-INF/versions/9/version/PackagePrivate.class
102      *   version/PackagePrivate.java -&gt; META-INF/versions/9/version/PackagePrivate.java
103      *   version/Version.class -&gt; META-INF/versions/10/version/Version.class
104      *   version/Version.java -&gt; META-INF/versions/10/version/Version.java
105      *
106      * then wrap the map in a function that getEntry can use to override root
107      * entry lookup for entries that have corresponding versioned entries
108      */
109     private Function&lt;byte[],byte[]&gt; createVersionedLinks(int version) {
110         HashMap&lt;IndexNode,byte[]&gt; aliasMap = new HashMap&lt;&gt;();
111         IndexNode verdir = getInode(getBytes(&quot;/META-INF/versions&quot;));
112         if (verdir != null) {
113             getVersionMap(version, verdir).values()
114                 .forEach(versionNode -&gt; {   // for each META-INF/versions/{n} directory
115                     // put all the leaf inodes, i.e. entries, into the alias map
116                     // possibly shadowing lower versioned entries
117                     walk(versionNode, entryNode -&gt; {
118                         byte[] rootName = getRootName(versionNode, entryNode);
119                         if (rootName != null) {
120                             IndexNode rootNode = getInode(rootName);
121                             if (rootNode == null) { // no matching root node, make a virtual one
122                                 rootNode = IndexNode.keyOf(rootName);
123                             }
124                             aliasMap.put(rootNode, entryNode.name);
125                         }
126                     });
127                 });
128         }
129         return path -&gt; aliasMap.get(IndexNode.keyOf(path));
130     }
131 
132     /**
133      * create a sorted version map of version -&gt; inode, for inodes &lt;= max version
134      *   9 -&gt; META-INF/versions/9
135      *  10 -&gt; META-INF/versions/10
136      */
137     private TreeMap&lt;Integer, IndexNode&gt; getVersionMap(int version, IndexNode metaInfVersions) {
138         TreeMap&lt;Integer,IndexNode&gt; map = new TreeMap&lt;&gt;();
139         IndexNode child = metaInfVersions.child;
140         while (child != null) {
141             Integer key = getVersion(child.name, metaInfVersions.name.length + 1);
142             if (key != null &amp;&amp; key &lt;= version) {
143                 map.put(key, child);
144             }
145             child = child.sibling;
146         }
147         return map;
148     }
149 
150     /**
151      * extract the integer version number -- META-INF/versions/9 returns 9
152      */
153     private Integer getVersion(byte[] name, int offset) {
154         try {
155             return Integer.parseInt(getString(Arrays.copyOfRange(name, offset, name.length)));
156         } catch (NumberFormatException x) {
157             // ignore this even though it might indicate issues with the JAR structure
158             return null;
159         }
160     }
161 
162     /**
163      * walk the IndexNode tree processing all leaf nodes
164      */
165     private void walk(IndexNode inode, Consumer&lt;IndexNode&gt; process) {
166         if (inode == null) return;
167         if (inode.isDir()) {
168             walk(inode.child, process);
169         } else {
170             process.accept(inode);
171         }
172         walk(inode.sibling, process);
173     }
174 
175     /**
176      * extract the root name from a versioned entry name
177      *   given inode for META-INF/versions/9/foo/bar.class
178      *   and prefix META-INF/versions/9/
179      *   returns foo/bar.class
180      */
181     private byte[] getRootName(IndexNode prefix, IndexNode inode) {
182         int offset = prefix.name.length;
183         byte[] fullName = inode.name;
184         return Arrays.copyOfRange(fullName, offset, fullName.length);
185     }
186 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nio.zipfs;
 27 
 28 import java.nio.file.Paths;
 29 import java.util.Collections;
 30 import java.util.Map;
 31 import java.util.zip.ZipException;
 32 
 33 import static jdk.nio.zipfs.ZipConstants.*;
 34 import static jdk.nio.zipfs.ZipUtils.dosToJavaTime;
 35 import static jdk.nio.zipfs.ZipUtils.unixToJavaTime;
 36 import static jdk.nio.zipfs.ZipUtils.winToJavaTime;
 37 
 38 /**
 39  * Print all loc and cen headers of the ZIP file
 40  *
 41  * @author Xueming Shen
 42  */
 43 public class ZipInfo {
 44 
 45     public static void main(String[] args) throws Throwable {
 46         if (args.length &lt; 1) {
 47             print(&quot;Usage: java ZipInfo zfname&quot;);
 48         } else {
 49             Map&lt;String, ?&gt; env = Collections.emptyMap();
 50             ZipFileSystem zfs = (ZipFileSystem)(new ZipFileSystemProvider()
 51                                     .newFileSystem(Paths.get(args[0]), env));
 52             byte[] cen = zfs.cen;
 53             if (cen == null) {
 54                 print(&quot;zip file is empty%n&quot;);
 55                 return;
 56             }
 57             int    pos = 0;
 58             byte[] buf = new byte[1024];
 59             int    no = 1;
 60             while (pos + CENHDR &lt; cen.length) {
 61                 print(&quot;----------------#%d--------------------%n&quot;, no++);
 62                 printCEN(cen, pos);
 63 
 64                 // use size CENHDR as the extra bytes to read, just in case the
 65                 // loc.extra is bigger than the cen.extra, try to avoid to read
 66                 // twice
 67                 long len = LOCHDR + CENNAM(cen, pos) + CENEXT(cen, pos) + CENHDR;
 68                 if (zfs.readFullyAt(buf, 0, len, locoff(cen, pos)) != len)
 69                     throw new ZipException(&quot;read loc header failed&quot;);
 70                 if (LOCEXT(buf) &gt; CENEXT(cen, pos) + CENHDR) {
 71                     // have to read the second time;
 72                     len = LOCHDR + LOCNAM(buf) + LOCEXT(buf);
 73                     if (zfs.readFullyAt(buf, 0, len, locoff(cen, pos)) != len)
 74                         throw new ZipException(&quot;read loc header failed&quot;);
 75                 }
 76                 printLOC(buf);
 77                 pos += CENHDR + CENNAM(cen, pos) + CENEXT(cen, pos) + CENCOM(cen, pos);
 78             }
 79             zfs.close();
 80         }
 81     }
 82 
 83     private static void print(String fmt, Object... objs) {
 84         System.out.printf(fmt, objs);
 85     }
 86 
 87     private static void printLOC(byte[] loc) {
 88         print(&quot;%n&quot;);
 89         print(&quot;[Local File Header]%n&quot;);
 90         print(&quot;    Signature   :   %#010x%n&quot;, LOCSIG(loc));
 91         if (LOCSIG(loc) != LOCSIG) {
 92            print(&quot;    Wrong signature!&quot;);
 93            return;
 94         }
 95         print(&quot;    Version     :       %#6x    [%d.%d]%n&quot;,
 96                   LOCVER(loc), LOCVER(loc) / 10, LOCVER(loc) % 10);
 97         print(&quot;    Flag        :       %#6x%n&quot;, LOCFLG(loc));
 98         print(&quot;    Method      :       %#6x%n&quot;, LOCHOW(loc));
 99         print(&quot;    LastMTime   :   %#10x    [%tc]%n&quot;,
100               LOCTIM(loc), dosToJavaTime(LOCTIM(loc)));
101         print(&quot;    CRC         :   %#10x%n&quot;, LOCCRC(loc));
102         print(&quot;    CSize       :   %#10x%n&quot;, LOCSIZ(loc));
103         print(&quot;    Size        :   %#10x%n&quot;, LOCLEN(loc));
104         print(&quot;    NameLength  :       %#6x    [%s]%n&quot;,
105                   LOCNAM(loc), new String(loc, LOCHDR, LOCNAM(loc)));
106         print(&quot;    ExtraLength :       %#6x%n&quot;, LOCEXT(loc));
107         if (LOCEXT(loc) != 0)
108             printExtra(loc, LOCHDR + LOCNAM(loc), LOCEXT(loc));
109     }
110 
111     private static void printCEN(byte[] cen, int off) {
112         print(&quot;[Central Directory Header]%n&quot;);
113         print(&quot;    Signature   :   %#010x%n&quot;, CENSIG(cen, off));
114         if (CENSIG(cen, off) != CENSIG) {
115            print(&quot;    Wrong signature!&quot;);
116            return;
117         }
118         print(&quot;    VerMadeby   :       %#6x    [%d, %d.%d]%n&quot;,
119               CENVEM(cen, off), (CENVEM(cen, off) &gt;&gt; 8),
120               (CENVEM(cen, off) &amp; 0xff) / 10,
121               (CENVEM(cen, off) &amp; 0xff) % 10);
122         print(&quot;    VerExtract  :       %#6x    [%d.%d]%n&quot;,
123               CENVER(cen, off), CENVER(cen, off) / 10, CENVER(cen, off) % 10);
124         print(&quot;    Flag        :       %#6x%n&quot;, CENFLG(cen, off));
125         print(&quot;    Method      :       %#6x%n&quot;, CENHOW(cen, off));
126         print(&quot;    LastMTime   :   %#10x    [%tc]%n&quot;,
127               CENTIM(cen, off), dosToJavaTime(CENTIM(cen, off)));
128         print(&quot;    CRC         :   %#10x%n&quot;, CENCRC(cen, off));
129         print(&quot;    CSize       :   %#10x%n&quot;, CENSIZ(cen, off));
130         print(&quot;    Size        :   %#10x%n&quot;, CENLEN(cen, off));
131         print(&quot;    NameLen     :       %#6x    [%s]%n&quot;,
132               CENNAM(cen, off), new String(cen, off + CENHDR, CENNAM(cen, off)));
133         print(&quot;    ExtraLen    :       %#6x%n&quot;, CENEXT(cen, off));
134         if (CENEXT(cen, off) != 0)
135             printExtra(cen, off + CENHDR + CENNAM(cen, off), CENEXT(cen, off));
136         print(&quot;    CommentLen  :       %#6x%n&quot;, CENCOM(cen, off));
137         print(&quot;    DiskStart   :       %#6x%n&quot;, CENDSK(cen, off));
138         print(&quot;    Attrs       :       %#6x%n&quot;, CENATT(cen, off));
139         print(&quot;    AttrsEx     :   %#10x%n&quot;, CENATX(cen, off));
140         print(&quot;    LocOff      :   %#10x%n&quot;, CENOFF(cen, off));
141 
142     }
143 
144     private static long locoff(byte[] cen, int pos) {
145         long locoff = CENOFF(cen, pos);
146         if (locoff == ZIP64_MINVAL) {    //ZIP64
147             int off = pos + CENHDR + CENNAM(cen, pos);
148             int end = off + CENEXT(cen, pos);
149             while (off + 4 &lt; end) {
150                 int tag = SH(cen, off);
151                 int sz = SH(cen, off + 2);
152                 if (tag != EXTID_ZIP64) {
153                     off += 4 + sz;
154                     continue;
155                 }
156                 off += 4;
157                 if (CENLEN(cen, pos) == ZIP64_MINVAL)
158                     off += 8;
159                 if (CENSIZ(cen, pos) == ZIP64_MINVAL)
160                     off += 8;
161                 return LL(cen, off);
162             }
163             // should never be here
164         }
165         return locoff;
166     }
167 
168     private static void printExtra(byte[] extra, int off, int len) {
169         int end = off + len;
170         while (off + 4 &lt;= end) {
171             int tag = SH(extra, off);
172             int sz = SH(extra, off + 2);
173             print(&quot;        [tag=0x%04x, sz=%d, data= &quot;, tag, sz);
174             if (off + sz &gt; end) {
175                 print(&quot;    Error: Invalid extra data, beyond extra length&quot;);
176                 break;
177             }
178             off += 4;
179             for (int i = 0; i &lt; sz; i++)
180                 print(&quot;%02x &quot;, extra[off + i]);
181             print(&quot;]%n&quot;);
182             switch (tag) {
183             case EXTID_ZIP64 :
184                 print(&quot;         -&gt;ZIP64: &quot;);
185                 int pos = off;
186                 while (pos + 8 &lt;= off + sz) {
187                     print(&quot; *0x%x &quot;, LL(extra, pos));
188                     pos += 8;
189                 }
190                 print(&quot;%n&quot;);
191                 break;
192             case EXTID_NTFS:
193                 print(&quot;         -&gt;PKWare NTFS%n&quot;);
194                 // 4 bytes reserved
195                 if (SH(extra, off + 4) !=  0x0001 || SH(extra, off + 6) !=  24)
196                     print(&quot;    Error: Invalid NTFS sub-tag or subsz&quot;);
197                 print(&quot;            mtime:%tc%n&quot;,
198                       winToJavaTime(LL(extra, off + 8)));
199                 print(&quot;            atime:%tc%n&quot;,
200                       winToJavaTime(LL(extra, off + 16)));
201                 print(&quot;            ctime:%tc%n&quot;,
202                       winToJavaTime(LL(extra, off + 24)));
203                 break;
204             case EXTID_EXTT:
205                 print(&quot;         -&gt;Info-ZIP Extended Timestamp: flag=%x%n&quot;,extra[off]);
206                 pos = off + 1 ;
207                 while (pos + 4 &lt;= off + sz) {
208                     print(&quot;            *%tc%n&quot;,
209                           unixToJavaTime(LG(extra, pos)));
210                     pos += 4;
211                 }
212                 break;
213             default:
214                 print(&quot;         -&gt;[tag=%x, size=%d]%n&quot;, tag, sz);
215             }
216             off += sz;
217         }
218     }
219 }
    </pre>
  </body>
</html>
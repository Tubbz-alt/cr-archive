<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipFileSystem.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZipFileStore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipFileSystemProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipFileSystem.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.nio.zipfs;
  27 
  28 import java.io.BufferedOutputStream;
  29 import java.io.ByteArrayInputStream;
  30 import java.io.ByteArrayOutputStream;
  31 import java.io.EOFException;
  32 import java.io.FilterOutputStream;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.OutputStream;

  36 import java.nio.ByteBuffer;
  37 import java.nio.MappedByteBuffer;
  38 import java.nio.channels.FileChannel;
  39 import java.nio.channels.FileLock;
  40 import java.nio.channels.ReadableByteChannel;
  41 import java.nio.channels.SeekableByteChannel;
  42 import java.nio.channels.WritableByteChannel;
  43 import java.nio.file.*;
<span class="line-modified">  44 import java.nio.file.attribute.FileAttribute;</span>
<span class="line-removed">  45 import java.nio.file.attribute.FileTime;</span>
<span class="line-removed">  46 import java.nio.file.attribute.UserPrincipalLookupService;</span>
  47 import java.nio.file.spi.FileSystemProvider;
  48 import java.security.AccessController;
  49 import java.security.PrivilegedAction;
  50 import java.security.PrivilegedActionException;
  51 import java.security.PrivilegedExceptionAction;
  52 import java.util.*;
  53 import java.util.concurrent.locks.ReadWriteLock;
  54 import java.util.concurrent.locks.ReentrantReadWriteLock;




  55 import java.util.regex.Pattern;
  56 import java.util.zip.CRC32;
  57 import java.util.zip.Deflater;
  58 import java.util.zip.DeflaterOutputStream;
  59 import java.util.zip.Inflater;
  60 import java.util.zip.InflaterInputStream;
  61 import java.util.zip.ZipException;
  62 
  63 import static java.lang.Boolean.TRUE;
  64 import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;
  65 import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
  66 import static java.nio.file.StandardOpenOption.APPEND;
  67 import static java.nio.file.StandardOpenOption.CREATE;
  68 import static java.nio.file.StandardOpenOption.CREATE_NEW;
  69 import static java.nio.file.StandardOpenOption.READ;
  70 import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;
  71 import static java.nio.file.StandardOpenOption.WRITE;
  72 import static jdk.nio.zipfs.ZipConstants.*;
  73 import static jdk.nio.zipfs.ZipUtils.*;
  74 
  75 /**
  76  * A FileSystem built on a zip file
  77  *
  78  * @author Xueming Shen
  79  */
  80 class ZipFileSystem extends FileSystem {
























  81     private final ZipFileSystemProvider provider;
  82     private final Path zfpath;
  83     final ZipCoder zc;
  84     private final ZipPath rootdir;
<span class="line-modified">  85     private boolean readOnly = false;    // readonly file system</span>



  86 
  87     // configurable by env map
  88     private final boolean noExtt;        // see readExtra()
  89     private final boolean useTempFile;   // use a temp file for newOS, default
  90                                          // is to use BAOS for better performance
<span class="line-removed">  91     private static final boolean isWindows = AccessController.doPrivileged(</span>
<span class="line-removed">  92             (PrivilegedAction&lt;Boolean&gt;)() -&gt; System.getProperty(&quot;os.name&quot;)</span>
<span class="line-removed">  93                                                    .startsWith(&quot;Windows&quot;));</span>
  94     private final boolean forceEnd64;
<span class="line-modified">  95     private final int defaultMethod;     // METHOD_STORED if &quot;noCompression=true&quot;</span>
<span class="line-modified">  96                                          // METHOD_DEFLATED otherwise</span>











  97 
  98     ZipFileSystem(ZipFileSystemProvider provider,
  99                   Path zfpath,
 100                   Map&lt;String, ?&gt; env) throws IOException
 101     {
 102         // default encoding for name/comment
 103         String nameEncoding = env.containsKey(&quot;encoding&quot;) ?
<span class="line-modified"> 104                               (String)env.get(&quot;encoding&quot;) : &quot;UTF-8&quot;;</span>
 105         this.noExtt = &quot;false&quot;.equals(env.get(&quot;zipinfo-time&quot;));
 106         this.useTempFile  = isTrue(env, &quot;useTempFile&quot;);
 107         this.forceEnd64 = isTrue(env, &quot;forceZIP64End&quot;);
<span class="line-modified"> 108         this.defaultMethod = isTrue(env, &quot;noCompression&quot;) ? METHOD_STORED: METHOD_DEFLATED;</span>






 109         if (Files.notExists(zfpath)) {
<span class="line-modified"> 110             // create a new zip if not exists</span>
 111             if (isTrue(env, &quot;create&quot;)) {
 112                 try (OutputStream os = Files.newOutputStream(zfpath, CREATE_NEW, WRITE)) {
 113                     new END().write(os, 0, forceEnd64);
 114                 }
 115             } else {
<span class="line-modified"> 116                 throw new FileSystemNotFoundException(zfpath.toString());</span>
 117             }
 118         }
 119         // sm and existence check
 120         zfpath.getFileSystem().provider().checkAccess(zfpath, AccessMode.READ);
 121         boolean writeable = AccessController.doPrivileged(
<span class="line-modified"> 122             (PrivilegedAction&lt;Boolean&gt;) () -&gt;  Files.isWritable(zfpath));</span>
 123         this.readOnly = !writeable;
 124         this.zc = ZipCoder.get(nameEncoding);
 125         this.rootdir = new ZipPath(this, new byte[]{&#39;/&#39;});
 126         this.ch = Files.newByteChannel(zfpath, READ);
 127         try {
 128             this.cen = initCEN();
 129         } catch (IOException x) {
 130             try {
 131                 this.ch.close();
 132             } catch (IOException xx) {
 133                 x.addSuppressed(xx);
 134             }
 135             throw x;
 136         }
 137         this.provider = provider;
 138         this.zfpath = zfpath;














































 139     }
 140 
 141     // returns true if there is a name=true/&quot;true&quot; setting in env
 142     private static boolean isTrue(Map&lt;String, ?&gt; env, String name) {
 143         return &quot;true&quot;.equals(env.get(name)) || TRUE.equals(env.get(name));
 144     }
 145 







































































































 146     @Override
 147     public FileSystemProvider provider() {
 148         return provider;
 149     }
 150 
 151     @Override
 152     public String getSeparator() {
 153         return &quot;/&quot;;
 154     }
 155 
 156     @Override
 157     public boolean isOpen() {
 158         return isOpen;
 159     }
 160 
 161     @Override
 162     public boolean isReadOnly() {
 163         return readOnly;
 164     }
 165 
<span class="line-modified"> 166     private void checkWritable() throws IOException {</span>
<span class="line-modified"> 167         if (readOnly)</span>
 168             throw new ReadOnlyFileSystemException();

 169     }
 170 
 171     void setReadOnly() {
 172         this.readOnly = true;
 173     }
 174 
 175     @Override
 176     public Iterable&lt;Path&gt; getRootDirectories() {
 177         return List.of(rootdir);
 178     }
 179 
 180     ZipPath getRootDir() {
 181         return rootdir;
 182     }
 183 
 184     @Override
 185     public ZipPath getPath(String first, String... more) {
 186         if (more.length == 0) {
 187             return new ZipPath(this, first);
 188         }
</pre>
<hr />
<pre>
 201 
 202     @Override
 203     public UserPrincipalLookupService getUserPrincipalLookupService() {
 204         throw new UnsupportedOperationException();
 205     }
 206 
 207     @Override
 208     public WatchService newWatchService() {
 209         throw new UnsupportedOperationException();
 210     }
 211 
 212     FileStore getFileStore(ZipPath path) {
 213         return new ZipFileStore(path);
 214     }
 215 
 216     @Override
 217     public Iterable&lt;FileStore&gt; getFileStores() {
 218         return List.of(new ZipFileStore(rootdir));
 219     }
 220 
<span class="line-removed"> 221     private static final Set&lt;String&gt; supportedFileAttributeViews =</span>
<span class="line-removed"> 222             Set.of(&quot;basic&quot;, &quot;zip&quot;);</span>
<span class="line-removed"> 223 </span>
 224     @Override
 225     public Set&lt;String&gt; supportedFileAttributeViews() {
 226         return supportedFileAttributeViews;
 227     }
 228 
 229     @Override
 230     public String toString() {
 231         return zfpath.toString();
 232     }
 233 
 234     Path getZipFile() {
 235         return zfpath;
 236     }
 237 
 238     private static final String GLOB_SYNTAX = &quot;glob&quot;;
 239     private static final String REGEX_SYNTAX = &quot;regex&quot;;
 240 
 241     @Override
 242     public PathMatcher getPathMatcher(String syntaxAndInput) {
 243         int pos = syntaxAndInput.indexOf(&#39;:&#39;);
 244         if (pos &lt;= 0 || pos == syntaxAndInput.length()) {
 245             throw new IllegalArgumentException();
 246         }
 247         String syntax = syntaxAndInput.substring(0, pos);
 248         String input = syntaxAndInput.substring(pos + 1);
 249         String expr;
 250         if (syntax.equalsIgnoreCase(GLOB_SYNTAX)) {
 251             expr = toRegexPattern(input);
 252         } else {
 253             if (syntax.equalsIgnoreCase(REGEX_SYNTAX)) {
 254                 expr = input;
 255             } else {
 256                 throw new UnsupportedOperationException(&quot;Syntax &#39;&quot; + syntax +
 257                     &quot;&#39; not recognized&quot;);
 258             }
 259         }
 260         // return matcher
 261         final Pattern pattern = Pattern.compile(expr);
<span class="line-modified"> 262         return new PathMatcher() {</span>
<span class="line-removed"> 263             @Override</span>
<span class="line-removed"> 264             public boolean matches(Path path) {</span>
<span class="line-removed"> 265                 return pattern.matcher(path.toString()).matches();</span>
<span class="line-removed"> 266             }</span>
<span class="line-removed"> 267         };</span>
 268     }
 269 
 270     @Override
 271     public void close() throws IOException {
 272         beginWrite();
 273         try {
 274             if (!isOpen)
 275                 return;
 276             isOpen = false;          // set closed
 277         } finally {
 278             endWrite();
 279         }
 280         if (!streams.isEmpty()) {    // unlock and close all remaining streams
 281             Set&lt;InputStream&gt; copy = new HashSet&lt;&gt;(streams);
 282             for (InputStream is : copy)
 283                 is.close();
 284         }
 285         beginWrite();                // lock and sync
 286         try {
 287             AccessController.doPrivileged((PrivilegedExceptionAction&lt;Void&gt;)() -&gt; {
 288                 sync(); return null;
 289             });
 290             ch.close();              // close the ch just in case no update
 291                                      // and sync didn&#39;t close the ch
 292         } catch (PrivilegedActionException e) {
 293             throw (IOException)e.getException();
 294         } finally {
 295             endWrite();
 296         }
 297 
 298         synchronized (inflaters) {
 299             for (Inflater inf : inflaters)
 300                 inf.end();
 301         }
 302         synchronized (deflaters) {
 303             for (Deflater def : deflaters)
 304                 def.end();
 305         }
 306 








 307         IOException ioe = null;
 308         synchronized (tmppaths) {
 309             for (Path p : tmppaths) {
 310                 try {
 311                     AccessController.doPrivileged(
 312                         (PrivilegedExceptionAction&lt;Boolean&gt;)() -&gt; Files.deleteIfExists(p));
 313                 } catch (PrivilegedActionException e) {
 314                     IOException x = (IOException)e.getException();
 315                     if (ioe == null)
 316                         ioe = x;
 317                     else
 318                         ioe.addSuppressed(x);
 319                 }
 320             }
 321         }
 322         provider.removeFileSystem(zfpath, this);
 323         if (ioe != null)
 324            throw ioe;
 325     }
 326 
 327     ZipFileAttributes getFileAttributes(byte[] path)
 328         throws IOException
 329     {
<span class="line-removed"> 330         Entry e;</span>
 331         beginRead();
 332         try {
 333             ensureOpen();
<span class="line-modified"> 334             e = getEntry(path);</span>
<span class="line-modified"> 335             if (e == null) {</span>
<span class="line-modified"> 336                 IndexNode inode = getInode(path);</span>
<span class="line-modified"> 337                 if (inode == null)</span>
<span class="line-modified"> 338                     return null;</span>

 339                 // pseudo directory, uses METHOD_STORED
<span class="line-modified"> 340                 e = new Entry(inode.name, inode.isdir, METHOD_STORED);</span>


 341                 e.mtime = e.atime = e.ctime = zfsDefaultTimeStamp;



 342             }
 343         } finally {
 344             endRead();
 345         }
<span class="line-removed"> 346         return e;</span>
 347     }
 348 
 349     void checkAccess(byte[] path) throws IOException {
 350         beginRead();
 351         try {
 352             ensureOpen();
 353             // is it necessary to readCEN as a sanity check?
 354             if (getInode(path) == null) {
 355                 throw new NoSuchFileException(toString());
 356             }
 357 
 358         } finally {
 359             endRead();
 360         }
 361     }
 362 
 363     void setTimes(byte[] path, FileTime mtime, FileTime atime, FileTime ctime)
 364         throws IOException
 365     {
 366         checkWritable();
 367         beginWrite();
 368         try {
 369             ensureOpen();
 370             Entry e = getEntry(path);    // ensureOpen checked
 371             if (e == null)
 372                 throw new NoSuchFileException(getString(path));
 373             if (e.type == Entry.CEN)
<span class="line-modified"> 374                 e.type = Entry.COPY;      // copy e</span>
 375             if (mtime != null)
 376                 e.mtime = mtime.toMillis();
 377             if (atime != null)
 378                 e.atime = atime.toMillis();
 379             if (ctime != null)
 380                 e.ctime = ctime.toMillis();
 381             update(e);
 382         } finally {
 383             endWrite();
 384         }
 385     }
 386 
<span class="line-modified"> 387     boolean exists(byte[] path)</span>
<span class="line-modified"> 388         throws IOException</span>
<span class="line-modified"> 389     {</span>

























































 390         beginRead();
 391         try {
 392             ensureOpen();
 393             return getInode(path) != null;
 394         } finally {
 395             endRead();
 396         }
 397     }
 398 
<span class="line-modified"> 399     boolean isDirectory(byte[] path)</span>
<span class="line-removed"> 400         throws IOException</span>
<span class="line-removed"> 401     {</span>
 402         beginRead();
 403         try {
 404             IndexNode n = getInode(path);
 405             return n != null &amp;&amp; n.isDir();
 406         } finally {
 407             endRead();
 408         }
 409     }
 410 
 411     // returns the list of child paths of &quot;path&quot;
 412     Iterator&lt;Path&gt; iteratorOf(ZipPath dir,
 413                               DirectoryStream.Filter&lt;? super Path&gt; filter)
 414         throws IOException
 415     {
 416         beginWrite();    // iteration of inodes needs exclusive lock
 417         try {
 418             ensureOpen();
 419             byte[] path = dir.getResolvedPath();
 420             IndexNode inode = getInode(path);
 421             if (inode == null)
 422                 throw new NotDirectoryException(getString(path));
 423             List&lt;Path&gt; list = new ArrayList&lt;&gt;();
 424             IndexNode child = inode.child;
 425             while (child != null) {
 426                 // (1) Assume each path from the zip file itself is &quot;normalized&quot;
 427                 // (2) IndexNode.name is absolute. see IndexNode(byte[],int,int)
 428                 // (3) If parent &quot;dir&quot; is relative when ZipDirectoryStream
 429                 //     is created, the returned child path needs to be relative
 430                 //     as well.
<span class="line-modified"> 431                 byte[] cname = child.name;</span>
<span class="line-removed"> 432                 ZipPath childPath = new ZipPath(this, cname, true);</span>
 433                 ZipPath childFileName = childPath.getFileName();
 434                 ZipPath zpath = dir.resolve(childFileName);
 435                 if (filter == null || filter.accept(zpath))
 436                     list.add(zpath);
 437                 child = child.sibling;
 438             }
 439             return list.iterator();
 440         } finally {
 441             endWrite();
 442         }
 443     }
 444 
<span class="line-modified"> 445     void createDirectory(byte[] dir, FileAttribute&lt;?&gt;... attrs)</span>
<span class="line-removed"> 446         throws IOException</span>
<span class="line-removed"> 447     {</span>
 448         checkWritable();
<span class="line-removed"> 449         //  dir = toDirectoryPath(dir);</span>
 450         beginWrite();
 451         try {
 452             ensureOpen();
<span class="line-modified"> 453             if (dir.length == 0 || exists(dir))  // root dir, or exiting dir</span>
 454                 throw new FileAlreadyExistsException(getString(dir));
 455             checkParents(dir);
<span class="line-modified"> 456             Entry e = new Entry(dir, Entry.NEW, true, METHOD_STORED);</span>


 457             update(e);
 458         } finally {
 459             endWrite();
 460         }
 461     }
 462 
 463     void copyFile(boolean deletesrc, byte[]src, byte[] dst, CopyOption... options)
 464         throws IOException
 465     {
 466         checkWritable();
 467         if (Arrays.equals(src, dst))
 468             return;    // do nothing, src and dst are the same
 469 
 470         beginWrite();
 471         try {
 472             ensureOpen();
 473             Entry eSrc = getEntry(src);  // ensureOpen checked
 474 
 475             if (eSrc == null)
 476                 throw new NoSuchFileException(getString(src));
 477             if (eSrc.isDir()) {    // spec says to create dst dir
 478                 createDirectory(dst);
 479                 return;
 480             }
 481             boolean hasReplace = false;
 482             boolean hasCopyAttrs = false;
 483             for (CopyOption opt : options) {
 484                 if (opt == REPLACE_EXISTING)
 485                     hasReplace = true;
 486                 else if (opt == COPY_ATTRIBUTES)
 487                     hasCopyAttrs = true;
 488             }
 489             Entry eDst = getEntry(dst);
 490             if (eDst != null) {
 491                 if (!hasReplace)
 492                     throw new FileAlreadyExistsException(getString(dst));
 493             } else {
 494                 checkParents(dst);
 495             }
<span class="line-modified"> 496             Entry u = new Entry(eSrc, Entry.COPY);  // copy eSrc entry</span>
<span class="line-modified"> 497             u.name(dst);                            // change name</span>
<span class="line-modified"> 498             if (eSrc.type == Entry.NEW || eSrc.type == Entry.FILECH)</span>
<span class="line-modified"> 499             {</span>


 500                 u.type = eSrc.type;    // make it the same type
 501                 if (deletesrc) {       // if it&#39;s a &quot;rename&quot;, take the data
 502                     u.bytes = eSrc.bytes;
 503                     u.file = eSrc.file;
 504                 } else {               // if it&#39;s not &quot;rename&quot;, copy the data
 505                     if (eSrc.bytes != null)
 506                         u.bytes = Arrays.copyOf(eSrc.bytes, eSrc.bytes.length);
 507                     else if (eSrc.file != null) {
 508                         u.file = getTempPathForEntry(null);
 509                         Files.copy(eSrc.file, u.file, REPLACE_EXISTING);
 510                     }
 511                 }












 512             }

 513             if (!hasCopyAttrs)
 514                 u.mtime = u.atime= u.ctime = System.currentTimeMillis();
 515             update(u);
 516             if (deletesrc)
 517                 updateDelete(eSrc);
 518         } finally {
 519             endWrite();
 520         }
 521     }
 522 
 523     // Returns an output stream for writing the contents into the specified
 524     // entry.
 525     OutputStream newOutputStream(byte[] path, OpenOption... options)
 526         throws IOException
 527     {
 528         checkWritable();
 529         boolean hasCreateNew = false;
 530         boolean hasCreate = false;
 531         boolean hasAppend = false;
 532         boolean hasTruncate = false;
</pre>
<hr />
<pre>
 535                 throw new IllegalArgumentException(&quot;READ not allowed&quot;);
 536             if (opt == CREATE_NEW)
 537                 hasCreateNew = true;
 538             if (opt == CREATE)
 539                 hasCreate = true;
 540             if (opt == APPEND)
 541                 hasAppend = true;
 542             if (opt == TRUNCATE_EXISTING)
 543                 hasTruncate = true;
 544         }
 545         if (hasAppend &amp;&amp; hasTruncate)
 546             throw new IllegalArgumentException(&quot;APPEND + TRUNCATE_EXISTING not allowed&quot;);
 547         beginRead();                 // only need a readlock, the &quot;update()&quot; will
 548         try {                        // try to obtain a writelock when the os is
 549             ensureOpen();            // being closed.
 550             Entry e = getEntry(path);
 551             if (e != null) {
 552                 if (e.isDir() || hasCreateNew)
 553                     throw new FileAlreadyExistsException(getString(path));
 554                 if (hasAppend) {
<span class="line-removed"> 555                     InputStream is = getInputStream(e);</span>
 556                     OutputStream os = getOutputStream(new Entry(e, Entry.NEW));
<span class="line-modified"> 557                     is.transferTo(os);</span>
<span class="line-modified"> 558                     is.close();</span>

 559                     return os;
 560                 }
<span class="line-modified"> 561                 return getOutputStream(new Entry(e, Entry.NEW));</span>


 562             } else {
 563                 if (!hasCreate &amp;&amp; !hasCreateNew)
 564                     throw new NoSuchFileException(getString(path));
 565                 checkParents(path);
<span class="line-modified"> 566                 return getOutputStream(new Entry(path, Entry.NEW, false, defaultMethod));</span>


 567             }
 568         } finally {
 569             endRead();
 570         }
 571     }
 572 
 573     // Returns an input stream for reading the contents of the specified
 574     // file entry.
 575     InputStream newInputStream(byte[] path) throws IOException {
 576         beginRead();
 577         try {
 578             ensureOpen();
 579             Entry e = getEntry(path);
 580             if (e == null)
 581                 throw new NoSuchFileException(getString(path));
 582             if (e.isDir())
 583                 throw new FileSystemException(getString(path), &quot;is a directory&quot;, null);
 584             return getInputStream(e);
 585         } finally {
 586             endRead();
 587         }
 588     }
 589 
 590     private void checkOptions(Set&lt;? extends OpenOption&gt; options) {
 591         // check for options of null type and option is an intance of StandardOpenOption
 592         for (OpenOption option : options) {
 593             if (option == null)
 594                 throw new NullPointerException();
 595             if (!(option instanceof StandardOpenOption))
 596                 throw new IllegalArgumentException();
 597         }
 598         if (options.contains(APPEND) &amp;&amp; options.contains(TRUNCATE_EXISTING))
 599             throw new IllegalArgumentException(&quot;APPEND + TRUNCATE_EXISTING not allowed&quot;);
 600     }
 601 
<span class="line-removed"> 602 </span>
 603     // Returns an output SeekableByteChannel for either
<span class="line-modified"> 604     // (1) writing the contents of a new entry, if the entry doesn&#39;t exit, or</span>
 605     // (2) updating/replacing the contents of an existing entry.
<span class="line-modified"> 606     // Note: The content is not compressed.</span>

 607     private class EntryOutputChannel extends ByteArrayChannel {
<span class="line-modified"> 608         Entry e;</span>
 609 
<span class="line-modified"> 610         EntryOutputChannel(Entry e) throws IOException {</span>
 611             super(e.size &gt; 0? (int)e.size : 8192, false);
 612             this.e = e;
 613             if (e.mtime == -1)
 614                 e.mtime = System.currentTimeMillis();
 615             if (e.method == -1)
<span class="line-modified"> 616                 e.method = defaultMethod;</span>
 617             // store size, compressed size, and crc-32 in datadescriptor
 618             e.flag = FLAG_DATADESCR;
 619             if (zc.isUTF8())
 620                 e.flag |= FLAG_USE_UTF8;
 621         }
 622 
 623         @Override
 624         public void close() throws IOException {
<span class="line-modified"> 625             e.bytes = toByteArray();</span>
<span class="line-modified"> 626             e.size = e.bytes.length;</span>
<span class="line-modified"> 627             e.crc = -1;</span>

 628             super.close();
<span class="line-removed"> 629             update(e);</span>
 630         }
 631     }
 632 
<span class="line-modified"> 633     private int getCompressMethod(FileAttribute&lt;?&gt;... attrs) {</span>
<span class="line-removed"> 634          return defaultMethod;</span>
<span class="line-removed"> 635     }</span>
<span class="line-removed"> 636 </span>
<span class="line-removed"> 637     // Returns a Writable/ReadByteChannel for now. Might consdier to use</span>
 638     // newFileChannel() instead, which dump the entry data into a regular
<span class="line-modified"> 639     // file on the default file system and create a FileChannel on top of</span>
<span class="line-removed"> 640     // it.</span>
 641     SeekableByteChannel newByteChannel(byte[] path,
 642                                        Set&lt;? extends OpenOption&gt; options,
 643                                        FileAttribute&lt;?&gt;... attrs)
 644         throws IOException
 645     {
 646         checkOptions(options);
 647         if (options.contains(StandardOpenOption.WRITE) ||
 648             options.contains(StandardOpenOption.APPEND)) {
 649             checkWritable();
<span class="line-modified"> 650             beginRead();    // only need a readlock, the &quot;update()&quot; will obtain</span>
<span class="line-modified"> 651                             // thewritelock when the channel is closed</span>
 652             try {
<span class="line-removed"> 653                 ensureOpen();</span>
 654                 Entry e = getEntry(path);
 655                 if (e != null) {
 656                     if (e.isDir() || options.contains(CREATE_NEW))
 657                         throw new FileAlreadyExistsException(getString(path));
 658                     SeekableByteChannel sbc =
<span class="line-modified"> 659                             new EntryOutputChannel(new Entry(e, Entry.NEW));</span>


 660                     if (options.contains(APPEND)) {
 661                         try (InputStream is = getInputStream(e)) {  // copyover
 662                             byte[] buf = new byte[8192];
 663                             ByteBuffer bb = ByteBuffer.wrap(buf);
 664                             int n;
 665                             while ((n = is.read(buf)) != -1) {
 666                                 bb.position(0);
 667                                 bb.limit(n);
 668                                 sbc.write(bb);
 669                             }
 670                         }
 671                     }
 672                     return sbc;
 673                 }
 674                 if (!options.contains(CREATE) &amp;&amp; !options.contains(CREATE_NEW))
 675                     throw new NoSuchFileException(getString(path));
 676                 checkParents(path);
 677                 return new EntryOutputChannel(
<span class="line-modified"> 678                     new Entry(path, Entry.NEW, false, getCompressMethod(attrs)));</span>
<span class="line-modified"> 679 </span>

 680             } finally {
 681                 endRead();
 682             }
 683         } else {
 684             beginRead();
 685             try {
 686                 ensureOpen();
 687                 Entry e = getEntry(path);
 688                 if (e == null || e.isDir())
 689                     throw new NoSuchFileException(getString(path));
 690                 try (InputStream is = getInputStream(e)) {
 691                     // TBD: if (e.size &lt; NNNNN);
 692                     return new ByteArrayChannel(is.readAllBytes(), true);
 693                 }
 694             } finally {
 695                 endRead();
 696             }
 697         }
 698     }
 699 
</pre>
<hr />
<pre>
 723                     }
 724                 } else {
 725                     if (options.contains(StandardOpenOption.CREATE_NEW)) {
 726                         throw new FileAlreadyExistsException(getString(path));
 727                     }
 728                     if (e.isDir())
 729                         throw new FileAlreadyExistsException(&quot;directory &lt;&quot;
 730                             + getString(path) + &quot;&gt; exists&quot;);
 731                 }
 732                 options = new HashSet&lt;&gt;(options);
 733                 options.remove(StandardOpenOption.CREATE_NEW); // for tmpfile
 734             } else if (e == null || e.isDir()) {
 735                 throw new NoSuchFileException(getString(path));
 736             }
 737 
 738             final boolean isFCH = (e != null &amp;&amp; e.type == Entry.FILECH);
 739             final Path tmpfile = isFCH ? e.file : getTempPathForEntry(path);
 740             final FileChannel fch = tmpfile.getFileSystem()
 741                                            .provider()
 742                                            .newFileChannel(tmpfile, options, attrs);
<span class="line-modified"> 743             final Entry u = isFCH ? e : new Entry(path, tmpfile, Entry.FILECH);</span>



 744             if (forWrite) {
 745                 u.flag = FLAG_DATADESCR;
<span class="line-modified"> 746                 u.method = getCompressMethod(attrs);</span>
 747             }
 748             // is there a better way to hook into the FileChannel&#39;s close method?
 749             return new FileChannel() {
 750                 public int write(ByteBuffer src) throws IOException {
 751                     return fch.write(src);
 752                 }
 753                 public long write(ByteBuffer[] srcs, int offset, int length)
 754                     throws IOException
 755                 {
 756                     return fch.write(srcs, offset, length);
 757                 }
 758                 public long position() throws IOException {
 759                     return fch.position();
 760                 }
 761                 public FileChannel position(long newPosition)
 762                     throws IOException
 763                 {
 764                     fch.position(newPosition);
 765                     return this;
 766                 }
</pre>
<hr />
<pre>
 793                 public int read(ByteBuffer dst) throws IOException {
 794                     return fch.read(dst);
 795                 }
 796                 public int read(ByteBuffer dst, long position)
 797                     throws IOException
 798                 {
 799                     return fch.read(dst, position);
 800                 }
 801                 public long read(ByteBuffer[] dsts, int offset, int length)
 802                     throws IOException
 803                 {
 804                     return fch.read(dsts, offset, length);
 805                 }
 806                 public int write(ByteBuffer src, long position)
 807                     throws IOException
 808                     {
 809                    return fch.write(src, position);
 810                 }
 811                 public MappedByteBuffer map(MapMode mode,
 812                                             long position, long size)
<span class="line-removed"> 813                     throws IOException</span>
 814                 {
 815                     throw new UnsupportedOperationException();
 816                 }
 817                 public FileLock lock(long position, long size, boolean shared)
 818                     throws IOException
 819                 {
 820                     return fch.lock(position, size, shared);
 821                 }
 822                 public FileLock tryLock(long position, long size, boolean shared)
 823                     throws IOException
 824                 {
 825                     return fch.tryLock(position, size, shared);
 826                 }
 827                 protected void implCloseChannel() throws IOException {
 828                     fch.close();
 829                     if (forWrite) {
 830                         u.mtime = System.currentTimeMillis();
 831                         u.size = Files.size(u.file);
<span class="line-removed"> 832 </span>
 833                         update(u);
 834                     } else {
 835                         if (!isFCH)    // if this is a new fch for reading
 836                             removeTempPathForEntry(tmpfile);
 837                     }
 838                }
 839             };
 840         } finally {
 841             endRead();
 842         }
 843     }
 844 
 845     // the outstanding input streams that need to be closed
 846     private Set&lt;InputStream&gt; streams =
<span class="line-modified"> 847         Collections.synchronizedSet(new HashSet&lt;InputStream&gt;());</span>




 848 
<span class="line-modified"> 849     private Set&lt;Path&gt; tmppaths = Collections.synchronizedSet(new HashSet&lt;Path&gt;());</span>
 850     private Path getTempPathForEntry(byte[] path) throws IOException {
 851         Path tmpPath = createTempFileInSameDirectoryAs(zfpath);
 852         if (path != null) {
 853             Entry e = getEntry(path);
 854             if (e != null) {
 855                 try (InputStream is = newInputStream(path)) {
 856                     Files.copy(is, tmpPath, REPLACE_EXISTING);
 857                 }
 858             }
 859         }
 860         return tmpPath;
 861     }
 862 
 863     private void removeTempPathForEntry(Path path) throws IOException {
 864         Files.delete(path);
 865         tmppaths.remove(path);
 866     }
 867 
<span class="line-modified"> 868     // check if all parents really exit. ZIP spec does not require</span>
 869     // the existence of any &quot;parent directory&quot;.
 870     private void checkParents(byte[] path) throws IOException {
 871         beginRead();
 872         try {
 873             while ((path = getParent(path)) != null &amp;&amp;
 874                     path != ROOTPATH) {
 875                 if (!inodes.containsKey(IndexNode.keyOf(path))) {
 876                     throw new NoSuchFileException(getString(path));
 877                 }
 878             }
 879         } finally {
 880             endRead();
 881         }
 882     }
 883 
<span class="line-removed"> 884     private static byte[] ROOTPATH = new byte[] { &#39;/&#39; };</span>
 885     private static byte[] getParent(byte[] path) {
 886         int off = getParentOff(path);
 887         if (off &lt;= 1)
 888             return ROOTPATH;
 889         return Arrays.copyOf(path, off);
 890     }
 891 
 892     private static int getParentOff(byte[] path) {
 893         int off = path.length - 1;
 894         if (off &gt; 0 &amp;&amp; path[off] == &#39;/&#39;)  // isDirectory
 895             off--;
 896         while (off &gt; 0 &amp;&amp; path[off] != &#39;/&#39;) { off--; }
 897         return off;
 898     }
 899 
<span class="line-modified"> 900     private final void beginWrite() {</span>
 901         rwlock.writeLock().lock();
 902     }
 903 
<span class="line-modified"> 904     private final void endWrite() {</span>
 905         rwlock.writeLock().unlock();
 906     }
 907 
<span class="line-modified"> 908     private final void beginRead() {</span>
 909         rwlock.readLock().lock();
 910     }
 911 
<span class="line-modified"> 912     private final void endRead() {</span>
 913         rwlock.readLock().unlock();
 914     }
 915 
 916     ///////////////////////////////////////////////////////////////////
 917 
 918     private volatile boolean isOpen = true;
 919     private final SeekableByteChannel ch; // channel to the zipfile
 920     final byte[]  cen;     // CEN &amp; ENDHDR
 921     private END  end;
 922     private long locpos;   // position of first LOC header (usually 0)
 923 
 924     private final ReadWriteLock rwlock = new ReentrantReadWriteLock();
 925 
 926     // name -&gt; pos (in cen), IndexNode itself can be used as a &quot;key&quot;
 927     private LinkedHashMap&lt;IndexNode, IndexNode&gt; inodes;
 928 
 929     final byte[] getBytes(String name) {
 930         return zc.getBytes(name);
 931     }
 932 
</pre>
<hr />
<pre>
 934         return zc.toString(name);
 935     }
 936 
 937     @SuppressWarnings(&quot;deprecation&quot;)
 938     protected void finalize() throws IOException {
 939         close();
 940     }
 941 
 942     // Reads len bytes of data from the specified offset into buf.
 943     // Returns the total number of bytes read.
 944     // Each/every byte read from here (except the cen, which is mapped).
 945     final long readFullyAt(byte[] buf, int off, long len, long pos)
 946         throws IOException
 947     {
 948         ByteBuffer bb = ByteBuffer.wrap(buf);
 949         bb.position(off);
 950         bb.limit((int)(off + len));
 951         return readFullyAt(bb, pos);
 952     }
 953 
<span class="line-modified"> 954     private final long readFullyAt(ByteBuffer bb, long pos)</span>
<span class="line-removed"> 955         throws IOException</span>
<span class="line-removed"> 956     {</span>
 957         synchronized(ch) {
 958             return ch.position(pos).read(bb);
 959         }
 960     }
 961 
 962     // Searches for end of central directory (END) header. The contents of
 963     // the END header will be read and placed in endbuf. Returns the file
 964     // position of the END header, otherwise returns -1 if the END header
 965     // was not found or an error occurred.
<span class="line-modified"> 966     private END findEND() throws IOException</span>
<span class="line-removed"> 967     {</span>
 968         byte[] buf = new byte[READBLOCKSZ];
 969         long ziplen = ch.size();
 970         long minHDR = (ziplen - END_MAXLEN) &gt; 0 ? ziplen - END_MAXLEN : 0;
 971         long minPos = minHDR - (buf.length - ENDHDR);
 972 
<span class="line-modified"> 973         for (long pos = ziplen - buf.length; pos &gt;= minPos; pos -= (buf.length - ENDHDR))</span>
<span class="line-removed"> 974         {</span>
 975             int off = 0;
 976             if (pos &lt; 0) {
 977                 // Pretend there are some NUL bytes before start of file
 978                 off = (int)-pos;
 979                 Arrays.fill(buf, 0, off, (byte)0);
 980             }
 981             int len = buf.length - off;
 982             if (readFullyAt(buf, off, len, pos + off) != len)
<span class="line-modified"> 983                 zerror(&quot;zip END header not found&quot;);</span>
 984 
 985             // Now scan the block backwards for END header signature
 986             for (int i = buf.length - ENDHDR; i &gt;= 0; i--) {
<span class="line-modified"> 987                 if (buf[i+0] == (byte)&#39;P&#39;    &amp;&amp;</span>
 988                     buf[i+1] == (byte)&#39;K&#39;    &amp;&amp;
 989                     buf[i+2] == (byte)&#39;\005&#39; &amp;&amp;
 990                     buf[i+3] == (byte)&#39;\006&#39; &amp;&amp;
 991                     (pos + i + ENDHDR + ENDCOM(buf, i) == ziplen)) {
 992                     // Found END header
 993                     buf = Arrays.copyOfRange(buf, i, i + ENDHDR);
 994                     END end = new END();
<span class="line-modified"> 995                     end.endsub = ENDSUB(buf);</span>
 996                     end.centot = ENDTOT(buf);
 997                     end.cenlen = ENDSIZ(buf);
 998                     end.cenoff = ENDOFF(buf);
<span class="line-modified"> 999                     end.comlen = ENDCOM(buf);</span>
1000                     end.endpos = pos + i;
1001                     // try if there is zip64 end;
1002                     byte[] loc64 = new byte[ZIP64_LOCHDR];
1003                     if (end.endpos &lt; ZIP64_LOCHDR ||
1004                         readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)
1005                         != loc64.length ||
1006                         !locator64SigAt(loc64, 0)) {
1007                         return end;
1008                     }
1009                     long end64pos = ZIP64_LOCOFF(loc64);
1010                     byte[] end64buf = new byte[ZIP64_ENDHDR];
1011                     if (readFullyAt(end64buf, 0, end64buf.length, end64pos)
1012                         != end64buf.length ||
1013                         !end64SigAt(end64buf, 0)) {
1014                         return end;
1015                     }
1016                     // end64 found,
1017                     long cenlen64 = ZIP64_ENDSIZ(end64buf);
1018                     long cenoff64 = ZIP64_ENDOFF(end64buf);
1019                     long centot64 = ZIP64_ENDTOT(end64buf);
1020                     // double-check
1021                     if (cenlen64 != end.cenlen &amp;&amp; end.cenlen != ZIP64_MINVAL ||
1022                         cenoff64 != end.cenoff &amp;&amp; end.cenoff != ZIP64_MINVAL ||
1023                         centot64 != end.centot &amp;&amp; end.centot != ZIP64_MINVAL32) {
1024                         return end;
1025                     }
1026                     // to use the end64 values
1027                     end.cenlen = cenlen64;
1028                     end.cenoff = cenoff64;
1029                     end.centot = (int)centot64; // assume total &lt; 2g
1030                     end.endpos = end64pos;
1031                     return end;
1032                 }
1033             }
1034         }
<span class="line-modified">1035         zerror(&quot;zip END header not found&quot;);</span>
<span class="line-modified">1036         return null; //make compiler happy</span>













































































































































































































1037     }
1038 
1039     // Reads zip file central directory. Returns the file position of first
1040     // CEN header, otherwise returns -1 if an error occurred. If zip-&gt;msg != NULL
1041     // then the error was a zip format error and zip-&gt;msg has the error text.
1042     // Always pass in -1 for knownTotal; it&#39;s used for a recursive call.
1043     private byte[] initCEN() throws IOException {
1044         end = findEND();
1045         if (end.endpos == 0) {
1046             inodes = new LinkedHashMap&lt;&gt;(10);
1047             locpos = 0;
1048             buildNodeTree();
1049             return null;         // only END header present
1050         }
1051         if (end.cenlen &gt; end.endpos)
<span class="line-modified">1052             zerror(&quot;invalid END header (bad central directory size)&quot;);</span>
1053         long cenpos = end.endpos - end.cenlen;     // position of CEN table
1054 
1055         // Get position of first local file (LOC) header, taking into
1056         // account that there may be a stub prefixed to the zip file.
1057         locpos = cenpos - end.cenoff;
1058         if (locpos &lt; 0)
<span class="line-modified">1059             zerror(&quot;invalid END header (bad central directory offset)&quot;);</span>
1060 
1061         // read in the CEN and END
1062         byte[] cen = new byte[(int)(end.cenlen + ENDHDR)];
1063         if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
<span class="line-modified">1064             zerror(&quot;read CEN tables failed&quot;);</span>
1065         }
1066         // Iterate through the entries in the central directory
1067         inodes = new LinkedHashMap&lt;&gt;(end.centot + 1);
1068         int pos = 0;
1069         int limit = cen.length - ENDHDR;
1070         while (pos &lt; limit) {
1071             if (!cenSigAt(cen, pos))
<span class="line-modified">1072                 zerror(&quot;invalid CEN header (bad signature)&quot;);</span>
1073             int method = CENHOW(cen, pos);
1074             int nlen   = CENNAM(cen, pos);
1075             int elen   = CENEXT(cen, pos);
1076             int clen   = CENCOM(cen, pos);
1077             if ((CENFLG(cen, pos) &amp; 1) != 0) {
<span class="line-modified">1078                 zerror(&quot;invalid CEN header (encrypted entry)&quot;);</span>
1079             }
1080             if (method != METHOD_STORED &amp;&amp; method != METHOD_DEFLATED) {
<span class="line-modified">1081                 zerror(&quot;invalid CEN header (unsupported compression method: &quot; + method + &quot;)&quot;);</span>
1082             }
1083             if (pos + CENHDR + nlen &gt; limit) {
<span class="line-modified">1084                 zerror(&quot;invalid CEN header (bad header size)&quot;);</span>
1085             }
1086             IndexNode inode = new IndexNode(cen, pos, nlen);
1087             inodes.put(inode, inode);
1088 
1089             // skip ext and comment
1090             pos += (CENHDR + nlen + elen + clen);
1091         }
1092         if (pos + ENDHDR != cen.length) {
<span class="line-modified">1093             zerror(&quot;invalid CEN header (bad header size)&quot;);</span>
1094         }
1095         buildNodeTree();
1096         return cen;
1097     }
1098 
<span class="line-modified">1099     private void ensureOpen() throws IOException {</span>
1100         if (!isOpen)
1101             throw new ClosedFileSystemException();
1102     }
1103 
1104     // Creates a new empty temporary file in the same directory as the
1105     // specified file.  A variant of Files.createTempFile.
<span class="line-modified">1106     private Path createTempFileInSameDirectoryAs(Path path)</span>
<span class="line-removed">1107         throws IOException</span>
<span class="line-removed">1108     {</span>
1109         Path parent = path.toAbsolutePath().getParent();
1110         Path dir = (parent == null) ? path.getFileSystem().getPath(&quot;.&quot;) : parent;
1111         Path tmpPath = Files.createTempFile(dir, &quot;zipfstmp&quot;, null);
1112         tmppaths.add(tmpPath);
1113         return tmpPath;
1114     }
1115 
1116     ////////////////////update &amp; sync //////////////////////////////////////
1117 
1118     private boolean hasUpdate = false;
1119 
1120     // shared key. consumer guarantees the &quot;writeLock&quot; before use it.
1121     private final IndexNode LOOKUPKEY = new IndexNode(null, -1);
1122 
1123     private void updateDelete(IndexNode inode) {
1124         beginWrite();
1125         try {
1126             removeFromTree(inode);
1127             inodes.remove(inode);
1128             hasUpdate = true;
</pre>
<hr />
<pre>
1185             os.write(buf, 0, LOCHDR);    // write out the loc header
1186             locoff += LOCHDR;
1187             // use e.csize,  LOCSIZ(buf) is zero if FLAG_DATADESCR is on
1188             // size += LOCNAM(buf) + LOCEXT(buf) + LOCSIZ(buf);
1189             size += LOCNAM(buf) + LOCEXT(buf) + e.csize;
1190             written = LOCHDR + size;
1191         }
1192         int n;
1193         while (size &gt; 0 &amp;&amp;
1194             (n = (int)readFullyAt(buf, 0, buf.length, locoff)) != -1)
1195         {
1196             if (size &lt; n)
1197                 n = (int)size;
1198             os.write(buf, 0, n);
1199             size -= n;
1200             locoff += n;
1201         }
1202         return written;
1203     }
1204 
<span class="line-modified">1205     private long writeEntry(Entry e, OutputStream os, byte[] buf)</span>
1206         throws IOException {
1207 
1208         if (e.bytes == null &amp;&amp; e.file == null)    // dir, 0-length data
1209             return 0;
1210 
1211         long written = 0;
<span class="line-modified">1212         try (OutputStream os2 = e.method == METHOD_STORED ?</span>
<span class="line-modified">1213             new EntryOutputStreamCRC32(e, os) : new EntryOutputStreamDef(e, os)) {</span>
<span class="line-modified">1214             if (e.bytes != null) {                 // in-memory</span>
<span class="line-modified">1215                 os2.write(e.bytes, 0, e.bytes.length);</span>
<span class="line-modified">1216             } else if (e.file != null) {           // tmp file</span>
<span class="line-modified">1217                 if (e.type == Entry.NEW || e.type == Entry.FILECH) {</span>
<span class="line-modified">1218                     try (InputStream is = Files.newInputStream(e.file)) {</span>
<span class="line-removed">1219                         is.transferTo(os2);</span>
<span class="line-removed">1220                     }</span>
<span class="line-removed">1221                 }</span>
<span class="line-removed">1222                 Files.delete(e.file);</span>
<span class="line-removed">1223                 tmppaths.remove(e.file);</span>
1224             }
1225         }
1226         written += e.csize;
1227         if ((e.flag &amp; FLAG_DATADESCR) != 0) {
1228             written += e.writeEXT(os);
1229         }
1230         return written;
1231     }
1232 
<span class="line-modified">1233     // sync the zip file system, if there is any udpate</span>
<span class="line-modified">1234     private void sync() throws IOException {</span>











1235 










1236         if (!hasUpdate)
1237             return;

1238         Path tmpFile = createTempFileInSameDirectoryAs(zfpath);
<span class="line-modified">1239         try (OutputStream os = new BufferedOutputStream(Files.newOutputStream(tmpFile, WRITE)))</span>
<span class="line-removed">1240         {</span>
1241             ArrayList&lt;Entry&gt; elist = new ArrayList&lt;&gt;(inodes.size());
1242             long written = 0;
<span class="line-modified">1243             byte[] buf = new byte[8192];</span>
<span class="line-modified">1244             Entry e = null;</span>
1245 
1246             // write loc
1247             for (IndexNode inode : inodes.values()) {
1248                 if (inode instanceof Entry) {    // an updated inode
1249                     e = (Entry)inode;
1250                     try {
1251                         if (e.type == Entry.COPY) {
1252                             // entry copy: the only thing changed is the &quot;name&quot;
<span class="line-modified">1253                             // and &quot;nlen&quot; in LOC header, so we udpate/rewrite the</span>
1254                             // LOC in new file and simply copy the rest (data and
1255                             // ext) without enflating/deflating from the old zip
1256                             // file LOC entry.


1257                             written += copyLOCEntry(e, true, os, written, buf);
1258                         } else {                          // NEW, FILECH or CEN
1259                             e.locoff = written;
1260                             written += e.writeLOC(os);    // write loc header
<span class="line-modified">1261                             written += writeEntry(e, os, buf);</span>
1262                         }
1263                         elist.add(e);
1264                     } catch (IOException x) {
1265                         x.printStackTrace();    // skip any in-accurate entry
1266                     }
1267                 } else {                        // unchanged inode
1268                     if (inode.pos == -1) {
1269                         continue;               // pseudo directory node
1270                     }
1271                     if (inode.name.length == 1 &amp;&amp; inode.name[0] == &#39;/&#39;) {
<span class="line-modified">1272                         continue;               // no root &#39;/&#39; directory even it</span>
<span class="line-modified">1273                                                 // exits in original zip/jar file.</span>
1274                     }
<span class="line-modified">1275                     e = Entry.readCEN(this, inode);</span>
1276                     try {


1277                         written += copyLOCEntry(e, false, os, written, buf);
1278                         elist.add(e);
1279                     } catch (IOException x) {
1280                         x.printStackTrace();    // skip any wrong entry
1281                     }
1282                 }
1283             }
1284 
1285             // now write back the cen and end table
1286             end.cenoff = written;
1287             for (Entry entry : elist) {
1288                 written += entry.writeCEN(os);
1289             }
1290             end.centot = elist.size();
1291             end.cenlen = written - end.cenoff;
1292             end.write(os, written, forceEnd64);
1293         }
















1294 
<span class="line-modified">1295         ch.close();</span>
<span class="line-modified">1296         Files.delete(zfpath);</span>



1297         Files.move(tmpFile, zfpath, REPLACE_EXISTING);
1298         hasUpdate = false;    // clear
1299     }
1300 
<span class="line-modified">1301     IndexNode getInode(byte[] path) {</span>
<span class="line-modified">1302         if (path == null)</span>
<span class="line-modified">1303             throw new NullPointerException(&quot;path&quot;);</span>
<span class="line-modified">1304         return inodes.get(IndexNode.keyOf(path));</span>











































1305     }
1306 
<span class="line-modified">1307     Entry getEntry(byte[] path) throws IOException {</span>
1308         IndexNode inode = getInode(path);
1309         if (inode instanceof Entry)
1310             return (Entry)inode;
1311         if (inode == null || inode.pos == -1)
1312             return null;
<span class="line-modified">1313         return Entry.readCEN(this, inode);</span>
1314     }
1315 
1316     public void deleteFile(byte[] path, boolean failIfNotExists)
1317         throws IOException
1318     {
1319         checkWritable();
<span class="line-removed">1320 </span>
1321         IndexNode inode = getInode(path);
1322         if (inode == null) {
1323             if (path != null &amp;&amp; path.length == 0)
1324                 throw new ZipException(&quot;root directory &lt;/&gt; can&#39;t not be delete&quot;);
1325             if (failIfNotExists)
1326                 throw new NoSuchFileException(getString(path));
1327         } else {
1328             if (inode.isDir() &amp;&amp; inode.child != null)
1329                 throw new DirectoryNotEmptyException(getString(path));
1330             updateDelete(inode);
1331         }
1332     }
1333 
1334     // Returns an out stream for either
<span class="line-modified">1335     // (1) writing the contents of a new entry, if the entry exits, or</span>
1336     // (2) updating/replacing the contents of the specified existing entry.
1337     private OutputStream getOutputStream(Entry e) throws IOException {
<span class="line-removed">1338 </span>
1339         if (e.mtime == -1)
1340             e.mtime = System.currentTimeMillis();
1341         if (e.method == -1)
<span class="line-modified">1342             e.method = defaultMethod;</span>
1343         // store size, compressed size, and crc-32 in datadescr
1344         e.flag = FLAG_DATADESCR;
1345         if (zc.isUTF8())
1346             e.flag |= FLAG_USE_UTF8;
1347         OutputStream os;
1348         if (useTempFile) {
1349             e.file = getTempPathForEntry(null);
1350             os = Files.newOutputStream(e.file, WRITE);
1351         } else {
1352             os = new ByteArrayOutputStream((e.size &gt; 0)? (int)e.size : 8192);
1353         }
<span class="line-modified">1354         return new EntryOutputStream(e, os);</span>




1355     }
1356 
1357     private class EntryOutputStream extends FilterOutputStream {
<span class="line-modified">1358         private Entry e;</span>
1359         private long written;
1360         private boolean isClosed;
1361 
<span class="line-modified">1362         EntryOutputStream(Entry e, OutputStream os) throws IOException {</span>
1363             super(os);
1364             this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
1365             // this.written = 0;
1366         }
1367 
1368         @Override
1369         public synchronized void write(int b) throws IOException {
1370             out.write(b);
1371             written += 1;
1372         }
1373 
1374         @Override
<span class="line-modified">1375         public synchronized void write(byte b[], int off, int len)</span>
1376                 throws IOException {
1377             out.write(b, off, len);
1378             written += len;
1379         }
1380 
1381         @Override
1382         public synchronized void close() throws IOException {
1383             if (isClosed) {
1384                 return;
1385             }
1386             isClosed = true;
1387             e.size = written;
1388             if (out instanceof ByteArrayOutputStream)
1389                 e.bytes = ((ByteArrayOutputStream)out).toByteArray();
1390             super.close();
1391             update(e);
1392         }
1393     }
1394 





































1395     // Wrapper output stream class to write out a &quot;stored&quot; entry.
1396     // (1) this class does not close the underlying out stream when
1397     //     being closed.
1398     // (2) no need to be &quot;synchronized&quot;, only used by sync()
1399     private class EntryOutputStreamCRC32 extends FilterOutputStream {
<span class="line-modified">1400         private Entry e;</span>
<span class="line-modified">1401         private CRC32 crc;</span>
1402         private long written;
1403         private boolean isClosed;
1404 
<span class="line-modified">1405         EntryOutputStreamCRC32(Entry e, OutputStream os) throws IOException {</span>
1406             super(os);
1407             this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
1408             this.crc = new CRC32();
1409         }
1410 
1411         @Override
1412         public void write(int b) throws IOException {
1413             out.write(b);
1414             crc.update(b);
1415             written += 1;
1416         }
1417 
1418         @Override
<span class="line-modified">1419         public void write(byte b[], int off, int len)</span>
1420                 throws IOException {
1421             out.write(b, off, len);
1422             crc.update(b, off, len);
1423             written += len;
1424         }
1425 
1426         @Override
<span class="line-modified">1427         public void close() throws IOException {</span>
1428             if (isClosed)
1429                 return;
1430             isClosed = true;
1431             e.size = e.csize = written;
1432             e.crc = crc.getValue();
1433         }
1434     }
1435 
1436     // Wrapper output stream class to write out a &quot;deflated&quot; entry.
1437     // (1) this class does not close the underlying out stream when
1438     //     being closed.
1439     // (2) no need to be &quot;synchronized&quot;, only used by sync()
1440     private class EntryOutputStreamDef extends DeflaterOutputStream {
<span class="line-modified">1441         private CRC32 crc;</span>
<span class="line-modified">1442         private Entry e;</span>
1443         private boolean isClosed;
1444 
<span class="line-modified">1445         EntryOutputStreamDef(Entry e, OutputStream os) throws IOException {</span>
1446             super(os, getDeflater());
<span class="line-modified">1447             this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);</span>
1448             this.crc = new CRC32();
1449         }
1450 
1451         @Override
<span class="line-modified">1452         public void write(byte b[], int off, int len)</span>
<span class="line-removed">1453                 throws IOException {</span>
1454             super.write(b, off, len);
1455             crc.update(b, off, len);
1456         }
1457 
1458         @Override
1459         public void close() throws IOException {
1460             if (isClosed)
1461                 return;
1462             isClosed = true;
1463             finish();
<span class="line-modified">1464             e.size  = def.getBytesRead();</span>
1465             e.csize = def.getBytesWritten();
1466             e.crc = crc.getValue();
1467             releaseDeflater(def);
1468         }
1469     }
1470 
1471     private InputStream getInputStream(Entry e)
1472         throws IOException
1473     {
<span class="line-modified">1474         InputStream eis = null;</span>
<span class="line-removed">1475 </span>
1476         if (e.type == Entry.NEW) {
<span class="line-removed">1477             // now bytes &amp; file is uncompressed.</span>
1478             if (e.bytes != null)
<span class="line-modified">1479                 return new ByteArrayInputStream(e.bytes);</span>
1480             else if (e.file != null)
<span class="line-modified">1481                 return Files.newInputStream(e.file);</span>
1482             else
1483                 throw new ZipException(&quot;update entry data is missing&quot;);
1484         } else if (e.type == Entry.FILECH) {
1485             // FILECH result is un-compressed.
1486             eis = Files.newInputStream(e.file);
1487             // TBD: wrap to hook close()
1488             // streams.add(eis);
1489             return eis;
1490         } else {  // untouched CEN or COPY
1491             eis = new EntryInputStream(e, ch);
1492         }
1493         if (e.method == METHOD_DEFLATED) {
1494             // MORE: Compute good size for inflater stream:
1495             long bufSize = e.size + 2; // Inflater likes a bit of slack
1496             if (bufSize &gt; 65536)
1497                 bufSize = 8192;
1498             final long size = e.size;
1499             eis = new InflaterInputStream(eis, getInflater(), (int)bufSize) {
1500                 private boolean isClosed = false;
1501                 public void close() throws IOException {
</pre>
<hr />
<pre>
1508                 }
1509                 // Override fill() method to provide an extra &quot;dummy&quot; byte
1510                 // at the end of the input stream. This is required when
1511                 // using the &quot;nowrap&quot; Inflater option. (it appears the new
1512                 // zlib in 7 does not need it, but keep it for now)
1513                 protected void fill() throws IOException {
1514                     if (eof) {
1515                         throw new EOFException(
1516                             &quot;Unexpected end of ZLIB input stream&quot;);
1517                     }
1518                     len = this.in.read(buf, 0, buf.length);
1519                     if (len == -1) {
1520                         buf[0] = 0;
1521                         len = 1;
1522                         eof = true;
1523                     }
1524                     inf.setInput(buf, 0, len);
1525                 }
1526                 private boolean eof;
1527 
<span class="line-modified">1528                 public int available() throws IOException {</span>
1529                     if (isClosed)
1530                         return 0;
1531                     long avail = size - inf.getBytesWritten();
1532                     return avail &gt; (long) Integer.MAX_VALUE ?
1533                         Integer.MAX_VALUE : (int) avail;
1534                 }
1535             };
1536         } else if (e.method == METHOD_STORED) {
1537             // TBD: wrap/ it does not seem necessary
1538         } else {
1539             throw new ZipException(&quot;invalid compression method&quot;);
1540         }
1541         streams.add(eis);
1542         return eis;
1543     }
1544 
1545     // Inner class implementing the input stream used to read
1546     // a (possibly compressed) zip file entry.
1547     private class EntryInputStream extends InputStream {
1548         private final SeekableByteChannel zfch; // local ref to zipfs&#39;s &quot;ch&quot;. zipfs.ch might
<span class="line-modified">1549                                           // point to a new channel after sync()</span>
<span class="line-modified">1550         private   long pos;               // current position within entry data</span>
<span class="line-modified">1551         protected long rem;               // number of remaining bytes within entry</span>
1552 
1553         EntryInputStream(Entry e, SeekableByteChannel zfch)
1554             throws IOException
1555         {
1556             this.zfch = zfch;
1557             rem = e.csize;
1558             pos = e.locoff;
1559             if (pos == -1) {
1560                 Entry e2 = getEntry(e.name);
1561                 if (e2 == null) {
<span class="line-modified">1562                     throw new ZipException(&quot;invalid loc for entry &lt;&quot; + e.name + &quot;&gt;&quot;);</span>
1563                 }
1564                 pos = e2.locoff;
1565             }
1566             pos = -pos;  // lazy initialize the real data offset
1567         }
1568 
<span class="line-modified">1569         public int read(byte b[], int off, int len) throws IOException {</span>
1570             ensureOpen();
1571             initDataPos();
1572             if (rem == 0) {
1573                 return -1;
1574             }
1575             if (len &lt;= 0) {
1576                 return 0;
1577             }
1578             if (len &gt; rem) {
1579                 len = (int) rem;
1580             }
1581             // readFullyAt()
<span class="line-modified">1582             long n = 0;</span>
1583             ByteBuffer bb = ByteBuffer.wrap(b);
1584             bb.position(off);
1585             bb.limit(off + len);
1586             synchronized(zfch) {
1587                 n = zfch.position(pos).read(bb);
1588             }
1589             if (n &gt; 0) {
1590                 pos += n;
1591                 rem -= n;
1592             }
1593             if (rem == 0) {
1594                 close();
1595             }
1596             return (int)n;
1597         }
1598 
1599         public int read() throws IOException {
1600             byte[] b = new byte[1];
1601             if (read(b, 0, 1) == 1) {
1602                 return b[0] &amp; 0xff;
1603             } else {
1604                 return -1;
1605             }
1606         }
1607 
<span class="line-modified">1608         public long skip(long n) throws IOException {</span>
1609             ensureOpen();
1610             if (n &gt; rem)
1611                 n = rem;
1612             pos += n;
1613             rem -= n;
1614             if (rem == 0) {
1615                 close();
1616             }
1617             return n;
1618         }
1619 
1620         public int available() {
1621             return rem &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;
1622         }
1623 
1624         public void close() {
1625             rem = 0;
1626             streams.remove(this);
1627         }
1628 
1629         private void initDataPos() throws IOException {
1630             if (pos &lt;= 0) {
1631                 pos = -pos + locpos;
1632                 byte[] buf = new byte[LOCHDR];
1633                 if (readFullyAt(buf, 0, buf.length, pos) != LOCHDR) {
1634                     throw new ZipException(&quot;invalid loc &quot; + pos + &quot; for entry reading&quot;);
1635                 }
1636                 pos += LOCHDR + LOCNAM(buf) + LOCEXT(buf);
1637             }
1638         }
1639     }
1640 
<span class="line-removed">1641     static void zerror(String msg) throws ZipException {</span>
<span class="line-removed">1642         throw new ZipException(msg);</span>
<span class="line-removed">1643     }</span>
<span class="line-removed">1644 </span>
1645     // Maxmum number of de/inflater we cache
1646     private final int MAX_FLATER = 20;
1647     // List of available Inflater objects for decompression
1648     private final List&lt;Inflater&gt; inflaters = new ArrayList&lt;&gt;();
1649 
1650     // Gets an inflater from the list of available inflaters or allocates
1651     // a new one.
1652     private Inflater getInflater() {
1653         synchronized (inflaters) {
1654             int size = inflaters.size();
1655             if (size &gt; 0) {
<span class="line-modified">1656                 Inflater inf = inflaters.remove(size - 1);</span>
<span class="line-removed">1657                 return inf;</span>
1658             } else {
1659                 return new Inflater(true);
1660             }
1661         }
1662     }
1663 
1664     // Releases the specified inflater to the list of available inflaters.
1665     private void releaseInflater(Inflater inf) {
1666         synchronized (inflaters) {
1667             if (inflaters.size() &lt; MAX_FLATER) {
1668                 inf.reset();
1669                 inflaters.add(inf);
1670             } else {
1671                 inf.end();
1672             }
1673         }
1674     }
1675 
1676     // List of available Deflater objects for compression
1677     private final List&lt;Deflater&gt; deflaters = new ArrayList&lt;&gt;();
1678 
1679     // Gets a deflater from the list of available deflaters or allocates
1680     // a new one.
1681     private Deflater getDeflater() {
1682         synchronized (deflaters) {
1683             int size = deflaters.size();
1684             if (size &gt; 0) {
<span class="line-modified">1685                 Deflater def = deflaters.remove(size - 1);</span>
<span class="line-removed">1686                 return def;</span>
1687             } else {
1688                 return new Deflater(Deflater.DEFAULT_COMPRESSION, true);
1689             }
1690         }
1691     }
1692 
1693     // Releases the specified inflater to the list of available inflaters.
1694     private void releaseDeflater(Deflater def) {
1695         synchronized (deflaters) {
<span class="line-modified">1696             if (inflaters.size() &lt; MAX_FLATER) {</span>
1697                def.reset();
1698                deflaters.add(def);
1699             } else {
1700                def.end();
1701             }
1702         }
1703     }
1704 
1705     // End of central directory record
1706     static class END {
<span class="line-modified">1707         // these 2 fields are not used by anyone and write() uses &quot;0&quot;</span>
1708         // int  disknum;
1709         // int  sdisknum;
<span class="line-modified">1710         int  endsub;     // endsub</span>
<span class="line-modified">1711         int  centot;     // 4 bytes</span>
<span class="line-modified">1712         long cenlen;     // 4 bytes</span>
<span class="line-modified">1713         long cenoff;     // 4 bytes</span>
<span class="line-modified">1714         int  comlen;     // comment length</span>
<span class="line-modified">1715         byte[] comment;</span>
<span class="line-modified">1716 </span>
<span class="line-modified">1717         /* members of Zip64 end of central directory locator */</span>
1718         // int diskNum;
1719         long endpos;
1720         // int disktot;
1721 
1722         void write(OutputStream os, long offset, boolean forceEnd64) throws IOException {
1723             boolean hasZip64 = forceEnd64; // false;
1724             long xlen = cenlen;
1725             long xoff = cenoff;
1726             if (xlen &gt;= ZIP64_MINVAL) {
1727                 xlen = ZIP64_MINVAL;
1728                 hasZip64 = true;
1729             }
1730             if (xoff &gt;= ZIP64_MINVAL) {
1731                 xoff = ZIP64_MINVAL;
1732                 hasZip64 = true;
1733             }
1734             int count = centot;
1735             if (count &gt;= ZIP64_MINVAL32) {
1736                 count = ZIP64_MINVAL32;
1737                 hasZip64 = true;
1738             }
1739             if (hasZip64) {
<span class="line-removed">1740                 long off64 = offset;</span>
1741                 //zip64 end of central directory record
1742                 writeInt(os, ZIP64_ENDSIG);       // zip64 END record signature
1743                 writeLong(os, ZIP64_ENDHDR - 12); // size of zip64 end
1744                 writeShort(os, 45);               // version made by
1745                 writeShort(os, 45);               // version needed to extract
1746                 writeInt(os, 0);                  // number of this disk
1747                 writeInt(os, 0);                  // central directory start disk
1748                 writeLong(os, centot);            // number of directory entries on disk
1749                 writeLong(os, centot);            // number of directory entries
1750                 writeLong(os, cenlen);            // length of central directory
1751                 writeLong(os, cenoff);            // offset of central directory
1752 
1753                 //zip64 end of central directory locator
1754                 writeInt(os, ZIP64_LOCSIG);       // zip64 END locator signature
1755                 writeInt(os, 0);                  // zip64 END start disk
<span class="line-modified">1756                 writeLong(os, off64);             // offset of zip64 END</span>
1757                 writeInt(os, 1);                  // total number of disks (?)
1758             }
1759             writeInt(os, ENDSIG);                 // END record signature
1760             writeShort(os, 0);                    // number of this disk
1761             writeShort(os, 0);                    // central directory start disk
1762             writeShort(os, count);                // number of directory entries on disk
1763             writeShort(os, count);                // total number of directory entries
1764             writeInt(os, xlen);                   // length of central directory
1765             writeInt(os, xoff);                   // offset of central directory
<span class="line-modified">1766             if (comment != null) {            // zip file comment</span>
<span class="line-removed">1767                 writeShort(os, comment.length);</span>
<span class="line-removed">1768                 writeBytes(os, comment);</span>
<span class="line-removed">1769             } else {</span>
<span class="line-removed">1770                 writeShort(os, 0);</span>
<span class="line-removed">1771             }</span>
1772         }
1773     }
1774 
1775     // Internal node that links a &quot;name&quot; to its pos in cen table.
1776     // The node itself can be used as a &quot;key&quot; to lookup itself in
1777     // the HashMap inodes.
1778     static class IndexNode {
<span class="line-modified">1779         byte[] name;</span>
<span class="line-modified">1780         int    hashcode;  // node is hashable/hashed by its name</span>
<span class="line-removed">1781         int    pos = -1;  // position in cen table, -1 menas the</span>
<span class="line-removed">1782                           // entry does not exists in zip file</span>
1783         boolean isdir;






1784 
1785         IndexNode(byte[] name, boolean isdir) {
1786             name(name);
1787             this.isdir = isdir;
1788             this.pos = -1;
1789         }
1790 
1791         IndexNode(byte[] name, int pos) {
1792             name(name);
1793             this.pos = pos;
1794         }
1795 
<span class="line-modified">1796         // constructor for cenInit() (1) remove tailing &#39;/&#39; (2) pad leading &#39;/&#39;</span>
1797         IndexNode(byte[] cen, int pos, int nlen) {
1798             int noff = pos + CENHDR;
1799             if (cen[noff + nlen - 1] == &#39;/&#39;) {
1800                 isdir = true;
1801                 nlen--;
1802             }
1803             if (nlen &gt; 0 &amp;&amp; cen[noff] == &#39;/&#39;) {
1804                 name = Arrays.copyOfRange(cen, noff, noff + nlen);
1805             } else {
1806                 name = new byte[nlen + 1];
1807                 System.arraycopy(cen, noff, name, 1, nlen);
1808                 name[0] = &#39;/&#39;;
1809             }
<span class="line-modified">1810             name(name);</span>
1811             this.pos = pos;
1812         }
1813 









































1814         private static final ThreadLocal&lt;IndexNode&gt; cachedKey = new ThreadLocal&lt;&gt;();
1815 
<span class="line-modified">1816         final static IndexNode keyOf(byte[] name) { // get a lookup key;</span>
1817             IndexNode key = cachedKey.get();
1818             if (key == null) {
1819                 key = new IndexNode(name, -1);
1820                 cachedKey.set(key);
1821             }
1822             return key.as(name);
1823         }
1824 
1825         final void name(byte[] name) {
1826             this.name = name;
1827             this.hashcode = Arrays.hashCode(name);
1828         }
1829 
1830         final IndexNode as(byte[] name) {           // reuse the node, mostly
1831             name(name);                             // as a lookup &quot;key&quot;
1832             return this;
1833         }
1834 
1835         boolean isDir() {
1836             return isdir;
1837         }
1838 

1839         public boolean equals(Object other) {
1840             if (!(other instanceof IndexNode)) {
1841                 return false;
1842             }
1843             if (other instanceof ParentLookup) {
1844                 return ((ParentLookup)other).equals(this);
1845             }
1846             return Arrays.equals(name, ((IndexNode)other).name);
1847         }
1848 

1849         public int hashCode() {
1850             return hashcode;
1851         }
1852 
<span class="line-modified">1853         IndexNode() {}</span>
<span class="line-modified">1854         IndexNode sibling;</span>
<span class="line-modified">1855         IndexNode child;  // 1st child</span>

1856     }
1857 
1858     static class Entry extends IndexNode implements ZipFileAttributes {
<span class="line-removed">1859 </span>
1860         static final int CEN    = 1;  // entry read from cen
1861         static final int NEW    = 2;  // updated contents in bytes or file
1862         static final int FILECH = 3;  // fch update in &quot;file&quot;
1863         static final int COPY   = 4;  // copy of a CEN entry
1864 
1865         byte[] bytes;                 // updated content bytes
1866         Path   file;                  // use tmp file to store bytes;
1867         int    type = CEN;            // default is the entry read from cen
1868 
1869         // entry attributes
1870         int    version;
1871         int    flag;

1872         int    method = -1;    // compression method
1873         long   mtime  = -1;    // last modification time (in DOS time)
1874         long   atime  = -1;    // last access time
1875         long   ctime  = -1;    // create time
1876         long   crc    = -1;    // crc-32 of entry data
1877         long   csize  = -1;    // compressed size of entry data
1878         long   size   = -1;    // uncompressed size of entry data
1879         byte[] extra;
1880 
<span class="line-modified">1881         // cen</span>
<span class="line-modified">1882 </span>
<span class="line-removed">1883         // these fields are not used by anyone and writeCEN uses &quot;0&quot;</span>
1884         // int    versionMade;
1885         // int    disk;
1886         // int    attrs;
1887         // long   attrsEx;
1888         long   locoff;
1889         byte[] comment;
1890 
<span class="line-removed">1891         Entry() {}</span>
<span class="line-removed">1892 </span>
1893         Entry(byte[] name, boolean isdir, int method) {
1894             name(name);
1895             this.isdir = isdir;
1896             this.mtime  = this.ctime = this.atime = System.currentTimeMillis();
1897             this.crc    = 0;
1898             this.size   = 0;
1899             this.csize  = 0;
1900             this.method = method;
1901         }
1902 
<span class="line-modified">1903         Entry(byte[] name, int type, boolean isdir, int method) {</span>

1904             this(name, isdir, method);
1905             this.type = type;
















1906         }
1907 
<span class="line-modified">1908         Entry (Entry e, int type) {</span>
1909             name(e.name);
1910             this.isdir     = e.isdir;
1911             this.version   = e.version;
1912             this.ctime     = e.ctime;
1913             this.atime     = e.atime;
1914             this.mtime     = e.mtime;
1915             this.crc       = e.crc;
1916             this.size      = e.size;
1917             this.csize     = e.csize;
1918             this.method    = e.method;
1919             this.extra     = e.extra;
1920             /*
1921             this.versionMade = e.versionMade;
1922             this.disk      = e.disk;
1923             this.attrs     = e.attrs;
1924             this.attrsEx   = e.attrsEx;
1925             */
1926             this.locoff    = e.locoff;
1927             this.comment   = e.comment;

1928             this.type      = type;
1929         }
1930 
<span class="line-modified">1931         Entry (byte[] name, Path file, int type) {</span>
<span class="line-modified">1932             this(name, type, false, METHOD_STORED);</span>
<span class="line-removed">1933             this.file = file;</span>
1934         }
1935 
<span class="line-modified">1936         int version() throws ZipException {</span>









1937             if (method == METHOD_DEFLATED)
1938                 return 20;
1939             else if (method == METHOD_STORED)
1940                 return 10;
1941             throw new ZipException(&quot;unsupported compression method&quot;);
1942         }
1943 
<span class="line-modified">1944         ///////////////////// CEN //////////////////////</span>
<span class="line-modified">1945         static Entry readCEN(ZipFileSystem zipfs, IndexNode inode)</span>
<span class="line-modified">1946             throws IOException</span>
<span class="line-modified">1947         {</span>
<span class="line-modified">1948             return new Entry().cen(zipfs, inode);</span>


1949         }
1950 
<span class="line-modified">1951         private Entry cen(ZipFileSystem zipfs, IndexNode inode)</span>
<span class="line-modified">1952             throws IOException</span>
<span class="line-removed">1953         {</span>
1954             byte[] cen = zipfs.cen;
1955             int pos = inode.pos;
1956             if (!cenSigAt(cen, pos))
<span class="line-modified">1957                 zerror(&quot;invalid CEN header (bad signature)&quot;);</span>
1958             version     = CENVER(cen, pos);
1959             flag        = CENFLG(cen, pos);
1960             method      = CENHOW(cen, pos);
1961             mtime       = dosToJavaTime(CENTIM(cen, pos));
1962             crc         = CENCRC(cen, pos);
1963             csize       = CENSIZ(cen, pos);
1964             size        = CENLEN(cen, pos);
1965             int nlen    = CENNAM(cen, pos);
1966             int elen    = CENEXT(cen, pos);
1967             int clen    = CENCOM(cen, pos);
1968             /*
1969             versionMade = CENVEM(cen, pos);
1970             disk        = CENDSK(cen, pos);
1971             attrs       = CENATT(cen, pos);
1972             attrsEx     = CENATX(cen, pos);
1973             */



1974             locoff      = CENOFF(cen, pos);
1975             pos += CENHDR;
1976             this.name = inode.name;
1977             this.isdir = inode.isdir;
1978             this.hashcode = inode.hashcode;
1979 
1980             pos += nlen;
1981             if (elen &gt; 0) {
1982                 extra = Arrays.copyOfRange(cen, pos, pos + elen);
1983                 pos += elen;
1984                 readExtra(zipfs);
1985             }
1986             if (clen &gt; 0) {
1987                 comment = Arrays.copyOfRange(cen, pos, pos + clen);
1988             }
<span class="line-removed">1989             return this;</span>
1990         }
1991 
<span class="line-modified">1992         int writeCEN(OutputStream os) throws IOException {</span>
<span class="line-removed">1993             int version0 = version();</span>
1994             long csize0  = csize;
1995             long size0   = size;
1996             long locoff0 = locoff;
1997             int elen64   = 0;                // extra for ZIP64
1998             int elenNTFS = 0;                // extra for NTFS (a/c/mtime)
1999             int elenEXTT = 0;                // extra for Extended Timestamp
2000             boolean foundExtraTime = false;  // if time stamp NTFS, EXTT present
2001 
2002             byte[] zname = isdir ? toDirectoryPath(name) : name;
2003 
2004             // confirm size/length
2005             int nlen = (zname != null) ? zname.length - 1 : 0;  // name has [0] as &quot;slash&quot;
2006             int elen = (extra != null) ? extra.length : 0;
2007             int eoff = 0;
2008             int clen = (comment != null) ? comment.length : 0;
2009             if (csize &gt;= ZIP64_MINVAL) {
2010                 csize0 = ZIP64_MINVAL;
2011                 elen64 += 8;                 // csize(8)
2012             }
2013             if (size &gt;= ZIP64_MINVAL) {
2014                 size0 = ZIP64_MINVAL;        // size(8)
2015                 elen64 += 8;
2016             }
2017             if (locoff &gt;= ZIP64_MINVAL) {
2018                 locoff0 = ZIP64_MINVAL;
2019                 elen64 += 8;                 // offset(8)
2020             }
2021             if (elen64 != 0) {
2022                 elen64 += 4;                 // header and data sz 4 bytes
2023             }


2024             while (eoff + 4 &lt; elen) {
2025                 int tag = SH(extra, eoff);
2026                 int sz = SH(extra, eoff + 2);
2027                 if (tag == EXTID_EXTT || tag == EXTID_NTFS) {
2028                     foundExtraTime = true;
2029                 }
2030                 eoff += (4 + sz);
2031             }
2032             if (!foundExtraTime) {
2033                 if (isWindows) {             // use NTFS
2034                     elenNTFS = 36;           // total 36 bytes
2035                 } else {                     // Extended Timestamp otherwise
2036                     elenEXTT = 9;            // only mtime in cen
2037                 }
2038             }
2039             writeInt(os, CENSIG);            // CEN header signature
<span class="line-modified">2040             if (elen64 != 0) {</span>
<span class="line-modified">2041                 writeShort(os, 45);          // ver 4.5 for zip64</span>
<span class="line-removed">2042                 writeShort(os, 45);</span>
<span class="line-removed">2043             } else {</span>
<span class="line-removed">2044                 writeShort(os, version0);    // version made by</span>
<span class="line-removed">2045                 writeShort(os, version0);    // version needed to extract</span>
<span class="line-removed">2046             }</span>
2047             writeShort(os, flag);            // general purpose bit flag
2048             writeShort(os, method);          // compression method
2049                                              // last modification time
2050             writeInt(os, (int)javaToDosTime(mtime));
2051             writeInt(os, crc);               // crc-32
2052             writeInt(os, csize0);            // compressed size
2053             writeInt(os, size0);             // uncompressed size
2054             writeShort(os, nlen);
2055             writeShort(os, elen + elen64 + elenNTFS + elenEXTT);
2056 
2057             if (comment != null) {
2058                 writeShort(os, Math.min(clen, 0xffff));
2059             } else {
2060                 writeShort(os, 0);
2061             }
2062             writeShort(os, 0);              // starting disk number
2063             writeShort(os, 0);              // internal file attributes (unused)
<span class="line-modified">2064             writeInt(os, 0);                // external file attributes (unused)</span>


2065             writeInt(os, locoff0);          // relative offset of local header
2066             writeBytes(os, zname, 1, nlen);
<span class="line-modified">2067             if (elen64 != 0) {</span>
2068                 writeShort(os, EXTID_ZIP64);// Zip64 extra
2069                 writeShort(os, elen64 - 4); // size of &quot;this&quot; extra block
2070                 if (size0 == ZIP64_MINVAL)
2071                     writeLong(os, size);
2072                 if (csize0 == ZIP64_MINVAL)
2073                     writeLong(os, csize);
2074                 if (locoff0 == ZIP64_MINVAL)
2075                     writeLong(os, locoff);
2076             }
2077             if (elenNTFS != 0) {
2078                 writeShort(os, EXTID_NTFS);
2079                 writeShort(os, elenNTFS - 4);
2080                 writeInt(os, 0);            // reserved
2081                 writeShort(os, 0x0001);     // NTFS attr tag
2082                 writeShort(os, 24);
2083                 writeLong(os, javaToWinTime(mtime));
2084                 writeLong(os, javaToWinTime(atime));
2085                 writeLong(os, javaToWinTime(ctime));
2086             }
2087             if (elenEXTT != 0) {
2088                 writeShort(os, EXTID_EXTT);
2089                 writeShort(os, elenEXTT - 4);
2090                 if (ctime == -1)
2091                     os.write(0x3);          // mtime and atime
2092                 else
2093                     os.write(0x7);          // mtime, atime and ctime
2094                 writeInt(os, javaToUnixTime(mtime));
2095             }
2096             if (extra != null)              // whatever not recognized
2097                 writeBytes(os, extra);
2098             if (comment != null)            //TBD: 0, Math.min(commentBytes.length, 0xffff));
2099                 writeBytes(os, comment);
2100             return CENHDR + nlen + elen + clen + elen64 + elenNTFS + elenEXTT;
2101         }
2102 
2103         ///////////////////// LOC //////////////////////
2104 
<span class="line-modified">2105         int writeLOC(OutputStream os) throws IOException {</span>
<span class="line-removed">2106             int version0 = version();</span>
2107             byte[] zname = isdir ? toDirectoryPath(name) : name;
2108             int nlen = (zname != null) ? zname.length - 1 : 0; // [0] is slash
2109             int elen = (extra != null) ? extra.length : 0;
2110             boolean foundExtraTime = false;     // if extra timestamp present
2111             int eoff = 0;
2112             int elen64 = 0;

2113             int elenEXTT = 0;
2114             int elenNTFS = 0;
2115             writeInt(os, LOCSIG);               // LOC header signature
2116             if ((flag &amp; FLAG_DATADESCR) != 0) {
<span class="line-modified">2117                 writeShort(os, version0);       // version needed to extract</span>
2118                 writeShort(os, flag);           // general purpose bit flag
2119                 writeShort(os, method);         // compression method
2120                 // last modification time
2121                 writeInt(os, (int)javaToDosTime(mtime));
2122                 // store size, uncompressed size, and crc-32 in data descriptor
2123                 // immediately following compressed entry data
2124                 writeInt(os, 0);
2125                 writeInt(os, 0);
2126                 writeInt(os, 0);
2127             } else {
2128                 if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
2129                     elen64 = 20;    //headid(2) + size(2) + size(8) + csize(8)
<span class="line-modified">2130                     writeShort(os, 45);         // ver 4.5 for zip64</span>
<span class="line-removed">2131                 } else {</span>
<span class="line-removed">2132                     writeShort(os, version0);   // version needed to extract</span>
2133                 }

2134                 writeShort(os, flag);           // general purpose bit flag
2135                 writeShort(os, method);         // compression method
2136                                                 // last modification time
2137                 writeInt(os, (int)javaToDosTime(mtime));
2138                 writeInt(os, crc);              // crc-32
<span class="line-modified">2139                 if (elen64 != 0) {</span>
2140                     writeInt(os, ZIP64_MINVAL);
2141                     writeInt(os, ZIP64_MINVAL);
2142                 } else {
2143                     writeInt(os, csize);        // compressed size
2144                     writeInt(os, size);         // uncompressed size
2145                 }
2146             }
2147             while (eoff + 4 &lt; elen) {
2148                 int tag = SH(extra, eoff);
2149                 int sz = SH(extra, eoff + 2);
2150                 if (tag == EXTID_EXTT || tag == EXTID_NTFS) {
2151                     foundExtraTime = true;
2152                 }
2153                 eoff += (4 + sz);
2154             }
2155             if (!foundExtraTime) {
2156                 if (isWindows) {
2157                     elenNTFS = 36;              // NTFS, total 36 bytes
2158                 } else {                        // on unix use &quot;ext time&quot;
2159                     elenEXTT = 9;
2160                     if (atime != -1)
2161                         elenEXTT += 4;
2162                     if (ctime != -1)
2163                         elenEXTT += 4;
2164                 }
2165             }
2166             writeShort(os, nlen);
2167             writeShort(os, elen + elen64 + elenNTFS + elenEXTT);
2168             writeBytes(os, zname, 1, nlen);
<span class="line-modified">2169             if (elen64 != 0) {</span>
2170                 writeShort(os, EXTID_ZIP64);
2171                 writeShort(os, 16);
2172                 writeLong(os, size);
2173                 writeLong(os, csize);
2174             }
2175             if (elenNTFS != 0) {
2176                 writeShort(os, EXTID_NTFS);
2177                 writeShort(os, elenNTFS - 4);
2178                 writeInt(os, 0);            // reserved
2179                 writeShort(os, 0x0001);     // NTFS attr tag
2180                 writeShort(os, 24);
2181                 writeLong(os, javaToWinTime(mtime));
2182                 writeLong(os, javaToWinTime(atime));
2183                 writeLong(os, javaToWinTime(ctime));
2184             }
2185             if (elenEXTT != 0) {
2186                 writeShort(os, EXTID_EXTT);
2187                 writeShort(os, elenEXTT - 4);// size for the folowing data block
2188                 int fbyte = 0x1;
2189                 if (atime != -1)           // mtime and atime
2190                     fbyte |= 0x2;
2191                 if (ctime != -1)           // mtime, atime and ctime
2192                     fbyte |= 0x4;
2193                 os.write(fbyte);           // flags byte
2194                 writeInt(os, javaToUnixTime(mtime));
2195                 if (atime != -1)
2196                     writeInt(os, javaToUnixTime(atime));
2197                 if (ctime != -1)
2198                     writeInt(os, javaToUnixTime(ctime));
2199             }
2200             if (extra != null) {
2201                 writeBytes(os, extra);
2202             }
2203             return LOCHDR + nlen + elen + elen64 + elenNTFS + elenEXTT;
2204         }
2205 
<span class="line-modified">2206         // Data Descriptior</span>
<span class="line-modified">2207         int writeEXT(OutputStream os) throws IOException {</span>
2208             writeInt(os, EXTSIG);           // EXT header signature
2209             writeInt(os, crc);              // crc-32
2210             if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
2211                 writeLong(os, csize);
2212                 writeLong(os, size);
2213                 return 24;
2214             } else {
2215                 writeInt(os, csize);        // compressed size
2216                 writeInt(os, size);         // uncompressed size
2217                 return 16;
2218             }
2219         }
2220 
2221         // read NTFS, UNIX and ZIP64 data from cen.extra
<span class="line-modified">2222         void readExtra(ZipFileSystem zipfs) throws IOException {</span>
2223             if (extra == null)
2224                 return;
2225             int elen = extra.length;
2226             int off = 0;
2227             int newOff = 0;
2228             while (off + 4 &lt; elen) {
2229                 // extra spec: HeaderID+DataSize+Data
2230                 int pos = off;
2231                 int tag = SH(extra, pos);
2232                 int sz = SH(extra, pos + 2);
2233                 pos += 4;
2234                 if (pos + sz &gt; elen)         // invalid data
2235                     break;
2236                 switch (tag) {
2237                 case EXTID_ZIP64 :
2238                     if (size == ZIP64_MINVAL) {
2239                         if (pos + 8 &gt; elen)  // invalid zip64 extra
2240                             break;           // fields, just skip
2241                         size = LL(extra, pos);
2242                         pos += 8;
2243                     }
2244                     if (csize == ZIP64_MINVAL) {
2245                         if (pos + 8 &gt; elen)
2246                             break;
2247                         csize = LL(extra, pos);
2248                         pos += 8;
2249                     }
2250                     if (locoff == ZIP64_MINVAL) {
2251                         if (pos + 8 &gt; elen)
2252                             break;
2253                         locoff = LL(extra, pos);
<span class="line-removed">2254                         pos += 8;</span>
2255                     }
2256                     break;
2257                 case EXTID_NTFS:
2258                     if (sz &lt; 32)
2259                         break;
2260                     pos += 4;    // reserved 4 bytes
2261                     if (SH(extra, pos) !=  0x0001)
2262                         break;
2263                     if (SH(extra, pos + 2) != 24)
2264                         break;
2265                     // override the loc field, datatime here is
2266                     // more &quot;accurate&quot;
2267                     mtime  = winToJavaTime(LL(extra, pos + 4));
2268                     atime  = winToJavaTime(LL(extra, pos + 12));
2269                     ctime  = winToJavaTime(LL(extra, pos + 20));
2270                     break;
2271                 case EXTID_EXTT:
2272                     // spec says the Extened timestamp in cen only has mtime
2273                     // need to read the loc to get the extra a/ctime, if flag
2274                     // &quot;zipinfo-time&quot; is not specified to false;
2275                     // there is performance cost (move up to loc and read) to
2276                     // access the loc table foreach entry;
2277                     if (zipfs.noExtt) {
2278                         if (sz == 5)
2279                             mtime = unixToJavaTime(LG(extra, pos + 1));
2280                          break;
2281                     }
2282                     byte[] buf = new byte[LOCHDR];
2283                     if (zipfs.readFullyAt(buf, 0, buf.length , locoff)
2284                         != buf.length)
2285                         throw new ZipException(&quot;loc: reading failed&quot;);
2286                     if (!locSigAt(buf, 0))
2287                         throw new ZipException(&quot;loc: wrong sig -&gt;&quot;
2288                                            + Long.toString(getSig(buf, 0), 16));
2289                     int locElen = LOCEXT(buf);
<span class="line-modified">2290                     if (locElen &lt; 9)    // EXTT is at lease 9 bytes</span>
2291                         break;
2292                     int locNlen = LOCNAM(buf);
2293                     buf = new byte[locElen];
2294                     if (zipfs.readFullyAt(buf, 0, buf.length , locoff + LOCHDR + locNlen)
2295                         != buf.length)
2296                         throw new ZipException(&quot;loc extra: reading failed&quot;);
2297                     int locPos = 0;
2298                     while (locPos + 4 &lt; buf.length) {
2299                         int locTag = SH(buf, locPos);
2300                         int locSZ  = SH(buf, locPos + 2);
2301                         locPos += 4;
2302                         if (locTag  != EXTID_EXTT) {
2303                             locPos += locSZ;
2304                              continue;
2305                         }
2306                         int end = locPos + locSZ - 4;
2307                         int flag = CH(buf, locPos++);
2308                         if ((flag &amp; 0x1) != 0 &amp;&amp; locPos &lt;= end) {
2309                             mtime = unixToJavaTime(LG(buf, locPos));
2310                             locPos += 4;
2311                         }
2312                         if ((flag &amp; 0x2) != 0 &amp;&amp; locPos &lt;= end) {
2313                             atime = unixToJavaTime(LG(buf, locPos));
2314                             locPos += 4;
2315                         }
2316                         if ((flag &amp; 0x4) != 0 &amp;&amp; locPos &lt;= end) {
2317                             ctime = unixToJavaTime(LG(buf, locPos));
<span class="line-removed">2318                             locPos += 4;</span>
2319                         }
2320                         break;
2321                     }
2322                     break;
2323                 default:    // unknown tag
2324                     System.arraycopy(extra, off, extra, newOff, sz + 4);
2325                     newOff += (sz + 4);
2326                 }
2327                 off += (sz + 4);
2328             }
2329             if (newOff != 0 &amp;&amp; newOff != extra.length)
2330                 extra = Arrays.copyOf(extra, newOff);
2331             else
2332                 extra = null;
2333         }
2334 

























2335         ///////// basic file attributes ///////////
2336         @Override
2337         public FileTime creationTime() {
2338             return FileTime.fromMillis(ctime == -1 ? mtime : ctime);
2339         }
2340 
2341         @Override
2342         public boolean isDirectory() {
2343             return isDir();
2344         }
2345 
2346         @Override
2347         public boolean isOther() {
2348             return false;
2349         }
2350 
2351         @Override
2352         public boolean isRegularFile() {
2353             return !isDir();
2354         }
</pre>
<hr />
<pre>
2361         @Override
2362         public FileTime lastModifiedTime() {
2363             return FileTime.fromMillis(mtime);
2364         }
2365 
2366         @Override
2367         public long size() {
2368             return size;
2369         }
2370 
2371         @Override
2372         public boolean isSymbolicLink() {
2373             return false;
2374         }
2375 
2376         @Override
2377         public Object fileKey() {
2378             return null;
2379         }
2380 
<span class="line-modified">2381         ///////// zip entry attributes ///////////</span>


2382         public long compressedSize() {
2383             return csize;
2384         }
2385 

2386         public long crc() {
2387             return crc;
2388         }
2389 

2390         public int method() {
2391             return method;
2392         }
2393 

2394         public byte[] extra() {
2395             if (extra != null)
2396                 return Arrays.copyOf(extra, extra.length);
2397             return null;
2398         }
2399 

2400         public byte[] comment() {
2401             if (comment != null)
2402                 return Arrays.copyOf(comment, comment.length);
2403             return null;
2404         }
2405 
<span class="line-modified">2406         public String toString() {</span>
<span class="line-modified">2407             StringBuilder sb = new StringBuilder(1024);</span>
<span class="line-modified">2408             Formatter fm = new Formatter(sb);</span>
<span class="line-modified">2409             fm.format(&quot;    name            : %s%n&quot;, new String(name));</span>
<span class="line-modified">2410             fm.format(&quot;    creationTime    : %tc%n&quot;, creationTime().toMillis());</span>
<span class="line-modified">2411             fm.format(&quot;    lastAccessTime  : %tc%n&quot;, lastAccessTime().toMillis());</span>
<span class="line-modified">2412             fm.format(&quot;    lastModifiedTime: %tc%n&quot;, lastModifiedTime().toMillis());</span>
<span class="line-modified">2413             fm.format(&quot;    isRegularFile   : %b%n&quot;, isRegularFile());</span>
<span class="line-modified">2414             fm.format(&quot;    isDirectory     : %b%n&quot;, isDirectory());</span>
<span class="line-modified">2415             fm.format(&quot;    isSymbolicLink  : %b%n&quot;, isSymbolicLink());</span>
<span class="line-modified">2416             fm.format(&quot;    isOther         : %b%n&quot;, isOther());</span>
<span class="line-modified">2417             fm.format(&quot;    fileKey         : %s%n&quot;, fileKey());</span>
<span class="line-removed">2418             fm.format(&quot;    size            : %d%n&quot;, size());</span>
<span class="line-removed">2419             fm.format(&quot;    compressedSize  : %d%n&quot;, compressedSize());</span>
<span class="line-removed">2420             fm.format(&quot;    crc             : %x%n&quot;, crc());</span>
<span class="line-removed">2421             fm.format(&quot;    method          : %d%n&quot;, method());</span>
<span class="line-removed">2422             fm.close();</span>
<span class="line-removed">2423             return sb.toString();</span>
2424         }
2425     }
2426 
<span class="line-modified">2427     // ZIP directory has two issues:</span>
<span class="line-modified">2428     // (1) ZIP spec does not require the ZIP file to include</span>
<span class="line-modified">2429     //     directory entry</span>
<span class="line-removed">2430     // (2) all entries are not stored/organized in a &quot;tree&quot;</span>
<span class="line-removed">2431     //     structure.</span>
<span class="line-removed">2432     // A possible solution is to build the node tree ourself as</span>
<span class="line-removed">2433     // implemented below.</span>
2434 
<span class="line-modified">2435     // default time stamp for pseudo entries</span>
<span class="line-modified">2436     private long zfsDefaultTimeStamp = System.currentTimeMillis();</span>

2437 
<span class="line-modified">2438     private void removeFromTree(IndexNode inode) {</span>
<span class="line-modified">2439         IndexNode parent = inodes.get(LOOKUPKEY.as(getParent(inode.name)));</span>
<span class="line-modified">2440         IndexNode child = parent.child;</span>
<span class="line-modified">2441         if (child.equals(inode)) {</span>
<span class="line-modified">2442             parent.child = child.sibling;</span>
<span class="line-modified">2443         } else {</span>
<span class="line-modified">2444             IndexNode last = child;</span>
<span class="line-modified">2445             while ((child = child.sibling) != null) {</span>
<span class="line-modified">2446                 if (child.equals(inode)) {</span>
<span class="line-modified">2447                     last.sibling = child.sibling;</span>
<span class="line-modified">2448                     break;</span>
<span class="line-modified">2449                 } else {</span>
<span class="line-modified">2450                     last = child;</span>
<span class="line-modified">2451                 }</span>


















































2452             }

2453         }
2454     }
2455 
2456     // purely for parent lookup, so we don&#39;t have to copy the parent
2457     // name every time
2458     static class ParentLookup extends IndexNode {
2459         int len;
2460         ParentLookup() {}
2461 
2462         final ParentLookup as(byte[] name, int len) { // as a lookup &quot;key&quot;
2463             name(name, len);
2464             return this;
2465         }
2466 
2467         void name(byte[] name, int len) {
2468             this.name = name;
2469             this.len = len;
2470             // calculate the hashcode the same way as Arrays.hashCode() does
2471             int result = 1;
2472             for (int i = 0; i &lt; len; i++)
2473                 result = 31 * result + name[i];
2474             this.hashcode = result;
2475         }
2476 
2477         @Override
2478         public boolean equals(Object other) {
2479             if (!(other instanceof IndexNode)) {
2480                 return false;
2481             }
2482             byte[] oname = ((IndexNode)other).name;
2483             return Arrays.equals(name, 0, len,
2484                                  oname, 0, oname.length);
2485         }
<span class="line-removed">2486 </span>
<span class="line-removed">2487     }</span>
<span class="line-removed">2488 </span>
<span class="line-removed">2489     private void buildNodeTree() throws IOException {</span>
<span class="line-removed">2490         beginWrite();</span>
<span class="line-removed">2491         try {</span>
<span class="line-removed">2492             IndexNode root = inodes.get(LOOKUPKEY.as(ROOTPATH));</span>
<span class="line-removed">2493             if (root == null) {</span>
<span class="line-removed">2494                 root = new IndexNode(ROOTPATH, true);</span>
<span class="line-removed">2495             } else {</span>
<span class="line-removed">2496                 inodes.remove(root);</span>
<span class="line-removed">2497             }</span>
<span class="line-removed">2498             IndexNode[] nodes = inodes.keySet().toArray(new IndexNode[0]);</span>
<span class="line-removed">2499             inodes.put(root, root);</span>
<span class="line-removed">2500             ParentLookup lookup = new ParentLookup();</span>
<span class="line-removed">2501             for (IndexNode node : nodes) {</span>
<span class="line-removed">2502                 IndexNode parent;</span>
<span class="line-removed">2503                 while (true) {</span>
<span class="line-removed">2504                     int off = getParentOff(node.name);</span>
<span class="line-removed">2505                     if (off &lt;= 1) {    // parent is root</span>
<span class="line-removed">2506                         node.sibling = root.child;</span>
<span class="line-removed">2507                         root.child = node;</span>
<span class="line-removed">2508                         break;</span>
<span class="line-removed">2509                     }</span>
<span class="line-removed">2510                     lookup = lookup.as(node.name, off);</span>
<span class="line-removed">2511                     if (inodes.containsKey(lookup)) {</span>
<span class="line-removed">2512                         parent = inodes.get(lookup);</span>
<span class="line-removed">2513                         node.sibling = parent.child;</span>
<span class="line-removed">2514                         parent.child = node;</span>
<span class="line-removed">2515                         break;</span>
<span class="line-removed">2516                     }</span>
<span class="line-removed">2517                     // add new pseudo directory entry</span>
<span class="line-removed">2518                     parent = new IndexNode(Arrays.copyOf(node.name, off), true);</span>
<span class="line-removed">2519                     inodes.put(parent, parent);</span>
<span class="line-removed">2520                     node.sibling = parent.child;</span>
<span class="line-removed">2521                     parent.child = node;</span>
<span class="line-removed">2522                     node = parent;</span>
<span class="line-removed">2523                 }</span>
<span class="line-removed">2524             }</span>
<span class="line-removed">2525         } finally {</span>
<span class="line-removed">2526             endWrite();</span>
<span class="line-removed">2527         }</span>
2528     }
2529 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.nio.zipfs;
  27 
  28 import java.io.BufferedOutputStream;
  29 import java.io.ByteArrayInputStream;
  30 import java.io.ByteArrayOutputStream;
  31 import java.io.EOFException;
  32 import java.io.FilterOutputStream;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.OutputStream;
<span class="line-added">  36 import java.lang.Runtime.Version;</span>
  37 import java.nio.ByteBuffer;
  38 import java.nio.MappedByteBuffer;
  39 import java.nio.channels.FileChannel;
  40 import java.nio.channels.FileLock;
  41 import java.nio.channels.ReadableByteChannel;
  42 import java.nio.channels.SeekableByteChannel;
  43 import java.nio.channels.WritableByteChannel;
  44 import java.nio.file.*;
<span class="line-modified">  45 import java.nio.file.attribute.*;</span>


  46 import java.nio.file.spi.FileSystemProvider;
  47 import java.security.AccessController;
  48 import java.security.PrivilegedAction;
  49 import java.security.PrivilegedActionException;
  50 import java.security.PrivilegedExceptionAction;
  51 import java.util.*;
  52 import java.util.concurrent.locks.ReadWriteLock;
  53 import java.util.concurrent.locks.ReentrantReadWriteLock;
<span class="line-added">  54 import java.util.function.Consumer;</span>
<span class="line-added">  55 import java.util.function.Function;</span>
<span class="line-added">  56 import java.util.jar.Attributes;</span>
<span class="line-added">  57 import java.util.jar.Manifest;</span>
  58 import java.util.regex.Pattern;
  59 import java.util.zip.CRC32;
  60 import java.util.zip.Deflater;
  61 import java.util.zip.DeflaterOutputStream;
  62 import java.util.zip.Inflater;
  63 import java.util.zip.InflaterInputStream;
  64 import java.util.zip.ZipException;
  65 
  66 import static java.lang.Boolean.TRUE;
  67 import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;
  68 import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
  69 import static java.nio.file.StandardOpenOption.APPEND;
  70 import static java.nio.file.StandardOpenOption.CREATE;
  71 import static java.nio.file.StandardOpenOption.CREATE_NEW;
  72 import static java.nio.file.StandardOpenOption.READ;
  73 import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;
  74 import static java.nio.file.StandardOpenOption.WRITE;
  75 import static jdk.nio.zipfs.ZipConstants.*;
  76 import static jdk.nio.zipfs.ZipUtils.*;
  77 
  78 /**
  79  * A FileSystem built on a zip file
  80  *
  81  * @author Xueming Shen
  82  */
  83 class ZipFileSystem extends FileSystem {
<span class="line-added">  84     // statics</span>
<span class="line-added">  85     private static final boolean isWindows = AccessController.doPrivileged(</span>
<span class="line-added">  86         (PrivilegedAction&lt;Boolean&gt;)()-&gt;System.getProperty(&quot;os.name&quot;)</span>
<span class="line-added">  87                                              .startsWith(&quot;Windows&quot;));</span>
<span class="line-added">  88     private static final byte[] ROOTPATH = new byte[] { &#39;/&#39; };</span>
<span class="line-added">  89     private static final String PROPERTY_POSIX = &quot;enablePosixFileAttributes&quot;;</span>
<span class="line-added">  90     private static final String PROPERTY_DEFAULT_OWNER = &quot;defaultOwner&quot;;</span>
<span class="line-added">  91     private static final String PROPERTY_DEFAULT_GROUP = &quot;defaultGroup&quot;;</span>
<span class="line-added">  92     private static final String PROPERTY_DEFAULT_PERMISSIONS = &quot;defaultPermissions&quot;;</span>
<span class="line-added">  93     // Property used to specify the entry version to use for a multi-release JAR</span>
<span class="line-added">  94     private static final String PROPERTY_RELEASE_VERSION = &quot;releaseVersion&quot;;</span>
<span class="line-added">  95     // Original property used to specify the entry version to use for a</span>
<span class="line-added">  96     // multi-release JAR which is kept for backwards compatibility.</span>
<span class="line-added">  97     private static final String PROPERTY_MULTI_RELEASE = &quot;multi-release&quot;;</span>
<span class="line-added">  98 </span>
<span class="line-added">  99     private static final Set&lt;PosixFilePermission&gt; DEFAULT_PERMISSIONS =</span>
<span class="line-added"> 100         PosixFilePermissions.fromString(&quot;rwxrwxrwx&quot;);</span>
<span class="line-added"> 101     // Property used to specify the compression mode to use</span>
<span class="line-added"> 102     private static final String PROPERTY_COMPRESSION_METHOD = &quot;compressionMethod&quot;;</span>
<span class="line-added"> 103     // Value specified for compressionMethod property to compress Zip entries</span>
<span class="line-added"> 104     private static final String COMPRESSION_METHOD_DEFLATED = &quot;DEFLATED&quot;;</span>
<span class="line-added"> 105     // Value specified for compressionMethod property to not compress Zip entries</span>
<span class="line-added"> 106     private static final String COMPRESSION_METHOD_STORED = &quot;STORED&quot;;</span>
<span class="line-added"> 107 </span>
 108     private final ZipFileSystemProvider provider;
 109     private final Path zfpath;
 110     final ZipCoder zc;
 111     private final ZipPath rootdir;
<span class="line-modified"> 112     private boolean readOnly; // readonly file system, false by default</span>
<span class="line-added"> 113 </span>
<span class="line-added"> 114     // default time stamp for pseudo entries</span>
<span class="line-added"> 115     private final long zfsDefaultTimeStamp = System.currentTimeMillis();</span>
 116 
 117     // configurable by env map
 118     private final boolean noExtt;        // see readExtra()
 119     private final boolean useTempFile;   // use a temp file for newOS, default
 120                                          // is to use BAOS for better performance



 121     private final boolean forceEnd64;
<span class="line-modified"> 122     private final int defaultCompressionMethod; // METHOD_STORED if &quot;noCompression=true&quot;</span>
<span class="line-modified"> 123                                                 // METHOD_DEFLATED otherwise</span>
<span class="line-added"> 124 </span>
<span class="line-added"> 125     // entryLookup is identity by default, will be overridden for multi-release jars</span>
<span class="line-added"> 126     private Function&lt;byte[], byte[]&gt; entryLookup = Function.identity();</span>
<span class="line-added"> 127 </span>
<span class="line-added"> 128     // POSIX support</span>
<span class="line-added"> 129     final boolean supportPosix;</span>
<span class="line-added"> 130     private final UserPrincipal defaultOwner;</span>
<span class="line-added"> 131     private final GroupPrincipal defaultGroup;</span>
<span class="line-added"> 132     private final Set&lt;PosixFilePermission&gt; defaultPermissions;</span>
<span class="line-added"> 133 </span>
<span class="line-added"> 134     private final Set&lt;String&gt; supportedFileAttributeViews;</span>
 135 
 136     ZipFileSystem(ZipFileSystemProvider provider,
 137                   Path zfpath,
 138                   Map&lt;String, ?&gt; env) throws IOException
 139     {
 140         // default encoding for name/comment
 141         String nameEncoding = env.containsKey(&quot;encoding&quot;) ?
<span class="line-modified"> 142             (String)env.get(&quot;encoding&quot;) : &quot;UTF-8&quot;;</span>
 143         this.noExtt = &quot;false&quot;.equals(env.get(&quot;zipinfo-time&quot;));
 144         this.useTempFile  = isTrue(env, &quot;useTempFile&quot;);
 145         this.forceEnd64 = isTrue(env, &quot;forceZIP64End&quot;);
<span class="line-modified"> 146         this.defaultCompressionMethod = getDefaultCompressionMethod(env);</span>
<span class="line-added"> 147         this.supportPosix = isTrue(env, PROPERTY_POSIX);</span>
<span class="line-added"> 148         this.defaultOwner = initOwner(zfpath, env);</span>
<span class="line-added"> 149         this.defaultGroup = initGroup(zfpath, env);</span>
<span class="line-added"> 150         this.defaultPermissions = initPermissions(env);</span>
<span class="line-added"> 151         this.supportedFileAttributeViews = supportPosix ?</span>
<span class="line-added"> 152             Set.of(&quot;basic&quot;, &quot;posix&quot;, &quot;zip&quot;) : Set.of(&quot;basic&quot;, &quot;zip&quot;);</span>
 153         if (Files.notExists(zfpath)) {
<span class="line-modified"> 154             // create a new zip if it doesn&#39;t exist</span>
 155             if (isTrue(env, &quot;create&quot;)) {
 156                 try (OutputStream os = Files.newOutputStream(zfpath, CREATE_NEW, WRITE)) {
 157                     new END().write(os, 0, forceEnd64);
 158                 }
 159             } else {
<span class="line-modified"> 160                 throw new NoSuchFileException(zfpath.toString());</span>
 161             }
 162         }
 163         // sm and existence check
 164         zfpath.getFileSystem().provider().checkAccess(zfpath, AccessMode.READ);
 165         boolean writeable = AccessController.doPrivileged(
<span class="line-modified"> 166             (PrivilegedAction&lt;Boolean&gt;)()-&gt;Files.isWritable(zfpath));</span>
 167         this.readOnly = !writeable;
 168         this.zc = ZipCoder.get(nameEncoding);
 169         this.rootdir = new ZipPath(this, new byte[]{&#39;/&#39;});
 170         this.ch = Files.newByteChannel(zfpath, READ);
 171         try {
 172             this.cen = initCEN();
 173         } catch (IOException x) {
 174             try {
 175                 this.ch.close();
 176             } catch (IOException xx) {
 177                 x.addSuppressed(xx);
 178             }
 179             throw x;
 180         }
 181         this.provider = provider;
 182         this.zfpath = zfpath;
<span class="line-added"> 183 </span>
<span class="line-added"> 184         initializeReleaseVersion(env);</span>
<span class="line-added"> 185     }</span>
<span class="line-added"> 186 </span>
<span class="line-added"> 187     /**</span>
<span class="line-added"> 188      * Return the compression method to use (STORED or DEFLATED).  If the</span>
<span class="line-added"> 189      * property {@code commpressionMethod} is set use its value to determine</span>
<span class="line-added"> 190      * the compression method to use.  If the property is not set, then the</span>
<span class="line-added"> 191      * default compression is DEFLATED unless the property {@code noCompression}</span>
<span class="line-added"> 192      * is set which is supported for backwards compatibility.</span>
<span class="line-added"> 193      * @param env Zip FS map of properties</span>
<span class="line-added"> 194      * @return The Compression method to use</span>
<span class="line-added"> 195      */</span>
<span class="line-added"> 196     private int getDefaultCompressionMethod(Map&lt;String, ?&gt; env) {</span>
<span class="line-added"> 197         int result =</span>
<span class="line-added"> 198                 isTrue(env, &quot;noCompression&quot;) ? METHOD_STORED : METHOD_DEFLATED;</span>
<span class="line-added"> 199         if (env.containsKey(PROPERTY_COMPRESSION_METHOD)) {</span>
<span class="line-added"> 200             Object compressionMethod =  env.get(PROPERTY_COMPRESSION_METHOD);</span>
<span class="line-added"> 201             if (compressionMethod != null) {</span>
<span class="line-added"> 202                 if (compressionMethod instanceof String) {</span>
<span class="line-added"> 203                     switch (((String) compressionMethod).toUpperCase()) {</span>
<span class="line-added"> 204                         case COMPRESSION_METHOD_STORED:</span>
<span class="line-added"> 205                             result = METHOD_STORED;</span>
<span class="line-added"> 206                             break;</span>
<span class="line-added"> 207                         case COMPRESSION_METHOD_DEFLATED:</span>
<span class="line-added"> 208                             result = METHOD_DEFLATED;</span>
<span class="line-added"> 209                             break;</span>
<span class="line-added"> 210                         default:</span>
<span class="line-added"> 211                             throw new IllegalArgumentException(String.format(</span>
<span class="line-added"> 212                                     &quot;The value for the %s property must be %s or %s&quot;,</span>
<span class="line-added"> 213                                     PROPERTY_COMPRESSION_METHOD, COMPRESSION_METHOD_STORED,</span>
<span class="line-added"> 214                                     COMPRESSION_METHOD_DEFLATED));</span>
<span class="line-added"> 215                     }</span>
<span class="line-added"> 216                 } else {</span>
<span class="line-added"> 217                     throw new IllegalArgumentException(String.format(</span>
<span class="line-added"> 218                             &quot;The Object type for the %s property must be a String&quot;,</span>
<span class="line-added"> 219                             PROPERTY_COMPRESSION_METHOD));</span>
<span class="line-added"> 220                 }</span>
<span class="line-added"> 221             } else {</span>
<span class="line-added"> 222                 throw new IllegalArgumentException(String.format(</span>
<span class="line-added"> 223                         &quot;The value for the %s property must be %s or %s&quot;,</span>
<span class="line-added"> 224                         PROPERTY_COMPRESSION_METHOD, COMPRESSION_METHOD_STORED,</span>
<span class="line-added"> 225                         COMPRESSION_METHOD_DEFLATED));</span>
<span class="line-added"> 226             }</span>
<span class="line-added"> 227         }</span>
<span class="line-added"> 228         return result;</span>
 229     }
 230 
 231     // returns true if there is a name=true/&quot;true&quot; setting in env
 232     private static boolean isTrue(Map&lt;String, ?&gt; env, String name) {
 233         return &quot;true&quot;.equals(env.get(name)) || TRUE.equals(env.get(name));
 234     }
 235 
<span class="line-added"> 236     // Initialize the default owner for files inside the zip archive.</span>
<span class="line-added"> 237     // If not specified in env, it is the owner of the archive. If no owner can</span>
<span class="line-added"> 238     // be determined, we try to go with system property &quot;user.name&quot;. If that&#39;s not</span>
<span class="line-added"> 239     // accessible, we return &quot;&lt;zipfs_default&gt;&quot;.</span>
<span class="line-added"> 240     private UserPrincipal initOwner(Path zfpath, Map&lt;String, ?&gt; env) throws IOException {</span>
<span class="line-added"> 241         Object o = env.get(PROPERTY_DEFAULT_OWNER);</span>
<span class="line-added"> 242         if (o == null) {</span>
<span class="line-added"> 243             try {</span>
<span class="line-added"> 244                 PrivilegedExceptionAction&lt;UserPrincipal&gt; pa = ()-&gt;Files.getOwner(zfpath);</span>
<span class="line-added"> 245                 return AccessController.doPrivileged(pa);</span>
<span class="line-added"> 246             } catch (UnsupportedOperationException | PrivilegedActionException e) {</span>
<span class="line-added"> 247                 if (e instanceof UnsupportedOperationException ||</span>
<span class="line-added"> 248                     e.getCause() instanceof NoSuchFileException)</span>
<span class="line-added"> 249                 {</span>
<span class="line-added"> 250                     PrivilegedAction&lt;String&gt; pa = ()-&gt;System.getProperty(&quot;user.name&quot;);</span>
<span class="line-added"> 251                     String userName = AccessController.doPrivileged(pa);</span>
<span class="line-added"> 252                     return ()-&gt;userName;</span>
<span class="line-added"> 253                 } else {</span>
<span class="line-added"> 254                     throw new IOException(e);</span>
<span class="line-added"> 255                 }</span>
<span class="line-added"> 256             }</span>
<span class="line-added"> 257         }</span>
<span class="line-added"> 258         if (o instanceof String) {</span>
<span class="line-added"> 259             if (((String)o).isEmpty()) {</span>
<span class="line-added"> 260                 throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added"> 261                         PROPERTY_DEFAULT_OWNER + &quot; must not be empty.&quot;);</span>
<span class="line-added"> 262             }</span>
<span class="line-added"> 263             return ()-&gt;(String)o;</span>
<span class="line-added"> 264         }</span>
<span class="line-added"> 265         if (o instanceof UserPrincipal) {</span>
<span class="line-added"> 266             return (UserPrincipal)o;</span>
<span class="line-added"> 267         }</span>
<span class="line-added"> 268         throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added"> 269                 PROPERTY_DEFAULT_OWNER + &quot; must be of type &quot; + String.class +</span>
<span class="line-added"> 270             &quot; or &quot; + UserPrincipal.class);</span>
<span class="line-added"> 271     }</span>
<span class="line-added"> 272 </span>
<span class="line-added"> 273     // Initialize the default group for files inside the zip archive.</span>
<span class="line-added"> 274     // If not specified in env, we try to determine the group of the zip archive itself.</span>
<span class="line-added"> 275     // If this is not possible/unsupported, we will return a group principal going by</span>
<span class="line-added"> 276     // the same name as the default owner.</span>
<span class="line-added"> 277     private GroupPrincipal initGroup(Path zfpath, Map&lt;String, ?&gt; env) throws IOException {</span>
<span class="line-added"> 278         Object o = env.get(PROPERTY_DEFAULT_GROUP);</span>
<span class="line-added"> 279         if (o == null) {</span>
<span class="line-added"> 280             try {</span>
<span class="line-added"> 281                 PosixFileAttributeView zfpv = Files.getFileAttributeView(zfpath, PosixFileAttributeView.class);</span>
<span class="line-added"> 282                 if (zfpv == null) {</span>
<span class="line-added"> 283                     return defaultOwner::getName;</span>
<span class="line-added"> 284                 }</span>
<span class="line-added"> 285                 PrivilegedExceptionAction&lt;GroupPrincipal&gt; pa = ()-&gt;zfpv.readAttributes().group();</span>
<span class="line-added"> 286                 return AccessController.doPrivileged(pa);</span>
<span class="line-added"> 287             } catch (UnsupportedOperationException | PrivilegedActionException e) {</span>
<span class="line-added"> 288                 if (e instanceof UnsupportedOperationException ||</span>
<span class="line-added"> 289                     e.getCause() instanceof NoSuchFileException)</span>
<span class="line-added"> 290                 {</span>
<span class="line-added"> 291                     return defaultOwner::getName;</span>
<span class="line-added"> 292                 } else {</span>
<span class="line-added"> 293                     throw new IOException(e);</span>
<span class="line-added"> 294                 }</span>
<span class="line-added"> 295             }</span>
<span class="line-added"> 296         }</span>
<span class="line-added"> 297         if (o instanceof String) {</span>
<span class="line-added"> 298             if (((String)o).isEmpty()) {</span>
<span class="line-added"> 299                 throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added"> 300                         PROPERTY_DEFAULT_GROUP + &quot; must not be empty.&quot;);</span>
<span class="line-added"> 301             }</span>
<span class="line-added"> 302             return ()-&gt;(String)o;</span>
<span class="line-added"> 303         }</span>
<span class="line-added"> 304         if (o instanceof GroupPrincipal) {</span>
<span class="line-added"> 305             return (GroupPrincipal)o;</span>
<span class="line-added"> 306         }</span>
<span class="line-added"> 307         throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added"> 308                 PROPERTY_DEFAULT_GROUP + &quot; must be of type &quot; + String.class +</span>
<span class="line-added"> 309             &quot; or &quot; + GroupPrincipal.class);</span>
<span class="line-added"> 310     }</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312     // Initialize the default permissions for files inside the zip archive.</span>
<span class="line-added"> 313     // If not specified in env, it will return 777.</span>
<span class="line-added"> 314     private Set&lt;PosixFilePermission&gt; initPermissions(Map&lt;String, ?&gt; env) {</span>
<span class="line-added"> 315         Object o = env.get(PROPERTY_DEFAULT_PERMISSIONS);</span>
<span class="line-added"> 316         if (o == null) {</span>
<span class="line-added"> 317             return DEFAULT_PERMISSIONS;</span>
<span class="line-added"> 318         }</span>
<span class="line-added"> 319         if (o instanceof String) {</span>
<span class="line-added"> 320             return PosixFilePermissions.fromString((String)o);</span>
<span class="line-added"> 321         }</span>
<span class="line-added"> 322         if (!(o instanceof Set)) {</span>
<span class="line-added"> 323             throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added"> 324                 PROPERTY_DEFAULT_PERMISSIONS + &quot; must be of type &quot; + String.class +</span>
<span class="line-added"> 325                 &quot; or &quot; + Set.class);</span>
<span class="line-added"> 326         }</span>
<span class="line-added"> 327         Set&lt;PosixFilePermission&gt; perms = new HashSet&lt;&gt;();</span>
<span class="line-added"> 328         for (Object o2 : (Set&lt;?&gt;)o) {</span>
<span class="line-added"> 329             if (o2 instanceof PosixFilePermission) {</span>
<span class="line-added"> 330                 perms.add((PosixFilePermission)o2);</span>
<span class="line-added"> 331             } else {</span>
<span class="line-added"> 332                 throw new IllegalArgumentException(PROPERTY_DEFAULT_PERMISSIONS +</span>
<span class="line-added"> 333                     &quot; must only contain objects of type &quot; + PosixFilePermission.class);</span>
<span class="line-added"> 334             }</span>
<span class="line-added"> 335         }</span>
<span class="line-added"> 336         return perms;</span>
<span class="line-added"> 337     }</span>
<span class="line-added"> 338 </span>
 339     @Override
 340     public FileSystemProvider provider() {
 341         return provider;
 342     }
 343 
 344     @Override
 345     public String getSeparator() {
 346         return &quot;/&quot;;
 347     }
 348 
 349     @Override
 350     public boolean isOpen() {
 351         return isOpen;
 352     }
 353 
 354     @Override
 355     public boolean isReadOnly() {
 356         return readOnly;
 357     }
 358 
<span class="line-modified"> 359     private void checkWritable() {</span>
<span class="line-modified"> 360         if (readOnly) {</span>
 361             throw new ReadOnlyFileSystemException();
<span class="line-added"> 362         }</span>
 363     }
 364 
 365     void setReadOnly() {
 366         this.readOnly = true;
 367     }
 368 
 369     @Override
 370     public Iterable&lt;Path&gt; getRootDirectories() {
 371         return List.of(rootdir);
 372     }
 373 
 374     ZipPath getRootDir() {
 375         return rootdir;
 376     }
 377 
 378     @Override
 379     public ZipPath getPath(String first, String... more) {
 380         if (more.length == 0) {
 381             return new ZipPath(this, first);
 382         }
</pre>
<hr />
<pre>
 395 
 396     @Override
 397     public UserPrincipalLookupService getUserPrincipalLookupService() {
 398         throw new UnsupportedOperationException();
 399     }
 400 
 401     @Override
 402     public WatchService newWatchService() {
 403         throw new UnsupportedOperationException();
 404     }
 405 
 406     FileStore getFileStore(ZipPath path) {
 407         return new ZipFileStore(path);
 408     }
 409 
 410     @Override
 411     public Iterable&lt;FileStore&gt; getFileStores() {
 412         return List.of(new ZipFileStore(rootdir));
 413     }
 414 



 415     @Override
 416     public Set&lt;String&gt; supportedFileAttributeViews() {
 417         return supportedFileAttributeViews;
 418     }
 419 
 420     @Override
 421     public String toString() {
 422         return zfpath.toString();
 423     }
 424 
 425     Path getZipFile() {
 426         return zfpath;
 427     }
 428 
 429     private static final String GLOB_SYNTAX = &quot;glob&quot;;
 430     private static final String REGEX_SYNTAX = &quot;regex&quot;;
 431 
 432     @Override
 433     public PathMatcher getPathMatcher(String syntaxAndInput) {
 434         int pos = syntaxAndInput.indexOf(&#39;:&#39;);
 435         if (pos &lt;= 0 || pos == syntaxAndInput.length()) {
 436             throw new IllegalArgumentException();
 437         }
 438         String syntax = syntaxAndInput.substring(0, pos);
 439         String input = syntaxAndInput.substring(pos + 1);
 440         String expr;
 441         if (syntax.equalsIgnoreCase(GLOB_SYNTAX)) {
 442             expr = toRegexPattern(input);
 443         } else {
 444             if (syntax.equalsIgnoreCase(REGEX_SYNTAX)) {
 445                 expr = input;
 446             } else {
 447                 throw new UnsupportedOperationException(&quot;Syntax &#39;&quot; + syntax +
 448                     &quot;&#39; not recognized&quot;);
 449             }
 450         }
 451         // return matcher
 452         final Pattern pattern = Pattern.compile(expr);
<span class="line-modified"> 453         return (path)-&gt;pattern.matcher(path.toString()).matches();</span>





 454     }
 455 
 456     @Override
 457     public void close() throws IOException {
 458         beginWrite();
 459         try {
 460             if (!isOpen)
 461                 return;
 462             isOpen = false;          // set closed
 463         } finally {
 464             endWrite();
 465         }
 466         if (!streams.isEmpty()) {    // unlock and close all remaining streams
 467             Set&lt;InputStream&gt; copy = new HashSet&lt;&gt;(streams);
 468             for (InputStream is : copy)
 469                 is.close();
 470         }
 471         beginWrite();                // lock and sync
 472         try {
 473             AccessController.doPrivileged((PrivilegedExceptionAction&lt;Void&gt;)() -&gt; {
 474                 sync(); return null;
 475             });
 476             ch.close();              // close the ch just in case no update
 477                                      // and sync didn&#39;t close the ch
 478         } catch (PrivilegedActionException e) {
 479             throw (IOException)e.getException();
 480         } finally {
 481             endWrite();
 482         }
 483 
 484         synchronized (inflaters) {
 485             for (Inflater inf : inflaters)
 486                 inf.end();
 487         }
 488         synchronized (deflaters) {
 489             for (Deflater def : deflaters)
 490                 def.end();
 491         }
 492 
<span class="line-added"> 493         beginWrite();                // lock and sync</span>
<span class="line-added"> 494         try {</span>
<span class="line-added"> 495             // Clear the map so that its keys &amp; values can be garbage collected</span>
<span class="line-added"> 496             inodes = null;</span>
<span class="line-added"> 497         } finally {</span>
<span class="line-added"> 498             endWrite();</span>
<span class="line-added"> 499         }</span>
<span class="line-added"> 500 </span>
 501         IOException ioe = null;
 502         synchronized (tmppaths) {
 503             for (Path p : tmppaths) {
 504                 try {
 505                     AccessController.doPrivileged(
 506                         (PrivilegedExceptionAction&lt;Boolean&gt;)() -&gt; Files.deleteIfExists(p));
 507                 } catch (PrivilegedActionException e) {
 508                     IOException x = (IOException)e.getException();
 509                     if (ioe == null)
 510                         ioe = x;
 511                     else
 512                         ioe.addSuppressed(x);
 513                 }
 514             }
 515         }
 516         provider.removeFileSystem(zfpath, this);
 517         if (ioe != null)
 518            throw ioe;
 519     }
 520 
 521     ZipFileAttributes getFileAttributes(byte[] path)
 522         throws IOException
 523     {

 524         beginRead();
 525         try {
 526             ensureOpen();
<span class="line-modified"> 527             IndexNode inode = getInode(path);</span>
<span class="line-modified"> 528             if (inode == null) {</span>
<span class="line-modified"> 529                 return null;</span>
<span class="line-modified"> 530             } else if (inode instanceof Entry) {</span>
<span class="line-modified"> 531                 return (Entry)inode;</span>
<span class="line-added"> 532             } else if (inode.pos == -1) {</span>
 533                 // pseudo directory, uses METHOD_STORED
<span class="line-modified"> 534                 Entry e = supportPosix ?</span>
<span class="line-added"> 535                     new PosixEntry(inode.name, inode.isdir, METHOD_STORED) :</span>
<span class="line-added"> 536                     new Entry(inode.name, inode.isdir, METHOD_STORED);</span>
 537                 e.mtime = e.atime = e.ctime = zfsDefaultTimeStamp;
<span class="line-added"> 538                 return e;</span>
<span class="line-added"> 539             } else {</span>
<span class="line-added"> 540                 return supportPosix ? new PosixEntry(this, inode) : new Entry(this, inode);</span>
 541             }
 542         } finally {
 543             endRead();
 544         }

 545     }
 546 
 547     void checkAccess(byte[] path) throws IOException {
 548         beginRead();
 549         try {
 550             ensureOpen();
 551             // is it necessary to readCEN as a sanity check?
 552             if (getInode(path) == null) {
 553                 throw new NoSuchFileException(toString());
 554             }
 555 
 556         } finally {
 557             endRead();
 558         }
 559     }
 560 
 561     void setTimes(byte[] path, FileTime mtime, FileTime atime, FileTime ctime)
 562         throws IOException
 563     {
 564         checkWritable();
 565         beginWrite();
 566         try {
 567             ensureOpen();
 568             Entry e = getEntry(path);    // ensureOpen checked
 569             if (e == null)
 570                 throw new NoSuchFileException(getString(path));
 571             if (e.type == Entry.CEN)
<span class="line-modified"> 572                 e.type = Entry.COPY;     // copy e</span>
 573             if (mtime != null)
 574                 e.mtime = mtime.toMillis();
 575             if (atime != null)
 576                 e.atime = atime.toMillis();
 577             if (ctime != null)
 578                 e.ctime = ctime.toMillis();
 579             update(e);
 580         } finally {
 581             endWrite();
 582         }
 583     }
 584 
<span class="line-modified"> 585     void setOwner(byte[] path, UserPrincipal owner) throws IOException {</span>
<span class="line-modified"> 586         checkWritable();</span>
<span class="line-modified"> 587         beginWrite();</span>
<span class="line-added"> 588         try {</span>
<span class="line-added"> 589             ensureOpen();</span>
<span class="line-added"> 590             Entry e = getEntry(path);    // ensureOpen checked</span>
<span class="line-added"> 591             if (e == null) {</span>
<span class="line-added"> 592                 throw new NoSuchFileException(getString(path));</span>
<span class="line-added"> 593             }</span>
<span class="line-added"> 594             // as the owner information is not persistent, we don&#39;t need to</span>
<span class="line-added"> 595             // change e.type to Entry.COPY</span>
<span class="line-added"> 596             if (e instanceof PosixEntry) {</span>
<span class="line-added"> 597                 ((PosixEntry)e).owner = owner;</span>
<span class="line-added"> 598                 update(e);</span>
<span class="line-added"> 599             }</span>
<span class="line-added"> 600         } finally {</span>
<span class="line-added"> 601             endWrite();</span>
<span class="line-added"> 602         }</span>
<span class="line-added"> 603     }</span>
<span class="line-added"> 604 </span>
<span class="line-added"> 605     void setGroup(byte[] path, GroupPrincipal group) throws IOException {</span>
<span class="line-added"> 606         checkWritable();</span>
<span class="line-added"> 607         beginWrite();</span>
<span class="line-added"> 608         try {</span>
<span class="line-added"> 609             ensureOpen();</span>
<span class="line-added"> 610             Entry e = getEntry(path);    // ensureOpen checked</span>
<span class="line-added"> 611             if (e == null) {</span>
<span class="line-added"> 612                 throw new NoSuchFileException(getString(path));</span>
<span class="line-added"> 613             }</span>
<span class="line-added"> 614             // as the group information is not persistent, we don&#39;t need to</span>
<span class="line-added"> 615             // change e.type to Entry.COPY</span>
<span class="line-added"> 616             if (e instanceof PosixEntry) {</span>
<span class="line-added"> 617                 ((PosixEntry)e).group = group;</span>
<span class="line-added"> 618                 update(e);</span>
<span class="line-added"> 619             }</span>
<span class="line-added"> 620         } finally {</span>
<span class="line-added"> 621             endWrite();</span>
<span class="line-added"> 622         }</span>
<span class="line-added"> 623     }</span>
<span class="line-added"> 624 </span>
<span class="line-added"> 625     void setPermissions(byte[] path, Set&lt;PosixFilePermission&gt; perms) throws IOException {</span>
<span class="line-added"> 626         checkWritable();</span>
<span class="line-added"> 627         beginWrite();</span>
<span class="line-added"> 628         try {</span>
<span class="line-added"> 629             ensureOpen();</span>
<span class="line-added"> 630             Entry e = getEntry(path);    // ensureOpen checked</span>
<span class="line-added"> 631             if (e == null) {</span>
<span class="line-added"> 632                 throw new NoSuchFileException(getString(path));</span>
<span class="line-added"> 633             }</span>
<span class="line-added"> 634             if (e.type == Entry.CEN) {</span>
<span class="line-added"> 635                 e.type = Entry.COPY;     // copy e</span>
<span class="line-added"> 636             }</span>
<span class="line-added"> 637             e.posixPerms = perms == null ? -1 : ZipUtils.permsToFlags(perms);</span>
<span class="line-added"> 638             update(e);</span>
<span class="line-added"> 639         } finally {</span>
<span class="line-added"> 640             endWrite();</span>
<span class="line-added"> 641         }</span>
<span class="line-added"> 642     }</span>
<span class="line-added"> 643 </span>
<span class="line-added"> 644     boolean exists(byte[] path) {</span>
 645         beginRead();
 646         try {
 647             ensureOpen();
 648             return getInode(path) != null;
 649         } finally {
 650             endRead();
 651         }
 652     }
 653 
<span class="line-modified"> 654     boolean isDirectory(byte[] path) {</span>


 655         beginRead();
 656         try {
 657             IndexNode n = getInode(path);
 658             return n != null &amp;&amp; n.isDir();
 659         } finally {
 660             endRead();
 661         }
 662     }
 663 
 664     // returns the list of child paths of &quot;path&quot;
 665     Iterator&lt;Path&gt; iteratorOf(ZipPath dir,
 666                               DirectoryStream.Filter&lt;? super Path&gt; filter)
 667         throws IOException
 668     {
 669         beginWrite();    // iteration of inodes needs exclusive lock
 670         try {
 671             ensureOpen();
 672             byte[] path = dir.getResolvedPath();
 673             IndexNode inode = getInode(path);
 674             if (inode == null)
 675                 throw new NotDirectoryException(getString(path));
 676             List&lt;Path&gt; list = new ArrayList&lt;&gt;();
 677             IndexNode child = inode.child;
 678             while (child != null) {
 679                 // (1) Assume each path from the zip file itself is &quot;normalized&quot;
 680                 // (2) IndexNode.name is absolute. see IndexNode(byte[],int,int)
 681                 // (3) If parent &quot;dir&quot; is relative when ZipDirectoryStream
 682                 //     is created, the returned child path needs to be relative
 683                 //     as well.
<span class="line-modified"> 684                 ZipPath childPath = new ZipPath(this, child.name, true);</span>

 685                 ZipPath childFileName = childPath.getFileName();
 686                 ZipPath zpath = dir.resolve(childFileName);
 687                 if (filter == null || filter.accept(zpath))
 688                     list.add(zpath);
 689                 child = child.sibling;
 690             }
 691             return list.iterator();
 692         } finally {
 693             endWrite();
 694         }
 695     }
 696 
<span class="line-modified"> 697     void createDirectory(byte[] dir, FileAttribute&lt;?&gt;... attrs) throws IOException {</span>


 698         checkWritable();

 699         beginWrite();
 700         try {
 701             ensureOpen();
<span class="line-modified"> 702             if (dir.length == 0 || exists(dir))  // root dir, or existing dir</span>
 703                 throw new FileAlreadyExistsException(getString(dir));
 704             checkParents(dir);
<span class="line-modified"> 705             Entry e = supportPosix ?</span>
<span class="line-added"> 706                 new PosixEntry(dir, Entry.NEW, true, METHOD_STORED, attrs) :</span>
<span class="line-added"> 707                 new Entry(dir, Entry.NEW, true, METHOD_STORED, attrs);</span>
 708             update(e);
 709         } finally {
 710             endWrite();
 711         }
 712     }
 713 
 714     void copyFile(boolean deletesrc, byte[]src, byte[] dst, CopyOption... options)
 715         throws IOException
 716     {
 717         checkWritable();
 718         if (Arrays.equals(src, dst))
 719             return;    // do nothing, src and dst are the same
 720 
 721         beginWrite();
 722         try {
 723             ensureOpen();
 724             Entry eSrc = getEntry(src);  // ensureOpen checked
 725 
 726             if (eSrc == null)
 727                 throw new NoSuchFileException(getString(src));
 728             if (eSrc.isDir()) {    // spec says to create dst dir
 729                 createDirectory(dst);
 730                 return;
 731             }
 732             boolean hasReplace = false;
 733             boolean hasCopyAttrs = false;
 734             for (CopyOption opt : options) {
 735                 if (opt == REPLACE_EXISTING)
 736                     hasReplace = true;
 737                 else if (opt == COPY_ATTRIBUTES)
 738                     hasCopyAttrs = true;
 739             }
 740             Entry eDst = getEntry(dst);
 741             if (eDst != null) {
 742                 if (!hasReplace)
 743                     throw new FileAlreadyExistsException(getString(dst));
 744             } else {
 745                 checkParents(dst);
 746             }
<span class="line-modified"> 747             // copy eSrc entry and change name</span>
<span class="line-modified"> 748             Entry u = supportPosix ?</span>
<span class="line-modified"> 749                 new PosixEntry((PosixEntry)eSrc, Entry.COPY) :</span>
<span class="line-modified"> 750                 new Entry(eSrc, Entry.COPY);</span>
<span class="line-added"> 751             u.name(dst);</span>
<span class="line-added"> 752             if (eSrc.type == Entry.NEW || eSrc.type == Entry.FILECH) {</span>
 753                 u.type = eSrc.type;    // make it the same type
 754                 if (deletesrc) {       // if it&#39;s a &quot;rename&quot;, take the data
 755                     u.bytes = eSrc.bytes;
 756                     u.file = eSrc.file;
 757                 } else {               // if it&#39;s not &quot;rename&quot;, copy the data
 758                     if (eSrc.bytes != null)
 759                         u.bytes = Arrays.copyOf(eSrc.bytes, eSrc.bytes.length);
 760                     else if (eSrc.file != null) {
 761                         u.file = getTempPathForEntry(null);
 762                         Files.copy(eSrc.file, u.file, REPLACE_EXISTING);
 763                     }
 764                 }
<span class="line-added"> 765             } else if (eSrc.type == Entry.CEN &amp;&amp; eSrc.method != defaultCompressionMethod) {</span>
<span class="line-added"> 766 </span>
<span class="line-added"> 767                 /**</span>
<span class="line-added"> 768                  * We are copying a file within the same Zip file using a</span>
<span class="line-added"> 769                  * different compression method.</span>
<span class="line-added"> 770                  */</span>
<span class="line-added"> 771                 try (InputStream in = newInputStream(src);</span>
<span class="line-added"> 772                      OutputStream out = newOutputStream(dst,</span>
<span class="line-added"> 773                              CREATE, TRUNCATE_EXISTING, WRITE)) {</span>
<span class="line-added"> 774                     in.transferTo(out);</span>
<span class="line-added"> 775                 }</span>
<span class="line-added"> 776                 u = getEntry(dst);</span>
 777             }
<span class="line-added"> 778 </span>
 779             if (!hasCopyAttrs)
 780                 u.mtime = u.atime= u.ctime = System.currentTimeMillis();
 781             update(u);
 782             if (deletesrc)
 783                 updateDelete(eSrc);
 784         } finally {
 785             endWrite();
 786         }
 787     }
 788 
 789     // Returns an output stream for writing the contents into the specified
 790     // entry.
 791     OutputStream newOutputStream(byte[] path, OpenOption... options)
 792         throws IOException
 793     {
 794         checkWritable();
 795         boolean hasCreateNew = false;
 796         boolean hasCreate = false;
 797         boolean hasAppend = false;
 798         boolean hasTruncate = false;
</pre>
<hr />
<pre>
 801                 throw new IllegalArgumentException(&quot;READ not allowed&quot;);
 802             if (opt == CREATE_NEW)
 803                 hasCreateNew = true;
 804             if (opt == CREATE)
 805                 hasCreate = true;
 806             if (opt == APPEND)
 807                 hasAppend = true;
 808             if (opt == TRUNCATE_EXISTING)
 809                 hasTruncate = true;
 810         }
 811         if (hasAppend &amp;&amp; hasTruncate)
 812             throw new IllegalArgumentException(&quot;APPEND + TRUNCATE_EXISTING not allowed&quot;);
 813         beginRead();                 // only need a readlock, the &quot;update()&quot; will
 814         try {                        // try to obtain a writelock when the os is
 815             ensureOpen();            // being closed.
 816             Entry e = getEntry(path);
 817             if (e != null) {
 818                 if (e.isDir() || hasCreateNew)
 819                     throw new FileAlreadyExistsException(getString(path));
 820                 if (hasAppend) {

 821                     OutputStream os = getOutputStream(new Entry(e, Entry.NEW));
<span class="line-modified"> 822                     try (InputStream is = getInputStream(e)) {</span>
<span class="line-modified"> 823                         is.transferTo(os);</span>
<span class="line-added"> 824                     }</span>
 825                     return os;
 826                 }
<span class="line-modified"> 827                 return getOutputStream(supportPosix ?</span>
<span class="line-added"> 828                     new PosixEntry((PosixEntry)e, Entry.NEW, defaultCompressionMethod)</span>
<span class="line-added"> 829                         : new Entry(e, Entry.NEW, defaultCompressionMethod));</span>
 830             } else {
 831                 if (!hasCreate &amp;&amp; !hasCreateNew)
 832                     throw new NoSuchFileException(getString(path));
 833                 checkParents(path);
<span class="line-modified"> 834                 return getOutputStream(supportPosix ?</span>
<span class="line-added"> 835                     new PosixEntry(path, Entry.NEW, false, defaultCompressionMethod) :</span>
<span class="line-added"> 836                     new Entry(path, Entry.NEW, false, defaultCompressionMethod));</span>
 837             }
 838         } finally {
 839             endRead();
 840         }
 841     }
 842 
 843     // Returns an input stream for reading the contents of the specified
 844     // file entry.
 845     InputStream newInputStream(byte[] path) throws IOException {
 846         beginRead();
 847         try {
 848             ensureOpen();
 849             Entry e = getEntry(path);
 850             if (e == null)
 851                 throw new NoSuchFileException(getString(path));
 852             if (e.isDir())
 853                 throw new FileSystemException(getString(path), &quot;is a directory&quot;, null);
 854             return getInputStream(e);
 855         } finally {
 856             endRead();
 857         }
 858     }
 859 
 860     private void checkOptions(Set&lt;? extends OpenOption&gt; options) {
 861         // check for options of null type and option is an intance of StandardOpenOption
 862         for (OpenOption option : options) {
 863             if (option == null)
 864                 throw new NullPointerException();
 865             if (!(option instanceof StandardOpenOption))
 866                 throw new IllegalArgumentException();
 867         }
 868         if (options.contains(APPEND) &amp;&amp; options.contains(TRUNCATE_EXISTING))
 869             throw new IllegalArgumentException(&quot;APPEND + TRUNCATE_EXISTING not allowed&quot;);
 870     }
 871 

 872     // Returns an output SeekableByteChannel for either
<span class="line-modified"> 873     // (1) writing the contents of a new entry, if the entry doesn&#39;t exist, or</span>
 874     // (2) updating/replacing the contents of an existing entry.
<span class="line-modified"> 875     // Note: The content of the channel is not compressed until the</span>
<span class="line-added"> 876     // channel is closed</span>
 877     private class EntryOutputChannel extends ByteArrayChannel {
<span class="line-modified"> 878         final Entry e;</span>
 879 
<span class="line-modified"> 880         EntryOutputChannel(Entry e) {</span>
 881             super(e.size &gt; 0? (int)e.size : 8192, false);
 882             this.e = e;
 883             if (e.mtime == -1)
 884                 e.mtime = System.currentTimeMillis();
 885             if (e.method == -1)
<span class="line-modified"> 886                 e.method = defaultCompressionMethod;</span>
 887             // store size, compressed size, and crc-32 in datadescriptor
 888             e.flag = FLAG_DATADESCR;
 889             if (zc.isUTF8())
 890                 e.flag |= FLAG_USE_UTF8;
 891         }
 892 
 893         @Override
 894         public void close() throws IOException {
<span class="line-modified"> 895             // will update the entry</span>
<span class="line-modified"> 896             try (OutputStream os = getOutputStream(e)) {</span>
<span class="line-modified"> 897                 os.write(toByteArray());</span>
<span class="line-added"> 898             }</span>
 899             super.close();

 900         }
 901     }
 902 
<span class="line-modified"> 903     // Returns a Writable/ReadByteChannel for now. Might consider to use</span>




 904     // newFileChannel() instead, which dump the entry data into a regular
<span class="line-modified"> 905     // file on the default file system and create a FileChannel on top of it.</span>

 906     SeekableByteChannel newByteChannel(byte[] path,
 907                                        Set&lt;? extends OpenOption&gt; options,
 908                                        FileAttribute&lt;?&gt;... attrs)
 909         throws IOException
 910     {
 911         checkOptions(options);
 912         if (options.contains(StandardOpenOption.WRITE) ||
 913             options.contains(StandardOpenOption.APPEND)) {
 914             checkWritable();
<span class="line-modified"> 915             beginRead();    // only need a read lock, the &quot;update()&quot; will obtain</span>
<span class="line-modified"> 916                             // the write lock when the channel is closed</span>
 917             try {

 918                 Entry e = getEntry(path);
 919                 if (e != null) {
 920                     if (e.isDir() || options.contains(CREATE_NEW))
 921                         throw new FileAlreadyExistsException(getString(path));
 922                     SeekableByteChannel sbc =
<span class="line-modified"> 923                             new EntryOutputChannel(supportPosix ?</span>
<span class="line-added"> 924                                 new PosixEntry((PosixEntry)e, Entry.NEW) :</span>
<span class="line-added"> 925                                 new Entry(e, Entry.NEW));</span>
 926                     if (options.contains(APPEND)) {
 927                         try (InputStream is = getInputStream(e)) {  // copyover
 928                             byte[] buf = new byte[8192];
 929                             ByteBuffer bb = ByteBuffer.wrap(buf);
 930                             int n;
 931                             while ((n = is.read(buf)) != -1) {
 932                                 bb.position(0);
 933                                 bb.limit(n);
 934                                 sbc.write(bb);
 935                             }
 936                         }
 937                     }
 938                     return sbc;
 939                 }
 940                 if (!options.contains(CREATE) &amp;&amp; !options.contains(CREATE_NEW))
 941                     throw new NoSuchFileException(getString(path));
 942                 checkParents(path);
 943                 return new EntryOutputChannel(
<span class="line-modified"> 944                     supportPosix ?</span>
<span class="line-modified"> 945                         new PosixEntry(path, Entry.NEW, false, defaultCompressionMethod, attrs) :</span>
<span class="line-added"> 946                         new Entry(path, Entry.NEW, false, defaultCompressionMethod, attrs));</span>
 947             } finally {
 948                 endRead();
 949             }
 950         } else {
 951             beginRead();
 952             try {
 953                 ensureOpen();
 954                 Entry e = getEntry(path);
 955                 if (e == null || e.isDir())
 956                     throw new NoSuchFileException(getString(path));
 957                 try (InputStream is = getInputStream(e)) {
 958                     // TBD: if (e.size &lt; NNNNN);
 959                     return new ByteArrayChannel(is.readAllBytes(), true);
 960                 }
 961             } finally {
 962                 endRead();
 963             }
 964         }
 965     }
 966 
</pre>
<hr />
<pre>
 990                     }
 991                 } else {
 992                     if (options.contains(StandardOpenOption.CREATE_NEW)) {
 993                         throw new FileAlreadyExistsException(getString(path));
 994                     }
 995                     if (e.isDir())
 996                         throw new FileAlreadyExistsException(&quot;directory &lt;&quot;
 997                             + getString(path) + &quot;&gt; exists&quot;);
 998                 }
 999                 options = new HashSet&lt;&gt;(options);
1000                 options.remove(StandardOpenOption.CREATE_NEW); // for tmpfile
1001             } else if (e == null || e.isDir()) {
1002                 throw new NoSuchFileException(getString(path));
1003             }
1004 
1005             final boolean isFCH = (e != null &amp;&amp; e.type == Entry.FILECH);
1006             final Path tmpfile = isFCH ? e.file : getTempPathForEntry(path);
1007             final FileChannel fch = tmpfile.getFileSystem()
1008                                            .provider()
1009                                            .newFileChannel(tmpfile, options, attrs);
<span class="line-modified">1010             final Entry u = isFCH ? e : (</span>
<span class="line-added">1011                 supportPosix ?</span>
<span class="line-added">1012                 new PosixEntry(path, tmpfile, Entry.FILECH, attrs) :</span>
<span class="line-added">1013                 new Entry(path, tmpfile, Entry.FILECH, attrs));</span>
1014             if (forWrite) {
1015                 u.flag = FLAG_DATADESCR;
<span class="line-modified">1016                 u.method = defaultCompressionMethod;</span>
1017             }
1018             // is there a better way to hook into the FileChannel&#39;s close method?
1019             return new FileChannel() {
1020                 public int write(ByteBuffer src) throws IOException {
1021                     return fch.write(src);
1022                 }
1023                 public long write(ByteBuffer[] srcs, int offset, int length)
1024                     throws IOException
1025                 {
1026                     return fch.write(srcs, offset, length);
1027                 }
1028                 public long position() throws IOException {
1029                     return fch.position();
1030                 }
1031                 public FileChannel position(long newPosition)
1032                     throws IOException
1033                 {
1034                     fch.position(newPosition);
1035                     return this;
1036                 }
</pre>
<hr />
<pre>
1063                 public int read(ByteBuffer dst) throws IOException {
1064                     return fch.read(dst);
1065                 }
1066                 public int read(ByteBuffer dst, long position)
1067                     throws IOException
1068                 {
1069                     return fch.read(dst, position);
1070                 }
1071                 public long read(ByteBuffer[] dsts, int offset, int length)
1072                     throws IOException
1073                 {
1074                     return fch.read(dsts, offset, length);
1075                 }
1076                 public int write(ByteBuffer src, long position)
1077                     throws IOException
1078                     {
1079                    return fch.write(src, position);
1080                 }
1081                 public MappedByteBuffer map(MapMode mode,
1082                                             long position, long size)

1083                 {
1084                     throw new UnsupportedOperationException();
1085                 }
1086                 public FileLock lock(long position, long size, boolean shared)
1087                     throws IOException
1088                 {
1089                     return fch.lock(position, size, shared);
1090                 }
1091                 public FileLock tryLock(long position, long size, boolean shared)
1092                     throws IOException
1093                 {
1094                     return fch.tryLock(position, size, shared);
1095                 }
1096                 protected void implCloseChannel() throws IOException {
1097                     fch.close();
1098                     if (forWrite) {
1099                         u.mtime = System.currentTimeMillis();
1100                         u.size = Files.size(u.file);

1101                         update(u);
1102                     } else {
1103                         if (!isFCH)    // if this is a new fch for reading
1104                             removeTempPathForEntry(tmpfile);
1105                     }
1106                }
1107             };
1108         } finally {
1109             endRead();
1110         }
1111     }
1112 
1113     // the outstanding input streams that need to be closed
1114     private Set&lt;InputStream&gt; streams =
<span class="line-modified">1115         Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
<span class="line-added">1116 </span>
<span class="line-added">1117     // the ex-channel and ex-path that need to close when their outstanding</span>
<span class="line-added">1118     // input streams are all closed by the obtainers.</span>
<span class="line-added">1119     private final Set&lt;ExistingChannelCloser&gt; exChClosers = new HashSet&lt;&gt;();</span>
1120 
<span class="line-modified">1121     private final Set&lt;Path&gt; tmppaths = Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
1122     private Path getTempPathForEntry(byte[] path) throws IOException {
1123         Path tmpPath = createTempFileInSameDirectoryAs(zfpath);
1124         if (path != null) {
1125             Entry e = getEntry(path);
1126             if (e != null) {
1127                 try (InputStream is = newInputStream(path)) {
1128                     Files.copy(is, tmpPath, REPLACE_EXISTING);
1129                 }
1130             }
1131         }
1132         return tmpPath;
1133     }
1134 
1135     private void removeTempPathForEntry(Path path) throws IOException {
1136         Files.delete(path);
1137         tmppaths.remove(path);
1138     }
1139 
<span class="line-modified">1140     // check if all parents really exist. ZIP spec does not require</span>
1141     // the existence of any &quot;parent directory&quot;.
1142     private void checkParents(byte[] path) throws IOException {
1143         beginRead();
1144         try {
1145             while ((path = getParent(path)) != null &amp;&amp;
1146                     path != ROOTPATH) {
1147                 if (!inodes.containsKey(IndexNode.keyOf(path))) {
1148                     throw new NoSuchFileException(getString(path));
1149                 }
1150             }
1151         } finally {
1152             endRead();
1153         }
1154     }
1155 

1156     private static byte[] getParent(byte[] path) {
1157         int off = getParentOff(path);
1158         if (off &lt;= 1)
1159             return ROOTPATH;
1160         return Arrays.copyOf(path, off);
1161     }
1162 
1163     private static int getParentOff(byte[] path) {
1164         int off = path.length - 1;
1165         if (off &gt; 0 &amp;&amp; path[off] == &#39;/&#39;)  // isDirectory
1166             off--;
1167         while (off &gt; 0 &amp;&amp; path[off] != &#39;/&#39;) { off--; }
1168         return off;
1169     }
1170 
<span class="line-modified">1171     private void beginWrite() {</span>
1172         rwlock.writeLock().lock();
1173     }
1174 
<span class="line-modified">1175     private void endWrite() {</span>
1176         rwlock.writeLock().unlock();
1177     }
1178 
<span class="line-modified">1179     private void beginRead() {</span>
1180         rwlock.readLock().lock();
1181     }
1182 
<span class="line-modified">1183     private void endRead() {</span>
1184         rwlock.readLock().unlock();
1185     }
1186 
1187     ///////////////////////////////////////////////////////////////////
1188 
1189     private volatile boolean isOpen = true;
1190     private final SeekableByteChannel ch; // channel to the zipfile
1191     final byte[]  cen;     // CEN &amp; ENDHDR
1192     private END  end;
1193     private long locpos;   // position of first LOC header (usually 0)
1194 
1195     private final ReadWriteLock rwlock = new ReentrantReadWriteLock();
1196 
1197     // name -&gt; pos (in cen), IndexNode itself can be used as a &quot;key&quot;
1198     private LinkedHashMap&lt;IndexNode, IndexNode&gt; inodes;
1199 
1200     final byte[] getBytes(String name) {
1201         return zc.getBytes(name);
1202     }
1203 
</pre>
<hr />
<pre>
1205         return zc.toString(name);
1206     }
1207 
1208     @SuppressWarnings(&quot;deprecation&quot;)
1209     protected void finalize() throws IOException {
1210         close();
1211     }
1212 
1213     // Reads len bytes of data from the specified offset into buf.
1214     // Returns the total number of bytes read.
1215     // Each/every byte read from here (except the cen, which is mapped).
1216     final long readFullyAt(byte[] buf, int off, long len, long pos)
1217         throws IOException
1218     {
1219         ByteBuffer bb = ByteBuffer.wrap(buf);
1220         bb.position(off);
1221         bb.limit((int)(off + len));
1222         return readFullyAt(bb, pos);
1223     }
1224 
<span class="line-modified">1225     private long readFullyAt(ByteBuffer bb, long pos) throws IOException {</span>


1226         synchronized(ch) {
1227             return ch.position(pos).read(bb);
1228         }
1229     }
1230 
1231     // Searches for end of central directory (END) header. The contents of
1232     // the END header will be read and placed in endbuf. Returns the file
1233     // position of the END header, otherwise returns -1 if the END header
1234     // was not found or an error occurred.
<span class="line-modified">1235     private END findEND() throws IOException {</span>

1236         byte[] buf = new byte[READBLOCKSZ];
1237         long ziplen = ch.size();
1238         long minHDR = (ziplen - END_MAXLEN) &gt; 0 ? ziplen - END_MAXLEN : 0;
1239         long minPos = minHDR - (buf.length - ENDHDR);
1240 
<span class="line-modified">1241         for (long pos = ziplen - buf.length; pos &gt;= minPos; pos -= (buf.length - ENDHDR)) {</span>

1242             int off = 0;
1243             if (pos &lt; 0) {
1244                 // Pretend there are some NUL bytes before start of file
1245                 off = (int)-pos;
1246                 Arrays.fill(buf, 0, off, (byte)0);
1247             }
1248             int len = buf.length - off;
1249             if (readFullyAt(buf, off, len, pos + off) != len)
<span class="line-modified">1250                 throw new ZipException(&quot;zip END header not found&quot;);</span>
1251 
1252             // Now scan the block backwards for END header signature
1253             for (int i = buf.length - ENDHDR; i &gt;= 0; i--) {
<span class="line-modified">1254                 if (buf[i]   == (byte)&#39;P&#39;    &amp;&amp;</span>
1255                     buf[i+1] == (byte)&#39;K&#39;    &amp;&amp;
1256                     buf[i+2] == (byte)&#39;\005&#39; &amp;&amp;
1257                     buf[i+3] == (byte)&#39;\006&#39; &amp;&amp;
1258                     (pos + i + ENDHDR + ENDCOM(buf, i) == ziplen)) {
1259                     // Found END header
1260                     buf = Arrays.copyOfRange(buf, i, i + ENDHDR);
1261                     END end = new END();
<span class="line-modified">1262                     // end.endsub = ENDSUB(buf); // not used</span>
1263                     end.centot = ENDTOT(buf);
1264                     end.cenlen = ENDSIZ(buf);
1265                     end.cenoff = ENDOFF(buf);
<span class="line-modified">1266                     // end.comlen = ENDCOM(buf); // not used</span>
1267                     end.endpos = pos + i;
1268                     // try if there is zip64 end;
1269                     byte[] loc64 = new byte[ZIP64_LOCHDR];
1270                     if (end.endpos &lt; ZIP64_LOCHDR ||
1271                         readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)
1272                         != loc64.length ||
1273                         !locator64SigAt(loc64, 0)) {
1274                         return end;
1275                     }
1276                     long end64pos = ZIP64_LOCOFF(loc64);
1277                     byte[] end64buf = new byte[ZIP64_ENDHDR];
1278                     if (readFullyAt(end64buf, 0, end64buf.length, end64pos)
1279                         != end64buf.length ||
1280                         !end64SigAt(end64buf, 0)) {
1281                         return end;
1282                     }
1283                     // end64 found,
1284                     long cenlen64 = ZIP64_ENDSIZ(end64buf);
1285                     long cenoff64 = ZIP64_ENDOFF(end64buf);
1286                     long centot64 = ZIP64_ENDTOT(end64buf);
1287                     // double-check
1288                     if (cenlen64 != end.cenlen &amp;&amp; end.cenlen != ZIP64_MINVAL ||
1289                         cenoff64 != end.cenoff &amp;&amp; end.cenoff != ZIP64_MINVAL ||
1290                         centot64 != end.centot &amp;&amp; end.centot != ZIP64_MINVAL32) {
1291                         return end;
1292                     }
1293                     // to use the end64 values
1294                     end.cenlen = cenlen64;
1295                     end.cenoff = cenoff64;
1296                     end.centot = (int)centot64; // assume total &lt; 2g
1297                     end.endpos = end64pos;
1298                     return end;
1299                 }
1300             }
1301         }
<span class="line-modified">1302         throw new ZipException(&quot;zip END header not found&quot;);</span>
<span class="line-modified">1303     }</span>
<span class="line-added">1304 </span>
<span class="line-added">1305     private void makeParentDirs(IndexNode node, IndexNode root) {</span>
<span class="line-added">1306         IndexNode parent;</span>
<span class="line-added">1307         ParentLookup lookup = new ParentLookup();</span>
<span class="line-added">1308         while (true) {</span>
<span class="line-added">1309             int off = getParentOff(node.name);</span>
<span class="line-added">1310             // parent is root</span>
<span class="line-added">1311             if (off &lt;= 1) {</span>
<span class="line-added">1312                 node.sibling = root.child;</span>
<span class="line-added">1313                 root.child = node;</span>
<span class="line-added">1314                 break;</span>
<span class="line-added">1315             }</span>
<span class="line-added">1316             // parent exists</span>
<span class="line-added">1317             lookup = lookup.as(node.name, off);</span>
<span class="line-added">1318             if (inodes.containsKey(lookup)) {</span>
<span class="line-added">1319                 parent = inodes.get(lookup);</span>
<span class="line-added">1320                 node.sibling = parent.child;</span>
<span class="line-added">1321                 parent.child = node;</span>
<span class="line-added">1322                 break;</span>
<span class="line-added">1323             }</span>
<span class="line-added">1324             // parent does not exist, add new pseudo directory entry</span>
<span class="line-added">1325             parent = new IndexNode(Arrays.copyOf(node.name, off), true);</span>
<span class="line-added">1326             inodes.put(parent, parent);</span>
<span class="line-added">1327             node.sibling = parent.child;</span>
<span class="line-added">1328             parent.child = node;</span>
<span class="line-added">1329             node = parent;</span>
<span class="line-added">1330         }</span>
<span class="line-added">1331     }</span>
<span class="line-added">1332 </span>
<span class="line-added">1333     // ZIP directory has two issues:</span>
<span class="line-added">1334     // (1) ZIP spec does not require the ZIP file to include</span>
<span class="line-added">1335     //     directory entry</span>
<span class="line-added">1336     // (2) all entries are not stored/organized in a &quot;tree&quot;</span>
<span class="line-added">1337     //     structure.</span>
<span class="line-added">1338     // A possible solution is to build the node tree ourself as</span>
<span class="line-added">1339     // implemented below.</span>
<span class="line-added">1340     private void buildNodeTree() {</span>
<span class="line-added">1341         beginWrite();</span>
<span class="line-added">1342         try {</span>
<span class="line-added">1343             IndexNode root = inodes.remove(LOOKUPKEY.as(ROOTPATH));</span>
<span class="line-added">1344             if (root == null) {</span>
<span class="line-added">1345                 root = new IndexNode(ROOTPATH, true);</span>
<span class="line-added">1346             }</span>
<span class="line-added">1347             IndexNode[] nodes = inodes.values().toArray(new IndexNode[0]);</span>
<span class="line-added">1348             inodes.put(root, root);</span>
<span class="line-added">1349             for (IndexNode node : nodes) {</span>
<span class="line-added">1350                 makeParentDirs(node, root);</span>
<span class="line-added">1351             }</span>
<span class="line-added">1352         } finally {</span>
<span class="line-added">1353             endWrite();</span>
<span class="line-added">1354         }</span>
<span class="line-added">1355     }</span>
<span class="line-added">1356 </span>
<span class="line-added">1357     private void removeFromTree(IndexNode inode) {</span>
<span class="line-added">1358         IndexNode parent = inodes.get(LOOKUPKEY.as(getParent(inode.name)));</span>
<span class="line-added">1359         IndexNode child = parent.child;</span>
<span class="line-added">1360         if (child.equals(inode)) {</span>
<span class="line-added">1361             parent.child = child.sibling;</span>
<span class="line-added">1362         } else {</span>
<span class="line-added">1363             IndexNode last = child;</span>
<span class="line-added">1364             while ((child = child.sibling) != null) {</span>
<span class="line-added">1365                 if (child.equals(inode)) {</span>
<span class="line-added">1366                     last.sibling = child.sibling;</span>
<span class="line-added">1367                     break;</span>
<span class="line-added">1368                 } else {</span>
<span class="line-added">1369                     last = child;</span>
<span class="line-added">1370                 }</span>
<span class="line-added">1371             }</span>
<span class="line-added">1372         }</span>
<span class="line-added">1373     }</span>
<span class="line-added">1374 </span>
<span class="line-added">1375     /**</span>
<span class="line-added">1376      * If a version property has been specified and the file represents a multi-release JAR,</span>
<span class="line-added">1377      * determine the requested runtime version and initialize the ZipFileSystem instance accordingly.</span>
<span class="line-added">1378      *</span>
<span class="line-added">1379      * Checks if the Zip File System property &quot;releaseVersion&quot; has been specified. If it has,</span>
<span class="line-added">1380      * use its value to determine the requested version. If not use the value of the &quot;multi-release&quot; property.</span>
<span class="line-added">1381      */</span>
<span class="line-added">1382     private void initializeReleaseVersion(Map&lt;String, ?&gt; env) throws IOException {</span>
<span class="line-added">1383         Object o = env.containsKey(PROPERTY_RELEASE_VERSION) ?</span>
<span class="line-added">1384             env.get(PROPERTY_RELEASE_VERSION) :</span>
<span class="line-added">1385             env.get(PROPERTY_MULTI_RELEASE);</span>
<span class="line-added">1386 </span>
<span class="line-added">1387         if (o != null &amp;&amp; isMultiReleaseJar()) {</span>
<span class="line-added">1388             int version;</span>
<span class="line-added">1389             if (o instanceof String) {</span>
<span class="line-added">1390                 String s = (String)o;</span>
<span class="line-added">1391                 if (s.equals(&quot;runtime&quot;)) {</span>
<span class="line-added">1392                     version = Runtime.version().feature();</span>
<span class="line-added">1393                 } else if (s.matches(&quot;^[1-9][0-9]*$&quot;)) {</span>
<span class="line-added">1394                     version = Version.parse(s).feature();</span>
<span class="line-added">1395                 } else {</span>
<span class="line-added">1396                     throw new IllegalArgumentException(&quot;Invalid runtime version&quot;);</span>
<span class="line-added">1397                 }</span>
<span class="line-added">1398             } else if (o instanceof Integer) {</span>
<span class="line-added">1399                 version = Version.parse(((Integer)o).toString()).feature();</span>
<span class="line-added">1400             } else if (o instanceof Version) {</span>
<span class="line-added">1401                 version = ((Version)o).feature();</span>
<span class="line-added">1402             } else {</span>
<span class="line-added">1403                 throw new IllegalArgumentException(&quot;env parameter must be String, &quot; +</span>
<span class="line-added">1404                     &quot;Integer, or Version&quot;);</span>
<span class="line-added">1405             }</span>
<span class="line-added">1406             createVersionedLinks(version &lt; 0 ? 0 : version);</span>
<span class="line-added">1407             setReadOnly();</span>
<span class="line-added">1408         }</span>
<span class="line-added">1409     }</span>
<span class="line-added">1410 </span>
<span class="line-added">1411     /**</span>
<span class="line-added">1412      * Returns true if the Manifest main attribute &quot;Multi-Release&quot; is set to true; false otherwise.</span>
<span class="line-added">1413      */</span>
<span class="line-added">1414     private boolean isMultiReleaseJar() throws IOException {</span>
<span class="line-added">1415         try (InputStream is = newInputStream(getBytes(&quot;/META-INF/MANIFEST.MF&quot;))) {</span>
<span class="line-added">1416             String multiRelease = new Manifest(is).getMainAttributes()</span>
<span class="line-added">1417                 .getValue(Attributes.Name.MULTI_RELEASE);</span>
<span class="line-added">1418             return &quot;true&quot;.equalsIgnoreCase(multiRelease);</span>
<span class="line-added">1419         } catch (NoSuchFileException x) {</span>
<span class="line-added">1420             return false;</span>
<span class="line-added">1421         }</span>
<span class="line-added">1422     }</span>
<span class="line-added">1423 </span>
<span class="line-added">1424     /**</span>
<span class="line-added">1425      * Create a map of aliases for versioned entries, for example:</span>
<span class="line-added">1426      *   version/PackagePrivate.class -&gt; META-INF/versions/9/version/PackagePrivate.class</span>
<span class="line-added">1427      *   version/PackagePrivate.java -&gt; META-INF/versions/9/version/PackagePrivate.java</span>
<span class="line-added">1428      *   version/Version.class -&gt; META-INF/versions/10/version/Version.class</span>
<span class="line-added">1429      *   version/Version.java -&gt; META-INF/versions/10/version/Version.java</span>
<span class="line-added">1430      *</span>
<span class="line-added">1431      * Then wrap the map in a function that getEntry can use to override root</span>
<span class="line-added">1432      * entry lookup for entries that have corresponding versioned entries.</span>
<span class="line-added">1433      */</span>
<span class="line-added">1434     private void createVersionedLinks(int version) {</span>
<span class="line-added">1435         IndexNode verdir = getInode(getBytes(&quot;/META-INF/versions&quot;));</span>
<span class="line-added">1436         // nothing to do, if no /META-INF/versions</span>
<span class="line-added">1437         if (verdir == null) {</span>
<span class="line-added">1438             return;</span>
<span class="line-added">1439         }</span>
<span class="line-added">1440         // otherwise, create a map and for each META-INF/versions/{n} directory</span>
<span class="line-added">1441         // put all the leaf inodes, i.e. entries, into the alias map</span>
<span class="line-added">1442         // possibly shadowing lower versioned entries</span>
<span class="line-added">1443         HashMap&lt;IndexNode, byte[]&gt; aliasMap = new HashMap&lt;&gt;();</span>
<span class="line-added">1444         getVersionMap(version, verdir).values().forEach(versionNode -&gt;</span>
<span class="line-added">1445             walk(versionNode.child, entryNode -&gt;</span>
<span class="line-added">1446                 aliasMap.put(</span>
<span class="line-added">1447                     getOrCreateInode(getRootName(entryNode, versionNode), entryNode.isdir),</span>
<span class="line-added">1448                     entryNode.name))</span>
<span class="line-added">1449         );</span>
<span class="line-added">1450         entryLookup = path -&gt; {</span>
<span class="line-added">1451             byte[] entry = aliasMap.get(IndexNode.keyOf(path));</span>
<span class="line-added">1452             return entry == null ? path : entry;</span>
<span class="line-added">1453         };</span>
<span class="line-added">1454     }</span>
<span class="line-added">1455 </span>
<span class="line-added">1456     /**</span>
<span class="line-added">1457      * Create a sorted version map of version -&gt; inode, for inodes &lt;= max version.</span>
<span class="line-added">1458      *   9 -&gt; META-INF/versions/9</span>
<span class="line-added">1459      *  10 -&gt; META-INF/versions/10</span>
<span class="line-added">1460      */</span>
<span class="line-added">1461     private TreeMap&lt;Integer, IndexNode&gt; getVersionMap(int version, IndexNode metaInfVersions) {</span>
<span class="line-added">1462         TreeMap&lt;Integer,IndexNode&gt; map = new TreeMap&lt;&gt;();</span>
<span class="line-added">1463         IndexNode child = metaInfVersions.child;</span>
<span class="line-added">1464         while (child != null) {</span>
<span class="line-added">1465             Integer key = getVersion(child, metaInfVersions);</span>
<span class="line-added">1466             if (key != null &amp;&amp; key &lt;= version) {</span>
<span class="line-added">1467                 map.put(key, child);</span>
<span class="line-added">1468             }</span>
<span class="line-added">1469             child = child.sibling;</span>
<span class="line-added">1470         }</span>
<span class="line-added">1471         return map;</span>
<span class="line-added">1472     }</span>
<span class="line-added">1473 </span>
<span class="line-added">1474     /**</span>
<span class="line-added">1475      * Extract the integer version number -- META-INF/versions/9 returns 9.</span>
<span class="line-added">1476      */</span>
<span class="line-added">1477     private Integer getVersion(IndexNode inode, IndexNode metaInfVersions) {</span>
<span class="line-added">1478         try {</span>
<span class="line-added">1479             byte[] fullName = inode.name;</span>
<span class="line-added">1480             return Integer.parseInt(getString(Arrays</span>
<span class="line-added">1481                 .copyOfRange(fullName, metaInfVersions.name.length + 1, fullName.length)));</span>
<span class="line-added">1482         } catch (NumberFormatException x) {</span>
<span class="line-added">1483             // ignore this even though it might indicate issues with the JAR structure</span>
<span class="line-added">1484             return null;</span>
<span class="line-added">1485         }</span>
<span class="line-added">1486     }</span>
<span class="line-added">1487 </span>
<span class="line-added">1488     /**</span>
<span class="line-added">1489      * Walk the IndexNode tree processing all leaf nodes.</span>
<span class="line-added">1490      */</span>
<span class="line-added">1491     private void walk(IndexNode inode, Consumer&lt;IndexNode&gt; consumer) {</span>
<span class="line-added">1492         if (inode == null) return;</span>
<span class="line-added">1493         if (inode.isDir()) {</span>
<span class="line-added">1494             walk(inode.child, consumer);</span>
<span class="line-added">1495         } else {</span>
<span class="line-added">1496             consumer.accept(inode);</span>
<span class="line-added">1497         }</span>
<span class="line-added">1498         walk(inode.sibling, consumer);</span>
<span class="line-added">1499     }</span>
<span class="line-added">1500 </span>
<span class="line-added">1501     /**</span>
<span class="line-added">1502      * Extract the root name from a versioned entry name.</span>
<span class="line-added">1503      * E.g. given inode &#39;META-INF/versions/9/foo/bar.class&#39;</span>
<span class="line-added">1504      * and prefix &#39;META-INF/versions/9/&#39; returns &#39;foo/bar.class&#39;.</span>
<span class="line-added">1505      */</span>
<span class="line-added">1506     private byte[] getRootName(IndexNode inode, IndexNode prefix) {</span>
<span class="line-added">1507         byte[] fullName = inode.name;</span>
<span class="line-added">1508         return Arrays.copyOfRange(fullName, prefix.name.length, fullName.length);</span>
1509     }
1510 
1511     // Reads zip file central directory. Returns the file position of first
1512     // CEN header, otherwise returns -1 if an error occurred. If zip-&gt;msg != NULL
1513     // then the error was a zip format error and zip-&gt;msg has the error text.
1514     // Always pass in -1 for knownTotal; it&#39;s used for a recursive call.
1515     private byte[] initCEN() throws IOException {
1516         end = findEND();
1517         if (end.endpos == 0) {
1518             inodes = new LinkedHashMap&lt;&gt;(10);
1519             locpos = 0;
1520             buildNodeTree();
1521             return null;         // only END header present
1522         }
1523         if (end.cenlen &gt; end.endpos)
<span class="line-modified">1524             throw new ZipException(&quot;invalid END header (bad central directory size)&quot;);</span>
1525         long cenpos = end.endpos - end.cenlen;     // position of CEN table
1526 
1527         // Get position of first local file (LOC) header, taking into
1528         // account that there may be a stub prefixed to the zip file.
1529         locpos = cenpos - end.cenoff;
1530         if (locpos &lt; 0)
<span class="line-modified">1531             throw new ZipException(&quot;invalid END header (bad central directory offset)&quot;);</span>
1532 
1533         // read in the CEN and END
1534         byte[] cen = new byte[(int)(end.cenlen + ENDHDR)];
1535         if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
<span class="line-modified">1536             throw new ZipException(&quot;read CEN tables failed&quot;);</span>
1537         }
1538         // Iterate through the entries in the central directory
1539         inodes = new LinkedHashMap&lt;&gt;(end.centot + 1);
1540         int pos = 0;
1541         int limit = cen.length - ENDHDR;
1542         while (pos &lt; limit) {
1543             if (!cenSigAt(cen, pos))
<span class="line-modified">1544                 throw new ZipException(&quot;invalid CEN header (bad signature)&quot;);</span>
1545             int method = CENHOW(cen, pos);
1546             int nlen   = CENNAM(cen, pos);
1547             int elen   = CENEXT(cen, pos);
1548             int clen   = CENCOM(cen, pos);
1549             if ((CENFLG(cen, pos) &amp; 1) != 0) {
<span class="line-modified">1550                 throw new ZipException(&quot;invalid CEN header (encrypted entry)&quot;);</span>
1551             }
1552             if (method != METHOD_STORED &amp;&amp; method != METHOD_DEFLATED) {
<span class="line-modified">1553                 throw new ZipException(&quot;invalid CEN header (unsupported compression method: &quot; + method + &quot;)&quot;);</span>
1554             }
1555             if (pos + CENHDR + nlen &gt; limit) {
<span class="line-modified">1556                 throw new ZipException(&quot;invalid CEN header (bad header size)&quot;);</span>
1557             }
1558             IndexNode inode = new IndexNode(cen, pos, nlen);
1559             inodes.put(inode, inode);
1560 
1561             // skip ext and comment
1562             pos += (CENHDR + nlen + elen + clen);
1563         }
1564         if (pos + ENDHDR != cen.length) {
<span class="line-modified">1565             throw new ZipException(&quot;invalid CEN header (bad header size)&quot;);</span>
1566         }
1567         buildNodeTree();
1568         return cen;
1569     }
1570 
<span class="line-modified">1571     private void ensureOpen() {</span>
1572         if (!isOpen)
1573             throw new ClosedFileSystemException();
1574     }
1575 
1576     // Creates a new empty temporary file in the same directory as the
1577     // specified file.  A variant of Files.createTempFile.
<span class="line-modified">1578     private Path createTempFileInSameDirectoryAs(Path path) throws IOException {</span>


1579         Path parent = path.toAbsolutePath().getParent();
1580         Path dir = (parent == null) ? path.getFileSystem().getPath(&quot;.&quot;) : parent;
1581         Path tmpPath = Files.createTempFile(dir, &quot;zipfstmp&quot;, null);
1582         tmppaths.add(tmpPath);
1583         return tmpPath;
1584     }
1585 
1586     ////////////////////update &amp; sync //////////////////////////////////////
1587 
1588     private boolean hasUpdate = false;
1589 
1590     // shared key. consumer guarantees the &quot;writeLock&quot; before use it.
1591     private final IndexNode LOOKUPKEY = new IndexNode(null, -1);
1592 
1593     private void updateDelete(IndexNode inode) {
1594         beginWrite();
1595         try {
1596             removeFromTree(inode);
1597             inodes.remove(inode);
1598             hasUpdate = true;
</pre>
<hr />
<pre>
1655             os.write(buf, 0, LOCHDR);    // write out the loc header
1656             locoff += LOCHDR;
1657             // use e.csize,  LOCSIZ(buf) is zero if FLAG_DATADESCR is on
1658             // size += LOCNAM(buf) + LOCEXT(buf) + LOCSIZ(buf);
1659             size += LOCNAM(buf) + LOCEXT(buf) + e.csize;
1660             written = LOCHDR + size;
1661         }
1662         int n;
1663         while (size &gt; 0 &amp;&amp;
1664             (n = (int)readFullyAt(buf, 0, buf.length, locoff)) != -1)
1665         {
1666             if (size &lt; n)
1667                 n = (int)size;
1668             os.write(buf, 0, n);
1669             size -= n;
1670             locoff += n;
1671         }
1672         return written;
1673     }
1674 
<span class="line-modified">1675     private long writeEntry(Entry e, OutputStream os)</span>
1676         throws IOException {
1677 
1678         if (e.bytes == null &amp;&amp; e.file == null)    // dir, 0-length data
1679             return 0;
1680 
1681         long written = 0;
<span class="line-modified">1682         if (e.method != METHOD_STORED &amp;&amp; e.csize &gt; 0 &amp;&amp; (e.crc != 0 || e.size == 0)) {</span>
<span class="line-modified">1683             // pre-compressed entry, write directly to output stream</span>
<span class="line-modified">1684             writeTo(e, os);</span>
<span class="line-modified">1685         } else {</span>
<span class="line-modified">1686             try (OutputStream os2 = (e.method == METHOD_STORED) ?</span>
<span class="line-modified">1687                     new EntryOutputStreamCRC32(e, os) : new EntryOutputStreamDef(e, os)) {</span>
<span class="line-modified">1688                 writeTo(e, os2);</span>





1689             }
1690         }
1691         written += e.csize;
1692         if ((e.flag &amp; FLAG_DATADESCR) != 0) {
1693             written += e.writeEXT(os);
1694         }
1695         return written;
1696     }
1697 
<span class="line-modified">1698     private void writeTo(Entry e, OutputStream os) throws IOException {</span>
<span class="line-modified">1699         if (e.bytes != null) {</span>
<span class="line-added">1700             os.write(e.bytes, 0, e.bytes.length);</span>
<span class="line-added">1701         } else if (e.file != null) {</span>
<span class="line-added">1702             if (e.type == Entry.NEW || e.type == Entry.FILECH) {</span>
<span class="line-added">1703                 try (InputStream is = Files.newInputStream(e.file)) {</span>
<span class="line-added">1704                     is.transferTo(os);</span>
<span class="line-added">1705                 }</span>
<span class="line-added">1706             }</span>
<span class="line-added">1707             Files.delete(e.file);</span>
<span class="line-added">1708             tmppaths.remove(e.file);</span>
<span class="line-added">1709         }</span>
<span class="line-added">1710     }</span>
1711 
<span class="line-added">1712     // sync the zip file system, if there is any update</span>
<span class="line-added">1713     private void sync() throws IOException {</span>
<span class="line-added">1714         // check ex-closer</span>
<span class="line-added">1715         if (!exChClosers.isEmpty()) {</span>
<span class="line-added">1716             for (ExistingChannelCloser ecc : exChClosers) {</span>
<span class="line-added">1717                 if (ecc.closeAndDeleteIfDone()) {</span>
<span class="line-added">1718                     exChClosers.remove(ecc);</span>
<span class="line-added">1719                 }</span>
<span class="line-added">1720             }</span>
<span class="line-added">1721         }</span>
1722         if (!hasUpdate)
1723             return;
<span class="line-added">1724         PosixFileAttributes attrs = getPosixAttributes(zfpath);</span>
1725         Path tmpFile = createTempFileInSameDirectoryAs(zfpath);
<span class="line-modified">1726         try (OutputStream os = new BufferedOutputStream(Files.newOutputStream(tmpFile, WRITE))) {</span>

1727             ArrayList&lt;Entry&gt; elist = new ArrayList&lt;&gt;(inodes.size());
1728             long written = 0;
<span class="line-modified">1729             byte[] buf = null;</span>
<span class="line-modified">1730             Entry e;</span>
1731 
1732             // write loc
1733             for (IndexNode inode : inodes.values()) {
1734                 if (inode instanceof Entry) {    // an updated inode
1735                     e = (Entry)inode;
1736                     try {
1737                         if (e.type == Entry.COPY) {
1738                             // entry copy: the only thing changed is the &quot;name&quot;
<span class="line-modified">1739                             // and &quot;nlen&quot; in LOC header, so we update/rewrite the</span>
1740                             // LOC in new file and simply copy the rest (data and
1741                             // ext) without enflating/deflating from the old zip
1742                             // file LOC entry.
<span class="line-added">1743                             if (buf == null)</span>
<span class="line-added">1744                                 buf = new byte[8192];</span>
1745                             written += copyLOCEntry(e, true, os, written, buf);
1746                         } else {                          // NEW, FILECH or CEN
1747                             e.locoff = written;
1748                             written += e.writeLOC(os);    // write loc header
<span class="line-modified">1749                             written += writeEntry(e, os);</span>
1750                         }
1751                         elist.add(e);
1752                     } catch (IOException x) {
1753                         x.printStackTrace();    // skip any in-accurate entry
1754                     }
1755                 } else {                        // unchanged inode
1756                     if (inode.pos == -1) {
1757                         continue;               // pseudo directory node
1758                     }
1759                     if (inode.name.length == 1 &amp;&amp; inode.name[0] == &#39;/&#39;) {
<span class="line-modified">1760                         continue;               // no root &#39;/&#39; directory even if it</span>
<span class="line-modified">1761                                                 // exists in original zip/jar file.</span>
1762                     }
<span class="line-modified">1763                     e = supportPosix ? new PosixEntry(this, inode) : new Entry(this, inode);</span>
1764                     try {
<span class="line-added">1765                         if (buf == null)</span>
<span class="line-added">1766                             buf = new byte[8192];</span>
1767                         written += copyLOCEntry(e, false, os, written, buf);
1768                         elist.add(e);
1769                     } catch (IOException x) {
1770                         x.printStackTrace();    // skip any wrong entry
1771                     }
1772                 }
1773             }
1774 
1775             // now write back the cen and end table
1776             end.cenoff = written;
1777             for (Entry entry : elist) {
1778                 written += entry.writeCEN(os);
1779             }
1780             end.centot = elist.size();
1781             end.cenlen = written - end.cenoff;
1782             end.write(os, written, forceEnd64);
1783         }
<span class="line-added">1784         if (!streams.isEmpty()) {</span>
<span class="line-added">1785             //</span>
<span class="line-added">1786             // There are outstanding input streams open on existing &quot;ch&quot;,</span>
<span class="line-added">1787             // so, don&#39;t close the &quot;cha&quot; and delete the &quot;file for now, let</span>
<span class="line-added">1788             // the &quot;ex-channel-closer&quot; to handle them</span>
<span class="line-added">1789             Path path = createTempFileInSameDirectoryAs(zfpath);</span>
<span class="line-added">1790             ExistingChannelCloser ecc = new ExistingChannelCloser(path,</span>
<span class="line-added">1791                                                                   ch,</span>
<span class="line-added">1792                                                                   streams);</span>
<span class="line-added">1793             Files.move(zfpath, path, REPLACE_EXISTING);</span>
<span class="line-added">1794             exChClosers.add(ecc);</span>
<span class="line-added">1795             streams = Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
<span class="line-added">1796         } else {</span>
<span class="line-added">1797             ch.close();</span>
<span class="line-added">1798             Files.delete(zfpath);</span>
<span class="line-added">1799         }</span>
1800 
<span class="line-modified">1801         // Set the POSIX permissions of the original Zip File if available</span>
<span class="line-modified">1802         // before moving the temp file</span>
<span class="line-added">1803         if (attrs != null) {</span>
<span class="line-added">1804             Files.setPosixFilePermissions(tmpFile, attrs.permissions());</span>
<span class="line-added">1805         }</span>
1806         Files.move(tmpFile, zfpath, REPLACE_EXISTING);
1807         hasUpdate = false;    // clear
1808     }
1809 
<span class="line-modified">1810     /**</span>
<span class="line-modified">1811      * Returns a file&#39;s POSIX file attributes.</span>
<span class="line-modified">1812      * @param path The path to the file</span>
<span class="line-modified">1813      * @return The POSIX file attributes for the specified file or</span>
<span class="line-added">1814      *         null if the POSIX attribute view is not available</span>
<span class="line-added">1815      * @throws IOException If an error occurs obtaining the POSIX attributes for</span>
<span class="line-added">1816      *                    the specified file</span>
<span class="line-added">1817      */</span>
<span class="line-added">1818     private PosixFileAttributes getPosixAttributes(Path path) throws IOException {</span>
<span class="line-added">1819         try {</span>
<span class="line-added">1820             PosixFileAttributeView view =</span>
<span class="line-added">1821                     Files.getFileAttributeView(path, PosixFileAttributeView.class);</span>
<span class="line-added">1822             // Return if the attribute view is not supported</span>
<span class="line-added">1823             if (view == null) {</span>
<span class="line-added">1824                 return null;</span>
<span class="line-added">1825             }</span>
<span class="line-added">1826             return view.readAttributes();</span>
<span class="line-added">1827         } catch (UnsupportedOperationException e) {</span>
<span class="line-added">1828             // PosixFileAttributes not available</span>
<span class="line-added">1829             return null;</span>
<span class="line-added">1830         }</span>
<span class="line-added">1831     }</span>
<span class="line-added">1832 </span>
<span class="line-added">1833     private IndexNode getInode(byte[] path) {</span>
<span class="line-added">1834         return inodes.get(IndexNode.keyOf(Objects.requireNonNull(entryLookup.apply(path), &quot;path&quot;)));</span>
<span class="line-added">1835     }</span>
<span class="line-added">1836 </span>
<span class="line-added">1837     /**</span>
<span class="line-added">1838      * Return the IndexNode from the root tree. If it doesn&#39;t exist,</span>
<span class="line-added">1839      * it gets created along with all parent directory IndexNodes.</span>
<span class="line-added">1840      */</span>
<span class="line-added">1841     private IndexNode getOrCreateInode(byte[] path, boolean isdir) {</span>
<span class="line-added">1842         IndexNode node = getInode(path);</span>
<span class="line-added">1843         // if node exists, return it</span>
<span class="line-added">1844         if (node != null) {</span>
<span class="line-added">1845             return node;</span>
<span class="line-added">1846         }</span>
<span class="line-added">1847 </span>
<span class="line-added">1848         // otherwise create new pseudo node and parent directory hierarchy</span>
<span class="line-added">1849         node = new IndexNode(path, isdir);</span>
<span class="line-added">1850         beginWrite();</span>
<span class="line-added">1851         try {</span>
<span class="line-added">1852             makeParentDirs(node, Objects.requireNonNull(inodes.get(IndexNode.keyOf(ROOTPATH)), &quot;no root node found&quot;));</span>
<span class="line-added">1853             return node;</span>
<span class="line-added">1854         } finally {</span>
<span class="line-added">1855             endWrite();</span>
<span class="line-added">1856         }</span>
1857     }
1858 
<span class="line-modified">1859     private Entry getEntry(byte[] path) throws IOException {</span>
1860         IndexNode inode = getInode(path);
1861         if (inode instanceof Entry)
1862             return (Entry)inode;
1863         if (inode == null || inode.pos == -1)
1864             return null;
<span class="line-modified">1865         return supportPosix ? new PosixEntry(this, inode): new Entry(this, inode);</span>
1866     }
1867 
1868     public void deleteFile(byte[] path, boolean failIfNotExists)
1869         throws IOException
1870     {
1871         checkWritable();

1872         IndexNode inode = getInode(path);
1873         if (inode == null) {
1874             if (path != null &amp;&amp; path.length == 0)
1875                 throw new ZipException(&quot;root directory &lt;/&gt; can&#39;t not be delete&quot;);
1876             if (failIfNotExists)
1877                 throw new NoSuchFileException(getString(path));
1878         } else {
1879             if (inode.isDir() &amp;&amp; inode.child != null)
1880                 throw new DirectoryNotEmptyException(getString(path));
1881             updateDelete(inode);
1882         }
1883     }
1884 
1885     // Returns an out stream for either
<span class="line-modified">1886     // (1) writing the contents of a new entry, if the entry exists, or</span>
1887     // (2) updating/replacing the contents of the specified existing entry.
1888     private OutputStream getOutputStream(Entry e) throws IOException {

1889         if (e.mtime == -1)
1890             e.mtime = System.currentTimeMillis();
1891         if (e.method == -1)
<span class="line-modified">1892             e.method = defaultCompressionMethod;</span>
1893         // store size, compressed size, and crc-32 in datadescr
1894         e.flag = FLAG_DATADESCR;
1895         if (zc.isUTF8())
1896             e.flag |= FLAG_USE_UTF8;
1897         OutputStream os;
1898         if (useTempFile) {
1899             e.file = getTempPathForEntry(null);
1900             os = Files.newOutputStream(e.file, WRITE);
1901         } else {
1902             os = new ByteArrayOutputStream((e.size &gt; 0)? (int)e.size : 8192);
1903         }
<span class="line-modified">1904         if (e.method == METHOD_DEFLATED) {</span>
<span class="line-added">1905             return new DeflatingEntryOutputStream(e, os);</span>
<span class="line-added">1906         } else {</span>
<span class="line-added">1907             return new EntryOutputStream(e, os);</span>
<span class="line-added">1908         }</span>
1909     }
1910 
1911     private class EntryOutputStream extends FilterOutputStream {
<span class="line-modified">1912         private final Entry e;</span>
1913         private long written;
1914         private boolean isClosed;
1915 
<span class="line-modified">1916         EntryOutputStream(Entry e, OutputStream os) {</span>
1917             super(os);
1918             this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
1919             // this.written = 0;
1920         }
1921 
1922         @Override
1923         public synchronized void write(int b) throws IOException {
1924             out.write(b);
1925             written += 1;
1926         }
1927 
1928         @Override
<span class="line-modified">1929         public synchronized void write(byte[] b, int off, int len)</span>
1930                 throws IOException {
1931             out.write(b, off, len);
1932             written += len;
1933         }
1934 
1935         @Override
1936         public synchronized void close() throws IOException {
1937             if (isClosed) {
1938                 return;
1939             }
1940             isClosed = true;
1941             e.size = written;
1942             if (out instanceof ByteArrayOutputStream)
1943                 e.bytes = ((ByteArrayOutputStream)out).toByteArray();
1944             super.close();
1945             update(e);
1946         }
1947     }
1948 
<span class="line-added">1949     // Output stream returned when writing &quot;deflated&quot; entries into memory,</span>
<span class="line-added">1950     // to enable eager (possibly parallel) deflation and reduce memory required.</span>
<span class="line-added">1951     private class DeflatingEntryOutputStream extends DeflaterOutputStream {</span>
<span class="line-added">1952         private final CRC32 crc;</span>
<span class="line-added">1953         private final Entry e;</span>
<span class="line-added">1954         private boolean isClosed;</span>
<span class="line-added">1955 </span>
<span class="line-added">1956         DeflatingEntryOutputStream(Entry e, OutputStream os) {</span>
<span class="line-added">1957             super(os, getDeflater());</span>
<span class="line-added">1958             this.e = Objects.requireNonNull(e, &quot;Zip entry is null&quot;);</span>
<span class="line-added">1959             this.crc = new CRC32();</span>
<span class="line-added">1960         }</span>
<span class="line-added">1961 </span>
<span class="line-added">1962         @Override</span>
<span class="line-added">1963         public synchronized void write(byte[] b, int off, int len)</span>
<span class="line-added">1964                 throws IOException {</span>
<span class="line-added">1965             super.write(b, off, len);</span>
<span class="line-added">1966             crc.update(b, off, len);</span>
<span class="line-added">1967         }</span>
<span class="line-added">1968 </span>
<span class="line-added">1969         @Override</span>
<span class="line-added">1970         public synchronized void close() throws IOException {</span>
<span class="line-added">1971             if (isClosed)</span>
<span class="line-added">1972                 return;</span>
<span class="line-added">1973             isClosed = true;</span>
<span class="line-added">1974             finish();</span>
<span class="line-added">1975             e.size  = def.getBytesRead();</span>
<span class="line-added">1976             e.csize = def.getBytesWritten();</span>
<span class="line-added">1977             e.crc = crc.getValue();</span>
<span class="line-added">1978             if (out instanceof ByteArrayOutputStream)</span>
<span class="line-added">1979                 e.bytes = ((ByteArrayOutputStream)out).toByteArray();</span>
<span class="line-added">1980             super.close();</span>
<span class="line-added">1981             update(e);</span>
<span class="line-added">1982             releaseDeflater(def);</span>
<span class="line-added">1983         }</span>
<span class="line-added">1984     }</span>
<span class="line-added">1985 </span>
1986     // Wrapper output stream class to write out a &quot;stored&quot; entry.
1987     // (1) this class does not close the underlying out stream when
1988     //     being closed.
1989     // (2) no need to be &quot;synchronized&quot;, only used by sync()
1990     private class EntryOutputStreamCRC32 extends FilterOutputStream {
<span class="line-modified">1991         private final CRC32 crc;</span>
<span class="line-modified">1992         private final Entry e;</span>
1993         private long written;
1994         private boolean isClosed;
1995 
<span class="line-modified">1996         EntryOutputStreamCRC32(Entry e, OutputStream os) {</span>
1997             super(os);
1998             this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
1999             this.crc = new CRC32();
2000         }
2001 
2002         @Override
2003         public void write(int b) throws IOException {
2004             out.write(b);
2005             crc.update(b);
2006             written += 1;
2007         }
2008 
2009         @Override
<span class="line-modified">2010         public void write(byte[] b, int off, int len)</span>
2011                 throws IOException {
2012             out.write(b, off, len);
2013             crc.update(b, off, len);
2014             written += len;
2015         }
2016 
2017         @Override
<span class="line-modified">2018         public void close() {</span>
2019             if (isClosed)
2020                 return;
2021             isClosed = true;
2022             e.size = e.csize = written;
2023             e.crc = crc.getValue();
2024         }
2025     }
2026 
2027     // Wrapper output stream class to write out a &quot;deflated&quot; entry.
2028     // (1) this class does not close the underlying out stream when
2029     //     being closed.
2030     // (2) no need to be &quot;synchronized&quot;, only used by sync()
2031     private class EntryOutputStreamDef extends DeflaterOutputStream {
<span class="line-modified">2032         private final CRC32 crc;</span>
<span class="line-modified">2033         private final Entry e;</span>
2034         private boolean isClosed;
2035 
<span class="line-modified">2036         EntryOutputStreamDef(Entry e, OutputStream os) {</span>
2037             super(os, getDeflater());
<span class="line-modified">2038             this.e = Objects.requireNonNull(e, &quot;Zip entry is null&quot;);</span>
2039             this.crc = new CRC32();
2040         }
2041 
2042         @Override
<span class="line-modified">2043         public void write(byte[] b, int off, int len) throws IOException {</span>

2044             super.write(b, off, len);
2045             crc.update(b, off, len);
2046         }
2047 
2048         @Override
2049         public void close() throws IOException {
2050             if (isClosed)
2051                 return;
2052             isClosed = true;
2053             finish();
<span class="line-modified">2054             e.size = def.getBytesRead();</span>
2055             e.csize = def.getBytesWritten();
2056             e.crc = crc.getValue();
2057             releaseDeflater(def);
2058         }
2059     }
2060 
2061     private InputStream getInputStream(Entry e)
2062         throws IOException
2063     {
<span class="line-modified">2064         InputStream eis;</span>

2065         if (e.type == Entry.NEW) {

2066             if (e.bytes != null)
<span class="line-modified">2067                 eis = new ByteArrayInputStream(e.bytes);</span>
2068             else if (e.file != null)
<span class="line-modified">2069                 eis = Files.newInputStream(e.file);</span>
2070             else
2071                 throw new ZipException(&quot;update entry data is missing&quot;);
2072         } else if (e.type == Entry.FILECH) {
2073             // FILECH result is un-compressed.
2074             eis = Files.newInputStream(e.file);
2075             // TBD: wrap to hook close()
2076             // streams.add(eis);
2077             return eis;
2078         } else {  // untouched CEN or COPY
2079             eis = new EntryInputStream(e, ch);
2080         }
2081         if (e.method == METHOD_DEFLATED) {
2082             // MORE: Compute good size for inflater stream:
2083             long bufSize = e.size + 2; // Inflater likes a bit of slack
2084             if (bufSize &gt; 65536)
2085                 bufSize = 8192;
2086             final long size = e.size;
2087             eis = new InflaterInputStream(eis, getInflater(), (int)bufSize) {
2088                 private boolean isClosed = false;
2089                 public void close() throws IOException {
</pre>
<hr />
<pre>
2096                 }
2097                 // Override fill() method to provide an extra &quot;dummy&quot; byte
2098                 // at the end of the input stream. This is required when
2099                 // using the &quot;nowrap&quot; Inflater option. (it appears the new
2100                 // zlib in 7 does not need it, but keep it for now)
2101                 protected void fill() throws IOException {
2102                     if (eof) {
2103                         throw new EOFException(
2104                             &quot;Unexpected end of ZLIB input stream&quot;);
2105                     }
2106                     len = this.in.read(buf, 0, buf.length);
2107                     if (len == -1) {
2108                         buf[0] = 0;
2109                         len = 1;
2110                         eof = true;
2111                     }
2112                     inf.setInput(buf, 0, len);
2113                 }
2114                 private boolean eof;
2115 
<span class="line-modified">2116                 public int available() {</span>
2117                     if (isClosed)
2118                         return 0;
2119                     long avail = size - inf.getBytesWritten();
2120                     return avail &gt; (long) Integer.MAX_VALUE ?
2121                         Integer.MAX_VALUE : (int) avail;
2122                 }
2123             };
2124         } else if (e.method == METHOD_STORED) {
2125             // TBD: wrap/ it does not seem necessary
2126         } else {
2127             throw new ZipException(&quot;invalid compression method&quot;);
2128         }
2129         streams.add(eis);
2130         return eis;
2131     }
2132 
2133     // Inner class implementing the input stream used to read
2134     // a (possibly compressed) zip file entry.
2135     private class EntryInputStream extends InputStream {
2136         private final SeekableByteChannel zfch; // local ref to zipfs&#39;s &quot;ch&quot;. zipfs.ch might
<span class="line-modified">2137                                                 // point to a new channel after sync()</span>
<span class="line-modified">2138         private long pos;                       // current position within entry data</span>
<span class="line-modified">2139         private long rem;                       // number of remaining bytes within entry</span>
2140 
2141         EntryInputStream(Entry e, SeekableByteChannel zfch)
2142             throws IOException
2143         {
2144             this.zfch = zfch;
2145             rem = e.csize;
2146             pos = e.locoff;
2147             if (pos == -1) {
2148                 Entry e2 = getEntry(e.name);
2149                 if (e2 == null) {
<span class="line-modified">2150                     throw new ZipException(&quot;invalid loc for entry &lt;&quot; + getString(e.name) + &quot;&gt;&quot;);</span>
2151                 }
2152                 pos = e2.locoff;
2153             }
2154             pos = -pos;  // lazy initialize the real data offset
2155         }
2156 
<span class="line-modified">2157         public int read(byte[] b, int off, int len) throws IOException {</span>
2158             ensureOpen();
2159             initDataPos();
2160             if (rem == 0) {
2161                 return -1;
2162             }
2163             if (len &lt;= 0) {
2164                 return 0;
2165             }
2166             if (len &gt; rem) {
2167                 len = (int) rem;
2168             }
2169             // readFullyAt()
<span class="line-modified">2170             long n;</span>
2171             ByteBuffer bb = ByteBuffer.wrap(b);
2172             bb.position(off);
2173             bb.limit(off + len);
2174             synchronized(zfch) {
2175                 n = zfch.position(pos).read(bb);
2176             }
2177             if (n &gt; 0) {
2178                 pos += n;
2179                 rem -= n;
2180             }
2181             if (rem == 0) {
2182                 close();
2183             }
2184             return (int)n;
2185         }
2186 
2187         public int read() throws IOException {
2188             byte[] b = new byte[1];
2189             if (read(b, 0, 1) == 1) {
2190                 return b[0] &amp; 0xff;
2191             } else {
2192                 return -1;
2193             }
2194         }
2195 
<span class="line-modified">2196         public long skip(long n) {</span>
2197             ensureOpen();
2198             if (n &gt; rem)
2199                 n = rem;
2200             pos += n;
2201             rem -= n;
2202             if (rem == 0) {
2203                 close();
2204             }
2205             return n;
2206         }
2207 
2208         public int available() {
2209             return rem &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;
2210         }
2211 
2212         public void close() {
2213             rem = 0;
2214             streams.remove(this);
2215         }
2216 
2217         private void initDataPos() throws IOException {
2218             if (pos &lt;= 0) {
2219                 pos = -pos + locpos;
2220                 byte[] buf = new byte[LOCHDR];
2221                 if (readFullyAt(buf, 0, buf.length, pos) != LOCHDR) {
2222                     throw new ZipException(&quot;invalid loc &quot; + pos + &quot; for entry reading&quot;);
2223                 }
2224                 pos += LOCHDR + LOCNAM(buf) + LOCEXT(buf);
2225             }
2226         }
2227     }
2228 




2229     // Maxmum number of de/inflater we cache
2230     private final int MAX_FLATER = 20;
2231     // List of available Inflater objects for decompression
2232     private final List&lt;Inflater&gt; inflaters = new ArrayList&lt;&gt;();
2233 
2234     // Gets an inflater from the list of available inflaters or allocates
2235     // a new one.
2236     private Inflater getInflater() {
2237         synchronized (inflaters) {
2238             int size = inflaters.size();
2239             if (size &gt; 0) {
<span class="line-modified">2240                 return inflaters.remove(size - 1);</span>

2241             } else {
2242                 return new Inflater(true);
2243             }
2244         }
2245     }
2246 
2247     // Releases the specified inflater to the list of available inflaters.
2248     private void releaseInflater(Inflater inf) {
2249         synchronized (inflaters) {
2250             if (inflaters.size() &lt; MAX_FLATER) {
2251                 inf.reset();
2252                 inflaters.add(inf);
2253             } else {
2254                 inf.end();
2255             }
2256         }
2257     }
2258 
2259     // List of available Deflater objects for compression
2260     private final List&lt;Deflater&gt; deflaters = new ArrayList&lt;&gt;();
2261 
2262     // Gets a deflater from the list of available deflaters or allocates
2263     // a new one.
2264     private Deflater getDeflater() {
2265         synchronized (deflaters) {
2266             int size = deflaters.size();
2267             if (size &gt; 0) {
<span class="line-modified">2268                 return deflaters.remove(size - 1);</span>

2269             } else {
2270                 return new Deflater(Deflater.DEFAULT_COMPRESSION, true);
2271             }
2272         }
2273     }
2274 
2275     // Releases the specified inflater to the list of available inflaters.
2276     private void releaseDeflater(Deflater def) {
2277         synchronized (deflaters) {
<span class="line-modified">2278             if (deflaters.size() &lt; MAX_FLATER) {</span>
2279                def.reset();
2280                deflaters.add(def);
2281             } else {
2282                def.end();
2283             }
2284         }
2285     }
2286 
2287     // End of central directory record
2288     static class END {
<span class="line-modified">2289         // The fields that are commented out below are not used by anyone and write() uses &quot;0&quot;</span>
2290         // int  disknum;
2291         // int  sdisknum;
<span class="line-modified">2292         // int  endsub;</span>
<span class="line-modified">2293         int  centot;        // 4 bytes</span>
<span class="line-modified">2294         long cenlen;        // 4 bytes</span>
<span class="line-modified">2295         long cenoff;        // 4 bytes</span>
<span class="line-modified">2296         // int  comlen;     // comment length</span>
<span class="line-modified">2297         // byte[] comment;</span>
<span class="line-modified">2298 </span>
<span class="line-modified">2299         // members of Zip64 end of central directory locator</span>
2300         // int diskNum;
2301         long endpos;
2302         // int disktot;
2303 
2304         void write(OutputStream os, long offset, boolean forceEnd64) throws IOException {
2305             boolean hasZip64 = forceEnd64; // false;
2306             long xlen = cenlen;
2307             long xoff = cenoff;
2308             if (xlen &gt;= ZIP64_MINVAL) {
2309                 xlen = ZIP64_MINVAL;
2310                 hasZip64 = true;
2311             }
2312             if (xoff &gt;= ZIP64_MINVAL) {
2313                 xoff = ZIP64_MINVAL;
2314                 hasZip64 = true;
2315             }
2316             int count = centot;
2317             if (count &gt;= ZIP64_MINVAL32) {
2318                 count = ZIP64_MINVAL32;
2319                 hasZip64 = true;
2320             }
2321             if (hasZip64) {

2322                 //zip64 end of central directory record
2323                 writeInt(os, ZIP64_ENDSIG);       // zip64 END record signature
2324                 writeLong(os, ZIP64_ENDHDR - 12); // size of zip64 end
2325                 writeShort(os, 45);               // version made by
2326                 writeShort(os, 45);               // version needed to extract
2327                 writeInt(os, 0);                  // number of this disk
2328                 writeInt(os, 0);                  // central directory start disk
2329                 writeLong(os, centot);            // number of directory entries on disk
2330                 writeLong(os, centot);            // number of directory entries
2331                 writeLong(os, cenlen);            // length of central directory
2332                 writeLong(os, cenoff);            // offset of central directory
2333 
2334                 //zip64 end of central directory locator
2335                 writeInt(os, ZIP64_LOCSIG);       // zip64 END locator signature
2336                 writeInt(os, 0);                  // zip64 END start disk
<span class="line-modified">2337                 writeLong(os, offset);            // offset of zip64 END</span>
2338                 writeInt(os, 1);                  // total number of disks (?)
2339             }
2340             writeInt(os, ENDSIG);                 // END record signature
2341             writeShort(os, 0);                    // number of this disk
2342             writeShort(os, 0);                    // central directory start disk
2343             writeShort(os, count);                // number of directory entries on disk
2344             writeShort(os, count);                // total number of directory entries
2345             writeInt(os, xlen);                   // length of central directory
2346             writeInt(os, xoff);                   // offset of central directory
<span class="line-modified">2347             writeShort(os, 0);                    // zip file comment, not used</span>





2348         }
2349     }
2350 
2351     // Internal node that links a &quot;name&quot; to its pos in cen table.
2352     // The node itself can be used as a &quot;key&quot; to lookup itself in
2353     // the HashMap inodes.
2354     static class IndexNode {
<span class="line-modified">2355         byte[]  name;</span>
<span class="line-modified">2356         int     hashcode;    // node is hashable/hashed by its name</span>


2357         boolean isdir;
<span class="line-added">2358         int     pos = -1;    // position in cen table, -1 means the</span>
<span class="line-added">2359                              // entry does not exist in zip file</span>
<span class="line-added">2360         IndexNode child;     // first child</span>
<span class="line-added">2361         IndexNode sibling;   // next sibling</span>
<span class="line-added">2362 </span>
<span class="line-added">2363         IndexNode() {}</span>
2364 
2365         IndexNode(byte[] name, boolean isdir) {
2366             name(name);
2367             this.isdir = isdir;
2368             this.pos = -1;
2369         }
2370 
2371         IndexNode(byte[] name, int pos) {
2372             name(name);
2373             this.pos = pos;
2374         }
2375 
<span class="line-modified">2376         // constructor for initCEN() (1) remove trailing &#39;/&#39; (2) pad leading &#39;/&#39;</span>
2377         IndexNode(byte[] cen, int pos, int nlen) {
2378             int noff = pos + CENHDR;
2379             if (cen[noff + nlen - 1] == &#39;/&#39;) {
2380                 isdir = true;
2381                 nlen--;
2382             }
2383             if (nlen &gt; 0 &amp;&amp; cen[noff] == &#39;/&#39;) {
2384                 name = Arrays.copyOfRange(cen, noff, noff + nlen);
2385             } else {
2386                 name = new byte[nlen + 1];
2387                 System.arraycopy(cen, noff, name, 1, nlen);
2388                 name[0] = &#39;/&#39;;
2389             }
<span class="line-modified">2390             name(normalize(name));</span>
2391             this.pos = pos;
2392         }
2393 
<span class="line-added">2394         // Normalize the IndexNode.name field.</span>
<span class="line-added">2395         private byte[] normalize(byte[] path) {</span>
<span class="line-added">2396             int len = path.length;</span>
<span class="line-added">2397             if (len == 0)</span>
<span class="line-added">2398                 return path;</span>
<span class="line-added">2399             byte prevC = 0;</span>
<span class="line-added">2400             for (int pathPos = 0; pathPos &lt; len; pathPos++) {</span>
<span class="line-added">2401                 byte c = path[pathPos];</span>
<span class="line-added">2402                 if (c == &#39;/&#39; &amp;&amp; prevC == &#39;/&#39;)</span>
<span class="line-added">2403                     return normalize(path, pathPos - 1);</span>
<span class="line-added">2404                 prevC = c;</span>
<span class="line-added">2405             }</span>
<span class="line-added">2406             if (len &gt; 1 &amp;&amp; prevC == &#39;/&#39;) {</span>
<span class="line-added">2407                 return Arrays.copyOf(path, len - 1);</span>
<span class="line-added">2408             }</span>
<span class="line-added">2409             return path;</span>
<span class="line-added">2410         }</span>
<span class="line-added">2411 </span>
<span class="line-added">2412         private byte[] normalize(byte[] path, int off) {</span>
<span class="line-added">2413             // As we know we have at least one / to trim, we can reduce</span>
<span class="line-added">2414             // the size of the resulting array</span>
<span class="line-added">2415             byte[] to = new byte[path.length - 1];</span>
<span class="line-added">2416             int pathPos = 0;</span>
<span class="line-added">2417             while (pathPos &lt; off) {</span>
<span class="line-added">2418                 to[pathPos] = path[pathPos];</span>
<span class="line-added">2419                 pathPos++;</span>
<span class="line-added">2420             }</span>
<span class="line-added">2421             int toPos = pathPos;</span>
<span class="line-added">2422             byte prevC = 0;</span>
<span class="line-added">2423             while (pathPos &lt; path.length) {</span>
<span class="line-added">2424                 byte c = path[pathPos++];</span>
<span class="line-added">2425                 if (c == &#39;/&#39; &amp;&amp; prevC == &#39;/&#39;)</span>
<span class="line-added">2426                     continue;</span>
<span class="line-added">2427                 to[toPos++] = c;</span>
<span class="line-added">2428                 prevC = c;</span>
<span class="line-added">2429             }</span>
<span class="line-added">2430             if (toPos &gt; 1 &amp;&amp; to[toPos - 1] == &#39;/&#39;)</span>
<span class="line-added">2431                 toPos--;</span>
<span class="line-added">2432             return (toPos == to.length) ? to : Arrays.copyOf(to, toPos);</span>
<span class="line-added">2433         }</span>
<span class="line-added">2434 </span>
2435         private static final ThreadLocal&lt;IndexNode&gt; cachedKey = new ThreadLocal&lt;&gt;();
2436 
<span class="line-modified">2437         static final IndexNode keyOf(byte[] name) { // get a lookup key;</span>
2438             IndexNode key = cachedKey.get();
2439             if (key == null) {
2440                 key = new IndexNode(name, -1);
2441                 cachedKey.set(key);
2442             }
2443             return key.as(name);
2444         }
2445 
2446         final void name(byte[] name) {
2447             this.name = name;
2448             this.hashcode = Arrays.hashCode(name);
2449         }
2450 
2451         final IndexNode as(byte[] name) {           // reuse the node, mostly
2452             name(name);                             // as a lookup &quot;key&quot;
2453             return this;
2454         }
2455 
2456         boolean isDir() {
2457             return isdir;
2458         }
2459 
<span class="line-added">2460         @Override</span>
2461         public boolean equals(Object other) {
2462             if (!(other instanceof IndexNode)) {
2463                 return false;
2464             }
2465             if (other instanceof ParentLookup) {
2466                 return ((ParentLookup)other).equals(this);
2467             }
2468             return Arrays.equals(name, ((IndexNode)other).name);
2469         }
2470 
<span class="line-added">2471         @Override</span>
2472         public int hashCode() {
2473             return hashcode;
2474         }
2475 
<span class="line-modified">2476         @Override</span>
<span class="line-modified">2477         public String toString() {</span>
<span class="line-modified">2478             return new String(name) + (isdir ? &quot; (dir)&quot; : &quot; &quot;) + &quot;, index: &quot; + pos;</span>
<span class="line-added">2479         }</span>
2480     }
2481 
2482     static class Entry extends IndexNode implements ZipFileAttributes {

2483         static final int CEN    = 1;  // entry read from cen
2484         static final int NEW    = 2;  // updated contents in bytes or file
2485         static final int FILECH = 3;  // fch update in &quot;file&quot;
2486         static final int COPY   = 4;  // copy of a CEN entry
2487 
2488         byte[] bytes;                 // updated content bytes
2489         Path   file;                  // use tmp file to store bytes;
2490         int    type = CEN;            // default is the entry read from cen
2491 
2492         // entry attributes
2493         int    version;
2494         int    flag;
<span class="line-added">2495         int    posixPerms = -1; // posix permissions</span>
2496         int    method = -1;    // compression method
2497         long   mtime  = -1;    // last modification time (in DOS time)
2498         long   atime  = -1;    // last access time
2499         long   ctime  = -1;    // create time
2500         long   crc    = -1;    // crc-32 of entry data
2501         long   csize  = -1;    // compressed size of entry data
2502         long   size   = -1;    // uncompressed size of entry data
2503         byte[] extra;
2504 
<span class="line-modified">2505         // CEN</span>
<span class="line-modified">2506         // The fields that are commented out below are not used by anyone and write() uses &quot;0&quot;</span>

2507         // int    versionMade;
2508         // int    disk;
2509         // int    attrs;
2510         // long   attrsEx;
2511         long   locoff;
2512         byte[] comment;
2513 


2514         Entry(byte[] name, boolean isdir, int method) {
2515             name(name);
2516             this.isdir = isdir;
2517             this.mtime  = this.ctime = this.atime = System.currentTimeMillis();
2518             this.crc    = 0;
2519             this.size   = 0;
2520             this.csize  = 0;
2521             this.method = method;
2522         }
2523 
<span class="line-modified">2524         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">2525         Entry(byte[] name, int type, boolean isdir, int method, FileAttribute&lt;?&gt;... attrs) {</span>
2526             this(name, isdir, method);
2527             this.type = type;
<span class="line-added">2528             for (FileAttribute&lt;?&gt; attr : attrs) {</span>
<span class="line-added">2529                 String attrName = attr.name();</span>
<span class="line-added">2530                 if (attrName.equals(&quot;posix:permissions&quot;)) {</span>
<span class="line-added">2531                     posixPerms = ZipUtils.permsToFlags((Set&lt;PosixFilePermission&gt;)attr.value());</span>
<span class="line-added">2532                 }</span>
<span class="line-added">2533             }</span>
<span class="line-added">2534         }</span>
<span class="line-added">2535 </span>
<span class="line-added">2536         Entry(byte[] name, Path file, int type, FileAttribute&lt;?&gt;... attrs) {</span>
<span class="line-added">2537             this(name, type, false, METHOD_STORED, attrs);</span>
<span class="line-added">2538             this.file = file;</span>
<span class="line-added">2539         }</span>
<span class="line-added">2540 </span>
<span class="line-added">2541         Entry(Entry e, int type, int compressionMethod) {</span>
<span class="line-added">2542             this(e, type);</span>
<span class="line-added">2543             this.method = compressionMethod;</span>
2544         }
2545 
<span class="line-modified">2546         Entry(Entry e, int type) {</span>
2547             name(e.name);
2548             this.isdir     = e.isdir;
2549             this.version   = e.version;
2550             this.ctime     = e.ctime;
2551             this.atime     = e.atime;
2552             this.mtime     = e.mtime;
2553             this.crc       = e.crc;
2554             this.size      = e.size;
2555             this.csize     = e.csize;
2556             this.method    = e.method;
2557             this.extra     = e.extra;
2558             /*
2559             this.versionMade = e.versionMade;
2560             this.disk      = e.disk;
2561             this.attrs     = e.attrs;
2562             this.attrsEx   = e.attrsEx;
2563             */
2564             this.locoff    = e.locoff;
2565             this.comment   = e.comment;
<span class="line-added">2566             this.posixPerms = e.posixPerms;</span>
2567             this.type      = type;
2568         }
2569 
<span class="line-modified">2570         Entry(ZipFileSystem zipfs, IndexNode inode) throws IOException {</span>
<span class="line-modified">2571             readCEN(zipfs, inode);</span>

2572         }
2573 
<span class="line-modified">2574         // Calculates a suitable base for the version number to</span>
<span class="line-added">2575         // be used for fields version made by/version needed to extract.</span>
<span class="line-added">2576         // The lower bytes of these 2 byte fields hold the version number</span>
<span class="line-added">2577         // (value/10 = major; value%10 = minor)</span>
<span class="line-added">2578         // For different features certain minimum versions apply:</span>
<span class="line-added">2579         // stored = 10 (1.0), deflated = 20 (2.0), zip64 = 45 (4.5)</span>
<span class="line-added">2580         private int version(boolean zip64) throws ZipException {</span>
<span class="line-added">2581             if (zip64) {</span>
<span class="line-added">2582                 return 45;</span>
<span class="line-added">2583             }</span>
2584             if (method == METHOD_DEFLATED)
2585                 return 20;
2586             else if (method == METHOD_STORED)
2587                 return 10;
2588             throw new ZipException(&quot;unsupported compression method&quot;);
2589         }
2590 
<span class="line-modified">2591         /**</span>
<span class="line-modified">2592          * Adds information about compatibility of file attribute information</span>
<span class="line-modified">2593          * to a version value.</span>
<span class="line-modified">2594          */</span>
<span class="line-modified">2595         private int versionMadeBy(int version) {</span>
<span class="line-added">2596             return (posixPerms &lt; 0) ? version :</span>
<span class="line-added">2597                 VERSION_MADE_BY_BASE_UNIX | (version &amp; 0xff);</span>
2598         }
2599 
<span class="line-modified">2600         ///////////////////// CEN //////////////////////</span>
<span class="line-modified">2601         private void readCEN(ZipFileSystem zipfs, IndexNode inode) throws IOException {</span>

2602             byte[] cen = zipfs.cen;
2603             int pos = inode.pos;
2604             if (!cenSigAt(cen, pos))
<span class="line-modified">2605                 throw new ZipException(&quot;invalid CEN header (bad signature)&quot;);</span>
2606             version     = CENVER(cen, pos);
2607             flag        = CENFLG(cen, pos);
2608             method      = CENHOW(cen, pos);
2609             mtime       = dosToJavaTime(CENTIM(cen, pos));
2610             crc         = CENCRC(cen, pos);
2611             csize       = CENSIZ(cen, pos);
2612             size        = CENLEN(cen, pos);
2613             int nlen    = CENNAM(cen, pos);
2614             int elen    = CENEXT(cen, pos);
2615             int clen    = CENCOM(cen, pos);
2616             /*
2617             versionMade = CENVEM(cen, pos);
2618             disk        = CENDSK(cen, pos);
2619             attrs       = CENATT(cen, pos);
2620             attrsEx     = CENATX(cen, pos);
2621             */
<span class="line-added">2622             if (CENVEM_FA(cen, pos) == FILE_ATTRIBUTES_UNIX) {</span>
<span class="line-added">2623                 posixPerms = CENATX_PERMS(cen, pos) &amp; 0xFFF; // 12 bits for setuid, setgid, sticky + perms</span>
<span class="line-added">2624             }</span>
2625             locoff      = CENOFF(cen, pos);
2626             pos += CENHDR;
2627             this.name = inode.name;
2628             this.isdir = inode.isdir;
2629             this.hashcode = inode.hashcode;
2630 
2631             pos += nlen;
2632             if (elen &gt; 0) {
2633                 extra = Arrays.copyOfRange(cen, pos, pos + elen);
2634                 pos += elen;
2635                 readExtra(zipfs);
2636             }
2637             if (clen &gt; 0) {
2638                 comment = Arrays.copyOfRange(cen, pos, pos + clen);
2639             }

2640         }
2641 
<span class="line-modified">2642         private int writeCEN(OutputStream os) throws IOException {</span>

2643             long csize0  = csize;
2644             long size0   = size;
2645             long locoff0 = locoff;
2646             int elen64   = 0;                // extra for ZIP64
2647             int elenNTFS = 0;                // extra for NTFS (a/c/mtime)
2648             int elenEXTT = 0;                // extra for Extended Timestamp
2649             boolean foundExtraTime = false;  // if time stamp NTFS, EXTT present
2650 
2651             byte[] zname = isdir ? toDirectoryPath(name) : name;
2652 
2653             // confirm size/length
2654             int nlen = (zname != null) ? zname.length - 1 : 0;  // name has [0] as &quot;slash&quot;
2655             int elen = (extra != null) ? extra.length : 0;
2656             int eoff = 0;
2657             int clen = (comment != null) ? comment.length : 0;
2658             if (csize &gt;= ZIP64_MINVAL) {
2659                 csize0 = ZIP64_MINVAL;
2660                 elen64 += 8;                 // csize(8)
2661             }
2662             if (size &gt;= ZIP64_MINVAL) {
2663                 size0 = ZIP64_MINVAL;        // size(8)
2664                 elen64 += 8;
2665             }
2666             if (locoff &gt;= ZIP64_MINVAL) {
2667                 locoff0 = ZIP64_MINVAL;
2668                 elen64 += 8;                 // offset(8)
2669             }
2670             if (elen64 != 0) {
2671                 elen64 += 4;                 // header and data sz 4 bytes
2672             }
<span class="line-added">2673             boolean zip64 = (elen64 != 0);</span>
<span class="line-added">2674             int version0 = version(zip64);</span>
2675             while (eoff + 4 &lt; elen) {
2676                 int tag = SH(extra, eoff);
2677                 int sz = SH(extra, eoff + 2);
2678                 if (tag == EXTID_EXTT || tag == EXTID_NTFS) {
2679                     foundExtraTime = true;
2680                 }
2681                 eoff += (4 + sz);
2682             }
2683             if (!foundExtraTime) {
2684                 if (isWindows) {             // use NTFS
2685                     elenNTFS = 36;           // total 36 bytes
2686                 } else {                     // Extended Timestamp otherwise
2687                     elenEXTT = 9;            // only mtime in cen
2688                 }
2689             }
2690             writeInt(os, CENSIG);            // CEN header signature
<span class="line-modified">2691             writeShort(os, versionMadeBy(version0)); // version made by</span>
<span class="line-modified">2692             writeShort(os, version0);        // version needed to extract</span>





2693             writeShort(os, flag);            // general purpose bit flag
2694             writeShort(os, method);          // compression method
2695                                              // last modification time
2696             writeInt(os, (int)javaToDosTime(mtime));
2697             writeInt(os, crc);               // crc-32
2698             writeInt(os, csize0);            // compressed size
2699             writeInt(os, size0);             // uncompressed size
2700             writeShort(os, nlen);
2701             writeShort(os, elen + elen64 + elenNTFS + elenEXTT);
2702 
2703             if (comment != null) {
2704                 writeShort(os, Math.min(clen, 0xffff));
2705             } else {
2706                 writeShort(os, 0);
2707             }
2708             writeShort(os, 0);              // starting disk number
2709             writeShort(os, 0);              // internal file attributes (unused)
<span class="line-modified">2710             writeInt(os, posixPerms &gt; 0 ? posixPerms &lt;&lt; 16 : 0); // external file</span>
<span class="line-added">2711                                             // attributes, used for storing posix</span>
<span class="line-added">2712                                             // permissions</span>
2713             writeInt(os, locoff0);          // relative offset of local header
2714             writeBytes(os, zname, 1, nlen);
<span class="line-modified">2715             if (zip64) {</span>
2716                 writeShort(os, EXTID_ZIP64);// Zip64 extra
2717                 writeShort(os, elen64 - 4); // size of &quot;this&quot; extra block
2718                 if (size0 == ZIP64_MINVAL)
2719                     writeLong(os, size);
2720                 if (csize0 == ZIP64_MINVAL)
2721                     writeLong(os, csize);
2722                 if (locoff0 == ZIP64_MINVAL)
2723                     writeLong(os, locoff);
2724             }
2725             if (elenNTFS != 0) {
2726                 writeShort(os, EXTID_NTFS);
2727                 writeShort(os, elenNTFS - 4);
2728                 writeInt(os, 0);            // reserved
2729                 writeShort(os, 0x0001);     // NTFS attr tag
2730                 writeShort(os, 24);
2731                 writeLong(os, javaToWinTime(mtime));
2732                 writeLong(os, javaToWinTime(atime));
2733                 writeLong(os, javaToWinTime(ctime));
2734             }
2735             if (elenEXTT != 0) {
2736                 writeShort(os, EXTID_EXTT);
2737                 writeShort(os, elenEXTT - 4);
2738                 if (ctime == -1)
2739                     os.write(0x3);          // mtime and atime
2740                 else
2741                     os.write(0x7);          // mtime, atime and ctime
2742                 writeInt(os, javaToUnixTime(mtime));
2743             }
2744             if (extra != null)              // whatever not recognized
2745                 writeBytes(os, extra);
2746             if (comment != null)            //TBD: 0, Math.min(commentBytes.length, 0xffff));
2747                 writeBytes(os, comment);
2748             return CENHDR + nlen + elen + clen + elen64 + elenNTFS + elenEXTT;
2749         }
2750 
2751         ///////////////////// LOC //////////////////////
2752 
<span class="line-modified">2753         private int writeLOC(OutputStream os) throws IOException {</span>

2754             byte[] zname = isdir ? toDirectoryPath(name) : name;
2755             int nlen = (zname != null) ? zname.length - 1 : 0; // [0] is slash
2756             int elen = (extra != null) ? extra.length : 0;
2757             boolean foundExtraTime = false;     // if extra timestamp present
2758             int eoff = 0;
2759             int elen64 = 0;
<span class="line-added">2760             boolean zip64 = false;</span>
2761             int elenEXTT = 0;
2762             int elenNTFS = 0;
2763             writeInt(os, LOCSIG);               // LOC header signature
2764             if ((flag &amp; FLAG_DATADESCR) != 0) {
<span class="line-modified">2765                 writeShort(os, version(false)); // version needed to extract</span>
2766                 writeShort(os, flag);           // general purpose bit flag
2767                 writeShort(os, method);         // compression method
2768                 // last modification time
2769                 writeInt(os, (int)javaToDosTime(mtime));
2770                 // store size, uncompressed size, and crc-32 in data descriptor
2771                 // immediately following compressed entry data
2772                 writeInt(os, 0);
2773                 writeInt(os, 0);
2774                 writeInt(os, 0);
2775             } else {
2776                 if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
2777                     elen64 = 20;    //headid(2) + size(2) + size(8) + csize(8)
<span class="line-modified">2778                     zip64 = true;</span>


2779                 }
<span class="line-added">2780                 writeShort(os, version(zip64)); // version needed to extract</span>
2781                 writeShort(os, flag);           // general purpose bit flag
2782                 writeShort(os, method);         // compression method
2783                                                 // last modification time
2784                 writeInt(os, (int)javaToDosTime(mtime));
2785                 writeInt(os, crc);              // crc-32
<span class="line-modified">2786                 if (zip64) {</span>
2787                     writeInt(os, ZIP64_MINVAL);
2788                     writeInt(os, ZIP64_MINVAL);
2789                 } else {
2790                     writeInt(os, csize);        // compressed size
2791                     writeInt(os, size);         // uncompressed size
2792                 }
2793             }
2794             while (eoff + 4 &lt; elen) {
2795                 int tag = SH(extra, eoff);
2796                 int sz = SH(extra, eoff + 2);
2797                 if (tag == EXTID_EXTT || tag == EXTID_NTFS) {
2798                     foundExtraTime = true;
2799                 }
2800                 eoff += (4 + sz);
2801             }
2802             if (!foundExtraTime) {
2803                 if (isWindows) {
2804                     elenNTFS = 36;              // NTFS, total 36 bytes
2805                 } else {                        // on unix use &quot;ext time&quot;
2806                     elenEXTT = 9;
2807                     if (atime != -1)
2808                         elenEXTT += 4;
2809                     if (ctime != -1)
2810                         elenEXTT += 4;
2811                 }
2812             }
2813             writeShort(os, nlen);
2814             writeShort(os, elen + elen64 + elenNTFS + elenEXTT);
2815             writeBytes(os, zname, 1, nlen);
<span class="line-modified">2816             if (zip64) {</span>
2817                 writeShort(os, EXTID_ZIP64);
2818                 writeShort(os, 16);
2819                 writeLong(os, size);
2820                 writeLong(os, csize);
2821             }
2822             if (elenNTFS != 0) {
2823                 writeShort(os, EXTID_NTFS);
2824                 writeShort(os, elenNTFS - 4);
2825                 writeInt(os, 0);            // reserved
2826                 writeShort(os, 0x0001);     // NTFS attr tag
2827                 writeShort(os, 24);
2828                 writeLong(os, javaToWinTime(mtime));
2829                 writeLong(os, javaToWinTime(atime));
2830                 writeLong(os, javaToWinTime(ctime));
2831             }
2832             if (elenEXTT != 0) {
2833                 writeShort(os, EXTID_EXTT);
2834                 writeShort(os, elenEXTT - 4);// size for the folowing data block
2835                 int fbyte = 0x1;
2836                 if (atime != -1)           // mtime and atime
2837                     fbyte |= 0x2;
2838                 if (ctime != -1)           // mtime, atime and ctime
2839                     fbyte |= 0x4;
2840                 os.write(fbyte);           // flags byte
2841                 writeInt(os, javaToUnixTime(mtime));
2842                 if (atime != -1)
2843                     writeInt(os, javaToUnixTime(atime));
2844                 if (ctime != -1)
2845                     writeInt(os, javaToUnixTime(ctime));
2846             }
2847             if (extra != null) {
2848                 writeBytes(os, extra);
2849             }
2850             return LOCHDR + nlen + elen + elen64 + elenNTFS + elenEXTT;
2851         }
2852 
<span class="line-modified">2853         // Data Descriptor</span>
<span class="line-modified">2854         private int writeEXT(OutputStream os) throws IOException {</span>
2855             writeInt(os, EXTSIG);           // EXT header signature
2856             writeInt(os, crc);              // crc-32
2857             if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
2858                 writeLong(os, csize);
2859                 writeLong(os, size);
2860                 return 24;
2861             } else {
2862                 writeInt(os, csize);        // compressed size
2863                 writeInt(os, size);         // uncompressed size
2864                 return 16;
2865             }
2866         }
2867 
2868         // read NTFS, UNIX and ZIP64 data from cen.extra
<span class="line-modified">2869         private void readExtra(ZipFileSystem zipfs) throws IOException {</span>
2870             if (extra == null)
2871                 return;
2872             int elen = extra.length;
2873             int off = 0;
2874             int newOff = 0;
2875             while (off + 4 &lt; elen) {
2876                 // extra spec: HeaderID+DataSize+Data
2877                 int pos = off;
2878                 int tag = SH(extra, pos);
2879                 int sz = SH(extra, pos + 2);
2880                 pos += 4;
2881                 if (pos + sz &gt; elen)         // invalid data
2882                     break;
2883                 switch (tag) {
2884                 case EXTID_ZIP64 :
2885                     if (size == ZIP64_MINVAL) {
2886                         if (pos + 8 &gt; elen)  // invalid zip64 extra
2887                             break;           // fields, just skip
2888                         size = LL(extra, pos);
2889                         pos += 8;
2890                     }
2891                     if (csize == ZIP64_MINVAL) {
2892                         if (pos + 8 &gt; elen)
2893                             break;
2894                         csize = LL(extra, pos);
2895                         pos += 8;
2896                     }
2897                     if (locoff == ZIP64_MINVAL) {
2898                         if (pos + 8 &gt; elen)
2899                             break;
2900                         locoff = LL(extra, pos);

2901                     }
2902                     break;
2903                 case EXTID_NTFS:
2904                     if (sz &lt; 32)
2905                         break;
2906                     pos += 4;    // reserved 4 bytes
2907                     if (SH(extra, pos) !=  0x0001)
2908                         break;
2909                     if (SH(extra, pos + 2) != 24)
2910                         break;
2911                     // override the loc field, datatime here is
2912                     // more &quot;accurate&quot;
2913                     mtime  = winToJavaTime(LL(extra, pos + 4));
2914                     atime  = winToJavaTime(LL(extra, pos + 12));
2915                     ctime  = winToJavaTime(LL(extra, pos + 20));
2916                     break;
2917                 case EXTID_EXTT:
2918                     // spec says the Extened timestamp in cen only has mtime
2919                     // need to read the loc to get the extra a/ctime, if flag
2920                     // &quot;zipinfo-time&quot; is not specified to false;
2921                     // there is performance cost (move up to loc and read) to
2922                     // access the loc table foreach entry;
2923                     if (zipfs.noExtt) {
2924                         if (sz == 5)
2925                             mtime = unixToJavaTime(LG(extra, pos + 1));
2926                          break;
2927                     }
2928                     byte[] buf = new byte[LOCHDR];
2929                     if (zipfs.readFullyAt(buf, 0, buf.length , locoff)
2930                         != buf.length)
2931                         throw new ZipException(&quot;loc: reading failed&quot;);
2932                     if (!locSigAt(buf, 0))
2933                         throw new ZipException(&quot;loc: wrong sig -&gt;&quot;
2934                                            + Long.toString(getSig(buf, 0), 16));
2935                     int locElen = LOCEXT(buf);
<span class="line-modified">2936                     if (locElen &lt; 9)    // EXTT is at least 9 bytes</span>
2937                         break;
2938                     int locNlen = LOCNAM(buf);
2939                     buf = new byte[locElen];
2940                     if (zipfs.readFullyAt(buf, 0, buf.length , locoff + LOCHDR + locNlen)
2941                         != buf.length)
2942                         throw new ZipException(&quot;loc extra: reading failed&quot;);
2943                     int locPos = 0;
2944                     while (locPos + 4 &lt; buf.length) {
2945                         int locTag = SH(buf, locPos);
2946                         int locSZ  = SH(buf, locPos + 2);
2947                         locPos += 4;
2948                         if (locTag  != EXTID_EXTT) {
2949                             locPos += locSZ;
2950                              continue;
2951                         }
2952                         int end = locPos + locSZ - 4;
2953                         int flag = CH(buf, locPos++);
2954                         if ((flag &amp; 0x1) != 0 &amp;&amp; locPos &lt;= end) {
2955                             mtime = unixToJavaTime(LG(buf, locPos));
2956                             locPos += 4;
2957                         }
2958                         if ((flag &amp; 0x2) != 0 &amp;&amp; locPos &lt;= end) {
2959                             atime = unixToJavaTime(LG(buf, locPos));
2960                             locPos += 4;
2961                         }
2962                         if ((flag &amp; 0x4) != 0 &amp;&amp; locPos &lt;= end) {
2963                             ctime = unixToJavaTime(LG(buf, locPos));

2964                         }
2965                         break;
2966                     }
2967                     break;
2968                 default:    // unknown tag
2969                     System.arraycopy(extra, off, extra, newOff, sz + 4);
2970                     newOff += (sz + 4);
2971                 }
2972                 off += (sz + 4);
2973             }
2974             if (newOff != 0 &amp;&amp; newOff != extra.length)
2975                 extra = Arrays.copyOf(extra, newOff);
2976             else
2977                 extra = null;
2978         }
2979 
<span class="line-added">2980         @Override</span>
<span class="line-added">2981         public String toString() {</span>
<span class="line-added">2982             StringBuilder sb = new StringBuilder(1024);</span>
<span class="line-added">2983             Formatter fm = new Formatter(sb);</span>
<span class="line-added">2984             fm.format(&quot;    name            : %s%n&quot;, new String(name));</span>
<span class="line-added">2985             fm.format(&quot;    creationTime    : %tc%n&quot;, creationTime().toMillis());</span>
<span class="line-added">2986             fm.format(&quot;    lastAccessTime  : %tc%n&quot;, lastAccessTime().toMillis());</span>
<span class="line-added">2987             fm.format(&quot;    lastModifiedTime: %tc%n&quot;, lastModifiedTime().toMillis());</span>
<span class="line-added">2988             fm.format(&quot;    isRegularFile   : %b%n&quot;, isRegularFile());</span>
<span class="line-added">2989             fm.format(&quot;    isDirectory     : %b%n&quot;, isDirectory());</span>
<span class="line-added">2990             fm.format(&quot;    isSymbolicLink  : %b%n&quot;, isSymbolicLink());</span>
<span class="line-added">2991             fm.format(&quot;    isOther         : %b%n&quot;, isOther());</span>
<span class="line-added">2992             fm.format(&quot;    fileKey         : %s%n&quot;, fileKey());</span>
<span class="line-added">2993             fm.format(&quot;    size            : %d%n&quot;, size());</span>
<span class="line-added">2994             fm.format(&quot;    compressedSize  : %d%n&quot;, compressedSize());</span>
<span class="line-added">2995             fm.format(&quot;    crc             : %x%n&quot;, crc());</span>
<span class="line-added">2996             fm.format(&quot;    method          : %d%n&quot;, method());</span>
<span class="line-added">2997             Set&lt;PosixFilePermission&gt; permissions = storedPermissions().orElse(null);</span>
<span class="line-added">2998             if (permissions != null) {</span>
<span class="line-added">2999                 fm.format(&quot;    permissions     : %s%n&quot;, permissions);</span>
<span class="line-added">3000             }</span>
<span class="line-added">3001             fm.close();</span>
<span class="line-added">3002             return sb.toString();</span>
<span class="line-added">3003         }</span>
<span class="line-added">3004 </span>
3005         ///////// basic file attributes ///////////
3006         @Override
3007         public FileTime creationTime() {
3008             return FileTime.fromMillis(ctime == -1 ? mtime : ctime);
3009         }
3010 
3011         @Override
3012         public boolean isDirectory() {
3013             return isDir();
3014         }
3015 
3016         @Override
3017         public boolean isOther() {
3018             return false;
3019         }
3020 
3021         @Override
3022         public boolean isRegularFile() {
3023             return !isDir();
3024         }
</pre>
<hr />
<pre>
3031         @Override
3032         public FileTime lastModifiedTime() {
3033             return FileTime.fromMillis(mtime);
3034         }
3035 
3036         @Override
3037         public long size() {
3038             return size;
3039         }
3040 
3041         @Override
3042         public boolean isSymbolicLink() {
3043             return false;
3044         }
3045 
3046         @Override
3047         public Object fileKey() {
3048             return null;
3049         }
3050 
<span class="line-modified">3051         ///////// zip file attributes ///////////</span>
<span class="line-added">3052 </span>
<span class="line-added">3053         @Override</span>
3054         public long compressedSize() {
3055             return csize;
3056         }
3057 
<span class="line-added">3058         @Override</span>
3059         public long crc() {
3060             return crc;
3061         }
3062 
<span class="line-added">3063         @Override</span>
3064         public int method() {
3065             return method;
3066         }
3067 
<span class="line-added">3068         @Override</span>
3069         public byte[] extra() {
3070             if (extra != null)
3071                 return Arrays.copyOf(extra, extra.length);
3072             return null;
3073         }
3074 
<span class="line-added">3075         @Override</span>
3076         public byte[] comment() {
3077             if (comment != null)
3078                 return Arrays.copyOf(comment, comment.length);
3079             return null;
3080         }
3081 
<span class="line-modified">3082         @Override</span>
<span class="line-modified">3083         public Optional&lt;Set&lt;PosixFilePermission&gt;&gt; storedPermissions() {</span>
<span class="line-modified">3084             Set&lt;PosixFilePermission&gt; perms = null;</span>
<span class="line-modified">3085             if (posixPerms != -1) {</span>
<span class="line-modified">3086                 perms = new HashSet&lt;&gt;(PosixFilePermission.values().length);</span>
<span class="line-modified">3087                 for (PosixFilePermission perm : PosixFilePermission.values()) {</span>
<span class="line-modified">3088                     if ((posixPerms &amp; ZipUtils.permToFlag(perm)) != 0) {</span>
<span class="line-modified">3089                         perms.add(perm);</span>
<span class="line-modified">3090                     }</span>
<span class="line-modified">3091                 }</span>
<span class="line-modified">3092             }</span>
<span class="line-modified">3093             return Optional.ofNullable(perms);</span>






3094         }
3095     }
3096 
<span class="line-modified">3097     final class PosixEntry extends Entry implements PosixFileAttributes {</span>
<span class="line-modified">3098         private UserPrincipal owner = defaultOwner;</span>
<span class="line-modified">3099         private GroupPrincipal group = defaultGroup;</span>




3100 
<span class="line-modified">3101         PosixEntry(byte[] name, boolean isdir, int method) {</span>
<span class="line-modified">3102             super(name, isdir, method);</span>
<span class="line-added">3103         }</span>
3104 
<span class="line-modified">3105         PosixEntry(byte[] name, int type, boolean isdir, int method, FileAttribute&lt;?&gt;... attrs) {</span>
<span class="line-modified">3106             super(name, type, isdir, method, attrs);</span>
<span class="line-modified">3107         }</span>
<span class="line-modified">3108 </span>
<span class="line-modified">3109         PosixEntry(byte[] name, Path file, int type, FileAttribute&lt;?&gt;... attrs) {</span>
<span class="line-modified">3110             super(name, file, type, attrs);</span>
<span class="line-modified">3111         }</span>
<span class="line-modified">3112 </span>
<span class="line-modified">3113         PosixEntry(PosixEntry e, int type, int compressionMethod) {</span>
<span class="line-modified">3114             super(e, type);</span>
<span class="line-modified">3115             this.method = compressionMethod;</span>
<span class="line-modified">3116         }</span>
<span class="line-modified">3117 </span>
<span class="line-modified">3118         PosixEntry(PosixEntry e, int type) {</span>
<span class="line-added">3119             super(e, type);</span>
<span class="line-added">3120             this.owner = e.owner;</span>
<span class="line-added">3121             this.group = e.group;</span>
<span class="line-added">3122         }</span>
<span class="line-added">3123 </span>
<span class="line-added">3124         PosixEntry(ZipFileSystem zipfs, IndexNode inode) throws IOException {</span>
<span class="line-added">3125             super(zipfs, inode);</span>
<span class="line-added">3126         }</span>
<span class="line-added">3127 </span>
<span class="line-added">3128         @Override</span>
<span class="line-added">3129         public UserPrincipal owner() {</span>
<span class="line-added">3130             return owner;</span>
<span class="line-added">3131         }</span>
<span class="line-added">3132 </span>
<span class="line-added">3133         @Override</span>
<span class="line-added">3134         public GroupPrincipal group() {</span>
<span class="line-added">3135             return group;</span>
<span class="line-added">3136         }</span>
<span class="line-added">3137 </span>
<span class="line-added">3138         @Override</span>
<span class="line-added">3139         public Set&lt;PosixFilePermission&gt; permissions() {</span>
<span class="line-added">3140             return storedPermissions().orElse(Set.copyOf(defaultPermissions));</span>
<span class="line-added">3141         }</span>
<span class="line-added">3142     }</span>
<span class="line-added">3143 </span>
<span class="line-added">3144     private static class ExistingChannelCloser {</span>
<span class="line-added">3145         private final Path path;</span>
<span class="line-added">3146         private final SeekableByteChannel ch;</span>
<span class="line-added">3147         private final Set&lt;InputStream&gt; streams;</span>
<span class="line-added">3148         ExistingChannelCloser(Path path,</span>
<span class="line-added">3149                               SeekableByteChannel ch,</span>
<span class="line-added">3150                               Set&lt;InputStream&gt; streams) {</span>
<span class="line-added">3151             this.path = path;</span>
<span class="line-added">3152             this.ch = ch;</span>
<span class="line-added">3153             this.streams = streams;</span>
<span class="line-added">3154         }</span>
<span class="line-added">3155 </span>
<span class="line-added">3156         /**</span>
<span class="line-added">3157          * If there are no more outstanding streams, close the channel and</span>
<span class="line-added">3158          * delete the backing file</span>
<span class="line-added">3159          *</span>
<span class="line-added">3160          * @return true if we&#39;re done and closed the backing file,</span>
<span class="line-added">3161          *         otherwise false</span>
<span class="line-added">3162          * @throws IOException</span>
<span class="line-added">3163          */</span>
<span class="line-added">3164         private boolean closeAndDeleteIfDone() throws IOException {</span>
<span class="line-added">3165             if (streams.isEmpty()) {</span>
<span class="line-added">3166                 ch.close();</span>
<span class="line-added">3167                 Files.delete(path);</span>
<span class="line-added">3168                 return true;</span>
3169             }
<span class="line-added">3170             return false;</span>
3171         }
3172     }
3173 
3174     // purely for parent lookup, so we don&#39;t have to copy the parent
3175     // name every time
3176     static class ParentLookup extends IndexNode {
3177         int len;
3178         ParentLookup() {}
3179 
3180         final ParentLookup as(byte[] name, int len) { // as a lookup &quot;key&quot;
3181             name(name, len);
3182             return this;
3183         }
3184 
3185         void name(byte[] name, int len) {
3186             this.name = name;
3187             this.len = len;
3188             // calculate the hashcode the same way as Arrays.hashCode() does
3189             int result = 1;
3190             for (int i = 0; i &lt; len; i++)
3191                 result = 31 * result + name[i];
3192             this.hashcode = result;
3193         }
3194 
3195         @Override
3196         public boolean equals(Object other) {
3197             if (!(other instanceof IndexNode)) {
3198                 return false;
3199             }
3200             byte[] oname = ((IndexNode)other).name;
3201             return Arrays.equals(name, 0, len,
3202                                  oname, 0, oname.length);
3203         }










































3204     }
3205 }
</pre>
</td>
</tr>
</table>
<center><a href="ZipFileStore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipFileSystemProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
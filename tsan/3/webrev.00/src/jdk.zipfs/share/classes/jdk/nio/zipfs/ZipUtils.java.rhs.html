<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.nio.zipfs;
 27 
 28 import java.io.IOException;
 29 import java.io.OutputStream;
<a name="2" id="anc2"></a><span class="line-added"> 30 import java.nio.file.attribute.PosixFilePermission;</span>
 31 import java.time.DateTimeException;
 32 import java.time.Instant;
 33 import java.time.LocalDateTime;
 34 import java.time.ZoneId;
 35 import java.util.Arrays;
 36 import java.util.Date;
<a name="3" id="anc3"></a><span class="line-added"> 37 import java.util.Set;</span>
 38 import java.util.concurrent.TimeUnit;
 39 import java.util.regex.PatternSyntaxException;
 40 
 41 /**
 42  * @author Xueming Shen
 43  */
 44 class ZipUtils {
 45 
<a name="4" id="anc4"></a><span class="line-added"> 46     /**</span>
<span class="line-added"> 47      * The bit flag used to specify read permission by the owner.</span>
<span class="line-added"> 48      */</span>
<span class="line-added"> 49     static final int POSIX_USER_READ = 0400;</span>
<span class="line-added"> 50 </span>
<span class="line-added"> 51     /**</span>
<span class="line-added"> 52      * The bit flag used to specify write permission by the owner.</span>
<span class="line-added"> 53      */</span>
<span class="line-added"> 54     static final int POSIX_USER_WRITE = 0200;</span>
<span class="line-added"> 55 </span>
<span class="line-added"> 56     /**</span>
<span class="line-added"> 57      * The bit flag used to specify execute permission by the owner.</span>
<span class="line-added"> 58      */</span>
<span class="line-added"> 59     static final int POSIX_USER_EXECUTE = 0100;</span>
<span class="line-added"> 60 </span>
<span class="line-added"> 61     /**</span>
<span class="line-added"> 62      * The bit flag used to specify read permission by the group.</span>
<span class="line-added"> 63      */</span>
<span class="line-added"> 64     static final int POSIX_GROUP_READ = 040;</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66     /**</span>
<span class="line-added"> 67      * The bit flag used to specify write permission by the group.</span>
<span class="line-added"> 68      */</span>
<span class="line-added"> 69     static final int POSIX_GROUP_WRITE = 020;</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71     /**</span>
<span class="line-added"> 72      * The bit flag used to specify execute permission by the group.</span>
<span class="line-added"> 73      */</span>
<span class="line-added"> 74     static final int POSIX_GROUP_EXECUTE = 010;</span>
<span class="line-added"> 75 </span>
<span class="line-added"> 76     /**</span>
<span class="line-added"> 77      * The bit flag used to specify read permission by others.</span>
<span class="line-added"> 78      */</span>
<span class="line-added"> 79     static final int POSIX_OTHER_READ = 04;</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81     /**</span>
<span class="line-added"> 82      * The bit flag used to specify write permission by others.</span>
<span class="line-added"> 83      */</span>
<span class="line-added"> 84     static final int POSIX_OTHER_WRITE = 02;</span>
<span class="line-added"> 85 </span>
<span class="line-added"> 86     /**</span>
<span class="line-added"> 87      * The bit flag used to specify execute permission by others.</span>
<span class="line-added"> 88      */</span>
<span class="line-added"> 89     static final int POSIX_OTHER_EXECUTE = 01;</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91     /**</span>
<span class="line-added"> 92      * Convert a {@link PosixFilePermission} object into the appropriate bit</span>
<span class="line-added"> 93      * flag.</span>
<span class="line-added"> 94      *</span>
<span class="line-added"> 95      * @param perm The {@link PosixFilePermission} object.</span>
<span class="line-added"> 96      * @return The bit flag as int.</span>
<span class="line-added"> 97      */</span>
<span class="line-added"> 98     static int permToFlag(PosixFilePermission perm) {</span>
<span class="line-added"> 99         switch(perm) {</span>
<span class="line-added">100         case OWNER_READ:</span>
<span class="line-added">101             return POSIX_USER_READ;</span>
<span class="line-added">102         case OWNER_WRITE:</span>
<span class="line-added">103             return POSIX_USER_WRITE;</span>
<span class="line-added">104         case OWNER_EXECUTE:</span>
<span class="line-added">105             return POSIX_USER_EXECUTE;</span>
<span class="line-added">106         case GROUP_READ:</span>
<span class="line-added">107             return POSIX_GROUP_READ;</span>
<span class="line-added">108         case GROUP_WRITE:</span>
<span class="line-added">109             return POSIX_GROUP_WRITE;</span>
<span class="line-added">110         case GROUP_EXECUTE:</span>
<span class="line-added">111             return POSIX_GROUP_EXECUTE;</span>
<span class="line-added">112         case OTHERS_READ:</span>
<span class="line-added">113             return POSIX_OTHER_READ;</span>
<span class="line-added">114         case OTHERS_WRITE:</span>
<span class="line-added">115             return POSIX_OTHER_WRITE;</span>
<span class="line-added">116         case OTHERS_EXECUTE:</span>
<span class="line-added">117             return POSIX_OTHER_EXECUTE;</span>
<span class="line-added">118         default:</span>
<span class="line-added">119             return 0;</span>
<span class="line-added">120         }</span>
<span class="line-added">121     }</span>
<span class="line-added">122 </span>
<span class="line-added">123     /**</span>
<span class="line-added">124      * Converts a set of {@link PosixFilePermission}s into an int value where</span>
<span class="line-added">125      * the according bits are set.</span>
<span class="line-added">126      *</span>
<span class="line-added">127      * @param perms A Set of {@link PosixFilePermission} objects.</span>
<span class="line-added">128      *</span>
<span class="line-added">129      * @return A bit mask representing the input Set.</span>
<span class="line-added">130      */</span>
<span class="line-added">131     static int permsToFlags(Set&lt;PosixFilePermission&gt; perms) {</span>
<span class="line-added">132         if (perms == null) {</span>
<span class="line-added">133             return -1;</span>
<span class="line-added">134         }</span>
<span class="line-added">135         int flags = 0;</span>
<span class="line-added">136         for (PosixFilePermission perm : perms) {</span>
<span class="line-added">137             flags |= permToFlag(perm);</span>
<span class="line-added">138         }</span>
<span class="line-added">139         return flags;</span>
<span class="line-added">140     }</span>
<span class="line-added">141 </span>
142     /*
143      * Writes a 16-bit short to the output stream in little-endian byte order.
144      */
145     public static void writeShort(OutputStream os, int v) throws IOException {
146         os.write(v &amp; 0xff);
147         os.write((v &gt;&gt;&gt; 8) &amp; 0xff);
148     }
149 
150     /*
151      * Writes a 32-bit int to the output stream in little-endian byte order.
152      */
153     public static void writeInt(OutputStream os, long v) throws IOException {
154         os.write((int)(v &amp; 0xff));
155         os.write((int)((v &gt;&gt;&gt;  8) &amp; 0xff));
156         os.write((int)((v &gt;&gt;&gt; 16) &amp; 0xff));
157         os.write((int)((v &gt;&gt;&gt; 24) &amp; 0xff));
158     }
159 
160     /*
161      * Writes a 64-bit int to the output stream in little-endian byte order.
162      */
163     public static void writeLong(OutputStream os, long v) throws IOException {
164         os.write((int)(v &amp; 0xff));
165         os.write((int)((v &gt;&gt;&gt;  8) &amp; 0xff));
166         os.write((int)((v &gt;&gt;&gt; 16) &amp; 0xff));
167         os.write((int)((v &gt;&gt;&gt; 24) &amp; 0xff));
168         os.write((int)((v &gt;&gt;&gt; 32) &amp; 0xff));
169         os.write((int)((v &gt;&gt;&gt; 40) &amp; 0xff));
170         os.write((int)((v &gt;&gt;&gt; 48) &amp; 0xff));
171         os.write((int)((v &gt;&gt;&gt; 56) &amp; 0xff));
172     }
173 
174     /*
175      * Writes an array of bytes to the output stream.
176      */
177     public static void writeBytes(OutputStream os, byte[] b)
178         throws IOException
179     {
180         os.write(b, 0, b.length);
181     }
182 
183     /*
184      * Writes an array of bytes to the output stream.
185      */
186     public static void writeBytes(OutputStream os, byte[] b, int off, int len)
187         throws IOException
188     {
189         os.write(b, off, len);
190     }
191 
192     /*
193      * Append a slash at the end, if it does not have one yet
194      */
195     public static byte[] toDirectoryPath(byte[] dir) {
196         if (dir.length != 0 &amp;&amp; dir[dir.length - 1] != &#39;/&#39;) {
197             dir = Arrays.copyOf(dir, dir.length + 1);
198             dir[dir.length - 1] = &#39;/&#39;;
199         }
200         return dir;
201     }
202 
203     /*
204      * Converts DOS time to Java time (number of milliseconds since epoch).
205      */
206     public static long dosToJavaTime(long dtime) {
207         int year = (int) (((dtime &gt;&gt; 25) &amp; 0x7f) + 1980);
208         int month = (int) ((dtime &gt;&gt; 21) &amp; 0x0f);
209         int day = (int) ((dtime &gt;&gt; 16) &amp; 0x1f);
210         int hour = (int) ((dtime &gt;&gt; 11) &amp; 0x1f);
211         int minute = (int) ((dtime &gt;&gt; 5) &amp; 0x3f);
212         int second = (int) ((dtime &lt;&lt; 1) &amp; 0x3e);
213 
214         if (month &gt; 0 &amp;&amp; month &lt; 13 &amp;&amp; day &gt; 0 &amp;&amp; hour &lt; 24 &amp;&amp; minute &lt; 60 &amp;&amp; second &lt; 60) {
215             try {
216                 LocalDateTime ldt = LocalDateTime.of(year, month, day, hour, minute, second);
217                 return TimeUnit.MILLISECONDS.convert(ldt.toEpochSecond(
218                         ZoneId.systemDefault().getRules().getOffset(ldt)), TimeUnit.SECONDS);
219             } catch (DateTimeException dte) {
220                 // ignore
221             }
222         }
223         return overflowDosToJavaTime(year, month, day, hour, minute, second);
224     }
225 
226     /*
227      * Deal with corner cases where an arguably mal-formed DOS time is used
228      */
229     @SuppressWarnings(&quot;deprecation&quot;) // Use of Date constructor
230     private static long overflowDosToJavaTime(int year, int month, int day,
231                                               int hour, int minute, int second) {
232         return new Date(year - 1900, month - 1, day, hour, minute, second).getTime();
233     }
234 
235     /*
236      * Converts Java time to DOS time.
237      */
238     public static long javaToDosTime(long time) {
239         Instant instant = Instant.ofEpochMilli(time);
240         LocalDateTime ldt = LocalDateTime.ofInstant(
241                 instant, ZoneId.systemDefault());
242         int year = ldt.getYear() - 1980;
243         if (year &lt; 0) {
244             return (1 &lt;&lt; 21) | (1 &lt;&lt; 16);
245         }
246         return (year &lt;&lt; 25 |
247             ldt.getMonthValue() &lt;&lt; 21 |
248             ldt.getDayOfMonth() &lt;&lt; 16 |
249             ldt.getHour() &lt;&lt; 11 |
250             ldt.getMinute() &lt;&lt; 5 |
251             ldt.getSecond() &gt;&gt; 1) &amp; 0xffffffffL;
252     }
253 
254     // used to adjust values between Windows and java epoch
255     private static final long WINDOWS_EPOCH_IN_MICROSECONDS = -11644473600000000L;
256     public static final long winToJavaTime(long wtime) {
257         return TimeUnit.MILLISECONDS.convert(
258                wtime / 10 + WINDOWS_EPOCH_IN_MICROSECONDS, TimeUnit.MICROSECONDS);
259     }
260 
261     public static final long javaToWinTime(long time) {
262         return (TimeUnit.MICROSECONDS.convert(time, TimeUnit.MILLISECONDS)
263                - WINDOWS_EPOCH_IN_MICROSECONDS) * 10;
264     }
265 
266     public static final long unixToJavaTime(long utime) {
267         return TimeUnit.MILLISECONDS.convert(utime, TimeUnit.SECONDS);
268     }
269 
270     public static final long javaToUnixTime(long time) {
271         return TimeUnit.SECONDS.convert(time, TimeUnit.MILLISECONDS);
272     }
273 
274     private static final String regexMetaChars = &quot;.^$+{[]|()&quot;;
275     private static final String globMetaChars = &quot;\\*?[{&quot;;
276     private static boolean isRegexMeta(char c) {
277         return regexMetaChars.indexOf(c) != -1;
278     }
279     private static boolean isGlobMeta(char c) {
280         return globMetaChars.indexOf(c) != -1;
281     }
282     private static char EOL = 0;  //TBD
283     private static char next(String glob, int i) {
284         if (i &lt; glob.length()) {
285             return glob.charAt(i);
286         }
287         return EOL;
288     }
289 
290     /*
291      * Creates a regex pattern from the given glob expression.
292      *
293      * @throws  PatternSyntaxException
294      */
295     public static String toRegexPattern(String globPattern) {
296         boolean inGroup = false;
297         StringBuilder regex = new StringBuilder(&quot;^&quot;);
298 
299         int i = 0;
300         while (i &lt; globPattern.length()) {
301             char c = globPattern.charAt(i++);
302             switch (c) {
303                 case &#39;\\&#39;:
304                     // escape special characters
305                     if (i == globPattern.length()) {
306                         throw new PatternSyntaxException(&quot;No character to escape&quot;,
307                                 globPattern, i - 1);
308                     }
309                     char next = globPattern.charAt(i++);
310                     if (isGlobMeta(next) || isRegexMeta(next)) {
311                         regex.append(&#39;\\&#39;);
312                     }
313                     regex.append(next);
314                     break;
315                 case &#39;/&#39;:
316                     regex.append(c);
317                     break;
318                 case &#39;[&#39;:
319                     // don&#39;t match name separator in class
320                     regex.append(&quot;[[^/]&amp;&amp;[&quot;);
321                     if (next(globPattern, i) == &#39;^&#39;) {
322                         // escape the regex negation char if it appears
323                         regex.append(&quot;\\^&quot;);
324                         i++;
325                     } else {
326                         // negation
327                         if (next(globPattern, i) == &#39;!&#39;) {
328                             regex.append(&#39;^&#39;);
329                             i++;
330                         }
331                         // hyphen allowed at start
332                         if (next(globPattern, i) == &#39;-&#39;) {
333                             regex.append(&#39;-&#39;);
334                             i++;
335                         }
336                     }
337                     boolean hasRangeStart = false;
338                     char last = 0;
339                     while (i &lt; globPattern.length()) {
340                         c = globPattern.charAt(i++);
341                         if (c == &#39;]&#39;) {
342                             break;
343                         }
344                         if (c == &#39;/&#39;) {
345                             throw new PatternSyntaxException(&quot;Explicit &#39;name separator&#39; in class&quot;,
346                                     globPattern, i - 1);
347                         }
348                         // TBD: how to specify &#39;]&#39; in a class?
349                         if (c == &#39;\\&#39; || c == &#39;[&#39; ||
350                                 c == &#39;&amp;&#39; &amp;&amp; next(globPattern, i) == &#39;&amp;&#39;) {
351                             // escape &#39;\&#39;, &#39;[&#39; or &quot;&amp;&amp;&quot; for regex class
352                             regex.append(&#39;\\&#39;);
353                         }
354                         regex.append(c);
355 
356                         if (c == &#39;-&#39;) {
357                             if (!hasRangeStart) {
358                                 throw new PatternSyntaxException(&quot;Invalid range&quot;,
359                                         globPattern, i - 1);
360                             }
361                             if ((c = next(globPattern, i++)) == EOL || c == &#39;]&#39;) {
362                                 break;
363                             }
364                             if (c &lt; last) {
365                                 throw new PatternSyntaxException(&quot;Invalid range&quot;,
366                                         globPattern, i - 3);
367                             }
368                             regex.append(c);
369                             hasRangeStart = false;
370                         } else {
371                             hasRangeStart = true;
372                             last = c;
373                         }
374                     }
375                     if (c != &#39;]&#39;) {
376                         throw new PatternSyntaxException(&quot;Missing &#39;]&quot;, globPattern, i - 1);
377                     }
378                     regex.append(&quot;]]&quot;);
379                     break;
380                 case &#39;{&#39;:
381                     if (inGroup) {
382                         throw new PatternSyntaxException(&quot;Cannot nest groups&quot;,
383                                 globPattern, i - 1);
384                     }
385                     regex.append(&quot;(?:(?:&quot;);
386                     inGroup = true;
387                     break;
388                 case &#39;}&#39;:
389                     if (inGroup) {
390                         regex.append(&quot;))&quot;);
391                         inGroup = false;
392                     } else {
393                         regex.append(&#39;}&#39;);
394                     }
395                     break;
396                 case &#39;,&#39;:
397                     if (inGroup) {
398                         regex.append(&quot;)|(?:&quot;);
399                     } else {
400                         regex.append(&#39;,&#39;);
401                     }
402                     break;
403                 case &#39;*&#39;:
404                     if (next(globPattern, i) == &#39;*&#39;) {
405                         // crosses directory boundaries
406                         regex.append(&quot;.*&quot;);
407                         i++;
408                     } else {
409                         // within directory boundary
410                         regex.append(&quot;[^/]*&quot;);
411                     }
412                     break;
413                 case &#39;?&#39;:
414                    regex.append(&quot;[^/]&quot;);
415                    break;
416                 default:
417                     if (isRegexMeta(c)) {
418                         regex.append(&#39;\\&#39;);
419                     }
420                     regex.append(c);
421             }
422         }
423         if (inGroup) {
424             throw new PatternSyntaxException(&quot;Missing &#39;}&quot;, globPattern, i - 1);
425         }
426         return regex.append(&#39;$&#39;).toString();
427     }
428 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
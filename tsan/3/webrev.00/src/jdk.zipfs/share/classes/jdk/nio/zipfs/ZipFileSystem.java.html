<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipFileSystem.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.nio.zipfs;
  27 
  28 import java.io.BufferedOutputStream;
  29 import java.io.ByteArrayInputStream;
  30 import java.io.ByteArrayOutputStream;
  31 import java.io.EOFException;
  32 import java.io.FilterOutputStream;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.OutputStream;
  36 import java.lang.Runtime.Version;
  37 import java.nio.ByteBuffer;
  38 import java.nio.MappedByteBuffer;
  39 import java.nio.channels.FileChannel;
  40 import java.nio.channels.FileLock;
  41 import java.nio.channels.ReadableByteChannel;
  42 import java.nio.channels.SeekableByteChannel;
  43 import java.nio.channels.WritableByteChannel;
  44 import java.nio.file.*;
  45 import java.nio.file.attribute.*;
  46 import java.nio.file.spi.FileSystemProvider;
  47 import java.security.AccessController;
  48 import java.security.PrivilegedAction;
  49 import java.security.PrivilegedActionException;
  50 import java.security.PrivilegedExceptionAction;
  51 import java.util.*;
  52 import java.util.concurrent.locks.ReadWriteLock;
  53 import java.util.concurrent.locks.ReentrantReadWriteLock;
  54 import java.util.function.Consumer;
  55 import java.util.function.Function;
  56 import java.util.jar.Attributes;
  57 import java.util.jar.Manifest;
  58 import java.util.regex.Pattern;
  59 import java.util.zip.CRC32;
  60 import java.util.zip.Deflater;
  61 import java.util.zip.DeflaterOutputStream;
  62 import java.util.zip.Inflater;
  63 import java.util.zip.InflaterInputStream;
  64 import java.util.zip.ZipException;
  65 
  66 import static java.lang.Boolean.TRUE;
  67 import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;
  68 import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
  69 import static java.nio.file.StandardOpenOption.APPEND;
  70 import static java.nio.file.StandardOpenOption.CREATE;
  71 import static java.nio.file.StandardOpenOption.CREATE_NEW;
  72 import static java.nio.file.StandardOpenOption.READ;
  73 import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;
  74 import static java.nio.file.StandardOpenOption.WRITE;
  75 import static jdk.nio.zipfs.ZipConstants.*;
  76 import static jdk.nio.zipfs.ZipUtils.*;
  77 
  78 /**
  79  * A FileSystem built on a zip file
  80  *
  81  * @author Xueming Shen
  82  */
  83 class ZipFileSystem extends FileSystem {
  84     // statics
  85     private static final boolean isWindows = AccessController.doPrivileged(
  86         (PrivilegedAction&lt;Boolean&gt;)()-&gt;System.getProperty(&quot;os.name&quot;)
  87                                              .startsWith(&quot;Windows&quot;));
  88     private static final byte[] ROOTPATH = new byte[] { &#39;/&#39; };
  89     private static final String PROPERTY_POSIX = &quot;enablePosixFileAttributes&quot;;
  90     private static final String PROPERTY_DEFAULT_OWNER = &quot;defaultOwner&quot;;
  91     private static final String PROPERTY_DEFAULT_GROUP = &quot;defaultGroup&quot;;
  92     private static final String PROPERTY_DEFAULT_PERMISSIONS = &quot;defaultPermissions&quot;;
  93     // Property used to specify the entry version to use for a multi-release JAR
  94     private static final String PROPERTY_RELEASE_VERSION = &quot;releaseVersion&quot;;
  95     // Original property used to specify the entry version to use for a
  96     // multi-release JAR which is kept for backwards compatibility.
  97     private static final String PROPERTY_MULTI_RELEASE = &quot;multi-release&quot;;
  98 
  99     private static final Set&lt;PosixFilePermission&gt; DEFAULT_PERMISSIONS =
 100         PosixFilePermissions.fromString(&quot;rwxrwxrwx&quot;);
 101     // Property used to specify the compression mode to use
 102     private static final String PROPERTY_COMPRESSION_METHOD = &quot;compressionMethod&quot;;
 103     // Value specified for compressionMethod property to compress Zip entries
 104     private static final String COMPRESSION_METHOD_DEFLATED = &quot;DEFLATED&quot;;
 105     // Value specified for compressionMethod property to not compress Zip entries
 106     private static final String COMPRESSION_METHOD_STORED = &quot;STORED&quot;;
 107 
 108     private final ZipFileSystemProvider provider;
 109     private final Path zfpath;
 110     final ZipCoder zc;
 111     private final ZipPath rootdir;
 112     private boolean readOnly; // readonly file system, false by default
 113 
 114     // default time stamp for pseudo entries
 115     private final long zfsDefaultTimeStamp = System.currentTimeMillis();
 116 
 117     // configurable by env map
 118     private final boolean noExtt;        // see readExtra()
 119     private final boolean useTempFile;   // use a temp file for newOS, default
 120                                          // is to use BAOS for better performance
 121     private final boolean forceEnd64;
 122     private final int defaultCompressionMethod; // METHOD_STORED if &quot;noCompression=true&quot;
 123                                                 // METHOD_DEFLATED otherwise
 124 
 125     // entryLookup is identity by default, will be overridden for multi-release jars
 126     private Function&lt;byte[], byte[]&gt; entryLookup = Function.identity();
 127 
 128     // POSIX support
 129     final boolean supportPosix;
 130     private final UserPrincipal defaultOwner;
 131     private final GroupPrincipal defaultGroup;
 132     private final Set&lt;PosixFilePermission&gt; defaultPermissions;
 133 
 134     private final Set&lt;String&gt; supportedFileAttributeViews;
 135 
 136     ZipFileSystem(ZipFileSystemProvider provider,
 137                   Path zfpath,
 138                   Map&lt;String, ?&gt; env) throws IOException
 139     {
 140         // default encoding for name/comment
 141         String nameEncoding = env.containsKey(&quot;encoding&quot;) ?
 142             (String)env.get(&quot;encoding&quot;) : &quot;UTF-8&quot;;
 143         this.noExtt = &quot;false&quot;.equals(env.get(&quot;zipinfo-time&quot;));
 144         this.useTempFile  = isTrue(env, &quot;useTempFile&quot;);
 145         this.forceEnd64 = isTrue(env, &quot;forceZIP64End&quot;);
 146         this.defaultCompressionMethod = getDefaultCompressionMethod(env);
 147         this.supportPosix = isTrue(env, PROPERTY_POSIX);
 148         this.defaultOwner = initOwner(zfpath, env);
 149         this.defaultGroup = initGroup(zfpath, env);
 150         this.defaultPermissions = initPermissions(env);
 151         this.supportedFileAttributeViews = supportPosix ?
 152             Set.of(&quot;basic&quot;, &quot;posix&quot;, &quot;zip&quot;) : Set.of(&quot;basic&quot;, &quot;zip&quot;);
 153         if (Files.notExists(zfpath)) {
 154             // create a new zip if it doesn&#39;t exist
 155             if (isTrue(env, &quot;create&quot;)) {
 156                 try (OutputStream os = Files.newOutputStream(zfpath, CREATE_NEW, WRITE)) {
 157                     new END().write(os, 0, forceEnd64);
 158                 }
 159             } else {
 160                 throw new NoSuchFileException(zfpath.toString());
 161             }
 162         }
 163         // sm and existence check
 164         zfpath.getFileSystem().provider().checkAccess(zfpath, AccessMode.READ);
 165         boolean writeable = AccessController.doPrivileged(
 166             (PrivilegedAction&lt;Boolean&gt;)()-&gt;Files.isWritable(zfpath));
 167         this.readOnly = !writeable;
 168         this.zc = ZipCoder.get(nameEncoding);
 169         this.rootdir = new ZipPath(this, new byte[]{&#39;/&#39;});
 170         this.ch = Files.newByteChannel(zfpath, READ);
 171         try {
 172             this.cen = initCEN();
 173         } catch (IOException x) {
 174             try {
 175                 this.ch.close();
 176             } catch (IOException xx) {
 177                 x.addSuppressed(xx);
 178             }
 179             throw x;
 180         }
 181         this.provider = provider;
 182         this.zfpath = zfpath;
 183 
 184         initializeReleaseVersion(env);
 185     }
 186 
 187     /**
 188      * Return the compression method to use (STORED or DEFLATED).  If the
 189      * property {@code commpressionMethod} is set use its value to determine
 190      * the compression method to use.  If the property is not set, then the
 191      * default compression is DEFLATED unless the property {@code noCompression}
 192      * is set which is supported for backwards compatibility.
 193      * @param env Zip FS map of properties
 194      * @return The Compression method to use
 195      */
 196     private int getDefaultCompressionMethod(Map&lt;String, ?&gt; env) {
 197         int result =
 198                 isTrue(env, &quot;noCompression&quot;) ? METHOD_STORED : METHOD_DEFLATED;
 199         if (env.containsKey(PROPERTY_COMPRESSION_METHOD)) {
 200             Object compressionMethod =  env.get(PROPERTY_COMPRESSION_METHOD);
 201             if (compressionMethod != null) {
 202                 if (compressionMethod instanceof String) {
 203                     switch (((String) compressionMethod).toUpperCase()) {
 204                         case COMPRESSION_METHOD_STORED:
 205                             result = METHOD_STORED;
 206                             break;
 207                         case COMPRESSION_METHOD_DEFLATED:
 208                             result = METHOD_DEFLATED;
 209                             break;
 210                         default:
 211                             throw new IllegalArgumentException(String.format(
 212                                     &quot;The value for the %s property must be %s or %s&quot;,
 213                                     PROPERTY_COMPRESSION_METHOD, COMPRESSION_METHOD_STORED,
 214                                     COMPRESSION_METHOD_DEFLATED));
 215                     }
 216                 } else {
 217                     throw new IllegalArgumentException(String.format(
 218                             &quot;The Object type for the %s property must be a String&quot;,
 219                             PROPERTY_COMPRESSION_METHOD));
 220                 }
 221             } else {
 222                 throw new IllegalArgumentException(String.format(
 223                         &quot;The value for the %s property must be %s or %s&quot;,
 224                         PROPERTY_COMPRESSION_METHOD, COMPRESSION_METHOD_STORED,
 225                         COMPRESSION_METHOD_DEFLATED));
 226             }
 227         }
 228         return result;
 229     }
 230 
 231     // returns true if there is a name=true/&quot;true&quot; setting in env
 232     private static boolean isTrue(Map&lt;String, ?&gt; env, String name) {
 233         return &quot;true&quot;.equals(env.get(name)) || TRUE.equals(env.get(name));
 234     }
 235 
 236     // Initialize the default owner for files inside the zip archive.
 237     // If not specified in env, it is the owner of the archive. If no owner can
 238     // be determined, we try to go with system property &quot;user.name&quot;. If that&#39;s not
 239     // accessible, we return &quot;&lt;zipfs_default&gt;&quot;.
 240     private UserPrincipal initOwner(Path zfpath, Map&lt;String, ?&gt; env) throws IOException {
 241         Object o = env.get(PROPERTY_DEFAULT_OWNER);
 242         if (o == null) {
 243             try {
 244                 PrivilegedExceptionAction&lt;UserPrincipal&gt; pa = ()-&gt;Files.getOwner(zfpath);
 245                 return AccessController.doPrivileged(pa);
 246             } catch (UnsupportedOperationException | PrivilegedActionException e) {
 247                 if (e instanceof UnsupportedOperationException ||
 248                     e.getCause() instanceof NoSuchFileException)
 249                 {
 250                     PrivilegedAction&lt;String&gt; pa = ()-&gt;System.getProperty(&quot;user.name&quot;);
 251                     String userName = AccessController.doPrivileged(pa);
 252                     return ()-&gt;userName;
 253                 } else {
 254                     throw new IOException(e);
 255                 }
 256             }
 257         }
 258         if (o instanceof String) {
 259             if (((String)o).isEmpty()) {
 260                 throw new IllegalArgumentException(&quot;Value for property &quot; +
 261                         PROPERTY_DEFAULT_OWNER + &quot; must not be empty.&quot;);
 262             }
 263             return ()-&gt;(String)o;
 264         }
 265         if (o instanceof UserPrincipal) {
 266             return (UserPrincipal)o;
 267         }
 268         throw new IllegalArgumentException(&quot;Value for property &quot; +
 269                 PROPERTY_DEFAULT_OWNER + &quot; must be of type &quot; + String.class +
 270             &quot; or &quot; + UserPrincipal.class);
 271     }
 272 
 273     // Initialize the default group for files inside the zip archive.
 274     // If not specified in env, we try to determine the group of the zip archive itself.
 275     // If this is not possible/unsupported, we will return a group principal going by
 276     // the same name as the default owner.
 277     private GroupPrincipal initGroup(Path zfpath, Map&lt;String, ?&gt; env) throws IOException {
 278         Object o = env.get(PROPERTY_DEFAULT_GROUP);
 279         if (o == null) {
 280             try {
 281                 PosixFileAttributeView zfpv = Files.getFileAttributeView(zfpath, PosixFileAttributeView.class);
 282                 if (zfpv == null) {
 283                     return defaultOwner::getName;
 284                 }
 285                 PrivilegedExceptionAction&lt;GroupPrincipal&gt; pa = ()-&gt;zfpv.readAttributes().group();
 286                 return AccessController.doPrivileged(pa);
 287             } catch (UnsupportedOperationException | PrivilegedActionException e) {
 288                 if (e instanceof UnsupportedOperationException ||
 289                     e.getCause() instanceof NoSuchFileException)
 290                 {
 291                     return defaultOwner::getName;
 292                 } else {
 293                     throw new IOException(e);
 294                 }
 295             }
 296         }
 297         if (o instanceof String) {
 298             if (((String)o).isEmpty()) {
 299                 throw new IllegalArgumentException(&quot;Value for property &quot; +
 300                         PROPERTY_DEFAULT_GROUP + &quot; must not be empty.&quot;);
 301             }
 302             return ()-&gt;(String)o;
 303         }
 304         if (o instanceof GroupPrincipal) {
 305             return (GroupPrincipal)o;
 306         }
 307         throw new IllegalArgumentException(&quot;Value for property &quot; +
 308                 PROPERTY_DEFAULT_GROUP + &quot; must be of type &quot; + String.class +
 309             &quot; or &quot; + GroupPrincipal.class);
 310     }
 311 
 312     // Initialize the default permissions for files inside the zip archive.
 313     // If not specified in env, it will return 777.
 314     private Set&lt;PosixFilePermission&gt; initPermissions(Map&lt;String, ?&gt; env) {
 315         Object o = env.get(PROPERTY_DEFAULT_PERMISSIONS);
 316         if (o == null) {
 317             return DEFAULT_PERMISSIONS;
 318         }
 319         if (o instanceof String) {
 320             return PosixFilePermissions.fromString((String)o);
 321         }
 322         if (!(o instanceof Set)) {
 323             throw new IllegalArgumentException(&quot;Value for property &quot; +
 324                 PROPERTY_DEFAULT_PERMISSIONS + &quot; must be of type &quot; + String.class +
 325                 &quot; or &quot; + Set.class);
 326         }
 327         Set&lt;PosixFilePermission&gt; perms = new HashSet&lt;&gt;();
 328         for (Object o2 : (Set&lt;?&gt;)o) {
 329             if (o2 instanceof PosixFilePermission) {
 330                 perms.add((PosixFilePermission)o2);
 331             } else {
 332                 throw new IllegalArgumentException(PROPERTY_DEFAULT_PERMISSIONS +
 333                     &quot; must only contain objects of type &quot; + PosixFilePermission.class);
 334             }
 335         }
 336         return perms;
 337     }
 338 
 339     @Override
 340     public FileSystemProvider provider() {
 341         return provider;
 342     }
 343 
 344     @Override
 345     public String getSeparator() {
 346         return &quot;/&quot;;
 347     }
 348 
 349     @Override
 350     public boolean isOpen() {
 351         return isOpen;
 352     }
 353 
 354     @Override
 355     public boolean isReadOnly() {
 356         return readOnly;
 357     }
 358 
 359     private void checkWritable() {
 360         if (readOnly) {
 361             throw new ReadOnlyFileSystemException();
 362         }
 363     }
 364 
 365     void setReadOnly() {
 366         this.readOnly = true;
 367     }
 368 
 369     @Override
 370     public Iterable&lt;Path&gt; getRootDirectories() {
 371         return List.of(rootdir);
 372     }
 373 
 374     ZipPath getRootDir() {
 375         return rootdir;
 376     }
 377 
 378     @Override
 379     public ZipPath getPath(String first, String... more) {
 380         if (more.length == 0) {
 381             return new ZipPath(this, first);
 382         }
 383         StringBuilder sb = new StringBuilder();
 384         sb.append(first);
 385         for (String path : more) {
 386             if (path.length() &gt; 0) {
 387                 if (sb.length() &gt; 0) {
 388                     sb.append(&#39;/&#39;);
 389                 }
 390                 sb.append(path);
 391             }
 392         }
 393         return new ZipPath(this, sb.toString());
 394     }
 395 
 396     @Override
 397     public UserPrincipalLookupService getUserPrincipalLookupService() {
 398         throw new UnsupportedOperationException();
 399     }
 400 
 401     @Override
 402     public WatchService newWatchService() {
 403         throw new UnsupportedOperationException();
 404     }
 405 
 406     FileStore getFileStore(ZipPath path) {
 407         return new ZipFileStore(path);
 408     }
 409 
 410     @Override
 411     public Iterable&lt;FileStore&gt; getFileStores() {
 412         return List.of(new ZipFileStore(rootdir));
 413     }
 414 
 415     @Override
 416     public Set&lt;String&gt; supportedFileAttributeViews() {
 417         return supportedFileAttributeViews;
 418     }
 419 
 420     @Override
 421     public String toString() {
 422         return zfpath.toString();
 423     }
 424 
 425     Path getZipFile() {
 426         return zfpath;
 427     }
 428 
 429     private static final String GLOB_SYNTAX = &quot;glob&quot;;
 430     private static final String REGEX_SYNTAX = &quot;regex&quot;;
 431 
 432     @Override
 433     public PathMatcher getPathMatcher(String syntaxAndInput) {
 434         int pos = syntaxAndInput.indexOf(&#39;:&#39;);
 435         if (pos &lt;= 0 || pos == syntaxAndInput.length()) {
 436             throw new IllegalArgumentException();
 437         }
 438         String syntax = syntaxAndInput.substring(0, pos);
 439         String input = syntaxAndInput.substring(pos + 1);
 440         String expr;
 441         if (syntax.equalsIgnoreCase(GLOB_SYNTAX)) {
 442             expr = toRegexPattern(input);
 443         } else {
 444             if (syntax.equalsIgnoreCase(REGEX_SYNTAX)) {
 445                 expr = input;
 446             } else {
 447                 throw new UnsupportedOperationException(&quot;Syntax &#39;&quot; + syntax +
 448                     &quot;&#39; not recognized&quot;);
 449             }
 450         }
 451         // return matcher
 452         final Pattern pattern = Pattern.compile(expr);
 453         return (path)-&gt;pattern.matcher(path.toString()).matches();
 454     }
 455 
 456     @Override
 457     public void close() throws IOException {
 458         beginWrite();
 459         try {
 460             if (!isOpen)
 461                 return;
 462             isOpen = false;          // set closed
 463         } finally {
 464             endWrite();
 465         }
 466         if (!streams.isEmpty()) {    // unlock and close all remaining streams
 467             Set&lt;InputStream&gt; copy = new HashSet&lt;&gt;(streams);
 468             for (InputStream is : copy)
 469                 is.close();
 470         }
 471         beginWrite();                // lock and sync
 472         try {
 473             AccessController.doPrivileged((PrivilegedExceptionAction&lt;Void&gt;)() -&gt; {
 474                 sync(); return null;
 475             });
 476             ch.close();              // close the ch just in case no update
 477                                      // and sync didn&#39;t close the ch
 478         } catch (PrivilegedActionException e) {
 479             throw (IOException)e.getException();
 480         } finally {
 481             endWrite();
 482         }
 483 
 484         synchronized (inflaters) {
 485             for (Inflater inf : inflaters)
 486                 inf.end();
 487         }
 488         synchronized (deflaters) {
 489             for (Deflater def : deflaters)
 490                 def.end();
 491         }
 492 
 493         beginWrite();                // lock and sync
 494         try {
 495             // Clear the map so that its keys &amp; values can be garbage collected
 496             inodes = null;
 497         } finally {
 498             endWrite();
 499         }
 500 
 501         IOException ioe = null;
 502         synchronized (tmppaths) {
 503             for (Path p : tmppaths) {
 504                 try {
 505                     AccessController.doPrivileged(
 506                         (PrivilegedExceptionAction&lt;Boolean&gt;)() -&gt; Files.deleteIfExists(p));
 507                 } catch (PrivilegedActionException e) {
 508                     IOException x = (IOException)e.getException();
 509                     if (ioe == null)
 510                         ioe = x;
 511                     else
 512                         ioe.addSuppressed(x);
 513                 }
 514             }
 515         }
 516         provider.removeFileSystem(zfpath, this);
 517         if (ioe != null)
 518            throw ioe;
 519     }
 520 
 521     ZipFileAttributes getFileAttributes(byte[] path)
 522         throws IOException
 523     {
 524         beginRead();
 525         try {
 526             ensureOpen();
 527             IndexNode inode = getInode(path);
 528             if (inode == null) {
 529                 return null;
 530             } else if (inode instanceof Entry) {
 531                 return (Entry)inode;
 532             } else if (inode.pos == -1) {
 533                 // pseudo directory, uses METHOD_STORED
 534                 Entry e = supportPosix ?
 535                     new PosixEntry(inode.name, inode.isdir, METHOD_STORED) :
 536                     new Entry(inode.name, inode.isdir, METHOD_STORED);
 537                 e.mtime = e.atime = e.ctime = zfsDefaultTimeStamp;
 538                 return e;
 539             } else {
 540                 return supportPosix ? new PosixEntry(this, inode) : new Entry(this, inode);
 541             }
 542         } finally {
 543             endRead();
 544         }
 545     }
 546 
 547     void checkAccess(byte[] path) throws IOException {
 548         beginRead();
 549         try {
 550             ensureOpen();
 551             // is it necessary to readCEN as a sanity check?
 552             if (getInode(path) == null) {
 553                 throw new NoSuchFileException(toString());
 554             }
 555 
 556         } finally {
 557             endRead();
 558         }
 559     }
 560 
 561     void setTimes(byte[] path, FileTime mtime, FileTime atime, FileTime ctime)
 562         throws IOException
 563     {
 564         checkWritable();
 565         beginWrite();
 566         try {
 567             ensureOpen();
 568             Entry e = getEntry(path);    // ensureOpen checked
 569             if (e == null)
 570                 throw new NoSuchFileException(getString(path));
 571             if (e.type == Entry.CEN)
 572                 e.type = Entry.COPY;     // copy e
 573             if (mtime != null)
 574                 e.mtime = mtime.toMillis();
 575             if (atime != null)
 576                 e.atime = atime.toMillis();
 577             if (ctime != null)
 578                 e.ctime = ctime.toMillis();
 579             update(e);
 580         } finally {
 581             endWrite();
 582         }
 583     }
 584 
 585     void setOwner(byte[] path, UserPrincipal owner) throws IOException {
 586         checkWritable();
 587         beginWrite();
 588         try {
 589             ensureOpen();
 590             Entry e = getEntry(path);    // ensureOpen checked
 591             if (e == null) {
 592                 throw new NoSuchFileException(getString(path));
 593             }
 594             // as the owner information is not persistent, we don&#39;t need to
 595             // change e.type to Entry.COPY
 596             if (e instanceof PosixEntry) {
 597                 ((PosixEntry)e).owner = owner;
 598                 update(e);
 599             }
 600         } finally {
 601             endWrite();
 602         }
 603     }
 604 
 605     void setGroup(byte[] path, GroupPrincipal group) throws IOException {
 606         checkWritable();
 607         beginWrite();
 608         try {
 609             ensureOpen();
 610             Entry e = getEntry(path);    // ensureOpen checked
 611             if (e == null) {
 612                 throw new NoSuchFileException(getString(path));
 613             }
 614             // as the group information is not persistent, we don&#39;t need to
 615             // change e.type to Entry.COPY
 616             if (e instanceof PosixEntry) {
 617                 ((PosixEntry)e).group = group;
 618                 update(e);
 619             }
 620         } finally {
 621             endWrite();
 622         }
 623     }
 624 
 625     void setPermissions(byte[] path, Set&lt;PosixFilePermission&gt; perms) throws IOException {
 626         checkWritable();
 627         beginWrite();
 628         try {
 629             ensureOpen();
 630             Entry e = getEntry(path);    // ensureOpen checked
 631             if (e == null) {
 632                 throw new NoSuchFileException(getString(path));
 633             }
 634             if (e.type == Entry.CEN) {
 635                 e.type = Entry.COPY;     // copy e
 636             }
 637             e.posixPerms = perms == null ? -1 : ZipUtils.permsToFlags(perms);
 638             update(e);
 639         } finally {
 640             endWrite();
 641         }
 642     }
 643 
 644     boolean exists(byte[] path) {
 645         beginRead();
 646         try {
 647             ensureOpen();
 648             return getInode(path) != null;
 649         } finally {
 650             endRead();
 651         }
 652     }
 653 
 654     boolean isDirectory(byte[] path) {
 655         beginRead();
 656         try {
 657             IndexNode n = getInode(path);
 658             return n != null &amp;&amp; n.isDir();
 659         } finally {
 660             endRead();
 661         }
 662     }
 663 
 664     // returns the list of child paths of &quot;path&quot;
 665     Iterator&lt;Path&gt; iteratorOf(ZipPath dir,
 666                               DirectoryStream.Filter&lt;? super Path&gt; filter)
 667         throws IOException
 668     {
 669         beginWrite();    // iteration of inodes needs exclusive lock
 670         try {
 671             ensureOpen();
 672             byte[] path = dir.getResolvedPath();
 673             IndexNode inode = getInode(path);
 674             if (inode == null)
 675                 throw new NotDirectoryException(getString(path));
 676             List&lt;Path&gt; list = new ArrayList&lt;&gt;();
 677             IndexNode child = inode.child;
 678             while (child != null) {
 679                 // (1) Assume each path from the zip file itself is &quot;normalized&quot;
 680                 // (2) IndexNode.name is absolute. see IndexNode(byte[],int,int)
 681                 // (3) If parent &quot;dir&quot; is relative when ZipDirectoryStream
 682                 //     is created, the returned child path needs to be relative
 683                 //     as well.
 684                 ZipPath childPath = new ZipPath(this, child.name, true);
 685                 ZipPath childFileName = childPath.getFileName();
 686                 ZipPath zpath = dir.resolve(childFileName);
 687                 if (filter == null || filter.accept(zpath))
 688                     list.add(zpath);
 689                 child = child.sibling;
 690             }
 691             return list.iterator();
 692         } finally {
 693             endWrite();
 694         }
 695     }
 696 
 697     void createDirectory(byte[] dir, FileAttribute&lt;?&gt;... attrs) throws IOException {
 698         checkWritable();
 699         beginWrite();
 700         try {
 701             ensureOpen();
 702             if (dir.length == 0 || exists(dir))  // root dir, or existing dir
 703                 throw new FileAlreadyExistsException(getString(dir));
 704             checkParents(dir);
 705             Entry e = supportPosix ?
 706                 new PosixEntry(dir, Entry.NEW, true, METHOD_STORED, attrs) :
 707                 new Entry(dir, Entry.NEW, true, METHOD_STORED, attrs);
 708             update(e);
 709         } finally {
 710             endWrite();
 711         }
 712     }
 713 
 714     void copyFile(boolean deletesrc, byte[]src, byte[] dst, CopyOption... options)
 715         throws IOException
 716     {
 717         checkWritable();
 718         if (Arrays.equals(src, dst))
 719             return;    // do nothing, src and dst are the same
 720 
 721         beginWrite();
 722         try {
 723             ensureOpen();
 724             Entry eSrc = getEntry(src);  // ensureOpen checked
 725 
 726             if (eSrc == null)
 727                 throw new NoSuchFileException(getString(src));
 728             if (eSrc.isDir()) {    // spec says to create dst dir
 729                 createDirectory(dst);
 730                 return;
 731             }
 732             boolean hasReplace = false;
 733             boolean hasCopyAttrs = false;
 734             for (CopyOption opt : options) {
 735                 if (opt == REPLACE_EXISTING)
 736                     hasReplace = true;
 737                 else if (opt == COPY_ATTRIBUTES)
 738                     hasCopyAttrs = true;
 739             }
 740             Entry eDst = getEntry(dst);
 741             if (eDst != null) {
 742                 if (!hasReplace)
 743                     throw new FileAlreadyExistsException(getString(dst));
 744             } else {
 745                 checkParents(dst);
 746             }
 747             // copy eSrc entry and change name
 748             Entry u = supportPosix ?
 749                 new PosixEntry((PosixEntry)eSrc, Entry.COPY) :
 750                 new Entry(eSrc, Entry.COPY);
 751             u.name(dst);
 752             if (eSrc.type == Entry.NEW || eSrc.type == Entry.FILECH) {
 753                 u.type = eSrc.type;    // make it the same type
 754                 if (deletesrc) {       // if it&#39;s a &quot;rename&quot;, take the data
 755                     u.bytes = eSrc.bytes;
 756                     u.file = eSrc.file;
 757                 } else {               // if it&#39;s not &quot;rename&quot;, copy the data
 758                     if (eSrc.bytes != null)
 759                         u.bytes = Arrays.copyOf(eSrc.bytes, eSrc.bytes.length);
 760                     else if (eSrc.file != null) {
 761                         u.file = getTempPathForEntry(null);
 762                         Files.copy(eSrc.file, u.file, REPLACE_EXISTING);
 763                     }
 764                 }
 765             } else if (eSrc.type == Entry.CEN &amp;&amp; eSrc.method != defaultCompressionMethod) {
 766 
 767                 /**
 768                  * We are copying a file within the same Zip file using a
 769                  * different compression method.
 770                  */
 771                 try (InputStream in = newInputStream(src);
 772                      OutputStream out = newOutputStream(dst,
 773                              CREATE, TRUNCATE_EXISTING, WRITE)) {
 774                     in.transferTo(out);
 775                 }
 776                 u = getEntry(dst);
 777             }
 778 
 779             if (!hasCopyAttrs)
 780                 u.mtime = u.atime= u.ctime = System.currentTimeMillis();
 781             update(u);
 782             if (deletesrc)
 783                 updateDelete(eSrc);
 784         } finally {
 785             endWrite();
 786         }
 787     }
 788 
 789     // Returns an output stream for writing the contents into the specified
 790     // entry.
 791     OutputStream newOutputStream(byte[] path, OpenOption... options)
 792         throws IOException
 793     {
 794         checkWritable();
 795         boolean hasCreateNew = false;
 796         boolean hasCreate = false;
 797         boolean hasAppend = false;
 798         boolean hasTruncate = false;
 799         for (OpenOption opt : options) {
 800             if (opt == READ)
 801                 throw new IllegalArgumentException(&quot;READ not allowed&quot;);
 802             if (opt == CREATE_NEW)
 803                 hasCreateNew = true;
 804             if (opt == CREATE)
 805                 hasCreate = true;
 806             if (opt == APPEND)
 807                 hasAppend = true;
 808             if (opt == TRUNCATE_EXISTING)
 809                 hasTruncate = true;
 810         }
 811         if (hasAppend &amp;&amp; hasTruncate)
 812             throw new IllegalArgumentException(&quot;APPEND + TRUNCATE_EXISTING not allowed&quot;);
 813         beginRead();                 // only need a readlock, the &quot;update()&quot; will
 814         try {                        // try to obtain a writelock when the os is
 815             ensureOpen();            // being closed.
 816             Entry e = getEntry(path);
 817             if (e != null) {
 818                 if (e.isDir() || hasCreateNew)
 819                     throw new FileAlreadyExistsException(getString(path));
 820                 if (hasAppend) {
 821                     OutputStream os = getOutputStream(new Entry(e, Entry.NEW));
 822                     try (InputStream is = getInputStream(e)) {
 823                         is.transferTo(os);
 824                     }
 825                     return os;
 826                 }
 827                 return getOutputStream(supportPosix ?
 828                     new PosixEntry((PosixEntry)e, Entry.NEW, defaultCompressionMethod)
 829                         : new Entry(e, Entry.NEW, defaultCompressionMethod));
 830             } else {
 831                 if (!hasCreate &amp;&amp; !hasCreateNew)
 832                     throw new NoSuchFileException(getString(path));
 833                 checkParents(path);
 834                 return getOutputStream(supportPosix ?
 835                     new PosixEntry(path, Entry.NEW, false, defaultCompressionMethod) :
 836                     new Entry(path, Entry.NEW, false, defaultCompressionMethod));
 837             }
 838         } finally {
 839             endRead();
 840         }
 841     }
 842 
 843     // Returns an input stream for reading the contents of the specified
 844     // file entry.
 845     InputStream newInputStream(byte[] path) throws IOException {
 846         beginRead();
 847         try {
 848             ensureOpen();
 849             Entry e = getEntry(path);
 850             if (e == null)
 851                 throw new NoSuchFileException(getString(path));
 852             if (e.isDir())
 853                 throw new FileSystemException(getString(path), &quot;is a directory&quot;, null);
 854             return getInputStream(e);
 855         } finally {
 856             endRead();
 857         }
 858     }
 859 
 860     private void checkOptions(Set&lt;? extends OpenOption&gt; options) {
 861         // check for options of null type and option is an intance of StandardOpenOption
 862         for (OpenOption option : options) {
 863             if (option == null)
 864                 throw new NullPointerException();
 865             if (!(option instanceof StandardOpenOption))
 866                 throw new IllegalArgumentException();
 867         }
 868         if (options.contains(APPEND) &amp;&amp; options.contains(TRUNCATE_EXISTING))
 869             throw new IllegalArgumentException(&quot;APPEND + TRUNCATE_EXISTING not allowed&quot;);
 870     }
 871 
 872     // Returns an output SeekableByteChannel for either
 873     // (1) writing the contents of a new entry, if the entry doesn&#39;t exist, or
 874     // (2) updating/replacing the contents of an existing entry.
 875     // Note: The content of the channel is not compressed until the
 876     // channel is closed
 877     private class EntryOutputChannel extends ByteArrayChannel {
 878         final Entry e;
 879 
 880         EntryOutputChannel(Entry e) {
 881             super(e.size &gt; 0? (int)e.size : 8192, false);
 882             this.e = e;
 883             if (e.mtime == -1)
 884                 e.mtime = System.currentTimeMillis();
 885             if (e.method == -1)
 886                 e.method = defaultCompressionMethod;
 887             // store size, compressed size, and crc-32 in datadescriptor
 888             e.flag = FLAG_DATADESCR;
 889             if (zc.isUTF8())
 890                 e.flag |= FLAG_USE_UTF8;
 891         }
 892 
 893         @Override
 894         public void close() throws IOException {
 895             // will update the entry
 896             try (OutputStream os = getOutputStream(e)) {
 897                 os.write(toByteArray());
 898             }
 899             super.close();
 900         }
 901     }
 902 
 903     // Returns a Writable/ReadByteChannel for now. Might consider to use
 904     // newFileChannel() instead, which dump the entry data into a regular
 905     // file on the default file system and create a FileChannel on top of it.
 906     SeekableByteChannel newByteChannel(byte[] path,
 907                                        Set&lt;? extends OpenOption&gt; options,
 908                                        FileAttribute&lt;?&gt;... attrs)
 909         throws IOException
 910     {
 911         checkOptions(options);
 912         if (options.contains(StandardOpenOption.WRITE) ||
 913             options.contains(StandardOpenOption.APPEND)) {
 914             checkWritable();
 915             beginRead();    // only need a read lock, the &quot;update()&quot; will obtain
 916                             // the write lock when the channel is closed
 917             try {
 918                 Entry e = getEntry(path);
 919                 if (e != null) {
 920                     if (e.isDir() || options.contains(CREATE_NEW))
 921                         throw new FileAlreadyExistsException(getString(path));
 922                     SeekableByteChannel sbc =
 923                             new EntryOutputChannel(supportPosix ?
 924                                 new PosixEntry((PosixEntry)e, Entry.NEW) :
 925                                 new Entry(e, Entry.NEW));
 926                     if (options.contains(APPEND)) {
 927                         try (InputStream is = getInputStream(e)) {  // copyover
 928                             byte[] buf = new byte[8192];
 929                             ByteBuffer bb = ByteBuffer.wrap(buf);
 930                             int n;
 931                             while ((n = is.read(buf)) != -1) {
 932                                 bb.position(0);
 933                                 bb.limit(n);
 934                                 sbc.write(bb);
 935                             }
 936                         }
 937                     }
 938                     return sbc;
 939                 }
 940                 if (!options.contains(CREATE) &amp;&amp; !options.contains(CREATE_NEW))
 941                     throw new NoSuchFileException(getString(path));
 942                 checkParents(path);
 943                 return new EntryOutputChannel(
 944                     supportPosix ?
 945                         new PosixEntry(path, Entry.NEW, false, defaultCompressionMethod, attrs) :
 946                         new Entry(path, Entry.NEW, false, defaultCompressionMethod, attrs));
 947             } finally {
 948                 endRead();
 949             }
 950         } else {
 951             beginRead();
 952             try {
 953                 ensureOpen();
 954                 Entry e = getEntry(path);
 955                 if (e == null || e.isDir())
 956                     throw new NoSuchFileException(getString(path));
 957                 try (InputStream is = getInputStream(e)) {
 958                     // TBD: if (e.size &lt; NNNNN);
 959                     return new ByteArrayChannel(is.readAllBytes(), true);
 960                 }
 961             } finally {
 962                 endRead();
 963             }
 964         }
 965     }
 966 
 967     // Returns a FileChannel of the specified entry.
 968     //
 969     // This implementation creates a temporary file on the default file system,
 970     // copy the entry data into it if the entry exists, and then create a
 971     // FileChannel on top of it.
 972     FileChannel newFileChannel(byte[] path,
 973                                Set&lt;? extends OpenOption&gt; options,
 974                                FileAttribute&lt;?&gt;... attrs)
 975         throws IOException
 976     {
 977         checkOptions(options);
 978         final  boolean forWrite = (options.contains(StandardOpenOption.WRITE) ||
 979                                    options.contains(StandardOpenOption.APPEND));
 980         beginRead();
 981         try {
 982             ensureOpen();
 983             Entry e = getEntry(path);
 984             if (forWrite) {
 985                 checkWritable();
 986                 if (e == null) {
 987                     if (!options.contains(StandardOpenOption.CREATE) &amp;&amp;
 988                         !options.contains(StandardOpenOption.CREATE_NEW)) {
 989                         throw new NoSuchFileException(getString(path));
 990                     }
 991                 } else {
 992                     if (options.contains(StandardOpenOption.CREATE_NEW)) {
 993                         throw new FileAlreadyExistsException(getString(path));
 994                     }
 995                     if (e.isDir())
 996                         throw new FileAlreadyExistsException(&quot;directory &lt;&quot;
 997                             + getString(path) + &quot;&gt; exists&quot;);
 998                 }
 999                 options = new HashSet&lt;&gt;(options);
1000                 options.remove(StandardOpenOption.CREATE_NEW); // for tmpfile
1001             } else if (e == null || e.isDir()) {
1002                 throw new NoSuchFileException(getString(path));
1003             }
1004 
1005             final boolean isFCH = (e != null &amp;&amp; e.type == Entry.FILECH);
1006             final Path tmpfile = isFCH ? e.file : getTempPathForEntry(path);
1007             final FileChannel fch = tmpfile.getFileSystem()
1008                                            .provider()
1009                                            .newFileChannel(tmpfile, options, attrs);
1010             final Entry u = isFCH ? e : (
1011                 supportPosix ?
1012                 new PosixEntry(path, tmpfile, Entry.FILECH, attrs) :
1013                 new Entry(path, tmpfile, Entry.FILECH, attrs));
1014             if (forWrite) {
1015                 u.flag = FLAG_DATADESCR;
1016                 u.method = defaultCompressionMethod;
1017             }
1018             // is there a better way to hook into the FileChannel&#39;s close method?
1019             return new FileChannel() {
1020                 public int write(ByteBuffer src) throws IOException {
1021                     return fch.write(src);
1022                 }
1023                 public long write(ByteBuffer[] srcs, int offset, int length)
1024                     throws IOException
1025                 {
1026                     return fch.write(srcs, offset, length);
1027                 }
1028                 public long position() throws IOException {
1029                     return fch.position();
1030                 }
1031                 public FileChannel position(long newPosition)
1032                     throws IOException
1033                 {
1034                     fch.position(newPosition);
1035                     return this;
1036                 }
1037                 public long size() throws IOException {
1038                     return fch.size();
1039                 }
1040                 public FileChannel truncate(long size)
1041                     throws IOException
1042                 {
1043                     fch.truncate(size);
1044                     return this;
1045                 }
1046                 public void force(boolean metaData)
1047                     throws IOException
1048                 {
1049                     fch.force(metaData);
1050                 }
1051                 public long transferTo(long position, long count,
1052                                        WritableByteChannel target)
1053                     throws IOException
1054                 {
1055                     return fch.transferTo(position, count, target);
1056                 }
1057                 public long transferFrom(ReadableByteChannel src,
1058                                          long position, long count)
1059                     throws IOException
1060                 {
1061                     return fch.transferFrom(src, position, count);
1062                 }
1063                 public int read(ByteBuffer dst) throws IOException {
1064                     return fch.read(dst);
1065                 }
1066                 public int read(ByteBuffer dst, long position)
1067                     throws IOException
1068                 {
1069                     return fch.read(dst, position);
1070                 }
1071                 public long read(ByteBuffer[] dsts, int offset, int length)
1072                     throws IOException
1073                 {
1074                     return fch.read(dsts, offset, length);
1075                 }
1076                 public int write(ByteBuffer src, long position)
1077                     throws IOException
1078                     {
1079                    return fch.write(src, position);
1080                 }
1081                 public MappedByteBuffer map(MapMode mode,
1082                                             long position, long size)
1083                 {
1084                     throw new UnsupportedOperationException();
1085                 }
1086                 public FileLock lock(long position, long size, boolean shared)
1087                     throws IOException
1088                 {
1089                     return fch.lock(position, size, shared);
1090                 }
1091                 public FileLock tryLock(long position, long size, boolean shared)
1092                     throws IOException
1093                 {
1094                     return fch.tryLock(position, size, shared);
1095                 }
1096                 protected void implCloseChannel() throws IOException {
1097                     fch.close();
1098                     if (forWrite) {
1099                         u.mtime = System.currentTimeMillis();
1100                         u.size = Files.size(u.file);
1101                         update(u);
1102                     } else {
1103                         if (!isFCH)    // if this is a new fch for reading
1104                             removeTempPathForEntry(tmpfile);
1105                     }
1106                }
1107             };
1108         } finally {
1109             endRead();
1110         }
1111     }
1112 
1113     // the outstanding input streams that need to be closed
1114     private Set&lt;InputStream&gt; streams =
1115         Collections.synchronizedSet(new HashSet&lt;&gt;());
1116 
1117     // the ex-channel and ex-path that need to close when their outstanding
1118     // input streams are all closed by the obtainers.
1119     private final Set&lt;ExistingChannelCloser&gt; exChClosers = new HashSet&lt;&gt;();
1120 
1121     private final Set&lt;Path&gt; tmppaths = Collections.synchronizedSet(new HashSet&lt;&gt;());
1122     private Path getTempPathForEntry(byte[] path) throws IOException {
1123         Path tmpPath = createTempFileInSameDirectoryAs(zfpath);
1124         if (path != null) {
1125             Entry e = getEntry(path);
1126             if (e != null) {
1127                 try (InputStream is = newInputStream(path)) {
1128                     Files.copy(is, tmpPath, REPLACE_EXISTING);
1129                 }
1130             }
1131         }
1132         return tmpPath;
1133     }
1134 
1135     private void removeTempPathForEntry(Path path) throws IOException {
1136         Files.delete(path);
1137         tmppaths.remove(path);
1138     }
1139 
1140     // check if all parents really exist. ZIP spec does not require
1141     // the existence of any &quot;parent directory&quot;.
1142     private void checkParents(byte[] path) throws IOException {
1143         beginRead();
1144         try {
1145             while ((path = getParent(path)) != null &amp;&amp;
1146                     path != ROOTPATH) {
1147                 if (!inodes.containsKey(IndexNode.keyOf(path))) {
1148                     throw new NoSuchFileException(getString(path));
1149                 }
1150             }
1151         } finally {
1152             endRead();
1153         }
1154     }
1155 
1156     private static byte[] getParent(byte[] path) {
1157         int off = getParentOff(path);
1158         if (off &lt;= 1)
1159             return ROOTPATH;
1160         return Arrays.copyOf(path, off);
1161     }
1162 
1163     private static int getParentOff(byte[] path) {
1164         int off = path.length - 1;
1165         if (off &gt; 0 &amp;&amp; path[off] == &#39;/&#39;)  // isDirectory
1166             off--;
1167         while (off &gt; 0 &amp;&amp; path[off] != &#39;/&#39;) { off--; }
1168         return off;
1169     }
1170 
1171     private void beginWrite() {
1172         rwlock.writeLock().lock();
1173     }
1174 
1175     private void endWrite() {
1176         rwlock.writeLock().unlock();
1177     }
1178 
1179     private void beginRead() {
1180         rwlock.readLock().lock();
1181     }
1182 
1183     private void endRead() {
1184         rwlock.readLock().unlock();
1185     }
1186 
1187     ///////////////////////////////////////////////////////////////////
1188 
1189     private volatile boolean isOpen = true;
1190     private final SeekableByteChannel ch; // channel to the zipfile
1191     final byte[]  cen;     // CEN &amp; ENDHDR
1192     private END  end;
1193     private long locpos;   // position of first LOC header (usually 0)
1194 
1195     private final ReadWriteLock rwlock = new ReentrantReadWriteLock();
1196 
1197     // name -&gt; pos (in cen), IndexNode itself can be used as a &quot;key&quot;
1198     private LinkedHashMap&lt;IndexNode, IndexNode&gt; inodes;
1199 
1200     final byte[] getBytes(String name) {
1201         return zc.getBytes(name);
1202     }
1203 
1204     final String getString(byte[] name) {
1205         return zc.toString(name);
1206     }
1207 
1208     @SuppressWarnings(&quot;deprecation&quot;)
1209     protected void finalize() throws IOException {
1210         close();
1211     }
1212 
1213     // Reads len bytes of data from the specified offset into buf.
1214     // Returns the total number of bytes read.
1215     // Each/every byte read from here (except the cen, which is mapped).
1216     final long readFullyAt(byte[] buf, int off, long len, long pos)
1217         throws IOException
1218     {
1219         ByteBuffer bb = ByteBuffer.wrap(buf);
1220         bb.position(off);
1221         bb.limit((int)(off + len));
1222         return readFullyAt(bb, pos);
1223     }
1224 
1225     private long readFullyAt(ByteBuffer bb, long pos) throws IOException {
1226         synchronized(ch) {
1227             return ch.position(pos).read(bb);
1228         }
1229     }
1230 
1231     // Searches for end of central directory (END) header. The contents of
1232     // the END header will be read and placed in endbuf. Returns the file
1233     // position of the END header, otherwise returns -1 if the END header
1234     // was not found or an error occurred.
1235     private END findEND() throws IOException {
1236         byte[] buf = new byte[READBLOCKSZ];
1237         long ziplen = ch.size();
1238         long minHDR = (ziplen - END_MAXLEN) &gt; 0 ? ziplen - END_MAXLEN : 0;
1239         long minPos = minHDR - (buf.length - ENDHDR);
1240 
1241         for (long pos = ziplen - buf.length; pos &gt;= minPos; pos -= (buf.length - ENDHDR)) {
1242             int off = 0;
1243             if (pos &lt; 0) {
1244                 // Pretend there are some NUL bytes before start of file
1245                 off = (int)-pos;
1246                 Arrays.fill(buf, 0, off, (byte)0);
1247             }
1248             int len = buf.length - off;
1249             if (readFullyAt(buf, off, len, pos + off) != len)
1250                 throw new ZipException(&quot;zip END header not found&quot;);
1251 
1252             // Now scan the block backwards for END header signature
1253             for (int i = buf.length - ENDHDR; i &gt;= 0; i--) {
1254                 if (buf[i]   == (byte)&#39;P&#39;    &amp;&amp;
1255                     buf[i+1] == (byte)&#39;K&#39;    &amp;&amp;
1256                     buf[i+2] == (byte)&#39;\005&#39; &amp;&amp;
1257                     buf[i+3] == (byte)&#39;\006&#39; &amp;&amp;
1258                     (pos + i + ENDHDR + ENDCOM(buf, i) == ziplen)) {
1259                     // Found END header
1260                     buf = Arrays.copyOfRange(buf, i, i + ENDHDR);
1261                     END end = new END();
1262                     // end.endsub = ENDSUB(buf); // not used
1263                     end.centot = ENDTOT(buf);
1264                     end.cenlen = ENDSIZ(buf);
1265                     end.cenoff = ENDOFF(buf);
1266                     // end.comlen = ENDCOM(buf); // not used
1267                     end.endpos = pos + i;
1268                     // try if there is zip64 end;
1269                     byte[] loc64 = new byte[ZIP64_LOCHDR];
1270                     if (end.endpos &lt; ZIP64_LOCHDR ||
1271                         readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)
1272                         != loc64.length ||
1273                         !locator64SigAt(loc64, 0)) {
1274                         return end;
1275                     }
1276                     long end64pos = ZIP64_LOCOFF(loc64);
1277                     byte[] end64buf = new byte[ZIP64_ENDHDR];
1278                     if (readFullyAt(end64buf, 0, end64buf.length, end64pos)
1279                         != end64buf.length ||
1280                         !end64SigAt(end64buf, 0)) {
1281                         return end;
1282                     }
1283                     // end64 found,
1284                     long cenlen64 = ZIP64_ENDSIZ(end64buf);
1285                     long cenoff64 = ZIP64_ENDOFF(end64buf);
1286                     long centot64 = ZIP64_ENDTOT(end64buf);
1287                     // double-check
1288                     if (cenlen64 != end.cenlen &amp;&amp; end.cenlen != ZIP64_MINVAL ||
1289                         cenoff64 != end.cenoff &amp;&amp; end.cenoff != ZIP64_MINVAL ||
1290                         centot64 != end.centot &amp;&amp; end.centot != ZIP64_MINVAL32) {
1291                         return end;
1292                     }
1293                     // to use the end64 values
1294                     end.cenlen = cenlen64;
1295                     end.cenoff = cenoff64;
1296                     end.centot = (int)centot64; // assume total &lt; 2g
1297                     end.endpos = end64pos;
1298                     return end;
1299                 }
1300             }
1301         }
1302         throw new ZipException(&quot;zip END header not found&quot;);
1303     }
1304 
1305     private void makeParentDirs(IndexNode node, IndexNode root) {
1306         IndexNode parent;
1307         ParentLookup lookup = new ParentLookup();
1308         while (true) {
1309             int off = getParentOff(node.name);
1310             // parent is root
1311             if (off &lt;= 1) {
1312                 node.sibling = root.child;
1313                 root.child = node;
1314                 break;
1315             }
1316             // parent exists
1317             lookup = lookup.as(node.name, off);
1318             if (inodes.containsKey(lookup)) {
1319                 parent = inodes.get(lookup);
1320                 node.sibling = parent.child;
1321                 parent.child = node;
1322                 break;
1323             }
1324             // parent does not exist, add new pseudo directory entry
1325             parent = new IndexNode(Arrays.copyOf(node.name, off), true);
1326             inodes.put(parent, parent);
1327             node.sibling = parent.child;
1328             parent.child = node;
1329             node = parent;
1330         }
1331     }
1332 
1333     // ZIP directory has two issues:
1334     // (1) ZIP spec does not require the ZIP file to include
1335     //     directory entry
1336     // (2) all entries are not stored/organized in a &quot;tree&quot;
1337     //     structure.
1338     // A possible solution is to build the node tree ourself as
1339     // implemented below.
1340     private void buildNodeTree() {
1341         beginWrite();
1342         try {
1343             IndexNode root = inodes.remove(LOOKUPKEY.as(ROOTPATH));
1344             if (root == null) {
1345                 root = new IndexNode(ROOTPATH, true);
1346             }
1347             IndexNode[] nodes = inodes.values().toArray(new IndexNode[0]);
1348             inodes.put(root, root);
1349             for (IndexNode node : nodes) {
1350                 makeParentDirs(node, root);
1351             }
1352         } finally {
1353             endWrite();
1354         }
1355     }
1356 
1357     private void removeFromTree(IndexNode inode) {
1358         IndexNode parent = inodes.get(LOOKUPKEY.as(getParent(inode.name)));
1359         IndexNode child = parent.child;
1360         if (child.equals(inode)) {
1361             parent.child = child.sibling;
1362         } else {
1363             IndexNode last = child;
1364             while ((child = child.sibling) != null) {
1365                 if (child.equals(inode)) {
1366                     last.sibling = child.sibling;
1367                     break;
1368                 } else {
1369                     last = child;
1370                 }
1371             }
1372         }
1373     }
1374 
1375     /**
1376      * If a version property has been specified and the file represents a multi-release JAR,
1377      * determine the requested runtime version and initialize the ZipFileSystem instance accordingly.
1378      *
1379      * Checks if the Zip File System property &quot;releaseVersion&quot; has been specified. If it has,
1380      * use its value to determine the requested version. If not use the value of the &quot;multi-release&quot; property.
1381      */
1382     private void initializeReleaseVersion(Map&lt;String, ?&gt; env) throws IOException {
1383         Object o = env.containsKey(PROPERTY_RELEASE_VERSION) ?
1384             env.get(PROPERTY_RELEASE_VERSION) :
1385             env.get(PROPERTY_MULTI_RELEASE);
1386 
1387         if (o != null &amp;&amp; isMultiReleaseJar()) {
1388             int version;
1389             if (o instanceof String) {
1390                 String s = (String)o;
1391                 if (s.equals(&quot;runtime&quot;)) {
1392                     version = Runtime.version().feature();
1393                 } else if (s.matches(&quot;^[1-9][0-9]*$&quot;)) {
1394                     version = Version.parse(s).feature();
1395                 } else {
1396                     throw new IllegalArgumentException(&quot;Invalid runtime version&quot;);
1397                 }
1398             } else if (o instanceof Integer) {
1399                 version = Version.parse(((Integer)o).toString()).feature();
1400             } else if (o instanceof Version) {
1401                 version = ((Version)o).feature();
1402             } else {
1403                 throw new IllegalArgumentException(&quot;env parameter must be String, &quot; +
1404                     &quot;Integer, or Version&quot;);
1405             }
1406             createVersionedLinks(version &lt; 0 ? 0 : version);
1407             setReadOnly();
1408         }
1409     }
1410 
1411     /**
1412      * Returns true if the Manifest main attribute &quot;Multi-Release&quot; is set to true; false otherwise.
1413      */
1414     private boolean isMultiReleaseJar() throws IOException {
1415         try (InputStream is = newInputStream(getBytes(&quot;/META-INF/MANIFEST.MF&quot;))) {
1416             String multiRelease = new Manifest(is).getMainAttributes()
1417                 .getValue(Attributes.Name.MULTI_RELEASE);
1418             return &quot;true&quot;.equalsIgnoreCase(multiRelease);
1419         } catch (NoSuchFileException x) {
1420             return false;
1421         }
1422     }
1423 
1424     /**
1425      * Create a map of aliases for versioned entries, for example:
1426      *   version/PackagePrivate.class -&gt; META-INF/versions/9/version/PackagePrivate.class
1427      *   version/PackagePrivate.java -&gt; META-INF/versions/9/version/PackagePrivate.java
1428      *   version/Version.class -&gt; META-INF/versions/10/version/Version.class
1429      *   version/Version.java -&gt; META-INF/versions/10/version/Version.java
1430      *
1431      * Then wrap the map in a function that getEntry can use to override root
1432      * entry lookup for entries that have corresponding versioned entries.
1433      */
1434     private void createVersionedLinks(int version) {
1435         IndexNode verdir = getInode(getBytes(&quot;/META-INF/versions&quot;));
1436         // nothing to do, if no /META-INF/versions
1437         if (verdir == null) {
1438             return;
1439         }
1440         // otherwise, create a map and for each META-INF/versions/{n} directory
1441         // put all the leaf inodes, i.e. entries, into the alias map
1442         // possibly shadowing lower versioned entries
1443         HashMap&lt;IndexNode, byte[]&gt; aliasMap = new HashMap&lt;&gt;();
1444         getVersionMap(version, verdir).values().forEach(versionNode -&gt;
1445             walk(versionNode.child, entryNode -&gt;
1446                 aliasMap.put(
1447                     getOrCreateInode(getRootName(entryNode, versionNode), entryNode.isdir),
1448                     entryNode.name))
1449         );
1450         entryLookup = path -&gt; {
1451             byte[] entry = aliasMap.get(IndexNode.keyOf(path));
1452             return entry == null ? path : entry;
1453         };
1454     }
1455 
1456     /**
1457      * Create a sorted version map of version -&gt; inode, for inodes &lt;= max version.
1458      *   9 -&gt; META-INF/versions/9
1459      *  10 -&gt; META-INF/versions/10
1460      */
1461     private TreeMap&lt;Integer, IndexNode&gt; getVersionMap(int version, IndexNode metaInfVersions) {
1462         TreeMap&lt;Integer,IndexNode&gt; map = new TreeMap&lt;&gt;();
1463         IndexNode child = metaInfVersions.child;
1464         while (child != null) {
1465             Integer key = getVersion(child, metaInfVersions);
1466             if (key != null &amp;&amp; key &lt;= version) {
1467                 map.put(key, child);
1468             }
1469             child = child.sibling;
1470         }
1471         return map;
1472     }
1473 
1474     /**
1475      * Extract the integer version number -- META-INF/versions/9 returns 9.
1476      */
1477     private Integer getVersion(IndexNode inode, IndexNode metaInfVersions) {
1478         try {
1479             byte[] fullName = inode.name;
1480             return Integer.parseInt(getString(Arrays
1481                 .copyOfRange(fullName, metaInfVersions.name.length + 1, fullName.length)));
1482         } catch (NumberFormatException x) {
1483             // ignore this even though it might indicate issues with the JAR structure
1484             return null;
1485         }
1486     }
1487 
1488     /**
1489      * Walk the IndexNode tree processing all leaf nodes.
1490      */
1491     private void walk(IndexNode inode, Consumer&lt;IndexNode&gt; consumer) {
1492         if (inode == null) return;
1493         if (inode.isDir()) {
1494             walk(inode.child, consumer);
1495         } else {
1496             consumer.accept(inode);
1497         }
1498         walk(inode.sibling, consumer);
1499     }
1500 
1501     /**
1502      * Extract the root name from a versioned entry name.
1503      * E.g. given inode &#39;META-INF/versions/9/foo/bar.class&#39;
1504      * and prefix &#39;META-INF/versions/9/&#39; returns &#39;foo/bar.class&#39;.
1505      */
1506     private byte[] getRootName(IndexNode inode, IndexNode prefix) {
1507         byte[] fullName = inode.name;
1508         return Arrays.copyOfRange(fullName, prefix.name.length, fullName.length);
1509     }
1510 
1511     // Reads zip file central directory. Returns the file position of first
1512     // CEN header, otherwise returns -1 if an error occurred. If zip-&gt;msg != NULL
1513     // then the error was a zip format error and zip-&gt;msg has the error text.
1514     // Always pass in -1 for knownTotal; it&#39;s used for a recursive call.
1515     private byte[] initCEN() throws IOException {
1516         end = findEND();
1517         if (end.endpos == 0) {
1518             inodes = new LinkedHashMap&lt;&gt;(10);
1519             locpos = 0;
1520             buildNodeTree();
1521             return null;         // only END header present
1522         }
1523         if (end.cenlen &gt; end.endpos)
1524             throw new ZipException(&quot;invalid END header (bad central directory size)&quot;);
1525         long cenpos = end.endpos - end.cenlen;     // position of CEN table
1526 
1527         // Get position of first local file (LOC) header, taking into
1528         // account that there may be a stub prefixed to the zip file.
1529         locpos = cenpos - end.cenoff;
1530         if (locpos &lt; 0)
1531             throw new ZipException(&quot;invalid END header (bad central directory offset)&quot;);
1532 
1533         // read in the CEN and END
1534         byte[] cen = new byte[(int)(end.cenlen + ENDHDR)];
1535         if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
1536             throw new ZipException(&quot;read CEN tables failed&quot;);
1537         }
1538         // Iterate through the entries in the central directory
1539         inodes = new LinkedHashMap&lt;&gt;(end.centot + 1);
1540         int pos = 0;
1541         int limit = cen.length - ENDHDR;
1542         while (pos &lt; limit) {
1543             if (!cenSigAt(cen, pos))
1544                 throw new ZipException(&quot;invalid CEN header (bad signature)&quot;);
1545             int method = CENHOW(cen, pos);
1546             int nlen   = CENNAM(cen, pos);
1547             int elen   = CENEXT(cen, pos);
1548             int clen   = CENCOM(cen, pos);
1549             if ((CENFLG(cen, pos) &amp; 1) != 0) {
1550                 throw new ZipException(&quot;invalid CEN header (encrypted entry)&quot;);
1551             }
1552             if (method != METHOD_STORED &amp;&amp; method != METHOD_DEFLATED) {
1553                 throw new ZipException(&quot;invalid CEN header (unsupported compression method: &quot; + method + &quot;)&quot;);
1554             }
1555             if (pos + CENHDR + nlen &gt; limit) {
1556                 throw new ZipException(&quot;invalid CEN header (bad header size)&quot;);
1557             }
1558             IndexNode inode = new IndexNode(cen, pos, nlen);
1559             inodes.put(inode, inode);
1560 
1561             // skip ext and comment
1562             pos += (CENHDR + nlen + elen + clen);
1563         }
1564         if (pos + ENDHDR != cen.length) {
1565             throw new ZipException(&quot;invalid CEN header (bad header size)&quot;);
1566         }
1567         buildNodeTree();
1568         return cen;
1569     }
1570 
1571     private void ensureOpen() {
1572         if (!isOpen)
1573             throw new ClosedFileSystemException();
1574     }
1575 
1576     // Creates a new empty temporary file in the same directory as the
1577     // specified file.  A variant of Files.createTempFile.
1578     private Path createTempFileInSameDirectoryAs(Path path) throws IOException {
1579         Path parent = path.toAbsolutePath().getParent();
1580         Path dir = (parent == null) ? path.getFileSystem().getPath(&quot;.&quot;) : parent;
1581         Path tmpPath = Files.createTempFile(dir, &quot;zipfstmp&quot;, null);
1582         tmppaths.add(tmpPath);
1583         return tmpPath;
1584     }
1585 
1586     ////////////////////update &amp; sync //////////////////////////////////////
1587 
1588     private boolean hasUpdate = false;
1589 
1590     // shared key. consumer guarantees the &quot;writeLock&quot; before use it.
1591     private final IndexNode LOOKUPKEY = new IndexNode(null, -1);
1592 
1593     private void updateDelete(IndexNode inode) {
1594         beginWrite();
1595         try {
1596             removeFromTree(inode);
1597             inodes.remove(inode);
1598             hasUpdate = true;
1599         } finally {
1600              endWrite();
1601         }
1602     }
1603 
1604     private void update(Entry e) {
1605         beginWrite();
1606         try {
1607             IndexNode old = inodes.put(e, e);
1608             if (old != null) {
1609                 removeFromTree(old);
1610             }
1611             if (e.type == Entry.NEW || e.type == Entry.FILECH || e.type == Entry.COPY) {
1612                 IndexNode parent = inodes.get(LOOKUPKEY.as(getParent(e.name)));
1613                 e.sibling = parent.child;
1614                 parent.child = e;
1615             }
1616             hasUpdate = true;
1617         } finally {
1618             endWrite();
1619         }
1620     }
1621 
1622     // copy over the whole LOC entry (header if necessary, data and ext) from
1623     // old zip to the new one.
1624     private long copyLOCEntry(Entry e, boolean updateHeader,
1625                               OutputStream os,
1626                               long written, byte[] buf)
1627         throws IOException
1628     {
1629         long locoff = e.locoff;  // where to read
1630         e.locoff = written;      // update the e.locoff with new value
1631 
1632         // calculate the size need to write out
1633         long size = 0;
1634         //  if there is A ext
1635         if ((e.flag &amp; FLAG_DATADESCR) != 0) {
1636             if (e.size &gt;= ZIP64_MINVAL || e.csize &gt;= ZIP64_MINVAL)
1637                 size = 24;
1638             else
1639                 size = 16;
1640         }
1641         // read loc, use the original loc.elen/nlen
1642         //
1643         // an extra byte after loc is read, which should be the first byte of the
1644         // &#39;name&#39; field of the loc. if this byte is &#39;/&#39;, which means the original
1645         // entry has an absolute path in original zip/jar file, the e.writeLOC()
1646         // is used to output the loc, in which the leading &quot;/&quot; will be removed
1647         if (readFullyAt(buf, 0, LOCHDR + 1 , locoff) != LOCHDR + 1)
1648             throw new ZipException(&quot;loc: reading failed&quot;);
1649 
1650         if (updateHeader || LOCNAM(buf) &gt; 0 &amp;&amp; buf[LOCHDR] == &#39;/&#39;) {
1651             locoff += LOCHDR + LOCNAM(buf) + LOCEXT(buf);  // skip header
1652             size += e.csize;
1653             written = e.writeLOC(os) + size;
1654         } else {
1655             os.write(buf, 0, LOCHDR);    // write out the loc header
1656             locoff += LOCHDR;
1657             // use e.csize,  LOCSIZ(buf) is zero if FLAG_DATADESCR is on
1658             // size += LOCNAM(buf) + LOCEXT(buf) + LOCSIZ(buf);
1659             size += LOCNAM(buf) + LOCEXT(buf) + e.csize;
1660             written = LOCHDR + size;
1661         }
1662         int n;
1663         while (size &gt; 0 &amp;&amp;
1664             (n = (int)readFullyAt(buf, 0, buf.length, locoff)) != -1)
1665         {
1666             if (size &lt; n)
1667                 n = (int)size;
1668             os.write(buf, 0, n);
1669             size -= n;
1670             locoff += n;
1671         }
1672         return written;
1673     }
1674 
1675     private long writeEntry(Entry e, OutputStream os)
1676         throws IOException {
1677 
1678         if (e.bytes == null &amp;&amp; e.file == null)    // dir, 0-length data
1679             return 0;
1680 
1681         long written = 0;
1682         if (e.method != METHOD_STORED &amp;&amp; e.csize &gt; 0 &amp;&amp; (e.crc != 0 || e.size == 0)) {
1683             // pre-compressed entry, write directly to output stream
1684             writeTo(e, os);
1685         } else {
1686             try (OutputStream os2 = (e.method == METHOD_STORED) ?
1687                     new EntryOutputStreamCRC32(e, os) : new EntryOutputStreamDef(e, os)) {
1688                 writeTo(e, os2);
1689             }
1690         }
1691         written += e.csize;
1692         if ((e.flag &amp; FLAG_DATADESCR) != 0) {
1693             written += e.writeEXT(os);
1694         }
1695         return written;
1696     }
1697 
1698     private void writeTo(Entry e, OutputStream os) throws IOException {
1699         if (e.bytes != null) {
1700             os.write(e.bytes, 0, e.bytes.length);
1701         } else if (e.file != null) {
1702             if (e.type == Entry.NEW || e.type == Entry.FILECH) {
1703                 try (InputStream is = Files.newInputStream(e.file)) {
1704                     is.transferTo(os);
1705                 }
1706             }
1707             Files.delete(e.file);
1708             tmppaths.remove(e.file);
1709         }
1710     }
1711 
1712     // sync the zip file system, if there is any update
1713     private void sync() throws IOException {
1714         // check ex-closer
1715         if (!exChClosers.isEmpty()) {
1716             for (ExistingChannelCloser ecc : exChClosers) {
1717                 if (ecc.closeAndDeleteIfDone()) {
1718                     exChClosers.remove(ecc);
1719                 }
1720             }
1721         }
1722         if (!hasUpdate)
1723             return;
1724         PosixFileAttributes attrs = getPosixAttributes(zfpath);
1725         Path tmpFile = createTempFileInSameDirectoryAs(zfpath);
1726         try (OutputStream os = new BufferedOutputStream(Files.newOutputStream(tmpFile, WRITE))) {
1727             ArrayList&lt;Entry&gt; elist = new ArrayList&lt;&gt;(inodes.size());
1728             long written = 0;
1729             byte[] buf = null;
1730             Entry e;
1731 
1732             // write loc
1733             for (IndexNode inode : inodes.values()) {
1734                 if (inode instanceof Entry) {    // an updated inode
1735                     e = (Entry)inode;
1736                     try {
1737                         if (e.type == Entry.COPY) {
1738                             // entry copy: the only thing changed is the &quot;name&quot;
1739                             // and &quot;nlen&quot; in LOC header, so we update/rewrite the
1740                             // LOC in new file and simply copy the rest (data and
1741                             // ext) without enflating/deflating from the old zip
1742                             // file LOC entry.
1743                             if (buf == null)
1744                                 buf = new byte[8192];
1745                             written += copyLOCEntry(e, true, os, written, buf);
1746                         } else {                          // NEW, FILECH or CEN
1747                             e.locoff = written;
1748                             written += e.writeLOC(os);    // write loc header
1749                             written += writeEntry(e, os);
1750                         }
1751                         elist.add(e);
1752                     } catch (IOException x) {
1753                         x.printStackTrace();    // skip any in-accurate entry
1754                     }
1755                 } else {                        // unchanged inode
1756                     if (inode.pos == -1) {
1757                         continue;               // pseudo directory node
1758                     }
1759                     if (inode.name.length == 1 &amp;&amp; inode.name[0] == &#39;/&#39;) {
1760                         continue;               // no root &#39;/&#39; directory even if it
1761                                                 // exists in original zip/jar file.
1762                     }
1763                     e = supportPosix ? new PosixEntry(this, inode) : new Entry(this, inode);
1764                     try {
1765                         if (buf == null)
1766                             buf = new byte[8192];
1767                         written += copyLOCEntry(e, false, os, written, buf);
1768                         elist.add(e);
1769                     } catch (IOException x) {
1770                         x.printStackTrace();    // skip any wrong entry
1771                     }
1772                 }
1773             }
1774 
1775             // now write back the cen and end table
1776             end.cenoff = written;
1777             for (Entry entry : elist) {
1778                 written += entry.writeCEN(os);
1779             }
1780             end.centot = elist.size();
1781             end.cenlen = written - end.cenoff;
1782             end.write(os, written, forceEnd64);
1783         }
1784         if (!streams.isEmpty()) {
1785             //
1786             // There are outstanding input streams open on existing &quot;ch&quot;,
1787             // so, don&#39;t close the &quot;cha&quot; and delete the &quot;file for now, let
1788             // the &quot;ex-channel-closer&quot; to handle them
1789             Path path = createTempFileInSameDirectoryAs(zfpath);
1790             ExistingChannelCloser ecc = new ExistingChannelCloser(path,
1791                                                                   ch,
1792                                                                   streams);
1793             Files.move(zfpath, path, REPLACE_EXISTING);
1794             exChClosers.add(ecc);
1795             streams = Collections.synchronizedSet(new HashSet&lt;&gt;());
1796         } else {
1797             ch.close();
1798             Files.delete(zfpath);
1799         }
1800 
1801         // Set the POSIX permissions of the original Zip File if available
1802         // before moving the temp file
1803         if (attrs != null) {
1804             Files.setPosixFilePermissions(tmpFile, attrs.permissions());
1805         }
1806         Files.move(tmpFile, zfpath, REPLACE_EXISTING);
1807         hasUpdate = false;    // clear
1808     }
1809 
1810     /**
1811      * Returns a file&#39;s POSIX file attributes.
1812      * @param path The path to the file
1813      * @return The POSIX file attributes for the specified file or
1814      *         null if the POSIX attribute view is not available
1815      * @throws IOException If an error occurs obtaining the POSIX attributes for
1816      *                    the specified file
1817      */
1818     private PosixFileAttributes getPosixAttributes(Path path) throws IOException {
1819         try {
1820             PosixFileAttributeView view =
1821                     Files.getFileAttributeView(path, PosixFileAttributeView.class);
1822             // Return if the attribute view is not supported
1823             if (view == null) {
1824                 return null;
1825             }
1826             return view.readAttributes();
1827         } catch (UnsupportedOperationException e) {
1828             // PosixFileAttributes not available
1829             return null;
1830         }
1831     }
1832 
1833     private IndexNode getInode(byte[] path) {
1834         return inodes.get(IndexNode.keyOf(Objects.requireNonNull(entryLookup.apply(path), &quot;path&quot;)));
1835     }
1836 
1837     /**
1838      * Return the IndexNode from the root tree. If it doesn&#39;t exist,
1839      * it gets created along with all parent directory IndexNodes.
1840      */
1841     private IndexNode getOrCreateInode(byte[] path, boolean isdir) {
1842         IndexNode node = getInode(path);
1843         // if node exists, return it
1844         if (node != null) {
1845             return node;
1846         }
1847 
1848         // otherwise create new pseudo node and parent directory hierarchy
1849         node = new IndexNode(path, isdir);
1850         beginWrite();
1851         try {
1852             makeParentDirs(node, Objects.requireNonNull(inodes.get(IndexNode.keyOf(ROOTPATH)), &quot;no root node found&quot;));
1853             return node;
1854         } finally {
1855             endWrite();
1856         }
1857     }
1858 
1859     private Entry getEntry(byte[] path) throws IOException {
1860         IndexNode inode = getInode(path);
1861         if (inode instanceof Entry)
1862             return (Entry)inode;
1863         if (inode == null || inode.pos == -1)
1864             return null;
1865         return supportPosix ? new PosixEntry(this, inode): new Entry(this, inode);
1866     }
1867 
1868     public void deleteFile(byte[] path, boolean failIfNotExists)
1869         throws IOException
1870     {
1871         checkWritable();
1872         IndexNode inode = getInode(path);
1873         if (inode == null) {
1874             if (path != null &amp;&amp; path.length == 0)
1875                 throw new ZipException(&quot;root directory &lt;/&gt; can&#39;t not be delete&quot;);
1876             if (failIfNotExists)
1877                 throw new NoSuchFileException(getString(path));
1878         } else {
1879             if (inode.isDir() &amp;&amp; inode.child != null)
1880                 throw new DirectoryNotEmptyException(getString(path));
1881             updateDelete(inode);
1882         }
1883     }
1884 
1885     // Returns an out stream for either
1886     // (1) writing the contents of a new entry, if the entry exists, or
1887     // (2) updating/replacing the contents of the specified existing entry.
1888     private OutputStream getOutputStream(Entry e) throws IOException {
1889         if (e.mtime == -1)
1890             e.mtime = System.currentTimeMillis();
1891         if (e.method == -1)
1892             e.method = defaultCompressionMethod;
1893         // store size, compressed size, and crc-32 in datadescr
1894         e.flag = FLAG_DATADESCR;
1895         if (zc.isUTF8())
1896             e.flag |= FLAG_USE_UTF8;
1897         OutputStream os;
1898         if (useTempFile) {
1899             e.file = getTempPathForEntry(null);
1900             os = Files.newOutputStream(e.file, WRITE);
1901         } else {
1902             os = new ByteArrayOutputStream((e.size &gt; 0)? (int)e.size : 8192);
1903         }
1904         if (e.method == METHOD_DEFLATED) {
1905             return new DeflatingEntryOutputStream(e, os);
1906         } else {
1907             return new EntryOutputStream(e, os);
1908         }
1909     }
1910 
1911     private class EntryOutputStream extends FilterOutputStream {
1912         private final Entry e;
1913         private long written;
1914         private boolean isClosed;
1915 
1916         EntryOutputStream(Entry e, OutputStream os) {
1917             super(os);
1918             this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
1919             // this.written = 0;
1920         }
1921 
1922         @Override
1923         public synchronized void write(int b) throws IOException {
1924             out.write(b);
1925             written += 1;
1926         }
1927 
1928         @Override
1929         public synchronized void write(byte[] b, int off, int len)
1930                 throws IOException {
1931             out.write(b, off, len);
1932             written += len;
1933         }
1934 
1935         @Override
1936         public synchronized void close() throws IOException {
1937             if (isClosed) {
1938                 return;
1939             }
1940             isClosed = true;
1941             e.size = written;
1942             if (out instanceof ByteArrayOutputStream)
1943                 e.bytes = ((ByteArrayOutputStream)out).toByteArray();
1944             super.close();
1945             update(e);
1946         }
1947     }
1948 
1949     // Output stream returned when writing &quot;deflated&quot; entries into memory,
1950     // to enable eager (possibly parallel) deflation and reduce memory required.
1951     private class DeflatingEntryOutputStream extends DeflaterOutputStream {
1952         private final CRC32 crc;
1953         private final Entry e;
1954         private boolean isClosed;
1955 
1956         DeflatingEntryOutputStream(Entry e, OutputStream os) {
1957             super(os, getDeflater());
1958             this.e = Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
1959             this.crc = new CRC32();
1960         }
1961 
1962         @Override
1963         public synchronized void write(byte[] b, int off, int len)
1964                 throws IOException {
1965             super.write(b, off, len);
1966             crc.update(b, off, len);
1967         }
1968 
1969         @Override
1970         public synchronized void close() throws IOException {
1971             if (isClosed)
1972                 return;
1973             isClosed = true;
1974             finish();
1975             e.size  = def.getBytesRead();
1976             e.csize = def.getBytesWritten();
1977             e.crc = crc.getValue();
1978             if (out instanceof ByteArrayOutputStream)
1979                 e.bytes = ((ByteArrayOutputStream)out).toByteArray();
1980             super.close();
1981             update(e);
1982             releaseDeflater(def);
1983         }
1984     }
1985 
1986     // Wrapper output stream class to write out a &quot;stored&quot; entry.
1987     // (1) this class does not close the underlying out stream when
1988     //     being closed.
1989     // (2) no need to be &quot;synchronized&quot;, only used by sync()
1990     private class EntryOutputStreamCRC32 extends FilterOutputStream {
1991         private final CRC32 crc;
1992         private final Entry e;
1993         private long written;
1994         private boolean isClosed;
1995 
1996         EntryOutputStreamCRC32(Entry e, OutputStream os) {
1997             super(os);
1998             this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
1999             this.crc = new CRC32();
2000         }
2001 
2002         @Override
2003         public void write(int b) throws IOException {
2004             out.write(b);
2005             crc.update(b);
2006             written += 1;
2007         }
2008 
2009         @Override
2010         public void write(byte[] b, int off, int len)
2011                 throws IOException {
2012             out.write(b, off, len);
2013             crc.update(b, off, len);
2014             written += len;
2015         }
2016 
2017         @Override
2018         public void close() {
2019             if (isClosed)
2020                 return;
2021             isClosed = true;
2022             e.size = e.csize = written;
2023             e.crc = crc.getValue();
2024         }
2025     }
2026 
2027     // Wrapper output stream class to write out a &quot;deflated&quot; entry.
2028     // (1) this class does not close the underlying out stream when
2029     //     being closed.
2030     // (2) no need to be &quot;synchronized&quot;, only used by sync()
2031     private class EntryOutputStreamDef extends DeflaterOutputStream {
2032         private final CRC32 crc;
2033         private final Entry e;
2034         private boolean isClosed;
2035 
2036         EntryOutputStreamDef(Entry e, OutputStream os) {
2037             super(os, getDeflater());
2038             this.e = Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
2039             this.crc = new CRC32();
2040         }
2041 
2042         @Override
2043         public void write(byte[] b, int off, int len) throws IOException {
2044             super.write(b, off, len);
2045             crc.update(b, off, len);
2046         }
2047 
2048         @Override
2049         public void close() throws IOException {
2050             if (isClosed)
2051                 return;
2052             isClosed = true;
2053             finish();
2054             e.size = def.getBytesRead();
2055             e.csize = def.getBytesWritten();
2056             e.crc = crc.getValue();
2057             releaseDeflater(def);
2058         }
2059     }
2060 
2061     private InputStream getInputStream(Entry e)
2062         throws IOException
2063     {
2064         InputStream eis;
2065         if (e.type == Entry.NEW) {
2066             if (e.bytes != null)
2067                 eis = new ByteArrayInputStream(e.bytes);
2068             else if (e.file != null)
2069                 eis = Files.newInputStream(e.file);
2070             else
2071                 throw new ZipException(&quot;update entry data is missing&quot;);
2072         } else if (e.type == Entry.FILECH) {
2073             // FILECH result is un-compressed.
2074             eis = Files.newInputStream(e.file);
2075             // TBD: wrap to hook close()
2076             // streams.add(eis);
2077             return eis;
2078         } else {  // untouched CEN or COPY
2079             eis = new EntryInputStream(e, ch);
2080         }
2081         if (e.method == METHOD_DEFLATED) {
2082             // MORE: Compute good size for inflater stream:
2083             long bufSize = e.size + 2; // Inflater likes a bit of slack
2084             if (bufSize &gt; 65536)
2085                 bufSize = 8192;
2086             final long size = e.size;
2087             eis = new InflaterInputStream(eis, getInflater(), (int)bufSize) {
2088                 private boolean isClosed = false;
2089                 public void close() throws IOException {
2090                     if (!isClosed) {
2091                         releaseInflater(inf);
2092                         this.in.close();
2093                         isClosed = true;
2094                         streams.remove(this);
2095                     }
2096                 }
2097                 // Override fill() method to provide an extra &quot;dummy&quot; byte
2098                 // at the end of the input stream. This is required when
2099                 // using the &quot;nowrap&quot; Inflater option. (it appears the new
2100                 // zlib in 7 does not need it, but keep it for now)
2101                 protected void fill() throws IOException {
2102                     if (eof) {
2103                         throw new EOFException(
2104                             &quot;Unexpected end of ZLIB input stream&quot;);
2105                     }
2106                     len = this.in.read(buf, 0, buf.length);
2107                     if (len == -1) {
2108                         buf[0] = 0;
2109                         len = 1;
2110                         eof = true;
2111                     }
2112                     inf.setInput(buf, 0, len);
2113                 }
2114                 private boolean eof;
2115 
2116                 public int available() {
2117                     if (isClosed)
2118                         return 0;
2119                     long avail = size - inf.getBytesWritten();
2120                     return avail &gt; (long) Integer.MAX_VALUE ?
2121                         Integer.MAX_VALUE : (int) avail;
2122                 }
2123             };
2124         } else if (e.method == METHOD_STORED) {
2125             // TBD: wrap/ it does not seem necessary
2126         } else {
2127             throw new ZipException(&quot;invalid compression method&quot;);
2128         }
2129         streams.add(eis);
2130         return eis;
2131     }
2132 
2133     // Inner class implementing the input stream used to read
2134     // a (possibly compressed) zip file entry.
2135     private class EntryInputStream extends InputStream {
2136         private final SeekableByteChannel zfch; // local ref to zipfs&#39;s &quot;ch&quot;. zipfs.ch might
2137                                                 // point to a new channel after sync()
2138         private long pos;                       // current position within entry data
2139         private long rem;                       // number of remaining bytes within entry
2140 
2141         EntryInputStream(Entry e, SeekableByteChannel zfch)
2142             throws IOException
2143         {
2144             this.zfch = zfch;
2145             rem = e.csize;
2146             pos = e.locoff;
2147             if (pos == -1) {
2148                 Entry e2 = getEntry(e.name);
2149                 if (e2 == null) {
2150                     throw new ZipException(&quot;invalid loc for entry &lt;&quot; + getString(e.name) + &quot;&gt;&quot;);
2151                 }
2152                 pos = e2.locoff;
2153             }
2154             pos = -pos;  // lazy initialize the real data offset
2155         }
2156 
2157         public int read(byte[] b, int off, int len) throws IOException {
2158             ensureOpen();
2159             initDataPos();
2160             if (rem == 0) {
2161                 return -1;
2162             }
2163             if (len &lt;= 0) {
2164                 return 0;
2165             }
2166             if (len &gt; rem) {
2167                 len = (int) rem;
2168             }
2169             // readFullyAt()
2170             long n;
2171             ByteBuffer bb = ByteBuffer.wrap(b);
2172             bb.position(off);
2173             bb.limit(off + len);
2174             synchronized(zfch) {
2175                 n = zfch.position(pos).read(bb);
2176             }
2177             if (n &gt; 0) {
2178                 pos += n;
2179                 rem -= n;
2180             }
2181             if (rem == 0) {
2182                 close();
2183             }
2184             return (int)n;
2185         }
2186 
2187         public int read() throws IOException {
2188             byte[] b = new byte[1];
2189             if (read(b, 0, 1) == 1) {
2190                 return b[0] &amp; 0xff;
2191             } else {
2192                 return -1;
2193             }
2194         }
2195 
2196         public long skip(long n) {
2197             ensureOpen();
2198             if (n &gt; rem)
2199                 n = rem;
2200             pos += n;
2201             rem -= n;
2202             if (rem == 0) {
2203                 close();
2204             }
2205             return n;
2206         }
2207 
2208         public int available() {
2209             return rem &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;
2210         }
2211 
2212         public void close() {
2213             rem = 0;
2214             streams.remove(this);
2215         }
2216 
2217         private void initDataPos() throws IOException {
2218             if (pos &lt;= 0) {
2219                 pos = -pos + locpos;
2220                 byte[] buf = new byte[LOCHDR];
2221                 if (readFullyAt(buf, 0, buf.length, pos) != LOCHDR) {
2222                     throw new ZipException(&quot;invalid loc &quot; + pos + &quot; for entry reading&quot;);
2223                 }
2224                 pos += LOCHDR + LOCNAM(buf) + LOCEXT(buf);
2225             }
2226         }
2227     }
2228 
2229     // Maxmum number of de/inflater we cache
2230     private final int MAX_FLATER = 20;
2231     // List of available Inflater objects for decompression
2232     private final List&lt;Inflater&gt; inflaters = new ArrayList&lt;&gt;();
2233 
2234     // Gets an inflater from the list of available inflaters or allocates
2235     // a new one.
2236     private Inflater getInflater() {
2237         synchronized (inflaters) {
2238             int size = inflaters.size();
2239             if (size &gt; 0) {
2240                 return inflaters.remove(size - 1);
2241             } else {
2242                 return new Inflater(true);
2243             }
2244         }
2245     }
2246 
2247     // Releases the specified inflater to the list of available inflaters.
2248     private void releaseInflater(Inflater inf) {
2249         synchronized (inflaters) {
2250             if (inflaters.size() &lt; MAX_FLATER) {
2251                 inf.reset();
2252                 inflaters.add(inf);
2253             } else {
2254                 inf.end();
2255             }
2256         }
2257     }
2258 
2259     // List of available Deflater objects for compression
2260     private final List&lt;Deflater&gt; deflaters = new ArrayList&lt;&gt;();
2261 
2262     // Gets a deflater from the list of available deflaters or allocates
2263     // a new one.
2264     private Deflater getDeflater() {
2265         synchronized (deflaters) {
2266             int size = deflaters.size();
2267             if (size &gt; 0) {
2268                 return deflaters.remove(size - 1);
2269             } else {
2270                 return new Deflater(Deflater.DEFAULT_COMPRESSION, true);
2271             }
2272         }
2273     }
2274 
2275     // Releases the specified inflater to the list of available inflaters.
2276     private void releaseDeflater(Deflater def) {
2277         synchronized (deflaters) {
2278             if (deflaters.size() &lt; MAX_FLATER) {
2279                def.reset();
2280                deflaters.add(def);
2281             } else {
2282                def.end();
2283             }
2284         }
2285     }
2286 
2287     // End of central directory record
2288     static class END {
2289         // The fields that are commented out below are not used by anyone and write() uses &quot;0&quot;
2290         // int  disknum;
2291         // int  sdisknum;
2292         // int  endsub;
2293         int  centot;        // 4 bytes
2294         long cenlen;        // 4 bytes
2295         long cenoff;        // 4 bytes
2296         // int  comlen;     // comment length
2297         // byte[] comment;
2298 
2299         // members of Zip64 end of central directory locator
2300         // int diskNum;
2301         long endpos;
2302         // int disktot;
2303 
2304         void write(OutputStream os, long offset, boolean forceEnd64) throws IOException {
2305             boolean hasZip64 = forceEnd64; // false;
2306             long xlen = cenlen;
2307             long xoff = cenoff;
2308             if (xlen &gt;= ZIP64_MINVAL) {
2309                 xlen = ZIP64_MINVAL;
2310                 hasZip64 = true;
2311             }
2312             if (xoff &gt;= ZIP64_MINVAL) {
2313                 xoff = ZIP64_MINVAL;
2314                 hasZip64 = true;
2315             }
2316             int count = centot;
2317             if (count &gt;= ZIP64_MINVAL32) {
2318                 count = ZIP64_MINVAL32;
2319                 hasZip64 = true;
2320             }
2321             if (hasZip64) {
2322                 //zip64 end of central directory record
2323                 writeInt(os, ZIP64_ENDSIG);       // zip64 END record signature
2324                 writeLong(os, ZIP64_ENDHDR - 12); // size of zip64 end
2325                 writeShort(os, 45);               // version made by
2326                 writeShort(os, 45);               // version needed to extract
2327                 writeInt(os, 0);                  // number of this disk
2328                 writeInt(os, 0);                  // central directory start disk
2329                 writeLong(os, centot);            // number of directory entries on disk
2330                 writeLong(os, centot);            // number of directory entries
2331                 writeLong(os, cenlen);            // length of central directory
2332                 writeLong(os, cenoff);            // offset of central directory
2333 
2334                 //zip64 end of central directory locator
2335                 writeInt(os, ZIP64_LOCSIG);       // zip64 END locator signature
2336                 writeInt(os, 0);                  // zip64 END start disk
2337                 writeLong(os, offset);            // offset of zip64 END
2338                 writeInt(os, 1);                  // total number of disks (?)
2339             }
2340             writeInt(os, ENDSIG);                 // END record signature
2341             writeShort(os, 0);                    // number of this disk
2342             writeShort(os, 0);                    // central directory start disk
2343             writeShort(os, count);                // number of directory entries on disk
2344             writeShort(os, count);                // total number of directory entries
2345             writeInt(os, xlen);                   // length of central directory
2346             writeInt(os, xoff);                   // offset of central directory
2347             writeShort(os, 0);                    // zip file comment, not used
2348         }
2349     }
2350 
2351     // Internal node that links a &quot;name&quot; to its pos in cen table.
2352     // The node itself can be used as a &quot;key&quot; to lookup itself in
2353     // the HashMap inodes.
2354     static class IndexNode {
2355         byte[]  name;
2356         int     hashcode;    // node is hashable/hashed by its name
2357         boolean isdir;
2358         int     pos = -1;    // position in cen table, -1 means the
2359                              // entry does not exist in zip file
2360         IndexNode child;     // first child
2361         IndexNode sibling;   // next sibling
2362 
2363         IndexNode() {}
2364 
2365         IndexNode(byte[] name, boolean isdir) {
2366             name(name);
2367             this.isdir = isdir;
2368             this.pos = -1;
2369         }
2370 
2371         IndexNode(byte[] name, int pos) {
2372             name(name);
2373             this.pos = pos;
2374         }
2375 
2376         // constructor for initCEN() (1) remove trailing &#39;/&#39; (2) pad leading &#39;/&#39;
2377         IndexNode(byte[] cen, int pos, int nlen) {
2378             int noff = pos + CENHDR;
2379             if (cen[noff + nlen - 1] == &#39;/&#39;) {
2380                 isdir = true;
2381                 nlen--;
2382             }
2383             if (nlen &gt; 0 &amp;&amp; cen[noff] == &#39;/&#39;) {
2384                 name = Arrays.copyOfRange(cen, noff, noff + nlen);
2385             } else {
2386                 name = new byte[nlen + 1];
2387                 System.arraycopy(cen, noff, name, 1, nlen);
2388                 name[0] = &#39;/&#39;;
2389             }
2390             name(normalize(name));
2391             this.pos = pos;
2392         }
2393 
2394         // Normalize the IndexNode.name field.
2395         private byte[] normalize(byte[] path) {
2396             int len = path.length;
2397             if (len == 0)
2398                 return path;
2399             byte prevC = 0;
2400             for (int pathPos = 0; pathPos &lt; len; pathPos++) {
2401                 byte c = path[pathPos];
2402                 if (c == &#39;/&#39; &amp;&amp; prevC == &#39;/&#39;)
2403                     return normalize(path, pathPos - 1);
2404                 prevC = c;
2405             }
2406             if (len &gt; 1 &amp;&amp; prevC == &#39;/&#39;) {
2407                 return Arrays.copyOf(path, len - 1);
2408             }
2409             return path;
2410         }
2411 
2412         private byte[] normalize(byte[] path, int off) {
2413             // As we know we have at least one / to trim, we can reduce
2414             // the size of the resulting array
2415             byte[] to = new byte[path.length - 1];
2416             int pathPos = 0;
2417             while (pathPos &lt; off) {
2418                 to[pathPos] = path[pathPos];
2419                 pathPos++;
2420             }
2421             int toPos = pathPos;
2422             byte prevC = 0;
2423             while (pathPos &lt; path.length) {
2424                 byte c = path[pathPos++];
2425                 if (c == &#39;/&#39; &amp;&amp; prevC == &#39;/&#39;)
2426                     continue;
2427                 to[toPos++] = c;
2428                 prevC = c;
2429             }
2430             if (toPos &gt; 1 &amp;&amp; to[toPos - 1] == &#39;/&#39;)
2431                 toPos--;
2432             return (toPos == to.length) ? to : Arrays.copyOf(to, toPos);
2433         }
2434 
2435         private static final ThreadLocal&lt;IndexNode&gt; cachedKey = new ThreadLocal&lt;&gt;();
2436 
2437         static final IndexNode keyOf(byte[] name) { // get a lookup key;
2438             IndexNode key = cachedKey.get();
2439             if (key == null) {
2440                 key = new IndexNode(name, -1);
2441                 cachedKey.set(key);
2442             }
2443             return key.as(name);
2444         }
2445 
2446         final void name(byte[] name) {
2447             this.name = name;
2448             this.hashcode = Arrays.hashCode(name);
2449         }
2450 
2451         final IndexNode as(byte[] name) {           // reuse the node, mostly
2452             name(name);                             // as a lookup &quot;key&quot;
2453             return this;
2454         }
2455 
2456         boolean isDir() {
2457             return isdir;
2458         }
2459 
2460         @Override
2461         public boolean equals(Object other) {
2462             if (!(other instanceof IndexNode)) {
2463                 return false;
2464             }
2465             if (other instanceof ParentLookup) {
2466                 return ((ParentLookup)other).equals(this);
2467             }
2468             return Arrays.equals(name, ((IndexNode)other).name);
2469         }
2470 
2471         @Override
2472         public int hashCode() {
2473             return hashcode;
2474         }
2475 
2476         @Override
2477         public String toString() {
2478             return new String(name) + (isdir ? &quot; (dir)&quot; : &quot; &quot;) + &quot;, index: &quot; + pos;
2479         }
2480     }
2481 
2482     static class Entry extends IndexNode implements ZipFileAttributes {
2483         static final int CEN    = 1;  // entry read from cen
2484         static final int NEW    = 2;  // updated contents in bytes or file
2485         static final int FILECH = 3;  // fch update in &quot;file&quot;
2486         static final int COPY   = 4;  // copy of a CEN entry
2487 
2488         byte[] bytes;                 // updated content bytes
2489         Path   file;                  // use tmp file to store bytes;
2490         int    type = CEN;            // default is the entry read from cen
2491 
2492         // entry attributes
2493         int    version;
2494         int    flag;
2495         int    posixPerms = -1; // posix permissions
2496         int    method = -1;    // compression method
2497         long   mtime  = -1;    // last modification time (in DOS time)
2498         long   atime  = -1;    // last access time
2499         long   ctime  = -1;    // create time
2500         long   crc    = -1;    // crc-32 of entry data
2501         long   csize  = -1;    // compressed size of entry data
2502         long   size   = -1;    // uncompressed size of entry data
2503         byte[] extra;
2504 
2505         // CEN
2506         // The fields that are commented out below are not used by anyone and write() uses &quot;0&quot;
2507         // int    versionMade;
2508         // int    disk;
2509         // int    attrs;
2510         // long   attrsEx;
2511         long   locoff;
2512         byte[] comment;
2513 
2514         Entry(byte[] name, boolean isdir, int method) {
2515             name(name);
2516             this.isdir = isdir;
2517             this.mtime  = this.ctime = this.atime = System.currentTimeMillis();
2518             this.crc    = 0;
2519             this.size   = 0;
2520             this.csize  = 0;
2521             this.method = method;
2522         }
2523 
2524         @SuppressWarnings(&quot;unchecked&quot;)
2525         Entry(byte[] name, int type, boolean isdir, int method, FileAttribute&lt;?&gt;... attrs) {
2526             this(name, isdir, method);
2527             this.type = type;
2528             for (FileAttribute&lt;?&gt; attr : attrs) {
2529                 String attrName = attr.name();
2530                 if (attrName.equals(&quot;posix:permissions&quot;)) {
2531                     posixPerms = ZipUtils.permsToFlags((Set&lt;PosixFilePermission&gt;)attr.value());
2532                 }
2533             }
2534         }
2535 
2536         Entry(byte[] name, Path file, int type, FileAttribute&lt;?&gt;... attrs) {
2537             this(name, type, false, METHOD_STORED, attrs);
2538             this.file = file;
2539         }
2540 
2541         Entry(Entry e, int type, int compressionMethod) {
2542             this(e, type);
2543             this.method = compressionMethod;
2544         }
2545 
2546         Entry(Entry e, int type) {
2547             name(e.name);
2548             this.isdir     = e.isdir;
2549             this.version   = e.version;
2550             this.ctime     = e.ctime;
2551             this.atime     = e.atime;
2552             this.mtime     = e.mtime;
2553             this.crc       = e.crc;
2554             this.size      = e.size;
2555             this.csize     = e.csize;
2556             this.method    = e.method;
2557             this.extra     = e.extra;
2558             /*
2559             this.versionMade = e.versionMade;
2560             this.disk      = e.disk;
2561             this.attrs     = e.attrs;
2562             this.attrsEx   = e.attrsEx;
2563             */
2564             this.locoff    = e.locoff;
2565             this.comment   = e.comment;
2566             this.posixPerms = e.posixPerms;
2567             this.type      = type;
2568         }
2569 
2570         Entry(ZipFileSystem zipfs, IndexNode inode) throws IOException {
2571             readCEN(zipfs, inode);
2572         }
2573 
2574         // Calculates a suitable base for the version number to
2575         // be used for fields version made by/version needed to extract.
2576         // The lower bytes of these 2 byte fields hold the version number
2577         // (value/10 = major; value%10 = minor)
2578         // For different features certain minimum versions apply:
2579         // stored = 10 (1.0), deflated = 20 (2.0), zip64 = 45 (4.5)
2580         private int version(boolean zip64) throws ZipException {
2581             if (zip64) {
2582                 return 45;
2583             }
2584             if (method == METHOD_DEFLATED)
2585                 return 20;
2586             else if (method == METHOD_STORED)
2587                 return 10;
2588             throw new ZipException(&quot;unsupported compression method&quot;);
2589         }
2590 
2591         /**
2592          * Adds information about compatibility of file attribute information
2593          * to a version value.
2594          */
2595         private int versionMadeBy(int version) {
2596             return (posixPerms &lt; 0) ? version :
2597                 VERSION_MADE_BY_BASE_UNIX | (version &amp; 0xff);
2598         }
2599 
2600         ///////////////////// CEN //////////////////////
2601         private void readCEN(ZipFileSystem zipfs, IndexNode inode) throws IOException {
2602             byte[] cen = zipfs.cen;
2603             int pos = inode.pos;
2604             if (!cenSigAt(cen, pos))
2605                 throw new ZipException(&quot;invalid CEN header (bad signature)&quot;);
2606             version     = CENVER(cen, pos);
2607             flag        = CENFLG(cen, pos);
2608             method      = CENHOW(cen, pos);
2609             mtime       = dosToJavaTime(CENTIM(cen, pos));
2610             crc         = CENCRC(cen, pos);
2611             csize       = CENSIZ(cen, pos);
2612             size        = CENLEN(cen, pos);
2613             int nlen    = CENNAM(cen, pos);
2614             int elen    = CENEXT(cen, pos);
2615             int clen    = CENCOM(cen, pos);
2616             /*
2617             versionMade = CENVEM(cen, pos);
2618             disk        = CENDSK(cen, pos);
2619             attrs       = CENATT(cen, pos);
2620             attrsEx     = CENATX(cen, pos);
2621             */
2622             if (CENVEM_FA(cen, pos) == FILE_ATTRIBUTES_UNIX) {
2623                 posixPerms = CENATX_PERMS(cen, pos) &amp; 0xFFF; // 12 bits for setuid, setgid, sticky + perms
2624             }
2625             locoff      = CENOFF(cen, pos);
2626             pos += CENHDR;
2627             this.name = inode.name;
2628             this.isdir = inode.isdir;
2629             this.hashcode = inode.hashcode;
2630 
2631             pos += nlen;
2632             if (elen &gt; 0) {
2633                 extra = Arrays.copyOfRange(cen, pos, pos + elen);
2634                 pos += elen;
2635                 readExtra(zipfs);
2636             }
2637             if (clen &gt; 0) {
2638                 comment = Arrays.copyOfRange(cen, pos, pos + clen);
2639             }
2640         }
2641 
2642         private int writeCEN(OutputStream os) throws IOException {
2643             long csize0  = csize;
2644             long size0   = size;
2645             long locoff0 = locoff;
2646             int elen64   = 0;                // extra for ZIP64
2647             int elenNTFS = 0;                // extra for NTFS (a/c/mtime)
2648             int elenEXTT = 0;                // extra for Extended Timestamp
2649             boolean foundExtraTime = false;  // if time stamp NTFS, EXTT present
2650 
2651             byte[] zname = isdir ? toDirectoryPath(name) : name;
2652 
2653             // confirm size/length
2654             int nlen = (zname != null) ? zname.length - 1 : 0;  // name has [0] as &quot;slash&quot;
2655             int elen = (extra != null) ? extra.length : 0;
2656             int eoff = 0;
2657             int clen = (comment != null) ? comment.length : 0;
2658             if (csize &gt;= ZIP64_MINVAL) {
2659                 csize0 = ZIP64_MINVAL;
2660                 elen64 += 8;                 // csize(8)
2661             }
2662             if (size &gt;= ZIP64_MINVAL) {
2663                 size0 = ZIP64_MINVAL;        // size(8)
2664                 elen64 += 8;
2665             }
2666             if (locoff &gt;= ZIP64_MINVAL) {
2667                 locoff0 = ZIP64_MINVAL;
2668                 elen64 += 8;                 // offset(8)
2669             }
2670             if (elen64 != 0) {
2671                 elen64 += 4;                 // header and data sz 4 bytes
2672             }
2673             boolean zip64 = (elen64 != 0);
2674             int version0 = version(zip64);
2675             while (eoff + 4 &lt; elen) {
2676                 int tag = SH(extra, eoff);
2677                 int sz = SH(extra, eoff + 2);
2678                 if (tag == EXTID_EXTT || tag == EXTID_NTFS) {
2679                     foundExtraTime = true;
2680                 }
2681                 eoff += (4 + sz);
2682             }
2683             if (!foundExtraTime) {
2684                 if (isWindows) {             // use NTFS
2685                     elenNTFS = 36;           // total 36 bytes
2686                 } else {                     // Extended Timestamp otherwise
2687                     elenEXTT = 9;            // only mtime in cen
2688                 }
2689             }
2690             writeInt(os, CENSIG);            // CEN header signature
2691             writeShort(os, versionMadeBy(version0)); // version made by
2692             writeShort(os, version0);        // version needed to extract
2693             writeShort(os, flag);            // general purpose bit flag
2694             writeShort(os, method);          // compression method
2695                                              // last modification time
2696             writeInt(os, (int)javaToDosTime(mtime));
2697             writeInt(os, crc);               // crc-32
2698             writeInt(os, csize0);            // compressed size
2699             writeInt(os, size0);             // uncompressed size
2700             writeShort(os, nlen);
2701             writeShort(os, elen + elen64 + elenNTFS + elenEXTT);
2702 
2703             if (comment != null) {
2704                 writeShort(os, Math.min(clen, 0xffff));
2705             } else {
2706                 writeShort(os, 0);
2707             }
2708             writeShort(os, 0);              // starting disk number
2709             writeShort(os, 0);              // internal file attributes (unused)
2710             writeInt(os, posixPerms &gt; 0 ? posixPerms &lt;&lt; 16 : 0); // external file
2711                                             // attributes, used for storing posix
2712                                             // permissions
2713             writeInt(os, locoff0);          // relative offset of local header
2714             writeBytes(os, zname, 1, nlen);
2715             if (zip64) {
2716                 writeShort(os, EXTID_ZIP64);// Zip64 extra
2717                 writeShort(os, elen64 - 4); // size of &quot;this&quot; extra block
2718                 if (size0 == ZIP64_MINVAL)
2719                     writeLong(os, size);
2720                 if (csize0 == ZIP64_MINVAL)
2721                     writeLong(os, csize);
2722                 if (locoff0 == ZIP64_MINVAL)
2723                     writeLong(os, locoff);
2724             }
2725             if (elenNTFS != 0) {
2726                 writeShort(os, EXTID_NTFS);
2727                 writeShort(os, elenNTFS - 4);
2728                 writeInt(os, 0);            // reserved
2729                 writeShort(os, 0x0001);     // NTFS attr tag
2730                 writeShort(os, 24);
2731                 writeLong(os, javaToWinTime(mtime));
2732                 writeLong(os, javaToWinTime(atime));
2733                 writeLong(os, javaToWinTime(ctime));
2734             }
2735             if (elenEXTT != 0) {
2736                 writeShort(os, EXTID_EXTT);
2737                 writeShort(os, elenEXTT - 4);
2738                 if (ctime == -1)
2739                     os.write(0x3);          // mtime and atime
2740                 else
2741                     os.write(0x7);          // mtime, atime and ctime
2742                 writeInt(os, javaToUnixTime(mtime));
2743             }
2744             if (extra != null)              // whatever not recognized
2745                 writeBytes(os, extra);
2746             if (comment != null)            //TBD: 0, Math.min(commentBytes.length, 0xffff));
2747                 writeBytes(os, comment);
2748             return CENHDR + nlen + elen + clen + elen64 + elenNTFS + elenEXTT;
2749         }
2750 
2751         ///////////////////// LOC //////////////////////
2752 
2753         private int writeLOC(OutputStream os) throws IOException {
2754             byte[] zname = isdir ? toDirectoryPath(name) : name;
2755             int nlen = (zname != null) ? zname.length - 1 : 0; // [0] is slash
2756             int elen = (extra != null) ? extra.length : 0;
2757             boolean foundExtraTime = false;     // if extra timestamp present
2758             int eoff = 0;
2759             int elen64 = 0;
2760             boolean zip64 = false;
2761             int elenEXTT = 0;
2762             int elenNTFS = 0;
2763             writeInt(os, LOCSIG);               // LOC header signature
2764             if ((flag &amp; FLAG_DATADESCR) != 0) {
2765                 writeShort(os, version(false)); // version needed to extract
2766                 writeShort(os, flag);           // general purpose bit flag
2767                 writeShort(os, method);         // compression method
2768                 // last modification time
2769                 writeInt(os, (int)javaToDosTime(mtime));
2770                 // store size, uncompressed size, and crc-32 in data descriptor
2771                 // immediately following compressed entry data
2772                 writeInt(os, 0);
2773                 writeInt(os, 0);
2774                 writeInt(os, 0);
2775             } else {
2776                 if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
2777                     elen64 = 20;    //headid(2) + size(2) + size(8) + csize(8)
2778                     zip64 = true;
2779                 }
2780                 writeShort(os, version(zip64)); // version needed to extract
2781                 writeShort(os, flag);           // general purpose bit flag
2782                 writeShort(os, method);         // compression method
2783                                                 // last modification time
2784                 writeInt(os, (int)javaToDosTime(mtime));
2785                 writeInt(os, crc);              // crc-32
2786                 if (zip64) {
2787                     writeInt(os, ZIP64_MINVAL);
2788                     writeInt(os, ZIP64_MINVAL);
2789                 } else {
2790                     writeInt(os, csize);        // compressed size
2791                     writeInt(os, size);         // uncompressed size
2792                 }
2793             }
2794             while (eoff + 4 &lt; elen) {
2795                 int tag = SH(extra, eoff);
2796                 int sz = SH(extra, eoff + 2);
2797                 if (tag == EXTID_EXTT || tag == EXTID_NTFS) {
2798                     foundExtraTime = true;
2799                 }
2800                 eoff += (4 + sz);
2801             }
2802             if (!foundExtraTime) {
2803                 if (isWindows) {
2804                     elenNTFS = 36;              // NTFS, total 36 bytes
2805                 } else {                        // on unix use &quot;ext time&quot;
2806                     elenEXTT = 9;
2807                     if (atime != -1)
2808                         elenEXTT += 4;
2809                     if (ctime != -1)
2810                         elenEXTT += 4;
2811                 }
2812             }
2813             writeShort(os, nlen);
2814             writeShort(os, elen + elen64 + elenNTFS + elenEXTT);
2815             writeBytes(os, zname, 1, nlen);
2816             if (zip64) {
2817                 writeShort(os, EXTID_ZIP64);
2818                 writeShort(os, 16);
2819                 writeLong(os, size);
2820                 writeLong(os, csize);
2821             }
2822             if (elenNTFS != 0) {
2823                 writeShort(os, EXTID_NTFS);
2824                 writeShort(os, elenNTFS - 4);
2825                 writeInt(os, 0);            // reserved
2826                 writeShort(os, 0x0001);     // NTFS attr tag
2827                 writeShort(os, 24);
2828                 writeLong(os, javaToWinTime(mtime));
2829                 writeLong(os, javaToWinTime(atime));
2830                 writeLong(os, javaToWinTime(ctime));
2831             }
2832             if (elenEXTT != 0) {
2833                 writeShort(os, EXTID_EXTT);
2834                 writeShort(os, elenEXTT - 4);// size for the folowing data block
2835                 int fbyte = 0x1;
2836                 if (atime != -1)           // mtime and atime
2837                     fbyte |= 0x2;
2838                 if (ctime != -1)           // mtime, atime and ctime
2839                     fbyte |= 0x4;
2840                 os.write(fbyte);           // flags byte
2841                 writeInt(os, javaToUnixTime(mtime));
2842                 if (atime != -1)
2843                     writeInt(os, javaToUnixTime(atime));
2844                 if (ctime != -1)
2845                     writeInt(os, javaToUnixTime(ctime));
2846             }
2847             if (extra != null) {
2848                 writeBytes(os, extra);
2849             }
2850             return LOCHDR + nlen + elen + elen64 + elenNTFS + elenEXTT;
2851         }
2852 
2853         // Data Descriptor
2854         private int writeEXT(OutputStream os) throws IOException {
2855             writeInt(os, EXTSIG);           // EXT header signature
2856             writeInt(os, crc);              // crc-32
2857             if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
2858                 writeLong(os, csize);
2859                 writeLong(os, size);
2860                 return 24;
2861             } else {
2862                 writeInt(os, csize);        // compressed size
2863                 writeInt(os, size);         // uncompressed size
2864                 return 16;
2865             }
2866         }
2867 
2868         // read NTFS, UNIX and ZIP64 data from cen.extra
2869         private void readExtra(ZipFileSystem zipfs) throws IOException {
2870             if (extra == null)
2871                 return;
2872             int elen = extra.length;
2873             int off = 0;
2874             int newOff = 0;
2875             while (off + 4 &lt; elen) {
2876                 // extra spec: HeaderID+DataSize+Data
2877                 int pos = off;
2878                 int tag = SH(extra, pos);
2879                 int sz = SH(extra, pos + 2);
2880                 pos += 4;
2881                 if (pos + sz &gt; elen)         // invalid data
2882                     break;
2883                 switch (tag) {
2884                 case EXTID_ZIP64 :
2885                     if (size == ZIP64_MINVAL) {
2886                         if (pos + 8 &gt; elen)  // invalid zip64 extra
2887                             break;           // fields, just skip
2888                         size = LL(extra, pos);
2889                         pos += 8;
2890                     }
2891                     if (csize == ZIP64_MINVAL) {
2892                         if (pos + 8 &gt; elen)
2893                             break;
2894                         csize = LL(extra, pos);
2895                         pos += 8;
2896                     }
2897                     if (locoff == ZIP64_MINVAL) {
2898                         if (pos + 8 &gt; elen)
2899                             break;
2900                         locoff = LL(extra, pos);
2901                     }
2902                     break;
2903                 case EXTID_NTFS:
2904                     if (sz &lt; 32)
2905                         break;
2906                     pos += 4;    // reserved 4 bytes
2907                     if (SH(extra, pos) !=  0x0001)
2908                         break;
2909                     if (SH(extra, pos + 2) != 24)
2910                         break;
2911                     // override the loc field, datatime here is
2912                     // more &quot;accurate&quot;
2913                     mtime  = winToJavaTime(LL(extra, pos + 4));
2914                     atime  = winToJavaTime(LL(extra, pos + 12));
2915                     ctime  = winToJavaTime(LL(extra, pos + 20));
2916                     break;
2917                 case EXTID_EXTT:
2918                     // spec says the Extened timestamp in cen only has mtime
2919                     // need to read the loc to get the extra a/ctime, if flag
2920                     // &quot;zipinfo-time&quot; is not specified to false;
2921                     // there is performance cost (move up to loc and read) to
2922                     // access the loc table foreach entry;
2923                     if (zipfs.noExtt) {
2924                         if (sz == 5)
2925                             mtime = unixToJavaTime(LG(extra, pos + 1));
2926                          break;
2927                     }
2928                     byte[] buf = new byte[LOCHDR];
2929                     if (zipfs.readFullyAt(buf, 0, buf.length , locoff)
2930                         != buf.length)
2931                         throw new ZipException(&quot;loc: reading failed&quot;);
2932                     if (!locSigAt(buf, 0))
2933                         throw new ZipException(&quot;loc: wrong sig -&gt;&quot;
2934                                            + Long.toString(getSig(buf, 0), 16));
2935                     int locElen = LOCEXT(buf);
2936                     if (locElen &lt; 9)    // EXTT is at least 9 bytes
2937                         break;
2938                     int locNlen = LOCNAM(buf);
2939                     buf = new byte[locElen];
2940                     if (zipfs.readFullyAt(buf, 0, buf.length , locoff + LOCHDR + locNlen)
2941                         != buf.length)
2942                         throw new ZipException(&quot;loc extra: reading failed&quot;);
2943                     int locPos = 0;
2944                     while (locPos + 4 &lt; buf.length) {
2945                         int locTag = SH(buf, locPos);
2946                         int locSZ  = SH(buf, locPos + 2);
2947                         locPos += 4;
2948                         if (locTag  != EXTID_EXTT) {
2949                             locPos += locSZ;
2950                              continue;
2951                         }
2952                         int end = locPos + locSZ - 4;
2953                         int flag = CH(buf, locPos++);
2954                         if ((flag &amp; 0x1) != 0 &amp;&amp; locPos &lt;= end) {
2955                             mtime = unixToJavaTime(LG(buf, locPos));
2956                             locPos += 4;
2957                         }
2958                         if ((flag &amp; 0x2) != 0 &amp;&amp; locPos &lt;= end) {
2959                             atime = unixToJavaTime(LG(buf, locPos));
2960                             locPos += 4;
2961                         }
2962                         if ((flag &amp; 0x4) != 0 &amp;&amp; locPos &lt;= end) {
2963                             ctime = unixToJavaTime(LG(buf, locPos));
2964                         }
2965                         break;
2966                     }
2967                     break;
2968                 default:    // unknown tag
2969                     System.arraycopy(extra, off, extra, newOff, sz + 4);
2970                     newOff += (sz + 4);
2971                 }
2972                 off += (sz + 4);
2973             }
2974             if (newOff != 0 &amp;&amp; newOff != extra.length)
2975                 extra = Arrays.copyOf(extra, newOff);
2976             else
2977                 extra = null;
2978         }
2979 
2980         @Override
2981         public String toString() {
2982             StringBuilder sb = new StringBuilder(1024);
2983             Formatter fm = new Formatter(sb);
2984             fm.format(&quot;    name            : %s%n&quot;, new String(name));
2985             fm.format(&quot;    creationTime    : %tc%n&quot;, creationTime().toMillis());
2986             fm.format(&quot;    lastAccessTime  : %tc%n&quot;, lastAccessTime().toMillis());
2987             fm.format(&quot;    lastModifiedTime: %tc%n&quot;, lastModifiedTime().toMillis());
2988             fm.format(&quot;    isRegularFile   : %b%n&quot;, isRegularFile());
2989             fm.format(&quot;    isDirectory     : %b%n&quot;, isDirectory());
2990             fm.format(&quot;    isSymbolicLink  : %b%n&quot;, isSymbolicLink());
2991             fm.format(&quot;    isOther         : %b%n&quot;, isOther());
2992             fm.format(&quot;    fileKey         : %s%n&quot;, fileKey());
2993             fm.format(&quot;    size            : %d%n&quot;, size());
2994             fm.format(&quot;    compressedSize  : %d%n&quot;, compressedSize());
2995             fm.format(&quot;    crc             : %x%n&quot;, crc());
2996             fm.format(&quot;    method          : %d%n&quot;, method());
2997             Set&lt;PosixFilePermission&gt; permissions = storedPermissions().orElse(null);
2998             if (permissions != null) {
2999                 fm.format(&quot;    permissions     : %s%n&quot;, permissions);
3000             }
3001             fm.close();
3002             return sb.toString();
3003         }
3004 
3005         ///////// basic file attributes ///////////
3006         @Override
3007         public FileTime creationTime() {
3008             return FileTime.fromMillis(ctime == -1 ? mtime : ctime);
3009         }
3010 
3011         @Override
3012         public boolean isDirectory() {
3013             return isDir();
3014         }
3015 
3016         @Override
3017         public boolean isOther() {
3018             return false;
3019         }
3020 
3021         @Override
3022         public boolean isRegularFile() {
3023             return !isDir();
3024         }
3025 
3026         @Override
3027         public FileTime lastAccessTime() {
3028             return FileTime.fromMillis(atime == -1 ? mtime : atime);
3029         }
3030 
3031         @Override
3032         public FileTime lastModifiedTime() {
3033             return FileTime.fromMillis(mtime);
3034         }
3035 
3036         @Override
3037         public long size() {
3038             return size;
3039         }
3040 
3041         @Override
3042         public boolean isSymbolicLink() {
3043             return false;
3044         }
3045 
3046         @Override
3047         public Object fileKey() {
3048             return null;
3049         }
3050 
3051         ///////// zip file attributes ///////////
3052 
3053         @Override
3054         public long compressedSize() {
3055             return csize;
3056         }
3057 
3058         @Override
3059         public long crc() {
3060             return crc;
3061         }
3062 
3063         @Override
3064         public int method() {
3065             return method;
3066         }
3067 
3068         @Override
3069         public byte[] extra() {
3070             if (extra != null)
3071                 return Arrays.copyOf(extra, extra.length);
3072             return null;
3073         }
3074 
3075         @Override
3076         public byte[] comment() {
3077             if (comment != null)
3078                 return Arrays.copyOf(comment, comment.length);
3079             return null;
3080         }
3081 
3082         @Override
3083         public Optional&lt;Set&lt;PosixFilePermission&gt;&gt; storedPermissions() {
3084             Set&lt;PosixFilePermission&gt; perms = null;
3085             if (posixPerms != -1) {
3086                 perms = new HashSet&lt;&gt;(PosixFilePermission.values().length);
3087                 for (PosixFilePermission perm : PosixFilePermission.values()) {
3088                     if ((posixPerms &amp; ZipUtils.permToFlag(perm)) != 0) {
3089                         perms.add(perm);
3090                     }
3091                 }
3092             }
3093             return Optional.ofNullable(perms);
3094         }
3095     }
3096 
3097     final class PosixEntry extends Entry implements PosixFileAttributes {
3098         private UserPrincipal owner = defaultOwner;
3099         private GroupPrincipal group = defaultGroup;
3100 
3101         PosixEntry(byte[] name, boolean isdir, int method) {
3102             super(name, isdir, method);
3103         }
3104 
3105         PosixEntry(byte[] name, int type, boolean isdir, int method, FileAttribute&lt;?&gt;... attrs) {
3106             super(name, type, isdir, method, attrs);
3107         }
3108 
3109         PosixEntry(byte[] name, Path file, int type, FileAttribute&lt;?&gt;... attrs) {
3110             super(name, file, type, attrs);
3111         }
3112 
3113         PosixEntry(PosixEntry e, int type, int compressionMethod) {
3114             super(e, type);
3115             this.method = compressionMethod;
3116         }
3117 
3118         PosixEntry(PosixEntry e, int type) {
3119             super(e, type);
3120             this.owner = e.owner;
3121             this.group = e.group;
3122         }
3123 
3124         PosixEntry(ZipFileSystem zipfs, IndexNode inode) throws IOException {
3125             super(zipfs, inode);
3126         }
3127 
3128         @Override
3129         public UserPrincipal owner() {
3130             return owner;
3131         }
3132 
3133         @Override
3134         public GroupPrincipal group() {
3135             return group;
3136         }
3137 
3138         @Override
3139         public Set&lt;PosixFilePermission&gt; permissions() {
3140             return storedPermissions().orElse(Set.copyOf(defaultPermissions));
3141         }
3142     }
3143 
3144     private static class ExistingChannelCloser {
3145         private final Path path;
3146         private final SeekableByteChannel ch;
3147         private final Set&lt;InputStream&gt; streams;
3148         ExistingChannelCloser(Path path,
3149                               SeekableByteChannel ch,
3150                               Set&lt;InputStream&gt; streams) {
3151             this.path = path;
3152             this.ch = ch;
3153             this.streams = streams;
3154         }
3155 
3156         /**
3157          * If there are no more outstanding streams, close the channel and
3158          * delete the backing file
3159          *
3160          * @return true if we&#39;re done and closed the backing file,
3161          *         otherwise false
3162          * @throws IOException
3163          */
3164         private boolean closeAndDeleteIfDone() throws IOException {
3165             if (streams.isEmpty()) {
3166                 ch.close();
3167                 Files.delete(path);
3168                 return true;
3169             }
3170             return false;
3171         }
3172     }
3173 
3174     // purely for parent lookup, so we don&#39;t have to copy the parent
3175     // name every time
3176     static class ParentLookup extends IndexNode {
3177         int len;
3178         ParentLookup() {}
3179 
3180         final ParentLookup as(byte[] name, int len) { // as a lookup &quot;key&quot;
3181             name(name, len);
3182             return this;
3183         }
3184 
3185         void name(byte[] name, int len) {
3186             this.name = name;
3187             this.len = len;
3188             // calculate the hashcode the same way as Arrays.hashCode() does
3189             int result = 1;
3190             for (int i = 0; i &lt; len; i++)
3191                 result = 31 * result + name[i];
3192             this.hashcode = result;
3193         }
3194 
3195         @Override
3196         public boolean equals(Object other) {
3197             if (!(other instanceof IndexNode)) {
3198                 return false;
3199             }
3200             byte[] oname = ((IndexNode)other).name;
3201             return Arrays.equals(name, 0, len,
3202                                  oname, 0, oname.length);
3203         }
3204     }
3205 }
    </pre>
  </body>
</html>
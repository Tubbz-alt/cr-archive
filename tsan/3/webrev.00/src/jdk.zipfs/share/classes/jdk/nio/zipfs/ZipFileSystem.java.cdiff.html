<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipFileSystem.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZipFileStore.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipFileSystemProvider.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipFileSystem.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,29 ***</span>
  import java.io.EOFException;
  import java.io.FilterOutputStream;
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.OutputStream;
  import java.nio.ByteBuffer;
  import java.nio.MappedByteBuffer;
  import java.nio.channels.FileChannel;
  import java.nio.channels.FileLock;
  import java.nio.channels.ReadableByteChannel;
  import java.nio.channels.SeekableByteChannel;
  import java.nio.channels.WritableByteChannel;
  import java.nio.file.*;
<span class="line-modified">! import java.nio.file.attribute.FileAttribute;</span>
<span class="line-removed">- import java.nio.file.attribute.FileTime;</span>
<span class="line-removed">- import java.nio.file.attribute.UserPrincipalLookupService;</span>
  import java.nio.file.spi.FileSystemProvider;
  import java.security.AccessController;
  import java.security.PrivilegedAction;
  import java.security.PrivilegedActionException;
  import java.security.PrivilegedExceptionAction;
  import java.util.*;
  import java.util.concurrent.locks.ReadWriteLock;
  import java.util.concurrent.locks.ReentrantReadWriteLock;
  import java.util.regex.Pattern;
  import java.util.zip.CRC32;
  import java.util.zip.Deflater;
  import java.util.zip.DeflaterOutputStream;
  import java.util.zip.Inflater;
<span class="line-new-header">--- 31,32 ---</span>
  import java.io.EOFException;
  import java.io.FilterOutputStream;
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.OutputStream;
<span class="line-added">+ import java.lang.Runtime.Version;</span>
  import java.nio.ByteBuffer;
  import java.nio.MappedByteBuffer;
  import java.nio.channels.FileChannel;
  import java.nio.channels.FileLock;
  import java.nio.channels.ReadableByteChannel;
  import java.nio.channels.SeekableByteChannel;
  import java.nio.channels.WritableByteChannel;
  import java.nio.file.*;
<span class="line-modified">! import java.nio.file.attribute.*;</span>
  import java.nio.file.spi.FileSystemProvider;
  import java.security.AccessController;
  import java.security.PrivilegedAction;
  import java.security.PrivilegedActionException;
  import java.security.PrivilegedExceptionAction;
  import java.util.*;
  import java.util.concurrent.locks.ReadWriteLock;
  import java.util.concurrent.locks.ReentrantReadWriteLock;
<span class="line-added">+ import java.util.function.Consumer;</span>
<span class="line-added">+ import java.util.function.Function;</span>
<span class="line-added">+ import java.util.jar.Attributes;</span>
<span class="line-added">+ import java.util.jar.Manifest;</span>
  import java.util.regex.Pattern;
  import java.util.zip.CRC32;
  import java.util.zip.Deflater;
  import java.util.zip.DeflaterOutputStream;
  import java.util.zip.Inflater;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 76,52 ***</span>
   * A FileSystem built on a zip file
   *
   * @author Xueming Shen
   */
  class ZipFileSystem extends FileSystem {
      private final ZipFileSystemProvider provider;
      private final Path zfpath;
      final ZipCoder zc;
      private final ZipPath rootdir;
<span class="line-modified">!     private boolean readOnly = false;    // readonly file system</span>
  
      // configurable by env map
      private final boolean noExtt;        // see readExtra()
      private final boolean useTempFile;   // use a temp file for newOS, default
                                           // is to use BAOS for better performance
<span class="line-removed">-     private static final boolean isWindows = AccessController.doPrivileged(</span>
<span class="line-removed">-             (PrivilegedAction&lt;Boolean&gt;)() -&gt; System.getProperty(&quot;os.name&quot;)</span>
<span class="line-removed">-                                                    .startsWith(&quot;Windows&quot;));</span>
      private final boolean forceEnd64;
<span class="line-modified">!     private final int defaultMethod;     // METHOD_STORED if &quot;noCompression=true&quot;</span>
<span class="line-modified">!                                          // METHOD_DEFLATED otherwise</span>
  
      ZipFileSystem(ZipFileSystemProvider provider,
                    Path zfpath,
                    Map&lt;String, ?&gt; env) throws IOException
      {
          // default encoding for name/comment
          String nameEncoding = env.containsKey(&quot;encoding&quot;) ?
<span class="line-modified">!                               (String)env.get(&quot;encoding&quot;) : &quot;UTF-8&quot;;</span>
          this.noExtt = &quot;false&quot;.equals(env.get(&quot;zipinfo-time&quot;));
          this.useTempFile  = isTrue(env, &quot;useTempFile&quot;);
          this.forceEnd64 = isTrue(env, &quot;forceZIP64End&quot;);
<span class="line-modified">!         this.defaultMethod = isTrue(env, &quot;noCompression&quot;) ? METHOD_STORED: METHOD_DEFLATED;</span>
          if (Files.notExists(zfpath)) {
<span class="line-modified">!             // create a new zip if not exists</span>
              if (isTrue(env, &quot;create&quot;)) {
                  try (OutputStream os = Files.newOutputStream(zfpath, CREATE_NEW, WRITE)) {
                      new END().write(os, 0, forceEnd64);
                  }
              } else {
<span class="line-modified">!                 throw new FileSystemNotFoundException(zfpath.toString());</span>
              }
          }
          // sm and existence check
          zfpath.getFileSystem().provider().checkAccess(zfpath, AccessMode.READ);
          boolean writeable = AccessController.doPrivileged(
<span class="line-modified">!             (PrivilegedAction&lt;Boolean&gt;) () -&gt;  Files.isWritable(zfpath));</span>
          this.readOnly = !writeable;
          this.zc = ZipCoder.get(nameEncoding);
          this.rootdir = new ZipPath(this, new byte[]{&#39;/&#39;});
          this.ch = Files.newByteChannel(zfpath, READ);
          try {
<span class="line-new-header">--- 79,93 ---</span>
   * A FileSystem built on a zip file
   *
   * @author Xueming Shen
   */
  class ZipFileSystem extends FileSystem {
<span class="line-added">+     // statics</span>
<span class="line-added">+     private static final boolean isWindows = AccessController.doPrivileged(</span>
<span class="line-added">+         (PrivilegedAction&lt;Boolean&gt;)()-&gt;System.getProperty(&quot;os.name&quot;)</span>
<span class="line-added">+                                              .startsWith(&quot;Windows&quot;));</span>
<span class="line-added">+     private static final byte[] ROOTPATH = new byte[] { &#39;/&#39; };</span>
<span class="line-added">+     private static final String PROPERTY_POSIX = &quot;enablePosixFileAttributes&quot;;</span>
<span class="line-added">+     private static final String PROPERTY_DEFAULT_OWNER = &quot;defaultOwner&quot;;</span>
<span class="line-added">+     private static final String PROPERTY_DEFAULT_GROUP = &quot;defaultGroup&quot;;</span>
<span class="line-added">+     private static final String PROPERTY_DEFAULT_PERMISSIONS = &quot;defaultPermissions&quot;;</span>
<span class="line-added">+     // Property used to specify the entry version to use for a multi-release JAR</span>
<span class="line-added">+     private static final String PROPERTY_RELEASE_VERSION = &quot;releaseVersion&quot;;</span>
<span class="line-added">+     // Original property used to specify the entry version to use for a</span>
<span class="line-added">+     // multi-release JAR which is kept for backwards compatibility.</span>
<span class="line-added">+     private static final String PROPERTY_MULTI_RELEASE = &quot;multi-release&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static final Set&lt;PosixFilePermission&gt; DEFAULT_PERMISSIONS =</span>
<span class="line-added">+         PosixFilePermissions.fromString(&quot;rwxrwxrwx&quot;);</span>
<span class="line-added">+     // Property used to specify the compression mode to use</span>
<span class="line-added">+     private static final String PROPERTY_COMPRESSION_METHOD = &quot;compressionMethod&quot;;</span>
<span class="line-added">+     // Value specified for compressionMethod property to compress Zip entries</span>
<span class="line-added">+     private static final String COMPRESSION_METHOD_DEFLATED = &quot;DEFLATED&quot;;</span>
<span class="line-added">+     // Value specified for compressionMethod property to not compress Zip entries</span>
<span class="line-added">+     private static final String COMPRESSION_METHOD_STORED = &quot;STORED&quot;;</span>
<span class="line-added">+ </span>
      private final ZipFileSystemProvider provider;
      private final Path zfpath;
      final ZipCoder zc;
      private final ZipPath rootdir;
<span class="line-modified">!     private boolean readOnly; // readonly file system, false by default</span>
<span class="line-added">+ </span>
<span class="line-added">+     // default time stamp for pseudo entries</span>
<span class="line-added">+     private final long zfsDefaultTimeStamp = System.currentTimeMillis();</span>
  
      // configurable by env map
      private final boolean noExtt;        // see readExtra()
      private final boolean useTempFile;   // use a temp file for newOS, default
                                           // is to use BAOS for better performance
      private final boolean forceEnd64;
<span class="line-modified">!     private final int defaultCompressionMethod; // METHOD_STORED if &quot;noCompression=true&quot;</span>
<span class="line-modified">!                                                 // METHOD_DEFLATED otherwise</span>
<span class="line-added">+ </span>
<span class="line-added">+     // entryLookup is identity by default, will be overridden for multi-release jars</span>
<span class="line-added">+     private Function&lt;byte[], byte[]&gt; entryLookup = Function.identity();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // POSIX support</span>
<span class="line-added">+     final boolean supportPosix;</span>
<span class="line-added">+     private final UserPrincipal defaultOwner;</span>
<span class="line-added">+     private final GroupPrincipal defaultGroup;</span>
<span class="line-added">+     private final Set&lt;PosixFilePermission&gt; defaultPermissions;</span>
<span class="line-added">+ </span>
<span class="line-added">+     private final Set&lt;String&gt; supportedFileAttributeViews;</span>
  
      ZipFileSystem(ZipFileSystemProvider provider,
                    Path zfpath,
                    Map&lt;String, ?&gt; env) throws IOException
      {
          // default encoding for name/comment
          String nameEncoding = env.containsKey(&quot;encoding&quot;) ?
<span class="line-modified">!             (String)env.get(&quot;encoding&quot;) : &quot;UTF-8&quot;;</span>
          this.noExtt = &quot;false&quot;.equals(env.get(&quot;zipinfo-time&quot;));
          this.useTempFile  = isTrue(env, &quot;useTempFile&quot;);
          this.forceEnd64 = isTrue(env, &quot;forceZIP64End&quot;);
<span class="line-modified">!         this.defaultCompressionMethod = getDefaultCompressionMethod(env);</span>
<span class="line-added">+         this.supportPosix = isTrue(env, PROPERTY_POSIX);</span>
<span class="line-added">+         this.defaultOwner = initOwner(zfpath, env);</span>
<span class="line-added">+         this.defaultGroup = initGroup(zfpath, env);</span>
<span class="line-added">+         this.defaultPermissions = initPermissions(env);</span>
<span class="line-added">+         this.supportedFileAttributeViews = supportPosix ?</span>
<span class="line-added">+             Set.of(&quot;basic&quot;, &quot;posix&quot;, &quot;zip&quot;) : Set.of(&quot;basic&quot;, &quot;zip&quot;);</span>
          if (Files.notExists(zfpath)) {
<span class="line-modified">!             // create a new zip if it doesn&#39;t exist</span>
              if (isTrue(env, &quot;create&quot;)) {
                  try (OutputStream os = Files.newOutputStream(zfpath, CREATE_NEW, WRITE)) {
                      new END().write(os, 0, forceEnd64);
                  }
              } else {
<span class="line-modified">!                 throw new NoSuchFileException(zfpath.toString());</span>
              }
          }
          // sm and existence check
          zfpath.getFileSystem().provider().checkAccess(zfpath, AccessMode.READ);
          boolean writeable = AccessController.doPrivileged(
<span class="line-modified">!             (PrivilegedAction&lt;Boolean&gt;)()-&gt;Files.isWritable(zfpath));</span>
          this.readOnly = !writeable;
          this.zc = ZipCoder.get(nameEncoding);
          this.rootdir = new ZipPath(this, new byte[]{&#39;/&#39;});
          this.ch = Files.newByteChannel(zfpath, READ);
          try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,17 ***</span>
<span class="line-new-header">--- 178,166 ---</span>
              }
              throw x;
          }
          this.provider = provider;
          this.zfpath = zfpath;
<span class="line-added">+ </span>
<span class="line-added">+         initializeReleaseVersion(env);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Return the compression method to use (STORED or DEFLATED).  If the</span>
<span class="line-added">+      * property {@code commpressionMethod} is set use its value to determine</span>
<span class="line-added">+      * the compression method to use.  If the property is not set, then the</span>
<span class="line-added">+      * default compression is DEFLATED unless the property {@code noCompression}</span>
<span class="line-added">+      * is set which is supported for backwards compatibility.</span>
<span class="line-added">+      * @param env Zip FS map of properties</span>
<span class="line-added">+      * @return The Compression method to use</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private int getDefaultCompressionMethod(Map&lt;String, ?&gt; env) {</span>
<span class="line-added">+         int result =</span>
<span class="line-added">+                 isTrue(env, &quot;noCompression&quot;) ? METHOD_STORED : METHOD_DEFLATED;</span>
<span class="line-added">+         if (env.containsKey(PROPERTY_COMPRESSION_METHOD)) {</span>
<span class="line-added">+             Object compressionMethod =  env.get(PROPERTY_COMPRESSION_METHOD);</span>
<span class="line-added">+             if (compressionMethod != null) {</span>
<span class="line-added">+                 if (compressionMethod instanceof String) {</span>
<span class="line-added">+                     switch (((String) compressionMethod).toUpperCase()) {</span>
<span class="line-added">+                         case COMPRESSION_METHOD_STORED:</span>
<span class="line-added">+                             result = METHOD_STORED;</span>
<span class="line-added">+                             break;</span>
<span class="line-added">+                         case COMPRESSION_METHOD_DEFLATED:</span>
<span class="line-added">+                             result = METHOD_DEFLATED;</span>
<span class="line-added">+                             break;</span>
<span class="line-added">+                         default:</span>
<span class="line-added">+                             throw new IllegalArgumentException(String.format(</span>
<span class="line-added">+                                     &quot;The value for the %s property must be %s or %s&quot;,</span>
<span class="line-added">+                                     PROPERTY_COMPRESSION_METHOD, COMPRESSION_METHOD_STORED,</span>
<span class="line-added">+                                     COMPRESSION_METHOD_DEFLATED));</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     throw new IllegalArgumentException(String.format(</span>
<span class="line-added">+                             &quot;The Object type for the %s property must be a String&quot;,</span>
<span class="line-added">+                             PROPERTY_COMPRESSION_METHOD));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 throw new IllegalArgumentException(String.format(</span>
<span class="line-added">+                         &quot;The value for the %s property must be %s or %s&quot;,</span>
<span class="line-added">+                         PROPERTY_COMPRESSION_METHOD, COMPRESSION_METHOD_STORED,</span>
<span class="line-added">+                         COMPRESSION_METHOD_DEFLATED));</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return result;</span>
      }
  
      // returns true if there is a name=true/&quot;true&quot; setting in env
      private static boolean isTrue(Map&lt;String, ?&gt; env, String name) {
          return &quot;true&quot;.equals(env.get(name)) || TRUE.equals(env.get(name));
      }
  
<span class="line-added">+     // Initialize the default owner for files inside the zip archive.</span>
<span class="line-added">+     // If not specified in env, it is the owner of the archive. If no owner can</span>
<span class="line-added">+     // be determined, we try to go with system property &quot;user.name&quot;. If that&#39;s not</span>
<span class="line-added">+     // accessible, we return &quot;&lt;zipfs_default&gt;&quot;.</span>
<span class="line-added">+     private UserPrincipal initOwner(Path zfpath, Map&lt;String, ?&gt; env) throws IOException {</span>
<span class="line-added">+         Object o = env.get(PROPERTY_DEFAULT_OWNER);</span>
<span class="line-added">+         if (o == null) {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 PrivilegedExceptionAction&lt;UserPrincipal&gt; pa = ()-&gt;Files.getOwner(zfpath);</span>
<span class="line-added">+                 return AccessController.doPrivileged(pa);</span>
<span class="line-added">+             } catch (UnsupportedOperationException | PrivilegedActionException e) {</span>
<span class="line-added">+                 if (e instanceof UnsupportedOperationException ||</span>
<span class="line-added">+                     e.getCause() instanceof NoSuchFileException)</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     PrivilegedAction&lt;String&gt; pa = ()-&gt;System.getProperty(&quot;user.name&quot;);</span>
<span class="line-added">+                     String userName = AccessController.doPrivileged(pa);</span>
<span class="line-added">+                     return ()-&gt;userName;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     throw new IOException(e);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (o instanceof String) {</span>
<span class="line-added">+             if (((String)o).isEmpty()) {</span>
<span class="line-added">+                 throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added">+                         PROPERTY_DEFAULT_OWNER + &quot; must not be empty.&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return ()-&gt;(String)o;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (o instanceof UserPrincipal) {</span>
<span class="line-added">+             return (UserPrincipal)o;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added">+                 PROPERTY_DEFAULT_OWNER + &quot; must be of type &quot; + String.class +</span>
<span class="line-added">+             &quot; or &quot; + UserPrincipal.class);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Initialize the default group for files inside the zip archive.</span>
<span class="line-added">+     // If not specified in env, we try to determine the group of the zip archive itself.</span>
<span class="line-added">+     // If this is not possible/unsupported, we will return a group principal going by</span>
<span class="line-added">+     // the same name as the default owner.</span>
<span class="line-added">+     private GroupPrincipal initGroup(Path zfpath, Map&lt;String, ?&gt; env) throws IOException {</span>
<span class="line-added">+         Object o = env.get(PROPERTY_DEFAULT_GROUP);</span>
<span class="line-added">+         if (o == null) {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 PosixFileAttributeView zfpv = Files.getFileAttributeView(zfpath, PosixFileAttributeView.class);</span>
<span class="line-added">+                 if (zfpv == null) {</span>
<span class="line-added">+                     return defaultOwner::getName;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 PrivilegedExceptionAction&lt;GroupPrincipal&gt; pa = ()-&gt;zfpv.readAttributes().group();</span>
<span class="line-added">+                 return AccessController.doPrivileged(pa);</span>
<span class="line-added">+             } catch (UnsupportedOperationException | PrivilegedActionException e) {</span>
<span class="line-added">+                 if (e instanceof UnsupportedOperationException ||</span>
<span class="line-added">+                     e.getCause() instanceof NoSuchFileException)</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     return defaultOwner::getName;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     throw new IOException(e);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (o instanceof String) {</span>
<span class="line-added">+             if (((String)o).isEmpty()) {</span>
<span class="line-added">+                 throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added">+                         PROPERTY_DEFAULT_GROUP + &quot; must not be empty.&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return ()-&gt;(String)o;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (o instanceof GroupPrincipal) {</span>
<span class="line-added">+             return (GroupPrincipal)o;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added">+                 PROPERTY_DEFAULT_GROUP + &quot; must be of type &quot; + String.class +</span>
<span class="line-added">+             &quot; or &quot; + GroupPrincipal.class);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Initialize the default permissions for files inside the zip archive.</span>
<span class="line-added">+     // If not specified in env, it will return 777.</span>
<span class="line-added">+     private Set&lt;PosixFilePermission&gt; initPermissions(Map&lt;String, ?&gt; env) {</span>
<span class="line-added">+         Object o = env.get(PROPERTY_DEFAULT_PERMISSIONS);</span>
<span class="line-added">+         if (o == null) {</span>
<span class="line-added">+             return DEFAULT_PERMISSIONS;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (o instanceof String) {</span>
<span class="line-added">+             return PosixFilePermissions.fromString((String)o);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (!(o instanceof Set)) {</span>
<span class="line-added">+             throw new IllegalArgumentException(&quot;Value for property &quot; +</span>
<span class="line-added">+                 PROPERTY_DEFAULT_PERMISSIONS + &quot; must be of type &quot; + String.class +</span>
<span class="line-added">+                 &quot; or &quot; + Set.class);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         Set&lt;PosixFilePermission&gt; perms = new HashSet&lt;&gt;();</span>
<span class="line-added">+         for (Object o2 : (Set&lt;?&gt;)o) {</span>
<span class="line-added">+             if (o2 instanceof PosixFilePermission) {</span>
<span class="line-added">+                 perms.add((PosixFilePermission)o2);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 throw new IllegalArgumentException(PROPERTY_DEFAULT_PERMISSIONS +</span>
<span class="line-added">+                     &quot; must only contain objects of type &quot; + PosixFilePermission.class);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return perms;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public FileSystemProvider provider() {
          return provider;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 161,13 ***</span>
      @Override
      public boolean isReadOnly() {
          return readOnly;
      }
  
<span class="line-modified">!     private void checkWritable() throws IOException {</span>
<span class="line-modified">!         if (readOnly)</span>
              throw new ReadOnlyFileSystemException();
      }
  
      void setReadOnly() {
          this.readOnly = true;
      }
<span class="line-new-header">--- 354,14 ---</span>
      @Override
      public boolean isReadOnly() {
          return readOnly;
      }
  
<span class="line-modified">!     private void checkWritable() {</span>
<span class="line-modified">!         if (readOnly) {</span>
              throw new ReadOnlyFileSystemException();
<span class="line-added">+         }</span>
      }
  
      void setReadOnly() {
          this.readOnly = true;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 216,13 ***</span>
      @Override
      public Iterable&lt;FileStore&gt; getFileStores() {
          return List.of(new ZipFileStore(rootdir));
      }
  
<span class="line-removed">-     private static final Set&lt;String&gt; supportedFileAttributeViews =</span>
<span class="line-removed">-             Set.of(&quot;basic&quot;, &quot;zip&quot;);</span>
<span class="line-removed">- </span>
      @Override
      public Set&lt;String&gt; supportedFileAttributeViews() {
          return supportedFileAttributeViews;
      }
  
<span class="line-new-header">--- 410,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 257,16 ***</span>
                      &quot;&#39; not recognized&quot;);
              }
          }
          // return matcher
          final Pattern pattern = Pattern.compile(expr);
<span class="line-modified">!         return new PathMatcher() {</span>
<span class="line-removed">-             @Override</span>
<span class="line-removed">-             public boolean matches(Path path) {</span>
<span class="line-removed">-                 return pattern.matcher(path.toString()).matches();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         };</span>
      }
  
      @Override
      public void close() throws IOException {
          beginWrite();
<span class="line-new-header">--- 448,11 ---</span>
                      &quot;&#39; not recognized&quot;);
              }
          }
          // return matcher
          final Pattern pattern = Pattern.compile(expr);
<span class="line-modified">!         return (path)-&gt;pattern.matcher(path.toString()).matches();</span>
      }
  
      @Override
      public void close() throws IOException {
          beginWrite();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 302,10 ***</span>
<span class="line-new-header">--- 488,18 ---</span>
          synchronized (deflaters) {
              for (Deflater def : deflaters)
                  def.end();
          }
  
<span class="line-added">+         beginWrite();                // lock and sync</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             // Clear the map so that its keys &amp; values can be garbage collected</span>
<span class="line-added">+             inodes = null;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             endWrite();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          IOException ioe = null;
          synchronized (tmppaths) {
              for (Path p : tmppaths) {
                  try {
                      AccessController.doPrivileged(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 325,27 ***</span>
      }
  
      ZipFileAttributes getFileAttributes(byte[] path)
          throws IOException
      {
<span class="line-removed">-         Entry e;</span>
          beginRead();
          try {
              ensureOpen();
<span class="line-modified">!             e = getEntry(path);</span>
<span class="line-modified">!             if (e == null) {</span>
<span class="line-modified">!                 IndexNode inode = getInode(path);</span>
<span class="line-modified">!                 if (inode == null)</span>
<span class="line-modified">!                     return null;</span>
                  // pseudo directory, uses METHOD_STORED
<span class="line-modified">!                 e = new Entry(inode.name, inode.isdir, METHOD_STORED);</span>
                  e.mtime = e.atime = e.ctime = zfsDefaultTimeStamp;
              }
          } finally {
              endRead();
          }
<span class="line-removed">-         return e;</span>
      }
  
      void checkAccess(byte[] path) throws IOException {
          beginRead();
          try {
<span class="line-new-header">--- 519,31 ---</span>
      }
  
      ZipFileAttributes getFileAttributes(byte[] path)
          throws IOException
      {
          beginRead();
          try {
              ensureOpen();
<span class="line-modified">!             IndexNode inode = getInode(path);</span>
<span class="line-modified">!             if (inode == null) {</span>
<span class="line-modified">!                 return null;</span>
<span class="line-modified">!             } else if (inode instanceof Entry) {</span>
<span class="line-modified">!                 return (Entry)inode;</span>
<span class="line-added">+             } else if (inode.pos == -1) {</span>
                  // pseudo directory, uses METHOD_STORED
<span class="line-modified">!                 Entry e = supportPosix ?</span>
<span class="line-added">+                     new PosixEntry(inode.name, inode.isdir, METHOD_STORED) :</span>
<span class="line-added">+                     new Entry(inode.name, inode.isdir, METHOD_STORED);</span>
                  e.mtime = e.atime = e.ctime = zfsDefaultTimeStamp;
<span class="line-added">+                 return e;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 return supportPosix ? new PosixEntry(this, inode) : new Entry(this, inode);</span>
              }
          } finally {
              endRead();
          }
      }
  
      void checkAccess(byte[] path) throws IOException {
          beginRead();
          try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 369,11 ***</span>
              ensureOpen();
              Entry e = getEntry(path);    // ensureOpen checked
              if (e == null)
                  throw new NoSuchFileException(getString(path));
              if (e.type == Entry.CEN)
<span class="line-modified">!                 e.type = Entry.COPY;      // copy e</span>
              if (mtime != null)
                  e.mtime = mtime.toMillis();
              if (atime != null)
                  e.atime = atime.toMillis();
              if (ctime != null)
<span class="line-new-header">--- 567,11 ---</span>
              ensureOpen();
              Entry e = getEntry(path);    // ensureOpen checked
              if (e == null)
                  throw new NoSuchFileException(getString(path));
              if (e.type == Entry.CEN)
<span class="line-modified">!                 e.type = Entry.COPY;     // copy e</span>
              if (mtime != null)
                  e.mtime = mtime.toMillis();
              if (atime != null)
                  e.atime = atime.toMillis();
              if (ctime != null)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 382,25 ***</span>
          } finally {
              endWrite();
          }
      }
  
<span class="line-modified">!     boolean exists(byte[] path)</span>
<span class="line-modified">!         throws IOException</span>
<span class="line-modified">!     {</span>
          beginRead();
          try {
              ensureOpen();
              return getInode(path) != null;
          } finally {
              endRead();
          }
      }
  
<span class="line-modified">!     boolean isDirectory(byte[] path)</span>
<span class="line-removed">-         throws IOException</span>
<span class="line-removed">-     {</span>
          beginRead();
          try {
              IndexNode n = getInode(path);
              return n != null &amp;&amp; n.isDir();
          } finally {
<span class="line-new-header">--- 580,80 ---</span>
          } finally {
              endWrite();
          }
      }
  
<span class="line-modified">!     void setOwner(byte[] path, UserPrincipal owner) throws IOException {</span>
<span class="line-modified">!         checkWritable();</span>
<span class="line-modified">!         beginWrite();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             ensureOpen();</span>
<span class="line-added">+             Entry e = getEntry(path);    // ensureOpen checked</span>
<span class="line-added">+             if (e == null) {</span>
<span class="line-added">+                 throw new NoSuchFileException(getString(path));</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // as the owner information is not persistent, we don&#39;t need to</span>
<span class="line-added">+             // change e.type to Entry.COPY</span>
<span class="line-added">+             if (e instanceof PosixEntry) {</span>
<span class="line-added">+                 ((PosixEntry)e).owner = owner;</span>
<span class="line-added">+                 update(e);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             endWrite();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void setGroup(byte[] path, GroupPrincipal group) throws IOException {</span>
<span class="line-added">+         checkWritable();</span>
<span class="line-added">+         beginWrite();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             ensureOpen();</span>
<span class="line-added">+             Entry e = getEntry(path);    // ensureOpen checked</span>
<span class="line-added">+             if (e == null) {</span>
<span class="line-added">+                 throw new NoSuchFileException(getString(path));</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // as the group information is not persistent, we don&#39;t need to</span>
<span class="line-added">+             // change e.type to Entry.COPY</span>
<span class="line-added">+             if (e instanceof PosixEntry) {</span>
<span class="line-added">+                 ((PosixEntry)e).group = group;</span>
<span class="line-added">+                 update(e);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             endWrite();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void setPermissions(byte[] path, Set&lt;PosixFilePermission&gt; perms) throws IOException {</span>
<span class="line-added">+         checkWritable();</span>
<span class="line-added">+         beginWrite();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             ensureOpen();</span>
<span class="line-added">+             Entry e = getEntry(path);    // ensureOpen checked</span>
<span class="line-added">+             if (e == null) {</span>
<span class="line-added">+                 throw new NoSuchFileException(getString(path));</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (e.type == Entry.CEN) {</span>
<span class="line-added">+                 e.type = Entry.COPY;     // copy e</span>
<span class="line-added">+             }</span>
<span class="line-added">+             e.posixPerms = perms == null ? -1 : ZipUtils.permsToFlags(perms);</span>
<span class="line-added">+             update(e);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             endWrite();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     boolean exists(byte[] path) {</span>
          beginRead();
          try {
              ensureOpen();
              return getInode(path) != null;
          } finally {
              endRead();
          }
      }
  
<span class="line-modified">!     boolean isDirectory(byte[] path) {</span>
          beginRead();
          try {
              IndexNode n = getInode(path);
              return n != null &amp;&amp; n.isDir();
          } finally {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,12 ***</span>
                  // (1) Assume each path from the zip file itself is &quot;normalized&quot;
                  // (2) IndexNode.name is absolute. see IndexNode(byte[],int,int)
                  // (3) If parent &quot;dir&quot; is relative when ZipDirectoryStream
                  //     is created, the returned child path needs to be relative
                  //     as well.
<span class="line-modified">!                 byte[] cname = child.name;</span>
<span class="line-removed">-                 ZipPath childPath = new ZipPath(this, cname, true);</span>
                  ZipPath childFileName = childPath.getFileName();
                  ZipPath zpath = dir.resolve(childFileName);
                  if (filter == null || filter.accept(zpath))
                      list.add(zpath);
                  child = child.sibling;
<span class="line-new-header">--- 679,11 ---</span>
                  // (1) Assume each path from the zip file itself is &quot;normalized&quot;
                  // (2) IndexNode.name is absolute. see IndexNode(byte[],int,int)
                  // (3) If parent &quot;dir&quot; is relative when ZipDirectoryStream
                  //     is created, the returned child path needs to be relative
                  //     as well.
<span class="line-modified">!                 ZipPath childPath = new ZipPath(this, child.name, true);</span>
                  ZipPath childFileName = childPath.getFileName();
                  ZipPath zpath = dir.resolve(childFileName);
                  if (filter == null || filter.accept(zpath))
                      list.add(zpath);
                  child = child.sibling;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 440,22 ***</span>
          } finally {
              endWrite();
          }
      }
  
<span class="line-modified">!     void createDirectory(byte[] dir, FileAttribute&lt;?&gt;... attrs)</span>
<span class="line-removed">-         throws IOException</span>
<span class="line-removed">-     {</span>
          checkWritable();
<span class="line-removed">-         //  dir = toDirectoryPath(dir);</span>
          beginWrite();
          try {
              ensureOpen();
<span class="line-modified">!             if (dir.length == 0 || exists(dir))  // root dir, or exiting dir</span>
                  throw new FileAlreadyExistsException(getString(dir));
              checkParents(dir);
<span class="line-modified">!             Entry e = new Entry(dir, Entry.NEW, true, METHOD_STORED);</span>
              update(e);
          } finally {
              endWrite();
          }
      }
<span class="line-new-header">--- 692,21 ---</span>
          } finally {
              endWrite();
          }
      }
  
<span class="line-modified">!     void createDirectory(byte[] dir, FileAttribute&lt;?&gt;... attrs) throws IOException {</span>
          checkWritable();
          beginWrite();
          try {
              ensureOpen();
<span class="line-modified">!             if (dir.length == 0 || exists(dir))  // root dir, or existing dir</span>
                  throw new FileAlreadyExistsException(getString(dir));
              checkParents(dir);
<span class="line-modified">!             Entry e = supportPosix ?</span>
<span class="line-added">+                 new PosixEntry(dir, Entry.NEW, true, METHOD_STORED, attrs) :</span>
<span class="line-added">+                 new Entry(dir, Entry.NEW, true, METHOD_STORED, attrs);</span>
              update(e);
          } finally {
              endWrite();
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 491,14 ***</span>
                  if (!hasReplace)
                      throw new FileAlreadyExistsException(getString(dst));
              } else {
                  checkParents(dst);
              }
<span class="line-modified">!             Entry u = new Entry(eSrc, Entry.COPY);  // copy eSrc entry</span>
<span class="line-modified">!             u.name(dst);                            // change name</span>
<span class="line-modified">!             if (eSrc.type == Entry.NEW || eSrc.type == Entry.FILECH)</span>
<span class="line-modified">!             {</span>
                  u.type = eSrc.type;    // make it the same type
                  if (deletesrc) {       // if it&#39;s a &quot;rename&quot;, take the data
                      u.bytes = eSrc.bytes;
                      u.file = eSrc.file;
                  } else {               // if it&#39;s not &quot;rename&quot;, copy the data
<span class="line-new-header">--- 742,16 ---</span>
                  if (!hasReplace)
                      throw new FileAlreadyExistsException(getString(dst));
              } else {
                  checkParents(dst);
              }
<span class="line-modified">!             // copy eSrc entry and change name</span>
<span class="line-modified">!             Entry u = supportPosix ?</span>
<span class="line-modified">!                 new PosixEntry((PosixEntry)eSrc, Entry.COPY) :</span>
<span class="line-modified">!                 new Entry(eSrc, Entry.COPY);</span>
<span class="line-added">+             u.name(dst);</span>
<span class="line-added">+             if (eSrc.type == Entry.NEW || eSrc.type == Entry.FILECH) {</span>
                  u.type = eSrc.type;    // make it the same type
                  if (deletesrc) {       // if it&#39;s a &quot;rename&quot;, take the data
                      u.bytes = eSrc.bytes;
                      u.file = eSrc.file;
                  } else {               // if it&#39;s not &quot;rename&quot;, copy the data
</pre>
<hr />
<pre>
<span class="line-old-header">*** 507,11 ***</span>
<span class="line-new-header">--- 760,24 ---</span>
                      else if (eSrc.file != null) {
                          u.file = getTempPathForEntry(null);
                          Files.copy(eSrc.file, u.file, REPLACE_EXISTING);
                      }
                  }
<span class="line-added">+             } else if (eSrc.type == Entry.CEN &amp;&amp; eSrc.method != defaultCompressionMethod) {</span>
<span class="line-added">+ </span>
<span class="line-added">+                 /**</span>
<span class="line-added">+                  * We are copying a file within the same Zip file using a</span>
<span class="line-added">+                  * different compression method.</span>
<span class="line-added">+                  */</span>
<span class="line-added">+                 try (InputStream in = newInputStream(src);</span>
<span class="line-added">+                      OutputStream out = newOutputStream(dst,</span>
<span class="line-added">+                              CREATE, TRUNCATE_EXISTING, WRITE)) {</span>
<span class="line-added">+                     in.transferTo(out);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 u = getEntry(dst);</span>
              }
<span class="line-added">+ </span>
              if (!hasCopyAttrs)
                  u.mtime = u.atime= u.ctime = System.currentTimeMillis();
              update(u);
              if (deletesrc)
                  updateDelete(eSrc);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 550,22 ***</span>
              Entry e = getEntry(path);
              if (e != null) {
                  if (e.isDir() || hasCreateNew)
                      throw new FileAlreadyExistsException(getString(path));
                  if (hasAppend) {
<span class="line-removed">-                     InputStream is = getInputStream(e);</span>
                      OutputStream os = getOutputStream(new Entry(e, Entry.NEW));
<span class="line-modified">!                     is.transferTo(os);</span>
<span class="line-modified">!                     is.close();</span>
                      return os;
                  }
<span class="line-modified">!                 return getOutputStream(new Entry(e, Entry.NEW));</span>
              } else {
                  if (!hasCreate &amp;&amp; !hasCreateNew)
                      throw new NoSuchFileException(getString(path));
                  checkParents(path);
<span class="line-modified">!                 return getOutputStream(new Entry(path, Entry.NEW, false, defaultMethod));</span>
              }
          } finally {
              endRead();
          }
      }
<span class="line-new-header">--- 816,26 ---</span>
              Entry e = getEntry(path);
              if (e != null) {
                  if (e.isDir() || hasCreateNew)
                      throw new FileAlreadyExistsException(getString(path));
                  if (hasAppend) {
                      OutputStream os = getOutputStream(new Entry(e, Entry.NEW));
<span class="line-modified">!                     try (InputStream is = getInputStream(e)) {</span>
<span class="line-modified">!                         is.transferTo(os);</span>
<span class="line-added">+                     }</span>
                      return os;
                  }
<span class="line-modified">!                 return getOutputStream(supportPosix ?</span>
<span class="line-added">+                     new PosixEntry((PosixEntry)e, Entry.NEW, defaultCompressionMethod)</span>
<span class="line-added">+                         : new Entry(e, Entry.NEW, defaultCompressionMethod));</span>
              } else {
                  if (!hasCreate &amp;&amp; !hasCreateNew)
                      throw new NoSuchFileException(getString(path));
                  checkParents(path);
<span class="line-modified">!                 return getOutputStream(supportPosix ?</span>
<span class="line-added">+                     new PosixEntry(path, Entry.NEW, false, defaultCompressionMethod) :</span>
<span class="line-added">+                     new Entry(path, Entry.NEW, false, defaultCompressionMethod));</span>
              }
          } finally {
              endRead();
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 597,68 ***</span>
          }
          if (options.contains(APPEND) &amp;&amp; options.contains(TRUNCATE_EXISTING))
              throw new IllegalArgumentException(&quot;APPEND + TRUNCATE_EXISTING not allowed&quot;);
      }
  
<span class="line-removed">- </span>
      // Returns an output SeekableByteChannel for either
<span class="line-modified">!     // (1) writing the contents of a new entry, if the entry doesn&#39;t exit, or</span>
      // (2) updating/replacing the contents of an existing entry.
<span class="line-modified">!     // Note: The content is not compressed.</span>
      private class EntryOutputChannel extends ByteArrayChannel {
<span class="line-modified">!         Entry e;</span>
  
<span class="line-modified">!         EntryOutputChannel(Entry e) throws IOException {</span>
              super(e.size &gt; 0? (int)e.size : 8192, false);
              this.e = e;
              if (e.mtime == -1)
                  e.mtime = System.currentTimeMillis();
              if (e.method == -1)
<span class="line-modified">!                 e.method = defaultMethod;</span>
              // store size, compressed size, and crc-32 in datadescriptor
              e.flag = FLAG_DATADESCR;
              if (zc.isUTF8())
                  e.flag |= FLAG_USE_UTF8;
          }
  
          @Override
          public void close() throws IOException {
<span class="line-modified">!             e.bytes = toByteArray();</span>
<span class="line-modified">!             e.size = e.bytes.length;</span>
<span class="line-modified">!             e.crc = -1;</span>
              super.close();
<span class="line-removed">-             update(e);</span>
          }
      }
  
<span class="line-modified">!     private int getCompressMethod(FileAttribute&lt;?&gt;... attrs) {</span>
<span class="line-removed">-          return defaultMethod;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Returns a Writable/ReadByteChannel for now. Might consdier to use</span>
      // newFileChannel() instead, which dump the entry data into a regular
<span class="line-modified">!     // file on the default file system and create a FileChannel on top of</span>
<span class="line-removed">-     // it.</span>
      SeekableByteChannel newByteChannel(byte[] path,
                                         Set&lt;? extends OpenOption&gt; options,
                                         FileAttribute&lt;?&gt;... attrs)
          throws IOException
      {
          checkOptions(options);
          if (options.contains(StandardOpenOption.WRITE) ||
              options.contains(StandardOpenOption.APPEND)) {
              checkWritable();
<span class="line-modified">!             beginRead();    // only need a readlock, the &quot;update()&quot; will obtain</span>
<span class="line-modified">!                             // thewritelock when the channel is closed</span>
              try {
<span class="line-removed">-                 ensureOpen();</span>
                  Entry e = getEntry(path);
                  if (e != null) {
                      if (e.isDir() || options.contains(CREATE_NEW))
                          throw new FileAlreadyExistsException(getString(path));
                      SeekableByteChannel sbc =
<span class="line-modified">!                             new EntryOutputChannel(new Entry(e, Entry.NEW));</span>
                      if (options.contains(APPEND)) {
                          try (InputStream is = getInputStream(e)) {  // copyover
                              byte[] buf = new byte[8192];
                              ByteBuffer bb = ByteBuffer.wrap(buf);
                              int n;
<span class="line-new-header">--- 867,64 ---</span>
          }
          if (options.contains(APPEND) &amp;&amp; options.contains(TRUNCATE_EXISTING))
              throw new IllegalArgumentException(&quot;APPEND + TRUNCATE_EXISTING not allowed&quot;);
      }
  
      // Returns an output SeekableByteChannel for either
<span class="line-modified">!     // (1) writing the contents of a new entry, if the entry doesn&#39;t exist, or</span>
      // (2) updating/replacing the contents of an existing entry.
<span class="line-modified">!     // Note: The content of the channel is not compressed until the</span>
<span class="line-added">+     // channel is closed</span>
      private class EntryOutputChannel extends ByteArrayChannel {
<span class="line-modified">!         final Entry e;</span>
  
<span class="line-modified">!         EntryOutputChannel(Entry e) {</span>
              super(e.size &gt; 0? (int)e.size : 8192, false);
              this.e = e;
              if (e.mtime == -1)
                  e.mtime = System.currentTimeMillis();
              if (e.method == -1)
<span class="line-modified">!                 e.method = defaultCompressionMethod;</span>
              // store size, compressed size, and crc-32 in datadescriptor
              e.flag = FLAG_DATADESCR;
              if (zc.isUTF8())
                  e.flag |= FLAG_USE_UTF8;
          }
  
          @Override
          public void close() throws IOException {
<span class="line-modified">!             // will update the entry</span>
<span class="line-modified">!             try (OutputStream os = getOutputStream(e)) {</span>
<span class="line-modified">!                 os.write(toByteArray());</span>
<span class="line-added">+             }</span>
              super.close();
          }
      }
  
<span class="line-modified">!     // Returns a Writable/ReadByteChannel for now. Might consider to use</span>
      // newFileChannel() instead, which dump the entry data into a regular
<span class="line-modified">!     // file on the default file system and create a FileChannel on top of it.</span>
      SeekableByteChannel newByteChannel(byte[] path,
                                         Set&lt;? extends OpenOption&gt; options,
                                         FileAttribute&lt;?&gt;... attrs)
          throws IOException
      {
          checkOptions(options);
          if (options.contains(StandardOpenOption.WRITE) ||
              options.contains(StandardOpenOption.APPEND)) {
              checkWritable();
<span class="line-modified">!             beginRead();    // only need a read lock, the &quot;update()&quot; will obtain</span>
<span class="line-modified">!                             // the write lock when the channel is closed</span>
              try {
                  Entry e = getEntry(path);
                  if (e != null) {
                      if (e.isDir() || options.contains(CREATE_NEW))
                          throw new FileAlreadyExistsException(getString(path));
                      SeekableByteChannel sbc =
<span class="line-modified">!                             new EntryOutputChannel(supportPosix ?</span>
<span class="line-added">+                                 new PosixEntry((PosixEntry)e, Entry.NEW) :</span>
<span class="line-added">+                                 new Entry(e, Entry.NEW));</span>
                      if (options.contains(APPEND)) {
                          try (InputStream is = getInputStream(e)) {  // copyover
                              byte[] buf = new byte[8192];
                              ByteBuffer bb = ByteBuffer.wrap(buf);
                              int n;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 673,12 ***</span>
                  }
                  if (!options.contains(CREATE) &amp;&amp; !options.contains(CREATE_NEW))
                      throw new NoSuchFileException(getString(path));
                  checkParents(path);
                  return new EntryOutputChannel(
<span class="line-modified">!                     new Entry(path, Entry.NEW, false, getCompressMethod(attrs)));</span>
<span class="line-modified">! </span>
              } finally {
                  endRead();
              }
          } else {
              beginRead();
<span class="line-new-header">--- 939,13 ---</span>
                  }
                  if (!options.contains(CREATE) &amp;&amp; !options.contains(CREATE_NEW))
                      throw new NoSuchFileException(getString(path));
                  checkParents(path);
                  return new EntryOutputChannel(
<span class="line-modified">!                     supportPosix ?</span>
<span class="line-modified">!                         new PosixEntry(path, Entry.NEW, false, defaultCompressionMethod, attrs) :</span>
<span class="line-added">+                         new Entry(path, Entry.NEW, false, defaultCompressionMethod, attrs));</span>
              } finally {
                  endRead();
              }
          } else {
              beginRead();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 738,14 ***</span>
              final boolean isFCH = (e != null &amp;&amp; e.type == Entry.FILECH);
              final Path tmpfile = isFCH ? e.file : getTempPathForEntry(path);
              final FileChannel fch = tmpfile.getFileSystem()
                                             .provider()
                                             .newFileChannel(tmpfile, options, attrs);
<span class="line-modified">!             final Entry u = isFCH ? e : new Entry(path, tmpfile, Entry.FILECH);</span>
              if (forWrite) {
                  u.flag = FLAG_DATADESCR;
<span class="line-modified">!                 u.method = getCompressMethod(attrs);</span>
              }
              // is there a better way to hook into the FileChannel&#39;s close method?
              return new FileChannel() {
                  public int write(ByteBuffer src) throws IOException {
                      return fch.write(src);
<span class="line-new-header">--- 1005,17 ---</span>
              final boolean isFCH = (e != null &amp;&amp; e.type == Entry.FILECH);
              final Path tmpfile = isFCH ? e.file : getTempPathForEntry(path);
              final FileChannel fch = tmpfile.getFileSystem()
                                             .provider()
                                             .newFileChannel(tmpfile, options, attrs);
<span class="line-modified">!             final Entry u = isFCH ? e : (</span>
<span class="line-added">+                 supportPosix ?</span>
<span class="line-added">+                 new PosixEntry(path, tmpfile, Entry.FILECH, attrs) :</span>
<span class="line-added">+                 new Entry(path, tmpfile, Entry.FILECH, attrs));</span>
              if (forWrite) {
                  u.flag = FLAG_DATADESCR;
<span class="line-modified">!                 u.method = defaultCompressionMethod;</span>
              }
              // is there a better way to hook into the FileChannel&#39;s close method?
              return new FileChannel() {
                  public int write(ByteBuffer src) throws IOException {
                      return fch.write(src);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 808,11 ***</span>
                      {
                     return fch.write(src, position);
                  }
                  public MappedByteBuffer map(MapMode mode,
                                              long position, long size)
<span class="line-removed">-                     throws IOException</span>
                  {
                      throw new UnsupportedOperationException();
                  }
                  public FileLock lock(long position, long size, boolean shared)
                      throws IOException
<span class="line-new-header">--- 1078,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 827,11 ***</span>
                  protected void implCloseChannel() throws IOException {
                      fch.close();
                      if (forWrite) {
                          u.mtime = System.currentTimeMillis();
                          u.size = Files.size(u.file);
<span class="line-removed">- </span>
                          update(u);
                      } else {
                          if (!isFCH)    // if this is a new fch for reading
                              removeTempPathForEntry(tmpfile);
                      }
<span class="line-new-header">--- 1096,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 842,13 ***</span>
          }
      }
  
      // the outstanding input streams that need to be closed
      private Set&lt;InputStream&gt; streams =
<span class="line-modified">!         Collections.synchronizedSet(new HashSet&lt;InputStream&gt;());</span>
  
<span class="line-modified">!     private Set&lt;Path&gt; tmppaths = Collections.synchronizedSet(new HashSet&lt;Path&gt;());</span>
      private Path getTempPathForEntry(byte[] path) throws IOException {
          Path tmpPath = createTempFileInSameDirectoryAs(zfpath);
          if (path != null) {
              Entry e = getEntry(path);
              if (e != null) {
<span class="line-new-header">--- 1110,17 ---</span>
          }
      }
  
      // the outstanding input streams that need to be closed
      private Set&lt;InputStream&gt; streams =
<span class="line-modified">!         Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
<span class="line-added">+ </span>
<span class="line-added">+     // the ex-channel and ex-path that need to close when their outstanding</span>
<span class="line-added">+     // input streams are all closed by the obtainers.</span>
<span class="line-added">+     private final Set&lt;ExistingChannelCloser&gt; exChClosers = new HashSet&lt;&gt;();</span>
  
<span class="line-modified">!     private final Set&lt;Path&gt; tmppaths = Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
      private Path getTempPathForEntry(byte[] path) throws IOException {
          Path tmpPath = createTempFileInSameDirectoryAs(zfpath);
          if (path != null) {
              Entry e = getEntry(path);
              if (e != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 863,11 ***</span>
      private void removeTempPathForEntry(Path path) throws IOException {
          Files.delete(path);
          tmppaths.remove(path);
      }
  
<span class="line-modified">!     // check if all parents really exit. ZIP spec does not require</span>
      // the existence of any &quot;parent directory&quot;.
      private void checkParents(byte[] path) throws IOException {
          beginRead();
          try {
              while ((path = getParent(path)) != null &amp;&amp;
<span class="line-new-header">--- 1135,11 ---</span>
      private void removeTempPathForEntry(Path path) throws IOException {
          Files.delete(path);
          tmppaths.remove(path);
      }
  
<span class="line-modified">!     // check if all parents really exist. ZIP spec does not require</span>
      // the existence of any &quot;parent directory&quot;.
      private void checkParents(byte[] path) throws IOException {
          beginRead();
          try {
              while ((path = getParent(path)) != null &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 879,11 ***</span>
          } finally {
              endRead();
          }
      }
  
<span class="line-removed">-     private static byte[] ROOTPATH = new byte[] { &#39;/&#39; };</span>
      private static byte[] getParent(byte[] path) {
          int off = getParentOff(path);
          if (off &lt;= 1)
              return ROOTPATH;
          return Arrays.copyOf(path, off);
<span class="line-new-header">--- 1151,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 895,23 ***</span>
              off--;
          while (off &gt; 0 &amp;&amp; path[off] != &#39;/&#39;) { off--; }
          return off;
      }
  
<span class="line-modified">!     private final void beginWrite() {</span>
          rwlock.writeLock().lock();
      }
  
<span class="line-modified">!     private final void endWrite() {</span>
          rwlock.writeLock().unlock();
      }
  
<span class="line-modified">!     private final void beginRead() {</span>
          rwlock.readLock().lock();
      }
  
<span class="line-modified">!     private final void endRead() {</span>
          rwlock.readLock().unlock();
      }
  
      ///////////////////////////////////////////////////////////////////
  
<span class="line-new-header">--- 1166,23 ---</span>
              off--;
          while (off &gt; 0 &amp;&amp; path[off] != &#39;/&#39;) { off--; }
          return off;
      }
  
<span class="line-modified">!     private void beginWrite() {</span>
          rwlock.writeLock().lock();
      }
  
<span class="line-modified">!     private void endWrite() {</span>
          rwlock.writeLock().unlock();
      }
  
<span class="line-modified">!     private void beginRead() {</span>
          rwlock.readLock().lock();
      }
  
<span class="line-modified">!     private void endRead() {</span>
          rwlock.readLock().unlock();
      }
  
      ///////////////////////////////////////////////////////////////////
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 949,56 ***</span>
          bb.position(off);
          bb.limit((int)(off + len));
          return readFullyAt(bb, pos);
      }
  
<span class="line-modified">!     private final long readFullyAt(ByteBuffer bb, long pos)</span>
<span class="line-removed">-         throws IOException</span>
<span class="line-removed">-     {</span>
          synchronized(ch) {
              return ch.position(pos).read(bb);
          }
      }
  
      // Searches for end of central directory (END) header. The contents of
      // the END header will be read and placed in endbuf. Returns the file
      // position of the END header, otherwise returns -1 if the END header
      // was not found or an error occurred.
<span class="line-modified">!     private END findEND() throws IOException</span>
<span class="line-removed">-     {</span>
          byte[] buf = new byte[READBLOCKSZ];
          long ziplen = ch.size();
          long minHDR = (ziplen - END_MAXLEN) &gt; 0 ? ziplen - END_MAXLEN : 0;
          long minPos = minHDR - (buf.length - ENDHDR);
  
<span class="line-modified">!         for (long pos = ziplen - buf.length; pos &gt;= minPos; pos -= (buf.length - ENDHDR))</span>
<span class="line-removed">-         {</span>
              int off = 0;
              if (pos &lt; 0) {
                  // Pretend there are some NUL bytes before start of file
                  off = (int)-pos;
                  Arrays.fill(buf, 0, off, (byte)0);
              }
              int len = buf.length - off;
              if (readFullyAt(buf, off, len, pos + off) != len)
<span class="line-modified">!                 zerror(&quot;zip END header not found&quot;);</span>
  
              // Now scan the block backwards for END header signature
              for (int i = buf.length - ENDHDR; i &gt;= 0; i--) {
<span class="line-modified">!                 if (buf[i+0] == (byte)&#39;P&#39;    &amp;&amp;</span>
                      buf[i+1] == (byte)&#39;K&#39;    &amp;&amp;
                      buf[i+2] == (byte)&#39;\005&#39; &amp;&amp;
                      buf[i+3] == (byte)&#39;\006&#39; &amp;&amp;
                      (pos + i + ENDHDR + ENDCOM(buf, i) == ziplen)) {
                      // Found END header
                      buf = Arrays.copyOfRange(buf, i, i + ENDHDR);
                      END end = new END();
<span class="line-modified">!                     end.endsub = ENDSUB(buf);</span>
                      end.centot = ENDTOT(buf);
                      end.cenlen = ENDSIZ(buf);
                      end.cenoff = ENDOFF(buf);
<span class="line-modified">!                     end.comlen = ENDCOM(buf);</span>
                      end.endpos = pos + i;
                      // try if there is zip64 end;
                      byte[] loc64 = new byte[ZIP64_LOCHDR];
                      if (end.endpos &lt; ZIP64_LOCHDR ||
                          readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)
<span class="line-new-header">--- 1220,52 ---</span>
          bb.position(off);
          bb.limit((int)(off + len));
          return readFullyAt(bb, pos);
      }
  
<span class="line-modified">!     private long readFullyAt(ByteBuffer bb, long pos) throws IOException {</span>
          synchronized(ch) {
              return ch.position(pos).read(bb);
          }
      }
  
      // Searches for end of central directory (END) header. The contents of
      // the END header will be read and placed in endbuf. Returns the file
      // position of the END header, otherwise returns -1 if the END header
      // was not found or an error occurred.
<span class="line-modified">!     private END findEND() throws IOException {</span>
          byte[] buf = new byte[READBLOCKSZ];
          long ziplen = ch.size();
          long minHDR = (ziplen - END_MAXLEN) &gt; 0 ? ziplen - END_MAXLEN : 0;
          long minPos = minHDR - (buf.length - ENDHDR);
  
<span class="line-modified">!         for (long pos = ziplen - buf.length; pos &gt;= minPos; pos -= (buf.length - ENDHDR)) {</span>
              int off = 0;
              if (pos &lt; 0) {
                  // Pretend there are some NUL bytes before start of file
                  off = (int)-pos;
                  Arrays.fill(buf, 0, off, (byte)0);
              }
              int len = buf.length - off;
              if (readFullyAt(buf, off, len, pos + off) != len)
<span class="line-modified">!                 throw new ZipException(&quot;zip END header not found&quot;);</span>
  
              // Now scan the block backwards for END header signature
              for (int i = buf.length - ENDHDR; i &gt;= 0; i--) {
<span class="line-modified">!                 if (buf[i]   == (byte)&#39;P&#39;    &amp;&amp;</span>
                      buf[i+1] == (byte)&#39;K&#39;    &amp;&amp;
                      buf[i+2] == (byte)&#39;\005&#39; &amp;&amp;
                      buf[i+3] == (byte)&#39;\006&#39; &amp;&amp;
                      (pos + i + ENDHDR + ENDCOM(buf, i) == ziplen)) {
                      // Found END header
                      buf = Arrays.copyOfRange(buf, i, i + ENDHDR);
                      END end = new END();
<span class="line-modified">!                     // end.endsub = ENDSUB(buf); // not used</span>
                      end.centot = ENDTOT(buf);
                      end.cenlen = ENDSIZ(buf);
                      end.cenoff = ENDOFF(buf);
<span class="line-modified">!                     // end.comlen = ENDCOM(buf); // not used</span>
                      end.endpos = pos + i;
                      // try if there is zip64 end;
                      byte[] loc64 = new byte[ZIP64_LOCHDR];
                      if (end.endpos &lt; ZIP64_LOCHDR ||
                          readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1030,12 ***</span>
                      end.endpos = end64pos;
                      return end;
                  }
              }
          }
<span class="line-modified">!         zerror(&quot;zip END header not found&quot;);</span>
<span class="line-modified">!         return null; //make compiler happy</span>
      }
  
      // Reads zip file central directory. Returns the file position of first
      // CEN header, otherwise returns -1 if an error occurred. If zip-&gt;msg != NULL
      // then the error was a zip format error and zip-&gt;msg has the error text.
<span class="line-new-header">--- 1297,217 ---</span>
                      end.endpos = end64pos;
                      return end;
                  }
              }
          }
<span class="line-modified">!         throw new ZipException(&quot;zip END header not found&quot;);</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private void makeParentDirs(IndexNode node, IndexNode root) {</span>
<span class="line-added">+         IndexNode parent;</span>
<span class="line-added">+         ParentLookup lookup = new ParentLookup();</span>
<span class="line-added">+         while (true) {</span>
<span class="line-added">+             int off = getParentOff(node.name);</span>
<span class="line-added">+             // parent is root</span>
<span class="line-added">+             if (off &lt;= 1) {</span>
<span class="line-added">+                 node.sibling = root.child;</span>
<span class="line-added">+                 root.child = node;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // parent exists</span>
<span class="line-added">+             lookup = lookup.as(node.name, off);</span>
<span class="line-added">+             if (inodes.containsKey(lookup)) {</span>
<span class="line-added">+                 parent = inodes.get(lookup);</span>
<span class="line-added">+                 node.sibling = parent.child;</span>
<span class="line-added">+                 parent.child = node;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // parent does not exist, add new pseudo directory entry</span>
<span class="line-added">+             parent = new IndexNode(Arrays.copyOf(node.name, off), true);</span>
<span class="line-added">+             inodes.put(parent, parent);</span>
<span class="line-added">+             node.sibling = parent.child;</span>
<span class="line-added">+             parent.child = node;</span>
<span class="line-added">+             node = parent;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // ZIP directory has two issues:</span>
<span class="line-added">+     // (1) ZIP spec does not require the ZIP file to include</span>
<span class="line-added">+     //     directory entry</span>
<span class="line-added">+     // (2) all entries are not stored/organized in a &quot;tree&quot;</span>
<span class="line-added">+     //     structure.</span>
<span class="line-added">+     // A possible solution is to build the node tree ourself as</span>
<span class="line-added">+     // implemented below.</span>
<span class="line-added">+     private void buildNodeTree() {</span>
<span class="line-added">+         beginWrite();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             IndexNode root = inodes.remove(LOOKUPKEY.as(ROOTPATH));</span>
<span class="line-added">+             if (root == null) {</span>
<span class="line-added">+                 root = new IndexNode(ROOTPATH, true);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             IndexNode[] nodes = inodes.values().toArray(new IndexNode[0]);</span>
<span class="line-added">+             inodes.put(root, root);</span>
<span class="line-added">+             for (IndexNode node : nodes) {</span>
<span class="line-added">+                 makeParentDirs(node, root);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             endWrite();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private void removeFromTree(IndexNode inode) {</span>
<span class="line-added">+         IndexNode parent = inodes.get(LOOKUPKEY.as(getParent(inode.name)));</span>
<span class="line-added">+         IndexNode child = parent.child;</span>
<span class="line-added">+         if (child.equals(inode)) {</span>
<span class="line-added">+             parent.child = child.sibling;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             IndexNode last = child;</span>
<span class="line-added">+             while ((child = child.sibling) != null) {</span>
<span class="line-added">+                 if (child.equals(inode)) {</span>
<span class="line-added">+                     last.sibling = child.sibling;</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     last = child;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * If a version property has been specified and the file represents a multi-release JAR,</span>
<span class="line-added">+      * determine the requested runtime version and initialize the ZipFileSystem instance accordingly.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Checks if the Zip File System property &quot;releaseVersion&quot; has been specified. If it has,</span>
<span class="line-added">+      * use its value to determine the requested version. If not use the value of the &quot;multi-release&quot; property.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void initializeReleaseVersion(Map&lt;String, ?&gt; env) throws IOException {</span>
<span class="line-added">+         Object o = env.containsKey(PROPERTY_RELEASE_VERSION) ?</span>
<span class="line-added">+             env.get(PROPERTY_RELEASE_VERSION) :</span>
<span class="line-added">+             env.get(PROPERTY_MULTI_RELEASE);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (o != null &amp;&amp; isMultiReleaseJar()) {</span>
<span class="line-added">+             int version;</span>
<span class="line-added">+             if (o instanceof String) {</span>
<span class="line-added">+                 String s = (String)o;</span>
<span class="line-added">+                 if (s.equals(&quot;runtime&quot;)) {</span>
<span class="line-added">+                     version = Runtime.version().feature();</span>
<span class="line-added">+                 } else if (s.matches(&quot;^[1-9][0-9]*$&quot;)) {</span>
<span class="line-added">+                     version = Version.parse(s).feature();</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     throw new IllegalArgumentException(&quot;Invalid runtime version&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else if (o instanceof Integer) {</span>
<span class="line-added">+                 version = Version.parse(((Integer)o).toString()).feature();</span>
<span class="line-added">+             } else if (o instanceof Version) {</span>
<span class="line-added">+                 version = ((Version)o).feature();</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 throw new IllegalArgumentException(&quot;env parameter must be String, &quot; +</span>
<span class="line-added">+                     &quot;Integer, or Version&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             createVersionedLinks(version &lt; 0 ? 0 : version);</span>
<span class="line-added">+             setReadOnly();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns true if the Manifest main attribute &quot;Multi-Release&quot; is set to true; false otherwise.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private boolean isMultiReleaseJar() throws IOException {</span>
<span class="line-added">+         try (InputStream is = newInputStream(getBytes(&quot;/META-INF/MANIFEST.MF&quot;))) {</span>
<span class="line-added">+             String multiRelease = new Manifest(is).getMainAttributes()</span>
<span class="line-added">+                 .getValue(Attributes.Name.MULTI_RELEASE);</span>
<span class="line-added">+             return &quot;true&quot;.equalsIgnoreCase(multiRelease);</span>
<span class="line-added">+         } catch (NoSuchFileException x) {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Create a map of aliases for versioned entries, for example:</span>
<span class="line-added">+      *   version/PackagePrivate.class -&gt; META-INF/versions/9/version/PackagePrivate.class</span>
<span class="line-added">+      *   version/PackagePrivate.java -&gt; META-INF/versions/9/version/PackagePrivate.java</span>
<span class="line-added">+      *   version/Version.class -&gt; META-INF/versions/10/version/Version.class</span>
<span class="line-added">+      *   version/Version.java -&gt; META-INF/versions/10/version/Version.java</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Then wrap the map in a function that getEntry can use to override root</span>
<span class="line-added">+      * entry lookup for entries that have corresponding versioned entries.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void createVersionedLinks(int version) {</span>
<span class="line-added">+         IndexNode verdir = getInode(getBytes(&quot;/META-INF/versions&quot;));</span>
<span class="line-added">+         // nothing to do, if no /META-INF/versions</span>
<span class="line-added">+         if (verdir == null) {</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // otherwise, create a map and for each META-INF/versions/{n} directory</span>
<span class="line-added">+         // put all the leaf inodes, i.e. entries, into the alias map</span>
<span class="line-added">+         // possibly shadowing lower versioned entries</span>
<span class="line-added">+         HashMap&lt;IndexNode, byte[]&gt; aliasMap = new HashMap&lt;&gt;();</span>
<span class="line-added">+         getVersionMap(version, verdir).values().forEach(versionNode -&gt;</span>
<span class="line-added">+             walk(versionNode.child, entryNode -&gt;</span>
<span class="line-added">+                 aliasMap.put(</span>
<span class="line-added">+                     getOrCreateInode(getRootName(entryNode, versionNode), entryNode.isdir),</span>
<span class="line-added">+                     entryNode.name))</span>
<span class="line-added">+         );</span>
<span class="line-added">+         entryLookup = path -&gt; {</span>
<span class="line-added">+             byte[] entry = aliasMap.get(IndexNode.keyOf(path));</span>
<span class="line-added">+             return entry == null ? path : entry;</span>
<span class="line-added">+         };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Create a sorted version map of version -&gt; inode, for inodes &lt;= max version.</span>
<span class="line-added">+      *   9 -&gt; META-INF/versions/9</span>
<span class="line-added">+      *  10 -&gt; META-INF/versions/10</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private TreeMap&lt;Integer, IndexNode&gt; getVersionMap(int version, IndexNode metaInfVersions) {</span>
<span class="line-added">+         TreeMap&lt;Integer,IndexNode&gt; map = new TreeMap&lt;&gt;();</span>
<span class="line-added">+         IndexNode child = metaInfVersions.child;</span>
<span class="line-added">+         while (child != null) {</span>
<span class="line-added">+             Integer key = getVersion(child, metaInfVersions);</span>
<span class="line-added">+             if (key != null &amp;&amp; key &lt;= version) {</span>
<span class="line-added">+                 map.put(key, child);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             child = child.sibling;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return map;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Extract the integer version number -- META-INF/versions/9 returns 9.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private Integer getVersion(IndexNode inode, IndexNode metaInfVersions) {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             byte[] fullName = inode.name;</span>
<span class="line-added">+             return Integer.parseInt(getString(Arrays</span>
<span class="line-added">+                 .copyOfRange(fullName, metaInfVersions.name.length + 1, fullName.length)));</span>
<span class="line-added">+         } catch (NumberFormatException x) {</span>
<span class="line-added">+             // ignore this even though it might indicate issues with the JAR structure</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Walk the IndexNode tree processing all leaf nodes.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void walk(IndexNode inode, Consumer&lt;IndexNode&gt; consumer) {</span>
<span class="line-added">+         if (inode == null) return;</span>
<span class="line-added">+         if (inode.isDir()) {</span>
<span class="line-added">+             walk(inode.child, consumer);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             consumer.accept(inode);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         walk(inode.sibling, consumer);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Extract the root name from a versioned entry name.</span>
<span class="line-added">+      * E.g. given inode &#39;META-INF/versions/9/foo/bar.class&#39;</span>
<span class="line-added">+      * and prefix &#39;META-INF/versions/9/&#39; returns &#39;foo/bar.class&#39;.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private byte[] getRootName(IndexNode inode, IndexNode prefix) {</span>
<span class="line-added">+         byte[] fullName = inode.name;</span>
<span class="line-added">+         return Arrays.copyOfRange(fullName, prefix.name.length, fullName.length);</span>
      }
  
      // Reads zip file central directory. Returns the file position of first
      // CEN header, otherwise returns -1 if an error occurred. If zip-&gt;msg != NULL
      // then the error was a zip format error and zip-&gt;msg has the error text.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1047,67 ***</span>
              locpos = 0;
              buildNodeTree();
              return null;         // only END header present
          }
          if (end.cenlen &gt; end.endpos)
<span class="line-modified">!             zerror(&quot;invalid END header (bad central directory size)&quot;);</span>
          long cenpos = end.endpos - end.cenlen;     // position of CEN table
  
          // Get position of first local file (LOC) header, taking into
          // account that there may be a stub prefixed to the zip file.
          locpos = cenpos - end.cenoff;
          if (locpos &lt; 0)
<span class="line-modified">!             zerror(&quot;invalid END header (bad central directory offset)&quot;);</span>
  
          // read in the CEN and END
          byte[] cen = new byte[(int)(end.cenlen + ENDHDR)];
          if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
<span class="line-modified">!             zerror(&quot;read CEN tables failed&quot;);</span>
          }
          // Iterate through the entries in the central directory
          inodes = new LinkedHashMap&lt;&gt;(end.centot + 1);
          int pos = 0;
          int limit = cen.length - ENDHDR;
          while (pos &lt; limit) {
              if (!cenSigAt(cen, pos))
<span class="line-modified">!                 zerror(&quot;invalid CEN header (bad signature)&quot;);</span>
              int method = CENHOW(cen, pos);
              int nlen   = CENNAM(cen, pos);
              int elen   = CENEXT(cen, pos);
              int clen   = CENCOM(cen, pos);
              if ((CENFLG(cen, pos) &amp; 1) != 0) {
<span class="line-modified">!                 zerror(&quot;invalid CEN header (encrypted entry)&quot;);</span>
              }
              if (method != METHOD_STORED &amp;&amp; method != METHOD_DEFLATED) {
<span class="line-modified">!                 zerror(&quot;invalid CEN header (unsupported compression method: &quot; + method + &quot;)&quot;);</span>
              }
              if (pos + CENHDR + nlen &gt; limit) {
<span class="line-modified">!                 zerror(&quot;invalid CEN header (bad header size)&quot;);</span>
              }
              IndexNode inode = new IndexNode(cen, pos, nlen);
              inodes.put(inode, inode);
  
              // skip ext and comment
              pos += (CENHDR + nlen + elen + clen);
          }
          if (pos + ENDHDR != cen.length) {
<span class="line-modified">!             zerror(&quot;invalid CEN header (bad header size)&quot;);</span>
          }
          buildNodeTree();
          return cen;
      }
  
<span class="line-modified">!     private void ensureOpen() throws IOException {</span>
          if (!isOpen)
              throw new ClosedFileSystemException();
      }
  
      // Creates a new empty temporary file in the same directory as the
      // specified file.  A variant of Files.createTempFile.
<span class="line-modified">!     private Path createTempFileInSameDirectoryAs(Path path)</span>
<span class="line-removed">-         throws IOException</span>
<span class="line-removed">-     {</span>
          Path parent = path.toAbsolutePath().getParent();
          Path dir = (parent == null) ? path.getFileSystem().getPath(&quot;.&quot;) : parent;
          Path tmpPath = Files.createTempFile(dir, &quot;zipfstmp&quot;, null);
          tmppaths.add(tmpPath);
          return tmpPath;
<span class="line-new-header">--- 1519,65 ---</span>
              locpos = 0;
              buildNodeTree();
              return null;         // only END header present
          }
          if (end.cenlen &gt; end.endpos)
<span class="line-modified">!             throw new ZipException(&quot;invalid END header (bad central directory size)&quot;);</span>
          long cenpos = end.endpos - end.cenlen;     // position of CEN table
  
          // Get position of first local file (LOC) header, taking into
          // account that there may be a stub prefixed to the zip file.
          locpos = cenpos - end.cenoff;
          if (locpos &lt; 0)
<span class="line-modified">!             throw new ZipException(&quot;invalid END header (bad central directory offset)&quot;);</span>
  
          // read in the CEN and END
          byte[] cen = new byte[(int)(end.cenlen + ENDHDR)];
          if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
<span class="line-modified">!             throw new ZipException(&quot;read CEN tables failed&quot;);</span>
          }
          // Iterate through the entries in the central directory
          inodes = new LinkedHashMap&lt;&gt;(end.centot + 1);
          int pos = 0;
          int limit = cen.length - ENDHDR;
          while (pos &lt; limit) {
              if (!cenSigAt(cen, pos))
<span class="line-modified">!                 throw new ZipException(&quot;invalid CEN header (bad signature)&quot;);</span>
              int method = CENHOW(cen, pos);
              int nlen   = CENNAM(cen, pos);
              int elen   = CENEXT(cen, pos);
              int clen   = CENCOM(cen, pos);
              if ((CENFLG(cen, pos) &amp; 1) != 0) {
<span class="line-modified">!                 throw new ZipException(&quot;invalid CEN header (encrypted entry)&quot;);</span>
              }
              if (method != METHOD_STORED &amp;&amp; method != METHOD_DEFLATED) {
<span class="line-modified">!                 throw new ZipException(&quot;invalid CEN header (unsupported compression method: &quot; + method + &quot;)&quot;);</span>
              }
              if (pos + CENHDR + nlen &gt; limit) {
<span class="line-modified">!                 throw new ZipException(&quot;invalid CEN header (bad header size)&quot;);</span>
              }
              IndexNode inode = new IndexNode(cen, pos, nlen);
              inodes.put(inode, inode);
  
              // skip ext and comment
              pos += (CENHDR + nlen + elen + clen);
          }
          if (pos + ENDHDR != cen.length) {
<span class="line-modified">!             throw new ZipException(&quot;invalid CEN header (bad header size)&quot;);</span>
          }
          buildNodeTree();
          return cen;
      }
  
<span class="line-modified">!     private void ensureOpen() {</span>
          if (!isOpen)
              throw new ClosedFileSystemException();
      }
  
      // Creates a new empty temporary file in the same directory as the
      // specified file.  A variant of Files.createTempFile.
<span class="line-modified">!     private Path createTempFileInSameDirectoryAs(Path path) throws IOException {</span>
          Path parent = path.toAbsolutePath().getParent();
          Path dir = (parent == null) ? path.getFileSystem().getPath(&quot;.&quot;) : parent;
          Path tmpPath = Files.createTempFile(dir, &quot;zipfstmp&quot;, null);
          tmppaths.add(tmpPath);
          return tmpPath;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1200,82 ***</span>
              locoff += n;
          }
          return written;
      }
  
<span class="line-modified">!     private long writeEntry(Entry e, OutputStream os, byte[] buf)</span>
          throws IOException {
  
          if (e.bytes == null &amp;&amp; e.file == null)    // dir, 0-length data
              return 0;
  
          long written = 0;
<span class="line-modified">!         try (OutputStream os2 = e.method == METHOD_STORED ?</span>
<span class="line-modified">!             new EntryOutputStreamCRC32(e, os) : new EntryOutputStreamDef(e, os)) {</span>
<span class="line-modified">!             if (e.bytes != null) {                 // in-memory</span>
<span class="line-modified">!                 os2.write(e.bytes, 0, e.bytes.length);</span>
<span class="line-modified">!             } else if (e.file != null) {           // tmp file</span>
<span class="line-modified">!                 if (e.type == Entry.NEW || e.type == Entry.FILECH) {</span>
<span class="line-modified">!                     try (InputStream is = Files.newInputStream(e.file)) {</span>
<span class="line-removed">-                         is.transferTo(os2);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 Files.delete(e.file);</span>
<span class="line-removed">-                 tmppaths.remove(e.file);</span>
              }
          }
          written += e.csize;
          if ((e.flag &amp; FLAG_DATADESCR) != 0) {
              written += e.writeEXT(os);
          }
          return written;
      }
  
<span class="line-modified">!     // sync the zip file system, if there is any udpate</span>
<span class="line-modified">!     private void sync() throws IOException {</span>
  
          if (!hasUpdate)
              return;
          Path tmpFile = createTempFileInSameDirectoryAs(zfpath);
<span class="line-modified">!         try (OutputStream os = new BufferedOutputStream(Files.newOutputStream(tmpFile, WRITE)))</span>
<span class="line-removed">-         {</span>
              ArrayList&lt;Entry&gt; elist = new ArrayList&lt;&gt;(inodes.size());
              long written = 0;
<span class="line-modified">!             byte[] buf = new byte[8192];</span>
<span class="line-modified">!             Entry e = null;</span>
  
              // write loc
              for (IndexNode inode : inodes.values()) {
                  if (inode instanceof Entry) {    // an updated inode
                      e = (Entry)inode;
                      try {
                          if (e.type == Entry.COPY) {
                              // entry copy: the only thing changed is the &quot;name&quot;
<span class="line-modified">!                             // and &quot;nlen&quot; in LOC header, so we udpate/rewrite the</span>
                              // LOC in new file and simply copy the rest (data and
                              // ext) without enflating/deflating from the old zip
                              // file LOC entry.
                              written += copyLOCEntry(e, true, os, written, buf);
                          } else {                          // NEW, FILECH or CEN
                              e.locoff = written;
                              written += e.writeLOC(os);    // write loc header
<span class="line-modified">!                             written += writeEntry(e, os, buf);</span>
                          }
                          elist.add(e);
                      } catch (IOException x) {
                          x.printStackTrace();    // skip any in-accurate entry
                      }
                  } else {                        // unchanged inode
                      if (inode.pos == -1) {
                          continue;               // pseudo directory node
                      }
                      if (inode.name.length == 1 &amp;&amp; inode.name[0] == &#39;/&#39;) {
<span class="line-modified">!                         continue;               // no root &#39;/&#39; directory even it</span>
<span class="line-modified">!                                                 // exits in original zip/jar file.</span>
                      }
<span class="line-modified">!                     e = Entry.readCEN(this, inode);</span>
                      try {
                          written += copyLOCEntry(e, false, os, written, buf);
                          elist.add(e);
                      } catch (IOException x) {
                          x.printStackTrace();    // skip any wrong entry
                      }
<span class="line-new-header">--- 1670,102 ---</span>
              locoff += n;
          }
          return written;
      }
  
<span class="line-modified">!     private long writeEntry(Entry e, OutputStream os)</span>
          throws IOException {
  
          if (e.bytes == null &amp;&amp; e.file == null)    // dir, 0-length data
              return 0;
  
          long written = 0;
<span class="line-modified">!         if (e.method != METHOD_STORED &amp;&amp; e.csize &gt; 0 &amp;&amp; (e.crc != 0 || e.size == 0)) {</span>
<span class="line-modified">!             // pre-compressed entry, write directly to output stream</span>
<span class="line-modified">!             writeTo(e, os);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             try (OutputStream os2 = (e.method == METHOD_STORED) ?</span>
<span class="line-modified">!                     new EntryOutputStreamCRC32(e, os) : new EntryOutputStreamDef(e, os)) {</span>
<span class="line-modified">!                 writeTo(e, os2);</span>
              }
          }
          written += e.csize;
          if ((e.flag &amp; FLAG_DATADESCR) != 0) {
              written += e.writeEXT(os);
          }
          return written;
      }
  
<span class="line-modified">!     private void writeTo(Entry e, OutputStream os) throws IOException {</span>
<span class="line-modified">!         if (e.bytes != null) {</span>
<span class="line-added">+             os.write(e.bytes, 0, e.bytes.length);</span>
<span class="line-added">+         } else if (e.file != null) {</span>
<span class="line-added">+             if (e.type == Entry.NEW || e.type == Entry.FILECH) {</span>
<span class="line-added">+                 try (InputStream is = Files.newInputStream(e.file)) {</span>
<span class="line-added">+                     is.transferTo(os);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             Files.delete(e.file);</span>
<span class="line-added">+             tmppaths.remove(e.file);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-added">+     // sync the zip file system, if there is any update</span>
<span class="line-added">+     private void sync() throws IOException {</span>
<span class="line-added">+         // check ex-closer</span>
<span class="line-added">+         if (!exChClosers.isEmpty()) {</span>
<span class="line-added">+             for (ExistingChannelCloser ecc : exChClosers) {</span>
<span class="line-added">+                 if (ecc.closeAndDeleteIfDone()) {</span>
<span class="line-added">+                     exChClosers.remove(ecc);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
          if (!hasUpdate)
              return;
<span class="line-added">+         PosixFileAttributes attrs = getPosixAttributes(zfpath);</span>
          Path tmpFile = createTempFileInSameDirectoryAs(zfpath);
<span class="line-modified">!         try (OutputStream os = new BufferedOutputStream(Files.newOutputStream(tmpFile, WRITE))) {</span>
              ArrayList&lt;Entry&gt; elist = new ArrayList&lt;&gt;(inodes.size());
              long written = 0;
<span class="line-modified">!             byte[] buf = null;</span>
<span class="line-modified">!             Entry e;</span>
  
              // write loc
              for (IndexNode inode : inodes.values()) {
                  if (inode instanceof Entry) {    // an updated inode
                      e = (Entry)inode;
                      try {
                          if (e.type == Entry.COPY) {
                              // entry copy: the only thing changed is the &quot;name&quot;
<span class="line-modified">!                             // and &quot;nlen&quot; in LOC header, so we update/rewrite the</span>
                              // LOC in new file and simply copy the rest (data and
                              // ext) without enflating/deflating from the old zip
                              // file LOC entry.
<span class="line-added">+                             if (buf == null)</span>
<span class="line-added">+                                 buf = new byte[8192];</span>
                              written += copyLOCEntry(e, true, os, written, buf);
                          } else {                          // NEW, FILECH or CEN
                              e.locoff = written;
                              written += e.writeLOC(os);    // write loc header
<span class="line-modified">!                             written += writeEntry(e, os);</span>
                          }
                          elist.add(e);
                      } catch (IOException x) {
                          x.printStackTrace();    // skip any in-accurate entry
                      }
                  } else {                        // unchanged inode
                      if (inode.pos == -1) {
                          continue;               // pseudo directory node
                      }
                      if (inode.name.length == 1 &amp;&amp; inode.name[0] == &#39;/&#39;) {
<span class="line-modified">!                         continue;               // no root &#39;/&#39; directory even if it</span>
<span class="line-modified">!                                                 // exists in original zip/jar file.</span>
                      }
<span class="line-modified">!                     e = supportPosix ? new PosixEntry(this, inode) : new Entry(this, inode);</span>
                      try {
<span class="line-added">+                         if (buf == null)</span>
<span class="line-added">+                             buf = new byte[8192];</span>
                          written += copyLOCEntry(e, false, os, written, buf);
                          elist.add(e);
                      } catch (IOException x) {
                          x.printStackTrace();    // skip any wrong entry
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1289,37 ***</span>
              }
              end.centot = elist.size();
              end.cenlen = written - end.cenoff;
              end.write(os, written, forceEnd64);
          }
  
<span class="line-modified">!         ch.close();</span>
<span class="line-modified">!         Files.delete(zfpath);</span>
          Files.move(tmpFile, zfpath, REPLACE_EXISTING);
          hasUpdate = false;    // clear
      }
  
<span class="line-modified">!     IndexNode getInode(byte[] path) {</span>
<span class="line-modified">!         if (path == null)</span>
<span class="line-modified">!             throw new NullPointerException(&quot;path&quot;);</span>
<span class="line-modified">!         return inodes.get(IndexNode.keyOf(path));</span>
      }
  
<span class="line-modified">!     Entry getEntry(byte[] path) throws IOException {</span>
          IndexNode inode = getInode(path);
          if (inode instanceof Entry)
              return (Entry)inode;
          if (inode == null || inode.pos == -1)
              return null;
<span class="line-modified">!         return Entry.readCEN(this, inode);</span>
      }
  
      public void deleteFile(byte[] path, boolean failIfNotExists)
          throws IOException
      {
          checkWritable();
<span class="line-removed">- </span>
          IndexNode inode = getInode(path);
          if (inode == null) {
              if (path != null &amp;&amp; path.length == 0)
                  throw new ZipException(&quot;root directory &lt;/&gt; can&#39;t not be delete&quot;);
              if (failIfNotExists)
<span class="line-new-header">--- 1779,98 ---</span>
              }
              end.centot = elist.size();
              end.cenlen = written - end.cenoff;
              end.write(os, written, forceEnd64);
          }
<span class="line-added">+         if (!streams.isEmpty()) {</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // There are outstanding input streams open on existing &quot;ch&quot;,</span>
<span class="line-added">+             // so, don&#39;t close the &quot;cha&quot; and delete the &quot;file for now, let</span>
<span class="line-added">+             // the &quot;ex-channel-closer&quot; to handle them</span>
<span class="line-added">+             Path path = createTempFileInSameDirectoryAs(zfpath);</span>
<span class="line-added">+             ExistingChannelCloser ecc = new ExistingChannelCloser(path,</span>
<span class="line-added">+                                                                   ch,</span>
<span class="line-added">+                                                                   streams);</span>
<span class="line-added">+             Files.move(zfpath, path, REPLACE_EXISTING);</span>
<span class="line-added">+             exChClosers.add(ecc);</span>
<span class="line-added">+             streams = Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             ch.close();</span>
<span class="line-added">+             Files.delete(zfpath);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         // Set the POSIX permissions of the original Zip File if available</span>
<span class="line-modified">!         // before moving the temp file</span>
<span class="line-added">+         if (attrs != null) {</span>
<span class="line-added">+             Files.setPosixFilePermissions(tmpFile, attrs.permissions());</span>
<span class="line-added">+         }</span>
          Files.move(tmpFile, zfpath, REPLACE_EXISTING);
          hasUpdate = false;    // clear
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Returns a file&#39;s POSIX file attributes.</span>
<span class="line-modified">!      * @param path The path to the file</span>
<span class="line-modified">!      * @return The POSIX file attributes for the specified file or</span>
<span class="line-added">+      *         null if the POSIX attribute view is not available</span>
<span class="line-added">+      * @throws IOException If an error occurs obtaining the POSIX attributes for</span>
<span class="line-added">+      *                    the specified file</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private PosixFileAttributes getPosixAttributes(Path path) throws IOException {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             PosixFileAttributeView view =</span>
<span class="line-added">+                     Files.getFileAttributeView(path, PosixFileAttributeView.class);</span>
<span class="line-added">+             // Return if the attribute view is not supported</span>
<span class="line-added">+             if (view == null) {</span>
<span class="line-added">+                 return null;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return view.readAttributes();</span>
<span class="line-added">+         } catch (UnsupportedOperationException e) {</span>
<span class="line-added">+             // PosixFileAttributes not available</span>
<span class="line-added">+             return null;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private IndexNode getInode(byte[] path) {</span>
<span class="line-added">+         return inodes.get(IndexNode.keyOf(Objects.requireNonNull(entryLookup.apply(path), &quot;path&quot;)));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Return the IndexNode from the root tree. If it doesn&#39;t exist,</span>
<span class="line-added">+      * it gets created along with all parent directory IndexNodes.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private IndexNode getOrCreateInode(byte[] path, boolean isdir) {</span>
<span class="line-added">+         IndexNode node = getInode(path);</span>
<span class="line-added">+         // if node exists, return it</span>
<span class="line-added">+         if (node != null) {</span>
<span class="line-added">+             return node;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // otherwise create new pseudo node and parent directory hierarchy</span>
<span class="line-added">+         node = new IndexNode(path, isdir);</span>
<span class="line-added">+         beginWrite();</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             makeParentDirs(node, Objects.requireNonNull(inodes.get(IndexNode.keyOf(ROOTPATH)), &quot;no root node found&quot;));</span>
<span class="line-added">+             return node;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             endWrite();</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     private Entry getEntry(byte[] path) throws IOException {</span>
          IndexNode inode = getInode(path);
          if (inode instanceof Entry)
              return (Entry)inode;
          if (inode == null || inode.pos == -1)
              return null;
<span class="line-modified">!         return supportPosix ? new PosixEntry(this, inode): new Entry(this, inode);</span>
      }
  
      public void deleteFile(byte[] path, boolean failIfNotExists)
          throws IOException
      {
          checkWritable();
          IndexNode inode = getInode(path);
          if (inode == null) {
              if (path != null &amp;&amp; path.length == 0)
                  throw new ZipException(&quot;root directory &lt;/&gt; can&#39;t not be delete&quot;);
              if (failIfNotExists)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1330,18 ***</span>
              updateDelete(inode);
          }
      }
  
      // Returns an out stream for either
<span class="line-modified">!     // (1) writing the contents of a new entry, if the entry exits, or</span>
      // (2) updating/replacing the contents of the specified existing entry.
      private OutputStream getOutputStream(Entry e) throws IOException {
<span class="line-removed">- </span>
          if (e.mtime == -1)
              e.mtime = System.currentTimeMillis();
          if (e.method == -1)
<span class="line-modified">!             e.method = defaultMethod;</span>
          // store size, compressed size, and crc-32 in datadescr
          e.flag = FLAG_DATADESCR;
          if (zc.isUTF8())
              e.flag |= FLAG_USE_UTF8;
          OutputStream os;
<span class="line-new-header">--- 1881,17 ---</span>
              updateDelete(inode);
          }
      }
  
      // Returns an out stream for either
<span class="line-modified">!     // (1) writing the contents of a new entry, if the entry exists, or</span>
      // (2) updating/replacing the contents of the specified existing entry.
      private OutputStream getOutputStream(Entry e) throws IOException {
          if (e.mtime == -1)
              e.mtime = System.currentTimeMillis();
          if (e.method == -1)
<span class="line-modified">!             e.method = defaultCompressionMethod;</span>
          // store size, compressed size, and crc-32 in datadescr
          e.flag = FLAG_DATADESCR;
          if (zc.isUTF8())
              e.flag |= FLAG_USE_UTF8;
          OutputStream os;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1349,19 ***</span>
              e.file = getTempPathForEntry(null);
              os = Files.newOutputStream(e.file, WRITE);
          } else {
              os = new ByteArrayOutputStream((e.size &gt; 0)? (int)e.size : 8192);
          }
<span class="line-modified">!         return new EntryOutputStream(e, os);</span>
      }
  
      private class EntryOutputStream extends FilterOutputStream {
<span class="line-modified">!         private Entry e;</span>
          private long written;
          private boolean isClosed;
  
<span class="line-modified">!         EntryOutputStream(Entry e, OutputStream os) throws IOException {</span>
              super(os);
              this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
              // this.written = 0;
          }
  
<span class="line-new-header">--- 1899,23 ---</span>
              e.file = getTempPathForEntry(null);
              os = Files.newOutputStream(e.file, WRITE);
          } else {
              os = new ByteArrayOutputStream((e.size &gt; 0)? (int)e.size : 8192);
          }
<span class="line-modified">!         if (e.method == METHOD_DEFLATED) {</span>
<span class="line-added">+             return new DeflatingEntryOutputStream(e, os);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             return new EntryOutputStream(e, os);</span>
<span class="line-added">+         }</span>
      }
  
      private class EntryOutputStream extends FilterOutputStream {
<span class="line-modified">!         private final Entry e;</span>
          private long written;
          private boolean isClosed;
  
<span class="line-modified">!         EntryOutputStream(Entry e, OutputStream os) {</span>
              super(os);
              this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
              // this.written = 0;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1370,11 ***</span>
              out.write(b);
              written += 1;
          }
  
          @Override
<span class="line-modified">!         public synchronized void write(byte b[], int off, int len)</span>
                  throws IOException {
              out.write(b, off, len);
              written += len;
          }
  
<span class="line-new-header">--- 1924,11 ---</span>
              out.write(b);
              written += 1;
          }
  
          @Override
<span class="line-modified">!         public synchronized void write(byte[] b, int off, int len)</span>
                  throws IOException {
              out.write(b, off, len);
              written += len;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1390,21 ***</span>
              super.close();
              update(e);
          }
      }
  
      // Wrapper output stream class to write out a &quot;stored&quot; entry.
      // (1) this class does not close the underlying out stream when
      //     being closed.
      // (2) no need to be &quot;synchronized&quot;, only used by sync()
      private class EntryOutputStreamCRC32 extends FilterOutputStream {
<span class="line-modified">!         private Entry e;</span>
<span class="line-modified">!         private CRC32 crc;</span>
          private long written;
          private boolean isClosed;
  
<span class="line-modified">!         EntryOutputStreamCRC32(Entry e, OutputStream os) throws IOException {</span>
              super(os);
              this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
              this.crc = new CRC32();
          }
  
<span class="line-new-header">--- 1944,58 ---</span>
              super.close();
              update(e);
          }
      }
  
<span class="line-added">+     // Output stream returned when writing &quot;deflated&quot; entries into memory,</span>
<span class="line-added">+     // to enable eager (possibly parallel) deflation and reduce memory required.</span>
<span class="line-added">+     private class DeflatingEntryOutputStream extends DeflaterOutputStream {</span>
<span class="line-added">+         private final CRC32 crc;</span>
<span class="line-added">+         private final Entry e;</span>
<span class="line-added">+         private boolean isClosed;</span>
<span class="line-added">+ </span>
<span class="line-added">+         DeflatingEntryOutputStream(Entry e, OutputStream os) {</span>
<span class="line-added">+             super(os, getDeflater());</span>
<span class="line-added">+             this.e = Objects.requireNonNull(e, &quot;Zip entry is null&quot;);</span>
<span class="line-added">+             this.crc = new CRC32();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public synchronized void write(byte[] b, int off, int len)</span>
<span class="line-added">+                 throws IOException {</span>
<span class="line-added">+             super.write(b, off, len);</span>
<span class="line-added">+             crc.update(b, off, len);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public synchronized void close() throws IOException {</span>
<span class="line-added">+             if (isClosed)</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             isClosed = true;</span>
<span class="line-added">+             finish();</span>
<span class="line-added">+             e.size  = def.getBytesRead();</span>
<span class="line-added">+             e.csize = def.getBytesWritten();</span>
<span class="line-added">+             e.crc = crc.getValue();</span>
<span class="line-added">+             if (out instanceof ByteArrayOutputStream)</span>
<span class="line-added">+                 e.bytes = ((ByteArrayOutputStream)out).toByteArray();</span>
<span class="line-added">+             super.close();</span>
<span class="line-added">+             update(e);</span>
<span class="line-added">+             releaseDeflater(def);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // Wrapper output stream class to write out a &quot;stored&quot; entry.
      // (1) this class does not close the underlying out stream when
      //     being closed.
      // (2) no need to be &quot;synchronized&quot;, only used by sync()
      private class EntryOutputStreamCRC32 extends FilterOutputStream {
<span class="line-modified">!         private final CRC32 crc;</span>
<span class="line-modified">!         private final Entry e;</span>
          private long written;
          private boolean isClosed;
  
<span class="line-modified">!         EntryOutputStreamCRC32(Entry e, OutputStream os) {</span>
              super(os);
              this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);
              this.crc = new CRC32();
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1414,19 ***</span>
              crc.update(b);
              written += 1;
          }
  
          @Override
<span class="line-modified">!         public void write(byte b[], int off, int len)</span>
                  throws IOException {
              out.write(b, off, len);
              crc.update(b, off, len);
              written += len;
          }
  
          @Override
<span class="line-modified">!         public void close() throws IOException {</span>
              if (isClosed)
                  return;
              isClosed = true;
              e.size = e.csize = written;
              e.crc = crc.getValue();
<span class="line-new-header">--- 2005,19 ---</span>
              crc.update(b);
              written += 1;
          }
  
          @Override
<span class="line-modified">!         public void write(byte[] b, int off, int len)</span>
                  throws IOException {
              out.write(b, off, len);
              crc.update(b, off, len);
              written += len;
          }
  
          @Override
<span class="line-modified">!         public void close() {</span>
              if (isClosed)
                  return;
              isClosed = true;
              e.size = e.csize = written;
              e.crc = crc.getValue();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1436,51 ***</span>
      // Wrapper output stream class to write out a &quot;deflated&quot; entry.
      // (1) this class does not close the underlying out stream when
      //     being closed.
      // (2) no need to be &quot;synchronized&quot;, only used by sync()
      private class EntryOutputStreamDef extends DeflaterOutputStream {
<span class="line-modified">!         private CRC32 crc;</span>
<span class="line-modified">!         private Entry e;</span>
          private boolean isClosed;
  
<span class="line-modified">!         EntryOutputStreamDef(Entry e, OutputStream os) throws IOException {</span>
              super(os, getDeflater());
<span class="line-modified">!             this.e =  Objects.requireNonNull(e, &quot;Zip entry is null&quot;);</span>
              this.crc = new CRC32();
          }
  
          @Override
<span class="line-modified">!         public void write(byte b[], int off, int len)</span>
<span class="line-removed">-                 throws IOException {</span>
              super.write(b, off, len);
              crc.update(b, off, len);
          }
  
          @Override
          public void close() throws IOException {
              if (isClosed)
                  return;
              isClosed = true;
              finish();
<span class="line-modified">!             e.size  = def.getBytesRead();</span>
              e.csize = def.getBytesWritten();
              e.crc = crc.getValue();
              releaseDeflater(def);
          }
      }
  
      private InputStream getInputStream(Entry e)
          throws IOException
      {
<span class="line-modified">!         InputStream eis = null;</span>
<span class="line-removed">- </span>
          if (e.type == Entry.NEW) {
<span class="line-removed">-             // now bytes &amp; file is uncompressed.</span>
              if (e.bytes != null)
<span class="line-modified">!                 return new ByteArrayInputStream(e.bytes);</span>
              else if (e.file != null)
<span class="line-modified">!                 return Files.newInputStream(e.file);</span>
              else
                  throw new ZipException(&quot;update entry data is missing&quot;);
          } else if (e.type == Entry.FILECH) {
              // FILECH result is un-compressed.
              eis = Files.newInputStream(e.file);
<span class="line-new-header">--- 2027,48 ---</span>
      // Wrapper output stream class to write out a &quot;deflated&quot; entry.
      // (1) this class does not close the underlying out stream when
      //     being closed.
      // (2) no need to be &quot;synchronized&quot;, only used by sync()
      private class EntryOutputStreamDef extends DeflaterOutputStream {
<span class="line-modified">!         private final CRC32 crc;</span>
<span class="line-modified">!         private final Entry e;</span>
          private boolean isClosed;
  
<span class="line-modified">!         EntryOutputStreamDef(Entry e, OutputStream os) {</span>
              super(os, getDeflater());
<span class="line-modified">!             this.e = Objects.requireNonNull(e, &quot;Zip entry is null&quot;);</span>
              this.crc = new CRC32();
          }
  
          @Override
<span class="line-modified">!         public void write(byte[] b, int off, int len) throws IOException {</span>
              super.write(b, off, len);
              crc.update(b, off, len);
          }
  
          @Override
          public void close() throws IOException {
              if (isClosed)
                  return;
              isClosed = true;
              finish();
<span class="line-modified">!             e.size = def.getBytesRead();</span>
              e.csize = def.getBytesWritten();
              e.crc = crc.getValue();
              releaseDeflater(def);
          }
      }
  
      private InputStream getInputStream(Entry e)
          throws IOException
      {
<span class="line-modified">!         InputStream eis;</span>
          if (e.type == Entry.NEW) {
              if (e.bytes != null)
<span class="line-modified">!                 eis = new ByteArrayInputStream(e.bytes);</span>
              else if (e.file != null)
<span class="line-modified">!                 eis = Files.newInputStream(e.file);</span>
              else
                  throw new ZipException(&quot;update entry data is missing&quot;);
          } else if (e.type == Entry.FILECH) {
              // FILECH result is un-compressed.
              eis = Files.newInputStream(e.file);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1523,11 ***</span>
                      }
                      inf.setInput(buf, 0, len);
                  }
                  private boolean eof;
  
<span class="line-modified">!                 public int available() throws IOException {</span>
                      if (isClosed)
                          return 0;
                      long avail = size - inf.getBytesWritten();
                      return avail &gt; (long) Integer.MAX_VALUE ?
                          Integer.MAX_VALUE : (int) avail;
<span class="line-new-header">--- 2111,11 ---</span>
                      }
                      inf.setInput(buf, 0, len);
                  }
                  private boolean eof;
  
<span class="line-modified">!                 public int available() {</span>
                      if (isClosed)
                          return 0;
                      long avail = size - inf.getBytesWritten();
                      return avail &gt; (long) Integer.MAX_VALUE ?
                          Integer.MAX_VALUE : (int) avail;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1544,31 ***</span>
  
      // Inner class implementing the input stream used to read
      // a (possibly compressed) zip file entry.
      private class EntryInputStream extends InputStream {
          private final SeekableByteChannel zfch; // local ref to zipfs&#39;s &quot;ch&quot;. zipfs.ch might
<span class="line-modified">!                                           // point to a new channel after sync()</span>
<span class="line-modified">!         private   long pos;               // current position within entry data</span>
<span class="line-modified">!         protected long rem;               // number of remaining bytes within entry</span>
  
          EntryInputStream(Entry e, SeekableByteChannel zfch)
              throws IOException
          {
              this.zfch = zfch;
              rem = e.csize;
              pos = e.locoff;
              if (pos == -1) {
                  Entry e2 = getEntry(e.name);
                  if (e2 == null) {
<span class="line-modified">!                     throw new ZipException(&quot;invalid loc for entry &lt;&quot; + e.name + &quot;&gt;&quot;);</span>
                  }
                  pos = e2.locoff;
              }
              pos = -pos;  // lazy initialize the real data offset
          }
  
<span class="line-modified">!         public int read(byte b[], int off, int len) throws IOException {</span>
              ensureOpen();
              initDataPos();
              if (rem == 0) {
                  return -1;
              }
<span class="line-new-header">--- 2132,31 ---</span>
  
      // Inner class implementing the input stream used to read
      // a (possibly compressed) zip file entry.
      private class EntryInputStream extends InputStream {
          private final SeekableByteChannel zfch; // local ref to zipfs&#39;s &quot;ch&quot;. zipfs.ch might
<span class="line-modified">!                                                 // point to a new channel after sync()</span>
<span class="line-modified">!         private long pos;                       // current position within entry data</span>
<span class="line-modified">!         private long rem;                       // number of remaining bytes within entry</span>
  
          EntryInputStream(Entry e, SeekableByteChannel zfch)
              throws IOException
          {
              this.zfch = zfch;
              rem = e.csize;
              pos = e.locoff;
              if (pos == -1) {
                  Entry e2 = getEntry(e.name);
                  if (e2 == null) {
<span class="line-modified">!                     throw new ZipException(&quot;invalid loc for entry &lt;&quot; + getString(e.name) + &quot;&gt;&quot;);</span>
                  }
                  pos = e2.locoff;
              }
              pos = -pos;  // lazy initialize the real data offset
          }
  
<span class="line-modified">!         public int read(byte[] b, int off, int len) throws IOException {</span>
              ensureOpen();
              initDataPos();
              if (rem == 0) {
                  return -1;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1577,11 ***</span>
              }
              if (len &gt; rem) {
                  len = (int) rem;
              }
              // readFullyAt()
<span class="line-modified">!             long n = 0;</span>
              ByteBuffer bb = ByteBuffer.wrap(b);
              bb.position(off);
              bb.limit(off + len);
              synchronized(zfch) {
                  n = zfch.position(pos).read(bb);
<span class="line-new-header">--- 2165,11 ---</span>
              }
              if (len &gt; rem) {
                  len = (int) rem;
              }
              // readFullyAt()
<span class="line-modified">!             long n;</span>
              ByteBuffer bb = ByteBuffer.wrap(b);
              bb.position(off);
              bb.limit(off + len);
              synchronized(zfch) {
                  n = zfch.position(pos).read(bb);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1603,11 ***</span>
              } else {
                  return -1;
              }
          }
  
<span class="line-modified">!         public long skip(long n) throws IOException {</span>
              ensureOpen();
              if (n &gt; rem)
                  n = rem;
              pos += n;
              rem -= n;
<span class="line-new-header">--- 2191,11 ---</span>
              } else {
                  return -1;
              }
          }
  
<span class="line-modified">!         public long skip(long n) {</span>
              ensureOpen();
              if (n &gt; rem)
                  n = rem;
              pos += n;
              rem -= n;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1636,14 ***</span>
                  pos += LOCHDR + LOCNAM(buf) + LOCEXT(buf);
              }
          }
      }
  
<span class="line-removed">-     static void zerror(String msg) throws ZipException {</span>
<span class="line-removed">-         throw new ZipException(msg);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      // Maxmum number of de/inflater we cache
      private final int MAX_FLATER = 20;
      // List of available Inflater objects for decompression
      private final List&lt;Inflater&gt; inflaters = new ArrayList&lt;&gt;();
  
<span class="line-new-header">--- 2224,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1651,12 ***</span>
      // a new one.
      private Inflater getInflater() {
          synchronized (inflaters) {
              int size = inflaters.size();
              if (size &gt; 0) {
<span class="line-modified">!                 Inflater inf = inflaters.remove(size - 1);</span>
<span class="line-removed">-                 return inf;</span>
              } else {
                  return new Inflater(true);
              }
          }
      }
<span class="line-new-header">--- 2235,11 ---</span>
      // a new one.
      private Inflater getInflater() {
          synchronized (inflaters) {
              int size = inflaters.size();
              if (size &gt; 0) {
<span class="line-modified">!                 return inflaters.remove(size - 1);</span>
              } else {
                  return new Inflater(true);
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1680,43 ***</span>
      // a new one.
      private Deflater getDeflater() {
          synchronized (deflaters) {
              int size = deflaters.size();
              if (size &gt; 0) {
<span class="line-modified">!                 Deflater def = deflaters.remove(size - 1);</span>
<span class="line-removed">-                 return def;</span>
              } else {
                  return new Deflater(Deflater.DEFAULT_COMPRESSION, true);
              }
          }
      }
  
      // Releases the specified inflater to the list of available inflaters.
      private void releaseDeflater(Deflater def) {
          synchronized (deflaters) {
<span class="line-modified">!             if (inflaters.size() &lt; MAX_FLATER) {</span>
                 def.reset();
                 deflaters.add(def);
              } else {
                 def.end();
              }
          }
      }
  
      // End of central directory record
      static class END {
<span class="line-modified">!         // these 2 fields are not used by anyone and write() uses &quot;0&quot;</span>
          // int  disknum;
          // int  sdisknum;
<span class="line-modified">!         int  endsub;     // endsub</span>
<span class="line-modified">!         int  centot;     // 4 bytes</span>
<span class="line-modified">!         long cenlen;     // 4 bytes</span>
<span class="line-modified">!         long cenoff;     // 4 bytes</span>
<span class="line-modified">!         int  comlen;     // comment length</span>
<span class="line-modified">!         byte[] comment;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /* members of Zip64 end of central directory locator */</span>
          // int diskNum;
          long endpos;
          // int disktot;
  
          void write(OutputStream os, long offset, boolean forceEnd64) throws IOException {
<span class="line-new-header">--- 2263,42 ---</span>
      // a new one.
      private Deflater getDeflater() {
          synchronized (deflaters) {
              int size = deflaters.size();
              if (size &gt; 0) {
<span class="line-modified">!                 return deflaters.remove(size - 1);</span>
              } else {
                  return new Deflater(Deflater.DEFAULT_COMPRESSION, true);
              }
          }
      }
  
      // Releases the specified inflater to the list of available inflaters.
      private void releaseDeflater(Deflater def) {
          synchronized (deflaters) {
<span class="line-modified">!             if (deflaters.size() &lt; MAX_FLATER) {</span>
                 def.reset();
                 deflaters.add(def);
              } else {
                 def.end();
              }
          }
      }
  
      // End of central directory record
      static class END {
<span class="line-modified">!         // The fields that are commented out below are not used by anyone and write() uses &quot;0&quot;</span>
          // int  disknum;
          // int  sdisknum;
<span class="line-modified">!         // int  endsub;</span>
<span class="line-modified">!         int  centot;        // 4 bytes</span>
<span class="line-modified">!         long cenlen;        // 4 bytes</span>
<span class="line-modified">!         long cenoff;        // 4 bytes</span>
<span class="line-modified">!         // int  comlen;     // comment length</span>
<span class="line-modified">!         // byte[] comment;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // members of Zip64 end of central directory locator</span>
          // int diskNum;
          long endpos;
          // int disktot;
  
          void write(OutputStream os, long offset, boolean forceEnd64) throws IOException {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1735,11 ***</span>
              if (count &gt;= ZIP64_MINVAL32) {
                  count = ZIP64_MINVAL32;
                  hasZip64 = true;
              }
              if (hasZip64) {
<span class="line-removed">-                 long off64 = offset;</span>
                  //zip64 end of central directory record
                  writeInt(os, ZIP64_ENDSIG);       // zip64 END record signature
                  writeLong(os, ZIP64_ENDHDR - 12); // size of zip64 end
                  writeShort(os, 45);               // version made by
                  writeShort(os, 45);               // version needed to extract
<span class="line-new-header">--- 2317,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1751,38 ***</span>
                  writeLong(os, cenoff);            // offset of central directory
  
                  //zip64 end of central directory locator
                  writeInt(os, ZIP64_LOCSIG);       // zip64 END locator signature
                  writeInt(os, 0);                  // zip64 END start disk
<span class="line-modified">!                 writeLong(os, off64);             // offset of zip64 END</span>
                  writeInt(os, 1);                  // total number of disks (?)
              }
              writeInt(os, ENDSIG);                 // END record signature
              writeShort(os, 0);                    // number of this disk
              writeShort(os, 0);                    // central directory start disk
              writeShort(os, count);                // number of directory entries on disk
              writeShort(os, count);                // total number of directory entries
              writeInt(os, xlen);                   // length of central directory
              writeInt(os, xoff);                   // offset of central directory
<span class="line-modified">!             if (comment != null) {            // zip file comment</span>
<span class="line-removed">-                 writeShort(os, comment.length);</span>
<span class="line-removed">-                 writeBytes(os, comment);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 writeShort(os, 0);</span>
<span class="line-removed">-             }</span>
          }
      }
  
      // Internal node that links a &quot;name&quot; to its pos in cen table.
      // The node itself can be used as a &quot;key&quot; to lookup itself in
      // the HashMap inodes.
      static class IndexNode {
<span class="line-modified">!         byte[] name;</span>
<span class="line-modified">!         int    hashcode;  // node is hashable/hashed by its name</span>
<span class="line-removed">-         int    pos = -1;  // position in cen table, -1 menas the</span>
<span class="line-removed">-                           // entry does not exists in zip file</span>
          boolean isdir;
  
          IndexNode(byte[] name, boolean isdir) {
              name(name);
              this.isdir = isdir;
              this.pos = -1;
<span class="line-new-header">--- 2332,37 ---</span>
                  writeLong(os, cenoff);            // offset of central directory
  
                  //zip64 end of central directory locator
                  writeInt(os, ZIP64_LOCSIG);       // zip64 END locator signature
                  writeInt(os, 0);                  // zip64 END start disk
<span class="line-modified">!                 writeLong(os, offset);            // offset of zip64 END</span>
                  writeInt(os, 1);                  // total number of disks (?)
              }
              writeInt(os, ENDSIG);                 // END record signature
              writeShort(os, 0);                    // number of this disk
              writeShort(os, 0);                    // central directory start disk
              writeShort(os, count);                // number of directory entries on disk
              writeShort(os, count);                // total number of directory entries
              writeInt(os, xlen);                   // length of central directory
              writeInt(os, xoff);                   // offset of central directory
<span class="line-modified">!             writeShort(os, 0);                    // zip file comment, not used</span>
          }
      }
  
      // Internal node that links a &quot;name&quot; to its pos in cen table.
      // The node itself can be used as a &quot;key&quot; to lookup itself in
      // the HashMap inodes.
      static class IndexNode {
<span class="line-modified">!         byte[]  name;</span>
<span class="line-modified">!         int     hashcode;    // node is hashable/hashed by its name</span>
          boolean isdir;
<span class="line-added">+         int     pos = -1;    // position in cen table, -1 means the</span>
<span class="line-added">+                              // entry does not exist in zip file</span>
<span class="line-added">+         IndexNode child;     // first child</span>
<span class="line-added">+         IndexNode sibling;   // next sibling</span>
<span class="line-added">+ </span>
<span class="line-added">+         IndexNode() {}</span>
  
          IndexNode(byte[] name, boolean isdir) {
              name(name);
              this.isdir = isdir;
              this.pos = -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1791,11 ***</span>
          IndexNode(byte[] name, int pos) {
              name(name);
              this.pos = pos;
          }
  
<span class="line-modified">!         // constructor for cenInit() (1) remove tailing &#39;/&#39; (2) pad leading &#39;/&#39;</span>
          IndexNode(byte[] cen, int pos, int nlen) {
              int noff = pos + CENHDR;
              if (cen[noff + nlen - 1] == &#39;/&#39;) {
                  isdir = true;
                  nlen--;
<span class="line-new-header">--- 2371,11 ---</span>
          IndexNode(byte[] name, int pos) {
              name(name);
              this.pos = pos;
          }
  
<span class="line-modified">!         // constructor for initCEN() (1) remove trailing &#39;/&#39; (2) pad leading &#39;/&#39;</span>
          IndexNode(byte[] cen, int pos, int nlen) {
              int noff = pos + CENHDR;
              if (cen[noff + nlen - 1] == &#39;/&#39;) {
                  isdir = true;
                  nlen--;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1805,17 ***</span>
              } else {
                  name = new byte[nlen + 1];
                  System.arraycopy(cen, noff, name, 1, nlen);
                  name[0] = &#39;/&#39;;
              }
<span class="line-modified">!             name(name);</span>
              this.pos = pos;
          }
  
          private static final ThreadLocal&lt;IndexNode&gt; cachedKey = new ThreadLocal&lt;&gt;();
  
<span class="line-modified">!         final static IndexNode keyOf(byte[] name) { // get a lookup key;</span>
              IndexNode key = cachedKey.get();
              if (key == null) {
                  key = new IndexNode(name, -1);
                  cachedKey.set(key);
              }
<span class="line-new-header">--- 2385,58 ---</span>
              } else {
                  name = new byte[nlen + 1];
                  System.arraycopy(cen, noff, name, 1, nlen);
                  name[0] = &#39;/&#39;;
              }
<span class="line-modified">!             name(normalize(name));</span>
              this.pos = pos;
          }
  
<span class="line-added">+         // Normalize the IndexNode.name field.</span>
<span class="line-added">+         private byte[] normalize(byte[] path) {</span>
<span class="line-added">+             int len = path.length;</span>
<span class="line-added">+             if (len == 0)</span>
<span class="line-added">+                 return path;</span>
<span class="line-added">+             byte prevC = 0;</span>
<span class="line-added">+             for (int pathPos = 0; pathPos &lt; len; pathPos++) {</span>
<span class="line-added">+                 byte c = path[pathPos];</span>
<span class="line-added">+                 if (c == &#39;/&#39; &amp;&amp; prevC == &#39;/&#39;)</span>
<span class="line-added">+                     return normalize(path, pathPos - 1);</span>
<span class="line-added">+                 prevC = c;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (len &gt; 1 &amp;&amp; prevC == &#39;/&#39;) {</span>
<span class="line-added">+                 return Arrays.copyOf(path, len - 1);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return path;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private byte[] normalize(byte[] path, int off) {</span>
<span class="line-added">+             // As we know we have at least one / to trim, we can reduce</span>
<span class="line-added">+             // the size of the resulting array</span>
<span class="line-added">+             byte[] to = new byte[path.length - 1];</span>
<span class="line-added">+             int pathPos = 0;</span>
<span class="line-added">+             while (pathPos &lt; off) {</span>
<span class="line-added">+                 to[pathPos] = path[pathPos];</span>
<span class="line-added">+                 pathPos++;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             int toPos = pathPos;</span>
<span class="line-added">+             byte prevC = 0;</span>
<span class="line-added">+             while (pathPos &lt; path.length) {</span>
<span class="line-added">+                 byte c = path[pathPos++];</span>
<span class="line-added">+                 if (c == &#39;/&#39; &amp;&amp; prevC == &#39;/&#39;)</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 to[toPos++] = c;</span>
<span class="line-added">+                 prevC = c;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (toPos &gt; 1 &amp;&amp; to[toPos - 1] == &#39;/&#39;)</span>
<span class="line-added">+                 toPos--;</span>
<span class="line-added">+             return (toPos == to.length) ? to : Arrays.copyOf(to, toPos);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          private static final ThreadLocal&lt;IndexNode&gt; cachedKey = new ThreadLocal&lt;&gt;();
  
<span class="line-modified">!         static final IndexNode keyOf(byte[] name) { // get a lookup key;</span>
              IndexNode key = cachedKey.get();
              if (key == null) {
                  key = new IndexNode(name, -1);
                  cachedKey.set(key);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1834,31 ***</span>
  
          boolean isDir() {
              return isdir;
          }
  
          public boolean equals(Object other) {
              if (!(other instanceof IndexNode)) {
                  return false;
              }
              if (other instanceof ParentLookup) {
                  return ((ParentLookup)other).equals(this);
              }
              return Arrays.equals(name, ((IndexNode)other).name);
          }
  
          public int hashCode() {
              return hashcode;
          }
  
<span class="line-modified">!         IndexNode() {}</span>
<span class="line-modified">!         IndexNode sibling;</span>
<span class="line-modified">!         IndexNode child;  // 1st child</span>
      }
  
      static class Entry extends IndexNode implements ZipFileAttributes {
<span class="line-removed">- </span>
          static final int CEN    = 1;  // entry read from cen
          static final int NEW    = 2;  // updated contents in bytes or file
          static final int FILECH = 3;  // fch update in &quot;file&quot;
          static final int COPY   = 4;  // copy of a CEN entry
  
<span class="line-new-header">--- 2455,33 ---</span>
  
          boolean isDir() {
              return isdir;
          }
  
<span class="line-added">+         @Override</span>
          public boolean equals(Object other) {
              if (!(other instanceof IndexNode)) {
                  return false;
              }
              if (other instanceof ParentLookup) {
                  return ((ParentLookup)other).equals(this);
              }
              return Arrays.equals(name, ((IndexNode)other).name);
          }
  
<span class="line-added">+         @Override</span>
          public int hashCode() {
              return hashcode;
          }
  
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public String toString() {</span>
<span class="line-modified">!             return new String(name) + (isdir ? &quot; (dir)&quot; : &quot; &quot;) + &quot;, index: &quot; + pos;</span>
<span class="line-added">+         }</span>
      }
  
      static class Entry extends IndexNode implements ZipFileAttributes {
          static final int CEN    = 1;  // entry read from cen
          static final int NEW    = 2;  // updated contents in bytes or file
          static final int FILECH = 3;  // fch update in &quot;file&quot;
          static final int COPY   = 4;  // copy of a CEN entry
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1867,47 ***</span>
          int    type = CEN;            // default is the entry read from cen
  
          // entry attributes
          int    version;
          int    flag;
          int    method = -1;    // compression method
          long   mtime  = -1;    // last modification time (in DOS time)
          long   atime  = -1;    // last access time
          long   ctime  = -1;    // create time
          long   crc    = -1;    // crc-32 of entry data
          long   csize  = -1;    // compressed size of entry data
          long   size   = -1;    // uncompressed size of entry data
          byte[] extra;
  
<span class="line-modified">!         // cen</span>
<span class="line-modified">! </span>
<span class="line-removed">-         // these fields are not used by anyone and writeCEN uses &quot;0&quot;</span>
          // int    versionMade;
          // int    disk;
          // int    attrs;
          // long   attrsEx;
          long   locoff;
          byte[] comment;
  
<span class="line-removed">-         Entry() {}</span>
<span class="line-removed">- </span>
          Entry(byte[] name, boolean isdir, int method) {
              name(name);
              this.isdir = isdir;
              this.mtime  = this.ctime = this.atime = System.currentTimeMillis();
              this.crc    = 0;
              this.size   = 0;
              this.csize  = 0;
              this.method = method;
          }
  
<span class="line-modified">!         Entry(byte[] name, int type, boolean isdir, int method) {</span>
              this(name, isdir, method);
              this.type = type;
          }
  
<span class="line-modified">!         Entry (Entry e, int type) {</span>
              name(e.name);
              this.isdir     = e.isdir;
              this.version   = e.version;
              this.ctime     = e.ctime;
              this.atime     = e.atime;
<span class="line-new-header">--- 2490,62 ---</span>
          int    type = CEN;            // default is the entry read from cen
  
          // entry attributes
          int    version;
          int    flag;
<span class="line-added">+         int    posixPerms = -1; // posix permissions</span>
          int    method = -1;    // compression method
          long   mtime  = -1;    // last modification time (in DOS time)
          long   atime  = -1;    // last access time
          long   ctime  = -1;    // create time
          long   crc    = -1;    // crc-32 of entry data
          long   csize  = -1;    // compressed size of entry data
          long   size   = -1;    // uncompressed size of entry data
          byte[] extra;
  
<span class="line-modified">!         // CEN</span>
<span class="line-modified">!         // The fields that are commented out below are not used by anyone and write() uses &quot;0&quot;</span>
          // int    versionMade;
          // int    disk;
          // int    attrs;
          // long   attrsEx;
          long   locoff;
          byte[] comment;
  
          Entry(byte[] name, boolean isdir, int method) {
              name(name);
              this.isdir = isdir;
              this.mtime  = this.ctime = this.atime = System.currentTimeMillis();
              this.crc    = 0;
              this.size   = 0;
              this.csize  = 0;
              this.method = method;
          }
  
<span class="line-modified">!         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">+         Entry(byte[] name, int type, boolean isdir, int method, FileAttribute&lt;?&gt;... attrs) {</span>
              this(name, isdir, method);
              this.type = type;
<span class="line-added">+             for (FileAttribute&lt;?&gt; attr : attrs) {</span>
<span class="line-added">+                 String attrName = attr.name();</span>
<span class="line-added">+                 if (attrName.equals(&quot;posix:permissions&quot;)) {</span>
<span class="line-added">+                     posixPerms = ZipUtils.permsToFlags((Set&lt;PosixFilePermission&gt;)attr.value());</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         Entry(byte[] name, Path file, int type, FileAttribute&lt;?&gt;... attrs) {</span>
<span class="line-added">+             this(name, type, false, METHOD_STORED, attrs);</span>
<span class="line-added">+             this.file = file;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         Entry(Entry e, int type, int compressionMethod) {</span>
<span class="line-added">+             this(e, type);</span>
<span class="line-added">+             this.method = compressionMethod;</span>
          }
  
<span class="line-modified">!         Entry(Entry e, int type) {</span>
              name(e.name);
              this.isdir     = e.isdir;
              this.version   = e.version;
              this.ctime     = e.ctime;
              this.atime     = e.atime;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1923,40 ***</span>
              this.attrs     = e.attrs;
              this.attrsEx   = e.attrsEx;
              */
              this.locoff    = e.locoff;
              this.comment   = e.comment;
              this.type      = type;
          }
  
<span class="line-modified">!         Entry (byte[] name, Path file, int type) {</span>
<span class="line-modified">!             this(name, type, false, METHOD_STORED);</span>
<span class="line-removed">-             this.file = file;</span>
          }
  
<span class="line-modified">!         int version() throws ZipException {</span>
              if (method == METHOD_DEFLATED)
                  return 20;
              else if (method == METHOD_STORED)
                  return 10;
              throw new ZipException(&quot;unsupported compression method&quot;);
          }
  
<span class="line-modified">!         ///////////////////// CEN //////////////////////</span>
<span class="line-modified">!         static Entry readCEN(ZipFileSystem zipfs, IndexNode inode)</span>
<span class="line-modified">!             throws IOException</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             return new Entry().cen(zipfs, inode);</span>
          }
  
<span class="line-modified">!         private Entry cen(ZipFileSystem zipfs, IndexNode inode)</span>
<span class="line-modified">!             throws IOException</span>
<span class="line-removed">-         {</span>
              byte[] cen = zipfs.cen;
              int pos = inode.pos;
              if (!cenSigAt(cen, pos))
<span class="line-modified">!                 zerror(&quot;invalid CEN header (bad signature)&quot;);</span>
              version     = CENVER(cen, pos);
              flag        = CENFLG(cen, pos);
              method      = CENHOW(cen, pos);
              mtime       = dosToJavaTime(CENTIM(cen, pos));
              crc         = CENCRC(cen, pos);
<span class="line-new-header">--- 2561,50 ---</span>
              this.attrs     = e.attrs;
              this.attrsEx   = e.attrsEx;
              */
              this.locoff    = e.locoff;
              this.comment   = e.comment;
<span class="line-added">+             this.posixPerms = e.posixPerms;</span>
              this.type      = type;
          }
  
<span class="line-modified">!         Entry(ZipFileSystem zipfs, IndexNode inode) throws IOException {</span>
<span class="line-modified">!             readCEN(zipfs, inode);</span>
          }
  
<span class="line-modified">!         // Calculates a suitable base for the version number to</span>
<span class="line-added">+         // be used for fields version made by/version needed to extract.</span>
<span class="line-added">+         // The lower bytes of these 2 byte fields hold the version number</span>
<span class="line-added">+         // (value/10 = major; value%10 = minor)</span>
<span class="line-added">+         // For different features certain minimum versions apply:</span>
<span class="line-added">+         // stored = 10 (1.0), deflated = 20 (2.0), zip64 = 45 (4.5)</span>
<span class="line-added">+         private int version(boolean zip64) throws ZipException {</span>
<span class="line-added">+             if (zip64) {</span>
<span class="line-added">+                 return 45;</span>
<span class="line-added">+             }</span>
              if (method == METHOD_DEFLATED)
                  return 20;
              else if (method == METHOD_STORED)
                  return 10;
              throw new ZipException(&quot;unsupported compression method&quot;);
          }
  
<span class="line-modified">!         /**</span>
<span class="line-modified">!          * Adds information about compatibility of file attribute information</span>
<span class="line-modified">!          * to a version value.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         private int versionMadeBy(int version) {</span>
<span class="line-added">+             return (posixPerms &lt; 0) ? version :</span>
<span class="line-added">+                 VERSION_MADE_BY_BASE_UNIX | (version &amp; 0xff);</span>
          }
  
<span class="line-modified">!         ///////////////////// CEN //////////////////////</span>
<span class="line-modified">!         private void readCEN(ZipFileSystem zipfs, IndexNode inode) throws IOException {</span>
              byte[] cen = zipfs.cen;
              int pos = inode.pos;
              if (!cenSigAt(cen, pos))
<span class="line-modified">!                 throw new ZipException(&quot;invalid CEN header (bad signature)&quot;);</span>
              version     = CENVER(cen, pos);
              flag        = CENFLG(cen, pos);
              method      = CENHOW(cen, pos);
              mtime       = dosToJavaTime(CENTIM(cen, pos));
              crc         = CENCRC(cen, pos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1969,10 ***</span>
<span class="line-new-header">--- 2617,13 ---</span>
              versionMade = CENVEM(cen, pos);
              disk        = CENDSK(cen, pos);
              attrs       = CENATT(cen, pos);
              attrsEx     = CENATX(cen, pos);
              */
<span class="line-added">+             if (CENVEM_FA(cen, pos) == FILE_ATTRIBUTES_UNIX) {</span>
<span class="line-added">+                 posixPerms = CENATX_PERMS(cen, pos) &amp; 0xFFF; // 12 bits for setuid, setgid, sticky + perms</span>
<span class="line-added">+             }</span>
              locoff      = CENOFF(cen, pos);
              pos += CENHDR;
              this.name = inode.name;
              this.isdir = inode.isdir;
              this.hashcode = inode.hashcode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1984,15 ***</span>
                  readExtra(zipfs);
              }
              if (clen &gt; 0) {
                  comment = Arrays.copyOfRange(cen, pos, pos + clen);
              }
<span class="line-removed">-             return this;</span>
          }
  
<span class="line-modified">!         int writeCEN(OutputStream os) throws IOException {</span>
<span class="line-removed">-             int version0 = version();</span>
              long csize0  = csize;
              long size0   = size;
              long locoff0 = locoff;
              int elen64   = 0;                // extra for ZIP64
              int elenNTFS = 0;                // extra for NTFS (a/c/mtime)
<span class="line-new-header">--- 2635,13 ---</span>
                  readExtra(zipfs);
              }
              if (clen &gt; 0) {
                  comment = Arrays.copyOfRange(cen, pos, pos + clen);
              }
          }
  
<span class="line-modified">!         private int writeCEN(OutputStream os) throws IOException {</span>
              long csize0  = csize;
              long size0   = size;
              long locoff0 = locoff;
              int elen64   = 0;                // extra for ZIP64
              int elenNTFS = 0;                // extra for NTFS (a/c/mtime)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2019,10 ***</span>
<span class="line-new-header">--- 2668,12 ---</span>
                  elen64 += 8;                 // offset(8)
              }
              if (elen64 != 0) {
                  elen64 += 4;                 // header and data sz 4 bytes
              }
<span class="line-added">+             boolean zip64 = (elen64 != 0);</span>
<span class="line-added">+             int version0 = version(zip64);</span>
              while (eoff + 4 &lt; elen) {
                  int tag = SH(extra, eoff);
                  int sz = SH(extra, eoff + 2);
                  if (tag == EXTID_EXTT || tag == EXTID_NTFS) {
                      foundExtraTime = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2035,17 ***</span>
                  } else {                     // Extended Timestamp otherwise
                      elenEXTT = 9;            // only mtime in cen
                  }
              }
              writeInt(os, CENSIG);            // CEN header signature
<span class="line-modified">!             if (elen64 != 0) {</span>
<span class="line-modified">!                 writeShort(os, 45);          // ver 4.5 for zip64</span>
<span class="line-removed">-                 writeShort(os, 45);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 writeShort(os, version0);    // version made by</span>
<span class="line-removed">-                 writeShort(os, version0);    // version needed to extract</span>
<span class="line-removed">-             }</span>
              writeShort(os, flag);            // general purpose bit flag
              writeShort(os, method);          // compression method
                                               // last modification time
              writeInt(os, (int)javaToDosTime(mtime));
              writeInt(os, crc);               // crc-32
<span class="line-new-header">--- 2686,12 ---</span>
                  } else {                     // Extended Timestamp otherwise
                      elenEXTT = 9;            // only mtime in cen
                  }
              }
              writeInt(os, CENSIG);            // CEN header signature
<span class="line-modified">!             writeShort(os, versionMadeBy(version0)); // version made by</span>
<span class="line-modified">!             writeShort(os, version0);        // version needed to extract</span>
              writeShort(os, flag);            // general purpose bit flag
              writeShort(os, method);          // compression method
                                               // last modification time
              writeInt(os, (int)javaToDosTime(mtime));
              writeInt(os, crc);               // crc-32
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2059,14 ***</span>
              } else {
                  writeShort(os, 0);
              }
              writeShort(os, 0);              // starting disk number
              writeShort(os, 0);              // internal file attributes (unused)
<span class="line-modified">!             writeInt(os, 0);                // external file attributes (unused)</span>
              writeInt(os, locoff0);          // relative offset of local header
              writeBytes(os, zname, 1, nlen);
<span class="line-modified">!             if (elen64 != 0) {</span>
                  writeShort(os, EXTID_ZIP64);// Zip64 extra
                  writeShort(os, elen64 - 4); // size of &quot;this&quot; extra block
                  if (size0 == ZIP64_MINVAL)
                      writeLong(os, size);
                  if (csize0 == ZIP64_MINVAL)
<span class="line-new-header">--- 2705,16 ---</span>
              } else {
                  writeShort(os, 0);
              }
              writeShort(os, 0);              // starting disk number
              writeShort(os, 0);              // internal file attributes (unused)
<span class="line-modified">!             writeInt(os, posixPerms &gt; 0 ? posixPerms &lt;&lt; 16 : 0); // external file</span>
<span class="line-added">+                                             // attributes, used for storing posix</span>
<span class="line-added">+                                             // permissions</span>
              writeInt(os, locoff0);          // relative offset of local header
              writeBytes(os, zname, 1, nlen);
<span class="line-modified">!             if (zip64) {</span>
                  writeShort(os, EXTID_ZIP64);// Zip64 extra
                  writeShort(os, elen64 - 4); // size of &quot;this&quot; extra block
                  if (size0 == ZIP64_MINVAL)
                      writeLong(os, size);
                  if (csize0 == ZIP64_MINVAL)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2100,23 ***</span>
              return CENHDR + nlen + elen + clen + elen64 + elenNTFS + elenEXTT;
          }
  
          ///////////////////// LOC //////////////////////
  
<span class="line-modified">!         int writeLOC(OutputStream os) throws IOException {</span>
<span class="line-removed">-             int version0 = version();</span>
              byte[] zname = isdir ? toDirectoryPath(name) : name;
              int nlen = (zname != null) ? zname.length - 1 : 0; // [0] is slash
              int elen = (extra != null) ? extra.length : 0;
              boolean foundExtraTime = false;     // if extra timestamp present
              int eoff = 0;
              int elen64 = 0;
              int elenEXTT = 0;
              int elenNTFS = 0;
              writeInt(os, LOCSIG);               // LOC header signature
              if ((flag &amp; FLAG_DATADESCR) != 0) {
<span class="line-modified">!                 writeShort(os, version0);       // version needed to extract</span>
                  writeShort(os, flag);           // general purpose bit flag
                  writeShort(os, method);         // compression method
                  // last modification time
                  writeInt(os, (int)javaToDosTime(mtime));
                  // store size, uncompressed size, and crc-32 in data descriptor
<span class="line-new-header">--- 2748,23 ---</span>
              return CENHDR + nlen + elen + clen + elen64 + elenNTFS + elenEXTT;
          }
  
          ///////////////////// LOC //////////////////////
  
<span class="line-modified">!         private int writeLOC(OutputStream os) throws IOException {</span>
              byte[] zname = isdir ? toDirectoryPath(name) : name;
              int nlen = (zname != null) ? zname.length - 1 : 0; // [0] is slash
              int elen = (extra != null) ? extra.length : 0;
              boolean foundExtraTime = false;     // if extra timestamp present
              int eoff = 0;
              int elen64 = 0;
<span class="line-added">+             boolean zip64 = false;</span>
              int elenEXTT = 0;
              int elenNTFS = 0;
              writeInt(os, LOCSIG);               // LOC header signature
              if ((flag &amp; FLAG_DATADESCR) != 0) {
<span class="line-modified">!                 writeShort(os, version(false)); // version needed to extract</span>
                  writeShort(os, flag);           // general purpose bit flag
                  writeShort(os, method);         // compression method
                  // last modification time
                  writeInt(os, (int)javaToDosTime(mtime));
                  // store size, uncompressed size, and crc-32 in data descriptor
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2125,20 ***</span>
                  writeInt(os, 0);
                  writeInt(os, 0);
              } else {
                  if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
                      elen64 = 20;    //headid(2) + size(2) + size(8) + csize(8)
<span class="line-modified">!                     writeShort(os, 45);         // ver 4.5 for zip64</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     writeShort(os, version0);   // version needed to extract</span>
                  }
                  writeShort(os, flag);           // general purpose bit flag
                  writeShort(os, method);         // compression method
                                                  // last modification time
                  writeInt(os, (int)javaToDosTime(mtime));
                  writeInt(os, crc);              // crc-32
<span class="line-modified">!                 if (elen64 != 0) {</span>
                      writeInt(os, ZIP64_MINVAL);
                      writeInt(os, ZIP64_MINVAL);
                  } else {
                      writeInt(os, csize);        // compressed size
                      writeInt(os, size);         // uncompressed size
<span class="line-new-header">--- 2773,19 ---</span>
                  writeInt(os, 0);
                  writeInt(os, 0);
              } else {
                  if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
                      elen64 = 20;    //headid(2) + size(2) + size(8) + csize(8)
<span class="line-modified">!                     zip64 = true;</span>
                  }
<span class="line-added">+                 writeShort(os, version(zip64)); // version needed to extract</span>
                  writeShort(os, flag);           // general purpose bit flag
                  writeShort(os, method);         // compression method
                                                  // last modification time
                  writeInt(os, (int)javaToDosTime(mtime));
                  writeInt(os, crc);              // crc-32
<span class="line-modified">!                 if (zip64) {</span>
                      writeInt(os, ZIP64_MINVAL);
                      writeInt(os, ZIP64_MINVAL);
                  } else {
                      writeInt(os, csize);        // compressed size
                      writeInt(os, size);         // uncompressed size
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2164,11 ***</span>
                  }
              }
              writeShort(os, nlen);
              writeShort(os, elen + elen64 + elenNTFS + elenEXTT);
              writeBytes(os, zname, 1, nlen);
<span class="line-modified">!             if (elen64 != 0) {</span>
                  writeShort(os, EXTID_ZIP64);
                  writeShort(os, 16);
                  writeLong(os, size);
                  writeLong(os, csize);
              }
<span class="line-new-header">--- 2811,11 ---</span>
                  }
              }
              writeShort(os, nlen);
              writeShort(os, elen + elen64 + elenNTFS + elenEXTT);
              writeBytes(os, zname, 1, nlen);
<span class="line-modified">!             if (zip64) {</span>
                  writeShort(os, EXTID_ZIP64);
                  writeShort(os, 16);
                  writeLong(os, size);
                  writeLong(os, csize);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2201,12 ***</span>
                  writeBytes(os, extra);
              }
              return LOCHDR + nlen + elen + elen64 + elenNTFS + elenEXTT;
          }
  
<span class="line-modified">!         // Data Descriptior</span>
<span class="line-modified">!         int writeEXT(OutputStream os) throws IOException {</span>
              writeInt(os, EXTSIG);           // EXT header signature
              writeInt(os, crc);              // crc-32
              if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
                  writeLong(os, csize);
                  writeLong(os, size);
<span class="line-new-header">--- 2848,12 ---</span>
                  writeBytes(os, extra);
              }
              return LOCHDR + nlen + elen + elen64 + elenNTFS + elenEXTT;
          }
  
<span class="line-modified">!         // Data Descriptor</span>
<span class="line-modified">!         private int writeEXT(OutputStream os) throws IOException {</span>
              writeInt(os, EXTSIG);           // EXT header signature
              writeInt(os, crc);              // crc-32
              if (csize &gt;= ZIP64_MINVAL || size &gt;= ZIP64_MINVAL) {
                  writeLong(os, csize);
                  writeLong(os, size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2217,11 ***</span>
                  return 16;
              }
          }
  
          // read NTFS, UNIX and ZIP64 data from cen.extra
<span class="line-modified">!         void readExtra(ZipFileSystem zipfs) throws IOException {</span>
              if (extra == null)
                  return;
              int elen = extra.length;
              int off = 0;
              int newOff = 0;
<span class="line-new-header">--- 2864,11 ---</span>
                  return 16;
              }
          }
  
          // read NTFS, UNIX and ZIP64 data from cen.extra
<span class="line-modified">!         private void readExtra(ZipFileSystem zipfs) throws IOException {</span>
              if (extra == null)
                  return;
              int elen = extra.length;
              int off = 0;
              int newOff = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2249,11 ***</span>
                      }
                      if (locoff == ZIP64_MINVAL) {
                          if (pos + 8 &gt; elen)
                              break;
                          locoff = LL(extra, pos);
<span class="line-removed">-                         pos += 8;</span>
                      }
                      break;
                  case EXTID_NTFS:
                      if (sz &lt; 32)
                          break;
<span class="line-new-header">--- 2896,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2285,11 ***</span>
                          throw new ZipException(&quot;loc: reading failed&quot;);
                      if (!locSigAt(buf, 0))
                          throw new ZipException(&quot;loc: wrong sig -&gt;&quot;
                                             + Long.toString(getSig(buf, 0), 16));
                      int locElen = LOCEXT(buf);
<span class="line-modified">!                     if (locElen &lt; 9)    // EXTT is at lease 9 bytes</span>
                          break;
                      int locNlen = LOCNAM(buf);
                      buf = new byte[locElen];
                      if (zipfs.readFullyAt(buf, 0, buf.length , locoff + LOCHDR + locNlen)
                          != buf.length)
<span class="line-new-header">--- 2931,11 ---</span>
                          throw new ZipException(&quot;loc: reading failed&quot;);
                      if (!locSigAt(buf, 0))
                          throw new ZipException(&quot;loc: wrong sig -&gt;&quot;
                                             + Long.toString(getSig(buf, 0), 16));
                      int locElen = LOCEXT(buf);
<span class="line-modified">!                     if (locElen &lt; 9)    // EXTT is at least 9 bytes</span>
                          break;
                      int locNlen = LOCNAM(buf);
                      buf = new byte[locElen];
                      if (zipfs.readFullyAt(buf, 0, buf.length , locoff + LOCHDR + locNlen)
                          != buf.length)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2313,11 ***</span>
                              atime = unixToJavaTime(LG(buf, locPos));
                              locPos += 4;
                          }
                          if ((flag &amp; 0x4) != 0 &amp;&amp; locPos &lt;= end) {
                              ctime = unixToJavaTime(LG(buf, locPos));
<span class="line-removed">-                             locPos += 4;</span>
                          }
                          break;
                      }
                      break;
                  default:    // unknown tag
<span class="line-new-header">--- 2959,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2330,10 ***</span>
<span class="line-new-header">--- 2975,35 ---</span>
                  extra = Arrays.copyOf(extra, newOff);
              else
                  extra = null;
          }
  
<span class="line-added">+         @Override</span>
<span class="line-added">+         public String toString() {</span>
<span class="line-added">+             StringBuilder sb = new StringBuilder(1024);</span>
<span class="line-added">+             Formatter fm = new Formatter(sb);</span>
<span class="line-added">+             fm.format(&quot;    name            : %s%n&quot;, new String(name));</span>
<span class="line-added">+             fm.format(&quot;    creationTime    : %tc%n&quot;, creationTime().toMillis());</span>
<span class="line-added">+             fm.format(&quot;    lastAccessTime  : %tc%n&quot;, lastAccessTime().toMillis());</span>
<span class="line-added">+             fm.format(&quot;    lastModifiedTime: %tc%n&quot;, lastModifiedTime().toMillis());</span>
<span class="line-added">+             fm.format(&quot;    isRegularFile   : %b%n&quot;, isRegularFile());</span>
<span class="line-added">+             fm.format(&quot;    isDirectory     : %b%n&quot;, isDirectory());</span>
<span class="line-added">+             fm.format(&quot;    isSymbolicLink  : %b%n&quot;, isSymbolicLink());</span>
<span class="line-added">+             fm.format(&quot;    isOther         : %b%n&quot;, isOther());</span>
<span class="line-added">+             fm.format(&quot;    fileKey         : %s%n&quot;, fileKey());</span>
<span class="line-added">+             fm.format(&quot;    size            : %d%n&quot;, size());</span>
<span class="line-added">+             fm.format(&quot;    compressedSize  : %d%n&quot;, compressedSize());</span>
<span class="line-added">+             fm.format(&quot;    crc             : %x%n&quot;, crc());</span>
<span class="line-added">+             fm.format(&quot;    method          : %d%n&quot;, method());</span>
<span class="line-added">+             Set&lt;PosixFilePermission&gt; permissions = storedPermissions().orElse(null);</span>
<span class="line-added">+             if (permissions != null) {</span>
<span class="line-added">+                 fm.format(&quot;    permissions     : %s%n&quot;, permissions);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             fm.close();</span>
<span class="line-added">+             return sb.toString();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          ///////// basic file attributes ///////////
          @Override
          public FileTime creationTime() {
              return FileTime.fromMillis(ctime == -1 ? mtime : ctime);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2376,82 ***</span>
          @Override
          public Object fileKey() {
              return null;
          }
  
<span class="line-modified">!         ///////// zip entry attributes ///////////</span>
          public long compressedSize() {
              return csize;
          }
  
          public long crc() {
              return crc;
          }
  
          public int method() {
              return method;
          }
  
          public byte[] extra() {
              if (extra != null)
                  return Arrays.copyOf(extra, extra.length);
              return null;
          }
  
          public byte[] comment() {
              if (comment != null)
                  return Arrays.copyOf(comment, comment.length);
              return null;
          }
  
<span class="line-modified">!         public String toString() {</span>
<span class="line-modified">!             StringBuilder sb = new StringBuilder(1024);</span>
<span class="line-modified">!             Formatter fm = new Formatter(sb);</span>
<span class="line-modified">!             fm.format(&quot;    name            : %s%n&quot;, new String(name));</span>
<span class="line-modified">!             fm.format(&quot;    creationTime    : %tc%n&quot;, creationTime().toMillis());</span>
<span class="line-modified">!             fm.format(&quot;    lastAccessTime  : %tc%n&quot;, lastAccessTime().toMillis());</span>
<span class="line-modified">!             fm.format(&quot;    lastModifiedTime: %tc%n&quot;, lastModifiedTime().toMillis());</span>
<span class="line-modified">!             fm.format(&quot;    isRegularFile   : %b%n&quot;, isRegularFile());</span>
<span class="line-modified">!             fm.format(&quot;    isDirectory     : %b%n&quot;, isDirectory());</span>
<span class="line-modified">!             fm.format(&quot;    isSymbolicLink  : %b%n&quot;, isSymbolicLink());</span>
<span class="line-modified">!             fm.format(&quot;    isOther         : %b%n&quot;, isOther());</span>
<span class="line-modified">!             fm.format(&quot;    fileKey         : %s%n&quot;, fileKey());</span>
<span class="line-removed">-             fm.format(&quot;    size            : %d%n&quot;, size());</span>
<span class="line-removed">-             fm.format(&quot;    compressedSize  : %d%n&quot;, compressedSize());</span>
<span class="line-removed">-             fm.format(&quot;    crc             : %x%n&quot;, crc());</span>
<span class="line-removed">-             fm.format(&quot;    method          : %d%n&quot;, method());</span>
<span class="line-removed">-             fm.close();</span>
<span class="line-removed">-             return sb.toString();</span>
          }
      }
  
<span class="line-modified">!     // ZIP directory has two issues:</span>
<span class="line-modified">!     // (1) ZIP spec does not require the ZIP file to include</span>
<span class="line-modified">!     //     directory entry</span>
<span class="line-removed">-     // (2) all entries are not stored/organized in a &quot;tree&quot;</span>
<span class="line-removed">-     //     structure.</span>
<span class="line-removed">-     // A possible solution is to build the node tree ourself as</span>
<span class="line-removed">-     // implemented below.</span>
  
<span class="line-modified">!     // default time stamp for pseudo entries</span>
<span class="line-modified">!     private long zfsDefaultTimeStamp = System.currentTimeMillis();</span>
  
<span class="line-modified">!     private void removeFromTree(IndexNode inode) {</span>
<span class="line-modified">!         IndexNode parent = inodes.get(LOOKUPKEY.as(getParent(inode.name)));</span>
<span class="line-modified">!         IndexNode child = parent.child;</span>
<span class="line-modified">!         if (child.equals(inode)) {</span>
<span class="line-modified">!             parent.child = child.sibling;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             IndexNode last = child;</span>
<span class="line-modified">!             while ((child = child.sibling) != null) {</span>
<span class="line-modified">!                 if (child.equals(inode)) {</span>
<span class="line-modified">!                     last.sibling = child.sibling;</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 } else {</span>
<span class="line-modified">!                     last = child;</span>
<span class="line-modified">!                 }</span>
              }
          }
      }
  
      // purely for parent lookup, so we don&#39;t have to copy the parent
      // name every time
<span class="line-new-header">--- 3046,130 ---</span>
          @Override
          public Object fileKey() {
              return null;
          }
  
<span class="line-modified">!         ///////// zip file attributes ///////////</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
          public long compressedSize() {
              return csize;
          }
  
<span class="line-added">+         @Override</span>
          public long crc() {
              return crc;
          }
  
<span class="line-added">+         @Override</span>
          public int method() {
              return method;
          }
  
<span class="line-added">+         @Override</span>
          public byte[] extra() {
              if (extra != null)
                  return Arrays.copyOf(extra, extra.length);
              return null;
          }
  
<span class="line-added">+         @Override</span>
          public byte[] comment() {
              if (comment != null)
                  return Arrays.copyOf(comment, comment.length);
              return null;
          }
  
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public Optional&lt;Set&lt;PosixFilePermission&gt;&gt; storedPermissions() {</span>
<span class="line-modified">!             Set&lt;PosixFilePermission&gt; perms = null;</span>
<span class="line-modified">!             if (posixPerms != -1) {</span>
<span class="line-modified">!                 perms = new HashSet&lt;&gt;(PosixFilePermission.values().length);</span>
<span class="line-modified">!                 for (PosixFilePermission perm : PosixFilePermission.values()) {</span>
<span class="line-modified">!                     if ((posixPerms &amp; ZipUtils.permToFlag(perm)) != 0) {</span>
<span class="line-modified">!                         perms.add(perm);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             return Optional.ofNullable(perms);</span>
          }
      }
  
<span class="line-modified">!     final class PosixEntry extends Entry implements PosixFileAttributes {</span>
<span class="line-modified">!         private UserPrincipal owner = defaultOwner;</span>
<span class="line-modified">!         private GroupPrincipal group = defaultGroup;</span>
  
<span class="line-modified">!         PosixEntry(byte[] name, boolean isdir, int method) {</span>
<span class="line-modified">!             super(name, isdir, method);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         PosixEntry(byte[] name, int type, boolean isdir, int method, FileAttribute&lt;?&gt;... attrs) {</span>
<span class="line-modified">!             super(name, type, isdir, method, attrs);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         PosixEntry(byte[] name, Path file, int type, FileAttribute&lt;?&gt;... attrs) {</span>
<span class="line-modified">!             super(name, file, type, attrs);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         PosixEntry(PosixEntry e, int type, int compressionMethod) {</span>
<span class="line-modified">!             super(e, type);</span>
<span class="line-modified">!             this.method = compressionMethod;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         PosixEntry(PosixEntry e, int type) {</span>
<span class="line-added">+             super(e, type);</span>
<span class="line-added">+             this.owner = e.owner;</span>
<span class="line-added">+             this.group = e.group;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         PosixEntry(ZipFileSystem zipfs, IndexNode inode) throws IOException {</span>
<span class="line-added">+             super(zipfs, inode);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public UserPrincipal owner() {</span>
<span class="line-added">+             return owner;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public GroupPrincipal group() {</span>
<span class="line-added">+             return group;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public Set&lt;PosixFilePermission&gt; permissions() {</span>
<span class="line-added">+             return storedPermissions().orElse(Set.copyOf(defaultPermissions));</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static class ExistingChannelCloser {</span>
<span class="line-added">+         private final Path path;</span>
<span class="line-added">+         private final SeekableByteChannel ch;</span>
<span class="line-added">+         private final Set&lt;InputStream&gt; streams;</span>
<span class="line-added">+         ExistingChannelCloser(Path path,</span>
<span class="line-added">+                               SeekableByteChannel ch,</span>
<span class="line-added">+                               Set&lt;InputStream&gt; streams) {</span>
<span class="line-added">+             this.path = path;</span>
<span class="line-added">+             this.ch = ch;</span>
<span class="line-added">+             this.streams = streams;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * If there are no more outstanding streams, close the channel and</span>
<span class="line-added">+          * delete the backing file</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * @return true if we&#39;re done and closed the backing file,</span>
<span class="line-added">+          *         otherwise false</span>
<span class="line-added">+          * @throws IOException</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private boolean closeAndDeleteIfDone() throws IOException {</span>
<span class="line-added">+             if (streams.isEmpty()) {</span>
<span class="line-added">+                 ch.close();</span>
<span class="line-added">+                 Files.delete(path);</span>
<span class="line-added">+                 return true;</span>
              }
<span class="line-added">+             return false;</span>
          }
      }
  
      // purely for parent lookup, so we don&#39;t have to copy the parent
      // name every time
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2481,49 ***</span>
              }
              byte[] oname = ((IndexNode)other).name;
              return Arrays.equals(name, 0, len,
                                   oname, 0, oname.length);
          }
<span class="line-removed">- </span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private void buildNodeTree() throws IOException {</span>
<span class="line-removed">-         beginWrite();</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             IndexNode root = inodes.get(LOOKUPKEY.as(ROOTPATH));</span>
<span class="line-removed">-             if (root == null) {</span>
<span class="line-removed">-                 root = new IndexNode(ROOTPATH, true);</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 inodes.remove(root);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             IndexNode[] nodes = inodes.keySet().toArray(new IndexNode[0]);</span>
<span class="line-removed">-             inodes.put(root, root);</span>
<span class="line-removed">-             ParentLookup lookup = new ParentLookup();</span>
<span class="line-removed">-             for (IndexNode node : nodes) {</span>
<span class="line-removed">-                 IndexNode parent;</span>
<span class="line-removed">-                 while (true) {</span>
<span class="line-removed">-                     int off = getParentOff(node.name);</span>
<span class="line-removed">-                     if (off &lt;= 1) {    // parent is root</span>
<span class="line-removed">-                         node.sibling = root.child;</span>
<span class="line-removed">-                         root.child = node;</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     lookup = lookup.as(node.name, off);</span>
<span class="line-removed">-                     if (inodes.containsKey(lookup)) {</span>
<span class="line-removed">-                         parent = inodes.get(lookup);</span>
<span class="line-removed">-                         node.sibling = parent.child;</span>
<span class="line-removed">-                         parent.child = node;</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     // add new pseudo directory entry</span>
<span class="line-removed">-                     parent = new IndexNode(Arrays.copyOf(node.name, off), true);</span>
<span class="line-removed">-                     inodes.put(parent, parent);</span>
<span class="line-removed">-                     node.sibling = parent.child;</span>
<span class="line-removed">-                     parent.child = node;</span>
<span class="line-removed">-                     node = parent;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } finally {</span>
<span class="line-removed">-             endWrite();</span>
<span class="line-removed">-         }</span>
      }
  }
<span class="line-new-header">--- 3199,7 ---</span>
</pre>
<center><a href="ZipFileStore.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipFileSystemProvider.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
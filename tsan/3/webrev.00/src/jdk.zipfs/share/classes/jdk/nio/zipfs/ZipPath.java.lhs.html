<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipPath.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.nio.zipfs;
  27 
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.OutputStream;
  32 import java.net.URI;
  33 import java.nio.channels.FileChannel;
  34 import java.nio.channels.SeekableByteChannel;
  35 import java.nio.file.*;
  36 import java.nio.file.DirectoryStream.Filter;
<a name="1" id="anc1"></a><span class="line-modified">  37 import java.nio.file.attribute.BasicFileAttributeView;</span>
<span class="line-removed">  38 import java.nio.file.attribute.FileAttribute;</span>
<span class="line-removed">  39 import java.nio.file.attribute.FileTime;</span>
  40 import java.util.Arrays;
  41 import java.util.Iterator;
  42 import java.util.Map;
  43 import java.util.NoSuchElementException;
  44 import java.util.Objects;
  45 import java.util.Set;
  46 
  47 import static java.nio.charset.StandardCharsets.UTF_8;
  48 import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;
  49 import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
  50 import static java.nio.file.StandardOpenOption.CREATE;
  51 import static java.nio.file.StandardOpenOption.READ;
  52 import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;
  53 import static java.nio.file.StandardOpenOption.WRITE;
  54 
  55 /**
  56  * @author Xueming Shen, Rajendra Gutupalli,Jaya Hangal
  57  */
  58 final class ZipPath implements Path {
  59 
  60     private final ZipFileSystem zfs;
  61     private final byte[] path;
  62     private volatile int[] offsets;
  63     private int hashcode = 0;  // cached hashcode (created lazily)
  64 
  65     ZipPath(ZipFileSystem zfs, byte[] path) {
  66         this(zfs, path, false);
  67     }
  68 
  69     ZipPath(ZipFileSystem zfs, byte[] path, boolean normalized) {
  70         this.zfs = zfs;
  71         if (normalized) {
  72             this.path = path;
  73         } else {
  74             if (zfs.zc.isUTF8()) {
  75                 this.path = normalize(path);
  76             } else {    // see normalize(String);
  77                 this.path = normalize(zfs.getString(path));
  78             }
  79         }
  80     }
  81 
  82     ZipPath(ZipFileSystem zfs, String path) {
  83         this.zfs = zfs;
  84         this.path = normalize(path);
  85     }
  86 
  87     @Override
  88     public ZipPath getRoot() {
  89         if (this.isAbsolute())
  90             return zfs.getRootDir();
  91         else
  92             return null;
  93     }
  94 
  95     @Override
  96     public ZipPath getFileName() {
  97         int off = path.length;
  98         if (off == 0 || off == 1 &amp;&amp; path[0] == &#39;/&#39;)
  99             return null;
 100         while (--off &gt;= 0 &amp;&amp; path[off] != &#39;/&#39;) {}
 101         if (off &lt; 0)
 102             return this;
 103         off++;
 104         byte[] result = new byte[path.length - off];
 105         System.arraycopy(path, off, result, 0, result.length);
 106         return new ZipPath(getFileSystem(), result, true);
 107     }
 108 
 109     @Override
 110     public ZipPath getParent() {
 111         int off = path.length;
 112         if (off == 0 || off == 1 &amp;&amp; path[0] == &#39;/&#39;)
 113             return null;
 114         while (--off &gt;= 0 &amp;&amp; path[off] != &#39;/&#39;) {}
 115         if (off &lt;= 0)
 116             return getRoot();
 117         byte[] result = new byte[off];
 118         System.arraycopy(path, 0, result, 0, off);
 119         return new ZipPath(getFileSystem(), result, true);
 120     }
 121 
 122     @Override
 123     public int getNameCount() {
 124         initOffsets();
 125         return offsets.length;
 126     }
 127 
 128     @Override
 129     public ZipPath getName(int index) {
 130         initOffsets();
 131         if (index &lt; 0 || index &gt;= offsets.length)
 132             throw new IllegalArgumentException();
 133         int begin = offsets[index];
 134         int len;
 135         if (index == (offsets.length-1))
 136             len = path.length - begin;
 137         else
 138             len = offsets[index+1] - begin - 1;
 139         // construct result
 140         byte[] result = new byte[len];
 141         System.arraycopy(path, begin, result, 0, len);
 142         return new ZipPath(zfs, result);
 143     }
 144 
 145     @Override
 146     public ZipPath subpath(int beginIndex, int endIndex) {
 147         initOffsets();
 148         if (beginIndex &lt; 0 ||
 149             beginIndex &gt;=  offsets.length ||
 150             endIndex &gt; offsets.length ||
 151             beginIndex &gt;= endIndex)
 152             throw new IllegalArgumentException();
 153 
 154         // starting offset and length
 155         int begin = offsets[beginIndex];
 156         int len;
 157         if (endIndex == offsets.length)
 158             len = path.length - begin;
 159         else
 160             len = offsets[endIndex] - begin - 1;
 161         // construct result
 162         byte[] result = new byte[len];
 163         System.arraycopy(path, begin, result, 0, len);
 164         return new ZipPath(zfs, result);
 165     }
 166 
 167     @Override
 168     public ZipPath toRealPath(LinkOption... options) throws IOException {
 169         ZipPath realPath;
 170         byte[] resolved = getResolvedPath();
 171         // resolved is always absolute and normalized
 172         if (resolved == path) {
 173             realPath = this;
 174         } else {
 175             realPath = new ZipPath(zfs, resolved, true);
 176             realPath.resolved = resolved;
 177         }
 178         realPath.checkAccess();
 179         return realPath;
 180     }
 181 
 182     boolean isHidden() {
 183         return false;
 184     }
 185 
 186     @Override
 187     public ZipPath toAbsolutePath() {
 188         if (isAbsolute()) {
 189             return this;
 190         } else {
 191             // add &#39;/&#39; before the existing path
 192             byte[] tmp = new byte[path.length + 1];
 193             System.arraycopy(path, 0, tmp, 1, path.length);
 194             tmp[0] = &#39;/&#39;;
 195             return new ZipPath(zfs, tmp, true);  // normalized
 196         }
 197     }
 198 
 199     @Override
 200     public URI toUri() {
 201         try {
 202             return new URI(&quot;jar&quot;,
 203                            decodeUri(zfs.getZipFile().toUri().toString()) +
 204                            &quot;!&quot; +
 205                            zfs.getString(toAbsolutePath().path),
 206                            null);
 207         } catch (Exception ex) {
 208             throw new AssertionError(ex);
 209         }
 210     }
 211 
 212     private boolean equalsNameAt(ZipPath other, int index) {
 213         int mbegin = offsets[index];
<a name="2" id="anc2"></a><span class="line-modified"> 214         int mlen = 0;</span>
 215         if (index == (offsets.length-1))
 216             mlen = path.length - mbegin;
 217         else
 218             mlen = offsets[index + 1] - mbegin - 1;
 219         int obegin = other.offsets[index];
<a name="3" id="anc3"></a><span class="line-modified"> 220         int olen = 0;</span>
 221         if (index == (other.offsets.length - 1))
 222             olen = other.path.length - obegin;
 223         else
 224             olen = other.offsets[index + 1] - obegin - 1;
 225         if (mlen != olen)
 226             return false;
 227         int n = 0;
 228         while(n &lt; mlen) {
 229             if (path[mbegin + n] != other.path[obegin + n])
 230                 return false;
 231             n++;
 232         }
 233         return true;
 234     }
 235 
 236     @Override
 237     public Path relativize(Path other) {
 238         final ZipPath o = checkPath(other);
 239         if (o.equals(this))
 240             return new ZipPath(zfs, new byte[0], true);
 241         if (this.path.length == 0)
 242             return o;
 243         if (this.zfs != o.zfs || this.isAbsolute() != o.isAbsolute())
 244             throw new IllegalArgumentException();
 245         if (this.path.length == 1 &amp;&amp; this.path[0] == &#39;/&#39;)
 246             return new ZipPath(zfs,
 247                                Arrays.copyOfRange(o.path, 1, o.path.length),
 248                                true);
 249         int mc = this.getNameCount();
 250         int oc = o.getNameCount();
 251         int n = Math.min(mc, oc);
 252         int i = 0;
 253         while (i &lt; n) {
 254             if (!equalsNameAt(o, i))
 255                 break;
 256             i++;
 257         }
 258         int dotdots = mc - i;
 259         int len = dotdots * 3 - 1;
 260         if (i &lt; oc)
 261             len += (o.path.length - o.offsets[i] + 1);
 262         byte[] result = new byte[len];
 263 
 264         int pos = 0;
 265         while (dotdots &gt; 0) {
 266             result[pos++] = (byte)&#39;.&#39;;
 267             result[pos++] = (byte)&#39;.&#39;;
 268             if (pos &lt; len)       // no tailing slash at the end
 269                 result[pos++] = (byte)&#39;/&#39;;
 270             dotdots--;
 271         }
 272         if (i &lt; oc)
 273             System.arraycopy(o.path, o.offsets[i],
 274                              result, pos,
 275                              o.path.length - o.offsets[i]);
 276         return new ZipPath(zfs, result);
 277     }
 278 
 279     @Override
 280     public ZipFileSystem getFileSystem() {
 281         return zfs;
 282     }
 283 
 284     @Override
 285     public boolean isAbsolute() {
 286         return path.length &gt; 0 &amp;&amp; path[0] == &#39;/&#39;;
 287     }
 288 
 289     @Override
 290     public ZipPath resolve(Path other) {
 291         ZipPath o = checkPath(other);
 292         if (o.path.length == 0)
 293             return this;
 294         if (o.isAbsolute() || this.path.length == 0)
 295             return o;
 296         return resolve(o.path);
 297     }
 298 
 299     // opath is normalized, just concat
 300     private ZipPath resolve(byte[] opath) {
<a name="4" id="anc4"></a><span class="line-modified"> 301         byte[] resolved = null;</span>
 302         byte[] tpath = this.path;
 303         int tlen = tpath.length;
 304         int olen = opath.length;
 305         if (path[tlen - 1] == &#39;/&#39;) {
 306             resolved = new byte[tlen + olen];
 307             System.arraycopy(tpath, 0, resolved, 0, tlen);
 308             System.arraycopy(opath, 0, resolved, tlen, olen);
 309         } else {
 310             resolved = new byte[tlen + 1 + olen];
 311             System.arraycopy(tpath, 0, resolved, 0, tlen);
 312             resolved[tlen] = &#39;/&#39;;
 313             System.arraycopy(opath, 0, resolved, tlen + 1, olen);
 314         }
 315         return new ZipPath(zfs, resolved, true);
 316     }
 317 
 318     @Override
 319     public Path resolveSibling(Path other) {
 320         Objects.requireNonNull(other, &quot;other&quot;);
 321         Path parent = getParent();
 322         return (parent == null) ? other : parent.resolve(other);
 323     }
 324 
 325     @Override
 326     public boolean startsWith(Path other) {
 327         Objects.requireNonNull(other, &quot;other&quot;);
 328         if (!(other instanceof ZipPath))
 329             return false;
 330         final ZipPath o = (ZipPath)other;
 331         if (o.isAbsolute() != this.isAbsolute() ||
 332             o.path.length &gt; this.path.length)
 333             return false;
 334         int olast = o.path.length;
 335         for (int i = 0; i &lt; olast; i++) {
 336             if (o.path[i] != this.path[i])
 337                 return false;
 338         }
 339         olast--;
 340         return o.path.length == this.path.length ||
 341                o.path[olast] == &#39;/&#39; ||
 342                this.path[olast + 1] == &#39;/&#39;;
 343     }
 344 
 345     @Override
 346     public boolean endsWith(Path other) {
 347         Objects.requireNonNull(other, &quot;other&quot;);
 348         if (!(other instanceof ZipPath))
 349             return false;
 350         final ZipPath o = (ZipPath)other;
 351         int olast = o.path.length - 1;
 352         if (olast &gt; 0 &amp;&amp; o.path[olast] == &#39;/&#39;)
 353             olast--;
 354         int last = this.path.length - 1;
 355         if (last &gt; 0 &amp;&amp; this.path[last] == &#39;/&#39;)
 356             last--;
 357         if (olast == -1)    // o.path.length == 0
 358             return last == -1;
 359         if ((o.isAbsolute() &amp;&amp;(!this.isAbsolute() || olast != last)) ||
 360             (last &lt; olast))
 361             return false;
 362         for (; olast &gt;= 0; olast--, last--) {
 363             if (o.path[olast] != this.path[last])
 364                 return false;
 365         }
 366         return o.path[olast + 1] == &#39;/&#39; ||
 367                last == -1 || this.path[last] == &#39;/&#39;;
 368     }
 369 
 370     @Override
 371     public ZipPath resolve(String other) {
 372         byte[] opath = normalize(other);
 373         if (opath.length == 0)
 374             return this;
 375         if (opath[0] == &#39;/&#39; || this.path.length == 0)
 376             return new ZipPath(zfs, opath, true);
 377         return resolve(opath);
 378     }
 379 
 380     @Override
 381     public final Path resolveSibling(String other) {
 382         return resolveSibling(zfs.getPath(other));
 383     }
 384 
 385     @Override
 386     public final boolean startsWith(String other) {
 387         return startsWith(zfs.getPath(other));
 388     }
 389 
 390     @Override
 391     public final boolean endsWith(String other) {
 392         return endsWith(zfs.getPath(other));
 393     }
 394 
 395     @Override
 396     public Path normalize() {
 397         byte[] resolved = getResolved();
 398         if (resolved == path)    // no change
 399             return this;
 400         return new ZipPath(zfs, resolved, true);
 401     }
 402 
 403     private ZipPath checkPath(Path path) {
 404         Objects.requireNonNull(path, &quot;path&quot;);
 405         if (!(path instanceof ZipPath))
 406             throw new ProviderMismatchException();
 407         return (ZipPath) path;
 408     }
 409 
 410     // create offset list if not already created
 411     private void initOffsets() {
 412         if (offsets == null) {
 413             int count, index;
 414             // count names
 415             count = 0;
 416             index = 0;
 417             if (path.length == 0) {
 418                 // empty path has one name
 419                 count = 1;
 420             } else {
 421                 while (index &lt; path.length) {
 422                     byte c = path[index++];
 423                     if (c != &#39;/&#39;) {
 424                         count++;
 425                         while (index &lt; path.length &amp;&amp; path[index] != &#39;/&#39;)
 426                              index++;
 427                     }
 428                 }
 429             }
 430             // populate offsets
 431             int[] result = new int[count];
 432             count = 0;
 433             index = 0;
 434             while (index &lt; path.length) {
 435                 byte c = path[index];
 436                 if (c == &#39;/&#39;) {
 437                     index++;
 438                 } else {
 439                     result[count++] = index++;
 440                     while (index &lt; path.length &amp;&amp; path[index] != &#39;/&#39;)
 441                         index++;
 442                 }
 443             }
 444             synchronized (this) {
 445                 if (offsets == null)
 446                     offsets = result;
 447             }
 448         }
 449     }
 450 
 451     // resolved path for locating zip entry inside the zip file,
 452     // the result path does not contain ./ and .. components
 453     private volatile byte[] resolved = null;
 454     byte[] getResolvedPath() {
 455         byte[] r = resolved;
 456         if (r == null) {
 457             if (isAbsolute())
 458                 r = getResolved();
 459             else
 460                 r = toAbsolutePath().getResolvedPath();
 461             resolved = r;
 462         }
 463         return resolved;
 464     }
 465 
 466     // removes redundant slashs, replace &quot;\&quot; to zip separator &quot;/&quot;
 467     // and check for invalid characters
 468     private byte[] normalize(byte[] path) {
 469         int len = path.length;
 470         if (len == 0)
 471             return path;
 472         byte prevC = 0;
 473         for (int i = 0; i &lt; len; i++) {
 474             byte c = path[i];
 475             if (c == &#39;\\&#39; || c == &#39;\u0000&#39;)
 476                 return normalize(path, i);
 477             if (c == (byte)&#39;/&#39; &amp;&amp; prevC == &#39;/&#39;)
 478                 return normalize(path, i - 1);
 479             prevC = c;
 480         }
 481         if (len &gt; 1 &amp;&amp; prevC == &#39;/&#39;) {
 482             return Arrays.copyOf(path, len - 1);
 483         }
 484         return path;
 485     }
 486 
 487     private byte[] normalize(byte[] path, int off) {
 488         byte[] to = new byte[path.length];
 489         int n = 0;
 490         while (n &lt; off) {
 491             to[n] = path[n];
 492             n++;
 493         }
 494         int m = n;
 495         byte prevC = 0;
 496         while (n &lt; path.length) {
 497             byte c = path[n++];
 498             if (c == (byte)&#39;\\&#39;)
 499                 c = (byte)&#39;/&#39;;
 500             if (c == (byte)&#39;/&#39; &amp;&amp; prevC == (byte)&#39;/&#39;)
 501                 continue;
 502             if (c == &#39;\u0000&#39;)
 503                 throw new InvalidPathException(zfs.getString(path),
 504                                                &quot;Path: nul character not allowed&quot;);
 505             to[m++] = c;
 506             prevC = c;
 507         }
 508         if (m &gt; 1 &amp;&amp; to[m - 1] == &#39;/&#39;)
 509             m--;
 510         return (m == to.length)? to : Arrays.copyOf(to, m);
 511     }
 512 
 513     // if zfs is NOT in utf8, normalize the path as &quot;String&quot;
 514     // to avoid incorrectly normalizing byte &#39;0x5c&#39; (as &#39;\&#39;)
 515     // to &#39;/&#39;.
 516     private byte[] normalize(String path) {
 517         if (zfs.zc.isUTF8())
 518             return normalize(zfs.getBytes(path));
 519         int len = path.length();
 520         if (len == 0)
 521             return new byte[0];
 522         char prevC = 0;
 523         for (int i = 0; i &lt; len; i++) {
 524             char c = path.charAt(i);
 525             if (c == &#39;\\&#39; || c == &#39;\u0000&#39;)
 526                 return normalize(path, i, len);
 527             if (c == &#39;/&#39; &amp;&amp; prevC == &#39;/&#39;)
 528                 return normalize(path, i - 1, len);
 529             prevC = c;
 530         }
 531         if (len &gt; 1 &amp;&amp; prevC == &#39;/&#39;)
 532             path = path.substring(0, len - 1);
 533         return zfs.getBytes(path);
 534     }
 535 
 536     private byte[] normalize(String path, int off, int len) {
 537         StringBuilder to = new StringBuilder(len);
 538         to.append(path, 0, off);
 539         char prevC = 0;
 540         while (off &lt; len) {
 541             char c = path.charAt(off++);
 542             if (c == &#39;\\&#39;)
 543                 c = &#39;/&#39;;
 544             if (c == &#39;/&#39; &amp;&amp; prevC == &#39;/&#39;)
 545                 continue;
 546             if (c == &#39;\u0000&#39;)
 547                 throw new InvalidPathException(path,
 548                                                &quot;Path: nul character not allowed&quot;);
 549             to.append(c);
 550             prevC = c;
 551         }
 552         len = to.length();
 553         if (len &gt; 1 &amp;&amp; prevC == &#39;/&#39;)
 554             to.delete(len -1, len);
 555         return zfs.getBytes(to.toString());
 556     }
 557 
 558     // Remove DotSlash(./) and resolve DotDot (..) components
 559     private byte[] getResolved() {
 560         for (int i = 0; i &lt; path.length; i++) {
 561             if (path[i] == (byte)&#39;.&#39; &amp;&amp;
 562                 (i + 1 == path.length || path[i + 1] == &#39;/&#39;)) {
 563                 return resolve0();
 564             }
 565         }
 566         return path;
 567     }
 568 
 569     // TBD: performance, avoid initOffsets
 570     private byte[] resolve0() {
 571         byte[] to = new byte[path.length];
 572         int nc = getNameCount();
 573         int[] lastM = new int[nc];
 574         int lastMOff = -1;
 575         int m = 0;
 576         for (int i = 0; i &lt; nc; i++) {
 577             int n = offsets[i];
 578             int len = (i == offsets.length - 1)?
 579                       (path.length - n):(offsets[i + 1] - n - 1);
 580             if (len == 1 &amp;&amp; path[n] == (byte)&#39;.&#39;) {
 581                 if (m == 0 &amp;&amp; path[0] == &#39;/&#39;)   // absolute path
 582                     to[m++] = &#39;/&#39;;
 583                 continue;
 584             }
 585             if (len == 2 &amp;&amp; path[n] == &#39;.&#39; &amp;&amp; path[n + 1] == &#39;.&#39;) {
 586                 if (lastMOff &gt;= 0) {
 587                     m = lastM[lastMOff--];  // retreat
 588                     continue;
 589                 }
 590                 if (path[0] == &#39;/&#39;) {  // &quot;/../xyz&quot; skip
 591                     if (m == 0)
 592                         to[m++] = &#39;/&#39;;
 593                 } else {               // &quot;../xyz&quot; -&gt; &quot;../xyz&quot;
 594                     if (m != 0 &amp;&amp; to[m-1] != &#39;/&#39;)
 595                         to[m++] = &#39;/&#39;;
 596                     while (len-- &gt; 0)
 597                         to[m++] = path[n++];
 598                 }
 599                 continue;
 600             }
 601             if (m == 0 &amp;&amp; path[0] == &#39;/&#39; ||   // absolute path
 602                 m != 0 &amp;&amp; to[m-1] != &#39;/&#39;) {   // not the first name
 603                 to[m++] = &#39;/&#39;;
 604             }
 605             lastM[++lastMOff] = m;
 606             while (len-- &gt; 0)
 607                 to[m++] = path[n++];
 608         }
 609         if (m &gt; 1 &amp;&amp; to[m - 1] == &#39;/&#39;)
 610             m--;
 611         return (m == to.length)? to : Arrays.copyOf(to, m);
 612     }
 613 
 614     @Override
 615     public String toString() {
 616         return zfs.getString(path);
 617     }
 618 
 619     @Override
 620     public int hashCode() {
 621         int h = hashcode;
 622         if (h == 0)
 623             hashcode = h = Arrays.hashCode(path);
 624         return h;
 625     }
 626 
 627     @Override
 628     public boolean equals(Object obj) {
<a name="5" id="anc5"></a><span class="line-modified"> 629         return obj != null &amp;&amp;</span>
<span class="line-modified"> 630                obj instanceof ZipPath &amp;&amp;</span>
<span class="line-removed"> 631                this.zfs == ((ZipPath)obj).zfs &amp;&amp;</span>
 632                compareTo((Path) obj) == 0;
 633     }
 634 
 635     @Override
 636     public int compareTo(Path other) {
 637         final ZipPath o = checkPath(other);
 638         int len1 = this.path.length;
 639         int len2 = o.path.length;
 640 
 641         int n = Math.min(len1, len2);
<a name="6" id="anc6"></a><span class="line-removed"> 642         byte v1[] = this.path;</span>
<span class="line-removed"> 643         byte v2[] = o.path;</span>
 644 
 645         int k = 0;
 646         while (k &lt; n) {
<a name="7" id="anc7"></a><span class="line-modified"> 647             int c1 = v1[k] &amp; 0xff;</span>
<span class="line-modified"> 648             int c2 = v2[k] &amp; 0xff;</span>
 649             if (c1 != c2)
 650                 return c1 - c2;
 651             k++;
 652         }
 653         return len1 - len2;
 654     }
 655 
 656     public WatchKey register(
 657             WatchService watcher,
 658             WatchEvent.Kind&lt;?&gt;[] events,
 659             WatchEvent.Modifier... modifiers) {
 660         if (watcher == null || events == null || modifiers == null) {
 661             throw new NullPointerException();
 662         }
 663         // watcher must be associated with a different provider
 664         throw new ProviderMismatchException();
 665     }
 666 
 667     @Override
 668     public WatchKey register(WatchService watcher, WatchEvent.Kind&lt;?&gt;... events) {
 669         return register(watcher, events, new WatchEvent.Modifier[0]);
 670     }
 671 
 672     @Override
 673     public final File toFile() {
 674         throw new UnsupportedOperationException();
 675     }
 676 
 677     @Override
 678     public Iterator&lt;Path&gt; iterator() {
<a name="8" id="anc8"></a><span class="line-modified"> 679         return new Iterator&lt;Path&gt;() {</span>
 680             private int i = 0;
 681 
 682             @Override
 683             public boolean hasNext() {
 684                 return (i &lt; getNameCount());
 685             }
 686 
 687             @Override
 688             public Path next() {
 689                 if (i &lt; getNameCount()) {
 690                     Path result = getName(i);
 691                     i++;
 692                     return result;
 693                 } else {
 694                     throw new NoSuchElementException();
 695                 }
 696             }
 697 
 698             @Override
 699             public void remove() {
 700                 throw new ReadOnlyFileSystemException();
 701             }
 702         };
 703     }
 704 
 705     /////////////////////////////////////////////////////////////////////
 706 
<a name="9" id="anc9"></a>
































 707     void createDirectory(FileAttribute&lt;?&gt;... attrs)
 708         throws IOException
 709     {
 710         zfs.createDirectory(getResolvedPath(), attrs);
 711     }
 712 
 713     InputStream newInputStream(OpenOption... options) throws IOException
 714     {
 715         if (options.length &gt; 0) {
 716             for (OpenOption opt : options) {
 717                 if (opt != READ)
 718                     throw new UnsupportedOperationException(&quot;&#39;&quot; + opt + &quot;&#39; not allowed&quot;);
 719             }
 720         }
 721         return zfs.newInputStream(getResolvedPath());
 722     }
 723 
 724     DirectoryStream&lt;Path&gt; newDirectoryStream(Filter&lt;? super Path&gt; filter)
 725         throws IOException
 726     {
 727         return new ZipDirectoryStream(this, filter);
 728     }
 729 
 730     void delete() throws IOException {
 731         zfs.deleteFile(getResolvedPath(), true);
 732     }
 733 
<a name="10" id="anc10"></a><span class="line-modified"> 734     void deleteIfExists() throws IOException {</span>
 735         zfs.deleteFile(getResolvedPath(), false);
 736     }
 737 
<a name="11" id="anc11"></a><span class="line-modified"> 738     ZipFileAttributes getAttributes() throws IOException</span>
<span class="line-removed"> 739     {</span>
 740         ZipFileAttributes zfas = zfs.getFileAttributes(getResolvedPath());
 741         if (zfas == null)
 742             throw new NoSuchFileException(toString());
 743         return zfas;
 744     }
 745 
<a name="12" id="anc12"></a>















 746     void setAttribute(String attribute, Object value, LinkOption... options)
 747         throws IOException
 748     {
<a name="13" id="anc13"></a><span class="line-modified"> 749         String type = null;</span>
<span class="line-modified"> 750         String attr = null;</span>
 751         int colonPos = attribute.indexOf(&#39;:&#39;);
 752         if (colonPos == -1) {
 753             type = &quot;basic&quot;;
 754             attr = attribute;
 755         } else {
 756             type = attribute.substring(0, colonPos++);
 757             attr = attribute.substring(colonPos);
 758         }
<a name="14" id="anc14"></a><span class="line-modified"> 759         ZipFileAttributeView view = ZipFileAttributeView.get(this, type);</span>
<span class="line-removed"> 760         if (view == null)</span>
<span class="line-removed"> 761             throw new UnsupportedOperationException(&quot;view &lt;&quot; + view + &quot;&gt; is not supported&quot;);</span>
<span class="line-removed"> 762         view.setAttribute(attr, value);</span>
 763     }
 764 
 765     void setTimes(FileTime mtime, FileTime atime, FileTime ctime)
 766         throws IOException
 767     {
 768         zfs.setTimes(getResolvedPath(), mtime, atime, ctime);
 769     }
 770 
<a name="15" id="anc15"></a><span class="line-modified"> 771     Map&lt;String, Object&gt; readAttributes(String attributes, LinkOption... options)</span>




 772         throws IOException
<a name="16" id="anc16"></a>


 773 
<a name="17" id="anc17"></a>





 774     {
<a name="18" id="anc18"></a><span class="line-modified"> 775         String view = null;</span>
<span class="line-modified"> 776         String attrs = null;</span>
 777         int colonPos = attributes.indexOf(&#39;:&#39;);
 778         if (colonPos == -1) {
 779             view = &quot;basic&quot;;
 780             attrs = attributes;
 781         } else {
 782             view = attributes.substring(0, colonPos++);
 783             attrs = attributes.substring(colonPos);
 784         }
<a name="19" id="anc19"></a><span class="line-modified"> 785         ZipFileAttributeView zfv = ZipFileAttributeView.get(this, view);</span>
<span class="line-removed"> 786         if (zfv == null) {</span>
<span class="line-removed"> 787             throw new UnsupportedOperationException(&quot;view not supported&quot;);</span>
<span class="line-removed"> 788         }</span>
<span class="line-removed"> 789         return zfv.readAttributes(attrs);</span>
 790     }
 791 
 792     FileStore getFileStore() throws IOException {
 793         // each ZipFileSystem only has one root (as requested for now)
 794         if (exists())
 795             return zfs.getFileStore(this);
 796         throw new NoSuchFileException(zfs.getString(path));
 797     }
 798 
 799     boolean isSameFile(Path other) throws IOException {
 800         if (this.equals(other))
 801             return true;
 802         if (other == null ||
 803             this.getFileSystem() != other.getFileSystem())
 804             return false;
 805         this.checkAccess();
 806         ((ZipPath)other).checkAccess();
 807         return Arrays.equals(this.getResolvedPath(),
 808                              ((ZipPath)other).getResolvedPath());
 809     }
 810 
 811     SeekableByteChannel newByteChannel(Set&lt;? extends OpenOption&gt; options,
 812                                        FileAttribute&lt;?&gt;... attrs)
 813         throws IOException
 814     {
 815         return zfs.newByteChannel(getResolvedPath(), options, attrs);
 816     }
 817 
 818 
 819     FileChannel newFileChannel(Set&lt;? extends OpenOption&gt; options,
 820                                FileAttribute&lt;?&gt;... attrs)
 821         throws IOException
 822     {
 823         return zfs.newFileChannel(getResolvedPath(), options, attrs);
 824     }
 825 
 826     void checkAccess(AccessMode... modes) throws IOException {
 827         boolean w = false;
 828         boolean x = false;
 829         for (AccessMode mode : modes) {
 830             switch (mode) {
 831                 case READ:
 832                     break;
 833                 case WRITE:
 834                     w = true;
 835                     break;
 836                 case EXECUTE:
 837                     x = true;
 838                     break;
 839                 default:
 840                     throw new UnsupportedOperationException();
 841             }
 842         }
 843         zfs.checkAccess(getResolvedPath());
 844         if ((w &amp;&amp; zfs.isReadOnly()) || x) {
 845             throw new AccessDeniedException(toString());
 846         }
 847     }
 848 
<a name="20" id="anc20"></a><span class="line-modified"> 849     boolean exists() {</span>
<span class="line-modified"> 850         try {</span>
<span class="line-removed"> 851             return zfs.exists(getResolvedPath());</span>
<span class="line-removed"> 852         } catch (IOException x) {}</span>
<span class="line-removed"> 853         return false;</span>
 854     }
 855 
 856     OutputStream newOutputStream(OpenOption... options) throws IOException
 857     {
 858         if (options.length == 0)
 859             return zfs.newOutputStream(getResolvedPath(),
 860                                        CREATE, TRUNCATE_EXISTING, WRITE);
 861         return zfs.newOutputStream(getResolvedPath(), options);
 862     }
 863 
 864     void move(ZipPath target, CopyOption... options)
 865         throws IOException
 866     {
 867         if (Files.isSameFile(this.zfs.getZipFile(), target.zfs.getZipFile()))
 868         {
 869             zfs.copyFile(true,
 870                          getResolvedPath(), target.getResolvedPath(),
 871                          options);
 872         } else {
 873             copyToTarget(target, options);
 874             delete();
 875         }
 876     }
 877 
 878     void copy(ZipPath target, CopyOption... options)
 879         throws IOException
 880     {
 881         if (Files.isSameFile(this.zfs.getZipFile(), target.zfs.getZipFile()))
 882             zfs.copyFile(false,
 883                          getResolvedPath(), target.getResolvedPath(),
 884                          options);
 885         else
 886             copyToTarget(target, options);
 887     }
 888 
 889     private void copyToTarget(ZipPath target, CopyOption... options)
 890         throws IOException
 891     {
 892         boolean replaceExisting = false;
 893         boolean copyAttrs = false;
 894         for (CopyOption opt : options) {
 895             if (opt == REPLACE_EXISTING)
 896                 replaceExisting = true;
 897             else if (opt == COPY_ATTRIBUTES)
 898                 copyAttrs = true;
 899         }
 900         // attributes of source file
<a name="21" id="anc21"></a><span class="line-modified"> 901         ZipFileAttributes zfas = getAttributes();</span>
 902         // check if target exists
 903         boolean exists;
 904         if (replaceExisting) {
 905             try {
 906                 target.deleteIfExists();
 907                 exists = false;
 908             } catch (DirectoryNotEmptyException x) {
 909                 exists = true;
 910             }
 911         } else {
 912             exists = target.exists();
 913         }
 914         if (exists)
 915             throw new FileAlreadyExistsException(target.toString());
 916 
 917         if (zfas.isDirectory()) {
 918             // create directory or file
 919             target.createDirectory();
 920         } else {
<a name="22" id="anc22"></a><span class="line-modified"> 921             InputStream is = zfs.newInputStream(getResolvedPath());</span>
<span class="line-modified"> 922             try {</span>
<span class="line-modified"> 923                 OutputStream os = target.newOutputStream();</span>
<span class="line-modified"> 924                 try {</span>
<span class="line-modified"> 925                     byte[] buf = new byte[8192];</span>
<span class="line-modified"> 926                     int n = 0;</span>
<span class="line-modified"> 927                     while ((n = is.read(buf)) != -1) {</span>
<span class="line-removed"> 928                         os.write(buf, 0, n);</span>
<span class="line-removed"> 929                     }</span>
<span class="line-removed"> 930                 } finally {</span>
<span class="line-removed"> 931                     os.close();</span>
 932                 }
<a name="23" id="anc23"></a><span class="line-removed"> 933             } finally {</span>
<span class="line-removed"> 934                 is.close();</span>
 935             }
 936         }
 937         if (copyAttrs) {
<a name="24" id="anc24"></a><span class="line-modified"> 938             BasicFileAttributeView view =</span>
<span class="line-modified"> 939                 ZipFileAttributeView.get(target, BasicFileAttributeView.class);</span>
 940             try {
 941                 view.setTimes(zfas.lastModifiedTime(),
 942                               zfas.lastAccessTime(),
 943                               zfas.creationTime());
<a name="25" id="anc25"></a>

 944             } catch (IOException x) {
 945                 // rollback?
 946                 try {
 947                     target.delete();
 948                 } catch (IOException ignore) { }
 949                 throw x;
 950             }
 951         }
 952     }
 953 
 954     private static int decode(char c) {
 955         if ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;))
 956             return c - &#39;0&#39;;
 957         if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;f&#39;))
 958             return c - &#39;a&#39; + 10;
 959         if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;F&#39;))
 960             return c - &#39;A&#39; + 10;
 961         assert false;
 962         return -1;
 963     }
 964 
 965     // to avoid double escape
<a name="26" id="anc26"></a><span class="line-modified"> 966     static String decodeUri(String s) {</span>
 967         if (s == null)
<a name="27" id="anc27"></a><span class="line-modified"> 968             return s;</span>
 969         int n = s.length();
 970         if (n == 0)
 971             return s;
 972         if (s.indexOf(&#39;%&#39;) &lt; 0)
 973             return s;
 974 
 975         StringBuilder sb = new StringBuilder(n);
 976         byte[] bb = new byte[n];
 977         boolean betweenBrackets = false;
 978 
 979         for (int i = 0; i &lt; n;) {
 980             char c = s.charAt(i);
 981             if (c == &#39;[&#39;) {
 982                 betweenBrackets = true;
 983             } else if (betweenBrackets &amp;&amp; c == &#39;]&#39;) {
 984                 betweenBrackets = false;
 985             }
 986             if (c != &#39;%&#39; || betweenBrackets ) {
 987                 sb.append(c);
 988                 i++;
 989                 continue;
 990             }
 991             int nb = 0;
 992             while (c == &#39;%&#39;) {
 993                 assert (n - i &gt;= 2);
 994                 bb[nb++] = (byte)(((decode(s.charAt(++i)) &amp; 0xf) &lt;&lt; 4) |
 995                                   (decode(s.charAt(++i)) &amp; 0xf));
 996                 if (++i &gt;= n) {
 997                     break;
 998                 }
 999                 c = s.charAt(i);
1000             }
1001             sb.append(new String(bb, 0, nb, UTF_8));
1002         }
1003         return sb.toString();
1004     }
1005 }
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
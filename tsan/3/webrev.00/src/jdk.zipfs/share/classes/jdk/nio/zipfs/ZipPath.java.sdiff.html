<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipPath.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ZipInfo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipUtils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipPath.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.nio.zipfs;
  27 
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.OutputStream;
  32 import java.net.URI;
  33 import java.nio.channels.FileChannel;
  34 import java.nio.channels.SeekableByteChannel;
  35 import java.nio.file.*;
  36 import java.nio.file.DirectoryStream.Filter;
<span class="line-modified">  37 import java.nio.file.attribute.BasicFileAttributeView;</span>
<span class="line-removed">  38 import java.nio.file.attribute.FileAttribute;</span>
<span class="line-removed">  39 import java.nio.file.attribute.FileTime;</span>
  40 import java.util.Arrays;
  41 import java.util.Iterator;
  42 import java.util.Map;
  43 import java.util.NoSuchElementException;
  44 import java.util.Objects;
  45 import java.util.Set;
  46 
  47 import static java.nio.charset.StandardCharsets.UTF_8;
  48 import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;
  49 import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
  50 import static java.nio.file.StandardOpenOption.CREATE;
  51 import static java.nio.file.StandardOpenOption.READ;
  52 import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;
  53 import static java.nio.file.StandardOpenOption.WRITE;
  54 
  55 /**
  56  * @author Xueming Shen, Rajendra Gutupalli,Jaya Hangal
  57  */
  58 final class ZipPath implements Path {
  59 
</pre>
<hr />
<pre>
 194             tmp[0] = &#39;/&#39;;
 195             return new ZipPath(zfs, tmp, true);  // normalized
 196         }
 197     }
 198 
 199     @Override
 200     public URI toUri() {
 201         try {
 202             return new URI(&quot;jar&quot;,
 203                            decodeUri(zfs.getZipFile().toUri().toString()) +
 204                            &quot;!&quot; +
 205                            zfs.getString(toAbsolutePath().path),
 206                            null);
 207         } catch (Exception ex) {
 208             throw new AssertionError(ex);
 209         }
 210     }
 211 
 212     private boolean equalsNameAt(ZipPath other, int index) {
 213         int mbegin = offsets[index];
<span class="line-modified"> 214         int mlen = 0;</span>
 215         if (index == (offsets.length-1))
 216             mlen = path.length - mbegin;
 217         else
 218             mlen = offsets[index + 1] - mbegin - 1;
 219         int obegin = other.offsets[index];
<span class="line-modified"> 220         int olen = 0;</span>
 221         if (index == (other.offsets.length - 1))
 222             olen = other.path.length - obegin;
 223         else
 224             olen = other.offsets[index + 1] - obegin - 1;
 225         if (mlen != olen)
 226             return false;
 227         int n = 0;
 228         while(n &lt; mlen) {
 229             if (path[mbegin + n] != other.path[obegin + n])
 230                 return false;
 231             n++;
 232         }
 233         return true;
 234     }
 235 
 236     @Override
 237     public Path relativize(Path other) {
 238         final ZipPath o = checkPath(other);
 239         if (o.equals(this))
 240             return new ZipPath(zfs, new byte[0], true);
</pre>
<hr />
<pre>
 281         return zfs;
 282     }
 283 
 284     @Override
 285     public boolean isAbsolute() {
 286         return path.length &gt; 0 &amp;&amp; path[0] == &#39;/&#39;;
 287     }
 288 
 289     @Override
 290     public ZipPath resolve(Path other) {
 291         ZipPath o = checkPath(other);
 292         if (o.path.length == 0)
 293             return this;
 294         if (o.isAbsolute() || this.path.length == 0)
 295             return o;
 296         return resolve(o.path);
 297     }
 298 
 299     // opath is normalized, just concat
 300     private ZipPath resolve(byte[] opath) {
<span class="line-modified"> 301         byte[] resolved = null;</span>
 302         byte[] tpath = this.path;
 303         int tlen = tpath.length;
 304         int olen = opath.length;
 305         if (path[tlen - 1] == &#39;/&#39;) {
 306             resolved = new byte[tlen + olen];
 307             System.arraycopy(tpath, 0, resolved, 0, tlen);
 308             System.arraycopy(opath, 0, resolved, tlen, olen);
 309         } else {
 310             resolved = new byte[tlen + 1 + olen];
 311             System.arraycopy(tpath, 0, resolved, 0, tlen);
 312             resolved[tlen] = &#39;/&#39;;
 313             System.arraycopy(opath, 0, resolved, tlen + 1, olen);
 314         }
 315         return new ZipPath(zfs, resolved, true);
 316     }
 317 
 318     @Override
 319     public Path resolveSibling(Path other) {
 320         Objects.requireNonNull(other, &quot;other&quot;);
 321         Path parent = getParent();
</pre>
<hr />
<pre>
 609         if (m &gt; 1 &amp;&amp; to[m - 1] == &#39;/&#39;)
 610             m--;
 611         return (m == to.length)? to : Arrays.copyOf(to, m);
 612     }
 613 
 614     @Override
 615     public String toString() {
 616         return zfs.getString(path);
 617     }
 618 
 619     @Override
 620     public int hashCode() {
 621         int h = hashcode;
 622         if (h == 0)
 623             hashcode = h = Arrays.hashCode(path);
 624         return h;
 625     }
 626 
 627     @Override
 628     public boolean equals(Object obj) {
<span class="line-modified"> 629         return obj != null &amp;&amp;</span>
<span class="line-modified"> 630                obj instanceof ZipPath &amp;&amp;</span>
<span class="line-removed"> 631                this.zfs == ((ZipPath)obj).zfs &amp;&amp;</span>
 632                compareTo((Path) obj) == 0;
 633     }
 634 
 635     @Override
 636     public int compareTo(Path other) {
 637         final ZipPath o = checkPath(other);
 638         int len1 = this.path.length;
 639         int len2 = o.path.length;
 640 
 641         int n = Math.min(len1, len2);
<span class="line-removed"> 642         byte v1[] = this.path;</span>
<span class="line-removed"> 643         byte v2[] = o.path;</span>
 644 
 645         int k = 0;
 646         while (k &lt; n) {
<span class="line-modified"> 647             int c1 = v1[k] &amp; 0xff;</span>
<span class="line-modified"> 648             int c2 = v2[k] &amp; 0xff;</span>
 649             if (c1 != c2)
 650                 return c1 - c2;
 651             k++;
 652         }
 653         return len1 - len2;
 654     }
 655 
 656     public WatchKey register(
 657             WatchService watcher,
 658             WatchEvent.Kind&lt;?&gt;[] events,
 659             WatchEvent.Modifier... modifiers) {
 660         if (watcher == null || events == null || modifiers == null) {
 661             throw new NullPointerException();
 662         }
 663         // watcher must be associated with a different provider
 664         throw new ProviderMismatchException();
 665     }
 666 
 667     @Override
 668     public WatchKey register(WatchService watcher, WatchEvent.Kind&lt;?&gt;... events) {
 669         return register(watcher, events, new WatchEvent.Modifier[0]);
 670     }
 671 
 672     @Override
 673     public final File toFile() {
 674         throw new UnsupportedOperationException();
 675     }
 676 
 677     @Override
 678     public Iterator&lt;Path&gt; iterator() {
<span class="line-modified"> 679         return new Iterator&lt;Path&gt;() {</span>
 680             private int i = 0;
 681 
 682             @Override
 683             public boolean hasNext() {
 684                 return (i &lt; getNameCount());
 685             }
 686 
 687             @Override
 688             public Path next() {
 689                 if (i &lt; getNameCount()) {
 690                     Path result = getName(i);
 691                     i++;
 692                     return result;
 693                 } else {
 694                     throw new NoSuchElementException();
 695                 }
 696             }
 697 
 698             @Override
 699             public void remove() {
 700                 throw new ReadOnlyFileSystemException();
 701             }
 702         };
 703     }
 704 
 705     /////////////////////////////////////////////////////////////////////
 706 

































 707     void createDirectory(FileAttribute&lt;?&gt;... attrs)
 708         throws IOException
 709     {
 710         zfs.createDirectory(getResolvedPath(), attrs);
 711     }
 712 
 713     InputStream newInputStream(OpenOption... options) throws IOException
 714     {
 715         if (options.length &gt; 0) {
 716             for (OpenOption opt : options) {
 717                 if (opt != READ)
 718                     throw new UnsupportedOperationException(&quot;&#39;&quot; + opt + &quot;&#39; not allowed&quot;);
 719             }
 720         }
 721         return zfs.newInputStream(getResolvedPath());
 722     }
 723 
 724     DirectoryStream&lt;Path&gt; newDirectoryStream(Filter&lt;? super Path&gt; filter)
 725         throws IOException
 726     {
 727         return new ZipDirectoryStream(this, filter);
 728     }
 729 
 730     void delete() throws IOException {
 731         zfs.deleteFile(getResolvedPath(), true);
 732     }
 733 
<span class="line-modified"> 734     void deleteIfExists() throws IOException {</span>
 735         zfs.deleteFile(getResolvedPath(), false);
 736     }
 737 
<span class="line-modified"> 738     ZipFileAttributes getAttributes() throws IOException</span>
<span class="line-removed"> 739     {</span>
 740         ZipFileAttributes zfas = zfs.getFileAttributes(getResolvedPath());
 741         if (zfas == null)
 742             throw new NoSuchFileException(toString());
 743         return zfas;
 744     }
 745 
















 746     void setAttribute(String attribute, Object value, LinkOption... options)
 747         throws IOException
 748     {
<span class="line-modified"> 749         String type = null;</span>
<span class="line-modified"> 750         String attr = null;</span>
 751         int colonPos = attribute.indexOf(&#39;:&#39;);
 752         if (colonPos == -1) {
 753             type = &quot;basic&quot;;
 754             attr = attribute;
 755         } else {
 756             type = attribute.substring(0, colonPos++);
 757             attr = attribute.substring(colonPos);
 758         }
<span class="line-modified"> 759         ZipFileAttributeView view = ZipFileAttributeView.get(this, type);</span>
<span class="line-removed"> 760         if (view == null)</span>
<span class="line-removed"> 761             throw new UnsupportedOperationException(&quot;view &lt;&quot; + view + &quot;&gt; is not supported&quot;);</span>
<span class="line-removed"> 762         view.setAttribute(attr, value);</span>
 763     }
 764 
 765     void setTimes(FileTime mtime, FileTime atime, FileTime ctime)
 766         throws IOException
 767     {
 768         zfs.setTimes(getResolvedPath(), mtime, atime, ctime);
 769     }
 770 
<span class="line-modified"> 771     Map&lt;String, Object&gt; readAttributes(String attributes, LinkOption... options)</span>




 772         throws IOException



 773 






 774     {
<span class="line-modified"> 775         String view = null;</span>
<span class="line-modified"> 776         String attrs = null;</span>
 777         int colonPos = attributes.indexOf(&#39;:&#39;);
 778         if (colonPos == -1) {
 779             view = &quot;basic&quot;;
 780             attrs = attributes;
 781         } else {
 782             view = attributes.substring(0, colonPos++);
 783             attrs = attributes.substring(colonPos);
 784         }
<span class="line-modified"> 785         ZipFileAttributeView zfv = ZipFileAttributeView.get(this, view);</span>
<span class="line-removed"> 786         if (zfv == null) {</span>
<span class="line-removed"> 787             throw new UnsupportedOperationException(&quot;view not supported&quot;);</span>
<span class="line-removed"> 788         }</span>
<span class="line-removed"> 789         return zfv.readAttributes(attrs);</span>
 790     }
 791 
 792     FileStore getFileStore() throws IOException {
 793         // each ZipFileSystem only has one root (as requested for now)
 794         if (exists())
 795             return zfs.getFileStore(this);
 796         throw new NoSuchFileException(zfs.getString(path));
 797     }
 798 
 799     boolean isSameFile(Path other) throws IOException {
 800         if (this.equals(other))
 801             return true;
 802         if (other == null ||
 803             this.getFileSystem() != other.getFileSystem())
 804             return false;
 805         this.checkAccess();
 806         ((ZipPath)other).checkAccess();
 807         return Arrays.equals(this.getResolvedPath(),
 808                              ((ZipPath)other).getResolvedPath());
 809     }
</pre>
<hr />
<pre>
 829         for (AccessMode mode : modes) {
 830             switch (mode) {
 831                 case READ:
 832                     break;
 833                 case WRITE:
 834                     w = true;
 835                     break;
 836                 case EXECUTE:
 837                     x = true;
 838                     break;
 839                 default:
 840                     throw new UnsupportedOperationException();
 841             }
 842         }
 843         zfs.checkAccess(getResolvedPath());
 844         if ((w &amp;&amp; zfs.isReadOnly()) || x) {
 845             throw new AccessDeniedException(toString());
 846         }
 847     }
 848 
<span class="line-modified"> 849     boolean exists() {</span>
<span class="line-modified"> 850         try {</span>
<span class="line-removed"> 851             return zfs.exists(getResolvedPath());</span>
<span class="line-removed"> 852         } catch (IOException x) {}</span>
<span class="line-removed"> 853         return false;</span>
 854     }
 855 
 856     OutputStream newOutputStream(OpenOption... options) throws IOException
 857     {
 858         if (options.length == 0)
 859             return zfs.newOutputStream(getResolvedPath(),
 860                                        CREATE, TRUNCATE_EXISTING, WRITE);
 861         return zfs.newOutputStream(getResolvedPath(), options);
 862     }
 863 
 864     void move(ZipPath target, CopyOption... options)
 865         throws IOException
 866     {
 867         if (Files.isSameFile(this.zfs.getZipFile(), target.zfs.getZipFile()))
 868         {
 869             zfs.copyFile(true,
 870                          getResolvedPath(), target.getResolvedPath(),
 871                          options);
 872         } else {
 873             copyToTarget(target, options);
</pre>
<hr />
<pre>
 881         if (Files.isSameFile(this.zfs.getZipFile(), target.zfs.getZipFile()))
 882             zfs.copyFile(false,
 883                          getResolvedPath(), target.getResolvedPath(),
 884                          options);
 885         else
 886             copyToTarget(target, options);
 887     }
 888 
 889     private void copyToTarget(ZipPath target, CopyOption... options)
 890         throws IOException
 891     {
 892         boolean replaceExisting = false;
 893         boolean copyAttrs = false;
 894         for (CopyOption opt : options) {
 895             if (opt == REPLACE_EXISTING)
 896                 replaceExisting = true;
 897             else if (opt == COPY_ATTRIBUTES)
 898                 copyAttrs = true;
 899         }
 900         // attributes of source file
<span class="line-modified"> 901         ZipFileAttributes zfas = getAttributes();</span>
 902         // check if target exists
 903         boolean exists;
 904         if (replaceExisting) {
 905             try {
 906                 target.deleteIfExists();
 907                 exists = false;
 908             } catch (DirectoryNotEmptyException x) {
 909                 exists = true;
 910             }
 911         } else {
 912             exists = target.exists();
 913         }
 914         if (exists)
 915             throw new FileAlreadyExistsException(target.toString());
 916 
 917         if (zfas.isDirectory()) {
 918             // create directory or file
 919             target.createDirectory();
 920         } else {
<span class="line-modified"> 921             InputStream is = zfs.newInputStream(getResolvedPath());</span>
<span class="line-modified"> 922             try {</span>
<span class="line-modified"> 923                 OutputStream os = target.newOutputStream();</span>
<span class="line-modified"> 924                 try {</span>
<span class="line-modified"> 925                     byte[] buf = new byte[8192];</span>
<span class="line-modified"> 926                     int n = 0;</span>
<span class="line-modified"> 927                     while ((n = is.read(buf)) != -1) {</span>
<span class="line-removed"> 928                         os.write(buf, 0, n);</span>
<span class="line-removed"> 929                     }</span>
<span class="line-removed"> 930                 } finally {</span>
<span class="line-removed"> 931                     os.close();</span>
 932                 }
<span class="line-removed"> 933             } finally {</span>
<span class="line-removed"> 934                 is.close();</span>
 935             }
 936         }
 937         if (copyAttrs) {
<span class="line-modified"> 938             BasicFileAttributeView view =</span>
<span class="line-modified"> 939                 ZipFileAttributeView.get(target, BasicFileAttributeView.class);</span>
 940             try {
 941                 view.setTimes(zfas.lastModifiedTime(),
 942                               zfas.lastAccessTime(),
 943                               zfas.creationTime());


 944             } catch (IOException x) {
 945                 // rollback?
 946                 try {
 947                     target.delete();
 948                 } catch (IOException ignore) { }
 949                 throw x;
 950             }
 951         }
 952     }
 953 
 954     private static int decode(char c) {
 955         if ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;))
 956             return c - &#39;0&#39;;
 957         if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;f&#39;))
 958             return c - &#39;a&#39; + 10;
 959         if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;F&#39;))
 960             return c - &#39;A&#39; + 10;
 961         assert false;
 962         return -1;
 963     }
 964 
 965     // to avoid double escape
<span class="line-modified"> 966     static String decodeUri(String s) {</span>
 967         if (s == null)
<span class="line-modified"> 968             return s;</span>
 969         int n = s.length();
 970         if (n == 0)
 971             return s;
 972         if (s.indexOf(&#39;%&#39;) &lt; 0)
 973             return s;
 974 
 975         StringBuilder sb = new StringBuilder(n);
 976         byte[] bb = new byte[n];
 977         boolean betweenBrackets = false;
 978 
 979         for (int i = 0; i &lt; n;) {
 980             char c = s.charAt(i);
 981             if (c == &#39;[&#39;) {
 982                 betweenBrackets = true;
 983             } else if (betweenBrackets &amp;&amp; c == &#39;]&#39;) {
 984                 betweenBrackets = false;
 985             }
 986             if (c != &#39;%&#39; || betweenBrackets ) {
 987                 sb.append(c);
 988                 i++;
</pre>
</td>
<td>
<hr />
<pre>
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.nio.zipfs;
  27 
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.io.OutputStream;
  32 import java.net.URI;
  33 import java.nio.channels.FileChannel;
  34 import java.nio.channels.SeekableByteChannel;
  35 import java.nio.file.*;
  36 import java.nio.file.DirectoryStream.Filter;
<span class="line-modified">  37 import java.nio.file.attribute.*;</span>


  38 import java.util.Arrays;
  39 import java.util.Iterator;
  40 import java.util.Map;
  41 import java.util.NoSuchElementException;
  42 import java.util.Objects;
  43 import java.util.Set;
  44 
  45 import static java.nio.charset.StandardCharsets.UTF_8;
  46 import static java.nio.file.StandardCopyOption.COPY_ATTRIBUTES;
  47 import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
  48 import static java.nio.file.StandardOpenOption.CREATE;
  49 import static java.nio.file.StandardOpenOption.READ;
  50 import static java.nio.file.StandardOpenOption.TRUNCATE_EXISTING;
  51 import static java.nio.file.StandardOpenOption.WRITE;
  52 
  53 /**
  54  * @author Xueming Shen, Rajendra Gutupalli,Jaya Hangal
  55  */
  56 final class ZipPath implements Path {
  57 
</pre>
<hr />
<pre>
 192             tmp[0] = &#39;/&#39;;
 193             return new ZipPath(zfs, tmp, true);  // normalized
 194         }
 195     }
 196 
 197     @Override
 198     public URI toUri() {
 199         try {
 200             return new URI(&quot;jar&quot;,
 201                            decodeUri(zfs.getZipFile().toUri().toString()) +
 202                            &quot;!&quot; +
 203                            zfs.getString(toAbsolutePath().path),
 204                            null);
 205         } catch (Exception ex) {
 206             throw new AssertionError(ex);
 207         }
 208     }
 209 
 210     private boolean equalsNameAt(ZipPath other, int index) {
 211         int mbegin = offsets[index];
<span class="line-modified"> 212         int mlen;</span>
 213         if (index == (offsets.length-1))
 214             mlen = path.length - mbegin;
 215         else
 216             mlen = offsets[index + 1] - mbegin - 1;
 217         int obegin = other.offsets[index];
<span class="line-modified"> 218         int olen;</span>
 219         if (index == (other.offsets.length - 1))
 220             olen = other.path.length - obegin;
 221         else
 222             olen = other.offsets[index + 1] - obegin - 1;
 223         if (mlen != olen)
 224             return false;
 225         int n = 0;
 226         while(n &lt; mlen) {
 227             if (path[mbegin + n] != other.path[obegin + n])
 228                 return false;
 229             n++;
 230         }
 231         return true;
 232     }
 233 
 234     @Override
 235     public Path relativize(Path other) {
 236         final ZipPath o = checkPath(other);
 237         if (o.equals(this))
 238             return new ZipPath(zfs, new byte[0], true);
</pre>
<hr />
<pre>
 279         return zfs;
 280     }
 281 
 282     @Override
 283     public boolean isAbsolute() {
 284         return path.length &gt; 0 &amp;&amp; path[0] == &#39;/&#39;;
 285     }
 286 
 287     @Override
 288     public ZipPath resolve(Path other) {
 289         ZipPath o = checkPath(other);
 290         if (o.path.length == 0)
 291             return this;
 292         if (o.isAbsolute() || this.path.length == 0)
 293             return o;
 294         return resolve(o.path);
 295     }
 296 
 297     // opath is normalized, just concat
 298     private ZipPath resolve(byte[] opath) {
<span class="line-modified"> 299         byte[] resolved;</span>
 300         byte[] tpath = this.path;
 301         int tlen = tpath.length;
 302         int olen = opath.length;
 303         if (path[tlen - 1] == &#39;/&#39;) {
 304             resolved = new byte[tlen + olen];
 305             System.arraycopy(tpath, 0, resolved, 0, tlen);
 306             System.arraycopy(opath, 0, resolved, tlen, olen);
 307         } else {
 308             resolved = new byte[tlen + 1 + olen];
 309             System.arraycopy(tpath, 0, resolved, 0, tlen);
 310             resolved[tlen] = &#39;/&#39;;
 311             System.arraycopy(opath, 0, resolved, tlen + 1, olen);
 312         }
 313         return new ZipPath(zfs, resolved, true);
 314     }
 315 
 316     @Override
 317     public Path resolveSibling(Path other) {
 318         Objects.requireNonNull(other, &quot;other&quot;);
 319         Path parent = getParent();
</pre>
<hr />
<pre>
 607         if (m &gt; 1 &amp;&amp; to[m - 1] == &#39;/&#39;)
 608             m--;
 609         return (m == to.length)? to : Arrays.copyOf(to, m);
 610     }
 611 
 612     @Override
 613     public String toString() {
 614         return zfs.getString(path);
 615     }
 616 
 617     @Override
 618     public int hashCode() {
 619         int h = hashcode;
 620         if (h == 0)
 621             hashcode = h = Arrays.hashCode(path);
 622         return h;
 623     }
 624 
 625     @Override
 626     public boolean equals(Object obj) {
<span class="line-modified"> 627         return obj instanceof ZipPath &amp;&amp;</span>
<span class="line-modified"> 628                this.zfs == ((ZipPath) obj).zfs &amp;&amp;</span>

 629                compareTo((Path) obj) == 0;
 630     }
 631 
 632     @Override
 633     public int compareTo(Path other) {
 634         final ZipPath o = checkPath(other);
 635         int len1 = this.path.length;
 636         int len2 = o.path.length;
 637 
 638         int n = Math.min(len1, len2);


 639 
 640         int k = 0;
 641         while (k &lt; n) {
<span class="line-modified"> 642             int c1 = this.path[k] &amp; 0xff;</span>
<span class="line-modified"> 643             int c2 = o.path[k] &amp; 0xff;</span>
 644             if (c1 != c2)
 645                 return c1 - c2;
 646             k++;
 647         }
 648         return len1 - len2;
 649     }
 650 
 651     public WatchKey register(
 652             WatchService watcher,
 653             WatchEvent.Kind&lt;?&gt;[] events,
 654             WatchEvent.Modifier... modifiers) {
 655         if (watcher == null || events == null || modifiers == null) {
 656             throw new NullPointerException();
 657         }
 658         // watcher must be associated with a different provider
 659         throw new ProviderMismatchException();
 660     }
 661 
 662     @Override
 663     public WatchKey register(WatchService watcher, WatchEvent.Kind&lt;?&gt;... events) {
 664         return register(watcher, events, new WatchEvent.Modifier[0]);
 665     }
 666 
 667     @Override
 668     public final File toFile() {
 669         throw new UnsupportedOperationException();
 670     }
 671 
 672     @Override
 673     public Iterator&lt;Path&gt; iterator() {
<span class="line-modified"> 674         return new Iterator&lt;&gt;() {</span>
 675             private int i = 0;
 676 
 677             @Override
 678             public boolean hasNext() {
 679                 return (i &lt; getNameCount());
 680             }
 681 
 682             @Override
 683             public Path next() {
 684                 if (i &lt; getNameCount()) {
 685                     Path result = getName(i);
 686                     i++;
 687                     return result;
 688                 } else {
 689                     throw new NoSuchElementException();
 690                 }
 691             }
 692 
 693             @Override
 694             public void remove() {
 695                 throw new ReadOnlyFileSystemException();
 696             }
 697         };
 698     }
 699 
 700     /////////////////////////////////////////////////////////////////////
 701 
<span class="line-added"> 702     @SuppressWarnings(&quot;unchecked&quot;) // Cast to V</span>
<span class="line-added"> 703     &lt;V extends FileAttributeView&gt; V getFileAttributeView(Class&lt;V&gt; type) {</span>
<span class="line-added"> 704         if (type == null)</span>
<span class="line-added"> 705             throw new NullPointerException();</span>
<span class="line-added"> 706         if (type == BasicFileAttributeView.class)</span>
<span class="line-added"> 707             return (V)new ZipFileAttributeView(this, false);</span>
<span class="line-added"> 708         if (type == ZipFileAttributeView.class)</span>
<span class="line-added"> 709             return (V)new ZipFileAttributeView(this, true);</span>
<span class="line-added"> 710         if (zfs.supportPosix) {</span>
<span class="line-added"> 711             if (type == PosixFileAttributeView.class)</span>
<span class="line-added"> 712                 return (V)new ZipPosixFileAttributeView(this, false);</span>
<span class="line-added"> 713             if (type == FileOwnerAttributeView.class)</span>
<span class="line-added"> 714                 return (V)new ZipPosixFileAttributeView(this,true);</span>
<span class="line-added"> 715         }</span>
<span class="line-added"> 716         throw new UnsupportedOperationException(&quot;view &lt;&quot; + type + &quot;&gt; is not supported&quot;);</span>
<span class="line-added"> 717     }</span>
<span class="line-added"> 718 </span>
<span class="line-added"> 719     private ZipFileAttributeView getFileAttributeView(String type) {</span>
<span class="line-added"> 720         if (type == null)</span>
<span class="line-added"> 721             throw new NullPointerException();</span>
<span class="line-added"> 722         if (&quot;basic&quot;.equals(type))</span>
<span class="line-added"> 723             return new ZipFileAttributeView(this, false);</span>
<span class="line-added"> 724         if (&quot;zip&quot;.equals(type))</span>
<span class="line-added"> 725             return new ZipFileAttributeView(this, true);</span>
<span class="line-added"> 726         if (zfs.supportPosix) {</span>
<span class="line-added"> 727             if (&quot;posix&quot;.equals(type))</span>
<span class="line-added"> 728                 return new ZipPosixFileAttributeView(this, false);</span>
<span class="line-added"> 729             if (&quot;owner&quot;.equals(type))</span>
<span class="line-added"> 730                 return new ZipPosixFileAttributeView(this, true);</span>
<span class="line-added"> 731         }</span>
<span class="line-added"> 732         throw new UnsupportedOperationException(&quot;view &lt;&quot; + type + &quot;&gt; is not supported&quot;);</span>
<span class="line-added"> 733     }</span>
<span class="line-added"> 734 </span>
 735     void createDirectory(FileAttribute&lt;?&gt;... attrs)
 736         throws IOException
 737     {
 738         zfs.createDirectory(getResolvedPath(), attrs);
 739     }
 740 
 741     InputStream newInputStream(OpenOption... options) throws IOException
 742     {
 743         if (options.length &gt; 0) {
 744             for (OpenOption opt : options) {
 745                 if (opt != READ)
 746                     throw new UnsupportedOperationException(&quot;&#39;&quot; + opt + &quot;&#39; not allowed&quot;);
 747             }
 748         }
 749         return zfs.newInputStream(getResolvedPath());
 750     }
 751 
 752     DirectoryStream&lt;Path&gt; newDirectoryStream(Filter&lt;? super Path&gt; filter)
 753         throws IOException
 754     {
 755         return new ZipDirectoryStream(this, filter);
 756     }
 757 
 758     void delete() throws IOException {
 759         zfs.deleteFile(getResolvedPath(), true);
 760     }
 761 
<span class="line-modified"> 762     private void deleteIfExists() throws IOException {</span>
 763         zfs.deleteFile(getResolvedPath(), false);
 764     }
 765 
<span class="line-modified"> 766     ZipFileAttributes readAttributes() throws IOException {</span>

 767         ZipFileAttributes zfas = zfs.getFileAttributes(getResolvedPath());
 768         if (zfas == null)
 769             throw new NoSuchFileException(toString());
 770         return zfas;
 771     }
 772 
<span class="line-added"> 773     @SuppressWarnings(&quot;unchecked&quot;) // Cast to A</span>
<span class="line-added"> 774     &lt;A extends BasicFileAttributes&gt; A readAttributes(Class&lt;A&gt; type) throws IOException {</span>
<span class="line-added"> 775         // unconditionally support BasicFileAttributes and ZipFileAttributes</span>
<span class="line-added"> 776         if (type == BasicFileAttributes.class || type == ZipFileAttributes.class) {</span>
<span class="line-added"> 777             return (A)readAttributes();</span>
<span class="line-added"> 778         }</span>
<span class="line-added"> 779 </span>
<span class="line-added"> 780         // support PosixFileAttributes when activated</span>
<span class="line-added"> 781         if (type == PosixFileAttributes.class &amp;&amp; zfs.supportPosix) {</span>
<span class="line-added"> 782             return (A)readAttributes();</span>
<span class="line-added"> 783         }</span>
<span class="line-added"> 784 </span>
<span class="line-added"> 785         throw new UnsupportedOperationException(&quot;Attributes of type &quot; +</span>
<span class="line-added"> 786             type.getName() + &quot; not supported&quot;);</span>
<span class="line-added"> 787     }</span>
<span class="line-added"> 788 </span>
 789     void setAttribute(String attribute, Object value, LinkOption... options)
 790         throws IOException
 791     {
<span class="line-modified"> 792         String type;</span>
<span class="line-modified"> 793         String attr;</span>
 794         int colonPos = attribute.indexOf(&#39;:&#39;);
 795         if (colonPos == -1) {
 796             type = &quot;basic&quot;;
 797             attr = attribute;
 798         } else {
 799             type = attribute.substring(0, colonPos++);
 800             attr = attribute.substring(colonPos);
 801         }
<span class="line-modified"> 802         getFileAttributeView(type).setAttribute(attr, value);</span>



 803     }
 804 
 805     void setTimes(FileTime mtime, FileTime atime, FileTime ctime)
 806         throws IOException
 807     {
 808         zfs.setTimes(getResolvedPath(), mtime, atime, ctime);
 809     }
 810 
<span class="line-modified"> 811     void setOwner(UserPrincipal owner) throws IOException {</span>
<span class="line-added"> 812         zfs.setOwner(getResolvedPath(), owner);</span>
<span class="line-added"> 813     }</span>
<span class="line-added"> 814 </span>
<span class="line-added"> 815     void setPermissions(Set&lt;PosixFilePermission&gt; perms)</span>
 816         throws IOException
<span class="line-added"> 817     {</span>
<span class="line-added"> 818         zfs.setPermissions(getResolvedPath(), perms);</span>
<span class="line-added"> 819     }</span>
 820 
<span class="line-added"> 821     void setGroup(GroupPrincipal group) throws IOException {</span>
<span class="line-added"> 822         zfs.setGroup(getResolvedPath(), group);</span>
<span class="line-added"> 823     }</span>
<span class="line-added"> 824 </span>
<span class="line-added"> 825     Map&lt;String, Object&gt; readAttributes(String attributes, LinkOption... options)</span>
<span class="line-added"> 826         throws IOException</span>
 827     {
<span class="line-modified"> 828         String view;</span>
<span class="line-modified"> 829         String attrs;</span>
 830         int colonPos = attributes.indexOf(&#39;:&#39;);
 831         if (colonPos == -1) {
 832             view = &quot;basic&quot;;
 833             attrs = attributes;
 834         } else {
 835             view = attributes.substring(0, colonPos++);
 836             attrs = attributes.substring(colonPos);
 837         }
<span class="line-modified"> 838         return getFileAttributeView(view).readAttributes(attrs);</span>




 839     }
 840 
 841     FileStore getFileStore() throws IOException {
 842         // each ZipFileSystem only has one root (as requested for now)
 843         if (exists())
 844             return zfs.getFileStore(this);
 845         throw new NoSuchFileException(zfs.getString(path));
 846     }
 847 
 848     boolean isSameFile(Path other) throws IOException {
 849         if (this.equals(other))
 850             return true;
 851         if (other == null ||
 852             this.getFileSystem() != other.getFileSystem())
 853             return false;
 854         this.checkAccess();
 855         ((ZipPath)other).checkAccess();
 856         return Arrays.equals(this.getResolvedPath(),
 857                              ((ZipPath)other).getResolvedPath());
 858     }
</pre>
<hr />
<pre>
 878         for (AccessMode mode : modes) {
 879             switch (mode) {
 880                 case READ:
 881                     break;
 882                 case WRITE:
 883                     w = true;
 884                     break;
 885                 case EXECUTE:
 886                     x = true;
 887                     break;
 888                 default:
 889                     throw new UnsupportedOperationException();
 890             }
 891         }
 892         zfs.checkAccess(getResolvedPath());
 893         if ((w &amp;&amp; zfs.isReadOnly()) || x) {
 894             throw new AccessDeniedException(toString());
 895         }
 896     }
 897 
<span class="line-modified"> 898     private boolean exists() {</span>
<span class="line-modified"> 899         return zfs.exists(getResolvedPath());</span>



 900     }
 901 
 902     OutputStream newOutputStream(OpenOption... options) throws IOException
 903     {
 904         if (options.length == 0)
 905             return zfs.newOutputStream(getResolvedPath(),
 906                                        CREATE, TRUNCATE_EXISTING, WRITE);
 907         return zfs.newOutputStream(getResolvedPath(), options);
 908     }
 909 
 910     void move(ZipPath target, CopyOption... options)
 911         throws IOException
 912     {
 913         if (Files.isSameFile(this.zfs.getZipFile(), target.zfs.getZipFile()))
 914         {
 915             zfs.copyFile(true,
 916                          getResolvedPath(), target.getResolvedPath(),
 917                          options);
 918         } else {
 919             copyToTarget(target, options);
</pre>
<hr />
<pre>
 927         if (Files.isSameFile(this.zfs.getZipFile(), target.zfs.getZipFile()))
 928             zfs.copyFile(false,
 929                          getResolvedPath(), target.getResolvedPath(),
 930                          options);
 931         else
 932             copyToTarget(target, options);
 933     }
 934 
 935     private void copyToTarget(ZipPath target, CopyOption... options)
 936         throws IOException
 937     {
 938         boolean replaceExisting = false;
 939         boolean copyAttrs = false;
 940         for (CopyOption opt : options) {
 941             if (opt == REPLACE_EXISTING)
 942                 replaceExisting = true;
 943             else if (opt == COPY_ATTRIBUTES)
 944                 copyAttrs = true;
 945         }
 946         // attributes of source file
<span class="line-modified"> 947         ZipFileAttributes zfas = readAttributes();</span>
 948         // check if target exists
 949         boolean exists;
 950         if (replaceExisting) {
 951             try {
 952                 target.deleteIfExists();
 953                 exists = false;
 954             } catch (DirectoryNotEmptyException x) {
 955                 exists = true;
 956             }
 957         } else {
 958             exists = target.exists();
 959         }
 960         if (exists)
 961             throw new FileAlreadyExistsException(target.toString());
 962 
 963         if (zfas.isDirectory()) {
 964             // create directory or file
 965             target.createDirectory();
 966         } else {
<span class="line-modified"> 967             try (InputStream is = zfs.newInputStream(getResolvedPath());</span>
<span class="line-modified"> 968                  OutputStream os = target.newOutputStream())</span>
<span class="line-modified"> 969             {</span>
<span class="line-modified"> 970                 byte[] buf = new byte[8192];</span>
<span class="line-modified"> 971                 int n;</span>
<span class="line-modified"> 972                 while ((n = is.read(buf)) != -1) {</span>
<span class="line-modified"> 973                     os.write(buf, 0, n);</span>




 974                 }


 975             }
 976         }
 977         if (copyAttrs) {
<span class="line-modified"> 978             ZipFileAttributeView view =</span>
<span class="line-modified"> 979                 target.getFileAttributeView(ZipFileAttributeView.class);</span>
 980             try {
 981                 view.setTimes(zfas.lastModifiedTime(),
 982                               zfas.lastAccessTime(),
 983                               zfas.creationTime());
<span class="line-added"> 984                 // copy permissions</span>
<span class="line-added"> 985                 view.setPermissions(zfas.storedPermissions().orElse(null));</span>
 986             } catch (IOException x) {
 987                 // rollback?
 988                 try {
 989                     target.delete();
 990                 } catch (IOException ignore) { }
 991                 throw x;
 992             }
 993         }
 994     }
 995 
 996     private static int decode(char c) {
 997         if ((c &gt;= &#39;0&#39;) &amp;&amp; (c &lt;= &#39;9&#39;))
 998             return c - &#39;0&#39;;
 999         if ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;f&#39;))
1000             return c - &#39;a&#39; + 10;
1001         if ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;F&#39;))
1002             return c - &#39;A&#39; + 10;
1003         assert false;
1004         return -1;
1005     }
1006 
1007     // to avoid double escape
<span class="line-modified">1008     private static String decodeUri(String s) {</span>
1009         if (s == null)
<span class="line-modified">1010             return null;</span>
1011         int n = s.length();
1012         if (n == 0)
1013             return s;
1014         if (s.indexOf(&#39;%&#39;) &lt; 0)
1015             return s;
1016 
1017         StringBuilder sb = new StringBuilder(n);
1018         byte[] bb = new byte[n];
1019         boolean betweenBrackets = false;
1020 
1021         for (int i = 0; i &lt; n;) {
1022             char c = s.charAt(i);
1023             if (c == &#39;[&#39;) {
1024                 betweenBrackets = true;
1025             } else if (betweenBrackets &amp;&amp; c == &#39;]&#39;) {
1026                 betweenBrackets = false;
1027             }
1028             if (c != &#39;%&#39; || betweenBrackets ) {
1029                 sb.append(c);
1030                 i++;
</pre>
</td>
</tr>
</table>
<center><a href="ZipInfo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ZipUtils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.rmi/share/classes/java/rmi/server/RemoteObjectInvocationHandler.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.rmi.server;
 26 
 27 import java.io.InvalidObjectException;
 28 import java.lang.reflect.InvocationHandler;
 29 import java.lang.reflect.Method;
 30 import java.lang.reflect.Proxy;
 31 import java.rmi.Remote;
<a name="2" id="anc2"></a>
 32 import java.rmi.UnexpectedException;
 33 import java.rmi.activation.Activatable;
 34 import java.util.Map;
 35 import java.util.WeakHashMap;
 36 import sun.rmi.server.Util;
 37 import sun.rmi.server.WeakClassHashMap;
 38 
 39 /**
 40  * An implementation of the &lt;code&gt;InvocationHandler&lt;/code&gt; interface for
 41  * use with Java Remote Method Invocation (Java RMI).  This invocation
 42  * handler can be used in conjunction with a dynamic proxy instance as a
 43  * replacement for a pregenerated stub class.
 44  *
 45  * &lt;p&gt;Applications are not expected to use this class directly.  A remote
 46  * object exported to use a dynamic proxy with {@link UnicastRemoteObject}
 47  * or {@link Activatable} has an instance of this class as that proxy&#39;s
 48  * invocation handler.
 49  *
 50  * @author  Ann Wollrath
 51  * @since   1.5
 52  **/
 53 public class RemoteObjectInvocationHandler
 54     extends RemoteObject
 55     implements InvocationHandler
 56 {
 57     private static final long serialVersionUID = 2L;
 58 
 59     /**
 60      * A weak hash map, mapping classes to weak hash maps that map
 61      * method objects to method hashes.
 62      **/
 63     private static final MethodToHash_Maps methodToHash_Maps =
 64         new MethodToHash_Maps();
 65 
 66     /**
 67      * Creates a new &lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt; constructed
 68      * with the specified &lt;code&gt;RemoteRef&lt;/code&gt;.
 69      *
 70      * @param ref the remote ref
 71      *
 72      * @throws NullPointerException if &lt;code&gt;ref&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
 73      **/
 74     public RemoteObjectInvocationHandler(RemoteRef ref) {
 75         super(ref);
 76         if (ref == null) {
 77             throw new NullPointerException();
 78         }
 79     }
 80 
 81     /**
 82      * Processes a method invocation made on the encapsulating
 83      * proxy instance, &lt;code&gt;proxy&lt;/code&gt;, and returns the result.
 84      *
 85      * &lt;p&gt;&lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt; implements this method
 86      * as follows:
 87      *
 88      * &lt;p&gt;If &lt;code&gt;method&lt;/code&gt; is one of the following methods, it
 89      * is processed as described below:
 90      *
 91      * &lt;ul&gt;
 92      *
 93      * &lt;li&gt;{@link Object#hashCode Object.hashCode}: Returns the hash
 94      * code value for the proxy.
 95      *
 96      * &lt;li&gt;{@link Object#equals Object.equals}: Returns &lt;code&gt;true&lt;/code&gt;
 97      * if the argument (&lt;code&gt;args[0]&lt;/code&gt;) is an instance of a dynamic
 98      * proxy class and this invocation handler is equal to the invocation
 99      * handler of that argument, and returns &lt;code&gt;false&lt;/code&gt; otherwise.
100      *
101      * &lt;li&gt;{@link Object#toString Object.toString}: Returns a string
102      * representation of the proxy.
103      * &lt;/ul&gt;
104      *
105      * &lt;p&gt;If &lt;code&gt;method&lt;/code&gt; overrides {@link Object#finalize Object.finalize},
106      * it is ignored.
107      *
108      * &lt;p&gt;Otherwise, a remote call is made as follows:
109      *
110      * &lt;ul&gt;
111      * &lt;li&gt;If &lt;code&gt;proxy&lt;/code&gt; is not an instance of the interface
112      * {@link Remote}, then an {@link IllegalArgumentException} is thrown.
113      *
114      * &lt;li&gt;Otherwise, the {@link RemoteRef#invoke invoke} method is invoked
115      * on this invocation handler&#39;s &lt;code&gt;RemoteRef&lt;/code&gt;, passing
116      * &lt;code&gt;proxy&lt;/code&gt;, &lt;code&gt;method&lt;/code&gt;, &lt;code&gt;args&lt;/code&gt;, and the
117      * method hash (defined in section 8.3 of the &quot;Java Remote Method
118      * Invocation (RMI) Specification&quot;) for &lt;code&gt;method&lt;/code&gt;, and the
119      * result is returned.
120      *
121      * &lt;li&gt;If an exception is thrown by &lt;code&gt;RemoteRef.invoke&lt;/code&gt; and
122      * that exception is a checked exception that is not assignable to any
123      * exception in the &lt;code&gt;throws&lt;/code&gt; clause of the method
124      * implemented by the &lt;code&gt;proxy&lt;/code&gt;&#39;s class, then that exception
125      * is wrapped in an {@link UnexpectedException} and the wrapped
126      * exception is thrown.  Otherwise, the exception thrown by
127      * &lt;code&gt;invoke&lt;/code&gt; is thrown by this method.
128      * &lt;/ul&gt;
129      *
130      * &lt;p&gt;The semantics of this method are unspecified if the
131      * arguments could not have been produced by an instance of some
132      * valid dynamic proxy class containing this invocation handler.
133      *
134      * @param proxy the proxy instance that the method was invoked on
135      * @param method the &lt;code&gt;Method&lt;/code&gt; instance corresponding to the
136      * interface method invoked on the proxy instance
137      * @param args an array of objects containing the values of the
138      * arguments passed in the method invocation on the proxy instance, or
139      * &lt;code&gt;null&lt;/code&gt; if the method takes no arguments
140      * @return the value to return from the method invocation on the proxy
141      * instance
142      * @throws  Throwable the exception to throw from the method invocation
143      * on the proxy instance
144      **/
145     public Object invoke(Object proxy, Method method, Object[] args)
146         throws Throwable
147     {
148         if (! Proxy.isProxyClass(proxy.getClass())) {
149             throw new IllegalArgumentException(&quot;not a proxy&quot;);
150         }
151 
152         if (Proxy.getInvocationHandler(proxy) != this) {
153             throw new IllegalArgumentException(&quot;handler mismatch&quot;);
154         }
155 
156         if (method.getDeclaringClass() == Object.class) {
157             return invokeObjectMethod(proxy, method, args);
158         } else if (&quot;finalize&quot;.equals(method.getName()) &amp;&amp; method.getParameterCount() == 0) {
159             return null; // ignore
160         } else {
161             return invokeRemoteMethod(proxy, method, args);
162         }
163     }
164 
165     /**
166      * Handles java.lang.Object methods.
167      **/
168     private Object invokeObjectMethod(Object proxy,
169                                       Method method,
170                                       Object[] args)
171     {
172         String name = method.getName();
173 
174         if (name.equals(&quot;hashCode&quot;)) {
175             return hashCode();
176 
177         } else if (name.equals(&quot;equals&quot;)) {
178             Object obj = args[0];
179             InvocationHandler hdlr;
180             return
181                 proxy == obj ||
182                 (obj != null &amp;&amp;
183                  Proxy.isProxyClass(obj.getClass()) &amp;&amp;
184                  (hdlr = Proxy.getInvocationHandler(obj)) instanceof RemoteObjectInvocationHandler &amp;&amp;
185                  this.equals(hdlr));
186 
187         } else if (name.equals(&quot;toString&quot;)) {
188             return proxyToString(proxy);
189 
190         } else {
191             throw new IllegalArgumentException(
192                 &quot;unexpected Object method: &quot; + method);
193         }
194     }
195 
196     /**
197      * Handles remote methods.
198      **/
199     private Object invokeRemoteMethod(Object proxy,
200                                       Method method,
201                                       Object[] args)
202         throws Exception
203     {
204         try {
205             if (!(proxy instanceof Remote)) {
206                 throw new IllegalArgumentException(
207                     &quot;proxy not Remote instance&quot;);
208             }
<a name="3" id="anc3"></a>






209             return ref.invoke((Remote) proxy, method, args,
210                               getMethodHash(method));
211         } catch (Exception e) {
212             if (!(e instanceof RuntimeException)) {
213                 Class&lt;?&gt; cl = proxy.getClass();
214                 try {
215                     method = cl.getMethod(method.getName(),
216                                           method.getParameterTypes());
217                 } catch (NoSuchMethodException nsme) {
218                     throw (IllegalArgumentException)
219                         new IllegalArgumentException().initCause(nsme);
220                 }
221                 Class&lt;?&gt; thrownType = e.getClass();
222                 for (Class&lt;?&gt; declaredType : method.getExceptionTypes()) {
223                     if (declaredType.isAssignableFrom(thrownType)) {
224                         throw e;
225                     }
226                 }
227                 e = new UnexpectedException(&quot;unexpected exception&quot;, e);
228             }
229             throw e;
230         }
231     }
232 
233     /**
234      * Returns a string representation for a proxy that uses this invocation
235      * handler.
236      **/
237     private String proxyToString(Object proxy) {
238         Class&lt;?&gt;[] interfaces = proxy.getClass().getInterfaces();
239         if (interfaces.length == 0) {
240             return &quot;Proxy[&quot; + this + &quot;]&quot;;
241         }
242         String iface = interfaces[0].getName();
243         if (iface.equals(&quot;java.rmi.Remote&quot;) &amp;&amp; interfaces.length &gt; 1) {
244             iface = interfaces[1].getName();
245         }
246         int dot = iface.lastIndexOf(&#39;.&#39;);
247         if (dot &gt;= 0) {
248             iface = iface.substring(dot + 1);
249         }
250         return &quot;Proxy[&quot; + iface + &quot;,&quot; + this + &quot;]&quot;;
251     }
252 
253     /**
254      * @throws InvalidObjectException unconditionally
255      **/
256     private void readObjectNoData() throws InvalidObjectException {
257         throw new InvalidObjectException(&quot;no data in stream; class: &quot; +
258                                          this.getClass().getName());
259     }
260 
261     /**
262      * Returns the method hash for the specified method.  Subsequent calls
263      * to &quot;getMethodHash&quot; passing the same method argument should be faster
264      * since this method caches internally the result of the method to
265      * method hash mapping.  The method hash is calculated using the
266      * &quot;computeMethodHash&quot; method.
267      *
268      * @param method the remote method
269      * @return the method hash for the specified method
270      */
271     private static long getMethodHash(Method method) {
272         return methodToHash_Maps.get(method.getDeclaringClass()).get(method);
273     }
274 
275     /**
276      * A weak hash map, mapping classes to weak hash maps that map
277      * method objects to method hashes.
278      **/
279     private static class MethodToHash_Maps
280         extends WeakClassHashMap&lt;Map&lt;Method,Long&gt;&gt;
281     {
282         MethodToHash_Maps() {}
283 
284         protected Map&lt;Method,Long&gt; computeValue(Class&lt;?&gt; remoteClass) {
285             return new WeakHashMap&lt;Method,Long&gt;() {
286                 public synchronized Long get(Object key) {
287                     Long hash = super.get(key);
288                     if (hash == null) {
289                         Method method = (Method) key;
290                         hash = Util.computeMethodHash(method);
291                         put(method, hash);
292                     }
293                     return hash;
294                 }
295             };
296         }
297     }
298 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
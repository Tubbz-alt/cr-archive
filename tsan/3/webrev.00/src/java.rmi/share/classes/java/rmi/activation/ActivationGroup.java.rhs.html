<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.rmi/share/classes/java/rmi/activation/ActivationGroup.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.rmi.activation;
 27 
 28 import java.lang.reflect.Constructor;
 29 import java.lang.reflect.InvocationTargetException;
 30 import java.rmi.MarshalledObject;
 31 import java.rmi.Naming;
 32 import java.rmi.Remote;
 33 import java.rmi.RemoteException;
 34 import java.rmi.activation.UnknownGroupException;
 35 import java.rmi.activation.UnknownObjectException;
 36 import java.rmi.server.RMIClassLoader;
 37 import java.rmi.server.UnicastRemoteObject;
 38 import java.security.AccessController;
 39 import java.security.PrivilegedAction;
 40 
 41 /**
 42  * An &lt;code&gt;ActivationGroup&lt;/code&gt; is responsible for creating new
 43  * instances of &quot;activatable&quot; objects in its group, informing its
 44  * &lt;code&gt;ActivationMonitor&lt;/code&gt; when either: its object&#39;s become
 45  * active or inactive, or the group as a whole becomes inactive. &lt;p&gt;
 46  *
 47  * An &lt;code&gt;ActivationGroup&lt;/code&gt; is &lt;i&gt;initially&lt;/i&gt; created in one
 48  * of several ways: &lt;ul&gt;
 49  * &lt;li&gt;as a side-effect of creating an &lt;code&gt;ActivationDesc&lt;/code&gt;
 50  *     without an explicit &lt;code&gt;ActivationGroupID&lt;/code&gt; for the
 51  *     first activatable object in the group, or
 52  * &lt;li&gt;via the &lt;code&gt;ActivationGroup.createGroup&lt;/code&gt; method
 53  * &lt;li&gt;as a side-effect of activating the first object in a group
 54  *     whose &lt;code&gt;ActivationGroupDesc&lt;/code&gt; was only registered.&lt;/ul&gt;&lt;p&gt;
 55  *
 56  * Only the activator can &lt;i&gt;recreate&lt;/i&gt; an
 57  * &lt;code&gt;ActivationGroup&lt;/code&gt;.  The activator spawns, as needed, a
 58  * separate VM (as a child process, for example) for each registered
 59  * activation group and directs activation requests to the appropriate
 60  * group. It is implementation specific how VMs are spawned. An
 61  * activation group is created via the
 62  * &lt;code&gt;ActivationGroup.createGroup&lt;/code&gt; static method. The
 63  * &lt;code&gt;createGroup&lt;/code&gt; method has two requirements on the group
 64  * to be created: 1) the group must be a concrete subclass of
 65  * &lt;code&gt;ActivationGroup&lt;/code&gt;, and 2) the group must have a
 66  * constructor that takes two arguments:
 67  *
 68  * &lt;ul&gt;
 69  * &lt;li&gt; the group&#39;s &lt;code&gt;ActivationGroupID&lt;/code&gt;, and
 70  * &lt;li&gt; the group&#39;s initialization data (in a
 71  *      &lt;code&gt;java.rmi.MarshalledObject&lt;/code&gt;)&lt;/ul&gt;&lt;p&gt;
 72  *
 73  * When created, the default implementation of
 74  * &lt;code&gt;ActivationGroup&lt;/code&gt; will override the system properties
 75  * with the properties requested when its
 76  * &lt;code&gt;ActivationGroupDesc&lt;/code&gt; was created, and will set a
 77  * {@link SecurityManager} as the default system
 78  * security manager.  If your application requires specific properties
 79  * to be set when objects are activated in the group, the application
 80  * should create a special &lt;code&gt;Properties&lt;/code&gt; object containing
 81  * these properties, then create an &lt;code&gt;ActivationGroupDesc&lt;/code&gt;
 82  * with the &lt;code&gt;Properties&lt;/code&gt; object, and use
 83  * &lt;code&gt;ActivationGroup.createGroup&lt;/code&gt; before creating any
 84  * &lt;code&gt;ActivationDesc&lt;/code&gt;s (before the default
 85  * &lt;code&gt;ActivationGroupDesc&lt;/code&gt; is created).  If your application
 86  * requires the use of a security manager other than
 87  * {@link SecurityManager}, in the
 88  * ActivativationGroupDescriptor properties list you can set
 89  * &lt;code&gt;java.security.manager&lt;/code&gt; property to the name of the security
 90  * manager you would like to install.
 91  *
 92  * @author      Ann Wollrath
 93  * @see         ActivationInstantiator
 94  * @see         ActivationGroupDesc
 95  * @see         ActivationGroupID
 96  * @since       1.2
 97  */
 98 public abstract class ActivationGroup
 99         extends UnicastRemoteObject
100         implements ActivationInstantiator
101 {
102     /**
103      * @serial the group&#39;s identifier
104      */
105     private ActivationGroupID groupID;
106 
107     /**
108      * @serial the group&#39;s monitor
109      */
<a name="2" id="anc2"></a><span class="line-added">110     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
111     private ActivationMonitor monitor;
112 
113     /**
114      * @serial the group&#39;s incarnation number
115      */
116     private long incarnation;
117 
118     /** the current activation group for this VM */
119     private static ActivationGroup currGroup;
120     /** the current group&#39;s identifier */
121     private static ActivationGroupID currGroupID;
122     /** the current group&#39;s activation system */
123     private static ActivationSystem currSystem;
124     /** used to control a group being created only once */
125     private static boolean canCreate = true;
126 
127     /** indicate compatibility with the Java 2 SDK v1.2 version of class */
128     private static final long serialVersionUID = -7696947875314805420L;
129 
130     /**
131      * Constructs an activation group with the given activation group
132      * identifier.  The group is exported as a
133      * &lt;code&gt;java.rmi.server.UnicastRemoteObject&lt;/code&gt;.
134      *
135      * @param   groupID the group&#39;s identifier
136      * @throws  RemoteException if this group could not be exported
137      * @throws  UnsupportedOperationException if and only if activation is
138      *          not supported by this implementation
139      * @since   1.2
140      */
141     protected ActivationGroup(ActivationGroupID groupID)
142         throws RemoteException
143     {
144         // call super constructor to export the object
145         super();
146         this.groupID = groupID;
147     }
148 
149     /**
150      * The group&#39;s &lt;code&gt;inactiveObject&lt;/code&gt; method is called
151      * indirectly via a call to the &lt;code&gt;Activatable.inactive&lt;/code&gt;
152      * method. A remote object implementation must call
153      * &lt;code&gt;Activatable&lt;/code&gt;&#39;s &lt;code&gt;inactive&lt;/code&gt; method when
154      * that object deactivates (the object deems that it is no longer
155      * active). If the object does not call
156      * &lt;code&gt;Activatable.inactive&lt;/code&gt; when it deactivates, the
157      * object will never be garbage collected since the group keeps
158      * strong references to the objects it creates.
159      *
160      * &lt;p&gt;The group&#39;s &lt;code&gt;inactiveObject&lt;/code&gt; method unexports the
161      * remote object from the RMI runtime so that the object can no
162      * longer receive incoming RMI calls. An object will only be unexported
163      * if the object has no pending or executing calls.
164      * The subclass of &lt;code&gt;ActivationGroup&lt;/code&gt; must override this
165      * method and unexport the object.
166      *
167      * &lt;p&gt;After removing the object from the RMI runtime, the group
168      * must inform its &lt;code&gt;ActivationMonitor&lt;/code&gt; (via the monitor&#39;s
169      * &lt;code&gt;inactiveObject&lt;/code&gt; method) that the remote object is
170      * not currently active so that the remote object will be
171      * re-activated by the activator upon a subsequent activation
172      * request.
173      *
174      * &lt;p&gt;This method simply informs the group&#39;s monitor that the object
175      * is inactive.  It is up to the concrete subclass of ActivationGroup
176      * to fulfill the additional requirement of unexporting the object.
177      *
178      * @param id the object&#39;s activation identifier
179      * @return true if the object was successfully deactivated; otherwise
180      *         returns false.
181      * @exception UnknownObjectException if object is unknown (may already
182      * be inactive)
183      * @exception RemoteException if call informing monitor fails
184      * @exception ActivationException if group is inactive
185      * @since 1.2
186      */
187     public boolean inactiveObject(ActivationID id)
188         throws ActivationException, UnknownObjectException, RemoteException
189     {
190         getMonitor().inactiveObject(id);
191         return true;
192     }
193 
194     /**
195      * The group&#39;s &lt;code&gt;activeObject&lt;/code&gt; method is called when an
196      * object is exported (either by &lt;code&gt;Activatable&lt;/code&gt; object
197      * construction or an explicit call to
198      * &lt;code&gt;Activatable.exportObject&lt;/code&gt;. The group must inform its
199      * &lt;code&gt;ActivationMonitor&lt;/code&gt; that the object is active (via
200      * the monitor&#39;s &lt;code&gt;activeObject&lt;/code&gt; method) if the group
201      * hasn&#39;t already done so.
202      *
203      * @param id the object&#39;s identifier
204      * @param obj the remote object implementation
205      * @exception UnknownObjectException if object is not registered
206      * @exception RemoteException if call informing monitor fails
207      * @exception ActivationException if group is inactive
208      * @since 1.2
209      */
210     public abstract void activeObject(ActivationID id, Remote obj)
211         throws ActivationException, UnknownObjectException, RemoteException;
212 
213     /**
214      * Create and set the activation group for the current VM.  The
215      * activation group can only be set if it is not currently set.
216      * An activation group is set using the &lt;code&gt;createGroup&lt;/code&gt;
217      * method when the &lt;code&gt;Activator&lt;/code&gt; initiates the
218      * re-creation of an activation group in order to carry out
219      * incoming &lt;code&gt;activate&lt;/code&gt; requests. A group must first be
220      * registered with the &lt;code&gt;ActivationSystem&lt;/code&gt; before it can
221      * be created via this method.
222      *
223      * &lt;p&gt;The group class specified by the
224      * &lt;code&gt;ActivationGroupDesc&lt;/code&gt; must be a concrete subclass of
225      * &lt;code&gt;ActivationGroup&lt;/code&gt; and have a public constructor that
226      * takes two arguments: the &lt;code&gt;ActivationGroupID&lt;/code&gt; for the
227      * group and the &lt;code&gt;MarshalledObject&lt;/code&gt; containing the
228      * group&#39;s initialization data (obtained from the
229      * &lt;code&gt;ActivationGroupDesc&lt;/code&gt;.
230      *
231      * &lt;p&gt;If the group class name specified in the
232      * &lt;code&gt;ActivationGroupDesc&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then
233      * this method will behave as if the group descriptor contained
234      * the name of the default activation group implementation class.
235      *
236      * &lt;p&gt;Note that if your application creates its own custom
237      * activation group, a security manager must be set for that
238      * group.  Otherwise objects cannot be activated in the group.
239      * {@link SecurityManager} is set by default.
240      *
241      * &lt;p&gt;If a security manager is already set in the group VM, this
242      * method first calls the security manager&#39;s
243      * &lt;code&gt;checkSetFactory&lt;/code&gt; method.  This could result in a
244      * &lt;code&gt;SecurityException&lt;/code&gt;. If your application needs to
245      * set a different security manager, you must ensure that the
246      * policy file specified by the group&#39;s
247      * &lt;code&gt;ActivationGroupDesc&lt;/code&gt; grants the group the necessary
248      * permissions to set a new security manager.  (Note: This will be
249      * necessary if your group downloads and sets a security manager).
250      *
251      * &lt;p&gt;After the group is created, the
252      * &lt;code&gt;ActivationSystem&lt;/code&gt; is informed that the group is
253      * active by calling the &lt;code&gt;activeGroup&lt;/code&gt; method which
254      * returns the &lt;code&gt;ActivationMonitor&lt;/code&gt; for the group. The
255      * application need not call &lt;code&gt;activeGroup&lt;/code&gt;
256      * independently since it is taken care of by this method.
257      *
258      * &lt;p&gt;Once a group is created, subsequent calls to the
259      * &lt;code&gt;currentGroupID&lt;/code&gt; method will return the identifier
260      * for this group until the group becomes inactive.
261      *
262      * @param id the activation group&#39;s identifier
263      * @param desc the activation group&#39;s descriptor
264      * @param incarnation the group&#39;s incarnation number (zero on group&#39;s
265      * initial creation)
266      * @return the activation group for the VM
267      * @exception ActivationException if group already exists or if error
268      * occurs during group creation
269      * @exception SecurityException if permission to create group is denied.
270      * (Note: The default implementation of the security manager
271      * &lt;code&gt;checkSetFactory&lt;/code&gt;
272      * method requires the RuntimePermission &quot;setFactory&quot;)
273      * @exception UnsupportedOperationException if and only if activation is
274      * not supported by this implementation
275      * @see SecurityManager#checkSetFactory
276      * @since 1.2
277      */
278     public static synchronized
279         ActivationGroup createGroup(ActivationGroupID id,
280                                     final ActivationGroupDesc desc,
281                                     long incarnation)
282         throws ActivationException
283     {
284         SecurityManager security = System.getSecurityManager();
285         if (security != null)
286             security.checkSetFactory();
287 
288         if (currGroup != null)
289             throw new ActivationException(&quot;group already exists&quot;);
290 
291         if (canCreate == false)
292             throw new ActivationException(&quot;group deactivated and &quot; +
293                                           &quot;cannot be recreated&quot;);
294 
295         try {
296             // load group&#39;s class
297             String groupClassName = desc.getClassName();
298             Class&lt;? extends ActivationGroup&gt; cl;
299             Class&lt;? extends ActivationGroup&gt; defaultGroupClass =
300                 sun.rmi.server.ActivationGroupImpl.class;
301             if (groupClassName == null ||       // see 4252236
302                 groupClassName.equals(defaultGroupClass.getName()))
303             {
304                 cl = defaultGroupClass;
305             } else {
306                 Class&lt;?&gt; cl0;
307                 try {
308                     cl0 = RMIClassLoader.loadClass(desc.getLocation(),
309                                                    groupClassName);
310                 } catch (Exception ex) {
311                     throw new ActivationException(
312                         &quot;Could not load group implementation class&quot;, ex);
313                 }
314                 if (ActivationGroup.class.isAssignableFrom(cl0)) {
315                     cl = cl0.asSubclass(ActivationGroup.class);
316                 } else {
317                     throw new ActivationException(&quot;group not correct class: &quot; +
318                                                   cl0.getName());
319                 }
320             }
321 
322             // create group
323             Constructor&lt;? extends ActivationGroup&gt; constructor =
324                 cl.getConstructor(ActivationGroupID.class,
325                                   MarshalledObject.class);
326             ActivationGroup newGroup =
327                 constructor.newInstance(id, desc.getData());
328             currSystem = id.getSystem();
329             newGroup.incarnation = incarnation;
330             newGroup.monitor =
331                 currSystem.activeGroup(id, newGroup, incarnation);
332             currGroup = newGroup;
333             currGroupID = id;
334             canCreate = false;
335         } catch (InvocationTargetException e) {
336                 e.getTargetException().printStackTrace();
337                 throw new ActivationException(&quot;exception in group constructor&quot;,
338                                               e.getTargetException());
339 
340         } catch (ActivationException e) {
341             throw e;
342 
343         } catch (Exception e) {
344             throw new ActivationException(&quot;exception creating group&quot;, e);
345         }
346 
347         return currGroup;
348     }
349 
350     /**
351      * Returns the current activation group&#39;s identifier.  Returns null
352      * if no group is currently active for this VM.
353      * @exception UnsupportedOperationException if and only if activation is
354      * not supported by this implementation
355      * @return the activation group&#39;s identifier
356      * @since 1.2
357      */
358     public static synchronized ActivationGroupID currentGroupID() {
359         return currGroupID;
360     }
361 
362     /**
363      * Returns the activation group identifier for the VM.  If an
364      * activation group does not exist for this VM, a default
365      * activation group is created. A group can be created only once,
366      * so if a group has already become active and deactivated.
367      *
368      * @return the activation group identifier
369      * @exception ActivationException if error occurs during group
370      * creation, if security manager is not set, or if the group
371      * has already been created and deactivated.
372      */
373     static synchronized ActivationGroupID internalCurrentGroupID()
374         throws ActivationException
375     {
376         if (currGroupID == null)
377             throw new ActivationException(&quot;nonexistent group&quot;);
378 
379         return currGroupID;
380     }
381 
382     /**
383      * Set the activation system for the VM.  The activation system can
384      * only be set it if no group is currently active. If the activation
385      * system is not set via this call, then the &lt;code&gt;getSystem&lt;/code&gt;
386      * method attempts to obtain a reference to the
387      * &lt;code&gt;ActivationSystem&lt;/code&gt; by looking up the name
388      * &quot;java.rmi.activation.ActivationSystem&quot; in the Activator&#39;s
389      * registry. By default, the port number used to look up the
390      * activation system is defined by
391      * &lt;code&gt;ActivationSystem.SYSTEM_PORT&lt;/code&gt;. This port can be overridden
392      * by setting the property &lt;code&gt;java.rmi.activation.port&lt;/code&gt;.
393      *
394      * &lt;p&gt;If there is a security manager, this method first
395      * calls the security manager&#39;s &lt;code&gt;checkSetFactory&lt;/code&gt; method.
396      * This could result in a SecurityException.
397      *
398      * @param system remote reference to the &lt;code&gt;ActivationSystem&lt;/code&gt;
399      * @exception ActivationException if activation system is already set
400      * @exception SecurityException if permission to set the activation system is denied.
401      * (Note: The default implementation of the security manager
402      * &lt;code&gt;checkSetFactory&lt;/code&gt;
403      * method requires the RuntimePermission &quot;setFactory&quot;)
404      * @exception UnsupportedOperationException if and only if activation is
405      * not supported by this implementation
406      * @see #getSystem
407      * @see SecurityManager#checkSetFactory
408      * @since 1.2
409      */
410     public static synchronized void setSystem(ActivationSystem system)
411         throws ActivationException
412     {
413         SecurityManager security = System.getSecurityManager();
414         if (security != null)
415             security.checkSetFactory();
416 
417         if (currSystem != null)
418             throw new ActivationException(&quot;activation system already set&quot;);
419 
420         currSystem = system;
421     }
422 
423     /**
424      * Returns the activation system for the VM. The activation system
425      * may be set by the &lt;code&gt;setSystem&lt;/code&gt; method. If the
426      * activation system is not set via the &lt;code&gt;setSystem&lt;/code&gt;
427      * method, then the &lt;code&gt;getSystem&lt;/code&gt; method attempts to
428      * obtain a reference to the &lt;code&gt;ActivationSystem&lt;/code&gt; by
429      * looking up the name &quot;java.rmi.activation.ActivationSystem&quot; in
430      * the Activator&#39;s registry. By default, the port number used to
431      * look up the activation system is defined by
432      * &lt;code&gt;ActivationSystem.SYSTEM_PORT&lt;/code&gt;. This port can be
433      * overridden by setting the property
434      * &lt;code&gt;java.rmi.activation.port&lt;/code&gt;.
435      *
436      * @return the activation system for the VM/group
437      * @exception ActivationException if activation system cannot be
438      *  obtained or is not bound
439      * (means that it is not running)
440      * @exception UnsupportedOperationException if and only if activation is
441      * not supported by this implementation
442      * @see #setSystem
443      * @since 1.2
444      */
445     public static synchronized ActivationSystem getSystem()
446         throws ActivationException
447     {
448         if (currSystem == null) {
449             try {
450                 int port = AccessController.doPrivileged((PrivilegedAction&lt;Integer&gt;) () -&gt;
451                     Integer.getInteger(&quot;java.rmi.activation.port&quot;, ActivationSystem.SYSTEM_PORT));
452                 currSystem = (ActivationSystem)
453                     Naming.lookup(&quot;//:&quot; + port +
454                                   &quot;/java.rmi.activation.ActivationSystem&quot;);
455             } catch (Exception e) {
456                 throw new ActivationException(
457                     &quot;unable to obtain ActivationSystem&quot;, e);
458             }
459         }
460         return currSystem;
461     }
462 
463     /**
464      * This protected method is necessary for subclasses to
465      * make the &lt;code&gt;activeObject&lt;/code&gt; callback to the group&#39;s
466      * monitor. The call is simply forwarded to the group&#39;s
467      * &lt;code&gt;ActivationMonitor&lt;/code&gt;.
468      *
469      * @param id the object&#39;s identifier
470      * @param mobj a marshalled object containing the remote object&#39;s stub
471      * @exception UnknownObjectException if object is not registered
472      * @exception RemoteException if call informing monitor fails
473      * @exception ActivationException if an activation error occurs
474      * @since 1.2
475      */
476     protected void activeObject(ActivationID id,
477                                 MarshalledObject&lt;? extends Remote&gt; mobj)
478         throws ActivationException, UnknownObjectException, RemoteException
479     {
480         getMonitor().activeObject(id, mobj);
481     }
482 
483     /**
484      * This protected method is necessary for subclasses to
485      * make the &lt;code&gt;inactiveGroup&lt;/code&gt; callback to the group&#39;s
486      * monitor. The call is simply forwarded to the group&#39;s
487      * &lt;code&gt;ActivationMonitor&lt;/code&gt;. Also, the current group
488      * for the VM is set to null.
489      *
490      * @exception UnknownGroupException if group is not registered
491      * @exception RemoteException if call informing monitor fails
492      * @since 1.2
493      */
494     protected void inactiveGroup()
495         throws UnknownGroupException, RemoteException
496     {
497         try {
498             getMonitor().inactiveGroup(groupID, incarnation);
499         } finally {
500             destroyGroup();
501         }
502     }
503 
504     /**
505      * Returns the monitor for the activation group.
506      */
507     private ActivationMonitor getMonitor() throws RemoteException {
508         synchronized (ActivationGroup.class) {
509             if (monitor != null) {
510                 return monitor;
511             }
512         }
513         throw new RemoteException(&quot;monitor not received&quot;);
514     }
515 
516     /**
517      * Destroys the current group.
518      */
519     private static synchronized void destroyGroup() {
520         currGroup = null;
521         currGroupID = null;
522         // NOTE: don&#39;t set currSystem to null since it may be needed
523     }
524 
525     /**
526      * Returns the current group for the VM.
527      * @exception ActivationException if current group is null (not active)
528      */
529     static synchronized ActivationGroup currentGroup()
530         throws ActivationException
531     {
532         if (currGroup == null) {
533             throw new ActivationException(&quot;group is not active&quot;);
534         }
535         return currGroup;
536     }
537 
538 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
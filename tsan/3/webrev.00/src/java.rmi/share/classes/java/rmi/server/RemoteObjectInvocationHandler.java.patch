diff a/src/java.rmi/share/classes/java/rmi/server/RemoteObjectInvocationHandler.java b/src/java.rmi/share/classes/java/rmi/server/RemoteObjectInvocationHandler.java
--- a/src/java.rmi/share/classes/java/rmi/server/RemoteObjectInvocationHandler.java
+++ b/src/java.rmi/share/classes/java/rmi/server/RemoteObjectInvocationHandler.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -27,10 +27,11 @@
 import java.io.InvalidObjectException;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.rmi.Remote;
+import java.rmi.RemoteException;
 import java.rmi.UnexpectedException;
 import java.rmi.activation.Activatable;
 import java.util.Map;
 import java.util.WeakHashMap;
 import sun.rmi.server.Util;
@@ -204,10 +205,17 @@
         try {
             if (!(proxy instanceof Remote)) {
                 throw new IllegalArgumentException(
                     "proxy not Remote instance");
             }
+
+            // Verify that the method is declared on an interface that extends Remote
+            Class<?> decl = method.getDeclaringClass();
+            if (!Remote.class.isAssignableFrom(decl)) {
+                throw new RemoteException("Method is not Remote: " + decl + "::" + method);
+            }
+
             return ref.invoke((Remote) proxy, method, args,
                               getMethodHash(method));
         } catch (Exception e) {
             if (!(e instanceof RuntimeException)) {
                 Class<?> cl = proxy.getClass();

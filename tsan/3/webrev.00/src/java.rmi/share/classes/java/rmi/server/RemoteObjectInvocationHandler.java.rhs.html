<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.rmi/share/classes/java/rmi/server/RemoteObjectInvocationHandler.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package java.rmi.server;
 26 
 27 import java.io.InvalidObjectException;
 28 import java.lang.reflect.InvocationHandler;
 29 import java.lang.reflect.Method;
 30 import java.lang.reflect.Proxy;
 31 import java.rmi.Remote;
<a name="2" id="anc2"></a><span class="line-added"> 32 import java.rmi.RemoteException;</span>
 33 import java.rmi.UnexpectedException;
 34 import java.rmi.activation.Activatable;
 35 import java.util.Map;
 36 import java.util.WeakHashMap;
 37 import sun.rmi.server.Util;
 38 import sun.rmi.server.WeakClassHashMap;
 39 
 40 /**
 41  * An implementation of the &lt;code&gt;InvocationHandler&lt;/code&gt; interface for
 42  * use with Java Remote Method Invocation (Java RMI).  This invocation
 43  * handler can be used in conjunction with a dynamic proxy instance as a
 44  * replacement for a pregenerated stub class.
 45  *
 46  * &lt;p&gt;Applications are not expected to use this class directly.  A remote
 47  * object exported to use a dynamic proxy with {@link UnicastRemoteObject}
 48  * or {@link Activatable} has an instance of this class as that proxy&#39;s
 49  * invocation handler.
 50  *
 51  * @author  Ann Wollrath
 52  * @since   1.5
 53  **/
 54 public class RemoteObjectInvocationHandler
 55     extends RemoteObject
 56     implements InvocationHandler
 57 {
 58     private static final long serialVersionUID = 2L;
 59 
 60     /**
 61      * A weak hash map, mapping classes to weak hash maps that map
 62      * method objects to method hashes.
 63      **/
 64     private static final MethodToHash_Maps methodToHash_Maps =
 65         new MethodToHash_Maps();
 66 
 67     /**
 68      * Creates a new &lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt; constructed
 69      * with the specified &lt;code&gt;RemoteRef&lt;/code&gt;.
 70      *
 71      * @param ref the remote ref
 72      *
 73      * @throws NullPointerException if &lt;code&gt;ref&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
 74      **/
 75     public RemoteObjectInvocationHandler(RemoteRef ref) {
 76         super(ref);
 77         if (ref == null) {
 78             throw new NullPointerException();
 79         }
 80     }
 81 
 82     /**
 83      * Processes a method invocation made on the encapsulating
 84      * proxy instance, &lt;code&gt;proxy&lt;/code&gt;, and returns the result.
 85      *
 86      * &lt;p&gt;&lt;code&gt;RemoteObjectInvocationHandler&lt;/code&gt; implements this method
 87      * as follows:
 88      *
 89      * &lt;p&gt;If &lt;code&gt;method&lt;/code&gt; is one of the following methods, it
 90      * is processed as described below:
 91      *
 92      * &lt;ul&gt;
 93      *
 94      * &lt;li&gt;{@link Object#hashCode Object.hashCode}: Returns the hash
 95      * code value for the proxy.
 96      *
 97      * &lt;li&gt;{@link Object#equals Object.equals}: Returns &lt;code&gt;true&lt;/code&gt;
 98      * if the argument (&lt;code&gt;args[0]&lt;/code&gt;) is an instance of a dynamic
 99      * proxy class and this invocation handler is equal to the invocation
100      * handler of that argument, and returns &lt;code&gt;false&lt;/code&gt; otherwise.
101      *
102      * &lt;li&gt;{@link Object#toString Object.toString}: Returns a string
103      * representation of the proxy.
104      * &lt;/ul&gt;
105      *
106      * &lt;p&gt;If &lt;code&gt;method&lt;/code&gt; overrides {@link Object#finalize Object.finalize},
107      * it is ignored.
108      *
109      * &lt;p&gt;Otherwise, a remote call is made as follows:
110      *
111      * &lt;ul&gt;
112      * &lt;li&gt;If &lt;code&gt;proxy&lt;/code&gt; is not an instance of the interface
113      * {@link Remote}, then an {@link IllegalArgumentException} is thrown.
114      *
115      * &lt;li&gt;Otherwise, the {@link RemoteRef#invoke invoke} method is invoked
116      * on this invocation handler&#39;s &lt;code&gt;RemoteRef&lt;/code&gt;, passing
117      * &lt;code&gt;proxy&lt;/code&gt;, &lt;code&gt;method&lt;/code&gt;, &lt;code&gt;args&lt;/code&gt;, and the
118      * method hash (defined in section 8.3 of the &quot;Java Remote Method
119      * Invocation (RMI) Specification&quot;) for &lt;code&gt;method&lt;/code&gt;, and the
120      * result is returned.
121      *
122      * &lt;li&gt;If an exception is thrown by &lt;code&gt;RemoteRef.invoke&lt;/code&gt; and
123      * that exception is a checked exception that is not assignable to any
124      * exception in the &lt;code&gt;throws&lt;/code&gt; clause of the method
125      * implemented by the &lt;code&gt;proxy&lt;/code&gt;&#39;s class, then that exception
126      * is wrapped in an {@link UnexpectedException} and the wrapped
127      * exception is thrown.  Otherwise, the exception thrown by
128      * &lt;code&gt;invoke&lt;/code&gt; is thrown by this method.
129      * &lt;/ul&gt;
130      *
131      * &lt;p&gt;The semantics of this method are unspecified if the
132      * arguments could not have been produced by an instance of some
133      * valid dynamic proxy class containing this invocation handler.
134      *
135      * @param proxy the proxy instance that the method was invoked on
136      * @param method the &lt;code&gt;Method&lt;/code&gt; instance corresponding to the
137      * interface method invoked on the proxy instance
138      * @param args an array of objects containing the values of the
139      * arguments passed in the method invocation on the proxy instance, or
140      * &lt;code&gt;null&lt;/code&gt; if the method takes no arguments
141      * @return the value to return from the method invocation on the proxy
142      * instance
143      * @throws  Throwable the exception to throw from the method invocation
144      * on the proxy instance
145      **/
146     public Object invoke(Object proxy, Method method, Object[] args)
147         throws Throwable
148     {
149         if (! Proxy.isProxyClass(proxy.getClass())) {
150             throw new IllegalArgumentException(&quot;not a proxy&quot;);
151         }
152 
153         if (Proxy.getInvocationHandler(proxy) != this) {
154             throw new IllegalArgumentException(&quot;handler mismatch&quot;);
155         }
156 
157         if (method.getDeclaringClass() == Object.class) {
158             return invokeObjectMethod(proxy, method, args);
159         } else if (&quot;finalize&quot;.equals(method.getName()) &amp;&amp; method.getParameterCount() == 0) {
160             return null; // ignore
161         } else {
162             return invokeRemoteMethod(proxy, method, args);
163         }
164     }
165 
166     /**
167      * Handles java.lang.Object methods.
168      **/
169     private Object invokeObjectMethod(Object proxy,
170                                       Method method,
171                                       Object[] args)
172     {
173         String name = method.getName();
174 
175         if (name.equals(&quot;hashCode&quot;)) {
176             return hashCode();
177 
178         } else if (name.equals(&quot;equals&quot;)) {
179             Object obj = args[0];
180             InvocationHandler hdlr;
181             return
182                 proxy == obj ||
183                 (obj != null &amp;&amp;
184                  Proxy.isProxyClass(obj.getClass()) &amp;&amp;
185                  (hdlr = Proxy.getInvocationHandler(obj)) instanceof RemoteObjectInvocationHandler &amp;&amp;
186                  this.equals(hdlr));
187 
188         } else if (name.equals(&quot;toString&quot;)) {
189             return proxyToString(proxy);
190 
191         } else {
192             throw new IllegalArgumentException(
193                 &quot;unexpected Object method: &quot; + method);
194         }
195     }
196 
197     /**
198      * Handles remote methods.
199      **/
200     private Object invokeRemoteMethod(Object proxy,
201                                       Method method,
202                                       Object[] args)
203         throws Exception
204     {
205         try {
206             if (!(proxy instanceof Remote)) {
207                 throw new IllegalArgumentException(
208                     &quot;proxy not Remote instance&quot;);
209             }
<a name="3" id="anc3"></a><span class="line-added">210 </span>
<span class="line-added">211             // Verify that the method is declared on an interface that extends Remote</span>
<span class="line-added">212             Class&lt;?&gt; decl = method.getDeclaringClass();</span>
<span class="line-added">213             if (!Remote.class.isAssignableFrom(decl)) {</span>
<span class="line-added">214                 throw new RemoteException(&quot;Method is not Remote: &quot; + decl + &quot;::&quot; + method);</span>
<span class="line-added">215             }</span>
<span class="line-added">216 </span>
217             return ref.invoke((Remote) proxy, method, args,
218                               getMethodHash(method));
219         } catch (Exception e) {
220             if (!(e instanceof RuntimeException)) {
221                 Class&lt;?&gt; cl = proxy.getClass();
222                 try {
223                     method = cl.getMethod(method.getName(),
224                                           method.getParameterTypes());
225                 } catch (NoSuchMethodException nsme) {
226                     throw (IllegalArgumentException)
227                         new IllegalArgumentException().initCause(nsme);
228                 }
229                 Class&lt;?&gt; thrownType = e.getClass();
230                 for (Class&lt;?&gt; declaredType : method.getExceptionTypes()) {
231                     if (declaredType.isAssignableFrom(thrownType)) {
232                         throw e;
233                     }
234                 }
235                 e = new UnexpectedException(&quot;unexpected exception&quot;, e);
236             }
237             throw e;
238         }
239     }
240 
241     /**
242      * Returns a string representation for a proxy that uses this invocation
243      * handler.
244      **/
245     private String proxyToString(Object proxy) {
246         Class&lt;?&gt;[] interfaces = proxy.getClass().getInterfaces();
247         if (interfaces.length == 0) {
248             return &quot;Proxy[&quot; + this + &quot;]&quot;;
249         }
250         String iface = interfaces[0].getName();
251         if (iface.equals(&quot;java.rmi.Remote&quot;) &amp;&amp; interfaces.length &gt; 1) {
252             iface = interfaces[1].getName();
253         }
254         int dot = iface.lastIndexOf(&#39;.&#39;);
255         if (dot &gt;= 0) {
256             iface = iface.substring(dot + 1);
257         }
258         return &quot;Proxy[&quot; + iface + &quot;,&quot; + this + &quot;]&quot;;
259     }
260 
261     /**
262      * @throws InvalidObjectException unconditionally
263      **/
264     private void readObjectNoData() throws InvalidObjectException {
265         throw new InvalidObjectException(&quot;no data in stream; class: &quot; +
266                                          this.getClass().getName());
267     }
268 
269     /**
270      * Returns the method hash for the specified method.  Subsequent calls
271      * to &quot;getMethodHash&quot; passing the same method argument should be faster
272      * since this method caches internally the result of the method to
273      * method hash mapping.  The method hash is calculated using the
274      * &quot;computeMethodHash&quot; method.
275      *
276      * @param method the remote method
277      * @return the method hash for the specified method
278      */
279     private static long getMethodHash(Method method) {
280         return methodToHash_Maps.get(method.getDeclaringClass()).get(method);
281     }
282 
283     /**
284      * A weak hash map, mapping classes to weak hash maps that map
285      * method objects to method hashes.
286      **/
287     private static class MethodToHash_Maps
288         extends WeakClassHashMap&lt;Map&lt;Method,Long&gt;&gt;
289     {
290         MethodToHash_Maps() {}
291 
292         protected Map&lt;Method,Long&gt; computeValue(Class&lt;?&gt; remoteClass) {
293             return new WeakHashMap&lt;Method,Long&gt;() {
294                 public synchronized Long get(Object key) {
295                     Long hash = super.get(key);
296                     if (hash == null) {
297                         Method method = (Method) key;
298                         hash = Util.computeMethodHash(method);
299                         put(method, hash);
300                     }
301                     return hash;
302                 }
303             };
304         }
305     }
306 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
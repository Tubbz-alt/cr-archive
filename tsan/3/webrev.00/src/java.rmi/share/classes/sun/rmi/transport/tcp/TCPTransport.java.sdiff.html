<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.rmi/share/classes/sun/rmi/transport/tcp/TCPTransport.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TCPEndpoint.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../man/rmid.1.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.rmi/share/classes/sun/rmi/transport/tcp/TCPTransport.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
256         } finally {
257             if (!ok) {
258                 synchronized (this) {
259                     decrementExportCount();
260                 }
261             }
262         }
263     }
264 
265     protected synchronized void targetUnexported() {
266         decrementExportCount();
267     }
268 
269     /**
270      * Decrements the count of exported objects, closing the current
271      * server socket if the count reaches zero.
272      **/
273     private void decrementExportCount() {
274         assert Thread.holdsLock(this);
275         exportCount--;




276         if (exportCount == 0 &amp;&amp; getEndpoint().getListenPort() != 0) {
277             ServerSocket ss = server;
278             server = null;
279             try {



280                 ss.close();
281             } catch (IOException e) {




282             }
283         }
284     }
285 
286     /**
287      * Verify that the current access control context has permission to
288      * accept the connection being dispatched by the current thread.
289      */
290     protected void checkAcceptPermission(AccessControlContext acc) {
291         SecurityManager sm = System.getSecurityManager();
292         if (sm == null) {
293             return;
294         }
295         ConnectionHandler h = threadConnectionHandler.get();
296         if (h == null) {
297             throw new Error(
298                 &quot;checkAcceptPermission not in ConnectionHandler thread&quot;);
299         }
300         h.checkAcceptPermission(sm, acc);
301     }
</pre>
<hr />
<pre>
349     /**
350      * Worker for accepting connections from a server socket.
351      **/
352     private class AcceptLoop implements Runnable {
353 
354         private final ServerSocket serverSocket;
355 
356         // state for throttling loop on exceptions (local to accept thread)
357         private long lastExceptionTime = 0L;
358         private int recentExceptionCount;
359 
360         AcceptLoop(ServerSocket serverSocket) {
361             this.serverSocket = serverSocket;
362         }
363 
364         public void run() {
365             try {
366                 executeAcceptLoop();
367             } finally {
368                 try {




369                     /*
370                      * Only one accept loop is started per server
371                      * socket, so after no more connections will be
372                      * accepted, ensure that the server socket is no
373                      * longer listening.
374                      */
375                     serverSocket.close();
376                 } catch (IOException e) {




377                 }
378             }
379         }
380 
381         /**
382          * Accepts connections from the server socket and executes
383          * handlers for them in the thread pool.
384          **/
385         private void executeAcceptLoop() {
386             if (tcpLog.isLoggable(Log.BRIEF)) {
387                 tcpLog.log(Log.BRIEF, &quot;listening on port &quot; +
388                            getEndpoint().getPort());
389             }
390 
391             while (true) {
392                 Socket socket = null;
393                 try {
394                     socket = serverSocket.accept();
395 
396                     /*
</pre>
<hr />
<pre>
507             long now = System.currentTimeMillis();
508             if (lastExceptionTime == 0L || (now - lastExceptionTime) &gt; 5000) {
509                 // last exception was long ago (or this is the first)
510                 lastExceptionTime = now;
511                 recentExceptionCount = 0;
512             } else {
513                 // exception burst window was started recently
514                 if (++recentExceptionCount &gt;= 10) {
515                     try {
516                         Thread.sleep(10000);
517                     } catch (InterruptedException ignore) {
518                     }
519                 }
520             }
521         }
522     }
523 
524     /** close socket and eat exception */
525     private static void closeSocket(Socket sock) {
526         try {



527             sock.close();
528         } catch (IOException ex) {
529             // eat exception



530         }
531     }
532 
533     /**
534      * handleMessages decodes transport operations and handles messages
535      * appropriately.  If an exception occurs during message handling,
536      * the socket is closed.
537      */
538     void handleMessages(Connection conn, boolean persistent) {
539         int port = getEndpoint().getPort();
540 
541         try {
542             DataInputStream in = new DataInputStream(conn.getInputStream());
543             do {
544                 int op = in.read();     // transport op
545                 if (op == -1) {
546                     if (tcpLog.isLoggable(Log.BRIEF)) {
547                         tcpLog.log(Log.BRIEF, &quot;(port &quot; +
548                             port + &quot;) connection closed&quot;);
549                     }
</pre>
<hr />
<pre>
574                 case TransportConstants.DGCAck:
575                     DGCAckHandler.received(UID.read(in));
576                     break;
577 
578                 default:
579                     throw new IOException(&quot;unknown transport op &quot; + op);
580                 }
581             } while (persistent);
582 
583         } catch (IOException e) {
584             // exception during processing causes connection to close (below)
585             if (tcpLog.isLoggable(Log.BRIEF)) {
586                 tcpLog.log(Log.BRIEF, &quot;(port &quot; + port +
587                     &quot;) exception: &quot;, e);
588             }
589         } finally {
590             try {
591                 conn.close();
592             } catch (IOException ex) {
593                 // eat exception



594             }
595         }
596     }
597 
598     /**
599      * Returns the client host for the current thread&#39;s connection.  Throws
600      * ServerNotActiveException if no connection is active for this thread.
601      */
602     public static String getClientHost() throws ServerNotActiveException {
603         ConnectionHandler h = threadConnectionHandler.get();
604         if (h != null) {
605             return h.getClientHost();
606         } else {
607             throw new ServerNotActiveException(&quot;not in a remote call&quot;);
608         }
609     }
610 
611     /**
612      * Services messages on accepted connection
613      */
</pre>
<hr />
<pre>
706             }
707 
708             try {
709                 InputStream sockIn = socket.getInputStream();
710                 InputStream bufIn = sockIn.markSupported()
711                         ? sockIn
712                         : new BufferedInputStream(sockIn);
713 
714                 // Read magic
715                 DataInputStream in = new DataInputStream(bufIn);
716                 int magic = in.readInt();
717 
718                 // read and verify transport header
719                 short version = in.readShort();
720                 if (magic != TransportConstants.Magic ||
721                     version != TransportConstants.Version) {
722                     // protocol mismatch detected...
723                     // just close socket: this would recurse if we marshal an
724                     // exception to the client and the protocol at other end
725                     // doesn&#39;t match.




726                     closeSocket(socket);
727                     return;
728                 }
729 
730                 OutputStream sockOut = socket.getOutputStream();
731                 BufferedOutputStream bufOut =
732                     new BufferedOutputStream(sockOut);
733                 DataOutputStream out = new DataOutputStream(bufOut);
734 
735                 int remotePort = socket.getPort();
736 
737                 if (tcpLog.isLoggable(Log.BRIEF)) {
738                     tcpLog.log(Log.BRIEF, &quot;accepted socket from [&quot; +
739                                      remoteHost + &quot;:&quot; + remotePort + &quot;]&quot;);
740                 }
741 
742                 TCPEndpoint ep;
743                 TCPChannel ch;
744                 TCPConnection conn;
745 
</pre>
</td>
<td>
<hr />
<pre>
256         } finally {
257             if (!ok) {
258                 synchronized (this) {
259                     decrementExportCount();
260                 }
261             }
262         }
263     }
264 
265     protected synchronized void targetUnexported() {
266         decrementExportCount();
267     }
268 
269     /**
270      * Decrements the count of exported objects, closing the current
271      * server socket if the count reaches zero.
272      **/
273     private void decrementExportCount() {
274         assert Thread.holdsLock(this);
275         exportCount--;
<span class="line-added">276         if (tcpLog.isLoggable(Log.VERBOSE)) {</span>
<span class="line-added">277             tcpLog.log(Log.VERBOSE,</span>
<span class="line-added">278                     &quot;server socket: &quot; + server + &quot;, exportCount: &quot; + exportCount);</span>
<span class="line-added">279         }</span>
280         if (exportCount == 0 &amp;&amp; getEndpoint().getListenPort() != 0) {
281             ServerSocket ss = server;
282             server = null;
283             try {
<span class="line-added">284                 if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">285                     tcpLog.log(Log.BRIEF, &quot;server socket close: &quot; + ss);</span>
<span class="line-added">286                 }</span>
287                 ss.close();
288             } catch (IOException e) {
<span class="line-added">289                 if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">290                     tcpLog.log(Log.BRIEF,</span>
<span class="line-added">291                             &quot;server socket close throws: &quot; + e);</span>
<span class="line-added">292                 }</span>
293             }
294         }
295     }
296 
297     /**
298      * Verify that the current access control context has permission to
299      * accept the connection being dispatched by the current thread.
300      */
301     protected void checkAcceptPermission(AccessControlContext acc) {
302         SecurityManager sm = System.getSecurityManager();
303         if (sm == null) {
304             return;
305         }
306         ConnectionHandler h = threadConnectionHandler.get();
307         if (h == null) {
308             throw new Error(
309                 &quot;checkAcceptPermission not in ConnectionHandler thread&quot;);
310         }
311         h.checkAcceptPermission(sm, acc);
312     }
</pre>
<hr />
<pre>
360     /**
361      * Worker for accepting connections from a server socket.
362      **/
363     private class AcceptLoop implements Runnable {
364 
365         private final ServerSocket serverSocket;
366 
367         // state for throttling loop on exceptions (local to accept thread)
368         private long lastExceptionTime = 0L;
369         private int recentExceptionCount;
370 
371         AcceptLoop(ServerSocket serverSocket) {
372             this.serverSocket = serverSocket;
373         }
374 
375         public void run() {
376             try {
377                 executeAcceptLoop();
378             } finally {
379                 try {
<span class="line-added">380                     if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">381                         tcpLog.log(Log.BRIEF,</span>
<span class="line-added">382                                 &quot;server socket close: &quot; + serverSocket);</span>
<span class="line-added">383                     }</span>
384                     /*
385                      * Only one accept loop is started per server
386                      * socket, so after no more connections will be
387                      * accepted, ensure that the server socket is no
388                      * longer listening.
389                      */
390                     serverSocket.close();
391                 } catch (IOException e) {
<span class="line-added">392                     if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">393                         tcpLog.log(Log.BRIEF,</span>
<span class="line-added">394                                 &quot;server socket close throws: &quot; + e);</span>
<span class="line-added">395                     }</span>
396                 }
397             }
398         }
399 
400         /**
401          * Accepts connections from the server socket and executes
402          * handlers for them in the thread pool.
403          **/
404         private void executeAcceptLoop() {
405             if (tcpLog.isLoggable(Log.BRIEF)) {
406                 tcpLog.log(Log.BRIEF, &quot;listening on port &quot; +
407                            getEndpoint().getPort());
408             }
409 
410             while (true) {
411                 Socket socket = null;
412                 try {
413                     socket = serverSocket.accept();
414 
415                     /*
</pre>
<hr />
<pre>
526             long now = System.currentTimeMillis();
527             if (lastExceptionTime == 0L || (now - lastExceptionTime) &gt; 5000) {
528                 // last exception was long ago (or this is the first)
529                 lastExceptionTime = now;
530                 recentExceptionCount = 0;
531             } else {
532                 // exception burst window was started recently
533                 if (++recentExceptionCount &gt;= 10) {
534                     try {
535                         Thread.sleep(10000);
536                     } catch (InterruptedException ignore) {
537                     }
538                 }
539             }
540         }
541     }
542 
543     /** close socket and eat exception */
544     private static void closeSocket(Socket sock) {
545         try {
<span class="line-added">546             if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">547                 tcpLog.log(Log.BRIEF, &quot;socket close: &quot; + sock);</span>
<span class="line-added">548             }</span>
549             sock.close();
550         } catch (IOException ex) {
551             // eat exception
<span class="line-added">552             if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">553                 tcpLog.log(Log.BRIEF, &quot;socket close throws: &quot; + ex);</span>
<span class="line-added">554             }</span>
555         }
556     }
557 
558     /**
559      * handleMessages decodes transport operations and handles messages
560      * appropriately.  If an exception occurs during message handling,
561      * the socket is closed.
562      */
563     void handleMessages(Connection conn, boolean persistent) {
564         int port = getEndpoint().getPort();
565 
566         try {
567             DataInputStream in = new DataInputStream(conn.getInputStream());
568             do {
569                 int op = in.read();     // transport op
570                 if (op == -1) {
571                     if (tcpLog.isLoggable(Log.BRIEF)) {
572                         tcpLog.log(Log.BRIEF, &quot;(port &quot; +
573                             port + &quot;) connection closed&quot;);
574                     }
</pre>
<hr />
<pre>
599                 case TransportConstants.DGCAck:
600                     DGCAckHandler.received(UID.read(in));
601                     break;
602 
603                 default:
604                     throw new IOException(&quot;unknown transport op &quot; + op);
605                 }
606             } while (persistent);
607 
608         } catch (IOException e) {
609             // exception during processing causes connection to close (below)
610             if (tcpLog.isLoggable(Log.BRIEF)) {
611                 tcpLog.log(Log.BRIEF, &quot;(port &quot; + port +
612                     &quot;) exception: &quot;, e);
613             }
614         } finally {
615             try {
616                 conn.close();
617             } catch (IOException ex) {
618                 // eat exception
<span class="line-added">619                 if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">620                     tcpLog.log(Log.BRIEF, &quot;Connection close throws &quot; + ex);</span>
<span class="line-added">621                 }</span>
622             }
623         }
624     }
625 
626     /**
627      * Returns the client host for the current thread&#39;s connection.  Throws
628      * ServerNotActiveException if no connection is active for this thread.
629      */
630     public static String getClientHost() throws ServerNotActiveException {
631         ConnectionHandler h = threadConnectionHandler.get();
632         if (h != null) {
633             return h.getClientHost();
634         } else {
635             throw new ServerNotActiveException(&quot;not in a remote call&quot;);
636         }
637     }
638 
639     /**
640      * Services messages on accepted connection
641      */
</pre>
<hr />
<pre>
734             }
735 
736             try {
737                 InputStream sockIn = socket.getInputStream();
738                 InputStream bufIn = sockIn.markSupported()
739                         ? sockIn
740                         : new BufferedInputStream(sockIn);
741 
742                 // Read magic
743                 DataInputStream in = new DataInputStream(bufIn);
744                 int magic = in.readInt();
745 
746                 // read and verify transport header
747                 short version = in.readShort();
748                 if (magic != TransportConstants.Magic ||
749                     version != TransportConstants.Version) {
750                     // protocol mismatch detected...
751                     // just close socket: this would recurse if we marshal an
752                     // exception to the client and the protocol at other end
753                     // doesn&#39;t match.
<span class="line-added">754                     if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">755                         tcpLog.log(Log.BRIEF, &quot;magic or version not match: &quot;</span>
<span class="line-added">756                                                   + magic + &quot;, &quot; + version);</span>
<span class="line-added">757                     }</span>
758                     closeSocket(socket);
759                     return;
760                 }
761 
762                 OutputStream sockOut = socket.getOutputStream();
763                 BufferedOutputStream bufOut =
764                     new BufferedOutputStream(sockOut);
765                 DataOutputStream out = new DataOutputStream(bufOut);
766 
767                 int remotePort = socket.getPort();
768 
769                 if (tcpLog.isLoggable(Log.BRIEF)) {
770                     tcpLog.log(Log.BRIEF, &quot;accepted socket from [&quot; +
771                                      remoteHost + &quot;:&quot; + remotePort + &quot;]&quot;);
772                 }
773 
774                 TCPEndpoint ep;
775                 TCPChannel ch;
776                 TCPConnection conn;
777 
</pre>
</td>
</tr>
</table>
<center><a href="TCPEndpoint.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../man/rmid.1.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.rmi/share/classes/sun/rmi/transport/tcp/TCPEndpoint.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.rmi.transport.tcp;
 26 
 27 import java.io.DataInput;
 28 import java.io.DataOutput;
 29 import java.io.IOException;
 30 import java.io.ObjectInput;
 31 import java.io.ObjectOutput;
<a name="2" id="anc2"></a><span class="line-added"> 32 import java.lang.reflect.Proxy;</span>
 33 import java.net.InetAddress;
 34 import java.net.ServerSocket;
 35 import java.net.Socket;
 36 import java.rmi.ConnectIOException;
 37 import java.rmi.RemoteException;
 38 import java.rmi.server.RMIClientSocketFactory;
 39 import java.rmi.server.RMIServerSocketFactory;
 40 import java.rmi.server.RMISocketFactory;
 41 import java.security.AccessController;
 42 import java.security.PrivilegedAction;
 43 import java.util.Collection;
 44 import java.util.HashMap;
 45 import java.util.HashSet;
 46 import java.util.LinkedList;
 47 import java.util.Map;
 48 import java.util.Set;
 49 import sun.rmi.runtime.Log;
 50 import sun.rmi.runtime.NewThreadAction;
 51 import sun.rmi.transport.Channel;
 52 import sun.rmi.transport.Endpoint;
 53 import sun.rmi.transport.Target;
 54 import sun.rmi.transport.Transport;
 55 
 56 /**
 57  * TCPEndpoint represents some communication endpoint for an address
 58  * space (VM).
 59  *
 60  * @author Ann Wollrath
 61  */
 62 public class TCPEndpoint implements Endpoint {
 63     /** IP address or host name */
 64     private String host;
 65     /** port number */
 66     private int port;
 67     /** custom client socket factory (null if not custom factory) */
 68     private final RMIClientSocketFactory csf;
 69     /** custom server socket factory (null if not custom factory) */
 70     private final RMIServerSocketFactory ssf;
 71 
 72     /** if local, the port number to listen on */
 73     private int listenPort = -1;
 74     /** if local, the transport object associated with this endpoint */
 75     private TCPTransport transport = null;
 76 
 77     /** the local host name */
 78     private static String localHost;
 79     /** true if real local host name is known yet */
 80     private static boolean localHostKnown;
 81 
 82     // this should be a *private* method since it is privileged
 83     private static int getInt(String name, int def) {
 84         return AccessController.doPrivileged(
 85                 (PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.getInteger(name, def));
 86     }
 87 
 88     // this should be a *private* method since it is privileged
 89     private static boolean getBoolean(String name) {
 90         return AccessController.doPrivileged(
 91                 (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(name));
 92     }
 93 
 94     /**
 95      * Returns the value of the java.rmi.server.hostname property.
 96      */
 97     private static String getHostnameProperty() {
 98         return AccessController.doPrivileged(
 99             (PrivilegedAction&lt;String&gt;) () -&gt; System.getProperty(&quot;java.rmi.server.hostname&quot;));
100     }
101 
102     /**
103      * Find host name of local machine.  Property &quot;java.rmi.server.hostname&quot;
104      * is used if set, so server administrator can compensate for the possible
105      * inablility to get fully qualified host name from VM.
106      */
107     static {
108         localHostKnown = true;
109         localHost = getHostnameProperty();
110 
111         // could try querying CGI program here?
112         if (localHost == null) {
113             try {
114                 InetAddress localAddr = InetAddress.getLocalHost();
115                 byte[] raw = localAddr.getAddress();
116                 if ((raw[0] == 127) &amp;&amp;
117                     (raw[1] ==   0) &amp;&amp;
118                     (raw[2] ==   0) &amp;&amp;
119                     (raw[3] ==   1)) {
120                     localHostKnown = false;
121                 }
122 
123                 /* if the user wishes to use a fully qualified domain
124                  * name then attempt to find one.
125                  */
126                 if (getBoolean(&quot;java.rmi.server.useLocalHostName&quot;)) {
127                     localHost = FQDN.attemptFQDN(localAddr);
128                 } else {
129                     /* default to using ip addresses, names will
130                      * work across seperate domains.
131                      */
132                     localHost = localAddr.getHostAddress();
133                 }
134             } catch (Exception e) {
135                 localHostKnown = false;
136                 localHost = null;
137             }
138         }
139 
140         if (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) {
141             TCPTransport.tcpLog.log(Log.BRIEF,
142                 &quot;localHostKnown = &quot; + localHostKnown +
143                 &quot;, localHost = &quot; + localHost);
144         }
145     }
146 
147     /** maps an endpoint key containing custom socket factories to
148      * their own unique endpoint */
149     // TBD: should this be a weak hash table?
150     private static final
151         Map&lt;TCPEndpoint,LinkedList&lt;TCPEndpoint&gt;&gt; localEndpoints =
152         new HashMap&lt;&gt;();
153 
154     /**
155      * Create an endpoint for a specified host and port.
156      * This should not be used by external classes to create endpoints
157      * for servers in this VM; use getLocalEndpoint instead.
158      */
159     public TCPEndpoint(String host, int port) {
160         this(host, port, null, null);
161     }
162 
163     /**
164      * Create a custom socket factory endpoint for a specified host and port.
165      * This should not be used by external classes to create endpoints
166      * for servers in this VM; use getLocalEndpoint instead.
167      */
168     public TCPEndpoint(String host, int port, RMIClientSocketFactory csf,
169                        RMIServerSocketFactory ssf)
170     {
171         if (host == null)
172             host = &quot;&quot;;
173         this.host = host;
174         this.port = port;
175         this.csf = csf;
176         this.ssf = ssf;
177     }
178 
179     /**
180      * Get an endpoint for the local address space on specified port.
181      * If port number is 0, it returns shared default endpoint object
182      * whose host name and port may or may not have been determined.
183      */
184     public static TCPEndpoint getLocalEndpoint(int port) {
185         return getLocalEndpoint(port, null, null);
186     }
187 
188     public static TCPEndpoint getLocalEndpoint(int port,
189                                                RMIClientSocketFactory csf,
190                                                RMIServerSocketFactory ssf)
191     {
192         /*
193          * Find mapping for an endpoint key to the list of local unique
194          * endpoints for this client/server socket factory pair (perhaps
195          * null) for the specific port.
196          */
197         TCPEndpoint ep = null;
198 
199         synchronized (localEndpoints) {
200             TCPEndpoint endpointKey = new TCPEndpoint(null, port, csf, ssf);
201             LinkedList&lt;TCPEndpoint&gt; epList = localEndpoints.get(endpointKey);
202             String localHost = resampleLocalHost();
203 
204             if (epList == null) {
205                 /*
206                  * Create new endpoint list.
207                  */
208                 ep = new TCPEndpoint(localHost, port, csf, ssf);
209                 epList = new LinkedList&lt;TCPEndpoint&gt;();
210                 epList.add(ep);
211                 ep.listenPort = port;
212                 ep.transport = new TCPTransport(epList);
213                 localEndpoints.put(endpointKey, epList);
214 
215                 if (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) {
216                     TCPTransport.tcpLog.log(Log.BRIEF,
217                         &quot;created local endpoint for socket factory &quot; + ssf +
218                         &quot; on port &quot; + port);
219                 }
220             } else {
221                 synchronized (epList) {
222                     ep = epList.getLast();
223                     String lastHost = ep.host;
224                     int lastPort =  ep.port;
225                     TCPTransport lastTransport = ep.transport;
226                     // assert (localHost == null ^ lastHost != null)
227                     if (localHost != null &amp;&amp; !localHost.equals(lastHost)) {
228                         /*
229                          * Hostname has been updated; add updated endpoint
230                          * to list.
231                          */
232                         if (lastPort != 0) {
233                             /*
234                              * Remove outdated endpoints only if the
235                              * port has already been set on those endpoints.
236                              */
237                             epList.clear();
238                         }
239                         ep = new TCPEndpoint(localHost, lastPort, csf, ssf);
240                         ep.listenPort = port;
241                         ep.transport = lastTransport;
242                         epList.add(ep);
243                     }
244                 }
245             }
246         }
247 
248         return ep;
249     }
250 
251     /**
252      * Resamples the local hostname and returns the possibly-updated
253      * local hostname.
254      */
255     private static String resampleLocalHost() {
256 
257         String hostnameProperty = getHostnameProperty();
258 
259         synchronized (localEndpoints) {
260             // assert(localHostKnown ^ (localHost == null))
261 
262             if (hostnameProperty != null) {
263                 if (!localHostKnown) {
264                     /*
265                      * If the local hostname is unknown, update ALL
266                      * existing endpoints with the new hostname.
267                      */
268                     setLocalHost(hostnameProperty);
269                 } else if (!hostnameProperty.equals(localHost)) {
270                     /*
271                      * Only update the localHost field for reference
272                      * in future endpoint creation.
273                      */
274                     localHost = hostnameProperty;
275 
276                     if (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) {
277                         TCPTransport.tcpLog.log(Log.BRIEF,
278                             &quot;updated local hostname to: &quot; + localHost);
279                     }
280                 }
281             }
282             return localHost;
283         }
284     }
285 
286     /**
287      * Set the local host name, if currently unknown.
288      */
289     static void setLocalHost(String host) {
290         // assert (host != null)
291 
292         synchronized (localEndpoints) {
293             /*
294              * If host is not known, change the host field of ALL
295              * the local endpoints.
296              */
297             if (!localHostKnown) {
298                 localHost = host;
299                 localHostKnown = true;
300 
301                 if (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) {
302                     TCPTransport.tcpLog.log(Log.BRIEF,
303                         &quot;local host set to &quot; + host);
304                 }
305                 for (LinkedList&lt;TCPEndpoint&gt; epList : localEndpoints.values())
306                 {
307                     synchronized (epList) {
308                         for (TCPEndpoint ep : epList) {
309                             ep.host = host;
310                         }
311                     }
312                 }
313             }
314         }
315     }
316 
317     /**
318      * Set the port of the (shared) default endpoint object.
319      * When first created, it contains port 0 because the transport
320      * hasn&#39;t tried to listen to get assigned a port, or if listening
321      * failed, a port hasn&#39;t been assigned from the server.
322      */
323     static void setDefaultPort(int port, RMIClientSocketFactory csf,
324                                RMIServerSocketFactory ssf)
325     {
326         TCPEndpoint endpointKey = new TCPEndpoint(null, 0, csf, ssf);
327 
328         synchronized (localEndpoints) {
329             LinkedList&lt;TCPEndpoint&gt; epList = localEndpoints.get(endpointKey);
330 
331             synchronized (epList) {
332                 int size = epList.size();
333                 TCPEndpoint lastEp = epList.getLast();
334 
335                 for (TCPEndpoint ep : epList) {
336                     ep.port = port;
337                 }
338                 if (size &gt; 1) {
339                     /*
340                      * Remove all but the last element of the list
341                      * (which contains the most recent hostname).
342                      */
343                     epList.clear();
344                     epList.add(lastEp);
345                 }
346             }
347 
348             /*
349              * Allow future exports to use the actual bound port
350              * explicitly (see 6269166).
351              */
352             TCPEndpoint newEndpointKey = new TCPEndpoint(null, port, csf, ssf);
353             localEndpoints.put(newEndpointKey, epList);
354 
355             if (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) {
356                 TCPTransport.tcpLog.log(Log.BRIEF,
357                     &quot;default port for server socket factory &quot; + ssf +
358                     &quot; and client socket factory &quot; + csf +
359                     &quot; set to &quot; + port);
360             }
361         }
362     }
363 
364     /**
365      * Returns transport for making connections to remote endpoints;
366      * (here, the default transport at port 0 is used).
367      */
368     public Transport getOutboundTransport() {
369         TCPEndpoint localEndpoint = getLocalEndpoint(0, null, null);
370         return localEndpoint.transport;
371     }
372 
373     /**
374      * Returns the current list of known transports.
375      * The returned list is an unshared collection of Transports,
376      * including all transports which may have channels to remote
377      * endpoints.
378      */
379     private static Collection&lt;TCPTransport&gt; allKnownTransports() {
380         // Loop through local endpoints, getting the transport of each one.
381         Set&lt;TCPTransport&gt; s;
382         synchronized (localEndpoints) {
383             // presize s to number of localEndpoints
384             s = new HashSet&lt;TCPTransport&gt;(localEndpoints.size());
385             for (LinkedList&lt;TCPEndpoint&gt; epList : localEndpoints.values()) {
386                 /*
387                  * Each local endpoint has its transport added to s.
388                  * Note: the transport is the same for all endpoints
389                  * in the list, so it is okay to pick any one of them.
390                  */
391                 TCPEndpoint ep = epList.getFirst();
392                 s.add(ep.transport);
393             }
394         }
395         return s;
396     }
397 
398     /**
399      * Release idle outbound connections to reduce demand on I/O resources.
400      * All transports are asked to release excess connections.
401      */
402     public static void shedConnectionCaches() {
403         for (TCPTransport transport : allKnownTransports()) {
404             transport.shedConnectionCaches();
405         }
406     }
407 
408     /**
409      * Export the object to accept incoming calls.
410      */
411     public void exportObject(Target target) throws RemoteException {
412         transport.exportObject(target);
413     }
414 
415     /**
416      * Returns a channel for this (remote) endpoint.
417      */
418     public Channel getChannel() {
419         return getOutboundTransport().getChannel(this);
420     }
421 
422     /**
423      * Returns address for endpoint
424      */
425     public String getHost() {
426         return host;
427     }
428 
429     /**
430      * Returns the port for this endpoint.  If this endpoint was
431      * created as a server endpoint (using getLocalEndpoint) for a
432      * default/anonymous port and its inbound transport has started
433      * listening, this method returns (instead of zero) the actual
434      * bound port suitable for passing to clients.
435      **/
436     public int getPort() {
437         return port;
438     }
439 
440     /**
441      * Returns the port that this endpoint&#39;s inbound transport listens
442      * on, if this endpoint was created as a server endpoint (using
443      * getLocalEndpoint).  If this endpoint was created for the
444      * default/anonymous port, then this method returns zero even if
445      * the transport has started listening.
446      **/
447     public int getListenPort() {
448         return listenPort;
449     }
450 
451     /**
452      * Returns the transport for incoming connections to this
453      * endpoint, if this endpoint was created as a server endpoint
454      * (using getLocalEndpoint).
455      **/
456     public Transport getInboundTransport() {
457         return transport;
458     }
459 
460     /**
461      * Get the client socket factory associated with this endpoint.
462      */
463     public RMIClientSocketFactory getClientSocketFactory() {
464         return csf;
465     }
466 
467     /**
468      * Get the server socket factory associated with this endpoint.
469      */
470     public RMIServerSocketFactory getServerSocketFactory() {
471         return ssf;
472     }
473 
474     /**
475      * Return string representation for endpoint.
476      */
477     public String toString() {
478         return &quot;[&quot; + host + &quot;:&quot; + port +
479             (ssf != null ? &quot;,&quot; + ssf : &quot;&quot;) +
480             (csf != null ? &quot;,&quot; + csf : &quot;&quot;) +
481             &quot;]&quot;;
482     }
483 
484     public int hashCode() {
485         return port;
486     }
487 
488     public boolean equals(Object obj) {
489         if ((obj != null) &amp;&amp; (obj instanceof TCPEndpoint)) {
490             TCPEndpoint ep = (TCPEndpoint) obj;
491             if (port != ep.port || !host.equals(ep.host))
492                 return false;
493             if (((csf == null) ^ (ep.csf == null)) ||
494                 ((ssf == null) ^ (ep.ssf == null)))
495                 return false;
496             /*
497              * Fix for 4254510: perform socket factory *class* equality check
498              * before socket factory equality check to avoid passing
499              * a potentially naughty socket factory to this endpoint&#39;s
500              * {client,server} socket factory equals method.
501              */
502             if ((csf != null) &amp;&amp;
503                 !(csf.getClass() == ep.csf.getClass() &amp;&amp; csf.equals(ep.csf)))
504                 return false;
505             if ((ssf != null) &amp;&amp;
506                 !(ssf.getClass() == ep.ssf.getClass() &amp;&amp; ssf.equals(ep.ssf)))
507                 return false;
508             return true;
509         } else {
510             return false;
511         }
512     }
513 
514     /* codes for the self-describing formats of wire representation */
515     private static final int FORMAT_HOST_PORT           = 0;
516     private static final int FORMAT_HOST_PORT_FACTORY   = 1;
517 
518     /**
519      * Write endpoint to output stream.
520      */
521     public void write(ObjectOutput out) throws IOException {
522         if (csf == null) {
523             out.writeByte(FORMAT_HOST_PORT);
524             out.writeUTF(host);
525             out.writeInt(port);
526         } else {
527             out.writeByte(FORMAT_HOST_PORT_FACTORY);
528             out.writeUTF(host);
529             out.writeInt(port);
530             out.writeObject(csf);
531         }
532     }
533 
534     /**
535      * Get the endpoint from the input stream.
536      * @param in the input stream
537      * @exception IOException If id could not be read (due to stream failure)
538      */
539     public static TCPEndpoint read(ObjectInput in)
540         throws IOException, ClassNotFoundException
541     {
542         String host;
543         int port;
544         RMIClientSocketFactory csf = null;
545 
546         byte format = in.readByte();
547         switch (format) {
548           case FORMAT_HOST_PORT:
549             host = in.readUTF();
550             port = in.readInt();
551             break;
552 
553           case FORMAT_HOST_PORT_FACTORY:
554             host = in.readUTF();
555             port = in.readInt();
556             csf = (RMIClientSocketFactory) in.readObject();
<a name="3" id="anc3"></a><span class="line-added">557             if (csf != null &amp;&amp; Proxy.isProxyClass(csf.getClass())) {</span>
<span class="line-added">558                 throw new IOException(&quot;Invalid SocketFactory&quot;);</span>
<span class="line-added">559             }</span>
560           break;
561 
562           default:
563             throw new IOException(&quot;invalid endpoint format&quot;);
564         }
565         return new TCPEndpoint(host, port, csf, null);
566     }
567 
568     /**
569      * Write endpoint to output stream in older format used by
570      * UnicastRef for JDK1.1 compatibility.
571      */
572     public void writeHostPortFormat(DataOutput out) throws IOException {
573         if (csf != null) {
574             throw new InternalError(&quot;TCPEndpoint.writeHostPortFormat: &quot; +
575                 &quot;called for endpoint with non-null socket factory&quot;);
576         }
577         out.writeUTF(host);
578         out.writeInt(port);
579     }
580 
581     /**
582      * Create a new endpoint from input stream data.
583      * @param in the input stream
584      */
585     public static TCPEndpoint readHostPortFormat(DataInput in)
586         throws IOException
587     {
588         String host = in.readUTF();
589         int port = in.readInt();
590         return new TCPEndpoint(host, port);
591     }
592 
593     private static RMISocketFactory chooseFactory() {
594         RMISocketFactory sf = RMISocketFactory.getSocketFactory();
595         if (sf == null) {
596             sf = TCPTransport.defaultSocketFactory;
597         }
598         return sf;
599     }
600 
601     /**
602      * Open and return new client socket connection to endpoint.
603      */
604     Socket newSocket() throws RemoteException {
605         if (TCPTransport.tcpLog.isLoggable(Log.VERBOSE)) {
606             TCPTransport.tcpLog.log(Log.VERBOSE,
607                 &quot;opening socket to &quot; + this);
608         }
609 
610         Socket socket;
611 
612         try {
613             RMIClientSocketFactory clientFactory = csf;
614             if (clientFactory == null) {
615                 clientFactory = chooseFactory();
616             }
617             socket = clientFactory.createSocket(host, port);
618 
619         } catch (java.net.UnknownHostException e) {
620             throw new java.rmi.UnknownHostException(
621                 &quot;Unknown host: &quot; + host, e);
622         } catch (java.net.ConnectException e) {
623             throw new java.rmi.ConnectException(
624                 &quot;Connection refused to host: &quot; + host, e);
625         } catch (IOException e) {
626             // We might have simply run out of file descriptors
627             try {
628                 TCPEndpoint.shedConnectionCaches();
629                 // REMIND: should we retry createSocket?
630             } catch (OutOfMemoryError | Exception mem) {
631                 // don&#39;t quit if out of memory
632                 // or shed fails non-catastrophically
633             }
634 
635             throw new ConnectIOException(&quot;Exception creating connection to: &quot; +
636                 host, e);
637         }
638 
639         // set socket to disable Nagle&#39;s algorithm (always send immediately)
640         // TBD: should this be left up to socket factory instead?
641         try {
642             socket.setTcpNoDelay(true);
643         } catch (Exception e) {
644             // if we fail to set this, ignore and proceed anyway
645         }
646 
647         // fix 4187495: explicitly set SO_KEEPALIVE to prevent client hangs
648         try {
649             socket.setKeepAlive(true);
650         } catch (Exception e) {
651             // ignore and proceed
652         }
653 
654         return socket;
655     }
656 
657     /**
658      * Return new server socket to listen for connections on this endpoint.
659      */
660     ServerSocket newServerSocket() throws IOException {
661         if (TCPTransport.tcpLog.isLoggable(Log.VERBOSE)) {
662             TCPTransport.tcpLog.log(Log.VERBOSE,
663                 &quot;creating server socket on &quot; + this);
664         }
665 
666         RMIServerSocketFactory serverFactory = ssf;
667         if (serverFactory == null) {
668             serverFactory = chooseFactory();
669         }
670         ServerSocket server = serverFactory.createServerSocket(listenPort);
671 
672         // if we listened on an anonymous port, set the default port
673         // (for this socket factory)
674         if (listenPort == 0)
675             setDefaultPort(server.getLocalPort(), csf, ssf);
676 
677         return server;
678     }
679 
680     /**
681      * The class FQDN encapsulates a routine that makes a best effort
682      * attempt to retrieve the fully qualified domain name of the local
683      * host.
684      *
685      * @author  Laird Dornin
686      */
687     private static class FQDN implements Runnable {
688 
689         /**
690          * strings in which we can store discovered fqdn
691          */
692         private String reverseLookup;
693 
694         private String hostAddress;
695 
696         private FQDN(String hostAddress) {
697             this.hostAddress = hostAddress;
698         }
699 
700         /**
701          * Do our best to obtain a fully qualified hostname for the local
702          * host.  Perform the following steps to get a localhostname:
703          *
704          * 1. InetAddress.getLocalHost().getHostName() - if contains
705          *    &#39;.&#39; use as FQDN
706          * 2. if no &#39;.&#39; query name service for FQDN in a thread
707          *    Note: We query the name service for an FQDN by creating
708          *    an InetAddress via a stringified copy of the local ip
709          *    address; this creates an InetAddress with a null hostname.
710          *    Asking for the hostname of this InetAddress causes a name
711          *    service lookup.
712          *
713          * 3. if name service takes too long to return, use ip address
714          * 4. if name service returns but response contains no &#39;.&#39;
715          *    default to ipaddress.
716          */
717         static String attemptFQDN(InetAddress localAddr)
718             throws java.net.UnknownHostException
719         {
720 
721             String hostName = localAddr.getHostName();
722 
723             if (hostName.indexOf(&#39;.&#39;) &lt; 0 ) {
724 
725                 String hostAddress = localAddr.getHostAddress();
726                 FQDN f = new FQDN(hostAddress);
727 
728                 int nameServiceTimeOut =
729                     TCPEndpoint.getInt(&quot;sun.rmi.transport.tcp.localHostNameTimeOut&quot;,
730                                        10000);
731 
732                 try {
733                     synchronized(f) {
734                         f.getFQDN();
735 
736                         /* wait to obtain an FQDN */
737                         f.wait(nameServiceTimeOut);
738                     }
739                 } catch (InterruptedException e) {
740                     /* propagate the exception to the caller */
741                     Thread.currentThread().interrupt();
742                 }
743                 hostName = f.getHost();
744 
745                 if ((hostName == null) || (hostName.isEmpty())
746                     || (hostName.indexOf(&#39;.&#39;) &lt; 0 )) {
747 
748                     hostName = hostAddress;
749                 }
750             }
751             return hostName;
752         }
753 
754         /**
755          * Method that that will start a thread to wait to retrieve a
756          * fully qualified domain name from a name service.  The spawned
757          * thread may never return but we have marked it as a daemon so the vm
758          * will terminate appropriately.
759          */
760         private void getFQDN() {
761 
762             /* FQDN finder will run in RMI threadgroup. */
763             Thread t = AccessController.doPrivileged(
764                 new NewThreadAction(FQDN.this, &quot;FQDN Finder&quot;, true));
765             t.start();
766         }
767 
768         private synchronized String getHost() {
769             return reverseLookup;
770         }
771 
772         /**
773          * thread to query a name service for the fqdn of this host.
774          */
775         public void run()  {
776 
777             String name = null;
778 
779             try {
780                 name = InetAddress.getByName(hostAddress).getHostName();
781             } catch (java.net.UnknownHostException e) {
782             } finally {
783                 synchronized(this) {
784                     reverseLookup = name;
785                     this.notify();
786                 }
787             }
788         }
789     }
790 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.rmi/share/classes/sun/rmi/server/UnicastRef.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.rmi.server;
 27 
 28 import java.io.IOException;
 29 import java.io.ObjectInput;
 30 import java.io.ObjectInputStream;
 31 import java.io.ObjectOutput;
 32 import java.lang.reflect.Method;
 33 import java.rmi.MarshalException;
 34 import java.rmi.Remote;
 35 import java.rmi.RemoteException;
 36 import java.rmi.UnmarshalException;
 37 import java.rmi.server.Operation;
 38 import java.rmi.server.RemoteCall;
 39 import java.rmi.server.RemoteObject;
 40 import java.rmi.server.RemoteRef;
 41 import java.security.AccessController;
 42 import java.security.PrivilegedAction;
 43 
 44 import jdk.internal.access.SharedSecrets;
 45 import sun.rmi.runtime.Log;
 46 import sun.rmi.transport.Connection;
 47 import sun.rmi.transport.LiveRef;
 48 import sun.rmi.transport.StreamRemoteCall;
 49 
 50 /**
 51  * NOTE: There is a JDK-internal dependency on the existence of this
 52  * class&#39;s getLiveRef method (as it is inherited by UnicastRef2) in
 53  * the implementation of javax.management.remote.rmi.RMIConnector.
 54  */
 55 @SuppressWarnings(&quot;deprecation&quot;)
 56 public class UnicastRef implements RemoteRef {
 57 
 58     /**
 59      * Client-side transport log.
 60      */
 61     public static final Log clientRefLog =
 62         Log.getLog(&quot;sun.rmi.client.ref&quot;, &quot;transport&quot;,  Util.logLevel);
 63 
 64     /**
 65      * Client-side call log.
 66      */
 67     public static final Log clientCallLog =
 68         Log.getLog(&quot;sun.rmi.client.call&quot;, &quot;RMI&quot;,
 69                    AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt;
 70                        Boolean.getBoolean(&quot;sun.rmi.client.logCalls&quot;)));
 71     private static final long serialVersionUID = 8258372400816541186L;
 72 
 73     protected LiveRef ref;
 74 
 75     /**
 76      * Create a new (empty) Unicast remote reference.
 77      */
 78     public UnicastRef() {
 79     }
 80 
 81     /**
 82      * Create a new Unicast RemoteRef.
 83      */
 84     public UnicastRef(LiveRef liveRef) {
 85         ref = liveRef;
 86     }
 87 
 88     /**
 89      * Returns the current value of this UnicastRef&#39;s underlying
 90      * LiveRef.
 91      *
 92      * NOTE: There is a JDK-internal dependency on the existence of
 93      * this method (as it is inherited by UnicastRef) in the
 94      * implementation of javax.management.remote.rmi.RMIConnector.
 95      **/
 96     public LiveRef getLiveRef() {
 97         return ref;
 98     }
 99 
100     /**
101      * Invoke a method. This form of delegating method invocation
102      * to the reference allows the reference to take care of
103      * setting up the connection to the remote host, marshalling
104      * some representation for the method and parameters, then
105      * communicating the method invocation to the remote host.
106      * This method either returns the result of a method invocation
107      * on the remote object which resides on the remote host or
108      * throws a RemoteException if the call failed or an
109      * application-level exception if the remote invocation throws
110      * an exception.
111      *
112      * @param obj the proxy for the remote object
113      * @param method the method to be invoked
114      * @param params the parameter list
115      * @param opnum  a hash that may be used to represent the method
116      * @since 1.2
117      */
118     public Object invoke(Remote obj,
119                          Method method,
120                          Object[] params,
121                          long opnum)
122         throws Exception
123     {
124         if (clientRefLog.isLoggable(Log.VERBOSE)) {
125             clientRefLog.log(Log.VERBOSE, &quot;method: &quot; + method);
126         }
127 
128         if (clientCallLog.isLoggable(Log.VERBOSE)) {
129             logClientCall(obj, method);
130         }
131 
132         Connection conn = ref.getChannel().newConnection();
133         RemoteCall call = null;
134         boolean reuse = true;
135 
136         /* If the call connection is &quot;reused&quot; early, remember not to
137          * reuse again.
138          */
139         boolean alreadyFreed = false;
140 
141         try {
142             if (clientRefLog.isLoggable(Log.VERBOSE)) {
143                 clientRefLog.log(Log.VERBOSE, &quot;opnum = &quot; + opnum);
144             }
145 
146             // create call context
147             call = new StreamRemoteCall(conn, ref.getObjID(), -1, opnum);
148 
149             // marshal parameters
150             try {
151                 ObjectOutput out = call.getOutputStream();
152                 marshalCustomCallData(out);
153                 Class&lt;?&gt;[] types = method.getParameterTypes();
154                 for (int i = 0; i &lt; types.length; i++) {
155                     marshalValue(types[i], params[i], out);
156                 }
157             } catch (IOException e) {
158                 clientRefLog.log(Log.BRIEF,
159                     &quot;IOException marshalling arguments: &quot;, e);
160                 throw new MarshalException(&quot;error marshalling arguments&quot;, e);
161             }
162 
163             // unmarshal return
164             call.executeCall();
165 
166             try {
167                 Class&lt;?&gt; rtype = method.getReturnType();
168                 if (rtype == void.class)
169                     return null;
170                 ObjectInput in = call.getInputStream();
171 
172                 /* StreamRemoteCall.done() does not actually make use
173                  * of conn, therefore it is safe to reuse this
174                  * connection before the dirty call is sent for
175                  * registered refs.
176                  */
177                 Object returnValue = unmarshalValue(rtype, in);
178 
179                 /* we are freeing the connection now, do not free
180                  * again or reuse.
181                  */
182                 alreadyFreed = true;
183 
184                 /* if we got to this point, reuse must have been true. */
185                 clientRefLog.log(Log.BRIEF, &quot;free connection (reuse = true)&quot;);
186 
187                 /* Free the call&#39;s connection early. */
188                 ref.getChannel().free(conn, true);
189 
190                 return returnValue;
191 
192             } catch (IOException | ClassNotFoundException e) {
193                 // disable saving any refs in the inputStream for GC
194                 ((StreamRemoteCall)call).discardPendingRefs();
195                 clientRefLog.log(Log.BRIEF,
196                                  e.getClass().getName() + &quot; unmarshalling return: &quot;, e);
197                 throw new UnmarshalException(&quot;error unmarshalling return&quot;, e);
198             } finally {
199                 try {
200                     call.done();
201                 } catch (IOException e) {
202                     /* WARNING: If the conn has been reused early,
203                      * then it is too late to recover from thrown
204                      * IOExceptions caught here. This code is relying
205                      * on StreamRemoteCall.done() not actually
206                      * throwing IOExceptions.
207                      */
208                     reuse = false;
209                 }
210             }
211 
212         } catch (RuntimeException e) {
213             /*
214              * Need to distinguish between client (generated by the
215              * invoke method itself) and server RuntimeExceptions.
216              * Client side RuntimeExceptions are likely to have
217              * corrupted the call connection and those from the server
218              * are not likely to have done so.  If the exception came
219              * from the server the call connection should be reused.
220              */
221             if ((call == null) ||
222                 (((StreamRemoteCall) call).getServerException() != e))
223             {
224                 reuse = false;
225             }
226             throw e;
227 
228         } catch (RemoteException e) {
229             /*
230              * Some failure during call; assume connection cannot
231              * be reused.  Must assume failure even if ServerException
232              * or ServerError occurs since these failures can happen
233              * during parameter deserialization which would leave
234              * the connection in a corrupted state.
235              */
236             reuse = false;
237             throw e;
238 
239         } catch (Error e) {
240             /* If errors occurred, the connection is most likely not
241              *  reusable.
242              */
243             reuse = false;
244             throw e;
245 
246         } finally {
247 
248             /* alreadyFreed ensures that we do not log a reuse that
249              * may have already happened.
250              */
251             if (!alreadyFreed) {
252                 if (clientRefLog.isLoggable(Log.BRIEF)) {
253                     clientRefLog.log(Log.BRIEF, &quot;free connection (reuse = &quot; +
254                                            reuse + &quot;)&quot;);
255                 }
256                 ref.getChannel().free(conn, reuse);
257             }
258         }
259     }
260 
261     protected void marshalCustomCallData(ObjectOutput out) throws IOException
262     {}
263 
264     /**
265      * Marshal value to an ObjectOutput sink using RMI&#39;s serialization
266      * format for parameters or return values.
267      */
268     protected static void marshalValue(Class&lt;?&gt; type, Object value,
269                                        ObjectOutput out)
270         throws IOException
271     {
272         if (type.isPrimitive()) {
273             if (type == int.class) {
274                 out.writeInt(((Integer) value).intValue());
275             } else if (type == boolean.class) {
276                 out.writeBoolean(((Boolean) value).booleanValue());
277             } else if (type == byte.class) {
278                 out.writeByte(((Byte) value).byteValue());
279             } else if (type == char.class) {
280                 out.writeChar(((Character) value).charValue());
281             } else if (type == short.class) {
282                 out.writeShort(((Short) value).shortValue());
283             } else if (type == long.class) {
284                 out.writeLong(((Long) value).longValue());
285             } else if (type == float.class) {
286                 out.writeFloat(((Float) value).floatValue());
287             } else if (type == double.class) {
288                 out.writeDouble(((Double) value).doubleValue());
289             } else {
290                 throw new Error(&quot;Unrecognized primitive type: &quot; + type);
291             }
292         } else {
293             out.writeObject(value);
294         }
295     }
296 
297     /**
298      * Unmarshal value from an ObjectInput source using RMI&#39;s serialization
299      * format for parameters or return values.
300      */
301     protected static Object unmarshalValue(Class&lt;?&gt; type, ObjectInput in)
302         throws IOException, ClassNotFoundException
303     {
304         if (type.isPrimitive()) {
305             if (type == int.class) {
306                 return Integer.valueOf(in.readInt());
307             } else if (type == boolean.class) {
308                 return Boolean.valueOf(in.readBoolean());
309             } else if (type == byte.class) {
310                 return Byte.valueOf(in.readByte());
311             } else if (type == char.class) {
312                 return Character.valueOf(in.readChar());
313             } else if (type == short.class) {
314                 return Short.valueOf(in.readShort());
315             } else if (type == long.class) {
316                 return Long.valueOf(in.readLong());
317             } else if (type == float.class) {
318                 return Float.valueOf(in.readFloat());
319             } else if (type == double.class) {
320                 return Double.valueOf(in.readDouble());
321             } else {
322                 throw new Error(&quot;Unrecognized primitive type: &quot; + type);
323             }
324         } else if (type == String.class &amp;&amp; in instanceof ObjectInputStream) {
325             return SharedSecrets.getJavaObjectInputStreamReadString().readString((ObjectInputStream)in);
326         } else {
327             return in.readObject();
328         }
329     }
330 
331     /**
332      * Create an appropriate call object for a new call on this object.
333      * Passing operation array and index, allows the stubs generator to
334      * assign the operation indexes and interpret them. The RemoteRef
335      * may need the operation to encode in for the call.
336      */
337     public RemoteCall newCall(RemoteObject obj, Operation[] ops, int opnum,
338                               long hash)
339         throws RemoteException
340     {
341         clientRefLog.log(Log.BRIEF, &quot;get connection&quot;);
342 
343         Connection conn = ref.getChannel().newConnection();
344         try {
345             clientRefLog.log(Log.VERBOSE, &quot;create call context&quot;);
346 
347             /* log information about the outgoing call */
348             if (clientCallLog.isLoggable(Log.VERBOSE)) {
349                 logClientCall(obj, ops[opnum]);
350             }
351 
352             RemoteCall call =
353                 new StreamRemoteCall(conn, ref.getObjID(), opnum, hash);
354             try {
355                 marshalCustomCallData(call.getOutputStream());
356             } catch (IOException e) {
357                 throw new MarshalException(&quot;error marshaling &quot; +
358                                            &quot;custom call data&quot;);
359             }
360             return call;
361         } catch (RemoteException e) {
362             ref.getChannel().free(conn, false);
363             throw e;
364         }
365     }
366 
367     /**
368      * Invoke makes the remote call present in the RemoteCall object.
369      *
370      * Invoke will raise any &quot;user&quot; exceptions which
371      * should pass through and not be caught by the stub.  If any
372      * exception is raised during the remote invocation, invoke should
373      * take care of cleaning up the connection before raising the
374      * &quot;user&quot; or remote exception.
375      */
376     public void invoke(RemoteCall call) throws Exception {
377         try {
378             clientRefLog.log(Log.VERBOSE, &quot;execute call&quot;);
379 
380             call.executeCall();
381 
382         } catch (RemoteException e) {
383             /*
384              * Call did not complete; connection can&#39;t be reused.
385              */
386             clientRefLog.log(Log.BRIEF, &quot;exception: &quot;, e);
387             free(call, false);
388             throw e;
389 
390         } catch (Error e) {
391             /* If errors occurred, the connection is most likely not
392              *  reusable.
393              */
394             clientRefLog.log(Log.BRIEF, &quot;error: &quot;, e);
395             free(call, false);
396             throw e;
397 
398         } catch (RuntimeException e) {
399             /*
400              * REMIND: Since runtime exceptions are no longer wrapped,
401              * we can&#39;t assue that the connection was left in
402              * a reusable state. Is this okay?
403              */
404             clientRefLog.log(Log.BRIEF, &quot;exception: &quot;, e);
405             free(call, false);
406             throw e;
407 
408         } catch (Exception e) {
409             /*
410              * Assume that these other exceptions are user exceptions
411              * and leave the connection in a reusable state.
412              */
413             clientRefLog.log(Log.BRIEF, &quot;exception: &quot;, e);
414             free(call, true);
415             /* reraise user (and unknown) exceptions. */
416             throw e;
417         }
418 
419         /*
420          * Don&#39;t free the connection if an exception did not
421          * occur because the stub needs to unmarshal the
422          * return value. The connection will be freed
423          * by a call to the &quot;done&quot; method.
424          */
425     }
426 
427     /**
428      * Private method to free a connection.
429      */
430     private void free(RemoteCall call, boolean reuse) throws RemoteException {
431         Connection conn = ((StreamRemoteCall)call).getConnection();
432         ref.getChannel().free(conn, reuse);
433     }
434 
435     /**
436      * Done should only be called if the invoke returns successfully
437      * (non-exceptionally) to the stub. It allows the remote reference to
438      * clean up (or reuse) the connection.
439      */
440     public void done(RemoteCall call) throws RemoteException {
441 
442         /* Done only uses the connection inside the call to obtain the
443          * channel the connection uses.  Once all information is read
444          * from the connection, the connection may be freed.
445          */
446         clientRefLog.log(Log.BRIEF, &quot;free connection (reuse = true)&quot;);
447 
448         /* Free the call connection early. */
449         free(call, true);
450 
451         try {
452             call.done();
453         } catch (IOException e) {
454             /* WARNING: If the conn has been reused early, then it is
455              * too late to recover from thrown IOExceptions caught
456              * here. This code is relying on StreamRemoteCall.done()
457              * not actually throwing IOExceptions.
458              */
459         }
460     }
461 
462     /**
463      * Log the details of an outgoing call.  The method parameter is either of
464      * type java.lang.reflect.Method or java.rmi.server.Operation.
465      */
466     void logClientCall(Object obj, Object method) {
467         clientCallLog.log(Log.VERBOSE, &quot;outbound call: &quot; +
468             ref + &quot; : &quot; + obj.getClass().getName() +
469             ref.getObjID().toString() + &quot;: &quot; + method);
470     }
471 
472     /**
473      * Returns the class of the ref type to be serialized
474      */
475     public String getRefClass(ObjectOutput out) {
476         return &quot;UnicastRef&quot;;
477     }
478 
479     /**
480      * Write out external representation for remote ref.
481      */
482     public void writeExternal(ObjectOutput out) throws IOException {
483         ref.write(out, false);
484     }
485 
486     /**
487      * Read in external representation for remote ref.
488      * @exception ClassNotFoundException If the class for an object
489      * being restored cannot be found.
490      */
491     public void readExternal(ObjectInput in)
492         throws IOException, ClassNotFoundException
493     {
494         ref = LiveRef.read(in, false);
495     }
496 
497     //----------------------------------------------------------------------;
498     /**
499      * Method from object, forward from RemoteObject
500      */
501     public String remoteToString() {
502         return Util.getUnqualifiedName(getClass()) + &quot; [liveRef: &quot; + ref + &quot;]&quot;;
503     }
504 
505     /**
506      * default implementation of hashCode for remote objects
507      */
508     public int remoteHashCode() {
509         return ref.hashCode();
510     }
511 
512     /** default implementation of equals for remote objects
513      */
514     public boolean remoteEquals(RemoteRef sub) {
515         if (sub instanceof UnicastRef)
516             return ref.remoteEquals(((UnicastRef)sub).ref);
517         return false;
518     }
519 }
    </pre>
  </body>
</html>
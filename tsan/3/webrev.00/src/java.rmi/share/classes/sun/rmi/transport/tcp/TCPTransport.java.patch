diff a/src/java.rmi/share/classes/sun/rmi/transport/tcp/TCPTransport.java b/src/java.rmi/share/classes/sun/rmi/transport/tcp/TCPTransport.java
--- a/src/java.rmi/share/classes/sun/rmi/transport/tcp/TCPTransport.java
+++ b/src/java.rmi/share/classes/sun/rmi/transport/tcp/TCPTransport.java
@@ -271,16 +271,27 @@
      * server socket if the count reaches zero.
      **/
     private void decrementExportCount() {
         assert Thread.holdsLock(this);
         exportCount--;
+        if (tcpLog.isLoggable(Log.VERBOSE)) {
+            tcpLog.log(Log.VERBOSE,
+                    "server socket: " + server + ", exportCount: " + exportCount);
+        }
         if (exportCount == 0 && getEndpoint().getListenPort() != 0) {
             ServerSocket ss = server;
             server = null;
             try {
+                if (tcpLog.isLoggable(Log.BRIEF)) {
+                    tcpLog.log(Log.BRIEF, "server socket close: " + ss);
+                }
                 ss.close();
             } catch (IOException e) {
+                if (tcpLog.isLoggable(Log.BRIEF)) {
+                    tcpLog.log(Log.BRIEF,
+                            "server socket close throws: " + e);
+                }
             }
         }
     }
 
     /**
@@ -364,18 +375,26 @@
         public void run() {
             try {
                 executeAcceptLoop();
             } finally {
                 try {
+                    if (tcpLog.isLoggable(Log.BRIEF)) {
+                        tcpLog.log(Log.BRIEF,
+                                "server socket close: " + serverSocket);
+                    }
                     /*
                      * Only one accept loop is started per server
                      * socket, so after no more connections will be
                      * accepted, ensure that the server socket is no
                      * longer listening.
                      */
                     serverSocket.close();
                 } catch (IOException e) {
+                    if (tcpLog.isLoggable(Log.BRIEF)) {
+                        tcpLog.log(Log.BRIEF,
+                                "server socket close throws: " + e);
+                    }
                 }
             }
         }
 
         /**
@@ -522,13 +541,19 @@
     }
 
     /** close socket and eat exception */
     private static void closeSocket(Socket sock) {
         try {
+            if (tcpLog.isLoggable(Log.BRIEF)) {
+                tcpLog.log(Log.BRIEF, "socket close: " + sock);
+            }
             sock.close();
         } catch (IOException ex) {
             // eat exception
+            if (tcpLog.isLoggable(Log.BRIEF)) {
+                tcpLog.log(Log.BRIEF, "socket close throws: " + ex);
+            }
         }
     }
 
     /**
      * handleMessages decodes transport operations and handles messages
@@ -589,10 +614,13 @@
         } finally {
             try {
                 conn.close();
             } catch (IOException ex) {
                 // eat exception
+                if (tcpLog.isLoggable(Log.BRIEF)) {
+                    tcpLog.log(Log.BRIEF, "Connection close throws " + ex);
+                }
             }
         }
     }
 
     /**
@@ -721,10 +749,14 @@
                     version != TransportConstants.Version) {
                     // protocol mismatch detected...
                     // just close socket: this would recurse if we marshal an
                     // exception to the client and the protocol at other end
                     // doesn't match.
+                    if (tcpLog.isLoggable(Log.BRIEF)) {
+                        tcpLog.log(Log.BRIEF, "magic or version not match: "
+                                                  + magic + ", " + version);
+                    }
                     closeSocket(socket);
                     return;
                 }
 
                 OutputStream sockOut = socket.getOutputStream();

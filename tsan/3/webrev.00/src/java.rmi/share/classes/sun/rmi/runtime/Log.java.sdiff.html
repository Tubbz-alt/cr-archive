<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.rmi/share/classes/sun/rmi/runtime/Log.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../registry/RegistryImpl_Stub.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../server/ActivatableServerRef.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.rmi/share/classes/sun/rmi/runtime/Log.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.rmi.runtime;
 27 
 28 import java.io.ByteArrayOutputStream;
 29 import java.io.PrintStream;
 30 import java.io.OutputStream;

 31 import java.rmi.server.LogStream;
 32 import java.security.PrivilegedAction;

 33 import java.util.logging.Handler;
 34 import java.util.logging.SimpleFormatter;
 35 import java.util.logging.Level;
 36 import java.util.logging.Logger;
 37 import java.util.logging.LogRecord;
 38 import java.util.logging.StreamHandler;
 39 
 40 /**
 41  * Utility which provides an abstract &quot;logger&quot; like RMI internal API
 42  * which can be directed to use one of two types of logging
 43  * infrastructure: the java.util.logging API or the
 44  * java.rmi.server.LogStream API.  The default behavior is to use the
 45  * java.util.logging API.  The LogStream API may be used instead by
 46  * setting the system property sun.rmi.log.useOld to true.
 47  *
 48  * For backwards compatibility, supports the RMI system logging
 49  * properties which pre-1.4 comprised the only way to configure RMI
 50  * logging.  If the java.util.logging API is used and RMI system log
 51  * properties are set, the system properties override initial RMI
 52  * logger values as appropriate. If the java.util.logging API is
 53  * turned off, pre-1.4 logging behavior is used.
 54  *
 55  * @author Laird Dornin
 56  * @since 1.4
 57  */
 58 @SuppressWarnings(&quot;deprecation&quot;)
 59 public abstract class Log {
 60 
 61     /** Logger re-definition of old RMI log values */
 62     public static final Level BRIEF = Level.FINE;
 63     public static final Level VERBOSE = Level.FINER;
 64 


 65     /* selects log implementation */
 66     private static final LogFactory logFactory;
 67     static {
 68         boolean useOld = java.security.AccessController.doPrivileged(
 69             (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;sun.rmi.log.useOld&quot;));
 70 
 71         /* set factory to select the logging facility to use */
 72         logFactory = (useOld ? (LogFactory) new LogStreamLogFactory() :
 73                       (LogFactory) new LoggerLogFactory());
 74     }
 75 
 76     /** &quot;logger like&quot; API to be used by RMI implementation */
 77     public abstract boolean isLoggable(Level level);
 78     public abstract void log(Level level, String message);
 79     public abstract void log(Level level, String message, Throwable thrown);
 80 
 81     /** get and set the RMI server call output stream */
 82     public abstract void setOutputStream(OutputStream stream);
 83     public abstract PrintStream getPrintStream();
 84 
</pre>
<hr />
<pre>
200                 java.security.AccessController.doPrivileged(
201                     new java.security.PrivilegedAction&lt;Void&gt;() {
202                         public Void run() {
203                             if (!logger.isLoggable(level)) {
204                                 logger.setLevel(level);
205                             }
206                             logger.addHandler(alternateConsole);
207                             return null;
208                         }
209                     }
210                 );
211             }
212         }
213 
214         public boolean isLoggable(Level level) {
215             return logger.isLoggable(level);
216         }
217 
218         public void log(Level level, String message) {
219             if (isLoggable(level)) {
<span class="line-modified">220                 String[] source = getSource();</span>
<span class="line-modified">221                 logger.logp(level, source[0], source[1],</span>
222                            Thread.currentThread().getName() + &quot;: &quot; + message);
223             }
224         }
225 
226         public void log(Level level, String message, Throwable thrown) {
227             if (isLoggable(level)) {
<span class="line-modified">228                 String[] source = getSource();</span>
<span class="line-modified">229                 logger.logp(level, source[0], source[1],</span>
230                     Thread.currentThread().getName() + &quot;: &quot; +
231                            message, thrown);
232             }
233         }
234 
235         public String toString() {
236             return logger.toString() + &quot;, level: &quot; + logger.getLevel() +
237                     &quot;, name: &quot; + logger.getName();
238         }
239 
240         /**
241          * Set the output stream associated with the RMI server call
242          * logger.
243          *
244          * Calling code needs LoggingPermission &quot;control&quot;.
245          */
246         public synchronized void setOutputStream(OutputStream out) {
247             if (out != null) {
248                 if (!logger.isLoggable(VERBOSE)) {
249                     logger.setLevel(VERBOSE);
</pre>
<hr />
<pre>
373 
374         /** the level of the log as set by associated property */
375         private int levelValue = Level.OFF.intValue();
376 
377         private LogStreamLog(LogStream stream, Level level) {
378             if ((stream != null) &amp;&amp; (level != null)) {
379                 /* if the stream or level is null, don&#39;t log any
380                  * messages
381                  */
382                 levelValue = level.intValue();
383             }
384             this.stream = stream;
385         }
386 
387         public synchronized boolean isLoggable(Level level) {
388             return (level.intValue() &gt;= levelValue);
389         }
390 
391         public void log(Level messageLevel, String message) {
392             if (isLoggable(messageLevel)) {
<span class="line-modified">393                 String[] source = getSource();</span>
<span class="line-modified">394                 stream.println(unqualifiedName(source[0]) +</span>
<span class="line-modified">395                                &quot;.&quot; + source[1] + &quot;: &quot; + message);</span>
396             }
397         }
398 
399         public void log(Level level, String message, Throwable thrown) {
400             if (isLoggable(level)) {
401                 /*
402                  * keep output contiguous and maintain the contract of
403                  * RemoteServer.getLog
404                  */
405                 synchronized (stream) {
<span class="line-modified">406                     String[] source = getSource();</span>
<span class="line-modified">407                     stream.println(unqualifiedName(source[0]) + &quot;.&quot; +</span>
<span class="line-modified">408                                    source[1] + &quot;: &quot; + message);</span>
409                     thrown.printStackTrace(stream);
410                 }
411             }
412         }
413 
414         public PrintStream getPrintStream() {
415             return stream;
416         }
417 
418         public synchronized void setOutputStream(OutputStream out) {
419             if (out != null) {
420                 if (VERBOSE.intValue() &lt; levelValue) {
421                     levelValue = VERBOSE.intValue();
422                 }
423                 stream.setOutputStream(out);
424             } else {
425                 /* ensure that messages are not logged */
426                 levelValue = Level.OFF.intValue();
427             }
428         }
429 
430         /*
431          * Mimic old log messages that only contain unqualified names.
432          */
433         private static String unqualifiedName(String name) {
434             int lastDot = name.lastIndexOf(&#39;.&#39;);
435             if (lastDot &gt;= 0) {
436                 name = name.substring(lastDot + 1);
437             }
438             name = name.replace(&#39;$&#39;, &#39;.&#39;);
439             return name;
440         }
441     }
442 
443     /**
<span class="line-modified">444      * Obtain class and method names of code calling a log method.</span>
445      */
<span class="line-modified">446     private static String[] getSource() {</span>
<span class="line-modified">447         StackTraceElement[] trace = (new Exception()).getStackTrace();</span>
<span class="line-modified">448         return new String[] {</span>
<span class="line-modified">449             trace[3].getClassName(),</span>
<span class="line-modified">450             trace[3].getMethodName()</span>
<span class="line-removed">451         };</span>
452     }
453 }
</pre>
</td>
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.rmi.runtime;
 27 
 28 import java.io.ByteArrayOutputStream;
 29 import java.io.PrintStream;
 30 import java.io.OutputStream;
<span class="line-added"> 31 import java.lang.StackWalker.StackFrame;</span>
 32 import java.rmi.server.LogStream;
 33 import java.security.PrivilegedAction;
<span class="line-added"> 34 import java.util.Set;</span>
 35 import java.util.logging.Handler;
 36 import java.util.logging.SimpleFormatter;
 37 import java.util.logging.Level;
 38 import java.util.logging.Logger;
 39 import java.util.logging.LogRecord;
 40 import java.util.logging.StreamHandler;
 41 
 42 /**
 43  * Utility which provides an abstract &quot;logger&quot; like RMI internal API
 44  * which can be directed to use one of two types of logging
 45  * infrastructure: the java.util.logging API or the
 46  * java.rmi.server.LogStream API.  The default behavior is to use the
 47  * java.util.logging API.  The LogStream API may be used instead by
 48  * setting the system property sun.rmi.log.useOld to true.
 49  *
 50  * For backwards compatibility, supports the RMI system logging
 51  * properties which pre-1.4 comprised the only way to configure RMI
 52  * logging.  If the java.util.logging API is used and RMI system log
 53  * properties are set, the system properties override initial RMI
 54  * logger values as appropriate. If the java.util.logging API is
 55  * turned off, pre-1.4 logging behavior is used.
 56  *
 57  * @author Laird Dornin
 58  * @since 1.4
 59  */
 60 @SuppressWarnings(&quot;deprecation&quot;)
 61 public abstract class Log {
 62 
 63     /** Logger re-definition of old RMI log values */
 64     public static final Level BRIEF = Level.FINE;
 65     public static final Level VERBOSE = Level.FINER;
 66 
<span class="line-added"> 67     private static final StackWalker WALKER = StackWalker.getInstance(Set.of(), 4);</span>
<span class="line-added"> 68 </span>
 69     /* selects log implementation */
 70     private static final LogFactory logFactory;
 71     static {
 72         boolean useOld = java.security.AccessController.doPrivileged(
 73             (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;sun.rmi.log.useOld&quot;));
 74 
 75         /* set factory to select the logging facility to use */
 76         logFactory = (useOld ? (LogFactory) new LogStreamLogFactory() :
 77                       (LogFactory) new LoggerLogFactory());
 78     }
 79 
 80     /** &quot;logger like&quot; API to be used by RMI implementation */
 81     public abstract boolean isLoggable(Level level);
 82     public abstract void log(Level level, String message);
 83     public abstract void log(Level level, String message, Throwable thrown);
 84 
 85     /** get and set the RMI server call output stream */
 86     public abstract void setOutputStream(OutputStream stream);
 87     public abstract PrintStream getPrintStream();
 88 
</pre>
<hr />
<pre>
204                 java.security.AccessController.doPrivileged(
205                     new java.security.PrivilegedAction&lt;Void&gt;() {
206                         public Void run() {
207                             if (!logger.isLoggable(level)) {
208                                 logger.setLevel(level);
209                             }
210                             logger.addHandler(alternateConsole);
211                             return null;
212                         }
213                     }
214                 );
215             }
216         }
217 
218         public boolean isLoggable(Level level) {
219             return logger.isLoggable(level);
220         }
221 
222         public void log(Level level, String message) {
223             if (isLoggable(level)) {
<span class="line-modified">224                 StackFrame sourceFrame = getSource();</span>
<span class="line-modified">225                 logger.logp(level, sourceFrame.getClassName(), sourceFrame.getMethodName(),</span>
226                            Thread.currentThread().getName() + &quot;: &quot; + message);
227             }
228         }
229 
230         public void log(Level level, String message, Throwable thrown) {
231             if (isLoggable(level)) {
<span class="line-modified">232                 StackFrame sourceFrame = getSource();</span>
<span class="line-modified">233                 logger.logp(level, sourceFrame.getClassName(), sourceFrame.getMethodName(),</span>
234                     Thread.currentThread().getName() + &quot;: &quot; +
235                            message, thrown);
236             }
237         }
238 
239         public String toString() {
240             return logger.toString() + &quot;, level: &quot; + logger.getLevel() +
241                     &quot;, name: &quot; + logger.getName();
242         }
243 
244         /**
245          * Set the output stream associated with the RMI server call
246          * logger.
247          *
248          * Calling code needs LoggingPermission &quot;control&quot;.
249          */
250         public synchronized void setOutputStream(OutputStream out) {
251             if (out != null) {
252                 if (!logger.isLoggable(VERBOSE)) {
253                     logger.setLevel(VERBOSE);
</pre>
<hr />
<pre>
377 
378         /** the level of the log as set by associated property */
379         private int levelValue = Level.OFF.intValue();
380 
381         private LogStreamLog(LogStream stream, Level level) {
382             if ((stream != null) &amp;&amp; (level != null)) {
383                 /* if the stream or level is null, don&#39;t log any
384                  * messages
385                  */
386                 levelValue = level.intValue();
387             }
388             this.stream = stream;
389         }
390 
391         public synchronized boolean isLoggable(Level level) {
392             return (level.intValue() &gt;= levelValue);
393         }
394 
395         public void log(Level messageLevel, String message) {
396             if (isLoggable(messageLevel)) {
<span class="line-modified">397                 StackFrame sourceFrame = getSource();</span>
<span class="line-modified">398                 stream.println(unqualifiedName(sourceFrame.getClassName()) +</span>
<span class="line-modified">399                                &quot;.&quot; + sourceFrame.getMethodName() + &quot;: &quot; + message);</span>
400             }
401         }
402 
403         public void log(Level level, String message, Throwable thrown) {
404             if (isLoggable(level)) {
405                 /*
406                  * keep output contiguous and maintain the contract of
407                  * RemoteServer.getLog
408                  */
409                 synchronized (stream) {
<span class="line-modified">410                     StackFrame sourceFrame = getSource();</span>
<span class="line-modified">411                     stream.println(unqualifiedName(sourceFrame.getClassName()) + &quot;.&quot; +</span>
<span class="line-modified">412                                     sourceFrame.getMethodName() + &quot;: &quot; + message);</span>
413                     thrown.printStackTrace(stream);
414                 }
415             }
416         }
417 
418         public PrintStream getPrintStream() {
419             return stream;
420         }
421 
422         public synchronized void setOutputStream(OutputStream out) {
423             if (out != null) {
424                 if (VERBOSE.intValue() &lt; levelValue) {
425                     levelValue = VERBOSE.intValue();
426                 }
427                 stream.setOutputStream(out);
428             } else {
429                 /* ensure that messages are not logged */
430                 levelValue = Level.OFF.intValue();
431             }
432         }
433 
434         /*
435          * Mimic old log messages that only contain unqualified names.
436          */
437         private static String unqualifiedName(String name) {
438             int lastDot = name.lastIndexOf(&#39;.&#39;);
439             if (lastDot &gt;= 0) {
440                 name = name.substring(lastDot + 1);
441             }
442             name = name.replace(&#39;$&#39;, &#39;.&#39;);
443             return name;
444         }
445     }
446 
447     /**
<span class="line-modified">448      * Obtain stack frame of code calling a log method.</span>
449      */
<span class="line-modified">450     private static StackFrame getSource() {</span>
<span class="line-modified">451         return WALKER.walk(s -&gt; s</span>
<span class="line-modified">452                                  .skip(3)</span>
<span class="line-modified">453                                  .findFirst()</span>
<span class="line-modified">454                                  .get());</span>

455     }
456 }
</pre>
</td>
</tr>
</table>
<center><a href="../registry/RegistryImpl_Stub.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../server/ActivatableServerRef.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.rmi/share/classes/sun/rmi/transport/StreamRemoteCall.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DGCImpl_Stub.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="tcp/TCPConnection.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.rmi/share/classes/sun/rmi/transport/StreamRemoteCall.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.rmi.transport;
 27 
 28 import java.io.DataInputStream;
 29 import java.io.DataOutputStream;
 30 import java.io.IOException;
 31 import java.io.ObjectInput;

 32 import java.io.ObjectOutput;
 33 import java.io.StreamCorruptedException;
 34 import java.rmi.RemoteException;
 35 import java.rmi.MarshalException;
 36 import java.rmi.UnmarshalException;
 37 import java.rmi.server.ObjID;
 38 import java.rmi.server.RemoteCall;



 39 import sun.rmi.runtime.Log;
 40 import sun.rmi.server.UnicastRef;
 41 import sun.rmi.transport.tcp.TCPEndpoint;
 42 
 43 /**
 44  * Stream-based implementation of the RemoteCall interface.
 45  *
 46  * @author Ann Wollrath
 47  */
 48 @SuppressWarnings(&quot;deprecation&quot;)
 49 public class StreamRemoteCall implements RemoteCall {
 50     private ConnectionInputStream in = null;
 51     private ConnectionOutputStream out = null;
 52     private Connection conn;

 53     private boolean resultStarted = false;
 54     private Exception serverException = null;
 55 
 56     public StreamRemoteCall(Connection c) {
 57         conn = c;
 58     }
 59 
 60     public StreamRemoteCall(Connection c, ObjID id, int op, long hash)
 61         throws RemoteException
 62     {
 63         try {
 64             conn = c;
 65             Transport.transportLog.log(Log.VERBOSE,
 66                 &quot;write remote call header...&quot;);
 67 
 68             // write out remote call header info...
 69             // call header, part 1 (read by Transport)
 70             conn.getOutputStream().write(TransportConstants.Call);
 71             getOutputStream();           // creates a MarshalOutputStream
 72             id.write(out);               // object id (target of call)
</pre>
<hr />
<pre>
106 
107     /**
108      * Release the outputStream  Currently, will not complain if the
109      * output stream is released more than once.
110      */
111     public void releaseOutputStream() throws IOException {
112         try {
113             if (out != null) {
114                 try {
115                     out.flush();
116                 } finally {
117                     out.done();         // always start DGC ack timer
118                 }
119             }
120             conn.releaseOutputStream();
121         } finally {
122             out = null;
123         }
124     }
125 







126     /**
127      * Get the InputStream the stub/skeleton should get results/arguments
128      * from.
129      */
130     public ObjectInput getInputStream() throws IOException {
131         if (in == null) {
132             Transport.transportLog.log(Log.VERBOSE, &quot;getting input stream&quot;);
133 
134             in = new ConnectionInputStream(conn.getInputStream());






135         }
136         return in;
137     }
138 
139     /**
140      * Release the input stream, this would allow some transports to release
141      * the channel early.
142      */
143     public void releaseInputStream() throws IOException {
144         /* WARNING: Currently, the UnicastRef.java invoke methods rely
145          * upon this method not throwing an IOException.
146          */
147 
148         try {
149             if (in != null) {
150                 // execute MarshalInputStream &quot;done&quot; callbacks
151                 try {
152                     in.done();
153                 } catch (RuntimeException e) {
154                 }
</pre>
<hr />
<pre>
234             throw e;
235         } catch (IOException e) {
236             throw new UnmarshalException(&quot;Error unmarshaling return header&quot;,
237                                          e);
238         } finally {
239             if (ackHandler != null) {
240                 ackHandler.release();
241             }
242         }
243 
244         // read return value
245         switch (returnType) {
246         case TransportConstants.NormalReturn:
247             break;
248 
249         case TransportConstants.ExceptionalReturn:
250             Object ex;
251             try {
252                 ex = in.readObject();
253             } catch (Exception e) {

254                 throw new UnmarshalException(&quot;Error unmarshaling return&quot;, e);
255             }
256 
257             // An exception should have been received,
258             // if so throw it, else flag error
259             if (ex instanceof Exception) {
260                 exceptionReceivedFromServer((Exception) ex);
261             } else {

262                 throw new UnmarshalException(&quot;Return type not Exception&quot;);
263             }
264             // Exception is thrown before fallthrough can occur
265         default:
266             if (Transport.transportLog.isLoggable(Log.BRIEF)) {
267                 Transport.transportLog.log(Log.BRIEF,
268                     &quot;return code invalid: &quot; + returnType);
269             }
270             throw new UnmarshalException(&quot;Return code invalid&quot;);
271         }
272     }
273 
274     /**
275      * Routine that causes the stack traces of remote exceptions to be
276      * filled in with the current stack trace on the client.  Detail
277      * exceptions are filled in iteratively.
278      */
279     protected void exceptionReceivedFromServer(Exception ex) throws Exception {
280         serverException = ex;
281 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.rmi.transport;
 27 
 28 import java.io.DataInputStream;
 29 import java.io.DataOutputStream;
 30 import java.io.IOException;
 31 import java.io.ObjectInput;
<span class="line-added"> 32 import java.io.ObjectInputFilter;</span>
 33 import java.io.ObjectOutput;
 34 import java.io.StreamCorruptedException;
 35 import java.rmi.RemoteException;
 36 import java.rmi.MarshalException;
 37 import java.rmi.UnmarshalException;
 38 import java.rmi.server.ObjID;
 39 import java.rmi.server.RemoteCall;
<span class="line-added"> 40 import java.security.AccessController;</span>
<span class="line-added"> 41 import java.security.PrivilegedAction;</span>
<span class="line-added"> 42 </span>
 43 import sun.rmi.runtime.Log;
 44 import sun.rmi.server.UnicastRef;
 45 import sun.rmi.transport.tcp.TCPEndpoint;
 46 
 47 /**
 48  * Stream-based implementation of the RemoteCall interface.
 49  *
 50  * @author Ann Wollrath
 51  */
 52 @SuppressWarnings(&quot;deprecation&quot;)
 53 public class StreamRemoteCall implements RemoteCall {
 54     private ConnectionInputStream in = null;
 55     private ConnectionOutputStream out = null;
 56     private Connection conn;
<span class="line-added"> 57     private ObjectInputFilter filter = null;</span>
 58     private boolean resultStarted = false;
 59     private Exception serverException = null;
 60 
 61     public StreamRemoteCall(Connection c) {
 62         conn = c;
 63     }
 64 
 65     public StreamRemoteCall(Connection c, ObjID id, int op, long hash)
 66         throws RemoteException
 67     {
 68         try {
 69             conn = c;
 70             Transport.transportLog.log(Log.VERBOSE,
 71                 &quot;write remote call header...&quot;);
 72 
 73             // write out remote call header info...
 74             // call header, part 1 (read by Transport)
 75             conn.getOutputStream().write(TransportConstants.Call);
 76             getOutputStream();           // creates a MarshalOutputStream
 77             id.write(out);               // object id (target of call)
</pre>
<hr />
<pre>
111 
112     /**
113      * Release the outputStream  Currently, will not complain if the
114      * output stream is released more than once.
115      */
116     public void releaseOutputStream() throws IOException {
117         try {
118             if (out != null) {
119                 try {
120                     out.flush();
121                 } finally {
122                     out.done();         // always start DGC ack timer
123                 }
124             }
125             conn.releaseOutputStream();
126         } finally {
127             out = null;
128         }
129     }
130 
<span class="line-added">131     public void setObjectInputFilter(ObjectInputFilter filter) {</span>
<span class="line-added">132         if (in != null) {</span>
<span class="line-added">133             throw new IllegalStateException(&quot;set filter must occur before calling getInputStream&quot;);</span>
<span class="line-added">134         }</span>
<span class="line-added">135         this.filter = filter;</span>
<span class="line-added">136     }</span>
<span class="line-added">137 </span>
138     /**
139      * Get the InputStream the stub/skeleton should get results/arguments
140      * from.
141      */
142     public ObjectInput getInputStream() throws IOException {
143         if (in == null) {
144             Transport.transportLog.log(Log.VERBOSE, &quot;getting input stream&quot;);
145 
146             in = new ConnectionInputStream(conn.getInputStream());
<span class="line-added">147             if (filter != null) {</span>
<span class="line-added">148                 AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {</span>
<span class="line-added">149                     in.setObjectInputFilter(filter);</span>
<span class="line-added">150                     return null;</span>
<span class="line-added">151                 });</span>
<span class="line-added">152             }</span>
153         }
154         return in;
155     }
156 
157     /**
158      * Release the input stream, this would allow some transports to release
159      * the channel early.
160      */
161     public void releaseInputStream() throws IOException {
162         /* WARNING: Currently, the UnicastRef.java invoke methods rely
163          * upon this method not throwing an IOException.
164          */
165 
166         try {
167             if (in != null) {
168                 // execute MarshalInputStream &quot;done&quot; callbacks
169                 try {
170                     in.done();
171                 } catch (RuntimeException e) {
172                 }
</pre>
<hr />
<pre>
252             throw e;
253         } catch (IOException e) {
254             throw new UnmarshalException(&quot;Error unmarshaling return header&quot;,
255                                          e);
256         } finally {
257             if (ackHandler != null) {
258                 ackHandler.release();
259             }
260         }
261 
262         // read return value
263         switch (returnType) {
264         case TransportConstants.NormalReturn:
265             break;
266 
267         case TransportConstants.ExceptionalReturn:
268             Object ex;
269             try {
270                 ex = in.readObject();
271             } catch (Exception e) {
<span class="line-added">272                 discardPendingRefs();</span>
273                 throw new UnmarshalException(&quot;Error unmarshaling return&quot;, e);
274             }
275 
276             // An exception should have been received,
277             // if so throw it, else flag error
278             if (ex instanceof Exception) {
279                 exceptionReceivedFromServer((Exception) ex);
280             } else {
<span class="line-added">281                 discardPendingRefs();</span>
282                 throw new UnmarshalException(&quot;Return type not Exception&quot;);
283             }
284             // Exception is thrown before fallthrough can occur
285         default:
286             if (Transport.transportLog.isLoggable(Log.BRIEF)) {
287                 Transport.transportLog.log(Log.BRIEF,
288                     &quot;return code invalid: &quot; + returnType);
289             }
290             throw new UnmarshalException(&quot;Return code invalid&quot;);
291         }
292     }
293 
294     /**
295      * Routine that causes the stack traces of remote exceptions to be
296      * filled in with the current stack trace on the client.  Detail
297      * exceptions are filled in iteratively.
298      */
299     protected void exceptionReceivedFromServer(Exception ex) throws Exception {
300         serverException = ex;
301 
</pre>
</td>
</tr>
</table>
<center><a href="DGCImpl_Stub.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="tcp/TCPConnection.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.rmi/share/classes/sun/rmi/runtime/Log.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.rmi.runtime;
 27 
 28 import java.io.ByteArrayOutputStream;
 29 import java.io.PrintStream;
 30 import java.io.OutputStream;
<a name="1" id="anc1"></a>
 31 import java.rmi.server.LogStream;
 32 import java.security.PrivilegedAction;
<a name="2" id="anc2"></a>
 33 import java.util.logging.Handler;
 34 import java.util.logging.SimpleFormatter;
 35 import java.util.logging.Level;
 36 import java.util.logging.Logger;
 37 import java.util.logging.LogRecord;
 38 import java.util.logging.StreamHandler;
 39 
 40 /**
 41  * Utility which provides an abstract &quot;logger&quot; like RMI internal API
 42  * which can be directed to use one of two types of logging
 43  * infrastructure: the java.util.logging API or the
 44  * java.rmi.server.LogStream API.  The default behavior is to use the
 45  * java.util.logging API.  The LogStream API may be used instead by
 46  * setting the system property sun.rmi.log.useOld to true.
 47  *
 48  * For backwards compatibility, supports the RMI system logging
 49  * properties which pre-1.4 comprised the only way to configure RMI
 50  * logging.  If the java.util.logging API is used and RMI system log
 51  * properties are set, the system properties override initial RMI
 52  * logger values as appropriate. If the java.util.logging API is
 53  * turned off, pre-1.4 logging behavior is used.
 54  *
 55  * @author Laird Dornin
 56  * @since 1.4
 57  */
 58 @SuppressWarnings(&quot;deprecation&quot;)
 59 public abstract class Log {
 60 
 61     /** Logger re-definition of old RMI log values */
 62     public static final Level BRIEF = Level.FINE;
 63     public static final Level VERBOSE = Level.FINER;
 64 
<a name="3" id="anc3"></a>

 65     /* selects log implementation */
 66     private static final LogFactory logFactory;
 67     static {
 68         boolean useOld = java.security.AccessController.doPrivileged(
 69             (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;sun.rmi.log.useOld&quot;));
 70 
 71         /* set factory to select the logging facility to use */
 72         logFactory = (useOld ? (LogFactory) new LogStreamLogFactory() :
 73                       (LogFactory) new LoggerLogFactory());
 74     }
 75 
 76     /** &quot;logger like&quot; API to be used by RMI implementation */
 77     public abstract boolean isLoggable(Level level);
 78     public abstract void log(Level level, String message);
 79     public abstract void log(Level level, String message, Throwable thrown);
 80 
 81     /** get and set the RMI server call output stream */
 82     public abstract void setOutputStream(OutputStream stream);
 83     public abstract PrintStream getPrintStream();
 84 
 85     /** factory interface enables Logger and LogStream implementations */
 86     private static interface LogFactory {
 87         Log createLog(String loggerName, String oldLogName, Level level);
 88     }
 89 
 90     /* access log objects */
 91 
 92     /**
 93      * Access log for a tri-state system property.
 94      *
 95      * Need to first convert override value to a log level, taking
 96      * care to interpret a range of values between BRIEF, VERBOSE and
 97      * SILENT.
 98      *
 99      * An override {@literal &lt;} 0 is interpreted to mean that the logging
100      * configuration should not be overridden. The level passed to the
101      * factories createLog method will be null in this case.
102      *
103      * Note that if oldLogName is null and old logging is on, the
104      * returned LogStreamLog will ignore the override parameter - the
105      * log will never log messages.  This permits new logs that only
106      * write to Loggers to do nothing when old logging is active.
107      *
108      * Do not call getLog multiple times on the same logger name.
109      * Since this is an internal API, no checks are made to ensure
110      * that multiple logs do not exist for the same logger.
111      */
112     public static Log getLog(String loggerName, String oldLogName,
113                              int override)
114     {
115         Level level;
116 
117         if (override &lt; 0) {
118             level = null;
119         } else if (override == LogStream.SILENT) {
120             level = Level.OFF;
121         } else if ((override &gt; LogStream.SILENT) &amp;&amp;
122                    (override &lt;= LogStream.BRIEF)) {
123             level = BRIEF;
124         } else if ((override &gt; LogStream.BRIEF) &amp;&amp;
125                    (override &lt;= LogStream.VERBOSE))
126         {
127             level = VERBOSE;
128         } else {
129             level = Level.FINEST;
130         }
131         return logFactory.createLog(loggerName, oldLogName, level);
132     }
133 
134     /**
135      * Access logs associated with boolean properties
136      *
137      * Do not call getLog multiple times on the same logger name.
138      * Since this is an internal API, no checks are made to ensure
139      * that multiple logs do not exist for the same logger.
140      */
141     public static Log getLog(String loggerName, String oldLogName,
142                              boolean override)
143     {
144         Level level = (override ? VERBOSE : null);
145         return logFactory.createLog(loggerName, oldLogName, level);
146     }
147 
148     /**
149      * Factory to create Log objects which deliver log messages to the
150      * java.util.logging API.
151      */
152     private static class LoggerLogFactory implements LogFactory {
153         LoggerLogFactory() {}
154 
155         /*
156          * Accessor to obtain an arbitrary RMI logger with name
157          * loggerName.  If the level of the logger is greater than the
158          * level for the system property with name, the logger level
159          * will be set to the value of system property.
160          */
161         public Log createLog(final String loggerName, String oldLogName,
162                              final Level level)
163         {
164             Logger logger = Logger.getLogger(loggerName);
165             return new LoggerLog(logger, level);
166         }
167     }
168 
169     /**
170      * Class specialized to log messages to the java.util.logging API
171      */
172     private static class LoggerLog extends Log {
173 
174         /* alternate console handler for RMI loggers */
175         private static final Handler alternateConsole =
176                 java.security.AccessController.doPrivileged(
177                 new java.security.PrivilegedAction&lt;Handler&gt;() {
178                     public Handler run() {
179                             InternalStreamHandler alternate =
180                                 new InternalStreamHandler(System.err);
181                             alternate.setLevel(Level.ALL);
182                             return alternate;
183                         }
184                 });
185 
186         /** handler to which messages are copied */
187         private InternalStreamHandler copyHandler = null;
188 
189         /* logger to which log messages are written */
190         private final Logger logger;
191 
192         /* used as return value of RemoteServer.getLog */
193         private LoggerPrintStream loggerSandwich;
194 
195         /** creates a Log which will delegate to the given logger */
196         private LoggerLog(final Logger logger, final Level level) {
197             this.logger = logger;
198 
199             if (level != null){
200                 java.security.AccessController.doPrivileged(
201                     new java.security.PrivilegedAction&lt;Void&gt;() {
202                         public Void run() {
203                             if (!logger.isLoggable(level)) {
204                                 logger.setLevel(level);
205                             }
206                             logger.addHandler(alternateConsole);
207                             return null;
208                         }
209                     }
210                 );
211             }
212         }
213 
214         public boolean isLoggable(Level level) {
215             return logger.isLoggable(level);
216         }
217 
218         public void log(Level level, String message) {
219             if (isLoggable(level)) {
<a name="4" id="anc4"></a><span class="line-modified">220                 String[] source = getSource();</span>
<span class="line-modified">221                 logger.logp(level, source[0], source[1],</span>
222                            Thread.currentThread().getName() + &quot;: &quot; + message);
223             }
224         }
225 
226         public void log(Level level, String message, Throwable thrown) {
227             if (isLoggable(level)) {
<a name="5" id="anc5"></a><span class="line-modified">228                 String[] source = getSource();</span>
<span class="line-modified">229                 logger.logp(level, source[0], source[1],</span>
230                     Thread.currentThread().getName() + &quot;: &quot; +
231                            message, thrown);
232             }
233         }
234 
235         public String toString() {
236             return logger.toString() + &quot;, level: &quot; + logger.getLevel() +
237                     &quot;, name: &quot; + logger.getName();
238         }
239 
240         /**
241          * Set the output stream associated with the RMI server call
242          * logger.
243          *
244          * Calling code needs LoggingPermission &quot;control&quot;.
245          */
246         public synchronized void setOutputStream(OutputStream out) {
247             if (out != null) {
248                 if (!logger.isLoggable(VERBOSE)) {
249                     logger.setLevel(VERBOSE);
250                 }
251                 copyHandler = new InternalStreamHandler(out);
252                 copyHandler.setLevel(Log.VERBOSE);
253                 logger.addHandler(copyHandler);
254             } else {
255                 /* ensure that messages are not logged */
256                 if (copyHandler != null) {
257                     logger.removeHandler(copyHandler);
258                 }
259                 copyHandler = null;
260             }
261         }
262 
263         public synchronized PrintStream getPrintStream() {
264             if (loggerSandwich == null) {
265                 loggerSandwich = new LoggerPrintStream(logger);
266             }
267             return loggerSandwich;
268         }
269     }
270 
271     /**
272      * Subclass of StreamHandler for redirecting log output.  flush
273      * must be called in the publish and close methods.
274      */
275     private static class InternalStreamHandler extends StreamHandler {
276         InternalStreamHandler(OutputStream out) {
277             super(out, new SimpleFormatter());
278         }
279 
280         public void publish(LogRecord record) {
281             super.publish(record);
282             flush();
283         }
284 
285         public void close() {
286             flush();
287         }
288     }
289 
290     /**
291      * PrintStream which forwards log messages to the logger.  Class
292      * is needed to maintain backwards compatibility with
293      * RemoteServer.{set|get}Log().
294      */
295     private static class LoggerPrintStream extends PrintStream {
296 
297         /** logger where output of this log is sent */
298         private final Logger logger;
299 
300         /** record the last character written to this stream */
301         private int last = -1;
302 
303         /** stream used for buffering lines */
304         private final ByteArrayOutputStream bufOut;
305 
306         private LoggerPrintStream(Logger logger)
307         {
308             super(new ByteArrayOutputStream());
309             bufOut = (ByteArrayOutputStream) super.out;
310             this.logger = logger;
311         }
312 
313         public void write(int b) {
314             if ((last == &#39;\r&#39;) &amp;&amp; (b == &#39;\n&#39;)) {
315                 last = -1;
316                 return;
317             } else if ((b == &#39;\n&#39;) || (b == &#39;\r&#39;)) {
318                 try {
319                     /* write the converted bytes of the log message */
320                     String message =
321                         Thread.currentThread().getName() + &quot;: &quot; +
322                         bufOut.toString();
323                     logger.logp(Level.INFO, &quot;LogStream&quot;, &quot;print&quot;, message);
324                 } finally {
325                     bufOut.reset();
326                 }
327             } else {
328                 super.write(b);
329             }
330             last = b;
331         }
332 
333         public void write(byte b[], int off, int len) {
334             if (len &lt; 0) {
335                 throw new ArrayIndexOutOfBoundsException(len);
336             }
337             for (int i = 0; i &lt; len; i++) {
338                 write(b[off + i]);
339             }
340         }
341 
342         public String toString() {
343             return &quot;RMI&quot;;
344         }
345     }
346 
347     /**
348      * Factory to create Log objects which deliver log messages to the
349      * java.rmi.server.LogStream API
350      */
351     private static class LogStreamLogFactory implements LogFactory {
352         LogStreamLogFactory() {}
353 
354         /* create a new LogStreamLog for the specified log */
355         public Log createLog(String loggerName, String oldLogName,
356                              Level level)
357         {
358             LogStream stream = null;
359             if (oldLogName != null) {
360                 stream = LogStream.log(oldLogName);
361             }
362             return new LogStreamLog(stream, level);
363         }
364     }
365 
366     /**
367      * Class specialized to log messages to the
368      * java.rmi.server.LogStream API
369      */
370     private static class LogStreamLog extends Log {
371         /** Log stream to which log messages are written */
372         private final LogStream stream;
373 
374         /** the level of the log as set by associated property */
375         private int levelValue = Level.OFF.intValue();
376 
377         private LogStreamLog(LogStream stream, Level level) {
378             if ((stream != null) &amp;&amp; (level != null)) {
379                 /* if the stream or level is null, don&#39;t log any
380                  * messages
381                  */
382                 levelValue = level.intValue();
383             }
384             this.stream = stream;
385         }
386 
387         public synchronized boolean isLoggable(Level level) {
388             return (level.intValue() &gt;= levelValue);
389         }
390 
391         public void log(Level messageLevel, String message) {
392             if (isLoggable(messageLevel)) {
<a name="6" id="anc6"></a><span class="line-modified">393                 String[] source = getSource();</span>
<span class="line-modified">394                 stream.println(unqualifiedName(source[0]) +</span>
<span class="line-modified">395                                &quot;.&quot; + source[1] + &quot;: &quot; + message);</span>
396             }
397         }
398 
399         public void log(Level level, String message, Throwable thrown) {
400             if (isLoggable(level)) {
401                 /*
402                  * keep output contiguous and maintain the contract of
403                  * RemoteServer.getLog
404                  */
405                 synchronized (stream) {
<a name="7" id="anc7"></a><span class="line-modified">406                     String[] source = getSource();</span>
<span class="line-modified">407                     stream.println(unqualifiedName(source[0]) + &quot;.&quot; +</span>
<span class="line-modified">408                                    source[1] + &quot;: &quot; + message);</span>
409                     thrown.printStackTrace(stream);
410                 }
411             }
412         }
413 
414         public PrintStream getPrintStream() {
415             return stream;
416         }
417 
418         public synchronized void setOutputStream(OutputStream out) {
419             if (out != null) {
420                 if (VERBOSE.intValue() &lt; levelValue) {
421                     levelValue = VERBOSE.intValue();
422                 }
423                 stream.setOutputStream(out);
424             } else {
425                 /* ensure that messages are not logged */
426                 levelValue = Level.OFF.intValue();
427             }
428         }
429 
430         /*
431          * Mimic old log messages that only contain unqualified names.
432          */
433         private static String unqualifiedName(String name) {
434             int lastDot = name.lastIndexOf(&#39;.&#39;);
435             if (lastDot &gt;= 0) {
436                 name = name.substring(lastDot + 1);
437             }
438             name = name.replace(&#39;$&#39;, &#39;.&#39;);
439             return name;
440         }
441     }
442 
443     /**
<a name="8" id="anc8"></a><span class="line-modified">444      * Obtain class and method names of code calling a log method.</span>
445      */
<a name="9" id="anc9"></a><span class="line-modified">446     private static String[] getSource() {</span>
<span class="line-modified">447         StackTraceElement[] trace = (new Exception()).getStackTrace();</span>
<span class="line-modified">448         return new String[] {</span>
<span class="line-modified">449             trace[3].getClassName(),</span>
<span class="line-modified">450             trace[3].getMethodName()</span>
<span class="line-removed">451         };</span>
452     }
453 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.rmi/share/classes/sun/rmi/transport/tcp/TCPTransport.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1996, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.rmi.transport.tcp;
 26 
 27 import java.lang.ref.Reference;
 28 import java.lang.ref.SoftReference;
 29 import java.lang.ref.WeakReference;
 30 import java.lang.reflect.InvocationTargetException;
 31 import java.lang.reflect.UndeclaredThrowableException;
 32 import java.io.DataInputStream;
 33 import java.io.DataOutputStream;
 34 import java.io.IOException;
 35 import java.io.InputStream;
 36 import java.io.OutputStream;
 37 import java.io.BufferedInputStream;
 38 import java.io.BufferedOutputStream;
 39 import java.net.InetAddress;
 40 import java.net.ServerSocket;
 41 import java.net.Socket;
 42 import java.rmi.RemoteException;
 43 import java.rmi.server.ExportException;
 44 import java.rmi.server.LogStream;
 45 import java.rmi.server.RMIFailureHandler;
 46 import java.rmi.server.RMISocketFactory;
 47 import java.rmi.server.RemoteCall;
 48 import java.rmi.server.ServerNotActiveException;
 49 import java.rmi.server.UID;
 50 import java.security.AccessControlContext;
 51 import java.security.AccessController;
 52 import java.security.Permissions;
 53 import java.security.PrivilegedAction;
 54 import java.security.ProtectionDomain;
 55 import java.util.ArrayList;
 56 import java.util.LinkedList;
 57 import java.util.List;
 58 import java.util.Map;
 59 import java.util.WeakHashMap;
 60 import java.util.logging.Level;
 61 import java.util.concurrent.ExecutorService;
 62 import java.util.concurrent.RejectedExecutionException;
 63 import java.util.concurrent.SynchronousQueue;
 64 import java.util.concurrent.ThreadFactory;
 65 import java.util.concurrent.ThreadPoolExecutor;
 66 import java.util.concurrent.TimeUnit;
 67 import java.util.concurrent.atomic.AtomicInteger;
 68 import sun.rmi.runtime.Log;
 69 import sun.rmi.runtime.NewThreadAction;
 70 import sun.rmi.transport.Channel;
 71 import sun.rmi.transport.Connection;
 72 import sun.rmi.transport.DGCAckHandler;
 73 import sun.rmi.transport.Endpoint;
 74 import sun.rmi.transport.StreamRemoteCall;
 75 import sun.rmi.transport.Target;
 76 import sun.rmi.transport.Transport;
 77 import sun.rmi.transport.TransportConstants;
 78 
 79 /**
 80  * TCPTransport is the socket-based implementation of the RMI Transport
 81  * abstraction.
 82  *
 83  * @author Ann Wollrath
 84  * @author Peter Jones
 85  */
 86 @SuppressWarnings(&quot;deprecation&quot;)
 87 public class TCPTransport extends Transport {
 88 
 89     /* tcp package log */
 90     static final Log tcpLog = Log.getLog(&quot;sun.rmi.transport.tcp&quot;, &quot;tcp&quot;,
 91         LogStream.parseLevel(AccessController.doPrivileged(
 92             (PrivilegedAction&lt;String&gt;) () -&gt; System.getProperty(&quot;sun.rmi.transport.tcp.logLevel&quot;))));
 93 
 94     /** maximum number of connection handler threads */
 95     private static final int maxConnectionThreads =     // default no limit
 96         AccessController.doPrivileged((PrivilegedAction&lt;Integer&gt;) () -&gt;
 97             Integer.getInteger(&quot;sun.rmi.transport.tcp.maxConnectionThreads&quot;,
 98                                Integer.MAX_VALUE));
 99 
100     /** keep alive time for idle connection handler threads */
101     private static final long threadKeepAliveTime =     // default 1 minute
102         AccessController.doPrivileged((PrivilegedAction&lt;Long&gt;) () -&gt;
103             Long.getLong(&quot;sun.rmi.transport.tcp.threadKeepAliveTime&quot;, 60000));
104 
105     /** thread pool for connection handlers */
106     private static final ExecutorService connectionThreadPool =
107         new ThreadPoolExecutor(0, maxConnectionThreads,
108             threadKeepAliveTime, TimeUnit.MILLISECONDS,
109             new SynchronousQueue&lt;Runnable&gt;(),
110             new ThreadFactory() {
111                 public Thread newThread(Runnable runnable) {
112                     return AccessController.doPrivileged(new NewThreadAction(
113                         runnable, &quot;TCP Connection(idle)&quot;, true, true));
114                 }
115             });
116 
117     /** total connections handled */
118     private static final AtomicInteger connectionCount = new AtomicInteger(0);
119 
120     /** client host for the current thread&#39;s connection */
121     private static final ThreadLocal&lt;ConnectionHandler&gt;
122         threadConnectionHandler = new ThreadLocal&lt;&gt;();
123 
124     /** an AccessControlContext with no permissions */
125     private static final AccessControlContext NOPERMS_ACC;
126     static {
127         Permissions perms = new Permissions();
128         ProtectionDomain[] pd = { new ProtectionDomain(null, perms) };
129         NOPERMS_ACC = new AccessControlContext(pd);
130     }
131 
132     /** endpoints for this transport */
133     private final LinkedList&lt;TCPEndpoint&gt; epList;
134     /** number of objects exported on this transport */
135     private int exportCount = 0;
136     /** server socket for this transport */
137     private ServerSocket server = null;
138     /** table mapping endpoints to channels */
139     private final Map&lt;TCPEndpoint,Reference&lt;TCPChannel&gt;&gt; channelTable =
140         new WeakHashMap&lt;&gt;();
141 
142     static final RMISocketFactory defaultSocketFactory =
143         RMISocketFactory.getDefaultSocketFactory();
144 
145     /** number of milliseconds in accepted-connection timeout.
146      * Warning: this should be greater than 15 seconds (the client-side
147      * timeout), and defaults to 2 hours.
148      * The maximum representable value is slightly more than 24 days
149      * and 20 hours.
150      */
151     private static final int connectionReadTimeout =    // default 2 hours
152         AccessController.doPrivileged((PrivilegedAction&lt;Integer&gt;) () -&gt;
153             Integer.getInteger(&quot;sun.rmi.transport.tcp.readTimeout&quot;, 2 * 3600 * 1000));
154 
155     /**
156      * Constructs a TCPTransport.
157      */
158     TCPTransport(LinkedList&lt;TCPEndpoint&gt; epList)  {
159         // assert ((epList.size() != null) &amp;&amp; (epList.size() &gt;= 1))
160         this.epList = epList;
161         if (tcpLog.isLoggable(Log.BRIEF)) {
162             tcpLog.log(Log.BRIEF, &quot;Version = &quot; +
163                 TransportConstants.Version + &quot;, ep = &quot; + getEndpoint());
164         }
165     }
166 
167     /**
168      * Closes all cached connections in every channel subordinated to this
169      * transport.  Currently, this only closes outgoing connections.
170      */
171     public void shedConnectionCaches() {
172         List&lt;TCPChannel&gt; channels;
173         synchronized (channelTable) {
174             channels = new ArrayList&lt;TCPChannel&gt;(channelTable.values().size());
175             for (Reference&lt;TCPChannel&gt; ref : channelTable.values()) {
176                 TCPChannel ch = ref.get();
177                 if (ch != null) {
178                     channels.add(ch);
179                 }
180             }
181         }
182         for (TCPChannel channel : channels) {
183             channel.shedCache();
184         }
185     }
186 
187     /**
188      * Returns a &lt;I&gt;Channel&lt;/I&gt; that generates connections to the
189      * endpoint &lt;I&gt;ep&lt;/I&gt;. A Channel is an object that creates and
190      * manages connections of a particular type to some particular
191      * address space.
192      * @param ep the endpoint to which connections will be generated.
193      * @return the channel or null if the transport cannot
194      * generate connections to this endpoint
195      */
196     public TCPChannel getChannel(Endpoint ep) {
197         TCPChannel ch = null;
198         if (ep instanceof TCPEndpoint) {
199             synchronized (channelTable) {
200                 Reference&lt;TCPChannel&gt; ref = channelTable.get(ep);
201                 if (ref != null) {
202                     ch = ref.get();
203                 }
204                 if (ch == null) {
205                     TCPEndpoint tcpEndpoint = (TCPEndpoint) ep;
206                     ch = new TCPChannel(this, tcpEndpoint);
207                     channelTable.put(tcpEndpoint,
208                                      new WeakReference&lt;TCPChannel&gt;(ch));
209                 }
210             }
211         }
212         return ch;
213     }
214 
215     /**
216      * Removes the &lt;I&gt;Channel&lt;/I&gt; that generates connections to the
217      * endpoint &lt;I&gt;ep&lt;/I&gt;.
218      */
219     public void free(Endpoint ep) {
220         if (ep instanceof TCPEndpoint) {
221             synchronized (channelTable) {
222                 Reference&lt;TCPChannel&gt; ref = channelTable.remove(ep);
223                 if (ref != null) {
224                     TCPChannel channel = ref.get();
225                     if (channel != null) {
226                         channel.shedCache();
227                     }
228                 }
229             }
230         }
231     }
232 
233     /**
234      * Export the object so that it can accept incoming calls.
235      */
236     public void exportObject(Target target) throws RemoteException {
237         /*
238          * Ensure that a server socket is listening, and count this
239          * export while synchronized to prevent the server socket from
240          * being closed due to concurrent unexports.
241          */
242         synchronized (this) {
243             listen();
244             exportCount++;
245         }
246 
247         /*
248          * Try to add the Target to the exported object table; keep
249          * counting this export (to keep server socket open) only if
250          * that succeeds.
251          */
252         boolean ok = false;
253         try {
254             super.exportObject(target);
255             ok = true;
256         } finally {
257             if (!ok) {
258                 synchronized (this) {
259                     decrementExportCount();
260                 }
261             }
262         }
263     }
264 
265     protected synchronized void targetUnexported() {
266         decrementExportCount();
267     }
268 
269     /**
270      * Decrements the count of exported objects, closing the current
271      * server socket if the count reaches zero.
272      **/
273     private void decrementExportCount() {
274         assert Thread.holdsLock(this);
275         exportCount--;
<a name="1" id="anc1"></a>



276         if (exportCount == 0 &amp;&amp; getEndpoint().getListenPort() != 0) {
277             ServerSocket ss = server;
278             server = null;
279             try {
<a name="2" id="anc2"></a>


280                 ss.close();
281             } catch (IOException e) {
<a name="3" id="anc3"></a>



282             }
283         }
284     }
285 
286     /**
287      * Verify that the current access control context has permission to
288      * accept the connection being dispatched by the current thread.
289      */
290     protected void checkAcceptPermission(AccessControlContext acc) {
291         SecurityManager sm = System.getSecurityManager();
292         if (sm == null) {
293             return;
294         }
295         ConnectionHandler h = threadConnectionHandler.get();
296         if (h == null) {
297             throw new Error(
298                 &quot;checkAcceptPermission not in ConnectionHandler thread&quot;);
299         }
300         h.checkAcceptPermission(sm, acc);
301     }
302 
303     private TCPEndpoint getEndpoint() {
304         synchronized (epList) {
305             return epList.getLast();
306         }
307     }
308 
309     /**
310      * Listen on transport&#39;s endpoint.
311      */
312     private void listen() throws RemoteException {
313         assert Thread.holdsLock(this);
314         TCPEndpoint ep = getEndpoint();
315         int port = ep.getPort();
316 
317         if (server == null) {
318             if (tcpLog.isLoggable(Log.BRIEF)) {
319                 tcpLog.log(Log.BRIEF,
320                     &quot;(port &quot; + port + &quot;) create server socket&quot;);
321             }
322 
323             try {
324                 server = ep.newServerSocket();
325                 /*
326                  * Don&#39;t retry ServerSocket if creation fails since
327                  * &quot;port in use&quot; will cause export to hang if an
328                  * RMIFailureHandler is not installed.
329                  */
330                 Thread t = AccessController.doPrivileged(
331                     new NewThreadAction(new AcceptLoop(server),
332                                         &quot;TCP Accept-&quot; + port, true));
333                 t.start();
334             } catch (java.net.BindException e) {
335                 throw new ExportException(&quot;Port already in use: &quot; + port, e);
336             } catch (IOException e) {
337                 throw new ExportException(&quot;Listen failed on port: &quot; + port, e);
338             }
339 
340         } else {
341             // otherwise verify security access to existing server socket
342             SecurityManager sm = System.getSecurityManager();
343             if (sm != null) {
344                 sm.checkListen(port);
345             }
346         }
347     }
348 
349     /**
350      * Worker for accepting connections from a server socket.
351      **/
352     private class AcceptLoop implements Runnable {
353 
354         private final ServerSocket serverSocket;
355 
356         // state for throttling loop on exceptions (local to accept thread)
357         private long lastExceptionTime = 0L;
358         private int recentExceptionCount;
359 
360         AcceptLoop(ServerSocket serverSocket) {
361             this.serverSocket = serverSocket;
362         }
363 
364         public void run() {
365             try {
366                 executeAcceptLoop();
367             } finally {
368                 try {
<a name="4" id="anc4"></a>



369                     /*
370                      * Only one accept loop is started per server
371                      * socket, so after no more connections will be
372                      * accepted, ensure that the server socket is no
373                      * longer listening.
374                      */
375                     serverSocket.close();
376                 } catch (IOException e) {
<a name="5" id="anc5"></a>



377                 }
378             }
379         }
380 
381         /**
382          * Accepts connections from the server socket and executes
383          * handlers for them in the thread pool.
384          **/
385         private void executeAcceptLoop() {
386             if (tcpLog.isLoggable(Log.BRIEF)) {
387                 tcpLog.log(Log.BRIEF, &quot;listening on port &quot; +
388                            getEndpoint().getPort());
389             }
390 
391             while (true) {
392                 Socket socket = null;
393                 try {
394                     socket = serverSocket.accept();
395 
396                     /*
397                      * Find client host name (or &quot;0.0.0.0&quot; if unknown)
398                      */
399                     InetAddress clientAddr = socket.getInetAddress();
400                     String clientHost = (clientAddr != null
401                                          ? clientAddr.getHostAddress()
402                                          : &quot;0.0.0.0&quot;);
403 
404                     /*
405                      * Execute connection handler in the thread pool,
406                      * which uses non-system threads.
407                      */
408                     try {
409                         connectionThreadPool.execute(
410                             new ConnectionHandler(socket, clientHost));
411                     } catch (RejectedExecutionException e) {
412                         closeSocket(socket);
413                         tcpLog.log(Log.BRIEF,
414                                    &quot;rejected connection from &quot; + clientHost);
415                     }
416 
417                 } catch (Throwable t) {
418                     try {
419                         /*
420                          * If the server socket has been closed, such
421                          * as because there are no more exported
422                          * objects, then we expect accept to throw an
423                          * exception, so just terminate normally.
424                          */
425                         if (serverSocket.isClosed()) {
426                             break;
427                         }
428 
429                         try {
430                             if (tcpLog.isLoggable(Level.WARNING)) {
431                                 tcpLog.log(Level.WARNING,
432                                            &quot;accept loop for &quot; + serverSocket +
433                                            &quot; throws&quot;, t);
434                             }
435                         } catch (Throwable tt) {
436                         }
437                     } finally {
438                         /*
439                          * Always close the accepted socket (if any)
440                          * if an exception occurs, but only after
441                          * logging an unexpected exception.
442                          */
443                         if (socket != null) {
444                             closeSocket(socket);
445                         }
446                     }
447 
448                     /*
449                      * In case we&#39;re running out of file descriptors,
450                      * release resources held in caches.
451                      */
452                     if (!(t instanceof SecurityException)) {
453                         try {
454                             TCPEndpoint.shedConnectionCaches();
455                         } catch (Throwable tt) {
456                         }
457                     }
458 
459                     /*
460                      * A NoClassDefFoundError can occur if no file
461                      * descriptors are available, in which case this
462                      * loop should not terminate.
463                      */
464                     if (t instanceof Exception ||
465                         t instanceof OutOfMemoryError ||
466                         t instanceof NoClassDefFoundError)
467                     {
468                         if (!continueAfterAcceptFailure(t)) {
469                             return;
470                         }
471                         // continue loop
472                     } else if (t instanceof Error) {
473                         throw (Error) t;
474                     } else {
475                         throw new UndeclaredThrowableException(t);
476                     }
477                 }
478             }
479         }
480 
481         /**
482          * Returns true if the accept loop should continue after the
483          * specified exception has been caught, or false if the accept
484          * loop should terminate (closing the server socket).  If
485          * there is an RMIFailureHandler, this method returns the
486          * result of passing the specified exception to it; otherwise,
487          * this method always returns true, after sleeping to throttle
488          * the accept loop if necessary.
489          **/
490         private boolean continueAfterAcceptFailure(Throwable t) {
491             RMIFailureHandler fh = RMISocketFactory.getFailureHandler();
492             if (fh != null) {
493                 return fh.failure(t instanceof Exception ? (Exception) t :
494                                   new InvocationTargetException(t));
495             } else {
496                 throttleLoopOnException();
497                 return true;
498             }
499         }
500 
501         /**
502          * Throttles the accept loop after an exception has been
503          * caught: if a burst of 10 exceptions in 5 seconds occurs,
504          * then wait for 10 seconds to curb busy CPU usage.
505          **/
506         private void throttleLoopOnException() {
507             long now = System.currentTimeMillis();
508             if (lastExceptionTime == 0L || (now - lastExceptionTime) &gt; 5000) {
509                 // last exception was long ago (or this is the first)
510                 lastExceptionTime = now;
511                 recentExceptionCount = 0;
512             } else {
513                 // exception burst window was started recently
514                 if (++recentExceptionCount &gt;= 10) {
515                     try {
516                         Thread.sleep(10000);
517                     } catch (InterruptedException ignore) {
518                     }
519                 }
520             }
521         }
522     }
523 
524     /** close socket and eat exception */
525     private static void closeSocket(Socket sock) {
526         try {
<a name="6" id="anc6"></a>


527             sock.close();
528         } catch (IOException ex) {
529             // eat exception
<a name="7" id="anc7"></a>


530         }
531     }
532 
533     /**
534      * handleMessages decodes transport operations and handles messages
535      * appropriately.  If an exception occurs during message handling,
536      * the socket is closed.
537      */
538     void handleMessages(Connection conn, boolean persistent) {
539         int port = getEndpoint().getPort();
540 
541         try {
542             DataInputStream in = new DataInputStream(conn.getInputStream());
543             do {
544                 int op = in.read();     // transport op
545                 if (op == -1) {
546                     if (tcpLog.isLoggable(Log.BRIEF)) {
547                         tcpLog.log(Log.BRIEF, &quot;(port &quot; +
548                             port + &quot;) connection closed&quot;);
549                     }
550                     break;
551                 }
552 
553                 if (tcpLog.isLoggable(Log.BRIEF)) {
554                     tcpLog.log(Log.BRIEF, &quot;(port &quot; + port +
555                         &quot;) op = &quot; + op);
556                 }
557 
558                 switch (op) {
559                 case TransportConstants.Call:
560                     // service incoming RMI call
561                     RemoteCall call = new StreamRemoteCall(conn);
562                     if (serviceCall(call) == false)
563                         return;
564                     break;
565 
566                 case TransportConstants.Ping:
567                     // send ack for ping
568                     DataOutputStream out =
569                         new DataOutputStream(conn.getOutputStream());
570                     out.writeByte(TransportConstants.PingAck);
571                     conn.releaseOutputStream();
572                     break;
573 
574                 case TransportConstants.DGCAck:
575                     DGCAckHandler.received(UID.read(in));
576                     break;
577 
578                 default:
579                     throw new IOException(&quot;unknown transport op &quot; + op);
580                 }
581             } while (persistent);
582 
583         } catch (IOException e) {
584             // exception during processing causes connection to close (below)
585             if (tcpLog.isLoggable(Log.BRIEF)) {
586                 tcpLog.log(Log.BRIEF, &quot;(port &quot; + port +
587                     &quot;) exception: &quot;, e);
588             }
589         } finally {
590             try {
591                 conn.close();
592             } catch (IOException ex) {
593                 // eat exception
<a name="8" id="anc8"></a>


594             }
595         }
596     }
597 
598     /**
599      * Returns the client host for the current thread&#39;s connection.  Throws
600      * ServerNotActiveException if no connection is active for this thread.
601      */
602     public static String getClientHost() throws ServerNotActiveException {
603         ConnectionHandler h = threadConnectionHandler.get();
604         if (h != null) {
605             return h.getClientHost();
606         } else {
607             throw new ServerNotActiveException(&quot;not in a remote call&quot;);
608         }
609     }
610 
611     /**
612      * Services messages on accepted connection
613      */
614     private class ConnectionHandler implements Runnable {
615 
616         /** int value of &quot;POST&quot; in ASCII (Java&#39;s specified data formats
617          *  make this once-reviled tactic again socially acceptable) */
618         private static final int POST = 0x504f5354;
619 
620         /** most recently accept-authorized AccessControlContext */
621         private AccessControlContext okContext;
622         /** cache of accept-authorized AccessControlContexts */
623         private Map&lt;AccessControlContext,
624                     Reference&lt;AccessControlContext&gt;&gt; authCache;
625         /** security manager which authorized contexts in authCache */
626         private SecurityManager cacheSecurityManager = null;
627 
628         private Socket socket;
629         private String remoteHost;
630 
631         ConnectionHandler(Socket socket, String remoteHost) {
632             this.socket = socket;
633             this.remoteHost = remoteHost;
634         }
635 
636         String getClientHost() {
637             return remoteHost;
638         }
639 
640         /**
641          * Verify that the given AccessControlContext has permission to
642          * accept this connection.
643          */
644         void checkAcceptPermission(SecurityManager sm,
645                                    AccessControlContext acc)
646         {
647             /*
648              * Note: no need to synchronize on cache-related fields, since this
649              * method only gets called from the ConnectionHandler&#39;s thread.
650              */
651             if (sm != cacheSecurityManager) {
652                 okContext = null;
653                 authCache = new WeakHashMap&lt;AccessControlContext,
654                                             Reference&lt;AccessControlContext&gt;&gt;();
655                 cacheSecurityManager = sm;
656             }
657             if (acc.equals(okContext) || authCache.containsKey(acc)) {
658                 return;
659             }
660             InetAddress addr = socket.getInetAddress();
661             String host = (addr != null) ? addr.getHostAddress() : &quot;*&quot;;
662 
663             sm.checkAccept(host, socket.getPort());
664 
665             authCache.put(acc, new SoftReference&lt;AccessControlContext&gt;(acc));
666             okContext = acc;
667         }
668 
669         public void run() {
670             Thread t = Thread.currentThread();
671             String name = t.getName();
672             try {
673                 t.setName(&quot;RMI TCP Connection(&quot; +
674                           connectionCount.incrementAndGet() +
675                           &quot;)-&quot; + remoteHost);
676                 AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;)() -&gt; {
677                     run0();
678                     return null;
679                 }, NOPERMS_ACC);
680             } finally {
681                 t.setName(name);
682             }
683         }
684 
685         @SuppressWarnings(&quot;fallthrough&quot;)
686         private void run0() {
687             TCPEndpoint endpoint = getEndpoint();
688             int port = endpoint.getPort();
689 
690             threadConnectionHandler.set(this);
691 
692             // set socket to disable Nagle&#39;s algorithm (always send
693             // immediately)
694             // TBD: should this be left up to socket factory instead?
695             try {
696                 socket.setTcpNoDelay(true);
697             } catch (Exception e) {
698                 // if we fail to set this, ignore and proceed anyway
699             }
700             // set socket to timeout after excessive idle time
701             try {
702                 if (connectionReadTimeout &gt; 0)
703                     socket.setSoTimeout(connectionReadTimeout);
704             } catch (Exception e) {
705                 // too bad, continue anyway
706             }
707 
708             try {
709                 InputStream sockIn = socket.getInputStream();
710                 InputStream bufIn = sockIn.markSupported()
711                         ? sockIn
712                         : new BufferedInputStream(sockIn);
713 
714                 // Read magic
715                 DataInputStream in = new DataInputStream(bufIn);
716                 int magic = in.readInt();
717 
718                 // read and verify transport header
719                 short version = in.readShort();
720                 if (magic != TransportConstants.Magic ||
721                     version != TransportConstants.Version) {
722                     // protocol mismatch detected...
723                     // just close socket: this would recurse if we marshal an
724                     // exception to the client and the protocol at other end
725                     // doesn&#39;t match.
<a name="9" id="anc9"></a>



726                     closeSocket(socket);
727                     return;
728                 }
729 
730                 OutputStream sockOut = socket.getOutputStream();
731                 BufferedOutputStream bufOut =
732                     new BufferedOutputStream(sockOut);
733                 DataOutputStream out = new DataOutputStream(bufOut);
734 
735                 int remotePort = socket.getPort();
736 
737                 if (tcpLog.isLoggable(Log.BRIEF)) {
738                     tcpLog.log(Log.BRIEF, &quot;accepted socket from [&quot; +
739                                      remoteHost + &quot;:&quot; + remotePort + &quot;]&quot;);
740                 }
741 
742                 TCPEndpoint ep;
743                 TCPChannel ch;
744                 TCPConnection conn;
745 
746                 // send ack (or nack) for protocol
747                 byte protocol = in.readByte();
748                 switch (protocol) {
749                 case TransportConstants.SingleOpProtocol:
750                     // no ack for protocol
751 
752                     // create dummy channel for receiving messages
753                     ep = new TCPEndpoint(remoteHost, socket.getLocalPort(),
754                                          endpoint.getClientSocketFactory(),
755                                          endpoint.getServerSocketFactory());
756                     ch = new TCPChannel(TCPTransport.this, ep);
757                     conn = new TCPConnection(ch, socket, bufIn, bufOut);
758 
759                     // read input messages
760                     handleMessages(conn, false);
761                     break;
762 
763                 case TransportConstants.StreamProtocol:
764                     // send ack
765                     out.writeByte(TransportConstants.ProtocolAck);
766 
767                     // suggest endpoint (in case client doesn&#39;t know host name)
768                     if (tcpLog.isLoggable(Log.VERBOSE)) {
769                         tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +
770                             &quot;) &quot; + &quot;suggesting &quot; + remoteHost + &quot;:&quot; +
771                             remotePort);
772                     }
773 
774                     out.writeUTF(remoteHost);
775                     out.writeInt(remotePort);
776                     out.flush();
777 
778                     // read and discard (possibly bogus) endpoint
779                     // REMIND: would be faster to read 2 bytes then skip N+4
780                     String clientHost = in.readUTF();
781                     int    clientPort = in.readInt();
782                     if (tcpLog.isLoggable(Log.VERBOSE)) {
783                         tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +
784                             &quot;) client using &quot; + clientHost + &quot;:&quot; + clientPort);
785                     }
786 
787                     // create dummy channel for receiving messages
788                     // (why not use clientHost and clientPort?)
789                     ep = new TCPEndpoint(remoteHost, socket.getLocalPort(),
790                                          endpoint.getClientSocketFactory(),
791                                          endpoint.getServerSocketFactory());
792                     ch = new TCPChannel(TCPTransport.this, ep);
793                     conn = new TCPConnection(ch, socket, bufIn, bufOut);
794 
795                     // read input messages
796                     handleMessages(conn, true);
797                     break;
798 
799                 case TransportConstants.MultiplexProtocol:
800                     if (tcpLog.isLoggable(Log.VERBOSE)) {
801                         tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +
802                                 &quot;) rejecting multiplex protocol&quot;);
803                     }
804                     // Fall-through to reject use of MultiplexProtocol
805                 default:
806                     // protocol not understood, send nack and close socket
807                     out.writeByte(TransportConstants.ProtocolNack);
808                     out.flush();
809                     break;
810                 }
811 
812             } catch (IOException e) {
813                 // socket in unknown state: destroy socket
814                 tcpLog.log(Log.BRIEF, &quot;terminated with exception:&quot;, e);
815             } finally {
816                 closeSocket(socket);
817             }
818         }
819     }
820 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
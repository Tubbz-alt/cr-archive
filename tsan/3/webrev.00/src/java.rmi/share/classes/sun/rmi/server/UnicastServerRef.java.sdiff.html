<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.rmi/share/classes/sun/rmi/server/UnicastServerRef.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnicastRef.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../transport/DGCImpl_Skel.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.rmi/share/classes/sun/rmi/server/UnicastServerRef.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.rmi.server;
 27 
 28 import java.io.IOException;
 29 import java.io.ObjectInput;
 30 import java.io.ObjectInputFilter;
 31 import java.io.ObjectInputStream;
 32 import java.io.ObjectOutput;
 33 import java.lang.reflect.InvocationTargetException;
 34 import java.lang.reflect.Method;
 35 import java.rmi.AccessException;
 36 import java.rmi.MarshalException;
 37 import java.rmi.Remote;
 38 import java.rmi.RemoteException;
 39 import java.rmi.ServerError;
 40 import java.rmi.ServerException;
 41 import java.rmi.UnmarshalException;
 42 import java.rmi.server.ExportException;

 43 import java.rmi.server.RemoteCall;
 44 import java.rmi.server.RemoteRef;
 45 import java.rmi.server.RemoteStub;
 46 import java.rmi.server.ServerNotActiveException;
 47 import java.rmi.server.ServerRef;
 48 import java.rmi.server.Skeleton;
 49 import java.rmi.server.SkeletonNotFoundException;
 50 import java.security.AccessController;
 51 import java.security.PrivilegedAction;
 52 import java.util.Collections;
 53 import java.util.Date;
 54 import java.util.HashMap;
 55 import java.util.Map;
 56 import java.util.WeakHashMap;
 57 import java.util.concurrent.atomic.AtomicInteger;
 58 import sun.rmi.runtime.Log;
 59 import sun.rmi.transport.LiveRef;
 60 import sun.rmi.transport.StreamRemoteCall;
 61 import sun.rmi.transport.Target;
 62 import sun.rmi.transport.tcp.TCPTransport;
</pre>
<hr />
<pre>
275      * method arguments can be obtained.
276      * @exception IOException If unable to marshal return result or
277      * release input or output streams
278      */
279     public void dispatch(Remote obj, RemoteCall call) throws IOException {
280         // positive operation number in 1.1 stubs;
281         // negative version number in 1.2 stubs and beyond...
282         int num;
283         long op;
284 
285         try {
286             // read remote call header
287             ObjectInput in;
288             try {
289                 in = call.getInputStream();
290                 num = in.readInt();
291             } catch (Exception readEx) {
292                 throw new UnmarshalException(&quot;error unmarshalling call header&quot;,
293                                              readEx);
294             }
<span class="line-modified">295             if (num &gt;= 0) {</span>
<span class="line-modified">296                 if (skel != null) {</span>
297                     oldDispatch(obj, call, num);
298                     return;
<span class="line-modified">299                 } else {</span>
<span class="line-modified">300                     throw new UnmarshalException(</span>
<span class="line-modified">301                         &quot;skeleton class not found but required &quot; +</span>
<span class="line-modified">302                         &quot;for client version&quot;);</span>
<span class="line-removed">303                 }</span>
304             }
305             try {
306                 op = in.readLong();
307             } catch (Exception readEx) {
308                 throw new UnmarshalException(&quot;error unmarshalling call header&quot;,
309                         readEx);
310             }
311 
312             /*
313              * Since only system classes (with null class loaders) will be on
314              * the execution stack during parameter unmarshalling for the 1.2
315              * stub protocol, tell the MarshalInputStream not to bother trying
316              * to resolve classes using its superclasses&#39;s default method of
317              * consulting the first non-null class loader on the stack.
318              */
319             MarshalInputStream marshalStream = (MarshalInputStream) in;
320             marshalStream.skipDefaultResolveClass();
321 
322             Method method = hashToMethod_Map.get(op);
323             if (method == null) {
</pre>
<hr />
<pre>
411     /**
412      * Sets a filter for invocation arguments, if a filter has been set.
413      * Called by dispatch before the arguments are read.
414      */
415     protected void unmarshalCustomCallData(ObjectInput in)
416             throws IOException, ClassNotFoundException {
417         if (filter != null &amp;&amp;
418                 in instanceof ObjectInputStream) {
419             // Set the filter on the stream
420             ObjectInputStream ois = (ObjectInputStream) in;
421 
422             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;)() -&gt; {
423                 ois.setObjectInputFilter(filter);
424                 return null;
425             });
426         }
427     }
428 
429     /**
430      * Handle server-side dispatch using the RMI 1.1 stub/skeleton
<span class="line-modified">431      * protocol, given a non-negative operation number that has</span>
<span class="line-modified">432      * already been read from the call stream.</span>
433      * Exceptions are handled by the caller to be sent to the remote client.
434      *
435      * @param obj the target remote object for the call
436      * @param call the &quot;remote call&quot; from which operation and
437      * method arguments can be obtained.
438      * @param op the operation number
439      * @throws Exception if unable to marshal return result or
440      * release input or output streams
441      */
442     private void oldDispatch(Remote obj, RemoteCall call, int op)
443         throws Exception
444     {
445         long hash;              // hash for matching stub with skeleton
446 
447         // read remote call header
448         ObjectInput in;
449         in = call.getInputStream();
450         try {
451             Class&lt;?&gt; clazz = Class.forName(&quot;sun.rmi.transport.DGCImpl_Skel&quot;);
452             if (clazz.isAssignableFrom(skel.getClass())) {
453                 ((MarshalInputStream)in).useCodebaseOnly();
454             }
455         } catch (ClassNotFoundException ignore) { }
456 
457         try {
458             hash = in.readLong();
459         } catch (Exception ioe) {
460             throw new UnmarshalException(&quot;error unmarshalling call header&quot;, ioe);
461         }
462 
463         // if calls are being logged, write out object id and operation
<span class="line-modified">464         logCall(obj, skel.getOperations()[op]);</span>

465         unmarshalCustomCallData(in);
466         // dispatch to skeleton for remote object
467         skel.dispatch(obj, call, op, hash);
468     }
469 
470     /**
471      * Clear the stack trace of the given Throwable by replacing it with
472      * an empty StackTraceElement array, and do the same for all of its
473      * chained causative exceptions.
474      */
475     public static void clearStackTraces(Throwable t) {
476         StackTraceElement[] empty = new StackTraceElement[0];
477         while (t != null) {
478             t.setStackTrace(empty);
479             t = t.getCause();
480         }
481     }
482 
483     /**
484      * Log the details of an incoming call.  The method parameter is either of
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.rmi.server;
 27 
 28 import java.io.IOException;
 29 import java.io.ObjectInput;
 30 import java.io.ObjectInputFilter;
 31 import java.io.ObjectInputStream;
 32 import java.io.ObjectOutput;
 33 import java.lang.reflect.InvocationTargetException;
 34 import java.lang.reflect.Method;
 35 import java.rmi.AccessException;
 36 import java.rmi.MarshalException;
 37 import java.rmi.Remote;
 38 import java.rmi.RemoteException;
 39 import java.rmi.ServerError;
 40 import java.rmi.ServerException;
 41 import java.rmi.UnmarshalException;
 42 import java.rmi.server.ExportException;
<span class="line-added"> 43 import java.rmi.server.Operation;</span>
 44 import java.rmi.server.RemoteCall;
 45 import java.rmi.server.RemoteRef;
 46 import java.rmi.server.RemoteStub;
 47 import java.rmi.server.ServerNotActiveException;
 48 import java.rmi.server.ServerRef;
 49 import java.rmi.server.Skeleton;
 50 import java.rmi.server.SkeletonNotFoundException;
 51 import java.security.AccessController;
 52 import java.security.PrivilegedAction;
 53 import java.util.Collections;
 54 import java.util.Date;
 55 import java.util.HashMap;
 56 import java.util.Map;
 57 import java.util.WeakHashMap;
 58 import java.util.concurrent.atomic.AtomicInteger;
 59 import sun.rmi.runtime.Log;
 60 import sun.rmi.transport.LiveRef;
 61 import sun.rmi.transport.StreamRemoteCall;
 62 import sun.rmi.transport.Target;
 63 import sun.rmi.transport.tcp.TCPTransport;
</pre>
<hr />
<pre>
276      * method arguments can be obtained.
277      * @exception IOException If unable to marshal return result or
278      * release input or output streams
279      */
280     public void dispatch(Remote obj, RemoteCall call) throws IOException {
281         // positive operation number in 1.1 stubs;
282         // negative version number in 1.2 stubs and beyond...
283         int num;
284         long op;
285 
286         try {
287             // read remote call header
288             ObjectInput in;
289             try {
290                 in = call.getInputStream();
291                 num = in.readInt();
292             } catch (Exception readEx) {
293                 throw new UnmarshalException(&quot;error unmarshalling call header&quot;,
294                                              readEx);
295             }
<span class="line-modified">296             if (skel != null) {</span>
<span class="line-modified">297                 // If there is a skeleton, use it</span>
298                     oldDispatch(obj, call, num);
299                     return;
<span class="line-modified">300 </span>
<span class="line-modified">301             } else if (num &gt;= 0){</span>
<span class="line-modified">302                 throw new UnmarshalException(</span>
<span class="line-modified">303                         &quot;skeleton class not found but required for client version&quot;);</span>

304             }
305             try {
306                 op = in.readLong();
307             } catch (Exception readEx) {
308                 throw new UnmarshalException(&quot;error unmarshalling call header&quot;,
309                         readEx);
310             }
311 
312             /*
313              * Since only system classes (with null class loaders) will be on
314              * the execution stack during parameter unmarshalling for the 1.2
315              * stub protocol, tell the MarshalInputStream not to bother trying
316              * to resolve classes using its superclasses&#39;s default method of
317              * consulting the first non-null class loader on the stack.
318              */
319             MarshalInputStream marshalStream = (MarshalInputStream) in;
320             marshalStream.skipDefaultResolveClass();
321 
322             Method method = hashToMethod_Map.get(op);
323             if (method == null) {
</pre>
<hr />
<pre>
411     /**
412      * Sets a filter for invocation arguments, if a filter has been set.
413      * Called by dispatch before the arguments are read.
414      */
415     protected void unmarshalCustomCallData(ObjectInput in)
416             throws IOException, ClassNotFoundException {
417         if (filter != null &amp;&amp;
418                 in instanceof ObjectInputStream) {
419             // Set the filter on the stream
420             ObjectInputStream ois = (ObjectInputStream) in;
421 
422             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;)() -&gt; {
423                 ois.setObjectInputFilter(filter);
424                 return null;
425             });
426         }
427     }
428 
429     /**
430      * Handle server-side dispatch using the RMI 1.1 stub/skeleton
<span class="line-modified">431      * protocol, given a non-negative operation number or negative method hash</span>
<span class="line-modified">432      * that has already been read from the call stream.</span>
433      * Exceptions are handled by the caller to be sent to the remote client.
434      *
435      * @param obj the target remote object for the call
436      * @param call the &quot;remote call&quot; from which operation and
437      * method arguments can be obtained.
438      * @param op the operation number
439      * @throws Exception if unable to marshal return result or
440      * release input or output streams
441      */
442     private void oldDispatch(Remote obj, RemoteCall call, int op)
443         throws Exception
444     {
445         long hash;              // hash for matching stub with skeleton
446 
447         // read remote call header
448         ObjectInput in;
449         in = call.getInputStream();
450         try {
451             Class&lt;?&gt; clazz = Class.forName(&quot;sun.rmi.transport.DGCImpl_Skel&quot;);
452             if (clazz.isAssignableFrom(skel.getClass())) {
453                 ((MarshalInputStream)in).useCodebaseOnly();
454             }
455         } catch (ClassNotFoundException ignore) { }
456 
457         try {
458             hash = in.readLong();
459         } catch (Exception ioe) {
460             throw new UnmarshalException(&quot;error unmarshalling call header&quot;, ioe);
461         }
462 
463         // if calls are being logged, write out object id and operation
<span class="line-modified">464         Operation[] operations = skel.getOperations();</span>
<span class="line-added">465         logCall(obj, op &gt;= 0 &amp;&amp; op &lt; operations.length ?  operations[op] : &quot;op: &quot; + op);</span>
466         unmarshalCustomCallData(in);
467         // dispatch to skeleton for remote object
468         skel.dispatch(obj, call, op, hash);
469     }
470 
471     /**
472      * Clear the stack trace of the given Throwable by replacing it with
473      * an empty StackTraceElement array, and do the same for all of its
474      * chained causative exceptions.
475      */
476     public static void clearStackTraces(Throwable t) {
477         StackTraceElement[] empty = new StackTraceElement[0];
478         while (t != null) {
479             t.setStackTrace(empty);
480             t = t.getCause();
481         }
482     }
483 
484     /**
485      * Log the details of an incoming call.  The method parameter is either of
</pre>
</td>
</tr>
</table>
<center><a href="UnicastRef.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../transport/DGCImpl_Skel.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
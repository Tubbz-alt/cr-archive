<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.rmi/share/classes/sun/rmi/runtime/Log.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.rmi.runtime;
 27 
 28 import java.io.ByteArrayOutputStream;
 29 import java.io.PrintStream;
 30 import java.io.OutputStream;
<a name="1" id="anc1"></a><span class="line-added"> 31 import java.lang.StackWalker.StackFrame;</span>
 32 import java.rmi.server.LogStream;
 33 import java.security.PrivilegedAction;
<a name="2" id="anc2"></a><span class="line-added"> 34 import java.util.Set;</span>
 35 import java.util.logging.Handler;
 36 import java.util.logging.SimpleFormatter;
 37 import java.util.logging.Level;
 38 import java.util.logging.Logger;
 39 import java.util.logging.LogRecord;
 40 import java.util.logging.StreamHandler;
 41 
 42 /**
 43  * Utility which provides an abstract &quot;logger&quot; like RMI internal API
 44  * which can be directed to use one of two types of logging
 45  * infrastructure: the java.util.logging API or the
 46  * java.rmi.server.LogStream API.  The default behavior is to use the
 47  * java.util.logging API.  The LogStream API may be used instead by
 48  * setting the system property sun.rmi.log.useOld to true.
 49  *
 50  * For backwards compatibility, supports the RMI system logging
 51  * properties which pre-1.4 comprised the only way to configure RMI
 52  * logging.  If the java.util.logging API is used and RMI system log
 53  * properties are set, the system properties override initial RMI
 54  * logger values as appropriate. If the java.util.logging API is
 55  * turned off, pre-1.4 logging behavior is used.
 56  *
 57  * @author Laird Dornin
 58  * @since 1.4
 59  */
 60 @SuppressWarnings(&quot;deprecation&quot;)
 61 public abstract class Log {
 62 
 63     /** Logger re-definition of old RMI log values */
 64     public static final Level BRIEF = Level.FINE;
 65     public static final Level VERBOSE = Level.FINER;
 66 
<a name="3" id="anc3"></a><span class="line-added"> 67     private static final StackWalker WALKER = StackWalker.getInstance(Set.of(), 4);</span>
<span class="line-added"> 68 </span>
 69     /* selects log implementation */
 70     private static final LogFactory logFactory;
 71     static {
 72         boolean useOld = java.security.AccessController.doPrivileged(
 73             (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;sun.rmi.log.useOld&quot;));
 74 
 75         /* set factory to select the logging facility to use */
 76         logFactory = (useOld ? (LogFactory) new LogStreamLogFactory() :
 77                       (LogFactory) new LoggerLogFactory());
 78     }
 79 
 80     /** &quot;logger like&quot; API to be used by RMI implementation */
 81     public abstract boolean isLoggable(Level level);
 82     public abstract void log(Level level, String message);
 83     public abstract void log(Level level, String message, Throwable thrown);
 84 
 85     /** get and set the RMI server call output stream */
 86     public abstract void setOutputStream(OutputStream stream);
 87     public abstract PrintStream getPrintStream();
 88 
 89     /** factory interface enables Logger and LogStream implementations */
 90     private static interface LogFactory {
 91         Log createLog(String loggerName, String oldLogName, Level level);
 92     }
 93 
 94     /* access log objects */
 95 
 96     /**
 97      * Access log for a tri-state system property.
 98      *
 99      * Need to first convert override value to a log level, taking
100      * care to interpret a range of values between BRIEF, VERBOSE and
101      * SILENT.
102      *
103      * An override {@literal &lt;} 0 is interpreted to mean that the logging
104      * configuration should not be overridden. The level passed to the
105      * factories createLog method will be null in this case.
106      *
107      * Note that if oldLogName is null and old logging is on, the
108      * returned LogStreamLog will ignore the override parameter - the
109      * log will never log messages.  This permits new logs that only
110      * write to Loggers to do nothing when old logging is active.
111      *
112      * Do not call getLog multiple times on the same logger name.
113      * Since this is an internal API, no checks are made to ensure
114      * that multiple logs do not exist for the same logger.
115      */
116     public static Log getLog(String loggerName, String oldLogName,
117                              int override)
118     {
119         Level level;
120 
121         if (override &lt; 0) {
122             level = null;
123         } else if (override == LogStream.SILENT) {
124             level = Level.OFF;
125         } else if ((override &gt; LogStream.SILENT) &amp;&amp;
126                    (override &lt;= LogStream.BRIEF)) {
127             level = BRIEF;
128         } else if ((override &gt; LogStream.BRIEF) &amp;&amp;
129                    (override &lt;= LogStream.VERBOSE))
130         {
131             level = VERBOSE;
132         } else {
133             level = Level.FINEST;
134         }
135         return logFactory.createLog(loggerName, oldLogName, level);
136     }
137 
138     /**
139      * Access logs associated with boolean properties
140      *
141      * Do not call getLog multiple times on the same logger name.
142      * Since this is an internal API, no checks are made to ensure
143      * that multiple logs do not exist for the same logger.
144      */
145     public static Log getLog(String loggerName, String oldLogName,
146                              boolean override)
147     {
148         Level level = (override ? VERBOSE : null);
149         return logFactory.createLog(loggerName, oldLogName, level);
150     }
151 
152     /**
153      * Factory to create Log objects which deliver log messages to the
154      * java.util.logging API.
155      */
156     private static class LoggerLogFactory implements LogFactory {
157         LoggerLogFactory() {}
158 
159         /*
160          * Accessor to obtain an arbitrary RMI logger with name
161          * loggerName.  If the level of the logger is greater than the
162          * level for the system property with name, the logger level
163          * will be set to the value of system property.
164          */
165         public Log createLog(final String loggerName, String oldLogName,
166                              final Level level)
167         {
168             Logger logger = Logger.getLogger(loggerName);
169             return new LoggerLog(logger, level);
170         }
171     }
172 
173     /**
174      * Class specialized to log messages to the java.util.logging API
175      */
176     private static class LoggerLog extends Log {
177 
178         /* alternate console handler for RMI loggers */
179         private static final Handler alternateConsole =
180                 java.security.AccessController.doPrivileged(
181                 new java.security.PrivilegedAction&lt;Handler&gt;() {
182                     public Handler run() {
183                             InternalStreamHandler alternate =
184                                 new InternalStreamHandler(System.err);
185                             alternate.setLevel(Level.ALL);
186                             return alternate;
187                         }
188                 });
189 
190         /** handler to which messages are copied */
191         private InternalStreamHandler copyHandler = null;
192 
193         /* logger to which log messages are written */
194         private final Logger logger;
195 
196         /* used as return value of RemoteServer.getLog */
197         private LoggerPrintStream loggerSandwich;
198 
199         /** creates a Log which will delegate to the given logger */
200         private LoggerLog(final Logger logger, final Level level) {
201             this.logger = logger;
202 
203             if (level != null){
204                 java.security.AccessController.doPrivileged(
205                     new java.security.PrivilegedAction&lt;Void&gt;() {
206                         public Void run() {
207                             if (!logger.isLoggable(level)) {
208                                 logger.setLevel(level);
209                             }
210                             logger.addHandler(alternateConsole);
211                             return null;
212                         }
213                     }
214                 );
215             }
216         }
217 
218         public boolean isLoggable(Level level) {
219             return logger.isLoggable(level);
220         }
221 
222         public void log(Level level, String message) {
223             if (isLoggable(level)) {
<a name="4" id="anc4"></a><span class="line-modified">224                 StackFrame sourceFrame = getSource();</span>
<span class="line-modified">225                 logger.logp(level, sourceFrame.getClassName(), sourceFrame.getMethodName(),</span>
226                            Thread.currentThread().getName() + &quot;: &quot; + message);
227             }
228         }
229 
230         public void log(Level level, String message, Throwable thrown) {
231             if (isLoggable(level)) {
<a name="5" id="anc5"></a><span class="line-modified">232                 StackFrame sourceFrame = getSource();</span>
<span class="line-modified">233                 logger.logp(level, sourceFrame.getClassName(), sourceFrame.getMethodName(),</span>
234                     Thread.currentThread().getName() + &quot;: &quot; +
235                            message, thrown);
236             }
237         }
238 
239         public String toString() {
240             return logger.toString() + &quot;, level: &quot; + logger.getLevel() +
241                     &quot;, name: &quot; + logger.getName();
242         }
243 
244         /**
245          * Set the output stream associated with the RMI server call
246          * logger.
247          *
248          * Calling code needs LoggingPermission &quot;control&quot;.
249          */
250         public synchronized void setOutputStream(OutputStream out) {
251             if (out != null) {
252                 if (!logger.isLoggable(VERBOSE)) {
253                     logger.setLevel(VERBOSE);
254                 }
255                 copyHandler = new InternalStreamHandler(out);
256                 copyHandler.setLevel(Log.VERBOSE);
257                 logger.addHandler(copyHandler);
258             } else {
259                 /* ensure that messages are not logged */
260                 if (copyHandler != null) {
261                     logger.removeHandler(copyHandler);
262                 }
263                 copyHandler = null;
264             }
265         }
266 
267         public synchronized PrintStream getPrintStream() {
268             if (loggerSandwich == null) {
269                 loggerSandwich = new LoggerPrintStream(logger);
270             }
271             return loggerSandwich;
272         }
273     }
274 
275     /**
276      * Subclass of StreamHandler for redirecting log output.  flush
277      * must be called in the publish and close methods.
278      */
279     private static class InternalStreamHandler extends StreamHandler {
280         InternalStreamHandler(OutputStream out) {
281             super(out, new SimpleFormatter());
282         }
283 
284         public void publish(LogRecord record) {
285             super.publish(record);
286             flush();
287         }
288 
289         public void close() {
290             flush();
291         }
292     }
293 
294     /**
295      * PrintStream which forwards log messages to the logger.  Class
296      * is needed to maintain backwards compatibility with
297      * RemoteServer.{set|get}Log().
298      */
299     private static class LoggerPrintStream extends PrintStream {
300 
301         /** logger where output of this log is sent */
302         private final Logger logger;
303 
304         /** record the last character written to this stream */
305         private int last = -1;
306 
307         /** stream used for buffering lines */
308         private final ByteArrayOutputStream bufOut;
309 
310         private LoggerPrintStream(Logger logger)
311         {
312             super(new ByteArrayOutputStream());
313             bufOut = (ByteArrayOutputStream) super.out;
314             this.logger = logger;
315         }
316 
317         public void write(int b) {
318             if ((last == &#39;\r&#39;) &amp;&amp; (b == &#39;\n&#39;)) {
319                 last = -1;
320                 return;
321             } else if ((b == &#39;\n&#39;) || (b == &#39;\r&#39;)) {
322                 try {
323                     /* write the converted bytes of the log message */
324                     String message =
325                         Thread.currentThread().getName() + &quot;: &quot; +
326                         bufOut.toString();
327                     logger.logp(Level.INFO, &quot;LogStream&quot;, &quot;print&quot;, message);
328                 } finally {
329                     bufOut.reset();
330                 }
331             } else {
332                 super.write(b);
333             }
334             last = b;
335         }
336 
337         public void write(byte b[], int off, int len) {
338             if (len &lt; 0) {
339                 throw new ArrayIndexOutOfBoundsException(len);
340             }
341             for (int i = 0; i &lt; len; i++) {
342                 write(b[off + i]);
343             }
344         }
345 
346         public String toString() {
347             return &quot;RMI&quot;;
348         }
349     }
350 
351     /**
352      * Factory to create Log objects which deliver log messages to the
353      * java.rmi.server.LogStream API
354      */
355     private static class LogStreamLogFactory implements LogFactory {
356         LogStreamLogFactory() {}
357 
358         /* create a new LogStreamLog for the specified log */
359         public Log createLog(String loggerName, String oldLogName,
360                              Level level)
361         {
362             LogStream stream = null;
363             if (oldLogName != null) {
364                 stream = LogStream.log(oldLogName);
365             }
366             return new LogStreamLog(stream, level);
367         }
368     }
369 
370     /**
371      * Class specialized to log messages to the
372      * java.rmi.server.LogStream API
373      */
374     private static class LogStreamLog extends Log {
375         /** Log stream to which log messages are written */
376         private final LogStream stream;
377 
378         /** the level of the log as set by associated property */
379         private int levelValue = Level.OFF.intValue();
380 
381         private LogStreamLog(LogStream stream, Level level) {
382             if ((stream != null) &amp;&amp; (level != null)) {
383                 /* if the stream or level is null, don&#39;t log any
384                  * messages
385                  */
386                 levelValue = level.intValue();
387             }
388             this.stream = stream;
389         }
390 
391         public synchronized boolean isLoggable(Level level) {
392             return (level.intValue() &gt;= levelValue);
393         }
394 
395         public void log(Level messageLevel, String message) {
396             if (isLoggable(messageLevel)) {
<a name="6" id="anc6"></a><span class="line-modified">397                 StackFrame sourceFrame = getSource();</span>
<span class="line-modified">398                 stream.println(unqualifiedName(sourceFrame.getClassName()) +</span>
<span class="line-modified">399                                &quot;.&quot; + sourceFrame.getMethodName() + &quot;: &quot; + message);</span>
400             }
401         }
402 
403         public void log(Level level, String message, Throwable thrown) {
404             if (isLoggable(level)) {
405                 /*
406                  * keep output contiguous and maintain the contract of
407                  * RemoteServer.getLog
408                  */
409                 synchronized (stream) {
<a name="7" id="anc7"></a><span class="line-modified">410                     StackFrame sourceFrame = getSource();</span>
<span class="line-modified">411                     stream.println(unqualifiedName(sourceFrame.getClassName()) + &quot;.&quot; +</span>
<span class="line-modified">412                                     sourceFrame.getMethodName() + &quot;: &quot; + message);</span>
413                     thrown.printStackTrace(stream);
414                 }
415             }
416         }
417 
418         public PrintStream getPrintStream() {
419             return stream;
420         }
421 
422         public synchronized void setOutputStream(OutputStream out) {
423             if (out != null) {
424                 if (VERBOSE.intValue() &lt; levelValue) {
425                     levelValue = VERBOSE.intValue();
426                 }
427                 stream.setOutputStream(out);
428             } else {
429                 /* ensure that messages are not logged */
430                 levelValue = Level.OFF.intValue();
431             }
432         }
433 
434         /*
435          * Mimic old log messages that only contain unqualified names.
436          */
437         private static String unqualifiedName(String name) {
438             int lastDot = name.lastIndexOf(&#39;.&#39;);
439             if (lastDot &gt;= 0) {
440                 name = name.substring(lastDot + 1);
441             }
442             name = name.replace(&#39;$&#39;, &#39;.&#39;);
443             return name;
444         }
445     }
446 
447     /**
<a name="8" id="anc8"></a><span class="line-modified">448      * Obtain stack frame of code calling a log method.</span>
449      */
<a name="9" id="anc9"></a><span class="line-modified">450     private static StackFrame getSource() {</span>
<span class="line-modified">451         return WALKER.walk(s -&gt; s</span>
<span class="line-modified">452                                  .skip(3)</span>
<span class="line-modified">453                                  .findFirst()</span>
<span class="line-modified">454                                  .get());</span>

455     }
456 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
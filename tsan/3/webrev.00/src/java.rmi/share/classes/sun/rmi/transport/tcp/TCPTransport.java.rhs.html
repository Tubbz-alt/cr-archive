<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.rmi/share/classes/sun/rmi/transport/tcp/TCPTransport.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1996, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.rmi.transport.tcp;
 26 
 27 import java.lang.ref.Reference;
 28 import java.lang.ref.SoftReference;
 29 import java.lang.ref.WeakReference;
 30 import java.lang.reflect.InvocationTargetException;
 31 import java.lang.reflect.UndeclaredThrowableException;
 32 import java.io.DataInputStream;
 33 import java.io.DataOutputStream;
 34 import java.io.IOException;
 35 import java.io.InputStream;
 36 import java.io.OutputStream;
 37 import java.io.BufferedInputStream;
 38 import java.io.BufferedOutputStream;
 39 import java.net.InetAddress;
 40 import java.net.ServerSocket;
 41 import java.net.Socket;
 42 import java.rmi.RemoteException;
 43 import java.rmi.server.ExportException;
 44 import java.rmi.server.LogStream;
 45 import java.rmi.server.RMIFailureHandler;
 46 import java.rmi.server.RMISocketFactory;
 47 import java.rmi.server.RemoteCall;
 48 import java.rmi.server.ServerNotActiveException;
 49 import java.rmi.server.UID;
 50 import java.security.AccessControlContext;
 51 import java.security.AccessController;
 52 import java.security.Permissions;
 53 import java.security.PrivilegedAction;
 54 import java.security.ProtectionDomain;
 55 import java.util.ArrayList;
 56 import java.util.LinkedList;
 57 import java.util.List;
 58 import java.util.Map;
 59 import java.util.WeakHashMap;
 60 import java.util.logging.Level;
 61 import java.util.concurrent.ExecutorService;
 62 import java.util.concurrent.RejectedExecutionException;
 63 import java.util.concurrent.SynchronousQueue;
 64 import java.util.concurrent.ThreadFactory;
 65 import java.util.concurrent.ThreadPoolExecutor;
 66 import java.util.concurrent.TimeUnit;
 67 import java.util.concurrent.atomic.AtomicInteger;
 68 import sun.rmi.runtime.Log;
 69 import sun.rmi.runtime.NewThreadAction;
 70 import sun.rmi.transport.Channel;
 71 import sun.rmi.transport.Connection;
 72 import sun.rmi.transport.DGCAckHandler;
 73 import sun.rmi.transport.Endpoint;
 74 import sun.rmi.transport.StreamRemoteCall;
 75 import sun.rmi.transport.Target;
 76 import sun.rmi.transport.Transport;
 77 import sun.rmi.transport.TransportConstants;
 78 
 79 /**
 80  * TCPTransport is the socket-based implementation of the RMI Transport
 81  * abstraction.
 82  *
 83  * @author Ann Wollrath
 84  * @author Peter Jones
 85  */
 86 @SuppressWarnings(&quot;deprecation&quot;)
 87 public class TCPTransport extends Transport {
 88 
 89     /* tcp package log */
 90     static final Log tcpLog = Log.getLog(&quot;sun.rmi.transport.tcp&quot;, &quot;tcp&quot;,
 91         LogStream.parseLevel(AccessController.doPrivileged(
 92             (PrivilegedAction&lt;String&gt;) () -&gt; System.getProperty(&quot;sun.rmi.transport.tcp.logLevel&quot;))));
 93 
 94     /** maximum number of connection handler threads */
 95     private static final int maxConnectionThreads =     // default no limit
 96         AccessController.doPrivileged((PrivilegedAction&lt;Integer&gt;) () -&gt;
 97             Integer.getInteger(&quot;sun.rmi.transport.tcp.maxConnectionThreads&quot;,
 98                                Integer.MAX_VALUE));
 99 
100     /** keep alive time for idle connection handler threads */
101     private static final long threadKeepAliveTime =     // default 1 minute
102         AccessController.doPrivileged((PrivilegedAction&lt;Long&gt;) () -&gt;
103             Long.getLong(&quot;sun.rmi.transport.tcp.threadKeepAliveTime&quot;, 60000));
104 
105     /** thread pool for connection handlers */
106     private static final ExecutorService connectionThreadPool =
107         new ThreadPoolExecutor(0, maxConnectionThreads,
108             threadKeepAliveTime, TimeUnit.MILLISECONDS,
109             new SynchronousQueue&lt;Runnable&gt;(),
110             new ThreadFactory() {
111                 public Thread newThread(Runnable runnable) {
112                     return AccessController.doPrivileged(new NewThreadAction(
113                         runnable, &quot;TCP Connection(idle)&quot;, true, true));
114                 }
115             });
116 
117     /** total connections handled */
118     private static final AtomicInteger connectionCount = new AtomicInteger(0);
119 
120     /** client host for the current thread&#39;s connection */
121     private static final ThreadLocal&lt;ConnectionHandler&gt;
122         threadConnectionHandler = new ThreadLocal&lt;&gt;();
123 
124     /** an AccessControlContext with no permissions */
125     private static final AccessControlContext NOPERMS_ACC;
126     static {
127         Permissions perms = new Permissions();
128         ProtectionDomain[] pd = { new ProtectionDomain(null, perms) };
129         NOPERMS_ACC = new AccessControlContext(pd);
130     }
131 
132     /** endpoints for this transport */
133     private final LinkedList&lt;TCPEndpoint&gt; epList;
134     /** number of objects exported on this transport */
135     private int exportCount = 0;
136     /** server socket for this transport */
137     private ServerSocket server = null;
138     /** table mapping endpoints to channels */
139     private final Map&lt;TCPEndpoint,Reference&lt;TCPChannel&gt;&gt; channelTable =
140         new WeakHashMap&lt;&gt;();
141 
142     static final RMISocketFactory defaultSocketFactory =
143         RMISocketFactory.getDefaultSocketFactory();
144 
145     /** number of milliseconds in accepted-connection timeout.
146      * Warning: this should be greater than 15 seconds (the client-side
147      * timeout), and defaults to 2 hours.
148      * The maximum representable value is slightly more than 24 days
149      * and 20 hours.
150      */
151     private static final int connectionReadTimeout =    // default 2 hours
152         AccessController.doPrivileged((PrivilegedAction&lt;Integer&gt;) () -&gt;
153             Integer.getInteger(&quot;sun.rmi.transport.tcp.readTimeout&quot;, 2 * 3600 * 1000));
154 
155     /**
156      * Constructs a TCPTransport.
157      */
158     TCPTransport(LinkedList&lt;TCPEndpoint&gt; epList)  {
159         // assert ((epList.size() != null) &amp;&amp; (epList.size() &gt;= 1))
160         this.epList = epList;
161         if (tcpLog.isLoggable(Log.BRIEF)) {
162             tcpLog.log(Log.BRIEF, &quot;Version = &quot; +
163                 TransportConstants.Version + &quot;, ep = &quot; + getEndpoint());
164         }
165     }
166 
167     /**
168      * Closes all cached connections in every channel subordinated to this
169      * transport.  Currently, this only closes outgoing connections.
170      */
171     public void shedConnectionCaches() {
172         List&lt;TCPChannel&gt; channels;
173         synchronized (channelTable) {
174             channels = new ArrayList&lt;TCPChannel&gt;(channelTable.values().size());
175             for (Reference&lt;TCPChannel&gt; ref : channelTable.values()) {
176                 TCPChannel ch = ref.get();
177                 if (ch != null) {
178                     channels.add(ch);
179                 }
180             }
181         }
182         for (TCPChannel channel : channels) {
183             channel.shedCache();
184         }
185     }
186 
187     /**
188      * Returns a &lt;I&gt;Channel&lt;/I&gt; that generates connections to the
189      * endpoint &lt;I&gt;ep&lt;/I&gt;. A Channel is an object that creates and
190      * manages connections of a particular type to some particular
191      * address space.
192      * @param ep the endpoint to which connections will be generated.
193      * @return the channel or null if the transport cannot
194      * generate connections to this endpoint
195      */
196     public TCPChannel getChannel(Endpoint ep) {
197         TCPChannel ch = null;
198         if (ep instanceof TCPEndpoint) {
199             synchronized (channelTable) {
200                 Reference&lt;TCPChannel&gt; ref = channelTable.get(ep);
201                 if (ref != null) {
202                     ch = ref.get();
203                 }
204                 if (ch == null) {
205                     TCPEndpoint tcpEndpoint = (TCPEndpoint) ep;
206                     ch = new TCPChannel(this, tcpEndpoint);
207                     channelTable.put(tcpEndpoint,
208                                      new WeakReference&lt;TCPChannel&gt;(ch));
209                 }
210             }
211         }
212         return ch;
213     }
214 
215     /**
216      * Removes the &lt;I&gt;Channel&lt;/I&gt; that generates connections to the
217      * endpoint &lt;I&gt;ep&lt;/I&gt;.
218      */
219     public void free(Endpoint ep) {
220         if (ep instanceof TCPEndpoint) {
221             synchronized (channelTable) {
222                 Reference&lt;TCPChannel&gt; ref = channelTable.remove(ep);
223                 if (ref != null) {
224                     TCPChannel channel = ref.get();
225                     if (channel != null) {
226                         channel.shedCache();
227                     }
228                 }
229             }
230         }
231     }
232 
233     /**
234      * Export the object so that it can accept incoming calls.
235      */
236     public void exportObject(Target target) throws RemoteException {
237         /*
238          * Ensure that a server socket is listening, and count this
239          * export while synchronized to prevent the server socket from
240          * being closed due to concurrent unexports.
241          */
242         synchronized (this) {
243             listen();
244             exportCount++;
245         }
246 
247         /*
248          * Try to add the Target to the exported object table; keep
249          * counting this export (to keep server socket open) only if
250          * that succeeds.
251          */
252         boolean ok = false;
253         try {
254             super.exportObject(target);
255             ok = true;
256         } finally {
257             if (!ok) {
258                 synchronized (this) {
259                     decrementExportCount();
260                 }
261             }
262         }
263     }
264 
265     protected synchronized void targetUnexported() {
266         decrementExportCount();
267     }
268 
269     /**
270      * Decrements the count of exported objects, closing the current
271      * server socket if the count reaches zero.
272      **/
273     private void decrementExportCount() {
274         assert Thread.holdsLock(this);
275         exportCount--;
<a name="1" id="anc1"></a><span class="line-added">276         if (tcpLog.isLoggable(Log.VERBOSE)) {</span>
<span class="line-added">277             tcpLog.log(Log.VERBOSE,</span>
<span class="line-added">278                     &quot;server socket: &quot; + server + &quot;, exportCount: &quot; + exportCount);</span>
<span class="line-added">279         }</span>
280         if (exportCount == 0 &amp;&amp; getEndpoint().getListenPort() != 0) {
281             ServerSocket ss = server;
282             server = null;
283             try {
<a name="2" id="anc2"></a><span class="line-added">284                 if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">285                     tcpLog.log(Log.BRIEF, &quot;server socket close: &quot; + ss);</span>
<span class="line-added">286                 }</span>
287                 ss.close();
288             } catch (IOException e) {
<a name="3" id="anc3"></a><span class="line-added">289                 if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">290                     tcpLog.log(Log.BRIEF,</span>
<span class="line-added">291                             &quot;server socket close throws: &quot; + e);</span>
<span class="line-added">292                 }</span>
293             }
294         }
295     }
296 
297     /**
298      * Verify that the current access control context has permission to
299      * accept the connection being dispatched by the current thread.
300      */
301     protected void checkAcceptPermission(AccessControlContext acc) {
302         SecurityManager sm = System.getSecurityManager();
303         if (sm == null) {
304             return;
305         }
306         ConnectionHandler h = threadConnectionHandler.get();
307         if (h == null) {
308             throw new Error(
309                 &quot;checkAcceptPermission not in ConnectionHandler thread&quot;);
310         }
311         h.checkAcceptPermission(sm, acc);
312     }
313 
314     private TCPEndpoint getEndpoint() {
315         synchronized (epList) {
316             return epList.getLast();
317         }
318     }
319 
320     /**
321      * Listen on transport&#39;s endpoint.
322      */
323     private void listen() throws RemoteException {
324         assert Thread.holdsLock(this);
325         TCPEndpoint ep = getEndpoint();
326         int port = ep.getPort();
327 
328         if (server == null) {
329             if (tcpLog.isLoggable(Log.BRIEF)) {
330                 tcpLog.log(Log.BRIEF,
331                     &quot;(port &quot; + port + &quot;) create server socket&quot;);
332             }
333 
334             try {
335                 server = ep.newServerSocket();
336                 /*
337                  * Don&#39;t retry ServerSocket if creation fails since
338                  * &quot;port in use&quot; will cause export to hang if an
339                  * RMIFailureHandler is not installed.
340                  */
341                 Thread t = AccessController.doPrivileged(
342                     new NewThreadAction(new AcceptLoop(server),
343                                         &quot;TCP Accept-&quot; + port, true));
344                 t.start();
345             } catch (java.net.BindException e) {
346                 throw new ExportException(&quot;Port already in use: &quot; + port, e);
347             } catch (IOException e) {
348                 throw new ExportException(&quot;Listen failed on port: &quot; + port, e);
349             }
350 
351         } else {
352             // otherwise verify security access to existing server socket
353             SecurityManager sm = System.getSecurityManager();
354             if (sm != null) {
355                 sm.checkListen(port);
356             }
357         }
358     }
359 
360     /**
361      * Worker for accepting connections from a server socket.
362      **/
363     private class AcceptLoop implements Runnable {
364 
365         private final ServerSocket serverSocket;
366 
367         // state for throttling loop on exceptions (local to accept thread)
368         private long lastExceptionTime = 0L;
369         private int recentExceptionCount;
370 
371         AcceptLoop(ServerSocket serverSocket) {
372             this.serverSocket = serverSocket;
373         }
374 
375         public void run() {
376             try {
377                 executeAcceptLoop();
378             } finally {
379                 try {
<a name="4" id="anc4"></a><span class="line-added">380                     if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">381                         tcpLog.log(Log.BRIEF,</span>
<span class="line-added">382                                 &quot;server socket close: &quot; + serverSocket);</span>
<span class="line-added">383                     }</span>
384                     /*
385                      * Only one accept loop is started per server
386                      * socket, so after no more connections will be
387                      * accepted, ensure that the server socket is no
388                      * longer listening.
389                      */
390                     serverSocket.close();
391                 } catch (IOException e) {
<a name="5" id="anc5"></a><span class="line-added">392                     if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">393                         tcpLog.log(Log.BRIEF,</span>
<span class="line-added">394                                 &quot;server socket close throws: &quot; + e);</span>
<span class="line-added">395                     }</span>
396                 }
397             }
398         }
399 
400         /**
401          * Accepts connections from the server socket and executes
402          * handlers for them in the thread pool.
403          **/
404         private void executeAcceptLoop() {
405             if (tcpLog.isLoggable(Log.BRIEF)) {
406                 tcpLog.log(Log.BRIEF, &quot;listening on port &quot; +
407                            getEndpoint().getPort());
408             }
409 
410             while (true) {
411                 Socket socket = null;
412                 try {
413                     socket = serverSocket.accept();
414 
415                     /*
416                      * Find client host name (or &quot;0.0.0.0&quot; if unknown)
417                      */
418                     InetAddress clientAddr = socket.getInetAddress();
419                     String clientHost = (clientAddr != null
420                                          ? clientAddr.getHostAddress()
421                                          : &quot;0.0.0.0&quot;);
422 
423                     /*
424                      * Execute connection handler in the thread pool,
425                      * which uses non-system threads.
426                      */
427                     try {
428                         connectionThreadPool.execute(
429                             new ConnectionHandler(socket, clientHost));
430                     } catch (RejectedExecutionException e) {
431                         closeSocket(socket);
432                         tcpLog.log(Log.BRIEF,
433                                    &quot;rejected connection from &quot; + clientHost);
434                     }
435 
436                 } catch (Throwable t) {
437                     try {
438                         /*
439                          * If the server socket has been closed, such
440                          * as because there are no more exported
441                          * objects, then we expect accept to throw an
442                          * exception, so just terminate normally.
443                          */
444                         if (serverSocket.isClosed()) {
445                             break;
446                         }
447 
448                         try {
449                             if (tcpLog.isLoggable(Level.WARNING)) {
450                                 tcpLog.log(Level.WARNING,
451                                            &quot;accept loop for &quot; + serverSocket +
452                                            &quot; throws&quot;, t);
453                             }
454                         } catch (Throwable tt) {
455                         }
456                     } finally {
457                         /*
458                          * Always close the accepted socket (if any)
459                          * if an exception occurs, but only after
460                          * logging an unexpected exception.
461                          */
462                         if (socket != null) {
463                             closeSocket(socket);
464                         }
465                     }
466 
467                     /*
468                      * In case we&#39;re running out of file descriptors,
469                      * release resources held in caches.
470                      */
471                     if (!(t instanceof SecurityException)) {
472                         try {
473                             TCPEndpoint.shedConnectionCaches();
474                         } catch (Throwable tt) {
475                         }
476                     }
477 
478                     /*
479                      * A NoClassDefFoundError can occur if no file
480                      * descriptors are available, in which case this
481                      * loop should not terminate.
482                      */
483                     if (t instanceof Exception ||
484                         t instanceof OutOfMemoryError ||
485                         t instanceof NoClassDefFoundError)
486                     {
487                         if (!continueAfterAcceptFailure(t)) {
488                             return;
489                         }
490                         // continue loop
491                     } else if (t instanceof Error) {
492                         throw (Error) t;
493                     } else {
494                         throw new UndeclaredThrowableException(t);
495                     }
496                 }
497             }
498         }
499 
500         /**
501          * Returns true if the accept loop should continue after the
502          * specified exception has been caught, or false if the accept
503          * loop should terminate (closing the server socket).  If
504          * there is an RMIFailureHandler, this method returns the
505          * result of passing the specified exception to it; otherwise,
506          * this method always returns true, after sleeping to throttle
507          * the accept loop if necessary.
508          **/
509         private boolean continueAfterAcceptFailure(Throwable t) {
510             RMIFailureHandler fh = RMISocketFactory.getFailureHandler();
511             if (fh != null) {
512                 return fh.failure(t instanceof Exception ? (Exception) t :
513                                   new InvocationTargetException(t));
514             } else {
515                 throttleLoopOnException();
516                 return true;
517             }
518         }
519 
520         /**
521          * Throttles the accept loop after an exception has been
522          * caught: if a burst of 10 exceptions in 5 seconds occurs,
523          * then wait for 10 seconds to curb busy CPU usage.
524          **/
525         private void throttleLoopOnException() {
526             long now = System.currentTimeMillis();
527             if (lastExceptionTime == 0L || (now - lastExceptionTime) &gt; 5000) {
528                 // last exception was long ago (or this is the first)
529                 lastExceptionTime = now;
530                 recentExceptionCount = 0;
531             } else {
532                 // exception burst window was started recently
533                 if (++recentExceptionCount &gt;= 10) {
534                     try {
535                         Thread.sleep(10000);
536                     } catch (InterruptedException ignore) {
537                     }
538                 }
539             }
540         }
541     }
542 
543     /** close socket and eat exception */
544     private static void closeSocket(Socket sock) {
545         try {
<a name="6" id="anc6"></a><span class="line-added">546             if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">547                 tcpLog.log(Log.BRIEF, &quot;socket close: &quot; + sock);</span>
<span class="line-added">548             }</span>
549             sock.close();
550         } catch (IOException ex) {
551             // eat exception
<a name="7" id="anc7"></a><span class="line-added">552             if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">553                 tcpLog.log(Log.BRIEF, &quot;socket close throws: &quot; + ex);</span>
<span class="line-added">554             }</span>
555         }
556     }
557 
558     /**
559      * handleMessages decodes transport operations and handles messages
560      * appropriately.  If an exception occurs during message handling,
561      * the socket is closed.
562      */
563     void handleMessages(Connection conn, boolean persistent) {
564         int port = getEndpoint().getPort();
565 
566         try {
567             DataInputStream in = new DataInputStream(conn.getInputStream());
568             do {
569                 int op = in.read();     // transport op
570                 if (op == -1) {
571                     if (tcpLog.isLoggable(Log.BRIEF)) {
572                         tcpLog.log(Log.BRIEF, &quot;(port &quot; +
573                             port + &quot;) connection closed&quot;);
574                     }
575                     break;
576                 }
577 
578                 if (tcpLog.isLoggable(Log.BRIEF)) {
579                     tcpLog.log(Log.BRIEF, &quot;(port &quot; + port +
580                         &quot;) op = &quot; + op);
581                 }
582 
583                 switch (op) {
584                 case TransportConstants.Call:
585                     // service incoming RMI call
586                     RemoteCall call = new StreamRemoteCall(conn);
587                     if (serviceCall(call) == false)
588                         return;
589                     break;
590 
591                 case TransportConstants.Ping:
592                     // send ack for ping
593                     DataOutputStream out =
594                         new DataOutputStream(conn.getOutputStream());
595                     out.writeByte(TransportConstants.PingAck);
596                     conn.releaseOutputStream();
597                     break;
598 
599                 case TransportConstants.DGCAck:
600                     DGCAckHandler.received(UID.read(in));
601                     break;
602 
603                 default:
604                     throw new IOException(&quot;unknown transport op &quot; + op);
605                 }
606             } while (persistent);
607 
608         } catch (IOException e) {
609             // exception during processing causes connection to close (below)
610             if (tcpLog.isLoggable(Log.BRIEF)) {
611                 tcpLog.log(Log.BRIEF, &quot;(port &quot; + port +
612                     &quot;) exception: &quot;, e);
613             }
614         } finally {
615             try {
616                 conn.close();
617             } catch (IOException ex) {
618                 // eat exception
<a name="8" id="anc8"></a><span class="line-added">619                 if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">620                     tcpLog.log(Log.BRIEF, &quot;Connection close throws &quot; + ex);</span>
<span class="line-added">621                 }</span>
622             }
623         }
624     }
625 
626     /**
627      * Returns the client host for the current thread&#39;s connection.  Throws
628      * ServerNotActiveException if no connection is active for this thread.
629      */
630     public static String getClientHost() throws ServerNotActiveException {
631         ConnectionHandler h = threadConnectionHandler.get();
632         if (h != null) {
633             return h.getClientHost();
634         } else {
635             throw new ServerNotActiveException(&quot;not in a remote call&quot;);
636         }
637     }
638 
639     /**
640      * Services messages on accepted connection
641      */
642     private class ConnectionHandler implements Runnable {
643 
644         /** int value of &quot;POST&quot; in ASCII (Java&#39;s specified data formats
645          *  make this once-reviled tactic again socially acceptable) */
646         private static final int POST = 0x504f5354;
647 
648         /** most recently accept-authorized AccessControlContext */
649         private AccessControlContext okContext;
650         /** cache of accept-authorized AccessControlContexts */
651         private Map&lt;AccessControlContext,
652                     Reference&lt;AccessControlContext&gt;&gt; authCache;
653         /** security manager which authorized contexts in authCache */
654         private SecurityManager cacheSecurityManager = null;
655 
656         private Socket socket;
657         private String remoteHost;
658 
659         ConnectionHandler(Socket socket, String remoteHost) {
660             this.socket = socket;
661             this.remoteHost = remoteHost;
662         }
663 
664         String getClientHost() {
665             return remoteHost;
666         }
667 
668         /**
669          * Verify that the given AccessControlContext has permission to
670          * accept this connection.
671          */
672         void checkAcceptPermission(SecurityManager sm,
673                                    AccessControlContext acc)
674         {
675             /*
676              * Note: no need to synchronize on cache-related fields, since this
677              * method only gets called from the ConnectionHandler&#39;s thread.
678              */
679             if (sm != cacheSecurityManager) {
680                 okContext = null;
681                 authCache = new WeakHashMap&lt;AccessControlContext,
682                                             Reference&lt;AccessControlContext&gt;&gt;();
683                 cacheSecurityManager = sm;
684             }
685             if (acc.equals(okContext) || authCache.containsKey(acc)) {
686                 return;
687             }
688             InetAddress addr = socket.getInetAddress();
689             String host = (addr != null) ? addr.getHostAddress() : &quot;*&quot;;
690 
691             sm.checkAccept(host, socket.getPort());
692 
693             authCache.put(acc, new SoftReference&lt;AccessControlContext&gt;(acc));
694             okContext = acc;
695         }
696 
697         public void run() {
698             Thread t = Thread.currentThread();
699             String name = t.getName();
700             try {
701                 t.setName(&quot;RMI TCP Connection(&quot; +
702                           connectionCount.incrementAndGet() +
703                           &quot;)-&quot; + remoteHost);
704                 AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;)() -&gt; {
705                     run0();
706                     return null;
707                 }, NOPERMS_ACC);
708             } finally {
709                 t.setName(name);
710             }
711         }
712 
713         @SuppressWarnings(&quot;fallthrough&quot;)
714         private void run0() {
715             TCPEndpoint endpoint = getEndpoint();
716             int port = endpoint.getPort();
717 
718             threadConnectionHandler.set(this);
719 
720             // set socket to disable Nagle&#39;s algorithm (always send
721             // immediately)
722             // TBD: should this be left up to socket factory instead?
723             try {
724                 socket.setTcpNoDelay(true);
725             } catch (Exception e) {
726                 // if we fail to set this, ignore and proceed anyway
727             }
728             // set socket to timeout after excessive idle time
729             try {
730                 if (connectionReadTimeout &gt; 0)
731                     socket.setSoTimeout(connectionReadTimeout);
732             } catch (Exception e) {
733                 // too bad, continue anyway
734             }
735 
736             try {
737                 InputStream sockIn = socket.getInputStream();
738                 InputStream bufIn = sockIn.markSupported()
739                         ? sockIn
740                         : new BufferedInputStream(sockIn);
741 
742                 // Read magic
743                 DataInputStream in = new DataInputStream(bufIn);
744                 int magic = in.readInt();
745 
746                 // read and verify transport header
747                 short version = in.readShort();
748                 if (magic != TransportConstants.Magic ||
749                     version != TransportConstants.Version) {
750                     // protocol mismatch detected...
751                     // just close socket: this would recurse if we marshal an
752                     // exception to the client and the protocol at other end
753                     // doesn&#39;t match.
<a name="9" id="anc9"></a><span class="line-added">754                     if (tcpLog.isLoggable(Log.BRIEF)) {</span>
<span class="line-added">755                         tcpLog.log(Log.BRIEF, &quot;magic or version not match: &quot;</span>
<span class="line-added">756                                                   + magic + &quot;, &quot; + version);</span>
<span class="line-added">757                     }</span>
758                     closeSocket(socket);
759                     return;
760                 }
761 
762                 OutputStream sockOut = socket.getOutputStream();
763                 BufferedOutputStream bufOut =
764                     new BufferedOutputStream(sockOut);
765                 DataOutputStream out = new DataOutputStream(bufOut);
766 
767                 int remotePort = socket.getPort();
768 
769                 if (tcpLog.isLoggable(Log.BRIEF)) {
770                     tcpLog.log(Log.BRIEF, &quot;accepted socket from [&quot; +
771                                      remoteHost + &quot;:&quot; + remotePort + &quot;]&quot;);
772                 }
773 
774                 TCPEndpoint ep;
775                 TCPChannel ch;
776                 TCPConnection conn;
777 
778                 // send ack (or nack) for protocol
779                 byte protocol = in.readByte();
780                 switch (protocol) {
781                 case TransportConstants.SingleOpProtocol:
782                     // no ack for protocol
783 
784                     // create dummy channel for receiving messages
785                     ep = new TCPEndpoint(remoteHost, socket.getLocalPort(),
786                                          endpoint.getClientSocketFactory(),
787                                          endpoint.getServerSocketFactory());
788                     ch = new TCPChannel(TCPTransport.this, ep);
789                     conn = new TCPConnection(ch, socket, bufIn, bufOut);
790 
791                     // read input messages
792                     handleMessages(conn, false);
793                     break;
794 
795                 case TransportConstants.StreamProtocol:
796                     // send ack
797                     out.writeByte(TransportConstants.ProtocolAck);
798 
799                     // suggest endpoint (in case client doesn&#39;t know host name)
800                     if (tcpLog.isLoggable(Log.VERBOSE)) {
801                         tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +
802                             &quot;) &quot; + &quot;suggesting &quot; + remoteHost + &quot;:&quot; +
803                             remotePort);
804                     }
805 
806                     out.writeUTF(remoteHost);
807                     out.writeInt(remotePort);
808                     out.flush();
809 
810                     // read and discard (possibly bogus) endpoint
811                     // REMIND: would be faster to read 2 bytes then skip N+4
812                     String clientHost = in.readUTF();
813                     int    clientPort = in.readInt();
814                     if (tcpLog.isLoggable(Log.VERBOSE)) {
815                         tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +
816                             &quot;) client using &quot; + clientHost + &quot;:&quot; + clientPort);
817                     }
818 
819                     // create dummy channel for receiving messages
820                     // (why not use clientHost and clientPort?)
821                     ep = new TCPEndpoint(remoteHost, socket.getLocalPort(),
822                                          endpoint.getClientSocketFactory(),
823                                          endpoint.getServerSocketFactory());
824                     ch = new TCPChannel(TCPTransport.this, ep);
825                     conn = new TCPConnection(ch, socket, bufIn, bufOut);
826 
827                     // read input messages
828                     handleMessages(conn, true);
829                     break;
830 
831                 case TransportConstants.MultiplexProtocol:
832                     if (tcpLog.isLoggable(Log.VERBOSE)) {
833                         tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +
834                                 &quot;) rejecting multiplex protocol&quot;);
835                     }
836                     // Fall-through to reject use of MultiplexProtocol
837                 default:
838                     // protocol not understood, send nack and close socket
839                     out.writeByte(TransportConstants.ProtocolNack);
840                     out.flush();
841                     break;
842                 }
843 
844             } catch (IOException e) {
845                 // socket in unknown state: destroy socket
846                 tcpLog.log(Log.BRIEF, &quot;terminated with exception:&quot;, e);
847             } finally {
848                 closeSocket(socket);
849             }
850         }
851     }
852 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
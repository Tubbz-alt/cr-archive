<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.security.jgss/share/classes/com/sun/security/sasl/gsskerb/GssKrb5Client.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GssKrb5Base.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GssKrb5Server.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.security.jgss/share/classes/com/sun/security/sasl/gsskerb/GssKrb5Client.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.security.sasl.gsskerb;
 27 
<span class="line-removed"> 28 import java.io.IOException;</span>
 29 import java.util.Map;
 30 import java.util.logging.Level;
 31 import javax.security.sasl.*;
 32 


 33 // JAAS
 34 import javax.security.auth.callback.CallbackHandler;
 35 
 36 // JGSS
 37 import org.ietf.jgss.*;
 38 
 39 /**
 40   * Implements the GSSAPI SASL client mechanism for Kerberos V5.
 41   * (&lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2222.txt&quot;&gt;RFC 2222&lt;/A&gt;,
 42   * &lt;a HREF=&quot;http://www.ietf.org/internet-drafts/draft-ietf-cat-sasl-gssapi-04.txt&quot;&gt;draft-ietf-cat-sasl-gssapi-04.txt&lt;/a&gt;).
 43   * It uses the Java Bindings for GSSAPI
 44   * (&lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2853.txt&quot;&gt;RFC 2853&lt;/A&gt;)
 45   * for getting GSSAPI/Kerberos V5 support.
 46   *
 47   * The client/server interactions are:
 48   * C0: bind (GSSAPI, initial response)
 49   * S0: sasl-bind-in-progress, challenge 1 (output of accept_sec_context or [])
 50   * C1: bind (GSSAPI, response 1 (output of init_sec_context or []))
 51   * S1: sasl-bind-in-progress challenge 2 (security layer, server max recv size)
 52   * C2: bind (GSSAPI, response 2 (security layer, client max recv size, authzid))
</pre>
<hr />
<pre>
 66   * - quality of protection; list of auth, auth-int, auth-conf; default is &quot;auth&quot;
 67   * javax.security.sasl.maxbuf
 68   * - max receive buffer size; default is 65536
 69   * javax.security.sasl.sendmaxbuffer
 70   * - max send buffer size; default is 65536; (min with server max recv size)
 71   *
 72   * javax.security.sasl.server.authentication
 73   * - &quot;true&quot; means require mutual authentication; default is &quot;false&quot;
 74   *
 75   * javax.security.sasl.credentials
 76   * - an {@link org.ietf.jgss.GSSCredential} used for delegated authentication.
 77   *
 78   * @author Rosanna Lee
 79   */
 80 
 81 final class GssKrb5Client extends GssKrb5Base implements SaslClient {
 82     // ---------------- Constants -----------------
 83     private static final String MY_CLASS_NAME = GssKrb5Client.class.getName();
 84 
 85     private boolean finalHandshake = false;
<span class="line-removed"> 86     private boolean mutual = false;       // default false</span>
 87     private byte[] authzID;
 88 
 89     /**
 90      * Creates a SASL mechanism with client credentials that it needs
 91      * to participate in GSS-API/Kerberos v5 authentication exchange
 92      * with the server.
 93      */
 94     GssKrb5Client(String authzID, String protocol, String serverName,
 95         Map&lt;String, ?&gt; props, CallbackHandler cbh) throws SaslException {
 96 
 97         super(props, MY_CLASS_NAME);
 98 
 99         String service = protocol + &quot;@&quot; + serverName;
100         logger.log(Level.FINE, &quot;KRB5CLNT01:Requesting service name: {0}&quot;,
101             service);
102 
103         try {
104             GSSManager mgr = GSSManager.getInstance();
105 
106             // Create the name for the requested service entity for Krb5 mech
</pre>
<hr />
<pre>
113                 Object prop = props.get(Sasl.CREDENTIALS);
114                 if (prop != null &amp;&amp; prop instanceof GSSCredential) {
115                     credentials = (GSSCredential) prop;
116                     logger.log(Level.FINE,
117                         &quot;KRB5CLNT01:Using the credentials supplied in &quot; +
118                         &quot;javax.security.sasl.credentials&quot;);
119                 }
120             }
121 
122             // Create a context using credentials for Krb5 mech
123             secCtx = mgr.createContext(acceptorName,
124                 KRB5_OID,   /* mechanism */
125                 credentials, /* credentials */
126                 GSSContext.INDEFINITE_LIFETIME);
127 
128             // Request credential delegation when credentials have been supplied
129             if (credentials != null) {
130                 secCtx.requestCredDeleg(true);
131             }
132 
<span class="line-modified">133             // Parse properties  to set desired context options</span>










134             if (props != null) {
135                 // Mutual authentication
136                 String prop = (String)props.get(Sasl.SERVER_AUTH);
137                 if (prop != null) {
138                     mutual = &quot;true&quot;.equalsIgnoreCase(prop);
139                 }
140             }
141             secCtx.requestMutualAuth(mutual);
142 
143             // Always specify potential need for integrity and confidentiality
144             // Decision will be made during final handshake
145             secCtx.requestConf(true);
146             secCtx.requestInteg(true);
147 
148         } catch (GSSException e) {
149             throw new SaslException(&quot;Failure to initialize security context&quot;, e);
150         }
151 
152         if (authzID != null &amp;&amp; authzID.length() &gt; 0) {
<span class="line-modified">153             try {</span>
<span class="line-removed">154                 this.authzID = authzID.getBytes(&quot;UTF8&quot;);</span>
<span class="line-removed">155             } catch (IOException e) {</span>
<span class="line-removed">156                 throw new SaslException(&quot;Cannot encode authorization ID&quot;, e);</span>
<span class="line-removed">157             }</span>
158         }
159     }
160 
161     public boolean hasInitialResponse() {
162         return true;
163     }
164 
165     /**
166      * Processes the challenge data.
167      *
168      * The server sends a challenge data using which the client must
169      * process using GSS_Init_sec_context.
170      * As per RFC 2222, when GSS_S_COMPLETE is returned, we do
171      * an extra handshake to determine the negotiated security protection
172      * and buffer sizes.
173      *
174      * @param challengeData A non-null byte array containing the
175      * challenge data from the server.
176      * @return A non-null byte array containing the response to be
177      * sent to the server.
</pre>
<hr />
<pre>
213         }
214     }
215 
216     private byte[] doFinalHandshake(byte[] challengeData) throws SaslException {
217         try {
218             // Security context already established. challengeData
219             // should contain security layers and server&#39;s maximum buffer size
220 
221             if (logger.isLoggable(Level.FINER)) {
222                 traceOutput(MY_CLASS_NAME, &quot;doFinalHandshake&quot;,
223                     &quot;KRB5CLNT04:Challenge [raw]:&quot;, challengeData);
224             }
225 
226             if (challengeData.length == 0) {
227                 // Received S0, should return []
228                 return EMPTY;
229             }
230 
231             // Received S1 (security layer, server max recv size)
232 

233             byte[] gssOutToken = secCtx.unwrap(challengeData, 0,
<span class="line-modified">234                 challengeData.length, new MessageProp(0, false));</span>

235 
236             // First octet is a bit-mask specifying the protections
237             // supported by the server
238             if (logger.isLoggable(Level.FINE)) {
239                 if (logger.isLoggable(Level.FINER)) {
240                     traceOutput(MY_CLASS_NAME, &quot;doFinalHandshake&quot;,
241                         &quot;KRB5CLNT05:Challenge [unwrapped]:&quot;, gssOutToken);
242                 }
243                 logger.log(Level.FINE, &quot;KRB5CLNT06:Server protections: {0}&quot;,
244                     gssOutToken[0]);
245             }
246 
247             // Client selects preferred protection
248             // qop is ordered list of qop values
249             byte selectedQop = findPreferredMask(gssOutToken[0], qop);
250             if (selectedQop == 0) {
251                 throw new SaslException(
252                     &quot;No common protection layer between client and server&quot;);
253             }
254 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.security.sasl.gsskerb;
 27 

 28 import java.util.Map;
 29 import java.util.logging.Level;
 30 import javax.security.sasl.*;
 31 
<span class="line-added"> 32 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added"> 33 </span>
 34 // JAAS
 35 import javax.security.auth.callback.CallbackHandler;
 36 
 37 // JGSS
 38 import org.ietf.jgss.*;
 39 
 40 /**
 41   * Implements the GSSAPI SASL client mechanism for Kerberos V5.
 42   * (&lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2222.txt&quot;&gt;RFC 2222&lt;/A&gt;,
 43   * &lt;a HREF=&quot;http://www.ietf.org/internet-drafts/draft-ietf-cat-sasl-gssapi-04.txt&quot;&gt;draft-ietf-cat-sasl-gssapi-04.txt&lt;/a&gt;).
 44   * It uses the Java Bindings for GSSAPI
 45   * (&lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2853.txt&quot;&gt;RFC 2853&lt;/A&gt;)
 46   * for getting GSSAPI/Kerberos V5 support.
 47   *
 48   * The client/server interactions are:
 49   * C0: bind (GSSAPI, initial response)
 50   * S0: sasl-bind-in-progress, challenge 1 (output of accept_sec_context or [])
 51   * C1: bind (GSSAPI, response 1 (output of init_sec_context or []))
 52   * S1: sasl-bind-in-progress challenge 2 (security layer, server max recv size)
 53   * C2: bind (GSSAPI, response 2 (security layer, client max recv size, authzid))
</pre>
<hr />
<pre>
 67   * - quality of protection; list of auth, auth-int, auth-conf; default is &quot;auth&quot;
 68   * javax.security.sasl.maxbuf
 69   * - max receive buffer size; default is 65536
 70   * javax.security.sasl.sendmaxbuffer
 71   * - max send buffer size; default is 65536; (min with server max recv size)
 72   *
 73   * javax.security.sasl.server.authentication
 74   * - &quot;true&quot; means require mutual authentication; default is &quot;false&quot;
 75   *
 76   * javax.security.sasl.credentials
 77   * - an {@link org.ietf.jgss.GSSCredential} used for delegated authentication.
 78   *
 79   * @author Rosanna Lee
 80   */
 81 
 82 final class GssKrb5Client extends GssKrb5Base implements SaslClient {
 83     // ---------------- Constants -----------------
 84     private static final String MY_CLASS_NAME = GssKrb5Client.class.getName();
 85 
 86     private boolean finalHandshake = false;

 87     private byte[] authzID;
 88 
 89     /**
 90      * Creates a SASL mechanism with client credentials that it needs
 91      * to participate in GSS-API/Kerberos v5 authentication exchange
 92      * with the server.
 93      */
 94     GssKrb5Client(String authzID, String protocol, String serverName,
 95         Map&lt;String, ?&gt; props, CallbackHandler cbh) throws SaslException {
 96 
 97         super(props, MY_CLASS_NAME);
 98 
 99         String service = protocol + &quot;@&quot; + serverName;
100         logger.log(Level.FINE, &quot;KRB5CLNT01:Requesting service name: {0}&quot;,
101             service);
102 
103         try {
104             GSSManager mgr = GSSManager.getInstance();
105 
106             // Create the name for the requested service entity for Krb5 mech
</pre>
<hr />
<pre>
113                 Object prop = props.get(Sasl.CREDENTIALS);
114                 if (prop != null &amp;&amp; prop instanceof GSSCredential) {
115                     credentials = (GSSCredential) prop;
116                     logger.log(Level.FINE,
117                         &quot;KRB5CLNT01:Using the credentials supplied in &quot; +
118                         &quot;javax.security.sasl.credentials&quot;);
119                 }
120             }
121 
122             // Create a context using credentials for Krb5 mech
123             secCtx = mgr.createContext(acceptorName,
124                 KRB5_OID,   /* mechanism */
125                 credentials, /* credentials */
126                 GSSContext.INDEFINITE_LIFETIME);
127 
128             // Request credential delegation when credentials have been supplied
129             if (credentials != null) {
130                 secCtx.requestCredDeleg(true);
131             }
132 
<span class="line-modified">133             // mutual is by default true if there is a security layer</span>
<span class="line-added">134             boolean mutual;</span>
<span class="line-added">135             if ((allQop &amp; INTEGRITY_ONLY_PROTECTION) != 0</span>
<span class="line-added">136                     || (allQop &amp; PRIVACY_PROTECTION) != 0) {</span>
<span class="line-added">137                 mutual = true;</span>
<span class="line-added">138                 secCtx.requestSequenceDet(true);</span>
<span class="line-added">139             } else {</span>
<span class="line-added">140                 mutual = false;</span>
<span class="line-added">141             }</span>
<span class="line-added">142 </span>
<span class="line-added">143             // User can override default mutual flag</span>
144             if (props != null) {
145                 // Mutual authentication
146                 String prop = (String)props.get(Sasl.SERVER_AUTH);
147                 if (prop != null) {
148                     mutual = &quot;true&quot;.equalsIgnoreCase(prop);
149                 }
150             }
151             secCtx.requestMutualAuth(mutual);
152 
153             // Always specify potential need for integrity and confidentiality
154             // Decision will be made during final handshake
155             secCtx.requestConf(true);
156             secCtx.requestInteg(true);
157 
158         } catch (GSSException e) {
159             throw new SaslException(&quot;Failure to initialize security context&quot;, e);
160         }
161 
162         if (authzID != null &amp;&amp; authzID.length() &gt; 0) {
<span class="line-modified">163             this.authzID = authzID.getBytes(UTF_8);</span>




164         }
165     }
166 
167     public boolean hasInitialResponse() {
168         return true;
169     }
170 
171     /**
172      * Processes the challenge data.
173      *
174      * The server sends a challenge data using which the client must
175      * process using GSS_Init_sec_context.
176      * As per RFC 2222, when GSS_S_COMPLETE is returned, we do
177      * an extra handshake to determine the negotiated security protection
178      * and buffer sizes.
179      *
180      * @param challengeData A non-null byte array containing the
181      * challenge data from the server.
182      * @return A non-null byte array containing the response to be
183      * sent to the server.
</pre>
<hr />
<pre>
219         }
220     }
221 
222     private byte[] doFinalHandshake(byte[] challengeData) throws SaslException {
223         try {
224             // Security context already established. challengeData
225             // should contain security layers and server&#39;s maximum buffer size
226 
227             if (logger.isLoggable(Level.FINER)) {
228                 traceOutput(MY_CLASS_NAME, &quot;doFinalHandshake&quot;,
229                     &quot;KRB5CLNT04:Challenge [raw]:&quot;, challengeData);
230             }
231 
232             if (challengeData.length == 0) {
233                 // Received S0, should return []
234                 return EMPTY;
235             }
236 
237             // Received S1 (security layer, server max recv size)
238 
<span class="line-added">239             MessageProp msgProp = new MessageProp(false);</span>
240             byte[] gssOutToken = secCtx.unwrap(challengeData, 0,
<span class="line-modified">241                 challengeData.length, msgProp);</span>
<span class="line-added">242             checkMessageProp(&quot;Handshake failure: &quot;, msgProp);</span>
243 
244             // First octet is a bit-mask specifying the protections
245             // supported by the server
246             if (logger.isLoggable(Level.FINE)) {
247                 if (logger.isLoggable(Level.FINER)) {
248                     traceOutput(MY_CLASS_NAME, &quot;doFinalHandshake&quot;,
249                         &quot;KRB5CLNT05:Challenge [unwrapped]:&quot;, gssOutToken);
250                 }
251                 logger.log(Level.FINE, &quot;KRB5CLNT06:Server protections: {0}&quot;,
252                     gssOutToken[0]);
253             }
254 
255             // Client selects preferred protection
256             // qop is ordered list of qop values
257             byte selectedQop = findPreferredMask(gssOutToken[0], qop);
258             if (selectedQop == 0) {
259                 throw new SaslException(
260                     &quot;No common protection layer between client and server&quot;);
261             }
262 
</pre>
</td>
</tr>
</table>
<center><a href="GssKrb5Base.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GssKrb5Server.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
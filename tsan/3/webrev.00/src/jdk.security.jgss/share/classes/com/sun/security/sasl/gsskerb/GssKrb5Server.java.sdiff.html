<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.security.jgss/share/classes/com/sun/security/sasl/gsskerb/GssKrb5Server.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GssKrb5Client.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../jdk.unsupported/share/classes/sun/misc/Unsafe.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.security.jgss/share/classes/com/sun/security/sasl/gsskerb/GssKrb5Server.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.security.sasl.gsskerb;
 27 
 28 import javax.security.sasl.*;
 29 import java.io.*;
 30 import java.util.Map;
 31 import java.util.logging.Level;
 32 


 33 // JAAS
 34 import javax.security.auth.callback.*;
 35 
 36 // JGSS
 37 import org.ietf.jgss.*;
 38 
 39 /**
 40   * Implements the GSSAPI SASL server mechanism for Kerberos V5.
 41   * (&lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2222.txt&quot;&gt;RFC 2222&lt;/A&gt;,
 42   * &lt;a HREF=&quot;http://www.ietf.org/internet-drafts/draft-ietf-cat-sasl-gssapi-00.txt&quot;&gt;draft-ietf-cat-sasl-gssapi-00.txt&lt;/a&gt;).
 43   *
 44   * Expects thread&#39;s Subject to contain server&#39;s Kerberos credentials
 45   * - If not, underlying KRB5 mech will attempt to acquire Kerberos creds
 46   *   by logging into Kerberos (via default TextCallbackHandler).
 47   * - These creds will be used for exchange with client.
 48   *
 49   * Required callbacks:
 50   * - AuthorizeCallback
 51   *      handler must verify that authid/authzids are allowed and set
 52   *      authorized ID to be the canonicalized authzid (if applicable).
</pre>
<hr />
<pre>
233             }
234 
235             byte[] gssOutToken = secCtx.wrap(gssInToken, 0, gssInToken.length,
236                 new MessageProp(0 /* gop */, false /* privacy */));
237 
238             if (logger.isLoggable(Level.FINER)) {
239                 traceOutput(MY_CLASS_NAME, &quot;doHandshake1&quot;,
240                     &quot;KRB5SRV08:Challenge [after wrap]&quot;, gssOutToken);
241             }
242             return gssOutToken;
243 
244         } catch (GSSException e) {
245             throw new SaslException(&quot;Problem wrapping handshake1&quot;, e);
246         }
247     }
248 
249     private byte[] doHandshake2(byte[] responseData) throws SaslException {
250         try {
251             // Expecting 4 octets from client selected protection
252             // and client&#39;s receive buffer size

253             byte[] gssOutToken = secCtx.unwrap(responseData, 0,
<span class="line-modified">254                 responseData.length, new MessageProp(0, false));</span>

255 
256             if (logger.isLoggable(Level.FINER)) {
257                 traceOutput(MY_CLASS_NAME, &quot;doHandshake2&quot;,
258                     &quot;KRB5SRV09:Response [after unwrap]&quot;, gssOutToken);
259             }
260 
261             // First octet is a bit-mask specifying the selected protection
262             byte selectedQop = gssOutToken[0];
263             if ((selectedQop&amp;allQop) == 0) {
264                 throw new SaslException(&quot;Client selected unsupported protection: &quot;
265                     + selectedQop);
266             }
267             if ((selectedQop&amp;PRIVACY_PROTECTION) != 0) {
268                 privacy = true;
269                 integrity = true;
270             } else if ((selectedQop&amp;INTEGRITY_ONLY_PROTECTION) != 0) {
271                 integrity = true;
272             }
273 
274             // 2nd-4th octets specifies maximum buffer size expected by
</pre>
<hr />
<pre>
283 
284             // Update context to limit size of returned buffer
285             rawSendSize = secCtx.getWrapSizeLimit(JGSS_QOP, privacy,
286                 sendMaxBufSize);
287 
288             if (logger.isLoggable(Level.FINE)) {
289                 logger.log(Level.FINE,
290             &quot;KRB5SRV10:Selected protection: {0}; privacy: {1}; integrity: {2}&quot;,
291                     new Object[]{selectedQop,
292                                  Boolean.valueOf(privacy),
293                                  Boolean.valueOf(integrity)});
294                 logger.log(Level.FINE,
295 &quot;KRB5SRV11:Client max recv size: {0}; server max send size: {1}; rawSendSize: {2}&quot;,
296                     new Object[] {clntMaxBufSize,
297                                   sendMaxBufSize,
298                                   rawSendSize});
299             }
300 
301             // Get authorization identity, if any
302             if (gssOutToken.length &gt; 4) {
<span class="line-modified">303                 try {</span>
<span class="line-modified">304                     authzid = new String(gssOutToken, 4,</span>
<span class="line-removed">305                         gssOutToken.length - 4, &quot;UTF-8&quot;);</span>
<span class="line-removed">306                 } catch (UnsupportedEncodingException uee) {</span>
<span class="line-removed">307                     throw new SaslException (&quot;Cannot decode authzid&quot;, uee);</span>
<span class="line-removed">308                 }</span>
309             } else {
310                 authzid = peer;
311             }
312             logger.log(Level.FINE, &quot;KRB5SRV12:Authzid: {0}&quot;, authzid);
313 
314             AuthorizeCallback acb = new AuthorizeCallback(peer, authzid);
315 
316             // In Kerberos, realm is embedded in peer name
317             cbh.handle(new Callback[] {acb});
318             if (acb.isAuthorized()) {
319                 authzid = acb.getAuthorizedID();
320                 completed = true;
321             } else {
322                 // Authorization failed
323                 throw new SaslException(peer +
324                     &quot; is not authorized to connect as &quot; + authzid);
325             }
326 
327             return null;
328         } catch (GSSException e) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.security.sasl.gsskerb;
 27 
 28 import javax.security.sasl.*;
 29 import java.io.*;
 30 import java.util.Map;
 31 import java.util.logging.Level;
 32 
<span class="line-added"> 33 import static java.nio.charset.StandardCharsets.UTF_8;</span>
<span class="line-added"> 34 </span>
 35 // JAAS
 36 import javax.security.auth.callback.*;
 37 
 38 // JGSS
 39 import org.ietf.jgss.*;
 40 
 41 /**
 42   * Implements the GSSAPI SASL server mechanism for Kerberos V5.
 43   * (&lt;A HREF=&quot;http://www.ietf.org/rfc/rfc2222.txt&quot;&gt;RFC 2222&lt;/A&gt;,
 44   * &lt;a HREF=&quot;http://www.ietf.org/internet-drafts/draft-ietf-cat-sasl-gssapi-00.txt&quot;&gt;draft-ietf-cat-sasl-gssapi-00.txt&lt;/a&gt;).
 45   *
 46   * Expects thread&#39;s Subject to contain server&#39;s Kerberos credentials
 47   * - If not, underlying KRB5 mech will attempt to acquire Kerberos creds
 48   *   by logging into Kerberos (via default TextCallbackHandler).
 49   * - These creds will be used for exchange with client.
 50   *
 51   * Required callbacks:
 52   * - AuthorizeCallback
 53   *      handler must verify that authid/authzids are allowed and set
 54   *      authorized ID to be the canonicalized authzid (if applicable).
</pre>
<hr />
<pre>
235             }
236 
237             byte[] gssOutToken = secCtx.wrap(gssInToken, 0, gssInToken.length,
238                 new MessageProp(0 /* gop */, false /* privacy */));
239 
240             if (logger.isLoggable(Level.FINER)) {
241                 traceOutput(MY_CLASS_NAME, &quot;doHandshake1&quot;,
242                     &quot;KRB5SRV08:Challenge [after wrap]&quot;, gssOutToken);
243             }
244             return gssOutToken;
245 
246         } catch (GSSException e) {
247             throw new SaslException(&quot;Problem wrapping handshake1&quot;, e);
248         }
249     }
250 
251     private byte[] doHandshake2(byte[] responseData) throws SaslException {
252         try {
253             // Expecting 4 octets from client selected protection
254             // and client&#39;s receive buffer size
<span class="line-added">255             MessageProp msgProp = new MessageProp(false);</span>
256             byte[] gssOutToken = secCtx.unwrap(responseData, 0,
<span class="line-modified">257                 responseData.length, msgProp);</span>
<span class="line-added">258             checkMessageProp(&quot;Handshake failure: &quot;, msgProp);</span>
259 
260             if (logger.isLoggable(Level.FINER)) {
261                 traceOutput(MY_CLASS_NAME, &quot;doHandshake2&quot;,
262                     &quot;KRB5SRV09:Response [after unwrap]&quot;, gssOutToken);
263             }
264 
265             // First octet is a bit-mask specifying the selected protection
266             byte selectedQop = gssOutToken[0];
267             if ((selectedQop&amp;allQop) == 0) {
268                 throw new SaslException(&quot;Client selected unsupported protection: &quot;
269                     + selectedQop);
270             }
271             if ((selectedQop&amp;PRIVACY_PROTECTION) != 0) {
272                 privacy = true;
273                 integrity = true;
274             } else if ((selectedQop&amp;INTEGRITY_ONLY_PROTECTION) != 0) {
275                 integrity = true;
276             }
277 
278             // 2nd-4th octets specifies maximum buffer size expected by
</pre>
<hr />
<pre>
287 
288             // Update context to limit size of returned buffer
289             rawSendSize = secCtx.getWrapSizeLimit(JGSS_QOP, privacy,
290                 sendMaxBufSize);
291 
292             if (logger.isLoggable(Level.FINE)) {
293                 logger.log(Level.FINE,
294             &quot;KRB5SRV10:Selected protection: {0}; privacy: {1}; integrity: {2}&quot;,
295                     new Object[]{selectedQop,
296                                  Boolean.valueOf(privacy),
297                                  Boolean.valueOf(integrity)});
298                 logger.log(Level.FINE,
299 &quot;KRB5SRV11:Client max recv size: {0}; server max send size: {1}; rawSendSize: {2}&quot;,
300                     new Object[] {clntMaxBufSize,
301                                   sendMaxBufSize,
302                                   rawSendSize});
303             }
304 
305             // Get authorization identity, if any
306             if (gssOutToken.length &gt; 4) {
<span class="line-modified">307                 authzid = new String(gssOutToken, 4,</span>
<span class="line-modified">308                         gssOutToken.length - 4, UTF_8);</span>




309             } else {
310                 authzid = peer;
311             }
312             logger.log(Level.FINE, &quot;KRB5SRV12:Authzid: {0}&quot;, authzid);
313 
314             AuthorizeCallback acb = new AuthorizeCallback(peer, authzid);
315 
316             // In Kerberos, realm is embedded in peer name
317             cbh.handle(new Callback[] {acb});
318             if (acb.isAuthorized()) {
319                 authzid = acb.getAuthorizedID();
320                 completed = true;
321             } else {
322                 // Authorization failed
323                 throw new SaslException(peer +
324                     &quot; is not authorized to connect as &quot; + authzid);
325             }
326 
327             return null;
328         } catch (GSSException e) {
</pre>
</td>
</tr>
</table>
<center><a href="GssKrb5Client.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../jdk.unsupported/share/classes/sun/misc/Unsafe.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
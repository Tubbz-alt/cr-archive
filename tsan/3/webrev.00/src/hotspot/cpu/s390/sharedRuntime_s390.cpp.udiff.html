<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/s390/sharedRuntime_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="s390.ad.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_s390.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/sharedRuntime_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,8 +1,8 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, 2018 SAP SE. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30,11 +30,13 @@</span>
  #include &quot;code/vtableStubs.hpp&quot;
  #include &quot;gc/shared/gcLocker.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;interpreter/interp_masm.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;nativeInst_s390.hpp&quot;</span>
  #include &quot;oops/compiledICHolder.hpp&quot;
<span class="udiff-line-added">+ #include &quot;oops/klass.inline.hpp&quot;</span>
  #include &quot;registerSaver_s390.hpp&quot;
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/vframeArray.hpp&quot;
  #include &quot;utilities/align.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -881,20 +883,20 @@</span>
                              const BasicType *sig_bt,
                              const VMRegPair *regs) {
    if (!VerifyOops) { return; }
  
    for (int i = 0; i &lt; total_args_passed; i++) {
<span class="udiff-line-modified-removed">-     if (sig_bt[i] == T_OBJECT || sig_bt[i] == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+     if (is_reference_type(sig_bt[i])) {</span>
        VMReg r = regs[i].first();
        assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
  
        if (r-&gt;is_stack()) {
          __ z_lg(Z_R0_scratch,
                  Address(Z_SP, r-&gt;reg2stack() * VMRegImpl::stack_slot_size + wordSize));
<span class="udiff-line-modified-removed">-         __ verify_oop(Z_R0_scratch);</span>
<span class="udiff-line-modified-added">+         __ verify_oop(Z_R0_scratch, FILE_AND_LINE);</span>
        } else {
<span class="udiff-line-modified-removed">-         __ verify_oop(r-&gt;as_Register());</span>
<span class="udiff-line-modified-added">+         __ verify_oop(r-&gt;as_Register(), FILE_AND_LINE);</span>
        }
      }
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1516,12 +1518,12 @@</span>
  nmethod *SharedRuntime::generate_native_wrapper(MacroAssembler *masm,
                                                  const methodHandle&amp; method,
                                                  int compile_id,
                                                  BasicType *in_sig_bt,
                                                  VMRegPair *in_regs,
<span class="udiff-line-modified-removed">-                                                 BasicType ret_type) {</span>
<span class="udiff-line-modified-removed">- #ifdef COMPILER2</span>
<span class="udiff-line-modified-added">+                                                 BasicType ret_type,</span>
<span class="udiff-line-modified-added">+                                                 address critical_entry) {</span>
    int total_in_args = method-&gt;size_of_parameters();
    if (method-&gt;is_method_handle_intrinsic()) {
      vmIntrinsics::ID iid = method-&gt;intrinsic_id();
      intptr_t start = (intptr_t) __ pc();
      int vep_offset = ((intptr_t) __ pc()) - start;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1552,11 +1554,11 @@</span>
    //  Precalculations before generating any code
    //
    ///////////////////////////////////////////////////////////////////////
  
    bool is_critical_native = true;
<span class="udiff-line-modified-removed">-   address native_func = method-&gt;critical_native_function();</span>
<span class="udiff-line-modified-added">+   address native_func = critical_entry;</span>
    if (native_func == NULL) {
      native_func = method-&gt;native_function();
      is_critical_native = false;
    }
    assert(native_func != NULL, &quot;must have function&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1616,38 +1618,25 @@</span>
  
      for (int i = 0; i &lt; total_in_args; i++) {
        out_sig_bt[argc++] = in_sig_bt[i];
      }
    } else {
<span class="udiff-line-removed">-     Thread* THREAD = Thread::current();</span>
      in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
      SignatureStream ss(method-&gt;signature());
      int o = 0;
      for (int i = 0; i &lt; total_in_args; i++, o++) {
        if (in_sig_bt[i] == T_ARRAY) {
          // Arrays are passed as tuples (int, elem*).
<span class="udiff-line-modified-removed">-         Symbol* atype = ss.as_symbol(CHECK_NULL);</span>
<span class="udiff-line-modified-removed">-         const char* at = atype-&gt;as_C_string();</span>
<span class="udiff-line-modified-removed">-         if (strlen(at) == 2) {</span>
<span class="udiff-line-removed">-           assert(at[0] == &#39;[&#39;, &quot;must be&quot;);</span>
<span class="udiff-line-removed">-           switch (at[1]) {</span>
<span class="udiff-line-removed">-             case &#39;B&#39;: in_elem_bt[o]  = T_BYTE; break;</span>
<span class="udiff-line-removed">-             case &#39;C&#39;: in_elem_bt[o]  = T_CHAR; break;</span>
<span class="udiff-line-removed">-             case &#39;D&#39;: in_elem_bt[o]  = T_DOUBLE; break;</span>
<span class="udiff-line-removed">-             case &#39;F&#39;: in_elem_bt[o]  = T_FLOAT; break;</span>
<span class="udiff-line-removed">-             case &#39;I&#39;: in_elem_bt[o]  = T_INT; break;</span>
<span class="udiff-line-removed">-             case &#39;J&#39;: in_elem_bt[o]  = T_LONG; break;</span>
<span class="udiff-line-removed">-             case &#39;S&#39;: in_elem_bt[o]  = T_SHORT; break;</span>
<span class="udiff-line-removed">-             case &#39;Z&#39;: in_elem_bt[o]  = T_BOOLEAN; break;</span>
<span class="udiff-line-removed">-             default: ShouldNotReachHere();</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         ss.skip_array_prefix(1);  // skip one &#39;[&#39;</span>
<span class="udiff-line-modified-added">+         assert(ss.is_primitive(), &quot;primitive type expected&quot;);</span>
<span class="udiff-line-modified-added">+         in_elem_bt[o] = ss.type();</span>
        } else {
          in_elem_bt[o] = T_VOID;
        }
        if (in_sig_bt[i] != T_VOID) {
<span class="udiff-line-modified-removed">-         assert(in_sig_bt[i] == ss.type(), &quot;must match&quot;);</span>
<span class="udiff-line-modified-added">+         assert(in_sig_bt[i] == ss.type() ||</span>
<span class="udiff-line-added">+                in_sig_bt[i] == T_ARRAY, &quot;must match&quot;);</span>
          ss.next();
        }
      }
      assert(total_in_args == o, &quot;must match&quot;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1831,10 +1820,24 @@</span>
    //---------------------------------------------------------------------
    // Verified entry point (VEP)
    //---------------------------------------------------------------------
    wrapper_VEPStart = __ offset();
  
<span class="udiff-line-added">+   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {</span>
<span class="udiff-line-added">+     Label L_skip_barrier;</span>
<span class="udiff-line-added">+     Register klass = Z_R1_scratch;</span>
<span class="udiff-line-added">+     // Notify OOP recorder (don&#39;t need the relocation)</span>
<span class="udiff-line-added">+     AddressLiteral md = __ constant_metadata_address(method-&gt;method_holder());</span>
<span class="udiff-line-added">+     __ load_const_optimized(klass, md.value());</span>
<span class="udiff-line-added">+     __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());</span>
<span class="udiff-line-added">+     __ z_br(klass);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ bind(L_skip_barrier);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    __ save_return_pc();
    __ generate_stack_overflow_check(frame_size_in_bytes);  // Check before creating frame.
  #ifndef USE_RESIZE_FRAME
    __ push_frame(frame_size_in_bytes);                     // Create a new frame for the wrapper.
  #else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2302,11 +2305,11 @@</span>
    __ verify_thread(); // Z_thread must be correct.
  
    __ reset_last_Java_frame();
  
    // Unpack oop result, e.g. JNIHandles::resolve result.
<span class="udiff-line-modified-removed">-   if (ret_type == T_OBJECT || ret_type == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+   if (is_reference_type(ret_type)) {</span>
      __ resolve_jobject(Z_RET, /* tmp1 */ Z_R13, /* tmp2 */ Z_R7);
    }
  
    if (CheckJNICalls) {
      // clear_pending_jni_exception_check
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2384,14 +2387,10 @@</span>
    if (is_critical_native) {
      nm-&gt;set_lazy_critical_native(true);
    }
  
    return nm;
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-   ShouldNotReachHere();</span>
<span class="udiff-line-removed">-   return NULL;</span>
<span class="udiff-line-removed">- #endif // COMPILER2</span>
  }
  
  static address gen_c2i_adapter(MacroAssembler  *masm,
                                 int total_args_passed,
                                 int comp_args_on_stack,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2605,11 +2604,11 @@</span>
            __ z_mvc(Address(Z_SP, st_off), Address(ld_ptr, ld_offset), sizeof(void*));
          }
        } else {
          if (!r_2-&gt;is_valid()) {
            // Not sure we need to do this but it shouldn&#39;t hurt.
<span class="udiff-line-modified-removed">-           if (sig_bt[i] == T_OBJECT || sig_bt[i] == T_ADDRESS || sig_bt[i] == T_ARRAY) {</span>
<span class="udiff-line-modified-added">+           if (is_reference_type(sig_bt[i]) || sig_bt[i] == T_ADDRESS) {</span>
              __ z_lg(r_1-&gt;as_Register(), ld_offset, ld_ptr);
            } else {
              __ z_l(r_1-&gt;as_Register(), ld_offset, ld_ptr);
            }
          } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2673,11 +2672,11 @@</span>
      // Check the pointers.
      if (!ImplicitNullChecks || MacroAssembler::needs_explicit_null_check(klass_offset)) {
        __ z_ltgr(Z_ARG1, Z_ARG1);
        __ z_bre(ic_miss);
      }
<span class="udiff-line-modified-removed">-     __ verify_oop(Z_ARG1);</span>
<span class="udiff-line-modified-added">+     __ verify_oop(Z_ARG1, FILE_AND_LINE);</span>
  
      // Check ic: object class &lt;-&gt; cached class
      // Compress cached class for comparison. That&#39;s more efficient.
      if (UseCompressedClassPointers) {
        __ z_lg(Z_R11, holder_klass_offset, Z_method);             // Z_R11 is overwritten a few instructions down anyway.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2695,14 +2694,36 @@</span>
      __ z_brne(ic_miss);  // Cache miss: call runtime to handle this.
  
      // Fallthru to VEP. Duplicate LTG, but saved taken branch.
    }
  
<span class="udiff-line-modified-removed">-   address c2i_entry;</span>
<span class="udiff-line-modified-removed">-   c2i_entry = gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);</span>
<span class="udiff-line-modified-added">+   address c2i_entry = __ pc();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   // Class initialization barrier for static methods</span>
<span class="udiff-line-added">+   address c2i_no_clinit_check_entry = NULL;</span>
<span class="udiff-line-added">+   if (VM_Version::supports_fast_class_init_checks()) {</span>
<span class="udiff-line-added">+     Label L_skip_barrier;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     { // Bypass the barrier for non-static methods</span>
<span class="udiff-line-added">+       __ testbit(Address(Z_method, Method::access_flags_offset()), JVM_ACC_STATIC_BIT);</span>
<span class="udiff-line-added">+       __ z_bfalse(L_skip_barrier); // non-static</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Register klass = Z_R11;</span>
<span class="udiff-line-added">+     __ load_method_holder(klass, Z_method);</span>
<span class="udiff-line-added">+     __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());</span>
<span class="udiff-line-added">+     __ z_br(klass);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     __ bind(L_skip_barrier);</span>
<span class="udiff-line-added">+     c2i_no_clinit_check_entry = __ pc();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);</span>
  
<span class="udiff-line-modified-removed">-   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);</span>
<span class="udiff-line-modified-added">+   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>
  }
  
  // This function returns the adjust size (in number of words) to a c2i adapter
  // activation for use during deoptimization.
  //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2841,11 +2862,11 @@</span>
    // The return_pc has been stored in the frame of the deoptee and
    // will replace the address of the deopt_handler in the call
    // to Deoptimization::fetch_unroll_info below.
    // The (int) cast is necessary, because -((unsigned int)14)
    // is an unsigned int.
<span class="udiff-line-modified-removed">-   __ add2reg(Z_R14, -(int)HandlerImpl::size_deopt_handler());</span>
<span class="udiff-line-modified-added">+   __ add2reg(Z_R14, -(int)NativeCall::max_instruction_size());</span>
  
    const Register   exec_mode_reg = Z_tmp_1;
  
    // stack: (deoptee, caller of deoptee, ...)
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2920,11 +2941,11 @@</span>
  
  
  #ifdef ASSERT
    // verify that there is really an exception oop in JavaThread
    __ z_lg(Z_ARG1, Address(Z_thread, JavaThread::exception_oop_offset()));
<span class="udiff-line-modified-removed">-   __ verify_oop(Z_ARG1);</span>
<span class="udiff-line-modified-added">+   __ MacroAssembler::verify_oop(Z_ARG1, FILE_AND_LINE);</span>
  
    // verify that there is no pending exception
    __ asm_assert_mem8_is_zero(in_bytes(Thread::pending_exception_offset()), Z_thread,
                               &quot;must not have pending exception here&quot;, __LINE__);
  #endif
</pre>
<center><a href="s390.ad.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_s390.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
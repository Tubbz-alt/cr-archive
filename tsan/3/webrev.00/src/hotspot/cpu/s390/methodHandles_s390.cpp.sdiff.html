<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/methodHandles_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/methodHandles_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 68 #else
 69 #define NONZERO(x) (x)
 70 #endif
 71 
 72 #ifdef ASSERT
 73 void MethodHandles::verify_klass(MacroAssembler* _masm,
 74                                  Register obj_reg, SystemDictionary::WKID klass_id,
 75                                  Register temp_reg, Register temp2_reg,
 76                                  const char* error_message) {
 77 
 78   InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);
 79   Klass* klass = SystemDictionary::well_known_klass(klass_id);
 80 
 81   assert(temp_reg != Z_R0 &amp;&amp; // Is used as base register!
 82          temp_reg != noreg &amp;&amp; temp2_reg != noreg, &quot;need valid registers!&quot;);
 83 
 84   NearLabel L_ok, L_bad;
 85 
 86   BLOCK_COMMENT(&quot;verify_klass {&quot;);
 87 
<span class="line-modified"> 88   __ verify_oop(obj_reg);</span>
 89   __ compareU64_and_branch(obj_reg, (intptr_t)0L, Assembler::bcondEqual, L_bad);
 90   __ load_klass(temp_reg, obj_reg);
 91   // klass_addr is a klass in allstatic SystemDictionaryHandles. Can&#39;t get GCed.
 92   __ load_const_optimized(temp2_reg, (address)klass_addr);
 93   __ z_lg(temp2_reg, Address(temp2_reg));
 94   __ compareU64_and_branch(temp_reg, temp2_reg, Assembler::bcondEqual, L_ok);
 95 
 96   intptr_t super_check_offset = klass-&gt;super_check_offset();
 97   __ z_lg(temp_reg, Address(temp_reg, super_check_offset));
 98   __ compareU64_and_branch(temp_reg, temp2_reg, Assembler::bcondEqual, L_ok);
 99   __ BIND(L_bad);
100   __ stop(error_message);
101   __ BIND(L_ok);
102 
103   BLOCK_COMMENT(&quot;} verify_klass&quot;);
104 }
105 
106 void MethodHandles::verify_ref_kind(MacroAssembler* _masm, int ref_kind,
107                                     Register member_reg, Register temp  ) {
108   NearLabel L;
</pre>
<hr />
<pre>
177 
178   __ bind(L_no_such_method);
179   assert(StubRoutines::throw_AbstractMethodError_entry() != NULL, &quot;not yet generated!&quot;);
180   __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());
181   __ z_br(target);
182 }
183 
184 void MethodHandles::jump_to_lambda_form(MacroAssembler* _masm,
185                                         Register recv, Register method_temp,
186                                         Register temp2, Register temp3,
187                                         bool for_compiler_entry) {
188 
189   // This is the initial entry point of a lazy method handle.
190   // After type checking, it picks up the invoker from the LambdaForm.
191   assert_different_registers(recv, method_temp, temp2, temp3);
192   assert(method_temp == Z_method, &quot;required register for loading method&quot;);
193 
194   BLOCK_COMMENT(&quot;jump_to_lambda_form {&quot;);
195 
196   // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
<span class="line-modified">197   __ verify_oop(recv);</span>
198   __ load_heap_oop(method_temp,
199                    Address(recv,
200                            NONZERO(java_lang_invoke_MethodHandle::form_offset_in_bytes())),
201                    noreg, noreg, IS_NOT_NULL);
<span class="line-modified">202   __ verify_oop(method_temp);</span>
203   __ load_heap_oop(method_temp,
204                    Address(method_temp,
205                            NONZERO(java_lang_invoke_LambdaForm::vmentry_offset_in_bytes())),
206                    noreg, noreg, IS_NOT_NULL);
<span class="line-modified">207   __ verify_oop(method_temp);</span>
208   __ load_heap_oop(method_temp,
209                    Address(method_temp,
210                            NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes())),
211                    noreg, noreg, IS_NOT_NULL);
<span class="line-modified">212   __ verify_oop(method_temp);</span>
213   __ z_lg(method_temp,
214           Address(method_temp,
215                   NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes())));
216 
217   if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
218     // Make sure recv is already on stack.
219     NearLabel L;
220     Address paramSize(temp2, ConstMethod::size_of_parameters_offset());
221 
222     __ z_lg(temp2, Address(method_temp, Method::const_offset()));
223     __ load_sized_value(temp2, paramSize, sizeof(u2), /*is_signed*/ false);
224     // if (temp2 != recv) stop
225     __ z_lg(temp2, __ argument_address(temp2, temp2, 0));
226     __ compare64_and_branch(temp2, recv, Assembler::bcondEqual, L);
227     __ stop(&quot;receiver not on stack&quot;);
228     __ BIND(L);
229   }
230 
231   jump_from_method_handle(_masm, method_temp, temp2, Z_R0, for_compiler_entry);
232 
</pre>
<hr />
<pre>
368     jump_to_lambda_form(_masm, receiver_reg, Z_method, Z_R1, temp3, for_compiler_entry);
369     return;
370   }
371 
372   // The method is a member invoker used by direct method handles.
373   if (VerifyMethodHandles) {
374     // Make sure the trailing argument really is a MemberName (caller responsibility).
375     verify_klass(_masm, member_reg,
376                  SystemDictionary::WK_KLASS_ENUM_NAME(MemberName_klass),
377                  temp1, temp2,
378                  &quot;MemberName required for invokeVirtual etc.&quot;);
379   }
380 
381   Address  member_clazz(   member_reg, NONZERO(java_lang_invoke_MemberName::clazz_offset_in_bytes()));
382   Address  member_vmindex( member_reg, NONZERO(java_lang_invoke_MemberName::vmindex_offset_in_bytes()));
383   Address  member_vmtarget(member_reg, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes()));
384   Address  vmtarget_method(Z_method, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes()));
385   Register temp1_recv_klass = temp1;
386 
387   if (iid != vmIntrinsics::_linkToStatic) {
<span class="line-modified">388     __ verify_oop(receiver_reg);</span>
389     if (iid == vmIntrinsics::_linkToSpecial) {
390       // Don&#39;t actually load the klass; just null-check the receiver.
391       __ null_check(receiver_reg);
392     } else {
393       // Load receiver klass itself.
394       __ null_check(receiver_reg, Z_R0, oopDesc::klass_offset_in_bytes());
395       __ load_klass(temp1_recv_klass, receiver_reg);
396       __ verify_klass_ptr(temp1_recv_klass);
397     }
398     BLOCK_COMMENT(&quot;check_receiver {&quot;);
399     // The receiver for the MemberName must be in receiver_reg.
400     // Check the receiver against the MemberName.clazz.
401     if (VerifyMethodHandles &amp;&amp; iid == vmIntrinsics::_linkToSpecial) {
402       // Did not load it above...
403       __ load_klass(temp1_recv_klass, receiver_reg);
404       __ verify_klass_ptr(temp1_recv_klass);
405     }
406 
407     if (VerifyMethodHandles &amp;&amp; iid != vmIntrinsics::_linkToInterface) {
408       NearLabel L_ok;
</pre>
</td>
<td>
<hr />
<pre>
 68 #else
 69 #define NONZERO(x) (x)
 70 #endif
 71 
 72 #ifdef ASSERT
 73 void MethodHandles::verify_klass(MacroAssembler* _masm,
 74                                  Register obj_reg, SystemDictionary::WKID klass_id,
 75                                  Register temp_reg, Register temp2_reg,
 76                                  const char* error_message) {
 77 
 78   InstanceKlass** klass_addr = SystemDictionary::well_known_klass_addr(klass_id);
 79   Klass* klass = SystemDictionary::well_known_klass(klass_id);
 80 
 81   assert(temp_reg != Z_R0 &amp;&amp; // Is used as base register!
 82          temp_reg != noreg &amp;&amp; temp2_reg != noreg, &quot;need valid registers!&quot;);
 83 
 84   NearLabel L_ok, L_bad;
 85 
 86   BLOCK_COMMENT(&quot;verify_klass {&quot;);
 87 
<span class="line-modified"> 88   __ verify_oop(obj_reg, FILE_AND_LINE);</span>
 89   __ compareU64_and_branch(obj_reg, (intptr_t)0L, Assembler::bcondEqual, L_bad);
 90   __ load_klass(temp_reg, obj_reg);
 91   // klass_addr is a klass in allstatic SystemDictionaryHandles. Can&#39;t get GCed.
 92   __ load_const_optimized(temp2_reg, (address)klass_addr);
 93   __ z_lg(temp2_reg, Address(temp2_reg));
 94   __ compareU64_and_branch(temp_reg, temp2_reg, Assembler::bcondEqual, L_ok);
 95 
 96   intptr_t super_check_offset = klass-&gt;super_check_offset();
 97   __ z_lg(temp_reg, Address(temp_reg, super_check_offset));
 98   __ compareU64_and_branch(temp_reg, temp2_reg, Assembler::bcondEqual, L_ok);
 99   __ BIND(L_bad);
100   __ stop(error_message);
101   __ BIND(L_ok);
102 
103   BLOCK_COMMENT(&quot;} verify_klass&quot;);
104 }
105 
106 void MethodHandles::verify_ref_kind(MacroAssembler* _masm, int ref_kind,
107                                     Register member_reg, Register temp  ) {
108   NearLabel L;
</pre>
<hr />
<pre>
177 
178   __ bind(L_no_such_method);
179   assert(StubRoutines::throw_AbstractMethodError_entry() != NULL, &quot;not yet generated!&quot;);
180   __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());
181   __ z_br(target);
182 }
183 
184 void MethodHandles::jump_to_lambda_form(MacroAssembler* _masm,
185                                         Register recv, Register method_temp,
186                                         Register temp2, Register temp3,
187                                         bool for_compiler_entry) {
188 
189   // This is the initial entry point of a lazy method handle.
190   // After type checking, it picks up the invoker from the LambdaForm.
191   assert_different_registers(recv, method_temp, temp2, temp3);
192   assert(method_temp == Z_method, &quot;required register for loading method&quot;);
193 
194   BLOCK_COMMENT(&quot;jump_to_lambda_form {&quot;);
195 
196   // Load the invoker, as MH -&gt; MH.form -&gt; LF.vmentry
<span class="line-modified">197   __ verify_oop(recv, FILE_AND_LINE);</span>
198   __ load_heap_oop(method_temp,
199                    Address(recv,
200                            NONZERO(java_lang_invoke_MethodHandle::form_offset_in_bytes())),
201                    noreg, noreg, IS_NOT_NULL);
<span class="line-modified">202   __ verify_oop(method_temp, FILE_AND_LINE);</span>
203   __ load_heap_oop(method_temp,
204                    Address(method_temp,
205                            NONZERO(java_lang_invoke_LambdaForm::vmentry_offset_in_bytes())),
206                    noreg, noreg, IS_NOT_NULL);
<span class="line-modified">207   __ verify_oop(method_temp, FILE_AND_LINE);</span>
208   __ load_heap_oop(method_temp,
209                    Address(method_temp,
210                            NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes())),
211                    noreg, noreg, IS_NOT_NULL);
<span class="line-modified">212   __ verify_oop(method_temp, FILE_AND_LINE);</span>
213   __ z_lg(method_temp,
214           Address(method_temp,
215                   NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes())));
216 
217   if (VerifyMethodHandles &amp;&amp; !for_compiler_entry) {
218     // Make sure recv is already on stack.
219     NearLabel L;
220     Address paramSize(temp2, ConstMethod::size_of_parameters_offset());
221 
222     __ z_lg(temp2, Address(method_temp, Method::const_offset()));
223     __ load_sized_value(temp2, paramSize, sizeof(u2), /*is_signed*/ false);
224     // if (temp2 != recv) stop
225     __ z_lg(temp2, __ argument_address(temp2, temp2, 0));
226     __ compare64_and_branch(temp2, recv, Assembler::bcondEqual, L);
227     __ stop(&quot;receiver not on stack&quot;);
228     __ BIND(L);
229   }
230 
231   jump_from_method_handle(_masm, method_temp, temp2, Z_R0, for_compiler_entry);
232 
</pre>
<hr />
<pre>
368     jump_to_lambda_form(_masm, receiver_reg, Z_method, Z_R1, temp3, for_compiler_entry);
369     return;
370   }
371 
372   // The method is a member invoker used by direct method handles.
373   if (VerifyMethodHandles) {
374     // Make sure the trailing argument really is a MemberName (caller responsibility).
375     verify_klass(_masm, member_reg,
376                  SystemDictionary::WK_KLASS_ENUM_NAME(MemberName_klass),
377                  temp1, temp2,
378                  &quot;MemberName required for invokeVirtual etc.&quot;);
379   }
380 
381   Address  member_clazz(   member_reg, NONZERO(java_lang_invoke_MemberName::clazz_offset_in_bytes()));
382   Address  member_vmindex( member_reg, NONZERO(java_lang_invoke_MemberName::vmindex_offset_in_bytes()));
383   Address  member_vmtarget(member_reg, NONZERO(java_lang_invoke_MemberName::method_offset_in_bytes()));
384   Address  vmtarget_method(Z_method, NONZERO(java_lang_invoke_ResolvedMethodName::vmtarget_offset_in_bytes()));
385   Register temp1_recv_klass = temp1;
386 
387   if (iid != vmIntrinsics::_linkToStatic) {
<span class="line-modified">388     __ verify_oop(receiver_reg, FILE_AND_LINE);</span>
389     if (iid == vmIntrinsics::_linkToSpecial) {
390       // Don&#39;t actually load the klass; just null-check the receiver.
391       __ null_check(receiver_reg);
392     } else {
393       // Load receiver klass itself.
394       __ null_check(receiver_reg, Z_R0, oopDesc::klass_offset_in_bytes());
395       __ load_klass(temp1_recv_klass, receiver_reg);
396       __ verify_klass_ptr(temp1_recv_klass);
397     }
398     BLOCK_COMMENT(&quot;check_receiver {&quot;);
399     // The receiver for the MemberName must be in receiver_reg.
400     // Check the receiver against the MemberName.clazz.
401     if (VerifyMethodHandles &amp;&amp; iid == vmIntrinsics::_linkToSpecial) {
402       // Did not load it above...
403       __ load_klass(temp1_recv_klass, receiver_reg);
404       __ verify_klass_ptr(temp1_recv_klass);
405     }
406 
407     if (VerifyMethodHandles &amp;&amp; iid != vmIntrinsics::_linkToInterface) {
408       NearLabel L_ok;
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
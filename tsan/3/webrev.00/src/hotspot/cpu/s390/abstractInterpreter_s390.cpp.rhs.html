<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/abstractInterpreter_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2016 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;interpreter/interpreter.hpp&quot;
 28 #include &quot;oops/constMethod.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 29 #include &quot;oops/klass.inline.hpp&quot;</span>
 30 #include &quot;oops/method.hpp&quot;
 31 #include &quot;runtime/frame.inline.hpp&quot;
 32 #include &quot;utilities/debug.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 
 35 int AbstractInterpreter::BasicType_as_index(BasicType type) {
 36   int i = 0;
 37   switch (type) {
 38     case T_BOOLEAN: i = 0; break;
 39     case T_CHAR   : i = 1; break;
 40     case T_BYTE   : i = 2; break;
 41     case T_SHORT  : i = 3; break;
 42     case T_INT    : i = 4; break;
 43     case T_LONG   : i = 5; break;
 44     case T_VOID   : i = 6; break;
 45     case T_FLOAT  : i = 7; break;
 46     case T_DOUBLE : i = 8; break;
 47     case T_OBJECT : i = 9; break;
 48     case T_ARRAY  : i = 9; break;
 49     default       : ShouldNotReachHere();
 50   }
 51   assert(0 &lt;= i &amp;&amp; i &lt; AbstractInterpreter::number_of_result_handlers, &quot;index out of bounds&quot;);
 52   return i;
 53 }
 54 
 55 // How much stack a method top interpreter activation needs in words.
 56 int AbstractInterpreter::size_top_interpreter_activation(Method* method) {
 57 
 58   // We have to size the following 2 frames:
 59   //
 60   //   [TOP_IJAVA_FRAME_ABI]
 61   //   [ENTRY_FRAME]
 62   //
 63   // This expands to (see frame_s390.hpp):
 64   //
 65   //   [TOP_IJAVA_FRAME_ABI]
 66   //   [operand stack]                 &gt; stack
 67   //   [monitors]      (optional)      &gt; monitors
 68   //   [IJAVA_STATE]                   &gt; interpreter_state
 69   //   [PARENT_IJAVA_FRAME_ABI]
 70   //   [callee&#39;s locals w/o arguments] \ locals
 71   //   [outgoing arguments]            /
 72   //   [ENTRY_FRAME_LOCALS]
 73 
 74   int locals = method-&gt;max_locals() * BytesPerWord;
 75   int interpreter_state = frame::z_ijava_state_size;
 76 
 77   int stack = method-&gt;max_stack() * BytesPerWord;
 78   int monitors = method-&gt;is_synchronized() ? frame::interpreter_frame_monitor_size_in_bytes() : 0;
 79 
 80   int total_bytes =
 81     frame::z_top_ijava_frame_abi_size +
 82     stack +
 83     monitors +
 84     interpreter_state +
 85     frame::z_parent_ijava_frame_abi_size +
 86     locals +
 87     frame::z_entry_frame_locals_size;
 88 
 89   return (total_bytes/BytesPerWord);
 90 }
 91 
 92 // Returns number of stackElementWords needed for the interpreter frame with the
 93 // given sections.
 94 // This overestimates the stack by one slot in case of alignments.
 95 int AbstractInterpreter::size_activation(int max_stack,
 96                                          int temps,
 97                                          int extra_args,
 98                                          int monitors,
 99                                          int callee_params,
100                                          int callee_locals,
101                                          bool is_top_frame) {
102   // Note: This calculation must exactly parallel the frame setup
103   // in AbstractInterpreterGenerator::generate_method_entry.
104 
105   assert((Interpreter::stackElementSize == frame::alignment_in_bytes), &quot;must align frame size&quot;);
106   const int abi_scratch = is_top_frame ? (frame::z_top_ijava_frame_abi_size    / Interpreter::stackElementSize) :
107                                          (frame::z_parent_ijava_frame_abi_size / Interpreter::stackElementSize);
108 
109   const int size =
110     max_stack                                                 +
111     (callee_locals - callee_params)                           + // Already counted in max_stack().
112     monitors * frame::interpreter_frame_monitor_size()        +
113     abi_scratch                                               +
114     frame::z_ijava_state_size / Interpreter::stackElementSize;
115 
116   // Fixed size of an interpreter frame.
117   return size;
118 }
119 
120 // Fills a sceletal interpreter frame generated during deoptimizations.
121 //
122 // Parameters:
123 //
124 // interpreter_frame != NULL:
125 //   set up the method, locals, and monitors.
126 //   The frame interpreter_frame, if not NULL, is guaranteed to be the
127 //   right size, as determined by a previous call to this method.
128 //   It is also guaranteed to be walkable even though it is in a skeletal state
129 //
130 // is_top_frame == true:
131 //   We&#39;re processing the *oldest* interpreter frame!
132 //
133 // pop_frame_extra_args:
134 //   If this is != 0 we are returning to a deoptimized frame by popping
135 //   off the callee frame. We want to re-execute the call that called the
136 //   callee interpreted, but since the return to the interpreter would pop
137 //   the arguments off advance the esp by dummy popframe_extra_args slots.
138 //   Popping off those will establish the stack layout as it was before the call.
139 //
140 
141 void AbstractInterpreter::layout_activation(Method* method,
142                                             int tempcount,
143                                             int popframe_extra_args,
144                                             int moncount,
145                                             int caller_actual_parameters,
146                                             int callee_param_count,
147                                             int callee_locals_count,
148                                             frame* caller,
149                                             frame* interpreter_frame,
150                                             bool is_top_frame,
151                                             bool is_bottom_frame) {
152   // TOP_IJAVA_FRAME:
153   //
154   //    0 [TOP_IJAVA_FRAME_ABI]         -+
155   //   16 [operand stack]                | size
156   //      [monitors]      (optional)     |
157   //      [IJAVA_STATE]                 -+
158   //      Note: own locals are located in the caller frame.
159   //
160   // PARENT_IJAVA_FRAME:
161   //
162   //    0 [PARENT_IJAVA_FRAME_ABI]                    -+
163   //      [callee&#39;s locals w/o arguments]              |
164   //      [outgoing arguments]                         | size
165   //      [used part of operand stack w/o arguments]   |
166   //      [monitors]      (optional)                   |
167   //      [IJAVA_STATE]                               -+
168   //
169 
170   // Now we know our caller, calc the exact frame layout and size
171   // z_ijava_state-&gt;locals - i*BytesPerWord points to i-th Java local (i starts at 0).
172   intptr_t* locals_base = (caller-&gt;is_interpreted_frame())
173     ? (caller-&gt;interpreter_frame_tos_address() + caller_actual_parameters - 1)
174     : (caller-&gt;sp()                            + method-&gt;max_locals()     - 1 +
175        frame::z_parent_ijava_frame_abi_size / Interpreter::stackElementSize);
176 
177   intptr_t* monitor_base = (intptr_t*)((address)interpreter_frame-&gt;fp() - frame::z_ijava_state_size);
178   intptr_t* monitor      = monitor_base - (moncount * frame::interpreter_frame_monitor_size());
179   intptr_t* operand_stack_base = monitor;
180   intptr_t* tos          = operand_stack_base - tempcount - popframe_extra_args;
181   intptr_t* top_frame_sp =
182     operand_stack_base - method-&gt;max_stack() - frame::z_top_ijava_frame_abi_size / Interpreter::stackElementSize;
183   intptr_t* sender_sp;
184   if (caller-&gt;is_interpreted_frame()) {
185     sender_sp = caller-&gt;interpreter_frame_top_frame_sp();
186   } else if (caller-&gt;is_compiled_frame()) {
187     sender_sp = caller-&gt;fp() - caller-&gt;cb()-&gt;frame_size();
188     // The bottom frame&#39;s sender_sp is its caller&#39;s unextended_sp.
189     // It was already set when its skeleton was pushed (see push_skeleton_frames()).
190     // Note: the unextended_sp is required by nmethod::orig_pc_addr().
191     assert(is_bottom_frame &amp;&amp; (sender_sp == caller-&gt;unextended_sp()),
192            &quot;must initialize sender_sp of bottom skeleton frame when pushing it&quot;);
193   } else {
194     assert(caller-&gt;is_entry_frame(), &quot;is there a new frame type??&quot;);
195     sender_sp = caller-&gt;sp(); // Call_stub only uses it&#39;s fp.
196   }
197 
198   interpreter_frame-&gt;interpreter_frame_set_method(method);
199   interpreter_frame-&gt;interpreter_frame_set_mirror(method-&gt;method_holder()-&gt;java_mirror());
200   interpreter_frame-&gt;interpreter_frame_set_locals(locals_base);
201   interpreter_frame-&gt;interpreter_frame_set_monitor_end((BasicObjectLock *)monitor);
202   *interpreter_frame-&gt;interpreter_frame_cache_addr() = method-&gt;constants()-&gt;cache();
203   interpreter_frame-&gt;interpreter_frame_set_tos_address(tos);
204   interpreter_frame-&gt;interpreter_frame_set_sender_sp(sender_sp);
205   interpreter_frame-&gt;interpreter_frame_set_top_frame_sp(top_frame_sp);
206 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/s390/c1_LIRAssembler_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap_s390.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_s390.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/c1_LIRAssembler_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">!  * Copyright (c) 2016, 2017, SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">!  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,17 ***</span>
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;c1/c1_ValueStack.hpp&quot;
  #include &quot;ci/ciArrayKlass.hpp&quot;
  #include &quot;ci/ciInstance.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified">! #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="line-removed">- #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;</span>
  #include &quot;nativeInst_s390.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;vmreg_s390.inline.hpp&quot;
  
  #define __ _masm-&gt;
  
  #ifndef PRODUCT
<span class="line-new-header">--- 31,17 ---</span>
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;c1/c1_ValueStack.hpp&quot;
  #include &quot;ci/ciArrayKlass.hpp&quot;
  #include &quot;ci/ciInstance.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified">! #include &quot;memory/universe.hpp&quot;</span>
  #include &quot;nativeInst_s390.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  #include &quot;vmreg_s390.inline.hpp&quot;
  
  #define __ _masm-&gt;
  
  #ifndef PRODUCT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,10 ***</span>
<span class="line-new-header">--- 78,25 ---</span>
    int offset = __ offset();
    __ inline_cache_check(receiver, Z_inline_cache);
    return offset;
  }
  
<span class="line-added">+ void LIR_Assembler::clinit_barrier(ciMethod* method) {</span>
<span class="line-added">+   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   Label L_skip_barrier;</span>
<span class="line-added">+   Register klass = Z_R1_scratch;</span>
<span class="line-added">+ </span>
<span class="line-added">+   metadata2reg(method-&gt;holder()-&gt;constant_encoding(), klass);</span>
<span class="line-added">+   __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());</span>
<span class="line-added">+   __ z_br(klass);</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ bind(L_skip_barrier);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void LIR_Assembler::osr_entry() {
    // On-stack-replacement entry sequence (interpreter frame layout described in interpreter_sparc.cpp):
    //
    //   1. Create a new compiled activation.
    //   2. Initialize local variables in the compiled activation. The expression stack must be empty
</pre>
<hr />
<pre>
<span class="line-old-header">*** 879,11 ***</span>
    Register disp_reg = Z_R0;
    int disp_value = addr-&gt;disp();
    bool needs_patching = (patch_code != lir_patch_none);
  
    if (addr-&gt;base()-&gt;type() == T_OBJECT) {
<span class="line-modified">!     __ verify_oop(src);</span>
    }
  
    PatchingStub* patch = NULL;
    if (needs_patching) {
      patch = new PatchingStub(_masm, PatchingStub::access_field_id);
<span class="line-new-header">--- 894,11 ---</span>
    Register disp_reg = Z_R0;
    int disp_value = addr-&gt;disp();
    bool needs_patching = (patch_code != lir_patch_none);
  
    if (addr-&gt;base()-&gt;type() == T_OBJECT) {
<span class="line-modified">!     __ verify_oop(src, FILE_AND_LINE);</span>
    }
  
    PatchingStub* patch = NULL;
    if (needs_patching) {
      patch = new PatchingStub(_masm, PatchingStub::access_field_id);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 954,10 ***</span>
<span class="line-new-header">--- 969,11 ---</span>
          __ z_llgf(dest-&gt;as_register(), disp_value, disp_reg, src);
          __ oop_decoder(dest-&gt;as_register(), dest-&gt;as_register(), true);
        } else {
          __ z_lg(dest-&gt;as_register(), disp_value, disp_reg, src);
        }
<span class="line-added">+       __ verify_oop(dest-&gt;as_register(), FILE_AND_LINE);</span>
        break;
      }
      case T_FLOAT:
        if (short_disp) {
                      __ z_le(dest-&gt;as_float_reg(),  disp_value, disp_reg, src);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 973,13 ***</span>
        }
        break;
      case T_LONG  :  __ z_lg(dest-&gt;as_register_lo(), disp_value, disp_reg, src); break;
      default      : ShouldNotReachHere();
    }
<span class="line-removed">-   if (type == T_ARRAY || type == T_OBJECT) {</span>
<span class="line-removed">-     __ verify_oop(dest-&gt;as_register());</span>
<span class="line-removed">-   }</span>
  
    if (patch != NULL) {
      patching_epilog(patch, patch_code, src, info);
    }
    if (info != NULL) add_debug_info_for_null_check(offset, info);
<span class="line-new-header">--- 989,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 988,14 ***</span>
  void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
    assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
    assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
  
    if (dest-&gt;is_single_cpu()) {
<span class="line-modified">!     if (type == T_ARRAY || type == T_OBJECT) {</span>
        __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), true);
<span class="line-modified">!       __ verify_oop(dest-&gt;as_register());</span>
<span class="line-modified">!     } else if (type == T_METADATA) {</span>
        __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), true);
      } else {
        __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), false);
      }
    } else if (dest-&gt;is_double_cpu()) {
<span class="line-new-header">--- 1001,14 ---</span>
  void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
    assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
    assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
  
    if (dest-&gt;is_single_cpu()) {
<span class="line-modified">!     if (is_reference_type(type)) {</span>
        __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), true);
<span class="line-modified">!       __ verify_oop(dest-&gt;as_register(), FILE_AND_LINE);</span>
<span class="line-modified">!     } else if (type == T_METADATA || type == T_ADDRESS) {</span>
        __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), true);
      } else {
        __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), false);
      }
    } else if (dest-&gt;is_double_cpu()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1016,14 ***</span>
    assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
    assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
  
    if (src-&gt;is_single_cpu()) {
      const Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
<span class="line-modified">!     if (type == T_OBJECT || type == T_ARRAY) {</span>
<span class="line-modified">!       __ verify_oop(src-&gt;as_register());</span>
        __ reg2mem_opt(src-&gt;as_register(), dst, true);
<span class="line-modified">!     } else if (type == T_METADATA) {</span>
        __ reg2mem_opt(src-&gt;as_register(), dst, true);
      } else {
        __ reg2mem_opt(src-&gt;as_register(), dst, false);
      }
    } else if (src-&gt;is_double_cpu()) {
<span class="line-new-header">--- 1029,14 ---</span>
    assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
    assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
  
    if (src-&gt;is_single_cpu()) {
      const Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
<span class="line-modified">!     if (is_reference_type(type)) {</span>
<span class="line-modified">!       __ verify_oop(src-&gt;as_register(), FILE_AND_LINE);</span>
        __ reg2mem_opt(src-&gt;as_register(), dst, true);
<span class="line-modified">!     } else if (type == T_METADATA || type == T_ADDRESS) {</span>
        __ reg2mem_opt(src-&gt;as_register(), dst, true);
      } else {
        __ reg2mem_opt(src-&gt;as_register(), dst, false);
      }
    } else if (src-&gt;is_double_cpu()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1062,12 ***</span>
        __ z_lgr(to_reg-&gt;as_register(), from_reg-&gt;as_register());
      }
    } else {
      ShouldNotReachHere();
    }
<span class="line-modified">!   if (to_reg-&gt;type() == T_OBJECT || to_reg-&gt;type() == T_ARRAY) {</span>
<span class="line-modified">!     __ verify_oop(to_reg-&gt;as_register());</span>
    }
  }
  
  void LIR_Assembler::reg2mem(LIR_Opr from, LIR_Opr dest_opr, BasicType type,
                              LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
<span class="line-new-header">--- 1075,12 ---</span>
        __ z_lgr(to_reg-&gt;as_register(), from_reg-&gt;as_register());
      }
    } else {
      ShouldNotReachHere();
    }
<span class="line-modified">!   if (is_reference_type(to_reg-&gt;type())) {</span>
<span class="line-modified">!     __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);</span>
    }
  }
  
  void LIR_Assembler::reg2mem(LIR_Opr from, LIR_Opr dest_opr, BasicType type,
                              LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1079,11 ***</span>
    Register disp_reg = Z_R0;
    int disp_value = addr-&gt;disp();
    bool needs_patching = (patch_code != lir_patch_none);
  
    if (addr-&gt;base()-&gt;is_oop_register()) {
<span class="line-modified">!     __ verify_oop(dest);</span>
    }
  
    PatchingStub* patch = NULL;
    if (needs_patching) {
      patch = new PatchingStub(_masm, PatchingStub::access_field_id);
<span class="line-new-header">--- 1092,11 ---</span>
    Register disp_reg = Z_R0;
    int disp_value = addr-&gt;disp();
    bool needs_patching = (patch_code != lir_patch_none);
  
    if (addr-&gt;base()-&gt;is_oop_register()) {
<span class="line-modified">!     __ verify_oop(dest, FILE_AND_LINE);</span>
    }
  
    PatchingStub* patch = NULL;
    if (needs_patching) {
      patch = new PatchingStub(_masm, PatchingStub::access_field_id);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1113,12 ***</span>
      disp_reg = addr-&gt;index()-&gt;as_pointer_register();
    }
  
    assert(disp_reg != Z_R0 || Immediate::is_simm20(disp_value), &quot;should have set this up&quot;);
  
<span class="line-modified">!   if (type == T_ARRAY || type == T_OBJECT) {</span>
<span class="line-modified">!     __ verify_oop(from-&gt;as_register());</span>
    }
  
    bool short_disp = Immediate::is_uimm12(disp_value);
  
    // Remember the offset of the store. The patching_epilog must be done
<span class="line-new-header">--- 1126,12 ---</span>
      disp_reg = addr-&gt;index()-&gt;as_pointer_register();
    }
  
    assert(disp_reg != Z_R0 || Immediate::is_simm20(disp_value), &quot;should have set this up&quot;);
  
<span class="line-modified">!   if (is_reference_type(type)) {</span>
<span class="line-modified">!     __ verify_oop(from-&gt;as_register(), FILE_AND_LINE);</span>
    }
  
    bool short_disp = Immediate::is_uimm12(disp_value);
  
    // Remember the offset of the store. The patching_epilog must be done
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1276,23 ***</span>
    bool unsigned_comp = condition == lir_cond_belowEqual || condition == lir_cond_aboveEqual;
    if (opr1-&gt;is_single_cpu()) {
      Register reg1 = opr1-&gt;as_register();
      if (opr2-&gt;is_single_cpu()) {
        // cpu register - cpu register
<span class="line-modified">!       if (opr1-&gt;type() == T_OBJECT || opr1-&gt;type() == T_ARRAY) {</span>
          __ z_clgr(reg1, opr2-&gt;as_register());
        } else {
<span class="line-modified">!         assert(opr2-&gt;type() != T_OBJECT &amp;&amp; opr2-&gt;type() != T_ARRAY, &quot;cmp int, oop?&quot;);</span>
          if (unsigned_comp) {
            __ z_clr(reg1, opr2-&gt;as_register());
          } else {
            __ z_cr(reg1, opr2-&gt;as_register());
          }
        }
      } else if (opr2-&gt;is_stack()) {
        // cpu register - stack
<span class="line-modified">!       if (opr1-&gt;type() == T_OBJECT || opr1-&gt;type() == T_ARRAY) {</span>
          __ z_cg(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
        } else {
          if (unsigned_comp) {
            __ z_cly(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
          } else {
<span class="line-new-header">--- 1289,23 ---</span>
    bool unsigned_comp = condition == lir_cond_belowEqual || condition == lir_cond_aboveEqual;
    if (opr1-&gt;is_single_cpu()) {
      Register reg1 = opr1-&gt;as_register();
      if (opr2-&gt;is_single_cpu()) {
        // cpu register - cpu register
<span class="line-modified">!       if (is_reference_type(opr1-&gt;type())) {</span>
          __ z_clgr(reg1, opr2-&gt;as_register());
        } else {
<span class="line-modified">!         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);</span>
          if (unsigned_comp) {
            __ z_clr(reg1, opr2-&gt;as_register());
          } else {
            __ z_cr(reg1, opr2-&gt;as_register());
          }
        }
      } else if (opr2-&gt;is_stack()) {
        // cpu register - stack
<span class="line-modified">!       if (is_reference_type(opr1-&gt;type())) {</span>
          __ z_cg(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
        } else {
          if (unsigned_comp) {
            __ z_cly(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1306,11 ***</span>
          if (unsigned_comp) {
            __ z_clfi(reg1, c-&gt;as_jint());
          } else {
            __ z_cfi(reg1, c-&gt;as_jint());
          }
<span class="line-modified">!       } else if (c-&gt;type() == T_OBJECT || c-&gt;type() == T_ARRAY) {</span>
          // In 64bit oops are single register.
          jobject o = c-&gt;as_jobject();
          if (o == NULL) {
            __ z_ltgr(reg1, reg1);
          } else {
<span class="line-new-header">--- 1319,20 ---</span>
          if (unsigned_comp) {
            __ z_clfi(reg1, c-&gt;as_jint());
          } else {
            __ z_cfi(reg1, c-&gt;as_jint());
          }
<span class="line-modified">!       } else if (c-&gt;type() == T_METADATA) {</span>
<span class="line-added">+         // We only need, for now, comparison with NULL for metadata.</span>
<span class="line-added">+         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);</span>
<span class="line-added">+         Metadata* m = c-&gt;as_metadata();</span>
<span class="line-added">+         if (m == NULL) {</span>
<span class="line-added">+           __ z_cghi(reg1, 0);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           ShouldNotReachHere();</span>
<span class="line-added">+         }</span>
<span class="line-added">+       } else if (is_reference_type(c-&gt;type())) {</span>
          // In 64bit oops are single register.
          jobject o = c-&gt;as_jobject();
          if (o == NULL) {
            __ z_ltgr(reg1, reg1);
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1675,14 ***</span>
    } else {
      ShouldNotReachHere();
    }
  }
  
<span class="line-removed">- void LIR_Assembler::fpop() {</span>
<span class="line-removed">-   // do nothing</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
    switch (code) {
      case lir_sqrt: {
        assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for dsqrt&quot;);
        FloatRegister src_reg = value-&gt;as_double_reg();
<span class="line-new-header">--- 1697,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1749,11 ***</span>
            break;
          default: ShouldNotReachHere();
        }
      } else {
        Register r_lo;
<span class="line-modified">!       if (right-&gt;type() == T_OBJECT || right-&gt;type() == T_ARRAY) {</span>
          r_lo = right-&gt;as_register();
        } else {
          r_lo = right-&gt;as_register_lo();
        }
        switch (code) {
<span class="line-new-header">--- 1767,11 ---</span>
            break;
          default: ShouldNotReachHere();
        }
      } else {
        Register r_lo;
<span class="line-modified">!       if (is_reference_type(right-&gt;type())) {</span>
          r_lo = right-&gt;as_register();
        } else {
          r_lo = right-&gt;as_register_lo();
        }
        switch (code) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1779,11 ***</span>
  // See operand selection in LIRGenerator::do_ArithmeticOp_Int().
  void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
    if (left-&gt;is_double_cpu()) {
      // 64 bit integer case
      assert(left-&gt;is_double_cpu(), &quot;left must be register&quot;);
<span class="line-modified">!     assert(right-&gt;is_double_cpu() || is_power_of_2_long(right-&gt;as_jlong()),</span>
             &quot;right must be register or power of 2 constant&quot;);
      assert(result-&gt;is_double_cpu(), &quot;result must be register&quot;);
  
      Register lreg = left-&gt;as_register_lo();
      Register dreg = result-&gt;as_register_lo();
<span class="line-new-header">--- 1797,11 ---</span>
  // See operand selection in LIRGenerator::do_ArithmeticOp_Int().
  void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
    if (left-&gt;is_double_cpu()) {
      // 64 bit integer case
      assert(left-&gt;is_double_cpu(), &quot;left must be register&quot;);
<span class="line-modified">!     assert(right-&gt;is_double_cpu() || is_power_of_2(right-&gt;as_jlong()),</span>
             &quot;right must be register or power of 2 constant&quot;);
      assert(result-&gt;is_double_cpu(), &quot;result must be register&quot;);
  
      Register lreg = left-&gt;as_register_lo();
      Register dreg = result-&gt;as_register_lo();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1967,11 ***</span>
        __ branch_optimized(Assembler::bcondAlways, *stub-&gt;entry());
        __ bind(*stub-&gt;continuation());
        return;
      }
  
<span class="line-removed">-     Label done;</span>
      // Save outgoing arguments in callee saved registers (C convention) in case
      // a call to System.arraycopy is needed.
      Register callee_saved_src     = Z_R10;
      Register callee_saved_src_pos = Z_R11;
      Register callee_saved_dst     = Z_R12;
<span class="line-new-header">--- 1985,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2139,11 ***</span>
        __ check_klass_subtype_fast_path(src_klass, dst_klass, tmp, &amp;cont, &amp;slow, NULL);
  
        store_parameter(src_klass, 0); // sub
        store_parameter(dst_klass, 1); // super
        emit_call_c(Runtime1::entry_for (Runtime1::slow_subtype_check_id));
<span class="line-modified">!       CHECK_BAILOUT();</span>
        // Sets condition code 0 for match (2 otherwise).
        __ branch_optimized(Assembler::bcondEqual, cont);
  
        __ bind(slow);
  
<span class="line-new-header">--- 2156,11 ---</span>
        __ check_klass_subtype_fast_path(src_klass, dst_klass, tmp, &amp;cont, &amp;slow, NULL);
  
        store_parameter(src_klass, 0); // sub
        store_parameter(dst_klass, 1); // super
        emit_call_c(Runtime1::entry_for (Runtime1::slow_subtype_check_id));
<span class="line-modified">!       CHECK_BAILOUT2(cont, slow);</span>
        // Sets condition code 0 for match (2 otherwise).
        __ branch_optimized(Assembler::bcondEqual, cont);
  
        __ bind(slow);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2198,11 ***</span>
  
          __ load_klass(Z_ARG5, dst);
          __ z_lg(Z_ARG5, Address(Z_ARG5, ObjArrayKlass::element_klass_offset()));
          __ z_lg(Z_ARG4, Address(Z_ARG5, Klass::super_check_offset_offset()));
          emit_call_c(copyfunc_addr);
<span class="line-modified">!         CHECK_BAILOUT();</span>
  
  #ifndef PRODUCT
          if (PrintC1Statistics) {
            NearLabel failed;
            __ compareU32_and_branch(Z_RET, (intptr_t)0, Assembler::bcondNotEqual, failed);
<span class="line-new-header">--- 2215,11 ---</span>
  
          __ load_klass(Z_ARG5, dst);
          __ z_lg(Z_ARG5, Address(Z_ARG5, ObjArrayKlass::element_klass_offset()));
          __ z_lg(Z_ARG4, Address(Z_ARG5, Klass::super_check_offset_offset()));
          emit_call_c(copyfunc_addr);
<span class="line-modified">!         CHECK_BAILOUT2(cont, slow);</span>
  
  #ifndef PRODUCT
          if (PrintC1Statistics) {
            NearLabel failed;
            __ compareU32_and_branch(Z_RET, (intptr_t)0, Assembler::bcondNotEqual, failed);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2388,20 ***</span>
                       op-&gt;header_size(),
                       op-&gt;object_size(),
                       op-&gt;klass()-&gt;as_register(),
                       *op-&gt;stub()-&gt;entry());
    __ bind(*op-&gt;stub()-&gt;continuation());
<span class="line-modified">!   __ verify_oop(op-&gt;obj()-&gt;as_register());</span>
  }
  
  void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
    Register len = op-&gt;len()-&gt;as_register();
    __ move_reg_if_needed(len, T_LONG, len, T_INT); // sign extend
  
    if (UseSlowPath ||
<span class="line-modified">!       (!UseFastNewObjectArray &amp;&amp; (op-&gt;type() == T_OBJECT || op-&gt;type() == T_ARRAY)) ||</span>
<span class="line-modified">!       (!UseFastNewTypeArray   &amp;&amp; (op-&gt;type() != T_OBJECT &amp;&amp; op-&gt;type() != T_ARRAY))) {</span>
      __ z_brul(*op-&gt;stub()-&gt;entry());
    } else {
      __ allocate_array(op-&gt;obj()-&gt;as_register(),
                        op-&gt;len()-&gt;as_register(),
                        op-&gt;tmp1()-&gt;as_register(),
<span class="line-new-header">--- 2405,20 ---</span>
                       op-&gt;header_size(),
                       op-&gt;object_size(),
                       op-&gt;klass()-&gt;as_register(),
                       *op-&gt;stub()-&gt;entry());
    __ bind(*op-&gt;stub()-&gt;continuation());
<span class="line-modified">!   __ verify_oop(op-&gt;obj()-&gt;as_register(), FILE_AND_LINE);</span>
  }
  
  void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
    Register len = op-&gt;len()-&gt;as_register();
    __ move_reg_if_needed(len, T_LONG, len, T_INT); // sign extend
  
    if (UseSlowPath ||
<span class="line-modified">!       (!UseFastNewObjectArray &amp;&amp; (is_reference_type(op-&gt;type()))) ||</span>
<span class="line-modified">!       (!UseFastNewTypeArray   &amp;&amp; (!is_reference_type(op-&gt;type())))) {</span>
      __ z_brul(*op-&gt;stub()-&gt;entry());
    } else {
      __ allocate_array(op-&gt;obj()-&gt;as_register(),
                        op-&gt;len()-&gt;as_register(),
                        op-&gt;tmp1()-&gt;as_register(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2524,11 ***</span>
    } else {
      klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
    }
    assert(obj != k_RInfo, &quot;must be different&quot;);
  
<span class="line-modified">!   __ verify_oop(obj);</span>
  
    // Get object class.
    // Not a safepoint as obj null check happens earlier.
    if (op-&gt;fast_check()) {
      if (UseCompressedClassPointers) {
<span class="line-new-header">--- 2541,11 ---</span>
    } else {
      klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
    }
    assert(obj != k_RInfo, &quot;must be different&quot;);
  
<span class="line-modified">!   __ verify_oop(obj, FILE_AND_LINE);</span>
  
    // Get object class.
    // Not a safepoint as obj null check happens earlier.
    if (op-&gt;fast_check()) {
      if (UseCompressedClassPointers) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2553,11 ***</span>
        // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
        address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
        store_parameter(klass_RInfo, 0); // sub
        store_parameter(k_RInfo, 1);     // super
        emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
<span class="line-modified">!       CHECK_BAILOUT();</span>
        __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
        // Fall through to success case.
      }
    }
  
<span class="line-new-header">--- 2570,11 ---</span>
        // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
        address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
        store_parameter(klass_RInfo, 0); // sub
        store_parameter(k_RInfo, 1);     // super
        emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
<span class="line-modified">!       CHECK_BAILOUT2(profile_cast_failure, profile_cast_success);</span>
        __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
        // Fall through to success case.
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2636,11 ***</span>
      // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
      address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
      store_parameter(klass_RInfo, 0); // sub
      store_parameter(k_RInfo, 1);     // super
      emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
<span class="line-modified">!     CHECK_BAILOUT();</span>
      __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
      // Fall through to success case.
  
      if (op-&gt;should_profile()) {
        Register mdo = klass_RInfo, recv = k_RInfo;
<span class="line-new-header">--- 2653,11 ---</span>
      // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
      address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
      store_parameter(klass_RInfo, 0); // sub
      store_parameter(k_RInfo, 1);     // super
      emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
<span class="line-modified">!     CHECK_BAILOUT3(profile_cast_success, profile_cast_failure, done);</span>
      __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
      // Fall through to success case.
  
      if (op-&gt;should_profile()) {
        Register mdo = klass_RInfo, recv = k_RInfo;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2717,18 ***</span>
    } else {
      ShouldNotReachHere(); // new lir_cas_??
    }
  }
  
<span class="line-removed">- void LIR_Assembler::set_24bit_FPU() {</span>
<span class="line-removed">-   ShouldNotCallThis(); // x86 only</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::reset_FPU() {</span>
<span class="line-removed">-   ShouldNotCallThis(); // x86 only</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void LIR_Assembler::breakpoint() {
    Unimplemented();
    //  __ breakpoint_trap();
  }
  
<span class="line-new-header">--- 2734,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2865,22 ***</span>
      assert(left-&gt;is_double_cpu(), &quot;Must be a long&quot;);
      __ z_lcgr(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
    }
  }
  
<span class="line-removed">- void LIR_Assembler::fxch(int i) {</span>
<span class="line-removed">-   ShouldNotCallThis(); // x86 only</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::fld(int i) {</span>
<span class="line-removed">-   ShouldNotCallThis(); // x86 only</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void LIR_Assembler::ffree(int i) {</span>
<span class="line-removed">-   ShouldNotCallThis(); // x86 only</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void LIR_Assembler::rt_call(LIR_Opr result, address dest,
                              const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
    assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
    emit_call_c(dest);
    CHECK_BAILOUT();
<span class="line-new-header">--- 2874,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2985,11 ***</span>
    bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
  
    assert(do_null || do_update, &quot;why are we here?&quot;);
    assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
  
<span class="line-modified">!   __ verify_oop(obj);</span>
  
    if (do_null || tmp1 != obj DEBUG_ONLY(|| true)) {
      __ z_ltgr(tmp1, obj);
    }
    if (do_null) {
<span class="line-new-header">--- 2982,11 ---</span>
    bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
  
    assert(do_null || do_update, &quot;why are we here?&quot;);
    assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
  
<span class="line-modified">!   __ verify_oop(obj, FILE_AND_LINE);</span>
  
    if (do_null || tmp1 != obj DEBUG_ONLY(|| true)) {
      __ z_ltgr(tmp1, obj);
    }
    if (do_null) {
</pre>
<center><a href="c1_FrameMap_s390.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_s390.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/c1_LIRGenerator_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2016, 2017, SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;c1/c1_Compilation.hpp&quot;
  28 #include &quot;c1/c1_FrameMap.hpp&quot;
  29 #include &quot;c1/c1_Instruction.hpp&quot;
  30 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  32 #include &quot;c1/c1_Runtime1.hpp&quot;
  33 #include &quot;c1/c1_ValueStack.hpp&quot;
  34 #include &quot;ci/ciArray.hpp&quot;
  35 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  36 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  37 #include &quot;runtime/sharedRuntime.hpp&quot;
  38 #include &quot;runtime/stubRoutines.hpp&quot;
  39 #include &quot;vmreg_s390.inline.hpp&quot;
<a name="1" id="anc1"></a>
  40 
  41 #ifdef ASSERT
  42 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  43 #else
  44 #define __ gen()-&gt;lir()-&gt;
  45 #endif
  46 
  47 void LIRItem::load_byte_item() {
  48   // Byte loads use same registers as other loads.
  49   load_item();
  50 }
  51 
  52 void LIRItem::load_nonconstant(int bits) {
  53   LIR_Opr r = value()-&gt;operand();
  54   if (_gen-&gt;can_inline_as_constant(value(), bits)) {
  55     if (!r-&gt;is_constant()) {
  56       r = LIR_OprFact::value_type(value()-&gt;type());
  57     }
  58     _result = r;
  59   } else {
  60     load_item();
  61   }
  62 }
  63 
  64 //--------------------------------------------------------------
  65 //               LIRGenerator
  66 //--------------------------------------------------------------
  67 
  68 LIR_Opr LIRGenerator::exceptionOopOpr() { return FrameMap::as_oop_opr(Z_EXC_OOP); }
  69 LIR_Opr LIRGenerator::exceptionPcOpr()  { return FrameMap::as_opr(Z_EXC_PC); }
  70 LIR_Opr LIRGenerator::divInOpr()        { return FrameMap::Z_R11_opr; }
  71 LIR_Opr LIRGenerator::divOutOpr()       { return FrameMap::Z_R11_opr; }
  72 LIR_Opr LIRGenerator::remOutOpr()       { return FrameMap::Z_R10_opr; }
  73 LIR_Opr LIRGenerator::ldivInOpr()       { return FrameMap::Z_R11_long_opr; }
  74 LIR_Opr LIRGenerator::ldivOutOpr()      { return FrameMap::Z_R11_long_opr; }
  75 LIR_Opr LIRGenerator::lremOutOpr()      { return FrameMap::Z_R10_long_opr; }
  76 LIR_Opr LIRGenerator::syncLockOpr()     { return new_register(T_INT); }
  77 LIR_Opr LIRGenerator::syncTempOpr()     { return FrameMap::Z_R13_opr; }
  78 LIR_Opr LIRGenerator::getThreadTemp()   { return LIR_OprFact::illegalOpr; }
  79 
  80 LIR_Opr LIRGenerator::result_register_for (ValueType* type, bool callee) {
  81   LIR_Opr opr;
  82   switch (type-&gt;tag()) {
  83     case intTag:    opr = FrameMap::Z_R2_opr;        break;
  84     case objectTag: opr = FrameMap::Z_R2_oop_opr;    break;
  85     case longTag:   opr = FrameMap::Z_R2_long_opr;   break;
  86     case floatTag:  opr = FrameMap::Z_F0_opr;        break;
  87     case doubleTag: opr = FrameMap::Z_F0_double_opr; break;
  88 
  89     case addressTag:
  90     default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
  91   }
  92 
  93   assert(opr-&gt;type_field() == as_OprType(as_BasicType(type)), &quot;type mismatch&quot;);
  94   return opr;
  95 }
  96 
  97 LIR_Opr LIRGenerator::rlock_byte(BasicType type) {
  98   return new_register(T_INT);
  99 }
 100 
 101 //--------- Loading items into registers. --------------------------------
 102 
 103 // z/Architecture cannot inline all constants.
 104 bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {
 105   if (v-&gt;type()-&gt;as_IntConstant() != NULL) {
 106     return Immediate::is_simm16(v-&gt;type()-&gt;as_IntConstant()-&gt;value());
 107   } else if (v-&gt;type()-&gt;as_LongConstant() != NULL) {
 108     return Immediate::is_simm16(v-&gt;type()-&gt;as_LongConstant()-&gt;value());
 109   } else if (v-&gt;type()-&gt;as_ObjectConstant() != NULL) {
 110     return v-&gt;type()-&gt;as_ObjectConstant()-&gt;value()-&gt;is_null_object();
 111   } else {
 112     return false;
 113   }
 114 }
 115 
 116 bool LIRGenerator::can_inline_as_constant(Value i, int bits) const {
 117   if (i-&gt;type()-&gt;as_IntConstant() != NULL) {
 118     return Assembler::is_simm(i-&gt;type()-&gt;as_IntConstant()-&gt;value(), bits);
 119   } else if (i-&gt;type()-&gt;as_LongConstant() != NULL) {
 120     return Assembler::is_simm(i-&gt;type()-&gt;as_LongConstant()-&gt;value(), bits);
 121   } else {
 122     return can_store_as_constant(i, as_BasicType(i-&gt;type()));
 123   }
 124 }
 125 
 126 bool LIRGenerator::can_inline_as_constant(LIR_Const* c) const {
 127   if (c-&gt;type() == T_INT) {
 128     return Immediate::is_simm20(c-&gt;as_jint());
 129   } else   if (c-&gt;type() == T_LONG) {
 130     return Immediate::is_simm20(c-&gt;as_jlong());
 131   }
 132   return false;
 133 }
 134 
 135 LIR_Opr LIRGenerator::safepoint_poll_register() {
 136   return new_register(longType);
 137 }
 138 
 139 LIR_Address* LIRGenerator::generate_address(LIR_Opr base, LIR_Opr index,
 140                                             int shift, int disp, BasicType type) {
 141   assert(base-&gt;is_register(), &quot;must be&quot;);
 142   if (index-&gt;is_constant()) {
 143     intx large_disp = disp;
 144     LIR_Const *constant = index-&gt;as_constant_ptr();
 145     if (constant-&gt;type() == T_LONG) {
 146       large_disp += constant-&gt;as_jlong() &lt;&lt; shift;
 147     } else {
 148       large_disp += (intx)(constant-&gt;as_jint()) &lt;&lt; shift;
 149     }
 150     if (Displacement::is_validDisp(large_disp)) {
 151       return new LIR_Address(base, large_disp, type);
 152     }
 153     // Index is illegal so replace it with the displacement loaded into a register.
 154     index = new_pointer_register();
 155     __ move(LIR_OprFact::intptrConst(large_disp), index);
 156     return new LIR_Address(base, index, type);
 157   } else {
 158     if (shift &gt; 0) {
 159       LIR_Opr tmp = new_pointer_register();
 160       __ shift_left(index, shift, tmp);
 161       index = tmp;
 162     }
 163     return new LIR_Address(base, index, disp, type);
 164   }
 165 }
 166 
 167 LIR_Address* LIRGenerator::emit_array_address(LIR_Opr array_opr, LIR_Opr index_opr,
 168                                               BasicType type) {
 169   int elem_size = type2aelembytes(type);
 170   int shift = exact_log2(elem_size);
 171   int offset_in_bytes = arrayOopDesc::base_offset_in_bytes(type);
 172 
 173   LIR_Address* addr;
 174   if (index_opr-&gt;is_constant()) {
 175     addr = new LIR_Address(array_opr,
 176                            offset_in_bytes + (intx)(index_opr-&gt;as_jint()) * elem_size, type);
 177   } else {
 178     if (index_opr-&gt;type() == T_INT) {
 179       LIR_Opr tmp = new_register(T_LONG);
 180       __ convert(Bytecodes::_i2l, index_opr, tmp);
 181       index_opr = tmp;
 182     }
 183     if (shift &gt; 0) {
 184       __ shift_left(index_opr, shift, index_opr);
 185     }
 186     addr = new LIR_Address(array_opr,
 187                            index_opr,
 188                            offset_in_bytes, type);
 189   }
 190   return addr;
 191 }
 192 
 193 LIR_Opr LIRGenerator::load_immediate(int x, BasicType type) {
 194   LIR_Opr r = LIR_OprFact::illegalOpr;
 195   if (type == T_LONG) {
 196     r = LIR_OprFact::longConst(x);
 197   } else if (type == T_INT) {
 198     r = LIR_OprFact::intConst(x);
 199   } else {
 200     ShouldNotReachHere();
 201   }
 202   return r;
 203 }
 204 
 205 void LIRGenerator::increment_counter(address counter, BasicType type, int step) {
 206   LIR_Opr pointer = new_pointer_register();
 207   __ move(LIR_OprFact::intptrConst(counter), pointer);
 208   LIR_Address* addr = new LIR_Address(pointer, type);
 209   increment_counter(addr, step);
 210 }
 211 
 212 void LIRGenerator::increment_counter(LIR_Address* addr, int step) {
 213   __ add((LIR_Opr)addr, LIR_OprFact::intConst(step), (LIR_Opr)addr);
 214 }
 215 
 216 void LIRGenerator::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
 217   LIR_Opr scratch = FrameMap::Z_R1_opr;
 218   __ load(new LIR_Address(base, disp, T_INT), scratch, info);
 219   __ cmp(condition, scratch, c);
 220 }
 221 
 222 void LIRGenerator::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Opr base, int disp, BasicType type, CodeEmitInfo* info) {
 223   __ cmp_reg_mem(condition, reg, new LIR_Address(base, disp, type), info);
 224 }
 225 
 226 bool LIRGenerator::strength_reduce_multiply(LIR_Opr left, int c, LIR_Opr result, LIR_Opr tmp) {
 227   if (tmp-&gt;is_valid()) {
 228     if (is_power_of_2(c + 1)) {
 229       __ move(left, tmp);
 230       __ shift_left(left, log2_int(c + 1), left);
 231       __ sub(left, tmp, result);
 232       return true;
 233     } else if (is_power_of_2(c - 1)) {
 234       __ move(left, tmp);
 235       __ shift_left(left, log2_int(c - 1), left);
 236       __ add(left, tmp, result);
 237       return true;
 238     }
 239   }
 240   return false;
 241 }
 242 
 243 void LIRGenerator::store_stack_parameter (LIR_Opr item, ByteSize offset_from_sp) {
 244   BasicType type = item-&gt;type();
 245   __ store(item, new LIR_Address(FrameMap::Z_SP_opr, in_bytes(offset_from_sp), type));
 246 }
 247 
 248 //----------------------------------------------------------------------
 249 //             visitor functions
 250 //----------------------------------------------------------------------
 251 
 252 void LIRGenerator::array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci) {
 253   LIR_Opr tmp1 = new_register(objectType);
 254   LIR_Opr tmp2 = new_register(objectType);
 255   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
 256   __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 257 }
 258 
 259 void LIRGenerator::do_MonitorEnter(MonitorEnter* x) {
 260   assert(x-&gt;is_pinned(),&quot;&quot;);
 261   LIRItem obj(x-&gt;obj(), this);
 262   obj.load_item();
 263 
 264   set_no_result(x);
 265 
 266   // &quot;lock&quot; stores the address of the monitor stack slot, so this is not an oop.
 267   LIR_Opr lock = new_register(T_INT);
 268 
 269   CodeEmitInfo* info_for_exception = NULL;
 270   if (x-&gt;needs_null_check()) {
 271     info_for_exception = state_for (x);
 272   }
 273   // This CodeEmitInfo must not have the xhandlers because here the
 274   // object is already locked (xhandlers expect object to be unlocked).
 275   CodeEmitInfo* info = state_for (x, x-&gt;state(), true);
 276   monitor_enter(obj.result(), lock, syncTempOpr(), LIR_OprFact::illegalOpr,
 277                 x-&gt;monitor_no(), info_for_exception, info);
 278 }
 279 
 280 void LIRGenerator::do_MonitorExit(MonitorExit* x) {
 281   assert(x-&gt;is_pinned(),&quot;&quot;);
 282 
 283   LIRItem obj(x-&gt;obj(), this);
 284   obj.dont_load_item();
 285 
 286   LIR_Opr lock = new_register(T_INT);
 287   LIR_Opr obj_temp = new_register(T_INT);
 288   set_no_result(x);
 289   monitor_exit(obj_temp, lock, syncTempOpr(), LIR_OprFact::illegalOpr, x-&gt;monitor_no());
 290 }
 291 
 292 // _ineg, _lneg, _fneg, _dneg
 293 void LIRGenerator::do_NegateOp(NegateOp* x) {
 294   LIRItem value(x-&gt;x(), this);
 295   value.load_item();
 296   LIR_Opr reg = rlock_result(x);
 297   __ negate(value.result(), reg);
 298 }
 299 
 300 // for _fadd, _fmul, _fsub, _fdiv, _frem
 301 //     _dadd, _dmul, _dsub, _ddiv, _drem
 302 void LIRGenerator::do_ArithmeticOp_FPU(ArithmeticOp* x) {
 303   LIRItem left(x-&gt;x(),  this);
 304   LIRItem right(x-&gt;y(), this);
 305   LIRItem* left_arg  = &amp;left;
 306   LIRItem* right_arg = &amp;right;
 307   assert(!left.is_stack(), &quot;can&#39;t both be memory operands&quot;);
 308   left.load_item();
 309 
 310   if (right.is_register() || right.is_constant()) {
 311     right.load_item();
 312   } else {
 313     right.dont_load_item();
 314   }
 315 
 316   if ((x-&gt;op() == Bytecodes::_frem) || (x-&gt;op() == Bytecodes::_drem)) {
 317     address entry;
 318     switch (x-&gt;op()) {
 319     case Bytecodes::_frem:
 320       entry = CAST_FROM_FN_PTR(address, SharedRuntime::frem);
 321       break;
 322     case Bytecodes::_drem:
 323       entry = CAST_FROM_FN_PTR(address, SharedRuntime::drem);
 324       break;
 325     default:
 326       ShouldNotReachHere();
 327     }
 328     LIR_Opr result = call_runtime(x-&gt;x(), x-&gt;y(), entry, x-&gt;type(), NULL);
 329     set_result(x, result);
 330   } else {
 331     LIR_Opr reg = rlock(x);
 332     LIR_Opr tmp = LIR_OprFact::illegalOpr;
 333     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);
 334     set_result(x, reg);
 335   }
 336 }
 337 
 338 // for _ladd, _lmul, _lsub, _ldiv, _lrem
 339 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 340   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 341     // Use shifts if divisior is a power of 2 otherwise use DSGR instruction.
 342     // Instruction: DSGR R1, R2
 343     // input : R1+1: dividend   (R1, R1+1 designate a register pair, R1 must be even)
 344     //         R2:   divisor
 345     //
 346     // output: R1+1: quotient
 347     //         R1:   remainder
 348     //
 349     // Register selection: R1:   Z_R10
 350     //                     R1+1: Z_R11
 351     //                     R2:   to be chosen by register allocator (linear scan)
 352 
 353     // R1, and R1+1 will be destroyed.
 354 
 355     LIRItem right(x-&gt;y(), this);
 356     LIRItem left(x-&gt;x() , this);   // Visit left second, so that the is_register test is valid.
 357 
 358     // Call state_for before load_item_force because state_for may
 359     // force the evaluation of other instructions that are needed for
 360     // correct debug info. Otherwise the live range of the fix
 361     // register might be too long.
 362     CodeEmitInfo* info = state_for (x);
 363 
 364     LIR_Opr result = rlock_result(x);
 365     LIR_Opr result_reg = result;
 366     LIR_Opr tmp = LIR_OprFact::illegalOpr;
 367     LIR_Opr divisor_opr = right.result();
 368     if (divisor_opr-&gt;is_constant() &amp;&amp; is_power_of_2(divisor_opr-&gt;as_jlong())) {
 369       left.load_item();
 370       right.dont_load_item();
 371     } else {
 372       left.load_item_force(ldivInOpr());
 373       right.load_item();
 374 
 375       // DSGR instruction needs register pair.
 376       if (x-&gt;op() == Bytecodes::_ldiv) {
 377         result_reg = ldivOutOpr();
 378         tmp        = lremOutOpr();
 379       } else {
 380         result_reg = lremOutOpr();
 381         tmp        = ldivOutOpr();
 382       }
 383     }
 384 
 385     if (!ImplicitDiv0Checks) {
 386       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
 387       __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));
 388       // Idiv/irem cannot trap (passing info would generate an assertion).
 389       info = NULL;
 390     }
 391 
 392     if (x-&gt;op() == Bytecodes::_lrem) {
 393       __ irem(left.result(), right.result(), result_reg, tmp, info);
 394     } else if (x-&gt;op() == Bytecodes::_ldiv) {
 395       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 396     } else {
 397       ShouldNotReachHere();
 398     }
 399 
 400     if (result_reg != result) {
 401       __ move(result_reg, result);
 402     }
 403   } else {
 404     LIRItem left(x-&gt;x(), this);
 405     LIRItem right(x-&gt;y(), this);
 406 
 407     left.load_item();
 408     right.load_nonconstant(32);
 409     rlock_result(x);
 410     arithmetic_op_long(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), NULL);
 411   }
 412 }
 413 
 414 // for: _iadd, _imul, _isub, _idiv, _irem
 415 void LIRGenerator::do_ArithmeticOp_Int(ArithmeticOp* x) {
 416   if (x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem) {
 417     // Use shifts if divisior is a power of 2 otherwise use DSGFR instruction.
 418     // Instruction: DSGFR R1, R2
 419     // input : R1+1: dividend   (R1, R1+1 designate a register pair, R1 must be even)
 420     //         R2:   divisor
 421     //
 422     // output: R1+1: quotient
 423     //         R1:   remainder
 424     //
 425     // Register selection: R1:   Z_R10
 426     //                     R1+1: Z_R11
 427     //                     R2:   To be chosen by register allocator (linear scan).
 428 
 429     // R1, and R1+1 will be destroyed.
 430 
 431     LIRItem right(x-&gt;y(), this);
 432     LIRItem left(x-&gt;x() , this);   // Visit left second, so that the is_register test is valid.
 433 
 434     // Call state_for before load_item_force because state_for may
 435     // force the evaluation of other instructions that are needed for
 436     // correct debug info. Otherwise the live range of the fix
 437     // register might be too long.
 438     CodeEmitInfo* info = state_for (x);
 439 
 440     LIR_Opr result = rlock_result(x);
 441     LIR_Opr result_reg = result;
 442     LIR_Opr tmp = LIR_OprFact::illegalOpr;
 443     LIR_Opr divisor_opr = right.result();
 444     if (divisor_opr-&gt;is_constant() &amp;&amp; is_power_of_2(divisor_opr-&gt;as_jint())) {
 445       left.load_item();
 446       right.dont_load_item();
 447     } else {
 448       left.load_item_force(divInOpr());
 449       right.load_item();
 450 
 451       // DSGFR instruction needs register pair.
 452       if (x-&gt;op() == Bytecodes::_idiv) {
 453         result_reg = divOutOpr();
 454         tmp        = remOutOpr();
 455       } else {
 456         result_reg = remOutOpr();
 457         tmp        = divOutOpr();
 458       }
 459     }
 460 
 461     if (!ImplicitDiv0Checks) {
 462       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::intConst(0));
 463       __ branch(lir_cond_equal, T_INT, new DivByZeroStub(info));
 464       // Idiv/irem cannot trap (passing info would generate an assertion).
 465       info = NULL;
 466     }
 467 
 468     if (x-&gt;op() == Bytecodes::_irem) {
 469       __ irem(left.result(), right.result(), result_reg, tmp, info);
 470     } else if (x-&gt;op() == Bytecodes::_idiv) {
 471       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 472     } else {
 473       ShouldNotReachHere();
 474     }
 475 
 476     if (result_reg != result) {
 477       __ move(result_reg, result);
 478     }
 479   } else {
 480     LIRItem left(x-&gt;x(),  this);
 481     LIRItem right(x-&gt;y(), this);
 482     LIRItem* left_arg = &amp;left;
 483     LIRItem* right_arg = &amp;right;
 484     if (x-&gt;is_commutative() &amp;&amp; left.is_stack() &amp;&amp; right.is_register()) {
 485       // swap them if left is real stack (or cached) and right is real register(not cached)
 486       left_arg = &amp;right;
 487       right_arg = &amp;left;
 488     }
 489 
 490     left_arg-&gt;load_item();
 491 
 492     // Do not need to load right, as we can handle stack and constants.
 493     if (x-&gt;op() == Bytecodes::_imul) {
 494       bool use_tmp = false;
 495       if (right_arg-&gt;is_constant()) {
 496         int iconst = right_arg-&gt;get_jint_constant();
 497         if (is_power_of_2(iconst - 1) || is_power_of_2(iconst + 1)) {
 498           use_tmp = true;
 499         }
 500       }
 501       right_arg-&gt;dont_load_item();
 502       LIR_Opr tmp = LIR_OprFact::illegalOpr;
 503       if (use_tmp) {
 504         tmp = new_register(T_INT);
 505       }
 506       rlock_result(x);
 507 
 508       arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), tmp);
 509     } else {
 510       right_arg-&gt;dont_load_item();
 511       rlock_result(x);
 512       LIR_Opr tmp = LIR_OprFact::illegalOpr;
 513       arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), tmp);
 514     }
 515   }
 516 }
 517 
 518 void LIRGenerator::do_ArithmeticOp(ArithmeticOp* x) {
 519   // If an operand with use count 1 is the left operand, then it is
 520   // likely that no move for 2-operand-LIR-form is necessary.
 521   if (x-&gt;is_commutative() &amp;&amp; x-&gt;y()-&gt;as_Constant() == NULL &amp;&amp; x-&gt;x()-&gt;use_count() &gt; x-&gt;y()-&gt;use_count()) {
 522     x-&gt;swap_operands();
 523   }
 524 
 525   ValueTag tag = x-&gt;type()-&gt;tag();
 526   assert(x-&gt;x()-&gt;type()-&gt;tag() == tag &amp;&amp; x-&gt;y()-&gt;type()-&gt;tag() == tag, &quot;wrong parameters&quot;);
 527   switch (tag) {
 528     case floatTag:
 529     case doubleTag: do_ArithmeticOp_FPU(x);  return;
 530     case longTag:   do_ArithmeticOp_Long(x); return;
 531     case intTag:    do_ArithmeticOp_Int(x);  return;
 532     default:
 533       ShouldNotReachHere();
 534   }
 535 }
 536 
 537 // _ishl, _lshl, _ishr, _lshr, _iushr, _lushr
 538 void LIRGenerator::do_ShiftOp(ShiftOp* x) {
 539   // count must always be in rcx
 540   LIRItem value(x-&gt;x(), this);
 541   LIRItem count(x-&gt;y(), this);
 542 
 543   ValueTag elemType = x-&gt;type()-&gt;tag();
 544   bool must_load_count = !count.is_constant();
 545   if (must_load_count) {
 546     count.load_item();
 547   } else {
 548     count.dont_load_item();
 549   }
 550   value.load_item();
 551   LIR_Opr reg = rlock_result(x);
 552 
 553   shift_op(x-&gt;op(), reg, value.result(), count.result(), LIR_OprFact::illegalOpr);
 554 }
 555 
 556 // _iand, _land, _ior, _lor, _ixor, _lxor
 557 void LIRGenerator::do_LogicOp(LogicOp* x) {
 558   // IF an operand with use count 1 is the left operand, then it is
 559   // likely that no move for 2-operand-LIR-form is necessary.
 560   if (x-&gt;is_commutative() &amp;&amp; x-&gt;y()-&gt;as_Constant() == NULL &amp;&amp; x-&gt;x()-&gt;use_count() &gt; x-&gt;y()-&gt;use_count()) {
 561     x-&gt;swap_operands();
 562   }
 563 
 564   LIRItem left(x-&gt;x(), this);
 565   LIRItem right(x-&gt;y(), this);
 566 
 567   left.load_item();
 568   right.load_nonconstant(32);
 569   LIR_Opr reg = rlock_result(x);
 570 
 571   logic_op(x-&gt;op(), reg, left.result(), right.result());
 572 }
 573 
 574 // _lcmp, _fcmpl, _fcmpg, _dcmpl, _dcmpg
 575 void LIRGenerator::do_CompareOp(CompareOp* x) {
 576   LIRItem left(x-&gt;x(), this);
 577   LIRItem right(x-&gt;y(), this);
 578   left.load_item();
 579   right.load_item();
 580   LIR_Opr reg = rlock_result(x);
 581   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 582     Bytecodes::Code code = x-&gt;op();
 583     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 584   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 585     __ lcmp2int(left.result(), right.result(), reg);
 586   } else {
 587     ShouldNotReachHere();
 588   }
 589 }
 590 
 591 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 592   LIR_Opr t1 = LIR_OprFact::illegalOpr;
 593   LIR_Opr t2 = LIR_OprFact::illegalOpr;
 594   cmp_value.load_item();
 595   new_value.load_item();
 596   if (type == T_OBJECT) {
 597     if (UseCompressedOops) {
 598       t1 = new_register(T_OBJECT);
 599       t2 = new_register(T_OBJECT);
 600     }
 601     __ cas_obj(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), t1, t2);
 602   } else if (type == T_INT) {
 603     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), t1, t2);
 604   } else if (type == T_LONG) {
 605     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), t1, t2);
 606   } else {
 607     ShouldNotReachHere();
 608   }
 609   // Generate conditional move of boolean result.
 610   LIR_Opr result = new_register(T_INT);
 611   __ cmove(lir_cond_equal, LIR_OprFact::intConst(1), LIR_OprFact::intConst(0),
 612            result, type);
 613   return result;
 614 }
 615 
 616 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 617   Unimplemented(); // Currently not supported on this platform.
 618   return LIR_OprFact::illegalOpr;
 619 }
 620 
 621 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 622   LIR_Opr result = new_register(type);
 623   value.load_item();
 624   __ xadd(addr, value.result(), result, LIR_OprFact::illegalOpr);
 625   return result;
 626 }
 627 
 628 void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {
 629   switch (x-&gt;id()) {
 630     case vmIntrinsics::_dabs:
 631     case vmIntrinsics::_dsqrt: {
 632       assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
 633       LIRItem value(x-&gt;argument_at(0), this);
 634       value.load_item();
 635       LIR_Opr dst = rlock_result(x);
 636 
 637       switch (x-&gt;id()) {
 638         case vmIntrinsics::_dsqrt: {
 639           __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);
 640           break;
 641         }
 642         case vmIntrinsics::_dabs: {
 643           __ abs(value.result(), dst, LIR_OprFact::illegalOpr);
 644           break;
 645         }
 646         default:
 647           ShouldNotReachHere();
 648       }
 649       break;
 650     }
 651     case vmIntrinsics::_dsin:   // fall through
 652     case vmIntrinsics::_dcos:   // fall through
 653     case vmIntrinsics::_dtan:   // fall through
 654     case vmIntrinsics::_dlog:   // fall through
 655     case vmIntrinsics::_dlog10: // fall through
 656     case vmIntrinsics::_dexp: {
 657       assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
 658 
 659       address runtime_entry = NULL;
 660       switch (x-&gt;id()) {
 661         case vmIntrinsics::_dsin:
 662           runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dsin);
 663           break;
 664         case vmIntrinsics::_dcos:
 665           runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dcos);
 666           break;
 667         case vmIntrinsics::_dtan:
 668           runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dtan);
 669           break;
 670         case vmIntrinsics::_dlog:
 671           runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dlog);
 672           break;
 673         case vmIntrinsics::_dlog10:
 674           runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dlog10);
 675           break;
 676         case vmIntrinsics::_dexp:
 677           runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dexp);
 678           break;
 679         default:
 680           ShouldNotReachHere();
 681       }
 682 
 683       LIR_Opr result = call_runtime(x-&gt;argument_at(0), runtime_entry, x-&gt;type(), NULL);
 684       set_result(x, result);
 685       break;
 686     }
 687     case vmIntrinsics::_dpow: {
 688       assert(x-&gt;number_of_arguments() == 2, &quot;wrong type&quot;);
 689       address runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dpow);
 690       LIR_Opr result = call_runtime(x-&gt;argument_at(0), x-&gt;argument_at(1), runtime_entry, x-&gt;type(), NULL);
 691       set_result(x, result);
 692       break;
 693     }
 694     default:
 695       break;
 696   }
 697 }
 698 
 699 void LIRGenerator::do_ArrayCopy(Intrinsic* x) {
 700   assert(x-&gt;number_of_arguments() == 5, &quot;wrong type&quot;);
 701 
 702   // Copy stubs possibly call C code, e.g. G1 barriers, so we need to reserve room
 703   // for the C ABI (see frame::z_abi_160).
 704   BasicTypeArray sig; // Empty signature is precise enough.
 705   frame_map()-&gt;c_calling_convention(&amp;sig);
 706 
 707   // Make all state_for calls early since they can emit code.
 708   CodeEmitInfo* info = state_for (x, x-&gt;state());
 709 
 710   LIRItem src(x-&gt;argument_at(0), this);
 711   LIRItem src_pos(x-&gt;argument_at(1), this);
 712   LIRItem dst(x-&gt;argument_at(2), this);
 713   LIRItem dst_pos(x-&gt;argument_at(3), this);
 714   LIRItem length(x-&gt;argument_at(4), this);
 715 
 716   // Operands for arraycopy must use fixed registers, otherwise
 717   // LinearScan will fail allocation (because arraycopy always needs a
 718   // call).
 719 
 720   src.load_item_force     (FrameMap::as_oop_opr(Z_ARG1));
 721   src_pos.load_item_force (FrameMap::as_opr(Z_ARG2));
 722   dst.load_item_force     (FrameMap::as_oop_opr(Z_ARG3));
 723   dst_pos.load_item_force (FrameMap::as_opr(Z_ARG4));
 724   length.load_item_force  (FrameMap::as_opr(Z_ARG5));
 725 
 726   LIR_Opr tmp =            FrameMap::as_opr(Z_R7);
 727 
 728   set_no_result(x);
 729 
 730   int flags;
 731   ciArrayKlass* expected_type;
 732   arraycopy_helper(x, &amp;flags, &amp;expected_type);
 733 
 734   __ arraycopy(src.result(), src_pos.result(), dst.result(), dst_pos.result(),
 735                length.result(), tmp, expected_type, flags, info); // does add_safepoint
 736 }
 737 
 738 // _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f
 739 // _i2b, _i2c, _i2s
 740 void LIRGenerator::do_Convert(Convert* x) {
 741   LIRItem value(x-&gt;value(), this);
 742 
 743   value.load_item();
 744   LIR_Opr reg = rlock_result(x);
 745   __ convert(x-&gt;op(), value.result(), reg);
 746 }
 747 
 748 void LIRGenerator::do_NewInstance(NewInstance* x) {
 749   print_if_not_loaded(x);
 750 
 751   // This instruction can be deoptimized in the slow path : use
 752   // Z_R2 as result register.
 753   const LIR_Opr reg = result_register_for (x-&gt;type());
 754 
 755   CodeEmitInfo* info = state_for (x, x-&gt;state());
 756   LIR_Opr tmp1 = FrameMap::Z_R12_oop_opr;
 757   LIR_Opr tmp2 = FrameMap::Z_R13_oop_opr;
 758   LIR_Opr tmp3 = reg;
 759   LIR_Opr tmp4 = LIR_OprFact::illegalOpr;
 760   LIR_Opr klass_reg = FrameMap::Z_R11_metadata_opr;
 761   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(), tmp1, tmp2, tmp3, tmp4, klass_reg, info);
 762   LIR_Opr result = rlock_result(x);
 763   __ move(reg, result);
 764 }
 765 
 766 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
 767   CodeEmitInfo* info = state_for (x, x-&gt;state());
 768 
 769   LIRItem length(x-&gt;length(), this);
 770   length.load_item();
 771 
 772   LIR_Opr reg = result_register_for (x-&gt;type());
 773   LIR_Opr tmp1 = FrameMap::Z_R12_oop_opr;
 774   LIR_Opr tmp2 = FrameMap::Z_R13_oop_opr;
 775   LIR_Opr tmp3 = reg;
 776   LIR_Opr tmp4 = LIR_OprFact::illegalOpr;
 777   LIR_Opr klass_reg = FrameMap::Z_R11_metadata_opr;
 778   LIR_Opr len = length.result();
 779   BasicType elem_type = x-&gt;elt_type();
 780 
 781   __ metadata2reg(ciTypeArrayKlass::make(elem_type)-&gt;constant_encoding(), klass_reg);
 782 
 783   CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len, reg, info);
 784   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);
 785 
 786   LIR_Opr result = rlock_result(x);
 787   __ move(reg, result);
 788 }
 789 
 790 void LIRGenerator::do_NewObjectArray(NewObjectArray* x) {
 791   // Evaluate state_for early since it may emit code.
 792   CodeEmitInfo* info = state_for (x, x-&gt;state());
 793   // In case of patching (i.e., object class is not yet loaded), we need to reexecute the instruction
 794   // and therefore provide the state before the parameters have been consumed.
 795   CodeEmitInfo* patching_info = NULL;
 796   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
 797     patching_info = state_for (x, x-&gt;state_before());
 798   }
 799 
 800   LIRItem length(x-&gt;length(), this);
 801   length.load_item();
 802 
 803   const LIR_Opr reg = result_register_for (x-&gt;type());
 804   LIR_Opr tmp1 = FrameMap::Z_R12_oop_opr;
 805   LIR_Opr tmp2 = FrameMap::Z_R13_oop_opr;
 806   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
 807   LIR_Opr tmp4 = LIR_OprFact::illegalOpr;
 808   LIR_Opr klass_reg = FrameMap::Z_R11_metadata_opr;
 809   LIR_Opr len = length.result();
 810 
 811   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info);
 812   ciKlass* obj = ciObjArrayKlass::make(x-&gt;klass());
 813   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
 814     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
 815   }
 816   klass2reg_with_patching(klass_reg, obj, patching_info);
 817   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);
 818 
 819   LIR_Opr result = rlock_result(x);
 820   __ move(reg, result);
 821 }
 822 
 823 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
 824   Values* dims = x-&gt;dims();
 825   int i = dims-&gt;length();
 826   LIRItemList* items = new LIRItemList(i, i, NULL);
 827   while (i-- &gt; 0) {
 828     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
 829     items-&gt;at_put(i, size);
 830   }
 831 
 832   // Evaluate state_for early since it may emit code.
 833   CodeEmitInfo* patching_info = NULL;
 834   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
 835     patching_info = state_for (x, x-&gt;state_before());
 836 
 837     // Cannot re-use same xhandlers for multiple CodeEmitInfos, so
 838     // clone all handlers (NOTE: Usually this is handled transparently
 839     // by the CodeEmitInfo cloning logic in CodeStub constructors but
 840     // is done explicitly here because a stub isn&#39;t being used).
 841     x-&gt;set_exception_handlers(new XHandlers(x-&gt;exception_handlers()));
 842   }
 843   CodeEmitInfo* info = state_for (x, x-&gt;state());
 844 
 845   i = dims-&gt;length();
 846   while (--i &gt;= 0) {
 847     LIRItem* size = items-&gt;at(i);
 848     size-&gt;load_nonconstant(32);
 849     // FrameMap::_reserved_argument_area_size includes the dimensions varargs, because
 850     // it&#39;s initialized to hir()-&gt;max_stack() when the FrameMap is created.
 851     store_stack_parameter(size-&gt;result(), in_ByteSize(i*sizeof(jint) + FrameMap::first_available_sp_in_frame));
 852   }
 853 
 854   LIR_Opr klass_reg = FrameMap::Z_R3_metadata_opr;
 855   klass2reg_with_patching(klass_reg, x-&gt;klass(), patching_info);
 856 
 857   LIR_Opr rank = FrameMap::Z_R4_opr;
 858   __ move(LIR_OprFact::intConst(x-&gt;rank()), rank);
 859   LIR_Opr varargs = FrameMap::Z_R5_opr;
 860   __ leal(LIR_OprFact::address(new LIR_Address(FrameMap::Z_SP_opr, FrameMap::first_available_sp_in_frame, T_INT)),
 861           varargs);
 862   LIR_OprList* args = new LIR_OprList(3);
 863   args-&gt;append(klass_reg);
 864   args-&gt;append(rank);
 865   args-&gt;append(varargs);
 866   LIR_Opr reg = result_register_for (x-&gt;type());
 867   __ call_runtime(Runtime1::entry_for (Runtime1::new_multi_array_id),
 868                   LIR_OprFact::illegalOpr,
 869                   reg, args, info);
 870 
 871   LIR_Opr result = rlock_result(x);
 872   __ move(reg, result);
 873 }
 874 
 875 void LIRGenerator::do_BlockBegin(BlockBegin* x) {
 876   // Nothing to do.
 877 }
 878 
 879 void LIRGenerator::do_CheckCast(CheckCast* x) {
 880   LIRItem obj(x-&gt;obj(), this);
 881 
 882   CodeEmitInfo* patching_info = NULL;
 883   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
 884     // Must do this before locking the destination register as an oop register,
 885     // and before the obj is loaded (the latter is for deoptimization).
 886     patching_info = state_for (x, x-&gt;state_before());
 887   }
 888   obj.load_item();
 889 
 890   // info for exceptions
 891   CodeEmitInfo* info_for_exception =
 892       (x-&gt;needs_exception_state() ? state_for(x) :
 893                                     state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
 894 
 895   CodeStub* stub;
 896   if (x-&gt;is_incompatible_class_change_check()) {
 897     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
 898     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);
 899   } else if (x-&gt;is_invokespecial_receiver_check()) {
 900     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
 901     stub = new DeoptimizeStub(info_for_exception,
 902                               Deoptimization::Reason_class_check,
 903                               Deoptimization::Action_none);
 904   } else {
 905     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);
 906   }
 907   LIR_Opr reg = rlock_result(x);
 908   LIR_Opr tmp1 = new_register(objectType);
 909   LIR_Opr tmp2 = new_register(objectType);
 910   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
 911   __ checkcast(reg, obj.result(), x-&gt;klass(),
 912                tmp1, tmp2, tmp3,
 913                x-&gt;direct_compare(), info_for_exception, patching_info, stub,
 914                x-&gt;profiled_method(), x-&gt;profiled_bci());
 915 }
 916 
 917 
 918 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
 919   LIRItem obj(x-&gt;obj(), this);
 920   CodeEmitInfo* patching_info = NULL;
 921   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
 922     patching_info = state_for (x, x-&gt;state_before());
 923   }
 924   // Ensure the result register is not the input register because the
 925   // result is initialized before the patching safepoint.
 926   obj.load_item();
 927   LIR_Opr out_reg = rlock_result(x);
 928   LIR_Opr tmp1 = new_register(objectType);
 929   LIR_Opr tmp2 = new_register(objectType);
 930   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
 931   __ instanceof(out_reg, obj.result(), x-&gt;klass(), tmp1, tmp2, tmp3,
 932                 x-&gt;direct_compare(), patching_info,
 933                 x-&gt;profiled_method(), x-&gt;profiled_bci());
 934 }
 935 
 936 
 937 void LIRGenerator::do_If (If* x) {
 938   assert(x-&gt;number_of_sux() == 2, &quot;inconsistency&quot;);
 939   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
 940   bool is_safepoint = x-&gt;is_safepoint();
 941 
 942   If::Condition cond = x-&gt;cond();
 943 
 944   LIRItem xitem(x-&gt;x(), this);
 945   LIRItem yitem(x-&gt;y(), this);
 946   LIRItem* xin = &amp;xitem;
 947   LIRItem* yin = &amp;yitem;
 948 
 949   if (tag == longTag) {
 950     // For longs, only conditions &quot;eql&quot;, &quot;neq&quot;, &quot;lss&quot;, &quot;geq&quot; are valid;
 951     // mirror for other conditions.
 952     if (cond == If::gtr || cond == If::leq) {
 953       cond = Instruction::mirror(cond);
 954       xin = &amp;yitem;
 955       yin = &amp;xitem;
 956     }
 957     xin-&gt;set_destroys_register();
 958   }
 959   xin-&gt;load_item();
 960   // TODO: don&#39;t load long constants != 0L
 961   if (tag == longTag &amp;&amp; yin-&gt;is_constant() &amp;&amp; yin-&gt;get_jlong_constant() == 0 &amp;&amp; (cond == If::eql || cond == If::neq)) {
 962     // inline long zero
 963     yin-&gt;dont_load_item();
 964   } else if (tag == longTag || tag == floatTag || tag == doubleTag) {
 965     // Longs cannot handle constants at right side.
 966     yin-&gt;load_item();
 967   } else {
 968     yin-&gt;dont_load_item();
 969   }
 970 
 971   LIR_Opr left = xin-&gt;result();
 972   LIR_Opr right = yin-&gt;result();
 973 
 974   set_no_result(x);
 975 
 976   // Add safepoint before generating condition code so it can be recomputed.
 977   if (x-&gt;is_safepoint()) {
 978     // Increment backedge counter if needed.
 979     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
 980         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
 981     // Use safepoint_poll_register() instead of LIR_OprFact::illegalOpr.
 982     __ safepoint(safepoint_poll_register(), state_for (x, x-&gt;state_before()));
 983   }
 984 
 985   __ cmp(lir_cond(cond), left, right);
 986   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
 987   profile_branch(x, cond);
 988   move_to_phi(x-&gt;state());
 989   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 990     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());
 991   } else {
 992     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());
 993   }
 994   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
 995   __ jump(x-&gt;default_sux());
 996 }
 997 
 998 LIR_Opr LIRGenerator::getThreadPointer() {
 999   return FrameMap::as_pointer_opr(Z_thread);
1000 }
1001 
1002 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1003   __ move(LIR_OprFact::intConst(block-&gt;block_id()), FrameMap::Z_R2_opr);
1004   LIR_OprList* args = new LIR_OprList(1);
1005   args-&gt;append(FrameMap::Z_R2_opr);
1006   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
1007   __ call_runtime_leaf(func, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, args);
1008 }
1009 
1010 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1011                                         CodeEmitInfo* info) {
1012   __ store(value, address, info);
1013 }
1014 
1015 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1016                                        CodeEmitInfo* info) {
1017   __ load(address, result, info);
1018 }
1019 
1020 void LIRGenerator::do_update_CRC32(Intrinsic* x) {
1021   assert(UseCRC32Intrinsics, &quot;or should not be here&quot;);
1022   LIR_Opr result = rlock_result(x);
1023 
1024   switch (x-&gt;id()) {
1025     case vmIntrinsics::_updateCRC32: {
1026       LIRItem crc(x-&gt;argument_at(0), this);
1027       LIRItem val(x-&gt;argument_at(1), this);
1028       // Registers destroyed by update_crc32.
1029       crc.set_destroys_register();
1030       val.set_destroys_register();
1031       crc.load_item();
1032       val.load_item();
1033       __ update_crc32(crc.result(), val.result(), result);
1034       break;
1035     }
1036     case vmIntrinsics::_updateBytesCRC32:
1037     case vmIntrinsics::_updateByteBufferCRC32: {
1038       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32);
1039 
1040       LIRItem crc(x-&gt;argument_at(0), this);
1041       LIRItem buf(x-&gt;argument_at(1), this);
1042       LIRItem off(x-&gt;argument_at(2), this);
1043       LIRItem len(x-&gt;argument_at(3), this);
1044       buf.load_item();
1045       off.load_nonconstant();
1046 
1047       LIR_Opr index = off.result();
1048       int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
1049       if (off.result()-&gt;is_constant()) {
1050         index = LIR_OprFact::illegalOpr;
1051         offset += off.result()-&gt;as_jint();
1052       }
1053       LIR_Opr base_op = buf.result();
1054 
1055       if (index-&gt;is_valid()) {
1056         LIR_Opr tmp = new_register(T_LONG);
1057         __ convert(Bytecodes::_i2l, index, tmp);
1058         index = tmp;
1059       }
1060 
1061       LIR_Address* a = new LIR_Address(base_op, index, offset, T_BYTE);
1062 
1063       BasicTypeList signature(3);
1064       signature.append(T_INT);
1065       signature.append(T_ADDRESS);
1066       signature.append(T_INT);
1067       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1068       const LIR_Opr result_reg = result_register_for (x-&gt;type());
1069 
1070       LIR_Opr arg1 = cc-&gt;at(0);
1071       LIR_Opr arg2 = cc-&gt;at(1);
1072       LIR_Opr arg3 = cc-&gt;at(2);
1073 
1074       crc.load_item_force(arg1); // We skip int-&gt;long conversion here, because CRC32 stub doesn&#39;t care about high bits.
1075       __ leal(LIR_OprFact::address(a), arg2);
1076       len.load_item_force(arg3); // We skip int-&gt;long conversion here, because CRC32 stub expects int.
1077 
1078       __ call_runtime_leaf(StubRoutines::updateBytesCRC32(), LIR_OprFact::illegalOpr, result_reg, cc-&gt;args());
1079       __ move(result_reg, result);
1080       break;
1081     }
1082     default: {
1083       ShouldNotReachHere();
1084     }
1085   }
1086 }
1087 
1088 void LIRGenerator::do_update_CRC32C(Intrinsic* x) {
1089   assert(UseCRC32CIntrinsics, &quot;or should not be here&quot;);
1090   LIR_Opr result = rlock_result(x);
1091 
1092   switch (x-&gt;id()) {
1093     case vmIntrinsics::_updateBytesCRC32C:
1094     case vmIntrinsics::_updateDirectByteBufferCRC32C: {
1095       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32C);
1096 
1097       LIRItem crc(x-&gt;argument_at(0), this);
1098       LIRItem buf(x-&gt;argument_at(1), this);
1099       LIRItem off(x-&gt;argument_at(2), this);
1100       LIRItem end(x-&gt;argument_at(3), this);
1101       buf.load_item();
1102       off.load_nonconstant();
1103       end.load_nonconstant();
1104 
1105       // len = end - off
1106       LIR_Opr len  = end.result();
1107       LIR_Opr tmpA = new_register(T_INT);
1108       LIR_Opr tmpB = new_register(T_INT);
1109       __ move(end.result(), tmpA);
1110       __ move(off.result(), tmpB);
1111       __ sub(tmpA, tmpB, tmpA);
1112       len = tmpA;
1113 
1114       LIR_Opr index = off.result();
1115       int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
1116       if (off.result()-&gt;is_constant()) {
1117         index = LIR_OprFact::illegalOpr;
1118         offset += off.result()-&gt;as_jint();
1119       }
1120       LIR_Opr base_op = buf.result();
1121 
1122       if (index-&gt;is_valid()) {
1123         LIR_Opr tmp = new_register(T_LONG);
1124         __ convert(Bytecodes::_i2l, index, tmp);
1125         index = tmp;
1126       }
1127 
1128       LIR_Address* a = new LIR_Address(base_op, index, offset, T_BYTE);
1129 
1130       BasicTypeList signature(3);
1131       signature.append(T_INT);
1132       signature.append(T_ADDRESS);
1133       signature.append(T_INT);
1134       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1135       const LIR_Opr result_reg = result_register_for (x-&gt;type());
1136 
1137       LIR_Opr arg1 = cc-&gt;at(0);
1138       LIR_Opr arg2 = cc-&gt;at(1);
1139       LIR_Opr arg3 = cc-&gt;at(2);
1140 
1141       crc.load_item_force(arg1); // We skip int-&gt;long conversion here, because CRC32C stub doesn&#39;t care about high bits.
1142       __ leal(LIR_OprFact::address(a), arg2);
1143       __ move(len, cc-&gt;at(2));   // We skip int-&gt;long conversion here, because CRC32C stub expects int.
1144 
1145       __ call_runtime_leaf(StubRoutines::updateBytesCRC32C(), LIR_OprFact::illegalOpr, result_reg, cc-&gt;args());
1146       __ move(result_reg, result);
1147       break;
1148     }
1149     default: {
1150       ShouldNotReachHere();
1151     }
1152   }
1153 }
1154 
1155 void LIRGenerator::do_FmaIntrinsic(Intrinsic* x) {
1156   assert(x-&gt;number_of_arguments() == 3, &quot;wrong type&quot;);
1157   assert(UseFMA, &quot;Needs FMA instructions support.&quot;);
1158   LIRItem value(x-&gt;argument_at(0), this);
1159   LIRItem value1(x-&gt;argument_at(1), this);
1160   LIRItem value2(x-&gt;argument_at(2), this);
1161 
1162   value2.set_destroys_register();
1163 
1164   value.load_item();
1165   value1.load_item();
1166   value2.load_item();
1167 
1168   LIR_Opr calc_input = value.result();
1169   LIR_Opr calc_input1 = value1.result();
1170   LIR_Opr calc_input2 = value2.result();
1171   LIR_Opr calc_result = rlock_result(x);
1172 
1173   switch (x-&gt;id()) {
1174   case vmIntrinsics::_fmaD:   __ fmad(calc_input, calc_input1, calc_input2, calc_result); break;
1175   case vmIntrinsics::_fmaF:   __ fmaf(calc_input, calc_input1, calc_input2, calc_result); break;
1176   default:                    ShouldNotReachHere();
1177   }
1178 }
1179 
1180 void LIRGenerator::do_vectorizedMismatch(Intrinsic* x) {
1181   fatal(&quot;vectorizedMismatch intrinsic is not implemented on this platform&quot;);
1182 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
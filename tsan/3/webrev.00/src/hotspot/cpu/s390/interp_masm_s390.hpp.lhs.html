<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/interp_masm_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2016, 2017 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_S390_INTERP_MASM_S390_HPP
 27 #define CPU_S390_INTERP_MASM_S390_HPP
 28 
 29 #include &quot;asm/macroAssembler.hpp&quot;
 30 #include &quot;interpreter/invocationCounter.hpp&quot;
 31 
 32 // This file specializes the assember with interpreter-specific macros.
 33 
 34 class InterpreterMacroAssembler: public MacroAssembler {
 35 
 36  protected:
 37   // Interpreter specific version of call_VM_base().
 38   virtual void call_VM_leaf_base(address entry_point);
 39   virtual void call_VM_leaf_base(address entry_point, bool allow_relocation);
 40 
 41   virtual void call_VM_base(Register oop_result,
 42                             Register last_java_sp,
 43                             address  entry_point,
 44                             bool check_exceptions);
 45   virtual void call_VM_base(Register oop_result,
 46                             Register last_java_sp,
 47                             address  entry_point,
 48                             bool allow_relocation,
 49                             bool check_exceptions);
 50 
 51   // Base routine for all dispatches.
 52   void dispatch_base(TosState state, address* table, bool generate_poll = false);
 53 
 54  public:
 55   InterpreterMacroAssembler(CodeBuffer* c)
 56     : MacroAssembler(c) {}
 57 
 58   virtual void check_and_handle_popframe(Register java_thread);
 59   virtual void check_and_handle_earlyret(Register java_thread);
 60 
 61   void jump_to_entry(address entry, Register Rscratch);
 62 
 63   virtual void load_earlyret_value(TosState state);
 64 
 65   static const Address l_tmp;
 66   static const Address d_tmp;
 67 
 68   // Handy address generation macros.
 69 #define thread_(field_name) Address(Z_thread, JavaThread::field_name ## _offset())
 70 #define method_(field_name) Address(Z_method, Method::field_name ## _offset())
 71 #define method2_(Rmethod, field_name) Address(Rmethod, Method::field_name ## _offset())
 72 
 73   // Helper routine for frame allocation/deallocation.
 74   // Compute the delta by which the caller&#39;s SP has to
 75   // be adjusted to accomodate for the non-argument locals.
 76   void compute_extra_locals_size_in_bytes(Register args_size, Register locals_size, Register delta);
 77 
 78   // dispatch routines
 79   void dispatch_prolog(TosState state, int step = 0);
 80   void dispatch_epilog(TosState state, int step = 0);
 81   void dispatch_only(TosState state, bool generate_poll = false);
 82   // Dispatch normal table via Z_bytecode (assume Z_bytecode is loaded already).
 83   void dispatch_only_normal(TosState state);
 84   void dispatch_normal(TosState state);
 85   void dispatch_next(TosState state, int step = 0, bool generate_poll = false);
 86   void dispatch_next_noverify_oop(TosState state, int step = 0);
 87   void dispatch_via(TosState state, address* table);
 88 
 89   void narrow(Register result, Register ret_type);
 90 
 91   // Jump to an invoked target.
 92   void prepare_to_jump_from_interpreted(Register method);
 93   void jump_from_interpreted(Register method, Register temp);
 94 
 95   // Removes the current activation (incl. unlocking of monitors).
 96   // Additionally this code is used for earlyReturn in which case we
 97   // want to skip throwing an exception and installing an exception.
 98   void remove_activation(TosState state,
 99                          Register return_pc,
100                          bool throw_monitor_exception = true,
101                          bool install_monitor_exception = true,
102                          bool notify_jvmti = true);
103 
104  public:
105   // Super call_VM calls - correspond to MacroAssembler::call_VM(_leaf) calls.
106   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
107   void super_call_VM(Register thread_cache, Register oop_result, Register last_java_sp,
108                      address entry_point, Register arg_1, Register arg_2, bool check_exception = true);
109 
110   // Generate a subtype check: branch to ok_is_subtype if sub_klass is
111   // a subtype of super_klass. Blows registers tmp1, tmp2 and tmp3.
112   void gen_subtype_check(Register sub_klass, Register super_klass, Register tmp1, Register tmp2, Label &amp;ok_is_subtype);
113 
114   void get_cache_and_index_at_bcp(Register cache, Register cpe_offset, int bcp_offset, size_t index_size = sizeof(u2));
115   void get_cache_and_index_and_bytecode_at_bcp(Register cache, Register cpe_offset, Register bytecode,
116                                                int byte_no, int bcp_offset, size_t index_size = sizeof(u2));
117   void get_cache_entry_pointer_at_bcp(Register cache, Register tmp, int bcp_offset, size_t index_size = sizeof(u2));
118   void get_cache_index_at_bcp(Register index, int bcp_offset, size_t index_size = sizeof(u2));
119   void load_resolved_reference_at_index(Register result, Register index);
120   // load cpool-&gt;resolved_klass_at(index)
121   void load_resolved_klass_at_offset(Register cpool, Register offset, Register iklass);
122 
<a name="1" id="anc1"></a>

123   // Pop topmost element from stack. It just disappears. Useful if
124   // consumed previously by access via stackTop().
125   void popx(int len);
126   void pop_i()   { popx(1); }
127   void pop_ptr() { popx(1); }
128   void pop_l()   { popx(2); }
129   void pop_f()   { popx(1); }
130   void pop_d()   { popx(2); }
131   // Get Address object of stack top. No checks. No pop.
132   // Purpose: provide address of stack operand to exploit reg-mem operations.
133   // Avoid RISC-like mem2reg - reg-reg-op sequence.
134   Address stackTop();
135 
136   // Helpers for expression stack.
137   void pop_i(     Register r);
138   void pop_ptr(   Register r);
139   void pop_l(     Register r);
140   void pop_f(FloatRegister f);
141   void pop_d(FloatRegister f);
142 
143   void push_i(     Register r = Z_tos);
144   void push_ptr(   Register r = Z_tos);
145   void push_l(     Register r = Z_tos);
146   void push_f(FloatRegister f = Z_ftos);
147   void push_d(FloatRegister f = Z_ftos);
148 
149   // Helpers for swap and dup.
150   void load_ptr(int n, Register val);
151   void store_ptr(int n, Register val);
152 
153   void pop (TosState state);           // transition vtos -&gt; state
154   void push(TosState state);           // transition state -&gt; vtos
155   void empty_expression_stack(void);
156 
157 #ifdef ASSERT
158   void verify_sp(Register Rsp, Register Rtemp);
159   void verify_esp(Register Resp, Register Rtemp); // Verify that Resp points to a word in the operand stack.
160 #endif // ASSERT
161 
162  public:
163   void if_cmp(Condition cc, bool ptr_compare);
164 
165   // Accessors to the template interpreter state.
166 
167   void asm_assert_ijava_state_magic(Register tmp) PRODUCT_RETURN;
168 
169   void save_bcp();
170 
171   void restore_bcp();
172 
173   void save_esp();
174 
175   void restore_esp();
176 
177   void get_monitors(Register reg);
178 
179   void save_monitors(Register reg);
180 
181   void get_mdp(Register mdp);
182 
183   void save_mdp(Register mdp);
184 
185   // Values that are only read (besides initialization).
186   void restore_locals();
187 
188   void get_method(Register reg);
189 
190   // Load values from bytecode stream:
191 
192   enum signedOrNot { Signed, Unsigned };
193   enum setCCOrNot  { set_CC,  dont_set_CC };
194 
195   void get_2_byte_integer_at_bcp(Register    Rdst,
196                                  int         bcp_offset,
197                                  signedOrNot is_signed  );
198 
199   void get_4_byte_integer_at_bcp(Register   Rdst,
200                                  int        bcp_offset,
201                                  setCCOrNot should_set_CC = dont_set_CC);
202 
203   // common code
204 
205   void field_offset_at(int n, Register tmp, Register dest, Register base);
206   int  field_offset_at(Register object, address bcp, int offset);
207   void fast_iaaccess(int n, address bcp);
208   void fast_iaputfield(address bcp, bool do_store_check);
209 
210   void index_check(Register array, Register index, int index_shift, Register tmp, Register res);
211   void index_check_without_pop(Register array, Register index, int index_shift, Register tmp, Register res);
212 
213   void get_constant_pool(Register Rdst);
214   void get_constant_pool_cache(Register Rdst);
215   void get_cpool_and_tags(Register Rcpool, Register Rtags);
216   void is_a(Label&amp; L);
217 
218 
219   // --------------------------------------------------
220 
221   void unlock_if_synchronized_method(TosState state, bool throw_monitor_exception = true, bool install_monitor_exception = true);
222 
223   void add_monitor_to_stack(bool stack_is_empty,
224                             Register Rtemp,
225                             Register Rtemp2,
226                             Register Rtemp3);
227 
228   void access_local_int(Register index, Register dst);
229   void access_local_ptr(Register index, Register dst);
230   void access_local_long(Register index, Register dst);
231   void access_local_float(Register index, FloatRegister dst);
232   void access_local_double(Register index, FloatRegister dst);
233 #ifdef ASSERT
234   void check_for_regarea_stomp(Register Rindex, int offset, Register Rlimit, Register Rscratch, Register Rscratch1);
235 #endif // ASSERT
236   void store_local_int(Register index, Register src);
237   void store_local_ptr(Register index, Register src);
238   void store_local_long(Register index, Register src);
239   void store_local_float(Register index, FloatRegister src);
240   void store_local_double(Register index, FloatRegister src);
241 
242 
243   Address first_local_in_stack();
244   static int top_most_monitor_byte_offset(); // Offset in bytes to top of monitor block.
245   Address top_most_monitor();
246   void compute_stack_base(Register Rdest);
247 
248   enum LoadOrStore { load, store };
249   void static_iload_or_store(int which_local, LoadOrStore direction, Register Rtmp);
250   void static_aload_or_store(int which_local, LoadOrStore direction, Register Rtmp);
251   void static_dload_or_store(int which_local, LoadOrStore direction);
252 
253   void static_iinc(          int which_local, jint increment, Register Rtmp, Register Rtmp2);
254 
255   void get_method_counters(Register Rmethod, Register Rcounters, Label&amp; skip);
256   void increment_invocation_counter(Register Rcounters, Register RctrSum);
257   void increment_backedge_counter(Register Rcounters, Register RctrSum);
258   void test_backedge_count_for_osr(Register backedge_count, Register branch_bcp, Register Rtmp);
259 
260   void record_static_call_in_profile(Register Rentry, Register Rtmp);
261   void record_receiver_call_in_profile(Register Rklass, Register Rentry, Register Rtmp);
262 
263   // Object locking
264   void lock_object  (Register lock_reg, Register obj_reg);
265   void unlock_object(Register lock_reg, Register obj_reg=noreg);
266 
267   // Interpreter profiling operations
268   void set_method_data_pointer_for_bcp();
269   void test_method_data_pointer(Register mdp, Label&amp; zero_continue);
270   void verify_method_data_pointer();
271 
272   void set_mdp_data_at(Register mdp_in, int constant, Register value);
273   void increment_mdp_data_at(Register mdp_in, int constant,
274                              Register tmp = Z_R1_scratch, bool decrement = false);
275   void increment_mask_and_jump(Address counter_addr,
276                                int increment, Address mask,
277                                Register scratch, bool preloaded,
278                                branch_condition cond, Label* where);
279   void set_mdp_flag_at(Register mdp_in, int flag_constant);
280   void test_mdp_data_at(Register mdp_in, int offset, Register value,
281                         Register test_value_out,
282                         Label&amp; not_equal_continue);
283 
284   void record_klass_in_profile(Register receiver, Register mdp,
285                                Register reg2, bool is_virtual_call);
286   void record_klass_in_profile_helper(Register receiver, Register mdp,
287                                       Register reg2, int start_row,
288                                       Label&amp; done, bool is_virtual_call);
289 
290   void update_mdp_by_offset(Register mdp_in, int offset_of_offset);
291   void update_mdp_by_offset(Register mdp_in, Register dataidx, int offset_of_disp);
292   void update_mdp_by_constant(Register mdp_in, int constant);
293   void update_mdp_for_ret(Register return_bci);
294 
295   void profile_taken_branch(Register mdp, Register bumped_count);
296   void profile_not_taken_branch(Register mdp);
297   void profile_call(Register mdp);
298   void profile_final_call(Register mdp);
299   void profile_virtual_call(Register receiver, Register mdp,
300                             Register scratch2,
301                             bool receiver_can_be_null = false);
302   void profile_ret(Register return_bci, Register mdp);
303   void profile_null_seen(Register mdp);
304   void profile_typecheck(Register mdp, Register klass, Register scratch);
305   void profile_typecheck_failed(Register mdp, Register tmp);
306   void profile_switch_default(Register mdp);
307   void profile_switch_case(Register index_in_scratch, Register mdp,
308                            Register scratch1, Register scratch2);
309 
310   void profile_obj_type(Register obj, Address mdo_addr, Register klass, bool cmp_done = false);
311   void profile_arguments_type(Register mdp, Register callee, Register tmp, bool is_virtual);
312   void profile_return_type(Register mdp, Register ret, Register tmp);
313   void profile_parameters_type(Register mdp, Register tmp1, Register tmp2);
314 
315   // Debugging
316   void verify_oop(Register reg, TosState state = atos);    // Only if +VerifyOops &amp;&amp; state == atos.
317   void verify_oop_or_return_address(Register reg, Register rtmp); // for astore
318   void verify_FPU(int stack_depth, TosState state = ftos);
319 
320   // JVMTI helpers
321   void skip_if_jvmti_mode(Label &amp;Lskip, Register Rscratch = Z_R0);
322 
323   // support for JVMTI/Dtrace
324   typedef enum { NotifyJVMTI, SkipNotifyJVMTI } NotifyMethodExitMode;
325   void notify_method_entry();
326   void notify_method_exit(bool native_method, TosState state, NotifyMethodExitMode mode);
327 
328   // Pop the topmost TOP_IJAVA_FRAME and set it&#39;s sender_sp as new Z_SP.
329   // The return pc is loaded into the Register return_pc.
330   void pop_interpreter_frame(Register return_pc, Register tmp1, Register tmp2);
331 };
332 
333 #endif // CPU_S390_INTERP_MASM_S390_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
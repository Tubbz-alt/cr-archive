<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/s390/c1_MacroAssembler_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRGenerator_s390.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_s390.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/c1_MacroAssembler_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -29,20 +29,20 @@</span>
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;gc/shared/collectedHeap.hpp&quot;
  #include &quot;interpreter/interpreter.hpp&quot;
  #include &quot;oops/arrayOop.hpp&quot;
<span class="udiff-line-modified-removed">- #include &quot;oops/markOop.hpp&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;oops/markWord.hpp&quot;</span>
  #include &quot;runtime/basicLock.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/os.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  
  void C1_MacroAssembler::inline_cache_check(Register receiver, Register iCache) {
    Label ic_miss, ic_hit;
<span class="udiff-line-modified-removed">-   verify_oop(receiver);</span>
<span class="udiff-line-modified-added">+   verify_oop(receiver, FILE_AND_LINE);</span>
    int klass_offset = oopDesc::klass_offset_in_bytes();
  
    if (!ImplicitNullChecks || MacroAssembler::needs_explicit_null_check(klass_offset)) {
      if (VM_Version::has_CompareBranch()) {
        z_cgij(receiver, 0, Assembler::bcondEqual, ic_miss);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -81,11 +81,11 @@</span>
  void C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label&amp; slow_case) {
    const int hdr_offset = oopDesc::mark_offset_in_bytes();
    assert_different_registers(hdr, obj, disp_hdr);
    NearLabel done;
  
<span class="udiff-line-modified-removed">-   verify_oop(obj);</span>
<span class="udiff-line-modified-added">+   verify_oop(obj, FILE_AND_LINE);</span>
  
    // Load object header.
    z_lg(hdr, Address(obj, hdr_offset));
  
    // Save object being locked into the BasicObjectLock...
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -94,11 +94,11 @@</span>
    if (UseBiasedLocking) {
      biased_locking_enter(obj, hdr, Z_R1_scratch, Z_R0_scratch, done, &amp;slow_case);
    }
  
    // and mark it as unlocked.
<span class="udiff-line-modified-removed">-   z_oill(hdr, markOopDesc::unlocked_value);</span>
<span class="udiff-line-modified-added">+   z_oill(hdr, markWord::unlocked_value);</span>
    // Save unlocked object header into the displaced header location on the stack.
    z_stg(hdr, Address(disp_hdr, (intptr_t)0));
    // Test if object header is still the same (i.e. unlocked), and if so, store the
    // displaced header address in the object header. If it is not the same, get the
    // object header instead.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -113,23 +113,23 @@</span>
    }
    branch_optimized(Assembler::bcondEqual, done);
    // If the object header was not the same, it is now in the hdr register.
    // =&gt; Test if it is a stack pointer into the same stack (recursive locking), i.e.:
    //
<span class="udiff-line-modified-removed">-   // 1) (hdr &amp; markOopDesc::lock_mask_in_place) == 0</span>
<span class="udiff-line-modified-added">+   // 1) (hdr &amp; markWord::lock_mask_in_place) == 0</span>
    // 2) rsp &lt;= hdr
    // 3) hdr &lt;= rsp + page_size
    //
    // These 3 tests can be done by evaluating the following expression:
    //
<span class="udiff-line-modified-removed">-   // (hdr - Z_SP) &amp; (~(page_size-1) | markOopDesc::lock_mask_in_place)</span>
<span class="udiff-line-modified-added">+   // (hdr - Z_SP) &amp; (~(page_size-1) | markWord::lock_mask_in_place)</span>
    //
    // assuming both the stack pointer and page_size have their least
    // significant 2 bits cleared and page_size is a power of 2
    z_sgr(hdr, Z_SP);
  
<span class="udiff-line-modified-removed">-   load_const_optimized(Z_R0_scratch, (~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place));</span>
<span class="udiff-line-modified-added">+   load_const_optimized(Z_R0_scratch, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));</span>
    z_ngr(hdr, Z_R0_scratch); // AND sets CC (result eq/ne 0).
    // For recursive locking, the result is zero. =&gt; Save it in the displaced header
    // location (NULL in the displaced hdr location indicates recursive locking).
    z_stg(hdr, Address(disp_hdr, (intptr_t)0));
    // Otherwise we don&#39;t care about the result and handle locking via runtime call.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -156,11 +156,11 @@</span>
    z_bre(done);
    if (!UseBiasedLocking) {
      // Load object.
      z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset_in_bytes()));
    }
<span class="udiff-line-modified-removed">-   verify_oop(obj);</span>
<span class="udiff-line-modified-added">+   verify_oop(obj, FILE_AND_LINE);</span>
    // Test if object header is pointing to the displaced header, and if so, restore
    // the displaced header in the object. If the object header is not pointing to
    // the displaced header, get the object header instead.
    z_csg(disp_hdr, hdr, hdr_offset, obj);
    // If the object header was not pointing to the displaced header,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -190,11 +190,11 @@</span>
    if (UseBiasedLocking &amp;&amp; !len-&gt;is_valid()) {
      assert_different_registers(obj, klass, len, t1);
      z_lg(t1, Address(klass, Klass::prototype_header_offset()));
    } else {
      // This assumes that all prototype bits fit in an int32_t.
<span class="udiff-line-modified-removed">-     load_const_optimized(t1, (intx)markOopDesc::prototype());</span>
<span class="udiff-line-modified-added">+     load_const_optimized(t1, (intx)markWord::prototype().value());</span>
    }
    z_stg(t1, Address(obj, oopDesc::mark_offset_in_bytes()));
  
    if (len-&gt;is_valid()) {
      // Length will be in the klass gap, if one exists.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -276,11 +276,11 @@</span>
    //  if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
    //    assert(obj == rax, &quot;must be&quot;);
    //    call(RuntimeAddress(Runtime1::entry_for (Runtime1::dtrace_object_alloc_id)));
    //  }
  
<span class="udiff-line-modified-removed">-   verify_oop(obj);</span>
<span class="udiff-line-modified-added">+   verify_oop(obj, FILE_AND_LINE);</span>
  }
  
  void C1_MacroAssembler::allocate_array(
    Register obj,                        // result: Pointer to array after successful allocation.
    Register len,                        // array length
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -334,29 +334,28 @@</span>
    // if (CURRENT_ENV-&gt;dtrace_alloc_probes()) {
    //   assert(obj == rax, &quot;must be&quot;);
    //   call(RuntimeAddress(Runtime1::entry_for (Runtime1::dtrace_object_alloc_id)));
    // }
  
<span class="udiff-line-modified-removed">-   verify_oop(obj);</span>
<span class="udiff-line-modified-added">+   verify_oop(obj, FILE_AND_LINE);</span>
  }
  
  
  #ifndef PRODUCT
  
  void C1_MacroAssembler::verify_stack_oop(int stack_offset) {
<span class="udiff-line-modified-removed">-   Unimplemented();</span>
<span class="udiff-line-modified-removed">-   // if (!VerifyOops) return;</span>
<span class="udiff-line-removed">-   // verify_oop_addr(Address(SP, stack_offset + STACK_BIAS));</span>
<span class="udiff-line-modified-added">+   if (!VerifyOops) return;</span>
<span class="udiff-line-modified-added">+   verify_oop_addr(Address(Z_SP, stack_offset), FILE_AND_LINE);</span>
  }
  
  void C1_MacroAssembler::verify_not_null_oop(Register r) {
    if (!VerifyOops) return;
    NearLabel not_null;
    compareU64_and_branch(r, (intptr_t)0, bcondNotEqual, not_null);
    stop(&quot;non-null oop required&quot;);
    bind(not_null);
<span class="udiff-line-modified-removed">-   verify_oop(r);</span>
<span class="udiff-line-modified-added">+   verify_oop(r, FILE_AND_LINE);</span>
  }
  
  void C1_MacroAssembler::invalidate_registers(Register preserve1,
                                               Register preserve2,
                                               Register preserve3) {
</pre>
<center><a href="c1_LIRGenerator_s390.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_s390.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/interp_masm_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRT_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/interp_masm_s390.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
103 
104  public:
105   // Super call_VM calls - correspond to MacroAssembler::call_VM(_leaf) calls.
106   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
107   void super_call_VM(Register thread_cache, Register oop_result, Register last_java_sp,
108                      address entry_point, Register arg_1, Register arg_2, bool check_exception = true);
109 
110   // Generate a subtype check: branch to ok_is_subtype if sub_klass is
111   // a subtype of super_klass. Blows registers tmp1, tmp2 and tmp3.
112   void gen_subtype_check(Register sub_klass, Register super_klass, Register tmp1, Register tmp2, Label &amp;ok_is_subtype);
113 
114   void get_cache_and_index_at_bcp(Register cache, Register cpe_offset, int bcp_offset, size_t index_size = sizeof(u2));
115   void get_cache_and_index_and_bytecode_at_bcp(Register cache, Register cpe_offset, Register bytecode,
116                                                int byte_no, int bcp_offset, size_t index_size = sizeof(u2));
117   void get_cache_entry_pointer_at_bcp(Register cache, Register tmp, int bcp_offset, size_t index_size = sizeof(u2));
118   void get_cache_index_at_bcp(Register index, int bcp_offset, size_t index_size = sizeof(u2));
119   void load_resolved_reference_at_index(Register result, Register index);
120   // load cpool-&gt;resolved_klass_at(index)
121   void load_resolved_klass_at_offset(Register cpool, Register offset, Register iklass);
122 


123   // Pop topmost element from stack. It just disappears. Useful if
124   // consumed previously by access via stackTop().
125   void popx(int len);
126   void pop_i()   { popx(1); }
127   void pop_ptr() { popx(1); }
128   void pop_l()   { popx(2); }
129   void pop_f()   { popx(1); }
130   void pop_d()   { popx(2); }
131   // Get Address object of stack top. No checks. No pop.
132   // Purpose: provide address of stack operand to exploit reg-mem operations.
133   // Avoid RISC-like mem2reg - reg-reg-op sequence.
134   Address stackTop();
135 
136   // Helpers for expression stack.
137   void pop_i(     Register r);
138   void pop_ptr(   Register r);
139   void pop_l(     Register r);
140   void pop_f(FloatRegister f);
141   void pop_d(FloatRegister f);
142 
</pre>
</td>
<td>
<hr />
<pre>
103 
104  public:
105   // Super call_VM calls - correspond to MacroAssembler::call_VM(_leaf) calls.
106   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
107   void super_call_VM(Register thread_cache, Register oop_result, Register last_java_sp,
108                      address entry_point, Register arg_1, Register arg_2, bool check_exception = true);
109 
110   // Generate a subtype check: branch to ok_is_subtype if sub_klass is
111   // a subtype of super_klass. Blows registers tmp1, tmp2 and tmp3.
112   void gen_subtype_check(Register sub_klass, Register super_klass, Register tmp1, Register tmp2, Label &amp;ok_is_subtype);
113 
114   void get_cache_and_index_at_bcp(Register cache, Register cpe_offset, int bcp_offset, size_t index_size = sizeof(u2));
115   void get_cache_and_index_and_bytecode_at_bcp(Register cache, Register cpe_offset, Register bytecode,
116                                                int byte_no, int bcp_offset, size_t index_size = sizeof(u2));
117   void get_cache_entry_pointer_at_bcp(Register cache, Register tmp, int bcp_offset, size_t index_size = sizeof(u2));
118   void get_cache_index_at_bcp(Register index, int bcp_offset, size_t index_size = sizeof(u2));
119   void load_resolved_reference_at_index(Register result, Register index);
120   // load cpool-&gt;resolved_klass_at(index)
121   void load_resolved_klass_at_offset(Register cpool, Register offset, Register iklass);
122 
<span class="line-added">123   void load_resolved_method_at_index(int byte_no, Register cache, Register cpe_offset, Register method);</span>
<span class="line-added">124 </span>
125   // Pop topmost element from stack. It just disappears. Useful if
126   // consumed previously by access via stackTop().
127   void popx(int len);
128   void pop_i()   { popx(1); }
129   void pop_ptr() { popx(1); }
130   void pop_l()   { popx(2); }
131   void pop_f()   { popx(1); }
132   void pop_d()   { popx(2); }
133   // Get Address object of stack top. No checks. No pop.
134   // Purpose: provide address of stack operand to exploit reg-mem operations.
135   // Avoid RISC-like mem2reg - reg-reg-op sequence.
136   Address stackTop();
137 
138   // Helpers for expression stack.
139   void pop_i(     Register r);
140   void pop_ptr(   Register r);
141   void pop_l(     Register r);
142   void pop_f(FloatRegister f);
143   void pop_d(FloatRegister f);
144 
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRT_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
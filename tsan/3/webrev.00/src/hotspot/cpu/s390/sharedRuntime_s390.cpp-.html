<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/s390/sharedRuntime_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2016, 2018 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/debugInfoRec.hpp&quot;
  29 #include &quot;code/icBuffer.hpp&quot;
  30 #include &quot;code/vtableStubs.hpp&quot;
  31 #include &quot;gc/shared/gcLocker.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/interp_masm.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;oops/compiledICHolder.hpp&quot;
  36 #include &quot;registerSaver_s390.hpp&quot;
  37 #include &quot;runtime/safepointMechanism.hpp&quot;
  38 #include &quot;runtime/sharedRuntime.hpp&quot;
  39 #include &quot;runtime/vframeArray.hpp&quot;
  40 #include &quot;utilities/align.hpp&quot;
  41 #include &quot;vmreg_s390.inline.hpp&quot;
  42 #ifdef COMPILER1
  43 #include &quot;c1/c1_Runtime1.hpp&quot;
  44 #endif
  45 #ifdef COMPILER2
  46 #include &quot;opto/ad.hpp&quot;
  47 #include &quot;opto/runtime.hpp&quot;
  48 #endif
  49 
  50 #ifdef PRODUCT
  51 #define __ masm-&gt;
  52 #else
  53 #define __ (Verbose ? (masm-&gt;block_comment(FILE_AND_LINE),masm):masm)-&gt;
  54 #endif
  55 
  56 #define BLOCK_COMMENT(str) __ block_comment(str)
  57 #define BIND(label)        bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  58 
  59 #define RegisterSaver_LiveIntReg(regname) \
  60   { RegisterSaver::int_reg,   regname-&gt;encoding(), regname-&gt;as_VMReg() }
  61 
  62 #define RegisterSaver_LiveFloatReg(regname) \
  63   { RegisterSaver::float_reg, regname-&gt;encoding(), regname-&gt;as_VMReg() }
  64 
  65 // Registers which are not saved/restored, but still they have got a frame slot.
  66 // Used to get same frame size for RegisterSaver_LiveRegs and RegisterSaver_LiveRegsWithoutR2
  67 #define RegisterSaver_ExcludedIntReg(regname) \
  68   { RegisterSaver::excluded_reg, regname-&gt;encoding(), regname-&gt;as_VMReg() }
  69 
  70 // Registers which are not saved/restored, but still they have got a frame slot.
  71 // Used to get same frame size for RegisterSaver_LiveRegs and RegisterSaver_LiveRegsWithoutR2.
  72 #define RegisterSaver_ExcludedFloatReg(regname) \
  73   { RegisterSaver::excluded_reg, regname-&gt;encoding(), regname-&gt;as_VMReg() }
  74 
  75 static const RegisterSaver::LiveRegType RegisterSaver_LiveRegs[] = {
  76   // Live registers which get spilled to the stack. Register positions
  77   // in this array correspond directly to the stack layout.
  78   //
  79   // live float registers:
  80   //
  81   RegisterSaver_LiveFloatReg(Z_F0 ),
  82   // RegisterSaver_ExcludedFloatReg(Z_F1 ), // scratch (Z_fscratch_1)
  83   RegisterSaver_LiveFloatReg(Z_F2 ),
  84   RegisterSaver_LiveFloatReg(Z_F3 ),
  85   RegisterSaver_LiveFloatReg(Z_F4 ),
  86   RegisterSaver_LiveFloatReg(Z_F5 ),
  87   RegisterSaver_LiveFloatReg(Z_F6 ),
  88   RegisterSaver_LiveFloatReg(Z_F7 ),
  89   RegisterSaver_LiveFloatReg(Z_F8 ),
  90   RegisterSaver_LiveFloatReg(Z_F9 ),
  91   RegisterSaver_LiveFloatReg(Z_F10),
  92   RegisterSaver_LiveFloatReg(Z_F11),
  93   RegisterSaver_LiveFloatReg(Z_F12),
  94   RegisterSaver_LiveFloatReg(Z_F13),
  95   RegisterSaver_LiveFloatReg(Z_F14),
  96   RegisterSaver_LiveFloatReg(Z_F15),
  97   //
  98   // RegisterSaver_ExcludedIntReg(Z_R0), // scratch
  99   // RegisterSaver_ExcludedIntReg(Z_R1), // scratch
 100   RegisterSaver_LiveIntReg(Z_R2 ),
 101   RegisterSaver_LiveIntReg(Z_R3 ),
 102   RegisterSaver_LiveIntReg(Z_R4 ),
 103   RegisterSaver_LiveIntReg(Z_R5 ),
 104   RegisterSaver_LiveIntReg(Z_R6 ),
 105   RegisterSaver_LiveIntReg(Z_R7 ),
 106   RegisterSaver_LiveIntReg(Z_R8 ),
 107   RegisterSaver_LiveIntReg(Z_R9 ),
 108   RegisterSaver_LiveIntReg(Z_R10),
 109   RegisterSaver_LiveIntReg(Z_R11),
 110   RegisterSaver_LiveIntReg(Z_R12),
 111   RegisterSaver_LiveIntReg(Z_R13),
 112   // RegisterSaver_ExcludedIntReg(Z_R14), // return pc (Saved in caller frame.)
 113   // RegisterSaver_ExcludedIntReg(Z_R15)  // stack pointer
 114 };
 115 
 116 static const RegisterSaver::LiveRegType RegisterSaver_LiveIntRegs[] = {
 117   // Live registers which get spilled to the stack. Register positions
 118   // in this array correspond directly to the stack layout.
 119   //
 120   // live float registers: All excluded, but still they get a stack slot to get same frame size.
 121   //
 122   RegisterSaver_ExcludedFloatReg(Z_F0 ),
 123   // RegisterSaver_ExcludedFloatReg(Z_F1 ), // scratch (Z_fscratch_1)
 124   RegisterSaver_ExcludedFloatReg(Z_F2 ),
 125   RegisterSaver_ExcludedFloatReg(Z_F3 ),
 126   RegisterSaver_ExcludedFloatReg(Z_F4 ),
 127   RegisterSaver_ExcludedFloatReg(Z_F5 ),
 128   RegisterSaver_ExcludedFloatReg(Z_F6 ),
 129   RegisterSaver_ExcludedFloatReg(Z_F7 ),
 130   RegisterSaver_ExcludedFloatReg(Z_F8 ),
 131   RegisterSaver_ExcludedFloatReg(Z_F9 ),
 132   RegisterSaver_ExcludedFloatReg(Z_F10),
 133   RegisterSaver_ExcludedFloatReg(Z_F11),
 134   RegisterSaver_ExcludedFloatReg(Z_F12),
 135   RegisterSaver_ExcludedFloatReg(Z_F13),
 136   RegisterSaver_ExcludedFloatReg(Z_F14),
 137   RegisterSaver_ExcludedFloatReg(Z_F15),
 138   //
 139   // RegisterSaver_ExcludedIntReg(Z_R0), // scratch
 140   // RegisterSaver_ExcludedIntReg(Z_R1), // scratch
 141   RegisterSaver_LiveIntReg(Z_R2 ),
 142   RegisterSaver_LiveIntReg(Z_R3 ),
 143   RegisterSaver_LiveIntReg(Z_R4 ),
 144   RegisterSaver_LiveIntReg(Z_R5 ),
 145   RegisterSaver_LiveIntReg(Z_R6 ),
 146   RegisterSaver_LiveIntReg(Z_R7 ),
 147   RegisterSaver_LiveIntReg(Z_R8 ),
 148   RegisterSaver_LiveIntReg(Z_R9 ),
 149   RegisterSaver_LiveIntReg(Z_R10),
 150   RegisterSaver_LiveIntReg(Z_R11),
 151   RegisterSaver_LiveIntReg(Z_R12),
 152   RegisterSaver_LiveIntReg(Z_R13),
 153   // RegisterSaver_ExcludedIntReg(Z_R14), // return pc (Saved in caller frame.)
 154   // RegisterSaver_ExcludedIntReg(Z_R15)  // stack pointer
 155 };
 156 
 157 static const RegisterSaver::LiveRegType RegisterSaver_LiveRegsWithoutR2[] = {
 158   // Live registers which get spilled to the stack. Register positions
 159   // in this array correspond directly to the stack layout.
 160   //
 161   // live float registers:
 162   //
 163   RegisterSaver_LiveFloatReg(Z_F0 ),
 164   // RegisterSaver_ExcludedFloatReg(Z_F1 ), // scratch (Z_fscratch_1)
 165   RegisterSaver_LiveFloatReg(Z_F2 ),
 166   RegisterSaver_LiveFloatReg(Z_F3 ),
 167   RegisterSaver_LiveFloatReg(Z_F4 ),
 168   RegisterSaver_LiveFloatReg(Z_F5 ),
 169   RegisterSaver_LiveFloatReg(Z_F6 ),
 170   RegisterSaver_LiveFloatReg(Z_F7 ),
 171   RegisterSaver_LiveFloatReg(Z_F8 ),
 172   RegisterSaver_LiveFloatReg(Z_F9 ),
 173   RegisterSaver_LiveFloatReg(Z_F10),
 174   RegisterSaver_LiveFloatReg(Z_F11),
 175   RegisterSaver_LiveFloatReg(Z_F12),
 176   RegisterSaver_LiveFloatReg(Z_F13),
 177   RegisterSaver_LiveFloatReg(Z_F14),
 178   RegisterSaver_LiveFloatReg(Z_F15),
 179   //
 180   // RegisterSaver_ExcludedIntReg(Z_R0), // scratch
 181   // RegisterSaver_ExcludedIntReg(Z_R1), // scratch
 182   RegisterSaver_ExcludedIntReg(Z_R2), // Omit saving R2.
 183   RegisterSaver_LiveIntReg(Z_R3 ),
 184   RegisterSaver_LiveIntReg(Z_R4 ),
 185   RegisterSaver_LiveIntReg(Z_R5 ),
 186   RegisterSaver_LiveIntReg(Z_R6 ),
 187   RegisterSaver_LiveIntReg(Z_R7 ),
 188   RegisterSaver_LiveIntReg(Z_R8 ),
 189   RegisterSaver_LiveIntReg(Z_R9 ),
 190   RegisterSaver_LiveIntReg(Z_R10),
 191   RegisterSaver_LiveIntReg(Z_R11),
 192   RegisterSaver_LiveIntReg(Z_R12),
 193   RegisterSaver_LiveIntReg(Z_R13),
 194   // RegisterSaver_ExcludedIntReg(Z_R14), // return pc (Saved in caller frame.)
 195   // RegisterSaver_ExcludedIntReg(Z_R15)  // stack pointer
 196 };
 197 
 198 // Live argument registers which get spilled to the stack.
 199 static const RegisterSaver::LiveRegType RegisterSaver_LiveArgRegs[] = {
 200   RegisterSaver_LiveFloatReg(Z_FARG1),
 201   RegisterSaver_LiveFloatReg(Z_FARG2),
 202   RegisterSaver_LiveFloatReg(Z_FARG3),
 203   RegisterSaver_LiveFloatReg(Z_FARG4),
 204   RegisterSaver_LiveIntReg(Z_ARG1),
 205   RegisterSaver_LiveIntReg(Z_ARG2),
 206   RegisterSaver_LiveIntReg(Z_ARG3),
 207   RegisterSaver_LiveIntReg(Z_ARG4),
 208   RegisterSaver_LiveIntReg(Z_ARG5)
 209 };
 210 
 211 static const RegisterSaver::LiveRegType RegisterSaver_LiveVolatileRegs[] = {
 212   // Live registers which get spilled to the stack. Register positions
 213   // in this array correspond directly to the stack layout.
 214   //
 215   // live float registers:
 216   //
 217   RegisterSaver_LiveFloatReg(Z_F0 ),
 218   // RegisterSaver_ExcludedFloatReg(Z_F1 ), // scratch (Z_fscratch_1)
 219   RegisterSaver_LiveFloatReg(Z_F2 ),
 220   RegisterSaver_LiveFloatReg(Z_F3 ),
 221   RegisterSaver_LiveFloatReg(Z_F4 ),
 222   RegisterSaver_LiveFloatReg(Z_F5 ),
 223   RegisterSaver_LiveFloatReg(Z_F6 ),
 224   RegisterSaver_LiveFloatReg(Z_F7 ),
 225   // RegisterSaver_LiveFloatReg(Z_F8 ), // non-volatile
 226   // RegisterSaver_LiveFloatReg(Z_F9 ), // non-volatile
 227   // RegisterSaver_LiveFloatReg(Z_F10), // non-volatile
 228   // RegisterSaver_LiveFloatReg(Z_F11), // non-volatile
 229   // RegisterSaver_LiveFloatReg(Z_F12), // non-volatile
 230   // RegisterSaver_LiveFloatReg(Z_F13), // non-volatile
 231   // RegisterSaver_LiveFloatReg(Z_F14), // non-volatile
 232   // RegisterSaver_LiveFloatReg(Z_F15), // non-volatile
 233   //
 234   // RegisterSaver_ExcludedIntReg(Z_R0), // scratch
 235   // RegisterSaver_ExcludedIntReg(Z_R1), // scratch
 236   RegisterSaver_LiveIntReg(Z_R2 ),
 237   RegisterSaver_LiveIntReg(Z_R3 ),
 238   RegisterSaver_LiveIntReg(Z_R4 ),
 239   RegisterSaver_LiveIntReg(Z_R5 ),
 240   // RegisterSaver_LiveIntReg(Z_R6 ), // non-volatile
 241   // RegisterSaver_LiveIntReg(Z_R7 ), // non-volatile
 242   // RegisterSaver_LiveIntReg(Z_R8 ), // non-volatile
 243   // RegisterSaver_LiveIntReg(Z_R9 ), // non-volatile
 244   // RegisterSaver_LiveIntReg(Z_R10), // non-volatile
 245   // RegisterSaver_LiveIntReg(Z_R11), // non-volatile
 246   // RegisterSaver_LiveIntReg(Z_R12), // non-volatile
 247   // RegisterSaver_LiveIntReg(Z_R13), // non-volatile
 248   // RegisterSaver_ExcludedIntReg(Z_R14), // return pc (Saved in caller frame.)
 249   // RegisterSaver_ExcludedIntReg(Z_R15)  // stack pointer
 250 };
 251 
 252 int RegisterSaver::live_reg_save_size(RegisterSet reg_set) {
 253   int reg_space = -1;
 254   switch (reg_set) {
 255     case all_registers:           reg_space = sizeof(RegisterSaver_LiveRegs); break;
 256     case all_registers_except_r2: reg_space = sizeof(RegisterSaver_LiveRegsWithoutR2); break;
 257     case all_integer_registers:   reg_space = sizeof(RegisterSaver_LiveIntRegs); break;
 258     case all_volatile_registers:  reg_space = sizeof(RegisterSaver_LiveVolatileRegs); break;
 259     case arg_registers:           reg_space = sizeof(RegisterSaver_LiveArgRegs); break;
 260     default: ShouldNotReachHere();
 261   }
 262   return (reg_space / sizeof(RegisterSaver::LiveRegType)) * reg_size;
 263 }
 264 
 265 
 266 int RegisterSaver::live_reg_frame_size(RegisterSet reg_set) {
 267   return live_reg_save_size(reg_set) + frame::z_abi_160_size;
 268 }
 269 
 270 
 271 // return_pc: Specify the register that should be stored as the return pc in the current frame.
 272 OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, RegisterSet reg_set, Register return_pc) {
 273   // Record volatile registers as callee-save values in an OopMap so
 274   // their save locations will be propagated to the caller frame&#39;s
 275   // RegisterMap during StackFrameStream construction (needed for
 276   // deoptimization; see compiledVFrame::create_stack_value).
 277 
 278   // Calculate frame size.
 279   const int frame_size_in_bytes  = live_reg_frame_size(reg_set);
 280   const int frame_size_in_slots  = frame_size_in_bytes / sizeof(jint);
 281   const int register_save_offset = frame_size_in_bytes - live_reg_save_size(reg_set);
 282 
 283   // OopMap frame size is in c2 stack slots (sizeof(jint)) not bytes or words.
 284   OopMap* map = new OopMap(frame_size_in_slots, 0);
 285 
 286   int regstosave_num = 0;
 287   const RegisterSaver::LiveRegType* live_regs = NULL;
 288 
 289   switch (reg_set) {
 290     case all_registers:
 291       regstosave_num = sizeof(RegisterSaver_LiveRegs)/sizeof(RegisterSaver::LiveRegType);
 292       live_regs      = RegisterSaver_LiveRegs;
 293       break;
 294     case all_registers_except_r2:
 295       regstosave_num = sizeof(RegisterSaver_LiveRegsWithoutR2)/sizeof(RegisterSaver::LiveRegType);;
 296       live_regs      = RegisterSaver_LiveRegsWithoutR2;
 297       break;
 298     case all_integer_registers:
 299       regstosave_num = sizeof(RegisterSaver_LiveIntRegs)/sizeof(RegisterSaver::LiveRegType);
 300       live_regs      = RegisterSaver_LiveIntRegs;
 301       break;
 302     case all_volatile_registers:
 303       regstosave_num = sizeof(RegisterSaver_LiveVolatileRegs)/sizeof(RegisterSaver::LiveRegType);
 304       live_regs      = RegisterSaver_LiveVolatileRegs;
 305       break;
 306     case arg_registers:
 307       regstosave_num = sizeof(RegisterSaver_LiveArgRegs)/sizeof(RegisterSaver::LiveRegType);;
 308       live_regs      = RegisterSaver_LiveArgRegs;
 309       break;
 310     default: ShouldNotReachHere();
 311   }
 312 
 313   // Save return pc in old frame.
 314   __ save_return_pc(return_pc);
 315 
 316   // Push a new frame (includes stack linkage).
 317   // Use return_pc as scratch for push_frame. Z_R0_scratch (the default) and Z_R1_scratch are
 318   // illegally used to pass parameters by RangeCheckStub::emit_code().
 319   __ push_frame(frame_size_in_bytes, return_pc);
 320   // We have to restore return_pc right away.
 321   // Nobody else will. Furthermore, return_pc isn&#39;t necessarily the default (Z_R14).
 322   // Nobody else knows which register we saved.
 323   __ z_lg(return_pc, _z_abi16(return_pc) + frame_size_in_bytes, Z_SP);
 324 
 325   // Register save area in new frame starts above z_abi_160 area.
 326   int offset = register_save_offset;
 327 
 328   Register first = noreg;
 329   Register last  = noreg;
 330   int      first_offset = -1;
 331   bool     float_spilled = false;
 332 
 333   for (int i = 0; i &lt; regstosave_num; i++, offset += reg_size) {
 334     int reg_num  = live_regs[i].reg_num;
 335     int reg_type = live_regs[i].reg_type;
 336 
 337     switch (reg_type) {
 338       case RegisterSaver::int_reg: {
 339         Register reg = as_Register(reg_num);
 340         if (last != reg-&gt;predecessor()) {
 341           if (first != noreg) {
 342             __ z_stmg(first, last, first_offset, Z_SP);
 343           }
 344           first = reg;
 345           first_offset = offset;
 346           DEBUG_ONLY(float_spilled = false);
 347         }
 348         last = reg;
 349         assert(last != Z_R0, &quot;r0 would require special treatment&quot;);
 350         assert(!float_spilled, &quot;for simplicity, do not mix up ints and floats in RegisterSaver_LiveRegs[]&quot;);
 351         break;
 352       }
 353 
 354       case RegisterSaver::excluded_reg: // Not saved/restored, but with dedicated slot.
 355         continue; // Continue with next loop iteration.
 356 
 357       case RegisterSaver::float_reg: {
 358         FloatRegister freg = as_FloatRegister(reg_num);
 359         __ z_std(freg, offset, Z_SP);
 360         DEBUG_ONLY(float_spilled = true);
 361         break;
 362       }
 363 
 364       default:
 365         ShouldNotReachHere();
 366         break;
 367     }
 368 
 369     // Second set_callee_saved is really a waste but we&#39;ll keep things as they were for now
 370     map-&gt;set_callee_saved(VMRegImpl::stack2reg(offset &gt;&gt; 2), live_regs[i].vmreg);
 371     map-&gt;set_callee_saved(VMRegImpl::stack2reg((offset + half_reg_size) &gt;&gt; 2), live_regs[i].vmreg-&gt;next());
 372   }
 373   assert(first != noreg, &quot;Should spill at least one int reg.&quot;);
 374   __ z_stmg(first, last, first_offset, Z_SP);
 375 
 376   // And we&#39;re done.
 377   return map;
 378 }
 379 
 380 
 381 // Generate the OopMap (again, regs where saved before).
 382 OopMap* RegisterSaver::generate_oop_map(MacroAssembler* masm, RegisterSet reg_set) {
 383   // Calculate frame size.
 384   const int frame_size_in_bytes  = live_reg_frame_size(reg_set);
 385   const int frame_size_in_slots  = frame_size_in_bytes / sizeof(jint);
 386   const int register_save_offset = frame_size_in_bytes - live_reg_save_size(reg_set);
 387 
 388   // OopMap frame size is in c2 stack slots (sizeof(jint)) not bytes or words.
 389   OopMap* map = new OopMap(frame_size_in_slots, 0);
 390 
 391   int regstosave_num = 0;
 392   const RegisterSaver::LiveRegType* live_regs = NULL;
 393 
 394   switch (reg_set) {
 395     case all_registers:
 396       regstosave_num = sizeof(RegisterSaver_LiveRegs)/sizeof(RegisterSaver::LiveRegType);
 397       live_regs      = RegisterSaver_LiveRegs;
 398       break;
 399     case all_registers_except_r2:
 400       regstosave_num = sizeof(RegisterSaver_LiveRegsWithoutR2)/sizeof(RegisterSaver::LiveRegType);;
 401       live_regs      = RegisterSaver_LiveRegsWithoutR2;
 402       break;
 403     case all_integer_registers:
 404       regstosave_num = sizeof(RegisterSaver_LiveIntRegs)/sizeof(RegisterSaver::LiveRegType);
 405       live_regs      = RegisterSaver_LiveIntRegs;
 406       break;
 407     case all_volatile_registers:
 408       regstosave_num = sizeof(RegisterSaver_LiveVolatileRegs)/sizeof(RegisterSaver::LiveRegType);
 409       live_regs      = RegisterSaver_LiveVolatileRegs;
 410       break;
 411     case arg_registers:
 412       regstosave_num = sizeof(RegisterSaver_LiveArgRegs)/sizeof(RegisterSaver::LiveRegType);;
 413       live_regs      = RegisterSaver_LiveArgRegs;
 414       break;
 415     default: ShouldNotReachHere();
 416   }
 417 
 418   // Register save area in new frame starts above z_abi_160 area.
 419   int offset = register_save_offset;
 420   for (int i = 0; i &lt; regstosave_num; i++) {
 421     if (live_regs[i].reg_type &lt; RegisterSaver::excluded_reg) {
 422       map-&gt;set_callee_saved(VMRegImpl::stack2reg(offset&gt;&gt;2), live_regs[i].vmreg);
 423       map-&gt;set_callee_saved(VMRegImpl::stack2reg((offset + half_reg_size)&gt;&gt;2), live_regs[i].vmreg-&gt;next());
 424     }
 425     offset += reg_size;
 426   }
 427   return map;
 428 }
 429 
 430 
 431 // Pop the current frame and restore all the registers that we saved.
 432 void RegisterSaver::restore_live_registers(MacroAssembler* masm, RegisterSet reg_set) {
 433   int offset;
 434   const int register_save_offset = live_reg_frame_size(reg_set) - live_reg_save_size(reg_set);
 435 
 436   Register first = noreg;
 437   Register last = noreg;
 438   int      first_offset = -1;
 439   bool     float_spilled = false;
 440 
 441   int regstosave_num = 0;
 442   const RegisterSaver::LiveRegType* live_regs = NULL;
 443 
 444   switch (reg_set) {
 445     case all_registers:
 446       regstosave_num = sizeof(RegisterSaver_LiveRegs)/sizeof(RegisterSaver::LiveRegType);;
 447       live_regs      = RegisterSaver_LiveRegs;
 448       break;
 449     case all_registers_except_r2:
 450       regstosave_num = sizeof(RegisterSaver_LiveRegsWithoutR2)/sizeof(RegisterSaver::LiveRegType);;
 451       live_regs      = RegisterSaver_LiveRegsWithoutR2;
 452       break;
 453     case all_integer_registers:
 454       regstosave_num = sizeof(RegisterSaver_LiveIntRegs)/sizeof(RegisterSaver::LiveRegType);
 455       live_regs      = RegisterSaver_LiveIntRegs;
 456       break;
 457     case all_volatile_registers:
 458       regstosave_num = sizeof(RegisterSaver_LiveVolatileRegs)/sizeof(RegisterSaver::LiveRegType);;
 459       live_regs      = RegisterSaver_LiveVolatileRegs;
 460       break;
 461     case arg_registers:
 462       regstosave_num = sizeof(RegisterSaver_LiveArgRegs)/sizeof(RegisterSaver::LiveRegType);;
 463       live_regs      = RegisterSaver_LiveArgRegs;
 464       break;
 465     default: ShouldNotReachHere();
 466   }
 467 
 468   // Restore all registers (ints and floats).
 469 
 470   // Register save area in new frame starts above z_abi_160 area.
 471   offset = register_save_offset;
 472 
 473   for (int i = 0; i &lt; regstosave_num; i++, offset += reg_size) {
 474     int reg_num  = live_regs[i].reg_num;
 475     int reg_type = live_regs[i].reg_type;
 476 
 477     switch (reg_type) {
 478       case RegisterSaver::excluded_reg:
 479         continue; // Continue with next loop iteration.
 480 
 481       case RegisterSaver::int_reg: {
 482         Register reg = as_Register(reg_num);
 483         if (last != reg-&gt;predecessor()) {
 484           if (first != noreg) {
 485             __ z_lmg(first, last, first_offset, Z_SP);
 486           }
 487           first = reg;
 488           first_offset = offset;
 489           DEBUG_ONLY(float_spilled = false);
 490         }
 491         last = reg;
 492         assert(last != Z_R0, &quot;r0 would require special treatment&quot;);
 493         assert(!float_spilled, &quot;for simplicity, do not mix up ints and floats in RegisterSaver_LiveRegs[]&quot;);
 494         break;
 495       }
 496 
 497       case RegisterSaver::float_reg: {
 498         FloatRegister freg = as_FloatRegister(reg_num);
 499         __ z_ld(freg, offset, Z_SP);
 500         DEBUG_ONLY(float_spilled = true);
 501         break;
 502       }
 503 
 504       default:
 505         ShouldNotReachHere();
 506     }
 507   }
 508   assert(first != noreg, &quot;Should spill at least one int reg.&quot;);
 509   __ z_lmg(first, last, first_offset, Z_SP);
 510 
 511   // Pop the frame.
 512   __ pop_frame();
 513 
 514   // Restore the flags.
 515   __ restore_return_pc();
 516 }
 517 
 518 
 519 // Pop the current frame and restore the registers that might be holding a result.
 520 void RegisterSaver::restore_result_registers(MacroAssembler* masm) {
 521   int i;
 522   int offset;
 523   const int regstosave_num       = sizeof(RegisterSaver_LiveRegs) /
 524                                    sizeof(RegisterSaver::LiveRegType);
 525   const int register_save_offset = live_reg_frame_size(all_registers) - live_reg_save_size(all_registers);
 526 
 527   // Restore all result registers (ints and floats).
 528   offset = register_save_offset;
 529   for (int i = 0; i &lt; regstosave_num; i++, offset += reg_size) {
 530     int reg_num = RegisterSaver_LiveRegs[i].reg_num;
 531     int reg_type = RegisterSaver_LiveRegs[i].reg_type;
 532     switch (reg_type) {
 533       case RegisterSaver::excluded_reg:
 534         continue; // Continue with next loop iteration.
 535       case RegisterSaver::int_reg: {
 536         if (as_Register(reg_num) == Z_RET) { // int result_reg
 537           __ z_lg(as_Register(reg_num), offset, Z_SP);
 538         }
 539         break;
 540       }
 541       case RegisterSaver::float_reg: {
 542         if (as_FloatRegister(reg_num) == Z_FRET) { // float result_reg
 543           __ z_ld(as_FloatRegister(reg_num), offset, Z_SP);
 544         }
 545         break;
 546       }
 547       default:
 548         ShouldNotReachHere();
 549     }
 550   }
 551 }
 552 
 553 size_t SharedRuntime::trampoline_size() {
 554   return MacroAssembler::load_const_size() + 2;
 555 }
 556 
 557 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
 558   // Think about using pc-relative branch.
 559   __ load_const(Z_R1_scratch, destination);
 560   __ z_br(Z_R1_scratch);
 561 }
 562 
 563 // ---------------------------------------------------------------------------
 564 void SharedRuntime::save_native_result(MacroAssembler * masm,
 565                                        BasicType ret_type,
 566                                        int frame_slots) {
 567   Address memaddr(Z_SP, frame_slots * VMRegImpl::stack_slot_size);
 568 
 569   switch (ret_type) {
 570     case T_BOOLEAN:  // Save shorter types as int. Do we need sign extension at restore??
 571     case T_BYTE:
 572     case T_CHAR:
 573     case T_SHORT:
 574     case T_INT:
 575       __ reg2mem_opt(Z_RET, memaddr, false);
 576       break;
 577     case T_OBJECT:   // Save pointer types as long.
 578     case T_ARRAY:
 579     case T_ADDRESS:
 580     case T_VOID:
 581     case T_LONG:
 582       __ reg2mem_opt(Z_RET, memaddr);
 583       break;
 584     case T_FLOAT:
 585       __ freg2mem_opt(Z_FRET, memaddr, false);
 586       break;
 587     case T_DOUBLE:
 588       __ freg2mem_opt(Z_FRET, memaddr);
 589       break;
 590     default:
 591       ShouldNotReachHere();
 592       break;
 593   }
 594 }
 595 
 596 void SharedRuntime::restore_native_result(MacroAssembler *masm,
 597                                           BasicType       ret_type,
 598                                           int             frame_slots) {
 599   Address memaddr(Z_SP, frame_slots * VMRegImpl::stack_slot_size);
 600 
 601   switch (ret_type) {
 602     case T_BOOLEAN:  // Restore shorter types as int. Do we need sign extension at restore??
 603     case T_BYTE:
 604     case T_CHAR:
 605     case T_SHORT:
 606     case T_INT:
 607       __ mem2reg_opt(Z_RET, memaddr, false);
 608       break;
 609     case T_OBJECT:   // Restore pointer types as long.
 610     case T_ARRAY:
 611     case T_ADDRESS:
 612     case T_VOID:
 613     case T_LONG:
 614       __ mem2reg_opt(Z_RET, memaddr);
 615       break;
 616     case T_FLOAT:
 617       __ mem2freg_opt(Z_FRET, memaddr, false);
 618       break;
 619     case T_DOUBLE:
 620       __ mem2freg_opt(Z_FRET, memaddr);
 621       break;
 622     default:
 623       ShouldNotReachHere();
 624       break;
 625   }
 626 }
 627 
 628 // ---------------------------------------------------------------------------
 629 // Read the array of BasicTypes from a signature, and compute where the
 630 // arguments should go. Values in the VMRegPair regs array refer to 4-byte
 631 // quantities. Values less than VMRegImpl::stack0 are registers, those above
 632 // refer to 4-byte stack slots. All stack slots are based off of the stack pointer
 633 // as framesizes are fixed.
 634 // VMRegImpl::stack0 refers to the first slot 0(sp).
 635 // VMRegImpl::stack0+1 refers to the memory word 4-byes higher. Registers
 636 // up to RegisterImpl::number_of_registers are the 64-bit integer registers.
 637 
 638 // Note: the INPUTS in sig_bt are in units of Java argument words, which are
 639 // either 32-bit or 64-bit depending on the build. The OUTPUTS are in 32-bit
 640 // units regardless of build.
 641 
 642 // The Java calling convention is a &quot;shifted&quot; version of the C ABI.
 643 // By skipping the first C ABI register we can call non-static jni methods
 644 // with small numbers of arguments without having to shuffle the arguments
 645 // at all. Since we control the java ABI we ought to at least get some
 646 // advantage out of it.
 647 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 648                                            VMRegPair *regs,
 649                                            int total_args_passed,
 650                                            int is_outgoing) {
 651   // c2c calling conventions for compiled-compiled calls.
 652 
 653   // An int/float occupies 1 slot here.
 654   const int inc_stk_for_intfloat   = 1; // 1 slots for ints and floats.
 655   const int inc_stk_for_longdouble = 2; // 2 slots for longs and doubles.
 656 
 657   const VMReg z_iarg_reg[5] = {
 658     Z_R2-&gt;as_VMReg(),
 659     Z_R3-&gt;as_VMReg(),
 660     Z_R4-&gt;as_VMReg(),
 661     Z_R5-&gt;as_VMReg(),
 662     Z_R6-&gt;as_VMReg()
 663   };
 664   const VMReg z_farg_reg[4] = {
 665     Z_F0-&gt;as_VMReg(),
 666     Z_F2-&gt;as_VMReg(),
 667     Z_F4-&gt;as_VMReg(),
 668     Z_F6-&gt;as_VMReg()
 669   };
 670   const int z_num_iarg_registers = sizeof(z_iarg_reg) / sizeof(z_iarg_reg[0]);
 671   const int z_num_farg_registers = sizeof(z_farg_reg) / sizeof(z_farg_reg[0]);
 672 
 673   assert(RegisterImpl::number_of_arg_registers == z_num_iarg_registers, &quot;iarg reg count mismatch&quot;);
 674   assert(FloatRegisterImpl::number_of_arg_registers == z_num_farg_registers, &quot;farg reg count mismatch&quot;);
 675 
 676   int i;
 677   int stk = 0;
 678   int ireg = 0;
 679   int freg = 0;
 680 
 681   for (int i = 0; i &lt; total_args_passed; ++i) {
 682     switch (sig_bt[i]) {
 683       case T_BOOLEAN:
 684       case T_CHAR:
 685       case T_BYTE:
 686       case T_SHORT:
 687       case T_INT:
 688         if (ireg &lt; z_num_iarg_registers) {
 689           // Put int/ptr in register.
 690           regs[i].set1(z_iarg_reg[ireg]);
 691           ++ireg;
 692         } else {
 693           // Put int/ptr on stack.
 694           regs[i].set1(VMRegImpl::stack2reg(stk));
 695           stk += inc_stk_for_intfloat;
 696         }
 697         break;
 698       case T_LONG:
 699         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;expecting half&quot;);
 700         if (ireg &lt; z_num_iarg_registers) {
 701           // Put long in register.
 702           regs[i].set2(z_iarg_reg[ireg]);
 703           ++ireg;
 704         } else {
 705           // Put long on stack and align to 2 slots.
 706           if (stk &amp; 0x1) { ++stk; }
 707           regs[i].set2(VMRegImpl::stack2reg(stk));
 708           stk += inc_stk_for_longdouble;
 709         }
 710         break;
 711       case T_OBJECT:
 712       case T_ARRAY:
 713       case T_ADDRESS:
 714         if (ireg &lt; z_num_iarg_registers) {
 715           // Put ptr in register.
 716           regs[i].set2(z_iarg_reg[ireg]);
 717           ++ireg;
 718         } else {
 719           // Put ptr on stack and align to 2 slots, because
 720           // &quot;64-bit pointers record oop-ishness on 2 aligned adjacent
 721           // registers.&quot; (see OopFlow::build_oop_map).
 722           if (stk &amp; 0x1) { ++stk; }
 723           regs[i].set2(VMRegImpl::stack2reg(stk));
 724           stk += inc_stk_for_longdouble;
 725         }
 726         break;
 727       case T_FLOAT:
 728         if (freg &lt; z_num_farg_registers) {
 729           // Put float in register.
 730           regs[i].set1(z_farg_reg[freg]);
 731           ++freg;
 732         } else {
 733           // Put float on stack.
 734           regs[i].set1(VMRegImpl::stack2reg(stk));
 735           stk += inc_stk_for_intfloat;
 736         }
 737         break;
 738       case T_DOUBLE:
 739         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;expecting half&quot;);
 740         if (freg &lt; z_num_farg_registers) {
 741           // Put double in register.
 742           regs[i].set2(z_farg_reg[freg]);
 743           ++freg;
 744         } else {
 745           // Put double on stack and align to 2 slots.
 746           if (stk &amp; 0x1) { ++stk; }
 747           regs[i].set2(VMRegImpl::stack2reg(stk));
 748           stk += inc_stk_for_longdouble;
 749         }
 750         break;
 751       case T_VOID:
 752         assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 753         // Do not count halves.
 754         regs[i].set_bad();
 755         break;
 756       default:
 757         ShouldNotReachHere();
 758     }
 759   }
 760   return align_up(stk, 2);
 761 }
 762 
 763 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 764                                         VMRegPair *regs,
 765                                         VMRegPair *regs2,
 766                                         int total_args_passed) {
 767   assert(regs2 == NULL, &quot;second VMRegPair array not used on this platform&quot;);
 768 
 769   // Calling conventions for C runtime calls and calls to JNI native methods.
 770   const VMReg z_iarg_reg[5] = {
 771     Z_R2-&gt;as_VMReg(),
 772     Z_R3-&gt;as_VMReg(),
 773     Z_R4-&gt;as_VMReg(),
 774     Z_R5-&gt;as_VMReg(),
 775     Z_R6-&gt;as_VMReg()
 776   };
 777   const VMReg z_farg_reg[4] = {
 778     Z_F0-&gt;as_VMReg(),
 779     Z_F2-&gt;as_VMReg(),
 780     Z_F4-&gt;as_VMReg(),
 781     Z_F6-&gt;as_VMReg()
 782   };
 783   const int z_num_iarg_registers = sizeof(z_iarg_reg) / sizeof(z_iarg_reg[0]);
 784   const int z_num_farg_registers = sizeof(z_farg_reg) / sizeof(z_farg_reg[0]);
 785 
 786   // Check calling conventions consistency.
 787   assert(RegisterImpl::number_of_arg_registers == z_num_iarg_registers, &quot;iarg reg count mismatch&quot;);
 788   assert(FloatRegisterImpl::number_of_arg_registers == z_num_farg_registers, &quot;farg reg count mismatch&quot;);
 789 
 790   // Avoid passing C arguments in the wrong stack slots.
 791 
 792   // &#39;Stk&#39; counts stack slots. Due to alignment, 32 bit values occupy
 793   // 2 such slots, like 64 bit values do.
 794   const int inc_stk_for_intfloat   = 2; // 2 slots for ints and floats.
 795   const int inc_stk_for_longdouble = 2; // 2 slots for longs and doubles.
 796 
 797   int i;
 798   // Leave room for C-compatible ABI
 799   int stk = (frame::z_abi_160_size - frame::z_jit_out_preserve_size) / VMRegImpl::stack_slot_size;
 800   int freg = 0;
 801   int ireg = 0;
 802 
 803   // We put the first 5 arguments into registers and the rest on the
 804   // stack. Float arguments are already in their argument registers
 805   // due to c2c calling conventions (see calling_convention).
 806   for (int i = 0; i &lt; total_args_passed; ++i) {
 807     switch (sig_bt[i]) {
 808       case T_BOOLEAN:
 809       case T_CHAR:
 810       case T_BYTE:
 811       case T_SHORT:
 812       case T_INT:
 813         // Fall through, handle as long.
 814       case T_LONG:
 815       case T_OBJECT:
 816       case T_ARRAY:
 817       case T_ADDRESS:
 818       case T_METADATA:
 819         // Oops are already boxed if required (JNI).
 820         if (ireg &lt; z_num_iarg_registers) {
 821           regs[i].set2(z_iarg_reg[ireg]);
 822           ++ireg;
 823         } else {
 824           regs[i].set2(VMRegImpl::stack2reg(stk));
 825           stk += inc_stk_for_longdouble;
 826         }
 827         break;
 828       case T_FLOAT:
 829         if (freg &lt; z_num_farg_registers) {
 830           regs[i].set1(z_farg_reg[freg]);
 831           ++freg;
 832         } else {
 833           regs[i].set1(VMRegImpl::stack2reg(stk+1));
 834           stk +=  inc_stk_for_intfloat;
 835         }
 836         break;
 837       case T_DOUBLE:
 838         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;expecting half&quot;);
 839         if (freg &lt; z_num_farg_registers) {
 840           regs[i].set2(z_farg_reg[freg]);
 841           ++freg;
 842         } else {
 843           // Put double on stack.
 844           regs[i].set2(VMRegImpl::stack2reg(stk));
 845           stk += inc_stk_for_longdouble;
 846         }
 847         break;
 848       case T_VOID:
 849         // Do not count halves.
 850         regs[i].set_bad();
 851         break;
 852       default:
 853         ShouldNotReachHere();
 854     }
 855   }
 856   return align_up(stk, 2);
 857 }
 858 
 859 ////////////////////////////////////////////////////////////////////////
 860 //
 861 //  Argument shufflers
 862 //
 863 ////////////////////////////////////////////////////////////////////////
 864 
 865 //----------------------------------------------------------------------
 866 // The java_calling_convention describes stack locations as ideal slots on
 867 // a frame with no abi restrictions. Since we must observe abi restrictions
 868 // (like the placement of the register window) the slots must be biased by
 869 // the following value.
 870 //----------------------------------------------------------------------
 871 static int reg2slot(VMReg r) {
 872   return r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
 873 }
 874 
 875 static int reg2offset(VMReg r) {
 876   return reg2slot(r) * VMRegImpl::stack_slot_size;
 877 }
 878 
 879 static void verify_oop_args(MacroAssembler *masm,
 880                             int total_args_passed,
 881                             const BasicType *sig_bt,
 882                             const VMRegPair *regs) {
 883   if (!VerifyOops) { return; }
 884 
 885   for (int i = 0; i &lt; total_args_passed; i++) {
 886     if (sig_bt[i] == T_OBJECT || sig_bt[i] == T_ARRAY) {
 887       VMReg r = regs[i].first();
 888       assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
 889 
 890       if (r-&gt;is_stack()) {
 891         __ z_lg(Z_R0_scratch,
 892                 Address(Z_SP, r-&gt;reg2stack() * VMRegImpl::stack_slot_size + wordSize));
 893         __ verify_oop(Z_R0_scratch);
 894       } else {
 895         __ verify_oop(r-&gt;as_Register());
 896       }
 897     }
 898   }
 899 }
 900 
 901 static void gen_special_dispatch(MacroAssembler *masm,
 902                                  int total_args_passed,
 903                                  vmIntrinsics::ID special_dispatch,
 904                                  const BasicType *sig_bt,
 905                                  const VMRegPair *regs) {
 906   verify_oop_args(masm, total_args_passed, sig_bt, regs);
 907 
 908   // Now write the args into the outgoing interpreter space.
 909   bool     has_receiver   = false;
 910   Register receiver_reg   = noreg;
 911   int      member_arg_pos = -1;
 912   Register member_reg     = noreg;
 913   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(special_dispatch);
 914 
 915   if (ref_kind != 0) {
 916     member_arg_pos = total_args_passed - 1;  // trailing MemberName argument
 917     member_reg = Z_R9;                       // Known to be free at this point.
 918     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
 919   } else {
 920     guarantee(special_dispatch == vmIntrinsics::_invokeBasic, &quot;special_dispatch=%d&quot;, special_dispatch);
 921     has_receiver = true;
 922   }
 923 
 924   if (member_reg != noreg) {
 925     // Load the member_arg into register, if necessary.
 926     assert(member_arg_pos &gt;= 0 &amp;&amp; member_arg_pos &lt; total_args_passed, &quot;oob&quot;);
 927     assert(sig_bt[member_arg_pos] == T_OBJECT, &quot;dispatch argument must be an object&quot;);
 928 
 929     VMReg r = regs[member_arg_pos].first();
 930     assert(r-&gt;is_valid(), &quot;bad member arg&quot;);
 931 
 932     if (r-&gt;is_stack()) {
 933       __ z_lg(member_reg, Address(Z_SP, reg2offset(r)));
 934     } else {
 935       // No data motion is needed.
 936       member_reg = r-&gt;as_Register();
 937     }
 938   }
 939 
 940   if (has_receiver) {
 941     // Make sure the receiver is loaded into a register.
 942     assert(total_args_passed &gt; 0, &quot;oob&quot;);
 943     assert(sig_bt[0] == T_OBJECT, &quot;receiver argument must be an object&quot;);
 944 
 945     VMReg r = regs[0].first();
 946     assert(r-&gt;is_valid(), &quot;bad receiver arg&quot;);
 947 
 948     if (r-&gt;is_stack()) {
 949       // Porting note: This assumes that compiled calling conventions always
 950       // pass the receiver oop in a register. If this is not true on some
 951       // platform, pick a temp and load the receiver from stack.
 952       assert(false, &quot;receiver always in a register&quot;);
 953       receiver_reg = Z_R13;  // Known to be free at this point.
 954       __ z_lg(receiver_reg, Address(Z_SP, reg2offset(r)));
 955     } else {
 956       // No data motion is needed.
 957       receiver_reg = r-&gt;as_Register();
 958     }
 959   }
 960 
 961   // Figure out which address we are really jumping to:
 962   MethodHandles::generate_method_handle_dispatch(masm, special_dispatch,
 963                                                  receiver_reg, member_reg,
 964                                                  /*for_compiler_entry:*/ true);
 965 }
 966 
 967 ////////////////////////////////////////////////////////////////////////
 968 //
 969 //  Argument shufflers
 970 //
 971 ////////////////////////////////////////////////////////////////////////
 972 
 973 // Is the size of a vector size (in bytes) bigger than a size saved by default?
 974 // 8 bytes registers are saved by default on z/Architecture.
 975 bool SharedRuntime::is_wide_vector(int size) {
 976   // Note, MaxVectorSize == 8 on this platform.
 977   assert(size &lt;= 8, &quot;%d bytes vectors are not supported&quot;, size);
 978   return size &gt; 8;
 979 }
 980 
 981 //----------------------------------------------------------------------
 982 // An oop arg. Must pass a handle not the oop itself
 983 //----------------------------------------------------------------------
 984 static void object_move(MacroAssembler *masm,
 985                         OopMap *map,
 986                         int oop_handle_offset,
 987                         int framesize_in_slots,
 988                         VMRegPair src,
 989                         VMRegPair dst,
 990                         bool is_receiver,
 991                         int *receiver_offset) {
 992   int frame_offset = framesize_in_slots*VMRegImpl::stack_slot_size;
 993 
 994   assert(!is_receiver || (is_receiver &amp;&amp; (*receiver_offset == -1)), &quot;only one receiving object per call, please.&quot;);
 995 
 996   // Must pass a handle. First figure out the location we use as a handle.
 997 
 998   if (src.first()-&gt;is_stack()) {
 999     // Oop is already on the stack, put handle on stack or in register
1000     // If handle will be on the stack, use temp reg to calculate it.
1001     Register rHandle = dst.first()-&gt;is_stack() ? Z_R1 : dst.first()-&gt;as_Register();
1002     Label    skip;
1003     int      slot_in_older_frame = reg2slot(src.first());
1004 
1005     guarantee(!is_receiver, &quot;expecting receiver in register&quot;);
1006     map-&gt;set_oop(VMRegImpl::stack2reg(slot_in_older_frame + framesize_in_slots));
1007 
1008     __ add2reg(rHandle, reg2offset(src.first())+frame_offset, Z_SP);
1009     __ load_and_test_long(Z_R0, Address(rHandle));
1010     __ z_brne(skip);
1011     // Use a NULL handle if oop is NULL.
1012     __ clear_reg(rHandle, true, false);
1013     __ bind(skip);
1014 
1015     // Copy handle to the right place (register or stack).
1016     if (dst.first()-&gt;is_stack()) {
1017       __ z_stg(rHandle, reg2offset(dst.first()), Z_SP);
1018     } // else
1019       // nothing to do. rHandle uses the correct register
1020   } else {
1021     // Oop is passed in an input register. We must flush it to the stack.
1022     const Register rOop = src.first()-&gt;as_Register();
1023     const Register rHandle = dst.first()-&gt;is_stack() ? Z_R1 : dst.first()-&gt;as_Register();
1024     int            oop_slot = (rOop-&gt;encoding()-Z_ARG1-&gt;encoding()) * VMRegImpl::slots_per_word + oop_handle_offset;
1025     int            oop_slot_offset = oop_slot*VMRegImpl::stack_slot_size;
1026     NearLabel skip;
1027 
1028     if (is_receiver) {
1029       *receiver_offset = oop_slot_offset;
1030     }
1031     map-&gt;set_oop(VMRegImpl::stack2reg(oop_slot));
1032 
1033     // Flush Oop to stack, calculate handle.
1034     __ z_stg(rOop, oop_slot_offset, Z_SP);
1035     __ add2reg(rHandle, oop_slot_offset, Z_SP);
1036 
1037     // If Oop == NULL, use a NULL handle.
1038     __ compare64_and_branch(rOop, (RegisterOrConstant)0L, Assembler::bcondNotEqual, skip);
1039     __ clear_reg(rHandle, true, false);
1040     __ bind(skip);
1041 
1042     // Copy handle to the right place (register or stack).
1043     if (dst.first()-&gt;is_stack()) {
1044       __ z_stg(rHandle, reg2offset(dst.first()), Z_SP);
1045     } // else
1046       // nothing to do here, since rHandle = dst.first()-&gt;as_Register in this case.
1047   }
1048 }
1049 
1050 //----------------------------------------------------------------------
1051 // A float arg. May have to do float reg to int reg conversion
1052 //----------------------------------------------------------------------
1053 static void float_move(MacroAssembler *masm,
1054                        VMRegPair src,
1055                        VMRegPair dst,
1056                        int framesize_in_slots,
1057                        int workspace_slot_offset) {
1058   int frame_offset = framesize_in_slots * VMRegImpl::stack_slot_size;
1059   int workspace_offset = workspace_slot_offset * VMRegImpl::stack_slot_size;
1060 
1061   // We do not accept an argument in a VMRegPair to be spread over two slots,
1062   // no matter what physical location (reg or stack) the slots may have.
1063   // We just check for the unaccepted slot to be invalid.
1064   assert(!src.second()-&gt;is_valid(), &quot;float in arg spread over two slots&quot;);
1065   assert(!dst.second()-&gt;is_valid(), &quot;float out arg spread over two slots&quot;);
1066 
1067   if (src.first()-&gt;is_stack()) {
1068     if (dst.first()-&gt;is_stack()) {
1069       // stack -&gt; stack. The easiest of the bunch.
1070       __ z_mvc(Address(Z_SP, reg2offset(dst.first())),
1071                Address(Z_SP, reg2offset(src.first()) + frame_offset), sizeof(float));
1072     } else {
1073       // stack to reg
1074       Address memaddr(Z_SP, reg2offset(src.first()) + frame_offset);
1075       if (dst.first()-&gt;is_Register()) {
1076         __ mem2reg_opt(dst.first()-&gt;as_Register(), memaddr, false);
1077       } else {
1078         __ mem2freg_opt(dst.first()-&gt;as_FloatRegister(), memaddr, false);
1079       }
1080     }
1081   } else if (src.first()-&gt;is_Register()) {
1082     if (dst.first()-&gt;is_stack()) {
1083       // gpr -&gt; stack
1084       __ reg2mem_opt(src.first()-&gt;as_Register(),
1085                      Address(Z_SP, reg2offset(dst.first()), false ));
1086     } else {
1087       if (dst.first()-&gt;is_Register()) {
1088         // gpr -&gt; gpr
1089         __ move_reg_if_needed(dst.first()-&gt;as_Register(), T_INT,
1090                               src.first()-&gt;as_Register(), T_INT);
1091       } else {
1092         if (VM_Version::has_FPSupportEnhancements()) {
1093           // gpr -&gt; fpr. Exploit z10 capability of direct transfer.
1094           __ z_ldgr(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_Register());
1095         } else {
1096           // gpr -&gt; fpr. Use work space on stack to transfer data.
1097           Address   stackaddr(Z_SP, workspace_offset);
1098 
1099           __ reg2mem_opt(src.first()-&gt;as_Register(), stackaddr, false);
1100           __ mem2freg_opt(dst.first()-&gt;as_FloatRegister(), stackaddr, false);
1101         }
1102       }
1103     }
1104   } else {
1105     if (dst.first()-&gt;is_stack()) {
1106       // fpr -&gt; stack
1107       __ freg2mem_opt(src.first()-&gt;as_FloatRegister(),
1108                       Address(Z_SP, reg2offset(dst.first())), false);
1109     } else {
1110       if (dst.first()-&gt;is_Register()) {
1111         if (VM_Version::has_FPSupportEnhancements()) {
1112           // fpr -&gt; gpr.
1113           __ z_lgdr(dst.first()-&gt;as_Register(), src.first()-&gt;as_FloatRegister());
1114         } else {
1115           // fpr -&gt; gpr. Use work space on stack to transfer data.
1116           Address   stackaddr(Z_SP, workspace_offset);
1117 
1118           __ freg2mem_opt(src.first()-&gt;as_FloatRegister(), stackaddr, false);
1119           __ mem2reg_opt(dst.first()-&gt;as_Register(), stackaddr, false);
1120         }
1121       } else {
1122         // fpr -&gt; fpr
1123         __ move_freg_if_needed(dst.first()-&gt;as_FloatRegister(), T_FLOAT,
1124                                src.first()-&gt;as_FloatRegister(), T_FLOAT);
1125       }
1126     }
1127   }
1128 }
1129 
1130 //----------------------------------------------------------------------
1131 // A double arg. May have to do double reg to long reg conversion
1132 //----------------------------------------------------------------------
1133 static void double_move(MacroAssembler *masm,
1134                         VMRegPair src,
1135                         VMRegPair dst,
1136                         int framesize_in_slots,
1137                         int workspace_slot_offset) {
1138   int frame_offset = framesize_in_slots*VMRegImpl::stack_slot_size;
1139   int workspace_offset = workspace_slot_offset*VMRegImpl::stack_slot_size;
1140 
1141   // Since src is always a java calling convention we know that the
1142   // src pair is always either all registers or all stack (and aligned?)
1143 
1144   if (src.first()-&gt;is_stack()) {
1145     if (dst.first()-&gt;is_stack()) {
1146       // stack -&gt; stack. The easiest of the bunch.
1147       __ z_mvc(Address(Z_SP, reg2offset(dst.first())),
1148                Address(Z_SP, reg2offset(src.first()) + frame_offset), sizeof(double));
1149     } else {
1150       // stack to reg
1151       Address stackaddr(Z_SP, reg2offset(src.first()) + frame_offset);
1152 
1153       if (dst.first()-&gt;is_Register()) {
1154         __ mem2reg_opt(dst.first()-&gt;as_Register(), stackaddr);
1155       } else {
1156         __ mem2freg_opt(dst.first()-&gt;as_FloatRegister(), stackaddr);
1157       }
1158     }
1159   } else if (src.first()-&gt;is_Register()) {
1160     if (dst.first()-&gt;is_stack()) {
1161       // gpr -&gt; stack
1162       __ reg2mem_opt(src.first()-&gt;as_Register(),
1163                      Address(Z_SP, reg2offset(dst.first())));
1164     } else {
1165       if (dst.first()-&gt;is_Register()) {
1166         // gpr -&gt; gpr
1167         __ move_reg_if_needed(dst.first()-&gt;as_Register(), T_LONG,
1168                               src.first()-&gt;as_Register(), T_LONG);
1169       } else {
1170         if (VM_Version::has_FPSupportEnhancements()) {
1171           // gpr -&gt; fpr. Exploit z10 capability of direct transfer.
1172           __ z_ldgr(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_Register());
1173         } else {
1174           // gpr -&gt; fpr. Use work space on stack to transfer data.
1175           Address stackaddr(Z_SP, workspace_offset);
1176           __ reg2mem_opt(src.first()-&gt;as_Register(), stackaddr);
1177           __ mem2freg_opt(dst.first()-&gt;as_FloatRegister(), stackaddr);
1178         }
1179       }
1180     }
1181   } else {
1182     if (dst.first()-&gt;is_stack()) {
1183       // fpr -&gt; stack
1184       __ freg2mem_opt(src.first()-&gt;as_FloatRegister(),
1185                       Address(Z_SP, reg2offset(dst.first())));
1186     } else {
1187       if (dst.first()-&gt;is_Register()) {
1188         if (VM_Version::has_FPSupportEnhancements()) {
1189           // fpr -&gt; gpr. Exploit z10 capability of direct transfer.
1190           __ z_lgdr(dst.first()-&gt;as_Register(), src.first()-&gt;as_FloatRegister());
1191         } else {
1192           // fpr -&gt; gpr. Use work space on stack to transfer data.
1193           Address stackaddr(Z_SP, workspace_offset);
1194 
1195           __ freg2mem_opt(src.first()-&gt;as_FloatRegister(), stackaddr);
1196           __ mem2reg_opt(dst.first()-&gt;as_Register(), stackaddr);
1197         }
1198       } else {
1199         // fpr -&gt; fpr
1200         // In theory these overlap but the ordering is such that this is likely a nop.
1201         __ move_freg_if_needed(dst.first()-&gt;as_FloatRegister(), T_DOUBLE,
1202                                src.first()-&gt;as_FloatRegister(), T_DOUBLE);
1203       }
1204     }
1205   }
1206 }
1207 
1208 //----------------------------------------------------------------------
1209 // A long arg.
1210 //----------------------------------------------------------------------
1211 static void long_move(MacroAssembler *masm,
1212                       VMRegPair src,
1213                       VMRegPair dst,
1214                       int framesize_in_slots) {
1215   int frame_offset = framesize_in_slots*VMRegImpl::stack_slot_size;
1216 
1217   if (src.first()-&gt;is_stack()) {
1218     if (dst.first()-&gt;is_stack()) {
1219       // stack -&gt; stack. The easiest of the bunch.
1220       __ z_mvc(Address(Z_SP, reg2offset(dst.first())),
1221                Address(Z_SP, reg2offset(src.first()) + frame_offset), sizeof(long));
1222     } else {
1223       // stack to reg
1224       assert(dst.first()-&gt;is_Register(), &quot;long dst value must be in GPR&quot;);
1225       __ mem2reg_opt(dst.first()-&gt;as_Register(),
1226                       Address(Z_SP, reg2offset(src.first()) + frame_offset));
1227     }
1228   } else {
1229     // reg to reg
1230     assert(src.first()-&gt;is_Register(), &quot;long src value must be in GPR&quot;);
1231     if (dst.first()-&gt;is_stack()) {
1232       // reg -&gt; stack
1233       __ reg2mem_opt(src.first()-&gt;as_Register(),
1234                      Address(Z_SP, reg2offset(dst.first())));
1235     } else {
1236       // reg -&gt; reg
1237       assert(dst.first()-&gt;is_Register(), &quot;long dst value must be in GPR&quot;);
1238       __ move_reg_if_needed(dst.first()-&gt;as_Register(),
1239                             T_LONG, src.first()-&gt;as_Register(), T_LONG);
1240     }
1241   }
1242 }
1243 
1244 
1245 //----------------------------------------------------------------------
1246 // A int-like arg.
1247 //----------------------------------------------------------------------
1248 // On z/Architecture we will store integer like items to the stack as 64 bit
1249 // items, according to the z/Architecture ABI, even though Java would only store
1250 // 32 bits for a parameter.
1251 // We do sign extension for all base types. That is ok since the only
1252 // unsigned base type is T_CHAR, and T_CHAR uses only 16 bits of an int.
1253 // Sign extension 32-&gt;64 bit will thus not affect the value.
1254 //----------------------------------------------------------------------
1255 static void move32_64(MacroAssembler *masm,
1256                       VMRegPair src,
1257                       VMRegPair dst,
1258                       int framesize_in_slots) {
1259   int frame_offset = framesize_in_slots * VMRegImpl::stack_slot_size;
1260 
1261   if (src.first()-&gt;is_stack()) {
1262     Address memaddr(Z_SP, reg2offset(src.first()) + frame_offset);
1263     if (dst.first()-&gt;is_stack()) {
1264       // stack -&gt; stack. MVC not posible due to sign extension.
1265       Address firstaddr(Z_SP, reg2offset(dst.first()));
1266       __ mem2reg_signed_opt(Z_R0_scratch, memaddr);
1267       __ reg2mem_opt(Z_R0_scratch, firstaddr);
1268     } else {
1269       // stack -&gt; reg, sign extended
1270       __ mem2reg_signed_opt(dst.first()-&gt;as_Register(), memaddr);
1271     }
1272   } else {
1273     if (dst.first()-&gt;is_stack()) {
1274       // reg -&gt; stack, sign extended
1275       Address firstaddr(Z_SP, reg2offset(dst.first()));
1276       __ z_lgfr(src.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1277       __ reg2mem_opt(src.first()-&gt;as_Register(), firstaddr);
1278     } else {
1279       // reg -&gt; reg, sign extended
1280       __ z_lgfr(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1281     }
1282   }
1283 }
1284 
1285 static void save_or_restore_arguments(MacroAssembler *masm,
1286                                       const int stack_slots,
1287                                       const int total_in_args,
1288                                       const int arg_save_area,
1289                                       OopMap *map,
1290                                       VMRegPair *in_regs,
1291                                       BasicType *in_sig_bt) {
1292 
1293   // If map is non-NULL then the code should store the values,
1294   // otherwise it should load them.
1295   int slot = arg_save_area;
1296   // Handle double words first.
1297   for (int i = 0; i &lt; total_in_args; i++) {
1298     if (in_regs[i].first()-&gt;is_FloatRegister() &amp;&amp; in_sig_bt[i] == T_DOUBLE) {
1299       int offset = slot * VMRegImpl::stack_slot_size;
1300       slot += VMRegImpl::slots_per_word;
1301       assert(slot &lt;= stack_slots, &quot;overflow (after DOUBLE stack slot)&quot;);
1302       const FloatRegister   freg = in_regs[i].first()-&gt;as_FloatRegister();
1303       Address   stackaddr(Z_SP, offset);
1304       if (map != NULL) {
1305         __ freg2mem_opt(freg, stackaddr);
1306       } else {
1307         __ mem2freg_opt(freg, stackaddr);
1308       }
1309     } else if (in_regs[i].first()-&gt;is_Register() &amp;&amp;
1310                (in_sig_bt[i] == T_LONG || in_sig_bt[i] == T_ARRAY)) {
1311       int offset = slot * VMRegImpl::stack_slot_size;
1312       const Register   reg = in_regs[i].first()-&gt;as_Register();
1313       if (map != NULL) {
1314         __ z_stg(reg, offset, Z_SP);
1315         if (in_sig_bt[i] == T_ARRAY) {
1316           map-&gt;set_oop(VMRegImpl::stack2reg(slot));
1317         }
1318       } else {
1319         __ z_lg(reg, offset, Z_SP);
1320       }
1321       slot += VMRegImpl::slots_per_word;
1322       assert(slot &lt;= stack_slots, &quot;overflow (after LONG/ARRAY stack slot)&quot;);
1323     }
1324   }
1325 
1326   // Save or restore single word registers.
1327   for (int i = 0; i &lt; total_in_args; i++) {
1328     if (in_regs[i].first()-&gt;is_Register()) {
1329       int offset = slot * VMRegImpl::stack_slot_size;
1330       // Value lives in an input register. Save it on stack.
1331       switch (in_sig_bt[i]) {
1332         case T_BOOLEAN:
1333         case T_CHAR:
1334         case T_BYTE:
1335         case T_SHORT:
1336         case T_INT: {
1337           const Register   reg = in_regs[i].first()-&gt;as_Register();
1338           Address   stackaddr(Z_SP, offset);
1339           if (map != NULL) {
1340             __ z_st(reg, stackaddr);
1341           } else {
1342             __ z_lgf(reg, stackaddr);
1343           }
1344           slot++;
1345           assert(slot &lt;= stack_slots, &quot;overflow (after INT or smaller stack slot)&quot;);
1346           break;
1347         }
1348         case T_ARRAY:
1349         case T_LONG:
1350           // handled above
1351           break;
1352         case T_OBJECT:
1353         default: ShouldNotReachHere();
1354       }
1355     } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1356       if (in_sig_bt[i] == T_FLOAT) {
1357         int offset = slot * VMRegImpl::stack_slot_size;
1358         slot++;
1359         assert(slot &lt;= stack_slots, &quot;overflow (after FLOAT stack slot)&quot;);
1360         const FloatRegister   freg = in_regs[i].first()-&gt;as_FloatRegister();
1361         Address   stackaddr(Z_SP, offset);
1362         if (map != NULL) {
1363           __ freg2mem_opt(freg, stackaddr, false);
1364         } else {
1365           __ mem2freg_opt(freg, stackaddr, false);
1366         }
1367       }
1368     } else if (in_regs[i].first()-&gt;is_stack() &amp;&amp;
1369                in_sig_bt[i] == T_ARRAY &amp;&amp; map != NULL) {
1370       int offset_in_older_frame = in_regs[i].first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1371       map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + stack_slots));
1372     }
1373   }
1374 }
1375 
1376 // Check GCLocker::needs_gc and enter the runtime if it&#39;s true. This
1377 // keeps a new JNI critical region from starting until a GC has been
1378 // forced. Save down any oops in registers and describe them in an OopMap.
1379 static void check_needs_gc_for_critical_native(MacroAssembler   *masm,
1380                                                 const int stack_slots,
1381                                                 const int total_in_args,
1382                                                 const int arg_save_area,
1383                                                 OopMapSet *oop_maps,
1384                                                 VMRegPair *in_regs,
1385                                                 BasicType *in_sig_bt) {
1386   __ block_comment(&quot;check GCLocker::needs_gc&quot;);
1387   Label cont;
1388 
1389   // Check GCLocker::_needs_gc flag.
1390   __ load_const_optimized(Z_R1_scratch, (long) GCLocker::needs_gc_address());
1391   __ z_cli(0, Z_R1_scratch, 0);
1392   __ z_bre(cont);
1393 
1394   // Save down any values that are live in registers and call into the
1395   // runtime to halt for a GC.
1396   OopMap *map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1397 
1398   save_or_restore_arguments(masm, stack_slots, total_in_args,
1399                             arg_save_area, map, in_regs, in_sig_bt);
1400   address the_pc = __ pc();
1401   __ set_last_Java_frame(Z_SP, noreg);
1402 
1403   __ block_comment(&quot;block_for_jni_critical&quot;);
1404   __ z_lgr(Z_ARG1, Z_thread);
1405 
1406   address entry_point = CAST_FROM_FN_PTR(address, SharedRuntime::block_for_jni_critical);
1407   __ call_c(entry_point);
1408   oop_maps-&gt;add_gc_map(__ offset(), map);
1409 
1410   __ reset_last_Java_frame();
1411 
1412   // Reload all the register arguments.
1413   save_or_restore_arguments(masm, stack_slots, total_in_args,
1414                             arg_save_area, NULL, in_regs, in_sig_bt);
1415 
1416   __ bind(cont);
1417 
1418   if (StressCriticalJNINatives) {
1419     // Stress register saving
1420     OopMap *map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1421     save_or_restore_arguments(masm, stack_slots, total_in_args,
1422                               arg_save_area, map, in_regs, in_sig_bt);
1423 
1424     // Destroy argument registers.
1425     for (int i = 0; i &lt; total_in_args; i++) {
1426       if (in_regs[i].first()-&gt;is_Register()) {
1427         // Don&#39;t set CC.
1428         __ clear_reg(in_regs[i].first()-&gt;as_Register(), true, false);
1429       } else {
1430         if (in_regs[i].first()-&gt;is_FloatRegister()) {
1431           FloatRegister fr = in_regs[i].first()-&gt;as_FloatRegister();
1432           __ z_lcdbr(fr, fr);
1433         }
1434       }
1435     }
1436 
1437     save_or_restore_arguments(masm, stack_slots, total_in_args,
1438                               arg_save_area, NULL, in_regs, in_sig_bt);
1439   }
1440 }
1441 
1442 static void move_ptr(MacroAssembler *masm,
1443                      VMRegPair src,
1444                      VMRegPair dst,
1445                      int framesize_in_slots) {
1446   int frame_offset = framesize_in_slots * VMRegImpl::stack_slot_size;
1447 
1448   if (src.first()-&gt;is_stack()) {
1449     if (dst.first()-&gt;is_stack()) {
1450       // stack to stack
1451       __ mem2reg_opt(Z_R0_scratch, Address(Z_SP, reg2offset(src.first()) + frame_offset));
1452       __ reg2mem_opt(Z_R0_scratch, Address(Z_SP, reg2offset(dst.first())));
1453     } else {
1454       // stack to reg
1455       __ mem2reg_opt(dst.first()-&gt;as_Register(),
1456                      Address(Z_SP, reg2offset(src.first()) + frame_offset));
1457     }
1458   } else {
1459     if (dst.first()-&gt;is_stack()) {
1460       // reg to stack
1461     __ reg2mem_opt(src.first()-&gt;as_Register(), Address(Z_SP, reg2offset(dst.first())));
1462     } else {
1463     __ lgr_if_needed(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1464     }
1465   }
1466 }
1467 
1468 // Unpack an array argument into a pointer to the body and the length
1469 // if the array is non-null, otherwise pass 0 for both.
1470 static void unpack_array_argument(MacroAssembler *masm,
1471                                    VMRegPair reg,
1472                                    BasicType in_elem_type,
1473                                    VMRegPair body_arg,
1474                                    VMRegPair length_arg,
1475                                    int framesize_in_slots) {
1476   Register tmp_reg = Z_tmp_2;
1477   Register tmp2_reg = Z_tmp_1;
1478 
1479   assert(!body_arg.first()-&gt;is_Register() || body_arg.first()-&gt;as_Register() != tmp_reg,
1480          &quot;possible collision&quot;);
1481   assert(!length_arg.first()-&gt;is_Register() || length_arg.first()-&gt;as_Register() != tmp_reg,
1482          &quot;possible collision&quot;);
1483 
1484   // Pass the length, ptr pair.
1485   NearLabel set_out_args;
1486   VMRegPair tmp, tmp2;
1487 
1488   tmp.set_ptr(tmp_reg-&gt;as_VMReg());
1489   tmp2.set_ptr(tmp2_reg-&gt;as_VMReg());
1490   if (reg.first()-&gt;is_stack()) {
1491     // Load the arg up from the stack.
1492     move_ptr(masm, reg, tmp, framesize_in_slots);
1493     reg = tmp;
1494   }
1495 
1496   const Register first = reg.first()-&gt;as_Register();
1497 
1498   // Don&#39;t set CC, indicate unused result.
1499   (void) __ clear_reg(tmp2_reg, true, false);
1500   if (tmp_reg != first) {
1501     __ clear_reg(tmp_reg, true, false);  // Don&#39;t set CC.
1502   }
1503   __ compare64_and_branch(first, (RegisterOrConstant)0L, Assembler::bcondEqual, set_out_args);
1504   __ z_lgf(tmp2_reg, Address(first, arrayOopDesc::length_offset_in_bytes()));
1505   __ add2reg(tmp_reg, arrayOopDesc::base_offset_in_bytes(in_elem_type), first);
1506 
1507   __ bind(set_out_args);
1508   move_ptr(masm, tmp, body_arg, framesize_in_slots);
1509   move32_64(masm, tmp2, length_arg, framesize_in_slots);
1510 }
1511 
1512 //----------------------------------------------------------------------
1513 // Wrap a JNI call.
1514 //----------------------------------------------------------------------
1515 #undef USE_RESIZE_FRAME
1516 nmethod *SharedRuntime::generate_native_wrapper(MacroAssembler *masm,
1517                                                 const methodHandle&amp; method,
1518                                                 int compile_id,
1519                                                 BasicType *in_sig_bt,
1520                                                 VMRegPair *in_regs,
1521                                                 BasicType ret_type) {
1522 #ifdef COMPILER2
1523   int total_in_args = method-&gt;size_of_parameters();
1524   if (method-&gt;is_method_handle_intrinsic()) {
1525     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1526     intptr_t start = (intptr_t) __ pc();
1527     int vep_offset = ((intptr_t) __ pc()) - start;
1528 
1529     gen_special_dispatch(masm, total_in_args,
1530                          method-&gt;intrinsic_id(), in_sig_bt, in_regs);
1531 
1532     int frame_complete = ((intptr_t)__ pc()) - start; // Not complete, period.
1533 
1534     __ flush();
1535 
1536     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // No out slots at all, actually.
1537 
1538     return nmethod::new_native_nmethod(method,
1539                                        compile_id,
1540                                        masm-&gt;code(),
1541                                        vep_offset,
1542                                        frame_complete,
1543                                        stack_slots / VMRegImpl::slots_per_word,
1544                                        in_ByteSize(-1),
1545                                        in_ByteSize(-1),
1546                                        (OopMapSet *) NULL);
1547   }
1548 
1549 
1550   ///////////////////////////////////////////////////////////////////////
1551   //
1552   //  Precalculations before generating any code
1553   //
1554   ///////////////////////////////////////////////////////////////////////
1555 
1556   bool is_critical_native = true;
1557   address native_func = method-&gt;critical_native_function();
1558   if (native_func == NULL) {
1559     native_func = method-&gt;native_function();
1560     is_critical_native = false;
1561   }
1562   assert(native_func != NULL, &quot;must have function&quot;);
1563 
1564   //---------------------------------------------------------------------
1565   // We have received a description of where all the java args are located
1566   // on entry to the wrapper. We need to convert these args to where
1567   // the jni function will expect them. To figure out where they go
1568   // we convert the java signature to a C signature by inserting
1569   // the hidden arguments as arg[0] and possibly arg[1] (static method).
1570   //
1571   // The first hidden argument arg[0] is a pointer to the JNI environment.
1572   // It is generated for every call.
1573   // The second argument arg[1] to the JNI call, which is hidden for static
1574   // methods, is the boxed lock object. For static calls, the lock object
1575   // is the static method itself. The oop is constructed here. for instance
1576   // calls, the lock is performed on the object itself, the pointer of
1577   // which is passed as the first visible argument.
1578   //---------------------------------------------------------------------
1579 
1580   // Additionally, on z/Architecture we must convert integers
1581   // to longs in the C signature. We do this in advance in order to have
1582   // no trouble with indexes into the bt-arrays.
1583   // So convert the signature and registers now, and adjust the total number
1584   // of in-arguments accordingly.
1585   bool method_is_static = method-&gt;is_static();
1586   int  total_c_args     = total_in_args;
1587 
1588   if (!is_critical_native) {
1589     int n_hidden_args = method_is_static ? 2 : 1;
1590     total_c_args += n_hidden_args;
1591   } else {
1592     // No JNIEnv*, no this*, but unpacked arrays (base+length).
1593     for (int i = 0; i &lt; total_in_args; i++) {
1594       if (in_sig_bt[i] == T_ARRAY) {
1595         total_c_args ++;
1596       }
1597     }
1598   }
1599 
1600   BasicType *out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1601   VMRegPair *out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1602   BasicType* in_elem_bt = NULL;
1603 
1604   // Create the signature for the C call:
1605   //   1) add the JNIEnv*
1606   //   2) add the class if the method is static
1607   //   3) copy the rest of the incoming signature (shifted by the number of
1608   //      hidden arguments)
1609 
1610   int argc = 0;
1611   if (!is_critical_native) {
1612     out_sig_bt[argc++] = T_ADDRESS;
1613     if (method-&gt;is_static()) {
1614       out_sig_bt[argc++] = T_OBJECT;
1615     }
1616 
1617     for (int i = 0; i &lt; total_in_args; i++) {
1618       out_sig_bt[argc++] = in_sig_bt[i];
1619     }
1620   } else {
1621     Thread* THREAD = Thread::current();
1622     in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
1623     SignatureStream ss(method-&gt;signature());
1624     int o = 0;
1625     for (int i = 0; i &lt; total_in_args; i++, o++) {
1626       if (in_sig_bt[i] == T_ARRAY) {
1627         // Arrays are passed as tuples (int, elem*).
1628         Symbol* atype = ss.as_symbol(CHECK_NULL);
1629         const char* at = atype-&gt;as_C_string();
1630         if (strlen(at) == 2) {
1631           assert(at[0] == &#39;[&#39;, &quot;must be&quot;);
1632           switch (at[1]) {
1633             case &#39;B&#39;: in_elem_bt[o]  = T_BYTE; break;
1634             case &#39;C&#39;: in_elem_bt[o]  = T_CHAR; break;
1635             case &#39;D&#39;: in_elem_bt[o]  = T_DOUBLE; break;
1636             case &#39;F&#39;: in_elem_bt[o]  = T_FLOAT; break;
1637             case &#39;I&#39;: in_elem_bt[o]  = T_INT; break;
1638             case &#39;J&#39;: in_elem_bt[o]  = T_LONG; break;
1639             case &#39;S&#39;: in_elem_bt[o]  = T_SHORT; break;
1640             case &#39;Z&#39;: in_elem_bt[o]  = T_BOOLEAN; break;
1641             default: ShouldNotReachHere();
1642           }
1643         }
1644       } else {
1645         in_elem_bt[o] = T_VOID;
1646       }
1647       if (in_sig_bt[i] != T_VOID) {
1648         assert(in_sig_bt[i] == ss.type(), &quot;must match&quot;);
1649         ss.next();
1650       }
1651     }
1652     assert(total_in_args == o, &quot;must match&quot;);
1653 
1654     for (int i = 0; i &lt; total_in_args; i++) {
1655       if (in_sig_bt[i] == T_ARRAY) {
1656         // Arrays are passed as tuples (int, elem*).
1657         out_sig_bt[argc++] = T_INT;
1658         out_sig_bt[argc++] = T_ADDRESS;
1659       } else {
1660         out_sig_bt[argc++] = in_sig_bt[i];
1661       }
1662     }
1663   }
1664 
1665   ///////////////////////////////////////////////////////////////////////
1666   // Now figure out where the args must be stored and how much stack space
1667   // they require (neglecting out_preserve_stack_slots but providing space
1668   // for storing the first five register arguments).
1669   // It&#39;s weird, see int_stk_helper.
1670   ///////////////////////////////////////////////////////////////////////
1671 
1672   //---------------------------------------------------------------------
1673   // Compute framesize for the wrapper.
1674   //
1675   // - We need to handlize all oops passed in registers.
1676   // - We must create space for them here that is disjoint from the save area.
1677   // - We always just allocate 5 words for storing down these object.
1678   //   This allows us to simply record the base and use the Ireg number to
1679   //   decide which slot to use.
1680   // - Note that the reg number used to index the stack slot is the inbound
1681   //   number, not the outbound number.
1682   // - We must shuffle args to match the native convention,
1683   //   and to include var-args space.
1684   //---------------------------------------------------------------------
1685 
1686   //---------------------------------------------------------------------
1687   // Calculate the total number of stack slots we will need:
1688   // - 1) abi requirements
1689   // - 2) outgoing args
1690   // - 3) space for inbound oop handle area
1691   // - 4) space for handlizing a klass if static method
1692   // - 5) space for a lock if synchronized method
1693   // - 6) workspace (save rtn value, int&lt;-&gt;float reg moves, ...)
1694   // - 7) filler slots for alignment
1695   //---------------------------------------------------------------------
1696   // Here is how the space we have allocated will look like.
1697   // Since we use resize_frame, we do not create a new stack frame,
1698   // but just extend the one we got with our own data area.
1699   //
1700   // If an offset or pointer name points to a separator line, it is
1701   // assumed that addressing with offset 0 selects storage starting
1702   // at the first byte above the separator line.
1703   //
1704   //
1705   //     ...                   ...
1706   //      | caller&#39;s frame      |
1707   // FP-&gt; |---------------------|
1708   //      | filler slots, if any|
1709   //     7| #slots == mult of 2 |
1710   //      |---------------------|
1711   //      | work space          |
1712   //     6| 2 slots = 8 bytes   |
1713   //      |---------------------|
1714   //     5| lock box (if sync)  |
1715   //      |---------------------| &lt;- lock_slot_offset
1716   //     4| klass (if static)   |
1717   //      |---------------------| &lt;- klass_slot_offset
1718   //     3| oopHandle area      |
1719   //      | (save area for      |
1720   //      |  critical natives)  |
1721   //      |                     |
1722   //      |                     |
1723   //      |---------------------| &lt;- oop_handle_offset
1724   //     2| outbound memory     |
1725   //     ...                   ...
1726   //      | based arguments     |
1727   //      |---------------------|
1728   //      | vararg              |
1729   //     ...                   ...
1730   //      | area                |
1731   //      |---------------------| &lt;- out_arg_slot_offset
1732   //     1| out_preserved_slots |
1733   //     ...                   ...
1734   //      | (z_abi spec)        |
1735   // SP-&gt; |---------------------| &lt;- FP_slot_offset (back chain)
1736   //     ...                   ...
1737   //
1738   //---------------------------------------------------------------------
1739 
1740   // *_slot_offset indicates offset from SP in #stack slots
1741   // *_offset      indicates offset from SP in #bytes
1742 
1743   int stack_slots = c_calling_convention(out_sig_bt, out_regs, /*regs2=*/NULL, total_c_args) + // 1+2
1744                     SharedRuntime::out_preserve_stack_slots(); // see c_calling_convention
1745 
1746   // Now the space for the inbound oop handle area.
1747   int total_save_slots = RegisterImpl::number_of_arg_registers * VMRegImpl::slots_per_word;
1748   if (is_critical_native) {
1749     // Critical natives may have to call out so they need a save area
1750     // for register arguments.
1751     int double_slots = 0;
1752     int single_slots = 0;
1753     for (int i = 0; i &lt; total_in_args; i++) {
1754       if (in_regs[i].first()-&gt;is_Register()) {
1755         const Register reg = in_regs[i].first()-&gt;as_Register();
1756         switch (in_sig_bt[i]) {
1757           case T_BOOLEAN:
1758           case T_BYTE:
1759           case T_SHORT:
1760           case T_CHAR:
1761           case T_INT:
1762           // Fall through.
1763           case T_ARRAY:
1764           case T_LONG: double_slots++; break;
1765           default:  ShouldNotReachHere();
1766         }
1767       } else {
1768         if (in_regs[i].first()-&gt;is_FloatRegister()) {
1769           switch (in_sig_bt[i]) {
1770             case T_FLOAT:  single_slots++; break;
1771             case T_DOUBLE: double_slots++; break;
1772             default:  ShouldNotReachHere();
1773           }
1774         }
1775       }
1776     }  // for
1777     total_save_slots = double_slots * 2 + align_up(single_slots, 2); // Round to even.
1778   }
1779 
1780   int oop_handle_slot_offset = stack_slots;
1781   stack_slots += total_save_slots;                                        // 3)
1782 
1783   int klass_slot_offset = 0;
1784   int klass_offset      = -1;
1785   if (method_is_static &amp;&amp; !is_critical_native) {                          // 4)
1786     klass_slot_offset  = stack_slots;
1787     klass_offset       = klass_slot_offset * VMRegImpl::stack_slot_size;
1788     stack_slots       += VMRegImpl::slots_per_word;
1789   }
1790 
1791   int lock_slot_offset = 0;
1792   int lock_offset      = -1;
1793   if (method-&gt;is_synchronized()) {                                        // 5)
1794     lock_slot_offset   = stack_slots;
1795     lock_offset        = lock_slot_offset * VMRegImpl::stack_slot_size;
1796     stack_slots       += VMRegImpl::slots_per_word;
1797   }
1798 
1799   int workspace_slot_offset= stack_slots;                                 // 6)
1800   stack_slots         += 2;
1801 
1802   // Now compute actual number of stack words we need.
1803   // Round to align stack properly.
1804   stack_slots = align_up(stack_slots,                                     // 7)
1805                          frame::alignment_in_bytes / VMRegImpl::stack_slot_size);
1806   int frame_size_in_bytes = stack_slots * VMRegImpl::stack_slot_size;
1807 
1808 
1809   ///////////////////////////////////////////////////////////////////////
1810   // Now we can start generating code
1811   ///////////////////////////////////////////////////////////////////////
1812 
1813   unsigned int wrapper_CodeStart  = __ offset();
1814   unsigned int wrapper_UEPStart;
1815   unsigned int wrapper_VEPStart;
1816   unsigned int wrapper_FrameDone;
1817   unsigned int wrapper_CRegsSet;
1818   Label     handle_pending_exception;
1819   Label     ic_miss;
1820 
1821   //---------------------------------------------------------------------
1822   // Unverified entry point (UEP)
1823   //---------------------------------------------------------------------
1824   wrapper_UEPStart = __ offset();
1825 
1826   // check ic: object class &lt;-&gt; cached class
1827   if (!method_is_static) __ nmethod_UEP(ic_miss);
1828   // Fill with nops (alignment of verified entry point).
1829   __ align(CodeEntryAlignment);
1830 
1831   //---------------------------------------------------------------------
1832   // Verified entry point (VEP)
1833   //---------------------------------------------------------------------
1834   wrapper_VEPStart = __ offset();
1835 
1836   __ save_return_pc();
1837   __ generate_stack_overflow_check(frame_size_in_bytes);  // Check before creating frame.
1838 #ifndef USE_RESIZE_FRAME
1839   __ push_frame(frame_size_in_bytes);                     // Create a new frame for the wrapper.
1840 #else
1841   __ resize_frame(-frame_size_in_bytes, Z_R0_scratch);    // No new frame for the wrapper.
1842                                                           // Just resize the existing one.
1843 #endif
1844 
1845   wrapper_FrameDone = __ offset();
1846 
1847   __ verify_thread();
1848 
1849   // Native nmethod wrappers never take possession of the oop arguments.
1850   // So the caller will gc the arguments.
1851   // The only thing we need an oopMap for is if the call is static.
1852   //
1853   // An OopMap for lock (and class if static), and one for the VM call itself
1854   OopMapSet  *oop_maps        = new OopMapSet();
1855   OopMap     *map             = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1856 
1857   if (is_critical_native) {
1858     check_needs_gc_for_critical_native(masm, stack_slots, total_in_args,
1859                                        oop_handle_slot_offset, oop_maps, in_regs, in_sig_bt);
1860   }
1861 
1862 
1863   //////////////////////////////////////////////////////////////////////
1864   //
1865   // The Grand Shuffle
1866   //
1867   //////////////////////////////////////////////////////////////////////
1868   //
1869   // We immediately shuffle the arguments so that for any vm call we have
1870   // to make from here on out (sync slow path, jvmti, etc.) we will have
1871   // captured the oops from our caller and have a valid oopMap for them.
1872   //
1873   //--------------------------------------------------------------------
1874   // Natives require 1 or 2 extra arguments over the normal ones: the JNIEnv*
1875   // (derived from JavaThread* which is in Z_thread) and, if static,
1876   // the class mirror instead of a receiver. This pretty much guarantees that
1877   // register layout will not match. We ignore these extra arguments during
1878   // the shuffle. The shuffle is described by the two calling convention
1879   // vectors we have in our possession. We simply walk the java vector to
1880   // get the source locations and the c vector to get the destinations.
1881   //
1882   // This is a trick. We double the stack slots so we can claim
1883   // the oops in the caller&#39;s frame. Since we are sure to have
1884   // more args than the caller doubling is enough to make
1885   // sure we can capture all the incoming oop args from the caller.
1886   //--------------------------------------------------------------------
1887 
1888   // Record sp-based slot for receiver on stack for non-static methods.
1889   int receiver_offset = -1;
1890 
1891   //--------------------------------------------------------------------
1892   // We move the arguments backwards because the floating point registers
1893   // destination will always be to a register with a greater or equal
1894   // register number or the stack.
1895   //   jix is the index of the incoming Java arguments.
1896   //   cix is the index of the outgoing C arguments.
1897   //--------------------------------------------------------------------
1898 
1899 #ifdef ASSERT
1900   bool reg_destroyed[RegisterImpl::number_of_registers];
1901   bool freg_destroyed[FloatRegisterImpl::number_of_registers];
1902   for (int r = 0; r &lt; RegisterImpl::number_of_registers; r++) {
1903     reg_destroyed[r] = false;
1904   }
1905   for (int f = 0; f &lt; FloatRegisterImpl::number_of_registers; f++) {
1906     freg_destroyed[f] = false;
1907   }
1908 #endif // ASSERT
1909 
1910   for (int jix = total_in_args - 1, cix = total_c_args - 1; jix &gt;= 0; jix--, cix--) {
1911 #ifdef ASSERT
1912     if (in_regs[jix].first()-&gt;is_Register()) {
1913       assert(!reg_destroyed[in_regs[jix].first()-&gt;as_Register()-&gt;encoding()], &quot;ack!&quot;);
1914     } else {
1915       if (in_regs[jix].first()-&gt;is_FloatRegister()) {
1916         assert(!freg_destroyed[in_regs[jix].first()-&gt;as_FloatRegister()-&gt;encoding()], &quot;ack!&quot;);
1917       }
1918     }
1919     if (out_regs[cix].first()-&gt;is_Register()) {
1920       reg_destroyed[out_regs[cix].first()-&gt;as_Register()-&gt;encoding()] = true;
1921     } else {
1922       if (out_regs[cix].first()-&gt;is_FloatRegister()) {
1923         freg_destroyed[out_regs[cix].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1924       }
1925     }
1926 #endif // ASSERT
1927 
1928     switch (in_sig_bt[jix]) {
1929       // Due to casting, small integers should only occur in pairs with type T_LONG.
1930       case T_BOOLEAN:
1931       case T_CHAR:
1932       case T_BYTE:
1933       case T_SHORT:
1934       case T_INT:
1935         // Move int and do sign extension.
1936         move32_64(masm, in_regs[jix], out_regs[cix], stack_slots);
1937         break;
1938 
1939       case T_LONG :
1940         long_move(masm, in_regs[jix], out_regs[cix], stack_slots);
1941         break;
1942 
1943       case T_ARRAY:
1944         if (is_critical_native) {
1945           int body_arg = cix;
1946           cix -= 1; // Point to length arg.
1947           unpack_array_argument(masm, in_regs[jix], in_elem_bt[jix], out_regs[body_arg], out_regs[cix], stack_slots);
1948           break;
1949         }
1950         // else fallthrough
1951       case T_OBJECT:
1952         assert(!is_critical_native, &quot;no oop arguments&quot;);
1953         object_move(masm, map, oop_handle_slot_offset, stack_slots, in_regs[jix], out_regs[cix],
1954                     ((jix == 0) &amp;&amp; (!method_is_static)),
1955                     &amp;receiver_offset);
1956         break;
1957       case T_VOID:
1958         break;
1959 
1960       case T_FLOAT:
1961         float_move(masm, in_regs[jix], out_regs[cix], stack_slots, workspace_slot_offset);
1962         break;
1963 
1964       case T_DOUBLE:
1965         assert(jix+1 &lt;  total_in_args &amp;&amp; in_sig_bt[jix+1]  == T_VOID &amp;&amp; out_sig_bt[cix+1] == T_VOID, &quot;bad arg list&quot;);
1966         double_move(masm, in_regs[jix], out_regs[cix], stack_slots, workspace_slot_offset);
1967         break;
1968 
1969       case T_ADDRESS:
1970         assert(false, &quot;found T_ADDRESS in java args&quot;);
1971         break;
1972 
1973       default:
1974         ShouldNotReachHere();
1975     }
1976   }
1977 
1978   //--------------------------------------------------------------------
1979   // Pre-load a static method&#39;s oop into ARG2.
1980   // Used both by locking code and the normal JNI call code.
1981   //--------------------------------------------------------------------
1982   if (method_is_static &amp;&amp; !is_critical_native) {
1983     __ set_oop_constant(JNIHandles::make_local(method-&gt;method_holder()-&gt;java_mirror()), Z_ARG2);
1984 
1985     // Now handlize the static class mirror in ARG2. It&#39;s known not-null.
1986     __ z_stg(Z_ARG2, klass_offset, Z_SP);
1987     map-&gt;set_oop(VMRegImpl::stack2reg(klass_slot_offset));
1988     __ add2reg(Z_ARG2, klass_offset, Z_SP);
1989   }
1990 
1991   // Get JNIEnv* which is first argument to native.
1992   if (!is_critical_native) {
1993     __ add2reg(Z_ARG1, in_bytes(JavaThread::jni_environment_offset()), Z_thread);
1994   }
1995 
1996   //////////////////////////////////////////////////////////////////////
1997   // We have all of the arguments setup at this point.
1998   // We MUST NOT touch any outgoing regs from this point on.
1999   // So if we must call out we must push a new frame.
2000   //////////////////////////////////////////////////////////////////////
2001 
2002 
2003   // Calc the current pc into Z_R10 and into wrapper_CRegsSet.
2004   // Both values represent the same position.
2005   __ get_PC(Z_R10);                // PC into register
2006   wrapper_CRegsSet = __ offset();  // and into into variable.
2007 
2008   // Z_R10 now has the pc loaded that we will use when we finally call to native.
2009 
2010   // We use the same pc/oopMap repeatedly when we call out.
2011   oop_maps-&gt;add_gc_map((int)(wrapper_CRegsSet-wrapper_CodeStart), map);
2012 
2013   // Lock a synchronized method.
2014 
2015   if (method-&gt;is_synchronized()) {
2016     assert(!is_critical_native, &quot;unhandled&quot;);
2017 
2018     // ATTENTION: args and Z_R10 must be preserved.
2019     Register r_oop  = Z_R11;
2020     Register r_box  = Z_R12;
2021     Register r_tmp1 = Z_R13;
2022     Register r_tmp2 = Z_R7;
2023     Label done;
2024 
2025     // Load the oop for the object or class. R_carg2_classorobject contains
2026     // either the handlized oop from the incoming arguments or the handlized
2027     // class mirror (if the method is static).
2028     __ z_lg(r_oop, 0, Z_ARG2);
2029 
2030     lock_offset = (lock_slot_offset * VMRegImpl::stack_slot_size);
2031     // Get the lock box slot&#39;s address.
2032     __ add2reg(r_box, lock_offset, Z_SP);
2033 
2034 #ifdef ASSERT
2035     if (UseBiasedLocking)
2036       // Making the box point to itself will make it clear it went unused
2037       // but also be obviously invalid.
2038       __ z_stg(r_box, 0, r_box);
2039 #endif // ASSERT
2040 
2041     // Try fastpath for locking.
2042     // Fast_lock kills r_temp_1, r_temp_2. (Don&#39;t use R1 as temp, won&#39;t work!)
2043     __ compiler_fast_lock_object(r_oop, r_box, r_tmp1, r_tmp2);
2044     __ z_bre(done);
2045 
2046     //-------------------------------------------------------------------------
2047     // None of the above fast optimizations worked so we have to get into the
2048     // slow case of monitor enter. Inline a special case of call_VM that
2049     // disallows any pending_exception.
2050     //-------------------------------------------------------------------------
2051 
2052     Register oldSP = Z_R11;
2053 
2054     __ z_lgr(oldSP, Z_SP);
2055 
2056     RegisterSaver::save_live_registers(masm, RegisterSaver::arg_registers);
2057 
2058     // Prepare arguments for call.
2059     __ z_lg(Z_ARG1, 0, Z_ARG2); // Ynboxed class mirror or unboxed object.
2060     __ add2reg(Z_ARG2, lock_offset, oldSP);
2061     __ z_lgr(Z_ARG3, Z_thread);
2062 
2063     __ set_last_Java_frame(oldSP, Z_R10 /* gc map pc */);
2064 
2065     // Do the call.
2066     __ load_const_optimized(Z_R1_scratch, CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C));
2067     __ call(Z_R1_scratch);
2068 
2069     __ reset_last_Java_frame();
2070 
2071     RegisterSaver::restore_live_registers(masm, RegisterSaver::arg_registers);
2072 #ifdef ASSERT
2073     { Label L;
2074       __ load_and_test_long(Z_R0, Address(Z_thread, Thread::pending_exception_offset()));
2075       __ z_bre(L);
2076       __ stop(&quot;no pending exception allowed on exit from IR::monitorenter&quot;);
2077       __ bind(L);
2078     }
2079 #endif
2080     __ bind(done);
2081   } // lock for synchronized methods
2082 
2083 
2084   //////////////////////////////////////////////////////////////////////
2085   // Finally just about ready to make the JNI call.
2086   //////////////////////////////////////////////////////////////////////
2087 
2088   // Use that pc we placed in Z_R10 a while back as the current frame anchor.
2089   __ set_last_Java_frame(Z_SP, Z_R10);
2090 
2091   // Transition from _thread_in_Java to _thread_in_native.
2092   __ set_thread_state(_thread_in_native);
2093 
2094 
2095   //////////////////////////////////////////////////////////////////////
2096   // This is the JNI call.
2097   //////////////////////////////////////////////////////////////////////
2098 
2099   __ call_c(native_func);
2100 
2101 
2102   //////////////////////////////////////////////////////////////////////
2103   // We have survived the call once we reach here.
2104   //////////////////////////////////////////////////////////////////////
2105 
2106 
2107   //--------------------------------------------------------------------
2108   // Unpack native results.
2109   //--------------------------------------------------------------------
2110   // For int-types, we do any needed sign-extension required.
2111   // Care must be taken that the return value (in Z_ARG1 = Z_RET = Z_R2
2112   // or in Z_FARG0 = Z_FRET = Z_F0) will survive any VM calls for
2113   // blocking or unlocking.
2114   // An OOP result (handle) is done specially in the slow-path code.
2115   //--------------------------------------------------------------------
2116   switch (ret_type) {
2117     case T_VOID:    break;         // Nothing to do!
2118     case T_FLOAT:   break;         // Got it where we want it (unless slow-path)
2119     case T_DOUBLE:  break;         // Got it where we want it (unless slow-path)
2120     case T_LONG:    break;         // Got it where we want it (unless slow-path)
2121     case T_OBJECT:  break;         // Really a handle.
2122                                    // Cannot de-handlize until after reclaiming jvm_lock.
2123     case T_ARRAY:   break;
2124 
2125     case T_BOOLEAN:                // 0 -&gt; false(0); !0 -&gt; true(1)
2126       __ z_lngfr(Z_RET, Z_RET);    // Force sign bit on except for zero.
2127       __ z_srlg(Z_RET, Z_RET, 63); // Shift sign bit into least significant pos.
2128       break;
2129     case T_BYTE:    __ z_lgbr(Z_RET, Z_RET);  break; // sign extension
2130     case T_CHAR:    __ z_llghr(Z_RET, Z_RET); break; // unsigned result
2131     case T_SHORT:   __ z_lghr(Z_RET, Z_RET);  break; // sign extension
2132     case T_INT:     __ z_lgfr(Z_RET, Z_RET);  break; // sign-extend for beauty.
2133 
2134     default:
2135       ShouldNotReachHere();
2136       break;
2137   }
2138 
2139 
2140   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
2141   // This additional state is necessary because reading and testing the synchronization
2142   // state is not atomic w.r.t. GC, as this scenario demonstrates:
2143   //   - Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
2144   //   - VM thread changes sync state to synchronizing and suspends threads for GC.
2145   //   - Thread A is resumed to finish this native method, but doesn&#39;t block here since it
2146   //     didn&#39;t see any synchronization in progress, and escapes.
2147 
2148   // Transition from _thread_in_native to _thread_in_native_trans.
2149   __ set_thread_state(_thread_in_native_trans);
2150 
2151   // Safepoint synchronization
2152   //--------------------------------------------------------------------
2153   // Must we block?
2154   //--------------------------------------------------------------------
2155   // Block, if necessary, before resuming in _thread_in_Java state.
2156   // In order for GC to work, don&#39;t clear the last_Java_sp until after blocking.
2157   //--------------------------------------------------------------------
2158   Label after_transition;
2159   {
2160     Label no_block, sync;
2161 
2162     save_native_result(masm, ret_type, workspace_slot_offset); // Make Z_R2 available as work reg.
2163 
2164     // Force this write out before the read below.
2165     __ z_fence();
2166 
2167     __ safepoint_poll(sync, Z_R1);
2168 
2169     __ load_and_test_int(Z_R0, Address(Z_thread, JavaThread::suspend_flags_offset()));
2170     __ z_bre(no_block);
2171 
2172     // Block. Save any potential method result value before the operation and
2173     // use a leaf call to leave the last_Java_frame setup undisturbed. Doing this
2174     // lets us share the oopMap we used when we went native rather than create
2175     // a distinct one for this pc.
2176     //
2177     __ bind(sync);
2178     __ z_acquire();
2179 
2180     address entry_point = is_critical_native ? CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)
2181                                              : CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans);
2182 
2183     __ call_VM_leaf(entry_point, Z_thread);
2184 
2185     if (is_critical_native) {
2186       restore_native_result(masm, ret_type, workspace_slot_offset);
2187       __ z_bru(after_transition); // No thread state transition here.
2188     }
2189     __ bind(no_block);
2190     restore_native_result(masm, ret_type, workspace_slot_offset);
2191   }
2192 
2193   //--------------------------------------------------------------------
2194   // Thread state is thread_in_native_trans. Any safepoint blocking has
2195   // already happened so we can now change state to _thread_in_Java.
2196   //--------------------------------------------------------------------
2197   // Transition from _thread_in_native_trans to _thread_in_Java.
2198   __ set_thread_state(_thread_in_Java);
2199   __ bind(after_transition);
2200 
2201 
2202   //--------------------------------------------------------------------
2203   // Reguard any pages if necessary.
2204   // Protect native result from being destroyed.
2205   //--------------------------------------------------------------------
2206 
2207   Label no_reguard;
2208 
2209   __ z_cli(Address(Z_thread, JavaThread::stack_guard_state_offset() + in_ByteSize(sizeof(JavaThread::StackGuardState) - 1)),
2210            JavaThread::stack_guard_yellow_reserved_disabled);
2211 
2212   __ z_bre(no_reguard);
2213 
2214   save_native_result(masm, ret_type, workspace_slot_offset);
2215   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages), Z_method);
2216   restore_native_result(masm, ret_type, workspace_slot_offset);
2217 
2218   __ bind(no_reguard);
2219 
2220 
2221   // Synchronized methods (slow path only)
2222   // No pending exceptions for now.
2223   //--------------------------------------------------------------------
2224   // Handle possibly pending exception (will unlock if necessary).
2225   // Native result is, if any is live, in Z_FRES or Z_RES.
2226   //--------------------------------------------------------------------
2227   // Unlock
2228   //--------------------------------------------------------------------
2229   if (method-&gt;is_synchronized()) {
2230     const Register r_oop        = Z_R11;
2231     const Register r_box        = Z_R12;
2232     const Register r_tmp1       = Z_R13;
2233     const Register r_tmp2       = Z_R7;
2234     Label done;
2235 
2236     // Get unboxed oop of class mirror or object ...
2237     int   offset = method_is_static ? klass_offset : receiver_offset;
2238 
2239     assert(offset != -1, &quot;&quot;);
2240     __ z_lg(r_oop, offset, Z_SP);
2241 
2242     // ... and address of lock object box.
2243     __ add2reg(r_box, lock_offset, Z_SP);
2244 
2245     // Try fastpath for unlocking.
2246     __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2); // Don&#39;t use R1 as temp.
2247     __ z_bre(done);
2248 
2249     // Slow path for unlocking.
2250     // Save and restore any potential method result value around the unlocking operation.
2251     const Register R_exc = Z_R11;
2252 
2253     save_native_result(masm, ret_type, workspace_slot_offset);
2254 
2255     // Must save pending exception around the slow-path VM call. Since it&#39;s a
2256     // leaf call, the pending exception (if any) can be kept in a register.
2257     __ z_lg(R_exc, Address(Z_thread, Thread::pending_exception_offset()));
2258     assert(R_exc-&gt;is_nonvolatile(), &quot;exception register must be non-volatile&quot;);
2259 
2260     // Must clear pending-exception before re-entering the VM. Since this is
2261     // a leaf call, pending-exception-oop can be safely kept in a register.
2262     __ clear_mem(Address(Z_thread, Thread::pending_exception_offset()), sizeof(intptr_t));
2263 
2264     // Inline a special case of call_VM that disallows any pending_exception.
2265 
2266     // Get locked oop from the handle we passed to jni.
2267     __ z_lg(Z_ARG1, offset, Z_SP);
2268     __ add2reg(Z_ARG2, lock_offset, Z_SP);
2269     __ z_lgr(Z_ARG3, Z_thread);
2270 
2271     __ load_const_optimized(Z_R1_scratch, CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C));
2272 
2273     __ call(Z_R1_scratch);
2274 
2275 #ifdef ASSERT
2276     {
2277       Label L;
2278       __ load_and_test_long(Z_R0, Address(Z_thread, Thread::pending_exception_offset()));
2279       __ z_bre(L);
2280       __ stop(&quot;no pending exception allowed on exit from IR::monitorexit&quot;);
2281       __ bind(L);
2282     }
2283 #endif
2284 
2285     // Check_forward_pending_exception jump to forward_exception if any pending
2286     // exception is set. The forward_exception routine expects to see the
2287     // exception in pending_exception and not in a register. Kind of clumsy,
2288     // since all folks who branch to forward_exception must have tested
2289     // pending_exception first and hence have it in a register already.
2290     __ z_stg(R_exc, Address(Z_thread, Thread::pending_exception_offset()));
2291     restore_native_result(masm, ret_type, workspace_slot_offset);
2292     __ z_bru(done);
2293     __ z_illtrap(0x66);
2294 
2295     __ bind(done);
2296   }
2297 
2298 
2299   //--------------------------------------------------------------------
2300   // Clear &quot;last Java frame&quot; SP and PC.
2301   //--------------------------------------------------------------------
2302   __ verify_thread(); // Z_thread must be correct.
2303 
2304   __ reset_last_Java_frame();
2305 
2306   // Unpack oop result, e.g. JNIHandles::resolve result.
2307   if (ret_type == T_OBJECT || ret_type == T_ARRAY) {
2308     __ resolve_jobject(Z_RET, /* tmp1 */ Z_R13, /* tmp2 */ Z_R7);
2309   }
2310 
2311   if (CheckJNICalls) {
2312     // clear_pending_jni_exception_check
2313     __ clear_mem(Address(Z_thread, JavaThread::pending_jni_exception_check_fn_offset()), sizeof(oop));
2314   }
2315 
2316   // Reset handle block.
2317   if (!is_critical_native) {
2318     __ z_lg(Z_R1_scratch, Address(Z_thread, JavaThread::active_handles_offset()));
2319     __ clear_mem(Address(Z_R1_scratch, JNIHandleBlock::top_offset_in_bytes()), 4);
2320 
2321     // Check for pending exceptions.
2322     __ load_and_test_long(Z_R0, Address(Z_thread, Thread::pending_exception_offset()));
2323     __ z_brne(handle_pending_exception);
2324   }
2325 
2326 
2327   //////////////////////////////////////////////////////////////////////
2328   // Return
2329   //////////////////////////////////////////////////////////////////////
2330 
2331 
2332 #ifndef USE_RESIZE_FRAME
2333   __ pop_frame();                     // Pop wrapper frame.
2334 #else
2335   __ resize_frame(frame_size_in_bytes, Z_R0_scratch);  // Revert stack extension.
2336 #endif
2337   __ restore_return_pc();             // This is the way back to the caller.
2338   __ z_br(Z_R14);
2339 
2340 
2341   //////////////////////////////////////////////////////////////////////
2342   // Out-of-line calls to the runtime.
2343   //////////////////////////////////////////////////////////////////////
2344 
2345 
2346   if (!is_critical_native) {
2347 
2348     //---------------------------------------------------------------------
2349     // Handler for pending exceptions (out-of-line).
2350     //---------------------------------------------------------------------
2351     // Since this is a native call, we know the proper exception handler
2352     // is the empty function. We just pop this frame and then jump to
2353     // forward_exception_entry. Z_R14 will contain the native caller&#39;s
2354     // return PC.
2355     __ bind(handle_pending_exception);
2356     __ pop_frame();
2357     __ load_const_optimized(Z_R1_scratch, StubRoutines::forward_exception_entry());
2358     __ restore_return_pc();
2359     __ z_br(Z_R1_scratch);
2360 
2361     //---------------------------------------------------------------------
2362     // Handler for a cache miss (out-of-line)
2363     //---------------------------------------------------------------------
2364     __ call_ic_miss_handler(ic_miss, 0x77, 0, Z_R1_scratch);
2365   }
2366   __ flush();
2367 
2368 
2369   //////////////////////////////////////////////////////////////////////
2370   // end of code generation
2371   //////////////////////////////////////////////////////////////////////
2372 
2373 
2374   nmethod *nm = nmethod::new_native_nmethod(method,
2375                                             compile_id,
2376                                             masm-&gt;code(),
2377                                             (int)(wrapper_VEPStart-wrapper_CodeStart),
2378                                             (int)(wrapper_FrameDone-wrapper_CodeStart),
2379                                             stack_slots / VMRegImpl::slots_per_word,
2380                                             (method_is_static ? in_ByteSize(klass_offset) : in_ByteSize(receiver_offset)),
2381                                             in_ByteSize(lock_offset),
2382                                             oop_maps);
2383 
2384   if (is_critical_native) {
2385     nm-&gt;set_lazy_critical_native(true);
2386   }
2387 
2388   return nm;
2389 #else
2390   ShouldNotReachHere();
2391   return NULL;
2392 #endif // COMPILER2
2393 }
2394 
2395 static address gen_c2i_adapter(MacroAssembler  *masm,
2396                                int total_args_passed,
2397                                int comp_args_on_stack,
2398                                const BasicType *sig_bt,
2399                                const VMRegPair *regs,
2400                                Label &amp;skip_fixup) {
2401   // Before we get into the guts of the C2I adapter, see if we should be here
2402   // at all. We&#39;ve come from compiled code and are attempting to jump to the
2403   // interpreter, which means the caller made a static call to get here
2404   // (vcalls always get a compiled target if there is one). Check for a
2405   // compiled target. If there is one, we need to patch the caller&#39;s call.
2406 
2407   // These two defs MUST MATCH code in gen_i2c2i_adapter!
2408   const Register ientry = Z_R11;
2409   const Register code   = Z_R11;
2410 
2411   address c2i_entrypoint;
2412   Label   patch_callsite;
2413 
2414   // Regular (verified) c2i entry point.
2415   c2i_entrypoint = __ pc();
2416 
2417   // Call patching needed?
2418   __ load_and_test_long(Z_R0_scratch, method_(code));
2419   __ z_lg(ientry, method_(interpreter_entry));  // Preload interpreter entry (also if patching).
2420   __ z_brne(patch_callsite);                    // Patch required if code != NULL (compiled target exists).
2421 
2422   __ bind(skip_fixup);  // Return point from patch_callsite.
2423 
2424   // Since all args are passed on the stack, total_args_passed*wordSize is the
2425   // space we need. We need ABI scratch area but we use the caller&#39;s since
2426   // it has already been allocated.
2427 
2428   const int abi_scratch = frame::z_top_ijava_frame_abi_size;
2429   int       extraspace  = align_up(total_args_passed, 2)*wordSize + abi_scratch;
2430   Register  sender_SP   = Z_R10;
2431   Register  value       = Z_R12;
2432 
2433   // Remember the senderSP so we can pop the interpreter arguments off of the stack.
2434   // In addition, frame manager expects initial_caller_sp in Z_R10.
2435   __ z_lgr(sender_SP, Z_SP);
2436 
2437   // This should always fit in 14 bit immediate.
2438   __ resize_frame(-extraspace, Z_R0_scratch);
2439 
2440   // We use the caller&#39;s ABI scratch area (out_preserved_stack_slots) for the initial
2441   // args. This essentially moves the callers ABI scratch area from the top to the
2442   // bottom of the arg area.
2443 
2444   int st_off =  extraspace - wordSize;
2445 
2446   // Now write the args into the outgoing interpreter space.
2447   for (int i = 0; i &lt; total_args_passed; i++) {
2448     VMReg r_1 = regs[i].first();
2449     VMReg r_2 = regs[i].second();
2450     if (!r_1-&gt;is_valid()) {
2451       assert(!r_2-&gt;is_valid(), &quot;&quot;);
2452       continue;
2453     }
2454     if (r_1-&gt;is_stack()) {
2455       // The calling convention produces OptoRegs that ignore the preserve area (abi scratch).
2456       // We must account for it here.
2457       int ld_off = (r_1-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
2458 
2459       if (!r_2-&gt;is_valid()) {
2460         __ z_mvc(Address(Z_SP, st_off), Address(sender_SP, ld_off), sizeof(void*));
2461       } else {
2462         // longs are given 2 64-bit slots in the interpreter,
2463         // but the data is passed in only 1 slot.
2464         if (sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
2465 #ifdef ASSERT
2466           __ clear_mem(Address(Z_SP, st_off), sizeof(void *));
2467 #endif
2468           st_off -= wordSize;
2469         }
2470         __ z_mvc(Address(Z_SP, st_off), Address(sender_SP, ld_off), sizeof(void*));
2471       }
2472     } else {
2473       if (r_1-&gt;is_Register()) {
2474         if (!r_2-&gt;is_valid()) {
2475           __ z_st(r_1-&gt;as_Register(), st_off, Z_SP);
2476         } else {
2477           // longs are given 2 64-bit slots in the interpreter, but the
2478           // data is passed in only 1 slot.
2479           if (sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
2480 #ifdef ASSERT
2481             __ clear_mem(Address(Z_SP, st_off), sizeof(void *));
2482 #endif
2483             st_off -= wordSize;
2484           }
2485           __ z_stg(r_1-&gt;as_Register(), st_off, Z_SP);
2486         }
2487       } else {
2488         assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
2489         if (!r_2-&gt;is_valid()) {
2490           __ z_ste(r_1-&gt;as_FloatRegister(), st_off, Z_SP);
2491         } else {
2492           // In 64bit, doubles are given 2 64-bit slots in the interpreter, but the
2493           // data is passed in only 1 slot.
2494           // One of these should get known junk...
2495 #ifdef ASSERT
2496           __ z_lzdr(Z_F1);
2497           __ z_std(Z_F1, st_off, Z_SP);
2498 #endif
2499           st_off-=wordSize;
2500           __ z_std(r_1-&gt;as_FloatRegister(), st_off, Z_SP);
2501         }
2502       }
2503     }
2504     st_off -= wordSize;
2505   }
2506 
2507 
2508   // Jump to the interpreter just as if interpreter was doing it.
2509   __ add2reg(Z_esp, st_off, Z_SP);
2510 
2511   // Frame_manager expects initial_caller_sp (= SP without resize by c2i) in Z_R10.
2512   __ z_br(ientry);
2513 
2514 
2515   // Prevent illegal entry to out-of-line code.
2516   __ z_illtrap(0x22);
2517 
2518   // Generate out-of-line runtime call to patch caller,
2519   // then continue as interpreted.
2520 
2521   // IF you lose the race you go interpreted.
2522   // We don&#39;t see any possible endless c2i -&gt; i2c -&gt; c2i ...
2523   // transitions no matter how rare.
2524   __ bind(patch_callsite);
2525 
2526   RegisterSaver::save_live_registers(masm, RegisterSaver::arg_registers);
2527   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite), Z_method, Z_R14);
2528   RegisterSaver::restore_live_registers(masm, RegisterSaver::arg_registers);
2529   __ z_bru(skip_fixup);
2530 
2531   // end of out-of-line code
2532 
2533   return c2i_entrypoint;
2534 }
2535 
2536 // On entry, the following registers are set
2537 //
2538 //    Z_thread  r8  - JavaThread*
2539 //    Z_method  r9  - callee&#39;s method (method to be invoked)
2540 //    Z_esp     r7  - operand (or expression) stack pointer of caller. one slot above last arg.
2541 //    Z_SP      r15 - SP prepared by call stub such that caller&#39;s outgoing args are near top
2542 //
2543 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,
2544                                     int total_args_passed,
2545                                     int comp_args_on_stack,
2546                                     const BasicType *sig_bt,
2547                                     const VMRegPair *regs) {
2548   const Register value = Z_R12;
2549   const Register ld_ptr= Z_esp;
2550 
2551   int ld_offset = total_args_passed * wordSize;
2552 
2553   // Cut-out for having no stack args.
2554   if (comp_args_on_stack) {
2555     // Sig words on the stack are greater than VMRegImpl::stack0. Those in
2556     // registers are below. By subtracting stack0, we either get a negative
2557     // number (all values in registers) or the maximum stack slot accessed.
2558     // Convert VMRegImpl (4 byte) stack slots to words.
2559     int comp_words_on_stack = align_up(comp_args_on_stack*VMRegImpl::stack_slot_size, wordSize)&gt;&gt;LogBytesPerWord;
2560     // Round up to miminum stack alignment, in wordSize
2561     comp_words_on_stack = align_up(comp_words_on_stack, 2);
2562 
2563     __ resize_frame(-comp_words_on_stack*wordSize, Z_R0_scratch);
2564   }
2565 
2566   // Now generate the shuffle code. Pick up all register args and move the
2567   // rest through register value=Z_R12.
2568   for (int i = 0; i &lt; total_args_passed; i++) {
2569     if (sig_bt[i] == T_VOID) {
2570       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
2571       continue;
2572     }
2573 
2574     // Pick up 0, 1 or 2 words from ld_ptr.
2575     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(),
2576            &quot;scrambled load targets?&quot;);
2577     VMReg r_1 = regs[i].first();
2578     VMReg r_2 = regs[i].second();
2579     if (!r_1-&gt;is_valid()) {
2580       assert(!r_2-&gt;is_valid(), &quot;&quot;);
2581       continue;
2582     }
2583     if (r_1-&gt;is_FloatRegister()) {
2584       if (!r_2-&gt;is_valid()) {
2585         __ z_le(r_1-&gt;as_FloatRegister(), ld_offset, ld_ptr);
2586         ld_offset-=wordSize;
2587       } else {
2588         // Skip the unused interpreter slot.
2589         __ z_ld(r_1-&gt;as_FloatRegister(), ld_offset - wordSize, ld_ptr);
2590         ld_offset -= 2 * wordSize;
2591       }
2592     } else {
2593       if (r_1-&gt;is_stack()) {
2594         // Must do a memory to memory move.
2595         int st_off = (r_1-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
2596 
2597         if (!r_2-&gt;is_valid()) {
2598           __ z_mvc(Address(Z_SP, st_off), Address(ld_ptr, ld_offset), sizeof(void*));
2599         } else {
2600           // In 64bit, longs are given 2 64-bit slots in the interpreter, but the
2601           // data is passed in only 1 slot.
2602           if (sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
2603             ld_offset -= wordSize;
2604           }
2605           __ z_mvc(Address(Z_SP, st_off), Address(ld_ptr, ld_offset), sizeof(void*));
2606         }
2607       } else {
2608         if (!r_2-&gt;is_valid()) {
2609           // Not sure we need to do this but it shouldn&#39;t hurt.
2610           if (sig_bt[i] == T_OBJECT || sig_bt[i] == T_ADDRESS || sig_bt[i] == T_ARRAY) {
2611             __ z_lg(r_1-&gt;as_Register(), ld_offset, ld_ptr);
2612           } else {
2613             __ z_l(r_1-&gt;as_Register(), ld_offset, ld_ptr);
2614           }
2615         } else {
2616           // In 64bit, longs are given 2 64-bit slots in the interpreter, but the
2617           // data is passed in only 1 slot.
2618           if (sig_bt[i] == T_LONG || sig_bt[i] == T_DOUBLE) {
2619             ld_offset -= wordSize;
2620           }
2621           __ z_lg(r_1-&gt;as_Register(), ld_offset, ld_ptr);
2622         }
2623       }
2624       ld_offset -= wordSize;
2625     }
2626   }
2627 
2628   // Jump to the compiled code just as if compiled code was doing it.
2629   // load target address from method oop:
2630   __ z_lg(Z_R1_scratch, Address(Z_method, Method::from_compiled_offset()));
2631 
2632   // Store method oop into thread-&gt;callee_target.
2633   // 6243940: We might end up in handle_wrong_method if
2634   // the callee is deoptimized as we race thru here. If that
2635   // happens we don&#39;t want to take a safepoint because the
2636   // caller frame will look interpreted and arguments are now
2637   // &quot;compiled&quot; so it is much better to make this transition
2638   // invisible to the stack walking code. Unfortunately, if
2639   // we try and find the callee by normal means a safepoint
2640   // is possible. So we stash the desired callee in the thread
2641   // and the vm will find it there should this case occur.
2642   __ z_stg(Z_method, thread_(callee_target));
2643 
2644   __ z_br(Z_R1_scratch);
2645 }
2646 
2647 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
2648                                                             int total_args_passed,
2649                                                             int comp_args_on_stack,
2650                                                             const BasicType *sig_bt,
2651                                                             const VMRegPair *regs,
2652                                                             AdapterFingerPrint* fingerprint) {
2653   __ align(CodeEntryAlignment);
2654   address i2c_entry = __ pc();
2655   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
2656 
2657   address c2i_unverified_entry;
2658 
2659   Label skip_fixup;
2660   {
2661     Label ic_miss;
2662     const int klass_offset           = oopDesc::klass_offset_in_bytes();
2663     const int holder_klass_offset    = CompiledICHolder::holder_klass_offset();
2664     const int holder_metadata_offset = CompiledICHolder::holder_metadata_offset();
2665 
2666     // Out-of-line call to ic_miss handler.
2667     __ call_ic_miss_handler(ic_miss, 0x11, 0, Z_R1_scratch);
2668 
2669     // Unverified Entry Point UEP
2670     __ align(CodeEntryAlignment);
2671     c2i_unverified_entry = __ pc();
2672 
2673     // Check the pointers.
2674     if (!ImplicitNullChecks || MacroAssembler::needs_explicit_null_check(klass_offset)) {
2675       __ z_ltgr(Z_ARG1, Z_ARG1);
2676       __ z_bre(ic_miss);
2677     }
2678     __ verify_oop(Z_ARG1);
2679 
2680     // Check ic: object class &lt;-&gt; cached class
2681     // Compress cached class for comparison. That&#39;s more efficient.
2682     if (UseCompressedClassPointers) {
2683       __ z_lg(Z_R11, holder_klass_offset, Z_method);             // Z_R11 is overwritten a few instructions down anyway.
2684       __ compare_klass_ptr(Z_R11, klass_offset, Z_ARG1, false); // Cached class can&#39;t be zero.
2685     } else {
2686       __ z_clc(klass_offset, sizeof(void *)-1, Z_ARG1, holder_klass_offset, Z_method);
2687     }
2688     __ z_brne(ic_miss);  // Cache miss: call runtime to handle this.
2689 
2690     // This def MUST MATCH code in gen_c2i_adapter!
2691     const Register code = Z_R11;
2692 
2693     __ z_lg(Z_method, holder_metadata_offset, Z_method);
2694     __ load_and_test_long(Z_R0, method_(code));
2695     __ z_brne(ic_miss);  // Cache miss: call runtime to handle this.
2696 
2697     // Fallthru to VEP. Duplicate LTG, but saved taken branch.
2698   }
2699 
2700   address c2i_entry;
2701   c2i_entry = gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
2702 
2703   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);
2704 }
2705 
2706 // This function returns the adjust size (in number of words) to a c2i adapter
2707 // activation for use during deoptimization.
2708 //
2709 // Actually only compiled frames need to be adjusted, but it
2710 // doesn&#39;t harm to adjust entry and interpreter frames, too.
2711 //
2712 int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals) {
2713   assert(callee_locals &gt;= callee_parameters,
2714           &quot;test and remove; got more parms than locals&quot;);
2715   // Handle the abi adjustment here instead of doing it in push_skeleton_frames.
2716   return (callee_locals - callee_parameters) * Interpreter::stackElementWords +
2717          frame::z_parent_ijava_frame_abi_size / BytesPerWord;
2718 }
2719 
2720 uint SharedRuntime::out_preserve_stack_slots() {
2721   return frame::z_jit_out_preserve_size/VMRegImpl::stack_slot_size;
2722 }
2723 
2724 //
2725 // Frame generation for deopt and uncommon trap blobs.
2726 //
2727 static void push_skeleton_frame(MacroAssembler* masm,
2728                           /* Unchanged */
2729                           Register frame_sizes_reg,
2730                           Register pcs_reg,
2731                           /* Invalidate */
2732                           Register frame_size_reg,
2733                           Register pc_reg) {
2734   BLOCK_COMMENT(&quot;  push_skeleton_frame {&quot;);
2735    __ z_lg(pc_reg, 0, pcs_reg);
2736    __ z_lg(frame_size_reg, 0, frame_sizes_reg);
2737    __ z_stg(pc_reg, _z_abi(return_pc), Z_SP);
2738    Register fp = pc_reg;
2739    __ push_frame(frame_size_reg, fp);
2740 #ifdef ASSERT
2741    // The magic is required for successful walking skeletal frames.
2742    __ load_const_optimized(frame_size_reg/*tmp*/, frame::z_istate_magic_number);
2743    __ z_stg(frame_size_reg, _z_ijava_state_neg(magic), fp);
2744    // Fill other slots that are supposedly not necessary with eye catchers.
2745    __ load_const_optimized(frame_size_reg/*use as tmp*/, 0xdeadbad1);
2746    __ z_stg(frame_size_reg, _z_ijava_state_neg(top_frame_sp), fp);
2747    // The sender_sp of the bottom frame is set before pushing it.
2748    // The sender_sp of non bottom frames is their caller&#39;s top_frame_sp, which
2749    // is unknown here. Luckily it is not needed before filling the frame in
2750    // layout_activation(), we assert this by setting an eye catcher (see
2751    // comments on sender_sp in frame_s390.hpp).
2752    __ z_stg(frame_size_reg, _z_ijava_state_neg(sender_sp), Z_SP);
2753 #endif // ASSERT
2754   BLOCK_COMMENT(&quot;  } push_skeleton_frame&quot;);
2755 }
2756 
2757 // Loop through the UnrollBlock info and create new frames.
2758 static void push_skeleton_frames(MacroAssembler* masm, bool deopt,
2759                             /* read */
2760                             Register unroll_block_reg,
2761                             /* invalidate */
2762                             Register frame_sizes_reg,
2763                             Register number_of_frames_reg,
2764                             Register pcs_reg,
2765                             Register tmp1,
2766                             Register tmp2) {
2767   BLOCK_COMMENT(&quot;push_skeleton_frames {&quot;);
2768   // _number_of_frames is of type int (deoptimization.hpp).
2769   __ z_lgf(number_of_frames_reg,
2770            Address(unroll_block_reg, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
2771   __ z_lg(pcs_reg,
2772           Address(unroll_block_reg, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
2773   __ z_lg(frame_sizes_reg,
2774           Address(unroll_block_reg, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
2775 
2776   // stack: (caller_of_deoptee, ...).
2777 
2778   // If caller_of_deoptee is a compiled frame, then we extend it to make
2779   // room for the callee&#39;s locals and the frame::z_parent_ijava_frame_abi.
2780   // See also Deoptimization::last_frame_adjust() above.
2781   // Note: entry and interpreted frames are adjusted, too. But this doesn&#39;t harm.
2782 
2783   __ z_lgf(Z_R1_scratch,
2784            Address(unroll_block_reg, Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes()));
2785   __ z_lgr(tmp1, Z_SP);  // Save the sender sp before extending the frame.
2786   __ resize_frame_sub(Z_R1_scratch, tmp2/*tmp*/);
2787   // The oldest skeletal frame requires a valid sender_sp to make it walkable
2788   // (it is required to find the original pc of caller_of_deoptee if it is marked
2789   // for deoptimization - see nmethod::orig_pc_addr()).
2790   __ z_stg(tmp1, _z_ijava_state_neg(sender_sp), Z_SP);
2791 
2792   // Now push the new interpreter frames.
2793   Label loop, loop_entry;
2794 
2795   // Make sure that there is at least one entry in the array.
2796   DEBUG_ONLY(__ z_ltgr(number_of_frames_reg, number_of_frames_reg));
2797   __ asm_assert_ne(&quot;array_size must be &gt; 0&quot;, 0x205);
2798 
2799   __ z_bru(loop_entry);
2800 
2801   __ bind(loop);
2802 
2803   __ add2reg(frame_sizes_reg, wordSize);
2804   __ add2reg(pcs_reg, wordSize);
2805 
2806   __ bind(loop_entry);
2807 
2808   // Allocate a new frame, fill in the pc.
2809   push_skeleton_frame(masm, frame_sizes_reg, pcs_reg, tmp1, tmp2);
2810 
2811   __ z_aghi(number_of_frames_reg, -1);  // Emit AGHI, because it sets the condition code
2812   __ z_brne(loop);
2813 
2814   // Set the top frame&#39;s return pc.
2815   __ add2reg(pcs_reg, wordSize);
2816   __ z_lg(Z_R0_scratch, 0, pcs_reg);
2817   __ z_stg(Z_R0_scratch, _z_abi(return_pc), Z_SP);
2818   BLOCK_COMMENT(&quot;} push_skeleton_frames&quot;);
2819 }
2820 
2821 //------------------------------generate_deopt_blob----------------------------
2822 void SharedRuntime::generate_deopt_blob() {
2823   // Allocate space for the code.
2824   ResourceMark rm;
2825   // Setup code generation tools.
2826   CodeBuffer buffer(&quot;deopt_blob&quot;, 2048, 1024);
2827   InterpreterMacroAssembler* masm = new InterpreterMacroAssembler(&amp;buffer);
2828   Label exec_mode_initialized;
2829   OopMap* map = NULL;
2830   OopMapSet *oop_maps = new OopMapSet();
2831 
2832   unsigned int start_off = __ offset();
2833   Label cont;
2834 
2835   // --------------------------------------------------------------------------
2836   // Normal entry (non-exception case)
2837   //
2838   // We have been called from the deopt handler of the deoptee.
2839   // Z_R14 points behind the call in the deopt handler. We adjust
2840   // it such that it points to the start of the deopt handler.
2841   // The return_pc has been stored in the frame of the deoptee and
2842   // will replace the address of the deopt_handler in the call
2843   // to Deoptimization::fetch_unroll_info below.
2844   // The (int) cast is necessary, because -((unsigned int)14)
2845   // is an unsigned int.
2846   __ add2reg(Z_R14, -(int)HandlerImpl::size_deopt_handler());
2847 
2848   const Register   exec_mode_reg = Z_tmp_1;
2849 
2850   // stack: (deoptee, caller of deoptee, ...)
2851 
2852   // pushes an &quot;unpack&quot; frame
2853   // R14 contains the return address pointing into the deoptimized
2854   // nmethod that was valid just before the nmethod was deoptimized.
2855   // save R14 into the deoptee frame.  the `fetch_unroll_info&#39;
2856   // procedure called below will read it from there.
2857   map = RegisterSaver::save_live_registers(masm, RegisterSaver::all_registers);
2858 
2859   // note the entry point.
2860   __ load_const_optimized(exec_mode_reg, Deoptimization::Unpack_deopt);
2861   __ z_bru(exec_mode_initialized);
2862 
2863 #ifndef COMPILER1
2864   int reexecute_offset = 1; // odd offset will produce odd pc, which triggers an hardware trap
2865 #else
2866   // --------------------------------------------------------------------------
2867   // Reexecute entry
2868   // - Z_R14 = Deopt Handler in nmethod
2869 
2870   int reexecute_offset = __ offset() - start_off;
2871 
2872   // No need to update map as each call to save_live_registers will produce identical oopmap
2873   (void) RegisterSaver::save_live_registers(masm, RegisterSaver::all_registers);
2874 
2875   __ load_const_optimized(exec_mode_reg, Deoptimization::Unpack_reexecute);
2876   __ z_bru(exec_mode_initialized);
2877 #endif
2878 
2879 
2880   // --------------------------------------------------------------------------
2881   // Exception entry. We reached here via a branch. Registers on entry:
2882   // - Z_EXC_OOP (Z_ARG1) = exception oop
2883   // - Z_EXC_PC  (Z_ARG2) = the exception pc.
2884 
2885   int exception_offset = __ offset() - start_off;
2886 
2887   // all registers are dead at this entry point, except for Z_EXC_OOP, and
2888   // Z_EXC_PC which contain the exception oop and exception pc
2889   // respectively.  Set them in TLS and fall thru to the
2890   // unpack_with_exception_in_tls entry point.
2891 
2892   // Store exception oop and pc in thread (location known to GC).
2893   // Need this since the call to &quot;fetch_unroll_info()&quot; may safepoint.
2894   __ z_stg(Z_EXC_OOP, Address(Z_thread, JavaThread::exception_oop_offset()));
2895   __ z_stg(Z_EXC_PC,  Address(Z_thread, JavaThread::exception_pc_offset()));
2896 
2897   // fall through
2898 
2899   int exception_in_tls_offset = __ offset() - start_off;
2900 
2901   // new implementation because exception oop is now passed in JavaThread
2902 
2903   // Prolog for exception case
2904   // All registers must be preserved because they might be used by LinearScan
2905   // Exceptiop oop and throwing PC are passed in JavaThread
2906 
2907   // load throwing pc from JavaThread and us it as the return address of the current frame.
2908   __ z_lg(Z_R1_scratch, Address(Z_thread, JavaThread::exception_pc_offset()));
2909 
2910   // Save everything in sight.
2911   (void) RegisterSaver::save_live_registers(masm, RegisterSaver::all_registers, Z_R1_scratch);
2912 
2913   // Now it is safe to overwrite any register
2914 
2915   // Clear the exception pc field in JavaThread
2916   __ clear_mem(Address(Z_thread, JavaThread::exception_pc_offset()), 8);
2917 
2918   // Deopt during an exception.  Save exec mode for unpack_frames.
2919   __ load_const_optimized(exec_mode_reg, Deoptimization::Unpack_exception);
2920 
2921 
2922 #ifdef ASSERT
2923   // verify that there is really an exception oop in JavaThread
2924   __ z_lg(Z_ARG1, Address(Z_thread, JavaThread::exception_oop_offset()));
2925   __ verify_oop(Z_ARG1);
2926 
2927   // verify that there is no pending exception
2928   __ asm_assert_mem8_is_zero(in_bytes(Thread::pending_exception_offset()), Z_thread,
2929                              &quot;must not have pending exception here&quot;, __LINE__);
2930 #endif
2931 
2932   // --------------------------------------------------------------------------
2933   // At this point, the live registers are saved and
2934   // the exec_mode_reg has been set up correctly.
2935   __ bind(exec_mode_initialized);
2936 
2937   // stack: (&quot;unpack&quot; frame, deoptee, caller_of_deoptee, ...).
2938 
2939   {
2940   const Register unroll_block_reg  = Z_tmp_2;
2941 
2942   // we need to set `last_Java_frame&#39; because `fetch_unroll_info&#39; will
2943   // call `last_Java_frame()&#39;.  however we can&#39;t block and no gc will
2944   // occur so we don&#39;t need an oopmap. the value of the pc in the
2945   // frame is not particularly important.  it just needs to identify the blob.
2946 
2947   // Don&#39;t set last_Java_pc anymore here (is implicitly NULL then).
2948   // the correct PC is retrieved in pd_last_frame() in that case.
2949   __ set_last_Java_frame(/*sp*/Z_SP, noreg);
2950   // With EscapeAnalysis turned on, this call may safepoint
2951   // despite it&#39;s marked as &quot;leaf call&quot;!
2952   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info), Z_thread, exec_mode_reg);
2953   // Set an oopmap for the call site this describes all our saved volatile registers
2954   int offs = __ offset();
2955   oop_maps-&gt;add_gc_map(offs, map);
2956 
2957   __ reset_last_Java_frame();
2958   // save the return value.
2959   __ z_lgr(unroll_block_reg, Z_RET);
2960   // restore the return registers that have been saved
2961   // (among other registers) by save_live_registers(...).
2962   RegisterSaver::restore_result_registers(masm);
2963 
2964   // reload the exec mode from the UnrollBlock (it might have changed)
2965   __ z_llgf(exec_mode_reg, Address(unroll_block_reg, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2966 
2967   // In excp_deopt_mode, restore and clear exception oop which we
2968   // stored in the thread during exception entry above. The exception
2969   // oop will be the return value of this stub.
2970   NearLabel skip_restore_excp;
2971   __ compare64_and_branch(exec_mode_reg, Deoptimization::Unpack_exception, Assembler::bcondNotEqual, skip_restore_excp);
2972   __ z_lg(Z_RET, thread_(exception_oop));
2973   __ clear_mem(thread_(exception_oop), 8);
2974   __ bind(skip_restore_excp);
2975 
2976   // remove the &quot;unpack&quot; frame
2977   __ pop_frame();
2978 
2979   // stack: (deoptee, caller of deoptee, ...).
2980 
2981   // pop the deoptee&#39;s frame
2982   __ pop_frame();
2983 
2984   // stack: (caller_of_deoptee, ...).
2985 
2986   // loop through the `UnrollBlock&#39; info and create interpreter frames.
2987   push_skeleton_frames(masm, true/*deopt*/,
2988                   unroll_block_reg,
2989                   Z_tmp_3,
2990                   Z_tmp_4,
2991                   Z_ARG5,
2992                   Z_ARG4,
2993                   Z_ARG3);
2994 
2995   // stack: (skeletal interpreter frame, ..., optional skeletal
2996   // interpreter frame, caller of deoptee, ...).
2997   }
2998 
2999   // push an &quot;unpack&quot; frame taking care of float / int return values.
3000   __ push_frame(RegisterSaver::live_reg_frame_size(RegisterSaver::all_registers));
3001 
3002   // stack: (unpack frame, skeletal interpreter frame, ..., optional
3003   // skeletal interpreter frame, caller of deoptee, ...).
3004 
3005   // spill live volatile registers since we&#39;ll do a call.
3006   __ z_stg(Z_RET, offset_of(frame::z_abi_160_spill, spill[0]), Z_SP);
3007   __ z_std(Z_FRET, offset_of(frame::z_abi_160_spill, spill[1]), Z_SP);
3008 
3009   // let the unpacker layout information in the skeletal frames just allocated.
3010   __ get_PC(Z_RET);
3011   __ set_last_Java_frame(/*sp*/Z_SP, /*pc*/Z_RET);
3012   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames),
3013                   Z_thread/*thread*/, exec_mode_reg/*exec_mode*/);
3014 
3015   __ reset_last_Java_frame();
3016 
3017   // restore the volatiles saved above.
3018   __ z_lg(Z_RET, offset_of(frame::z_abi_160_spill, spill[0]), Z_SP);
3019   __ z_ld(Z_FRET, offset_of(frame::z_abi_160_spill, spill[1]), Z_SP);
3020 
3021   // pop the &quot;unpack&quot; frame.
3022   __ pop_frame();
3023   __ restore_return_pc();
3024 
3025   // stack: (top interpreter frame, ..., optional interpreter frame,
3026   // caller of deoptee, ...).
3027 
3028   __ z_lg(Z_fp, _z_abi(callers_sp), Z_SP); // restore frame pointer
3029   __ restore_bcp();
3030   __ restore_locals();
3031   __ restore_esp();
3032 
3033   // return to the interpreter entry point.
3034   __ z_br(Z_R14);
3035 
3036   // Make sure all code is generated
3037   masm-&gt;flush();
3038 
3039   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset, reexecute_offset, RegisterSaver::live_reg_frame_size(RegisterSaver::all_registers)/wordSize);
3040   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
3041 }
3042 
3043 
3044 #ifdef COMPILER2
3045 //------------------------------generate_uncommon_trap_blob--------------------
3046 void SharedRuntime::generate_uncommon_trap_blob() {
3047   // Allocate space for the code
3048   ResourceMark rm;
3049   // Setup code generation tools
3050   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
3051   InterpreterMacroAssembler* masm = new InterpreterMacroAssembler(&amp;buffer);
3052 
3053   Register unroll_block_reg = Z_tmp_1;
3054   Register klass_index_reg  = Z_ARG2;
3055   Register unc_trap_reg     = Z_ARG2;
3056 
3057   // stack: (deoptee, caller_of_deoptee, ...).
3058 
3059   // push a dummy &quot;unpack&quot; frame and call
3060   // `Deoptimization::uncommon_trap&#39; to pack the compiled frame into a
3061   // vframe array and return the `UnrollBlock&#39; information.
3062 
3063   // save R14 to compiled frame.
3064   __ save_return_pc();
3065   // push the &quot;unpack_frame&quot;.
3066   __ push_frame_abi160(0);
3067 
3068   // stack: (unpack frame, deoptee, caller_of_deoptee, ...).
3069 
3070   // set the &quot;unpack&quot; frame as last_Java_frame.
3071   // `Deoptimization::uncommon_trap&#39; expects it and considers its
3072   // sender frame as the deoptee frame.
3073   __ get_PC(Z_R1_scratch);
3074   __ set_last_Java_frame(/*sp*/Z_SP, /*pc*/Z_R1_scratch);
3075 
3076   __ z_lgr(klass_index_reg, Z_ARG1);  // passed implicitly as ARG2
3077   __ z_lghi(Z_ARG3, Deoptimization::Unpack_uncommon_trap);  // passed implicitly as ARG3
3078   BLOCK_COMMENT(&quot;call Deoptimization::uncommon_trap()&quot;);
3079   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap), Z_thread);
3080 
3081   __ reset_last_Java_frame();
3082 
3083   // pop the &quot;unpack&quot; frame
3084   __ pop_frame();
3085 
3086   // stack: (deoptee, caller_of_deoptee, ...).
3087 
3088   // save the return value.
3089   __ z_lgr(unroll_block_reg, Z_RET);
3090 
3091   // pop the deoptee frame.
3092   __ pop_frame();
3093 
3094   // stack: (caller_of_deoptee, ...).
3095 
3096 #ifdef ASSERT
3097   assert(Immediate::is_uimm8(Deoptimization::Unpack_LIMIT), &quot;Code not fit for larger immediates&quot;);
3098   assert(Immediate::is_uimm8(Deoptimization::Unpack_uncommon_trap), &quot;Code not fit for larger immediates&quot;);
3099   const int unpack_kind_byte_offset = Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()
3100 #ifndef VM_LITTLE_ENDIAN
3101   + 3
3102 #endif
3103   ;
3104   if (Displacement::is_shortDisp(unpack_kind_byte_offset)) {
3105     __ z_cli(unpack_kind_byte_offset, unroll_block_reg, Deoptimization::Unpack_uncommon_trap);
3106   } else {
3107     __ z_cliy(unpack_kind_byte_offset, unroll_block_reg, Deoptimization::Unpack_uncommon_trap);
3108   }
3109   __ asm_assert_eq(&quot;SharedRuntime::generate_deopt_blob: expected Unpack_uncommon_trap&quot;, 0);
3110 #endif
3111 
3112   __ zap_from_to(Z_SP, Z_SP, Z_R0_scratch, Z_R1, 500, -1);
3113 
3114   // allocate new interpreter frame(s) and possibly resize the caller&#39;s frame
3115   // (no more adapters !)
3116   push_skeleton_frames(masm, false/*deopt*/,
3117                   unroll_block_reg,
3118                   Z_tmp_2,
3119                   Z_tmp_3,
3120                   Z_tmp_4,
3121                   Z_ARG5,
3122                   Z_ARG4);
3123 
3124   // stack: (skeletal interpreter frame, ..., optional skeletal
3125   // interpreter frame, (resized) caller of deoptee, ...).
3126 
3127   // push a dummy &quot;unpack&quot; frame taking care of float return values.
3128   // call `Deoptimization::unpack_frames&#39; to layout information in the
3129   // interpreter frames just created
3130 
3131   // push the &quot;unpack&quot; frame
3132    const unsigned int framesize_in_bytes = __ push_frame_abi160(0);
3133 
3134   // stack: (unpack frame, skeletal interpreter frame, ..., optional
3135   // skeletal interpreter frame, (resized) caller of deoptee, ...).
3136 
3137   // set the &quot;unpack&quot; frame as last_Java_frame
3138   __ get_PC(Z_R1_scratch);
3139   __ set_last_Java_frame(/*sp*/Z_SP, /*pc*/Z_R1_scratch);
3140 
3141   // indicate it is the uncommon trap case
3142   BLOCK_COMMENT(&quot;call Deoptimization::Unpack_uncommon_trap()&quot;);
3143   __ load_const_optimized(unc_trap_reg, Deoptimization::Unpack_uncommon_trap);
3144   // let the unpacker layout information in the skeletal frames just allocated.
3145   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames), Z_thread);
3146 
3147   __ reset_last_Java_frame();
3148   // pop the &quot;unpack&quot; frame
3149   __ pop_frame();
3150   // restore LR from top interpreter frame
3151   __ restore_return_pc();
3152 
3153   // stack: (top interpreter frame, ..., optional interpreter frame,
3154   // (resized) caller of deoptee, ...).
3155 
3156   __ z_lg(Z_fp, _z_abi(callers_sp), Z_SP); // restore frame pointer
3157   __ restore_bcp();
3158   __ restore_locals();
3159   __ restore_esp();
3160 
3161   // return to the interpreter entry point
3162   __ z_br(Z_R14);
3163 
3164   masm-&gt;flush();
3165   _uncommon_trap_blob = UncommonTrapBlob::create(&amp;buffer, NULL, framesize_in_bytes/wordSize);
3166 }
3167 #endif // COMPILER2
3168 
3169 
3170 //------------------------------generate_handler_blob------
3171 //
3172 // Generate a special Compile2Runtime blob that saves all registers,
3173 // and setup oopmap.
3174 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
3175   assert(StubRoutines::forward_exception_entry() != NULL,
3176          &quot;must be generated before&quot;);
3177 
3178   ResourceMark rm;
3179   OopMapSet *oop_maps = new OopMapSet();
3180   OopMap* map;
3181 
3182   // Allocate space for the code. Setup code generation tools.
3183   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
3184   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3185 
3186   unsigned int start_off = __ offset();
3187   address call_pc = NULL;
3188   int frame_size_in_bytes;
3189 
3190   bool cause_return = (poll_type == POLL_AT_RETURN);
3191   // Make room for return address (or push it again)
3192   if (!cause_return) {
3193     __ z_lg(Z_R14, Address(Z_thread, JavaThread::saved_exception_pc_offset()));
3194   }
3195 
3196   // Save registers, fpu state, and flags
3197   map = RegisterSaver::save_live_registers(masm, RegisterSaver::all_registers);
3198 
3199   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; !cause_return) {
3200     // Keep a copy of the return pc to detect if it gets modified.
3201     __ z_lgr(Z_R6, Z_R14);
3202   }
3203 
3204   // The following is basically a call_VM. However, we need the precise
3205   // address of the call in order to generate an oopmap. Hence, we do all the
3206   // work outselves.
3207   __ set_last_Java_frame(Z_SP, noreg);
3208 
3209   // call into the runtime to handle the safepoint poll
3210   __ call_VM_leaf(call_ptr, Z_thread);
3211 
3212 
3213   // Set an oopmap for the call site. This oopmap will map all
3214   // oop-registers and debug-info registers as callee-saved. This
3215   // will allow deoptimization at this safepoint to find all possible
3216   // debug-info recordings, as well as let GC find all oops.
3217 
3218   oop_maps-&gt;add_gc_map((int)(__ offset()-start_off), map);
3219 
3220   Label noException;
3221 
3222   __ reset_last_Java_frame();
3223 
3224   __ load_and_test_long(Z_R1, thread_(pending_exception));
3225   __ z_bre(noException);
3226 
3227   // Pending exception case, used (sporadically) by
3228   // api/java_lang/Thread.State/index#ThreadState et al.
3229   RegisterSaver::restore_live_registers(masm, RegisterSaver::all_registers);
3230 
3231   // Jump to forward_exception_entry, with the issuing PC in Z_R14
3232   // so it looks like the original nmethod called forward_exception_entry.
3233   __ load_const_optimized(Z_R1_scratch, StubRoutines::forward_exception_entry());
3234   __ z_br(Z_R1_scratch);
3235 
3236   // No exception case
3237   __ bind(noException);
3238 
3239   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; !cause_return) {
3240     Label no_adjust;
3241      // If our stashed return pc was modified by the runtime we avoid touching it
3242     const int offset_of_return_pc = _z_abi16(return_pc) + RegisterSaver::live_reg_frame_size(RegisterSaver::all_registers);
3243     __ z_cg(Z_R6, offset_of_return_pc, Z_SP);
3244     __ z_brne(no_adjust);
3245 
3246     // Adjust return pc forward to step over the safepoint poll instruction
3247     __ instr_size(Z_R1_scratch, Z_R6);
3248     __ z_agr(Z_R6, Z_R1_scratch);
3249     __ z_stg(Z_R6, offset_of_return_pc, Z_SP);
3250 
3251     __ bind(no_adjust);
3252   }
3253 
3254   // Normal exit, restore registers and exit.
3255   RegisterSaver::restore_live_registers(masm, RegisterSaver::all_registers);
3256 
3257   __ z_br(Z_R14);
3258 
3259   // Make sure all code is generated
3260   masm-&gt;flush();
3261 
3262   // Fill-out other meta info
3263   return SafepointBlob::create(&amp;buffer, oop_maps, RegisterSaver::live_reg_frame_size(RegisterSaver::all_registers)/wordSize);
3264 }
3265 
3266 
3267 //
3268 // generate_resolve_blob - call resolution (static/virtual/opt-virtual/ic-miss
3269 //
3270 // Generate a stub that calls into vm to find out the proper destination
3271 // of a Java call. All the argument registers are live at this point
3272 // but since this is generic code we don&#39;t know what they are and the caller
3273 // must do any gc of the args.
3274 //
3275 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
3276   assert (StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
3277 
3278   // allocate space for the code
3279   ResourceMark rm;
3280 
3281   CodeBuffer buffer(name, 1000, 512);
3282   MacroAssembler* masm                = new MacroAssembler(&amp;buffer);
3283 
3284   OopMapSet *oop_maps = new OopMapSet();
3285   OopMap* map = NULL;
3286 
3287   unsigned int start_off = __ offset();
3288 
3289   map = RegisterSaver::save_live_registers(masm, RegisterSaver::all_registers);
3290 
3291   // We must save a PC from within the stub as return PC
3292   // C code doesn&#39;t store the LR where we expect the PC,
3293   // so we would run into trouble upon stack walking.
3294   __ get_PC(Z_R1_scratch);
3295 
3296   unsigned int frame_complete = __ offset();
3297 
3298   __ set_last_Java_frame(/*sp*/Z_SP, Z_R1_scratch);
3299 
3300   __ call_VM_leaf(destination, Z_thread, Z_method);
3301 
3302 
3303   // Set an oopmap for the call site.
3304   // We need this not only for callee-saved registers, but also for volatile
3305   // registers that the compiler might be keeping live across a safepoint.
3306 
3307   oop_maps-&gt;add_gc_map((int)(frame_complete-start_off), map);
3308 
3309   // clear last_Java_sp
3310   __ reset_last_Java_frame();
3311 
3312   // check for pending exceptions
3313   Label pending;
3314   __ load_and_test_long(Z_R0, Address(Z_thread, Thread::pending_exception_offset()));
3315   __ z_brne(pending);
3316 
3317   __ z_lgr(Z_R1_scratch, Z_R2); // r1 is neither saved nor restored, r2 contains the continuation.
3318   RegisterSaver::restore_live_registers(masm, RegisterSaver::all_registers);
3319 
3320   // get the returned method
3321   __ get_vm_result_2(Z_method);
3322 
3323   // We are back the the original state on entry and ready to go.
3324   __ z_br(Z_R1_scratch);
3325 
3326   // Pending exception after the safepoint
3327 
3328   __ bind(pending);
3329 
3330   RegisterSaver::restore_live_registers(masm, RegisterSaver::all_registers);
3331 
3332   // exception pending =&gt; remove activation and forward to exception handler
3333 
3334   __ z_lgr(Z_R2, Z_R0); // pending_exception
3335   __ clear_mem(Address(Z_thread, JavaThread::vm_result_offset()), sizeof(jlong));
3336   __ load_const_optimized(Z_R1_scratch, StubRoutines::forward_exception_entry());
3337   __ z_br(Z_R1_scratch);
3338 
3339   // -------------
3340   // make sure all code is generated
3341   masm-&gt;flush();
3342 
3343   // return the blob
3344   // frame_size_words or bytes??
3345   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, RegisterSaver::live_reg_frame_size(RegisterSaver::all_registers)/wordSize,
3346                                        oop_maps, true);
3347 
3348 }
3349 
3350 //------------------------------Montgomery multiplication------------------------
3351 //
3352 
3353 // Subtract 0:b from carry:a. Return carry.
3354 static unsigned long
3355 sub(unsigned long a[], unsigned long b[], unsigned long carry, long len) {
3356   unsigned long i, c = 8 * (unsigned long)(len - 1);
3357   __asm__ __volatile__ (
3358     &quot;SLGR   %[i], %[i]         \n&quot; // initialize to 0 and pre-set carry
3359     &quot;LGHI   0, 8               \n&quot; // index increment (for BRXLG)
3360     &quot;LGR    1, %[c]            \n&quot; // index limit (for BRXLG)
3361     &quot;0:                        \n&quot;
3362     &quot;LG     %[c], 0(%[i],%[a]) \n&quot;
3363     &quot;SLBG   %[c], 0(%[i],%[b]) \n&quot; // subtract with borrow
3364     &quot;STG    %[c], 0(%[i],%[a]) \n&quot;
3365     &quot;BRXLG  %[i], 0, 0b        \n&quot; // while ((i+=8)&lt;limit);
3366     &quot;SLBGR  %[c], %[c]         \n&quot; // save carry - 1
3367     : [i]&quot;=&amp;a&quot;(i), [c]&quot;+r&quot;(c)
3368     : [a]&quot;a&quot;(a), [b]&quot;a&quot;(b)
3369     : &quot;cc&quot;, &quot;memory&quot;, &quot;r0&quot;, &quot;r1&quot;
3370  );
3371   return carry + c;
3372 }
3373 
3374 // Multiply (unsigned) Long A by Long B, accumulating the double-
3375 // length result into the accumulator formed of T0, T1, and T2.
3376 inline void MACC(unsigned long A[], long A_ind,
3377                  unsigned long B[], long B_ind,
3378                  unsigned long &amp;T0, unsigned long &amp;T1, unsigned long &amp;T2) {
3379   long A_si = 8 * A_ind,
3380        B_si = 8 * B_ind;
3381   __asm__ __volatile__ (
3382     &quot;LG     1, 0(%[A_si],%[A]) \n&quot;
3383     &quot;MLG    0, 0(%[B_si],%[B]) \n&quot; // r0r1 = A * B
3384     &quot;ALGR   %[T0], 1           \n&quot;
3385     &quot;LGHI   1, 0               \n&quot; // r1 = 0
3386     &quot;ALCGR  %[T1], 0           \n&quot;
3387     &quot;ALCGR  %[T2], 1           \n&quot;
3388     : [T0]&quot;+r&quot;(T0), [T1]&quot;+r&quot;(T1), [T2]&quot;+r&quot;(T2)
3389     : [A]&quot;r&quot;(A), [A_si]&quot;r&quot;(A_si), [B]&quot;r&quot;(B), [B_si]&quot;r&quot;(B_si)
3390     : &quot;cc&quot;, &quot;r0&quot;, &quot;r1&quot;
3391  );
3392 }
3393 
3394 // As above, but add twice the double-length result into the
3395 // accumulator.
3396 inline void MACC2(unsigned long A[], long A_ind,
3397                   unsigned long B[], long B_ind,
3398                   unsigned long &amp;T0, unsigned long &amp;T1, unsigned long &amp;T2) {
3399   const unsigned long zero = 0;
3400   long A_si = 8 * A_ind,
3401        B_si = 8 * B_ind;
3402   __asm__ __volatile__ (
3403     &quot;LG     1, 0(%[A_si],%[A]) \n&quot;
3404     &quot;MLG    0, 0(%[B_si],%[B]) \n&quot; // r0r1 = A * B
3405     &quot;ALGR   %[T0], 1           \n&quot;
3406     &quot;ALCGR  %[T1], 0           \n&quot;
3407     &quot;ALCGR  %[T2], %[zero]     \n&quot;
3408     &quot;ALGR   %[T0], 1           \n&quot;
3409     &quot;ALCGR  %[T1], 0           \n&quot;
3410     &quot;ALCGR  %[T2], %[zero]     \n&quot;
3411     : [T0]&quot;+r&quot;(T0), [T1]&quot;+r&quot;(T1), [T2]&quot;+r&quot;(T2)
3412     : [A]&quot;r&quot;(A), [A_si]&quot;r&quot;(A_si), [B]&quot;r&quot;(B), [B_si]&quot;r&quot;(B_si), [zero]&quot;r&quot;(zero)
3413     : &quot;cc&quot;, &quot;r0&quot;, &quot;r1&quot;
3414  );
3415 }
3416 
3417 // Fast Montgomery multiplication. The derivation of the algorithm is
3418 // in &quot;A Cryptographic Library for the Motorola DSP56000,
3419 // Dusse and Kaliski, Proc. EUROCRYPT 90, pp. 230-237&quot;.
3420 static void
3421 montgomery_multiply(unsigned long a[], unsigned long b[], unsigned long n[],
3422                     unsigned long m[], unsigned long inv, int len) {
3423   unsigned long t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
3424   int i;
3425 
3426   assert(inv * n[0] == -1UL, &quot;broken inverse in Montgomery multiply&quot;);
3427 
3428   for (i = 0; i &lt; len; i++) {
3429     int j;
3430     for (j = 0; j &lt; i; j++) {
3431       MACC(a, j, b, i-j, t0, t1, t2);
3432       MACC(m, j, n, i-j, t0, t1, t2);
3433     }
3434     MACC(a, i, b, 0, t0, t1, t2);
3435     m[i] = t0 * inv;
3436     MACC(m, i, n, 0, t0, t1, t2);
3437 
3438     assert(t0 == 0, &quot;broken Montgomery multiply&quot;);
3439 
3440     t0 = t1; t1 = t2; t2 = 0;
3441   }
3442 
3443   for (i = len; i &lt; 2 * len; i++) {
3444     int j;
3445     for (j = i - len + 1; j &lt; len; j++) {
3446       MACC(a, j, b, i-j, t0, t1, t2);
3447       MACC(m, j, n, i-j, t0, t1, t2);
3448     }
3449     m[i-len] = t0;
3450     t0 = t1; t1 = t2; t2 = 0;
3451   }
3452 
3453   while (t0) {
3454     t0 = sub(m, n, t0, len);
3455   }
3456 }
3457 
3458 // Fast Montgomery squaring. This uses asymptotically 25% fewer
3459 // multiplies so it should be up to 25% faster than Montgomery
3460 // multiplication. However, its loop control is more complex and it
3461 // may actually run slower on some machines.
3462 static void
3463 montgomery_square(unsigned long a[], unsigned long n[],
3464                   unsigned long m[], unsigned long inv, int len) {
3465   unsigned long t0 = 0, t1 = 0, t2 = 0; // Triple-precision accumulator
3466   int i;
3467 
3468   assert(inv * n[0] == -1UL, &quot;broken inverse in Montgomery multiply&quot;);
3469 
3470   for (i = 0; i &lt; len; i++) {
3471     int j;
3472     int end = (i+1)/2;
3473     for (j = 0; j &lt; end; j++) {
3474       MACC2(a, j, a, i-j, t0, t1, t2);
3475       MACC(m, j, n, i-j, t0, t1, t2);
3476     }
3477     if ((i &amp; 1) == 0) {
3478       MACC(a, j, a, j, t0, t1, t2);
3479     }
3480     for (; j &lt; i; j++) {
3481       MACC(m, j, n, i-j, t0, t1, t2);
3482     }
3483     m[i] = t0 * inv;
3484     MACC(m, i, n, 0, t0, t1, t2);
3485 
3486     assert(t0 == 0, &quot;broken Montgomery square&quot;);
3487 
3488     t0 = t1; t1 = t2; t2 = 0;
3489   }
3490 
3491   for (i = len; i &lt; 2*len; i++) {
3492     int start = i-len+1;
3493     int end = start + (len - start)/2;
3494     int j;
3495     for (j = start; j &lt; end; j++) {
3496       MACC2(a, j, a, i-j, t0, t1, t2);
3497       MACC(m, j, n, i-j, t0, t1, t2);
3498     }
3499     if ((i &amp; 1) == 0) {
3500       MACC(a, j, a, j, t0, t1, t2);
3501     }
3502     for (; j &lt; len; j++) {
3503       MACC(m, j, n, i-j, t0, t1, t2);
3504     }
3505     m[i-len] = t0;
3506     t0 = t1; t1 = t2; t2 = 0;
3507   }
3508 
3509   while (t0) {
3510     t0 = sub(m, n, t0, len);
3511   }
3512 }
3513 
3514 // The threshold at which squaring is advantageous was determined
3515 // experimentally on an i7-3930K (Ivy Bridge) CPU @ 3.5GHz.
3516 // Value seems to be ok for other platforms, too.
3517 #define MONTGOMERY_SQUARING_THRESHOLD 64
3518 
3519 // Copy len longwords from s to d, word-swapping as we go. The
3520 // destination array is reversed.
3521 static void reverse_words(unsigned long *s, unsigned long *d, int len) {
3522   d += len;
3523   while(len-- &gt; 0) {
3524     d--;
3525     unsigned long s_val = *s;
3526     // Swap words in a longword on little endian machines.
3527 #ifdef VM_LITTLE_ENDIAN
3528      Unimplemented();
3529 #endif
3530     *d = s_val;
3531     s++;
3532   }
3533 }
3534 
3535 void SharedRuntime::montgomery_multiply(jint *a_ints, jint *b_ints, jint *n_ints,
3536                                         jint len, jlong inv,
3537                                         jint *m_ints) {
3538   len = len &amp; 0x7fffFFFF; // C2 does not respect int to long conversion for stub calls.
3539   assert(len % 2 == 0, &quot;array length in montgomery_multiply must be even&quot;);
3540   int longwords = len/2;
3541 
3542   // Make very sure we don&#39;t use so much space that the stack might
3543   // overflow. 512 jints corresponds to an 16384-bit integer and
3544   // will use here a total of 8k bytes of stack space.
3545   int total_allocation = longwords * sizeof (unsigned long) * 4;
3546   guarantee(total_allocation &lt;= 8192, &quot;must be&quot;);
3547   unsigned long *scratch = (unsigned long *)alloca(total_allocation);
3548 
3549   // Local scratch arrays
3550   unsigned long
3551     *a = scratch + 0 * longwords,
3552     *b = scratch + 1 * longwords,
3553     *n = scratch + 2 * longwords,
3554     *m = scratch + 3 * longwords;
3555 
3556   reverse_words((unsigned long *)a_ints, a, longwords);
3557   reverse_words((unsigned long *)b_ints, b, longwords);
3558   reverse_words((unsigned long *)n_ints, n, longwords);
3559 
3560   ::montgomery_multiply(a, b, n, m, (unsigned long)inv, longwords);
3561 
3562   reverse_words(m, (unsigned long *)m_ints, longwords);
3563 }
3564 
3565 void SharedRuntime::montgomery_square(jint *a_ints, jint *n_ints,
3566                                       jint len, jlong inv,
3567                                       jint *m_ints) {
3568   len = len &amp; 0x7fffFFFF; // C2 does not respect int to long conversion for stub calls.
3569   assert(len % 2 == 0, &quot;array length in montgomery_square must be even&quot;);
3570   int longwords = len/2;
3571 
3572   // Make very sure we don&#39;t use so much space that the stack might
3573   // overflow. 512 jints corresponds to an 16384-bit integer and
3574   // will use here a total of 6k bytes of stack space.
3575   int total_allocation = longwords * sizeof (unsigned long) * 3;
3576   guarantee(total_allocation &lt;= 8192, &quot;must be&quot;);
3577   unsigned long *scratch = (unsigned long *)alloca(total_allocation);
3578 
3579   // Local scratch arrays
3580   unsigned long
3581     *a = scratch + 0 * longwords,
3582     *n = scratch + 1 * longwords,
3583     *m = scratch + 2 * longwords;
3584 
3585   reverse_words((unsigned long *)a_ints, a, longwords);
3586   reverse_words((unsigned long *)n_ints, n, longwords);
3587 
3588   if (len &gt;= MONTGOMERY_SQUARING_THRESHOLD) {
3589     ::montgomery_square(a, n, m, (unsigned long)inv, longwords);
3590   } else {
3591     ::montgomery_multiply(a, a, n, m, (unsigned long)inv, longwords);
3592   }
3593 
3594   reverse_words(m, (unsigned long *)m_ints, longwords);
3595 }
3596 
3597 extern &quot;C&quot;
3598 int SpinPause() {
3599   return 0;
3600 }
    </pre>
  </body>
</html>
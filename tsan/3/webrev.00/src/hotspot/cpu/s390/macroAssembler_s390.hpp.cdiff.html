<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/s390/macroAssembler_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_s390.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_s390.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/macroAssembler_s390.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
   * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">!  * Copyright (c) 2016, 2018, SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">!  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 711,10 ***</span>
<span class="line-new-header">--- 711,15 ---</span>
                             Register super_klass,
                             Register temp1_reg,
                             Register temp2_reg,
                             Label&amp;   L_success);
  
<span class="line-added">+   void clinit_barrier(Register klass,</span>
<span class="line-added">+                       Register thread,</span>
<span class="line-added">+                       Label* L_fast_path = NULL,</span>
<span class="line-added">+                       Label* L_slow_path = NULL);</span>
<span class="line-added">+ </span>
    // Increment a counter at counter_address when the eq condition code is set.
    // Kills registers tmp1_reg and tmp2_reg and preserves the condition code.
    void increment_counter_eq(address counter_address, Register tmp1_reg, Register tmp2_reg);
    // Biased locking support
    // Upon entry,obj_reg must contain the target object, and mark_reg
</pre>
<hr />
<pre>
<span class="line-old-header">*** 821,18 ***</span>
                     Register Rbase = Z_R1, int pow2_offset = -1, bool only32bitValid = false);
    void oop_decoder(Register Rdst, Register Rsrc, bool maybeNULL,
                     Register Rbase = Z_R1, int pow2_offset = -1);
  
    void resolve_oop_handle(Register result);
<span class="line-modified">!   void load_mirror(Register mirror, Register method);</span>
  
    //--------------------------
    //---  Operations on arrays.
    //--------------------------
<span class="line-modified">!   unsigned int Clear_Array(Register cnt_arg, Register base_pointer_arg, Register src_addr, Register src_len);</span>
    unsigned int Clear_Array_Const(long cnt, Register base);
<span class="line-modified">!   unsigned int Clear_Array_Const_Big(long cnt, Register base_pointer_arg, Register src_addr, Register src_len);</span>
    unsigned int CopyRawMemory_AlignedDisjoint(Register src_reg, Register dst_reg,
                                               Register cnt_reg,
                                               Register tmp1_reg, Register tmp2_reg);
  
    //-------------------------------------------
<span class="line-new-header">--- 826,19 ---</span>
                     Register Rbase = Z_R1, int pow2_offset = -1, bool only32bitValid = false);
    void oop_decoder(Register Rdst, Register Rsrc, bool maybeNULL,
                     Register Rbase = Z_R1, int pow2_offset = -1);
  
    void resolve_oop_handle(Register result);
<span class="line-modified">!   void load_mirror_from_const_method(Register mirror, Register const_method);</span>
<span class="line-added">+   void load_method_holder(Register holder, Register method);</span>
  
    //--------------------------
    //---  Operations on arrays.
    //--------------------------
<span class="line-modified">!   unsigned int Clear_Array(Register cnt_arg, Register base_pointer_arg, Register odd_tmp_reg);</span>
    unsigned int Clear_Array_Const(long cnt, Register base);
<span class="line-modified">!   unsigned int Clear_Array_Const_Big(long cnt, Register base_pointer_arg, Register odd_tmp_reg);</span>
    unsigned int CopyRawMemory_AlignedDisjoint(Register src_reg, Register dst_reg,
                                               Register cnt_reg,
                                               Register tmp1_reg, Register tmp2_reg);
  
    //-------------------------------------------
</pre>
<hr />
<pre>
<span class="line-old-header">*** 842,10 ***</span>
<span class="line-new-header">--- 848,11 ---</span>
    //   Restores: src, dst
    //   Uses:     cnt
    //   Kills:    tmp, Z_R0, Z_R1.
    //   Early clobber: result.
    //   Boolean precise controls accuracy of result value.
<span class="line-added">+ #ifdef COMPILER2</span>
    unsigned int string_compress(Register result, Register src, Register dst, Register cnt,
                                 Register tmp,    bool precise);
  
    // Inflate byte[] to char[].
    unsigned int string_inflate_trot(Register src, Register dst, Register cnt, Register tmp);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 877,10 ***</span>
<span class="line-new-header">--- 884,11 ---</span>
                                Register needle, Register needlecnt, int needlecntval,
                                Register odd_reg, Register even_reg, int ae);
  
    unsigned int string_indexof_char(Register result, Register haystack, Register haycnt,
                                     Register needle, jchar needleChar, Register odd_reg, Register even_reg, bool is_byte);
<span class="line-added">+ #endif</span>
  
    // Emit an oop const to the constant pool and set a relocation info
    // with address current_pc. Return the TOC offset of the constant.
    int store_const_in_toc(AddressLiteral&amp; val);
    int store_oop_in_toc(AddressLiteral&amp; oop);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 910,17 ***</span>
    static int load_const_call_size() { return load_const_size() + call_byregister_size(); }
    static int load_const_from_toc_call_size() { return load_const_from_toc_size() + call_byregister_size(); }
    // Offset is +/- 2**32 -&gt; use long.
    static long get_load_const_from_toc_offset(address a);
  
<span class="line-removed">- </span>
<span class="line-removed">-   void generate_type_profiling(const Register Rdata,</span>
<span class="line-removed">-                                const Register Rreceiver_klass,</span>
<span class="line-removed">-                                const Register Rwanted_receiver_klass,</span>
<span class="line-removed">-                                const Register Rmatching_row,</span>
<span class="line-removed">-                                bool is_virtual_call);</span>
<span class="line-removed">- </span>
    // Bit operations for single register operands.
    inline void lshift(Register r, int places, bool doubl = true);   // &lt;&lt;
    inline void rshift(Register r, int places, bool doubl = true);   // &gt;&gt;
  
    //
<span class="line-new-header">--- 918,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 970,12 ***</span>
<span class="line-new-header">--- 971,19 ---</span>
    void asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id) PRODUCT_RETURN;
  
    // Verify Z_thread contents.
    void verify_thread();
  
<span class="line-added">+   // Save and restore functions: Exclude Z_R0.</span>
<span class="line-added">+   void save_volatile_regs(   Register dst, int offset, bool include_fp, bool include_flags);</span>
<span class="line-added">+   void restore_volatile_regs(Register src, int offset, bool include_fp, bool include_flags);</span>
<span class="line-added">+ </span>
    // Only if +VerifyOops.
<span class="line-added">+   // Kills Z_R0.</span>
    void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);
<span class="line-added">+   // Kills Z_R0, condition code.</span>
<span class="line-added">+   void verify_oop_addr(Address addr, const char* msg = &quot;contains broken oop&quot;);</span>
  
    // TODO: verify_method and klass metadata (compare against vptr?).
    void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
    void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line) {}
  
</pre>
<center><a href="macroAssembler_s390.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_s390.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
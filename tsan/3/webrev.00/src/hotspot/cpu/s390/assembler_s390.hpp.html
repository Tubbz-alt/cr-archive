<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/s390/assembler_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2016, 2019 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_S390_ASSEMBLER_S390_HPP
  27 #define CPU_S390_ASSEMBLER_S390_HPP
  28 
  29 #undef  LUCY_DBG
  30 
  31 // Immediate is an abstraction to represent the various immediate
  32 // operands which exist on z/Architecture. Neither this class nor
  33 // instances hereof have an own state. It consists of methods only.
  34 class Immediate {
  35 
  36  public:
  37     static bool is_simm(int64_t x, unsigned int nbits) {
  38       // nbits &lt; 2   --&gt; false
  39       // nbits &gt;= 64 --&gt; true
  40       assert(2 &lt;= nbits &amp;&amp; nbits &lt; 64, &quot;Don&#39;t call, use statically known result.&quot;);
  41       const int64_t min      = -(1L &lt;&lt; (nbits-1));
  42       const int64_t maxplus1 =  (1L &lt;&lt; (nbits-1));
  43       return min &lt;= x &amp;&amp; x &lt; maxplus1;
  44     }
  45     static bool is_simm32(int64_t x) {
  46       return is_simm(x, 32);
  47     }
  48     static bool is_simm20(int64_t x) {
  49       return is_simm(x, 20);
  50     }
  51     static bool is_simm16(int64_t x) {
  52       return is_simm(x, 16);
  53     }
  54     static bool is_simm8(int64_t x) {
  55       return is_simm(x,  8);
  56     }
  57 
  58     // Test if x is within signed immediate range for nbits.
  59     static bool is_uimm(int64_t x, unsigned int nbits) {
  60       // nbits == 0  --&gt; false
  61       // nbits &gt;= 64 --&gt; true
  62       assert(1 &lt;= nbits &amp;&amp; nbits &lt; 64, &quot;don&#39;t call, use statically known result&quot;);
  63       const uint64_t xu       = (unsigned long)x;
  64       const uint64_t maxplus1 = 1UL &lt;&lt; nbits;
  65       return xu &lt; maxplus1; // Unsigned comparison. Negative inputs appear to be very large.
  66     }
  67     static bool is_uimm32(int64_t x) {
  68       return is_uimm(x, 32);
  69     }
  70     static bool is_uimm16(int64_t x) {
  71       return is_uimm(x, 16);
  72     }
  73     static bool is_uimm12(int64_t x) {
  74       return is_uimm(x, 12);
  75     }
  76     static bool is_uimm8(int64_t x) {
  77       return is_uimm(x,  8);
  78     }
  79 };
  80 
  81 // Displacement is an abstraction to represent the various
  82 // displacements which exist with addresses on z/ArchiTecture.
  83 // Neither this class nor instances hereof have an own state. It
  84 // consists of methods only.
  85 class Displacement {
  86 
  87  public: // These tests are used outside the (Macro)Assembler world, e.g. in ad-file.
  88 
  89   static bool is_longDisp(int64_t x) {  // Fits in a 20-bit displacement field.
  90     return Immediate::is_simm20(x);
  91   }
  92   static bool is_shortDisp(int64_t x) { // Fits in a 12-bit displacement field.
  93     return Immediate::is_uimm12(x);
  94   }
  95   static bool is_validDisp(int64_t x) { // Is a valid displacement, regardless of length constraints.
  96     return is_longDisp(x);
  97   }
  98 };
  99 
 100 // RelAddr is an abstraction to represent relative addresses in the
 101 // form they are used on z/Architecture for instructions which access
 102 // their operand with pc-relative addresses. Neither this class nor
 103 // instances hereof have an own state. It consists of methods only.
 104 class RelAddr {
 105 
 106  private: // No public use at all. Solely for (Macro)Assembler.
 107 
 108   static bool is_in_range_of_RelAddr(address target, address pc, bool shortForm) {
 109     // Guard against illegal branch targets, e.g. -1. Occurrences in
 110     // CompiledStaticCall and ad-file. Do not assert (it&#39;s a test
 111     // function!). Just return false in case of illegal operands.
 112     if ((((uint64_t)target) &amp; 0x0001L) != 0) return false;
 113     if ((((uint64_t)pc)     &amp; 0x0001L) != 0) return false;
 114 
 115     if (shortForm) {
 116       return Immediate::is_simm((int64_t)(target-pc), 17); // Relative short addresses can reach +/- 2**16 bytes.
 117     } else {
 118       return Immediate::is_simm((int64_t)(target-pc), 33); // Relative long addresses can reach +/- 2**32 bytes.
 119     }
 120   }
 121 
 122   static bool is_in_range_of_RelAddr16(address target, address pc) {
 123     return is_in_range_of_RelAddr(target, pc, true);
 124   }
 125   static bool is_in_range_of_RelAddr16(ptrdiff_t distance) {
 126     return is_in_range_of_RelAddr((address)distance, 0, true);
 127   }
 128 
 129   static bool is_in_range_of_RelAddr32(address target, address pc) {
 130     return is_in_range_of_RelAddr(target, pc, false);
 131   }
 132   static bool is_in_range_of_RelAddr32(ptrdiff_t distance) {
 133     return is_in_range_of_RelAddr((address)distance, 0, false);
 134   }
 135 
 136   static int pcrel_off(address target, address pc, bool shortForm) {
 137     assert(((uint64_t)target &amp; 0x0001L) == 0, &quot;target of a relative address must be aligned&quot;);
 138     assert(((uint64_t)pc     &amp; 0x0001L) == 0, &quot;origin of a relative address must be aligned&quot;);
 139 
 140     if ((target == NULL) || (target == pc)) {
 141       return 0;  // Yet unknown branch destination.
 142     } else {
 143       guarantee(is_in_range_of_RelAddr(target, pc, shortForm), &quot;target not within reach&quot;);
 144       return (int)((target - pc)&gt;&gt;1);
 145     }
 146   }
 147 
 148   static int pcrel_off16(address target, address pc) {
 149     return pcrel_off(target, pc, true);
 150   }
 151   static int pcrel_off16(ptrdiff_t distance) {
 152     return pcrel_off((address)distance, 0, true);
 153   }
 154 
 155   static int pcrel_off32(address target, address pc) {
 156     return pcrel_off(target, pc, false);
 157   }
 158   static int pcrel_off32(ptrdiff_t distance) {
 159     return pcrel_off((address)distance, 0, false);
 160   }
 161 
 162   static ptrdiff_t inv_pcrel_off16(int offset) {
 163     return ((ptrdiff_t)offset)&lt;&lt;1;
 164   }
 165 
 166   static ptrdiff_t inv_pcrel_off32(int offset) {
 167     return ((ptrdiff_t)offset)&lt;&lt;1;
 168   }
 169 
 170   friend class Assembler;
 171   friend class MacroAssembler;
 172   friend class NativeGeneralJump;
 173 };
 174 
 175 // Address is an abstraction used to represent a memory location
 176 // as passed to Z assembler instructions.
 177 //
 178 // Note: A register location is represented via a Register, not
 179 // via an address for efficiency &amp; simplicity reasons.
 180 class Address {
 181  private:
 182   Register _base;    // Base register.
 183   Register _index;   // Index register
 184   intptr_t _disp;    // Constant displacement.
 185 
 186  public:
 187   Address() :
 188     _base(noreg),
 189     _index(noreg),
 190     _disp(0) {}
 191 
 192   Address(Register base, Register index, intptr_t disp = 0) :
 193     _base(base),
 194     _index(index),
 195     _disp(disp) {}
 196 
 197   Address(Register base, intptr_t disp = 0) :
 198     _base(base),
 199     _index(noreg),
 200     _disp(disp) {}
 201 
 202   Address(Register base, RegisterOrConstant roc, intptr_t disp = 0) :
 203     _base(base),
 204     _index(noreg),
 205     _disp(disp) {
 206     if (roc.is_constant()) _disp += roc.as_constant(); else _index = roc.as_register();
 207   }
 208 
 209 #ifdef ASSERT
 210   // ByteSize is only a class when ASSERT is defined, otherwise it&#39;s an int.
 211   Address(Register base, ByteSize disp) :
 212     _base(base),
 213     _index(noreg),
 214     _disp(in_bytes(disp)) {}
 215 
 216   Address(Register base, Register index, ByteSize disp) :
 217     _base(base),
 218     _index(index),
 219     _disp(in_bytes(disp)) {}
 220 #endif
 221 
 222   // Aborts if disp is a register and base and index are set already.
 223   Address plus_disp(RegisterOrConstant disp) const {
 224     Address a = (*this);
 225     a._disp += disp.constant_or_zero();
 226     if (disp.is_register()) {
 227       if (a._index == noreg) {
 228         a._index = disp.as_register();
 229       } else {
 230         guarantee(_base == noreg, &quot;can not encode&quot;); a._base = disp.as_register();
 231       }
 232     }
 233     return a;
 234   }
 235 
 236   // A call to this is generated by adlc for replacement variable $xxx$$Address.
 237   static Address make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc);
 238 
 239   bool is_same_address(Address a) const {
 240     return _base == a._base &amp;&amp; _index == a._index &amp;&amp; _disp == a._disp;
 241   }
 242 
 243   // testers
 244   bool has_base()  const { return _base  != noreg; }
 245   bool has_index() const { return _index != noreg; }
 246   bool has_disp()  const { return true; } // There is no &quot;invalid&quot; value.
 247 
 248   bool is_disp12() const { return Immediate::is_uimm12(disp()); }
 249   bool is_disp20() const { return Immediate::is_simm20(disp()); }
 250   bool is_RSform()  { return has_base() &amp;&amp; !has_index() &amp;&amp; is_disp12(); }
 251   bool is_RSYform() { return has_base() &amp;&amp; !has_index() &amp;&amp; is_disp20(); }
 252   bool is_RXform()  { return has_base() &amp;&amp;  has_index() &amp;&amp; is_disp12(); }
 253   bool is_RXYform() { return has_base() &amp;&amp;  has_index() &amp;&amp; is_disp20(); }
 254 
 255   bool uses(Register r) { return _base == r || _index == r; };
 256 
 257   // accessors
 258   Register base()      const { return _base; }
 259   Register baseOrR0()  const { assert(_base  != Z_R0, &quot;&quot;); return _base  == noreg ? Z_R0 : _base; }
 260   Register index()     const { return _index; }
 261   Register indexOrR0() const { assert(_index != Z_R0, &quot;&quot;); return _index == noreg ? Z_R0 : _index; }
 262   intptr_t disp() const { return _disp; }
 263   // Specific version for short displacement instructions.
 264   int      disp12() const {
 265     assert(is_disp12(), &quot;displacement out of range for uimm12&quot;);
 266     return _disp;
 267   }
 268   // Specific version for long displacement instructions.
 269   int      disp20() const {
 270     assert(is_disp20(), &quot;displacement out of range for simm20&quot;);
 271     return _disp;
 272   }
 273   intptr_t value() const { return _disp; }
 274 
 275   friend class Assembler;
 276 };
 277 
 278 class AddressLiteral {
 279  private:
 280   address          _address;
 281   RelocationHolder _rspec;
 282 
 283   RelocationHolder rspec_from_rtype(relocInfo::relocType rtype, address addr) {
 284     switch (rtype) {
 285     case relocInfo::external_word_type:
 286       return external_word_Relocation::spec(addr);
 287     case relocInfo::internal_word_type:
 288       return internal_word_Relocation::spec(addr);
 289     case relocInfo::opt_virtual_call_type:
 290       return opt_virtual_call_Relocation::spec();
 291     case relocInfo::static_call_type:
 292       return static_call_Relocation::spec();
 293     case relocInfo::runtime_call_w_cp_type:
 294       return runtime_call_w_cp_Relocation::spec();
 295     case relocInfo::none:
 296       return RelocationHolder();
 297     default:
 298       ShouldNotReachHere();
 299       return RelocationHolder();
 300     }
 301   }
 302 
 303  protected:
 304   // creation
 305   AddressLiteral() : _address(NULL), _rspec(NULL) {}
 306 
 307  public:
 308   AddressLiteral(address addr, RelocationHolder const&amp; rspec)
 309     : _address(addr),
 310       _rspec(rspec) {}
 311 
 312   // Some constructors to avoid casting at the call site.
 313   AddressLiteral(jobject obj, RelocationHolder const&amp; rspec)
 314     : _address((address) obj),
 315       _rspec(rspec) {}
 316 
 317   AddressLiteral(intptr_t value, RelocationHolder const&amp; rspec)
 318     : _address((address) value),
 319       _rspec(rspec) {}
 320 
 321   AddressLiteral(address addr, relocInfo::relocType rtype = relocInfo::none)
 322     : _address((address) addr),
 323     _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 324 
 325   // Some constructors to avoid casting at the call site.
 326   AddressLiteral(address* addr, relocInfo::relocType rtype = relocInfo::none)
 327     : _address((address) addr),
 328     _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 329 
 330   AddressLiteral(bool* addr, relocInfo::relocType rtype = relocInfo::none)
 331     : _address((address) addr),
 332       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 333 
 334   AddressLiteral(const bool* addr, relocInfo::relocType rtype = relocInfo::none)
 335     : _address((address) addr),
 336       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 337 
 338   AddressLiteral(signed char* addr, relocInfo::relocType rtype = relocInfo::none)
 339     : _address((address) addr),
 340       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 341 
 342   AddressLiteral(int* addr, relocInfo::relocType rtype = relocInfo::none)
 343     : _address((address) addr),
 344       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 345 
 346   AddressLiteral(intptr_t addr, relocInfo::relocType rtype = relocInfo::none)
 347     : _address((address) addr),
 348       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 349 
 350   AddressLiteral(intptr_t* addr, relocInfo::relocType rtype = relocInfo::none)
 351     : _address((address) addr),
 352       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 353 
 354   AddressLiteral(float* addr, relocInfo::relocType rtype = relocInfo::none)
 355     : _address((address) addr),
 356       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 357 
 358   AddressLiteral(double* addr, relocInfo::relocType rtype = relocInfo::none)
 359     : _address((address) addr),
 360       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 361 
 362   intptr_t value() const { return (intptr_t) _address; }
 363 
 364   const relocInfo::relocType rtype() const { return _rspec.type(); }
 365   const RelocationHolder&amp;    rspec() const { return _rspec; }
 366 
 367   RelocationHolder rspec(int offset) const {
 368     return offset == 0 ? _rspec : _rspec.plus(offset);
 369   }
 370 };
 371 
 372 // Convenience classes
 373 class ExternalAddress: public AddressLiteral {
 374  private:
 375   static relocInfo::relocType reloc_for_target(address target) {
 376     // Sometimes ExternalAddress is used for values which aren&#39;t
 377     // exactly addresses, like the card table base.
 378     // External_word_type can&#39;t be used for values in the first page
 379     // so just skip the reloc in that case.
 380     return external_word_Relocation::can_be_relocated(target) ? relocInfo::external_word_type : relocInfo::none;
 381   }
 382 
 383  public:
 384   ExternalAddress(address target) : AddressLiteral(target, reloc_for_target(          target)) {}
 385 };
 386 
 387 // Argument is an abstraction used to represent an outgoing actual
 388 // argument or an incoming formal parameter, whether it resides in
 389 // memory or in a register, in a manner consistent with the
 390 // z/Architecture Application Binary Interface, or ABI. This is often
 391 // referred to as the native or C calling convention.
 392 class Argument {
 393  private:
 394   int _number;
 395   bool _is_in;
 396 
 397  public:
 398   enum {
 399     // Only 5 registers may contain integer parameters.
 400     n_register_parameters = 5,
 401     // Can have up to 4 floating registers.
 402     n_float_register_parameters = 4
 403   };
 404 
 405   // creation
 406   Argument(int number, bool is_in) : _number(number), _is_in(is_in) {}
 407   Argument(int number) : _number(number) {}
 408 
 409   int number() const { return _number; }
 410 
 411   Argument successor() const { return Argument(number() + 1); }
 412 
 413   // Locating register-based arguments:
 414   bool is_register() const { return _number &lt; n_register_parameters; }
 415 
 416   // Locating Floating Point register-based arguments:
 417   bool is_float_register() const { return _number &lt; n_float_register_parameters; }
 418 
 419   FloatRegister as_float_register() const {
 420     assert(is_float_register(), &quot;must be a register argument&quot;);
 421     return as_FloatRegister((number() *2) + 1);
 422   }
 423 
 424   FloatRegister as_double_register() const {
 425     assert(is_float_register(), &quot;must be a register argument&quot;);
 426     return as_FloatRegister((number() *2));
 427   }
 428 
 429   Register as_register() const {
 430     assert(is_register(), &quot;must be a register argument&quot;);
 431     return as_Register(number() + Z_ARG1-&gt;encoding());
 432   }
 433 
 434   // debugging
 435   const char* name() const;
 436 
 437   friend class Assembler;
 438 };
 439 
 440 
 441 // The z/Architecture Assembler: Pure assembler doing NO optimizations
 442 // on the instruction level; i.e., what you write is what you get. The
 443 // Assembler is generating code into a CodeBuffer.
 444 class Assembler : public AbstractAssembler {
 445  protected:
 446 
 447   friend class AbstractAssembler;
 448   friend class AddressLiteral;
 449 
 450   // Code patchers need various routines like inv_wdisp().
 451   friend class NativeInstruction;
 452 #ifndef COMPILER2
 453   friend class NativeGeneralJump;
 454 #endif
 455   friend class Relocation;
 456 
 457  public:
 458 
 459 // Addressing
 460 
 461 // address calculation
 462 #define LA_ZOPC     (unsigned  int)(0x41  &lt;&lt; 24)
 463 #define LAY_ZOPC    (unsigned long)(0xe3L &lt;&lt; 40 | 0x71L)
 464 #define LARL_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 0x00L &lt;&lt; 32)
 465 
 466 
 467 // Data Transfer
 468 
 469 // register to register transfer
 470 #define LR_ZOPC     (unsigned  int)(24 &lt;&lt; 8)
 471 #define LBR_ZOPC    (unsigned  int)(0xb926 &lt;&lt; 16)
 472 #define LHR_ZOPC    (unsigned  int)(0xb927 &lt;&lt; 16)
 473 #define LGBR_ZOPC   (unsigned  int)(0xb906 &lt;&lt; 16)
 474 #define LGHR_ZOPC   (unsigned  int)(0xb907 &lt;&lt; 16)
 475 #define LGFR_ZOPC   (unsigned  int)(0xb914 &lt;&lt; 16)
 476 #define LGR_ZOPC    (unsigned  int)(0xb904 &lt;&lt; 16)
 477 
 478 #define LLHR_ZOPC   (unsigned  int)(0xb995 &lt;&lt; 16)
 479 #define LLGCR_ZOPC  (unsigned  int)(0xb984 &lt;&lt; 16)
 480 #define LLGHR_ZOPC  (unsigned  int)(0xb985 &lt;&lt; 16)
 481 #define LLGTR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 23 &lt;&lt; 16)
 482 #define LLGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 22 &lt;&lt; 16)
 483 
 484 #define LTR_ZOPC    (unsigned  int)(18 &lt;&lt; 8)
 485 #define LTGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 18 &lt;&lt; 16)
 486 #define LTGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 2 &lt;&lt; 16)
 487 
 488 #define LER_ZOPC    (unsigned  int)(56 &lt;&lt; 8)
 489 #define LEDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 68 &lt;&lt; 16)
 490 #define LEXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 70 &lt;&lt; 16)
 491 #define LDEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 4 &lt;&lt; 16)
 492 #define LDR_ZOPC    (unsigned  int)(40 &lt;&lt; 8)
 493 #define LDXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 69 &lt;&lt; 16)
 494 #define LXEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 6 &lt;&lt; 16)
 495 #define LXDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 5 &lt;&lt; 16)
 496 #define LXR_ZOPC    (unsigned  int)(179 &lt;&lt; 24 | 101 &lt;&lt; 16)
 497 #define LTEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 2 &lt;&lt; 16)
 498 #define LTDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 18 &lt;&lt; 16)
 499 #define LTXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 66 &lt;&lt; 16)
 500 
 501 #define LRVR_ZOPC   (unsigned  int)(0xb91f &lt;&lt; 16)
 502 #define LRVGR_ZOPC  (unsigned  int)(0xb90f &lt;&lt; 16)
 503 
 504 #define LDGR_ZOPC   (unsigned  int)(0xb3c1 &lt;&lt; 16)                // z10
 505 #define LGDR_ZOPC   (unsigned  int)(0xb3cd &lt;&lt; 16)                // z10
 506 
 507 #define LOCR_ZOPC   (unsigned  int)(0xb9f2 &lt;&lt; 16)                // z196
 508 #define LOCGR_ZOPC  (unsigned  int)(0xb9e2 &lt;&lt; 16)                // z196
 509 
 510 // immediate to register transfer
 511 #define IIHH_ZOPC   (unsigned  int)(165 &lt;&lt; 24)
 512 #define IIHL_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 1 &lt;&lt; 16)
 513 #define IILH_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 2 &lt;&lt; 16)
 514 #define IILL_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 3 &lt;&lt; 16)
 515 #define IIHF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 8L &lt;&lt; 32)
 516 #define IILF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 9L &lt;&lt; 32)
 517 #define LLIHH_ZOPC  (unsigned  int)(165 &lt;&lt; 24 | 12 &lt;&lt; 16)
 518 #define LLIHL_ZOPC  (unsigned  int)(165 &lt;&lt; 24 | 13 &lt;&lt; 16)
 519 #define LLILH_ZOPC  (unsigned  int)(165 &lt;&lt; 24 | 14 &lt;&lt; 16)
 520 #define LLILL_ZOPC  (unsigned  int)(165 &lt;&lt; 24 | 15 &lt;&lt; 16)
 521 #define LLIHF_ZOPC  (unsigned long)(0xc0L &lt;&lt; 40 | 14L &lt;&lt; 32)
 522 #define LLILF_ZOPC  (unsigned long)(0xc0L &lt;&lt; 40 | 15L &lt;&lt; 32)
 523 #define LHI_ZOPC    (unsigned  int)(167 &lt;&lt; 24 | 8 &lt;&lt; 16)
 524 #define LGHI_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 9 &lt;&lt; 16)
 525 #define LGFI_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 1L &lt;&lt; 32)
 526 
 527 #define LZER_ZOPC   (unsigned  int)(0xb374 &lt;&lt; 16)
 528 #define LZDR_ZOPC   (unsigned  int)(0xb375 &lt;&lt; 16)
 529 
 530 // LOAD: memory to register transfer
 531 #define LB_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 118L)
 532 #define LH_ZOPC     (unsigned  int)(72 &lt;&lt; 24)
 533 #define LHY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 120L)
 534 #define L_ZOPC      (unsigned  int)(88 &lt;&lt; 24)
 535 #define LY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 88L)
 536 #define LT_ZOPC     (unsigned long)(0xe3L &lt;&lt; 40 | 0x12L)
 537 #define LGB_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 119L)
 538 #define LGH_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 21L)
 539 #define LGF_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 20L)
 540 #define LG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 4L)
 541 #define LTG_ZOPC    (unsigned long)(0xe3L &lt;&lt; 40 | 0x02L)
 542 #define LTGF_ZOPC   (unsigned long)(0xe3L &lt;&lt; 40 | 0x32L)
 543 
 544 #define LLC_ZOPC    (unsigned long)(0xe3L &lt;&lt; 40 | 0x94L)
 545 #define LLH_ZOPC    (unsigned long)(0xe3L &lt;&lt; 40 | 0x95L)
 546 #define LLGT_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 23L)
 547 #define LLGC_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 144L)
 548 #define LLGH_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 145L)
 549 #define LLGF_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 22L)
 550 
 551 #define IC_ZOPC     (unsigned  int)(0x43  &lt;&lt; 24)
 552 #define ICY_ZOPC    (unsigned long)(0xe3L &lt;&lt; 40 | 0x73L)
 553 #define ICM_ZOPC    (unsigned  int)(0xbf  &lt;&lt; 24)
 554 #define ICMY_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x81L)
 555 #define ICMH_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x80L)
 556 
 557 #define LRVH_ZOPC   (unsigned long)(0xe3L &lt;&lt; 40 | 0x1fL)
 558 #define LRV_ZOPC    (unsigned long)(0xe3L &lt;&lt; 40 | 0x1eL)
 559 #define LRVG_ZOPC   (unsigned long)(0xe3L &lt;&lt; 40 | 0x0fL)
 560 
 561 
 562 // LOAD relative: memory to register transfer
 563 #define LHRL_ZOPC   (unsigned long)(0xc4L &lt;&lt; 40 | 0x05L &lt;&lt; 32)  // z10
 564 #define LRL_ZOPC    (unsigned long)(0xc4L &lt;&lt; 40 | 0x0dL &lt;&lt; 32)  // z10
 565 #define LGHRL_ZOPC  (unsigned long)(0xc4L &lt;&lt; 40 | 0x04L &lt;&lt; 32)  // z10
 566 #define LGFRL_ZOPC  (unsigned long)(0xc4L &lt;&lt; 40 | 0x0cL &lt;&lt; 32)  // z10
 567 #define LGRL_ZOPC   (unsigned long)(0xc4L &lt;&lt; 40 | 0x08L &lt;&lt; 32)  // z10
 568 
 569 #define LLHRL_ZOPC  (unsigned long)(0xc4L &lt;&lt; 40 | 0x02L &lt;&lt; 32)  // z10
 570 #define LLGHRL_ZOPC (unsigned long)(0xc4L &lt;&lt; 40 | 0x06L &lt;&lt; 32)  // z10
 571 #define LLGFRL_ZOPC (unsigned long)(0xc4L &lt;&lt; 40 | 0x0eL &lt;&lt; 32)  // z10
 572 
 573 #define LOC_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0xf2L)        // z196
 574 #define LOCG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xe2L)        // z196
 575 
 576 
 577 // LOAD multiple registers at once
 578 #define LM_ZOPC     (unsigned  int)(0x98  &lt;&lt; 24)
 579 #define LMY_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x98L)
 580 #define LMG_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x04L)
 581 
 582 #define LE_ZOPC     (unsigned  int)(0x78 &lt;&lt; 24)
 583 #define LEY_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 100L)
 584 #define LDEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 4)
 585 #define LD_ZOPC     (unsigned  int)(0x68 &lt;&lt; 24)
 586 #define LDY_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 101L)
 587 #define LXEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 6)
 588 #define LXDB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 5)
 589 
 590 // STORE: register to memory transfer
 591 #define STC_ZOPC    (unsigned  int)(0x42 &lt;&lt; 24)
 592 #define STCY_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 114L)
 593 #define STH_ZOPC    (unsigned  int)(64 &lt;&lt; 24)
 594 #define STHY_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 112L)
 595 #define ST_ZOPC     (unsigned  int)(80 &lt;&lt; 24)
 596 #define STY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 80L)
 597 #define STG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 36L)
 598 
 599 #define STCM_ZOPC   (unsigned long)(0xbeL &lt;&lt; 24)
 600 #define STCMY_ZOPC  (unsigned long)(0xebL &lt;&lt; 40 | 0x2dL)
 601 #define STCMH_ZOPC  (unsigned long)(0xebL &lt;&lt; 40 | 0x2cL)
 602 
 603 // STORE relative: memory to register transfer
 604 #define STHRL_ZOPC  (unsigned long)(0xc4L &lt;&lt; 40 | 0x07L &lt;&lt; 32)  // z10
 605 #define STRL_ZOPC   (unsigned long)(0xc4L &lt;&lt; 40 | 0x0fL &lt;&lt; 32)  // z10
 606 #define STGRL_ZOPC  (unsigned long)(0xc4L &lt;&lt; 40 | 0x0bL &lt;&lt; 32)  // z10
 607 
 608 #define STOC_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xf3L)        // z196
 609 #define STOCG_ZOPC  (unsigned long)(0xebL &lt;&lt; 40 | 0xe3L)        // z196
 610 
 611 // STORE multiple registers at once
 612 #define STM_ZOPC    (unsigned  int)(0x90  &lt;&lt; 24)
 613 #define STMY_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x90L)
 614 #define STMG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x24L)
 615 
 616 #define STE_ZOPC    (unsigned  int)(0x70 &lt;&lt; 24)
 617 #define STEY_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 102L)
 618 #define STD_ZOPC    (unsigned  int)(0x60 &lt;&lt; 24)
 619 #define STDY_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 103L)
 620 
 621 // MOVE: immediate to memory transfer
 622 #define MVHHI_ZOPC  (unsigned long)(0xe5L &lt;&lt; 40 | 0x44L &lt;&lt; 32)   // z10
 623 #define MVHI_ZOPC   (unsigned long)(0xe5L &lt;&lt; 40 | 0x4cL &lt;&lt; 32)   // z10
 624 #define MVGHI_ZOPC  (unsigned long)(0xe5L &lt;&lt; 40 | 0x48L &lt;&lt; 32)   // z10
 625 
 626 
 627 //  ALU operations
 628 
 629 // Load Positive
 630 #define LPR_ZOPC    (unsigned  int)(16 &lt;&lt; 8)
 631 #define LPGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 16 &lt;&lt; 16)
 632 #define LPGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24)
 633 #define LPEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24)
 634 #define LPDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 16 &lt;&lt; 16)
 635 #define LPXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 64 &lt;&lt; 16)
 636 
 637 // Load Negative
 638 #define LNR_ZOPC    (unsigned  int)(17 &lt;&lt; 8)
 639 #define LNGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 17 &lt;&lt; 16)
 640 #define LNGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 1 &lt;&lt; 16)
 641 #define LNEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 1 &lt;&lt; 16)
 642 #define LNDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 17 &lt;&lt; 16)
 643 #define LNXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 65 &lt;&lt; 16)
 644 
 645 // Load Complement
 646 #define LCR_ZOPC    (unsigned  int)(19 &lt;&lt; 8)
 647 #define LCGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 19 &lt;&lt; 16)
 648 #define LCGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 3 &lt;&lt; 16)
 649 #define LCEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 3 &lt;&lt; 16)
 650 #define LCDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 19 &lt;&lt; 16)
 651 #define LCXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 67 &lt;&lt; 16)
 652 
 653 // Add
 654 // RR, signed
 655 #define AR_ZOPC     (unsigned  int)(26 &lt;&lt; 8)
 656 #define AGFR_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x18 &lt;&lt; 16)
 657 #define AGR_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x08 &lt;&lt; 16)
 658 // RRF, signed
 659 #define ARK_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00f8 &lt;&lt; 16)
 660 #define AGRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00e8 &lt;&lt; 16)
 661 // RI, signed
 662 #define AHI_ZOPC    (unsigned  int)(167 &lt;&lt; 24 | 10 &lt;&lt; 16)
 663 #define AFI_ZOPC    (unsigned long)(0xc2L &lt;&lt; 40 | 9L &lt;&lt; 32)
 664 #define AGHI_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 11 &lt;&lt; 16)
 665 #define AGFI_ZOPC   (unsigned long)(0xc2L &lt;&lt; 40 | 8L &lt;&lt; 32)
 666 // RIE, signed
 667 #define AHIK_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0x00d8L)
 668 #define AGHIK_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x00d9L)
 669 #define AIH_ZOPC    (unsigned long)(0xccL &lt;&lt; 40 | 0x08L &lt;&lt; 32)
 670 // RM, signed
 671 #define AHY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 122L)
 672 #define A_ZOPC      (unsigned  int)(90 &lt;&lt; 24)
 673 #define AY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 90L)
 674 #define AGF_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 24L)
 675 #define AG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 8L)
 676 // In-memory arithmetic (add signed, add logical with signed immediate).
 677 // MI, signed
 678 #define ASI_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x6aL)
 679 #define AGSI_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x7aL)
 680 
 681 // RR, Logical
 682 #define ALR_ZOPC    (unsigned  int)(30 &lt;&lt; 8)
 683 #define ALGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 26 &lt;&lt; 16)
 684 #define ALGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 10 &lt;&lt; 16)
 685 #define ALCGR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 136 &lt;&lt; 16)
 686 // RRF, Logical
 687 #define ALRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00fa &lt;&lt; 16)
 688 #define ALGRK_ZOPC  (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00ea &lt;&lt; 16)
 689 // RI, Logical
 690 #define ALFI_ZOPC   (unsigned long)(0xc2L &lt;&lt; 40 | 0x0bL &lt;&lt; 32)
 691 #define ALGFI_ZOPC  (unsigned long)(0xc2L &lt;&lt; 40 | 0x0aL &lt;&lt; 32)
 692 // RIE, Logical
 693 #define ALHSIK_ZOPC (unsigned long)(0xecL &lt;&lt; 40 | 0x00daL)
 694 #define ALGHSIK_ZOPC (unsigned long)(0xecL &lt;&lt; 40 | 0x00dbL)
 695 // RM, Logical
 696 #define AL_ZOPC     (unsigned  int)(0x5e &lt;&lt; 24)
 697 #define ALY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 94L)
 698 #define ALGF_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 26L)
 699 #define ALG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 10L)
 700 // In-memory arithmetic (add signed, add logical with signed immediate).
 701 // MI, Logical
 702 #define ALSI_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x6eL)
 703 #define ALGSI_ZOPC  (unsigned long)(0xebL &lt;&lt; 40 | 0x7eL)
 704 
 705 // RR, BFP
 706 #define AEBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 10 &lt;&lt; 16)
 707 #define ADBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 26 &lt;&lt; 16)
 708 #define AXBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 74 &lt;&lt; 16)
 709 // RM, BFP
 710 #define AEB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 10)
 711 #define ADB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 26)
 712 
 713 // Subtract
 714 // RR, signed
 715 #define SR_ZOPC     (unsigned  int)(27 &lt;&lt; 8)
 716 #define SGFR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 25 &lt;&lt; 16)
 717 #define SGR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 9 &lt;&lt; 16)
 718 // RRF, signed
 719 #define SRK_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00f9 &lt;&lt; 16)
 720 #define SGRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00e9 &lt;&lt; 16)
 721 //   RM, signed
 722 #define SH_ZOPC     (unsigned  int)(0x4b &lt;&lt; 24)
 723 #define SHY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 123L)
 724 #define S_ZOPC      (unsigned  int)(0x5B &lt;&lt; 24)
 725 #define SY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 91L)
 726 #define SGF_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 25)
 727 #define SG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 9)
 728 // RR, Logical
 729 #define SLR_ZOPC    (unsigned  int)(31 &lt;&lt; 8)
 730 #define SLGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 27 &lt;&lt; 16)
 731 #define SLGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 11 &lt;&lt; 16)
 732 // RIL, Logical
 733 #define SLFI_ZOPC   (unsigned long)(0xc2L &lt;&lt; 40 | 0x05L &lt;&lt; 32)
 734 #define SLGFI_ZOPC  (unsigned long)(0xc2L &lt;&lt; 40 | 0x04L &lt;&lt; 32)
 735 // RRF, Logical
 736 #define SLRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00fb &lt;&lt; 16)
 737 #define SLGRK_ZOPC  (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00eb &lt;&lt; 16)
 738 // RM, Logical
 739 #define SLY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 95L)
 740 #define SLGF_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 27L)
 741 #define SLG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 11L)
 742 
 743 // RR, BFP
 744 #define SEBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 11 &lt;&lt; 16)
 745 #define SDBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 27 &lt;&lt; 16)
 746 #define SXBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 75 &lt;&lt; 16)
 747 // RM, BFP
 748 #define SEB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 11)
 749 #define SDB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 27)
 750 
 751 // Multiply
 752 // RR, signed
 753 #define MR_ZOPC     (unsigned  int)(28 &lt;&lt; 8)
 754 #define MSR_ZOPC    (unsigned  int)(178 &lt;&lt; 24 | 82 &lt;&lt; 16)
 755 #define MSGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 28 &lt;&lt; 16)
 756 #define MSGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 12 &lt;&lt; 16)
 757 // RI, signed
 758 #define MHI_ZOPC    (unsigned  int)(167 &lt;&lt; 24 | 12 &lt;&lt; 16)
 759 #define MGHI_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 13 &lt;&lt; 16)
 760 #define MSFI_ZOPC   (unsigned long)(0xc2L &lt;&lt; 40 | 0x01L &lt;&lt; 32)   // z10
 761 #define MSGFI_ZOPC  (unsigned long)(0xc2L &lt;&lt; 40 | 0x00L &lt;&lt; 32)   // z10
 762 // RM, signed
 763 #define M_ZOPC      (unsigned  int)(92 &lt;&lt; 24)
 764 #define MS_ZOPC     (unsigned  int)(0x71 &lt;&lt; 24)
 765 #define MHY_ZOPC    (unsigned long)(0xe3L&lt;&lt; 40 | 0x7cL)
 766 #define MSY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 81L)
 767 #define MSGF_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 28L)
 768 #define MSG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 12L)
 769 // RR, unsigned
 770 #define MLR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 150 &lt;&lt; 16)
 771 #define MLGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 134 &lt;&lt; 16)
 772 // RM, unsigned
 773 #define ML_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 150L)
 774 #define MLG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 134L)
 775 
 776 // RR, BFP
 777 #define MEEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 23 &lt;&lt; 16)
 778 #define MDEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 12 &lt;&lt; 16)
 779 #define MDBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 28 &lt;&lt; 16)
 780 #define MXDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 7 &lt;&lt; 16)
 781 #define MXBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 76 &lt;&lt; 16)
 782 // RM, BFP
 783 #define MEEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 23)
 784 #define MDEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 12)
 785 #define MDB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 28)
 786 #define MXDB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 7)
 787 
 788 // Multiply-Add
 789 #define MAEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 14 &lt;&lt; 16)
 790 #define MADBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 30 &lt;&lt; 16)
 791 #define MSEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 15 &lt;&lt; 16)
 792 #define MSDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 31 &lt;&lt; 16)
 793 #define MAEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 14)
 794 #define MADB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 30)
 795 #define MSEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 15)
 796 #define MSDB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 31)
 797 
 798 // Divide
 799 // RR, signed
 800 #define DSGFR_ZOPC  (unsigned  int)(0xb91d &lt;&lt; 16)
 801 #define DSGR_ZOPC   (unsigned  int)(0xb90d &lt;&lt; 16)
 802 // RM, signed
 803 #define D_ZOPC      (unsigned  int)(93 &lt;&lt; 24)
 804 #define DSGF_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 29L)
 805 #define DSG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 13L)
 806 // RR, unsigned
 807 #define DLR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 151 &lt;&lt; 16)
 808 #define DLGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 135 &lt;&lt; 16)
 809 // RM, unsigned
 810 #define DL_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 151L)
 811 #define DLG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 135L)
 812 
 813 // RR, BFP
 814 #define DEBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 13 &lt;&lt; 16)
 815 #define DDBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 29 &lt;&lt; 16)
 816 #define DXBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 77 &lt;&lt; 16)
 817 // RM, BFP
 818 #define DEB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 13)
 819 #define DDB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 29)
 820 
 821 // Square Root
 822 // RR, BFP
 823 #define SQEBR_ZOPC  (unsigned  int)(0xb314 &lt;&lt; 16)
 824 #define SQDBR_ZOPC  (unsigned  int)(0xb315 &lt;&lt; 16)
 825 #define SQXBR_ZOPC  (unsigned  int)(0xb316 &lt;&lt; 16)
 826 // RM, BFP
 827 #define SQEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 20)
 828 #define SQDB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 21)
 829 
 830 // Compare and Test
 831 // RR, signed
 832 #define CR_ZOPC     (unsigned  int)(25 &lt;&lt; 8)
 833 #define CGFR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 48 &lt;&lt; 16)
 834 #define CGR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 32 &lt;&lt; 16)
 835 // RI, signed
 836 #define CHI_ZOPC    (unsigned  int)(167 &lt;&lt; 24 | 14 &lt;&lt; 16)
 837 #define CFI_ZOPC    (unsigned long)(0xc2L &lt;&lt; 40 | 0xdL &lt;&lt; 32)
 838 #define CGHI_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 15 &lt;&lt; 16)
 839 #define CGFI_ZOPC   (unsigned long)(0xc2L &lt;&lt; 40 | 0xcL &lt;&lt; 32)
 840 // RM, signed
 841 #define CH_ZOPC     (unsigned  int)(0x49 &lt;&lt; 24)
 842 #define CHY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 121L)
 843 #define C_ZOPC      (unsigned  int)(0x59 &lt;&lt; 24)
 844 #define CY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 89L)
 845 #define CGF_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 48L)
 846 #define CG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 32L)
 847 // RR, unsigned
 848 #define CLR_ZOPC    (unsigned  int)(21 &lt;&lt; 8)
 849 #define CLGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 49 &lt;&lt; 16)
 850 #define CLGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 33 &lt;&lt; 16)
 851 // RIL, unsigned
 852 #define CLFI_ZOPC   (unsigned long)(0xc2L &lt;&lt; 40 | 0xfL &lt;&lt; 32)
 853 #define CLGFI_ZOPC  (unsigned long)(0xc2L &lt;&lt; 40 | 0xeL &lt;&lt; 32)
 854 // RM, unsigned
 855 #define CL_ZOPC     (unsigned  int)(0x55 &lt;&lt; 24)
 856 #define CLY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 85L)
 857 #define CLGF_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 49L)
 858 #define CLG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 33L)
 859 // RI, unsigned
 860 #define TMHH_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 2 &lt;&lt; 16)
 861 #define TMHL_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 3 &lt;&lt; 16)
 862 #define TMLH_ZOPC   (unsigned  int)(167 &lt;&lt; 24)
 863 #define TMLL_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 1 &lt;&lt; 16)
 864 
 865 // RR, BFP
 866 #define CEBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 9 &lt;&lt; 16)
 867 #define CDBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 25 &lt;&lt; 16)
 868 #define CXBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 73 &lt;&lt; 16)
 869 // RM, BFP
 870 #define CEB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 9)
 871 #define CDB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 25)
 872 
 873 // Shift
 874 // arithmetic
 875 #define SLA_ZOPC    (unsigned  int)(0x8b  &lt;&lt; 24)
 876 #define SLAK_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xddL)
 877 #define SLAG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x0bL)
 878 #define SRA_ZOPC    (unsigned  int)(0x8a  &lt;&lt; 24)
 879 #define SRAK_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xdcL)
 880 #define SRAG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x0aL)
 881 // logical
 882 #define SLL_ZOPC    (unsigned  int)(0x89  &lt;&lt; 24)
 883 #define SLLK_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xdfL)
 884 #define SLLG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x0dL)
 885 #define SRL_ZOPC    (unsigned  int)(0x88  &lt;&lt; 24)
 886 #define SRLK_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xdeL)
 887 #define SRLG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x0cL)
 888 
 889 // Rotate, then AND/XOR/OR/insert
 890 // rotate
 891 #define RLL_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x1dL)         // z10
 892 #define RLLG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x1cL)         // z10
 893 // rotate and {AND|XOR|OR|INS}
 894 #define RNSBG_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x54L)         // z196
 895 #define RXSBG_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x57L)         // z196
 896 #define ROSBG_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x56L)         // z196
 897 #define RISBG_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x55L)         // z196
 898 
 899 // AND
 900 // RR, signed
 901 #define NR_ZOPC     (unsigned  int)(20 &lt;&lt; 8)
 902 #define NGR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 128 &lt;&lt; 16)
 903 // RRF, signed
 904 #define NRK_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00f4 &lt;&lt; 16)
 905 #define NGRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00e4 &lt;&lt; 16)
 906 // RI, signed
 907 #define NIHH_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 4 &lt;&lt; 16)
 908 #define NIHL_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 5 &lt;&lt; 16)
 909 #define NILH_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 6 &lt;&lt; 16)
 910 #define NILL_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 7 &lt;&lt; 16)
 911 #define NIHF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 10L &lt;&lt; 32)
 912 #define NILF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 11L &lt;&lt; 32)
 913 // RM, signed
 914 #define N_ZOPC      (unsigned  int)(0x54 &lt;&lt; 24)
 915 #define NY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 84L)
 916 #define NG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 128L)
 917 
 918 // OR
 919 // RR, signed
 920 #define OR_ZOPC     (unsigned  int)(22 &lt;&lt; 8)
 921 #define OGR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 129 &lt;&lt; 16)
 922 // RRF, signed
 923 #define ORK_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00f6 &lt;&lt; 16)
 924 #define OGRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00e6 &lt;&lt; 16)
 925 // RI, signed
 926 #define OIHH_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 8 &lt;&lt; 16)
 927 #define OIHL_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 9 &lt;&lt; 16)
 928 #define OILH_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 10 &lt;&lt; 16)
 929 #define OILL_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 11 &lt;&lt; 16)
 930 #define OIHF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 12L &lt;&lt; 32)
 931 #define OILF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 13L &lt;&lt; 32)
 932 // RM, signed
 933 #define O_ZOPC      (unsigned  int)(0x56 &lt;&lt; 24)
 934 #define OY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 86L)
 935 #define OG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 129L)
 936 
 937 // XOR
 938 // RR, signed
 939 #define XR_ZOPC     (unsigned  int)(23 &lt;&lt; 8)
 940 #define XGR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 130 &lt;&lt; 16)
 941 // RRF, signed
 942 #define XRK_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00f7 &lt;&lt; 16)
 943 #define XGRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00e7 &lt;&lt; 16)
 944 // RI, signed
 945 #define XIHF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 6L &lt;&lt; 32)
 946 #define XILF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 7L &lt;&lt; 32)
 947 // RM, signed
 948 #define X_ZOPC      (unsigned  int)(0x57 &lt;&lt; 24)
 949 #define XY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 87L)
 950 #define XG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 130L)
 951 
 952 
 953 // Data Conversion
 954 
 955 // INT to BFP
 956 #define CEFBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 148 &lt;&lt; 16)
 957 #define CDFBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 149 &lt;&lt; 16)
 958 #define CXFBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 150 &lt;&lt; 16)
 959 #define CEGBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 164 &lt;&lt; 16)
 960 #define CDGBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 165 &lt;&lt; 16)
 961 #define CXGBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 166 &lt;&lt; 16)
 962 // BFP to INT
 963 #define CFEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 152 &lt;&lt; 16)
 964 #define CFDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 153 &lt;&lt; 16)
 965 #define CFXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 154 &lt;&lt; 16)
 966 #define CGEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 168 &lt;&lt; 16)
 967 #define CGDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 169 &lt;&lt; 16)
 968 #define CGXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 170 &lt;&lt; 16)
 969 // INT to DEC
 970 #define CVD_ZOPC    (unsigned  int)(0x4e &lt;&lt; 24)
 971 #define CVDY_ZOPC   (unsigned long)(0xe3L &lt;&lt; 40 | 0x26L)
 972 #define CVDG_ZOPC   (unsigned long)(0xe3L &lt;&lt; 40 | 0x2eL)
 973 
 974 
 975 // BFP Control
 976 
 977 #define SRNM_ZOPC   (unsigned  int)(178 &lt;&lt; 24 | 153 &lt;&lt; 16)
 978 #define EFPC_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 140 &lt;&lt; 16)
 979 #define SFPC_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 132 &lt;&lt; 16)
 980 #define STFPC_ZOPC  (unsigned  int)(178 &lt;&lt; 24 | 156 &lt;&lt; 16)
 981 #define LFPC_ZOPC   (unsigned  int)(178 &lt;&lt; 24 | 157 &lt;&lt; 16)
 982 
 983 
 984 // Branch Instructions
 985 
 986 // Register
 987 #define BCR_ZOPC    (unsigned  int)(7 &lt;&lt; 8)
 988 #define BALR_ZOPC   (unsigned  int)(5 &lt;&lt; 8)
 989 #define BASR_ZOPC   (unsigned  int)(13 &lt;&lt; 8)
 990 #define BCTGR_ZOPC  (unsigned long)(0xb946 &lt;&lt; 16)
 991 // Absolute
 992 #define BC_ZOPC     (unsigned  int)(71 &lt;&lt; 24)
 993 #define BAL_ZOPC    (unsigned  int)(69 &lt;&lt; 24)
 994 #define BAS_ZOPC    (unsigned  int)(77 &lt;&lt; 24)
 995 #define BXH_ZOPC    (unsigned  int)(134 &lt;&lt; 24)
 996 #define BXHG_ZOPC   (unsigned long)(235L &lt;&lt; 40 | 68)
 997 // Relative
 998 #define BRC_ZOPC    (unsigned  int)(167 &lt;&lt; 24 | 4 &lt;&lt; 16)
 999 #define BRCL_ZOPC   (unsigned long)(192L &lt;&lt; 40 | 4L &lt;&lt; 32)
1000 #define BRAS_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 5 &lt;&lt; 16)
1001 #define BRASL_ZOPC  (unsigned long)(192L &lt;&lt; 40 | 5L &lt;&lt; 32)
1002 #define BRCT_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 6 &lt;&lt; 16)
1003 #define BRCTG_ZOPC  (unsigned  int)(167 &lt;&lt; 24 | 7 &lt;&lt; 16)
1004 #define BRXH_ZOPC   (unsigned  int)(132 &lt;&lt; 24)
1005 #define BRXHG_ZOPC  (unsigned long)(236L &lt;&lt; 40 | 68)
1006 #define BRXLE_ZOPC  (unsigned  int)(133 &lt;&lt; 24)
1007 #define BRXLG_ZOPC  (unsigned long)(236L &lt;&lt; 40 | 69)
1008 
1009 
1010 // Compare and Branch Instructions
1011 
1012 // signed comp reg/reg, branch Absolute
1013 #define CRB_ZOPC    (unsigned long)(0xecL &lt;&lt; 40 | 0xf6L)         // z10
1014 #define CGRB_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0xe4L)         // z10
1015 // signed comp reg/reg, branch Relative
1016 #define CRJ_ZOPC    (unsigned long)(0xecL &lt;&lt; 40 | 0x76L)         // z10
1017 #define CGRJ_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0x64L)         // z10
1018 // signed comp reg/imm, branch absolute
1019 #define CIB_ZOPC    (unsigned long)(0xecL &lt;&lt; 40 | 0xfeL)         // z10
1020 #define CGIB_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0xfcL)         // z10
1021 // signed comp reg/imm, branch relative
1022 #define CIJ_ZOPC    (unsigned long)(0xecL &lt;&lt; 40 | 0x7eL)         // z10
1023 #define CGIJ_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0x7cL)         // z10
1024 
1025 // unsigned comp reg/reg, branch Absolute
1026 #define CLRB_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0xf7L)         // z10
1027 #define CLGRB_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0xe5L)         // z10
1028 // unsigned comp reg/reg, branch Relative
1029 #define CLRJ_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0x77L)         // z10
1030 #define CLGRJ_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x65L)         // z10
1031 // unsigned comp reg/imm, branch absolute
1032 #define CLIB_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0xffL)         // z10
1033 #define CLGIB_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0xfdL)         // z10
1034 // unsigned comp reg/imm, branch relative
1035 #define CLIJ_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0x7fL)         // z10
1036 #define CLGIJ_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x7dL)         // z10
1037 
1038 // comp reg/reg, trap
1039 #define CRT_ZOPC    (unsigned  int)(0xb972 &lt;&lt; 16)                // z10
1040 #define CGRT_ZOPC   (unsigned  int)(0xb960 &lt;&lt; 16)                // z10
1041 #define CLRT_ZOPC   (unsigned  int)(0xb973 &lt;&lt; 16)                // z10
1042 #define CLGRT_ZOPC  (unsigned  int)(0xb961 &lt;&lt; 16)                // z10
1043 // comp reg/imm, trap
1044 #define CIT_ZOPC    (unsigned long)(0xecL &lt;&lt; 40 | 0x72L)         // z10
1045 #define CGIT_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0x70L)         // z10
1046 #define CLFIT_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x73L)         // z10
1047 #define CLGIT_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x71L)         // z10
1048 
1049 
1050 // Direct Memory Operations
1051 
1052 // Compare
1053 #define CLI_ZOPC    (unsigned  int)(0x95  &lt;&lt; 24)
1054 #define CLIY_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x55L)
1055 #define CLC_ZOPC    (unsigned long)(0xd5L &lt;&lt; 40)
1056 #define CLCL_ZOPC   (unsigned  int)(0x0f  &lt;&lt;  8)
1057 #define CLCLE_ZOPC  (unsigned  int)(0xa9  &lt;&lt; 24)
1058 #define CLCLU_ZOPC  (unsigned long)(0xebL &lt;&lt; 40 | 0x8fL)
1059 
1060 // Move
1061 #define MVI_ZOPC    (unsigned  int)(0x92  &lt;&lt; 24)
1062 #define MVIY_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x52L)
1063 #define MVC_ZOPC    (unsigned long)(0xd2L &lt;&lt; 40)
1064 #define MVCL_ZOPC   (unsigned  int)(0x0e  &lt;&lt;  8)
1065 #define MVCLE_ZOPC  (unsigned  int)(0xa8  &lt;&lt; 24)
1066 
1067 // Test
1068 #define TM_ZOPC     (unsigned  int)(0x91  &lt;&lt; 24)
1069 #define TMY_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x51L)
1070 
1071 // AND
1072 #define NI_ZOPC     (unsigned  int)(0x94  &lt;&lt; 24)
1073 #define NIY_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x54L)
1074 #define NC_ZOPC     (unsigned long)(0xd4L &lt;&lt; 40)
1075 
1076 // OR
1077 #define OI_ZOPC     (unsigned  int)(0x96  &lt;&lt; 24)
1078 #define OIY_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x56L)
1079 #define OC_ZOPC     (unsigned long)(0xd6L &lt;&lt; 40)
1080 
1081 // XOR
1082 #define XI_ZOPC     (unsigned  int)(0x97  &lt;&lt; 24)
1083 #define XIY_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x57L)
1084 #define XC_ZOPC     (unsigned long)(0xd7L &lt;&lt; 40)
1085 
1086 // Search String
1087 #define SRST_ZOPC   (unsigned  int)(178 &lt;&lt; 24 | 94 &lt;&lt; 16)
1088 #define SRSTU_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 190 &lt;&lt; 16)
1089 
1090 // Translate characters
1091 #define TROO_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x93 &lt;&lt; 16)
1092 #define TROT_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x92 &lt;&lt; 16)
1093 #define TRTO_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x91 &lt;&lt; 16)
1094 #define TRTT_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x90 &lt;&lt; 16)
1095 
1096 
1097 //---------------------------
1098 //--  Vector Instructions  --
1099 //---------------------------
1100 
1101 //---&lt;  Vector Support Instructions  &gt;---
1102 
1103 //---  Load (memory)  ---
1104 
1105 #define VLM_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x36L &lt;&lt; 0)   // load full vreg range (n * 128 bit)
1106 #define VL_ZOPC     (unsigned long)(0xe7L &lt;&lt; 40 | 0x06L &lt;&lt; 0)   // load full vreg (128 bit)
1107 #define VLEB_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x00L &lt;&lt; 0)   // load vreg element (8 bit)
1108 #define VLEH_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x01L &lt;&lt; 0)   // load vreg element (16 bit)
1109 #define VLEF_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x03L &lt;&lt; 0)   // load vreg element (32 bit)
1110 #define VLEG_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x02L &lt;&lt; 0)   // load vreg element (64 bit)
1111 
1112 #define VLREP_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x05L &lt;&lt; 0)   // load and replicate into all vector elements
1113 #define VLLEZ_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x04L &lt;&lt; 0)   // load logical element and zero.
1114 
1115 // vector register gather
1116 #define VGEF_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x13L &lt;&lt; 0)   // gather element (32 bit), V1(M3) = [D2(V2(M3),B2)]
1117 #define VGEG_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x12L &lt;&lt; 0)   // gather element (64 bit), V1(M3) = [D2(V2(M3),B2)]
1118 // vector register scatter
1119 #define VSCEF_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x1bL &lt;&lt; 0)   // vector scatter element FW
1120 #define VSCEG_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x1aL &lt;&lt; 0)   // vector scatter element DW
1121 
1122 #define VLBB_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x07L &lt;&lt; 0)   // load vreg to block boundary (load to alignment).
1123 #define VLL_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x37L &lt;&lt; 0)   // load vreg with length.
1124 
1125 //---  Load (register)  ---
1126 
1127 #define VLR_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x56L &lt;&lt; 0)   // copy full vreg (128 bit)
1128 #define VLGV_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x21L &lt;&lt; 0)   // copy vreg element -&gt; GR
1129 #define VLVG_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x22L &lt;&lt; 0)   // copy GR -&gt; vreg element
1130 #define VLVGP_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x62L &lt;&lt; 0)   // copy GR2, GR3 (disjoint pair) -&gt; vreg
1131 
1132 // vector register pack: cut in half the size the source vector elements
1133 #define VPK_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x94L &lt;&lt; 0)   // just cut
1134 #define VPKS_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x97L &lt;&lt; 0)   // saturate as signed values
1135 #define VPKLS_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x95L &lt;&lt; 0)   // saturate as unsigned values
1136 
1137 // vector register unpack: double in size the source vector elements
1138 #define VUPH_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xd7L &lt;&lt; 0)   // signed, left half of the source vector elements
1139 #define VUPLH_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xd5L &lt;&lt; 0)   // unsigned, left half of the source vector elements
1140 #define VUPL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xd6L &lt;&lt; 0)   // signed, right half of the source vector elements
1141 #define VUPLL_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xd4L &lt;&lt; 0)   // unsigned, right half of the source vector element
1142 
1143 // vector register merge
1144 #define VMRH_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x61L &lt;&lt; 0)   // register merge high (left half of source registers)
1145 #define VMRL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x60L &lt;&lt; 0)   // register merge low (right half of source registers)
1146 
1147 // vector register permute
1148 #define VPERM_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x8cL &lt;&lt; 0)   // vector permute
1149 #define VPDI_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x84L &lt;&lt; 0)   // vector permute DW immediate
1150 
1151 // vector register replicate
1152 #define VREP_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x4dL &lt;&lt; 0)   // vector replicate
1153 #define VREPI_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x45L &lt;&lt; 0)   // vector replicate immediate
1154 #define VSEL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x8dL &lt;&lt; 0)   // vector select
1155 
1156 #define VSEG_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x5fL &lt;&lt; 0)   // vector sign-extend to DW (rightmost element in each DW).
1157 
1158 //---  Load (immediate)  ---
1159 
1160 #define VLEIB_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x40L &lt;&lt; 0)   // load vreg element (16 bit imm to 8 bit)
1161 #define VLEIH_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x41L &lt;&lt; 0)   // load vreg element (16 bit imm to 16 bit)
1162 #define VLEIF_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x43L &lt;&lt; 0)   // load vreg element (16 bit imm to 32 bit)
1163 #define VLEIG_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x42L &lt;&lt; 0)   // load vreg element (16 bit imm to 64 bit)
1164 
1165 //---  Store  ---
1166 
1167 #define VSTM_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x3eL &lt;&lt; 0)   // store full vreg range (n * 128 bit)
1168 #define VST_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x0eL &lt;&lt; 0)   // store full vreg (128 bit)
1169 #define VSTEB_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x08L &lt;&lt; 0)   // store vreg element (8 bit)
1170 #define VSTEH_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x09L &lt;&lt; 0)   // store vreg element (16 bit)
1171 #define VSTEF_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x0bL &lt;&lt; 0)   // store vreg element (32 bit)
1172 #define VSTEG_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x0aL &lt;&lt; 0)   // store vreg element (64 bit)
1173 #define VSTL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x3fL &lt;&lt; 0)   // store vreg with length.
1174 
1175 //---  Misc  ---
1176 
1177 #define VGM_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x46L &lt;&lt; 0)   // generate bit  mask, [start..end] = &#39;1&#39;, else &#39;0&#39;
1178 #define VGBM_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x44L &lt;&lt; 0)   // generate byte mask, bits(imm16) -&gt; bytes
1179 
1180 //---&lt;  Vector Arithmetic Instructions  &gt;---
1181 
1182 // Load
1183 #define VLC_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xdeL &lt;&lt; 0)   // V1 := -V2,   element size = 2**m
1184 #define VLP_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xdfL &lt;&lt; 0)   // V1 := |V2|,  element size = 2**m
1185 
1186 // ADD
1187 #define VA_ZOPC     (unsigned long)(0xe7L &lt;&lt; 40 | 0xf3L &lt;&lt; 0)   // V1 := V2 + V3, element size = 2**m
1188 #define VACC_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xf1L &lt;&lt; 0)   // V1 := carry(V2 + V3), element size = 2**m
1189 
1190 // SUB
1191 #define VS_ZOPC     (unsigned long)(0xe7L &lt;&lt; 40 | 0xf7L &lt;&lt; 0)   // V1 := V2 - V3, element size = 2**m
1192 #define VSCBI_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xf5L &lt;&lt; 0)   // V1 := borrow(V2 - V3), element size = 2**m
1193 
1194 // MUL
1195 #define VML_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xa2L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m
1196 #define VMH_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xa3L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m
1197 #define VMLH_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xa1L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m, unsigned
1198 #define VME_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xa6L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m
1199 #define VMLE_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xa4L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m, unsigned
1200 #define VMO_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xa7L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m
1201 #define VMLO_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xa5L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m, unsigned
1202 
1203 // MUL &amp; ADD
1204 #define VMAL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xaaL &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m
1205 #define VMAH_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xabL &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m
1206 #define VMALH_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xa9L &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m, unsigned
1207 #define VMAE_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xaeL &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m
1208 #define VMALE_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xacL &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m, unsigned
1209 #define VMAO_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xafL &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m
1210 #define VMALO_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xadL &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m, unsigned
1211 
1212 // Vector SUM
1213 #define VSUM_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x64L &lt;&lt; 0)   // V1[j] := toFW(sum(V2[i]) + V3[j]), subelements: byte or HW
1214 #define VSUMG_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x65L &lt;&lt; 0)   // V1[j] := toDW(sum(V2[i]) + V3[j]), subelements: HW or FW
1215 #define VSUMQ_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x67L &lt;&lt; 0)   // V1[j] := toQW(sum(V2[i]) + V3[j]), subelements: FW or DW
1216 
1217 // Average
1218 #define VAVG_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xf2L &lt;&lt; 0)   // V1 := (V2+V3+1)/2, signed,   element size = 2**m
1219 #define VAVGL_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xf0L &lt;&lt; 0)   // V1 := (V2+V3+1)/2, unsigned, element size = 2**m
1220 
1221 // VECTOR Galois Field Multiply Sum
1222 #define VGFM_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xb4L &lt;&lt; 0)
1223 #define VGFMA_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xbcL &lt;&lt; 0)
1224 
1225 //---&lt;  Vector Logical Instructions  &gt;---
1226 
1227 // AND
1228 #define VN_ZOPC     (unsigned long)(0xe7L &lt;&lt; 40 | 0x68L &lt;&lt; 0)   // V1 := V2 &amp; V3,  element size = 2**m
1229 #define VNC_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x69L &lt;&lt; 0)   // V1 := V2 &amp; ~V3, element size = 2**m
1230 
1231 // XOR
1232 #define VX_ZOPC     (unsigned long)(0xe7L &lt;&lt; 40 | 0x6dL &lt;&lt; 0)   // V1 := V2 ^ V3,  element size = 2**m
1233 
1234 // NOR
1235 #define VNO_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x6bL &lt;&lt; 0)   // V1 := !(V2 | V3),  element size = 2**m
1236 
1237 // OR
1238 #define VO_ZOPC     (unsigned long)(0xe7L &lt;&lt; 40 | 0x6aL &lt;&lt; 0)   // V1 := V2 | V3,  element size = 2**m
1239 
1240 // Comparison (element-wise)
1241 #define VCEQ_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xf8L &lt;&lt; 0)   // V1 := (V2 == V3) ? 0xffff : 0x0000, element size = 2**m
1242 #define VCH_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xfbL &lt;&lt; 0)   // V1 := (V2  &gt; V3) ? 0xffff : 0x0000, element size = 2**m, signed
1243 #define VCHL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xf9L &lt;&lt; 0)   // V1 := (V2  &gt; V3) ? 0xffff : 0x0000, element size = 2**m, unsigned
1244 
1245 // Max/Min (element-wise)
1246 #define VMX_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xffL &lt;&lt; 0)   // V1 := (V2 &gt; V3) ? V2 : V3, element size = 2**m, signed
1247 #define VMXL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xfdL &lt;&lt; 0)   // V1 := (V2 &gt; V3) ? V2 : V3, element size = 2**m, unsigned
1248 #define VMN_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xfeL &lt;&lt; 0)   // V1 := (V2 &lt; V3) ? V2 : V3, element size = 2**m, signed
1249 #define VMNL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xfcL &lt;&lt; 0)   // V1 := (V2 &lt; V3) ? V2 : V3, element size = 2**m, unsigned
1250 
1251 // Leading/Trailing Zeros, population count
1252 #define VCLZ_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x53L &lt;&lt; 0)   // V1 := leadingzeros(V2),  element size = 2**m
1253 #define VCTZ_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x52L &lt;&lt; 0)   // V1 := trailingzeros(V2), element size = 2**m
1254 #define VPOPCT_ZOPC (unsigned long)(0xe7L &lt;&lt; 40 | 0x50L &lt;&lt; 0)   // V1 := popcount(V2), bytewise!!
1255 
1256 // Rotate/Shift
1257 #define VERLLV_ZOPC (unsigned long)(0xe7L &lt;&lt; 40 | 0x73L &lt;&lt; 0)   // V1 := rotateleft(V2), rotate count in V3 element
1258 #define VERLL_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x33L &lt;&lt; 0)   // V1 := rotateleft(V3), rotate count from d2(b2).
1259 #define VERIM_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x72L &lt;&lt; 0)   // Rotate then insert under mask. Read Principles of Operation!!
1260 
1261 #define VESLV_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x70L &lt;&lt; 0)   // V1 := SLL(V2, V3), unsigned, element-wise
1262 #define VESL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x30L &lt;&lt; 0)   // V1 := SLL(V3), unsigned, shift count from d2(b2).
1263 
1264 #define VESRAV_ZOPC (unsigned long)(0xe7L &lt;&lt; 40 | 0x7AL &lt;&lt; 0)   // V1 := SRA(V2, V3), signed, element-wise
1265 #define VESRA_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x3AL &lt;&lt; 0)   // V1 := SRA(V3), signed, shift count from d2(b2).
1266 #define VESRLV_ZOPC (unsigned long)(0xe7L &lt;&lt; 40 | 0x78L &lt;&lt; 0)   // V1 := SRL(V2, V3), unsigned, element-wise
1267 #define VESRL_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x38L &lt;&lt; 0)   // V1 := SRL(V3), unsigned, shift count from d2(b2).
1268 
1269 #define VSL_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x74L &lt;&lt; 0)   // V1 := SLL(V2), unsigned, bit-count
1270 #define VSLB_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x75L &lt;&lt; 0)   // V1 := SLL(V2), unsigned, byte-count
1271 #define VSLDB_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x77L &lt;&lt; 0)   // V1 := SLL((V2,V3)), unsigned, byte-count
1272 
1273 #define VSRA_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x7eL &lt;&lt; 0)   // V1 := SRA(V2), signed, bit-count
1274 #define VSRAB_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x7fL &lt;&lt; 0)   // V1 := SRA(V2), signed, byte-count
1275 #define VSRL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x7cL &lt;&lt; 0)   // V1 := SRL(V2), unsigned, bit-count
1276 #define VSRLB_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x7dL &lt;&lt; 0)   // V1 := SRL(V2), unsigned, byte-count
1277 
1278 // Test under Mask
1279 #define VTM_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xd8L &lt;&lt; 0)   // Like TM, set CC according to state of selected bits.
1280 
1281 //---&lt;  Vector String Instructions  &gt;---
1282 #define VFAE_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x82L &lt;&lt; 0)   // Find any element
1283 #define VFEE_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x80L &lt;&lt; 0)   // Find element equal
1284 #define VFENE_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x81L &lt;&lt; 0)   // Find element not equal
1285 #define VSTRC_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x8aL &lt;&lt; 0)   // String range compare
1286 #define VISTR_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x5cL &lt;&lt; 0)   // Isolate String
1287 
1288 
1289 //--------------------------------
1290 //--  Miscellaneous Operations  --
1291 //--------------------------------
1292 
1293 // Execute
1294 #define EX_ZOPC     (unsigned  int)(68L &lt;&lt; 24)
1295 #define EXRL_ZOPC   (unsigned long)(0xc6L &lt;&lt; 40 | 0x00L &lt;&lt; 32)  // z10
1296 
1297 // Compare and Swap
1298 #define CS_ZOPC     (unsigned  int)(0xba &lt;&lt; 24)
1299 #define CSY_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x14L)
1300 #define CSG_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x30L)
1301 
1302 // Interlocked-Update
1303 #define LAA_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0xf8L)         // z196
1304 #define LAAG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xe8L)         // z196
1305 #define LAAL_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xfaL)         // z196
1306 #define LAALG_ZOPC  (unsigned long)(0xebL &lt;&lt; 40 | 0xeaL)         // z196
1307 #define LAN_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0xf4L)         // z196
1308 #define LANG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xe4L)         // z196
1309 #define LAX_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0xf7L)         // z196
1310 #define LAXG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xe7L)         // z196
1311 #define LAO_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0xf6L)         // z196
1312 #define LAOG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xe6L)         // z196
1313 
1314 // System Functions
1315 #define STCKF_ZOPC  (unsigned  int)(0xb2 &lt;&lt; 24 | 0x7c &lt;&lt; 16)
1316 #define STFLE_ZOPC  (unsigned  int)(0xb2 &lt;&lt; 24 | 0xb0 &lt;&lt; 16)
1317 #define ECTG_ZOPC   (unsigned long)(0xc8L &lt;&lt;40 | 0x01L &lt;&lt; 32)    // z10
1318 #define ECAG_ZOPC   (unsigned long)(0xebL &lt;&lt;40 | 0x4cL)          // z10
1319 
1320 // Execution Prediction
1321 #define PFD_ZOPC    (unsigned long)(0xe3L &lt;&lt;40 | 0x36L)          // z10
1322 #define PFDRL_ZOPC  (unsigned long)(0xc6L &lt;&lt;40 | 0x02L &lt;&lt; 32)    // z10
1323 #define BPP_ZOPC    (unsigned long)(0xc7L &lt;&lt;40)                  // branch prediction preload  -- EC12
1324 #define BPRP_ZOPC   (unsigned long)(0xc5L &lt;&lt;40)                  // branch prediction preload  -- EC12
1325 
1326 // Transaction Control
1327 #define TBEGIN_ZOPC  (unsigned long)(0xe560L &lt;&lt; 32)              // tx begin                   -- EC12
1328 #define TBEGINC_ZOPC (unsigned long)(0xe561L &lt;&lt; 32)              // tx begin (constrained)     -- EC12
1329 #define TEND_ZOPC    (unsigned  int)(0xb2f8  &lt;&lt; 16)              // tx end                     -- EC12
1330 #define TABORT_ZOPC  (unsigned  int)(0xb2fc  &lt;&lt; 16)              // tx abort                   -- EC12
1331 #define ETND_ZOPC    (unsigned  int)(0xb2ec  &lt;&lt; 16)              // tx nesting depth           -- EC12
1332 #define PPA_ZOPC     (unsigned  int)(0xb2e8  &lt;&lt; 16)              // tx processor assist        -- EC12
1333 
1334 // Crypto and Checksum
1335 #define CKSM_ZOPC   (unsigned  int)(0xb2 &lt;&lt; 24 | 0x41 &lt;&lt; 16)     // checksum. This is NOT CRC32
1336 #define KM_ZOPC     (unsigned  int)(0xb9 &lt;&lt; 24 | 0x2e &lt;&lt; 16)     // cipher
1337 #define KMC_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x2f &lt;&lt; 16)     // cipher
1338 #define KIMD_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x3e &lt;&lt; 16)     // SHA (msg digest)
1339 #define KLMD_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x3f &lt;&lt; 16)     // SHA (msg digest)
1340 #define KMAC_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x1e &lt;&lt; 16)     // Message Authentication Code
1341 
1342 // Various
1343 #define TCEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 16)
1344 #define TCDB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 17)
1345 #define TAM_ZOPC    (unsigned long)(267)
1346 
1347 #define FLOGR_ZOPC  (unsigned  int)(0xb9 &lt;&lt; 24 | 0x83 &lt;&lt; 16)
1348 #define POPCNT_ZOPC (unsigned  int)(0xb9e1 &lt;&lt; 16)
1349 #define AHHHR_ZOPC  (unsigned  int)(0xb9c8 &lt;&lt; 16)
1350 #define AHHLR_ZOPC  (unsigned  int)(0xb9d8 &lt;&lt; 16)
1351 
1352 
1353 // OpCode field masks
1354 
1355 #define RI_MASK     (unsigned  int)(0xff  &lt;&lt; 24 | 0x0f &lt;&lt; 16)
1356 #define RRE_MASK    (unsigned  int)(0xff  &lt;&lt; 24 | 0xff &lt;&lt; 16)
1357 #define RSI_MASK    (unsigned  int)(0xff  &lt;&lt; 24)
1358 #define RIE_MASK    (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1359 #define RIL_MASK    (unsigned long)(0xffL &lt;&lt; 40 | 0x0fL &lt;&lt; 32)
1360 
1361 #define BASR_MASK   (unsigned  int)(0xff &lt;&lt; 8)
1362 #define BCR_MASK    (unsigned  int)(0xff &lt;&lt; 8)
1363 #define BRC_MASK    (unsigned  int)(0xff &lt;&lt; 24 | 0x0f &lt;&lt; 16)
1364 #define LGHI_MASK   (unsigned  int)(0xff &lt;&lt; 24 | 0x0f &lt;&lt; 16)
1365 #define LLI_MASK    (unsigned  int)(0xff &lt;&lt; 24 | 0x0f &lt;&lt; 16)
1366 #define II_MASK     (unsigned  int)(0xff &lt;&lt; 24 | 0x0f &lt;&lt; 16)
1367 #define LLIF_MASK   (unsigned long)(0xffL &lt;&lt; 40 | 0x0fL &lt;&lt; 32)
1368 #define IIF_MASK    (unsigned long)(0xffL &lt;&lt; 40 | 0x0fL &lt;&lt; 32)
1369 #define BRASL_MASK  (unsigned long)(0xffL &lt;&lt; 40 | 0x0fL &lt;&lt; 32)
1370 #define TM_MASK     (unsigned  int)(0xff &lt;&lt; 24)
1371 #define TMY_MASK    (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1372 #define LB_MASK     (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1373 #define LH_MASK     (unsigned int)(0xff &lt;&lt; 24)
1374 #define L_MASK      (unsigned int)(0xff &lt;&lt; 24)
1375 #define LY_MASK     (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1376 #define LG_MASK     (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1377 #define LLGH_MASK   (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1378 #define LLGF_MASK   (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1379 #define SLAG_MASK   (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1380 #define LARL_MASK   (unsigned long)(0xff0fL &lt;&lt; 32)
1381 #define LGRL_MASK   (unsigned long)(0xff0fL &lt;&lt; 32)
1382 #define LE_MASK     (unsigned int)(0xff &lt;&lt; 24)
1383 #define LD_MASK     (unsigned int)(0xff &lt;&lt; 24)
1384 #define ST_MASK     (unsigned int)(0xff &lt;&lt; 24)
1385 #define STC_MASK    (unsigned int)(0xff &lt;&lt; 24)
1386 #define STG_MASK    (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1387 #define STH_MASK    (unsigned int)(0xff &lt;&lt; 24)
1388 #define STE_MASK    (unsigned int)(0xff &lt;&lt; 24)
1389 #define STD_MASK    (unsigned int)(0xff &lt;&lt; 24)
1390 #define CMPBRANCH_MASK (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1391 #define REL_LONG_MASK  (unsigned long)(0xff0fL &lt;&lt; 32)
1392 
1393  public:
1394   // Condition code masks. Details:
1395   // - Mask bit#3 must be zero for all compare and branch/trap instructions to ensure
1396   //   future compatibility.
1397   // - For all arithmetic instructions which set the condition code, mask bit#3
1398   //   indicates overflow (&quot;unordered&quot; in float operations).
1399   // - &quot;unordered&quot; float comparison results have to be treated as low.
1400   // - When overflow/unordered is detected, none of the branch conditions is true,
1401   //   except for bcondOverflow/bcondNotOrdered and bcondAlways.
1402   // - For INT comparisons, the inverse condition can be calculated as (14-cond).
1403   // - For FLOAT comparisons, the inverse condition can be calculated as (15-cond).
1404   enum branch_condition {
1405     bcondNever       =  0,
1406     bcondAlways      = 15,
1407 
1408     // Specific names. Make use of lightweight sync.
1409     // Full and lightweight sync operation.
1410     bcondFullSync    = 15,
1411     bcondLightSync   = 14,
1412     bcondNop         =  0,
1413 
1414     // arithmetic compare instructions
1415     // arithmetic load and test, insert instructions
1416     // Mask bit#3 must be zero for future compatibility.
1417     bcondEqual       =  8,
1418     bcondNotEqual    =  6,
1419     bcondLow         =  4,
1420     bcondNotLow      = 10,
1421     bcondHigh        =  2,
1422     bcondNotHigh     = 12,
1423     // arithmetic calculation instructions
1424     // Mask bit#3 indicates overflow if detected by instr.
1425     // Mask bit#3 = 0 (overflow is not handled by compiler).
1426     bcondOverflow    =  1,
1427     bcondNotOverflow = 14,
1428     bcondZero        =  bcondEqual,
1429     bcondNotZero     =  bcondNotEqual,
1430     bcondNegative    =  bcondLow,
1431     bcondNotNegative =  bcondNotLow,
1432     bcondPositive    =  bcondHigh,
1433     bcondNotPositive =  bcondNotHigh,
1434     bcondNotOrdered  =  1,  // float comparisons
1435     bcondOrdered     = 14,  // float comparisons
1436     bcondLowOrNotOrdered  =  bcondLow  | bcondNotOrdered,  // float comparisons
1437     bcondHighOrNotOrdered =  bcondHigh | bcondNotOrdered,  // float comparisons
1438     bcondNotLowOrNotOrdered   =  bcondNotLow   | bcondNotOrdered,  // float comparisons
1439     bcondNotHighOrNotOrdered  =  bcondNotHigh  | bcondNotOrdered,  // float comparisons
1440     bcondNotEqualOrNotOrdered =  bcondNotEqual | bcondNotOrdered,  // float comparisons
1441     // unsigned arithmetic calculation instructions
1442     // Mask bit#0 is not used by these instructions.
1443     // There is no indication of overflow for these instr.
1444     bcondLogZero_NoCarry     =  8,
1445     bcondLogZero_Carry       =  2,
1446     // bcondLogZero_Borrow      =  8,  // This CC is never generated.
1447     bcondLogZero_NoBorrow    =  2,
1448     bcondLogZero             =  bcondLogZero_Carry | bcondLogZero_NoCarry,
1449     bcondLogNotZero_NoCarry  =  4,
1450     bcondLogNotZero_Carry    =  1,
1451     bcondLogNotZero_Borrow   =  4,
1452     bcondLogNotZero_NoBorrow =  1,
1453     bcondLogNotZero          =  bcondLogNotZero_Carry | bcondLogNotZero_NoCarry,
1454     bcondLogCarry            =  bcondLogZero_Carry | bcondLogNotZero_Carry,
1455     bcondLogBorrow           =  /* bcondLogZero_Borrow | */ bcondLogNotZero_Borrow,
1456     // Vector compare instructions
1457     bcondVAlltrue    =  8,  // All  vector elements evaluate true
1458     bcondVMixed      =  4,  // Some vector elements evaluate true, some false
1459     bcondVAllfalse   =  1,  // All  vector elements evaluate false
1460     // string search instructions
1461     bcondFound       =  4,
1462     bcondNotFound    =  2,
1463     bcondInterrupted =  1,
1464     // bit test instructions
1465     bcondAllZero     =  8,
1466     bcondMixed       =  6,
1467     bcondAllOne      =  1,
1468     bcondNotAllZero  =  7 // for tmll
1469   };
1470 
1471   enum Condition {
1472     // z/Architecture
1473     negative         = 0,
1474     less             = 0,
1475     positive         = 1,
1476     greater          = 1,
1477     zero             = 2,
1478     equal            = 2,
1479     summary_overflow = 3,
1480   };
1481 
1482   // Rounding mode for float-2-int conversions.
1483   enum RoundingMode {
1484     current_mode      = 0,   // Mode taken from FPC register.
1485     biased_to_nearest = 1,
1486     to_nearest        = 4,
1487     to_zero           = 5,
1488     to_plus_infinity  = 6,
1489     to_minus_infinity = 7
1490   };
1491 
1492   // Vector Register Element Type.
1493   enum VRegElemType {
1494     VRET_BYTE   = 0,
1495     VRET_HW     = 1,
1496     VRET_FW     = 2,
1497     VRET_DW     = 3,
1498     VRET_QW     = 4
1499   };
1500 
1501   // Vector Operation Result Control.
1502   //   This is a set of flags used in some vector instructions to control
1503   //   the result (side) effects of instruction execution.
1504   enum VOpRC {
1505     VOPRC_CCSET    = 0b0001, // set the CC.
1506     VOPRC_CCIGN    = 0b0000, // ignore, don&#39;t set CC.
1507     VOPRC_ZS       = 0b0010, // Zero Search. Additional, elementwise, comparison against zero.
1508     VOPRC_NOZS     = 0b0000, // No Zero Search.
1509     VOPRC_RTBYTEIX = 0b0100, // generate byte index to lowest element with true comparison.
1510     VOPRC_RTBITVEC = 0b0000, // generate bit vector, all 1s for true, all 0s for false element comparisons.
1511     VOPRC_INVERT   = 0b1000, // invert comparison results.
1512     VOPRC_NOINVERT = 0b0000  // use comparison results as is, do not invert.
1513   };
1514 
1515   // Inverse condition code, i.e. determine &quot;15 - cc&quot; for a given condition code cc.
1516   static branch_condition inverse_condition(branch_condition cc);
1517   static branch_condition inverse_float_condition(branch_condition cc);
1518 
1519 
1520   //-----------------------------------------------
1521   // instruction property getter methods
1522   //-----------------------------------------------
1523 
1524   // Calculate length of instruction.
1525   static unsigned int instr_len(unsigned char *instr);
1526 
1527   // Longest instructions are 6 bytes on z/Architecture.
1528   static unsigned int instr_maxlen() { return 6; }
1529 
1530   // Average instruction is 4 bytes on z/Architecture (just a guess).
1531   static unsigned int instr_avglen() { return 4; }
1532 
1533   // Shortest instructions are 2 bytes on z/Architecture.
1534   static unsigned int instr_minlen() { return 2; }
1535 
1536   // Move instruction at pc right-justified into passed long int.
1537   // Return instr len in bytes as function result.
1538   static unsigned int get_instruction(unsigned char *pc, unsigned long *instr);
1539 
1540   // Move instruction in passed (long int) into storage at pc.
1541   // This code is _NOT_ MT-safe!!
1542   static void set_instruction(unsigned char *pc, unsigned long instr, unsigned int len) {
1543     memcpy(pc, ((unsigned char *)&amp;instr)+sizeof(unsigned long)-len, len);
1544   }
1545 
1546 
1547   //------------------------------------------
1548   // instruction field test methods
1549   //------------------------------------------
1550 
1551   // Only used once in s390.ad to implement Matcher::is_short_branch_offset().
1552   static bool is_within_range_of_RelAddr16(address target, address origin) {
1553     return RelAddr::is_in_range_of_RelAddr16(target, origin);
1554   }
1555 
1556 
1557   //----------------------------------
1558   // some diagnostic output
1559   //----------------------------------
1560 
1561   static void print_dbg_msg(outputStream* out, unsigned long inst, const char* msg, int ilen) PRODUCT_RETURN;
1562   static void dump_code_range(outputStream* out, address pc, const unsigned int range, const char* msg = &quot; &quot;) PRODUCT_RETURN;
1563 
1564  protected:
1565 
1566   //-------------------------------------------------------
1567   // instruction field helper methods (internal)
1568   //-------------------------------------------------------
1569 
1570   // Return a mask of 1s between hi_bit and lo_bit (inclusive).
1571   static long fmask(unsigned int hi_bit, unsigned int lo_bit) {
1572     assert(hi_bit &gt;= lo_bit &amp;&amp; hi_bit &lt; 48, &quot;bad bits&quot;);
1573     return ((1L&lt;&lt;(hi_bit-lo_bit+1)) - 1) &lt;&lt; lo_bit;
1574   }
1575 
1576   // extract u_field
1577   // unsigned value
1578   static long inv_u_field(long x, int hi_bit, int lo_bit) {
1579     return (x &amp; fmask(hi_bit, lo_bit)) &gt;&gt; lo_bit;
1580   }
1581 
1582   // extract s_field
1583   // Signed value, may need sign extension.
1584   static long inv_s_field(long x, int hi_bit, int lo_bit) {
1585     x = inv_u_field(x, hi_bit, lo_bit);
1586     // Highest extracted bit set -&gt; sign extension.
1587     return (x &gt;= (1L&lt;&lt;(hi_bit-lo_bit)) ? x | ((-1L)&lt;&lt;(hi_bit-lo_bit)) : x);
1588   }
1589 
1590   // Extract primary opcode from instruction.
1591   static int z_inv_op(int  x) { return inv_u_field(x, 31, 24); }
1592   static int z_inv_op(long x) { return inv_u_field(x, 47, 40); }
1593 
1594   static int inv_reg( long x, int s, int len) { return inv_u_field(x, (len-s)-1, (len-s)-4); }  // Regs are encoded in 4 bits.
1595   static int inv_mask(long x, int s, int len) { return inv_u_field(x, (len-s)-1, (len-s)-8); }  // Mask is 8 bits long.
1596   static int inv_simm16_48(long x) { return (inv_s_field(x, 31, 16)); }                         // 6-byte instructions only
1597   static int inv_simm16(long x)    { return (inv_s_field(x, 15,  0)); }                         // 4-byte instructions only
1598   static int inv_simm20(long x)    { return (inv_u_field(x, 27, 16) |                           // 6-byte instructions only
1599                                              inv_s_field(x, 15, 8)&lt;&lt;12); }
1600   static int inv_simm32(long x)    { return (inv_s_field(x, 31,  0)); }                         // 6-byte instructions only
1601   static int inv_uimm12(long x)    { return (inv_u_field(x, 11,  0)); }                         // 4-byte instructions only
1602 
1603   // Encode u_field from long value.
1604   static long u_field(long x, int hi_bit, int lo_bit) {
1605     long r = x &lt;&lt; lo_bit;
1606     assert((r &amp; ~fmask(hi_bit, lo_bit))   == 0, &quot;value out of range&quot;);
1607     assert(inv_u_field(r, hi_bit, lo_bit) == x, &quot;just checking&quot;);
1608     return r;
1609   }
1610 
1611   static int64_t rsmask_48( Address a) { assert(a.is_RSform(),  &quot;bad address format&quot;); return rsmask_48( a.disp12(), a.base()); }
1612   static int64_t rxmask_48( Address a) {      if (a.is_RXform())  { return rxmask_48( a.disp12(), a.index(), a.base()); }
1613                                          else if (a.is_RSform())  { return rsmask_48( a.disp12(),            a.base()); }
1614                                          else                     { guarantee(false, &quot;bad address format&quot;);  return 0;  }
1615                                        }
1616   static int64_t rsymask_48(Address a) { assert(a.is_RSYform(), &quot;bad address format&quot;); return rsymask_48(a.disp20(), a.base()); }
1617   static int64_t rxymask_48(Address a) {      if (a.is_RXYform()) { return rxymask_48( a.disp20(), a.index(), a.base()); }
1618                                          else if (a.is_RSYform()) { return rsymask_48( a.disp20(),            a.base()); }
1619                                          else                     { guarantee(false, &quot;bad address format&quot;);  return 0;   }
1620                                        }
1621 
1622   static int64_t rsmask_48( int64_t d2, Register b2)              { return uimm12(d2, 20, 48)                   | regz(b2, 16, 48); }
1623   static int64_t rxmask_48( int64_t d2, Register x2, Register b2) { return uimm12(d2, 20, 48) | reg(x2, 12, 48) | regz(b2, 16, 48); }
1624   static int64_t rsymask_48(int64_t d2, Register b2)              { return simm20(d2)                           | regz(b2, 16, 48); }
1625   static int64_t rxymask_48(int64_t d2, Register x2, Register b2) { return simm20(d2)         | reg(x2, 12, 48) | regz(b2, 16, 48); }
1626 
1627   // Address calculated from d12(vx,b) - vx is vector index register.
1628   static int64_t rvmask_48( int64_t d2, VectorRegister x2, Register b2) { return uimm12(d2, 20, 48) | vreg(x2, 12) | regz(b2, 16, 48); }
1629 
1630   static int64_t vreg_mask(VectorRegister v, int pos) {
1631     return vreg(v, pos) | v-&gt;RXB_mask(pos);
1632   }
1633 
1634   // Vector Element Size Control. 4-bit field which indicates the size of the vector elements.
1635   static int64_t vesc_mask(int64_t size, int min_size, int max_size, int pos) {
1636     // min_size - minimum element size. Not all instructions support element sizes beginning with &quot;byte&quot;.
1637     // max_size - maximum element size. Not all instructions support element sizes up to &quot;QW&quot;.
1638     assert((min_size &lt;= size) &amp;&amp; (size &lt;= max_size), &quot;element size control out of range&quot;);
1639     return uimm4(size, pos, 48);
1640   }
1641 
1642   // Vector Element IndeX. 4-bit field which indexes the target vector element.
1643   static int64_t veix_mask(int64_t ix, int el_size, int pos) {
1644     // el_size - size of the vector element. This is a VRegElemType enum value.
1645     // ix      - vector element index.
1646     int max_ix = -1;
1647     switch (el_size) {
1648       case VRET_BYTE: max_ix = 15; break;
1649       case VRET_HW:   max_ix =  7; break;
1650       case VRET_FW:   max_ix =  3; break;
1651       case VRET_DW:   max_ix =  1; break;
1652       case VRET_QW:   max_ix =  0; break;
1653       default:        guarantee(false, &quot;bad vector element size %d&quot;, el_size); break;
1654     }
1655     assert((0 &lt;= ix) &amp;&amp; (ix &lt;= max_ix), &quot;element size out of range (0 &lt;= %ld &lt;= %d)&quot;, ix, max_ix);
1656     return uimm4(ix, pos, 48);
1657   }
1658 
1659   // Vector Operation Result Control. 4-bit field.
1660   static int64_t voprc_any(int64_t flags, int pos, int64_t allowed_flags = 0b1111) {
1661     assert((flags &amp; allowed_flags) == flags, &quot;Invalid VOPRC_* flag combination: %d&quot;, (int)flags);
1662     return uimm4(flags, pos, 48);
1663   }
1664 
1665   // Vector Operation Result Control. Condition code setting.
1666   static int64_t voprc_ccmask(int64_t flags, int pos) {
1667     return voprc_any(flags, pos, VOPRC_CCIGN | VOPRC_CCSET);
1668   }
1669 
1670  public:
1671 
1672   //--------------------------------------------------
1673   // instruction field construction methods
1674   //--------------------------------------------------
1675 
1676   // Compute relative address (32 bit) for branch.
1677   // Only used once in nativeInst_s390.cpp.
1678   static intptr_t z_pcrel_off(address dest, address pc) {
1679     return RelAddr::pcrel_off32(dest, pc);
1680   }
1681 
1682   // Extract 20-bit signed displacement.
1683   // Only used in disassembler_s390.cpp for temp enhancements.
1684   static int inv_simm20_xx(address iLoc) {
1685     unsigned long instr = 0;
1686     unsigned long iLen  = get_instruction(iLoc, &amp;instr);
1687     return inv_simm20(instr);
1688   }
1689 
1690   // unsigned immediate, in low bits, nbits long
1691   static long uimm(long x, int nbits) {
1692     assert(Immediate::is_uimm(x, nbits), &quot;unsigned constant out of range&quot;);
1693     return x &amp; fmask(nbits - 1, 0);
1694   }
1695 
1696   // Cast &#39;1&#39; to long to avoid sign extension if nbits = 32.
1697   // signed immediate, in low bits, nbits long
1698   static long simm(long x, int nbits) {
1699     assert(Immediate::is_simm(x, nbits), &quot;value out of range&quot;);
1700     return x &amp; fmask(nbits - 1, 0);
1701   }
1702 
1703   static long imm(int64_t x, int nbits) {
1704     // Assert that x can be represented with nbits bits ignoring the sign bits,
1705     // i.e. the more higher bits should all be 0 or 1.
1706     assert((x &gt;&gt; nbits) == 0 || (x &gt;&gt; nbits) == -1, &quot;value out of range&quot;);
1707     return x &amp; fmask(nbits-1, 0);
1708   }
1709 
1710   // A 20-bit displacement is only in instructions of the
1711   // RSY, RXY, or SIY format. In these instructions, the D
1712   // field consists of a DL (low) field in bit positions 20-31
1713   // and of a DH (high) field in bit positions 32-39. The
1714   // value of the displacement is formed by appending the
1715   // contents of the DH field to the left of the contents of
1716   // the DL field.
1717   static long simm20(int64_t ui20) {
1718     assert(Immediate::is_simm(ui20, 20), &quot;value out of range&quot;);
1719     return ( ((ui20        &amp; 0xfffL) &lt;&lt; (48-32)) |  // DL
1720             (((ui20 &gt;&gt; 12) &amp;  0xffL) &lt;&lt; (48-40)));  // DH
1721   }
1722 
1723   static long reg(Register r, int s, int len)  { return u_field(r-&gt;encoding(), (len-s)-1, (len-s)-4); }
1724   static long reg(int r, int s, int len)       { return u_field(r,             (len-s)-1, (len-s)-4); }
1725   static long regt(Register r, int s, int len) { return reg(r, s, len); }
1726   static long regz(Register r, int s, int len) { assert(r != Z_R0, &quot;cannot use register R0 in memory access&quot;); return reg(r, s, len); }
1727 
1728   static long uimm4( int64_t ui4,  int s, int len) { return uimm(ui4,   4) &lt;&lt; (len-s-4);  }
1729   static long uimm6( int64_t ui6,  int s, int len) { return uimm(ui6,   6) &lt;&lt; (len-s-6);  }
1730   static long uimm8( int64_t ui8,  int s, int len) { return uimm(ui8,   8) &lt;&lt; (len-s-8);  }
1731   static long uimm12(int64_t ui12, int s, int len) { return uimm(ui12, 12) &lt;&lt; (len-s-12); }
1732   static long uimm16(int64_t ui16, int s, int len) { return uimm(ui16, 16) &lt;&lt; (len-s-16); }
1733   static long uimm32(int64_t ui32, int s, int len) { return uimm((unsigned)ui32, 32) &lt;&lt; (len-s-32); } // prevent sign extension
1734 
1735   static long simm8( int64_t si8,  int s, int len) { return simm(si8,   8) &lt;&lt; (len-s-8);  }
1736   static long simm12(int64_t si12, int s, int len) { return simm(si12, 12) &lt;&lt; (len-s-12); }
1737   static long simm16(int64_t si16, int s, int len) { return simm(si16, 16) &lt;&lt; (len-s-16); }
1738   static long simm24(int64_t si24, int s, int len) { return simm(si24, 24) &lt;&lt; (len-s-24); }
1739   static long simm32(int64_t si32, int s, int len) { return simm(si32, 32) &lt;&lt; (len-s-32); }
1740 
1741   static long imm8( int64_t i8,  int s, int len)   { return imm(i8,   8) &lt;&lt; (len-s-8);  }
1742   static long imm12(int64_t i12, int s, int len)   { return imm(i12, 12) &lt;&lt; (len-s-12); }
1743   static long imm16(int64_t i16, int s, int len)   { return imm(i16, 16) &lt;&lt; (len-s-16); }
1744   static long imm24(int64_t i24, int s, int len)   { return imm(i24, 24) &lt;&lt; (len-s-24); }
1745   static long imm32(int64_t i32, int s, int len)   { return imm(i32, 32) &lt;&lt; (len-s-32); }
1746 
1747   static long vreg(VectorRegister v, int pos)      { const int len = 48; return u_field(v-&gt;encoding()&amp;0x0f, (len-pos)-1, (len-pos)-4) | v-&gt;RXB_mask(pos); }
1748 
1749   static long fregt(FloatRegister r, int s, int len) { return freg(r,s,len); }
1750   static long freg( FloatRegister r, int s, int len) { return u_field(r-&gt;encoding(), (len-s)-1, (len-s)-4); }
1751 
1752   // Rounding mode for float-2-int conversions.
1753   static long rounding_mode(RoundingMode m, int s, int len) {
1754     assert(m != 2 &amp;&amp; m != 3, &quot;invalid mode&quot;);
1755     return uimm(m, 4) &lt;&lt; (len-s-4);
1756   }
1757 
1758   //--------------------------------------------
1759   // instruction field getter methods
1760   //--------------------------------------------
1761 
1762   static int get_imm32(address a, int instruction_number) {
1763     int imm;
1764     int *p =((int *)(a + 2 + 6 * instruction_number));
1765     imm = *p;
1766     return imm;
1767   }
1768 
1769   static short get_imm16(address a, int instruction_number) {
1770     short imm;
1771     short *p =((short *)a) + 2 * instruction_number + 1;
1772     imm = *p;
1773     return imm;
1774   }
1775 
1776 
1777   //--------------------------------------------
1778   // instruction field setter methods
1779   //--------------------------------------------
1780 
1781   static void set_imm32(address a, int64_t s) {
1782     assert(Immediate::is_simm32(s) || Immediate::is_uimm32(s), &quot;to big&quot;);
1783     int* p = (int *) (a + 2);
1784     *p = s;
1785   }
1786 
1787   static void set_imm16(int* instr, int64_t s) {
1788     assert(Immediate::is_simm16(s) || Immediate::is_uimm16(s), &quot;to big&quot;);
1789     short* p = ((short *)instr) + 1;
1790     *p = s;
1791   }
1792 
1793  public:
1794 
1795   static unsigned int align(unsigned int x, unsigned int a) { return ((x + (a - 1)) &amp; ~(a - 1)); }
1796   static bool    is_aligned(unsigned int x, unsigned int a) { return (0 == x % a); }
1797 
1798   inline void emit_16(int x);
1799   inline void emit_32(int x);
1800   inline void emit_48(long x);
1801 
1802   // Compare and control flow instructions
1803   // =====================================
1804 
1805   // See also commodity routines compare64_and_branch(), compare32_and_branch().
1806 
1807   // compare instructions
1808   // compare register
1809   inline void z_cr(  Register r1, Register r2);                          // compare (r1, r2)        ; int32
1810   inline void z_cgr( Register r1, Register r2);                          // compare (r1, r2)        ; int64
1811   inline void z_cgfr(Register r1, Register r2);                          // compare (r1, r2)        ; int64 &lt;--&gt; int32
1812    // compare immediate
1813   inline void z_chi( Register r1, int64_t i2);                           // compare (r1, i2_imm16)  ; int32
1814   inline void z_cfi( Register r1, int64_t i2);                           // compare (r1, i2_imm32)  ; int32
1815   inline void z_cghi(Register r1, int64_t i2);                           // compare (r1, i2_imm16)  ; int64
1816   inline void z_cgfi(Register r1, int64_t i2);                           // compare (r1, i2_imm32)  ; int64
1817    // compare memory
1818   inline void z_ch(  Register r1, const Address &amp;a);                     // compare (r1, *(a))               ; int32 &lt;--&gt; int16
1819   inline void z_ch(  Register r1, int64_t d2, Register x2, Register b2); // compare (r1, *(d2_uimm12+x2+b2)) ; int32 &lt;--&gt; int16
1820   inline void z_c(   Register r1, const Address &amp;a);                     // compare (r1, *(a))               ; int32
1821   inline void z_c(   Register r1, int64_t d2, Register x2, Register b2); // compare (r1, *(d2_uimm12+x2+b2)) ; int32
1822   inline void z_cy(  Register r1, int64_t d2, Register x2, Register b2); // compare (r1, *(d2_uimm20+x2+b2)) ; int32
1823   inline void z_cy(  Register r1, int64_t d2, Register b2);              // compare (r1, *(d2_uimm20+x2+b2)) ; int32
1824   inline void z_cy(  Register r1, const Address&amp; a);                     // compare (r1, *(a))               ; int32
1825    //inline void z_cgf(Register r1,const Address &amp;a);                    // compare (r1, *(a))               ; int64 &lt;--&gt; int32
1826    //inline void z_cgf(Register r1,int64_t d2, Register x2, Register b2);// compare (r1, *(d2_uimm12+x2+b2)) ; int64 &lt;--&gt; int32
1827   inline void z_cg(  Register r1, const Address &amp;a);                     // compare (r1, *(a))               ; int64
1828   inline void z_cg(  Register r1, int64_t d2, Register x2, Register b2); // compare (r1, *(d2_imm20+x2+b2))  ; int64
1829 
1830    // compare logical instructions
1831    // compare register
1832   inline void z_clr(  Register r1, Register r2);                         // compare (r1, r2)                 ; uint32
1833   inline void z_clgr( Register r1, Register r2);                         // compare (r1, r2)                 ; uint64
1834    // compare immediate
1835   inline void z_clfi( Register r1, int64_t i2);                          // compare (r1, i2_uimm32)          ; uint32
1836   inline void z_clgfi(Register r1, int64_t i2);                          // compare (r1, i2_uimm32)          ; uint64
1837   inline void z_cl(   Register r1, const Address &amp;a);                    // compare (r1, *(a)                ; uint32
1838   inline void z_cl(   Register r1, int64_t d2, Register x2, Register b2);// compare (r1, *(d2_uimm12+x2+b2)  ; uint32
1839   inline void z_cly(  Register r1, int64_t d2, Register x2, Register b2);// compare (r1, *(d2_uimm20+x2+b2)) ; uint32
1840   inline void z_cly(  Register r1, int64_t d2, Register b2);             // compare (r1, *(d2_uimm20+x2+b2)) ; uint32
1841   inline void z_cly(  Register r1, const Address&amp; a);                    // compare (r1, *(a))               ; uint32
1842   inline void z_clg(  Register r1, const Address &amp;a);                    // compare (r1, *(a)                ; uint64
1843   inline void z_clg(  Register r1, int64_t d2, Register x2, Register b2);// compare (r1, *(d2_imm20+x2+b2)   ; uint64
1844 
1845   // test under mask
1846   inline void z_tmll(Register r1, int64_t i2);           // test under mask, see docu
1847   inline void z_tmlh(Register r1, int64_t i2);           // test under mask, see docu
1848   inline void z_tmhl(Register r1, int64_t i2);           // test under mask, see docu
1849   inline void z_tmhh(Register r1, int64_t i2);           // test under mask, see docu
1850 
1851   // branch instructions
1852   inline void z_bc(  branch_condition m1, int64_t d2, Register x2, Register b2);// branch  m1 ? pc = (d2_uimm12+x2+b2)
1853   inline void z_bcr( branch_condition m1, Register r2);                         // branch (m1 &amp;&amp; r2!=R0) ? pc = r2
1854   inline void z_brc( branch_condition i1, int64_t i2);                          // branch  i1 ? pc = pc + i2_imm16
1855   inline void z_brc( branch_condition i1, address a);                           // branch  i1 ? pc = a
1856   inline void z_brc( branch_condition i1, Label&amp; L);                            // branch  i1 ? pc = Label
1857   //inline void z_brcl(branch_condition i1, int64_t i2);                        // branch  i1 ? pc = pc + i2_imm32
1858   inline void z_brcl(branch_condition i1, address a);                           // branch  i1 ? pc = a
1859   inline void z_brcl(branch_condition i1, Label&amp; L);                            // branch  i1 ? pc = Label
1860   inline void z_bctgr(Register r1, Register r2);         // branch on count r1 -= 1; (r1!=0) ? pc = r2  ; r1 is int64
1861 
1862   // branch unconditional / always
1863   inline void z_br(Register r2);                         // branch to r2, nop if r2 == Z_R0
1864 
1865 
1866   // See also commodity routines compare64_and_branch(), compare32_and_branch().
1867   // signed comparison and branch
1868   inline void z_crb( Register r1, Register r2, branch_condition m3, int64_t d4, Register b4); // (r1 m3 r2) ? goto b4+d4      ; int32  -- z10
1869   inline void z_cgrb(Register r1, Register r2, branch_condition m3, int64_t d4, Register b4); // (r1 m3 r2) ? goto b4+d4      ; int64  -- z10
1870   inline void z_crj( Register r1, Register r2, branch_condition m3, Label&amp; L);                // (r1 m3 r2) ? goto L          ; int32  -- z10
1871   inline void z_crj( Register r1, Register r2, branch_condition m3, address a4);              // (r1 m3 r2) ? goto (pc+a4&lt;&lt;1) ; int32  -- z10
1872   inline void z_cgrj(Register r1, Register r2, branch_condition m3, Label&amp; L);                // (r1 m3 r2) ? goto L          ; int64  -- z10
1873   inline void z_cgrj(Register r1, Register r2, branch_condition m3, address a4);              // (r1 m3 r2) ? goto (pc+a4&lt;&lt;1) ; int64  -- z10
1874   inline void z_cib( Register r1, int64_t i2, branch_condition m3, int64_t d4, Register b4);  // (r1 m3 i2_imm8) ? goto b4+d4      ; int32  -- z10
1875   inline void z_cgib(Register r1, int64_t i2, branch_condition m3, int64_t d4, Register b4);  // (r1 m3 i2_imm8) ? goto b4+d4      ; int64  -- z10
1876   inline void z_cij( Register r1, int64_t i2, branch_condition m3, Label&amp; L);                 // (r1 m3 i2_imm8) ? goto L          ; int32  -- z10
1877   inline void z_cij( Register r1, int64_t i2, branch_condition m3, address a4);               // (r1 m3 i2_imm8) ? goto (pc+a4&lt;&lt;1) ; int32  -- z10
1878   inline void z_cgij(Register r1, int64_t i2, branch_condition m3, Label&amp; L);                 // (r1 m3 i2_imm8) ? goto L          ; int64  -- z10
1879   inline void z_cgij(Register r1, int64_t i2, branch_condition m3, address a4);               // (r1 m3 i2_imm8) ? goto (pc+a4&lt;&lt;1) ; int64  -- z10
1880   // unsigned comparison and branch
1881   inline void z_clrb( Register r1, Register r2, branch_condition m3, int64_t d4, Register b4);// (r1 m3 r2) ? goto b4+d4      ; uint32  -- z10
1882   inline void z_clgrb(Register r1, Register r2, branch_condition m3, int64_t d4, Register b4);// (r1 m3 r2) ? goto b4+d4      ; uint64  -- z10
1883   inline void z_clrj( Register r1, Register r2, branch_condition m3, Label&amp; L);               // (r1 m3 r2) ? goto L          ; uint32  -- z10
1884   inline void z_clrj( Register r1, Register r2, branch_condition m3, address a4);             // (r1 m3 r2) ? goto (pc+a4&lt;&lt;1) ; uint32  -- z10
1885   inline void z_clgrj(Register r1, Register r2, branch_condition m3, Label&amp; L);               // (r1 m3 r2) ? goto L          ; uint64  -- z10
1886   inline void z_clgrj(Register r1, Register r2, branch_condition m3, address a4);             // (r1 m3 r2) ? goto (pc+a4&lt;&lt;1) ; uint64  -- z10
1887   inline void z_clib( Register r1, int64_t i2, branch_condition m3, int64_t d4, Register b4); // (r1 m3 i2_uimm8) ? goto b4+d4      ; uint32  -- z10
1888   inline void z_clgib(Register r1, int64_t i2, branch_condition m3, int64_t d4, Register b4); // (r1 m3 i2_uimm8) ? goto b4+d4      ; uint64  -- z10
1889   inline void z_clij( Register r1, int64_t i2, branch_condition m3, Label&amp; L);                // (r1 m3 i2_uimm8) ? goto L          ; uint32  -- z10
1890   inline void z_clij( Register r1, int64_t i2, branch_condition m3, address a4);              // (r1 m3 i2_uimm8) ? goto (pc+a4&lt;&lt;1) ; uint32  -- z10
1891   inline void z_clgij(Register r1, int64_t i2, branch_condition m3, Label&amp; L);                // (r1 m3 i2_uimm8) ? goto L          ; uint64  -- z10
1892   inline void z_clgij(Register r1, int64_t i2, branch_condition m3, address a4);              // (r1 m3 i2_uimm8) ? goto (pc+a4&lt;&lt;1) ; uint64  -- z10
1893 
1894   // Compare and trap instructions.
1895   // signed comparison
1896   inline void z_crt(Register r1,  Register r2, int64_t m3);  // (r1 m3 r2)        ? trap ; int32  -- z10
1897   inline void z_cgrt(Register r1, Register r2, int64_t m3);  // (r1 m3 r2)        ? trap ; int64  -- z10
1898   inline void z_cit(Register r1,  int64_t i2, int64_t m3);   // (r1 m3 i2_imm16)  ? trap ; int32  -- z10
1899   inline void z_cgit(Register r1, int64_t i2, int64_t m3);   // (r1 m3 i2_imm16)  ? trap ; int64  -- z10
1900   // unsigned comparison
1901   inline void z_clrt(Register r1,  Register r2, int64_t m3); // (r1 m3 r2)        ? trap ; uint32 -- z10
1902   inline void z_clgrt(Register r1, Register r2, int64_t m3); // (r1 m3 r2)        ? trap ; uint64 -- z10
1903   inline void z_clfit(Register r1,  int64_t i2, int64_t m3); // (r1 m3 i2_uimm16) ? trap ; uint32 -- z10
1904   inline void z_clgit(Register r1, int64_t i2, int64_t m3);  // (r1 m3 i2_uimm16) ? trap ; uint64 -- z10
1905 
1906   inline void z_illtrap();
1907   inline void z_illtrap(int id);
1908   inline void z_illtrap_eyecatcher(unsigned short xpattern, unsigned short pattern);
1909 
1910 
1911   // load address, add for addresses
1912   // ===============================
1913 
1914   // The versions without suffix z assert that the base reg is != Z_R0.
1915   // Z_R0 is interpreted as constant &#39;0&#39;. The variants with Address operand
1916   // check this automatically, so no two versions are needed.
1917   inline void z_layz(Register r1, int64_t d2, Register x2, Register b2); // Special version. Allows Z_R0 as base reg.
1918   inline void z_lay(Register r1, const Address &amp;a);                      // r1 = a
1919   inline void z_lay(Register r1, int64_t d2, Register x2, Register b2);  // r1 = d2_imm20+x2+b2
1920   inline void z_laz(Register r1, int64_t d2, Register x2, Register b2);  // Special version. Allows Z_R0 as base reg.
1921   inline void z_la(Register r1, const Address &amp;a);                       // r1 = a                ; unsigned immediate!
1922   inline void z_la(Register r1, int64_t d2, Register x2, Register b2);   // r1 = d2_uimm12+x2+b2  ; unsigned immediate!
1923   inline void z_larl(Register r1, int64_t i2);                           // r1 = pc + i2_imm32&lt;&lt;1;
1924   inline void z_larl(Register r1, address a2);                           // r1 = pc + i2_imm32&lt;&lt;1;
1925 
1926   // Load instructions for integers
1927   // ==============================
1928 
1929   // Address as base + index + offset
1930   inline void z_lb( Register r1, const Address &amp;a);                     // load r1 = *(a)              ; int32 &lt;- int8
1931   inline void z_lb( Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm20+x2+b2) ; int32 &lt;- int8
1932   inline void z_lh( Register r1, const Address &amp;a);                     // load r1 = *(a)              ; int32 &lt;- int16
1933   inline void z_lh( Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_uimm12+x2+b2); int32 &lt;- int16
1934   inline void z_lhy(Register r1, const Address &amp;a);                     // load r1 = *(a)              ; int32 &lt;- int16
1935   inline void z_lhy(Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm20+x2+b2) ; int32 &lt;- int16
1936   inline void z_l(  Register r1, const Address&amp; a);                     // load r1 = *(a)              ; int32
1937   inline void z_l(  Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_uimm12+x2+b2); int32
1938   inline void z_ly( Register r1, const Address&amp; a);                     // load r1 = *(a)              ; int32
1939   inline void z_ly( Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm20+x2+b2) ; int32
1940 
1941   inline void z_lgb(Register r1, const Address &amp;a);                     // load r1 = *(a)              ; int64 &lt;- int8
1942   inline void z_lgb(Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm20+x2+b2) ; int64 &lt;- int8
1943   inline void z_lgh(Register r1, const Address &amp;a);                     // load r1 = *(a)              ; int64 &lt;- int16
1944   inline void z_lgh(Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm12+x2+b2) ; int64 &lt;- int16
1945   inline void z_lgf(Register r1, const Address &amp;a);                     // load r1 = *(a)              ; int64 &lt;- int32
1946   inline void z_lgf(Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm20+x2+b2) ; int64 &lt;- int32
1947   inline void z_lg( Register r1, const Address&amp; a);                     // load r1 = *(a)              ; int64 &lt;- int64
1948   inline void z_lg( Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm20+x2+b2) ; int64 &lt;- int64
1949 
1950   // load and test
1951   inline void z_lt(  Register r1, const Address &amp;a);                    // load and test r1 = *(a)              ; int32
1952   inline void z_lt(  Register r1, int64_t d2, Register x2, Register b2);// load and test r1 = *(d2_imm20+x2+b2) ; int32
1953   inline void z_ltg( Register r1, const Address &amp;a);                    // load and test r1 = *(a)              ; int64
1954   inline void z_ltg( Register r1, int64_t d2, Register x2, Register b2);// load and test r1 = *(d2_imm20+x2+b2) ; int64
1955   inline void z_ltgf(Register r1, const Address &amp;a);                    // load and test r1 = *(a)              ; int64 &lt;- int32
1956   inline void z_ltgf(Register r1, int64_t d2, Register x2, Register b2);// load and test r1 = *(d2_imm20+x2+b2) ; int64 &lt;- int32
1957 
1958   // load unsigned integer - zero extended
1959   inline void z_llc( Register r1, const Address&amp; a);                    // load r1 = *(a)              ; uint32 &lt;- uint8
1960   inline void z_llc( Register r1, int64_t d2, Register x2, Register b2);// load r1 = *(d2_imm20+x2+b2) ; uint32 &lt;- uint8
1961   inline void z_llh( Register r1, const Address&amp; a);                    // load r1 = *(a)              ; uint32 &lt;- uint16
1962   inline void z_llh( Register r1, int64_t d2, Register x2, Register b2);// load r1 = *(d2_imm20+x2+b2) ; uint32 &lt;- uint16
1963   inline void z_llgc(Register r1, const Address&amp; a);                    // load r1 = *(a)              ; uint64 &lt;- uint8
1964   inline void z_llgc(Register r1, int64_t d2, Register x2, Register b2);// load r1 = *(d2_imm20+x2+b2) ; uint64 &lt;- uint8
1965   inline void z_llgc( Register r1, int64_t d2, Register b2);            // load r1 = *(d2_imm20+b2)    ; uint64 &lt;- uint8
1966   inline void z_llgh(Register r1, const Address&amp; a);                    // load r1 = *(a)              ; uint64 &lt;- uint16
1967   inline void z_llgh(Register r1, int64_t d2, Register x2, Register b2);// load r1 = *(d2_imm20+x2+b2) ; uint64 &lt;- uint16
1968   inline void z_llgf(Register r1, const Address&amp; a);                    // load r1 = *(a)              ; uint64 &lt;- uint32
1969   inline void z_llgf(Register r1, int64_t d2, Register x2, Register b2);// load r1 = *(d2_imm20+x2+b2) ; uint64 &lt;- uint32
1970 
1971   // pc relative addressing
1972   inline void z_lhrl( Register r1, int64_t i2);   // load r1 = *(pc + i2_imm32&lt;&lt;1) ; int32 &lt;- int16    -- z10
1973   inline void z_lrl(  Register r1, int64_t i2);   // load r1 = *(pc + i2_imm32&lt;&lt;1) ; int32             -- z10
1974   inline void z_lghrl(Register r1, int64_t i2);   // load r1 = *(pc + i2_imm32&lt;&lt;1) ; int64 &lt;- int16    -- z10
1975   inline void z_lgfrl(Register r1, int64_t i2);   // load r1 = *(pc + i2_imm32&lt;&lt;1) ; int64 &lt;- int32    -- z10
1976   inline void z_lgrl( Register r1, int64_t i2);   // load r1 = *(pc + i2_imm32&lt;&lt;1) ; int64             -- z10
1977 
1978   inline void z_llhrl( Register r1, int64_t i2);  // load r1 = *(pc + i2_imm32&lt;&lt;1) ; uint32 &lt;- uint16  -- z10
1979   inline void z_llghrl(Register r1, int64_t i2);  // load r1 = *(pc + i2_imm32&lt;&lt;1) ; uint64 &lt;- uint16  -- z10
1980   inline void z_llgfrl(Register r1, int64_t i2);  // load r1 = *(pc + i2_imm32&lt;&lt;1) ; uint64 &lt;- uint32  -- z10
1981 
1982   // Store instructions for integers
1983   // ===============================
1984 
1985   // Address as base + index + offset
1986   inline void z_stc( Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int8
1987   inline void z_stc( Register r1, int64_t d2, Register x2, Register b2); // store *(d2_uimm12+x2+b2) = r1  ; int8
1988   inline void z_stcy(Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int8
1989   inline void z_stcy(Register r1, int64_t d2, Register x2, Register b2); // store *(d2_imm20+x2+b2)  = r1  ; int8
1990   inline void z_sth( Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int16
1991   inline void z_sth( Register r1, int64_t d2, Register x2, Register b2); // store *(d2_uimm12+x2+b2) = r1  ; int16
1992   inline void z_sthy(Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int16
1993   inline void z_sthy(Register r1, int64_t d2, Register x2, Register b2); // store *(d2_imm20+x2+b2)  = r1  ; int16
1994   inline void z_st(  Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int32
1995   inline void z_st(  Register r1, int64_t d2, Register x2, Register b2); // store *(d2_uimm12+x2+b2) = r1  ; int32
1996   inline void z_sty( Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int32
1997   inline void z_sty( Register r1, int64_t d2, Register x2, Register b2); // store *(d2_imm20+x2+b2)  = r1  ; int32
1998   inline void z_stg( Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int64
1999   inline void z_stg( Register r1, int64_t d2, Register x2, Register b2); // store *(d2_uimm12+x2+b2) = r1  ; int64
2000 
2001   inline void z_stcm( Register r1, int64_t m3, int64_t d2, Register b2); // store character under mask
2002   inline void z_stcmy(Register r1, int64_t m3, int64_t d2, Register b2); // store character under mask
2003   inline void z_stcmh(Register r1, int64_t m3, int64_t d2, Register b2); // store character under mask
2004 
2005   // pc relative addressing
2006   inline void z_sthrl(Register r1, int64_t i2);   // store *(pc + i2_imm32&lt;&lt;1) = r1 ; int16  -- z10
2007   inline void z_strl( Register r1, int64_t i2);   // store *(pc + i2_imm32&lt;&lt;1) = r1 ; int32  -- z10
2008   inline void z_stgrl(Register r1, int64_t i2);   // store *(pc + i2_imm32&lt;&lt;1) = r1 ; int64  -- z10
2009 
2010 
2011   // Load and store immediates
2012   // =========================
2013 
2014   // load immediate
2015   inline void z_lhi( Register r1, int64_t i2);                  // r1 = i2_imm16    ; int32 &lt;- int16
2016   inline void z_lghi(Register r1, int64_t i2);                  // r1 = i2_imm16    ; int64 &lt;- int16
2017   inline void z_lgfi(Register r1, int64_t i2);                  // r1 = i2_imm32    ; int64 &lt;- int32
2018 
2019   inline void z_llihf(Register r1, int64_t i2);                 // r1 = i2_imm32    ; uint64 &lt;- (uint32&lt;&lt;32)
2020   inline void z_llilf(Register r1, int64_t i2);                 // r1 = i2_imm32    ; uint64 &lt;- uint32
2021   inline void z_llihh(Register r1, int64_t i2);                 // r1 = i2_imm16    ; uint64 &lt;- (uint16&lt;&lt;48)
2022   inline void z_llihl(Register r1, int64_t i2);                 // r1 = i2_imm16    ; uint64 &lt;- (uint16&lt;&lt;32)
2023   inline void z_llilh(Register r1, int64_t i2);                 // r1 = i2_imm16    ; uint64 &lt;- (uint16&lt;&lt;16)
2024   inline void z_llill(Register r1, int64_t i2);                 // r1 = i2_imm16    ; uint64 &lt;- uint16
2025 
2026   // insert immediate
2027   inline void z_ic(  Register r1, int64_t d2, Register x2, Register b2); // insert character
2028   inline void z_icy( Register r1, int64_t d2, Register x2, Register b2); // insert character
2029   inline void z_icm( Register r1, int64_t m3, int64_t d2, Register b2);  // insert character under mask
2030   inline void z_icmy(Register r1, int64_t m3, int64_t d2, Register b2);  // insert character under mask
2031   inline void z_icmh(Register r1, int64_t m3, int64_t d2, Register b2);  // insert character under mask
2032 
2033   inline void z_iihh(Register r1, int64_t i2);                  // insert immediate  r1[ 0-15] = i2_imm16
2034   inline void z_iihl(Register r1, int64_t i2);                  // insert immediate  r1[16-31] = i2_imm16
2035   inline void z_iilh(Register r1, int64_t i2);                  // insert immediate  r1[32-47] = i2_imm16
2036   inline void z_iill(Register r1, int64_t i2);                  // insert immediate  r1[48-63] = i2_imm16
2037   inline void z_iihf(Register r1, int64_t i2);                  // insert immediate  r1[32-63] = i2_imm32
2038   inline void z_iilf(Register r1, int64_t i2);                  // insert immediate  r1[ 0-31] = i2_imm32
2039 
2040   // store immediate
2041   inline void z_mvhhi(const Address &amp;d, int64_t i2);            // store *(d)           = i2_imm16 ; int16
2042   inline void z_mvhhi(int64_t d1, Register b1, int64_t i2);     // store *(d1_imm12+b1) = i2_imm16 ; int16
2043   inline void z_mvhi( const Address &amp;d, int64_t i2);            // store *(d)           = i2_imm16 ; int32
2044   inline void z_mvhi( int64_t d1, Register b1, int64_t i2);     // store *(d1_imm12+b1) = i2_imm16 ; int32
2045   inline void z_mvghi(const Address &amp;d, int64_t i2);            // store *(d)           = i2_imm16 ; int64
2046   inline void z_mvghi(int64_t d1, Register b1, int64_t i2);     // store *(d1_imm12+b1) = i2_imm16 ; int64
2047 
2048   // Move and Convert instructions
2049   // =============================
2050 
2051   // move, sign extend
2052   inline void z_lbr(Register r1, Register r2);             // move r1 = r2 ; int32  &lt;- int8
2053   inline void z_lhr( Register r1, Register r2);            // move r1 = r2 ; int32  &lt;- int16
2054   inline void z_lr(Register r1, Register r2);              // move r1 = r2 ; int32, no sign extension
2055   inline void z_lgbr(Register r1, Register r2);            // move r1 = r2 ; int64  &lt;- int8
2056   inline void z_lghr(Register r1, Register r2);            // move r1 = r2 ; int64  &lt;- int16
2057   inline void z_lgfr(Register r1, Register r2);            // move r1 = r2 ; int64  &lt;- int32
2058   inline void z_lgr(Register r1, Register r2);             // move r1 = r2 ; int64
2059   // move, zero extend
2060   inline void z_llhr( Register r1, Register r2);           // move r1 = r2 ; uint32 &lt;- uint16
2061   inline void z_llgcr(Register r1, Register r2);           // move r1 = r2 ; uint64 &lt;- uint8
2062   inline void z_llghr(Register r1, Register r2);           // move r1 = r2 ; uint64 &lt;- uint16
2063   inline void z_llgfr(Register r1, Register r2);           // move r1 = r2 ; uint64 &lt;- uint32
2064 
2065   // move and test register
2066   inline void z_ltr(Register r1, Register r2);             // load/move and test r1 = r2; int32
2067   inline void z_ltgr(Register r1, Register r2);            // load/move and test r1 = r2; int64
2068   inline void z_ltgfr(Register r1, Register r2);           // load/move and test r1 = r2; int64 &lt;-- int32
2069 
2070   // move and byte-reverse
2071   inline void z_lrvr( Register r1, Register r2);           // move and reverse byte order r1 = r2; int32
2072   inline void z_lrvgr(Register r1, Register r2);           // move and reverse byte order r1 = r2; int64
2073 
2074 
2075   // Arithmetic instructions (Integer only)
2076   // ======================================
2077   // For float arithmetic instructions scroll further down
2078   // Add logical differs in the condition codes set!
2079 
2080   // add registers
2081   inline void z_ar(   Register r1, Register r2);                      // add         r1 = r1 + r2  ; int32
2082   inline void z_agr(  Register r1, Register r2);                      // add         r1 = r1 + r2  ; int64
2083   inline void z_agfr( Register r1, Register r2);                      // add         r1 = r1 + r2  ; int64 &lt;- int32
2084   inline void z_ark(  Register r1, Register r2, Register r3);         // add         r1 = r2 + r3  ; int32
2085   inline void z_agrk( Register r1, Register r2, Register r3);         // add         r1 = r2 + r3  ; int64
2086 
2087   inline void z_alr(  Register r1, Register r2);                      // add logical r1 = r1 + r2  ; int32
2088   inline void z_algr( Register r1, Register r2);                      // add logical r1 = r1 + r2  ; int64
2089   inline void z_algfr(Register r1, Register r2);                      // add logical r1 = r1 + r2  ; int64 &lt;- int32
2090   inline void z_alrk( Register r1, Register r2, Register r3);         // add logical r1 = r2 + r3  ; int32
2091   inline void z_algrk(Register r1, Register r2, Register r3);         // add logical r1 = r2 + r3  ; int64
2092   inline void z_alcgr(Register r1, Register r2);                      // add logical with carry r1 = r1 + r2 + c  ; int64
2093 
2094   // add immediate
2095   inline void z_ahi(  Register r1, int64_t i2);                       // add         r1 = r1 + i2_imm16 ; int32
2096   inline void z_afi(  Register r1, int64_t i2);                       // add         r1 = r1 + i2_imm32 ; int32
2097   inline void z_alfi( Register r1, int64_t i2);                       // add         r1 = r1 + i2_imm32 ; int32
2098   inline void z_aghi( Register r1, int64_t i2);                       // add logical r1 = r1 + i2_imm16 ; int64
2099   inline void z_agfi( Register r1, int64_t i2);                       // add         r1 = r1 + i2_imm32 ; int64
2100   inline void z_algfi(Register r1, int64_t i2);                       // add logical r1 = r1 + i2_imm32 ; int64
2101   inline void z_ahik( Register r1, Register r3, int64_t i2);          // add         r1 = r3 + i2_imm16 ; int32
2102   inline void z_aghik(Register r1, Register r3, int64_t i2);          // add         r1 = r3 + i2_imm16 ; int64
2103   inline void z_aih(  Register r1, int64_t i2);                       // add         r1 = r1 + i2_imm32 ; int32 (HiWord)
2104 
2105   // add memory
2106   inline void z_a( Register r1, int64_t d2, Register x2, Register b2);  // add r1 = r1 + *(d2_uimm12+s2+b2) ; int32
2107   inline void z_ay(  Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_imm20+s2+b2)  ; int32
2108   inline void z_ag(  Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_imm20+s2+b2)  ; int64
2109   inline void z_agf( Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_imm20+x2+b2)  ; int64 &lt;- int32
2110   inline void z_al(  Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_uimm12+x2+b2) ; int32
2111   inline void z_aly( Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_imm20+x2+b2)  ; int32
2112   inline void z_alg( Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_imm20+x2+b2)  ; int64
2113   inline void z_algf(Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_imm20+x2+b2)  ; int64 &lt;- int32
2114   inline void z_a(   Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int32
2115   inline void z_ay(  Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int32
2116   inline void z_al(  Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int32
2117   inline void z_aly( Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int32
2118   inline void z_ag(  Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int64
2119   inline void z_agf( Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int64 &lt;- int32
2120   inline void z_alg( Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int64
2121   inline void z_algf(Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int64 &lt;- int32
2122 
2123 
2124   inline void z_alhsik( Register r1, Register r3, int64_t i2);    // add logical r1 = r3 + i2_imm16   ; int32
2125   inline void z_alghsik(Register r1, Register r3, int64_t i2);    // add logical r1 = r3 + i2_imm16   ; int64
2126 
2127   inline void z_asi(  int64_t d1, Register b1, int64_t i2);       // add           *(d1_imm20+b1) += i2_imm8 ; int32   -- z10
2128   inline void z_agsi( int64_t d1, Register b1, int64_t i2);       // add           *(d1_imm20+b1) += i2_imm8 ; int64   -- z10
2129   inline void z_alsi( int64_t d1, Register b1, int64_t i2);       // add logical   *(d1_imm20+b1) += i2_imm8 ; uint32  -- z10
2130   inline void z_algsi(int64_t d1, Register b1, int64_t i2);       // add logical   *(d1_imm20+b1) += i2_imm8 ; uint64  -- z10
2131   inline void z_asi(  const Address&amp; d, int64_t i2);              // add           *(d) += i2_imm8           ; int32   -- z10
2132   inline void z_agsi( const Address&amp; d, int64_t i2);              // add           *(d) += i2_imm8           ; int64   -- z10
2133   inline void z_alsi( const Address&amp; d, int64_t i2);              // add logical   *(d) += i2_imm8           ; uint32  -- z10
2134   inline void z_algsi(const Address&amp; d, int64_t i2);              // add logical   *(d) += i2_imm8           ; uint64  -- z10
2135 
2136   // sign adjustment
2137   inline void z_lcr(  Register r1, Register r2 = noreg);              // neg r1 = -r2   ; int32
2138   inline void z_lcgr( Register r1, Register r2 = noreg);              // neg r1 = -r2   ; int64
2139   inline void z_lcgfr(Register r1, Register r2);                      // neg r1 = -r2   ; int64 &lt;- int32
2140   inline void z_lnr(  Register r1, Register r2 = noreg);              // neg r1 = -|r2| ; int32
2141   inline void z_lngr( Register r1, Register r2 = noreg);              // neg r1 = -|r2| ; int64
2142   inline void z_lngfr(Register r1, Register r2);                      // neg r1 = -|r2| ; int64 &lt;- int32
2143   inline void z_lpr(  Register r1, Register r2 = noreg);              //     r1 =  |r2| ; int32
2144   inline void z_lpgr( Register r1, Register r2 = noreg);              //     r1 =  |r2| ; int64
2145   inline void z_lpgfr(Register r1, Register r2);                      //     r1 =  |r2| ; int64 &lt;- int32
2146 
2147   // subtract intstructions
2148   // sub registers
2149   inline void z_sr(   Register r1, Register r2);                      // sub         r1 = r1 - r2                ; int32
2150   inline void z_sgr(  Register r1, Register r2);                      // sub         r1 = r1 - r2                ; int64
2151   inline void z_sgfr( Register r1, Register r2);                      // sub         r1 = r1 - r2                ; int64 &lt;- int32
2152   inline void z_srk(  Register r1, Register r2, Register r3);         // sub         r1 = r2 - r3                ; int32
2153   inline void z_sgrk( Register r1, Register r2, Register r3);         // sub         r1 = r2 - r3                ; int64
2154 
2155   inline void z_slr(  Register r1, Register r2);                      // sub logical r1 = r1 - r2                ; int32
2156   inline void z_slgr( Register r1, Register r2);                      // sub logical r1 = r1 - r2                ; int64
2157   inline void z_slgfr(Register r1, Register r2);                      // sub logical r1 = r1 - r2                ; int64 &lt;- int32
2158   inline void z_slrk( Register r1, Register r2, Register r3);         // sub logical r1 = r2 - r3                ; int32
2159   inline void z_slgrk(Register r1, Register r2, Register r3);         // sub logical r1 = r2 - r3                ; int64
2160   inline void z_slfi( Register r1, int64_t i2);                       // sub logical r1 = r1 - i2_uimm32         ; int32
2161   inline void z_slgfi(Register r1, int64_t i2);                       // add logical r1 = r1 - i2_uimm32         ; int64
2162 
2163   // sub memory
2164   inline void z_s(   Register r1, int64_t d2, Register x2, Register b2);  // sub         r1 = r1 - *(d2_imm12+x2+b2) ; int32
2165   inline void z_sy(  Register r1, int64_t d2, Register x2, Register b2);  // sub         r1 = r1 + *(d2_imm20+s2+b2) ; int32
2166   inline void z_sg(  Register r1, int64_t d2, Register x2, Register b2);  // sub         r1 = r1 - *(d2_imm12+x2+b2) ; int64
2167   inline void z_sgf( Register r1, int64_t d2, Register x2, Register b2);  // sub         r1 = r1 - *(d2_imm12+x2+b2) ; int64 - int32
2168   inline void z_slg( Register r1, int64_t d2, Register x2, Register b2);  // sub logical r1 = r1 - *(d2_imm20+x2+b2) ; uint64
2169   inline void z_slgf(Register r1, int64_t d2, Register x2, Register b2);  // sub logical r1 = r1 - *(d2_imm20+x2+b2) ; uint64 - uint32
2170   inline void z_s(   Register r1, const Address&amp; a);                      // sub         r1 = r1 - *(a)              ; int32
2171   inline void z_sy(  Register r1, const Address&amp; a);                      // sub         r1 = r1 - *(a)              ; int32
2172   inline void z_sg(  Register r1, const Address&amp; a);                      // sub         r1 = r1 - *(a)              ; int64
2173   inline void z_sgf( Register r1, const Address&amp; a);                      // sub         r1 = r1 - *(a)              ; int64 - int32
2174   inline void z_slg( Register r1, const Address&amp; a);                      // sub         r1 = r1 - *(a)              ; uint64
2175   inline void z_slgf(Register r1, const Address&amp; a);                      // sub         r1 = r1 - *(a)              ; uint64 - uint32
2176 
2177   inline void z_sh(  Register r1, int64_t d2, Register x2, Register b2);  // sub         r1 = r1 - *(d2_imm12+x2+b2) ; int32 - int16
2178   inline void z_shy( Register r1, int64_t d2, Register x2, Register b2);  // sub         r1 = r1 - *(d2_imm20+x2+b2) ; int32 - int16
2179   inline void z_sh(  Register r1, const Address &amp;a);                      // sub         r1 = r1 - *(d2_imm12+x2+b2) ; int32 - int16
2180   inline void z_shy( Register r1, const Address &amp;a);                      // sub         r1 = r1 - *(d2_imm20+x2+b2) ; int32 - int16
2181 
2182   // Multiplication instructions
2183   // mul registers
2184   inline void z_msr(  Register r1, Register r2);                          // mul r1 = r1 * r2          ; int32
2185   inline void z_msgr( Register r1, Register r2);                          // mul r1 = r1 * r2          ; int64
2186   inline void z_msgfr(Register r1, Register r2);                          // mul r1 = r1 * r2          ; int64 &lt;- int32
2187   inline void z_mlr(  Register r1, Register r2);                          // mul r1 = r1 * r2          ; int32 unsigned
2188   inline void z_mlgr( Register r1, Register r2);                          // mul r1 = r1 * r2          ; int64 unsigned
2189   // mul register - memory
2190   inline void z_mhy( Register r1, int64_t d2, Register x2, Register b2);  // mul r1 = r1 * *(d2+x2+b2)
2191   inline void z_msy( Register r1, int64_t d2, Register x2, Register b2);  // mul r1 = r1 * *(d2+x2+b2)
2192   inline void z_msg( Register r1, int64_t d2, Register x2, Register b2);  // mul r1 = r1 * *(d2+x2+b2)
2193   inline void z_msgf(Register r1, int64_t d2, Register x2, Register b2);  // mul r1 = r1 * *(d2+x2+b2)
2194   inline void z_ml(  Register r1, int64_t d2, Register x2, Register b2);  // mul r1 = r1 * *(d2+x2+b2)
2195   inline void z_mlg( Register r1, int64_t d2, Register x2, Register b2);  // mul r1 = r1 * *(d2+x2+b2)
2196   inline void z_mhy( Register r1, const Address&amp; a);                      // mul r1 = r1 * *(a)
2197   inline void z_msy( Register r1, const Address&amp; a);                      // mul r1 = r1 * *(a)
2198   inline void z_msg( Register r1, const Address&amp; a);                      // mul r1 = r1 * *(a)
2199   inline void z_msgf(Register r1, const Address&amp; a);                      // mul r1 = r1 * *(a)
2200   inline void z_ml(  Register r1, const Address&amp; a);                      // mul r1 = r1 * *(a)
2201   inline void z_mlg( Register r1, const Address&amp; a);                      // mul r1 = r1 * *(a)
2202 
2203   inline void z_msfi( Register r1, int64_t i2);   // mult r1 = r1 * i2_imm32;   int32  -- z10
2204   inline void z_msgfi(Register r1, int64_t i2);   // mult r1 = r1 * i2_imm32;   int64  -- z10
2205   inline void z_mhi(  Register r1, int64_t i2);   // mult r1 = r1 * i2_imm16;   int32
2206   inline void z_mghi( Register r1, int64_t i2);   // mult r1 = r1 * i2_imm16;   int64
2207 
2208   // Division instructions
2209   inline void z_dsgr( Register r1, Register r2);      // div  r1 = r1 / r2               ; int64/int32 needs reg pair!
2210   inline void z_dsgfr(Register r1, Register r2);      // div  r1 = r1 / r2               ; int64/int32 needs reg pair!
2211 
2212 
2213   // Logic instructions
2214   // ===================
2215 
2216   // and
2217   inline void z_n(   Register r1, int64_t d2, Register x2, Register b2);
2218   inline void z_ny(  Register r1, int64_t d2, Register x2, Register b2);
2219   inline void z_ng(  Register r1, int64_t d2, Register x2, Register b2);
2220   inline void z_n(   Register r1, const Address&amp; a);
2221   inline void z_ny(  Register r1, const Address&amp; a);
2222   inline void z_ng(  Register r1, const Address&amp; a);
2223 
2224   inline void z_nr(  Register r1, Register r2);               // and r1 = r1 &amp; r2         ; int32
2225   inline void z_ngr( Register r1, Register r2);               // and r1 = r1 &amp; r2         ; int64
2226   inline void z_nrk( Register r1, Register r2, Register r3);  // and r1 = r2 &amp; r3         ; int32
2227   inline void z_ngrk(Register r1, Register r2, Register r3);  // and r1 = r2 &amp; r3         ; int64
2228 
2229   inline void z_nihh(Register r1, int64_t i2);                // and r1 = r1 &amp; i2_imm16   ; and only for bits  0-15
2230   inline void z_nihl(Register r1, int64_t i2);                // and r1 = r1 &amp; i2_imm16   ; and only for bits 16-31
2231   inline void z_nilh(Register r1, int64_t i2);                // and r1 = r1 &amp; i2_imm16   ; and only for bits 32-47
2232   inline void z_nill(Register r1, int64_t i2);                // and r1 = r1 &amp; i2_imm16   ; and only for bits 48-63
2233   inline void z_nihf(Register r1, int64_t i2);                // and r1 = r1 &amp; i2_imm32   ; and only for bits  0-31
2234   inline void z_nilf(Register r1, int64_t i2);                // and r1 = r1 &amp; i2_imm32   ; and only for bits 32-63  see also MacroAssembler::nilf.
2235 
2236   // or
2237   inline void z_o(   Register r1, int64_t d2, Register x2, Register b2);
2238   inline void z_oy(  Register r1, int64_t d2, Register x2, Register b2);
2239   inline void z_og(  Register r1, int64_t d2, Register x2, Register b2);
2240   inline void z_o(   Register r1, const Address&amp; a);
2241   inline void z_oy(  Register r1, const Address&amp; a);
2242   inline void z_og(  Register r1, const Address&amp; a);
2243 
2244   inline void z_or(  Register r1, Register r2);               // or r1 = r1 | r2; int32
2245   inline void z_ogr( Register r1, Register r2);               // or r1 = r1 | r2; int64
2246   inline void z_ork( Register r1, Register r2, Register r3);  // or r1 = r2 | r3         ; int32
2247   inline void z_ogrk(Register r1, Register r2, Register r3);  // or r1 = r2 | r3         ; int64
2248 
2249   inline void z_oihh(Register r1, int64_t i2);                // or r1 = r1 | i2_imm16   ; or only for bits  0-15
2250   inline void z_oihl(Register r1, int64_t i2);                // or r1 = r1 | i2_imm16   ; or only for bits 16-31
2251   inline void z_oilh(Register r1, int64_t i2);                // or r1 = r1 | i2_imm16   ; or only for bits 32-47
2252   inline void z_oill(Register r1, int64_t i2);                // or r1 = r1 | i2_imm16   ; or only for bits 48-63
2253   inline void z_oihf(Register r1, int64_t i2);                // or r1 = r1 | i2_imm32   ; or only for bits  0-31
2254   inline void z_oilf(Register r1, int64_t i2);                // or r1 = r1 | i2_imm32   ; or only for bits 32-63
2255 
2256   // xor
2257   inline void z_x(   Register r1, int64_t d2, Register x2, Register b2);
2258   inline void z_xy(  Register r1, int64_t d2, Register x2, Register b2);
2259   inline void z_xg(  Register r1, int64_t d2, Register x2, Register b2);
2260   inline void z_x(   Register r1, const Address&amp; a);
2261   inline void z_xy(  Register r1, const Address&amp; a);
2262   inline void z_xg(  Register r1, const Address&amp; a);
2263 
2264   inline void z_xr(  Register r1, Register r2);               // xor r1 = r1 ^ r2         ; int32
2265   inline void z_xgr( Register r1, Register r2);               // xor r1 = r1 ^ r2         ; int64
2266   inline void z_xrk( Register r1, Register r2, Register r3);  // xor r1 = r2 ^ r3         ; int32
2267   inline void z_xgrk(Register r1, Register r2, Register r3);  // xor r1 = r2 ^ r3         ; int64
2268 
2269   inline void z_xihf(Register r1, int64_t i2);                // xor r1 = r1 ^ i2_imm32   ; or only for bits  0-31
2270   inline void z_xilf(Register r1, int64_t i2);                // xor r1 = r1 ^ i2_imm32   ; or only for bits 32-63
2271 
2272   // shift
2273   inline void z_sla( Register r1,              int64_t d2, Register b2=Z_R0); // shift left  r1 = r1 &lt;&lt; ((d2+b2)&amp;0x3f) ; int32, only 31 bits shifted, sign preserved!
2274   inline void z_slak(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift left  r1 = r3 &lt;&lt; ((d2+b2)&amp;0x3f) ; int32, only 31 bits shifted, sign preserved!
2275   inline void z_slag(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift left  r1 = r3 &lt;&lt; ((d2+b2)&amp;0x3f) ; int64, only 63 bits shifted, sign preserved!
2276   inline void z_sra( Register r1,              int64_t d2, Register b2=Z_R0); // shift right r1 = r1 &gt;&gt; ((d2+b2)&amp;0x3f) ; int32, sign extended
2277   inline void z_srak(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift right r1 = r3 &gt;&gt; ((d2+b2)&amp;0x3f) ; int32, sign extended
2278   inline void z_srag(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift right r1 = r3 &gt;&gt; ((d2+b2)&amp;0x3f) ; int64, sign extended
2279   inline void z_sll( Register r1,              int64_t d2, Register b2=Z_R0); // shift left  r1 = r1 &lt;&lt; ((d2+b2)&amp;0x3f) ; int32, zeros added
2280   inline void z_sllk(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift left  r1 = r3 &lt;&lt; ((d2+b2)&amp;0x3f) ; int32, zeros added
2281   inline void z_sllg(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift left  r1 = r3 &lt;&lt; ((d2+b2)&amp;0x3f) ; int64, zeros added
2282   inline void z_srl( Register r1,              int64_t d2, Register b2=Z_R0); // shift right r1 = r1 &gt;&gt; ((d2+b2)&amp;0x3f) ; int32, zero extended
2283   inline void z_srlk(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift right r1 = r3 &gt;&gt; ((d2+b2)&amp;0x3f) ; int32, zero extended
2284   inline void z_srlg(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift right r1 = r3 &gt;&gt; ((d2+b2)&amp;0x3f) ; int64, zero extended
2285 
2286   // rotate
2287   inline void z_rll( Register r1, Register r3, int64_t d2, Register b2=Z_R0); // rot r1 = r3 &lt;&lt; (d2+b2 &amp; 0x3f) ; int32  -- z10
2288   inline void z_rllg(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // rot r1 = r3 &lt;&lt; (d2+b2 &amp; 0x3f) ; int64  -- z10
2289 
2290   // rotate the AND/XOR/OR/insert
2291   inline void z_rnsbg( Register r1, Register r2, int64_t spos3, int64_t epos4, int64_t nrot5, bool test_only = false); // rotate then AND selected bits  -- z196
2292   inline void z_rxsbg( Register r1, Register r2, int64_t spos3, int64_t epos4, int64_t nrot5, bool test_only = false); // rotate then XOR selected bits  -- z196
2293   inline void z_rosbg( Register r1, Register r2, int64_t spos3, int64_t epos4, int64_t nrot5, bool test_only = false); // rotate then OR  selected bits  -- z196
2294   inline void z_risbg( Register r1, Register r2, int64_t spos3, int64_t epos4, int64_t nrot5, bool zero_rest = false); // rotate then INS selected bits  -- z196
2295 
2296 
2297   // memory-immediate instructions (8-bit immediate)
2298   // ===============================================
2299 
2300   inline void z_cli( int64_t d1, Register b1, int64_t i2); // compare *(d1_imm12+b1) ^= i2_imm8           ; int8
2301   inline void z_mvi( int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1)  = i2_imm8           ; int8
2302   inline void z_tm(  int64_t d1, Register b1, int64_t i2); // test    *(d1_imm12+b1) against mask i2_imm8 ; int8
2303   inline void z_ni(  int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1) &amp;= i2_imm8           ; int8
2304   inline void z_oi(  int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1) |= i2_imm8           ; int8
2305   inline void z_xi(  int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1) ^= i2_imm8           ; int8
2306   inline void z_cliy(int64_t d1, Register b1, int64_t i2); // compare *(d1_imm12+b1) ^= i2_imm8           ; int8
2307   inline void z_mviy(int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1)  = i2_imm8           ; int8
2308   inline void z_tmy( int64_t d1, Register b1, int64_t i2); // test    *(d1_imm12+b1) against mask i2_imm8 ; int8
2309   inline void z_niy( int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1) &amp;= i2_imm8           ; int8
2310   inline void z_oiy( int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1) |= i2_imm8           ; int8
2311   inline void z_xiy( int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1) ^= i2_imm8           ; int8
2312   inline void z_cli( const Address&amp; a, int64_t imm8);      // compare *(a)           ^= imm8              ; int8
2313   inline void z_mvi( const Address&amp; a, int64_t imm8);      // store   *(a)            = imm8              ; int8
2314   inline void z_tm(  const Address&amp; a, int64_t imm8);      // test    *(a)           against mask imm8    ; int8
2315   inline void z_ni(  const Address&amp; a, int64_t imm8);      // store   *(a)           &amp;= imm8              ; int8
2316   inline void z_oi(  const Address&amp; a, int64_t imm8);      // store   *(a)           |= imm8              ; int8
2317   inline void z_xi(  const Address&amp; a, int64_t imm8);      // store   *(a)           ^= imm8              ; int8
2318   inline void z_cliy(const Address&amp; a, int64_t imm8);      // compare *(a)           ^= imm8              ; int8
2319   inline void z_mviy(const Address&amp; a, int64_t imm8);      // store   *(a)            = imm8              ; int8
2320   inline void z_tmy( const Address&amp; a, int64_t imm8);      // test    *(a)           against mask imm8    ; int8
2321   inline void z_niy( const Address&amp; a, int64_t imm8);      // store   *(a)           &amp;= imm8              ; int8
2322   inline void z_oiy( const Address&amp; a, int64_t imm8);      // store   *(a)           |= imm8              ; int8
2323   inline void z_xiy( const Address&amp; a, int64_t imm8);      // store   *(a)           ^= imm8              ; int8
2324 
2325 
2326   //------------------------------
2327   // Interlocked-Update
2328   //------------------------------
2329   inline void z_laa(  Register r1, Register r3, int64_t d2, Register b2);   // load and add    int32, signed   -- z196
2330   inline void z_laag( Register r1, Register r3, int64_t d2, Register b2);   // load and add    int64, signed   -- z196
2331   inline void z_laal( Register r1, Register r3, int64_t d2, Register b2);   // load and add    int32, unsigned -- z196
2332   inline void z_laalg(Register r1, Register r3, int64_t d2, Register b2);   // load and add    int64, unsigned -- z196
2333   inline void z_lan(  Register r1, Register r3, int64_t d2, Register b2);   // load and and    int32           -- z196
2334   inline void z_lang( Register r1, Register r3, int64_t d2, Register b2);   // load and and    int64           -- z196
2335   inline void z_lax(  Register r1, Register r3, int64_t d2, Register b2);   // load and xor    int32           -- z196
2336   inline void z_laxg( Register r1, Register r3, int64_t d2, Register b2);   // load and xor    int64           -- z196
2337   inline void z_lao(  Register r1, Register r3, int64_t d2, Register b2);   // load and or     int32           -- z196
2338   inline void z_laog( Register r1, Register r3, int64_t d2, Register b2);   // load and or     int64           -- z196
2339 
2340   inline void z_laa(  Register r1, Register r3, const Address&amp; a);          // load and add    int32, signed   -- z196
2341   inline void z_laag( Register r1, Register r3, const Address&amp; a);          // load and add    int64, signed   -- z196
2342   inline void z_laal( Register r1, Register r3, const Address&amp; a);          // load and add    int32, unsigned -- z196
2343   inline void z_laalg(Register r1, Register r3, const Address&amp; a);          // load and add    int64, unsigned -- z196
2344   inline void z_lan(  Register r1, Register r3, const Address&amp; a);          // load and and    int32           -- z196
2345   inline void z_lang( Register r1, Register r3, const Address&amp; a);          // load and and    int64           -- z196
2346   inline void z_lax(  Register r1, Register r3, const Address&amp; a);          // load and xor    int32           -- z196
2347   inline void z_laxg( Register r1, Register r3, const Address&amp; a);          // load and xor    int64           -- z196
2348   inline void z_lao(  Register r1, Register r3, const Address&amp; a);          // load and or     int32           -- z196
2349   inline void z_laog( Register r1, Register r3, const Address&amp; a);          // load and or     int64           -- z196
2350 
2351   //--------------------------------
2352   // Execution Prediction
2353   //--------------------------------
2354   inline void z_pfd(  int64_t m1, int64_t d2, Register x2, Register b2);  // prefetch
2355   inline void z_pfd(  int64_t m1, Address a);
2356   inline void z_pfdrl(int64_t m1, int64_t i2);                            // prefetch
2357   inline void z_bpp(  int64_t m1, int64_t i2, int64_t d3, Register b3);   // branch prediction    -- EC12
2358   inline void z_bprp( int64_t m1, int64_t i2, int64_t i3);                // branch prediction    -- EC12
2359 
2360   //-------------------------------
2361   // Transaction Control
2362   //-------------------------------
2363   inline void z_tbegin(int64_t d1, Register b1, int64_t i2);          // begin transaction               -- EC12
2364   inline void z_tbeginc(int64_t d1, Register b1, int64_t i2);         // begin transaction (constrained) -- EC12
2365   inline void z_tend();                                               // end transaction                 -- EC12
2366   inline void z_tabort(int64_t d2, Register b2);                      // abort transaction               -- EC12
2367   inline void z_etnd(Register r1);                                    // extract tx nesting depth        -- EC12
2368   inline void z_ppa(Register r1, Register r2, int64_t m3);            // perform processor assist        -- EC12
2369 
2370   //---------------------------------
2371   // Conditional Execution
2372   //---------------------------------
2373   inline void z_locr( Register r1, Register r2, branch_condition cc);             // if (cc) load r1 = r2               ; int32 -- z196
2374   inline void z_locgr(Register r1, Register r2, branch_condition cc);             // if (cc) load r1 = r2               ; int64 -- z196
2375   inline void z_loc(  Register r1, int64_t d2, Register b2, branch_condition cc); // if (cc) load r1 = *(d2_simm20+b2)  ; int32 -- z196
2376   inline void z_locg( Register r1, int64_t d2, Register b2, branch_condition cc); // if (cc) load r1 = *(d2_simm20+b2)  ; int64 -- z196
2377   inline void z_loc(  Register r1, const Address&amp; a, branch_condition cc);        // if (cc) load r1 = *(a)             ; int32 -- z196
2378   inline void z_locg( Register r1, const Address&amp; a, branch_condition cc);        // if (cc) load r1 = *(a)             ; int64 -- z196
2379   inline void z_stoc( Register r1, int64_t d2, Register b2, branch_condition cc); // if (cc) store *(d2_simm20+b2) = r1 ; int32 -- z196
2380   inline void z_stocg(Register r1, int64_t d2, Register b2, branch_condition cc); // if (cc) store *(d2_simm20+b2) = r1 ; int64 -- z196
2381 
2382 
2383   // Complex CISC instructions
2384   // ==========================
2385 
2386   inline void z_cksm(Register r1, Register r2);                       // checksum. This is NOT CRC32
2387   inline void z_km(  Register r1, Register r2);                       // cipher message
2388   inline void z_kmc( Register r1, Register r2);                       // cipher message with chaining
2389   inline void z_kimd(Register r1, Register r2);                       // msg digest (SHA)
2390   inline void z_klmd(Register r1, Register r2);                       // msg digest (SHA)
2391   inline void z_kmac(Register r1, Register r2);                       // msg authentication code
2392 
2393   inline void z_ex(Register r1, int64_t d2, Register x2, Register b2);// execute
2394   inline void z_exrl(Register r1, int64_t i2);                        // execute relative long         -- z10
2395   inline void z_exrl(Register r1, address a2);                        // execute relative long         -- z10
2396 
2397   inline void z_ectg(int64_t d1, Register b1, int64_t d2, Register b2, Register r3);  // extract cpu time
2398   inline void z_ecag(Register r1, Register r3, int64_t d2, Register b2);              // extract CPU attribute
2399 
2400   inline void z_srst(Register r1, Register r2);                       // search string
2401   inline void z_srstu(Register r1, Register r2);                      // search string unicode
2402 
2403   inline void z_mvc(const Address&amp; d, const Address&amp; s, int64_t l);               // move l bytes
2404   inline void z_mvc(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2); // move l+1 bytes
2405   inline void z_mvcle(Register r1, Register r3, int64_t d2, Register b2=Z_R0);    // move region of memory
2406 
2407   inline void z_stfle(int64_t d2, Register b2);                            // store facility list extended
2408 
2409   inline void z_nc(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2);// and *(d1+b1) = *(d1+l+b1) &amp; *(d2+b2) ; d1, d2: uimm12, ands l+1 bytes
2410   inline void z_oc(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2);//  or *(d1+b1) = *(d1+l+b1) | *(d2+b2) ; d1, d2: uimm12,  ors l+1 bytes
2411   inline void z_xc(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2);// xor *(d1+b1) = *(d1+l+b1) ^ *(d2+b2) ; d1, d2: uimm12, xors l+1 bytes
2412   inline void z_nc(Address dst, int64_t len, Address src2);                     // and *dst = *dst &amp; *src2, ands len bytes in memory
2413   inline void z_oc(Address dst, int64_t len, Address src2);                     //  or *dst = *dst | *src2,  ors len bytes in memory
2414   inline void z_xc(Address dst, int64_t len, Address src2);                     // xor *dst = *dst ^ *src2, xors len bytes in memory
2415 
2416   // compare instructions
2417   inline void z_clc(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2);  // compare (*(d1_uimm12+b1), *(d1_uimm12+b1)) ; compare l bytes
2418   inline void z_clcle(Register r1, Register r3, int64_t d2, Register b2);  // compare logical long extended, see docu
2419   inline void z_clclu(Register r1, Register r3, int64_t d2, Register b2);  // compare logical long unicode, see docu
2420 
2421   // Translate characters
2422   inline void z_troo(Register r1, Register r2, int64_t m3);
2423   inline void z_trot(Register r1, Register r2, int64_t m3);
2424   inline void z_trto(Register r1, Register r2, int64_t m3);
2425   inline void z_trtt(Register r1, Register r2, int64_t m3);
2426 
2427 
2428   //---------------------------
2429   //--  Vector Instructions  --
2430   //---------------------------
2431 
2432   //---&lt;  Vector Support Instructions  &gt;---
2433 
2434   // Load (transfer from memory)
2435   inline void z_vlm(   VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2436   inline void z_vl(    VectorRegister v1, int64_t d2, Register x2, Register b2);
2437   inline void z_vleb(  VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2438   inline void z_vleh(  VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2439   inline void z_vlef(  VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2440   inline void z_vleg(  VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2441 
2442   // Gather/Scatter
2443   inline void z_vgef(  VectorRegister v1, int64_t d2, VectorRegister vx2, Register b2, int64_t m3);
2444   inline void z_vgeg(  VectorRegister v1, int64_t d2, VectorRegister vx2, Register b2, int64_t m3);
2445 
2446   inline void z_vscef( VectorRegister v1, int64_t d2, VectorRegister vx2, Register b2, int64_t m3);
2447   inline void z_vsceg( VectorRegister v1, int64_t d2, VectorRegister vx2, Register b2, int64_t m3);
2448 
2449   // load and replicate
2450   inline void z_vlrep( VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2451   inline void z_vlrepb(VectorRegister v1, int64_t d2, Register x2, Register b2);
2452   inline void z_vlreph(VectorRegister v1, int64_t d2, Register x2, Register b2);
2453   inline void z_vlrepf(VectorRegister v1, int64_t d2, Register x2, Register b2);
2454   inline void z_vlrepg(VectorRegister v1, int64_t d2, Register x2, Register b2);
2455 
2456   inline void z_vllez( VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2457   inline void z_vllezb(VectorRegister v1, int64_t d2, Register x2, Register b2);
2458   inline void z_vllezh(VectorRegister v1, int64_t d2, Register x2, Register b2);
2459   inline void z_vllezf(VectorRegister v1, int64_t d2, Register x2, Register b2);
2460   inline void z_vllezg(VectorRegister v1, int64_t d2, Register x2, Register b2);
2461 
2462   inline void z_vlbb(  VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2463   inline void z_vll(   VectorRegister v1, Register r3, int64_t d2, Register b2);
2464 
2465   // Load (register to register)
2466   inline void z_vlr(   VectorRegister v1, VectorRegister v2);
2467 
2468   inline void z_vlgv(  Register r1, VectorRegister v3, int64_t d2, Register b2, int64_t m4);
2469   inline void z_vlgvb( Register r1, VectorRegister v3, int64_t d2, Register b2);
2470   inline void z_vlgvh( Register r1, VectorRegister v3, int64_t d2, Register b2);
2471   inline void z_vlgvf( Register r1, VectorRegister v3, int64_t d2, Register b2);
2472   inline void z_vlgvg( Register r1, VectorRegister v3, int64_t d2, Register b2);
2473 
2474   inline void z_vlvg(  VectorRegister v1, Register r3, int64_t d2, Register b2, int64_t m4);
2475   inline void z_vlvgb( VectorRegister v1, Register r3, int64_t d2, Register b2);
2476   inline void z_vlvgh( VectorRegister v1, Register r3, int64_t d2, Register b2);
2477   inline void z_vlvgf( VectorRegister v1, Register r3, int64_t d2, Register b2);
2478   inline void z_vlvgg( VectorRegister v1, Register r3, int64_t d2, Register b2);
2479 
2480   inline void z_vlvgp( VectorRegister v1, Register r2, Register r3);
2481 
2482   // vector register pack
2483   inline void z_vpk(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2484   inline void z_vpkh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2485   inline void z_vpkf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2486   inline void z_vpkg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2487 
2488   inline void z_vpks(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4, int64_t cc5);
2489   inline void z_vpksh( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2490   inline void z_vpksf( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2491   inline void z_vpksg( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2492   inline void z_vpkshs(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2493   inline void z_vpksfs(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2494   inline void z_vpksgs(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2495 
2496   inline void z_vpkls(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4, int64_t cc5);
2497   inline void z_vpklsh( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2498   inline void z_vpklsf( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2499   inline void z_vpklsg( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2500   inline void z_vpklshs(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2501   inline void z_vpklsfs(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2502   inline void z_vpklsgs(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2503 
2504   // vector register unpack (sign-extended)
2505   inline void z_vuph(   VectorRegister v1, VectorRegister v2, int64_t m3);
2506   inline void z_vuphb(  VectorRegister v1, VectorRegister v2);
2507   inline void z_vuphh(  VectorRegister v1, VectorRegister v2);
2508   inline void z_vuphf(  VectorRegister v1, VectorRegister v2);
2509   inline void z_vupl(   VectorRegister v1, VectorRegister v2, int64_t m3);
2510   inline void z_vuplb(  VectorRegister v1, VectorRegister v2);
2511   inline void z_vuplh(  VectorRegister v1, VectorRegister v2);
2512   inline void z_vuplf(  VectorRegister v1, VectorRegister v2);
2513 
2514   // vector register unpack (zero-extended)
2515   inline void z_vuplh(  VectorRegister v1, VectorRegister v2, int64_t m3);
2516   inline void z_vuplhb( VectorRegister v1, VectorRegister v2);
2517   inline void z_vuplhh( VectorRegister v1, VectorRegister v2);
2518   inline void z_vuplhf( VectorRegister v1, VectorRegister v2);
2519   inline void z_vupll(  VectorRegister v1, VectorRegister v2, int64_t m3);
2520   inline void z_vupllb( VectorRegister v1, VectorRegister v2);
2521   inline void z_vupllh( VectorRegister v1, VectorRegister v2);
2522   inline void z_vupllf( VectorRegister v1, VectorRegister v2);
2523 
2524   // vector register merge high/low
2525   inline void z_vmrh( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2526   inline void z_vmrhb(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2527   inline void z_vmrhh(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2528   inline void z_vmrhf(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2529   inline void z_vmrhg(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2530 
2531   inline void z_vmrl( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2532   inline void z_vmrlb(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2533   inline void z_vmrlh(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2534   inline void z_vmrlf(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2535   inline void z_vmrlg(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2536 
2537   // vector register permute
2538   inline void z_vperm( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4);
2539   inline void z_vpdi(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t        m4);
2540 
2541   // vector register replicate
2542   inline void z_vrep(  VectorRegister v1, VectorRegister v3, int64_t imm2, int64_t m4);
2543   inline void z_vrepb( VectorRegister v1, VectorRegister v3, int64_t imm2);
2544   inline void z_vreph( VectorRegister v1, VectorRegister v3, int64_t imm2);
2545   inline void z_vrepf( VectorRegister v1, VectorRegister v3, int64_t imm2);
2546   inline void z_vrepg( VectorRegister v1, VectorRegister v3, int64_t imm2);
2547   inline void z_vrepi( VectorRegister v1, int64_t imm2,      int64_t m3);
2548   inline void z_vrepib(VectorRegister v1, int64_t imm2);
2549   inline void z_vrepih(VectorRegister v1, int64_t imm2);
2550   inline void z_vrepif(VectorRegister v1, int64_t imm2);
2551   inline void z_vrepig(VectorRegister v1, int64_t imm2);
2552 
2553   inline void z_vsel(  VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4);
2554   inline void z_vseg(  VectorRegister v1, VectorRegister v2, int64_t imm3);
2555 
2556   // Load (immediate)
2557   inline void z_vleib( VectorRegister v1, int64_t imm2, int64_t m3);
2558   inline void z_vleih( VectorRegister v1, int64_t imm2, int64_t m3);
2559   inline void z_vleif( VectorRegister v1, int64_t imm2, int64_t m3);
2560   inline void z_vleig( VectorRegister v1, int64_t imm2, int64_t m3);
2561 
2562   // Store
2563   inline void z_vstm(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2564   inline void z_vst(   VectorRegister v1, int64_t d2, Register x2, Register b2);
2565   inline void z_vsteb( VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2566   inline void z_vsteh( VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2567   inline void z_vstef( VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2568   inline void z_vsteg( VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2569   inline void z_vstl(  VectorRegister v1, Register r3, int64_t d2, Register b2);
2570 
2571   // Misc
2572   inline void z_vgm(   VectorRegister v1, int64_t imm2, int64_t imm3, int64_t m4);
2573   inline void z_vgmb(  VectorRegister v1, int64_t imm2, int64_t imm3);
2574   inline void z_vgmh(  VectorRegister v1, int64_t imm2, int64_t imm3);
2575   inline void z_vgmf(  VectorRegister v1, int64_t imm2, int64_t imm3);
2576   inline void z_vgmg(  VectorRegister v1, int64_t imm2, int64_t imm3);
2577 
2578   inline void z_vgbm(  VectorRegister v1, int64_t imm2);
2579   inline void z_vzero( VectorRegister v1); // preferred method to set vreg to all zeroes
2580   inline void z_vone(  VectorRegister v1); // preferred method to set vreg to all ones
2581 
2582   //---&lt;  Vector Arithmetic Instructions  &gt;---
2583 
2584   // Load
2585   inline void z_vlc(    VectorRegister v1, VectorRegister v2, int64_t m3);
2586   inline void z_vlcb(   VectorRegister v1, VectorRegister v2);
2587   inline void z_vlch(   VectorRegister v1, VectorRegister v2);
2588   inline void z_vlcf(   VectorRegister v1, VectorRegister v2);
2589   inline void z_vlcg(   VectorRegister v1, VectorRegister v2);
2590   inline void z_vlp(    VectorRegister v1, VectorRegister v2, int64_t m3);
2591   inline void z_vlpb(   VectorRegister v1, VectorRegister v2);
2592   inline void z_vlph(   VectorRegister v1, VectorRegister v2);
2593   inline void z_vlpf(   VectorRegister v1, VectorRegister v2);
2594   inline void z_vlpg(   VectorRegister v1, VectorRegister v2);
2595 
2596   // ADD
2597   inline void z_va(     VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2598   inline void z_vab(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2599   inline void z_vah(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2600   inline void z_vaf(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2601   inline void z_vag(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2602   inline void z_vaq(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2603   inline void z_vacc(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2604   inline void z_vaccb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2605   inline void z_vacch(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2606   inline void z_vaccf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2607   inline void z_vaccg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2608   inline void z_vaccq(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2609 
2610   // SUB
2611   inline void z_vs(     VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2612   inline void z_vsb(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2613   inline void z_vsh(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2614   inline void z_vsf(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2615   inline void z_vsg(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2616   inline void z_vsq(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2617   inline void z_vscbi(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2618   inline void z_vscbib( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2619   inline void z_vscbih( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2620   inline void z_vscbif( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2621   inline void z_vscbig( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2622   inline void z_vscbiq( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2623 
2624   // MULTIPLY
2625   inline void z_vml(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2626   inline void z_vmh(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2627   inline void z_vmlh(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2628   inline void z_vme(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2629   inline void z_vmle(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2630   inline void z_vmo(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2631   inline void z_vmlo(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2632 
2633   // MULTIPLY &amp; ADD
2634   inline void z_vmal(   VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2635   inline void z_vmah(   VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2636   inline void z_vmalh(  VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2637   inline void z_vmae(   VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2638   inline void z_vmale(  VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2639   inline void z_vmao(   VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2640   inline void z_vmalo(  VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2641 
2642   // VECTOR SUM
2643   inline void z_vsum(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2644   inline void z_vsumb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2645   inline void z_vsumh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2646   inline void z_vsumg(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2647   inline void z_vsumgh( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2648   inline void z_vsumgf( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2649   inline void z_vsumq(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2650   inline void z_vsumqf( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2651   inline void z_vsumqg( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2652 
2653   // Average
2654   inline void z_vavg(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2655   inline void z_vavgb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2656   inline void z_vavgh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2657   inline void z_vavgf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2658   inline void z_vavgg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2659   inline void z_vavgl(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2660   inline void z_vavglb( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2661   inline void z_vavglh( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2662   inline void z_vavglf( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2663   inline void z_vavglg( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2664 
2665   // VECTOR Galois Field Multiply Sum
2666   inline void z_vgfm(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2667   inline void z_vgfmb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2668   inline void z_vgfmh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2669   inline void z_vgfmf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2670   inline void z_vgfmg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2671   // VECTOR Galois Field Multiply Sum and Accumulate
2672   inline void z_vgfma(  VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2673   inline void z_vgfmab( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4);
2674   inline void z_vgfmah( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4);
2675   inline void z_vgfmaf( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4);
2676   inline void z_vgfmag( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4);
2677 
2678   //---&lt;  Vector Logical Instructions  &gt;---
2679 
2680   // AND
2681   inline void z_vn(     VectorRegister v1, VectorRegister v2, VectorRegister v3);
2682   inline void z_vnc(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2683 
2684   // XOR
2685   inline void z_vx(     VectorRegister v1, VectorRegister v2, VectorRegister v3);
2686 
2687   // NOR
2688   inline void z_vno(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2689 
2690   // OR
2691   inline void z_vo(     VectorRegister v1, VectorRegister v2, VectorRegister v3);
2692 
2693   // Comparison (element-wise)
2694   inline void z_vceq(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4, int64_t cc5);
2695   inline void z_vceqb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2696   inline void z_vceqh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2697   inline void z_vceqf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2698   inline void z_vceqg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2699   inline void z_vceqbs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2700   inline void z_vceqhs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2701   inline void z_vceqfs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2702   inline void z_vceqgs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2703   inline void z_vch(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4, int64_t cc5);
2704   inline void z_vchb(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2705   inline void z_vchh(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2706   inline void z_vchf(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2707   inline void z_vchg(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2708   inline void z_vchbs(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2709   inline void z_vchhs(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2710   inline void z_vchfs(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2711   inline void z_vchgs(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2712   inline void z_vchl(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4, int64_t cc5);
2713   inline void z_vchlb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2714   inline void z_vchlh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2715   inline void z_vchlf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2716   inline void z_vchlg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2717   inline void z_vchlbs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2718   inline void z_vchlhs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2719   inline void z_vchlfs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2720   inline void z_vchlgs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2721 
2722   // Max/Min (element-wise)
2723   inline void z_vmx(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2724   inline void z_vmxb(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2725   inline void z_vmxh(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2726   inline void z_vmxf(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2727   inline void z_vmxg(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2728   inline void z_vmxl(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2729   inline void z_vmxlb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2730   inline void z_vmxlh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2731   inline void z_vmxlf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2732   inline void z_vmxlg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2733   inline void z_vmn(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2734   inline void z_vmnb(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2735   inline void z_vmnh(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2736   inline void z_vmnf(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2737   inline void z_vmng(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2738   inline void z_vmnl(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2739   inline void z_vmnlb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2740   inline void z_vmnlh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2741   inline void z_vmnlf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2742   inline void z_vmnlg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2743 
2744   // Leading/Trailing Zeros, population count
2745   inline void z_vclz(   VectorRegister v1, VectorRegister v2, int64_t m3);
2746   inline void z_vclzb(  VectorRegister v1, VectorRegister v2);
2747   inline void z_vclzh(  VectorRegister v1, VectorRegister v2);
2748   inline void z_vclzf(  VectorRegister v1, VectorRegister v2);
2749   inline void z_vclzg(  VectorRegister v1, VectorRegister v2);
2750   inline void z_vctz(   VectorRegister v1, VectorRegister v2, int64_t m3);
2751   inline void z_vctzb(  VectorRegister v1, VectorRegister v2);
2752   inline void z_vctzh(  VectorRegister v1, VectorRegister v2);
2753   inline void z_vctzf(  VectorRegister v1, VectorRegister v2);
2754   inline void z_vctzg(  VectorRegister v1, VectorRegister v2);
2755   inline void z_vpopct( VectorRegister v1, VectorRegister v2, int64_t m3);
2756 
2757   // Rotate/Shift
2758   inline void z_verllv( VectorRegister v1, VectorRegister v2, VectorRegister v3,               int64_t m4);
2759   inline void z_verllvb(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2760   inline void z_verllvh(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2761   inline void z_verllvf(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2762   inline void z_verllvg(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2763   inline void z_verll(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2,         int64_t m4);
2764   inline void z_verllb( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2765   inline void z_verllh( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2766   inline void z_verllf( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2767   inline void z_verllg( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2768   inline void z_verim(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4, int64_t m5);
2769   inline void z_verimb( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4);
2770   inline void z_verimh( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4);
2771   inline void z_verimf( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4);
2772   inline void z_verimg( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4);
2773 
2774   inline void z_veslv(  VectorRegister v1, VectorRegister v2, VectorRegister v3,               int64_t m4);
2775   inline void z_veslvb( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2776   inline void z_veslvh( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2777   inline void z_veslvf( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2778   inline void z_veslvg( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2779   inline void z_vesl(   VectorRegister v1, VectorRegister v3, int64_t d2, Register b2,         int64_t m4);
2780   inline void z_veslb(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2781   inline void z_veslh(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2782   inline void z_veslf(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2783   inline void z_veslg(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2784 
2785   inline void z_vesrav( VectorRegister v1, VectorRegister v2, VectorRegister v3,               int64_t m4);
2786   inline void z_vesravb(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2787   inline void z_vesravh(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2788   inline void z_vesravf(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2789   inline void z_vesravg(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2790   inline void z_vesra(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2,         int64_t m4);
2791   inline void z_vesrab( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2792   inline void z_vesrah( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2793   inline void z_vesraf( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2794   inline void z_vesrag( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2795   inline void z_vesrlv( VectorRegister v1, VectorRegister v2, VectorRegister v3,               int64_t m4);
2796   inline void z_vesrlvb(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2797   inline void z_vesrlvh(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2798   inline void z_vesrlvf(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2799   inline void z_vesrlvg(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2800   inline void z_vesrl(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2,         int64_t m4);
2801   inline void z_vesrlb( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2802   inline void z_vesrlh( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2803   inline void z_vesrlf( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2804   inline void z_vesrlg( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2805 
2806   inline void z_vsl(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2807   inline void z_vslb(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2808   inline void z_vsldb(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4);
2809 
2810   inline void z_vsra(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2811   inline void z_vsrab(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2812   inline void z_vsrl(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2813   inline void z_vsrlb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2814 
2815   // Test under Mask
2816   inline void z_vtm(    VectorRegister v1, VectorRegister v2);
2817 
2818   //---&lt;  Vector String Instructions  &gt;---
2819   inline void z_vfae(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4, int64_t cc5);   // Find any element
2820   inline void z_vfaeb(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2821   inline void z_vfaeh(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2822   inline void z_vfaef(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2823   inline void z_vfee(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4, int64_t cc5);   // Find element equal
2824   inline void z_vfeeb(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2825   inline void z_vfeeh(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2826   inline void z_vfeef(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2827   inline void z_vfene(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4, int64_t cc5);   // Find element not equal
2828   inline void z_vfeneb( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2829   inline void z_vfeneh( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2830   inline void z_vfenef( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2831   inline void z_vstrc(  VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t imm5, int64_t cc6);   // String range compare
2832   inline void z_vstrcb( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t cc6);
2833   inline void z_vstrch( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t cc6);
2834   inline void z_vstrcf( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t cc6);
2835   inline void z_vistr(  VectorRegister v1, VectorRegister v2, int64_t imm3, int64_t cc5);                      // Isolate String
2836   inline void z_vistrb( VectorRegister v1, VectorRegister v2, int64_t cc5);
2837   inline void z_vistrh( VectorRegister v1, VectorRegister v2, int64_t cc5);
2838   inline void z_vistrf( VectorRegister v1, VectorRegister v2, int64_t cc5);
2839   inline void z_vistrbs(VectorRegister v1, VectorRegister v2);
2840   inline void z_vistrhs(VectorRegister v1, VectorRegister v2);
2841   inline void z_vistrfs(VectorRegister v1, VectorRegister v2);
2842 
2843 
2844   // Floatingpoint instructions
2845   // ==========================
2846 
2847   // compare instructions
2848   inline void z_cebr(FloatRegister r1, FloatRegister r2);                     // compare (r1, r2)                ; float
2849   inline void z_ceb(FloatRegister r1, int64_t d2, Register x2, Register b2);  // compare (r1, *(d2_imm12+x2+b2)) ; float
2850   inline void z_ceb(FloatRegister r1, const Address &amp;a);                      // compare (r1, *(d2_imm12+x2+b2)) ; float
2851   inline void z_cdbr(FloatRegister r1, FloatRegister r2);                     // compare (r1, r2)                ; double
2852   inline void z_cdb(FloatRegister r1, int64_t d2, Register x2, Register b2);  // compare (r1, *(d2_imm12+x2+b2)) ; double
2853   inline void z_cdb(FloatRegister r1, const Address &amp;a);                      // compare (r1, *(d2_imm12+x2+b2)) ; double
2854 
2855   // load instructions
2856   inline void z_le( FloatRegister r1, int64_t d2, Register x2, Register b2);   // load r1 = *(d2_uimm12+x2+b2) ; float
2857   inline void z_ley(FloatRegister r1, int64_t d2, Register x2, Register b2);   // load r1 = *(d2_imm20+x2+b2)  ; float
2858   inline void z_ld( FloatRegister r1, int64_t d2, Register x2, Register b2);   // load r1 = *(d2_uimm12+x2+b2) ; double
2859   inline void z_ldy(FloatRegister r1, int64_t d2, Register x2, Register b2);   // load r1 = *(d2_imm20+x2+b2)  ; double
2860   inline void z_le( FloatRegister r1, const Address &amp;a);                       // load r1 = *(a)               ; float
2861   inline void z_ley(FloatRegister r1, const Address &amp;a);                       // load r1 = *(a)               ; float
2862   inline void z_ld( FloatRegister r1, const Address &amp;a);                       // load r1 = *(a)               ; double
2863   inline void z_ldy(FloatRegister r1, const Address &amp;a);                       // load r1 = *(a)               ; double
2864 
2865   // store instructions
2866   inline void z_ste( FloatRegister r1, int64_t d2, Register x2, Register b2);  // store *(d2_uimm12+x2+b2) = r1  ; float
2867   inline void z_stey(FloatRegister r1, int64_t d2, Register x2, Register b2);  // store *(d2_imm20+x2+b2)  = r1  ; float
2868   inline void z_std( FloatRegister r1, int64_t d2, Register x2, Register b2);  // store *(d2_uimm12+x2+b2) = r1  ; double
2869   inline void z_stdy(FloatRegister r1, int64_t d2, Register x2, Register b2);  // store *(d2_imm20+x2+b2)  = r1  ; double
2870   inline void z_ste( FloatRegister r1, const Address &amp;a);                      // store *(a)               = r1  ; float
2871   inline void z_stey(FloatRegister r1, const Address &amp;a);                      // store *(a)               = r1  ; float
2872   inline void z_std( FloatRegister r1, const Address &amp;a);                      // store *(a)               = r1  ; double
2873   inline void z_stdy(FloatRegister r1, const Address &amp;a);                      // store *(a)               = r1  ; double
2874 
2875   // load and store immediates
2876   inline void z_lzer(FloatRegister r1);                                 // r1 = 0     ; single
2877   inline void z_lzdr(FloatRegister r1);                                 // r1 = 0     ; double
2878 
2879   // Move and Convert instructions
2880   inline void z_ler(FloatRegister r1, FloatRegister r2);                // move         r1 = r2 ; float
2881   inline void z_ldr(FloatRegister r1, FloatRegister r2);                // move         r1 = r2 ; double
2882   inline void z_ledbr(FloatRegister r1, FloatRegister r2);              // conv / round r1 = r2 ; float &lt;- double
2883   inline void z_ldebr(FloatRegister r1, FloatRegister r2);              // conv         r1 = r2 ; double &lt;- float
2884 
2885   // move between integer and float registers
2886   inline void z_cefbr( FloatRegister r1, Register r2);                  // r1 = r2; float  &lt;-- int32
2887   inline void z_cdfbr( FloatRegister r1, Register r2);                  // r1 = r2; double &lt;-- int32
2888   inline void z_cegbr( FloatRegister r1, Register r2);                  // r1 = r2; float  &lt;-- int64
2889   inline void z_cdgbr( FloatRegister r1, Register r2);                  // r1 = r2; double &lt;-- int64
2890 
2891   // rounding mode for float-2-int conversions
2892   inline void z_cfebr(Register r1, FloatRegister r2, RoundingMode m);   // conv r1 = r2  ; int32 &lt;-- float
2893   inline void z_cfdbr(Register r1, FloatRegister r2, RoundingMode m);   // conv r1 = r2  ; int32 &lt;-- double
2894   inline void z_cgebr(Register r1, FloatRegister r2, RoundingMode m);   // conv r1 = r2  ; int64 &lt;-- float
2895   inline void z_cgdbr(Register r1, FloatRegister r2, RoundingMode m);   // conv r1 = r2  ; int64 &lt;-- double
2896 
2897   inline void z_ldgr(FloatRegister r1, Register r2);   // fr1 = r2  ; what kind of conversion?  -- z10
2898   inline void z_lgdr(Register r1, FloatRegister r2);   // r1  = fr2 ; what kind of conversion?  -- z10
2899 
2900 
2901   // ADD
2902   inline void z_aebr(FloatRegister f1, FloatRegister f2);                      // f1 = f1 + f2               ; float
2903   inline void z_adbr(FloatRegister f1, FloatRegister f2);                      // f1 = f1 + f2               ; double
2904   inline void z_aeb( FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 + *(d2+x2+b2)      ; float
2905   inline void z_adb( FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 + *(d2+x2+b2)      ; double
2906   inline void z_aeb( FloatRegister f1, const Address&amp; a);                      // f1 = f1 + *(a)             ; float
2907   inline void z_adb( FloatRegister f1, const Address&amp; a);                      // f1 = f1 + *(a)             ; double
2908 
2909   // SUB
2910   inline void z_sebr(FloatRegister f1, FloatRegister f2);                      // f1 = f1 - f2               ; float
2911   inline void z_sdbr(FloatRegister f1, FloatRegister f2);                      // f1 = f1 - f2               ; double
2912   inline void z_seb( FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 - *(d2+x2+b2)      ; float
2913   inline void z_sdb( FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 - *(d2+x2+b2)      ; double
2914   inline void z_seb( FloatRegister f1, const Address&amp; a);                      // f1 = f1 - *(a)             ; float
2915   inline void z_sdb( FloatRegister f1, const Address&amp; a);                      // f1 = f1 - *(a)             ; double
2916   // negate
2917   inline void z_lcebr(FloatRegister r1, FloatRegister r2);                     // neg r1 = -r2   ; float
2918   inline void z_lcdbr(FloatRegister r1, FloatRegister r2);                     // neg r1 = -r2   ; double
2919 
2920   // Absolute value, monadic if fr2 == noreg.
2921   inline void z_lpdbr( FloatRegister fr1, FloatRegister fr2 = fnoreg);         // fr1 = |fr2|
2922 
2923 
2924   // MUL
2925   inline void z_meebr(FloatRegister f1, FloatRegister f2);                      // f1 = f1 * f2               ; float
2926   inline void z_mdbr( FloatRegister f1, FloatRegister f2);                      // f1 = f1 * f2               ; double
2927   inline void z_meeb( FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 * *(d2+x2+b2)      ; float
2928   inline void z_mdb(  FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 * *(d2+x2+b2)      ; double
2929   inline void z_meeb( FloatRegister f1, const Address&amp; a);
2930   inline void z_mdb(  FloatRegister f1, const Address&amp; a);
2931 
2932   // MUL-ADD
2933   inline void z_maebr(FloatRegister f1, FloatRegister f3, FloatRegister f2);    // f1 = f3 * f2 + f1          ; float
2934   inline void z_madbr(FloatRegister f1, FloatRegister f3, FloatRegister f2);    // f1 = f3 * f2 + f1          ; double
2935   inline void z_msebr(FloatRegister f1, FloatRegister f3, FloatRegister f2);    // f1 = f3 * f2 - f1          ; float
2936   inline void z_msdbr(FloatRegister f1, FloatRegister f3, FloatRegister f2);    // f1 = f3 * f2 - f1          ; double
2937   inline void z_maeb(FloatRegister f1, FloatRegister f3, int64_t d2, Register x2, Register b2); // f1 = f3 * *(d2+x2+b2) + f1 ; float
2938   inline void z_madb(FloatRegister f1, FloatRegister f3, int64_t d2, Register x2, Register b2); // f1 = f3 * *(d2+x2+b2) + f1 ; double
2939   inline void z_mseb(FloatRegister f1, FloatRegister f3, int64_t d2, Register x2, Register b2); // f1 = f3 * *(d2+x2+b2) - f1 ; float
2940   inline void z_msdb(FloatRegister f1, FloatRegister f3, int64_t d2, Register x2, Register b2); // f1 = f3 * *(d2+x2+b2) - f1 ; double
2941   inline void z_maeb(FloatRegister f1, FloatRegister f3, const Address&amp; a);
2942   inline void z_madb(FloatRegister f1, FloatRegister f3, const Address&amp; a);
2943   inline void z_mseb(FloatRegister f1, FloatRegister f3, const Address&amp; a);
2944   inline void z_msdb(FloatRegister f1, FloatRegister f3, const Address&amp; a);
2945 
2946   // DIV
2947   inline void z_debr( FloatRegister f1, FloatRegister f2);                      // f1 = f1 / f2               ; float
2948   inline void z_ddbr( FloatRegister f1, FloatRegister f2);                      // f1 = f1 / f2               ; double
2949   inline void z_deb(  FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 / *(d2+x2+b2)      ; float
2950   inline void z_ddb(  FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 / *(d2+x2+b2)      ; double
2951   inline void z_deb(  FloatRegister f1, const Address&amp; a);                      // f1 = f1 / *(a)             ; float
2952   inline void z_ddb(  FloatRegister f1, const Address&amp; a);                      // f1 = f1 / *(a)             ; double
2953 
2954   // square root
2955   inline void z_sqdbr(FloatRegister fr1, FloatRegister fr2);                    // fr1 = sqrt(fr2)            ; double
2956   inline void z_sqdb( FloatRegister fr1, int64_t d2, Register x2, Register b2); // fr1 = srqt( *(d2+x2+b2)
2957   inline void z_sqdb( FloatRegister fr1, int64_t d2, Register b2);              // fr1 = srqt( *(d2+b2)
2958 
2959   // Nop instruction
2960   // ===============
2961 
2962   // branch never (nop)
2963   inline void z_nop();
2964   inline void nop(); // Used by shared code.
2965 
2966   // ===============================================================================================
2967 
2968   // Simplified emitters:
2969   // ====================
2970 
2971 
2972   // Some memory instructions without index register (just convenience).
2973   inline void z_layz(Register r1, int64_t d2, Register b2 = Z_R0);
2974   inline void z_lay(Register r1, int64_t d2, Register b2);
2975   inline void z_laz(Register r1, int64_t d2, Register b2);
2976   inline void z_la(Register r1, int64_t d2, Register b2);
2977   inline void z_l(Register r1, int64_t d2, Register b2);
2978   inline void z_ly(Register r1, int64_t d2, Register b2);
2979   inline void z_lg(Register r1, int64_t d2, Register b2);
2980   inline void z_st(Register r1, int64_t d2, Register b2);
2981   inline void z_sty(Register r1, int64_t d2, Register b2);
2982   inline void z_stg(Register r1, int64_t d2, Register b2);
2983   inline void z_lgf(Register r1, int64_t d2, Register b2);
2984   inline void z_lgh(Register r1, int64_t d2, Register b2);
2985   inline void z_llgh(Register r1, int64_t d2, Register b2);
2986   inline void z_llgf(Register r1, int64_t d2, Register b2);
2987   inline void z_lgb(Register r1, int64_t d2, Register b2);
2988   inline void z_cl( Register r1, int64_t d2, Register b2);
2989   inline void z_c(Register r1, int64_t d2, Register b2);
2990   inline void z_cg(Register r1, int64_t d2, Register b2);
2991   inline void z_sh(Register r1, int64_t d2, Register b2);
2992   inline void z_shy(Register r1, int64_t d2, Register b2);
2993   inline void z_ste(FloatRegister r1, int64_t d2, Register b2);
2994   inline void z_std(FloatRegister r1, int64_t d2, Register b2);
2995   inline void z_stdy(FloatRegister r1, int64_t d2, Register b2);
2996   inline void z_stey(FloatRegister r1, int64_t d2, Register b2);
2997   inline void z_ld(FloatRegister r1, int64_t d2, Register b2);
2998   inline void z_ldy(FloatRegister r1, int64_t d2, Register b2);
2999   inline void z_le(FloatRegister r1, int64_t d2, Register b2);
3000   inline void z_ley(FloatRegister r1, int64_t d2, Register b2);
3001 
3002   inline void z_agf(Register r1, int64_t d2, Register b2);
3003 
3004   inline void z_exrl(Register r1, Label&amp; L);
3005   inline void z_larl(Register r1, Label&amp; L);
3006   inline void z_bru( Label&amp; L);
3007   inline void z_brul(Label&amp; L);
3008   inline void z_brul(address a);
3009   inline void z_brh( Label&amp; L);
3010   inline void z_brl( Label&amp; L);
3011   inline void z_bre( Label&amp; L);
3012   inline void z_brnh(Label&amp; L);
3013   inline void z_brnl(Label&amp; L);
3014   inline void z_brne(Label&amp; L);
3015   inline void z_brz( Label&amp; L);
3016   inline void z_brnz(Label&amp; L);
3017   inline void z_brnaz(Label&amp; L);
3018   inline void z_braz(Label&amp; L);
3019   inline void z_brnp(Label&amp; L);
3020 
3021   inline void z_btrue( Label&amp; L);
3022   inline void z_bfalse(Label&amp; L);
3023 
3024   inline void z_bvat(Label&amp; L);   // all true
3025   inline void z_bvnt(Label&amp; L);   // not all true (mixed or all false)
3026   inline void z_bvmix(Label&amp; L);  // mixed true and false
3027   inline void z_bvaf(Label&amp; L);   // not all false (mixed or all true)
3028   inline void z_bvnf(Label&amp; L);   // all false
3029 
3030   inline void z_brno( Label&amp; L);
3031 
3032 
3033   inline void z_basr(Register r1, Register r2);
3034   inline void z_brasl(Register r1, address a);
3035   inline void z_brct(Register r1, address a);
3036   inline void z_brct(Register r1, Label&amp; L);
3037 
3038   inline void z_brxh(Register r1, Register r3, address a);
3039   inline void z_brxh(Register r1, Register r3, Label&amp; L);
3040 
3041   inline void z_brxle(Register r1, Register r3, address a);
3042   inline void z_brxle(Register r1, Register r3, Label&amp; L);
3043 
3044   inline void z_brxhg(Register r1, Register r3, address a);
3045   inline void z_brxhg(Register r1, Register r3, Label&amp; L);
3046 
3047   inline void z_brxlg(Register r1, Register r3, address a);
3048   inline void z_brxlg(Register r1, Register r3, Label&amp; L);
3049 
3050   // Ppopulation count intrinsics.
3051   inline void z_flogr(Register r1, Register r2);    // find leftmost one
3052   inline void z_popcnt(Register r1, Register r2);   // population count
3053   inline void z_ahhhr(Register r1, Register r2, Register r3);   // ADD halfword high high
3054   inline void z_ahhlr(Register r1, Register r2, Register r3);   // ADD halfword high low
3055 
3056   inline void z_tam();
3057   inline void z_stckf(int64_t d2, Register b2);
3058   inline void z_stm( Register r1, Register r3, int64_t d2, Register b2);
3059   inline void z_stmy(Register r1, Register r3, int64_t d2, Register b2);
3060   inline void z_stmg(Register r1, Register r3, int64_t d2, Register b2);
3061   inline void z_lm( Register r1, Register r3, int64_t d2, Register b2);
3062   inline void z_lmy(Register r1, Register r3, int64_t d2, Register b2);
3063   inline void z_lmg(Register r1, Register r3, int64_t d2, Register b2);
3064 
3065   inline void z_cs( Register r1, Register r3, int64_t d2, Register b2);
3066   inline void z_csy(Register r1, Register r3, int64_t d2, Register b2);
3067   inline void z_csg(Register r1, Register r3, int64_t d2, Register b2);
3068   inline void z_cs( Register r1, Register r3, const Address&amp; a);
3069   inline void z_csy(Register r1, Register r3, const Address&amp; a);
3070   inline void z_csg(Register r1, Register r3, const Address&amp; a);
3071 
3072   inline void z_cvd(Register r1, int64_t d2, Register x2, Register b2);
3073   inline void z_cvdg(Register r1, int64_t d2, Register x2, Register b2);
3074   inline void z_cvd(Register r1, int64_t d2, Register b2);
3075   inline void z_cvdg(Register r1, int64_t d2, Register b2);
3076 
3077   // Instruction queries:
3078   // instruction properties and recognize emitted instructions
3079   // ===========================================================
3080 
3081   static int nop_size() { return 2; }
3082 
3083   static int z_brul_size() { return 6; }
3084 
3085   static bool is_z_basr(short x) {
3086     return (BASR_ZOPC == (x &amp; BASR_MASK));
3087   }
3088   static bool is_z_algr(long x) {
3089     return (ALGR_ZOPC == (x &amp; RRE_MASK));
3090   }
3091   static bool is_z_lb(long x) {
3092     return (LB_ZOPC == (x &amp; LB_MASK));
3093   }
3094   static bool is_z_lh(int x) {
3095     return (LH_ZOPC == (x &amp; LH_MASK));
3096   }
3097   static bool is_z_l(int x) {
3098     return (L_ZOPC == (x &amp; L_MASK));
3099   }
3100   static bool is_z_lgr(long x) {
3101     return (LGR_ZOPC == (x &amp; RRE_MASK));
3102   }
3103   static bool is_z_ly(long x) {
3104     return (LY_ZOPC == (x &amp; LY_MASK));
3105   }
3106   static bool is_z_lg(long x) {
3107     return (LG_ZOPC == (x &amp; LG_MASK));
3108   }
3109   static bool is_z_llgh(long x) {
3110     return (LLGH_ZOPC == (x &amp; LLGH_MASK));
3111   }
3112   static bool is_z_llgf(long x) {
3113     return (LLGF_ZOPC == (x &amp; LLGF_MASK));
3114   }
3115   static bool is_z_le(int x) {
3116     return (LE_ZOPC == (x &amp; LE_MASK));
3117   }
3118   static bool is_z_ld(int x) {
3119     return (LD_ZOPC == (x &amp; LD_MASK));
3120   }
3121   static bool is_z_st(int x) {
3122     return (ST_ZOPC == (x &amp; ST_MASK));
3123   }
3124   static bool is_z_stc(int x) {
3125     return (STC_ZOPC == (x &amp; STC_MASK));
3126   }
3127   static bool is_z_stg(long x) {
3128     return (STG_ZOPC == (x &amp; STG_MASK));
3129   }
3130   static bool is_z_sth(int x) {
3131     return (STH_ZOPC == (x &amp; STH_MASK));
3132   }
3133   static bool is_z_ste(int x) {
3134     return (STE_ZOPC == (x &amp; STE_MASK));
3135   }
3136   static bool is_z_std(int x) {
3137     return (STD_ZOPC == (x &amp; STD_MASK));
3138   }
3139   static bool is_z_slag(long x) {
3140     return (SLAG_ZOPC == (x &amp; SLAG_MASK));
3141   }
3142   static bool is_z_tmy(long x) {
3143     return (TMY_ZOPC == (x &amp; TMY_MASK));
3144   }
3145   static bool is_z_tm(long x) {
3146     return ((unsigned int)TM_ZOPC == (x &amp; (unsigned int)TM_MASK));
3147   }
3148   static bool is_z_bcr(long x) {
3149     return (BCR_ZOPC == (x &amp; BCR_MASK));
3150   }
3151   static bool is_z_nop(long x) {
3152     return is_z_bcr(x) &amp;&amp; ((x &amp; 0x00ff) == 0);
3153   }
3154   static bool is_z_nop(address x) {
3155     return is_z_nop(* (short *) x);
3156   }
3157   static bool is_z_br(long x) {
3158     return is_z_bcr(x) &amp;&amp; ((x &amp; 0x00f0) == 0x00f0);
3159   }
3160   static bool is_z_brc(long x, int cond) {
3161     return ((unsigned int)BRC_ZOPC == (x &amp; BRC_MASK)) &amp;&amp; ((cond&lt;&lt;20) == (x &amp; 0x00f00000U));
3162   }
3163   // Make use of lightweight sync.
3164   static bool is_z_sync_full(long x) {
3165     return is_z_bcr(x) &amp;&amp; (((x &amp; 0x00f0)&gt;&gt;4)==bcondFullSync) &amp;&amp; ((x &amp; 0x000f)==0x0000);
3166   }
3167   static bool is_z_sync_light(long x) {
3168     return is_z_bcr(x) &amp;&amp; (((x &amp; 0x00f0)&gt;&gt;4)==bcondLightSync) &amp;&amp; ((x &amp; 0x000f)==0x0000);
3169   }
3170   static bool is_z_sync(long x) {
3171     return is_z_sync_full(x) || is_z_sync_light(x);
3172   }
3173 
3174   static bool is_z_brasl(long x) {
3175     return (BRASL_ZOPC == (x &amp; BRASL_MASK));
3176   }
3177   static bool is_z_brasl(address a) {
3178   long x = (*((long *)a))&gt;&gt;16;
3179    return is_z_brasl(x);
3180   }
3181   static bool is_z_larl(long x) {
3182     return (LARL_ZOPC == (x &amp; LARL_MASK));
3183   }
3184   static bool is_z_lgrl(long x) {
3185     return (LGRL_ZOPC == (x &amp; LGRL_MASK));
3186   }
3187   static bool is_z_lgrl(address a) {
3188   long x = (*((long *)a))&gt;&gt;16;
3189    return is_z_lgrl(x);
3190   }
3191 
3192   static bool is_z_lghi(unsigned long x) {
3193     return (unsigned int)LGHI_ZOPC == (x &amp; (unsigned int)LGHI_MASK);
3194   }
3195 
3196   static bool is_z_llill(unsigned long x) {
3197     return (unsigned int)LLILL_ZOPC == (x &amp; (unsigned int)LLI_MASK);
3198   }
3199   static bool is_z_llilh(unsigned long x) {
3200     return (unsigned int)LLILH_ZOPC == (x &amp; (unsigned int)LLI_MASK);
3201   }
3202   static bool is_z_llihl(unsigned long x) {
3203     return (unsigned int)LLIHL_ZOPC == (x &amp; (unsigned int)LLI_MASK);
3204   }
3205   static bool is_z_llihh(unsigned long x) {
3206     return (unsigned int)LLIHH_ZOPC == (x &amp; (unsigned int)LLI_MASK);
3207   }
3208   static bool is_z_llilf(unsigned long x) {
3209     return LLILF_ZOPC == (x &amp; LLIF_MASK);
3210   }
3211   static bool is_z_llihf(unsigned long x) {
3212     return LLIHF_ZOPC == (x &amp; LLIF_MASK);
3213   }
3214 
3215   static bool is_z_iill(unsigned long x) {
3216     return (unsigned int)IILL_ZOPC == (x &amp; (unsigned int)II_MASK);
3217   }
3218   static bool is_z_iilh(unsigned long x) {
3219     return (unsigned int)IILH_ZOPC == (x &amp; (unsigned int)II_MASK);
3220   }
3221   static bool is_z_iihl(unsigned long x) {
3222     return (unsigned int)IIHL_ZOPC == (x &amp; (unsigned int)II_MASK);
3223   }
3224   static bool is_z_iihh(unsigned long x) {
3225     return (unsigned int)IIHH_ZOPC == (x &amp; (unsigned int)II_MASK);
3226   }
3227   static bool is_z_iilf(unsigned long x) {
3228     return IILF_ZOPC == (x &amp; IIF_MASK);
3229   }
3230   static bool is_z_iihf(unsigned long x) {
3231     return IIHF_ZOPC == (x &amp; IIF_MASK);
3232   }
3233 
3234   static inline bool is_equal(unsigned long inst, unsigned long idef);
3235   static inline bool is_equal(unsigned long inst, unsigned long idef, unsigned long imask);
3236   static inline bool is_equal(address iloc, unsigned long idef);
3237   static inline bool is_equal(address iloc, unsigned long idef, unsigned long imask);
3238 
3239   static inline bool is_sigtrap_range_check(address pc);
3240   static inline bool is_sigtrap_zero_check(address pc);
3241 
3242   //-----------------
3243   // memory barriers
3244   //-----------------
3245   // machine barrier instructions:
3246   //
3247   // - z_sync            Two-way memory barrier, aka fence.
3248   //                     Only load-after-store-order is not guaranteed in the
3249   //                     z/Architecture memory model, i.e. only &#39;fence&#39; is needed.
3250   //
3251   // semantic barrier instructions:
3252   // (as defined in orderAccess.hpp)
3253   //
3254   // - z_release         orders Store|Store,   empty implementation
3255   //                            Load|Store
3256   // - z_acquire         orders Load|Store,    empty implementation
3257   //                            Load|Load
3258   // - z_fence           orders Store|Store,   implemented as z_sync.
3259   //                            Load|Store,
3260   //                            Load|Load,
3261   //                            Store|Load
3262   //
3263   // For this implementation to be correct, we need H/W fixes on (very) old H/W:
3264   //          For z990, it is Driver-55:  MCL232 in the J13484 (i390/ML) Stream.
3265   //          For z9,   it is Driver-67:  MCL065 in the G40963 (i390/ML) Stream.
3266   // These drivers are a prereq. Otherwise, memory synchronization will not work.
3267 
3268   inline void z_sync();
3269   inline void z_release();
3270   inline void z_acquire();
3271   inline void z_fence();
3272 
3273   // Creation
3274   Assembler(CodeBuffer* code) : AbstractAssembler(code) { }
3275 
3276 };
3277 
3278 #endif // CPU_S390_ASSEMBLER_S390_HPP
    </pre>
  </body>
</html>
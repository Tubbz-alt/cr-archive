<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/s390/templateTable_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="templateInterpreterGenerator_s390.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_ext_s390.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/templateTable_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,10 ***</span>
<span class="line-new-header">--- 37,11 ---</span>
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;runtime/synchronizer.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  #ifdef PRODUCT
  #define __ _masm-&gt;
  #define BLOCK_COMMENT(str)
  #define BIND(label)        __ bind(label);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2402,18 ***</span>
  
  // ----------------------------------------------------------------------------
  // NOTE: Cpe_offset is already computed as byte offset, so we must not
  // shift it afterwards!
  void TemplateTable::resolve_cache_and_index(int byte_no,
<span class="line-modified">!                                             Register Rcache,</span>
                                              Register cpe_offset,
                                              size_t index_size) {
    BLOCK_COMMENT(&quot;resolve_cache_and_index {&quot;);
<span class="line-modified">!   NearLabel      resolved;</span>
    const Register bytecode_in_cpcache = Z_R1_scratch;
    const int      total_f1_offset = in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset());
<span class="line-modified">!   assert_different_registers(Rcache, cpe_offset, bytecode_in_cpcache);</span>
  
    Bytecodes::Code code = bytecode();
    switch (code) {
      case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
      case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
<span class="line-new-header">--- 2403,18 ---</span>
  
  // ----------------------------------------------------------------------------
  // NOTE: Cpe_offset is already computed as byte offset, so we must not
  // shift it afterwards!
  void TemplateTable::resolve_cache_and_index(int byte_no,
<span class="line-modified">!                                             Register cache,</span>
                                              Register cpe_offset,
                                              size_t index_size) {
    BLOCK_COMMENT(&quot;resolve_cache_and_index {&quot;);
<span class="line-modified">!   NearLabel      resolved, clinit_barrier_slow;</span>
    const Register bytecode_in_cpcache = Z_R1_scratch;
    const int      total_f1_offset = in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset());
<span class="line-modified">!   assert_different_registers(cache, cpe_offset, bytecode_in_cpcache);</span>
  
    Bytecodes::Code code = bytecode();
    switch (code) {
      case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
      case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2421,23 ***</span>
        break;
    }
  
    {
      assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
<span class="line-modified">!     __ get_cache_and_index_and_bytecode_at_bcp(Rcache, cpe_offset, bytecode_in_cpcache, byte_no, 1, index_size);</span>
      // Have we resolved this bytecode?
      __ compare32_and_branch(bytecode_in_cpcache, (int)code, Assembler::bcondEqual, resolved);
    }
  
    // Resolve first time through.
    address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
    __ load_const_optimized(Z_ARG2, (int) code);
    __ call_VM(noreg, entry, Z_ARG2);
  
    // Update registers with resolved info.
<span class="line-modified">!   __ get_cache_and_index_at_bcp(Rcache, cpe_offset, 1, index_size);</span>
    __ bind(resolved);
    BLOCK_COMMENT(&quot;} resolve_cache_and_index&quot;);
  }
  
  // The Rcache and index registers must be set before call.
  // Index is already a byte offset, don&#39;t shift!
<span class="line-new-header">--- 2422,36 ---</span>
        break;
    }
  
    {
      assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
<span class="line-modified">!     __ get_cache_and_index_and_bytecode_at_bcp(cache, cpe_offset, bytecode_in_cpcache, byte_no, 1, index_size);</span>
      // Have we resolved this bytecode?
      __ compare32_and_branch(bytecode_in_cpcache, (int)code, Assembler::bcondEqual, resolved);
    }
  
    // Resolve first time through.
<span class="line-added">+   // Class initialization barrier slow path lands here as well.</span>
<span class="line-added">+   __ bind(clinit_barrier_slow);</span>
    address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
    __ load_const_optimized(Z_ARG2, (int) code);
    __ call_VM(noreg, entry, Z_ARG2);
  
    // Update registers with resolved info.
<span class="line-modified">!   __ get_cache_and_index_at_bcp(cache, cpe_offset, 1, index_size);</span>
    __ bind(resolved);
<span class="line-added">+ </span>
<span class="line-added">+   // Class initialization barrier for static methods</span>
<span class="line-added">+   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; bytecode() == Bytecodes::_invokestatic) {</span>
<span class="line-added">+     const Register method = Z_R1_scratch;</span>
<span class="line-added">+     const Register klass  = Z_R1_scratch;</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ load_resolved_method_at_index(byte_no, cache, cpe_offset, method);</span>
<span class="line-added">+     __ load_method_holder(klass, method);</span>
<span class="line-added">+     __ clinit_barrier(klass, Z_thread, NULL /*L_fast_path*/, &amp;clinit_barrier_slow);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    BLOCK_COMMENT(&quot;} resolve_cache_and_index&quot;);
  }
  
  // The Rcache and index registers must be set before call.
  // Index is already a byte offset, don&#39;t shift!
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3662,13 ***</span>
    __ profile_virtual_call(klass, Z_ARG1/*mdp*/, flags/*scratch*/);
  
    // Find entry point to call.
  
    // Get declaring interface class from method
<span class="line-modified">!   __ z_lg(interface, Address(method, Method::const_offset()));</span>
<span class="line-removed">-   __ z_lg(interface, Address(interface, ConstMethod::constants_offset()));</span>
<span class="line-removed">-   __ z_lg(interface, Address(interface, ConstantPool::pool_holder_offset_in_bytes()));</span>
  
    // Get itable index from method
    Register index   = receiver,
             method2 = flags;
    __ z_lgf(index, Address(method, Method::itable_index_offset()));
<span class="line-new-header">--- 3676,11 ---</span>
    __ profile_virtual_call(klass, Z_ARG1/*mdp*/, flags/*scratch*/);
  
    // Find entry point to call.
  
    // Get declaring interface class from method
<span class="line-modified">!   __ load_method_holder(interface, method);</span>
  
    // Get itable index from method
    Register index   = receiver,
             method2 = flags;
    __ z_lgf(index, Address(method, Method::itable_index_offset()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3867,11 ***</span>
        Register prototype = RobjectFields;
        __ z_lg(prototype, Address(iklass, Klass::prototype_header_offset()));
        __ z_stg(prototype, Address(RallocatedObject, oopDesc::mark_offset_in_bytes()));
      } else {
        __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),
<span class="line-modified">!                      (long)markOopDesc::prototype());</span>
      }
  
      __ store_klass_gap(Rzero, RallocatedObject);  // Zero klass gap for compressed oops.
      __ store_klass(iklass, RallocatedObject);     // Store klass last.
  
<span class="line-new-header">--- 3879,11 ---</span>
        Register prototype = RobjectFields;
        __ z_lg(prototype, Address(iklass, Klass::prototype_header_offset()));
        __ z_stg(prototype, Address(RallocatedObject, oopDesc::mark_offset_in_bytes()));
      } else {
        __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),
<span class="line-modified">!                      (long)markWord::prototype().value());</span>
      }
  
      __ store_klass_gap(Rzero, RallocatedObject);  // Zero klass gap for compressed oops.
      __ store_klass(iklass, RallocatedObject);     // Store klass last.
  
</pre>
<center><a href="templateInterpreterGenerator_s390.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_ext_s390.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/c1_LIRAssembler_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/c1_LIRAssembler_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2016, 2017, SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified">  36 #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="line-removed">  37 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;</span>
  38 #include &quot;nativeInst_s390.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;runtime/frame.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;

  43 #include &quot;vmreg_s390.inline.hpp&quot;
  44 
  45 #define __ _masm-&gt;
  46 
  47 #ifndef PRODUCT
  48 #undef __
  49 #define __ (Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm) : _masm)-&gt;
  50 #endif
  51 
  52 //------------------------------------------------------------
  53 
  54 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  55   // Not used on ZARCH_64
  56   ShouldNotCallThis();
  57   return false;
  58 }
  59 
  60 LIR_Opr LIR_Assembler::receiverOpr() {
  61   return FrameMap::Z_R2_oop_opr;
  62 }
  63 
  64 LIR_Opr LIR_Assembler::osrBufferPointer() {
  65   return FrameMap::Z_R2_opr;
  66 }
  67 
  68 int LIR_Assembler::initial_frame_size_in_bytes() const {
  69   return in_bytes(frame_map()-&gt;framesize_in_bytes());
  70 }
  71 
  72 // Inline cache check: done before the frame is built.
  73 // The inline cached class is in Z_inline_cache(Z_R9).
  74 // We fetch the class of the receiver and compare it with the cached class.
  75 // If they do not match we jump to the slow case.
  76 int LIR_Assembler::check_icache() {
  77   Register receiver = receiverOpr()-&gt;as_register();
  78   int offset = __ offset();
  79   __ inline_cache_check(receiver, Z_inline_cache);
  80   return offset;
  81 }
  82 















  83 void LIR_Assembler::osr_entry() {
  84   // On-stack-replacement entry sequence (interpreter frame layout described in interpreter_sparc.cpp):
  85   //
  86   //   1. Create a new compiled activation.
  87   //   2. Initialize local variables in the compiled activation. The expression stack must be empty
  88   //      at the osr_bci; it is not initialized.
  89   //   3. Jump to the continuation address in compiled code to resume execution.
  90 
  91   // OSR entry point
  92   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
  93   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
  94   ValueStack* entry_state = osr_entry-&gt;end()-&gt;state();
  95   int number_of_locks = entry_state-&gt;locks_size();
  96 
  97   // Create a frame for the compiled activation.
  98   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
  99 
 100   // OSR buffer is
 101   //
 102   // locals[nlocals-1..0]
</pre>
<hr />
<pre>
 864 
 865 // 4-byte accesses only! Don&#39;t use it to access 8 bytes!
 866 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 867   ShouldNotCallThis();
 868   return 0; // unused
 869 }
 870 
 871 void LIR_Assembler::mem2reg(LIR_Opr src_opr, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code,
 872                             CodeEmitInfo* info, bool wide, bool unaligned) {
 873 
 874   assert(type != T_METADATA, &quot;load of metadata ptr not supported&quot;);
 875   LIR_Address* addr = src_opr-&gt;as_address_ptr();
 876   LIR_Opr to_reg = dest;
 877 
 878   Register src = addr-&gt;base()-&gt;as_pointer_register();
 879   Register disp_reg = Z_R0;
 880   int disp_value = addr-&gt;disp();
 881   bool needs_patching = (patch_code != lir_patch_none);
 882 
 883   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
<span class="line-modified"> 884     __ verify_oop(src);</span>
 885   }
 886 
 887   PatchingStub* patch = NULL;
 888   if (needs_patching) {
 889     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 890     assert(!to_reg-&gt;is_double_cpu() ||
 891            patch_code == lir_patch_none ||
 892            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
 893   }
 894 
 895   if (addr-&gt;index()-&gt;is_illegal()) {
 896     if (!Immediate::is_simm20(disp_value)) {
 897       if (needs_patching) {
 898         __ load_const(Z_R1_scratch, (intptr_t)0);
 899       } else {
 900         __ load_const_optimized(Z_R1_scratch, disp_value);
 901       }
 902       disp_reg = Z_R1_scratch;
 903       disp_value = 0;
 904     }
</pre>
<hr />
<pre>
 939                     __ z_ly(dest-&gt;as_register(),   disp_value, disp_reg, src);
 940       }
 941       break;
 942     case T_ADDRESS:
 943       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
 944         __ z_llgf(dest-&gt;as_register(), disp_value, disp_reg, src);
 945         __ decode_klass_not_null(dest-&gt;as_register());
 946       } else {
 947         __ z_lg(dest-&gt;as_register(), disp_value, disp_reg, src);
 948       }
 949       break;
 950     case T_ARRAY : // fall through
 951     case T_OBJECT:
 952     {
 953       if (UseCompressedOops &amp;&amp; !wide) {
 954         __ z_llgf(dest-&gt;as_register(), disp_value, disp_reg, src);
 955         __ oop_decoder(dest-&gt;as_register(), dest-&gt;as_register(), true);
 956       } else {
 957         __ z_lg(dest-&gt;as_register(), disp_value, disp_reg, src);
 958       }

 959       break;
 960     }
 961     case T_FLOAT:
 962       if (short_disp) {
 963                     __ z_le(dest-&gt;as_float_reg(),  disp_value, disp_reg, src);
 964       } else {
 965                     __ z_ley(dest-&gt;as_float_reg(), disp_value, disp_reg, src);
 966       }
 967       break;
 968     case T_DOUBLE:
 969       if (short_disp) {
 970                     __ z_ld(dest-&gt;as_double_reg(),  disp_value, disp_reg, src);
 971       } else {
 972                     __ z_ldy(dest-&gt;as_double_reg(), disp_value, disp_reg, src);
 973       }
 974       break;
 975     case T_LONG  :  __ z_lg(dest-&gt;as_register_lo(), disp_value, disp_reg, src); break;
 976     default      : ShouldNotReachHere();
 977   }
<span class="line-removed"> 978   if (type == T_ARRAY || type == T_OBJECT) {</span>
<span class="line-removed"> 979     __ verify_oop(dest-&gt;as_register());</span>
<span class="line-removed"> 980   }</span>
 981 
 982   if (patch != NULL) {
 983     patching_epilog(patch, patch_code, src, info);
 984   }
 985   if (info != NULL) add_debug_info_for_null_check(offset, info);
 986 }
 987 
 988 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
 989   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
 990   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 991 
 992   if (dest-&gt;is_single_cpu()) {
<span class="line-modified"> 993     if (type == T_ARRAY || type == T_OBJECT) {</span>
 994       __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), true);
<span class="line-modified"> 995       __ verify_oop(dest-&gt;as_register());</span>
<span class="line-modified"> 996     } else if (type == T_METADATA) {</span>
 997       __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), true);
 998     } else {
 999       __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), false);
1000     }
1001   } else if (dest-&gt;is_double_cpu()) {
1002     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1003     __ mem2reg_opt(dest-&gt;as_register_lo(), src_addr_LO, true);
1004   } else if (dest-&gt;is_single_fpu()) {
1005     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1006     __ mem2freg_opt(dest-&gt;as_float_reg(), src_addr, false);
1007   } else if (dest-&gt;is_double_fpu()) {
1008     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1009     __ mem2freg_opt(dest-&gt;as_double_reg(), src_addr, true);
1010   } else {
1011     ShouldNotReachHere();
1012   }
1013 }
1014 
1015 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
1016   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
1017   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
1018 
1019   if (src-&gt;is_single_cpu()) {
1020     const Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
<span class="line-modified">1021     if (type == T_OBJECT || type == T_ARRAY) {</span>
<span class="line-modified">1022       __ verify_oop(src-&gt;as_register());</span>
1023       __ reg2mem_opt(src-&gt;as_register(), dst, true);
<span class="line-modified">1024     } else if (type == T_METADATA) {</span>
1025       __ reg2mem_opt(src-&gt;as_register(), dst, true);
1026     } else {
1027       __ reg2mem_opt(src-&gt;as_register(), dst, false);
1028     }
1029   } else if (src-&gt;is_double_cpu()) {
1030     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1031     __ reg2mem_opt(src-&gt;as_register_lo(), dstLO, true);
1032   } else if (src-&gt;is_single_fpu()) {
1033     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1034     __ freg2mem_opt(src-&gt;as_float_reg(), dst_addr, false);
1035   } else if (src-&gt;is_double_fpu()) {
1036     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1037     __ freg2mem_opt(src-&gt;as_double_reg(), dst_addr, true);
1038   } else {
1039     ShouldNotReachHere();
1040   }
1041 }
1042 
1043 void LIR_Assembler::reg2reg(LIR_Opr from_reg, LIR_Opr to_reg) {
1044   if (from_reg-&gt;is_float_kind() &amp;&amp; to_reg-&gt;is_float_kind()) {
</pre>
<hr />
<pre>
1047       assert(to_reg-&gt;is_double_fpu(), &quot;should match&quot;);
1048       __ z_ldr(to_reg-&gt;as_double_reg(), from_reg-&gt;as_double_reg());
1049     } else {
1050       // float to float moves
1051       assert(to_reg-&gt;is_single_fpu(), &quot;should match&quot;);
1052       __ z_ler(to_reg-&gt;as_float_reg(), from_reg-&gt;as_float_reg());
1053     }
1054   } else if (!from_reg-&gt;is_float_kind() &amp;&amp; !to_reg-&gt;is_float_kind()) {
1055     if (from_reg-&gt;is_double_cpu()) {
1056       __ z_lgr(to_reg-&gt;as_pointer_register(), from_reg-&gt;as_pointer_register());
1057     } else if (to_reg-&gt;is_double_cpu()) {
1058       // int to int moves
1059       __ z_lgr(to_reg-&gt;as_register_lo(), from_reg-&gt;as_register());
1060     } else {
1061       // int to int moves
1062       __ z_lgr(to_reg-&gt;as_register(), from_reg-&gt;as_register());
1063     }
1064   } else {
1065     ShouldNotReachHere();
1066   }
<span class="line-modified">1067   if (to_reg-&gt;type() == T_OBJECT || to_reg-&gt;type() == T_ARRAY) {</span>
<span class="line-modified">1068     __ verify_oop(to_reg-&gt;as_register());</span>
1069   }
1070 }
1071 
1072 void LIR_Assembler::reg2mem(LIR_Opr from, LIR_Opr dest_opr, BasicType type,
1073                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
1074                             bool wide, bool unaligned) {
1075   assert(type != T_METADATA, &quot;store of metadata ptr not supported&quot;);
1076   LIR_Address* addr = dest_opr-&gt;as_address_ptr();
1077 
1078   Register dest = addr-&gt;base()-&gt;as_pointer_register();
1079   Register disp_reg = Z_R0;
1080   int disp_value = addr-&gt;disp();
1081   bool needs_patching = (patch_code != lir_patch_none);
1082 
1083   if (addr-&gt;base()-&gt;is_oop_register()) {
<span class="line-modified">1084     __ verify_oop(dest);</span>
1085   }
1086 
1087   PatchingStub* patch = NULL;
1088   if (needs_patching) {
1089     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1090     assert(!from-&gt;is_double_cpu() ||
1091            patch_code == lir_patch_none ||
1092            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1093   }
1094 
1095   assert(!needs_patching || (!Immediate::is_simm20(disp_value) &amp;&amp; addr-&gt;index()-&gt;is_illegal()), &quot;assumption&quot;);
1096   if (addr-&gt;index()-&gt;is_illegal()) {
1097     if (!Immediate::is_simm20(disp_value)) {
1098       if (needs_patching) {
1099         __ load_const(Z_R1_scratch, (intptr_t)0);
1100       } else {
1101         __ load_const_optimized(Z_R1_scratch, disp_value);
1102       }
1103       disp_reg = Z_R1_scratch;
1104       disp_value = 0;
1105     }
1106   } else {
1107     if (!Immediate::is_simm20(disp_value)) {
1108       __ load_const_optimized(Z_R1_scratch, disp_value);
1109       __ z_la(Z_R1_scratch, 0, Z_R1_scratch, addr-&gt;index()-&gt;as_register());
1110       disp_reg = Z_R1_scratch;
1111       disp_value = 0;
1112     }
1113     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1114   }
1115 
1116   assert(disp_reg != Z_R0 || Immediate::is_simm20(disp_value), &quot;should have set this up&quot;);
1117 
<span class="line-modified">1118   if (type == T_ARRAY || type == T_OBJECT) {</span>
<span class="line-modified">1119     __ verify_oop(from-&gt;as_register());</span>
1120   }
1121 
1122   bool short_disp = Immediate::is_uimm12(disp_value);
1123 
1124   // Remember the offset of the store. The patching_epilog must be done
1125   // before the call to add_debug_info_for_null_check, otherwise the PcDescs don&#39;t get
1126   // entered in increasing order.
1127   int offset = code_offset();
1128   switch (type) {
1129     case T_BOOLEAN: // fall through
1130     case T_BYTE  :
1131       if (short_disp) {
1132                     __ z_stc(from-&gt;as_register(),  disp_value, disp_reg, dest);
1133       } else {
1134                     __ z_stcy(from-&gt;as_register(), disp_value, disp_reg, dest);
1135       }
1136       break;
1137     case T_CHAR  : // fall through
1138     case T_SHORT :
1139       if (short_disp) {
</pre>
<hr />
<pre>
1261 
1262   __ set_inst_mark();
1263   AddressLiteral a((address)-1);
1264   success = success &amp;&amp; __ load_const_from_toc(Z_R1, a);
1265   if (!success) {
1266     bailout(&quot;const section overflow&quot;);
1267     return;
1268   }
1269 
1270   __ z_br(Z_R1);
1271   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
1272   __ end_a_stub(); // Update current stubs pointer and restore insts_end.
1273 }
1274 
1275 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1276   bool unsigned_comp = condition == lir_cond_belowEqual || condition == lir_cond_aboveEqual;
1277   if (opr1-&gt;is_single_cpu()) {
1278     Register reg1 = opr1-&gt;as_register();
1279     if (opr2-&gt;is_single_cpu()) {
1280       // cpu register - cpu register
<span class="line-modified">1281       if (opr1-&gt;type() == T_OBJECT || opr1-&gt;type() == T_ARRAY) {</span>
1282         __ z_clgr(reg1, opr2-&gt;as_register());
1283       } else {
<span class="line-modified">1284         assert(opr2-&gt;type() != T_OBJECT &amp;&amp; opr2-&gt;type() != T_ARRAY, &quot;cmp int, oop?&quot;);</span>
1285         if (unsigned_comp) {
1286           __ z_clr(reg1, opr2-&gt;as_register());
1287         } else {
1288           __ z_cr(reg1, opr2-&gt;as_register());
1289         }
1290       }
1291     } else if (opr2-&gt;is_stack()) {
1292       // cpu register - stack
<span class="line-modified">1293       if (opr1-&gt;type() == T_OBJECT || opr1-&gt;type() == T_ARRAY) {</span>
1294         __ z_cg(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
1295       } else {
1296         if (unsigned_comp) {
1297           __ z_cly(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
1298         } else {
1299           __ z_cy(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
1300         }
1301       }
1302     } else if (opr2-&gt;is_constant()) {
1303       // cpu register - constant
1304       LIR_Const* c = opr2-&gt;as_constant_ptr();
1305       if (c-&gt;type() == T_INT) {
1306         if (unsigned_comp) {
1307           __ z_clfi(reg1, c-&gt;as_jint());
1308         } else {
1309           __ z_cfi(reg1, c-&gt;as_jint());
1310         }
<span class="line-modified">1311       } else if (c-&gt;type() == T_OBJECT || c-&gt;type() == T_ARRAY) {</span>









1312         // In 64bit oops are single register.
1313         jobject o = c-&gt;as_jobject();
1314         if (o == NULL) {
1315           __ z_ltgr(reg1, reg1);
1316         } else {
1317           jobject2reg(o, Z_R1_scratch);
1318           __ z_cgr(reg1, Z_R1_scratch);
1319         }
1320       } else {
1321         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
1322       }
1323       // cpu register - address
1324     } else if (opr2-&gt;is_address()) {
1325       if (op-&gt;info() != NULL) {
1326         add_debug_info_for_null_check_here(op-&gt;info());
1327       }
1328       if (unsigned_comp) {
1329         __ z_cly(reg1, as_Address(opr2-&gt;as_address_ptr()));
1330       } else {
1331         __ z_cy(reg1, as_Address(opr2-&gt;as_address_ptr()));
</pre>
<hr />
<pre>
1660     assert(code == lir_add, &quot;unsupported operation&quot;);
1661     assert(right-&gt;is_constant(), &quot;unsupported operand&quot;);
1662     jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
1663     LIR_Address* lir_addr = left-&gt;as_address_ptr();
1664     Address addr = as_Address(lir_addr);
1665     switch (lir_addr-&gt;type()) {
1666       case T_INT:
1667         __ add2mem_32(addr, c, Z_R1_scratch);
1668         break;
1669       case T_LONG:
1670         __ add2mem_64(addr, c, Z_R1_scratch);
1671         break;
1672       default:
1673         ShouldNotReachHere();
1674     }
1675   } else {
1676     ShouldNotReachHere();
1677   }
1678 }
1679 
<span class="line-removed">1680 void LIR_Assembler::fpop() {</span>
<span class="line-removed">1681   // do nothing</span>
<span class="line-removed">1682 }</span>
<span class="line-removed">1683 </span>
1684 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
1685   switch (code) {
1686     case lir_sqrt: {
1687       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for dsqrt&quot;);
1688       FloatRegister src_reg = value-&gt;as_double_reg();
1689       FloatRegister dst_reg = dest-&gt;as_double_reg();
1690       __ z_sqdbr(dst_reg, src_reg);
1691       break;
1692     }
1693     case lir_abs: {
1694       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for fabs&quot;);
1695       FloatRegister src_reg = value-&gt;as_double_reg();
1696       FloatRegister dst_reg = dest-&gt;as_double_reg();
1697       __ z_lpdbr(dst_reg, src_reg);
1698       break;
1699     }
1700     default: {
1701       ShouldNotReachHere();
1702       break;
1703     }
</pre>
<hr />
<pre>
1734     }
1735     move_regs(reg, dst-&gt;as_register());
1736   } else {
1737     Register l_lo = left-&gt;as_register_lo();
1738     if (right-&gt;is_constant()) {
1739       __ load_const_optimized(Z_R1_scratch, right-&gt;as_constant_ptr()-&gt;as_jlong());
1740       switch (code) {
1741         case lir_logic_and:
1742           __ z_ngr(l_lo, Z_R1_scratch);
1743           break;
1744         case lir_logic_or:
1745           __ z_ogr(l_lo, Z_R1_scratch);
1746           break;
1747         case lir_logic_xor:
1748           __ z_xgr(l_lo, Z_R1_scratch);
1749           break;
1750         default: ShouldNotReachHere();
1751       }
1752     } else {
1753       Register r_lo;
<span class="line-modified">1754       if (right-&gt;type() == T_OBJECT || right-&gt;type() == T_ARRAY) {</span>
1755         r_lo = right-&gt;as_register();
1756       } else {
1757         r_lo = right-&gt;as_register_lo();
1758       }
1759       switch (code) {
1760         case lir_logic_and:
1761           __ z_ngr(l_lo, r_lo);
1762           break;
1763         case lir_logic_or:
1764           __ z_ogr(l_lo, r_lo);
1765           break;
1766         case lir_logic_xor:
1767           __ z_xgr(l_lo, r_lo);
1768           break;
1769         default: ShouldNotReachHere();
1770       }
1771     }
1772 
1773     Register dst_lo = dst-&gt;as_register_lo();
1774 
1775     move_regs(l_lo, dst_lo);
1776   }
1777 }
1778 
1779 // See operand selection in LIRGenerator::do_ArithmeticOp_Int().
1780 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
1781   if (left-&gt;is_double_cpu()) {
1782     // 64 bit integer case
1783     assert(left-&gt;is_double_cpu(), &quot;left must be register&quot;);
<span class="line-modified">1784     assert(right-&gt;is_double_cpu() || is_power_of_2_long(right-&gt;as_jlong()),</span>
1785            &quot;right must be register or power of 2 constant&quot;);
1786     assert(result-&gt;is_double_cpu(), &quot;result must be register&quot;);
1787 
1788     Register lreg = left-&gt;as_register_lo();
1789     Register dreg = result-&gt;as_register_lo();
1790 
1791     if (right-&gt;is_constant()) {
1792       // Convert division by a power of two into some shifts and logical operations.
1793       Register treg1 = Z_R0_scratch;
1794       Register treg2 = Z_R1_scratch;
1795       jlong divisor = right-&gt;as_jlong();
1796       jlong log_divisor = log2_long(right-&gt;as_jlong());
1797 
1798       if (divisor == min_jlong) {
1799         // Min_jlong is special. Result is &#39;0&#39; except for min_jlong/min_jlong = 1.
1800         if (dreg == lreg) {
1801           NearLabel done;
1802           __ load_const_optimized(treg2, min_jlong);
1803           __ z_cgr(lreg, treg2);
1804           __ z_lghi(dreg, 0);           // Preserves condition code.
</pre>
<hr />
<pre>
1952   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
1953   Register length  = op-&gt;length()-&gt;as_register();
1954   Register tmp = op-&gt;tmp()-&gt;as_register();
1955 
1956   CodeStub* stub = op-&gt;stub();
1957   int flags = op-&gt;flags();
1958   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
1959   if (basic_type == T_ARRAY) basic_type = T_OBJECT;
1960 
1961   // If we don&#39;t know anything, just go through the generic arraycopy.
1962   if (default_type == NULL) {
1963     address copyfunc_addr = StubRoutines::generic_arraycopy();
1964 
1965     if (copyfunc_addr == NULL) {
1966       // Take a slow path for generic arraycopy.
1967       __ branch_optimized(Assembler::bcondAlways, *stub-&gt;entry());
1968       __ bind(*stub-&gt;continuation());
1969       return;
1970     }
1971 
<span class="line-removed">1972     Label done;</span>
1973     // Save outgoing arguments in callee saved registers (C convention) in case
1974     // a call to System.arraycopy is needed.
1975     Register callee_saved_src     = Z_R10;
1976     Register callee_saved_src_pos = Z_R11;
1977     Register callee_saved_dst     = Z_R12;
1978     Register callee_saved_dst_pos = Z_R13;
1979     Register callee_saved_length  = Z_ARG5; // Z_ARG5 == Z_R6 is callee saved.
1980 
1981     __ lgr_if_needed(callee_saved_src, src);
1982     __ lgr_if_needed(callee_saved_src_pos, src_pos);
1983     __ lgr_if_needed(callee_saved_dst, dst);
1984     __ lgr_if_needed(callee_saved_dst_pos, dst_pos);
1985     __ lgr_if_needed(callee_saved_length, length);
1986 
1987     // C function requires 64 bit values.
1988     __ z_lgfr(src_pos, src_pos);
1989     __ z_lgfr(dst_pos, dst_pos);
1990     __ z_lgfr(length, length);
1991 
1992     // Pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint.
</pre>
<hr />
<pre>
2124       } else {
2125         __ z_lg(tmp, src_klass_addr);
2126         __ z_cg(tmp, dst_klass_addr);
2127       }
2128       __ branch_optimized(Assembler::bcondNotEqual, *stub-&gt;entry());
2129     } else {
2130       // For object arrays, if src is a sub class of dst then we can
2131       // safely do the copy.
2132       NearLabel cont, slow;
2133       Register src_klass = Z_R1_scratch;
2134       Register dst_klass = Z_R10;
2135 
2136       __ load_klass(src_klass, src);
2137       __ load_klass(dst_klass, dst);
2138 
2139       __ check_klass_subtype_fast_path(src_klass, dst_klass, tmp, &amp;cont, &amp;slow, NULL);
2140 
2141       store_parameter(src_klass, 0); // sub
2142       store_parameter(dst_klass, 1); // super
2143       emit_call_c(Runtime1::entry_for (Runtime1::slow_subtype_check_id));
<span class="line-modified">2144       CHECK_BAILOUT();</span>
2145       // Sets condition code 0 for match (2 otherwise).
2146       __ branch_optimized(Assembler::bcondEqual, cont);
2147 
2148       __ bind(slow);
2149 
2150       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2151       if (copyfunc_addr != NULL) { // use stub if available
2152         // Src is not a sub class of dst so we have to do a
2153         // per-element check.
2154 
2155         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2156         if ((flags &amp; mask) != mask) {
2157           // Check that at least both of them object arrays.
2158           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2159 
2160           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2161             __ load_klass(tmp, src);
2162           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2163             __ load_klass(tmp, dst);
2164           }
</pre>
<hr />
<pre>
2183         __ lgr_if_needed(callee_saved_dst_pos, dst_pos);
2184         __ lgr_if_needed(callee_saved_length, length);
2185 
2186         __ z_llgfr(length, length); // Higher 32bits must be null.
2187 
2188         __ z_sllg(Z_ARG1, src_pos, shift_amount); // index -&gt; byte offset
2189         __ z_sllg(Z_ARG2, dst_pos, shift_amount); // index -&gt; byte offset
2190 
2191         __ z_la(Z_ARG1, Address(src, Z_ARG1, arrayOopDesc::base_offset_in_bytes(basic_type)));
2192         assert_different_registers(Z_ARG1, dst, dst_pos, length);
2193         __ z_la(Z_ARG2, Address(dst, Z_ARG2, arrayOopDesc::base_offset_in_bytes(basic_type)));
2194         assert_different_registers(Z_ARG2, dst, length);
2195 
2196         __ z_lgr(Z_ARG3, length);
2197         assert_different_registers(Z_ARG3, dst);
2198 
2199         __ load_klass(Z_ARG5, dst);
2200         __ z_lg(Z_ARG5, Address(Z_ARG5, ObjArrayKlass::element_klass_offset()));
2201         __ z_lg(Z_ARG4, Address(Z_ARG5, Klass::super_check_offset_offset()));
2202         emit_call_c(copyfunc_addr);
<span class="line-modified">2203         CHECK_BAILOUT();</span>
2204 
2205 #ifndef PRODUCT
2206         if (PrintC1Statistics) {
2207           NearLabel failed;
2208           __ compareU32_and_branch(Z_RET, (intptr_t)0, Assembler::bcondNotEqual, failed);
2209           __ load_const_optimized(Z_R1_scratch, (address)&amp;Runtime1::_arraycopy_checkcast_cnt);
2210           __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);
2211           __ bind(failed);
2212         }
2213 #endif
2214 
2215         __ compareU32_and_branch(Z_RET, (intptr_t)0, Assembler::bcondEqual, *stub-&gt;continuation());
2216 
2217 #ifndef PRODUCT
2218         if (PrintC1Statistics) {
2219           __ load_const_optimized(Z_R1_scratch, (address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt);
2220           __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);
2221         }
2222 #endif
2223 
</pre>
<hr />
<pre>
2373   if (op-&gt;init_check()) {
2374     // Make sure klass is initialized &amp; doesn&#39;t have finalizer.
2375     const int state_offset = in_bytes(InstanceKlass::init_state_offset());
2376     Register iklass = op-&gt;klass()-&gt;as_register();
2377     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
2378     if (Immediate::is_uimm12(state_offset)) {
2379       __ z_cli(state_offset, iklass, InstanceKlass::fully_initialized);
2380     } else {
2381       __ z_cliy(state_offset, iklass, InstanceKlass::fully_initialized);
2382     }
2383     __ branch_optimized(Assembler::bcondNotEqual, *op-&gt;stub()-&gt;entry()); // Use long branch, because slow_case might be far.
2384   }
2385   __ allocate_object(op-&gt;obj()-&gt;as_register(),
2386                      op-&gt;tmp1()-&gt;as_register(),
2387                      op-&gt;tmp2()-&gt;as_register(),
2388                      op-&gt;header_size(),
2389                      op-&gt;object_size(),
2390                      op-&gt;klass()-&gt;as_register(),
2391                      *op-&gt;stub()-&gt;entry());
2392   __ bind(*op-&gt;stub()-&gt;continuation());
<span class="line-modified">2393   __ verify_oop(op-&gt;obj()-&gt;as_register());</span>
2394 }
2395 
2396 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
2397   Register len = op-&gt;len()-&gt;as_register();
2398   __ move_reg_if_needed(len, T_LONG, len, T_INT); // sign extend
2399 
2400   if (UseSlowPath ||
<span class="line-modified">2401       (!UseFastNewObjectArray &amp;&amp; (op-&gt;type() == T_OBJECT || op-&gt;type() == T_ARRAY)) ||</span>
<span class="line-modified">2402       (!UseFastNewTypeArray   &amp;&amp; (op-&gt;type() != T_OBJECT &amp;&amp; op-&gt;type() != T_ARRAY))) {</span>
2403     __ z_brul(*op-&gt;stub()-&gt;entry());
2404   } else {
2405     __ allocate_array(op-&gt;obj()-&gt;as_register(),
2406                       op-&gt;len()-&gt;as_register(),
2407                       op-&gt;tmp1()-&gt;as_register(),
2408                       op-&gt;tmp2()-&gt;as_register(),
2409                       arrayOopDesc::header_size(op-&gt;type()),
2410                       type2aelembytes(op-&gt;type()),
2411                       op-&gt;klass()-&gt;as_register(),
2412                       *op-&gt;stub()-&gt;entry());
2413   }
2414   __ bind(*op-&gt;stub()-&gt;continuation());
2415 }
2416 
2417 void LIR_Assembler::type_profile_helper(Register mdo, ciMethodData *md, ciProfileData *data,
2418                                         Register recv, Register tmp1, Label* update_done) {
2419   uint i;
2420   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2421     Label next_test;
2422     // See if the receiver is receiver[n].
</pre>
<hr />
<pre>
2509     __ or2mem_8(data_addr, header_bits);
2510     __ branch_optimized(Assembler::bcondAlways, *obj_is_null);
2511     __ bind(not_null);
2512   } else {
2513     __ compareU64_and_branch(obj, (intptr_t) 0, Assembler::bcondEqual, *obj_is_null);
2514   }
2515 
2516   NearLabel profile_cast_failure, profile_cast_success;
2517   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
2518   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
2519 
2520   // Patching may screw with our temporaries on sparc,
2521   // so let&#39;s do it before loading the class.
2522   if (k-&gt;is_loaded()) {
2523     metadata2reg(k-&gt;constant_encoding(), k_RInfo);
2524   } else {
2525     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
2526   }
2527   assert(obj != k_RInfo, &quot;must be different&quot;);
2528 
<span class="line-modified">2529   __ verify_oop(obj);</span>
2530 
2531   // Get object class.
2532   // Not a safepoint as obj null check happens earlier.
2533   if (op-&gt;fast_check()) {
2534     if (UseCompressedClassPointers) {
2535       __ load_klass(klass_RInfo, obj);
2536       __ compareU64_and_branch(k_RInfo, klass_RInfo, Assembler::bcondNotEqual, *failure_target);
2537     } else {
2538       __ z_cg(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
2539       __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
2540     }
2541     // Successful cast, fall through to profile or jump.
2542   } else {
2543     bool need_slow_path = !k-&gt;is_loaded() ||
2544                           ((int) k-&gt;super_check_offset() == in_bytes(Klass::secondary_super_cache_offset()));
2545     intptr_t super_check_offset = k-&gt;is_loaded() ? k-&gt;super_check_offset() : -1L;
2546     __ load_klass(klass_RInfo, obj);
2547     // Perform the fast part of the checking logic.
2548     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1,
2549                                      (need_slow_path ? success_target : NULL),
2550                                      failure_target, NULL,
2551                                      RegisterOrConstant(super_check_offset));
2552     if (need_slow_path) {
2553       // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2554       address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
2555       store_parameter(klass_RInfo, 0); // sub
2556       store_parameter(k_RInfo, 1);     // super
2557       emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
<span class="line-modified">2558       CHECK_BAILOUT();</span>
2559       __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
2560       // Fall through to success case.
2561     }
2562   }
2563 
2564   if (op-&gt;should_profile()) {
2565     Register mdo = klass_RInfo, recv = k_RInfo;
2566     assert_different_registers(obj, mdo, recv);
2567     __ bind(profile_cast_success);
2568     metadata2reg(md-&gt;constant_encoding(), mdo);
2569     __ load_klass(recv, obj);
2570     type_profile_helper(mdo, md, data, recv, Rtmp1, success);
2571     __ branch_optimized(Assembler::bcondAlways, *success);
2572 
2573     __ bind(profile_cast_failure);
2574     metadata2reg(md-&gt;constant_encoding(), mdo);
2575     __ add2mem_64(Address(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset())), -(int)DataLayout::counter_increment, Rtmp1);
2576     __ branch_optimized(Assembler::bcondAlways, *failure);
2577   } else {
2578     __ branch_optimized(Assembler::bcondAlways, *success);
</pre>
<hr />
<pre>
2621       __ or2mem_8(data_addr, header_bits);
2622       __ branch_optimized(Assembler::bcondAlways, done);
2623       __ bind(not_null);
2624     } else {
2625       __ compareU64_and_branch(value, (intptr_t) 0, Assembler::bcondEqual, done);
2626     }
2627 
2628     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
2629     __ load_klass(k_RInfo, array);
2630     __ load_klass(klass_RInfo, value);
2631 
2632     // Get instance klass (it&#39;s already uncompressed).
2633     __ z_lg(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
2634     // Perform the fast part of the checking logic.
2635     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
2636     // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2637     address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
2638     store_parameter(klass_RInfo, 0); // sub
2639     store_parameter(k_RInfo, 1);     // super
2640     emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
<span class="line-modified">2641     CHECK_BAILOUT();</span>
2642     __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
2643     // Fall through to success case.
2644 
2645     if (op-&gt;should_profile()) {
2646       Register mdo = klass_RInfo, recv = k_RInfo;
2647       assert_different_registers(value, mdo, recv);
2648       __ bind(profile_cast_success);
2649       metadata2reg(md-&gt;constant_encoding(), mdo);
2650       __ load_klass(recv, value);
2651       type_profile_helper(mdo, md, data, recv, Rtmp1, &amp;done);
2652       __ branch_optimized(Assembler::bcondAlways, done);
2653 
2654       __ bind(profile_cast_failure);
2655       metadata2reg(md-&gt;constant_encoding(), mdo);
2656       __ add2mem_64(Address(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset())), -(int)DataLayout::counter_increment, Rtmp1);
2657       __ branch_optimized(Assembler::bcondAlways, *stub-&gt;entry());
2658     }
2659 
2660     __ bind(done);
2661   } else {
</pre>
<hr />
<pre>
2702       if (UseCompressedOops) {
2703                  t1_cmp = op-&gt;tmp1()-&gt;as_register();
2704         Register t2_new = op-&gt;tmp2()-&gt;as_register();
2705         assert_different_registers(cmp_value, new_value, addr, t1_cmp, t2_new);
2706         __ oop_encoder(t1_cmp, cmp_value, true /*maybe null*/);
2707         __ oop_encoder(t2_new, new_value, true /*maybe null*/);
2708         __ z_cs(t1_cmp, t2_new, 0, addr);
2709       } else {
2710         __ z_lgr(t1_cmp, cmp_value);
2711         __ z_csg(t1_cmp, new_value, 0, addr);
2712       }
2713     } else {
2714       __ z_lr(t1_cmp, cmp_value);
2715       __ z_cs(t1_cmp, new_value, 0, addr);
2716     }
2717   } else {
2718     ShouldNotReachHere(); // new lir_cas_??
2719   }
2720 }
2721 
<span class="line-removed">2722 void LIR_Assembler::set_24bit_FPU() {</span>
<span class="line-removed">2723   ShouldNotCallThis(); // x86 only</span>
<span class="line-removed">2724 }</span>
<span class="line-removed">2725 </span>
<span class="line-removed">2726 void LIR_Assembler::reset_FPU() {</span>
<span class="line-removed">2727   ShouldNotCallThis(); // x86 only</span>
<span class="line-removed">2728 }</span>
<span class="line-removed">2729 </span>
2730 void LIR_Assembler::breakpoint() {
2731   Unimplemented();
2732   //  __ breakpoint_trap();
2733 }
2734 
2735 void LIR_Assembler::push(LIR_Opr opr) {
2736   ShouldNotCallThis(); // unused
2737 }
2738 
2739 void LIR_Assembler::pop(LIR_Opr opr) {
2740   ShouldNotCallThis(); // unused
2741 }
2742 
2743 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst_opr) {
2744   Address addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
2745   __ add2reg(dst_opr-&gt;as_register(), addr.disp(), addr.base());
2746 }
2747 
2748 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2749   Register obj = op-&gt;obj_opr()-&gt;as_register();  // May not be an oop.
</pre>
<hr />
<pre>
2850   ShouldNotCallThis(); // There are no delay slots on ZARCH_64.
2851 }
2852 
2853 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
2854   // tmp must be unused
2855   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2856   assert(left-&gt;is_register(), &quot;can only handle registers&quot;);
2857 
2858   if (left-&gt;is_single_cpu()) {
2859     __ z_lcr(dest-&gt;as_register(), left-&gt;as_register());
2860   } else if (left-&gt;is_single_fpu()) {
2861     __ z_lcebr(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
2862   } else if (left-&gt;is_double_fpu()) {
2863     __ z_lcdbr(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
2864   } else {
2865     assert(left-&gt;is_double_cpu(), &quot;Must be a long&quot;);
2866     __ z_lcgr(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
2867   }
2868 }
2869 
<span class="line-removed">2870 void LIR_Assembler::fxch(int i) {</span>
<span class="line-removed">2871   ShouldNotCallThis(); // x86 only</span>
<span class="line-removed">2872 }</span>
<span class="line-removed">2873 </span>
<span class="line-removed">2874 void LIR_Assembler::fld(int i) {</span>
<span class="line-removed">2875   ShouldNotCallThis(); // x86 only</span>
<span class="line-removed">2876 }</span>
<span class="line-removed">2877 </span>
<span class="line-removed">2878 void LIR_Assembler::ffree(int i) {</span>
<span class="line-removed">2879   ShouldNotCallThis(); // x86 only</span>
<span class="line-removed">2880 }</span>
<span class="line-removed">2881 </span>
2882 void LIR_Assembler::rt_call(LIR_Opr result, address dest,
2883                             const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
2884   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
2885   emit_call_c(dest);
2886   CHECK_BAILOUT();
2887   if (info != NULL) {
2888     add_call_info_here(info);
2889   }
2890 }
2891 
2892 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
2893   ShouldNotCallThis(); // not needed on ZARCH_64
2894 }
2895 
2896 void LIR_Assembler::membar() {
2897   __ z_fence();
2898 }
2899 
2900 void LIR_Assembler::membar_acquire() {
2901   __ z_acquire();
</pre>
<hr />
<pre>
2970 
2971 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
2972   Register obj = op-&gt;obj()-&gt;as_register();
2973   Register tmp1 = op-&gt;tmp()-&gt;as_pointer_register();
2974   Register tmp2 = Z_R1_scratch;
2975   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
2976   ciKlass* exact_klass = op-&gt;exact_klass();
2977   intptr_t current_klass = op-&gt;current_klass();
2978   bool not_null = op-&gt;not_null();
2979   bool no_conflict = op-&gt;no_conflict();
2980 
2981   Label update, next, none, null_seen, init_klass;
2982 
2983   bool do_null = !not_null;
2984   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
2985   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
2986 
2987   assert(do_null || do_update, &quot;why are we here?&quot;);
2988   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
2989 
<span class="line-modified">2990   __ verify_oop(obj);</span>
2991 
2992   if (do_null || tmp1 != obj DEBUG_ONLY(|| true)) {
2993     __ z_ltgr(tmp1, obj);
2994   }
2995   if (do_null) {
2996     __ z_brnz(update);
2997     if (!TypeEntries::was_null_seen(current_klass)) {
2998       __ z_lg(tmp1, mdo_addr);
2999       __ z_oill(tmp1, TypeEntries::null_seen);
3000       __ z_stg(tmp1, mdo_addr);
3001     }
3002     if (do_update) {
3003       __ z_bru(next);
3004     }
3005   } else {
3006     __ asm_assert_ne(&quot;unexpect null obj&quot;, __LINE__);
3007   }
3008 
3009   __ bind(update);
3010 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
<span class="line-modified">  36 #include &quot;memory/universe.hpp&quot;</span>

  37 #include &quot;nativeInst_s390.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
<span class="line-added">  42 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  43 #include &quot;vmreg_s390.inline.hpp&quot;
  44 
  45 #define __ _masm-&gt;
  46 
  47 #ifndef PRODUCT
  48 #undef __
  49 #define __ (Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm) : _masm)-&gt;
  50 #endif
  51 
  52 //------------------------------------------------------------
  53 
  54 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  55   // Not used on ZARCH_64
  56   ShouldNotCallThis();
  57   return false;
  58 }
  59 
  60 LIR_Opr LIR_Assembler::receiverOpr() {
  61   return FrameMap::Z_R2_oop_opr;
  62 }
  63 
  64 LIR_Opr LIR_Assembler::osrBufferPointer() {
  65   return FrameMap::Z_R2_opr;
  66 }
  67 
  68 int LIR_Assembler::initial_frame_size_in_bytes() const {
  69   return in_bytes(frame_map()-&gt;framesize_in_bytes());
  70 }
  71 
  72 // Inline cache check: done before the frame is built.
  73 // The inline cached class is in Z_inline_cache(Z_R9).
  74 // We fetch the class of the receiver and compare it with the cached class.
  75 // If they do not match we jump to the slow case.
  76 int LIR_Assembler::check_icache() {
  77   Register receiver = receiverOpr()-&gt;as_register();
  78   int offset = __ offset();
  79   __ inline_cache_check(receiver, Z_inline_cache);
  80   return offset;
  81 }
  82 
<span class="line-added">  83 void LIR_Assembler::clinit_barrier(ciMethod* method) {</span>
<span class="line-added">  84   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-added">  85 </span>
<span class="line-added">  86   Label L_skip_barrier;</span>
<span class="line-added">  87   Register klass = Z_R1_scratch;</span>
<span class="line-added">  88 </span>
<span class="line-added">  89   metadata2reg(method-&gt;holder()-&gt;constant_encoding(), klass);</span>
<span class="line-added">  90   __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added">  91 </span>
<span class="line-added">  92   __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());</span>
<span class="line-added">  93   __ z_br(klass);</span>
<span class="line-added">  94 </span>
<span class="line-added">  95   __ bind(L_skip_barrier);</span>
<span class="line-added">  96 }</span>
<span class="line-added">  97 </span>
  98 void LIR_Assembler::osr_entry() {
  99   // On-stack-replacement entry sequence (interpreter frame layout described in interpreter_sparc.cpp):
 100   //
 101   //   1. Create a new compiled activation.
 102   //   2. Initialize local variables in the compiled activation. The expression stack must be empty
 103   //      at the osr_bci; it is not initialized.
 104   //   3. Jump to the continuation address in compiled code to resume execution.
 105 
 106   // OSR entry point
 107   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 108   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 109   ValueStack* entry_state = osr_entry-&gt;end()-&gt;state();
 110   int number_of_locks = entry_state-&gt;locks_size();
 111 
 112   // Create a frame for the compiled activation.
 113   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 114 
 115   // OSR buffer is
 116   //
 117   // locals[nlocals-1..0]
</pre>
<hr />
<pre>
 879 
 880 // 4-byte accesses only! Don&#39;t use it to access 8 bytes!
 881 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 882   ShouldNotCallThis();
 883   return 0; // unused
 884 }
 885 
 886 void LIR_Assembler::mem2reg(LIR_Opr src_opr, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code,
 887                             CodeEmitInfo* info, bool wide, bool unaligned) {
 888 
 889   assert(type != T_METADATA, &quot;load of metadata ptr not supported&quot;);
 890   LIR_Address* addr = src_opr-&gt;as_address_ptr();
 891   LIR_Opr to_reg = dest;
 892 
 893   Register src = addr-&gt;base()-&gt;as_pointer_register();
 894   Register disp_reg = Z_R0;
 895   int disp_value = addr-&gt;disp();
 896   bool needs_patching = (patch_code != lir_patch_none);
 897 
 898   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
<span class="line-modified"> 899     __ verify_oop(src, FILE_AND_LINE);</span>
 900   }
 901 
 902   PatchingStub* patch = NULL;
 903   if (needs_patching) {
 904     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 905     assert(!to_reg-&gt;is_double_cpu() ||
 906            patch_code == lir_patch_none ||
 907            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
 908   }
 909 
 910   if (addr-&gt;index()-&gt;is_illegal()) {
 911     if (!Immediate::is_simm20(disp_value)) {
 912       if (needs_patching) {
 913         __ load_const(Z_R1_scratch, (intptr_t)0);
 914       } else {
 915         __ load_const_optimized(Z_R1_scratch, disp_value);
 916       }
 917       disp_reg = Z_R1_scratch;
 918       disp_value = 0;
 919     }
</pre>
<hr />
<pre>
 954                     __ z_ly(dest-&gt;as_register(),   disp_value, disp_reg, src);
 955       }
 956       break;
 957     case T_ADDRESS:
 958       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
 959         __ z_llgf(dest-&gt;as_register(), disp_value, disp_reg, src);
 960         __ decode_klass_not_null(dest-&gt;as_register());
 961       } else {
 962         __ z_lg(dest-&gt;as_register(), disp_value, disp_reg, src);
 963       }
 964       break;
 965     case T_ARRAY : // fall through
 966     case T_OBJECT:
 967     {
 968       if (UseCompressedOops &amp;&amp; !wide) {
 969         __ z_llgf(dest-&gt;as_register(), disp_value, disp_reg, src);
 970         __ oop_decoder(dest-&gt;as_register(), dest-&gt;as_register(), true);
 971       } else {
 972         __ z_lg(dest-&gt;as_register(), disp_value, disp_reg, src);
 973       }
<span class="line-added"> 974       __ verify_oop(dest-&gt;as_register(), FILE_AND_LINE);</span>
 975       break;
 976     }
 977     case T_FLOAT:
 978       if (short_disp) {
 979                     __ z_le(dest-&gt;as_float_reg(),  disp_value, disp_reg, src);
 980       } else {
 981                     __ z_ley(dest-&gt;as_float_reg(), disp_value, disp_reg, src);
 982       }
 983       break;
 984     case T_DOUBLE:
 985       if (short_disp) {
 986                     __ z_ld(dest-&gt;as_double_reg(),  disp_value, disp_reg, src);
 987       } else {
 988                     __ z_ldy(dest-&gt;as_double_reg(), disp_value, disp_reg, src);
 989       }
 990       break;
 991     case T_LONG  :  __ z_lg(dest-&gt;as_register_lo(), disp_value, disp_reg, src); break;
 992     default      : ShouldNotReachHere();
 993   }



 994 
 995   if (patch != NULL) {
 996     patching_epilog(patch, patch_code, src, info);
 997   }
 998   if (info != NULL) add_debug_info_for_null_check(offset, info);
 999 }
1000 
1001 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1002   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
1003   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1004 
1005   if (dest-&gt;is_single_cpu()) {
<span class="line-modified">1006     if (is_reference_type(type)) {</span>
1007       __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), true);
<span class="line-modified">1008       __ verify_oop(dest-&gt;as_register(), FILE_AND_LINE);</span>
<span class="line-modified">1009     } else if (type == T_METADATA || type == T_ADDRESS) {</span>
1010       __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), true);
1011     } else {
1012       __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), false);
1013     }
1014   } else if (dest-&gt;is_double_cpu()) {
1015     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1016     __ mem2reg_opt(dest-&gt;as_register_lo(), src_addr_LO, true);
1017   } else if (dest-&gt;is_single_fpu()) {
1018     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1019     __ mem2freg_opt(dest-&gt;as_float_reg(), src_addr, false);
1020   } else if (dest-&gt;is_double_fpu()) {
1021     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1022     __ mem2freg_opt(dest-&gt;as_double_reg(), src_addr, true);
1023   } else {
1024     ShouldNotReachHere();
1025   }
1026 }
1027 
1028 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
1029   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
1030   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
1031 
1032   if (src-&gt;is_single_cpu()) {
1033     const Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
<span class="line-modified">1034     if (is_reference_type(type)) {</span>
<span class="line-modified">1035       __ verify_oop(src-&gt;as_register(), FILE_AND_LINE);</span>
1036       __ reg2mem_opt(src-&gt;as_register(), dst, true);
<span class="line-modified">1037     } else if (type == T_METADATA || type == T_ADDRESS) {</span>
1038       __ reg2mem_opt(src-&gt;as_register(), dst, true);
1039     } else {
1040       __ reg2mem_opt(src-&gt;as_register(), dst, false);
1041     }
1042   } else if (src-&gt;is_double_cpu()) {
1043     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1044     __ reg2mem_opt(src-&gt;as_register_lo(), dstLO, true);
1045   } else if (src-&gt;is_single_fpu()) {
1046     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1047     __ freg2mem_opt(src-&gt;as_float_reg(), dst_addr, false);
1048   } else if (src-&gt;is_double_fpu()) {
1049     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1050     __ freg2mem_opt(src-&gt;as_double_reg(), dst_addr, true);
1051   } else {
1052     ShouldNotReachHere();
1053   }
1054 }
1055 
1056 void LIR_Assembler::reg2reg(LIR_Opr from_reg, LIR_Opr to_reg) {
1057   if (from_reg-&gt;is_float_kind() &amp;&amp; to_reg-&gt;is_float_kind()) {
</pre>
<hr />
<pre>
1060       assert(to_reg-&gt;is_double_fpu(), &quot;should match&quot;);
1061       __ z_ldr(to_reg-&gt;as_double_reg(), from_reg-&gt;as_double_reg());
1062     } else {
1063       // float to float moves
1064       assert(to_reg-&gt;is_single_fpu(), &quot;should match&quot;);
1065       __ z_ler(to_reg-&gt;as_float_reg(), from_reg-&gt;as_float_reg());
1066     }
1067   } else if (!from_reg-&gt;is_float_kind() &amp;&amp; !to_reg-&gt;is_float_kind()) {
1068     if (from_reg-&gt;is_double_cpu()) {
1069       __ z_lgr(to_reg-&gt;as_pointer_register(), from_reg-&gt;as_pointer_register());
1070     } else if (to_reg-&gt;is_double_cpu()) {
1071       // int to int moves
1072       __ z_lgr(to_reg-&gt;as_register_lo(), from_reg-&gt;as_register());
1073     } else {
1074       // int to int moves
1075       __ z_lgr(to_reg-&gt;as_register(), from_reg-&gt;as_register());
1076     }
1077   } else {
1078     ShouldNotReachHere();
1079   }
<span class="line-modified">1080   if (is_reference_type(to_reg-&gt;type())) {</span>
<span class="line-modified">1081     __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);</span>
1082   }
1083 }
1084 
1085 void LIR_Assembler::reg2mem(LIR_Opr from, LIR_Opr dest_opr, BasicType type,
1086                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
1087                             bool wide, bool unaligned) {
1088   assert(type != T_METADATA, &quot;store of metadata ptr not supported&quot;);
1089   LIR_Address* addr = dest_opr-&gt;as_address_ptr();
1090 
1091   Register dest = addr-&gt;base()-&gt;as_pointer_register();
1092   Register disp_reg = Z_R0;
1093   int disp_value = addr-&gt;disp();
1094   bool needs_patching = (patch_code != lir_patch_none);
1095 
1096   if (addr-&gt;base()-&gt;is_oop_register()) {
<span class="line-modified">1097     __ verify_oop(dest, FILE_AND_LINE);</span>
1098   }
1099 
1100   PatchingStub* patch = NULL;
1101   if (needs_patching) {
1102     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1103     assert(!from-&gt;is_double_cpu() ||
1104            patch_code == lir_patch_none ||
1105            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1106   }
1107 
1108   assert(!needs_patching || (!Immediate::is_simm20(disp_value) &amp;&amp; addr-&gt;index()-&gt;is_illegal()), &quot;assumption&quot;);
1109   if (addr-&gt;index()-&gt;is_illegal()) {
1110     if (!Immediate::is_simm20(disp_value)) {
1111       if (needs_patching) {
1112         __ load_const(Z_R1_scratch, (intptr_t)0);
1113       } else {
1114         __ load_const_optimized(Z_R1_scratch, disp_value);
1115       }
1116       disp_reg = Z_R1_scratch;
1117       disp_value = 0;
1118     }
1119   } else {
1120     if (!Immediate::is_simm20(disp_value)) {
1121       __ load_const_optimized(Z_R1_scratch, disp_value);
1122       __ z_la(Z_R1_scratch, 0, Z_R1_scratch, addr-&gt;index()-&gt;as_register());
1123       disp_reg = Z_R1_scratch;
1124       disp_value = 0;
1125     }
1126     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1127   }
1128 
1129   assert(disp_reg != Z_R0 || Immediate::is_simm20(disp_value), &quot;should have set this up&quot;);
1130 
<span class="line-modified">1131   if (is_reference_type(type)) {</span>
<span class="line-modified">1132     __ verify_oop(from-&gt;as_register(), FILE_AND_LINE);</span>
1133   }
1134 
1135   bool short_disp = Immediate::is_uimm12(disp_value);
1136 
1137   // Remember the offset of the store. The patching_epilog must be done
1138   // before the call to add_debug_info_for_null_check, otherwise the PcDescs don&#39;t get
1139   // entered in increasing order.
1140   int offset = code_offset();
1141   switch (type) {
1142     case T_BOOLEAN: // fall through
1143     case T_BYTE  :
1144       if (short_disp) {
1145                     __ z_stc(from-&gt;as_register(),  disp_value, disp_reg, dest);
1146       } else {
1147                     __ z_stcy(from-&gt;as_register(), disp_value, disp_reg, dest);
1148       }
1149       break;
1150     case T_CHAR  : // fall through
1151     case T_SHORT :
1152       if (short_disp) {
</pre>
<hr />
<pre>
1274 
1275   __ set_inst_mark();
1276   AddressLiteral a((address)-1);
1277   success = success &amp;&amp; __ load_const_from_toc(Z_R1, a);
1278   if (!success) {
1279     bailout(&quot;const section overflow&quot;);
1280     return;
1281   }
1282 
1283   __ z_br(Z_R1);
1284   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
1285   __ end_a_stub(); // Update current stubs pointer and restore insts_end.
1286 }
1287 
1288 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1289   bool unsigned_comp = condition == lir_cond_belowEqual || condition == lir_cond_aboveEqual;
1290   if (opr1-&gt;is_single_cpu()) {
1291     Register reg1 = opr1-&gt;as_register();
1292     if (opr2-&gt;is_single_cpu()) {
1293       // cpu register - cpu register
<span class="line-modified">1294       if (is_reference_type(opr1-&gt;type())) {</span>
1295         __ z_clgr(reg1, opr2-&gt;as_register());
1296       } else {
<span class="line-modified">1297         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);</span>
1298         if (unsigned_comp) {
1299           __ z_clr(reg1, opr2-&gt;as_register());
1300         } else {
1301           __ z_cr(reg1, opr2-&gt;as_register());
1302         }
1303       }
1304     } else if (opr2-&gt;is_stack()) {
1305       // cpu register - stack
<span class="line-modified">1306       if (is_reference_type(opr1-&gt;type())) {</span>
1307         __ z_cg(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
1308       } else {
1309         if (unsigned_comp) {
1310           __ z_cly(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
1311         } else {
1312           __ z_cy(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
1313         }
1314       }
1315     } else if (opr2-&gt;is_constant()) {
1316       // cpu register - constant
1317       LIR_Const* c = opr2-&gt;as_constant_ptr();
1318       if (c-&gt;type() == T_INT) {
1319         if (unsigned_comp) {
1320           __ z_clfi(reg1, c-&gt;as_jint());
1321         } else {
1322           __ z_cfi(reg1, c-&gt;as_jint());
1323         }
<span class="line-modified">1324       } else if (c-&gt;type() == T_METADATA) {</span>
<span class="line-added">1325         // We only need, for now, comparison with NULL for metadata.</span>
<span class="line-added">1326         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);</span>
<span class="line-added">1327         Metadata* m = c-&gt;as_metadata();</span>
<span class="line-added">1328         if (m == NULL) {</span>
<span class="line-added">1329           __ z_cghi(reg1, 0);</span>
<span class="line-added">1330         } else {</span>
<span class="line-added">1331           ShouldNotReachHere();</span>
<span class="line-added">1332         }</span>
<span class="line-added">1333       } else if (is_reference_type(c-&gt;type())) {</span>
1334         // In 64bit oops are single register.
1335         jobject o = c-&gt;as_jobject();
1336         if (o == NULL) {
1337           __ z_ltgr(reg1, reg1);
1338         } else {
1339           jobject2reg(o, Z_R1_scratch);
1340           __ z_cgr(reg1, Z_R1_scratch);
1341         }
1342       } else {
1343         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
1344       }
1345       // cpu register - address
1346     } else if (opr2-&gt;is_address()) {
1347       if (op-&gt;info() != NULL) {
1348         add_debug_info_for_null_check_here(op-&gt;info());
1349       }
1350       if (unsigned_comp) {
1351         __ z_cly(reg1, as_Address(opr2-&gt;as_address_ptr()));
1352       } else {
1353         __ z_cy(reg1, as_Address(opr2-&gt;as_address_ptr()));
</pre>
<hr />
<pre>
1682     assert(code == lir_add, &quot;unsupported operation&quot;);
1683     assert(right-&gt;is_constant(), &quot;unsupported operand&quot;);
1684     jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
1685     LIR_Address* lir_addr = left-&gt;as_address_ptr();
1686     Address addr = as_Address(lir_addr);
1687     switch (lir_addr-&gt;type()) {
1688       case T_INT:
1689         __ add2mem_32(addr, c, Z_R1_scratch);
1690         break;
1691       case T_LONG:
1692         __ add2mem_64(addr, c, Z_R1_scratch);
1693         break;
1694       default:
1695         ShouldNotReachHere();
1696     }
1697   } else {
1698     ShouldNotReachHere();
1699   }
1700 }
1701 




1702 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
1703   switch (code) {
1704     case lir_sqrt: {
1705       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for dsqrt&quot;);
1706       FloatRegister src_reg = value-&gt;as_double_reg();
1707       FloatRegister dst_reg = dest-&gt;as_double_reg();
1708       __ z_sqdbr(dst_reg, src_reg);
1709       break;
1710     }
1711     case lir_abs: {
1712       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for fabs&quot;);
1713       FloatRegister src_reg = value-&gt;as_double_reg();
1714       FloatRegister dst_reg = dest-&gt;as_double_reg();
1715       __ z_lpdbr(dst_reg, src_reg);
1716       break;
1717     }
1718     default: {
1719       ShouldNotReachHere();
1720       break;
1721     }
</pre>
<hr />
<pre>
1752     }
1753     move_regs(reg, dst-&gt;as_register());
1754   } else {
1755     Register l_lo = left-&gt;as_register_lo();
1756     if (right-&gt;is_constant()) {
1757       __ load_const_optimized(Z_R1_scratch, right-&gt;as_constant_ptr()-&gt;as_jlong());
1758       switch (code) {
1759         case lir_logic_and:
1760           __ z_ngr(l_lo, Z_R1_scratch);
1761           break;
1762         case lir_logic_or:
1763           __ z_ogr(l_lo, Z_R1_scratch);
1764           break;
1765         case lir_logic_xor:
1766           __ z_xgr(l_lo, Z_R1_scratch);
1767           break;
1768         default: ShouldNotReachHere();
1769       }
1770     } else {
1771       Register r_lo;
<span class="line-modified">1772       if (is_reference_type(right-&gt;type())) {</span>
1773         r_lo = right-&gt;as_register();
1774       } else {
1775         r_lo = right-&gt;as_register_lo();
1776       }
1777       switch (code) {
1778         case lir_logic_and:
1779           __ z_ngr(l_lo, r_lo);
1780           break;
1781         case lir_logic_or:
1782           __ z_ogr(l_lo, r_lo);
1783           break;
1784         case lir_logic_xor:
1785           __ z_xgr(l_lo, r_lo);
1786           break;
1787         default: ShouldNotReachHere();
1788       }
1789     }
1790 
1791     Register dst_lo = dst-&gt;as_register_lo();
1792 
1793     move_regs(l_lo, dst_lo);
1794   }
1795 }
1796 
1797 // See operand selection in LIRGenerator::do_ArithmeticOp_Int().
1798 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
1799   if (left-&gt;is_double_cpu()) {
1800     // 64 bit integer case
1801     assert(left-&gt;is_double_cpu(), &quot;left must be register&quot;);
<span class="line-modified">1802     assert(right-&gt;is_double_cpu() || is_power_of_2(right-&gt;as_jlong()),</span>
1803            &quot;right must be register or power of 2 constant&quot;);
1804     assert(result-&gt;is_double_cpu(), &quot;result must be register&quot;);
1805 
1806     Register lreg = left-&gt;as_register_lo();
1807     Register dreg = result-&gt;as_register_lo();
1808 
1809     if (right-&gt;is_constant()) {
1810       // Convert division by a power of two into some shifts and logical operations.
1811       Register treg1 = Z_R0_scratch;
1812       Register treg2 = Z_R1_scratch;
1813       jlong divisor = right-&gt;as_jlong();
1814       jlong log_divisor = log2_long(right-&gt;as_jlong());
1815 
1816       if (divisor == min_jlong) {
1817         // Min_jlong is special. Result is &#39;0&#39; except for min_jlong/min_jlong = 1.
1818         if (dreg == lreg) {
1819           NearLabel done;
1820           __ load_const_optimized(treg2, min_jlong);
1821           __ z_cgr(lreg, treg2);
1822           __ z_lghi(dreg, 0);           // Preserves condition code.
</pre>
<hr />
<pre>
1970   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
1971   Register length  = op-&gt;length()-&gt;as_register();
1972   Register tmp = op-&gt;tmp()-&gt;as_register();
1973 
1974   CodeStub* stub = op-&gt;stub();
1975   int flags = op-&gt;flags();
1976   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
1977   if (basic_type == T_ARRAY) basic_type = T_OBJECT;
1978 
1979   // If we don&#39;t know anything, just go through the generic arraycopy.
1980   if (default_type == NULL) {
1981     address copyfunc_addr = StubRoutines::generic_arraycopy();
1982 
1983     if (copyfunc_addr == NULL) {
1984       // Take a slow path for generic arraycopy.
1985       __ branch_optimized(Assembler::bcondAlways, *stub-&gt;entry());
1986       __ bind(*stub-&gt;continuation());
1987       return;
1988     }
1989 

1990     // Save outgoing arguments in callee saved registers (C convention) in case
1991     // a call to System.arraycopy is needed.
1992     Register callee_saved_src     = Z_R10;
1993     Register callee_saved_src_pos = Z_R11;
1994     Register callee_saved_dst     = Z_R12;
1995     Register callee_saved_dst_pos = Z_R13;
1996     Register callee_saved_length  = Z_ARG5; // Z_ARG5 == Z_R6 is callee saved.
1997 
1998     __ lgr_if_needed(callee_saved_src, src);
1999     __ lgr_if_needed(callee_saved_src_pos, src_pos);
2000     __ lgr_if_needed(callee_saved_dst, dst);
2001     __ lgr_if_needed(callee_saved_dst_pos, dst_pos);
2002     __ lgr_if_needed(callee_saved_length, length);
2003 
2004     // C function requires 64 bit values.
2005     __ z_lgfr(src_pos, src_pos);
2006     __ z_lgfr(dst_pos, dst_pos);
2007     __ z_lgfr(length, length);
2008 
2009     // Pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint.
</pre>
<hr />
<pre>
2141       } else {
2142         __ z_lg(tmp, src_klass_addr);
2143         __ z_cg(tmp, dst_klass_addr);
2144       }
2145       __ branch_optimized(Assembler::bcondNotEqual, *stub-&gt;entry());
2146     } else {
2147       // For object arrays, if src is a sub class of dst then we can
2148       // safely do the copy.
2149       NearLabel cont, slow;
2150       Register src_klass = Z_R1_scratch;
2151       Register dst_klass = Z_R10;
2152 
2153       __ load_klass(src_klass, src);
2154       __ load_klass(dst_klass, dst);
2155 
2156       __ check_klass_subtype_fast_path(src_klass, dst_klass, tmp, &amp;cont, &amp;slow, NULL);
2157 
2158       store_parameter(src_klass, 0); // sub
2159       store_parameter(dst_klass, 1); // super
2160       emit_call_c(Runtime1::entry_for (Runtime1::slow_subtype_check_id));
<span class="line-modified">2161       CHECK_BAILOUT2(cont, slow);</span>
2162       // Sets condition code 0 for match (2 otherwise).
2163       __ branch_optimized(Assembler::bcondEqual, cont);
2164 
2165       __ bind(slow);
2166 
2167       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2168       if (copyfunc_addr != NULL) { // use stub if available
2169         // Src is not a sub class of dst so we have to do a
2170         // per-element check.
2171 
2172         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2173         if ((flags &amp; mask) != mask) {
2174           // Check that at least both of them object arrays.
2175           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2176 
2177           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2178             __ load_klass(tmp, src);
2179           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2180             __ load_klass(tmp, dst);
2181           }
</pre>
<hr />
<pre>
2200         __ lgr_if_needed(callee_saved_dst_pos, dst_pos);
2201         __ lgr_if_needed(callee_saved_length, length);
2202 
2203         __ z_llgfr(length, length); // Higher 32bits must be null.
2204 
2205         __ z_sllg(Z_ARG1, src_pos, shift_amount); // index -&gt; byte offset
2206         __ z_sllg(Z_ARG2, dst_pos, shift_amount); // index -&gt; byte offset
2207 
2208         __ z_la(Z_ARG1, Address(src, Z_ARG1, arrayOopDesc::base_offset_in_bytes(basic_type)));
2209         assert_different_registers(Z_ARG1, dst, dst_pos, length);
2210         __ z_la(Z_ARG2, Address(dst, Z_ARG2, arrayOopDesc::base_offset_in_bytes(basic_type)));
2211         assert_different_registers(Z_ARG2, dst, length);
2212 
2213         __ z_lgr(Z_ARG3, length);
2214         assert_different_registers(Z_ARG3, dst);
2215 
2216         __ load_klass(Z_ARG5, dst);
2217         __ z_lg(Z_ARG5, Address(Z_ARG5, ObjArrayKlass::element_klass_offset()));
2218         __ z_lg(Z_ARG4, Address(Z_ARG5, Klass::super_check_offset_offset()));
2219         emit_call_c(copyfunc_addr);
<span class="line-modified">2220         CHECK_BAILOUT2(cont, slow);</span>
2221 
2222 #ifndef PRODUCT
2223         if (PrintC1Statistics) {
2224           NearLabel failed;
2225           __ compareU32_and_branch(Z_RET, (intptr_t)0, Assembler::bcondNotEqual, failed);
2226           __ load_const_optimized(Z_R1_scratch, (address)&amp;Runtime1::_arraycopy_checkcast_cnt);
2227           __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);
2228           __ bind(failed);
2229         }
2230 #endif
2231 
2232         __ compareU32_and_branch(Z_RET, (intptr_t)0, Assembler::bcondEqual, *stub-&gt;continuation());
2233 
2234 #ifndef PRODUCT
2235         if (PrintC1Statistics) {
2236           __ load_const_optimized(Z_R1_scratch, (address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt);
2237           __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);
2238         }
2239 #endif
2240 
</pre>
<hr />
<pre>
2390   if (op-&gt;init_check()) {
2391     // Make sure klass is initialized &amp; doesn&#39;t have finalizer.
2392     const int state_offset = in_bytes(InstanceKlass::init_state_offset());
2393     Register iklass = op-&gt;klass()-&gt;as_register();
2394     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
2395     if (Immediate::is_uimm12(state_offset)) {
2396       __ z_cli(state_offset, iklass, InstanceKlass::fully_initialized);
2397     } else {
2398       __ z_cliy(state_offset, iklass, InstanceKlass::fully_initialized);
2399     }
2400     __ branch_optimized(Assembler::bcondNotEqual, *op-&gt;stub()-&gt;entry()); // Use long branch, because slow_case might be far.
2401   }
2402   __ allocate_object(op-&gt;obj()-&gt;as_register(),
2403                      op-&gt;tmp1()-&gt;as_register(),
2404                      op-&gt;tmp2()-&gt;as_register(),
2405                      op-&gt;header_size(),
2406                      op-&gt;object_size(),
2407                      op-&gt;klass()-&gt;as_register(),
2408                      *op-&gt;stub()-&gt;entry());
2409   __ bind(*op-&gt;stub()-&gt;continuation());
<span class="line-modified">2410   __ verify_oop(op-&gt;obj()-&gt;as_register(), FILE_AND_LINE);</span>
2411 }
2412 
2413 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
2414   Register len = op-&gt;len()-&gt;as_register();
2415   __ move_reg_if_needed(len, T_LONG, len, T_INT); // sign extend
2416 
2417   if (UseSlowPath ||
<span class="line-modified">2418       (!UseFastNewObjectArray &amp;&amp; (is_reference_type(op-&gt;type()))) ||</span>
<span class="line-modified">2419       (!UseFastNewTypeArray   &amp;&amp; (!is_reference_type(op-&gt;type())))) {</span>
2420     __ z_brul(*op-&gt;stub()-&gt;entry());
2421   } else {
2422     __ allocate_array(op-&gt;obj()-&gt;as_register(),
2423                       op-&gt;len()-&gt;as_register(),
2424                       op-&gt;tmp1()-&gt;as_register(),
2425                       op-&gt;tmp2()-&gt;as_register(),
2426                       arrayOopDesc::header_size(op-&gt;type()),
2427                       type2aelembytes(op-&gt;type()),
2428                       op-&gt;klass()-&gt;as_register(),
2429                       *op-&gt;stub()-&gt;entry());
2430   }
2431   __ bind(*op-&gt;stub()-&gt;continuation());
2432 }
2433 
2434 void LIR_Assembler::type_profile_helper(Register mdo, ciMethodData *md, ciProfileData *data,
2435                                         Register recv, Register tmp1, Label* update_done) {
2436   uint i;
2437   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2438     Label next_test;
2439     // See if the receiver is receiver[n].
</pre>
<hr />
<pre>
2526     __ or2mem_8(data_addr, header_bits);
2527     __ branch_optimized(Assembler::bcondAlways, *obj_is_null);
2528     __ bind(not_null);
2529   } else {
2530     __ compareU64_and_branch(obj, (intptr_t) 0, Assembler::bcondEqual, *obj_is_null);
2531   }
2532 
2533   NearLabel profile_cast_failure, profile_cast_success;
2534   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
2535   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
2536 
2537   // Patching may screw with our temporaries on sparc,
2538   // so let&#39;s do it before loading the class.
2539   if (k-&gt;is_loaded()) {
2540     metadata2reg(k-&gt;constant_encoding(), k_RInfo);
2541   } else {
2542     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
2543   }
2544   assert(obj != k_RInfo, &quot;must be different&quot;);
2545 
<span class="line-modified">2546   __ verify_oop(obj, FILE_AND_LINE);</span>
2547 
2548   // Get object class.
2549   // Not a safepoint as obj null check happens earlier.
2550   if (op-&gt;fast_check()) {
2551     if (UseCompressedClassPointers) {
2552       __ load_klass(klass_RInfo, obj);
2553       __ compareU64_and_branch(k_RInfo, klass_RInfo, Assembler::bcondNotEqual, *failure_target);
2554     } else {
2555       __ z_cg(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
2556       __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
2557     }
2558     // Successful cast, fall through to profile or jump.
2559   } else {
2560     bool need_slow_path = !k-&gt;is_loaded() ||
2561                           ((int) k-&gt;super_check_offset() == in_bytes(Klass::secondary_super_cache_offset()));
2562     intptr_t super_check_offset = k-&gt;is_loaded() ? k-&gt;super_check_offset() : -1L;
2563     __ load_klass(klass_RInfo, obj);
2564     // Perform the fast part of the checking logic.
2565     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1,
2566                                      (need_slow_path ? success_target : NULL),
2567                                      failure_target, NULL,
2568                                      RegisterOrConstant(super_check_offset));
2569     if (need_slow_path) {
2570       // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2571       address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
2572       store_parameter(klass_RInfo, 0); // sub
2573       store_parameter(k_RInfo, 1);     // super
2574       emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
<span class="line-modified">2575       CHECK_BAILOUT2(profile_cast_failure, profile_cast_success);</span>
2576       __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
2577       // Fall through to success case.
2578     }
2579   }
2580 
2581   if (op-&gt;should_profile()) {
2582     Register mdo = klass_RInfo, recv = k_RInfo;
2583     assert_different_registers(obj, mdo, recv);
2584     __ bind(profile_cast_success);
2585     metadata2reg(md-&gt;constant_encoding(), mdo);
2586     __ load_klass(recv, obj);
2587     type_profile_helper(mdo, md, data, recv, Rtmp1, success);
2588     __ branch_optimized(Assembler::bcondAlways, *success);
2589 
2590     __ bind(profile_cast_failure);
2591     metadata2reg(md-&gt;constant_encoding(), mdo);
2592     __ add2mem_64(Address(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset())), -(int)DataLayout::counter_increment, Rtmp1);
2593     __ branch_optimized(Assembler::bcondAlways, *failure);
2594   } else {
2595     __ branch_optimized(Assembler::bcondAlways, *success);
</pre>
<hr />
<pre>
2638       __ or2mem_8(data_addr, header_bits);
2639       __ branch_optimized(Assembler::bcondAlways, done);
2640       __ bind(not_null);
2641     } else {
2642       __ compareU64_and_branch(value, (intptr_t) 0, Assembler::bcondEqual, done);
2643     }
2644 
2645     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
2646     __ load_klass(k_RInfo, array);
2647     __ load_klass(klass_RInfo, value);
2648 
2649     // Get instance klass (it&#39;s already uncompressed).
2650     __ z_lg(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
2651     // Perform the fast part of the checking logic.
2652     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
2653     // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2654     address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
2655     store_parameter(klass_RInfo, 0); // sub
2656     store_parameter(k_RInfo, 1);     // super
2657     emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
<span class="line-modified">2658     CHECK_BAILOUT3(profile_cast_success, profile_cast_failure, done);</span>
2659     __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
2660     // Fall through to success case.
2661 
2662     if (op-&gt;should_profile()) {
2663       Register mdo = klass_RInfo, recv = k_RInfo;
2664       assert_different_registers(value, mdo, recv);
2665       __ bind(profile_cast_success);
2666       metadata2reg(md-&gt;constant_encoding(), mdo);
2667       __ load_klass(recv, value);
2668       type_profile_helper(mdo, md, data, recv, Rtmp1, &amp;done);
2669       __ branch_optimized(Assembler::bcondAlways, done);
2670 
2671       __ bind(profile_cast_failure);
2672       metadata2reg(md-&gt;constant_encoding(), mdo);
2673       __ add2mem_64(Address(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset())), -(int)DataLayout::counter_increment, Rtmp1);
2674       __ branch_optimized(Assembler::bcondAlways, *stub-&gt;entry());
2675     }
2676 
2677     __ bind(done);
2678   } else {
</pre>
<hr />
<pre>
2719       if (UseCompressedOops) {
2720                  t1_cmp = op-&gt;tmp1()-&gt;as_register();
2721         Register t2_new = op-&gt;tmp2()-&gt;as_register();
2722         assert_different_registers(cmp_value, new_value, addr, t1_cmp, t2_new);
2723         __ oop_encoder(t1_cmp, cmp_value, true /*maybe null*/);
2724         __ oop_encoder(t2_new, new_value, true /*maybe null*/);
2725         __ z_cs(t1_cmp, t2_new, 0, addr);
2726       } else {
2727         __ z_lgr(t1_cmp, cmp_value);
2728         __ z_csg(t1_cmp, new_value, 0, addr);
2729       }
2730     } else {
2731       __ z_lr(t1_cmp, cmp_value);
2732       __ z_cs(t1_cmp, new_value, 0, addr);
2733     }
2734   } else {
2735     ShouldNotReachHere(); // new lir_cas_??
2736   }
2737 }
2738 








2739 void LIR_Assembler::breakpoint() {
2740   Unimplemented();
2741   //  __ breakpoint_trap();
2742 }
2743 
2744 void LIR_Assembler::push(LIR_Opr opr) {
2745   ShouldNotCallThis(); // unused
2746 }
2747 
2748 void LIR_Assembler::pop(LIR_Opr opr) {
2749   ShouldNotCallThis(); // unused
2750 }
2751 
2752 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst_opr) {
2753   Address addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
2754   __ add2reg(dst_opr-&gt;as_register(), addr.disp(), addr.base());
2755 }
2756 
2757 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2758   Register obj = op-&gt;obj_opr()-&gt;as_register();  // May not be an oop.
</pre>
<hr />
<pre>
2859   ShouldNotCallThis(); // There are no delay slots on ZARCH_64.
2860 }
2861 
2862 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
2863   // tmp must be unused
2864   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2865   assert(left-&gt;is_register(), &quot;can only handle registers&quot;);
2866 
2867   if (left-&gt;is_single_cpu()) {
2868     __ z_lcr(dest-&gt;as_register(), left-&gt;as_register());
2869   } else if (left-&gt;is_single_fpu()) {
2870     __ z_lcebr(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
2871   } else if (left-&gt;is_double_fpu()) {
2872     __ z_lcdbr(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
2873   } else {
2874     assert(left-&gt;is_double_cpu(), &quot;Must be a long&quot;);
2875     __ z_lcgr(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
2876   }
2877 }
2878 












2879 void LIR_Assembler::rt_call(LIR_Opr result, address dest,
2880                             const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
2881   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
2882   emit_call_c(dest);
2883   CHECK_BAILOUT();
2884   if (info != NULL) {
2885     add_call_info_here(info);
2886   }
2887 }
2888 
2889 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
2890   ShouldNotCallThis(); // not needed on ZARCH_64
2891 }
2892 
2893 void LIR_Assembler::membar() {
2894   __ z_fence();
2895 }
2896 
2897 void LIR_Assembler::membar_acquire() {
2898   __ z_acquire();
</pre>
<hr />
<pre>
2967 
2968 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
2969   Register obj = op-&gt;obj()-&gt;as_register();
2970   Register tmp1 = op-&gt;tmp()-&gt;as_pointer_register();
2971   Register tmp2 = Z_R1_scratch;
2972   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
2973   ciKlass* exact_klass = op-&gt;exact_klass();
2974   intptr_t current_klass = op-&gt;current_klass();
2975   bool not_null = op-&gt;not_null();
2976   bool no_conflict = op-&gt;no_conflict();
2977 
2978   Label update, next, none, null_seen, init_klass;
2979 
2980   bool do_null = !not_null;
2981   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
2982   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
2983 
2984   assert(do_null || do_update, &quot;why are we here?&quot;);
2985   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
2986 
<span class="line-modified">2987   __ verify_oop(obj, FILE_AND_LINE);</span>
2988 
2989   if (do_null || tmp1 != obj DEBUG_ONLY(|| true)) {
2990     __ z_ltgr(tmp1, obj);
2991   }
2992   if (do_null) {
2993     __ z_brnz(update);
2994     if (!TypeEntries::was_null_seen(current_klass)) {
2995       __ z_lg(tmp1, mdo_addr);
2996       __ z_oill(tmp1, TypeEntries::null_seen);
2997       __ z_stg(tmp1, mdo_addr);
2998     }
2999     if (do_update) {
3000       __ z_bru(next);
3001     }
3002   } else {
3003     __ asm_assert_ne(&quot;unexpect null obj&quot;, __LINE__);
3004   }
3005 
3006   __ bind(update);
3007 
</pre>
</td>
</tr>
</table>
<center><a href="c1_FrameMap_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
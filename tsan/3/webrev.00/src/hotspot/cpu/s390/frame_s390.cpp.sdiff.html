<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/frame_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="disassembler_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/g1/g1BarrierSetAssembler_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/frame_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;interpreter/interpreter.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified"> 29 #include &quot;oops/markOop.hpp&quot;</span>

 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/frame.inline.hpp&quot;
 32 #include &quot;runtime/handles.inline.hpp&quot;
 33 #include &quot;runtime/javaCalls.hpp&quot;
 34 #include &quot;runtime/monitorChunk.hpp&quot;
 35 #include &quot;runtime/os.inline.hpp&quot;
 36 #include &quot;runtime/signature.hpp&quot;
 37 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 38 #include &quot;runtime/stubRoutines.hpp&quot;
 39 #include &quot;vmreg_s390.inline.hpp&quot;
 40 #ifdef COMPILER1
 41 #include &quot;c1/c1_Runtime1.hpp&quot;
 42 #include &quot;runtime/vframeArray.hpp&quot;
 43 #endif
 44 
 45 // Major contributions by Aha, AS.
 46 
 47 #ifdef ASSERT
 48 void RegisterMap::check_location_valid() {
 49 }
 50 #endif // ASSERT
 51 
 52 
 53 // Profiling/safepoint support
 54 
 55 bool frame::safe_for_sender(JavaThread *thread) {
 56   bool safe = false;
 57   address sp = (address)_sp;
 58   address fp = (address)_fp;
 59   address unextended_sp = (address)_unextended_sp;
 60 
<span class="line-modified"> 61   // Consider stack guards when trying to determine &quot;safe&quot; stack pointers</span>
<span class="line-removed"> 62   static size_t stack_guard_size = os::uses_stack_guard_pages() ?</span>
<span class="line-removed"> 63     JavaThread::stack_red_zone_size() + JavaThread::stack_yellow_reserved_zone_size() : 0;</span>
<span class="line-removed"> 64   size_t usable_stack_size = thread-&gt;stack_size() - stack_guard_size;</span>
<span class="line-removed"> 65 </span>
 66   // sp must be within the usable part of the stack (not in guards)
<span class="line-modified"> 67   bool sp_safe = (sp &lt; thread-&gt;stack_base()) &amp;&amp;</span>
<span class="line-removed"> 68                  (sp &gt;= thread-&gt;stack_base() - usable_stack_size);</span>
<span class="line-removed"> 69 </span>
<span class="line-removed"> 70 </span>
<span class="line-removed"> 71   if (!sp_safe) {</span>
 72     return false;
 73   }
 74 
 75   // Unextended sp must be within the stack
 76   bool unextended_sp_safe = (unextended_sp &lt; thread-&gt;stack_base());
 77 
 78   if (!unextended_sp_safe) {
 79     return false;
 80   }
 81 
 82   // An fp must be within the stack and above (but not equal) sp.
<span class="line-modified"> 83   bool fp_safe = (fp &lt;= thread-&gt;stack_base()) &amp;&amp;  (fp &gt; sp);</span>
 84   // An interpreter fp must be within the stack and above (but not equal) sp.
 85   // Moreover, it must be at least the size of the z_ijava_state structure.
<span class="line-modified"> 86   bool fp_interp_safe = (fp &lt;= thread-&gt;stack_base()) &amp;&amp; (fp &gt; sp) &amp;&amp;</span>
 87     ((fp - sp) &gt;= z_ijava_state_size);
 88 
 89   // We know sp/unextended_sp are safe, only fp is questionable here
 90 
 91   // If the current frame is known to the code cache then we can attempt to
 92   // to construct the sender and do some validation of it. This goes a long way
 93   // toward eliminating issues when we get in frame construction code
 94 
 95   if (_cb != NULL ) {
 96     // Entry frame checks
 97     if (is_entry_frame()) {
 98       // An entry frame must have a valid fp.
 99       return fp_safe &amp;&amp; is_entry_frame_valid(thread);
100     }
101 
102     // Now check if the frame is complete and the test is
103     // reliable. Unfortunately we can only check frame completeness for
104     // runtime stubs. Other generic buffer blobs are more
105     // problematic so we just assume they are OK. Adapter blobs never have a
106     // complete frame and are never OK. nmethods should be OK on s390.
</pre>
<hr />
<pre>
126     // We must always be able to find a recognizable pc.
127     CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);
128     if (sender_blob == NULL) {
129       return false;
130     }
131 
132     // Could be a zombie method
133     if (sender_blob-&gt;is_zombie() || sender_blob-&gt;is_unloaded()) {
134       return false;
135     }
136 
137     // It should be safe to construct the sender though it might not be valid.
138 
139     frame sender(sender_sp, sender_pc);
140 
141     // Do we have a valid fp?
142     address sender_fp = (address) sender.fp();
143 
144     // sender_fp must be within the stack and above (but not
145     // equal) current frame&#39;s fp.
<span class="line-modified">146     if (sender_fp &gt; thread-&gt;stack_base() || sender_fp &lt;= fp) {</span>
147         return false;
148     }
149 
150     // If the potential sender is the interpreter then we can do some more checking.
151     if (Interpreter::contains(sender_pc)) {
152       return sender.is_interpreted_frame_valid(thread);
153     }
154 
155     // Could just be some random pointer within the codeBlob.
156     if (!sender.cb()-&gt;code_contains(sender_pc)) {
157       return false;
158     }
159 
160     // We should never be able to see an adapter if the current frame is something from code cache.
161     if (sender_blob-&gt;is_adapter_blob()) {
162       return false;
163     }
164 
165     if (sender.is_entry_frame()) {
166       return sender.is_entry_frame_valid(thread);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;interpreter/interpreter.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-modified"> 29 #include &quot;memory/universe.hpp&quot;</span>
<span class="line-added"> 30 #include &quot;oops/markWord.hpp&quot;</span>
 31 #include &quot;oops/oop.inline.hpp&quot;
 32 #include &quot;runtime/frame.inline.hpp&quot;
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/javaCalls.hpp&quot;
 35 #include &quot;runtime/monitorChunk.hpp&quot;
 36 #include &quot;runtime/os.inline.hpp&quot;
 37 #include &quot;runtime/signature.hpp&quot;
 38 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 39 #include &quot;runtime/stubRoutines.hpp&quot;
 40 #include &quot;vmreg_s390.inline.hpp&quot;
 41 #ifdef COMPILER1
 42 #include &quot;c1/c1_Runtime1.hpp&quot;
 43 #include &quot;runtime/vframeArray.hpp&quot;
 44 #endif
 45 
 46 // Major contributions by Aha, AS.
 47 
 48 #ifdef ASSERT
 49 void RegisterMap::check_location_valid() {
 50 }
 51 #endif // ASSERT
 52 
 53 
 54 // Profiling/safepoint support
 55 
 56 bool frame::safe_for_sender(JavaThread *thread) {
 57   bool safe = false;
 58   address sp = (address)_sp;
 59   address fp = (address)_fp;
 60   address unextended_sp = (address)_unextended_sp;
 61 
<span class="line-modified"> 62   // consider stack guards when trying to determine &quot;safe&quot; stack pointers</span>




 63   // sp must be within the usable part of the stack (not in guards)
<span class="line-modified"> 64   if (!thread-&gt;is_in_usable_stack(sp)) {</span>




 65     return false;
 66   }
 67 
 68   // Unextended sp must be within the stack
 69   bool unextended_sp_safe = (unextended_sp &lt; thread-&gt;stack_base());
 70 
 71   if (!unextended_sp_safe) {
 72     return false;
 73   }
 74 
 75   // An fp must be within the stack and above (but not equal) sp.
<span class="line-modified"> 76   bool fp_safe = (fp &lt; thread-&gt;stack_base()) &amp;&amp; (fp &gt; sp);</span>
 77   // An interpreter fp must be within the stack and above (but not equal) sp.
 78   // Moreover, it must be at least the size of the z_ijava_state structure.
<span class="line-modified"> 79   bool fp_interp_safe = (fp &lt; thread-&gt;stack_base()) &amp;&amp; (fp &gt; sp) &amp;&amp;</span>
 80     ((fp - sp) &gt;= z_ijava_state_size);
 81 
 82   // We know sp/unextended_sp are safe, only fp is questionable here
 83 
 84   // If the current frame is known to the code cache then we can attempt to
 85   // to construct the sender and do some validation of it. This goes a long way
 86   // toward eliminating issues when we get in frame construction code
 87 
 88   if (_cb != NULL ) {
 89     // Entry frame checks
 90     if (is_entry_frame()) {
 91       // An entry frame must have a valid fp.
 92       return fp_safe &amp;&amp; is_entry_frame_valid(thread);
 93     }
 94 
 95     // Now check if the frame is complete and the test is
 96     // reliable. Unfortunately we can only check frame completeness for
 97     // runtime stubs. Other generic buffer blobs are more
 98     // problematic so we just assume they are OK. Adapter blobs never have a
 99     // complete frame and are never OK. nmethods should be OK on s390.
</pre>
<hr />
<pre>
119     // We must always be able to find a recognizable pc.
120     CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);
121     if (sender_blob == NULL) {
122       return false;
123     }
124 
125     // Could be a zombie method
126     if (sender_blob-&gt;is_zombie() || sender_blob-&gt;is_unloaded()) {
127       return false;
128     }
129 
130     // It should be safe to construct the sender though it might not be valid.
131 
132     frame sender(sender_sp, sender_pc);
133 
134     // Do we have a valid fp?
135     address sender_fp = (address) sender.fp();
136 
137     // sender_fp must be within the stack and above (but not
138     // equal) current frame&#39;s fp.
<span class="line-modified">139     if (sender_fp &gt;= thread-&gt;stack_base() || sender_fp &lt;= fp) {</span>
140         return false;
141     }
142 
143     // If the potential sender is the interpreter then we can do some more checking.
144     if (Interpreter::contains(sender_pc)) {
145       return sender.is_interpreted_frame_valid(thread);
146     }
147 
148     // Could just be some random pointer within the codeBlob.
149     if (!sender.cb()-&gt;code_contains(sender_pc)) {
150       return false;
151     }
152 
153     // We should never be able to see an adapter if the current frame is something from code cache.
154     if (sender_blob-&gt;is_adapter_blob()) {
155       return false;
156     }
157 
158     if (sender.is_entry_frame()) {
159       return sender.is_entry_frame_valid(thread);
</pre>
</td>
</tr>
</table>
<center><a href="disassembler_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/g1/g1BarrierSetAssembler_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
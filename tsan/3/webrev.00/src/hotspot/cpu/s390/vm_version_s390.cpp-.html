<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/s390/vm_version_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2016, 2019 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;code/compiledIC.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;runtime/java.hpp&quot;
  33 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  34 #include &quot;vm_version_s390.hpp&quot;
  35 
  36 # include &lt;sys/sysinfo.h&gt;
  37 
  38 bool VM_Version::_is_determine_features_test_running  = false;
  39 const char*   VM_Version::_model_string;
  40 
  41 unsigned long VM_Version::_features[_features_buffer_len]           = {0, 0, 0, 0};
  42 unsigned long VM_Version::_cipher_features[_features_buffer_len]    = {0, 0, 0, 0};
  43 unsigned long VM_Version::_msgdigest_features[_features_buffer_len] = {0, 0, 0, 0};
  44 unsigned int  VM_Version::_nfeatures                                = 0;
  45 unsigned int  VM_Version::_ncipher_features                         = 0;
  46 unsigned int  VM_Version::_nmsgdigest_features                      = 0;
  47 unsigned int  VM_Version::_Dcache_lineSize                          = 256;
  48 unsigned int  VM_Version::_Icache_lineSize                          = 256;
  49 
  50 static const char* z_gen[]     = {&quot;  &quot;,   &quot;G1&quot;,   &quot;G2&quot;, &quot;G3&quot;,    &quot;G4&quot;,     &quot;G5&quot;,      &quot;G6&quot;,   &quot;G7&quot;   };
  51 static const char* z_machine[] = {&quot;  &quot;, &quot;2064&quot;, &quot;2084&quot;, &quot;2094&quot;,  &quot;2097&quot;,   &quot;2817&quot;,    &quot;  &quot;,   &quot;2964&quot; };
  52 static const char* z_name[]    = {&quot;  &quot;, &quot;z900&quot;, &quot;z990&quot;, &quot;z9 EC&quot;, &quot;z10 EC&quot;, &quot;z196 EC&quot;, &quot;ec12&quot;, &quot;z13&quot;  };
  53 
  54 void VM_Version::initialize() {
  55   determine_features();      // Get processor capabilities.
  56   set_features_string();     // Set a descriptive feature indication.
  57 
  58   if (Verbose) {
  59     print_features();
  60   }
  61 
  62   intx cache_line_size = Dcache_lineSize(0);
  63 
  64   MaxVectorSize = 8;
  65 
  66   if (has_PrefetchRaw()) {
  67     if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {  // not preset
  68       // 0 = no prefetch.
  69       // 1 = Prefetch instructions for each allocation.
  70       // 2 = Use TLAB watermark to gate allocation prefetch.
  71       AllocatePrefetchStyle = 1;
  72     }
  73 
  74     if (AllocatePrefetchStyle &gt; 0) {  // Prefetching turned on at all?
  75       // Distance to prefetch ahead of allocation pointer.
  76       if (FLAG_IS_DEFAULT(AllocatePrefetchDistance) || (AllocatePrefetchDistance &lt; 0)) {  // not preset
  77         AllocatePrefetchDistance = 0;
  78       }
  79 
  80       // Number of lines to prefetch ahead of allocation pointer.
  81       if (FLAG_IS_DEFAULT(AllocatePrefetchLines) || (AllocatePrefetchLines &lt;= 0)) {      // not preset
  82         AllocatePrefetchLines = 3;
  83       }
  84 
  85       // Step size in bytes of sequential prefetch instructions.
  86       if (FLAG_IS_DEFAULT(AllocatePrefetchStepSize) || (AllocatePrefetchStepSize &lt;= 0)) { // not preset
  87         FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
  88       } else if (AllocatePrefetchStepSize &lt; cache_line_size) {
  89         FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
  90       } else {
  91         FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
  92       }
  93     } else {
  94       FLAG_SET_DEFAULT(AllocatePrefetchStyle, 0);
  95       AllocatePrefetchDistance = 0;
  96       AllocatePrefetchLines    = 0;
  97       // Can&#39;t be zero. Will SIGFPE during constraints checking.
  98       FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
  99     }
 100 
 101   } else {
 102     FLAG_SET_DEFAULT(AllocatePrefetchStyle, 0);
 103     AllocatePrefetchDistance = 0;
 104     AllocatePrefetchLines    = 0;
 105     // Can&#39;t be zero. Will SIGFPE during constraints checking.
 106     FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
 107   }
 108 
 109   // TODO:
 110   // On z/Architecture, cache line size is significantly large (256 bytes). Do we really need
 111   // to keep contended members that far apart? Performance tests are required.
 112   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &amp;&amp; (cache_line_size &gt; ContendedPaddingWidth)) {
 113     ContendedPaddingWidth = cache_line_size;
 114   }
 115 
 116   // On z/Architecture, the CRC32/CRC32C intrinsics are implemented &quot;by hand&quot;.
 117   // TODO: Provide implementation based on the vector instructions available from z13.
 118   // Note: The CHECKSUM instruction, which has been there since the very beginning
 119   //       (of z/Architecture), computes &quot;some kind of&quot; a checksum.
 120   //       It has nothing to do with the CRC32 algorithm.
 121   if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
 122     FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);
 123   }
 124   if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 125     FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
 126   }
 127 
 128   // TODO: Provide implementation.
 129   if (UseAdler32Intrinsics) {
 130     warning(&quot;Adler32Intrinsics not available on this CPU.&quot;);
 131     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
 132   }
 133 
 134   // On z/Architecture, we take UseAES as the general switch to enable/disable the AES intrinsics.
 135   // The specific, and yet to be defined, switches UseAESxxxIntrinsics will then be set
 136   // depending on the actual machine capabilities.
 137   // Explicitly setting them via CmdLine option takes precedence, of course.
 138   // TODO: UseAESIntrinsics must be made keylength specific.
 139   // As of March 2015 and Java8, only AES128 is supported by the Java Cryptographic Extensions.
 140   // Therefore, UseAESIntrinsics is of minimal use at the moment.
 141   if (FLAG_IS_DEFAULT(UseAES) &amp;&amp; has_Crypto_AES()) {
 142     FLAG_SET_DEFAULT(UseAES, true);
 143   }
 144   if (UseAES &amp;&amp; !has_Crypto_AES()) {
 145     warning(&quot;AES instructions are not available on this CPU&quot;);
 146     FLAG_SET_DEFAULT(UseAES, false);
 147   }
 148   if (UseAES) {
 149     if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 150       FLAG_SET_DEFAULT(UseAESIntrinsics, true);
 151     }
 152   }
 153   if (UseAESIntrinsics &amp;&amp; !has_Crypto_AES()) {
 154     warning(&quot;AES intrinsics are not available on this CPU&quot;);
 155     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 156   }
 157   if (UseAESIntrinsics &amp;&amp; !UseAES) {
 158     warning(&quot;AES intrinsics require UseAES flag to be enabled. Intrinsics will be disabled.&quot;);
 159     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 160   }
 161 
 162   // TODO: implement AES/CTR intrinsics
 163   if (UseAESCTRIntrinsics) {
 164     warning(&quot;AES/CTR intrinsics are not available on this CPU&quot;);
 165     FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 166   }
 167 
 168   if (FLAG_IS_DEFAULT(UseGHASHIntrinsics) &amp;&amp; has_Crypto_GHASH()) {
 169     FLAG_SET_DEFAULT(UseGHASHIntrinsics, true);
 170   }
 171   if (UseGHASHIntrinsics &amp;&amp; !has_Crypto_GHASH()) {
 172     warning(&quot;GHASH intrinsics are not available on this CPU&quot;);
 173     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
 174   }
 175 
 176   if (FLAG_IS_DEFAULT(UseFMA)) {
 177     FLAG_SET_DEFAULT(UseFMA, true);
 178   }
 179 
 180   // On z/Architecture, we take UseSHA as the general switch to enable/disable the SHA intrinsics.
 181   // The specific switches UseSHAxxxIntrinsics will then be set depending on the actual
 182   // machine capabilities.
 183   // Explicitly setting them via CmdLine option takes precedence, of course.
 184   if (FLAG_IS_DEFAULT(UseSHA) &amp;&amp; has_Crypto_SHA()) {
 185     FLAG_SET_DEFAULT(UseSHA, true);
 186   }
 187   if (UseSHA &amp;&amp; !has_Crypto_SHA()) {
 188     warning(&quot;SHA instructions are not available on this CPU&quot;);
 189     FLAG_SET_DEFAULT(UseSHA, false);
 190   }
 191   if (UseSHA &amp;&amp; has_Crypto_SHA1()) {
 192     if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {
 193       FLAG_SET_DEFAULT(UseSHA1Intrinsics, true);
 194     }
 195   } else if (UseSHA1Intrinsics) {
 196     warning(&quot;Intrinsics for SHA-1 crypto hash functions not available on this CPU.&quot;);
 197     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
 198   }
 199   if (UseSHA &amp;&amp; has_Crypto_SHA256()) {
 200     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
 201       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
 202     }
 203   } else if (UseSHA256Intrinsics) {
 204     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
 205     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 206   }
 207   if (UseSHA &amp;&amp; has_Crypto_SHA512()) {
 208     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
 209       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
 210     }
 211   } else if (UseSHA512Intrinsics) {
 212     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
 213     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 214   }
 215 
 216   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
 217     FLAG_SET_DEFAULT(UseSHA, false);
 218   }
 219 
 220   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
 221     FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);
 222   }
 223   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
 224     FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, true);
 225   }
 226   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
 227     FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, true);
 228   }
 229   if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
 230     FLAG_SET_DEFAULT(UsePopCountInstruction, true);
 231   }
 232 
 233   // z/Architecture supports 8-byte compare-exchange operations
 234   // (see Atomic::cmpxchg)
 235   // and &#39;atomic long memory ops&#39; (see Unsafe_GetLongVolatile).
 236   _supports_cx8 = true;
 237 
 238   _supports_atomic_getadd4 = VM_Version::has_LoadAndALUAtomicV1();
 239   _supports_atomic_getadd8 = VM_Version::has_LoadAndALUAtomicV1();
 240 
 241   // z/Architecture supports unaligned memory accesses.
 242   // Performance penalty is negligible. An additional tick or so
 243   // is lost if the accessed data spans a cache line boundary.
 244   // Unaligned accesses are not atomic, of course.
 245   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
 246     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
 247   }
 248 }
 249 
 250 
 251 void VM_Version::set_features_string() {
 252 
 253   unsigned int ambiguity = 0;
 254   _model_string = z_name[0];
 255   if (is_z13()) {
 256     _features_string = &quot;System z G7-z13  (LDISP_fast, ExtImm, PCrel Load/Store, CmpB, Cond Load/Store, Interlocked Update, TxM, VectorInstr)&quot;;
 257     _model_string = z_name[7];
 258     ambiguity++;
 259   }
 260   if (is_ec12()) {
 261     _features_string = &quot;System z G6-EC12 (LDISP_fast, ExtImm, PCrel Load/Store, CmpB, Cond Load/Store, Interlocked Update, TxM)&quot;;
 262     _model_string = z_name[6];
 263     ambiguity++;
 264   }
 265   if (is_z196()) {
 266     _features_string = &quot;System z G5-z196 (LDISP_fast, ExtImm, PCrel Load/Store, CmpB, Cond Load/Store, Interlocked Update)&quot;;
 267     _model_string = z_name[5];
 268     ambiguity++;
 269   }
 270   if (is_z10()) {
 271     _features_string = &quot;System z G4-z10  (LDISP_fast, ExtImm, PCrel Load/Store, CmpB)&quot;;
 272     _model_string = z_name[4];
 273     ambiguity++;
 274   }
 275   if (is_z9()) {
 276     _features_string = &quot;System z G3-z9   (LDISP_fast, ExtImm), out-of-support as of 2016-04-01&quot;;
 277     _model_string = z_name[3];
 278     ambiguity++;
 279   }
 280   if (is_z990()) {
 281     _features_string = &quot;System z G2-z990 (LDISP_fast), out-of-support as of 2014-07-01&quot;;
 282     _model_string = z_name[2];
 283     ambiguity++;
 284   }
 285   if (is_z900()) {
 286     _features_string = &quot;System z G1-z900 (LDISP), out-of-support as of 2014-07-01&quot;;
 287     _model_string = z_name[1];
 288     ambiguity++;
 289   }
 290 
 291   if (ambiguity == 0) {
 292     _features_string = &quot;z/Architecture (unknown generation)&quot;;
 293   } else if (ambiguity &gt; 1) {
 294     tty-&gt;print_cr(&quot;*** WARNING *** Ambiguous z/Architecture detection, ambiguity = %d&quot;, ambiguity);
 295     tty-&gt;print_cr(&quot;                oldest detected generation is %s&quot;, _features_string);
 296     _features_string = &quot;z/Architecture (ambiguous detection)&quot;;
 297   }
 298 
 299   if (has_Crypto_AES()) {
 300     char buf[256];
 301     assert(strlen(_features_string) + 4 + 3*4 + 1 &lt; sizeof(buf), &quot;increase buffer size&quot;);
 302     jio_snprintf(buf, sizeof(buf), &quot;%s aes%s%s%s&quot;, // String &#39;aes&#39; must be surrounded by spaces so that jtreg tests recognize it.
 303                  _features_string,
 304                  has_Crypto_AES128() ? &quot; 128&quot; : &quot;&quot;,
 305                  has_Crypto_AES192() ? &quot; 192&quot; : &quot;&quot;,
 306                  has_Crypto_AES256() ? &quot; 256&quot; : &quot;&quot;);
 307     _features_string = os::strdup(buf);
 308   }
 309 
 310   if (has_Crypto_SHA()) {
 311     char buf[256];
 312     assert(strlen(_features_string) + 4 + 2 + 2*4 + 6 + 1 &lt; sizeof(buf), &quot;increase buffer size&quot;);
 313     // String &#39;sha1&#39; etc must be surrounded by spaces so that jtreg tests recognize it.
 314     jio_snprintf(buf, sizeof(buf), &quot;%s %s%s%s%s&quot;,
 315                  _features_string,
 316                  has_Crypto_SHA1()   ? &quot; sha1&quot;   : &quot;&quot;,
 317                  has_Crypto_SHA256() ? &quot; sha256&quot; : &quot;&quot;,
 318                  has_Crypto_SHA512() ? &quot; sha512&quot; : &quot;&quot;,
 319                  has_Crypto_GHASH()  ? &quot; ghash&quot;  : &quot;&quot;);
 320     if (has_Crypto_AES()) { os::free((void *)_features_string); }
 321     _features_string = os::strdup(buf);
 322   }
 323 }
 324 
 325 // featureBuffer - bit array indicating availability of various features
 326 // featureNum    - bit index of feature to be tested
 327 //                 Featurenum &lt; 0 requests test for any nonzero bit in featureBuffer.
 328 // bufLen        - length of featureBuffer in bits
 329 bool VM_Version::test_feature_bit(unsigned long* featureBuffer, int featureNum, unsigned int bufLen) {
 330   assert(bufLen &gt; 0,             &quot;buffer len must be positive&quot;);
 331   assert((bufLen &amp; 0x0007) == 0, &quot;unaligned buffer len&quot;);
 332   assert(((intptr_t)featureBuffer&amp;0x0007) == 0, &quot;unaligned feature buffer&quot;);
 333   if (featureNum &lt; 0) {
 334     // Any bit set at all?
 335     bool anyBit = false;
 336     for (size_t i = 0; i &lt; bufLen/(8*sizeof(long)); i++) {
 337       anyBit = anyBit || (featureBuffer[i] != 0);
 338     }
 339     return anyBit;
 340   } else {
 341     assert((unsigned int)featureNum &lt; bufLen,    &quot;feature index out of range&quot;);
 342     unsigned char* byteBuffer = (unsigned char*)featureBuffer;
 343     int   byteIndex  = featureNum/(8*sizeof(char));
 344     int   bitIndex   = featureNum%(8*sizeof(char));
 345     // Indexed bit set?
 346     return (byteBuffer[byteIndex] &amp; (1U&lt;&lt;(7-bitIndex))) != 0;
 347   }
 348 }
 349 
 350 void VM_Version::print_features_internal(const char* text, bool print_anyway) {
 351   tty-&gt;print_cr(&quot;%s %s&quot;,       text, features_string());
 352   tty-&gt;print(&quot;%s&quot;, text);
 353   for (unsigned int i = 0; i &lt; _nfeatures; i++) {
 354     tty-&gt;print(&quot;  0x%16.16lx&quot;, _features[i]);
 355   }
 356   tty-&gt;cr();
 357 
 358   if (Verbose || print_anyway) {
 359     // z900
 360     if (has_long_displacement()        ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;LongDispFacility&quot;);
 361     // z990
 362     if (has_long_displacement_fast()   ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;LongDispFacilityHighPerf&quot;);
 363     if (has_ETF2() &amp;&amp; has_ETF3()       ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ETF2 and ETF3&quot;);
 364     if (has_Crypto()                   ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;CryptoFacility&quot;);
 365     // z9
 366     if (has_extended_immediate()       ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ExtImmedFacility&quot;);
 367     if (has_StoreFacilityListExtended()) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;StoreFacilityListExtended&quot;);
 368     if (has_StoreClockFast()           ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;StoreClockFast&quot;);
 369     if (has_ETF2Enhancements()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ETF2 Enhancements&quot;);
 370     if (has_ETF3Enhancements()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ETF3 Enhancements&quot;);
 371     if (has_HFPUnnormalized()          ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;HFPUnnormalizedFacility&quot;);
 372     if (has_HFPMultiplyAndAdd()        ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;HFPMultiplyAndAddFacility&quot;);
 373     // z10
 374     if (has_ParsingEnhancements()      ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Parsing Enhancements&quot;);
 375     if (has_ExtractCPUtime()           ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ExtractCPUTime&quot;);
 376     if (has_CompareSwapStore()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;CompareSwapStore&quot;);
 377     if (has_GnrlInstrExtensions()      ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;General Instruction Extensions&quot;);
 378     if (has_CompareBranch()            ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Compare and Branch&quot;);
 379     if (has_CompareTrap()              ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Compare and Trap&quot;);
 380     if (has_RelativeLoadStore()        ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Relative Load/Store&quot;);
 381     if (has_MultiplySingleImm32()      ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;MultiplySingleImm32&quot;);
 382     if (has_Prefetch()                 ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Prefetch&quot;);
 383     if (has_MoveImmToMem()             ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Direct Moves Immediate to Memory&quot;);
 384     if (has_MemWithImmALUOps()         ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Direct ALU Ops Memory .op. Immediate&quot;);
 385     if (has_ExtractCPUAttributes()     ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Extract CPU Atributes&quot;);
 386     if (has_ExecuteExtensions()        ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ExecuteExtensions&quot;);
 387     if (has_FPSupportEnhancements()    ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;FPSupportEnhancements&quot;);
 388     if (has_DecimalFloatingPoint()     ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;DecimalFloatingPoint&quot;);
 389     // z196
 390     if (has_DistinctOpnds()            ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Distinct Operands&quot;);
 391     if (has_InterlockedAccessV1()      ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;InterlockedAccess V1 (fast)&quot;);
 392     if (has_PopCount()                 ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;PopCount&quot;);
 393     if (has_LoadStoreConditional()     ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;LoadStoreConditional&quot;);
 394     if (has_HighWordInstr()            ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;HighWord Instructions&quot;);
 395     if (has_FastSync()                 ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;FastSync (bcr 14,0)&quot;);
 396     if (has_AtomicMemWithImmALUOps()   ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Atomic Direct ALU Ops Memory .op. Immediate&quot;);
 397     if (has_FPExtensions()             ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Floatingpoint Extensions&quot;);
 398     if (has_CryptoExt3()               ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Crypto Extensions 3&quot;);
 399     if (has_CryptoExt4()               ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Crypto Extensions 4&quot;);
 400     // EC12
 401     if (has_MiscInstrExt()             ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Miscelaneous Instruction Extensions&quot;);
 402     if (has_ExecutionHint()            ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Execution Hints (branch prediction)&quot;);
 403     if (has_ProcessorAssist()          ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Processor Assists&quot;);
 404     if (has_LoadAndTrap()              ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Load and Trap&quot;);
 405     if (has_TxMem()                    ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Transactional Memory&quot;);
 406     if (has_InterlockedAccessV2()      ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;InterlockedAccess V2 (fast)&quot;);
 407     if (has_DFPZonedConversion()       ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;DFP Zoned Conversions&quot;);
 408     // z13
 409     if (has_LoadStoreConditional2()    ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Load/Store Conditional 2&quot;);
 410     if (has_CryptoExt5()               ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Crypto Extensions 5&quot;);
 411     if (has_DFPPackedConversion()      ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;DFP Packed Conversions&quot;);
 412     if (has_VectorFacility()           ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Vector Facility&quot;);
 413     // test switches
 414     if (has_TestFeature1Impl()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;TestFeature1Impl&quot;);
 415     if (has_TestFeature2Impl()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;TestFeature2Impl&quot;);
 416     if (has_TestFeature4Impl()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;TestFeature4Impl&quot;);
 417     if (has_TestFeature8Impl()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;TestFeature8Impl&quot;);
 418 
 419     if (has_Crypto()) {
 420       tty-&gt;cr();
 421       tty-&gt;print_cr(&quot;detailed availability of %s capabilities:&quot;, &quot;CryptoFacility&quot;);
 422       if (test_feature_bit(&amp;_cipher_features[0], -1, 2*Cipher::_featureBits)) {
 423         tty-&gt;cr();
 424         tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Message Cipher Functions&quot;);
 425       }
 426       if (test_feature_bit(&amp;_cipher_features[0], -1, (int)Cipher::_featureBits)) {
 427         tty-&gt;print_cr(&quot;    available Crypto Features of KM  (Cipher Message):&quot;);
 428         for (unsigned int i = 0; i &lt; Cipher::_featureBits; i++) {
 429           if (test_feature_bit(&amp;_cipher_features[0], i, (int)Cipher::_featureBits)) {
 430             switch (i) {
 431               case Cipher::_Query:              tty-&gt;print_cr(&quot;      available: KM   Query&quot;);                  break;
 432               case Cipher::_DEA:                tty-&gt;print_cr(&quot;      available: KM   DEA&quot;);                    break;
 433               case Cipher::_TDEA128:            tty-&gt;print_cr(&quot;      available: KM   TDEA-128&quot;);               break;
 434               case Cipher::_TDEA192:            tty-&gt;print_cr(&quot;      available: KM   TDEA-192&quot;);               break;
 435               case Cipher::_EncryptedDEA:       tty-&gt;print_cr(&quot;      available: KM   Encrypted DEA&quot;);          break;
 436               case Cipher::_EncryptedDEA128:    tty-&gt;print_cr(&quot;      available: KM   Encrypted DEA-128&quot;);      break;
 437               case Cipher::_EncryptedDEA192:    tty-&gt;print_cr(&quot;      available: KM   Encrypted DEA-192&quot;);      break;
 438               case Cipher::_AES128:             tty-&gt;print_cr(&quot;      available: KM   AES-128&quot;);                break;
 439               case Cipher::_AES192:             tty-&gt;print_cr(&quot;      available: KM   AES-192&quot;);                break;
 440               case Cipher::_AES256:             tty-&gt;print_cr(&quot;      available: KM   AES-256&quot;);                break;
 441               case Cipher::_EnccryptedAES128:   tty-&gt;print_cr(&quot;      available: KM   Encrypted-AES-128&quot;);      break;
 442               case Cipher::_EnccryptedAES192:   tty-&gt;print_cr(&quot;      available: KM   Encrypted-AES-192&quot;);      break;
 443               case Cipher::_EnccryptedAES256:   tty-&gt;print_cr(&quot;      available: KM   Encrypted-AES-256&quot;);      break;
 444               case Cipher::_XTSAES128:          tty-&gt;print_cr(&quot;      available: KM   XTS-AES-128&quot;);            break;
 445               case Cipher::_XTSAES256:          tty-&gt;print_cr(&quot;      available: KM   XTS-AES-256&quot;);            break;
 446               case Cipher::_EncryptedXTSAES128: tty-&gt;print_cr(&quot;      available: KM   XTS-Encrypted-AES-128&quot;);  break;
 447               case Cipher::_EncryptedXTSAES256: tty-&gt;print_cr(&quot;      available: KM   XTS-Encrypted-AES-256&quot;);  break;
 448               default: tty-&gt;print_cr(&quot;      available: unknown KM  code %d&quot;, i);      break;
 449             }
 450           }
 451         }
 452       }
 453       if (test_feature_bit(&amp;_cipher_features[2], -1, (int)Cipher::_featureBits)) {
 454         tty-&gt;print_cr(&quot;    available Crypto Features of KMC (Cipher Message with Chaining):&quot;);
 455         for (unsigned int i = 0; i &lt; Cipher::_featureBits; i++) {
 456             if (test_feature_bit(&amp;_cipher_features[2], i, (int)Cipher::_featureBits)) {
 457             switch (i) {
 458               case Cipher::_Query:              tty-&gt;print_cr(&quot;      available: KMC  Query&quot;);                  break;
 459               case Cipher::_DEA:                tty-&gt;print_cr(&quot;      available: KMC  DEA&quot;);                    break;
 460               case Cipher::_TDEA128:            tty-&gt;print_cr(&quot;      available: KMC  TDEA-128&quot;);               break;
 461               case Cipher::_TDEA192:            tty-&gt;print_cr(&quot;      available: KMC  TDEA-192&quot;);               break;
 462               case Cipher::_EncryptedDEA:       tty-&gt;print_cr(&quot;      available: KMC  Encrypted DEA&quot;);          break;
 463               case Cipher::_EncryptedDEA128:    tty-&gt;print_cr(&quot;      available: KMC  Encrypted DEA-128&quot;);      break;
 464               case Cipher::_EncryptedDEA192:    tty-&gt;print_cr(&quot;      available: KMC  Encrypted DEA-192&quot;);      break;
 465               case Cipher::_AES128:             tty-&gt;print_cr(&quot;      available: KMC  AES-128&quot;);                break;
 466               case Cipher::_AES192:             tty-&gt;print_cr(&quot;      available: KMC  AES-192&quot;);                break;
 467               case Cipher::_AES256:             tty-&gt;print_cr(&quot;      available: KMC  AES-256&quot;);                break;
 468               case Cipher::_EnccryptedAES128:   tty-&gt;print_cr(&quot;      available: KMC  Encrypted-AES-128&quot;);      break;
 469               case Cipher::_EnccryptedAES192:   tty-&gt;print_cr(&quot;      available: KMC  Encrypted-AES-192&quot;);      break;
 470               case Cipher::_EnccryptedAES256:   tty-&gt;print_cr(&quot;      available: KMC  Encrypted-AES-256&quot;);      break;
 471               case Cipher::_PRNG:               tty-&gt;print_cr(&quot;      available: KMC  PRNG&quot;);                   break;
 472               default: tty-&gt;print_cr(&quot;      available: unknown KMC code %d&quot;, i);      break;
 473             }
 474           }
 475         }
 476       }
 477 
 478       if (test_feature_bit(&amp;_msgdigest_features[0], -1, 2*MsgDigest::_featureBits)) {
 479         tty-&gt;cr();
 480         tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Message Digest Functions for SHA&quot;);
 481       }
 482       if (test_feature_bit(&amp;_msgdigest_features[0], -1, (int)MsgDigest::_featureBits)) {
 483         tty-&gt;print_cr(&quot;    available Features of KIMD (Msg Digest):&quot;);
 484         for (unsigned int i = 0; i &lt; MsgDigest::_featureBits; i++) {
 485             if (test_feature_bit(&amp;_msgdigest_features[0], i, (int)MsgDigest::_featureBits)) {
 486             switch (i) {
 487               case MsgDigest::_Query:  tty-&gt;print_cr(&quot;      available: KIMD Query&quot;);   break;
 488               case MsgDigest::_SHA1:   tty-&gt;print_cr(&quot;      available: KIMD SHA-1&quot;);   break;
 489               case MsgDigest::_SHA256: tty-&gt;print_cr(&quot;      available: KIMD SHA-256&quot;); break;
 490               case MsgDigest::_SHA512: tty-&gt;print_cr(&quot;      available: KIMD SHA-512&quot;); break;
 491               case MsgDigest::_GHASH:  tty-&gt;print_cr(&quot;      available: KIMD GHASH&quot;);   break;
 492               default: tty-&gt;print_cr(&quot;      available: unknown code %d&quot;, i);  break;
 493             }
 494           }
 495         }
 496       }
 497       if (test_feature_bit(&amp;_msgdigest_features[2], -1, (int)MsgDigest::_featureBits)) {
 498         tty-&gt;print_cr(&quot;    available Features of KLMD (Msg Digest):&quot;);
 499         for (unsigned int i = 0; i &lt; MsgDigest::_featureBits; i++) {
 500           if (test_feature_bit(&amp;_msgdigest_features[2], i, (int)MsgDigest::_featureBits)) {
 501             switch (i) {
 502               case MsgDigest::_Query:  tty-&gt;print_cr(&quot;      available: KLMD Query&quot;);   break;
 503               case MsgDigest::_SHA1:   tty-&gt;print_cr(&quot;      available: KLMD SHA-1&quot;);   break;
 504               case MsgDigest::_SHA256: tty-&gt;print_cr(&quot;      available: KLMD SHA-256&quot;); break;
 505               case MsgDigest::_SHA512: tty-&gt;print_cr(&quot;      available: KLMD SHA-512&quot;); break;
 506               default: tty-&gt;print_cr(&quot;      available: unknown code %d&quot;, i);  break;
 507             }
 508           }
 509         }
 510       }
 511     }
 512     if (ContendedPaddingWidth &gt; 0) {
 513       tty-&gt;cr();
 514       tty-&gt;print_cr(&quot;ContendedPaddingWidth &quot; INTX_FORMAT, ContendedPaddingWidth);
 515     }
 516   }
 517 }
 518 
 519 void VM_Version::print_features() {
 520   print_features_internal(&quot;Version:&quot;);
 521 }
 522 
 523 void VM_Version::reset_features(bool reset) {
 524   if (reset) {
 525     for (unsigned int i = 0; i &lt; _features_buffer_len; i++) {
 526       VM_Version::_features[i] = 0;
 527     }
 528   }
 529 }
 530 
 531 void VM_Version::set_features_z900(bool reset) {
 532   reset_features(reset);
 533 
 534   set_has_long_displacement();
 535   set_has_ETF2();
 536 }
 537 
 538 void VM_Version::set_features_z990(bool reset) {
 539   reset_features(reset);
 540 
 541   set_features_z900(false);
 542   set_has_ETF3();
 543   set_has_long_displacement_fast();
 544   set_has_HFPMultiplyAndAdd();
 545 }
 546 
 547 void VM_Version::set_features_z9(bool reset) {
 548   reset_features(reset);
 549 
 550   set_features_z990(false);
 551   set_has_StoreFacilityListExtended();
 552   // set_has_Crypto();   // Do not set, crypto features must be retrieved separately.
 553   set_has_ETF2Enhancements();
 554   set_has_ETF3Enhancements();
 555   set_has_extended_immediate();
 556   set_has_StoreClockFast();
 557   set_has_HFPUnnormalized();
 558 }
 559 
 560 void VM_Version::set_features_z10(bool reset) {
 561   reset_features(reset);
 562 
 563   set_features_z9(false);
 564   set_has_CompareSwapStore();
 565   set_has_RelativeLoadStore();
 566   set_has_CompareBranch();
 567   set_has_CompareTrap();
 568   set_has_MultiplySingleImm32();
 569   set_has_Prefetch();
 570   set_has_MoveImmToMem();
 571   set_has_MemWithImmALUOps();
 572   set_has_ExecuteExtensions();
 573   set_has_FPSupportEnhancements();
 574   set_has_DecimalFloatingPoint();
 575   set_has_ExtractCPUtime();
 576   set_has_CryptoExt3();
 577 }
 578 
 579 void VM_Version::set_features_z196(bool reset) {
 580   reset_features(reset);
 581 
 582   set_features_z10(false);
 583   set_has_InterlockedAccessV1();
 584   set_has_PopCount();
 585   set_has_LoadStoreConditional();
 586   set_has_HighWordInstr();
 587   set_has_FastSync();
 588   set_has_FPExtensions();
 589   set_has_DistinctOpnds();
 590   set_has_CryptoExt4();
 591 }
 592 
 593 void VM_Version::set_features_ec12(bool reset) {
 594   reset_features(reset);
 595 
 596   set_features_z196(false);
 597   set_has_MiscInstrExt();
 598   set_has_InterlockedAccessV2();
 599   set_has_LoadAndALUAtomicV2();
 600   set_has_TxMem();
 601 }
 602 
 603 void VM_Version::set_features_z13(bool reset) {
 604   reset_features(reset);
 605 
 606   set_features_ec12(false);
 607   set_has_LoadStoreConditional2();
 608   set_has_CryptoExt5();
 609   set_has_VectorFacility();
 610 }
 611 
 612 void VM_Version::set_features_from(const char* march) {
 613   bool err = false;
 614   bool prt = false;
 615 
 616   if ((march != NULL) &amp;&amp; (march[0] != &#39;\0&#39;)) {
 617     const int buf_len = 16;
 618     const int hdr_len =  5;
 619     char buf[buf_len];
 620     if (strlen(march) &gt;= hdr_len) {
 621       memcpy(buf, march, hdr_len);
 622       buf[hdr_len] = &#39;\00&#39;;
 623     } else {
 624       buf[0]       = &#39;\00&#39;;
 625     }
 626 
 627     if (!strcmp(march, &quot;z900&quot;)) {
 628       set_features_z900();
 629     } else if (!strcmp(march, &quot;z990&quot;)) {
 630         set_features_z990();
 631     } else if (!strcmp(march, &quot;z9&quot;)) {
 632         set_features_z9();
 633     } else if (!strcmp(march, &quot;z10&quot;)) {
 634         set_features_z10();
 635     } else if (!strcmp(march, &quot;z196&quot;)) {
 636         set_features_z196();
 637     } else if (!strcmp(march, &quot;ec12&quot;)) {
 638         set_features_ec12();
 639     } else if (!strcmp(march, &quot;z13&quot;)) {
 640         set_features_z13();
 641     } else if (!strcmp(buf, &quot;ztest&quot;)) {
 642       assert(!has_TestFeaturesImpl(), &quot;possible facility list flag conflict&quot;);
 643       if (strlen(march) &gt; hdr_len) {
 644         int itest = 0;
 645         if ((strlen(march)-hdr_len) &gt;= buf_len) err = true;
 646         if (!err) {
 647           memcpy(buf, &amp;march[hdr_len], strlen(march)-hdr_len);
 648           buf[strlen(march)-hdr_len] = &#39;\00&#39;;
 649           for (size_t i = 0; !err &amp;&amp; (i &lt; strlen(buf)); i++) {
 650             itest = itest*10 + buf[i]-&#39;0&#39;;
 651             err   = err || ((buf[i]-&#39;0&#39;) &lt; 0) || ((buf[i]-&#39;0&#39;) &gt; 9) || (itest &gt; 15);
 652           }
 653         }
 654         if (!err) {
 655           prt = true;
 656           if (itest &amp; 0x01) { set_has_TestFeature1Impl(); }
 657           if (itest &amp; 0x02) { set_has_TestFeature2Impl(); }
 658           if (itest &amp; 0x04) { set_has_TestFeature4Impl(); }
 659           if (itest &amp; 0x08) { set_has_TestFeature8Impl(); }
 660         }
 661       } else {
 662         prt = true;
 663         set_has_TestFeature1Impl();
 664         set_has_TestFeature2Impl();
 665         set_has_TestFeature4Impl();
 666         set_has_TestFeature8Impl();
 667       }
 668     } else {
 669       err = true;
 670     }
 671     if (!err) {
 672       set_features_string();
 673       if (prt || PrintAssembly) {
 674         print_features_internal(&quot;CPU Version as set by cmdline option:&quot;, prt);
 675       }
 676     } else {
 677       tty-&gt;print_cr(&quot;***Warning: Unsupported ProcessorArchitecture: %s, internal settings left undisturbed.&quot;, march);
 678     }
 679   }
 680 
 681 }
 682 
 683 static long (*getFeatures)(unsigned long*, int, int) = NULL;
 684 
 685 void VM_Version::set_getFeatures(address entryPoint) {
 686   if (getFeatures == NULL) {
 687     getFeatures = (long(*)(unsigned long*, int, int))entryPoint;
 688   }
 689 }
 690 
 691 long VM_Version::call_getFeatures(unsigned long* buffer, int buflen, int functionCode) {
 692   VM_Version::_is_determine_features_test_running = true;
 693   long functionResult = (*getFeatures)(buffer, buflen, functionCode);
 694   VM_Version::_is_determine_features_test_running = false;
 695   return functionResult;
 696 }
 697 
 698 // Helper function for &quot;extract cache attribute&quot; instruction.
 699 int VM_Version::calculate_ECAG_functionCode(unsigned int attributeIndication,
 700                                             unsigned int levelIndication,
 701                                             unsigned int typeIndication) {
 702   return (attributeIndication&lt;&lt;4) | (levelIndication&lt;&lt;1) | typeIndication;
 703 }
 704 
 705 void VM_Version::determine_features() {
 706 
 707   const int      cbuf_size = _code_buffer_len;
 708   const int      buf_len   = _features_buffer_len;
 709 
 710   // Allocate code buffer space for the detection code.
 711   ResourceMark    rm;
 712   CodeBuffer      cbuf(&quot;determine CPU features&quot;, cbuf_size, 0);
 713   MacroAssembler* a = new MacroAssembler(&amp;cbuf);
 714 
 715   // Emit code.
 716   set_getFeatures(a-&gt;pc());
 717   address   code = a-&gt;pc();
 718 
 719   // Try STFLE. Possible INVOP will cause defaults to be used.
 720   Label    getFEATURES;
 721   Label    getCPUFEATURES;                   // fcode = -1 (cache)
 722   Label    getCIPHERFEATURES;                // fcode = -2 (cipher)
 723   Label    getMSGDIGESTFEATURES;             // fcode = -3 (SHA)
 724   Label    getVECTORFEATURES;                // fcode = -4 (OS support for vector instructions)
 725   Label    errRTN;
 726   a-&gt;z_ltgfr(Z_R0, Z_ARG2);                  // Buf len to r0 and test.
 727   a-&gt;z_brl(getFEATURES);                     // negative -&gt; Get machine features not covered by facility list.
 728   a-&gt;z_lghi(Z_R1,0);
 729   a-&gt;z_brz(errRTN);                          // zero -&gt; Function code currently not used, indicate &quot;aborted&quot;.
 730 
 731   a-&gt;z_aghi(Z_R0, -1);
 732   a-&gt;z_stfle(0, Z_ARG1);
 733   a-&gt;z_lg(Z_R1, 0, Z_ARG1);                  // Get first DW of facility list.
 734   a-&gt;z_lgr(Z_RET, Z_R0);                     // Calculate rtn value for success.
 735   a-&gt;z_la(Z_RET, 1, Z_RET);
 736   a-&gt;z_brnz(errRTN);                         // Instr failed if non-zero CC.
 737   a-&gt;z_ltgr(Z_R1, Z_R1);                     // Instr failed if first DW == 0.
 738   a-&gt;z_bcr(Assembler::bcondNotZero, Z_R14);  // Successful return.
 739 
 740   a-&gt;bind(errRTN);
 741   a-&gt;z_lngr(Z_RET, Z_RET);
 742   a-&gt;z_ltgr(Z_R1, Z_R1);
 743   a-&gt;z_bcr(Assembler::bcondNotZero, Z_R14);  // Return &quot;buffer too small&quot;.
 744   a-&gt;z_xgr(Z_RET, Z_RET);
 745   a-&gt;z_br(Z_R14);                            // Return &quot;operation aborted&quot;.
 746 
 747   a-&gt;bind(getFEATURES);
 748   a-&gt;z_cghi(Z_R0, -1);                       // -1: Extract CPU attributes, currently: cache layout only.
 749   a-&gt;z_bre(getCPUFEATURES);
 750   a-&gt;z_cghi(Z_R0, -2);                       // -2: Extract detailed crypto capabilities (cipher instructions).
 751   a-&gt;z_bre(getCIPHERFEATURES);
 752   a-&gt;z_cghi(Z_R0, -3);                       // -3: Extract detailed crypto capabilities (msg digest instructions).
 753   a-&gt;z_bre(getMSGDIGESTFEATURES);
 754   a-&gt;z_cghi(Z_R0, -4);                       // -4: Verify vector instruction availability (OS support).
 755   a-&gt;z_bre(getVECTORFEATURES);
 756 
 757   a-&gt;z_xgr(Z_RET, Z_RET);                    // Not a valid function code.
 758   a-&gt;z_br(Z_R14);                            // Return &quot;operation aborted&quot;.
 759 
 760   // Try KIMD/KLMD query function to get details about msg digest (secure hash, SHA) instructions.
 761   a-&gt;bind(getMSGDIGESTFEATURES);
 762   a-&gt;z_lghi(Z_R0,(int)MsgDigest::_Query);    // query function code
 763   a-&gt;z_lgr(Z_R1,Z_R2);                       // param block addr, 2*16 bytes min size
 764   a-&gt;z_kimd(Z_R2,Z_R2);                      // Get available KIMD functions (bit pattern in param blk).
 765   a-&gt;z_la(Z_R1,16,Z_R1);                     // next param block addr
 766   a-&gt;z_klmd(Z_R2,Z_R2);                      // Get available KLMD functions (bit pattern in param blk).
 767   a-&gt;z_lghi(Z_RET,4);
 768   a-&gt;z_br(Z_R14);
 769 
 770   // Try KM/KMC query function to get details about crypto instructions.
 771   a-&gt;bind(getCIPHERFEATURES);
 772   a-&gt;z_lghi(Z_R0,(int)Cipher::_Query);       // query function code
 773   a-&gt;z_lgr(Z_R1,Z_R2);                       // param block addr, 2*16 bytes min size (KIMD/KLMD output)
 774   a-&gt;z_km(Z_R2,Z_R2);                        // get available KM functions
 775   a-&gt;z_la(Z_R1,16,Z_R1);                     // next param block addr
 776   a-&gt;z_kmc(Z_R2,Z_R2);                       // get available KMC functions
 777   a-&gt;z_lghi(Z_RET,4);
 778   a-&gt;z_br(Z_R14);
 779 
 780   // Use EXTRACT CPU ATTRIBUTE instruction to get information about cache layout.
 781   a-&gt;bind(getCPUFEATURES);
 782   a-&gt;z_xgr(Z_R0,Z_R0);                       // as recommended in instruction documentation
 783   a-&gt;z_ecag(Z_RET,Z_R0,0,Z_ARG3);            // Extract information as requested by Z_ARG1 contents.
 784   a-&gt;z_br(Z_R14);
 785 
 786   // Use a vector instruction to verify OS support. Will fail with SIGFPE if OS support is missing.
 787   a-&gt;bind(getVECTORFEATURES);
 788   a-&gt;z_vtm(Z_V0,Z_V0);                       // non-destructive vector instruction. Will cause SIGFPE if not supported.
 789   a-&gt;z_br(Z_R14);
 790 
 791   address code_end = a-&gt;pc();
 792   a-&gt;flush();
 793 
 794   // Print the detection code.
 795   bool printVerbose = Verbose || PrintAssembly || PrintStubCode;
 796   if (printVerbose) {
 797     ttyLocker ttyl;
 798     tty-&gt;print_cr(&quot;Decoding CPU feature detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
 799     tty-&gt;print_cr(&quot;Stub length is %ld bytes, codebuffer reserves %d bytes, %ld bytes spare.&quot;,
 800                   code_end-code, cbuf_size, cbuf_size-(code_end-code));
 801 
 802     // Use existing decode function. This enables the [Code] format which is needed to DecodeErrorFile.
 803     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 804   }
 805 
 806   // Prepare for detection code execution and clear work buffer.
 807   _nfeatures        = 0;
 808   _ncipher_features = 0;
 809   unsigned long  buffer[buf_len];
 810 
 811   for (int i = 0; i &lt; buf_len; i++) {
 812     buffer[i] = 0L;
 813   }
 814 
 815   // execute code
 816   // Illegal instructions will be replaced by 0 in signal handler.
 817   // In case of problems, call_getFeatures will return a not-positive result.
 818   long used_len = call_getFeatures(buffer, buf_len, 0);
 819 
 820   bool ok;
 821   if (used_len == 1) {
 822     ok = true;
 823   } else if (used_len &gt; 1) {
 824     unsigned int used_lenU = (unsigned int)used_len;
 825     ok = true;
 826     for (unsigned int i = 1; i &lt; used_lenU; i++) {
 827       ok = ok &amp;&amp; (buffer[i] == 0L);
 828     }
 829     if (printVerbose &amp;&amp; !ok) {
 830       bool compact = false;
 831       tty-&gt;print_cr(&quot;Note: feature list has %d (i.e. more than one) array elements.&quot;, used_lenU);
 832       if (compact) {
 833         tty-&gt;print(&quot;non-zero feature list elements:&quot;);
 834         for (unsigned int i = 0; i &lt; used_lenU; i++) {
 835           tty-&gt;print(&quot;  [%d]: 0x%16.16lx&quot;, i, buffer[i]);
 836         }
 837         tty-&gt;cr();
 838       } else {
 839         for (unsigned int i = 0; i &lt; used_lenU; i++) {
 840           tty-&gt;print_cr(&quot;non-zero feature list[%d]: 0x%16.16lx&quot;, i, buffer[i]);
 841         }
 842       }
 843 
 844       if (compact) {
 845         tty-&gt;print_cr(&quot;Active features (compact view):&quot;);
 846         for (unsigned int k = 0; k &lt; used_lenU; k++) {
 847           tty-&gt;print_cr(&quot;  buffer[%d]:&quot;, k);
 848           for (unsigned int j = k*sizeof(long); j &lt; (k+1)*sizeof(long); j++) {
 849             bool line = false;
 850             for (unsigned int i = j*8; i &lt; (j+1)*8; i++) {
 851               bool bit  = test_feature_bit(buffer, i, used_lenU*sizeof(long)*8);
 852               if (bit) {
 853                 if (!line) {
 854                   tty-&gt;print(&quot;    byte[%d]:&quot;, j);
 855                   line = true;
 856                 }
 857                 tty-&gt;print(&quot;  [%3.3d]&quot;, i);
 858               }
 859             }
 860             if (line) {
 861               tty-&gt;cr();
 862             }
 863           }
 864         }
 865       } else {
 866         tty-&gt;print_cr(&quot;Active features (full view):&quot;);
 867         for (unsigned int k = 0; k &lt; used_lenU; k++) {
 868           tty-&gt;print_cr(&quot;  buffer[%d]:&quot;, k);
 869           for (unsigned int j = k*sizeof(long); j &lt; (k+1)*sizeof(long); j++) {
 870             tty-&gt;print(&quot;    byte[%d]:&quot;, j);
 871             for (unsigned int i = j*8; i &lt; (j+1)*8; i++) {
 872               bool bit  = test_feature_bit(buffer, i, used_lenU*sizeof(long)*8);
 873               if (bit) {
 874                 tty-&gt;print(&quot;  [%3.3d]&quot;, i);
 875               } else {
 876                 tty-&gt;print(&quot;       &quot;);
 877               }
 878             }
 879             tty-&gt;cr();
 880           }
 881         }
 882       }
 883     }
 884     ok = true;
 885   } else {  // No features retrieved if we reach here. Buffer too short or instr not available.
 886     if (used_len &lt; 0) {
 887       ok = false;
 888       if (printVerbose) {
 889         tty-&gt;print_cr(&quot;feature list buffer[%d] too short, required: buffer[%ld]&quot;, buf_len, -used_len);
 890       }
 891     } else {
 892       if (printVerbose) {
 893         tty-&gt;print_cr(&quot;feature list could not be retrieved. Running on z900 or z990? Trying to find out...&quot;);
 894       }
 895       used_len = call_getFeatures(buffer, 0, 0);       // Must provide at least two DW buffer elements!!!!
 896 
 897       ok = used_len &gt; 0;
 898       if (ok) {
 899         if (buffer[1]*10 &lt; buffer[0]) {
 900           set_features_z900();
 901         } else {
 902           set_features_z990();
 903         }
 904 
 905         if (printVerbose) {
 906           tty-&gt;print_cr(&quot;Note: high-speed long displacement test used %ld iterations.&quot;, used_len);
 907           tty-&gt;print_cr(&quot;      Positive displacement loads took %8.8lu microseconds.&quot;, buffer[1]);
 908           tty-&gt;print_cr(&quot;      Negative displacement loads took %8.8lu microseconds.&quot;, buffer[0]);
 909           if (has_long_displacement_fast()) {
 910             tty-&gt;print_cr(&quot;      assuming high-speed long displacement IS     available.&quot;);
 911           } else {
 912             tty-&gt;print_cr(&quot;      assuming high-speed long displacement is NOT available.&quot;);
 913           }
 914         }
 915       } else {
 916         if (printVerbose) {
 917           tty-&gt;print_cr(&quot;Note: high-speed long displacement test was not successful.&quot;);
 918           tty-&gt;print_cr(&quot;      assuming long displacement is NOT available.&quot;);
 919         }
 920       }
 921       return; // Do not copy buffer to _features, no test for cipher features.
 922     }
 923   }
 924 
 925   if (ok) {
 926     // Fill features buffer.
 927     // Clear work buffer.
 928     for (int i = 0; i &lt; buf_len; i++) {
 929       _features[i]           = buffer[i];
 930       _cipher_features[i]    = 0;
 931       _msgdigest_features[i] = 0;
 932       buffer[i]              = 0L;
 933     }
 934     _nfeatures = used_len;
 935   } else {
 936     for (int i = 0; i &lt; buf_len; i++) {
 937       _features[i]           = 0;
 938       _cipher_features[i]    = 0;
 939       _msgdigest_features[i] = 0;
 940       buffer[i]              = 0L;
 941     }
 942     _nfeatures = 0;
 943   }
 944 
 945   if (has_VectorFacility()) {
 946     // Verify that feature can actually be used. OS support required.
 947     call_getFeatures(buffer, -4, 0);
 948     if (printVerbose) {
 949       ttyLocker ttyl;
 950       if (has_VectorFacility()) {
 951         tty-&gt;print_cr(&quot;  Vector Facility has been verified to be supported by OS&quot;);
 952       } else {
 953         tty-&gt;print_cr(&quot;  Vector Facility has been disabled - not supported by OS&quot;);
 954       }
 955     }
 956   }
 957 
 958   // Extract Crypto Facility details.
 959   if (has_Crypto()) {
 960     // Get cipher features.
 961     used_len = call_getFeatures(buffer, -2, 0);
 962     for (int i = 0; i &lt; buf_len; i++) {
 963       _cipher_features[i] = buffer[i];
 964     }
 965     _ncipher_features = used_len;
 966 
 967     // Get msg digest features.
 968     used_len = call_getFeatures(buffer, -3, 0);
 969     for (int i = 0; i &lt; buf_len; i++) {
 970       _msgdigest_features[i] = buffer[i];
 971     }
 972     _nmsgdigest_features = used_len;
 973   }
 974 
 975   static int   levelProperties[_max_cache_levels];     // All property indications per level.
 976   static int   levelScope[_max_cache_levels];          // private/shared
 977   static const char* levelScopeText[4] = {&quot;No cache   &quot;,
 978                                           &quot;CPU private&quot;,
 979                                           &quot;shared     &quot;,
 980                                           &quot;reserved   &quot;};
 981 
 982   static int   levelType[_max_cache_levels];           // D/I/mixed
 983   static const char* levelTypeText[4]  = {&quot;separate D and I caches&quot;,
 984                                           &quot;I cache only           &quot;,
 985                                           &quot;D-cache only           &quot;,
 986                                           &quot;combined D/I cache     &quot;};
 987 
 988   static unsigned int levelReserved[_max_cache_levels];    // reserved property bits
 989   static unsigned int levelLineSize[_max_cache_levels];
 990   static unsigned int levelTotalSize[_max_cache_levels];
 991   static unsigned int levelAssociativity[_max_cache_levels];
 992 
 993 
 994   // Extract Cache Layout details.
 995   if (has_ExtractCPUAttributes() &amp;&amp; printVerbose) { // For information only, as of now.
 996     bool         lineSize_mismatch;
 997     bool         print_something;
 998     long         functionResult;
 999     unsigned int attributeIndication = 0; // 0..15
1000     unsigned int levelIndication     = 0; // 0..8
1001     unsigned int typeIndication      = 0; // 0..1 (D-Cache, I-Cache)
1002     int          functionCode        = calculate_ECAG_functionCode(attributeIndication, levelIndication, typeIndication);
1003 
1004     // Get cache topology.
1005     functionResult = call_getFeatures(buffer, -1, functionCode);
1006 
1007     for (unsigned int i = 0; i &lt; _max_cache_levels; i++) {
1008       if (functionResult &gt; 0) {
1009         int shiftVal          = 8*(_max_cache_levels-(i+1));
1010         levelProperties[i]    = (functionResult &amp; (0xffUL&lt;&lt;shiftVal)) &gt;&gt; shiftVal;
1011         levelReserved[i]      = (levelProperties[i] &amp; 0xf0) &gt;&gt; 4;
1012         levelScope[i]         = (levelProperties[i] &amp; 0x0c) &gt;&gt; 2;
1013         levelType[i]          = (levelProperties[i] &amp; 0x03);
1014       } else {
1015         levelProperties[i]    = 0;
1016         levelReserved[i]      = 0;
1017         levelScope[i]         = 0;
1018         levelType[i]          = 0;
1019       }
1020       levelLineSize[i]      = 0;
1021       levelTotalSize[i]     = 0;
1022       levelAssociativity[i] = 0;
1023     }
1024 
1025     tty-&gt;cr();
1026     tty-&gt;print_cr(&quot;------------------------------------&quot;);
1027     tty-&gt;print_cr(&quot;---  Cache Topology Information  ---&quot;);
1028     tty-&gt;print_cr(&quot;------------------------------------&quot;);
1029     for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1030       tty-&gt;print_cr(&quot;  Cache Level %d: &lt;scope&gt;  %s | &lt;type&gt;  %s&quot;,
1031                     i+1, levelScopeText[levelScope[i]], levelTypeText[levelType[i]]);
1032     }
1033 
1034     // Get D-cache details per level.
1035     _Dcache_lineSize   = 0;
1036     lineSize_mismatch  = false;
1037     print_something    = false;
1038     typeIndication     = 0; // 0..1 (D-Cache, I-Cache)
1039     for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1040       if ((levelType[i] == 0) || (levelType[i] == 2)) {
1041         print_something     = true;
1042 
1043         // Get cache line size of level i.
1044         attributeIndication   = 1;
1045         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1046         levelLineSize[i]      = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1047 
1048         // Get cache total size of level i.
1049         attributeIndication   = 2;
1050         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1051         levelTotalSize[i]     = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1052 
1053         // Get cache associativity of level i.
1054         attributeIndication   = 3;
1055         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1056         levelAssociativity[i] = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1057 
1058         _Dcache_lineSize      = _Dcache_lineSize == 0 ? levelLineSize[i] : _Dcache_lineSize;
1059         lineSize_mismatch     = lineSize_mismatch || (_Dcache_lineSize != levelLineSize[i]);
1060       } else {
1061         levelLineSize[i]      = 0;
1062       }
1063     }
1064 
1065     if (print_something) {
1066       tty-&gt;cr();
1067       tty-&gt;print_cr(&quot;------------------------------------&quot;);
1068       tty-&gt;print_cr(&quot;---  D-Cache Detail Information  ---&quot;);
1069       tty-&gt;print_cr(&quot;------------------------------------&quot;);
1070       if (lineSize_mismatch) {
1071         tty-&gt;print_cr(&quot;WARNING: D-Cache line size mismatch!&quot;);
1072       }
1073       for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1074         if (levelLineSize[i] &gt; 0) {
1075           tty-&gt;print_cr(&quot;  D-Cache Level %d: line size = %4d,  total size = %6dKB,  associativity = %2d&quot;,
1076                         i+1, levelLineSize[i], levelTotalSize[i]/(int)K, levelAssociativity[i]);
1077         }
1078       }
1079     }
1080 
1081     // Get I-cache details per level.
1082     _Icache_lineSize   = 0;
1083     lineSize_mismatch  = false;
1084     print_something    = false;
1085     typeIndication     = 1; // 0..1 (D-Cache, I-Cache)
1086     for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1087       if ((levelType[i] == 0) || (levelType[i] == 1)) {
1088         print_something     = true;
1089 
1090         // Get cache line size of level i.
1091         attributeIndication   = 1;
1092         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1093         levelLineSize[i]      = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1094 
1095         // Get cache total size of level i.
1096         attributeIndication   = 2;
1097         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1098         levelTotalSize[i]     = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1099 
1100         // Get cache associativity of level i.
1101         attributeIndication   = 3;
1102         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1103         levelAssociativity[i] = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1104 
1105         _Icache_lineSize      = _Icache_lineSize == 0 ? levelLineSize[i] : _Icache_lineSize;
1106         lineSize_mismatch     = lineSize_mismatch || (_Icache_lineSize != levelLineSize[i]);
1107       } else {
1108         levelLineSize[i]      = 0;
1109       }
1110     }
1111 
1112     if (print_something) {
1113       tty-&gt;cr();
1114       tty-&gt;print_cr(&quot;------------------------------------&quot;);
1115       tty-&gt;print_cr(&quot;---  I-Cache Detail Information  ---&quot;);
1116       tty-&gt;print_cr(&quot;------------------------------------&quot;);
1117       if (lineSize_mismatch) {
1118         tty-&gt;print_cr(&quot;WARNING: I-Cache line size mismatch!&quot;);
1119       }
1120       for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1121         if (levelLineSize[i] &gt; 0) {
1122           tty-&gt;print_cr(&quot;  I-Cache Level %d: line size = %4d,  total size = %6dKB,  associativity = %2d&quot;,
1123                         i+1, levelLineSize[i], levelTotalSize[i]/(int)K, levelAssociativity[i]);
1124         }
1125       }
1126     }
1127 
1128     // Get D/I-cache details per level.
1129     lineSize_mismatch  = false;
1130     print_something    = false;
1131     typeIndication     = 0; // 0..1 (D-Cache, I-Cache)
1132     for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1133       if (levelType[i] == 3) {
1134         print_something     = true;
1135 
1136         // Get cache line size of level i.
1137         attributeIndication   = 1;
1138         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1139         levelLineSize[i]      = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1140 
1141         // Get cache total size of level i.
1142         attributeIndication   = 2;
1143         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1144         levelTotalSize[i]     = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1145 
1146         // Get cache associativity of level i.
1147         attributeIndication   = 3;
1148         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1149         levelAssociativity[i] = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1150 
1151         _Dcache_lineSize      = _Dcache_lineSize == 0 ? levelLineSize[i] : _Dcache_lineSize;
1152         _Icache_lineSize      = _Icache_lineSize == 0 ? levelLineSize[i] : _Icache_lineSize;
1153         lineSize_mismatch     = lineSize_mismatch || (_Dcache_lineSize != levelLineSize[i])
1154                                                   || (_Icache_lineSize != levelLineSize[i]);
1155       } else {
1156         levelLineSize[i]      = 0;
1157       }
1158     }
1159 
1160     if (print_something) {
1161       tty-&gt;cr();
1162       tty-&gt;print_cr(&quot;--------------------------------------&quot;);
1163       tty-&gt;print_cr(&quot;---  D/I-Cache Detail Information  ---&quot;);
1164       tty-&gt;print_cr(&quot;--------------------------------------&quot;);
1165       if (lineSize_mismatch) {
1166         tty-&gt;print_cr(&quot;WARNING: D/I-Cache line size mismatch!&quot;);
1167       }
1168       for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1169         if (levelLineSize[i] &gt; 0) {
1170           tty-&gt;print_cr(&quot;  D/I-Cache Level %d: line size = %4d,  total size = %6dKB,  associativity = %2d&quot;,
1171                         i+1, levelLineSize[i], levelTotalSize[i]/(int)K, levelAssociativity[i]);
1172         }
1173       }
1174     }
1175     tty-&gt;cr();
1176   }
1177   return;
1178 }
1179 
1180 unsigned long VM_Version::z_SIGILL() {
1181   unsigned long   ZeroBuffer = 0;
1182   unsigned long   work;
1183   asm(
1184     &quot;     LA      %[work],%[buffer]  \n\t&quot;   // Load address of buffer.
1185     &quot;     LARL    14,+6              \n\t&quot;   // Load address of faulting instruction.
1186     &quot;     BCR     15,%[work]         \n\t&quot;   // Branch into buffer, execute whatever is in there.
1187     : [buffer]  &quot;+Q&quot;  (ZeroBuffer)   /* outputs   */
1188     , [work]   &quot;=&amp;a&quot;  (work)         /* outputs   */
1189     :                                /* inputs    */
1190     : &quot;cc&quot;                           /* clobbered */
1191  );
1192   return ZeroBuffer;
1193 }
1194 
1195 unsigned long VM_Version::z_SIGSEGV() {
1196   unsigned long   ZeroBuffer = 0;
1197   unsigned long   work;
1198   asm(
1199     &quot;     LG      %[work],%[buffer]  \n\t&quot;   // Load zero address.
1200     &quot;     STG     %[work],0(,%[work])\n\t&quot;   // Store to address zero.
1201     : [buffer]  &quot;+Q&quot;  (ZeroBuffer)   /* outputs   */
1202     , [work]   &quot;=&amp;a&quot;  (work)         /* outputs   */
1203     :                                /* inputs    */
1204     : &quot;cc&quot;                           /* clobbered */
1205  );
1206   return ZeroBuffer;
1207 }
1208 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/c1_Runtime1_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_MacroAssembler_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_globals_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/c1_Runtime1_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;c1/c1_Defs.hpp&quot;
 29 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 30 #include &quot;c1/c1_Runtime1.hpp&quot;
 31 #include &quot;ci/ciUtilities.hpp&quot;
 32 #include &quot;gc/shared/cardTable.hpp&quot;
 33 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;

 35 #include &quot;nativeInst_s390.hpp&quot;
 36 #include &quot;oops/compiledICHolder.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;prims/jvmtiExport.hpp&quot;
 39 #include &quot;register_s390.hpp&quot;

 40 #include &quot;runtime/sharedRuntime.hpp&quot;
 41 #include &quot;runtime/signature.hpp&quot;
 42 #include &quot;runtime/vframeArray.hpp&quot;
 43 #include &quot;utilities/macros.hpp&quot;

 44 #include &quot;vmreg_s390.inline.hpp&quot;
<span class="line-removed"> 45 #include &quot;registerSaver_s390.hpp&quot;</span>
 46 
 47 // Implementation of StubAssembler
 48 
 49 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry_point, int number_of_arguments) {
 50   set_num_rt_args(0); // Nothing on stack.
 51   assert(!(oop_result1-&gt;is_valid() || metadata_result-&gt;is_valid()) || oop_result1 != metadata_result, &quot;registers must be different&quot;);
 52 
 53   // We cannot trust that code generated by the C++ compiler saves R14
 54   // to z_abi_160.return_pc, because sometimes it spills R14 using stmg at
 55   // z_abi_160.gpr14 (e.g. InterpreterRuntime::_new()).
 56   // Therefore we load the PC into Z_R1_scratch and let set_last_Java_frame() save
 57   // it into the frame anchor.
 58   address pc = get_PC(Z_R1_scratch);
 59   int call_offset = (int)(pc - addr_at(0));
 60   set_last_Java_frame(Z_SP, Z_R1_scratch);
 61 
 62   // ARG1 must hold thread address.
 63   z_lgr(Z_ARG1, Z_thread);
 64 
 65   address return_pc = NULL;
</pre>
<hr />
<pre>
321     case fast_new_instance_init_check_id:
322       {
323         Register klass    = Z_R11; // Incoming
324         Register obj      = Z_R2;  // Result
325 
326         if (id == new_instance_id) {
327           __ set_info(&quot;new_instance&quot;, dont_gc_arguments);
328         } else if (id == fast_new_instance_id) {
329           __ set_info(&quot;fast new_instance&quot;, dont_gc_arguments);
330         } else {
331           assert(id == fast_new_instance_init_check_id, &quot;bad StubID&quot;);
332           __ set_info(&quot;fast new_instance init check&quot;, dont_gc_arguments);
333         }
334 
335         OopMap* map = save_live_registers_except_r2(sasm);
336         int call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance), klass);
337         oop_maps = new OopMapSet();
338         oop_maps-&gt;add_gc_map(call_offset, map);
339         restore_live_registers_except_r2(sasm);
340 
<span class="line-modified">341         __ verify_oop(obj);</span>
342         __ z_br(Z_R14);
343       }
344       break;
345 
346     case counter_overflow_id:
347       {
348         // Arguments :
349         //   bci    : stack param 0
350         //   method : stack param 1
351         //
352         Register bci = Z_ARG2, method = Z_ARG3;
353         // frame size in bytes
354         OopMap* map = save_live_registers(sasm);
355         const int frame_size = sasm-&gt;frame_size() * VMRegImpl::slots_per_word * VMRegImpl::stack_slot_size;
356         __ z_lg(bci,    0*BytesPerWord + FrameMap::first_available_sp_in_frame + frame_size, Z_SP);
357         __ z_lg(method, 1*BytesPerWord + FrameMap::first_available_sp_in_frame + frame_size, Z_SP);
358         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, counter_overflow), bci, method);
359         oop_maps = new OopMapSet();
360         oop_maps-&gt;add_gc_map(call_offset, map);
361         restore_live_registers(sasm);
</pre>
<hr />
<pre>
387                      : Klass::_lh_array_tag_obj_value);
388           __ compare32_and_branch(t0, tag, Assembler::bcondEqual, ok);
389           __ stop(&quot;assert(is an array klass)&quot;);
390           __ should_not_reach_here();
391           __ bind(ok);
392         }
393 #endif // ASSERT
394 
395         OopMap* map = save_live_registers_except_r2(sasm);
396         int call_offset;
397         if (id == new_type_array_id) {
398           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_type_array), klass, length);
399         } else {
400           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_object_array), klass, length);
401         }
402 
403         oop_maps = new OopMapSet();
404         oop_maps-&gt;add_gc_map(call_offset, map);
405         restore_live_registers_except_r2(sasm);
406 
<span class="line-modified">407         __ verify_oop(obj);</span>
408         __ z_br(Z_R14);
409       }
410       break;
411 
412     case new_multi_array_id:
413       { __ set_info(&quot;new_multi_array&quot;, dont_gc_arguments);
414         // Z_R3,: klass
415         // Z_R4,: rank
416         // Z_R5: address of 1st dimension
417         OopMap* map = save_live_registers(sasm);
418         int call_offset = __ call_RT(Z_R2, noreg, CAST_FROM_FN_PTR(address, new_multi_array), Z_R3, Z_R4, Z_R5);
419 
420         oop_maps = new OopMapSet();
421         oop_maps-&gt;add_gc_map(call_offset, map);
422         restore_live_registers_except_r2(sasm);
423 
424         // Z_R2,: new multi array
<span class="line-modified">425         __ verify_oop(Z_R2);</span>
426         __ z_br(Z_R14);
427       }
428       break;
429 
430     case register_finalizer_id:
431       {
432         __ set_info(&quot;register_finalizer&quot;, dont_gc_arguments);
433 
434         // Load the klass and check the has finalizer flag.
435         Register klass = Z_ARG2;
436         __ load_klass(klass, Z_ARG1);
437         __ testbit(Address(klass, Klass::access_flags_offset()), exact_log2(JVM_ACC_HAS_FINALIZER));
438         __ z_bcr(Assembler::bcondAllZero, Z_R14); // Return if bit is not set.
439 
440         OopMap* oop_map = save_live_registers(sasm);
441         int call_offset = __ call_RT(noreg, noreg,
442                                      CAST_FROM_FN_PTR(address, SharedRuntime::register_finalizer), Z_ARG1);
443         oop_maps = new OopMapSet();
444         oop_maps-&gt;add_gc_map(call_offset, oop_map);
445 
</pre>
</td>
<td>
<hr />
<pre>
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/macroAssembler.inline.hpp&quot;
 28 #include &quot;c1/c1_Defs.hpp&quot;
 29 #include &quot;c1/c1_MacroAssembler.hpp&quot;
 30 #include &quot;c1/c1_Runtime1.hpp&quot;
 31 #include &quot;ci/ciUtilities.hpp&quot;
 32 #include &quot;gc/shared/cardTable.hpp&quot;
 33 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;
<span class="line-added"> 35 #include &quot;memory/universe.hpp&quot;</span>
 36 #include &quot;nativeInst_s390.hpp&quot;
 37 #include &quot;oops/compiledICHolder.hpp&quot;
 38 #include &quot;oops/oop.inline.hpp&quot;
 39 #include &quot;prims/jvmtiExport.hpp&quot;
 40 #include &quot;register_s390.hpp&quot;
<span class="line-added"> 41 #include &quot;registerSaver_s390.hpp&quot;</span>
 42 #include &quot;runtime/sharedRuntime.hpp&quot;
 43 #include &quot;runtime/signature.hpp&quot;
 44 #include &quot;runtime/vframeArray.hpp&quot;
 45 #include &quot;utilities/macros.hpp&quot;
<span class="line-added"> 46 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 47 #include &quot;vmreg_s390.inline.hpp&quot;

 48 
 49 // Implementation of StubAssembler
 50 
 51 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry_point, int number_of_arguments) {
 52   set_num_rt_args(0); // Nothing on stack.
 53   assert(!(oop_result1-&gt;is_valid() || metadata_result-&gt;is_valid()) || oop_result1 != metadata_result, &quot;registers must be different&quot;);
 54 
 55   // We cannot trust that code generated by the C++ compiler saves R14
 56   // to z_abi_160.return_pc, because sometimes it spills R14 using stmg at
 57   // z_abi_160.gpr14 (e.g. InterpreterRuntime::_new()).
 58   // Therefore we load the PC into Z_R1_scratch and let set_last_Java_frame() save
 59   // it into the frame anchor.
 60   address pc = get_PC(Z_R1_scratch);
 61   int call_offset = (int)(pc - addr_at(0));
 62   set_last_Java_frame(Z_SP, Z_R1_scratch);
 63 
 64   // ARG1 must hold thread address.
 65   z_lgr(Z_ARG1, Z_thread);
 66 
 67   address return_pc = NULL;
</pre>
<hr />
<pre>
323     case fast_new_instance_init_check_id:
324       {
325         Register klass    = Z_R11; // Incoming
326         Register obj      = Z_R2;  // Result
327 
328         if (id == new_instance_id) {
329           __ set_info(&quot;new_instance&quot;, dont_gc_arguments);
330         } else if (id == fast_new_instance_id) {
331           __ set_info(&quot;fast new_instance&quot;, dont_gc_arguments);
332         } else {
333           assert(id == fast_new_instance_init_check_id, &quot;bad StubID&quot;);
334           __ set_info(&quot;fast new_instance init check&quot;, dont_gc_arguments);
335         }
336 
337         OopMap* map = save_live_registers_except_r2(sasm);
338         int call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance), klass);
339         oop_maps = new OopMapSet();
340         oop_maps-&gt;add_gc_map(call_offset, map);
341         restore_live_registers_except_r2(sasm);
342 
<span class="line-modified">343         __ verify_oop(obj, FILE_AND_LINE);</span>
344         __ z_br(Z_R14);
345       }
346       break;
347 
348     case counter_overflow_id:
349       {
350         // Arguments :
351         //   bci    : stack param 0
352         //   method : stack param 1
353         //
354         Register bci = Z_ARG2, method = Z_ARG3;
355         // frame size in bytes
356         OopMap* map = save_live_registers(sasm);
357         const int frame_size = sasm-&gt;frame_size() * VMRegImpl::slots_per_word * VMRegImpl::stack_slot_size;
358         __ z_lg(bci,    0*BytesPerWord + FrameMap::first_available_sp_in_frame + frame_size, Z_SP);
359         __ z_lg(method, 1*BytesPerWord + FrameMap::first_available_sp_in_frame + frame_size, Z_SP);
360         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, counter_overflow), bci, method);
361         oop_maps = new OopMapSet();
362         oop_maps-&gt;add_gc_map(call_offset, map);
363         restore_live_registers(sasm);
</pre>
<hr />
<pre>
389                      : Klass::_lh_array_tag_obj_value);
390           __ compare32_and_branch(t0, tag, Assembler::bcondEqual, ok);
391           __ stop(&quot;assert(is an array klass)&quot;);
392           __ should_not_reach_here();
393           __ bind(ok);
394         }
395 #endif // ASSERT
396 
397         OopMap* map = save_live_registers_except_r2(sasm);
398         int call_offset;
399         if (id == new_type_array_id) {
400           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_type_array), klass, length);
401         } else {
402           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_object_array), klass, length);
403         }
404 
405         oop_maps = new OopMapSet();
406         oop_maps-&gt;add_gc_map(call_offset, map);
407         restore_live_registers_except_r2(sasm);
408 
<span class="line-modified">409         __ verify_oop(obj, FILE_AND_LINE);</span>
410         __ z_br(Z_R14);
411       }
412       break;
413 
414     case new_multi_array_id:
415       { __ set_info(&quot;new_multi_array&quot;, dont_gc_arguments);
416         // Z_R3,: klass
417         // Z_R4,: rank
418         // Z_R5: address of 1st dimension
419         OopMap* map = save_live_registers(sasm);
420         int call_offset = __ call_RT(Z_R2, noreg, CAST_FROM_FN_PTR(address, new_multi_array), Z_R3, Z_R4, Z_R5);
421 
422         oop_maps = new OopMapSet();
423         oop_maps-&gt;add_gc_map(call_offset, map);
424         restore_live_registers_except_r2(sasm);
425 
426         // Z_R2,: new multi array
<span class="line-modified">427         __ verify_oop(Z_R2, FILE_AND_LINE);</span>
428         __ z_br(Z_R14);
429       }
430       break;
431 
432     case register_finalizer_id:
433       {
434         __ set_info(&quot;register_finalizer&quot;, dont_gc_arguments);
435 
436         // Load the klass and check the has finalizer flag.
437         Register klass = Z_ARG2;
438         __ load_klass(klass, Z_ARG1);
439         __ testbit(Address(klass, Klass::access_flags_offset()), exact_log2(JVM_ACC_HAS_FINALIZER));
440         __ z_bcr(Assembler::bcondAllZero, Z_R14); // Return if bit is not set.
441 
442         OopMap* oop_map = save_live_registers(sasm);
443         int call_offset = __ call_RT(noreg, noreg,
444                                      CAST_FROM_FN_PTR(address, SharedRuntime::register_finalizer), Z_ARG1);
445         oop_maps = new OopMapSet();
446         oop_maps-&gt;add_gc_map(call_offset, oop_map);
447 
</pre>
</td>
</tr>
</table>
<center><a href="c1_MacroAssembler_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_globals_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
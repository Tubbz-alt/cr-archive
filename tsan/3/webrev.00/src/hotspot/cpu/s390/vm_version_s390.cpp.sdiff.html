<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/vm_version_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vm_version_ext_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/vm_version_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;code/compiledIC.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;runtime/java.hpp&quot;
  33 #include &quot;runtime/stubCodeGenerator.hpp&quot;
<span class="line-modified">  34 #include &quot;vm_version_s390.hpp&quot;</span>
  35 
  36 # include &lt;sys/sysinfo.h&gt;
  37 
  38 bool VM_Version::_is_determine_features_test_running  = false;
  39 const char*   VM_Version::_model_string;
  40 
  41 unsigned long VM_Version::_features[_features_buffer_len]           = {0, 0, 0, 0};
  42 unsigned long VM_Version::_cipher_features[_features_buffer_len]    = {0, 0, 0, 0};
  43 unsigned long VM_Version::_msgdigest_features[_features_buffer_len] = {0, 0, 0, 0};
  44 unsigned int  VM_Version::_nfeatures                                = 0;
  45 unsigned int  VM_Version::_ncipher_features                         = 0;
  46 unsigned int  VM_Version::_nmsgdigest_features                      = 0;
<span class="line-modified">  47 unsigned int  VM_Version::_Dcache_lineSize                          = 256;</span>
<span class="line-modified">  48 unsigned int  VM_Version::_Icache_lineSize                          = 256;</span>
  49 
  50 static const char* z_gen[]     = {&quot;  &quot;,   &quot;G1&quot;,   &quot;G2&quot;, &quot;G3&quot;,    &quot;G4&quot;,     &quot;G5&quot;,      &quot;G6&quot;,   &quot;G7&quot;   };
  51 static const char* z_machine[] = {&quot;  &quot;, &quot;2064&quot;, &quot;2084&quot;, &quot;2094&quot;,  &quot;2097&quot;,   &quot;2817&quot;,    &quot;  &quot;,   &quot;2964&quot; };
  52 static const char* z_name[]    = {&quot;  &quot;, &quot;z900&quot;, &quot;z990&quot;, &quot;z9 EC&quot;, &quot;z10 EC&quot;, &quot;z196 EC&quot;, &quot;ec12&quot;, &quot;z13&quot;  };
  53 
  54 void VM_Version::initialize() {
  55   determine_features();      // Get processor capabilities.
  56   set_features_string();     // Set a descriptive feature indication.
  57 
  58   if (Verbose) {
  59     print_features();
  60   }
  61 
  62   intx cache_line_size = Dcache_lineSize(0);
  63 

  64   MaxVectorSize = 8;

  65 
  66   if (has_PrefetchRaw()) {
  67     if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {  // not preset
  68       // 0 = no prefetch.
  69       // 1 = Prefetch instructions for each allocation.
  70       // 2 = Use TLAB watermark to gate allocation prefetch.
  71       AllocatePrefetchStyle = 1;
  72     }
  73 
  74     if (AllocatePrefetchStyle &gt; 0) {  // Prefetching turned on at all?
  75       // Distance to prefetch ahead of allocation pointer.
  76       if (FLAG_IS_DEFAULT(AllocatePrefetchDistance) || (AllocatePrefetchDistance &lt; 0)) {  // not preset
  77         AllocatePrefetchDistance = 0;
  78       }
  79 
  80       // Number of lines to prefetch ahead of allocation pointer.
  81       if (FLAG_IS_DEFAULT(AllocatePrefetchLines) || (AllocatePrefetchLines &lt;= 0)) {      // not preset
  82         AllocatePrefetchLines = 3;
  83       }
  84 
</pre>
<hr />
<pre>
 200     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
 201       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
 202     }
 203   } else if (UseSHA256Intrinsics) {
 204     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
 205     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 206   }
 207   if (UseSHA &amp;&amp; has_Crypto_SHA512()) {
 208     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
 209       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
 210     }
 211   } else if (UseSHA512Intrinsics) {
 212     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
 213     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 214   }
 215 
 216   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
 217     FLAG_SET_DEFAULT(UseSHA, false);
 218   }
 219 

 220   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
 221     FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);
 222   }
 223   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
 224     FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, true);
 225   }
 226   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
 227     FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, true);
 228   }

 229   if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
 230     FLAG_SET_DEFAULT(UsePopCountInstruction, true);
 231   }
 232 
 233   // z/Architecture supports 8-byte compare-exchange operations
 234   // (see Atomic::cmpxchg)
 235   // and &#39;atomic long memory ops&#39; (see Unsafe_GetLongVolatile).
 236   _supports_cx8 = true;
 237 
 238   _supports_atomic_getadd4 = VM_Version::has_LoadAndALUAtomicV1();
 239   _supports_atomic_getadd8 = VM_Version::has_LoadAndALUAtomicV1();
 240 
 241   // z/Architecture supports unaligned memory accesses.
 242   // Performance penalty is negligible. An additional tick or so
 243   // is lost if the accessed data spans a cache line boundary.
 244   // Unaligned accesses are not atomic, of course.
 245   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
 246     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
 247   }
 248 }
</pre>
<hr />
<pre>
 499         for (unsigned int i = 0; i &lt; MsgDigest::_featureBits; i++) {
 500           if (test_feature_bit(&amp;_msgdigest_features[2], i, (int)MsgDigest::_featureBits)) {
 501             switch (i) {
 502               case MsgDigest::_Query:  tty-&gt;print_cr(&quot;      available: KLMD Query&quot;);   break;
 503               case MsgDigest::_SHA1:   tty-&gt;print_cr(&quot;      available: KLMD SHA-1&quot;);   break;
 504               case MsgDigest::_SHA256: tty-&gt;print_cr(&quot;      available: KLMD SHA-256&quot;); break;
 505               case MsgDigest::_SHA512: tty-&gt;print_cr(&quot;      available: KLMD SHA-512&quot;); break;
 506               default: tty-&gt;print_cr(&quot;      available: unknown code %d&quot;, i);  break;
 507             }
 508           }
 509         }
 510       }
 511     }
 512     if (ContendedPaddingWidth &gt; 0) {
 513       tty-&gt;cr();
 514       tty-&gt;print_cr(&quot;ContendedPaddingWidth &quot; INTX_FORMAT, ContendedPaddingWidth);
 515     }
 516   }
 517 }
 518 













 519 void VM_Version::print_features() {
 520   print_features_internal(&quot;Version:&quot;);
 521 }
 522 
 523 void VM_Version::reset_features(bool reset) {
 524   if (reset) {
 525     for (unsigned int i = 0; i &lt; _features_buffer_len; i++) {
 526       VM_Version::_features[i] = 0;
 527     }
 528   }
 529 }
 530 
 531 void VM_Version::set_features_z900(bool reset) {
 532   reset_features(reset);
 533 
 534   set_has_long_displacement();
 535   set_has_ETF2();
 536 }
 537 
 538 void VM_Version::set_features_z990(bool reset) {
</pre>
<hr />
<pre>
 774   a-&gt;z_km(Z_R2,Z_R2);                        // get available KM functions
 775   a-&gt;z_la(Z_R1,16,Z_R1);                     // next param block addr
 776   a-&gt;z_kmc(Z_R2,Z_R2);                       // get available KMC functions
 777   a-&gt;z_lghi(Z_RET,4);
 778   a-&gt;z_br(Z_R14);
 779 
 780   // Use EXTRACT CPU ATTRIBUTE instruction to get information about cache layout.
 781   a-&gt;bind(getCPUFEATURES);
 782   a-&gt;z_xgr(Z_R0,Z_R0);                       // as recommended in instruction documentation
 783   a-&gt;z_ecag(Z_RET,Z_R0,0,Z_ARG3);            // Extract information as requested by Z_ARG1 contents.
 784   a-&gt;z_br(Z_R14);
 785 
 786   // Use a vector instruction to verify OS support. Will fail with SIGFPE if OS support is missing.
 787   a-&gt;bind(getVECTORFEATURES);
 788   a-&gt;z_vtm(Z_V0,Z_V0);                       // non-destructive vector instruction. Will cause SIGFPE if not supported.
 789   a-&gt;z_br(Z_R14);
 790 
 791   address code_end = a-&gt;pc();
 792   a-&gt;flush();
 793 


 794   // Print the detection code.
 795   bool printVerbose = Verbose || PrintAssembly || PrintStubCode;
 796   if (printVerbose) {
 797     ttyLocker ttyl;
 798     tty-&gt;print_cr(&quot;Decoding CPU feature detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
 799     tty-&gt;print_cr(&quot;Stub length is %ld bytes, codebuffer reserves %d bytes, %ld bytes spare.&quot;,
 800                   code_end-code, cbuf_size, cbuf_size-(code_end-code));
 801 
<span class="line-modified"> 802     // Use existing decode function. This enables the [Code] format which is needed to DecodeErrorFile.</span>
<span class="line-modified"> 803     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);</span>
 804   }
 805 
 806   // Prepare for detection code execution and clear work buffer.
 807   _nfeatures        = 0;
 808   _ncipher_features = 0;
 809   unsigned long  buffer[buf_len];
 810 
 811   for (int i = 0; i &lt; buf_len; i++) {
 812     buffer[i] = 0L;
 813   }
 814 
 815   // execute code
 816   // Illegal instructions will be replaced by 0 in signal handler.
 817   // In case of problems, call_getFeatures will return a not-positive result.
 818   long used_len = call_getFeatures(buffer, buf_len, 0);
 819 
 820   bool ok;
 821   if (used_len == 1) {
 822     ok = true;
 823   } else if (used_len &gt; 1) {
</pre>
</td>
<td>
<hr />
<pre>
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;code/compiledIC.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;runtime/java.hpp&quot;
  33 #include &quot;runtime/stubCodeGenerator.hpp&quot;
<span class="line-modified">  34 #include &quot;runtime/vm_version.hpp&quot;</span>
  35 
  36 # include &lt;sys/sysinfo.h&gt;
  37 
  38 bool VM_Version::_is_determine_features_test_running  = false;
  39 const char*   VM_Version::_model_string;
  40 
  41 unsigned long VM_Version::_features[_features_buffer_len]           = {0, 0, 0, 0};
  42 unsigned long VM_Version::_cipher_features[_features_buffer_len]    = {0, 0, 0, 0};
  43 unsigned long VM_Version::_msgdigest_features[_features_buffer_len] = {0, 0, 0, 0};
  44 unsigned int  VM_Version::_nfeatures                                = 0;
  45 unsigned int  VM_Version::_ncipher_features                         = 0;
  46 unsigned int  VM_Version::_nmsgdigest_features                      = 0;
<span class="line-modified">  47 unsigned int  VM_Version::_Dcache_lineSize                          = DEFAULT_CACHE_LINE_SIZE;</span>
<span class="line-modified">  48 unsigned int  VM_Version::_Icache_lineSize                          = DEFAULT_CACHE_LINE_SIZE;</span>
  49 
  50 static const char* z_gen[]     = {&quot;  &quot;,   &quot;G1&quot;,   &quot;G2&quot;, &quot;G3&quot;,    &quot;G4&quot;,     &quot;G5&quot;,      &quot;G6&quot;,   &quot;G7&quot;   };
  51 static const char* z_machine[] = {&quot;  &quot;, &quot;2064&quot;, &quot;2084&quot;, &quot;2094&quot;,  &quot;2097&quot;,   &quot;2817&quot;,    &quot;  &quot;,   &quot;2964&quot; };
  52 static const char* z_name[]    = {&quot;  &quot;, &quot;z900&quot;, &quot;z990&quot;, &quot;z9 EC&quot;, &quot;z10 EC&quot;, &quot;z196 EC&quot;, &quot;ec12&quot;, &quot;z13&quot;  };
  53 
  54 void VM_Version::initialize() {
  55   determine_features();      // Get processor capabilities.
  56   set_features_string();     // Set a descriptive feature indication.
  57 
  58   if (Verbose) {
  59     print_features();
  60   }
  61 
  62   intx cache_line_size = Dcache_lineSize(0);
  63 
<span class="line-added">  64 #ifdef COMPILER2</span>
  65   MaxVectorSize = 8;
<span class="line-added">  66 #endif</span>
  67 
  68   if (has_PrefetchRaw()) {
  69     if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {  // not preset
  70       // 0 = no prefetch.
  71       // 1 = Prefetch instructions for each allocation.
  72       // 2 = Use TLAB watermark to gate allocation prefetch.
  73       AllocatePrefetchStyle = 1;
  74     }
  75 
  76     if (AllocatePrefetchStyle &gt; 0) {  // Prefetching turned on at all?
  77       // Distance to prefetch ahead of allocation pointer.
  78       if (FLAG_IS_DEFAULT(AllocatePrefetchDistance) || (AllocatePrefetchDistance &lt; 0)) {  // not preset
  79         AllocatePrefetchDistance = 0;
  80       }
  81 
  82       // Number of lines to prefetch ahead of allocation pointer.
  83       if (FLAG_IS_DEFAULT(AllocatePrefetchLines) || (AllocatePrefetchLines &lt;= 0)) {      // not preset
  84         AllocatePrefetchLines = 3;
  85       }
  86 
</pre>
<hr />
<pre>
 202     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
 203       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
 204     }
 205   } else if (UseSHA256Intrinsics) {
 206     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
 207     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 208   }
 209   if (UseSHA &amp;&amp; has_Crypto_SHA512()) {
 210     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
 211       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
 212     }
 213   } else if (UseSHA512Intrinsics) {
 214     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
 215     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 216   }
 217 
 218   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
 219     FLAG_SET_DEFAULT(UseSHA, false);
 220   }
 221 
<span class="line-added"> 222 #ifdef COMPILER2</span>
 223   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
 224     FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);
 225   }
 226   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
 227     FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, true);
 228   }
 229   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
 230     FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, true);
 231   }
<span class="line-added"> 232 #endif</span>
 233   if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
 234     FLAG_SET_DEFAULT(UsePopCountInstruction, true);
 235   }
 236 
 237   // z/Architecture supports 8-byte compare-exchange operations
 238   // (see Atomic::cmpxchg)
 239   // and &#39;atomic long memory ops&#39; (see Unsafe_GetLongVolatile).
 240   _supports_cx8 = true;
 241 
 242   _supports_atomic_getadd4 = VM_Version::has_LoadAndALUAtomicV1();
 243   _supports_atomic_getadd8 = VM_Version::has_LoadAndALUAtomicV1();
 244 
 245   // z/Architecture supports unaligned memory accesses.
 246   // Performance penalty is negligible. An additional tick or so
 247   // is lost if the accessed data spans a cache line boundary.
 248   // Unaligned accesses are not atomic, of course.
 249   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
 250     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
 251   }
 252 }
</pre>
<hr />
<pre>
 503         for (unsigned int i = 0; i &lt; MsgDigest::_featureBits; i++) {
 504           if (test_feature_bit(&amp;_msgdigest_features[2], i, (int)MsgDigest::_featureBits)) {
 505             switch (i) {
 506               case MsgDigest::_Query:  tty-&gt;print_cr(&quot;      available: KLMD Query&quot;);   break;
 507               case MsgDigest::_SHA1:   tty-&gt;print_cr(&quot;      available: KLMD SHA-1&quot;);   break;
 508               case MsgDigest::_SHA256: tty-&gt;print_cr(&quot;      available: KLMD SHA-256&quot;); break;
 509               case MsgDigest::_SHA512: tty-&gt;print_cr(&quot;      available: KLMD SHA-512&quot;); break;
 510               default: tty-&gt;print_cr(&quot;      available: unknown code %d&quot;, i);  break;
 511             }
 512           }
 513         }
 514       }
 515     }
 516     if (ContendedPaddingWidth &gt; 0) {
 517       tty-&gt;cr();
 518       tty-&gt;print_cr(&quot;ContendedPaddingWidth &quot; INTX_FORMAT, ContendedPaddingWidth);
 519     }
 520   }
 521 }
 522 
<span class="line-added"> 523 void VM_Version::print_platform_virtualization_info(outputStream* st) {</span>
<span class="line-added"> 524   // /proc/sysinfo contains interesting information about</span>
<span class="line-added"> 525   // - LPAR</span>
<span class="line-added"> 526   // - whole &quot;Box&quot; (CPUs )</span>
<span class="line-added"> 527   // - z/VM / KVM (VM&lt;nn&gt;); this is not available in an LPAR-only setup</span>
<span class="line-added"> 528   const char* kw[] = { &quot;LPAR&quot;, &quot;CPUs&quot;, &quot;VM&quot;, NULL };</span>
<span class="line-added"> 529   const char* info_file = &quot;/proc/sysinfo&quot;;</span>
<span class="line-added"> 530 </span>
<span class="line-added"> 531   if (!print_matching_lines_from_file(info_file, st, kw)) {</span>
<span class="line-added"> 532     st-&gt;print_cr(&quot;  &lt;%s Not Available&gt;&quot;, info_file);</span>
<span class="line-added"> 533   }</span>
<span class="line-added"> 534 }</span>
<span class="line-added"> 535 </span>
 536 void VM_Version::print_features() {
 537   print_features_internal(&quot;Version:&quot;);
 538 }
 539 
 540 void VM_Version::reset_features(bool reset) {
 541   if (reset) {
 542     for (unsigned int i = 0; i &lt; _features_buffer_len; i++) {
 543       VM_Version::_features[i] = 0;
 544     }
 545   }
 546 }
 547 
 548 void VM_Version::set_features_z900(bool reset) {
 549   reset_features(reset);
 550 
 551   set_has_long_displacement();
 552   set_has_ETF2();
 553 }
 554 
 555 void VM_Version::set_features_z990(bool reset) {
</pre>
<hr />
<pre>
 791   a-&gt;z_km(Z_R2,Z_R2);                        // get available KM functions
 792   a-&gt;z_la(Z_R1,16,Z_R1);                     // next param block addr
 793   a-&gt;z_kmc(Z_R2,Z_R2);                       // get available KMC functions
 794   a-&gt;z_lghi(Z_RET,4);
 795   a-&gt;z_br(Z_R14);
 796 
 797   // Use EXTRACT CPU ATTRIBUTE instruction to get information about cache layout.
 798   a-&gt;bind(getCPUFEATURES);
 799   a-&gt;z_xgr(Z_R0,Z_R0);                       // as recommended in instruction documentation
 800   a-&gt;z_ecag(Z_RET,Z_R0,0,Z_ARG3);            // Extract information as requested by Z_ARG1 contents.
 801   a-&gt;z_br(Z_R14);
 802 
 803   // Use a vector instruction to verify OS support. Will fail with SIGFPE if OS support is missing.
 804   a-&gt;bind(getVECTORFEATURES);
 805   a-&gt;z_vtm(Z_V0,Z_V0);                       // non-destructive vector instruction. Will cause SIGFPE if not supported.
 806   a-&gt;z_br(Z_R14);
 807 
 808   address code_end = a-&gt;pc();
 809   a-&gt;flush();
 810 
<span class="line-added"> 811   cbuf.insts()-&gt;set_end(code_end);</span>
<span class="line-added"> 812 </span>
 813   // Print the detection code.
 814   bool printVerbose = Verbose || PrintAssembly || PrintStubCode;
 815   if (printVerbose) {
 816     ttyLocker ttyl;
 817     tty-&gt;print_cr(&quot;Decoding CPU feature detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
 818     tty-&gt;print_cr(&quot;Stub length is %ld bytes, codebuffer reserves %d bytes, %ld bytes spare.&quot;,
 819                   code_end-code, cbuf_size, cbuf_size-(code_end-code));
 820 
<span class="line-modified"> 821     // Use existing decode function. This enables the [MachCode] format which is needed to DecodeErrorFile.</span>
<span class="line-modified"> 822     Disassembler::decode(&amp;cbuf, code, code_end, tty);</span>
 823   }
 824 
 825   // Prepare for detection code execution and clear work buffer.
 826   _nfeatures        = 0;
 827   _ncipher_features = 0;
 828   unsigned long  buffer[buf_len];
 829 
 830   for (int i = 0; i &lt; buf_len; i++) {
 831     buffer[i] = 0L;
 832   }
 833 
 834   // execute code
 835   // Illegal instructions will be replaced by 0 in signal handler.
 836   // In case of problems, call_getFeatures will return a not-positive result.
 837   long used_len = call_getFeatures(buffer, buf_len, 0);
 838 
 839   bool ok;
 840   if (used_len == 1) {
 841     ok = true;
 842   } else if (used_len &gt; 1) {
</pre>
</td>
</tr>
</table>
<center><a href="vm_version_ext_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
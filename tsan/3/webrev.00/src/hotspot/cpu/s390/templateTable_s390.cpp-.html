<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/s390/templateTable_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2016, 2018 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/interpreter.hpp&quot;
  30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  31 #include &quot;interpreter/interp_masm.hpp&quot;
  32 #include &quot;interpreter/templateTable.hpp&quot;
  33 #include &quot;memory/universe.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;prims/methodHandles.hpp&quot;
  37 #include &quot;runtime/frame.inline.hpp&quot;
  38 #include &quot;runtime/safepointMechanism.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubRoutines.hpp&quot;
  41 #include &quot;runtime/synchronizer.hpp&quot;
  42 
  43 #ifdef PRODUCT
  44 #define __ _masm-&gt;
  45 #define BLOCK_COMMENT(str)
  46 #define BIND(label)        __ bind(label);
  47 #else
  48 #define __ (PRODUCT_ONLY(false&amp;&amp;)Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm):_masm)-&gt;
  49 #define BLOCK_COMMENT(str) __ block_comment(str)
  50 #define BIND(label)        __ bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  51 #endif
  52 
  53 // The assumed minimum size of a BranchTableBlock.
  54 // The actual size of each block heavily depends on the CPU capabilities and,
  55 // of course, on the logic implemented in each block.
  56 #ifdef ASSERT
  57   #define BTB_MINSIZE 256
  58 #else
  59   #define BTB_MINSIZE  64
  60 #endif
  61 
  62 #ifdef ASSERT
  63 // Macro to open a BranchTableBlock (a piece of code that is branched to by a calculated branch).
  64 #define BTB_BEGIN(lbl, alignment, name)                                        \
  65   __ align_address(alignment);                                                 \
  66   __ bind(lbl);                                                                \
  67   { unsigned int b_off = __ offset();                                          \
  68     uintptr_t   b_addr = (uintptr_t)__ pc();                                   \
  69     __ z_larl(Z_R0, (int64_t)0);     /* Check current address alignment. */    \
  70     __ z_slgr(Z_R0, br_tab);         /* Current Address must be equal    */    \
  71     __ z_slgr(Z_R0, flags);          /* to calculated branch target.     */    \
  72     __ z_brc(Assembler::bcondLogZero, 3); /* skip trap if ok. */               \
  73     __ z_illtrap(0x55);                                                        \
  74     guarantee(b_addr%alignment == 0, &quot;bad alignment at begin of block&quot; name);
  75 
  76 // Macro to close a BranchTableBlock (a piece of code that is branched to by a calculated branch).
  77 #define BTB_END(lbl, alignment, name)                                          \
  78     uintptr_t   e_addr = (uintptr_t)__ pc();                                   \
  79     unsigned int e_off = __ offset();                                          \
  80     unsigned int len   = e_off-b_off;                                          \
  81     if (len &gt; alignment) {                                                     \
  82       tty-&gt;print_cr(&quot;%4d of %4d @ &quot; INTPTR_FORMAT &quot;: Block len for %s&quot;,        \
  83                     len, alignment, e_addr-len, name);                         \
  84       guarantee(len &lt;= alignment, &quot;block too large&quot;);                          \
  85     }                                                                          \
  86     guarantee(len == e_addr-b_addr, &quot;block len mismatch&quot;);                     \
  87   }
  88 #else
  89 // Macro to open a BranchTableBlock (a piece of code that is branched to by a calculated branch).
  90 #define BTB_BEGIN(lbl, alignment, name)                                        \
  91   __ align_address(alignment);                                                 \
  92   __ bind(lbl);                                                                \
  93   { unsigned int b_off = __ offset();                                          \
  94     uintptr_t   b_addr = (uintptr_t)__ pc();                                   \
  95     guarantee(b_addr%alignment == 0, &quot;bad alignment at begin of block&quot; name);
  96 
  97 // Macro to close a BranchTableBlock (a piece of code that is branched to by a calculated branch).
  98 #define BTB_END(lbl, alignment, name)                                          \
  99     uintptr_t   e_addr = (uintptr_t)__ pc();                                   \
 100     unsigned int e_off = __ offset();                                          \
 101     unsigned int len   = e_off-b_off;                                          \
 102     if (len &gt; alignment) {                                                     \
 103       tty-&gt;print_cr(&quot;%4d of %4d @ &quot; INTPTR_FORMAT &quot;: Block len for %s&quot;,        \
 104                     len, alignment, e_addr-len, name);                         \
 105       guarantee(len &lt;= alignment, &quot;block too large&quot;);                          \
 106     }                                                                          \
 107     guarantee(len == e_addr-b_addr, &quot;block len mismatch&quot;);                     \
 108   }
 109 #endif // ASSERT
 110 
 111 // Platform-dependent initialization.
 112 
 113 void TemplateTable::pd_initialize() {
 114   // No specific initialization.
 115 }
 116 
 117 // Address computation: local variables
 118 
 119 static inline Address iaddress(int n) {
 120   return Address(Z_locals, Interpreter::local_offset_in_bytes(n));
 121 }
 122 
 123 static inline Address laddress(int n) {
 124   return iaddress(n + 1);
 125 }
 126 
 127 static inline Address faddress(int n) {
 128   return iaddress(n);
 129 }
 130 
 131 static inline Address daddress(int n) {
 132   return laddress(n);
 133 }
 134 
 135 static inline Address aaddress(int n) {
 136   return iaddress(n);
 137 }
 138 
 139 // Pass NULL, if no shift instruction should be emitted.
 140 static inline Address iaddress(InterpreterMacroAssembler *masm, Register r) {
 141   if (masm) {
 142     masm-&gt;z_sllg(r, r, LogBytesPerWord);  // index2bytes
 143   }
 144   return Address(Z_locals, r, Interpreter::local_offset_in_bytes(0));
 145 }
 146 
 147 // Pass NULL, if no shift instruction should be emitted.
 148 static inline Address laddress(InterpreterMacroAssembler *masm, Register r) {
 149   if (masm) {
 150     masm-&gt;z_sllg(r, r, LogBytesPerWord);  // index2bytes
 151   }
 152   return Address(Z_locals, r, Interpreter::local_offset_in_bytes(1) );
 153 }
 154 
 155 static inline Address faddress(InterpreterMacroAssembler *masm, Register r) {
 156   return iaddress(masm, r);
 157 }
 158 
 159 static inline Address daddress(InterpreterMacroAssembler *masm, Register r) {
 160   return laddress(masm, r);
 161 }
 162 
 163 static inline Address aaddress(InterpreterMacroAssembler *masm, Register r) {
 164   return iaddress(masm, r);
 165 }
 166 
 167 // At top of Java expression stack which may be different than esp(). It
 168 // isn&#39;t for category 1 objects.
 169 static inline Address at_tos(int slot = 0) {
 170   return Address(Z_esp, Interpreter::expr_offset_in_bytes(slot));
 171 }
 172 
 173 // Condition conversion
 174 static Assembler::branch_condition j_not(TemplateTable::Condition cc) {
 175   switch (cc) {
 176     case TemplateTable::equal :
 177       return Assembler::bcondNotEqual;
 178     case TemplateTable::not_equal :
 179       return Assembler::bcondEqual;
 180     case TemplateTable::less :
 181       return Assembler::bcondNotLow;
 182     case TemplateTable::less_equal :
 183       return Assembler::bcondHigh;
 184     case TemplateTable::greater :
 185       return Assembler::bcondNotHigh;
 186     case TemplateTable::greater_equal:
 187       return Assembler::bcondLow;
 188   }
 189   ShouldNotReachHere();
 190   return Assembler::bcondZero;
 191 }
 192 
 193 // Do an oop store like *(base + offset) = val
 194 // offset can be a register or a constant.
 195 static void do_oop_store(InterpreterMacroAssembler* _masm,
 196                          const Address&amp;     addr,
 197                          Register           val,         // Noreg means always null.
 198                          Register           tmp1,
 199                          Register           tmp2,
 200                          Register           tmp3,
 201                          DecoratorSet       decorators) {
 202   assert_different_registers(tmp1, tmp2, tmp3, val, addr.base());
 203   __ store_heap_oop(val, addr, tmp1, tmp2, tmp3, decorators);
 204 }
 205 
 206 static void do_oop_load(InterpreterMacroAssembler* _masm,
 207                         const Address&amp; addr,
 208                         Register dst,
 209                         Register tmp1,
 210                         Register tmp2,
 211                         DecoratorSet decorators) {
 212   assert_different_registers(addr.base(), tmp1, tmp2);
 213   assert_different_registers(dst, tmp1, tmp2);
 214   __ load_heap_oop(dst, addr, tmp1, tmp2, decorators);
 215 }
 216 
 217 Address TemplateTable::at_bcp(int offset) {
 218   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 219   return Address(Z_bcp, offset);
 220 }
 221 
 222 void TemplateTable::patch_bytecode(Bytecodes::Code bc,
 223                                    Register        bc_reg,
 224                                    Register        temp_reg,
 225                                    bool            load_bc_into_bc_reg, // = true
 226                                    int             byte_no) {
 227   if (!RewriteBytecodes) { return; }
 228 
 229   NearLabel L_patch_done;
 230   BLOCK_COMMENT(&quot;patch_bytecode {&quot;);
 231 
 232   switch (bc) {
 233     case Bytecodes::_fast_aputfield:
 234     case Bytecodes::_fast_bputfield:
 235     case Bytecodes::_fast_zputfield:
 236     case Bytecodes::_fast_cputfield:
 237     case Bytecodes::_fast_dputfield:
 238     case Bytecodes::_fast_fputfield:
 239     case Bytecodes::_fast_iputfield:
 240     case Bytecodes::_fast_lputfield:
 241     case Bytecodes::_fast_sputfield:
 242       {
 243         // We skip bytecode quickening for putfield instructions when
 244         // the put_code written to the constant pool cache is zero.
 245         // This is required so that every execution of this instruction
 246         // calls out to InterpreterRuntime::resolve_get_put to do
 247         // additional, required work.
 248         assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 249         assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 250         __ get_cache_and_index_and_bytecode_at_bcp(Z_R1_scratch, bc_reg,
 251                                                    temp_reg, byte_no, 1);
 252         __ load_const_optimized(bc_reg, bc);
 253         __ compareU32_and_branch(temp_reg, (intptr_t)0,
 254                                  Assembler::bcondZero, L_patch_done);
 255       }
 256       break;
 257     default:
 258       assert(byte_no == -1, &quot;sanity&quot;);
 259       // The pair bytecodes have already done the load.
 260       if (load_bc_into_bc_reg) {
 261         __ load_const_optimized(bc_reg, bc);
 262       }
 263       break;
 264   }
 265 
 266   if (JvmtiExport::can_post_breakpoint()) {
 267 
 268     Label   L_fast_patch;
 269 
 270     // If a breakpoint is present we can&#39;t rewrite the stream directly.
 271     __ z_cli(at_bcp(0), Bytecodes::_breakpoint);
 272     __ z_brne(L_fast_patch);
 273     __ get_method(temp_reg);
 274     // Let breakpoint table handling rewrite to quicker bytecode.
 275     __ call_VM_static(noreg,
 276                       CAST_FROM_FN_PTR(address, InterpreterRuntime::set_original_bytecode_at),
 277                       temp_reg, Z_R13, bc_reg);
 278     __ z_bru(L_patch_done);
 279 
 280     __ bind(L_fast_patch);
 281   }
 282 
 283 #ifdef ASSERT
 284   NearLabel   L_okay;
 285 
 286   // We load into 64 bits, since this works on any CPU.
 287   __ z_llgc(temp_reg, at_bcp(0));
 288   __ compareU32_and_branch(temp_reg, Bytecodes::java_code(bc),
 289                             Assembler::bcondEqual, L_okay        );
 290   __ compareU32_and_branch(temp_reg, bc_reg, Assembler::bcondEqual, L_okay);
 291   __ stop_static(&quot;patching the wrong bytecode&quot;);
 292   __ bind(L_okay);
 293 #endif
 294 
 295   // Patch bytecode.
 296   __ z_stc(bc_reg, at_bcp(0));
 297 
 298   __ bind(L_patch_done);
 299   BLOCK_COMMENT(&quot;} patch_bytecode&quot;);
 300 }
 301 
 302 // Individual instructions
 303 
 304 void TemplateTable::nop() {
 305   transition(vtos, vtos);
 306 }
 307 
 308 void TemplateTable::shouldnotreachhere() {
 309   transition(vtos, vtos);
 310   __ stop(&quot;shouldnotreachhere bytecode&quot;);
 311 }
 312 
 313 void TemplateTable::aconst_null() {
 314   transition(vtos, atos);
 315   __ clear_reg(Z_tos, true, false);
 316 }
 317 
 318 void TemplateTable::iconst(int value) {
 319   transition(vtos, itos);
 320   // Zero extension of the iconst makes zero extension at runtime obsolete.
 321   __ load_const_optimized(Z_tos, ((unsigned long)(unsigned int)value));
 322 }
 323 
 324 void TemplateTable::lconst(int value) {
 325   transition(vtos, ltos);
 326   __ load_const_optimized(Z_tos, value);
 327 }
 328 
 329 // No pc-relative load/store for floats.
 330 void TemplateTable::fconst(int value) {
 331   transition(vtos, ftos);
 332   static float   one = 1.0f, two = 2.0f;
 333 
 334   switch (value) {
 335     case 0:
 336       __ z_lzer(Z_ftos);
 337       return;
 338     case 1:
 339       __ load_absolute_address(Z_R1_scratch, (address) &amp;one);
 340       __ mem2freg_opt(Z_ftos, Address(Z_R1_scratch), false);
 341       return;
 342     case 2:
 343       __ load_absolute_address(Z_R1_scratch, (address) &amp;two);
 344       __ mem2freg_opt(Z_ftos, Address(Z_R1_scratch), false);
 345       return;
 346     default:
 347       ShouldNotReachHere();
 348       return;
 349   }
 350 }
 351 
 352 void TemplateTable::dconst(int value) {
 353   transition(vtos, dtos);
 354   static double one = 1.0;
 355 
 356   switch (value) {
 357     case 0:
 358       __ z_lzdr(Z_ftos);
 359       return;
 360     case 1:
 361       __ load_absolute_address(Z_R1_scratch, (address) &amp;one);
 362       __ mem2freg_opt(Z_ftos, Address(Z_R1_scratch));
 363       return;
 364     default:
 365       ShouldNotReachHere();
 366       return;
 367   }
 368 }
 369 
 370 void TemplateTable::bipush() {
 371   transition(vtos, itos);
 372   __ z_lb(Z_tos, at_bcp(1));
 373 }
 374 
 375 void TemplateTable::sipush() {
 376   transition(vtos, itos);
 377   __ get_2_byte_integer_at_bcp(Z_tos, 1, InterpreterMacroAssembler::Signed);
 378 }
 379 
 380 
 381 void TemplateTable::ldc(bool wide) {
 382   transition(vtos, vtos);
 383   Label call_ldc, notFloat, notClass, notInt, Done;
 384   const Register RcpIndex = Z_tmp_1;
 385   const Register Rtags = Z_ARG2;
 386 
 387   if (wide) {
 388     __ get_2_byte_integer_at_bcp(RcpIndex, 1, InterpreterMacroAssembler::Unsigned);
 389   } else {
 390     __ z_llgc(RcpIndex, at_bcp(1));
 391   }
 392 
 393   __ get_cpool_and_tags(Z_tmp_2, Rtags);
 394 
 395   const int      base_offset = ConstantPool::header_size() * wordSize;
 396   const int      tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 397   const Register Raddr_type = Rtags;
 398 
 399   // Get address of type.
 400   __ add2reg_with_index(Raddr_type, tags_offset, RcpIndex, Rtags);
 401 
 402   __ z_cli(0, Raddr_type, JVM_CONSTANT_UnresolvedClass);
 403   __ z_bre(call_ldc);    // Unresolved class - get the resolved class.
 404 
 405   __ z_cli(0, Raddr_type, JVM_CONSTANT_UnresolvedClassInError);
 406   __ z_bre(call_ldc);    // Unresolved class in error state - call into runtime
 407                          // to throw the error from the first resolution attempt.
 408 
 409   __ z_cli(0, Raddr_type, JVM_CONSTANT_Class);
 410   __ z_brne(notClass);   // Resolved class - need to call vm to get java
 411                          // mirror of the class.
 412 
 413   // We deal with a class. Call vm to do the appropriate.
 414   __ bind(call_ldc);
 415   __ load_const_optimized(Z_ARG2, wide);
 416   call_VM(Z_RET, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), Z_ARG2);
 417   __ push_ptr(Z_RET);
 418   __ z_bru(Done);
 419 
 420   // Not a class.
 421   __ bind(notClass);
 422   Register RcpOffset = RcpIndex;
 423   __ z_sllg(RcpOffset, RcpIndex, LogBytesPerWord); // Convert index to offset.
 424   __ z_cli(0, Raddr_type, JVM_CONSTANT_Float);
 425   __ z_brne(notFloat);
 426 
 427   // ftos
 428   __ mem2freg_opt(Z_ftos, Address(Z_tmp_2, RcpOffset, base_offset), false);
 429   __ push_f();
 430   __ z_bru(Done);
 431 
 432   __ bind(notFloat);
 433   __ z_cli(0, Raddr_type, JVM_CONSTANT_Integer);
 434   __ z_brne(notInt);
 435 
 436   // itos
 437   __ mem2reg_opt(Z_tos, Address(Z_tmp_2, RcpOffset, base_offset), false);
 438   __ push_i(Z_tos);
 439   __ z_bru(Done);
 440 
 441   // assume the tag is for condy; if not, the VM runtime will tell us
 442   __ bind(notInt);
 443   condy_helper(Done);
 444 
 445   __ bind(Done);
 446 }
 447 
 448 // Fast path for caching oop constants.
 449 // %%% We should use this to handle Class and String constants also.
 450 // %%% It will simplify the ldc/primitive path considerably.
 451 void TemplateTable::fast_aldc(bool wide) {
 452   transition(vtos, atos);
 453 
 454   const Register index = Z_tmp_2;
 455   int            index_size = wide ? sizeof(u2) : sizeof(u1);
 456   Label          L_do_resolve, L_resolved;
 457 
 458   // We are resolved if the resolved reference cache entry contains a
 459   // non-null object (CallSite, etc.).
 460   __ get_cache_index_at_bcp(index, 1, index_size);  // Load index.
 461   __ load_resolved_reference_at_index(Z_tos, index);
 462   __ z_ltgr(Z_tos, Z_tos);
 463   __ z_bre(L_do_resolve);
 464 
 465   // Convert null sentinel to NULL.
 466   __ load_const_optimized(Z_R1_scratch, (intptr_t)Universe::the_null_sentinel_addr());
 467   __ z_cg(Z_tos, Address(Z_R1_scratch));
 468   __ z_brne(L_resolved);
 469   __ clear_reg(Z_tos);
 470   __ z_bru(L_resolved);
 471 
 472   __ bind(L_do_resolve);
 473   // First time invocation - must resolve first.
 474   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 475   __ load_const_optimized(Z_ARG1, (int)bytecode());
 476   __ call_VM(Z_tos, entry, Z_ARG1);
 477 
 478   __ bind(L_resolved);
 479   __ verify_oop(Z_tos);
 480 }
 481 
 482 void TemplateTable::ldc2_w() {
 483   transition(vtos, vtos);
 484   Label notDouble, notLong, Done;
 485 
 486   // Z_tmp_1 = index of cp entry
 487   __ get_2_byte_integer_at_bcp(Z_tmp_1, 1, InterpreterMacroAssembler::Unsigned);
 488 
 489   __ get_cpool_and_tags(Z_tmp_2, Z_tos);
 490 
 491   const int base_offset = ConstantPool::header_size() * wordSize;
 492   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 493 
 494   // Get address of type.
 495   __ add2reg_with_index(Z_tos, tags_offset, Z_tos, Z_tmp_1);
 496 
 497   // Index needed in both branches, so calculate here.
 498   __ z_sllg(Z_tmp_1, Z_tmp_1, LogBytesPerWord);  // index2bytes
 499 
 500   // Check type.
 501   __ z_cli(0, Z_tos, JVM_CONSTANT_Double);
 502   __ z_brne(notDouble);
 503   // dtos
 504   __ mem2freg_opt(Z_ftos, Address(Z_tmp_2, Z_tmp_1, base_offset));
 505   __ push_d();
 506   __ z_bru(Done);
 507 
 508   __ bind(notDouble);
 509   __ z_cli(0, Z_tos, JVM_CONSTANT_Long);
 510   __ z_brne(notLong);
 511   // ltos
 512   __ mem2reg_opt(Z_tos, Address(Z_tmp_2, Z_tmp_1, base_offset));
 513   __ push_l();
 514   __ z_bru(Done);
 515 
 516   __ bind(notLong);
 517   condy_helper(Done);
 518 
 519   __ bind(Done);
 520 }
 521 
 522 void TemplateTable::condy_helper(Label&amp; Done) {
 523   const Register obj   = Z_tmp_1;
 524   const Register off   = Z_tmp_2;
 525   const Register flags = Z_ARG1;
 526   const Register rarg  = Z_ARG2;
 527   __ load_const_optimized(rarg, (int)bytecode());
 528   call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc), rarg);
 529   __ get_vm_result_2(flags);
 530 
 531   // VMr = obj = base address to find primitive value to push
 532   // VMr2 = flags = (tos, off) using format of CPCE::_flags
 533   assert(ConstantPoolCacheEntry::field_index_mask == 0xffff, &quot;or use other instructions&quot;);
 534   __ z_llghr(off, flags);
 535   const Address field(obj, off);
 536 
 537   // What sort of thing are we loading?
 538   __ z_srl(flags, ConstantPoolCacheEntry::tos_state_shift);
 539   // Make sure we don&#39;t need to mask flags for tos_state after the above shift.
 540   ConstantPoolCacheEntry::verify_tos_state_shift();
 541 
 542   switch (bytecode()) {
 543   case Bytecodes::_ldc:
 544   case Bytecodes::_ldc_w:
 545     {
 546       // tos in (itos, ftos, stos, btos, ctos, ztos)
 547       Label notInt, notFloat, notShort, notByte, notChar, notBool;
 548       __ z_cghi(flags, itos);
 549       __ z_brne(notInt);
 550       // itos
 551       __ z_l(Z_tos, field);
 552       __ push(itos);
 553       __ z_bru(Done);
 554 
 555       __ bind(notInt);
 556       __ z_cghi(flags, ftos);
 557       __ z_brne(notFloat);
 558       // ftos
 559       __ z_le(Z_ftos, field);
 560       __ push(ftos);
 561       __ z_bru(Done);
 562 
 563       __ bind(notFloat);
 564       __ z_cghi(flags, stos);
 565       __ z_brne(notShort);
 566       // stos
 567       __ z_lh(Z_tos, field);
 568       __ push(stos);
 569       __ z_bru(Done);
 570 
 571       __ bind(notShort);
 572       __ z_cghi(flags, btos);
 573       __ z_brne(notByte);
 574       // btos
 575       __ z_lb(Z_tos, field);
 576       __ push(btos);
 577       __ z_bru(Done);
 578 
 579       __ bind(notByte);
 580       __ z_cghi(flags, ctos);
 581       __ z_brne(notChar);
 582       // ctos
 583       __ z_llh(Z_tos, field);
 584       __ push(ctos);
 585       __ z_bru(Done);
 586 
 587       __ bind(notChar);
 588       __ z_cghi(flags, ztos);
 589       __ z_brne(notBool);
 590       // ztos
 591       __ z_lb(Z_tos, field);
 592       __ push(ztos);
 593       __ z_bru(Done);
 594 
 595       __ bind(notBool);
 596       break;
 597     }
 598 
 599   case Bytecodes::_ldc2_w:
 600     {
 601       Label notLong, notDouble;
 602       __ z_cghi(flags, ltos);
 603       __ z_brne(notLong);
 604       // ltos
 605       __ z_lg(Z_tos, field);
 606       __ push(ltos);
 607       __ z_bru(Done);
 608 
 609       __ bind(notLong);
 610       __ z_cghi(flags, dtos);
 611       __ z_brne(notDouble);
 612       // dtos
 613       __ z_ld(Z_ftos, field);
 614       __ push(dtos);
 615       __ z_bru(Done);
 616 
 617       __ bind(notDouble);
 618       break;
 619     }
 620 
 621   default:
 622     ShouldNotReachHere();
 623   }
 624 
 625   __ stop(&quot;bad ldc/condy&quot;);
 626 }
 627 
 628 void TemplateTable::locals_index(Register reg, int offset) {
 629   __ z_llgc(reg, at_bcp(offset));
 630   __ z_lcgr(reg);
 631 }
 632 
 633 void TemplateTable::iload() {
 634   iload_internal();
 635 }
 636 
 637 void TemplateTable::nofast_iload() {
 638   iload_internal(may_not_rewrite);
 639 }
 640 
 641 void TemplateTable::iload_internal(RewriteControl rc) {
 642   transition(vtos, itos);
 643 
 644   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 645     NearLabel rewrite, done;
 646     const Register bc = Z_ARG4;
 647 
 648     assert(Z_R1_scratch != bc, &quot;register damaged&quot;);
 649 
 650     // Get next byte.
 651     __ z_llgc(Z_R1_scratch, at_bcp(Bytecodes::length_for (Bytecodes::_iload)));
 652 
 653     // If _iload, wait to rewrite to iload2. We only want to rewrite the
 654     // last two iloads in a pair. Comparing against fast_iload means that
 655     // the next bytecode is neither an iload or a caload, and therefore
 656     // an iload pair.
 657     __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_iload,
 658                              Assembler::bcondEqual, done);
 659 
 660     __ load_const_optimized(bc, Bytecodes::_fast_iload2);
 661     __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_fast_iload,
 662                              Assembler::bcondEqual, rewrite);
 663 
 664     // If _caload, rewrite to fast_icaload.
 665     __ load_const_optimized(bc, Bytecodes::_fast_icaload);
 666     __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_caload,
 667                              Assembler::bcondEqual, rewrite);
 668 
 669     // Rewrite so iload doesn&#39;t check again.
 670     __ load_const_optimized(bc, Bytecodes::_fast_iload);
 671 
 672     // rewrite
 673     // bc: fast bytecode
 674     __ bind(rewrite);
 675     patch_bytecode(Bytecodes::_iload, bc, Z_R1_scratch, false);
 676 
 677     __ bind(done);
 678 
 679   }
 680 
 681   // Get the local value into tos.
 682   locals_index(Z_R1_scratch);
 683   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
 684 }
 685 
 686 void TemplateTable::fast_iload2() {
 687   transition(vtos, itos);
 688 
 689   locals_index(Z_R1_scratch);
 690   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
 691   __ push_i(Z_tos);
 692   locals_index(Z_R1_scratch, 3);
 693   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
 694 }
 695 
 696 void TemplateTable::fast_iload() {
 697   transition(vtos, itos);
 698 
 699   locals_index(Z_R1_scratch);
 700   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
 701 }
 702 
 703 void TemplateTable::lload() {
 704   transition(vtos, ltos);
 705 
 706   locals_index(Z_R1_scratch);
 707   __ mem2reg_opt(Z_tos, laddress(_masm, Z_R1_scratch));
 708 }
 709 
 710 void TemplateTable::fload() {
 711   transition(vtos, ftos);
 712 
 713   locals_index(Z_R1_scratch);
 714   __ mem2freg_opt(Z_ftos, faddress(_masm, Z_R1_scratch), false);
 715 }
 716 
 717 void TemplateTable::dload() {
 718   transition(vtos, dtos);
 719 
 720   locals_index(Z_R1_scratch);
 721   __ mem2freg_opt(Z_ftos, daddress(_masm, Z_R1_scratch));
 722 }
 723 
 724 void TemplateTable::aload() {
 725   transition(vtos, atos);
 726 
 727   locals_index(Z_R1_scratch);
 728   __ mem2reg_opt(Z_tos, aaddress(_masm, Z_R1_scratch));
 729 }
 730 
 731 void TemplateTable::locals_index_wide(Register reg) {
 732   __ get_2_byte_integer_at_bcp(reg, 2, InterpreterMacroAssembler::Unsigned);
 733   __ z_lcgr(reg);
 734 }
 735 
 736 void TemplateTable::wide_iload() {
 737   transition(vtos, itos);
 738 
 739   locals_index_wide(Z_tmp_1);
 740   __ mem2reg_opt(Z_tos, iaddress(_masm, Z_tmp_1), false);
 741 }
 742 
 743 void TemplateTable::wide_lload() {
 744   transition(vtos, ltos);
 745 
 746   locals_index_wide(Z_tmp_1);
 747   __ mem2reg_opt(Z_tos, laddress(_masm, Z_tmp_1));
 748 }
 749 
 750 void TemplateTable::wide_fload() {
 751   transition(vtos, ftos);
 752 
 753   locals_index_wide(Z_tmp_1);
 754   __ mem2freg_opt(Z_ftos, faddress(_masm, Z_tmp_1), false);
 755 }
 756 
 757 void TemplateTable::wide_dload() {
 758   transition(vtos, dtos);
 759 
 760   locals_index_wide(Z_tmp_1);
 761   __ mem2freg_opt(Z_ftos, daddress(_masm, Z_tmp_1));
 762 }
 763 
 764 void TemplateTable::wide_aload() {
 765   transition(vtos, atos);
 766 
 767   locals_index_wide(Z_tmp_1);
 768   __ mem2reg_opt(Z_tos, aaddress(_masm, Z_tmp_1));
 769 }
 770 
 771 void TemplateTable::index_check(Register array, Register index, unsigned int shift) {
 772   assert_different_registers(Z_R1_scratch, array, index);
 773 
 774   // Check array.
 775   __ null_check(array, Z_R0_scratch, arrayOopDesc::length_offset_in_bytes());
 776 
 777   // Sign extend index for use by indexed load.
 778   __ z_lgfr(index, index);
 779 
 780   // Check index.
 781   Label index_ok;
 782   __ z_cl(index, Address(array, arrayOopDesc::length_offset_in_bytes()));
 783   __ z_brl(index_ok);
 784   __ lgr_if_needed(Z_ARG3, index); // See generate_ArrayIndexOutOfBounds_handler().
 785   // Pass the array to create more detailed exceptions.
 786   __ lgr_if_needed(Z_ARG2, array); // See generate_ArrayIndexOutOfBounds_handler().
 787   __ load_absolute_address(Z_R1_scratch,
 788                            Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);
 789   __ z_bcr(Assembler::bcondAlways, Z_R1_scratch);
 790   __ bind(index_ok);
 791 
 792   if (shift &gt; 0)
 793     __ z_sllg(index, index, shift);
 794 }
 795 
 796 void TemplateTable::iaload() {
 797   transition(itos, itos);
 798 
 799   __ pop_ptr(Z_tmp_1);  // array
 800   // Index is in Z_tos.
 801   Register index = Z_tos;
 802   index_check(Z_tmp_1, index, LogBytesPerInt); // Kills Z_ARG3.
 803   // Load the value.
 804   __ mem2reg_opt(Z_tos,
 805                  Address(Z_tmp_1, index, arrayOopDesc::base_offset_in_bytes(T_INT)),
 806                  false);
 807 }
 808 
 809 void TemplateTable::laload() {
 810   transition(itos, ltos);
 811 
 812   __ pop_ptr(Z_tmp_2);
 813   // Z_tos   : index
 814   // Z_tmp_2 : array
 815   Register index = Z_tos;
 816   index_check(Z_tmp_2, index, LogBytesPerLong);
 817   __ mem2reg_opt(Z_tos,
 818                  Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_LONG)));
 819 }
 820 
 821 void TemplateTable::faload() {
 822   transition(itos, ftos);
 823 
 824   __ pop_ptr(Z_tmp_2);
 825   // Z_tos   : index
 826   // Z_tmp_2 : array
 827   Register index = Z_tos;
 828   index_check(Z_tmp_2, index, LogBytesPerInt);
 829   __ mem2freg_opt(Z_ftos,
 830                   Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
 831                   false);
 832 }
 833 
 834 void TemplateTable::daload() {
 835   transition(itos, dtos);
 836 
 837   __ pop_ptr(Z_tmp_2);
 838   // Z_tos   : index
 839   // Z_tmp_2 : array
 840   Register index = Z_tos;
 841   index_check(Z_tmp_2, index, LogBytesPerLong);
 842   __ mem2freg_opt(Z_ftos,
 843                   Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_DOUBLE)));
 844 }
 845 
 846 void TemplateTable::aaload() {
 847   transition(itos, atos);
 848 
 849   unsigned const int shift = LogBytesPerHeapOop;
 850   __ pop_ptr(Z_tmp_1);  // array
 851   // Index is in Z_tos.
 852   Register index = Z_tos;
 853   index_check(Z_tmp_1, index, shift);
 854   // Now load array element.
 855   do_oop_load(_masm, Address(Z_tmp_1, index, arrayOopDesc::base_offset_in_bytes(T_OBJECT)), Z_tos,
 856               Z_tmp_2, Z_tmp_3, IS_ARRAY);
 857   __ verify_oop(Z_tos);
 858 }
 859 
 860 void TemplateTable::baload() {
 861   transition(itos, itos);
 862 
 863   __ pop_ptr(Z_tmp_1);
 864   // Z_tos   : index
 865   // Z_tmp_1 : array
 866   Register index = Z_tos;
 867   index_check(Z_tmp_1, index, 0);
 868   __ z_lb(Z_tos,
 869           Address(Z_tmp_1, index, arrayOopDesc::base_offset_in_bytes(T_BYTE)));
 870 }
 871 
 872 void TemplateTable::caload() {
 873   transition(itos, itos);
 874 
 875   __ pop_ptr(Z_tmp_2);
 876   // Z_tos   : index
 877   // Z_tmp_2 : array
 878   Register index = Z_tos;
 879   index_check(Z_tmp_2, index, LogBytesPerShort);
 880   // Load into 64 bits, works on all CPUs.
 881   __ z_llgh(Z_tos,
 882             Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_CHAR)));
 883 }
 884 
 885 // Iload followed by caload frequent pair.
 886 void TemplateTable::fast_icaload() {
 887   transition(vtos, itos);
 888 
 889   // Load index out of locals.
 890   locals_index(Z_R1_scratch);
 891   __ mem2reg_opt(Z_ARG3, iaddress(_masm, Z_R1_scratch), false);
 892   // Z_ARG3  : index
 893   // Z_tmp_2 : array
 894   __ pop_ptr(Z_tmp_2);
 895   index_check(Z_tmp_2, Z_ARG3, LogBytesPerShort);
 896   // Load into 64 bits, works on all CPUs.
 897   __ z_llgh(Z_tos,
 898             Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_CHAR)));
 899 }
 900 
 901 void TemplateTable::saload() {
 902   transition(itos, itos);
 903 
 904   __ pop_ptr(Z_tmp_2);
 905   // Z_tos   : index
 906   // Z_tmp_2 : array
 907   Register index = Z_tos;
 908   index_check(Z_tmp_2, index, LogBytesPerShort);
 909   __ z_lh(Z_tos,
 910           Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_SHORT)));
 911 }
 912 
 913 void TemplateTable::iload(int n) {
 914   transition(vtos, itos);
 915   __ z_ly(Z_tos, iaddress(n));
 916 }
 917 
 918 void TemplateTable::lload(int n) {
 919   transition(vtos, ltos);
 920   __ z_lg(Z_tos, laddress(n));
 921 }
 922 
 923 void TemplateTable::fload(int n) {
 924   transition(vtos, ftos);
 925   __ mem2freg_opt(Z_ftos, faddress(n), false);
 926 }
 927 
 928 void TemplateTable::dload(int n) {
 929   transition(vtos, dtos);
 930   __ mem2freg_opt(Z_ftos, daddress(n));
 931 }
 932 
 933 void TemplateTable::aload(int n) {
 934   transition(vtos, atos);
 935   __ mem2reg_opt(Z_tos, aaddress(n));
 936 }
 937 
 938 void TemplateTable::aload_0() {
 939   aload_0_internal();
 940 }
 941 
 942 void TemplateTable::nofast_aload_0() {
 943   aload_0_internal(may_not_rewrite);
 944 }
 945 
 946 void TemplateTable::aload_0_internal(RewriteControl rc) {
 947   transition(vtos, atos);
 948 
 949   // According to bytecode histograms, the pairs:
 950   //
 951   // _aload_0, _fast_igetfield
 952   // _aload_0, _fast_agetfield
 953   // _aload_0, _fast_fgetfield
 954   //
 955   // occur frequently. If RewriteFrequentPairs is set, the (slow)
 956   // _aload_0 bytecode checks if the next bytecode is either
 957   // _fast_igetfield, _fast_agetfield or _fast_fgetfield and then
 958   // rewrites the current bytecode into a pair bytecode; otherwise it
 959   // rewrites the current bytecode into _fast_aload_0 that doesn&#39;t do
 960   // the pair check anymore.
 961   //
 962   // Note: If the next bytecode is _getfield, the rewrite must be
 963   //       delayed, otherwise we may miss an opportunity for a pair.
 964   //
 965   // Also rewrite frequent pairs
 966   //   aload_0, aload_1
 967   //   aload_0, iload_1
 968   // These bytecodes with a small amount of code are most profitable
 969   // to rewrite.
 970   if (!(RewriteFrequentPairs &amp;&amp; (rc == may_rewrite))) {
 971     aload(0);
 972     return;
 973   }
 974 
 975   NearLabel rewrite, done;
 976   const Register bc = Z_ARG4;
 977 
 978   assert(Z_R1_scratch != bc, &quot;register damaged&quot;);
 979   // Get next byte.
 980   __ z_llgc(Z_R1_scratch, at_bcp(Bytecodes::length_for (Bytecodes::_aload_0)));
 981 
 982   // Do actual aload_0.
 983   aload(0);
 984 
 985   // If _getfield then wait with rewrite.
 986   __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_getfield,
 987                            Assembler::bcondEqual, done);
 988 
 989   // If _igetfield then rewrite to _fast_iaccess_0.
 990   assert(Bytecodes::java_code(Bytecodes::_fast_iaccess_0)
 991             == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
 992 
 993   __ load_const_optimized(bc, Bytecodes::_fast_iaccess_0);
 994   __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_fast_igetfield,
 995                            Assembler::bcondEqual, rewrite);
 996 
 997   // If _agetfield then rewrite to _fast_aaccess_0.
 998   assert(Bytecodes::java_code(Bytecodes::_fast_aaccess_0)
 999             == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1000 
1001   __ load_const_optimized(bc, Bytecodes::_fast_aaccess_0);
1002   __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_fast_agetfield,
1003                            Assembler::bcondEqual, rewrite);
1004 
1005   // If _fgetfield then rewrite to _fast_faccess_0.
1006   assert(Bytecodes::java_code(Bytecodes::_fast_faccess_0)
1007             == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1008 
1009   __ load_const_optimized(bc, Bytecodes::_fast_faccess_0);
1010   __ compareU32_and_branch(Z_R1_scratch, Bytecodes::_fast_fgetfield,
1011                            Assembler::bcondEqual, rewrite);
1012 
1013   // Else rewrite to _fast_aload0.
1014   assert(Bytecodes::java_code(Bytecodes::_fast_aload_0)
1015             == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1016   __ load_const_optimized(bc, Bytecodes::_fast_aload_0);
1017 
1018   // rewrite
1019   // bc: fast bytecode
1020   __ bind(rewrite);
1021 
1022   patch_bytecode(Bytecodes::_aload_0, bc, Z_R1_scratch, false);
1023   // Reload local 0 because of VM call inside patch_bytecode().
1024   // this may trigger GC and thus change the oop.
1025   aload(0);
1026 
1027   __ bind(done);
1028 }
1029 
1030 void TemplateTable::istore() {
1031   transition(itos, vtos);
1032   locals_index(Z_R1_scratch);
1033   __ reg2mem_opt(Z_tos, iaddress(_masm, Z_R1_scratch), false);
1034 }
1035 
1036 void TemplateTable::lstore() {
1037   transition(ltos, vtos);
1038   locals_index(Z_R1_scratch);
1039   __ reg2mem_opt(Z_tos, laddress(_masm, Z_R1_scratch));
1040 }
1041 
1042 void TemplateTable::fstore() {
1043   transition(ftos, vtos);
1044   locals_index(Z_R1_scratch);
1045   __ freg2mem_opt(Z_ftos, faddress(_masm, Z_R1_scratch));
1046 }
1047 
1048 void TemplateTable::dstore() {
1049   transition(dtos, vtos);
1050   locals_index(Z_R1_scratch);
1051   __ freg2mem_opt(Z_ftos, daddress(_masm, Z_R1_scratch));
1052 }
1053 
1054 void TemplateTable::astore() {
1055   transition(vtos, vtos);
1056   __ pop_ptr(Z_tos);
1057   locals_index(Z_R1_scratch);
1058   __ reg2mem_opt(Z_tos, aaddress(_masm, Z_R1_scratch));
1059 }
1060 
1061 void TemplateTable::wide_istore() {
1062   transition(vtos, vtos);
1063   __ pop_i(Z_tos);
1064   locals_index_wide(Z_tmp_1);
1065   __ reg2mem_opt(Z_tos, iaddress(_masm, Z_tmp_1), false);
1066 }
1067 
1068 void TemplateTable::wide_lstore() {
1069   transition(vtos, vtos);
1070   __ pop_l(Z_tos);
1071   locals_index_wide(Z_tmp_1);
1072   __ reg2mem_opt(Z_tos, laddress(_masm, Z_tmp_1));
1073 }
1074 
1075 void TemplateTable::wide_fstore() {
1076   transition(vtos, vtos);
1077   __ pop_f(Z_ftos);
1078   locals_index_wide(Z_tmp_1);
1079   __ freg2mem_opt(Z_ftos, faddress(_masm, Z_tmp_1), false);
1080 }
1081 
1082 void TemplateTable::wide_dstore() {
1083   transition(vtos, vtos);
1084   __ pop_d(Z_ftos);
1085   locals_index_wide(Z_tmp_1);
1086   __ freg2mem_opt(Z_ftos, daddress(_masm, Z_tmp_1));
1087 }
1088 
1089 void TemplateTable::wide_astore() {
1090   transition(vtos, vtos);
1091   __ pop_ptr(Z_tos);
1092   locals_index_wide(Z_tmp_1);
1093   __ reg2mem_opt(Z_tos, aaddress(_masm, Z_tmp_1));
1094 }
1095 
1096 void TemplateTable::iastore() {
1097   transition(itos, vtos);
1098 
1099   Register index = Z_ARG3; // Index_check expects index in Z_ARG3.
1100   // Value is in Z_tos ...
1101   __ pop_i(index);        // index
1102   __ pop_ptr(Z_tmp_1);    // array
1103   index_check(Z_tmp_1, index, LogBytesPerInt);
1104   // ... and then move the value.
1105   __ reg2mem_opt(Z_tos,
1106                  Address(Z_tmp_1, index, arrayOopDesc::base_offset_in_bytes(T_INT)),
1107                  false);
1108 }
1109 
1110 void TemplateTable::lastore() {
1111   transition(ltos, vtos);
1112 
1113   __ pop_i(Z_ARG3);
1114   __ pop_ptr(Z_tmp_2);
1115   // Z_tos   : value
1116   // Z_ARG3  : index
1117   // Z_tmp_2 : array
1118  index_check(Z_tmp_2, Z_ARG3, LogBytesPerLong); // Prefer index in Z_ARG3.
1119   __ reg2mem_opt(Z_tos,
1120                  Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_LONG)));
1121 }
1122 
1123 void TemplateTable::fastore() {
1124   transition(ftos, vtos);
1125 
1126   __ pop_i(Z_ARG3);
1127   __ pop_ptr(Z_tmp_2);
1128   // Z_ftos  : value
1129   // Z_ARG3  : index
1130   // Z_tmp_2 : array
1131   index_check(Z_tmp_2, Z_ARG3, LogBytesPerInt); // Prefer index in Z_ARG3.
1132   __ freg2mem_opt(Z_ftos,
1133                   Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_FLOAT)),
1134                   false);
1135 }
1136 
1137 void TemplateTable::dastore() {
1138   transition(dtos, vtos);
1139 
1140   __ pop_i(Z_ARG3);
1141   __ pop_ptr(Z_tmp_2);
1142   // Z_ftos  : value
1143   // Z_ARG3  : index
1144   // Z_tmp_2 : array
1145   index_check(Z_tmp_2, Z_ARG3, LogBytesPerLong); // Prefer index in Z_ARG3.
1146   __ freg2mem_opt(Z_ftos,
1147                   Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_DOUBLE)));
1148 }
1149 
1150 void TemplateTable::aastore() {
1151   NearLabel is_null, ok_is_subtype, done;
1152   transition(vtos, vtos);
1153 
1154   // stack: ..., array, index, value
1155 
1156   Register Rvalue = Z_tos;
1157   Register Rarray = Z_ARG2;
1158   Register Rindex = Z_ARG3; // Convention for index_check().
1159 
1160   __ load_ptr(0, Rvalue);
1161   __ z_l(Rindex, Address(Z_esp, Interpreter::expr_offset_in_bytes(1)));
1162   __ load_ptr(2, Rarray);
1163 
1164   unsigned const int shift = LogBytesPerHeapOop;
1165   index_check(Rarray, Rindex, shift); // side effect: Rindex = Rindex &lt;&lt; shift
1166   Register Rstore_addr  = Rindex;
1167   // Address where the store goes to, i.e. &amp;(Rarry[index])
1168   __ load_address(Rstore_addr, Address(Rarray, Rindex, arrayOopDesc::base_offset_in_bytes(T_OBJECT)));
1169 
1170   // do array store check - check for NULL value first.
1171   __ compareU64_and_branch(Rvalue, (intptr_t)0, Assembler::bcondEqual, is_null);
1172 
1173   Register Rsub_klass   = Z_ARG4;
1174   Register Rsuper_klass = Z_ARG5;
1175   __ load_klass(Rsub_klass, Rvalue);
1176   // Load superklass.
1177   __ load_klass(Rsuper_klass, Rarray);
1178   __ z_lg(Rsuper_klass, Address(Rsuper_klass, ObjArrayKlass::element_klass_offset()));
1179 
1180   // Generate a fast subtype check.  Branch to ok_is_subtype if no failure.
1181   // Throw if failure.
1182   Register tmp1 = Z_tmp_1;
1183   Register tmp2 = Z_tmp_2;
1184   __ gen_subtype_check(Rsub_klass, Rsuper_klass, tmp1, tmp2, ok_is_subtype);
1185 
1186   // Fall through on failure.
1187   // Object is in Rvalue == Z_tos.
1188   assert(Rvalue == Z_tos, &quot;that&#39;s the expected location&quot;);
1189   __ load_absolute_address(tmp1, Interpreter::_throw_ArrayStoreException_entry);
1190   __ z_br(tmp1);
1191 
1192   Register tmp3 = Rsub_klass;
1193 
1194   // Have a NULL in Rvalue.
1195   __ bind(is_null);
1196   __ profile_null_seen(tmp1);
1197 
1198   // Store a NULL.
1199   do_oop_store(_masm, Address(Rstore_addr, (intptr_t)0), noreg,
1200                tmp3, tmp2, tmp1, IS_ARRAY);
1201   __ z_bru(done);
1202 
1203   // Come here on success.
1204   __ bind(ok_is_subtype);
1205 
1206   // Now store using the appropriate barrier.
1207   do_oop_store(_masm, Address(Rstore_addr, (intptr_t)0), Rvalue,
1208                tmp3, tmp2, tmp1, IS_ARRAY | IS_NOT_NULL);
1209 
1210   // Pop stack arguments.
1211   __ bind(done);
1212   __ add2reg(Z_esp, 3 * Interpreter::stackElementSize);
1213 }
1214 
1215 
1216 void TemplateTable::bastore() {
1217   transition(itos, vtos);
1218 
1219   __ pop_i(Z_ARG3);
1220   __ pop_ptr(Z_tmp_2);
1221   // Z_tos   : value
1222   // Z_ARG3  : index
1223   // Z_tmp_2 : array
1224 
1225   // Need to check whether array is boolean or byte
1226   // since both types share the bastore bytecode.
1227   __ load_klass(Z_tmp_1, Z_tmp_2);
1228   __ z_llgf(Z_tmp_1, Address(Z_tmp_1, Klass::layout_helper_offset()));
1229   __ z_tmll(Z_tmp_1, Klass::layout_helper_boolean_diffbit());
1230   Label L_skip;
1231   __ z_bfalse(L_skip);
1232   // if it is a T_BOOLEAN array, mask the stored value to 0/1
1233   __ z_nilf(Z_tos, 0x1);
1234   __ bind(L_skip);
1235 
1236   // No index shift necessary - pass 0.
1237   index_check(Z_tmp_2, Z_ARG3, 0); // Prefer index in Z_ARG3.
1238   __ z_stc(Z_tos,
1239            Address(Z_tmp_2, Z_ARG3, arrayOopDesc::base_offset_in_bytes(T_BYTE)));
1240 }
1241 
1242 void TemplateTable::castore() {
1243   transition(itos, vtos);
1244 
1245   __ pop_i(Z_ARG3);
1246   __ pop_ptr(Z_tmp_2);
1247   // Z_tos   : value
1248   // Z_ARG3  : index
1249   // Z_tmp_2 : array
1250   Register index = Z_ARG3; // prefer index in Z_ARG3
1251   index_check(Z_tmp_2, index, LogBytesPerShort);
1252   __ z_sth(Z_tos,
1253            Address(Z_tmp_2, index, arrayOopDesc::base_offset_in_bytes(T_CHAR)));
1254 }
1255 
1256 void TemplateTable::sastore() {
1257   castore();
1258 }
1259 
1260 void TemplateTable::istore(int n) {
1261   transition(itos, vtos);
1262   __ reg2mem_opt(Z_tos, iaddress(n), false);
1263 }
1264 
1265 void TemplateTable::lstore(int n) {
1266   transition(ltos, vtos);
1267   __ reg2mem_opt(Z_tos, laddress(n));
1268 }
1269 
1270 void TemplateTable::fstore(int n) {
1271   transition(ftos, vtos);
1272   __ freg2mem_opt(Z_ftos, faddress(n), false);
1273 }
1274 
1275 void TemplateTable::dstore(int n) {
1276   transition(dtos, vtos);
1277   __ freg2mem_opt(Z_ftos, daddress(n));
1278 }
1279 
1280 void TemplateTable::astore(int n) {
1281   transition(vtos, vtos);
1282   __ pop_ptr(Z_tos);
1283   __ reg2mem_opt(Z_tos, aaddress(n));
1284 }
1285 
1286 void TemplateTable::pop() {
1287   transition(vtos, vtos);
1288   __ add2reg(Z_esp, Interpreter::stackElementSize);
1289 }
1290 
1291 void TemplateTable::pop2() {
1292   transition(vtos, vtos);
1293   __ add2reg(Z_esp, 2 * Interpreter::stackElementSize);
1294 }
1295 
1296 void TemplateTable::dup() {
1297   transition(vtos, vtos);
1298   __ load_ptr(0, Z_tos);
1299   __ push_ptr(Z_tos);
1300   // stack: ..., a, a
1301 }
1302 
1303 void TemplateTable::dup_x1() {
1304   transition(vtos, vtos);
1305 
1306   // stack: ..., a, b
1307   __ load_ptr(0, Z_tos);          // load b
1308   __ load_ptr(1, Z_R0_scratch);   // load a
1309   __ store_ptr(1, Z_tos);         // store b
1310   __ store_ptr(0, Z_R0_scratch);  // store a
1311   __ push_ptr(Z_tos);             // push b
1312   // stack: ..., b, a, b
1313 }
1314 
1315 void TemplateTable::dup_x2() {
1316   transition(vtos, vtos);
1317 
1318   // stack: ..., a, b, c
1319   __ load_ptr(0, Z_R0_scratch);   // load c
1320   __ load_ptr(2, Z_R1_scratch);   // load a
1321   __ store_ptr(2, Z_R0_scratch);  // store c in a
1322   __ push_ptr(Z_R0_scratch);      // push c
1323   // stack: ..., c, b, c, c
1324   __ load_ptr(2, Z_R0_scratch);   // load b
1325   __ store_ptr(2, Z_R1_scratch);  // store a in b
1326   // stack: ..., c, a, c, c
1327   __ store_ptr(1, Z_R0_scratch);  // store b in c
1328   // stack: ..., c, a, b, c
1329 }
1330 
1331 void TemplateTable::dup2() {
1332   transition(vtos, vtos);
1333 
1334   // stack: ..., a, b
1335   __ load_ptr(1, Z_R0_scratch);  // load a
1336   __ push_ptr(Z_R0_scratch);     // push a
1337   __ load_ptr(1, Z_R0_scratch);  // load b
1338   __ push_ptr(Z_R0_scratch);     // push b
1339   // stack: ..., a, b, a, b
1340 }
1341 
1342 void TemplateTable::dup2_x1() {
1343   transition(vtos, vtos);
1344 
1345   // stack: ..., a, b, c
1346   __ load_ptr(0, Z_R0_scratch);  // load c
1347   __ load_ptr(1, Z_R1_scratch);  // load b
1348   __ push_ptr(Z_R1_scratch);     // push b
1349   __ push_ptr(Z_R0_scratch);     // push c
1350   // stack: ..., a, b, c, b, c
1351   __ store_ptr(3, Z_R0_scratch); // store c in b
1352   // stack: ..., a, c, c, b, c
1353   __ load_ptr( 4, Z_R0_scratch); // load a
1354   __ store_ptr(2, Z_R0_scratch); // store a in 2nd c
1355   // stack: ..., a, c, a, b, c
1356   __ store_ptr(4, Z_R1_scratch); // store b in a
1357   // stack: ..., b, c, a, b, c
1358 }
1359 
1360 void TemplateTable::dup2_x2() {
1361   transition(vtos, vtos);
1362 
1363   // stack: ..., a, b, c, d
1364   __ load_ptr(0, Z_R0_scratch);   // load d
1365   __ load_ptr(1, Z_R1_scratch);   // load c
1366   __ push_ptr(Z_R1_scratch);      // push c
1367   __ push_ptr(Z_R0_scratch);      // push d
1368   // stack: ..., a, b, c, d, c, d
1369   __ load_ptr(4, Z_R1_scratch);   // load b
1370   __ store_ptr(2, Z_R1_scratch);  // store b in d
1371   __ store_ptr(4, Z_R0_scratch);  // store d in b
1372   // stack: ..., a, d, c, b, c, d
1373   __ load_ptr(5, Z_R0_scratch);   // load a
1374   __ load_ptr(3, Z_R1_scratch);   // load c
1375   __ store_ptr(3, Z_R0_scratch);  // store a in c
1376   __ store_ptr(5, Z_R1_scratch);  // store c in a
1377   // stack: ..., c, d, a, b, c, d
1378 }
1379 
1380 void TemplateTable::swap() {
1381   transition(vtos, vtos);
1382 
1383   // stack: ..., a, b
1384   __ load_ptr(1, Z_R0_scratch);  // load a
1385   __ load_ptr(0, Z_R1_scratch);  // load b
1386   __ store_ptr(0, Z_R0_scratch);  // store a in b
1387   __ store_ptr(1, Z_R1_scratch);  // store b in a
1388   // stack: ..., b, a
1389 }
1390 
1391 void TemplateTable::iop2(Operation op) {
1392   transition(itos, itos);
1393   switch (op) {
1394     case add  :                           __ z_ay(Z_tos,  __ stackTop()); __ pop_i(); break;
1395     case sub  :                           __ z_sy(Z_tos,  __ stackTop()); __ pop_i(); __ z_lcr(Z_tos, Z_tos); break;
1396     case mul  :                           __ z_msy(Z_tos, __ stackTop()); __ pop_i(); break;
1397     case _and :                           __ z_ny(Z_tos,  __ stackTop()); __ pop_i(); break;
1398     case _or  :                           __ z_oy(Z_tos,  __ stackTop()); __ pop_i(); break;
1399     case _xor :                           __ z_xy(Z_tos,  __ stackTop()); __ pop_i(); break;
1400     case shl  : __ z_lr(Z_tmp_1, Z_tos);
1401                 __ z_nill(Z_tmp_1, 31);  // Lowest 5 bits are shiftamount.
1402                                           __ pop_i(Z_tos);   __ z_sll(Z_tos, 0,  Z_tmp_1); break;
1403     case shr  : __ z_lr(Z_tmp_1, Z_tos);
1404                 __ z_nill(Z_tmp_1, 31);  // Lowest 5 bits are shiftamount.
1405                                           __ pop_i(Z_tos);   __ z_sra(Z_tos, 0,  Z_tmp_1); break;
1406     case ushr : __ z_lr(Z_tmp_1, Z_tos);
1407                 __ z_nill(Z_tmp_1, 31);  // Lowest 5 bits are shiftamount.
1408                                           __ pop_i(Z_tos);   __ z_srl(Z_tos, 0,  Z_tmp_1); break;
1409     default   : ShouldNotReachHere(); break;
1410   }
1411   return;
1412 }
1413 
1414 void TemplateTable::lop2(Operation op) {
1415   transition(ltos, ltos);
1416 
1417   switch (op) {
1418     case add  :  __ z_ag(Z_tos,  __ stackTop()); __ pop_l(); break;
1419     case sub  :  __ z_sg(Z_tos,  __ stackTop()); __ pop_l(); __ z_lcgr(Z_tos, Z_tos); break;
1420     case mul  :  __ z_msg(Z_tos, __ stackTop()); __ pop_l(); break;
1421     case _and :  __ z_ng(Z_tos,  __ stackTop()); __ pop_l(); break;
1422     case _or  :  __ z_og(Z_tos,  __ stackTop()); __ pop_l(); break;
1423     case _xor :  __ z_xg(Z_tos,  __ stackTop()); __ pop_l(); break;
1424     default   : ShouldNotReachHere(); break;
1425   }
1426   return;
1427 }
1428 
1429 // Common part of idiv/irem.
1430 static void idiv_helper(InterpreterMacroAssembler * _masm, address exception) {
1431   NearLabel not_null;
1432 
1433   // Use register pair Z_tmp_1, Z_tmp_2 for DIVIDE SINGLE.
1434   assert(Z_tmp_1-&gt;successor() == Z_tmp_2, &quot; need even/odd register pair for idiv/irem&quot;);
1435 
1436   // Get dividend.
1437   __ pop_i(Z_tmp_2);
1438 
1439   // If divisor == 0 throw exception.
1440   __ compare32_and_branch(Z_tos, (intptr_t) 0,
1441                           Assembler::bcondNotEqual, not_null   );
1442   __ load_absolute_address(Z_R1_scratch, exception);
1443   __ z_br(Z_R1_scratch);
1444 
1445   __ bind(not_null);
1446 
1447   __ z_lgfr(Z_tmp_2, Z_tmp_2);   // Sign extend dividend.
1448   __ z_dsgfr(Z_tmp_1, Z_tos);    // Do it.
1449 }
1450 
1451 void TemplateTable::idiv() {
1452   transition(itos, itos);
1453 
1454   idiv_helper(_masm, Interpreter::_throw_ArithmeticException_entry);
1455   __ z_llgfr(Z_tos, Z_tmp_2);     // Result is in Z_tmp_2.
1456 }
1457 
1458 void TemplateTable::irem() {
1459   transition(itos, itos);
1460 
1461   idiv_helper(_masm, Interpreter::_throw_ArithmeticException_entry);
1462   __ z_llgfr(Z_tos, Z_tmp_1);     // Result is in Z_tmp_1.
1463 }
1464 
1465 void TemplateTable::lmul() {
1466   transition(ltos, ltos);
1467 
1468   // Multiply with memory operand.
1469   __ z_msg(Z_tos, __ stackTop());
1470   __ pop_l();  // Pop operand.
1471 }
1472 
1473 // Common part of ldiv/lrem.
1474 //
1475 // Input:
1476 //     Z_tos := the divisor (dividend still on stack)
1477 //
1478 // Updated registers:
1479 //     Z_tmp_1 := pop_l() % Z_tos     ; if is_ldiv == false
1480 //     Z_tmp_2 := pop_l() / Z_tos     ; if is_ldiv == true
1481 //
1482 static void ldiv_helper(InterpreterMacroAssembler * _masm, address exception, bool is_ldiv) {
1483   NearLabel not_null, done;
1484 
1485   // Use register pair Z_tmp_1, Z_tmp_2 for DIVIDE SINGLE.
1486   assert(Z_tmp_1-&gt;successor() == Z_tmp_2,
1487          &quot; need even/odd register pair for idiv/irem&quot;);
1488 
1489   // Get dividend.
1490   __ pop_l(Z_tmp_2);
1491 
1492   // If divisor == 0 throw exception.
1493   __ compare64_and_branch(Z_tos, (intptr_t)0, Assembler::bcondNotEqual, not_null);
1494   __ load_absolute_address(Z_R1_scratch, exception);
1495   __ z_br(Z_R1_scratch);
1496 
1497   __ bind(not_null);
1498   // Special case for dividend == 0x8000 and divisor == -1.
1499   if (is_ldiv) {
1500     // result := Z_tmp_2 := - dividend
1501     __ z_lcgr(Z_tmp_2, Z_tmp_2);
1502   } else {
1503     // result remainder := Z_tmp_1 := 0
1504     __ clear_reg(Z_tmp_1, true, false);  // Don&#39;t set CC.
1505   }
1506 
1507   // if divisor == -1 goto done
1508   __ compare64_and_branch(Z_tos, -1, Assembler::bcondEqual, done);
1509   if (is_ldiv)
1510     // Restore sign, because divisor != -1.
1511     __ z_lcgr(Z_tmp_2, Z_tmp_2);
1512   __ z_dsgr(Z_tmp_1, Z_tos);    // Do it.
1513   __ bind(done);
1514 }
1515 
1516 void TemplateTable::ldiv() {
1517   transition(ltos, ltos);
1518 
1519   ldiv_helper(_masm, Interpreter::_throw_ArithmeticException_entry, true /*is_ldiv*/);
1520   __ z_lgr(Z_tos, Z_tmp_2);     // Result is in Z_tmp_2.
1521 }
1522 
1523 void TemplateTable::lrem() {
1524   transition(ltos, ltos);
1525 
1526   ldiv_helper(_masm, Interpreter::_throw_ArithmeticException_entry, false /*is_ldiv*/);
1527   __ z_lgr(Z_tos, Z_tmp_1);     // Result is in Z_tmp_1.
1528 }
1529 
1530 void TemplateTable::lshl() {
1531   transition(itos, ltos);
1532 
1533   // Z_tos: shift amount
1534   __ pop_l(Z_tmp_1);              // Get shift value.
1535   __ z_sllg(Z_tos, Z_tmp_1, 0, Z_tos);
1536 }
1537 
1538 void TemplateTable::lshr() {
1539   transition(itos, ltos);
1540 
1541   // Z_tos: shift amount
1542   __ pop_l(Z_tmp_1);              // Get shift value.
1543   __ z_srag(Z_tos, Z_tmp_1, 0, Z_tos);
1544 }
1545 
1546 void TemplateTable::lushr() {
1547   transition(itos, ltos);
1548 
1549   // Z_tos: shift amount
1550   __ pop_l(Z_tmp_1);              // Get shift value.
1551   __ z_srlg(Z_tos, Z_tmp_1, 0, Z_tos);
1552 }
1553 
1554 void TemplateTable::fop2(Operation op) {
1555   transition(ftos, ftos);
1556 
1557   switch (op) {
1558     case add:
1559       // Add memory operand.
1560       __ z_aeb(Z_ftos, __ stackTop()); __ pop_f(); return;
1561     case sub:
1562       // Sub memory operand.
1563       __ z_ler(Z_F1, Z_ftos);    // first operand
1564       __ pop_f(Z_ftos);          // second operand from stack
1565       __ z_sebr(Z_ftos, Z_F1);
1566       return;
1567     case mul:
1568       // Multiply with memory operand.
1569       __ z_meeb(Z_ftos, __ stackTop()); __ pop_f(); return;
1570     case div:
1571       __ z_ler(Z_F1, Z_ftos);    // first operand
1572       __ pop_f(Z_ftos);          // second operand from stack
1573       __ z_debr(Z_ftos, Z_F1);
1574       return;
1575     case rem:
1576       // Do runtime call.
1577       __ z_ler(Z_FARG2, Z_ftos);  // divisor
1578       __ pop_f(Z_FARG1);          // dividend
1579       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem));
1580       // Result should be in the right place (Z_ftos == Z_FRET).
1581       return;
1582     default:
1583       ShouldNotReachHere();
1584       return;
1585   }
1586 }
1587 
1588 void TemplateTable::dop2(Operation op) {
1589   transition(dtos, dtos);
1590 
1591   switch (op) {
1592     case add:
1593       // Add memory operand.
1594       __ z_adb(Z_ftos, __ stackTop()); __ pop_d(); return;
1595     case sub:
1596       // Sub memory operand.
1597       __ z_ldr(Z_F1, Z_ftos);    // first operand
1598       __ pop_d(Z_ftos);          // second operand from stack
1599       __ z_sdbr(Z_ftos, Z_F1);
1600       return;
1601     case mul:
1602       // Multiply with memory operand.
1603       __ z_mdb(Z_ftos, __ stackTop()); __ pop_d(); return;
1604     case div:
1605       __ z_ldr(Z_F1, Z_ftos);    // first operand
1606       __ pop_d(Z_ftos);          // second operand from stack
1607       __ z_ddbr(Z_ftos, Z_F1);
1608       return;
1609     case rem:
1610       // Do runtime call.
1611       __ z_ldr(Z_FARG2, Z_ftos);  // divisor
1612       __ pop_d(Z_FARG1);          // dividend
1613       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem));
1614       // Result should be in the right place (Z_ftos == Z_FRET).
1615       return;
1616     default:
1617       ShouldNotReachHere();
1618       return;
1619   }
1620 }
1621 
1622 void TemplateTable::ineg() {
1623   transition(itos, itos);
1624   __ z_lcr(Z_tos);
1625 }
1626 
1627 void TemplateTable::lneg() {
1628   transition(ltos, ltos);
1629   __ z_lcgr(Z_tos);
1630 }
1631 
1632 void TemplateTable::fneg() {
1633   transition(ftos, ftos);
1634   __ z_lcebr(Z_ftos, Z_ftos);
1635 }
1636 
1637 void TemplateTable::dneg() {
1638   transition(dtos, dtos);
1639   __ z_lcdbr(Z_ftos, Z_ftos);
1640 }
1641 
1642 void TemplateTable::iinc() {
1643   transition(vtos, vtos);
1644 
1645   Address local;
1646   __ z_lb(Z_R0_scratch, at_bcp(2)); // Get constant.
1647   locals_index(Z_R1_scratch);
1648   local = iaddress(_masm, Z_R1_scratch);
1649   __ z_a(Z_R0_scratch, local);
1650   __ reg2mem_opt(Z_R0_scratch, local, false);
1651 }
1652 
1653 void TemplateTable::wide_iinc() {
1654   transition(vtos, vtos);
1655 
1656   // Z_tmp_1 := increment
1657   __ get_2_byte_integer_at_bcp(Z_tmp_1, 4, InterpreterMacroAssembler::Signed);
1658   // Z_R1_scratch := index of local to increment
1659   locals_index_wide(Z_tmp_2);
1660   // Load, increment, and store.
1661   __ access_local_int(Z_tmp_2, Z_tos);
1662   __ z_agr(Z_tos,  Z_tmp_1);
1663   // Shifted index is still in Z_tmp_2.
1664   __ reg2mem_opt(Z_tos, Address(Z_locals, Z_tmp_2), false);
1665 }
1666 
1667 
1668 void TemplateTable::convert() {
1669   // Checking
1670 #ifdef ASSERT
1671   TosState   tos_in  = ilgl;
1672   TosState   tos_out = ilgl;
1673 
1674   switch (bytecode()) {
1675     case Bytecodes::_i2l:
1676     case Bytecodes::_i2f:
1677     case Bytecodes::_i2d:
1678     case Bytecodes::_i2b:
1679     case Bytecodes::_i2c:
1680     case Bytecodes::_i2s:
1681       tos_in = itos;
1682       break;
1683     case Bytecodes::_l2i:
1684     case Bytecodes::_l2f:
1685     case Bytecodes::_l2d:
1686       tos_in = ltos;
1687       break;
1688     case Bytecodes::_f2i:
1689     case Bytecodes::_f2l:
1690     case Bytecodes::_f2d:
1691       tos_in = ftos;
1692       break;
1693     case Bytecodes::_d2i:
1694     case Bytecodes::_d2l:
1695     case Bytecodes::_d2f:
1696       tos_in = dtos;
1697       break;
1698     default :
1699       ShouldNotReachHere();
1700   }
1701   switch (bytecode()) {
1702     case Bytecodes::_l2i:
1703     case Bytecodes::_f2i:
1704     case Bytecodes::_d2i:
1705     case Bytecodes::_i2b:
1706     case Bytecodes::_i2c:
1707     case Bytecodes::_i2s:
1708       tos_out = itos;
1709       break;
1710     case Bytecodes::_i2l:
1711     case Bytecodes::_f2l:
1712     case Bytecodes::_d2l:
1713       tos_out = ltos;
1714       break;
1715     case Bytecodes::_i2f:
1716     case Bytecodes::_l2f:
1717     case Bytecodes::_d2f:
1718       tos_out = ftos;
1719       break;
1720     case Bytecodes::_i2d:
1721     case Bytecodes::_l2d:
1722     case Bytecodes::_f2d:
1723       tos_out = dtos;
1724       break;
1725     default :
1726       ShouldNotReachHere();
1727   }
1728 
1729   transition(tos_in, tos_out);
1730 #endif // ASSERT
1731 
1732   // Conversion
1733   Label done;
1734   switch (bytecode()) {
1735     case Bytecodes::_i2l:
1736       __ z_lgfr(Z_tos, Z_tos);
1737       return;
1738     case Bytecodes::_i2f:
1739       __ z_cefbr(Z_ftos, Z_tos);
1740       return;
1741     case Bytecodes::_i2d:
1742       __ z_cdfbr(Z_ftos, Z_tos);
1743       return;
1744     case Bytecodes::_i2b:
1745       // Sign extend least significant byte.
1746       __ move_reg_if_needed(Z_tos, T_BYTE, Z_tos, T_INT);
1747       return;
1748     case Bytecodes::_i2c:
1749       // Zero extend 2 least significant bytes.
1750       __ move_reg_if_needed(Z_tos, T_CHAR, Z_tos, T_INT);
1751       return;
1752     case Bytecodes::_i2s:
1753       // Sign extend 2 least significant bytes.
1754       __ move_reg_if_needed(Z_tos, T_SHORT, Z_tos, T_INT);
1755       return;
1756     case Bytecodes::_l2i:
1757       // Sign-extend not needed here, upper 4 bytes of int value in register are ignored.
1758       return;
1759     case Bytecodes::_l2f:
1760       __ z_cegbr(Z_ftos, Z_tos);
1761       return;
1762     case Bytecodes::_l2d:
1763       __ z_cdgbr(Z_ftos, Z_tos);
1764       return;
1765     case Bytecodes::_f2i:
1766     case Bytecodes::_f2l:
1767       __ clear_reg(Z_tos, true, false);  // Don&#39;t set CC.
1768       __ z_cebr(Z_ftos, Z_ftos);
1769       __ z_brno(done); // NaN -&gt; 0
1770       if (bytecode() == Bytecodes::_f2i)
1771         __ z_cfebr(Z_tos, Z_ftos, Assembler::to_zero);
1772       else // bytecode() == Bytecodes::_f2l
1773         __ z_cgebr(Z_tos, Z_ftos, Assembler::to_zero);
1774       break;
1775     case Bytecodes::_f2d:
1776       __ move_freg_if_needed(Z_ftos, T_DOUBLE, Z_ftos, T_FLOAT);
1777       return;
1778     case Bytecodes::_d2i:
1779     case Bytecodes::_d2l:
1780       __ clear_reg(Z_tos, true, false);  // Ddon&#39;t set CC.
1781       __ z_cdbr(Z_ftos, Z_ftos);
1782       __ z_brno(done); // NaN -&gt; 0
1783       if (bytecode() == Bytecodes::_d2i)
1784         __ z_cfdbr(Z_tos, Z_ftos, Assembler::to_zero);
1785       else // Bytecodes::_d2l
1786         __ z_cgdbr(Z_tos, Z_ftos, Assembler::to_zero);
1787       break;
1788     case Bytecodes::_d2f:
1789       __ move_freg_if_needed(Z_ftos, T_FLOAT, Z_ftos, T_DOUBLE);
1790       return;
1791     default:
1792       ShouldNotReachHere();
1793   }
1794   __ bind(done);
1795 }
1796 
1797 void TemplateTable::lcmp() {
1798   transition(ltos, itos);
1799 
1800   Label   done;
1801   Register val1 = Z_R0_scratch;
1802   Register val2 = Z_R1_scratch;
1803 
1804   if (VM_Version::has_LoadStoreConditional()) {
1805     __ pop_l(val1);           // pop value 1.
1806     __ z_lghi(val2,  -1);     // lt value
1807     __ z_cgr(val1, Z_tos);    // Compare with Z_tos (value 2). Protect CC under all circumstances.
1808     __ z_lghi(val1,   1);     // gt value
1809     __ z_lghi(Z_tos,  0);     // eq value
1810 
1811     __ z_locgr(Z_tos, val1, Assembler::bcondHigh);
1812     __ z_locgr(Z_tos, val2, Assembler::bcondLow);
1813   } else {
1814     __ pop_l(val1);           // Pop value 1.
1815     __ z_cgr(val1, Z_tos);    // Compare with Z_tos (value 2). Protect CC under all circumstances.
1816 
1817     __ z_lghi(Z_tos,  0);     // eq value
1818     __ z_bre(done);
1819 
1820     __ z_lghi(Z_tos,  1);     // gt value
1821     __ z_brh(done);
1822 
1823     __ z_lghi(Z_tos, -1);     // lt value
1824   }
1825 
1826   __ bind(done);
1827 }
1828 
1829 
1830 void TemplateTable::float_cmp(bool is_float, int unordered_result) {
1831   Label done;
1832 
1833   if (is_float) {
1834     __ pop_f(Z_FARG2);
1835     __ z_cebr(Z_FARG2, Z_ftos);
1836   } else {
1837     __ pop_d(Z_FARG2);
1838     __ z_cdbr(Z_FARG2, Z_ftos);
1839   }
1840 
1841   if (VM_Version::has_LoadStoreConditional()) {
1842     Register one       = Z_R0_scratch;
1843     Register minus_one = Z_R1_scratch;
1844     __ z_lghi(minus_one,  -1);
1845     __ z_lghi(one,  1);
1846     __ z_lghi(Z_tos, 0);
1847     __ z_locgr(Z_tos, one,       unordered_result == 1 ? Assembler::bcondHighOrNotOrdered : Assembler::bcondHigh);
1848     __ z_locgr(Z_tos, minus_one, unordered_result == 1 ? Assembler::bcondLow              : Assembler::bcondLowOrNotOrdered);
1849   } else {
1850     // Z_FARG2 == Z_ftos
1851     __ clear_reg(Z_tos, false, false);
1852     __ z_bre(done);
1853 
1854     // F_ARG2 &gt; Z_Ftos, or unordered
1855     __ z_lhi(Z_tos, 1);
1856     __ z_brc(unordered_result == 1 ? Assembler::bcondHighOrNotOrdered : Assembler::bcondHigh, done);
1857 
1858     // F_ARG2 &lt; Z_FTOS, or unordered
1859     __ z_lhi(Z_tos, -1);
1860 
1861     __ bind(done);
1862   }
1863 }
1864 
1865 void TemplateTable::branch(bool is_jsr, bool is_wide) {
1866   const Register   bumped_count = Z_tmp_1;
1867   const Register   method       = Z_tmp_2;
1868   const Register   m_counters   = Z_R1_scratch;
1869   const Register   mdo          = Z_tos;
1870 
1871   BLOCK_COMMENT(&quot;TemplateTable::branch {&quot;);
1872   __ get_method(method);
1873   __ profile_taken_branch(mdo, bumped_count);
1874 
1875   const ByteSize ctr_offset = InvocationCounter::counter_offset();
1876   const ByteSize be_offset  = MethodCounters::backedge_counter_offset()   + ctr_offset;
1877   const ByteSize inv_offset = MethodCounters::invocation_counter_offset() + ctr_offset;
1878 
1879   // Get (wide) offset to disp.
1880   const Register disp = Z_ARG5;
1881   if (is_wide) {
1882     __ get_4_byte_integer_at_bcp(disp, 1);
1883   } else {
1884     __ get_2_byte_integer_at_bcp(disp, 1, InterpreterMacroAssembler::Signed);
1885   }
1886 
1887   // Handle all the JSR stuff here, then exit.
1888   // It&#39;s much shorter and cleaner than intermingling with the
1889   // non-JSR normal-branch stuff occurring below.
1890   if (is_jsr) {
1891     // Compute return address as bci in Z_tos.
1892     __ z_lgr(Z_R1_scratch, Z_bcp);
1893     __ z_sg(Z_R1_scratch, Address(method, Method::const_offset()));
1894     __ add2reg(Z_tos, (is_wide ? 5 : 3) - in_bytes(ConstMethod::codes_offset()), Z_R1_scratch);
1895 
1896     // Bump bcp to target of JSR.
1897     __ z_agr(Z_bcp, disp);
1898     // Push return address for &quot;ret&quot; on stack.
1899     __ push_ptr(Z_tos);
1900     // And away we go!
1901     __ dispatch_next(vtos, 0 , true);
1902     return;
1903   }
1904 
1905   // Normal (non-jsr) branch handling.
1906 
1907   // Bump bytecode pointer by displacement (take the branch).
1908   __ z_agr(Z_bcp, disp);
1909 
1910   assert(UseLoopCounter || !UseOnStackReplacement,
1911          &quot;on-stack-replacement requires loop counters&quot;);
1912 
1913   NearLabel backedge_counter_overflow;
1914   NearLabel profile_method;
1915   NearLabel dispatch;
1916   int       increment = InvocationCounter::count_increment;
1917 
1918   if (UseLoopCounter) {
1919     // Increment backedge counter for backward branches.
1920     // disp: target offset
1921     // Z_bcp: target bcp
1922     // Z_locals: locals pointer
1923     //
1924     // Count only if backward branch.
1925     __ compare32_and_branch(disp, (intptr_t)0, Assembler::bcondHigh, dispatch);
1926 
1927     if (TieredCompilation) {
1928       Label noCounters;
1929 
1930       if (ProfileInterpreter) {
1931         NearLabel   no_mdo;
1932 
1933         // Are we profiling?
1934         __ load_and_test_long(mdo, Address(method, Method::method_data_offset()));
1935         __ branch_optimized(Assembler::bcondZero, no_mdo);
1936 
1937         // Increment the MDO backedge counter.
1938         const Address mdo_backedge_counter(mdo, MethodData::backedge_counter_offset() + InvocationCounter::counter_offset());
1939 
1940         const Address mask(mdo, MethodData::backedge_mask_offset());
1941         __ increment_mask_and_jump(mdo_backedge_counter, increment, mask,
1942                                    Z_ARG2, false, Assembler::bcondZero,
1943                                    UseOnStackReplacement ? &amp;backedge_counter_overflow : NULL);
1944         __ z_bru(dispatch);
1945         __ bind(no_mdo);
1946       }
1947 
1948       // Increment backedge counter in MethodCounters*.
1949       __ get_method_counters(method, m_counters, noCounters);
1950       const Address mask(m_counters, MethodCounters::backedge_mask_offset());
1951       __ increment_mask_and_jump(Address(m_counters, be_offset),
1952                                  increment, mask,
1953                                  Z_ARG2, false, Assembler::bcondZero,
1954                                  UseOnStackReplacement ? &amp;backedge_counter_overflow : NULL);
1955       __ bind(noCounters);
1956     } else {
1957       Register counter = Z_tos;
1958       Label    noCounters;
1959       // Get address of MethodCounters object.
1960       __ get_method_counters(method, m_counters, noCounters);
1961       // Increment backedge counter.
1962       __ increment_backedge_counter(m_counters, counter);
1963 
1964       if (ProfileInterpreter) {
1965         // Test to see if we should create a method data obj.
1966         __ z_cl(counter, Address(m_counters, MethodCounters::interpreter_profile_limit_offset()));
1967         __ z_brl(dispatch);
1968 
1969         // If no method data exists, go to profile method.
1970         __ test_method_data_pointer(Z_ARG4/*result unused*/, profile_method);
1971 
1972         if (UseOnStackReplacement) {
1973           // Check for overflow against &#39;bumped_count&#39; which is the MDO taken count.
1974           __ z_cl(bumped_count, Address(m_counters, MethodCounters::interpreter_backward_branch_limit_offset()));
1975           __ z_brl(dispatch);
1976 
1977           // When ProfileInterpreter is on, the backedge_count comes
1978           // from the methodDataOop, which value does not get reset on
1979           // the call to frequency_counter_overflow(). To avoid
1980           // excessive calls to the overflow routine while the method is
1981           // being compiled, add a second test to make sure the overflow
1982           // function is called only once every overflow_frequency.
1983           const int overflow_frequency = 1024;
1984           __ and_imm(bumped_count, overflow_frequency - 1);
1985           __ z_brz(backedge_counter_overflow);
1986 
1987         }
1988       } else {
1989         if (UseOnStackReplacement) {
1990           // Check for overflow against &#39;counter&#39;, which is the sum of the
1991           // counters.
1992           __ z_cl(counter, Address(m_counters, MethodCounters::interpreter_backward_branch_limit_offset()));
1993           __ z_brh(backedge_counter_overflow);
1994         }
1995       }
1996       __ bind(noCounters);
1997     }
1998 
1999     __ bind(dispatch);
2000   }
2001 
2002   // Pre-load the next target bytecode into rbx.
2003   __ z_llgc(Z_bytecode, Address(Z_bcp, (intptr_t) 0));
2004 
2005   // Continue with the bytecode @ target.
2006   // Z_tos: Return bci for jsr&#39;s, unused otherwise.
2007   // Z_bytecode: target bytecode
2008   // Z_bcp: target bcp
2009   __ dispatch_only(vtos, true);
2010 
2011   // Out-of-line code runtime calls.
2012   if (UseLoopCounter) {
2013     if (ProfileInterpreter) {
2014       // Out-of-line code to allocate method data oop.
2015       __ bind(profile_method);
2016 
2017       __ call_VM(noreg,
2018                  CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
2019       __ z_llgc(Z_bytecode, Address(Z_bcp, (intptr_t) 0));  // Restore target bytecode.
2020       __ set_method_data_pointer_for_bcp();
2021       __ z_bru(dispatch);
2022     }
2023 
2024     if (UseOnStackReplacement) {
2025 
2026       // invocation counter overflow
2027       __ bind(backedge_counter_overflow);
2028 
2029       __ z_lcgr(Z_ARG2, disp); // Z_ARG2 := -disp
2030       __ z_agr(Z_ARG2, Z_bcp); // Z_ARG2 := branch target bcp - disp == branch bcp
2031       __ call_VM(noreg,
2032                  CAST_FROM_FN_PTR(address, InterpreterRuntime::frequency_counter_overflow),
2033                  Z_ARG2);
2034 
2035       // Z_RET: osr nmethod (osr ok) or NULL (osr not possible).
2036       __ compare64_and_branch(Z_RET, (intptr_t) 0, Assembler::bcondEqual, dispatch);
2037 
2038       // Nmethod may have been invalidated (VM may block upon call_VM return).
2039       __ z_cliy(nmethod::state_offset(), Z_RET, nmethod::in_use);
2040       __ z_brne(dispatch);
2041 
2042       // Migrate the interpreter frame off of the stack.
2043 
2044       __ z_lgr(Z_tmp_1, Z_RET); // Save the nmethod.
2045 
2046       call_VM(noreg,
2047               CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));
2048 
2049       // Z_RET is OSR buffer, move it to expected parameter location.
2050       __ lgr_if_needed(Z_ARG1, Z_RET);
2051 
2052       // Pop the interpreter frame ...
2053       __ pop_interpreter_frame(Z_R14, Z_ARG2/*tmp1*/, Z_ARG3/*tmp2*/);
2054 
2055       // ... and begin the OSR nmethod.
2056       __ z_lg(Z_R1_scratch, Address(Z_tmp_1, nmethod::osr_entry_point_offset()));
2057       __ z_br(Z_R1_scratch);
2058     }
2059   }
2060   BLOCK_COMMENT(&quot;} TemplateTable::branch&quot;);
2061 }
2062 
2063 void TemplateTable::if_0cmp(Condition cc) {
2064   transition(itos, vtos);
2065 
2066   // Assume branch is more often taken than not (loops use backward branches).
2067   NearLabel not_taken;
2068   __ compare32_and_branch(Z_tos, (intptr_t) 0, j_not(cc), not_taken);
2069   branch(false, false);
2070   __ bind(not_taken);
2071   __ profile_not_taken_branch(Z_tos);
2072 }
2073 
2074 void TemplateTable::if_icmp(Condition cc) {
2075   transition(itos, vtos);
2076 
2077   // Assume branch is more often taken than not (loops use backward branches).
2078   NearLabel not_taken;
2079   __ pop_i(Z_R0_scratch);
2080   __ compare32_and_branch(Z_R0_scratch, Z_tos, j_not(cc), not_taken);
2081   branch(false, false);
2082   __ bind(not_taken);
2083   __ profile_not_taken_branch(Z_tos);
2084 }
2085 
2086 void TemplateTable::if_nullcmp(Condition cc) {
2087   transition(atos, vtos);
2088 
2089   // Assume branch is more often taken than not (loops use backward branches) .
2090   NearLabel not_taken;
2091   __ compare64_and_branch(Z_tos, (intptr_t) 0, j_not(cc), not_taken);
2092   branch(false, false);
2093   __ bind(not_taken);
2094   __ profile_not_taken_branch(Z_tos);
2095 }
2096 
2097 void TemplateTable::if_acmp(Condition cc) {
2098   transition(atos, vtos);
2099   // Assume branch is more often taken than not (loops use backward branches).
2100   NearLabel not_taken;
2101   __ pop_ptr(Z_ARG2);
2102   __ verify_oop(Z_ARG2);
2103   __ verify_oop(Z_tos);
2104   __ compareU64_and_branch(Z_tos, Z_ARG2, j_not(cc), not_taken);
2105   branch(false, false);
2106   __ bind(not_taken);
2107   __ profile_not_taken_branch(Z_ARG3);
2108 }
2109 
2110 void TemplateTable::ret() {
2111   transition(vtos, vtos);
2112 
2113   locals_index(Z_tmp_1);
2114   // Get return bci, compute return bcp. Must load 64 bits.
2115   __ mem2reg_opt(Z_tmp_1, iaddress(_masm, Z_tmp_1));
2116   __ profile_ret(Z_tmp_1, Z_tmp_2);
2117   __ get_method(Z_tos);
2118   __ mem2reg_opt(Z_R1_scratch, Address(Z_tos, Method::const_offset()));
2119   __ load_address(Z_bcp, Address(Z_R1_scratch, Z_tmp_1, ConstMethod::codes_offset()));
2120   __ dispatch_next(vtos, 0 , true);
2121 }
2122 
2123 void TemplateTable::wide_ret() {
2124   transition(vtos, vtos);
2125 
2126   locals_index_wide(Z_tmp_1);
2127   // Get return bci, compute return bcp.
2128   __ mem2reg_opt(Z_tmp_1, aaddress(_masm, Z_tmp_1));
2129   __ profile_ret(Z_tmp_1, Z_tmp_2);
2130   __ get_method(Z_tos);
2131   __ mem2reg_opt(Z_R1_scratch, Address(Z_tos, Method::const_offset()));
2132   __ load_address(Z_bcp, Address(Z_R1_scratch, Z_tmp_1, ConstMethod::codes_offset()));
2133   __ dispatch_next(vtos, 0, true);
2134 }
2135 
2136 void TemplateTable::tableswitch () {
2137   transition(itos, vtos);
2138 
2139   NearLabel default_case, continue_execution;
2140   Register  bcp = Z_ARG5;
2141   // Align bcp.
2142   __ load_address(bcp, at_bcp(BytesPerInt));
2143   __ z_nill(bcp, (-BytesPerInt) &amp; 0xffff);
2144 
2145   // Load lo &amp; hi.
2146   Register low  = Z_tmp_1;
2147   Register high = Z_tmp_2;
2148 
2149   // Load low into 64 bits, since used for address calculation.
2150   __ mem2reg_signed_opt(low, Address(bcp, BytesPerInt));
2151   __ mem2reg_opt(high, Address(bcp, 2 * BytesPerInt), false);
2152   // Sign extend &quot;label&quot; value for address calculation.
2153   __ z_lgfr(Z_tos, Z_tos);
2154 
2155   // Check against lo &amp; hi.
2156   __ compare32_and_branch(Z_tos, low, Assembler::bcondLow, default_case);
2157   __ compare32_and_branch(Z_tos, high, Assembler::bcondHigh, default_case);
2158 
2159   // Lookup dispatch offset.
2160   __ z_sgr(Z_tos, low);
2161   Register jump_table_offset = Z_ARG3;
2162   // Index2offset; index in Z_tos is killed by profile_switch_case.
2163   __ z_sllg(jump_table_offset, Z_tos, LogBytesPerInt);
2164   __ profile_switch_case(Z_tos, Z_ARG4 /*tmp for mdp*/, low/*tmp*/, Z_bytecode/*tmp*/);
2165 
2166   Register index = Z_tmp_2;
2167 
2168   // Load index sign extended for addressing.
2169   __ mem2reg_signed_opt(index, Address(bcp, jump_table_offset, 3 * BytesPerInt));
2170 
2171   // Continue execution.
2172   __ bind(continue_execution);
2173 
2174   // Load next bytecode.
2175   __ z_llgc(Z_bytecode, Address(Z_bcp, index));
2176   __ z_agr(Z_bcp, index); // Advance bcp.
2177   __ dispatch_only(vtos, true);
2178 
2179   // Handle default.
2180   __ bind(default_case);
2181 
2182   __ profile_switch_default(Z_tos);
2183   __ mem2reg_signed_opt(index, Address(bcp));
2184   __ z_bru(continue_execution);
2185 }
2186 
2187 void TemplateTable::lookupswitch () {
2188   transition(itos, itos);
2189   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2190 }
2191 
2192 void TemplateTable::fast_linearswitch () {
2193   transition(itos, vtos);
2194 
2195   Label    loop_entry, loop, found, continue_execution;
2196   Register bcp = Z_ARG5;
2197 
2198   // Align bcp.
2199   __ load_address(bcp, at_bcp(BytesPerInt));
2200   __ z_nill(bcp, (-BytesPerInt) &amp; 0xffff);
2201 
2202   // Start search with last case.
2203   Register current_case_offset = Z_tmp_1;
2204 
2205   __ mem2reg_signed_opt(current_case_offset, Address(bcp, BytesPerInt));
2206   __ z_sllg(current_case_offset, current_case_offset, LogBytesPerWord);   // index2bytes
2207   __ z_bru(loop_entry);
2208 
2209   // table search
2210   __ bind(loop);
2211 
2212   __ z_c(Z_tos, Address(bcp, current_case_offset, 2 * BytesPerInt));
2213   __ z_bre(found);
2214 
2215   __ bind(loop_entry);
2216   __ z_aghi(current_case_offset, -2 * BytesPerInt);  // Decrement.
2217   __ z_brnl(loop);
2218 
2219   // default case
2220   Register   offset = Z_tmp_2;
2221 
2222   __ profile_switch_default(Z_tos);
2223   // Load offset sign extended for addressing.
2224   __ mem2reg_signed_opt(offset, Address(bcp));
2225   __ z_bru(continue_execution);
2226 
2227   // Entry found -&gt; get offset.
2228   __ bind(found);
2229   __ mem2reg_signed_opt(offset, Address(bcp, current_case_offset, 3 * BytesPerInt));
2230   // Profile that this case was taken.
2231   Register current_case_idx = Z_ARG4;
2232   __ z_srlg(current_case_idx, current_case_offset, LogBytesPerWord); // bytes2index
2233   __ profile_switch_case(current_case_idx, Z_tos, bcp, Z_bytecode);
2234 
2235   // Continue execution.
2236   __ bind(continue_execution);
2237 
2238   // Load next bytecode.
2239   __ z_llgc(Z_bytecode, Address(Z_bcp, offset, 0));
2240   __ z_agr(Z_bcp, offset); // Advance bcp.
2241   __ dispatch_only(vtos, true);
2242 }
2243 
2244 
2245 void TemplateTable::fast_binaryswitch() {
2246 
2247   transition(itos, vtos);
2248 
2249   // Implementation using the following core algorithm:
2250   //
2251   // int binary_search(int key, LookupswitchPair* array, int n) {
2252   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2253   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2254   //   int i = 0;
2255   //   int j = n;
2256   //   while (i+1 &lt; j) {
2257   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2258   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2259   //     // where a stands for the array and assuming that the (inexisting)
2260   //     // element a[n] is infinitely big.
2261   //     int h = (i + j) &gt;&gt; 1;
2262   //     // i &lt; h &lt; j
2263   //     if (key &lt; array[h].fast_match()) {
2264   //       j = h;
2265   //     } else {
2266   //       i = h;
2267   //     }
2268   //   }
2269   //   // R: a[i] &lt;= key &lt; a[i+1] or Q
2270   //   // (i.e., if key is within array, i is the correct index)
2271   //   return i;
2272   // }
2273 
2274   // Register allocation
2275   // Note: Since we use the indices in address operands, we do all the
2276   // computation in 64 bits.
2277   const Register key   = Z_tos; // Already set (tosca).
2278   const Register array = Z_tmp_1;
2279   const Register i     = Z_tmp_2;
2280   const Register j     = Z_ARG5;
2281   const Register h     = Z_ARG4;
2282   const Register temp  = Z_R1_scratch;
2283 
2284   // Find array start.
2285   __ load_address(array, at_bcp(3 * BytesPerInt));
2286   __ z_nill(array, (-BytesPerInt) &amp; 0xffff);   // align
2287 
2288   // Initialize i &amp; j.
2289   __ clear_reg(i, true, false);  // i = 0;  Don&#39;t set CC.
2290   __ mem2reg_signed_opt(j, Address(array, -BytesPerInt)); // j = length(array);
2291 
2292   // And start.
2293   Label entry;
2294   __ z_bru(entry);
2295 
2296   // binary search loop
2297   {
2298     NearLabel   loop;
2299 
2300     __ bind(loop);
2301 
2302     // int h = (i + j) &gt;&gt; 1;
2303     __ add2reg_with_index(h, 0, i, j); // h = i + j;
2304     __ z_srag(h, h, 1);                // h = (i + j) &gt;&gt; 1;
2305 
2306     // if (key &lt; array[h].fast_match()) {
2307     //   j = h;
2308     // } else {
2309     //   i = h;
2310     // }
2311 
2312     // Convert array[h].match to native byte-ordering before compare.
2313     __ z_sllg(temp, h, LogBytesPerWord);   // index2bytes
2314     __ mem2reg_opt(temp, Address(array, temp), false);
2315 
2316     NearLabel  else_;
2317 
2318     __ compare32_and_branch(key, temp, Assembler::bcondNotLow, else_);
2319     // j = h if (key &lt;  array[h].fast_match())
2320     __ z_lgr(j, h);
2321     __ z_bru(entry); // continue
2322 
2323     __ bind(else_);
2324 
2325     // i = h if (key &gt;= array[h].fast_match())
2326     __ z_lgr(i, h);  // and fallthrough
2327 
2328     // while (i+1 &lt; j)
2329     __ bind(entry);
2330 
2331     // if (i + 1 &lt; j) continue search
2332     __ add2reg(h, 1, i);
2333     __ compare64_and_branch(h, j, Assembler::bcondLow, loop);
2334   }
2335 
2336   // End of binary search, result index is i (must check again!).
2337   NearLabel default_case;
2338 
2339   // h is no longer needed, so use it to hold the byte offset.
2340   __ z_sllg(h, i, LogBytesPerWord);   // index2bytes
2341   __ mem2reg_opt(temp, Address(array, h), false);
2342   __ compare32_and_branch(key, temp, Assembler::bcondNotEqual, default_case);
2343 
2344   // entry found -&gt; j = offset
2345   __ mem2reg_signed_opt(j, Address(array, h, BytesPerInt));
2346   __ profile_switch_case(i, key, array, Z_bytecode);
2347   // Load next bytecode.
2348   __ z_llgc(Z_bytecode, Address(Z_bcp, j));
2349   __ z_agr(Z_bcp, j);       // Advance bcp.
2350   __ dispatch_only(vtos, true);
2351 
2352   // default case -&gt; j = default offset
2353   __ bind(default_case);
2354 
2355   __ profile_switch_default(i);
2356   __ mem2reg_signed_opt(j, Address(array, -2 * BytesPerInt));
2357   // Load next bytecode.
2358   __ z_llgc(Z_bytecode, Address(Z_bcp, j));
2359   __ z_agr(Z_bcp, j);       // Advance bcp.
2360   __ dispatch_only(vtos, true);
2361 }
2362 
2363 void TemplateTable::_return(TosState state) {
2364   transition(state, state);
2365   assert(_desc-&gt;calls_vm(),
2366          &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2367 
2368   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2369     Register Rthis  = Z_ARG2;
2370     Register Rklass = Z_ARG5;
2371     Label skip_register_finalizer;
2372     assert(state == vtos, &quot;only valid state&quot;);
2373     __ z_lg(Rthis, aaddress(0));
2374     __ load_klass(Rklass, Rthis);
2375     __ testbit(Address(Rklass, Klass::access_flags_offset()), exact_log2(JVM_ACC_HAS_FINALIZER));
2376     __ z_bfalse(skip_register_finalizer);
2377     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), Rthis);
2378     __ bind(skip_register_finalizer);
2379   }
2380 
2381   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; _desc-&gt;bytecode() != Bytecodes::_return_register_finalizer) {
2382     Label no_safepoint;
2383     const Address poll_byte_addr(Z_thread, in_bytes(Thread::polling_page_offset()) + 7 /* Big Endian */);
2384     __ z_tm(poll_byte_addr, SafepointMechanism::poll_bit());
2385     __ z_braz(no_safepoint);
2386     __ push(state);
2387     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint));
2388     __ pop(state);
2389     __ bind(no_safepoint);
2390   }
2391 
2392   if (state == itos) {
2393     // Narrow result if state is itos but result type is smaller.
2394     // Need to narrow in the return bytecode rather than in generate_return_entry
2395     // since compiled code callers expect the result to already be narrowed.
2396     __ narrow(Z_tos, Z_tmp_1); /* fall through */
2397   }
2398 
2399   __ remove_activation(state, Z_R14);
2400   __ z_br(Z_R14);
2401 }
2402 
2403 // ----------------------------------------------------------------------------
2404 // NOTE: Cpe_offset is already computed as byte offset, so we must not
2405 // shift it afterwards!
2406 void TemplateTable::resolve_cache_and_index(int byte_no,
2407                                             Register Rcache,
2408                                             Register cpe_offset,
2409                                             size_t index_size) {
2410   BLOCK_COMMENT(&quot;resolve_cache_and_index {&quot;);
2411   NearLabel      resolved;
2412   const Register bytecode_in_cpcache = Z_R1_scratch;
2413   const int      total_f1_offset = in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset());
2414   assert_different_registers(Rcache, cpe_offset, bytecode_in_cpcache);
2415 
2416   Bytecodes::Code code = bytecode();
2417   switch (code) {
2418     case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2419     case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2420     default:
2421       break;
2422   }
2423 
2424   {
2425     assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
2426     __ get_cache_and_index_and_bytecode_at_bcp(Rcache, cpe_offset, bytecode_in_cpcache, byte_no, 1, index_size);
2427     // Have we resolved this bytecode?
2428     __ compare32_and_branch(bytecode_in_cpcache, (int)code, Assembler::bcondEqual, resolved);
2429   }
2430 
2431   // Resolve first time through.
2432   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2433   __ load_const_optimized(Z_ARG2, (int) code);
2434   __ call_VM(noreg, entry, Z_ARG2);
2435 
2436   // Update registers with resolved info.
2437   __ get_cache_and_index_at_bcp(Rcache, cpe_offset, 1, index_size);
2438   __ bind(resolved);
2439   BLOCK_COMMENT(&quot;} resolve_cache_and_index&quot;);
2440 }
2441 
2442 // The Rcache and index registers must be set before call.
2443 // Index is already a byte offset, don&#39;t shift!
2444 void TemplateTable::load_field_cp_cache_entry(Register obj,
2445                                               Register cache,
2446                                               Register index,
2447                                               Register off,
2448                                               Register flags,
2449                                               bool is_static = false) {
2450   assert_different_registers(cache, index, flags, off);
2451   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2452 
2453   // Field offset
2454   __ mem2reg_opt(off, Address(cache, index, cp_base_offset + ConstantPoolCacheEntry::f2_offset()));
2455   // Flags. Must load 64 bits.
2456   __ mem2reg_opt(flags, Address(cache, index, cp_base_offset + ConstantPoolCacheEntry::flags_offset()));
2457 
2458   // klass overwrite register
2459   if (is_static) {
2460     __ mem2reg_opt(obj, Address(cache, index, cp_base_offset + ConstantPoolCacheEntry::f1_offset()));
2461     __ mem2reg_opt(obj, Address(obj, Klass::java_mirror_offset()));
2462     __ resolve_oop_handle(obj);
2463   }
2464 }
2465 
2466 void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
2467                                                Register method,
2468                                                Register itable_index,
2469                                                Register flags,
2470                                                bool is_invokevirtual,
2471                                                bool is_invokevfinal, // unused
2472                                                bool is_invokedynamic) {
2473   BLOCK_COMMENT(&quot;load_invoke_cp_cache_entry {&quot;);
2474   // Setup registers.
2475   const Register cache     = Z_ARG1;
2476   const Register cpe_offset= flags;
2477   const ByteSize base_off  = ConstantPoolCache::base_offset();
2478   const ByteSize f1_off    = ConstantPoolCacheEntry::f1_offset();
2479   const ByteSize f2_off    = ConstantPoolCacheEntry::f2_offset();
2480   const ByteSize flags_off = ConstantPoolCacheEntry::flags_offset();
2481   const int method_offset  = in_bytes(base_off + ((byte_no == f2_byte) ? f2_off : f1_off));
2482   const int flags_offset   = in_bytes(base_off + flags_off);
2483   // Access constant pool cache fields.
2484   const int index_offset   = in_bytes(base_off + f2_off);
2485 
2486   assert_different_registers(method, itable_index, flags, cache);
2487   assert(is_invokevirtual == (byte_no == f2_byte), &quot;is_invokevirtual flag redundant&quot;);
2488 
2489   if (is_invokevfinal) {
2490     // Already resolved.
2491      assert(itable_index == noreg, &quot;register not used&quot;);
2492      __ get_cache_and_index_at_bcp(cache, cpe_offset, 1);
2493   } else {
2494     // Need to resolve.
2495     resolve_cache_and_index(byte_no, cache, cpe_offset, is_invokedynamic ? sizeof(u4) : sizeof(u2));
2496   }
2497   __ z_lg(method, Address(cache, cpe_offset, method_offset));
2498 
2499   if (itable_index != noreg) {
2500     __ z_lg(itable_index, Address(cache, cpe_offset, index_offset));
2501   }
2502 
2503   // Only load the lower 4 bytes and fill high bytes of flags with zeros.
2504   // Callers depend on this zero-extension!!!
2505   // Attention: overwrites cpe_offset == flags
2506   __ z_llgf(flags, Address(cache, cpe_offset, flags_offset + (BytesPerLong-BytesPerInt)));
2507 
2508   BLOCK_COMMENT(&quot;} load_invoke_cp_cache_entry&quot;);
2509 }
2510 
2511 // The registers cache and index expected to be set before call.
2512 // Correct values of the cache and index registers are preserved.
2513 void TemplateTable::jvmti_post_field_access(Register cache, Register index,
2514                                             bool is_static, bool has_tos) {
2515 
2516   // Do the JVMTI work here to avoid disturbing the register state below.
2517   // We use c_rarg registers here because we want to use the register used in
2518   // the call to the VM
2519   if (!JvmtiExport::can_post_field_access()) {
2520     return;
2521   }
2522 
2523   // Check to see if a field access watch has been set before we
2524   // take the time to call into the VM.
2525   Label exit;
2526   assert_different_registers(cache, index, Z_tos);
2527   __ load_absolute_address(Z_tos, (address)JvmtiExport::get_field_access_count_addr());
2528   __ load_and_test_int(Z_R0, Address(Z_tos));
2529   __ z_brz(exit);
2530 
2531   // Index is returned as byte offset, do not shift!
2532   __ get_cache_and_index_at_bcp(Z_ARG3, Z_R1_scratch, 1);
2533 
2534   // cache entry pointer
2535   __ add2reg_with_index(Z_ARG3,
2536                         in_bytes(ConstantPoolCache::base_offset()),
2537                         Z_ARG3, Z_R1_scratch);
2538 
2539   if (is_static) {
2540     __ clear_reg(Z_ARG2, true, false); // NULL object reference. Don&#39;t set CC.
2541   } else {
2542     __ mem2reg_opt(Z_ARG2, at_tos());  // Get object pointer without popping it.
2543     __ verify_oop(Z_ARG2);
2544   }
2545   // Z_ARG2: object pointer or NULL
2546   // Z_ARG3: cache entry pointer
2547   __ call_VM(noreg,
2548              CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access),
2549              Z_ARG2, Z_ARG3);
2550   __ get_cache_and_index_at_bcp(cache, index, 1);
2551 
2552   __ bind(exit);
2553 }
2554 
2555 void TemplateTable::pop_and_check_object(Register r) {
2556   __ pop_ptr(r);
2557   __ null_check(r);  // for field access must check obj.
2558   __ verify_oop(r);
2559 }
2560 
2561 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2562   transition(vtos, vtos);
2563 
2564   const Register cache = Z_tmp_1;
2565   const Register index = Z_tmp_2;
2566   const Register obj   = Z_tmp_1;
2567   const Register off   = Z_ARG2;
2568   const Register flags = Z_ARG1;
2569   const Register bc    = Z_tmp_1;  // Uses same reg as obj, so don&#39;t mix them.
2570 
2571   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2572   jvmti_post_field_access(cache, index, is_static, false);
2573   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2574 
2575   if (!is_static) {
2576     // Obj is on the stack.
2577     pop_and_check_object(obj);
2578   }
2579 
2580   // Displacement is 0, so any store instruction will be fine on any CPU.
2581   const Address field(obj, off);
2582 
2583   Label    is_Byte, is_Bool, is_Int, is_Short, is_Char,
2584            is_Long, is_Float, is_Object, is_Double;
2585   Label    is_badState8, is_badState9, is_badStateA, is_badStateB,
2586            is_badStateC, is_badStateD, is_badStateE, is_badStateF,
2587            is_badState;
2588   Label    branchTable, atosHandler,  Done;
2589   Register br_tab       = Z_R1_scratch;
2590   bool     do_rewrite   = !is_static &amp;&amp; (rc == may_rewrite);
2591   bool     dont_rewrite = (is_static || (rc == may_not_rewrite));
2592 
2593   assert(do_rewrite == !dont_rewrite, &quot;Oops, code is not fit for that&quot;);
2594   assert(btos == 0, &quot;change code, btos != 0&quot;);
2595 
2596   // Calculate branch table size. Generated code size depends on ASSERT and on bytecode rewriting.
2597 #ifdef ASSERT
2598   const unsigned int bsize = dont_rewrite ? BTB_MINSIZE*1 : BTB_MINSIZE*4;
2599 #else
2600   const unsigned int bsize = dont_rewrite ? BTB_MINSIZE*1 : BTB_MINSIZE*4;
2601 #endif
2602 
2603   // Calculate address of branch table entry and branch there.
2604   {
2605     const int bit_shift = exact_log2(bsize); // Size of each branch table entry.
2606     const int r_bitpos  = 63 - bit_shift;
2607     const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;
2608     const int n_rotate  = (bit_shift-ConstantPoolCacheEntry::tos_state_shift);
2609     __ z_larl(br_tab, branchTable);
2610     __ rotate_then_insert(flags, flags, l_bitpos, r_bitpos, n_rotate, true);
2611   }
2612   __ z_bc(Assembler::bcondAlways, 0, flags, br_tab);
2613 
2614   __ align_address(bsize);
2615   BIND(branchTable);
2616 
2617   // btos
2618   BTB_BEGIN(is_Byte, bsize, &quot;getfield_or_static:is_Byte&quot;);
2619   __ z_lb(Z_tos, field);
2620   __ push(btos);
2621   // Rewrite bytecode to be faster.
2622   if (do_rewrite) {
2623     patch_bytecode(Bytecodes::_fast_bgetfield, bc, Z_ARG5);
2624   }
2625   __ z_bru(Done);
2626   BTB_END(is_Byte, bsize, &quot;getfield_or_static:is_Byte&quot;);
2627 
2628   // ztos
2629   BTB_BEGIN(is_Bool, bsize, &quot;getfield_or_static:is_Bool&quot;);
2630   __ z_lb(Z_tos, field);
2631   __ push(ztos);
2632   // Rewrite bytecode to be faster.
2633   if (do_rewrite) {
2634     // Use btos rewriting, no truncating to t/f bit is needed for getfield.
2635     patch_bytecode(Bytecodes::_fast_bgetfield, bc, Z_ARG5);
2636   }
2637   __ z_bru(Done);
2638   BTB_END(is_Bool, bsize, &quot;getfield_or_static:is_Bool&quot;);
2639 
2640   // ctos
2641   BTB_BEGIN(is_Char, bsize, &quot;getfield_or_static:is_Char&quot;);
2642   // Load into 64 bits, works on all CPUs.
2643   __ z_llgh(Z_tos, field);
2644   __ push(ctos);
2645   // Rewrite bytecode to be faster.
2646   if (do_rewrite) {
2647     patch_bytecode(Bytecodes::_fast_cgetfield, bc, Z_ARG5);
2648   }
2649   __ z_bru(Done);
2650   BTB_END(is_Char, bsize, &quot;getfield_or_static:is_Char&quot;);
2651 
2652   // stos
2653   BTB_BEGIN(is_Short, bsize, &quot;getfield_or_static:is_Short&quot;);
2654   __ z_lh(Z_tos, field);
2655   __ push(stos);
2656   // Rewrite bytecode to be faster.
2657   if (do_rewrite) {
2658     patch_bytecode(Bytecodes::_fast_sgetfield, bc, Z_ARG5);
2659   }
2660   __ z_bru(Done);
2661   BTB_END(is_Short, bsize, &quot;getfield_or_static:is_Short&quot;);
2662 
2663   // itos
2664   BTB_BEGIN(is_Int, bsize, &quot;getfield_or_static:is_Int&quot;);
2665   __ mem2reg_opt(Z_tos, field, false);
2666   __ push(itos);
2667   // Rewrite bytecode to be faster.
2668   if (do_rewrite) {
2669     patch_bytecode(Bytecodes::_fast_igetfield, bc, Z_ARG5);
2670   }
2671   __ z_bru(Done);
2672   BTB_END(is_Int, bsize, &quot;getfield_or_static:is_Int&quot;);
2673 
2674   // ltos
2675   BTB_BEGIN(is_Long, bsize, &quot;getfield_or_static:is_Long&quot;);
2676   __ mem2reg_opt(Z_tos, field);
2677   __ push(ltos);
2678   // Rewrite bytecode to be faster.
2679   if (do_rewrite) {
2680     patch_bytecode(Bytecodes::_fast_lgetfield, bc, Z_ARG5);
2681   }
2682   __ z_bru(Done);
2683   BTB_END(is_Long, bsize, &quot;getfield_or_static:is_Long&quot;);
2684 
2685   // ftos
2686   BTB_BEGIN(is_Float, bsize, &quot;getfield_or_static:is_Float&quot;);
2687   __ mem2freg_opt(Z_ftos, field, false);
2688   __ push(ftos);
2689   // Rewrite bytecode to be faster.
2690   if (do_rewrite) {
2691     patch_bytecode(Bytecodes::_fast_fgetfield, bc, Z_ARG5);
2692   }
2693   __ z_bru(Done);
2694   BTB_END(is_Float, bsize, &quot;getfield_or_static:is_Float&quot;);
2695 
2696   // dtos
2697   BTB_BEGIN(is_Double, bsize, &quot;getfield_or_static:is_Double&quot;);
2698   __ mem2freg_opt(Z_ftos, field);
2699   __ push(dtos);
2700   // Rewrite bytecode to be faster.
2701   if (do_rewrite) {
2702     patch_bytecode(Bytecodes::_fast_dgetfield, bc, Z_ARG5);
2703   }
2704   __ z_bru(Done);
2705   BTB_END(is_Double, bsize, &quot;getfield_or_static:is_Double&quot;);
2706 
2707   // atos
2708   BTB_BEGIN(is_Object, bsize, &quot;getfield_or_static:is_Object&quot;);
2709   __ z_bru(atosHandler);
2710   BTB_END(is_Object, bsize, &quot;getfield_or_static:is_Object&quot;);
2711 
2712   // Bad state detection comes at no extra runtime cost.
2713   BTB_BEGIN(is_badState8, bsize, &quot;getfield_or_static:is_badState8&quot;);
2714   __ z_illtrap();
2715   __ z_bru(is_badState);
2716   BTB_END( is_badState8, bsize, &quot;getfield_or_static:is_badState8&quot;);
2717   BTB_BEGIN(is_badState9, bsize, &quot;getfield_or_static:is_badState9&quot;);
2718   __ z_illtrap();
2719   __ z_bru(is_badState);
2720   BTB_END( is_badState9, bsize, &quot;getfield_or_static:is_badState9&quot;);
2721   BTB_BEGIN(is_badStateA, bsize, &quot;getfield_or_static:is_badStateA&quot;);
2722   __ z_illtrap();
2723   __ z_bru(is_badState);
2724   BTB_END( is_badStateA, bsize, &quot;getfield_or_static:is_badStateA&quot;);
2725   BTB_BEGIN(is_badStateB, bsize, &quot;getfield_or_static:is_badStateB&quot;);
2726   __ z_illtrap();
2727   __ z_bru(is_badState);
2728   BTB_END( is_badStateB, bsize, &quot;getfield_or_static:is_badStateB&quot;);
2729   BTB_BEGIN(is_badStateC, bsize, &quot;getfield_or_static:is_badStateC&quot;);
2730   __ z_illtrap();
2731   __ z_bru(is_badState);
2732   BTB_END( is_badStateC, bsize, &quot;getfield_or_static:is_badStateC&quot;);
2733   BTB_BEGIN(is_badStateD, bsize, &quot;getfield_or_static:is_badStateD&quot;);
2734   __ z_illtrap();
2735   __ z_bru(is_badState);
2736   BTB_END( is_badStateD, bsize, &quot;getfield_or_static:is_badStateD&quot;);
2737   BTB_BEGIN(is_badStateE, bsize, &quot;getfield_or_static:is_badStateE&quot;);
2738   __ z_illtrap();
2739   __ z_bru(is_badState);
2740   BTB_END( is_badStateE, bsize, &quot;getfield_or_static:is_badStateE&quot;);
2741   BTB_BEGIN(is_badStateF, bsize, &quot;getfield_or_static:is_badStateF&quot;);
2742   __ z_illtrap();
2743   __ z_bru(is_badState);
2744   BTB_END( is_badStateF, bsize, &quot;getfield_or_static:is_badStateF&quot;);
2745 
2746   __ align_address(64);
2747   BIND(is_badState);  // Do this outside branch table. Needs a lot of space.
2748   {
2749     unsigned int b_off = __ offset();
2750     if (is_static) {
2751       __ stop_static(&quot;Bad state in getstatic&quot;);
2752     } else {
2753       __ stop_static(&quot;Bad state in getfield&quot;);
2754     }
2755     unsigned int e_off = __ offset();
2756   }
2757 
2758   __ align_address(64);
2759   BIND(atosHandler);  // Oops are really complicated to handle.
2760                       // There is a lot of code generated.
2761                       // Therefore: generate the handler outside of branch table.
2762                       // There is no performance penalty. The additional branch
2763                       // to here is compensated for by the fallthru to &quot;Done&quot;.
2764   {
2765     unsigned int b_off = __ offset();
2766     do_oop_load(_masm, field, Z_tos, Z_tmp_2, Z_tmp_3, IN_HEAP);
2767     __ verify_oop(Z_tos);
2768     __ push(atos);
2769     if (do_rewrite) {
2770       patch_bytecode(Bytecodes::_fast_agetfield, bc, Z_ARG5);
2771     }
2772     unsigned int e_off = __ offset();
2773   }
2774 
2775   BIND(Done);
2776 }
2777 
2778 void TemplateTable::getfield(int byte_no) {
2779   BLOCK_COMMENT(&quot;getfield  {&quot;);
2780   getfield_or_static(byte_no, false);
2781   BLOCK_COMMENT(&quot;} getfield&quot;);
2782 }
2783 
2784 void TemplateTable::nofast_getfield(int byte_no) {
2785   getfield_or_static(byte_no, false, may_not_rewrite);
2786 }
2787 
2788 void TemplateTable::getstatic(int byte_no) {
2789   BLOCK_COMMENT(&quot;getstatic {&quot;);
2790   getfield_or_static(byte_no, true);
2791   BLOCK_COMMENT(&quot;} getstatic&quot;);
2792 }
2793 
2794 // The registers cache and index expected to be set before call.  The
2795 // function may destroy various registers, just not the cache and
2796 // index registers.
2797 void TemplateTable::jvmti_post_field_mod(Register cache,
2798                                          Register index, bool is_static) {
2799   transition(vtos, vtos);
2800 
2801   if (!JvmtiExport::can_post_field_modification()) {
2802     return;
2803   }
2804 
2805   BLOCK_COMMENT(&quot;jvmti_post_field_mod {&quot;);
2806 
2807   // Check to see if a field modification watch has been set before
2808   // we take the time to call into the VM.
2809   Label    L1;
2810   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2811   assert_different_registers(cache, index, Z_tos);
2812 
2813   __ load_absolute_address(Z_tos, (address)JvmtiExport::get_field_modification_count_addr());
2814   __ load_and_test_int(Z_R0, Address(Z_tos));
2815   __ z_brz(L1);
2816 
2817   // Index is returned as byte offset, do not shift!
2818   __ get_cache_and_index_at_bcp(Z_ARG3, Z_R1_scratch, 1);
2819 
2820   if (is_static) {
2821     // Life is simple. Null out the object pointer.
2822     __ clear_reg(Z_ARG2, true, false);   // Don&#39;t set CC.
2823   } else {
2824     // Life is harder. The stack holds the value on top, followed by
2825     // the object. We don&#39;t know the size of the value, though. It
2826     // could be one or two words depending on its type. As a result,
2827     // we must find the type to determine where the object is.
2828     __ mem2reg_opt(Z_ARG4,
2829                    Address(Z_ARG3, Z_R1_scratch,
2830                            in_bytes(cp_base_offset + ConstantPoolCacheEntry::flags_offset()) +
2831                            (BytesPerLong - BytesPerInt)),
2832                    false);
2833     __ z_srl(Z_ARG4, ConstantPoolCacheEntry::tos_state_shift);
2834     // Make sure we don&#39;t need to mask Z_ARG4 for tos_state after the above shift.
2835     ConstantPoolCacheEntry::verify_tos_state_shift();
2836     __ mem2reg_opt(Z_ARG2, at_tos(1));  // Initially assume a one word jvalue.
2837 
2838     NearLabel   load_dtos, cont;
2839 
2840     __ compareU32_and_branch(Z_ARG4, (intptr_t) ltos,
2841                               Assembler::bcondNotEqual, load_dtos);
2842     __ mem2reg_opt(Z_ARG2, at_tos(2)); // ltos (two word jvalue)
2843     __ z_bru(cont);
2844 
2845     __ bind(load_dtos);
2846     __ compareU32_and_branch(Z_ARG4, (intptr_t)dtos, Assembler::bcondNotEqual, cont);
2847     __ mem2reg_opt(Z_ARG2, at_tos(2)); // dtos (two word jvalue)
2848 
2849     __ bind(cont);
2850   }
2851   // cache entry pointer
2852 
2853   __ add2reg_with_index(Z_ARG3, in_bytes(cp_base_offset), Z_ARG3, Z_R1_scratch);
2854 
2855   // object(tos)
2856   __ load_address(Z_ARG4, Address(Z_esp, Interpreter::stackElementSize));
2857   // Z_ARG2: object pointer set up above (NULL if static)
2858   // Z_ARG3: cache entry pointer
2859   // Z_ARG4: jvalue object on the stack
2860   __ call_VM(noreg,
2861              CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification),
2862              Z_ARG2, Z_ARG3, Z_ARG4);
2863   __ get_cache_and_index_at_bcp(cache, index, 1);
2864 
2865   __ bind(L1);
2866   BLOCK_COMMENT(&quot;} jvmti_post_field_mod&quot;);
2867 }
2868 
2869 
2870 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
2871   transition(vtos, vtos);
2872 
2873   const Register cache         = Z_tmp_1;
2874   const Register index         = Z_ARG5;
2875   const Register obj           = Z_tmp_1;
2876   const Register off           = Z_tmp_2;
2877   const Register flags         = Z_R1_scratch;
2878   const Register br_tab        = Z_ARG5;
2879   const Register bc            = Z_tmp_1;
2880   const Register oopStore_tmp1 = Z_R1_scratch;
2881   const Register oopStore_tmp2 = Z_ARG5;
2882   const Register oopStore_tmp3 = Z_R0_scratch;
2883 
2884   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
2885   jvmti_post_field_mod(cache, index, is_static);
2886   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
2887   // begin of life for:
2888   //   obj, off   long life range
2889   //   flags      short life range, up to branch into branch table
2890   // end of life for:
2891   //   cache, index
2892 
2893   const Address field(obj, off);
2894   Label is_Byte, is_Bool, is_Int, is_Short, is_Char,
2895         is_Long, is_Float, is_Object, is_Double;
2896   Label is_badState8, is_badState9, is_badStateA, is_badStateB,
2897         is_badStateC, is_badStateD, is_badStateE, is_badStateF,
2898         is_badState;
2899   Label branchTable, atosHandler, Done;
2900   bool  do_rewrite   = !is_static &amp;&amp; (rc == may_rewrite);
2901   bool  dont_rewrite = (is_static || (rc == may_not_rewrite));
2902 
2903   assert(do_rewrite == !dont_rewrite, &quot;Oops, code is not fit for that&quot;);
2904 
2905   assert(btos == 0, &quot;change code, btos != 0&quot;);
2906 
2907 #ifdef ASSERT
2908   const unsigned int bsize = is_static ? BTB_MINSIZE*1 : BTB_MINSIZE*4;
2909 #else
2910   const unsigned int bsize = is_static ? BTB_MINSIZE*1 : BTB_MINSIZE*8;
2911 #endif
2912 
2913   // Calculate address of branch table entry and branch there.
2914   {
2915     const int bit_shift = exact_log2(bsize); // Size of each branch table entry.
2916     const int r_bitpos  = 63 - bit_shift;
2917     const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;
2918     const int n_rotate  = (bit_shift-ConstantPoolCacheEntry::tos_state_shift);
2919     __ z_larl(br_tab, branchTable);
2920     __ rotate_then_insert(flags, flags, l_bitpos, r_bitpos, n_rotate, true);
2921     __ z_bc(Assembler::bcondAlways, 0, flags, br_tab);
2922   }
2923   // end of life for:
2924   //   flags, br_tab
2925 
2926   __ align_address(bsize);
2927   BIND(branchTable);
2928 
2929   // btos
2930   BTB_BEGIN(is_Byte, bsize, &quot;putfield_or_static:is_Byte&quot;);
2931   __ pop(btos);
2932   if (!is_static) {
2933     pop_and_check_object(obj);
2934   }
2935   __ z_stc(Z_tos, field);
2936   if (do_rewrite) {
2937     patch_bytecode(Bytecodes::_fast_bputfield, bc, Z_ARG5, true, byte_no);
2938   }
2939   __ z_bru(Done);
2940   BTB_END( is_Byte, bsize, &quot;putfield_or_static:is_Byte&quot;);
2941 
2942   // ztos
2943   BTB_BEGIN(is_Bool, bsize, &quot;putfield_or_static:is_Bool&quot;);
2944   __ pop(ztos);
2945   if (!is_static) {
2946     pop_and_check_object(obj);
2947   }
2948   __ z_nilf(Z_tos, 0x1);
2949   __ z_stc(Z_tos, field);
2950   if (do_rewrite) {
2951     patch_bytecode(Bytecodes::_fast_zputfield, bc, Z_ARG5, true, byte_no);
2952   }
2953   __ z_bru(Done);
2954   BTB_END(is_Bool, bsize, &quot;putfield_or_static:is_Bool&quot;);
2955 
2956   // ctos
2957   BTB_BEGIN(is_Char, bsize, &quot;putfield_or_static:is_Char&quot;);
2958   __ pop(ctos);
2959   if (!is_static) {
2960     pop_and_check_object(obj);
2961   }
2962   __ z_sth(Z_tos, field);
2963   if (do_rewrite) {
2964     patch_bytecode(Bytecodes::_fast_cputfield, bc, Z_ARG5, true, byte_no);
2965   }
2966   __ z_bru(Done);
2967   BTB_END( is_Char, bsize, &quot;putfield_or_static:is_Char&quot;);
2968 
2969   // stos
2970   BTB_BEGIN(is_Short, bsize, &quot;putfield_or_static:is_Short&quot;);
2971   __ pop(stos);
2972   if (!is_static) {
2973     pop_and_check_object(obj);
2974   }
2975   __ z_sth(Z_tos, field);
2976   if (do_rewrite) {
2977     patch_bytecode(Bytecodes::_fast_sputfield, bc, Z_ARG5, true, byte_no);
2978   }
2979   __ z_bru(Done);
2980   BTB_END( is_Short, bsize, &quot;putfield_or_static:is_Short&quot;);
2981 
2982   // itos
2983   BTB_BEGIN(is_Int, bsize, &quot;putfield_or_static:is_Int&quot;);
2984   __ pop(itos);
2985   if (!is_static) {
2986     pop_and_check_object(obj);
2987   }
2988   __ reg2mem_opt(Z_tos, field, false);
2989   if (do_rewrite) {
2990     patch_bytecode(Bytecodes::_fast_iputfield, bc, Z_ARG5, true, byte_no);
2991   }
2992   __ z_bru(Done);
2993   BTB_END( is_Int, bsize, &quot;putfield_or_static:is_Int&quot;);
2994 
2995   // ltos
2996   BTB_BEGIN(is_Long, bsize, &quot;putfield_or_static:is_Long&quot;);
2997   __ pop(ltos);
2998   if (!is_static) {
2999     pop_and_check_object(obj);
3000   }
3001   __ reg2mem_opt(Z_tos, field);
3002   if (do_rewrite) {
3003     patch_bytecode(Bytecodes::_fast_lputfield, bc, Z_ARG5, true, byte_no);
3004   }
3005   __ z_bru(Done);
3006   BTB_END( is_Long, bsize, &quot;putfield_or_static:is_Long&quot;);
3007 
3008   // ftos
3009   BTB_BEGIN(is_Float, bsize, &quot;putfield_or_static:is_Float&quot;);
3010   __ pop(ftos);
3011   if (!is_static) {
3012     pop_and_check_object(obj);
3013   }
3014   __ freg2mem_opt(Z_ftos, field, false);
3015   if (do_rewrite) {
3016     patch_bytecode(Bytecodes::_fast_fputfield, bc, Z_ARG5, true, byte_no);
3017   }
3018   __ z_bru(Done);
3019   BTB_END( is_Float, bsize, &quot;putfield_or_static:is_Float&quot;);
3020 
3021   // dtos
3022   BTB_BEGIN(is_Double, bsize, &quot;putfield_or_static:is_Double&quot;);
3023   __ pop(dtos);
3024   if (!is_static) {
3025     pop_and_check_object(obj);
3026   }
3027   __ freg2mem_opt(Z_ftos, field);
3028   if (do_rewrite) {
3029     patch_bytecode(Bytecodes::_fast_dputfield, bc, Z_ARG5, true, byte_no);
3030   }
3031   __ z_bru(Done);
3032   BTB_END( is_Double, bsize, &quot;putfield_or_static:is_Double&quot;);
3033 
3034   // atos
3035   BTB_BEGIN(is_Object, bsize, &quot;putfield_or_static:is_Object&quot;);
3036   __ z_bru(atosHandler);
3037   BTB_END( is_Object, bsize, &quot;putfield_or_static:is_Object&quot;);
3038 
3039   // Bad state detection comes at no extra runtime cost.
3040   BTB_BEGIN(is_badState8, bsize, &quot;putfield_or_static:is_badState8&quot;);
3041   __ z_illtrap();
3042   __ z_bru(is_badState);
3043   BTB_END( is_badState8, bsize, &quot;putfield_or_static:is_badState8&quot;);
3044   BTB_BEGIN(is_badState9, bsize, &quot;putfield_or_static:is_badState9&quot;);
3045   __ z_illtrap();
3046   __ z_bru(is_badState);
3047   BTB_END( is_badState9, bsize, &quot;putfield_or_static:is_badState9&quot;);
3048   BTB_BEGIN(is_badStateA, bsize, &quot;putfield_or_static:is_badStateA&quot;);
3049   __ z_illtrap();
3050   __ z_bru(is_badState);
3051   BTB_END( is_badStateA, bsize, &quot;putfield_or_static:is_badStateA&quot;);
3052   BTB_BEGIN(is_badStateB, bsize, &quot;putfield_or_static:is_badStateB&quot;);
3053   __ z_illtrap();
3054   __ z_bru(is_badState);
3055   BTB_END( is_badStateB, bsize, &quot;putfield_or_static:is_badStateB&quot;);
3056   BTB_BEGIN(is_badStateC, bsize, &quot;putfield_or_static:is_badStateC&quot;);
3057   __ z_illtrap();
3058   __ z_bru(is_badState);
3059   BTB_END( is_badStateC, bsize, &quot;putfield_or_static:is_badStateC&quot;);
3060   BTB_BEGIN(is_badStateD, bsize, &quot;putfield_or_static:is_badStateD&quot;);
3061   __ z_illtrap();
3062   __ z_bru(is_badState);
3063   BTB_END( is_badStateD, bsize, &quot;putfield_or_static:is_badStateD&quot;);
3064   BTB_BEGIN(is_badStateE, bsize, &quot;putfield_or_static:is_badStateE&quot;);
3065   __ z_illtrap();
3066   __ z_bru(is_badState);
3067   BTB_END( is_badStateE, bsize, &quot;putfield_or_static:is_badStateE&quot;);
3068   BTB_BEGIN(is_badStateF, bsize, &quot;putfield_or_static:is_badStateF&quot;);
3069   __ z_illtrap();
3070   __ z_bru(is_badState);
3071   BTB_END( is_badStateF, bsize, &quot;putfield_or_static:is_badStateF&quot;);
3072 
3073   __ align_address(64);
3074   BIND(is_badState);  // Do this outside branch table. Needs a lot of space.
3075   {
3076     unsigned int b_off = __ offset();
3077     if (is_static) __ stop_static(&quot;Bad state in putstatic&quot;);
3078     else            __ stop_static(&quot;Bad state in putfield&quot;);
3079     unsigned int e_off = __ offset();
3080   }
3081 
3082   __ align_address(64);
3083   BIND(atosHandler);  // Oops are really complicated to handle.
3084                       // There is a lot of code generated.
3085                       // Therefore: generate the handler outside of branch table.
3086                       // There is no performance penalty. The additional branch
3087                       // to here is compensated for by the fallthru to &quot;Done&quot;.
3088   {
3089     unsigned int b_off = __ offset();
3090     __ pop(atos);
3091     if (!is_static) {
3092       pop_and_check_object(obj);
3093     }
3094     // Store into the field
3095     do_oop_store(_masm, Address(obj, off), Z_tos,
3096                  oopStore_tmp1, oopStore_tmp2, oopStore_tmp3, IN_HEAP);
3097     if (do_rewrite) {
3098       patch_bytecode(Bytecodes::_fast_aputfield, bc, Z_ARG5, true, byte_no);
3099     }
3100     // __ z_bru(Done); // fallthru
3101     unsigned int e_off = __ offset();
3102   }
3103 
3104   BIND(Done);
3105 
3106   // Check for volatile store.
3107   Label notVolatile;
3108 
3109   __ testbit(Z_ARG4, ConstantPoolCacheEntry::is_volatile_shift);
3110   __ z_brz(notVolatile);
3111   __ z_fence();
3112 
3113   BIND(notVolatile);
3114 }
3115 
3116 void TemplateTable::putfield(int byte_no) {
3117   BLOCK_COMMENT(&quot;putfield  {&quot;);
3118   putfield_or_static(byte_no, false);
3119   BLOCK_COMMENT(&quot;} putfield&quot;);
3120 }
3121 
3122 void TemplateTable::nofast_putfield(int byte_no) {
3123   putfield_or_static(byte_no, false, may_not_rewrite);
3124 }
3125 
3126 void TemplateTable::putstatic(int byte_no) {
3127   BLOCK_COMMENT(&quot;putstatic {&quot;);
3128   putfield_or_static(byte_no, true);
3129   BLOCK_COMMENT(&quot;} putstatic&quot;);
3130 }
3131 
3132 // Push the tos value back to the stack.
3133 // gc will find oops there and update.
3134 void TemplateTable::jvmti_post_fast_field_mod() {
3135 
3136   if (!JvmtiExport::can_post_field_modification()) {
3137     return;
3138   }
3139 
3140   // Check to see if a field modification watch has been set before
3141   // we take the time to call into the VM.
3142   Label   exit;
3143 
3144   BLOCK_COMMENT(&quot;jvmti_post_fast_field_mod {&quot;);
3145 
3146   __ load_absolute_address(Z_R1_scratch,
3147                            (address) JvmtiExport::get_field_modification_count_addr());
3148   __ load_and_test_int(Z_R0_scratch, Address(Z_R1_scratch));
3149   __ z_brz(exit);
3150 
3151   Register obj = Z_tmp_1;
3152 
3153   __ pop_ptr(obj);                  // Copy the object pointer from tos.
3154   __ verify_oop(obj);
3155   __ push_ptr(obj);                 // Put the object pointer back on tos.
3156 
3157   // Save tos values before call_VM() clobbers them. Since we have
3158   // to do it for every data type, we use the saved values as the
3159   // jvalue object.
3160   switch (bytecode()) {          // Load values into the jvalue object.
3161     case Bytecodes::_fast_aputfield:
3162       __ push_ptr(Z_tos);
3163       break;
3164     case Bytecodes::_fast_bputfield:
3165     case Bytecodes::_fast_zputfield:
3166     case Bytecodes::_fast_sputfield:
3167     case Bytecodes::_fast_cputfield:
3168     case Bytecodes::_fast_iputfield:
3169       __ push_i(Z_tos);
3170       break;
3171     case Bytecodes::_fast_dputfield:
3172       __ push_d();
3173       break;
3174     case Bytecodes::_fast_fputfield:
3175       __ push_f();
3176       break;
3177     case Bytecodes::_fast_lputfield:
3178       __ push_l(Z_tos);
3179       break;
3180 
3181     default:
3182       ShouldNotReachHere();
3183   }
3184 
3185   // jvalue on the stack
3186   __ load_address(Z_ARG4, Address(Z_esp, Interpreter::stackElementSize));
3187   // Access constant pool cache entry.
3188   __ get_cache_entry_pointer_at_bcp(Z_ARG3, Z_tos, 1);
3189   __ verify_oop(obj);
3190 
3191   // obj   : object pointer copied above
3192   // Z_ARG3: cache entry pointer
3193   // Z_ARG4: jvalue object on the stack
3194   __ call_VM(noreg,
3195              CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification),
3196              obj, Z_ARG3, Z_ARG4);
3197 
3198   switch (bytecode()) {             // Restore tos values.
3199     case Bytecodes::_fast_aputfield:
3200       __ pop_ptr(Z_tos);
3201       break;
3202     case Bytecodes::_fast_bputfield:
3203     case Bytecodes::_fast_zputfield:
3204     case Bytecodes::_fast_sputfield:
3205     case Bytecodes::_fast_cputfield:
3206     case Bytecodes::_fast_iputfield:
3207       __ pop_i(Z_tos);
3208       break;
3209     case Bytecodes::_fast_dputfield:
3210       __ pop_d(Z_ftos);
3211       break;
3212     case Bytecodes::_fast_fputfield:
3213       __ pop_f(Z_ftos);
3214       break;
3215     case Bytecodes::_fast_lputfield:
3216       __ pop_l(Z_tos);
3217       break;
3218     default:
3219       break;
3220   }
3221 
3222   __ bind(exit);
3223   BLOCK_COMMENT(&quot;} jvmti_post_fast_field_mod&quot;);
3224 }
3225 
3226 void TemplateTable::fast_storefield(TosState state) {
3227   transition(state, vtos);
3228 
3229   ByteSize base = ConstantPoolCache::base_offset();
3230   jvmti_post_fast_field_mod();
3231 
3232   // Access constant pool cache.
3233   Register cache = Z_tmp_1;
3234   Register index = Z_tmp_2;
3235   Register flags = Z_ARG5;
3236 
3237   // Index comes in bytes, don&#39;t shift afterwards!
3238   __ get_cache_and_index_at_bcp(cache, index, 1);
3239 
3240   // Test for volatile.
3241   assert(!flags-&gt;is_volatile(), &quot;do_oop_store could perform leaf RT call&quot;);
3242   __ z_lg(flags, Address(cache, index, base + ConstantPoolCacheEntry::flags_offset()));
3243 
3244   // Replace index with field offset from cache entry.
3245   Register field_offset = index;
3246   __ z_lg(field_offset, Address(cache, index, base + ConstantPoolCacheEntry::f2_offset()));
3247 
3248   // Get object from stack.
3249   Register   obj = cache;
3250 
3251   pop_and_check_object(obj);
3252 
3253   // field address
3254   const Address   field(obj, field_offset);
3255 
3256   // access field
3257   switch (bytecode()) {
3258     case Bytecodes::_fast_aputfield:
3259       do_oop_store(_masm, Address(obj, field_offset), Z_tos,
3260                    Z_ARG2, Z_ARG3, Z_ARG4, IN_HEAP);
3261       break;
3262     case Bytecodes::_fast_lputfield:
3263       __ reg2mem_opt(Z_tos, field);
3264       break;
3265     case Bytecodes::_fast_iputfield:
3266       __ reg2mem_opt(Z_tos, field, false);
3267       break;
3268     case Bytecodes::_fast_zputfield:
3269       __ z_nilf(Z_tos, 0x1);
3270       // fall through to bputfield
3271     case Bytecodes::_fast_bputfield:
3272       __ z_stc(Z_tos, field);
3273       break;
3274     case Bytecodes::_fast_sputfield:
3275       // fall through
3276     case Bytecodes::_fast_cputfield:
3277       __ z_sth(Z_tos, field);
3278       break;
3279     case Bytecodes::_fast_fputfield:
3280       __ freg2mem_opt(Z_ftos, field, false);
3281       break;
3282     case Bytecodes::_fast_dputfield:
3283       __ freg2mem_opt(Z_ftos, field);
3284       break;
3285     default:
3286       ShouldNotReachHere();
3287   }
3288 
3289   //  Check for volatile store.
3290   Label notVolatile;
3291 
3292   __ testbit(flags, ConstantPoolCacheEntry::is_volatile_shift);
3293   __ z_brz(notVolatile);
3294   __ z_fence();
3295 
3296   __ bind(notVolatile);
3297 }
3298 
3299 void TemplateTable::fast_accessfield(TosState state) {
3300   transition(atos, state);
3301 
3302   Register obj = Z_tos;
3303 
3304   // Do the JVMTI work here to avoid disturbing the register state below
3305   if (JvmtiExport::can_post_field_access()) {
3306     // Check to see if a field access watch has been set before we
3307     // take the time to call into the VM.
3308     Label cont;
3309 
3310     __ load_absolute_address(Z_R1_scratch,
3311                              (address)JvmtiExport::get_field_access_count_addr());
3312     __ load_and_test_int(Z_R0_scratch, Address(Z_R1_scratch));
3313     __ z_brz(cont);
3314 
3315     // Access constant pool cache entry.
3316 
3317     __ get_cache_entry_pointer_at_bcp(Z_ARG3, Z_tmp_1, 1);
3318     __ verify_oop(obj);
3319     __ push_ptr(obj);  // Save object pointer before call_VM() clobbers it.
3320     __ z_lgr(Z_ARG2, obj);
3321 
3322     // Z_ARG2: object pointer copied above
3323     // Z_ARG3: cache entry pointer
3324     __ call_VM(noreg,
3325                CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access),
3326                Z_ARG2, Z_ARG3);
3327     __ pop_ptr(obj); // Restore object pointer.
3328 
3329     __ bind(cont);
3330   }
3331 
3332   // Access constant pool cache.
3333   Register   cache = Z_tmp_1;
3334   Register   index = Z_tmp_2;
3335 
3336   // Index comes in bytes, don&#39;t shift afterwards!
3337   __ get_cache_and_index_at_bcp(cache, index, 1);
3338   // Replace index with field offset from cache entry.
3339   __ mem2reg_opt(index,
3340                  Address(cache, index,
3341                          ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));
3342 
3343   __ verify_oop(obj);
3344   __ null_check(obj);
3345 
3346   Address field(obj, index);
3347 
3348   // access field
3349   switch (bytecode()) {
3350     case Bytecodes::_fast_agetfield:
3351       do_oop_load(_masm, field, Z_tos, Z_tmp_1, Z_tmp_2, IN_HEAP);
3352       __ verify_oop(Z_tos);
3353       return;
3354     case Bytecodes::_fast_lgetfield:
3355       __ mem2reg_opt(Z_tos, field);
3356       return;
3357     case Bytecodes::_fast_igetfield:
3358       __ mem2reg_opt(Z_tos, field, false);
3359       return;
3360     case Bytecodes::_fast_bgetfield:
3361       __ z_lb(Z_tos, field);
3362       return;
3363     case Bytecodes::_fast_sgetfield:
3364       __ z_lh(Z_tos, field);
3365       return;
3366     case Bytecodes::_fast_cgetfield:
3367       __ z_llgh(Z_tos, field);   // Load into 64 bits, works on all CPUs.
3368       return;
3369     case Bytecodes::_fast_fgetfield:
3370       __ mem2freg_opt(Z_ftos, field, false);
3371       return;
3372     case Bytecodes::_fast_dgetfield:
3373       __ mem2freg_opt(Z_ftos, field);
3374       return;
3375     default:
3376       ShouldNotReachHere();
3377   }
3378 }
3379 
3380 void TemplateTable::fast_xaccess(TosState state) {
3381   transition(vtos, state);
3382 
3383   Register receiver = Z_tos;
3384   // Get receiver.
3385   __ mem2reg_opt(Z_tos, aaddress(0));
3386 
3387   // Access constant pool cache.
3388   Register cache = Z_tmp_1;
3389   Register index = Z_tmp_2;
3390 
3391   // Index comes in bytes, don&#39;t shift afterwards!
3392   __ get_cache_and_index_at_bcp(cache, index, 2);
3393   // Replace index with field offset from cache entry.
3394   __ mem2reg_opt(index,
3395                  Address(cache, index,
3396                          ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f2_offset()));
3397 
3398   // Make sure exception is reported in correct bcp range (getfield is
3399   // next instruction).
3400   __ add2reg(Z_bcp, 1);
3401   __ null_check(receiver);
3402   switch (state) {
3403     case itos:
3404       __ mem2reg_opt(Z_tos, Address(receiver, index), false);
3405       break;
3406     case atos:
3407       do_oop_load(_masm, Address(receiver, index), Z_tos, Z_tmp_1, Z_tmp_2, IN_HEAP);
3408       __ verify_oop(Z_tos);
3409       break;
3410     case ftos:
3411       __ mem2freg_opt(Z_ftos, Address(receiver, index));
3412       break;
3413     default:
3414       ShouldNotReachHere();
3415   }
3416 
3417   // Reset bcp to original position.
3418   __ add2reg(Z_bcp, -1);
3419 }
3420 
3421 //-----------------------------------------------------------------------------
3422 // Calls
3423 
3424 void TemplateTable::prepare_invoke(int byte_no,
3425                                    Register method,  // linked method (or i-klass)
3426                                    Register index,   // itable index, MethodType, etc.
3427                                    Register recv,    // If caller wants to see it.
3428                                    Register flags) { // If caller wants to test it.
3429   // Determine flags.
3430   const Bytecodes::Code code = bytecode();
3431   const bool is_invokeinterface  = code == Bytecodes::_invokeinterface;
3432   const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;
3433   const bool is_invokehandle     = code == Bytecodes::_invokehandle;
3434   const bool is_invokevirtual    = code == Bytecodes::_invokevirtual;
3435   const bool is_invokespecial    = code == Bytecodes::_invokespecial;
3436   const bool load_receiver       = (recv != noreg);
3437   assert(load_receiver == (code != Bytecodes::_invokestatic &amp;&amp; code != Bytecodes::_invokedynamic), &quot;&quot;);
3438 
3439   // Setup registers &amp; access constant pool cache.
3440   if (recv  == noreg) { recv  = Z_ARG1; }
3441   if (flags == noreg) { flags = Z_ARG2; }
3442   assert_different_registers(method, Z_R14, index, recv, flags);
3443 
3444   BLOCK_COMMENT(&quot;prepare_invoke {&quot;);
3445 
3446   load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, false, is_invokedynamic);
3447 
3448   // Maybe push appendix to arguments.
3449   if (is_invokedynamic || is_invokehandle) {
3450     Label L_no_push;
3451     Register resolved_reference = Z_R1_scratch;
3452     __ testbit(flags, ConstantPoolCacheEntry::has_appendix_shift);
3453     __ z_bfalse(L_no_push);
3454     // Push the appendix as a trailing parameter.
3455     // This must be done before we get the receiver,
3456     // since the parameter_size includes it.
3457     __ load_resolved_reference_at_index(resolved_reference, index);
3458     __ verify_oop(resolved_reference);
3459     __ push_ptr(resolved_reference);  // Push appendix (MethodType, CallSite, etc.).
3460     __ bind(L_no_push);
3461   }
3462 
3463   // Load receiver if needed (after appendix is pushed so parameter size is correct).
3464   if (load_receiver) {
3465     assert(!is_invokedynamic, &quot;&quot;);
3466     // recv := int2long(flags &amp; ConstantPoolCacheEntry::parameter_size_mask) &lt;&lt; 3
3467     // Flags is zero-extended int2long when loaded during load_invoke_cp_cache_entry().
3468     // Only the least significant byte (psize) of flags is used.
3469     {
3470       const unsigned int logSES = Interpreter::logStackElementSize;
3471       const int bit_shift = logSES;
3472       const int r_bitpos  = 63 - bit_shift;
3473       const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::parameter_size_bits + 1;
3474       const int n_rotate  = bit_shift;
3475       assert(ConstantPoolCacheEntry::parameter_size_mask == 255, &quot;adapt bitpositions&quot;);
3476       __ rotate_then_insert(recv, flags, l_bitpos, r_bitpos, n_rotate, true);
3477     }
3478     // Recv now contains #arguments * StackElementSize.
3479 
3480     Address recv_addr(Z_esp, recv);
3481     __ z_lg(recv, recv_addr);
3482     __ verify_oop(recv);
3483   }
3484 
3485   // Compute return type.
3486   // ret_type is used by callers (invokespecial, invokestatic) at least.
3487   Register ret_type = Z_R1_scratch;
3488   assert_different_registers(ret_type, method);
3489 
3490   const address table_addr = (address)Interpreter::invoke_return_entry_table_for(code);
3491   __ load_absolute_address(Z_R14, table_addr);
3492 
3493   {
3494     const int bit_shift = LogBytesPerWord;           // Size of each table entry.
3495     const int r_bitpos  = 63 - bit_shift;
3496     const int l_bitpos  = r_bitpos - ConstantPoolCacheEntry::tos_state_bits + 1;
3497     const int n_rotate  = bit_shift-ConstantPoolCacheEntry::tos_state_shift;
3498     __ rotate_then_insert(ret_type, flags, l_bitpos, r_bitpos, n_rotate, true);
3499     // Make sure we don&#39;t need to mask flags for tos_state after the above shift.
3500     ConstantPoolCacheEntry::verify_tos_state_shift();
3501   }
3502 
3503     __ z_lg(Z_R14, Address(Z_R14, ret_type)); // Load return address.
3504   BLOCK_COMMENT(&quot;} prepare_invoke&quot;);
3505 }
3506 
3507 
3508 void TemplateTable::invokevirtual_helper(Register index,
3509                                          Register recv,
3510                                          Register flags) {
3511   // Uses temporary registers Z_tmp_2, Z_ARG4.
3512   assert_different_registers(index, recv, Z_tmp_2, Z_ARG4);
3513 
3514   // Test for an invoke of a final method.
3515   Label notFinal;
3516 
3517   BLOCK_COMMENT(&quot;invokevirtual_helper {&quot;);
3518 
3519   __ testbit(flags, ConstantPoolCacheEntry::is_vfinal_shift);
3520   __ z_brz(notFinal);
3521 
3522   const Register method = index;  // Method must be Z_ARG3.
3523   assert(method == Z_ARG3, &quot;method must be second argument for interpreter calling convention&quot;);
3524 
3525   // Do the call - the index is actually the method to call.
3526   // That is, f2 is a vtable index if !is_vfinal, else f2 is a method.
3527 
3528   // It&#39;s final, need a null check here!
3529   __ null_check(recv);
3530 
3531   // Profile this call.
3532   __ profile_final_call(Z_tmp_2);
3533   __ profile_arguments_type(Z_tmp_2, method, Z_ARG5, true); // Argument type profiling.
3534   __ jump_from_interpreted(method, Z_tmp_2);
3535 
3536   __ bind(notFinal);
3537 
3538   // Get receiver klass.
3539   __ null_check(recv, Z_R0_scratch, oopDesc::klass_offset_in_bytes());
3540   __ load_klass(Z_tmp_2, recv);
3541 
3542   // Profile this call.
3543   __ profile_virtual_call(Z_tmp_2, Z_ARG4, Z_ARG5);
3544 
3545   // Get target method &amp; entry point.
3546   __ z_sllg(index, index, exact_log2(vtableEntry::size_in_bytes()));
3547   __ mem2reg_opt(method,
3548                  Address(Z_tmp_2, index,
3549                          Klass::vtable_start_offset() + in_ByteSize(vtableEntry::method_offset_in_bytes())));
3550   __ profile_arguments_type(Z_ARG4, method, Z_ARG5, true);
3551   __ jump_from_interpreted(method, Z_ARG4);
3552   BLOCK_COMMENT(&quot;} invokevirtual_helper&quot;);
3553 }
3554 
3555 void TemplateTable::invokevirtual(int byte_no) {
3556   transition(vtos, vtos);
3557 
3558   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3559   prepare_invoke(byte_no,
3560                  Z_ARG3,  // method or vtable index
3561                  noreg,   // unused itable index
3562                  Z_ARG1,  // recv
3563                  Z_ARG2); // flags
3564 
3565   // Z_ARG3 : index
3566   // Z_ARG1 : receiver
3567   // Z_ARG2 : flags
3568   invokevirtual_helper(Z_ARG3, Z_ARG1, Z_ARG2);
3569 }
3570 
3571 void TemplateTable::invokespecial(int byte_no) {
3572   transition(vtos, vtos);
3573 
3574   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3575   Register Rmethod = Z_tmp_2;
3576   prepare_invoke(byte_no, Rmethod, noreg, // Get f1 method.
3577                  Z_ARG3);   // Get receiver also for null check.
3578   __ verify_oop(Z_ARG3);
3579   __ null_check(Z_ARG3);
3580   // Do the call.
3581   __ profile_call(Z_ARG2);
3582   __ profile_arguments_type(Z_ARG2, Rmethod, Z_ARG5, false);
3583   __ jump_from_interpreted(Rmethod, Z_R1_scratch);
3584 }
3585 
3586 void TemplateTable::invokestatic(int byte_no) {
3587   transition(vtos, vtos);
3588 
3589   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3590   Register Rmethod = Z_tmp_2;
3591   prepare_invoke(byte_no, Rmethod);   // Get f1 method.
3592   // Do the call.
3593   __ profile_call(Z_ARG2);
3594   __ profile_arguments_type(Z_ARG2, Rmethod, Z_ARG5, false);
3595   __ jump_from_interpreted(Rmethod, Z_R1_scratch);
3596 }
3597 
3598 // Outdated feature, and we don&#39;t support it.
3599 void TemplateTable::fast_invokevfinal(int byte_no) {
3600   transition(vtos, vtos);
3601   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3602   __ stop(&quot;fast_invokevfinal not used on linuxs390x&quot;);
3603 }
3604 
3605 void TemplateTable::invokeinterface(int byte_no) {
3606   transition(vtos, vtos);
3607 
3608   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3609   Register klass     = Z_ARG2,
3610            method    = Z_ARG3,
3611            interface = Z_ARG4,
3612            flags     = Z_ARG5,
3613            receiver  = Z_tmp_1;
3614 
3615   BLOCK_COMMENT(&quot;invokeinterface {&quot;);
3616 
3617   prepare_invoke(byte_no, interface, method,  // Get f1 klassOop, f2 Method*.
3618                  receiver, flags);
3619 
3620   // Z_R14 (== Z_bytecode) : return entry
3621 
3622   // First check for Object case, then private interface method,
3623   // then regular interface method.
3624 
3625   // Special case of invokeinterface called for virtual method of
3626   // java.lang.Object. See cpCache.cpp for details.
3627   NearLabel notObjectMethod, no_such_method;
3628   __ testbit(flags, ConstantPoolCacheEntry::is_forced_virtual_shift);
3629   __ z_brz(notObjectMethod);
3630   invokevirtual_helper(method, receiver, flags);
3631   __ bind(notObjectMethod);
3632 
3633   // Check for private method invocation - indicated by vfinal
3634   NearLabel notVFinal;
3635   __ testbit(flags, ConstantPoolCacheEntry::is_vfinal_shift);
3636   __ z_brz(notVFinal);
3637 
3638   // Get receiver klass into klass - also a null check.
3639   __ load_klass(klass, receiver);
3640 
3641   NearLabel subtype, no_such_interface;
3642 
3643   __ check_klass_subtype(klass, interface, Z_tmp_2, flags/*scratch*/, subtype);
3644   // If we get here the typecheck failed
3645   __ z_bru(no_such_interface);
3646   __ bind(subtype);
3647 
3648   // do the call
3649   __ profile_final_call(Z_tmp_2);
3650   __ profile_arguments_type(Z_tmp_2, method, Z_ARG5, true);
3651   __ jump_from_interpreted(method, Z_tmp_2);
3652 
3653   __ bind(notVFinal);
3654 
3655   // Get receiver klass into klass - also a null check.
3656   __ load_klass(klass, receiver);
3657 
3658   __ lookup_interface_method(klass, interface, noreg, noreg, /*temp*/Z_ARG1,
3659                              no_such_interface, /*return_method=*/false);
3660 
3661   // Profile this call.
3662   __ profile_virtual_call(klass, Z_ARG1/*mdp*/, flags/*scratch*/);
3663 
3664   // Find entry point to call.
3665 
3666   // Get declaring interface class from method
3667   __ z_lg(interface, Address(method, Method::const_offset()));
3668   __ z_lg(interface, Address(interface, ConstMethod::constants_offset()));
3669   __ z_lg(interface, Address(interface, ConstantPool::pool_holder_offset_in_bytes()));
3670 
3671   // Get itable index from method
3672   Register index   = receiver,
3673            method2 = flags;
3674   __ z_lgf(index, Address(method, Method::itable_index_offset()));
3675   __ z_aghi(index, -Method::itable_index_max);
3676   __ z_lcgr(index, index);
3677 
3678   __ lookup_interface_method(klass, interface, index, method2, Z_tmp_2,
3679                              no_such_interface);
3680 
3681   // Check for abstract method error.
3682   // Note: This should be done more efficiently via a throw_abstract_method_error
3683   // interpreter entry point and a conditional jump to it in case of a null
3684   // method.
3685   __ compareU64_and_branch(method2, (intptr_t) 0,
3686                            Assembler::bcondZero, no_such_method);
3687 
3688   __ profile_arguments_type(Z_tmp_1, method2, Z_tmp_2, true);
3689 
3690   // Do the call.
3691   __ jump_from_interpreted(method2, Z_tmp_2);
3692   __ should_not_reach_here();
3693 
3694   // exception handling code follows...
3695   // Note: Must restore interpreter registers to canonical
3696   // state for exception handling to work correctly!
3697 
3698   __ bind(no_such_method);
3699 
3700   // Throw exception.
3701   // Pass arguments for generating a verbose error message.
3702   __ z_lgr(Z_tmp_1, method); // Prevent register clash.
3703   __ call_VM(noreg,
3704              CAST_FROM_FN_PTR(address,
3705                               InterpreterRuntime::throw_AbstractMethodErrorVerbose),
3706                               klass, Z_tmp_1);
3707   // The call_VM checks for exception, so we should never return here.
3708   __ should_not_reach_here();
3709 
3710   __ bind(no_such_interface);
3711 
3712   // Throw exception.
3713   // Pass arguments for generating a verbose error message.
3714   __ call_VM(noreg,
3715              CAST_FROM_FN_PTR(address,
3716                               InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose),
3717                               klass, interface);
3718   // The call_VM checks for exception, so we should never return here.
3719   __ should_not_reach_here();
3720 
3721   BLOCK_COMMENT(&quot;} invokeinterface&quot;);
3722   return;
3723 }
3724 
3725 void TemplateTable::invokehandle(int byte_no) {
3726   transition(vtos, vtos);
3727 
3728   const Register method = Z_tmp_2;
3729   const Register recv   = Z_ARG5;
3730   const Register mtype  = Z_tmp_1;
3731   prepare_invoke(byte_no,
3732                  method, mtype,   // Get f2 method, f1 MethodType.
3733                  recv);
3734   __ verify_method_ptr(method);
3735   __ verify_oop(recv);
3736   __ null_check(recv);
3737 
3738   // Note: Mtype is already pushed (if necessary) by prepare_invoke.
3739 
3740   // FIXME: profile the LambdaForm also.
3741   __ profile_final_call(Z_ARG2);
3742   __ profile_arguments_type(Z_ARG3, method, Z_ARG5, true);
3743 
3744   __ jump_from_interpreted(method, Z_ARG3);
3745 }
3746 
3747 void TemplateTable::invokedynamic(int byte_no) {
3748   transition(vtos, vtos);
3749 
3750   const Register Rmethod   = Z_tmp_2;
3751   const Register Rcallsite = Z_tmp_1;
3752 
3753   prepare_invoke(byte_no, Rmethod, Rcallsite);
3754 
3755   // Rmethod: CallSite object (from f1)
3756   // Rcallsite: MH.linkToCallSite method (from f2)
3757 
3758   // Note: Callsite is already pushed by prepare_invoke.
3759 
3760   // TODO: should make a type profile for any invokedynamic that takes a ref argument.
3761   // Profile this call.
3762   __ profile_call(Z_ARG2);
3763   __ profile_arguments_type(Z_ARG2, Rmethod, Z_ARG5, false);
3764   __ jump_from_interpreted(Rmethod, Z_ARG2);
3765 }
3766 
3767 //-----------------------------------------------------------------------------
3768 // Allocation
3769 
3770 // Original comment on &quot;allow_shared_alloc&quot;:
3771 // Always go the slow path.
3772 //  + Eliminated optimization within the template-based interpreter:
3773 //    If an allocation is done within the interpreter without using
3774 //    tlabs, the interpreter tries to do the allocation directly
3775 //    on the heap.
3776 //  + That means the profiling hooks are not considered and allocations
3777 //    get lost for the profiling framework.
3778 //  + However, we do not think that this optimization is really needed,
3779 //    so we always go now the slow path through the VM in this case --
3780 //    spec jbb2005 shows no measurable performance degradation.
3781 void TemplateTable::_new() {
3782   transition(vtos, atos);
3783   address prev_instr_address = NULL;
3784   Register tags  = Z_tmp_1;
3785   Register RallocatedObject   = Z_tos;
3786   Register cpool = Z_ARG2;
3787   Register tmp = Z_ARG3; // RobjectFields==tmp and Rsize==offset must be a register pair.
3788   Register offset = Z_ARG4;
3789   Label slow_case;
3790   Label done;
3791   Label initialize_header;
3792 
3793   BLOCK_COMMENT(&quot;TemplateTable::_new {&quot;);
3794   __ get_2_byte_integer_at_bcp(offset/*dest*/, 1, InterpreterMacroAssembler::Unsigned);
3795   __ get_cpool_and_tags(cpool, tags);
3796   // Make sure the class we&#39;re about to instantiate has been resolved.
3797   // This is done before loading InstanceKlass to be consistent with the order
3798   // how Constant Pool is updated (see ConstantPool::klass_at_put).
3799   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
3800   __ load_address(tmp, Address(tags, offset, tags_offset));
3801   __ z_cli(0, tmp, JVM_CONSTANT_Class);
3802   __ z_brne(slow_case);
3803 
3804   __ z_sllg(offset, offset, LogBytesPerWord); // Convert to to offset.
3805   // Get InstanceKlass.
3806   Register iklass = cpool;
3807   __ load_resolved_klass_at_offset(cpool, offset, iklass);
3808 
3809   // Make sure klass is initialized &amp; doesn&#39;t have finalizer.
3810   // Make sure klass is fully initialized.
3811   const int state_offset = in_bytes(InstanceKlass::init_state_offset());
3812   if (Immediate::is_uimm12(state_offset)) {
3813     __ z_cli(state_offset, iklass, InstanceKlass::fully_initialized);
3814   } else {
3815     __ z_cliy(state_offset, iklass, InstanceKlass::fully_initialized);
3816   }
3817   __ z_brne(slow_case);
3818 
3819   // Get instance_size in InstanceKlass (scaled to a count of bytes).
3820   Register Rsize = offset;
3821   const int mask = 1 &lt;&lt; Klass::_lh_instance_slow_path_bit;
3822   __ z_llgf(Rsize, Address(iklass, Klass::layout_helper_offset()));
3823   __ z_tmll(Rsize, mask);
3824   __ z_btrue(slow_case);
3825 
3826   // Allocate the instance
3827   // 1) Try to allocate in the TLAB.
3828   // 2) If the above fails (or is not applicable), go to a slow case
3829   // (creates a new TLAB, etc.).
3830   // Note: compared to other architectures, s390&#39;s implementation always goes
3831   // to the slow path if TLAB is used and fails.
3832   if (UseTLAB) {
3833     Register RoldTopValue = RallocatedObject;
3834     Register RnewTopValue = tmp;
3835     __ z_lg(RoldTopValue, Address(Z_thread, JavaThread::tlab_top_offset()));
3836     __ load_address(RnewTopValue, Address(RoldTopValue, Rsize));
3837     __ z_cg(RnewTopValue, Address(Z_thread, JavaThread::tlab_end_offset()));
3838     __ z_brh(slow_case);
3839     __ z_stg(RnewTopValue, Address(Z_thread, JavaThread::tlab_top_offset()));
3840 
3841     Register RobjectFields = tmp;
3842     Register Rzero = Z_R1_scratch;
3843     __ clear_reg(Rzero, true /*whole reg*/, false); // Load 0L into Rzero. Don&#39;t set CC.
3844 
3845     if (!ZeroTLAB) {
3846       // The object is initialized before the header. If the object size is
3847       // zero, go directly to the header initialization.
3848       __ z_aghi(Rsize, (int)-sizeof(oopDesc)); // Subtract header size, set CC.
3849       __ z_bre(initialize_header);             // Jump if size of fields is zero.
3850 
3851       // Initialize object fields.
3852       // See documentation for MVCLE instruction!!!
3853       assert(RobjectFields-&gt;encoding() % 2 == 0, &quot;RobjectFields must be an even register&quot;);
3854       assert(Rsize-&gt;encoding() == (RobjectFields-&gt;encoding()+1),
3855              &quot;RobjectFields and Rsize must be a register pair&quot;);
3856       assert(Rzero-&gt;encoding() % 2 == 1, &quot;Rzero must be an odd register&quot;);
3857 
3858       // Set Rzero to 0 and use it as src length, then mvcle will copy nothing
3859       // and fill the object with the padding value 0.
3860       __ add2reg(RobjectFields, sizeof(oopDesc), RallocatedObject);
3861       __ move_long_ext(RobjectFields, as_Register(Rzero-&gt;encoding() - 1), 0);
3862     }
3863 
3864     // Initialize object header only.
3865     __ bind(initialize_header);
3866     if (UseBiasedLocking) {
3867       Register prototype = RobjectFields;
3868       __ z_lg(prototype, Address(iklass, Klass::prototype_header_offset()));
3869       __ z_stg(prototype, Address(RallocatedObject, oopDesc::mark_offset_in_bytes()));
3870     } else {
3871       __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),
3872                      (long)markOopDesc::prototype());
3873     }
3874 
3875     __ store_klass_gap(Rzero, RallocatedObject);  // Zero klass gap for compressed oops.
3876     __ store_klass(iklass, RallocatedObject);     // Store klass last.
3877 
3878     {
3879       SkipIfEqual skip(_masm, &amp;DTraceAllocProbes, false, Z_ARG5 /*scratch*/);
3880       // Trigger dtrace event for fastpath.
3881       __ push(atos); // Save the return value.
3882       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), RallocatedObject);
3883       __ pop(atos); // Restore the return value.
3884     }
3885     __ z_bru(done);
3886   }
3887 
3888   // slow case
3889   __ bind(slow_case);
3890   __ get_constant_pool(Z_ARG2);
3891   __ get_2_byte_integer_at_bcp(Z_ARG3/*dest*/, 1, InterpreterMacroAssembler::Unsigned);
3892   call_VM(Z_tos, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), Z_ARG2, Z_ARG3);
3893   __ verify_oop(Z_tos);
3894 
3895   // continue
3896   __ bind(done);
3897 
3898   BLOCK_COMMENT(&quot;} TemplateTable::_new&quot;);
3899 }
3900 
3901 void TemplateTable::newarray() {
3902   transition(itos, atos);
3903 
3904   // Call runtime.
3905   __ z_llgc(Z_ARG2, at_bcp(1));   // type
3906   __ z_lgfr(Z_ARG3, Z_tos);       // size
3907   call_VM(Z_RET,
3908           CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
3909           Z_ARG2, Z_ARG3);
3910 }
3911 
3912 void TemplateTable::anewarray() {
3913   transition(itos, atos);
3914   __ get_2_byte_integer_at_bcp(Z_ARG3, 1, InterpreterMacroAssembler::Unsigned);
3915   __ get_constant_pool(Z_ARG2);
3916   __ z_lgfr(Z_ARG4, Z_tos);
3917   call_VM(Z_tos, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
3918           Z_ARG2, Z_ARG3, Z_ARG4);
3919 }
3920 
3921 void TemplateTable::arraylength() {
3922   transition(atos, itos);
3923 
3924   int offset = arrayOopDesc::length_offset_in_bytes();
3925 
3926   __ null_check(Z_tos, Z_R0_scratch, offset);
3927   __ mem2reg_opt(Z_tos, Address(Z_tos, offset), false);
3928 }
3929 
3930 void TemplateTable::checkcast() {
3931   transition(atos, atos);
3932 
3933   NearLabel done, is_null, ok_is_subtype, quicked, resolved;
3934 
3935   BLOCK_COMMENT(&quot;checkcast {&quot;);
3936   // If object is NULL, we are almost done.
3937   __ compareU64_and_branch(Z_tos, (intptr_t) 0, Assembler::bcondZero, is_null);
3938 
3939   // Get cpool &amp; tags index.
3940   Register cpool = Z_tmp_1;
3941   Register tags = Z_tmp_2;
3942   Register index = Z_ARG5;
3943 
3944   __ get_cpool_and_tags(cpool, tags);
3945   __ get_2_byte_integer_at_bcp(index, 1, InterpreterMacroAssembler::Unsigned);
3946   // See if bytecode has already been quicked.
3947   // Note: For CLI, we would have to add the index to the tags pointer first,
3948   // thus load and compare in a &quot;classic&quot; manner.
3949   __ z_llgc(Z_R0_scratch,
3950             Address(tags, index, Array&lt;u1&gt;::base_offset_in_bytes()));
3951   __ compareU64_and_branch(Z_R0_scratch, JVM_CONSTANT_Class,
3952                            Assembler::bcondEqual, quicked);
3953 
3954   __ push(atos); // Save receiver for result, and for GC.
3955   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
3956   __ get_vm_result_2(Z_tos);
3957 
3958   Register   receiver = Z_ARG4;
3959   Register   klass = Z_tos;
3960   Register   subklass = Z_ARG5;
3961 
3962   __ pop_ptr(receiver); // restore receiver
3963   __ z_bru(resolved);
3964 
3965   // Get superklass in klass and subklass in subklass.
3966   __ bind(quicked);
3967 
3968   __ z_lgr(Z_ARG4, Z_tos);  // Save receiver.
3969   __ z_sllg(index, index, LogBytesPerWord);  // index2bytes for addressing
3970   __ load_resolved_klass_at_offset(cpool, index, klass);
3971 
3972   __ bind(resolved);
3973 
3974   __ load_klass(subklass, receiver);
3975 
3976   // Generate subtype check. Object in receiver.
3977   // Superklass in klass. Subklass in subklass.
3978   __ gen_subtype_check(subklass, klass, Z_ARG3, Z_tmp_1, ok_is_subtype);
3979 
3980   // Come here on failure.
3981   __ push_ptr(receiver);
3982   // Object is at TOS, target klass oop expected in rax by convention.
3983   __ z_brul((address) Interpreter::_throw_ClassCastException_entry);
3984 
3985   // Come here on success.
3986   __ bind(ok_is_subtype);
3987 
3988   __ z_lgr(Z_tos, receiver); // Restore object.
3989 
3990   // Collect counts on whether this test sees NULLs a lot or not.
3991   if (ProfileInterpreter) {
3992     __ z_bru(done);
3993     __ bind(is_null);
3994     __ profile_null_seen(Z_tmp_1);
3995   } else {
3996     __ bind(is_null);   // Same as &#39;done&#39;.
3997   }
3998 
3999   __ bind(done);
4000   BLOCK_COMMENT(&quot;} checkcast&quot;);
4001 }
4002 
4003 void TemplateTable::instanceof() {
4004   transition(atos, itos);
4005 
4006   NearLabel done, is_null, ok_is_subtype, quicked, resolved;
4007 
4008   BLOCK_COMMENT(&quot;instanceof {&quot;);
4009   // If object is NULL, we are almost done.
4010   __ compareU64_and_branch(Z_tos, (intptr_t) 0, Assembler::bcondZero, is_null);
4011 
4012   // Get cpool &amp; tags index.
4013   Register cpool = Z_tmp_1;
4014   Register tags = Z_tmp_2;
4015   Register index = Z_ARG5;
4016 
4017   __ get_cpool_and_tags(cpool, tags);
4018   __ get_2_byte_integer_at_bcp(index, 1, InterpreterMacroAssembler::Unsigned);
4019   // See if bytecode has already been quicked.
4020   // Note: For CLI, we would have to add the index to the tags pointer first,
4021   // thus load and compare in a &quot;classic&quot; manner.
4022   __ z_llgc(Z_R0_scratch,
4023             Address(tags, index, Array&lt;u1&gt;::base_offset_in_bytes()));
4024   __ compareU64_and_branch(Z_R0_scratch, JVM_CONSTANT_Class, Assembler::bcondEqual, quicked);
4025 
4026   __ push(atos); // Save receiver for result, and for GC.
4027   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4028   __ get_vm_result_2(Z_tos);
4029 
4030   Register receiver = Z_tmp_2;
4031   Register klass = Z_tos;
4032   Register subklass = Z_tmp_2;
4033 
4034   __ pop_ptr(receiver); // Restore receiver.
4035   __ verify_oop(receiver);
4036   __ load_klass(subklass, subklass);
4037   __ z_bru(resolved);
4038 
4039   // Get superklass in klass and subklass in subklass.
4040   __ bind(quicked);
4041 
4042   __ load_klass(subklass, Z_tos);
4043   __ z_sllg(index, index, LogBytesPerWord);  // index2bytes for addressing
4044   __ load_resolved_klass_at_offset(cpool, index, klass);
4045 
4046   __ bind(resolved);
4047 
4048   // Generate subtype check.
4049   // Superklass in klass. Subklass in subklass.
4050   __ gen_subtype_check(subklass, klass, Z_ARG4, Z_ARG5, ok_is_subtype);
4051 
4052   // Come here on failure.
4053   __ clear_reg(Z_tos, true, false);
4054   __ z_bru(done);
4055 
4056   // Come here on success.
4057   __ bind(ok_is_subtype);
4058   __ load_const_optimized(Z_tos, 1);
4059 
4060   // Collect counts on whether this test sees NULLs a lot or not.
4061   if (ProfileInterpreter) {
4062     __ z_bru(done);
4063     __ bind(is_null);
4064     __ profile_null_seen(Z_tmp_1);
4065   } else {
4066     __ bind(is_null);   // same as &#39;done&#39;
4067   }
4068 
4069   __ bind(done);
4070   // tos = 0: obj == NULL or  obj is not an instanceof the specified klass
4071   // tos = 1: obj != NULL and obj is     an instanceof the specified klass
4072   BLOCK_COMMENT(&quot;} instanceof&quot;);
4073 }
4074 
4075 //-----------------------------------------------------------------------------
4076 // Breakpoints
4077 void TemplateTable::_breakpoint() {
4078 
4079   // Note: We get here even if we are single stepping.
4080   // Jbug insists on setting breakpoints at every bytecode
4081   // even if we are in single step mode.
4082 
4083   transition(vtos, vtos);
4084 
4085   // Get the unpatched byte code.
4086   __ get_method(Z_ARG2);
4087   __ call_VM(noreg,
4088              CAST_FROM_FN_PTR(address, InterpreterRuntime::get_original_bytecode_at),
4089              Z_ARG2, Z_bcp);
4090   // Save the result to a register that is preserved over C-function calls.
4091   __ z_lgr(Z_tmp_1, Z_RET);
4092 
4093   // Post the breakpoint event.
4094   __ get_method(Z_ARG2);
4095   __ call_VM(noreg,
4096              CAST_FROM_FN_PTR(address, InterpreterRuntime::_breakpoint),
4097              Z_ARG2, Z_bcp);
4098 
4099   // Must restore the bytecode, because call_VM destroys Z_bytecode.
4100   __ z_lgr(Z_bytecode, Z_tmp_1);
4101 
4102   // Complete the execution of original bytecode.
4103   __ dispatch_only_normal(vtos);
4104 }
4105 
4106 
4107 // Exceptions
4108 
4109 void TemplateTable::athrow() {
4110   transition(atos, vtos);
4111   __ null_check(Z_tos);
4112   __ load_absolute_address(Z_ARG2, Interpreter::throw_exception_entry());
4113   __ z_br(Z_ARG2);
4114 }
4115 
4116 // Synchronization
4117 //
4118 // Note: monitorenter &amp; exit are symmetric routines; which is reflected
4119 //       in the assembly code structure as well
4120 //
4121 // Stack layout:
4122 //
4123 //               callers_sp        &lt;- Z_SP (callers_sp == Z_fp (own fp))
4124 //               return_pc
4125 //               [rest of ABI_160]
4126 //              /slot o:   free
4127 //             / ...       free
4128 //       oper. | slot n+1: free    &lt;- Z_esp points to first free slot
4129 //       stack | slot n:   val                      caches IJAVA_STATE.esp
4130 //             | ...
4131 //              \slot 0:   val
4132 //              /slot m            &lt;- IJAVA_STATE.monitors = monitor block top
4133 //             | ...
4134 //     monitors| slot 2
4135 //             | slot 1
4136 //              \slot 0
4137 //              /slot l            &lt;- monitor block bot
4138 // ijava_state | ...
4139 //             | slot 2
4140 //              \slot 0
4141 //                                 &lt;- Z_fp
4142 void TemplateTable::monitorenter() {
4143   transition(atos, vtos);
4144 
4145   BLOCK_COMMENT(&quot;monitorenter {&quot;);
4146 
4147   // Check for NULL object.
4148   __ null_check(Z_tos);
4149   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4150   NearLabel allocated;
4151   // Initialize entry pointer.
4152   const Register Rfree_slot = Z_tmp_1;
4153   __ clear_reg(Rfree_slot, true, false); // Points to free slot or NULL. Don&#39;t set CC.
4154 
4155   // Find a free slot in the monitor block from top to bot (result in Rfree_slot).
4156   {
4157     const Register Rcurr_monitor = Z_ARG2;
4158     const Register Rbot = Z_ARG3; // Points to word under bottom of monitor block.
4159     const Register Rlocked_obj = Z_ARG4;
4160     NearLabel loop, exit, not_free;
4161     // Starting with top-most entry.
4162     __ get_monitors(Rcurr_monitor); // Rcur_monitor = IJAVA_STATE.monitors
4163     __ add2reg(Rbot, -frame::z_ijava_state_size, Z_fp);
4164 
4165 #ifdef ASSERT
4166     address reentry = NULL;
4167     { NearLabel ok;
4168       __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondNotHigh, ok);
4169       reentry = __ stop_chain_static(reentry, &quot;IJAVA_STATE.monitors points below monitor block bottom&quot;);
4170       __ bind(ok);
4171     }
4172     { NearLabel ok;
4173       __ compareU64_and_branch(Rcurr_monitor, Z_esp, Assembler::bcondHigh, ok);
4174       reentry = __ stop_chain_static(reentry, &quot;IJAVA_STATE.monitors above Z_esp&quot;);
4175       __ bind(ok);
4176     }
4177 #endif
4178 
4179     // Check if bottom reached, i.e. if there is at least one monitor.
4180     __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondEqual, exit);
4181 
4182     __ bind(loop);
4183     // Check if current entry is used.
4184     __ load_and_test_long(Rlocked_obj, Address(Rcurr_monitor, BasicObjectLock::obj_offset_in_bytes()));
4185     __ z_brne(not_free);
4186     // If not used then remember entry in Rfree_slot.
4187     __ z_lgr(Rfree_slot, Rcurr_monitor);
4188     __ bind(not_free);
4189     // Exit if current entry is for same object; this guarantees, that new monitor
4190     // used for recursive lock is above the older one.
4191     __ compareU64_and_branch(Rlocked_obj, Z_tos, Assembler::bcondEqual, exit);
4192     // otherwise advance to next entry
4193     __ add2reg(Rcurr_monitor, entry_size);
4194     // Check if bottom reached, if not at bottom then check this entry.
4195     __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondNotEqual, loop);
4196     __ bind(exit);
4197   }
4198 
4199   // Rfree_slot != NULL -&gt; found one
4200   __ compareU64_and_branch(Rfree_slot, (intptr_t)0L, Assembler::bcondNotEqual, allocated);
4201 
4202   // Allocate one if there&#39;s no free slot.
4203   __ add_monitor_to_stack(false, Z_ARG3, Z_ARG4, Z_ARG5);
4204   __ get_monitors(Rfree_slot);
4205 
4206   // Rfree_slot: points to monitor entry.
4207   __ bind(allocated);
4208 
4209   // Increment bcp to point to the next bytecode, so exception
4210   // handling for async. exceptions work correctly.
4211   // The object has already been poped from the stack, so the
4212   // expression stack looks correct.
4213   __ add2reg(Z_bcp, 1, Z_bcp);
4214 
4215   // Store object.
4216   __ z_stg(Z_tos, BasicObjectLock::obj_offset_in_bytes(), Rfree_slot);
4217   __ lock_object(Rfree_slot, Z_tos);
4218 
4219   // Check to make sure this monitor doesn&#39;t cause stack overflow after locking.
4220   __ save_bcp();  // in case of exception
4221   __ generate_stack_overflow_check(0);
4222 
4223   // The bcp has already been incremented. Just need to dispatch to
4224   // next instruction.
4225   __ dispatch_next(vtos);
4226 
4227   BLOCK_COMMENT(&quot;} monitorenter&quot;);
4228 }
4229 
4230 
4231 void TemplateTable::monitorexit() {
4232   transition(atos, vtos);
4233 
4234   BLOCK_COMMENT(&quot;monitorexit {&quot;);
4235 
4236   // Check for NULL object.
4237   __ null_check(Z_tos);
4238 
4239   NearLabel found, not_found;
4240   const Register Rcurr_monitor = Z_ARG2;
4241 
4242   // Find matching slot.
4243   {
4244     const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4245     NearLabel entry, loop;
4246 
4247     const Register Rbot = Z_ARG3; // Points to word under bottom of monitor block.
4248     const Register Rlocked_obj = Z_ARG4;
4249     // Starting with top-most entry.
4250     __ get_monitors(Rcurr_monitor); // Rcur_monitor = IJAVA_STATE.monitors
4251     __ add2reg(Rbot, -frame::z_ijava_state_size, Z_fp);
4252 
4253 #ifdef ASSERT
4254     address reentry = NULL;
4255     { NearLabel ok;
4256       __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondNotHigh, ok);
4257       reentry = __ stop_chain_static(reentry, &quot;IJAVA_STATE.monitors points below monitor block bottom&quot;);
4258       __ bind(ok);
4259     }
4260     { NearLabel ok;
4261       __ compareU64_and_branch(Rcurr_monitor, Z_esp, Assembler::bcondHigh, ok);
4262       reentry = __ stop_chain_static(reentry, &quot;IJAVA_STATE.monitors above Z_esp&quot;);
4263       __ bind(ok);
4264     }
4265 #endif
4266 
4267     // Check if bottom reached, i.e. if there is at least one monitor.
4268     __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondEqual, not_found);
4269 
4270     __ bind(loop);
4271     // Check if current entry is for same object.
4272     __ z_lg(Rlocked_obj, Address(Rcurr_monitor, BasicObjectLock::obj_offset_in_bytes()));
4273     // If same object then stop searching.
4274     __ compareU64_and_branch(Rlocked_obj, Z_tos, Assembler::bcondEqual, found);
4275     // Otherwise advance to next entry.
4276     __ add2reg(Rcurr_monitor, entry_size);
4277     // Check if bottom reached, if not at bottom then check this entry.
4278     __ compareU64_and_branch(Rcurr_monitor, Rbot, Assembler::bcondNotEqual, loop);
4279   }
4280 
4281   __ bind(not_found);
4282   // Error handling. Unlocking was not block-structured.
4283   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
4284                    InterpreterRuntime::throw_illegal_monitor_state_exception));
4285   __ should_not_reach_here();
4286 
4287   __ bind(found);
4288   __ push_ptr(Z_tos); // Make sure object is on stack (contract with oopMaps).
4289   __ unlock_object(Rcurr_monitor, Z_tos);
4290   __ pop_ptr(Z_tos); // Discard object.
4291   BLOCK_COMMENT(&quot;} monitorexit&quot;);
4292 }
4293 
4294 // Wide instructions
4295 void TemplateTable::wide() {
4296   transition(vtos, vtos);
4297 
4298   __ z_llgc(Z_R1_scratch, at_bcp(1));
4299   __ z_sllg(Z_R1_scratch, Z_R1_scratch, LogBytesPerWord);
4300   __ load_absolute_address(Z_tmp_1, (address) Interpreter::_wentry_point);
4301   __ mem2reg_opt(Z_tmp_1, Address(Z_tmp_1, Z_R1_scratch));
4302   __ z_br(Z_tmp_1);
4303   // Note: the bcp increment step is part of the individual wide
4304   // bytecode implementations.
4305 }
4306 
4307 // Multi arrays
4308 void TemplateTable::multianewarray() {
4309   transition(vtos, atos);
4310 
4311   __ z_llgc(Z_tmp_1, at_bcp(3)); // Get number of dimensions.
4312   // Slot count to byte offset.
4313   __ z_sllg(Z_tmp_1, Z_tmp_1, Interpreter::logStackElementSize);
4314   // Z_esp points past last_dim, so set to Z_ARG2 to first_dim address.
4315   __ load_address(Z_ARG2, Address(Z_esp, Z_tmp_1));
4316   call_VM(Z_RET,
4317           CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray),
4318           Z_ARG2);
4319   // Pop dimensions from expression stack.
4320   __ z_agr(Z_esp, Z_tmp_1);
4321 }
    </pre>
  </body>
</html>
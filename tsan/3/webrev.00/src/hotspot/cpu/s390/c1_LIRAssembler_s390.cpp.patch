diff a/src/hotspot/cpu/s390/c1_LIRAssembler_s390.cpp b/src/hotspot/cpu/s390/c1_LIRAssembler_s390.cpp
--- a/src/hotspot/cpu/s390/c1_LIRAssembler_s390.cpp
+++ b/src/hotspot/cpu/s390/c1_LIRAssembler_s390.cpp
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2016, 2017, SAP SE. All rights reserved.
+ * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2019, SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -31,17 +31,17 @@
 #include "c1/c1_Runtime1.hpp"
 #include "c1/c1_ValueStack.hpp"
 #include "ci/ciArrayKlass.hpp"
 #include "ci/ciInstance.hpp"
 #include "gc/shared/collectedHeap.hpp"
-#include "gc/shared/barrierSet.hpp"
-#include "gc/shared/cardTableBarrierSet.hpp"
+#include "memory/universe.hpp"
 #include "nativeInst_s390.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "runtime/frame.inline.hpp"
 #include "runtime/safepointMechanism.inline.hpp"
 #include "runtime/sharedRuntime.hpp"
+#include "utilities/powerOfTwo.hpp"
 #include "vmreg_s390.inline.hpp"
 
 #define __ _masm->
 
 #ifndef PRODUCT
@@ -78,10 +78,25 @@
   int offset = __ offset();
   __ inline_cache_check(receiver, Z_inline_cache);
   return offset;
 }
 
+void LIR_Assembler::clinit_barrier(ciMethod* method) {
+  assert(!method->holder()->is_not_initialized(), "initialization should have been started");
+
+  Label L_skip_barrier;
+  Register klass = Z_R1_scratch;
+
+  metadata2reg(method->holder()->constant_encoding(), klass);
+  __ clinit_barrier(klass, Z_thread, &L_skip_barrier /*L_fast_path*/);
+
+  __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());
+  __ z_br(klass);
+
+  __ bind(L_skip_barrier);
+}
+
 void LIR_Assembler::osr_entry() {
   // On-stack-replacement entry sequence (interpreter frame layout described in interpreter_sparc.cpp):
   //
   //   1. Create a new compiled activation.
   //   2. Initialize local variables in the compiled activation. The expression stack must be empty
@@ -879,11 +894,11 @@
   Register disp_reg = Z_R0;
   int disp_value = addr->disp();
   bool needs_patching = (patch_code != lir_patch_none);
 
   if (addr->base()->type() == T_OBJECT) {
-    __ verify_oop(src);
+    __ verify_oop(src, FILE_AND_LINE);
   }
 
   PatchingStub* patch = NULL;
   if (needs_patching) {
     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
@@ -954,10 +969,11 @@
         __ z_llgf(dest->as_register(), disp_value, disp_reg, src);
         __ oop_decoder(dest->as_register(), dest->as_register(), true);
       } else {
         __ z_lg(dest->as_register(), disp_value, disp_reg, src);
       }
+      __ verify_oop(dest->as_register(), FILE_AND_LINE);
       break;
     }
     case T_FLOAT:
       if (short_disp) {
                     __ z_le(dest->as_float_reg(),  disp_value, disp_reg, src);
@@ -973,13 +989,10 @@
       }
       break;
     case T_LONG  :  __ z_lg(dest->as_register_lo(), disp_value, disp_reg, src); break;
     default      : ShouldNotReachHere();
   }
-  if (type == T_ARRAY || type == T_OBJECT) {
-    __ verify_oop(dest->as_register());
-  }
 
   if (patch != NULL) {
     patching_epilog(patch, patch_code, src, info);
   }
   if (info != NULL) add_debug_info_for_null_check(offset, info);
@@ -988,14 +1001,14 @@
 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
   assert(src->is_stack(), "should not call otherwise");
   assert(dest->is_register(), "should not call otherwise");
 
   if (dest->is_single_cpu()) {
-    if (type == T_ARRAY || type == T_OBJECT) {
+    if (is_reference_type(type)) {
       __ mem2reg_opt(dest->as_register(), frame_map()->address_for_slot(src->single_stack_ix()), true);
-      __ verify_oop(dest->as_register());
-    } else if (type == T_METADATA) {
+      __ verify_oop(dest->as_register(), FILE_AND_LINE);
+    } else if (type == T_METADATA || type == T_ADDRESS) {
       __ mem2reg_opt(dest->as_register(), frame_map()->address_for_slot(src->single_stack_ix()), true);
     } else {
       __ mem2reg_opt(dest->as_register(), frame_map()->address_for_slot(src->single_stack_ix()), false);
     }
   } else if (dest->is_double_cpu()) {
@@ -1016,14 +1029,14 @@
   assert(src->is_register(), "should not call otherwise");
   assert(dest->is_stack(), "should not call otherwise");
 
   if (src->is_single_cpu()) {
     const Address dst = frame_map()->address_for_slot(dest->single_stack_ix());
-    if (type == T_OBJECT || type == T_ARRAY) {
-      __ verify_oop(src->as_register());
+    if (is_reference_type(type)) {
+      __ verify_oop(src->as_register(), FILE_AND_LINE);
       __ reg2mem_opt(src->as_register(), dst, true);
-    } else if (type == T_METADATA) {
+    } else if (type == T_METADATA || type == T_ADDRESS) {
       __ reg2mem_opt(src->as_register(), dst, true);
     } else {
       __ reg2mem_opt(src->as_register(), dst, false);
     }
   } else if (src->is_double_cpu()) {
@@ -1062,12 +1075,12 @@
       __ z_lgr(to_reg->as_register(), from_reg->as_register());
     }
   } else {
     ShouldNotReachHere();
   }
-  if (to_reg->type() == T_OBJECT || to_reg->type() == T_ARRAY) {
-    __ verify_oop(to_reg->as_register());
+  if (is_reference_type(to_reg->type())) {
+    __ verify_oop(to_reg->as_register(), FILE_AND_LINE);
   }
 }
 
 void LIR_Assembler::reg2mem(LIR_Opr from, LIR_Opr dest_opr, BasicType type,
                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
@@ -1079,11 +1092,11 @@
   Register disp_reg = Z_R0;
   int disp_value = addr->disp();
   bool needs_patching = (patch_code != lir_patch_none);
 
   if (addr->base()->is_oop_register()) {
-    __ verify_oop(dest);
+    __ verify_oop(dest, FILE_AND_LINE);
   }
 
   PatchingStub* patch = NULL;
   if (needs_patching) {
     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
@@ -1113,12 +1126,12 @@
     disp_reg = addr->index()->as_pointer_register();
   }
 
   assert(disp_reg != Z_R0 || Immediate::is_simm20(disp_value), "should have set this up");
 
-  if (type == T_ARRAY || type == T_OBJECT) {
-    __ verify_oop(from->as_register());
+  if (is_reference_type(type)) {
+    __ verify_oop(from->as_register(), FILE_AND_LINE);
   }
 
   bool short_disp = Immediate::is_uimm12(disp_value);
 
   // Remember the offset of the store. The patching_epilog must be done
@@ -1276,23 +1289,23 @@
   bool unsigned_comp = condition == lir_cond_belowEqual || condition == lir_cond_aboveEqual;
   if (opr1->is_single_cpu()) {
     Register reg1 = opr1->as_register();
     if (opr2->is_single_cpu()) {
       // cpu register - cpu register
-      if (opr1->type() == T_OBJECT || opr1->type() == T_ARRAY) {
+      if (is_reference_type(opr1->type())) {
         __ z_clgr(reg1, opr2->as_register());
       } else {
-        assert(opr2->type() != T_OBJECT && opr2->type() != T_ARRAY, "cmp int, oop?");
+        assert(!is_reference_type(opr2->type()), "cmp int, oop?");
         if (unsigned_comp) {
           __ z_clr(reg1, opr2->as_register());
         } else {
           __ z_cr(reg1, opr2->as_register());
         }
       }
     } else if (opr2->is_stack()) {
       // cpu register - stack
-      if (opr1->type() == T_OBJECT || opr1->type() == T_ARRAY) {
+      if (is_reference_type(opr1->type())) {
         __ z_cg(reg1, frame_map()->address_for_slot(opr2->single_stack_ix()));
       } else {
         if (unsigned_comp) {
           __ z_cly(reg1, frame_map()->address_for_slot(opr2->single_stack_ix()));
         } else {
@@ -1306,11 +1319,20 @@
         if (unsigned_comp) {
           __ z_clfi(reg1, c->as_jint());
         } else {
           __ z_cfi(reg1, c->as_jint());
         }
-      } else if (c->type() == T_OBJECT || c->type() == T_ARRAY) {
+      } else if (c->type() == T_METADATA) {
+        // We only need, for now, comparison with NULL for metadata.
+        assert(condition == lir_cond_equal || condition == lir_cond_notEqual, "oops");
+        Metadata* m = c->as_metadata();
+        if (m == NULL) {
+          __ z_cghi(reg1, 0);
+        } else {
+          ShouldNotReachHere();
+        }
+      } else if (is_reference_type(c->type())) {
         // In 64bit oops are single register.
         jobject o = c->as_jobject();
         if (o == NULL) {
           __ z_ltgr(reg1, reg1);
         } else {
@@ -1675,14 +1697,10 @@
   } else {
     ShouldNotReachHere();
   }
 }
 
-void LIR_Assembler::fpop() {
-  // do nothing
-}
-
 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
   switch (code) {
     case lir_sqrt: {
       assert(!thread->is_valid(), "there is no need for a thread_reg for dsqrt");
       FloatRegister src_reg = value->as_double_reg();
@@ -1749,11 +1767,11 @@
           break;
         default: ShouldNotReachHere();
       }
     } else {
       Register r_lo;
-      if (right->type() == T_OBJECT || right->type() == T_ARRAY) {
+      if (is_reference_type(right->type())) {
         r_lo = right->as_register();
       } else {
         r_lo = right->as_register_lo();
       }
       switch (code) {
@@ -1779,11 +1797,11 @@
 // See operand selection in LIRGenerator::do_ArithmeticOp_Int().
 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
   if (left->is_double_cpu()) {
     // 64 bit integer case
     assert(left->is_double_cpu(), "left must be register");
-    assert(right->is_double_cpu() || is_power_of_2_long(right->as_jlong()),
+    assert(right->is_double_cpu() || is_power_of_2(right->as_jlong()),
            "right must be register or power of 2 constant");
     assert(result->is_double_cpu(), "result must be register");
 
     Register lreg = left->as_register_lo();
     Register dreg = result->as_register_lo();
@@ -1967,11 +1985,10 @@
       __ branch_optimized(Assembler::bcondAlways, *stub->entry());
       __ bind(*stub->continuation());
       return;
     }
 
-    Label done;
     // Save outgoing arguments in callee saved registers (C convention) in case
     // a call to System.arraycopy is needed.
     Register callee_saved_src     = Z_R10;
     Register callee_saved_src_pos = Z_R11;
     Register callee_saved_dst     = Z_R12;
@@ -2139,11 +2156,11 @@
       __ check_klass_subtype_fast_path(src_klass, dst_klass, tmp, &cont, &slow, NULL);
 
       store_parameter(src_klass, 0); // sub
       store_parameter(dst_klass, 1); // super
       emit_call_c(Runtime1::entry_for (Runtime1::slow_subtype_check_id));
-      CHECK_BAILOUT();
+      CHECK_BAILOUT2(cont, slow);
       // Sets condition code 0 for match (2 otherwise).
       __ branch_optimized(Assembler::bcondEqual, cont);
 
       __ bind(slow);
 
@@ -2198,11 +2215,11 @@
 
         __ load_klass(Z_ARG5, dst);
         __ z_lg(Z_ARG5, Address(Z_ARG5, ObjArrayKlass::element_klass_offset()));
         __ z_lg(Z_ARG4, Address(Z_ARG5, Klass::super_check_offset_offset()));
         emit_call_c(copyfunc_addr);
-        CHECK_BAILOUT();
+        CHECK_BAILOUT2(cont, slow);
 
 #ifndef PRODUCT
         if (PrintC1Statistics) {
           NearLabel failed;
           __ compareU32_and_branch(Z_RET, (intptr_t)0, Assembler::bcondNotEqual, failed);
@@ -2388,20 +2405,20 @@
                      op->header_size(),
                      op->object_size(),
                      op->klass()->as_register(),
                      *op->stub()->entry());
   __ bind(*op->stub()->continuation());
-  __ verify_oop(op->obj()->as_register());
+  __ verify_oop(op->obj()->as_register(), FILE_AND_LINE);
 }
 
 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
   Register len = op->len()->as_register();
   __ move_reg_if_needed(len, T_LONG, len, T_INT); // sign extend
 
   if (UseSlowPath ||
-      (!UseFastNewObjectArray && (op->type() == T_OBJECT || op->type() == T_ARRAY)) ||
-      (!UseFastNewTypeArray   && (op->type() != T_OBJECT && op->type() != T_ARRAY))) {
+      (!UseFastNewObjectArray && (is_reference_type(op->type()))) ||
+      (!UseFastNewTypeArray   && (!is_reference_type(op->type())))) {
     __ z_brul(*op->stub()->entry());
   } else {
     __ allocate_array(op->obj()->as_register(),
                       op->len()->as_register(),
                       op->tmp1()->as_register(),
@@ -2524,11 +2541,11 @@
   } else {
     klass2reg_with_patching(k_RInfo, op->info_for_patch());
   }
   assert(obj != k_RInfo, "must be different");
 
-  __ verify_oop(obj);
+  __ verify_oop(obj, FILE_AND_LINE);
 
   // Get object class.
   // Not a safepoint as obj null check happens earlier.
   if (op->fast_check()) {
     if (UseCompressedClassPointers) {
@@ -2553,11 +2570,11 @@
       // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
       address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
       store_parameter(klass_RInfo, 0); // sub
       store_parameter(k_RInfo, 1);     // super
       emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
-      CHECK_BAILOUT();
+      CHECK_BAILOUT2(profile_cast_failure, profile_cast_success);
       __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
       // Fall through to success case.
     }
   }
 
@@ -2636,11 +2653,11 @@
     // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
     address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
     store_parameter(klass_RInfo, 0); // sub
     store_parameter(k_RInfo, 1);     // super
     emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
-    CHECK_BAILOUT();
+    CHECK_BAILOUT3(profile_cast_success, profile_cast_failure, done);
     __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
     // Fall through to success case.
 
     if (op->should_profile()) {
       Register mdo = klass_RInfo, recv = k_RInfo;
@@ -2717,18 +2734,10 @@
   } else {
     ShouldNotReachHere(); // new lir_cas_??
   }
 }
 
-void LIR_Assembler::set_24bit_FPU() {
-  ShouldNotCallThis(); // x86 only
-}
-
-void LIR_Assembler::reset_FPU() {
-  ShouldNotCallThis(); // x86 only
-}
-
 void LIR_Assembler::breakpoint() {
   Unimplemented();
   //  __ breakpoint_trap();
 }
 
@@ -2865,22 +2874,10 @@
     assert(left->is_double_cpu(), "Must be a long");
     __ z_lcgr(dest->as_register_lo(), left->as_register_lo());
   }
 }
 
-void LIR_Assembler::fxch(int i) {
-  ShouldNotCallThis(); // x86 only
-}
-
-void LIR_Assembler::fld(int i) {
-  ShouldNotCallThis(); // x86 only
-}
-
-void LIR_Assembler::ffree(int i) {
-  ShouldNotCallThis(); // x86 only
-}
-
 void LIR_Assembler::rt_call(LIR_Opr result, address dest,
                             const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
   assert(!tmp->is_valid(), "don't need temporary");
   emit_call_c(dest);
   CHECK_BAILOUT();
@@ -2985,11 +2982,11 @@
   bool do_update = !TypeEntries::is_type_unknown(current_klass) && !exact_klass_set;
 
   assert(do_null || do_update, "why are we here?");
   assert(!TypeEntries::was_null_seen(current_klass) || do_update, "why are we here?");
 
-  __ verify_oop(obj);
+  __ verify_oop(obj, FILE_AND_LINE);
 
   if (do_null || tmp1 != obj DEBUG_ONLY(|| true)) {
     __ z_ltgr(tmp1, obj);
   }
   if (do_null) {

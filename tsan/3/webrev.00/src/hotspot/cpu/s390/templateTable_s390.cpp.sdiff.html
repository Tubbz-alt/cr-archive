<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/templateTable_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="templateInterpreterGenerator_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_ext_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/templateTable_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/interpreter.hpp&quot;
  30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  31 #include &quot;interpreter/interp_masm.hpp&quot;
  32 #include &quot;interpreter/templateTable.hpp&quot;
  33 #include &quot;memory/universe.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;prims/methodHandles.hpp&quot;
  37 #include &quot;runtime/frame.inline.hpp&quot;
  38 #include &quot;runtime/safepointMechanism.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubRoutines.hpp&quot;
  41 #include &quot;runtime/synchronizer.hpp&quot;

  42 
  43 #ifdef PRODUCT
  44 #define __ _masm-&gt;
  45 #define BLOCK_COMMENT(str)
  46 #define BIND(label)        __ bind(label);
  47 #else
  48 #define __ (PRODUCT_ONLY(false&amp;&amp;)Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm):_masm)-&gt;
  49 #define BLOCK_COMMENT(str) __ block_comment(str)
  50 #define BIND(label)        __ bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  51 #endif
  52 
  53 // The assumed minimum size of a BranchTableBlock.
  54 // The actual size of each block heavily depends on the CPU capabilities and,
  55 // of course, on the logic implemented in each block.
  56 #ifdef ASSERT
  57   #define BTB_MINSIZE 256
  58 #else
  59   #define BTB_MINSIZE  64
  60 #endif
  61 
</pre>
<hr />
<pre>
2387     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint));
2388     __ pop(state);
2389     __ bind(no_safepoint);
2390   }
2391 
2392   if (state == itos) {
2393     // Narrow result if state is itos but result type is smaller.
2394     // Need to narrow in the return bytecode rather than in generate_return_entry
2395     // since compiled code callers expect the result to already be narrowed.
2396     __ narrow(Z_tos, Z_tmp_1); /* fall through */
2397   }
2398 
2399   __ remove_activation(state, Z_R14);
2400   __ z_br(Z_R14);
2401 }
2402 
2403 // ----------------------------------------------------------------------------
2404 // NOTE: Cpe_offset is already computed as byte offset, so we must not
2405 // shift it afterwards!
2406 void TemplateTable::resolve_cache_and_index(int byte_no,
<span class="line-modified">2407                                             Register Rcache,</span>
2408                                             Register cpe_offset,
2409                                             size_t index_size) {
2410   BLOCK_COMMENT(&quot;resolve_cache_and_index {&quot;);
<span class="line-modified">2411   NearLabel      resolved;</span>
2412   const Register bytecode_in_cpcache = Z_R1_scratch;
2413   const int      total_f1_offset = in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset());
<span class="line-modified">2414   assert_different_registers(Rcache, cpe_offset, bytecode_in_cpcache);</span>
2415 
2416   Bytecodes::Code code = bytecode();
2417   switch (code) {
2418     case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2419     case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2420     default:
2421       break;
2422   }
2423 
2424   {
2425     assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
<span class="line-modified">2426     __ get_cache_and_index_and_bytecode_at_bcp(Rcache, cpe_offset, bytecode_in_cpcache, byte_no, 1, index_size);</span>
2427     // Have we resolved this bytecode?
2428     __ compare32_and_branch(bytecode_in_cpcache, (int)code, Assembler::bcondEqual, resolved);
2429   }
2430 
2431   // Resolve first time through.


2432   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2433   __ load_const_optimized(Z_ARG2, (int) code);
2434   __ call_VM(noreg, entry, Z_ARG2);
2435 
2436   // Update registers with resolved info.
<span class="line-modified">2437   __ get_cache_and_index_at_bcp(Rcache, cpe_offset, 1, index_size);</span>
2438   __ bind(resolved);











2439   BLOCK_COMMENT(&quot;} resolve_cache_and_index&quot;);
2440 }
2441 
2442 // The Rcache and index registers must be set before call.
2443 // Index is already a byte offset, don&#39;t shift!
2444 void TemplateTable::load_field_cp_cache_entry(Register obj,
2445                                               Register cache,
2446                                               Register index,
2447                                               Register off,
2448                                               Register flags,
2449                                               bool is_static = false) {
2450   assert_different_registers(cache, index, flags, off);
2451   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2452 
2453   // Field offset
2454   __ mem2reg_opt(off, Address(cache, index, cp_base_offset + ConstantPoolCacheEntry::f2_offset()));
2455   // Flags. Must load 64 bits.
2456   __ mem2reg_opt(flags, Address(cache, index, cp_base_offset + ConstantPoolCacheEntry::flags_offset()));
2457 
2458   // klass overwrite register
</pre>
<hr />
<pre>
3647 
3648   // do the call
3649   __ profile_final_call(Z_tmp_2);
3650   __ profile_arguments_type(Z_tmp_2, method, Z_ARG5, true);
3651   __ jump_from_interpreted(method, Z_tmp_2);
3652 
3653   __ bind(notVFinal);
3654 
3655   // Get receiver klass into klass - also a null check.
3656   __ load_klass(klass, receiver);
3657 
3658   __ lookup_interface_method(klass, interface, noreg, noreg, /*temp*/Z_ARG1,
3659                              no_such_interface, /*return_method=*/false);
3660 
3661   // Profile this call.
3662   __ profile_virtual_call(klass, Z_ARG1/*mdp*/, flags/*scratch*/);
3663 
3664   // Find entry point to call.
3665 
3666   // Get declaring interface class from method
<span class="line-modified">3667   __ z_lg(interface, Address(method, Method::const_offset()));</span>
<span class="line-removed">3668   __ z_lg(interface, Address(interface, ConstMethod::constants_offset()));</span>
<span class="line-removed">3669   __ z_lg(interface, Address(interface, ConstantPool::pool_holder_offset_in_bytes()));</span>
3670 
3671   // Get itable index from method
3672   Register index   = receiver,
3673            method2 = flags;
3674   __ z_lgf(index, Address(method, Method::itable_index_offset()));
3675   __ z_aghi(index, -Method::itable_index_max);
3676   __ z_lcgr(index, index);
3677 
3678   __ lookup_interface_method(klass, interface, index, method2, Z_tmp_2,
3679                              no_such_interface);
3680 
3681   // Check for abstract method error.
3682   // Note: This should be done more efficiently via a throw_abstract_method_error
3683   // interpreter entry point and a conditional jump to it in case of a null
3684   // method.
3685   __ compareU64_and_branch(method2, (intptr_t) 0,
3686                            Assembler::bcondZero, no_such_method);
3687 
3688   __ profile_arguments_type(Z_tmp_1, method2, Z_tmp_2, true);
3689 
</pre>
<hr />
<pre>
3852       // See documentation for MVCLE instruction!!!
3853       assert(RobjectFields-&gt;encoding() % 2 == 0, &quot;RobjectFields must be an even register&quot;);
3854       assert(Rsize-&gt;encoding() == (RobjectFields-&gt;encoding()+1),
3855              &quot;RobjectFields and Rsize must be a register pair&quot;);
3856       assert(Rzero-&gt;encoding() % 2 == 1, &quot;Rzero must be an odd register&quot;);
3857 
3858       // Set Rzero to 0 and use it as src length, then mvcle will copy nothing
3859       // and fill the object with the padding value 0.
3860       __ add2reg(RobjectFields, sizeof(oopDesc), RallocatedObject);
3861       __ move_long_ext(RobjectFields, as_Register(Rzero-&gt;encoding() - 1), 0);
3862     }
3863 
3864     // Initialize object header only.
3865     __ bind(initialize_header);
3866     if (UseBiasedLocking) {
3867       Register prototype = RobjectFields;
3868       __ z_lg(prototype, Address(iklass, Klass::prototype_header_offset()));
3869       __ z_stg(prototype, Address(RallocatedObject, oopDesc::mark_offset_in_bytes()));
3870     } else {
3871       __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),
<span class="line-modified">3872                      (long)markOopDesc::prototype());</span>
3873     }
3874 
3875     __ store_klass_gap(Rzero, RallocatedObject);  // Zero klass gap for compressed oops.
3876     __ store_klass(iklass, RallocatedObject);     // Store klass last.
3877 
3878     {
3879       SkipIfEqual skip(_masm, &amp;DTraceAllocProbes, false, Z_ARG5 /*scratch*/);
3880       // Trigger dtrace event for fastpath.
3881       __ push(atos); // Save the return value.
3882       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), RallocatedObject);
3883       __ pop(atos); // Restore the return value.
3884     }
3885     __ z_bru(done);
3886   }
3887 
3888   // slow case
3889   __ bind(slow_case);
3890   __ get_constant_pool(Z_ARG2);
3891   __ get_2_byte_integer_at_bcp(Z_ARG3/*dest*/, 1, InterpreterMacroAssembler::Unsigned);
3892   call_VM(Z_tos, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), Z_ARG2, Z_ARG3);
</pre>
</td>
<td>
<hr />
<pre>
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  29 #include &quot;interpreter/interpreter.hpp&quot;
  30 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  31 #include &quot;interpreter/interp_masm.hpp&quot;
  32 #include &quot;interpreter/templateTable.hpp&quot;
  33 #include &quot;memory/universe.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;prims/methodHandles.hpp&quot;
  37 #include &quot;runtime/frame.inline.hpp&quot;
  38 #include &quot;runtime/safepointMechanism.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubRoutines.hpp&quot;
  41 #include &quot;runtime/synchronizer.hpp&quot;
<span class="line-added">  42 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  43 
  44 #ifdef PRODUCT
  45 #define __ _masm-&gt;
  46 #define BLOCK_COMMENT(str)
  47 #define BIND(label)        __ bind(label);
  48 #else
  49 #define __ (PRODUCT_ONLY(false&amp;&amp;)Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm):_masm)-&gt;
  50 #define BLOCK_COMMENT(str) __ block_comment(str)
  51 #define BIND(label)        __ bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  52 #endif
  53 
  54 // The assumed minimum size of a BranchTableBlock.
  55 // The actual size of each block heavily depends on the CPU capabilities and,
  56 // of course, on the logic implemented in each block.
  57 #ifdef ASSERT
  58   #define BTB_MINSIZE 256
  59 #else
  60   #define BTB_MINSIZE  64
  61 #endif
  62 
</pre>
<hr />
<pre>
2388     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint));
2389     __ pop(state);
2390     __ bind(no_safepoint);
2391   }
2392 
2393   if (state == itos) {
2394     // Narrow result if state is itos but result type is smaller.
2395     // Need to narrow in the return bytecode rather than in generate_return_entry
2396     // since compiled code callers expect the result to already be narrowed.
2397     __ narrow(Z_tos, Z_tmp_1); /* fall through */
2398   }
2399 
2400   __ remove_activation(state, Z_R14);
2401   __ z_br(Z_R14);
2402 }
2403 
2404 // ----------------------------------------------------------------------------
2405 // NOTE: Cpe_offset is already computed as byte offset, so we must not
2406 // shift it afterwards!
2407 void TemplateTable::resolve_cache_and_index(int byte_no,
<span class="line-modified">2408                                             Register cache,</span>
2409                                             Register cpe_offset,
2410                                             size_t index_size) {
2411   BLOCK_COMMENT(&quot;resolve_cache_and_index {&quot;);
<span class="line-modified">2412   NearLabel      resolved, clinit_barrier_slow;</span>
2413   const Register bytecode_in_cpcache = Z_R1_scratch;
2414   const int      total_f1_offset = in_bytes(ConstantPoolCache::base_offset() + ConstantPoolCacheEntry::f1_offset());
<span class="line-modified">2415   assert_different_registers(cache, cpe_offset, bytecode_in_cpcache);</span>
2416 
2417   Bytecodes::Code code = bytecode();
2418   switch (code) {
2419     case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2420     case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2421     default:
2422       break;
2423   }
2424 
2425   {
2426     assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
<span class="line-modified">2427     __ get_cache_and_index_and_bytecode_at_bcp(cache, cpe_offset, bytecode_in_cpcache, byte_no, 1, index_size);</span>
2428     // Have we resolved this bytecode?
2429     __ compare32_and_branch(bytecode_in_cpcache, (int)code, Assembler::bcondEqual, resolved);
2430   }
2431 
2432   // Resolve first time through.
<span class="line-added">2433   // Class initialization barrier slow path lands here as well.</span>
<span class="line-added">2434   __ bind(clinit_barrier_slow);</span>
2435   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2436   __ load_const_optimized(Z_ARG2, (int) code);
2437   __ call_VM(noreg, entry, Z_ARG2);
2438 
2439   // Update registers with resolved info.
<span class="line-modified">2440   __ get_cache_and_index_at_bcp(cache, cpe_offset, 1, index_size);</span>
2441   __ bind(resolved);
<span class="line-added">2442 </span>
<span class="line-added">2443   // Class initialization barrier for static methods</span>
<span class="line-added">2444   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; bytecode() == Bytecodes::_invokestatic) {</span>
<span class="line-added">2445     const Register method = Z_R1_scratch;</span>
<span class="line-added">2446     const Register klass  = Z_R1_scratch;</span>
<span class="line-added">2447 </span>
<span class="line-added">2448     __ load_resolved_method_at_index(byte_no, cache, cpe_offset, method);</span>
<span class="line-added">2449     __ load_method_holder(klass, method);</span>
<span class="line-added">2450     __ clinit_barrier(klass, Z_thread, NULL /*L_fast_path*/, &amp;clinit_barrier_slow);</span>
<span class="line-added">2451   }</span>
<span class="line-added">2452 </span>
2453   BLOCK_COMMENT(&quot;} resolve_cache_and_index&quot;);
2454 }
2455 
2456 // The Rcache and index registers must be set before call.
2457 // Index is already a byte offset, don&#39;t shift!
2458 void TemplateTable::load_field_cp_cache_entry(Register obj,
2459                                               Register cache,
2460                                               Register index,
2461                                               Register off,
2462                                               Register flags,
2463                                               bool is_static = false) {
2464   assert_different_registers(cache, index, flags, off);
2465   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2466 
2467   // Field offset
2468   __ mem2reg_opt(off, Address(cache, index, cp_base_offset + ConstantPoolCacheEntry::f2_offset()));
2469   // Flags. Must load 64 bits.
2470   __ mem2reg_opt(flags, Address(cache, index, cp_base_offset + ConstantPoolCacheEntry::flags_offset()));
2471 
2472   // klass overwrite register
</pre>
<hr />
<pre>
3661 
3662   // do the call
3663   __ profile_final_call(Z_tmp_2);
3664   __ profile_arguments_type(Z_tmp_2, method, Z_ARG5, true);
3665   __ jump_from_interpreted(method, Z_tmp_2);
3666 
3667   __ bind(notVFinal);
3668 
3669   // Get receiver klass into klass - also a null check.
3670   __ load_klass(klass, receiver);
3671 
3672   __ lookup_interface_method(klass, interface, noreg, noreg, /*temp*/Z_ARG1,
3673                              no_such_interface, /*return_method=*/false);
3674 
3675   // Profile this call.
3676   __ profile_virtual_call(klass, Z_ARG1/*mdp*/, flags/*scratch*/);
3677 
3678   // Find entry point to call.
3679 
3680   // Get declaring interface class from method
<span class="line-modified">3681   __ load_method_holder(interface, method);</span>


3682 
3683   // Get itable index from method
3684   Register index   = receiver,
3685            method2 = flags;
3686   __ z_lgf(index, Address(method, Method::itable_index_offset()));
3687   __ z_aghi(index, -Method::itable_index_max);
3688   __ z_lcgr(index, index);
3689 
3690   __ lookup_interface_method(klass, interface, index, method2, Z_tmp_2,
3691                              no_such_interface);
3692 
3693   // Check for abstract method error.
3694   // Note: This should be done more efficiently via a throw_abstract_method_error
3695   // interpreter entry point and a conditional jump to it in case of a null
3696   // method.
3697   __ compareU64_and_branch(method2, (intptr_t) 0,
3698                            Assembler::bcondZero, no_such_method);
3699 
3700   __ profile_arguments_type(Z_tmp_1, method2, Z_tmp_2, true);
3701 
</pre>
<hr />
<pre>
3864       // See documentation for MVCLE instruction!!!
3865       assert(RobjectFields-&gt;encoding() % 2 == 0, &quot;RobjectFields must be an even register&quot;);
3866       assert(Rsize-&gt;encoding() == (RobjectFields-&gt;encoding()+1),
3867              &quot;RobjectFields and Rsize must be a register pair&quot;);
3868       assert(Rzero-&gt;encoding() % 2 == 1, &quot;Rzero must be an odd register&quot;);
3869 
3870       // Set Rzero to 0 and use it as src length, then mvcle will copy nothing
3871       // and fill the object with the padding value 0.
3872       __ add2reg(RobjectFields, sizeof(oopDesc), RallocatedObject);
3873       __ move_long_ext(RobjectFields, as_Register(Rzero-&gt;encoding() - 1), 0);
3874     }
3875 
3876     // Initialize object header only.
3877     __ bind(initialize_header);
3878     if (UseBiasedLocking) {
3879       Register prototype = RobjectFields;
3880       __ z_lg(prototype, Address(iklass, Klass::prototype_header_offset()));
3881       __ z_stg(prototype, Address(RallocatedObject, oopDesc::mark_offset_in_bytes()));
3882     } else {
3883       __ store_const(Address(RallocatedObject, oopDesc::mark_offset_in_bytes()),
<span class="line-modified">3884                      (long)markWord::prototype().value());</span>
3885     }
3886 
3887     __ store_klass_gap(Rzero, RallocatedObject);  // Zero klass gap for compressed oops.
3888     __ store_klass(iklass, RallocatedObject);     // Store klass last.
3889 
3890     {
3891       SkipIfEqual skip(_masm, &amp;DTraceAllocProbes, false, Z_ARG5 /*scratch*/);
3892       // Trigger dtrace event for fastpath.
3893       __ push(atos); // Save the return value.
3894       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), RallocatedObject);
3895       __ pop(atos); // Restore the return value.
3896     }
3897     __ z_bru(done);
3898   }
3899 
3900   // slow case
3901   __ bind(slow_case);
3902   __ get_constant_pool(Z_ARG2);
3903   __ get_2_byte_integer_at_bcp(Z_ARG3/*dest*/, 1, InterpreterMacroAssembler::Unsigned);
3904   call_VM(Z_tos, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), Z_ARG2, Z_ARG3);
</pre>
</td>
</tr>
</table>
<center><a href="templateInterpreterGenerator_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vm_version_ext_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
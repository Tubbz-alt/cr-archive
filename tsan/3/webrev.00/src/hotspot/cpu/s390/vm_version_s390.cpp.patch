diff a/src/hotspot/cpu/s390/vm_version_s390.cpp b/src/hotspot/cpu/s390/vm_version_s390.cpp
--- a/src/hotspot/cpu/s390/vm_version_s390.cpp
+++ b/src/hotspot/cpu/s390/vm_version_s390.cpp
@@ -29,11 +29,11 @@
 #include "compiler/disassembler.hpp"
 #include "code/compiledIC.hpp"
 #include "memory/resourceArea.hpp"
 #include "runtime/java.hpp"
 #include "runtime/stubCodeGenerator.hpp"
-#include "vm_version_s390.hpp"
+#include "runtime/vm_version.hpp"
 
 # include <sys/sysinfo.h>
 
 bool VM_Version::_is_determine_features_test_running  = false;
 const char*   VM_Version::_model_string;
@@ -42,12 +42,12 @@
 unsigned long VM_Version::_cipher_features[_features_buffer_len]    = {0, 0, 0, 0};
 unsigned long VM_Version::_msgdigest_features[_features_buffer_len] = {0, 0, 0, 0};
 unsigned int  VM_Version::_nfeatures                                = 0;
 unsigned int  VM_Version::_ncipher_features                         = 0;
 unsigned int  VM_Version::_nmsgdigest_features                      = 0;
-unsigned int  VM_Version::_Dcache_lineSize                          = 256;
-unsigned int  VM_Version::_Icache_lineSize                          = 256;
+unsigned int  VM_Version::_Dcache_lineSize                          = DEFAULT_CACHE_LINE_SIZE;
+unsigned int  VM_Version::_Icache_lineSize                          = DEFAULT_CACHE_LINE_SIZE;
 
 static const char* z_gen[]     = {"  ",   "G1",   "G2", "G3",    "G4",     "G5",      "G6",   "G7"   };
 static const char* z_machine[] = {"  ", "2064", "2084", "2094",  "2097",   "2817",    "  ",   "2964" };
 static const char* z_name[]    = {"  ", "z900", "z990", "z9 EC", "z10 EC", "z196 EC", "ec12", "z13"  };
 
@@ -59,11 +59,13 @@
     print_features();
   }
 
   intx cache_line_size = Dcache_lineSize(0);
 
+#ifdef COMPILER2
   MaxVectorSize = 8;
+#endif
 
   if (has_PrefetchRaw()) {
     if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {  // not preset
       // 0 = no prefetch.
       // 1 = Prefetch instructions for each allocation.
@@ -215,19 +217,21 @@
 
   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
     FLAG_SET_DEFAULT(UseSHA, false);
   }
 
+#ifdef COMPILER2
   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
     FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);
   }
   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
     FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, true);
   }
   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
     FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, true);
   }
+#endif
   if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
     FLAG_SET_DEFAULT(UsePopCountInstruction, true);
   }
 
   // z/Architecture supports 8-byte compare-exchange operations
@@ -514,10 +518,23 @@
       tty->print_cr("ContendedPaddingWidth " INTX_FORMAT, ContendedPaddingWidth);
     }
   }
 }
 
+void VM_Version::print_platform_virtualization_info(outputStream* st) {
+  // /proc/sysinfo contains interesting information about
+  // - LPAR
+  // - whole "Box" (CPUs )
+  // - z/VM / KVM (VM<nn>); this is not available in an LPAR-only setup
+  const char* kw[] = { "LPAR", "CPUs", "VM", NULL };
+  const char* info_file = "/proc/sysinfo";
+
+  if (!print_matching_lines_from_file(info_file, st, kw)) {
+    st->print_cr("  <%s Not Available>", info_file);
+  }
+}
+
 void VM_Version::print_features() {
   print_features_internal("Version:");
 }
 
 void VM_Version::reset_features(bool reset) {
@@ -789,20 +806,22 @@
   a->z_br(Z_R14);
 
   address code_end = a->pc();
   a->flush();
 
+  cbuf.insts()->set_end(code_end);
+
   // Print the detection code.
   bool printVerbose = Verbose || PrintAssembly || PrintStubCode;
   if (printVerbose) {
     ttyLocker ttyl;
     tty->print_cr("Decoding CPU feature detection stub at " INTPTR_FORMAT " before execution:", p2i(code));
     tty->print_cr("Stub length is %ld bytes, codebuffer reserves %d bytes, %ld bytes spare.",
                   code_end-code, cbuf_size, cbuf_size-(code_end-code));
 
-    // Use existing decode function. This enables the [Code] format which is needed to DecodeErrorFile.
-    Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
+    // Use existing decode function. This enables the [MachCode] format which is needed to DecodeErrorFile.
+    Disassembler::decode(&cbuf, code, code_end, tty);
   }
 
   // Prepare for detection code execution and clear work buffer.
   _nfeatures        = 0;
   _ncipher_features = 0;

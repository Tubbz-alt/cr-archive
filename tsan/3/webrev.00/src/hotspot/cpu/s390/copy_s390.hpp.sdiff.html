<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/copy_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compiledIC_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="disassembler_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/copy_s390.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2016 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
1078   while (count-- &gt; 0) {
1079     *to++ = v;
1080   }
1081 }
1082 
1083 static void pd_fill_to_aligned_words(HeapWord* tohw, size_t count, juint value) {
1084   // JVM2008: very frequent, but virtually all calls are with value == 0.
1085   pd_fill_to_words(tohw, count, value);
1086 }
1087 
1088 //**********************************//
1089 //  M E M O R Y   C L E A R I N G   //
1090 //**********************************//
1091 
1092 // Delegate to pd_zero_to_bytes. It also works HeapWord-atomic.
1093 // Distinguish between simple and large zero_to_words.
1094 static void pd_zero_to_words(HeapWord* tohw, size_t count) {
1095   pd_zero_to_bytes(tohw, count*HeapWordSize);
1096 }
1097 
<span class="line-removed">1098 // Delegate to pd_zero_to_bytes. It also works HeapWord-atomic.</span>
<span class="line-removed">1099 static void pd_zero_to_words_large(HeapWord* tohw, size_t count) {</span>
<span class="line-removed">1100   // JVM2008: generally frequent, some tests show very frequent calls.</span>
<span class="line-removed">1101   pd_zero_to_bytes(tohw, count*HeapWordSize);</span>
<span class="line-removed">1102 }</span>
<span class="line-removed">1103 </span>
1104 static void pd_zero_to_bytes(void* to, size_t count) {
1105   // JVM2008: some calls (generally), some tests frequent
1106 #ifdef USE_INLINE_ASM
1107   // Even zero_to_bytes() requires HeapWord-atomic, or, at least, sequential
1108   // zeroing of the memory. MVCLE is not fit for that job:
1109   //   &quot;As observed by other CPUs and by the channel subsystem,
1110   //    that portion of the first operand which is filled
1111   //    with the padding byte is not necessarily stored into in
1112   //    a left-to-right direction and may appear to be stored
1113   //    into more than once.&quot;
1114   // Therefore, implementation was changed to use (multiple) XC instructions.
1115 
1116   const long line_size = 256;
1117   jbyte* to_bytes  = (jbyte*)to;
1118   size_t len_bytes = count;
1119 
1120   if (len_bytes &lt;= line_size) {
1121     XC_MEMZERO_256(to_bytes, len_bytes);
1122   } else {
1123     XC_MEMZERO_ANY(to_bytes, len_bytes);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2016, 2020 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
1078   while (count-- &gt; 0) {
1079     *to++ = v;
1080   }
1081 }
1082 
1083 static void pd_fill_to_aligned_words(HeapWord* tohw, size_t count, juint value) {
1084   // JVM2008: very frequent, but virtually all calls are with value == 0.
1085   pd_fill_to_words(tohw, count, value);
1086 }
1087 
1088 //**********************************//
1089 //  M E M O R Y   C L E A R I N G   //
1090 //**********************************//
1091 
1092 // Delegate to pd_zero_to_bytes. It also works HeapWord-atomic.
1093 // Distinguish between simple and large zero_to_words.
1094 static void pd_zero_to_words(HeapWord* tohw, size_t count) {
1095   pd_zero_to_bytes(tohw, count*HeapWordSize);
1096 }
1097 






1098 static void pd_zero_to_bytes(void* to, size_t count) {
1099   // JVM2008: some calls (generally), some tests frequent
1100 #ifdef USE_INLINE_ASM
1101   // Even zero_to_bytes() requires HeapWord-atomic, or, at least, sequential
1102   // zeroing of the memory. MVCLE is not fit for that job:
1103   //   &quot;As observed by other CPUs and by the channel subsystem,
1104   //    that portion of the first operand which is filled
1105   //    with the padding byte is not necessarily stored into in
1106   //    a left-to-right direction and may appear to be stored
1107   //    into more than once.&quot;
1108   // Therefore, implementation was changed to use (multiple) XC instructions.
1109 
1110   const long line_size = 256;
1111   jbyte* to_bytes  = (jbyte*)to;
1112   size_t len_bytes = count;
1113 
1114   if (len_bytes &lt;= line_size) {
1115     XC_MEMZERO_256(to_bytes, len_bytes);
1116   } else {
1117     XC_MEMZERO_ANY(to_bytes, len_bytes);
</pre>
</td>
</tr>
</table>
<center><a href="compiledIC_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="disassembler_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
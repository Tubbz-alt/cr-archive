<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/s390/macroAssembler_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jniFastGetField_s390.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_s390.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/macroAssembler_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">!  * Copyright (c) 2016, 2018, SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,8 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">!  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 35,13 ***</span>
<span class="line-new-header">--- 35,15 ---</span>
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/accessDecorators.hpp&quot;
  #include &quot;oops/compressedOops.inline.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
<span class="line-added">+ #ifdef COMPILER2</span>
  #include &quot;opto/compile.hpp&quot;
  #include &quot;opto/intrinsicnode.hpp&quot;
  #include &quot;opto/matcher.hpp&quot;
<span class="line-added">+ #endif</span>
  #include &quot;prims/methodHandles.hpp&quot;
  #include &quot;registerSaver_s390.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/icache.hpp&quot;
  #include &quot;runtime/interfaceSupport.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 51,10 ***</span>
<span class="line-new-header">--- 53,11 ---</span>
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/stubRoutines.hpp&quot;
  #include &quot;utilities/events.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  #include &lt;ucontext.h&gt;
  
  #define BLOCK_COMMENT(str) block_comment(str)
  #define BIND(label)        bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1169,11 ***</span>
  }
  
  // Load narrow klass constant, compression required.
  void MacroAssembler::load_narrow_klass(Register t, Klass* k) {
    assert(UseCompressedClassPointers, &quot;must be on to call this method&quot;);
<span class="line-modified">!   narrowKlass encoded_k = Klass::encode_klass(k);</span>
    load_const_32to64(t, encoded_k, false /*sign_extend*/);
  }
  
  //------------------------------------------------------
  //  Compare (patchable) constant with register.
<span class="line-new-header">--- 1172,11 ---</span>
  }
  
  // Load narrow klass constant, compression required.
  void MacroAssembler::load_narrow_klass(Register t, Klass* k) {
    assert(UseCompressedClassPointers, &quot;must be on to call this method&quot;);
<span class="line-modified">!   narrowKlass encoded_k = CompressedKlassPointers::encode(k);</span>
    load_const_32to64(t, encoded_k, false /*sign_extend*/);
  }
  
  //------------------------------------------------------
  //  Compare (patchable) constant with register.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1187,11 ***</span>
  }
  
  // Compare narrow oop in reg with narrow oop constant, no decompression.
  void MacroAssembler::compare_immediate_narrow_klass(Register klass1, Klass* klass2) {
    assert(UseCompressedClassPointers, &quot;must be on to call this method&quot;);
<span class="line-modified">!   narrowKlass encoded_k = Klass::encode_klass(klass2);</span>
  
    Assembler::z_clfi(klass1, encoded_k);
  }
  
  //----------------------------------------------------------
<span class="line-new-header">--- 1190,11 ---</span>
  }
  
  // Compare narrow oop in reg with narrow oop constant, no decompression.
  void MacroAssembler::compare_immediate_narrow_klass(Register klass1, Klass* klass2) {
    assert(UseCompressedClassPointers, &quot;must be on to call this method&quot;);
<span class="line-modified">!   narrowKlass encoded_k = CompressedKlassPointers::encode(klass2);</span>
  
    Assembler::z_clfi(klass1, encoded_k);
  }
  
  //----------------------------------------------------------
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1283,11 ***</span>
  // Patching the immediate value of CPU version dependent load_narrow_klass sequence.
  // The passed ptr must NOT be in compressed format!
  int MacroAssembler::patch_load_narrow_klass(address pos, Klass* k) {
    assert(UseCompressedClassPointers, &quot;Can only patch compressed klass pointers&quot;);
  
<span class="line-modified">!   narrowKlass nk = Klass::encode_klass(k);</span>
    return patch_load_const_32to64(pos, nk);
  }
  
  // Patching the immediate value of CPU version dependent compare_immediate_narrow_oop sequence.
  // The passed ptr must NOT be in compressed format!
<span class="line-new-header">--- 1286,11 ---</span>
  // Patching the immediate value of CPU version dependent load_narrow_klass sequence.
  // The passed ptr must NOT be in compressed format!
  int MacroAssembler::patch_load_narrow_klass(address pos, Klass* k) {
    assert(UseCompressedClassPointers, &quot;Can only patch compressed klass pointers&quot;);
  
<span class="line-modified">!   narrowKlass nk = CompressedKlassPointers::encode(k);</span>
    return patch_load_const_32to64(pos, nk);
  }
  
  // Patching the immediate value of CPU version dependent compare_immediate_narrow_oop sequence.
  // The passed ptr must NOT be in compressed format!
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1301,11 ***</span>
  // Patching the immediate value of CPU version dependent compare_immediate_narrow_klass sequence.
  // The passed ptr must NOT be in compressed format!
  int MacroAssembler::patch_compare_immediate_narrow_klass(address pos, Klass* k) {
    assert(UseCompressedClassPointers, &quot;Can only patch compressed klass pointers&quot;);
  
<span class="line-modified">!   narrowKlass nk = Klass::encode_klass(k);</span>
    return patch_compare_immediate_32(pos, nk);
  }
  
  //------------------------------------------------------------------------
  //  Extract the constant from a load_constant instruction stream.
<span class="line-new-header">--- 1304,11 ---</span>
  // Patching the immediate value of CPU version dependent compare_immediate_narrow_klass sequence.
  // The passed ptr must NOT be in compressed format!
  int MacroAssembler::patch_compare_immediate_narrow_klass(address pos, Klass* k) {
    assert(UseCompressedClassPointers, &quot;Can only patch compressed klass pointers&quot;);
  
<span class="line-modified">!   narrowKlass nk = CompressedKlassPointers::encode(k);</span>
    return patch_compare_immediate_32(pos, nk);
  }
  
  //------------------------------------------------------------------------
  //  Extract the constant from a load_constant instruction stream.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2923,11 ***</span>
    BLOCK_COMMENT(&quot;} IC miss handler&quot;);
    return labelOffset;
  }
  
  void MacroAssembler::nmethod_UEP(Label&amp; ic_miss) {
<span class="line-modified">!   Register ic_reg       = as_Register(Matcher::inline_cache_reg_encode());</span>
    int      klass_offset = oopDesc::klass_offset_in_bytes();
    if (!ImplicitNullChecks || MacroAssembler::needs_explicit_null_check(klass_offset)) {
      if (VM_Version::has_CompareBranch()) {
        z_cgij(Z_ARG1, 0, Assembler::bcondEqual, ic_miss);
      } else {
<span class="line-new-header">--- 2926,11 ---</span>
    BLOCK_COMMENT(&quot;} IC miss handler&quot;);
    return labelOffset;
  }
  
  void MacroAssembler::nmethod_UEP(Label&amp; ic_miss) {
<span class="line-modified">!   Register ic_reg       = Z_inline_cache;</span>
    int      klass_offset = oopDesc::klass_offset_in_bytes();
    if (!ImplicitNullChecks || MacroAssembler::needs_explicit_null_check(klass_offset)) {
      if (VM_Version::has_CompareBranch()) {
        z_cgij(Z_ARG1, 0, Assembler::bcondEqual, ic_miss);
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3128,10 ***</span>
<span class="line-new-header">--- 3131,37 ---</span>
                                  temp1_reg, temp2_reg, &amp;L_success, NULL);
    BIND(failure);
    BLOCK_COMMENT(&quot;} check_klass_subtype&quot;);
  }
  
<span class="line-added">+ void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {</span>
<span class="line-added">+   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   Label L_fallthrough;</span>
<span class="line-added">+   if (L_fast_path == NULL) {</span>
<span class="line-added">+     L_fast_path = &amp;L_fallthrough;</span>
<span class="line-added">+   } else if (L_slow_path == NULL) {</span>
<span class="line-added">+     L_slow_path = &amp;L_fallthrough;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Fast path check: class is fully initialized</span>
<span class="line-added">+   z_cli(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);</span>
<span class="line-added">+   z_bre(*L_fast_path);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Fast path check: current thread is initializer thread</span>
<span class="line-added">+   z_cg(thread, Address(klass, InstanceKlass::init_thread_offset()));</span>
<span class="line-added">+   if (L_slow_path == &amp;L_fallthrough) {</span>
<span class="line-added">+     z_bre(*L_fast_path);</span>
<span class="line-added">+   } else if (L_fast_path == &amp;L_fallthrough) {</span>
<span class="line-added">+     z_brne(*L_slow_path);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     Unimplemented();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bind(L_fallthrough);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Increment a counter at counter_address when the eq condition code is
  // set. Kills registers tmp1_reg and tmp2_reg and preserves the condition code.
  void MacroAssembler::increment_counter_eq(address counter_address, Register tmp1_reg, Register tmp2_reg) {
    Label l;
    z_brne(l);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3169,19 ***</span>
    // Biased locking
    // See whether the lock is currently biased toward our thread and
    // whether the epoch is still valid.
    // Note that the runtime guarantees sufficient alignment of JavaThread
    // pointers to allow age to be placed into low bits.
<span class="line-modified">!   assert(markOopDesc::age_shift == markOopDesc::lock_bits + markOopDesc::biased_lock_bits,</span>
           &quot;biased locking makes assumptions about bit layout&quot;);
    z_lr(temp_reg, mark_reg);
<span class="line-modified">!   z_nilf(temp_reg, markOopDesc::biased_lock_mask_in_place);</span>
<span class="line-modified">!   z_chi(temp_reg, markOopDesc::biased_lock_pattern);</span>
    z_brne(cas_label);  // Try cas if object is not biased, i.e. cannot be biased locked.
  
    load_prototype_header(temp_reg, obj_reg);
<span class="line-modified">!   load_const_optimized(temp2_reg, ~((int) markOopDesc::age_mask_in_place));</span>
  
    z_ogr(temp_reg, Z_thread);
    z_xgr(temp_reg, mark_reg);
    z_ngr(temp_reg, temp2_reg);
    if (PrintBiasedLockingStatistics) {
<span class="line-new-header">--- 3199,19 ---</span>
    // Biased locking
    // See whether the lock is currently biased toward our thread and
    // whether the epoch is still valid.
    // Note that the runtime guarantees sufficient alignment of JavaThread
    // pointers to allow age to be placed into low bits.
<span class="line-modified">!   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,</span>
           &quot;biased locking makes assumptions about bit layout&quot;);
    z_lr(temp_reg, mark_reg);
<span class="line-modified">!   z_nilf(temp_reg, markWord::biased_lock_mask_in_place);</span>
<span class="line-modified">!   z_chi(temp_reg, markWord::biased_lock_pattern);</span>
    z_brne(cas_label);  // Try cas if object is not biased, i.e. cannot be biased locked.
  
    load_prototype_header(temp_reg, obj_reg);
<span class="line-modified">!   load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));</span>
  
    z_ogr(temp_reg, Z_thread);
    z_xgr(temp_reg, mark_reg);
    z_ngr(temp_reg, temp2_reg);
    if (PrintBiasedLockingStatistics) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3203,11 ***</span>
    // header.
  
    // If the low three bits in the xor result aren&#39;t clear, that means
    // the prototype header is no longer biased and we have to revoke
    // the bias on this object.
<span class="line-modified">!   z_tmll(temp_reg, markOopDesc::biased_lock_mask_in_place);</span>
    z_brnaz(try_revoke_bias);
  
    // Biasing is still enabled for this data type. See whether the
    // epoch of the current bias is still valid, meaning that the epoch
    // bits of the mark word are equal to the epoch bits of the
<span class="line-new-header">--- 3233,11 ---</span>
    // header.
  
    // If the low three bits in the xor result aren&#39;t clear, that means
    // the prototype header is no longer biased and we have to revoke
    // the bias on this object.
<span class="line-modified">!   z_tmll(temp_reg, markWord::biased_lock_mask_in_place);</span>
    z_brnaz(try_revoke_bias);
  
    // Biasing is still enabled for this data type. See whether the
    // epoch of the current bias is still valid, meaning that the epoch
    // bits of the mark word are equal to the epoch bits of the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3215,22 ***</span>
    // only change at a safepoint.) If not, attempt to rebias the object
    // toward the current thread. Note that we must be absolutely sure
    // that the current epoch is invalid in order to do this because
    // otherwise the manipulations it performs on the mark word are
    // illegal.
<span class="line-modified">!   z_tmll(temp_reg, markOopDesc::epoch_mask_in_place);</span>
    z_brnaz(try_rebias);
  
    //----------------------------------------------------------------------------
    // The epoch of the current bias is still valid but we know nothing
    // about the owner; it might be set or it might be clear. Try to
    // acquire the bias of the object using an atomic operation. If this
    // fails we will go in to the runtime to revoke the object&#39;s bias.
    // Note that we first construct the presumed unbiased header so we
    // don&#39;t accidentally blow away another thread&#39;s valid bias.
<span class="line-modified">!   z_nilf(mark_reg, markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place |</span>
<span class="line-modified">!          markOopDesc::epoch_mask_in_place);</span>
    z_lgr(temp_reg, Z_thread);
    z_llgfr(mark_reg, mark_reg);
    z_ogr(temp_reg, mark_reg);
  
    assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
<span class="line-new-header">--- 3245,22 ---</span>
    // only change at a safepoint.) If not, attempt to rebias the object
    // toward the current thread. Note that we must be absolutely sure
    // that the current epoch is invalid in order to do this because
    // otherwise the manipulations it performs on the mark word are
    // illegal.
<span class="line-modified">!   z_tmll(temp_reg, markWord::epoch_mask_in_place);</span>
    z_brnaz(try_rebias);
  
    //----------------------------------------------------------------------------
    // The epoch of the current bias is still valid but we know nothing
    // about the owner; it might be set or it might be clear. Try to
    // acquire the bias of the object using an atomic operation. If this
    // fails we will go in to the runtime to revoke the object&#39;s bias.
    // Note that we first construct the presumed unbiased header so we
    // don&#39;t accidentally blow away another thread&#39;s valid bias.
<span class="line-modified">!   z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place |</span>
<span class="line-modified">!          markWord::epoch_mask_in_place);</span>
    z_lgr(temp_reg, Z_thread);
    z_llgfr(mark_reg, mark_reg);
    z_ogr(temp_reg, mark_reg);
  
    assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3258,11 ***</span>
    // circumstances _only_, we are allowed to use the current header&#39;s
    // value as the comparison value when doing the cas to acquire the
    // bias in the current epoch. In other words, we allow transfer of
    // the bias from one thread to another directly in this situation.
  
<span class="line-modified">!   z_nilf(mark_reg, markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place);</span>
    load_prototype_header(temp_reg, obj_reg);
    z_llgfr(mark_reg, mark_reg);
  
    z_ogr(temp_reg, Z_thread);
  
<span class="line-new-header">--- 3288,11 ---</span>
    // circumstances _only_, we are allowed to use the current header&#39;s
    // value as the comparison value when doing the cas to acquire the
    // bias in the current epoch. In other words, we allow transfer of
    // the bias from one thread to another directly in this situation.
  
<span class="line-modified">!   z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);</span>
    load_prototype_header(temp_reg, obj_reg);
    z_llgfr(mark_reg, mark_reg);
  
    z_ogr(temp_reg, Z_thread);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3319,13 ***</span>
    // lock, the object could not be rebiased toward another thread, so
    // the bias bit would be clear.
    BLOCK_COMMENT(&quot;biased_locking_exit {&quot;);
  
    z_lg(temp_reg, 0, mark_addr);
<span class="line-modified">!   z_nilf(temp_reg, markOopDesc::biased_lock_mask_in_place);</span>
  
<span class="line-modified">!   z_chi(temp_reg, markOopDesc::biased_lock_pattern);</span>
    z_bre(done);
    BLOCK_COMMENT(&quot;} biased_locking_exit&quot;);
  }
  
  void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {
<span class="line-new-header">--- 3349,13 ---</span>
    // lock, the object could not be rebiased toward another thread, so
    // the bias bit would be clear.
    BLOCK_COMMENT(&quot;biased_locking_exit {&quot;);
  
    z_lg(temp_reg, 0, mark_addr);
<span class="line-modified">!   z_nilf(temp_reg, markWord::biased_lock_mask_in_place);</span>
  
<span class="line-modified">!   z_chi(temp_reg, markWord::biased_lock_pattern);</span>
    z_bre(done);
    BLOCK_COMMENT(&quot;} biased_locking_exit&quot;);
  }
  
  void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3334,55 ***</span>
    Register temp = temp2;
    NearLabel done, object_has_monitor;
  
    BLOCK_COMMENT(&quot;compiler_fast_lock_object {&quot;);
  
<span class="line-modified">!   // Load markOop from oop into mark.</span>
    z_lg(displacedHeader, 0, oop);
  
    if (try_bias) {
      biased_locking_enter(oop, displacedHeader, temp, Z_R0, done);
    }
  
    // Handle existing monitor.
    // The object has an existing monitor iff (mark &amp; monitor_value) != 0.
<span class="line-modified">!   guarantee(Immediate::is_uimm16(markOopDesc::monitor_value), &quot;must be half-word&quot;);</span>
    z_lr(temp, displacedHeader);
<span class="line-modified">!   z_nill(temp, markOopDesc::monitor_value);</span>
    z_brne(object_has_monitor);
  
<span class="line-modified">!   // Set mark to markOop | markOopDesc::unlocked_value.</span>
<span class="line-modified">!   z_oill(displacedHeader, markOopDesc::unlocked_value);</span>
  
    // Load Compare Value application register.
  
    // Initialize the box (must happen before we update the object mark).
    z_stg(displacedHeader, BasicLock::displaced_header_offset_in_bytes(), box);
  
    // Memory Fence (in cmpxchgd)
<span class="line-modified">!   // Compare object markOop with mark and if equal exchange scratch1 with object markOop.</span>
  
    // If the compare-and-swap succeeded, then we found an unlocked object and we
    // have now locked it.
    z_csg(displacedHeader, box, 0, oop);
    assert(currentHeader==displacedHeader, &quot;must be same register&quot;); // Identified two registers from z/Architecture.
    z_bre(done);
  
    // We did not see an unlocked object so try the fast recursive case.
  
    z_sgr(currentHeader, Z_SP);
<span class="line-modified">!   load_const_optimized(temp, (~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place));</span>
  
    z_ngr(currentHeader, temp);
    //   z_brne(done);
    //   z_release();
    z_stg(currentHeader/*==0 or not 0*/, BasicLock::displaced_header_offset_in_bytes(), box);
  
    z_bru(done);
  
    Register zero = temp;
<span class="line-modified">!   Register monitor_tagged = displacedHeader; // Tagged with markOopDesc::monitor_value.</span>
    bind(object_has_monitor);
    // The object&#39;s monitor m is unlocked iff m-&gt;owner == NULL,
    // otherwise m-&gt;owner may contain a thread or a stack address.
    //
    // Try to CAS m-&gt;owner from NULL to current thread.
<span class="line-new-header">--- 3364,55 ---</span>
    Register temp = temp2;
    NearLabel done, object_has_monitor;
  
    BLOCK_COMMENT(&quot;compiler_fast_lock_object {&quot;);
  
<span class="line-modified">!   // Load markWord from oop into mark.</span>
    z_lg(displacedHeader, 0, oop);
  
    if (try_bias) {
      biased_locking_enter(oop, displacedHeader, temp, Z_R0, done);
    }
  
    // Handle existing monitor.
    // The object has an existing monitor iff (mark &amp; monitor_value) != 0.
<span class="line-modified">!   guarantee(Immediate::is_uimm16(markWord::monitor_value), &quot;must be half-word&quot;);</span>
    z_lr(temp, displacedHeader);
<span class="line-modified">!   z_nill(temp, markWord::monitor_value);</span>
    z_brne(object_has_monitor);
  
<span class="line-modified">!   // Set mark to markWord | markWord::unlocked_value.</span>
<span class="line-modified">!   z_oill(displacedHeader, markWord::unlocked_value);</span>
  
    // Load Compare Value application register.
  
    // Initialize the box (must happen before we update the object mark).
    z_stg(displacedHeader, BasicLock::displaced_header_offset_in_bytes(), box);
  
    // Memory Fence (in cmpxchgd)
<span class="line-modified">!   // Compare object markWord with mark and if equal exchange scratch1 with object markWord.</span>
  
    // If the compare-and-swap succeeded, then we found an unlocked object and we
    // have now locked it.
    z_csg(displacedHeader, box, 0, oop);
    assert(currentHeader==displacedHeader, &quot;must be same register&quot;); // Identified two registers from z/Architecture.
    z_bre(done);
  
    // We did not see an unlocked object so try the fast recursive case.
  
    z_sgr(currentHeader, Z_SP);
<span class="line-modified">!   load_const_optimized(temp, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));</span>
  
    z_ngr(currentHeader, temp);
    //   z_brne(done);
    //   z_release();
    z_stg(currentHeader/*==0 or not 0*/, BasicLock::displaced_header_offset_in_bytes(), box);
  
    z_bru(done);
  
    Register zero = temp;
<span class="line-modified">!   Register monitor_tagged = displacedHeader; // Tagged with markWord::monitor_value.</span>
    bind(object_has_monitor);
    // The object&#39;s monitor m is unlocked iff m-&gt;owner == NULL,
    // otherwise m-&gt;owner may contain a thread or a stack address.
    //
    // Try to CAS m-&gt;owner from NULL to current thread.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3427,16 ***</span>
    z_bre(done);
  
    // Handle existing monitor.
    // The object has an existing monitor iff (mark &amp; monitor_value) != 0.
    z_lg(currentHeader, oopDesc::mark_offset_in_bytes(), oop);
<span class="line-modified">!   guarantee(Immediate::is_uimm16(markOopDesc::monitor_value), &quot;must be half-word&quot;);</span>
<span class="line-modified">!   z_nill(currentHeader, markOopDesc::monitor_value);</span>
    z_brne(object_has_monitor);
  
    // Check if it is still a light weight lock, this is true if we see
<span class="line-modified">!   // the stack address of the basicLock in the markOop of the object</span>
    // copy box to currentHeader such that csg does not kill it.
    z_lgr(currentHeader, box);
    z_csg(currentHeader, displacedHeader, 0, oop);
    z_bru(done); // Csg sets CR as desired.
  
<span class="line-new-header">--- 3457,16 ---</span>
    z_bre(done);
  
    // Handle existing monitor.
    // The object has an existing monitor iff (mark &amp; monitor_value) != 0.
    z_lg(currentHeader, oopDesc::mark_offset_in_bytes(), oop);
<span class="line-modified">!   guarantee(Immediate::is_uimm16(markWord::monitor_value), &quot;must be half-word&quot;);</span>
<span class="line-modified">!   z_nill(currentHeader, markWord::monitor_value);</span>
    z_brne(object_has_monitor);
  
    // Check if it is still a light weight lock, this is true if we see
<span class="line-modified">!   // the stack address of the basicLock in the markWord of the object</span>
    // copy box to currentHeader such that csg does not kill it.
    z_lgr(currentHeader, box);
    z_csg(currentHeader, displacedHeader, 0, oop);
    z_bru(done); // Csg sets CR as desired.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3556,11 ***</span>
    verify_thread();
  
    z_lg(oop_result, Address(Z_thread, JavaThread::vm_result_offset()));
    clear_mem(Address(Z_thread, JavaThread::vm_result_offset()), sizeof(void*));
  
<span class="line-modified">!   verify_oop(oop_result);</span>
  }
  
  void MacroAssembler::get_vm_result_2(Register result) {
    verify_thread();
  
<span class="line-new-header">--- 3586,11 ---</span>
    verify_thread();
  
    z_lg(oop_result, Address(Z_thread, JavaThread::vm_result_offset()));
    clear_mem(Address(Z_thread, JavaThread::vm_result_offset()), sizeof(void*));
  
<span class="line-modified">!   verify_oop(oop_result, FILE_AND_LINE);</span>
  }
  
  void MacroAssembler::get_vm_result_2(Register result) {
    verify_thread();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3604,12 ***</span>
  //-------------------------------------
  
  // Klass oop manipulations if compressed.
  void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
    Register current = (src != noreg) ? src : dst; // Klass is in dst if no src provided. (dst == src) also possible.
<span class="line-modified">!   address  base    = Universe::narrow_klass_base();</span>
<span class="line-modified">!   int      shift   = Universe::narrow_klass_shift();</span>
    assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
  
    BLOCK_COMMENT(&quot;cKlass encoder {&quot;);
  
  #ifdef ASSERT
<span class="line-new-header">--- 3634,12 ---</span>
  //-------------------------------------
  
  // Klass oop manipulations if compressed.
  void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
    Register current = (src != noreg) ? src : dst; // Klass is in dst if no src provided. (dst == src) also possible.
<span class="line-modified">!   address  base    = CompressedKlassPointers::base();</span>
<span class="line-modified">!   int      shift   = CompressedKlassPointers::shift();</span>
    assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
  
    BLOCK_COMMENT(&quot;cKlass encoder {&quot;);
  
  #ifdef ASSERT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3653,12 ***</span>
  // This function calculates the size of the code generated by
  //   decode_klass_not_null(register dst, Register src)
  // when (Universe::heap() != NULL). Hence, if the instructions
  // it generates change, then this method needs to be updated.
  int MacroAssembler::instr_size_for_decode_klass_not_null() {
<span class="line-modified">!   address  base    = Universe::narrow_klass_base();</span>
<span class="line-modified">!   int shift_size   = Universe::narrow_klass_shift() == 0 ? 0 : 6; /* sllg */</span>
    int addbase_size = 0;
    assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
  
    if (base != NULL) {
      unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
<span class="line-new-header">--- 3683,12 ---</span>
  // This function calculates the size of the code generated by
  //   decode_klass_not_null(register dst, Register src)
  // when (Universe::heap() != NULL). Hence, if the instructions
  // it generates change, then this method needs to be updated.
  int MacroAssembler::instr_size_for_decode_klass_not_null() {
<span class="line-modified">!   address  base    = CompressedKlassPointers::base();</span>
<span class="line-modified">!   int shift_size   = CompressedKlassPointers::shift() == 0 ? 0 : 6; /* sllg */</span>
    int addbase_size = 0;
    assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
  
    if (base != NULL) {
      unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3683,12 ***</span>
  //     then function instr_size_for_decode_klass_not_null()
  //     needs to get updated.
  // This variant of decode_klass_not_null() must generate predictable code!
  // The code must only depend on globally known parameters.
  void MacroAssembler::decode_klass_not_null(Register dst) {
<span class="line-modified">!   address  base    = Universe::narrow_klass_base();</span>
<span class="line-modified">!   int      shift   = Universe::narrow_klass_shift();</span>
    int      beg_off = offset();
    assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
  
    BLOCK_COMMENT(&quot;cKlass decoder (const size) {&quot;);
  
<span class="line-new-header">--- 3713,12 ---</span>
  //     then function instr_size_for_decode_klass_not_null()
  //     needs to get updated.
  // This variant of decode_klass_not_null() must generate predictable code!
  // The code must only depend on globally known parameters.
  void MacroAssembler::decode_klass_not_null(Register dst) {
<span class="line-modified">!   address  base    = CompressedKlassPointers::base();</span>
<span class="line-modified">!   int      shift   = CompressedKlassPointers::shift();</span>
    int      beg_off = offset();
    assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
  
    BLOCK_COMMENT(&quot;cKlass decoder (const size) {&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3726,12 ***</span>
  
  // This variant of decode_klass_not_null() is for cases where
  //  1) the size of the generated instructions may vary
  //  2) the result is (potentially) stored in a register different from the source.
  void MacroAssembler::decode_klass_not_null(Register dst, Register src) {
<span class="line-modified">!   address base  = Universe::narrow_klass_base();</span>
<span class="line-modified">!   int     shift = Universe::narrow_klass_shift();</span>
    assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
  
    BLOCK_COMMENT(&quot;cKlass decoder {&quot;);
  
    if (src == noreg) src = dst;
<span class="line-new-header">--- 3756,12 ---</span>
  
  // This variant of decode_klass_not_null() is for cases where
  //  1) the size of the generated instructions may vary
  //  2) the result is (potentially) stored in a register different from the source.
  void MacroAssembler::decode_klass_not_null(Register dst, Register src) {
<span class="line-modified">!   address base  = CompressedKlassPointers::base();</span>
<span class="line-modified">!   int     shift = CompressedKlassPointers::shift();</span>
    assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
  
    BLOCK_COMMENT(&quot;cKlass decoder {&quot;);
  
    if (src == noreg) src = dst;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3827,12 ***</span>
  void MacroAssembler::compare_klass_ptr(Register Rop1, int64_t disp, Register Rbase, bool maybeNULL) {
  
    BLOCK_COMMENT(&quot;compare klass ptr {&quot;);
  
    if (UseCompressedClassPointers) {
<span class="line-modified">!     const int shift = Universe::narrow_klass_shift();</span>
<span class="line-modified">!     address   base  = Universe::narrow_klass_base();</span>
  
      assert((shift == 0) || (shift == LogKlassAlignmentInBytes), &quot;cKlass encoder detected bad shift&quot;);
      assert_different_registers(Rop1, Z_R0);
      assert_different_registers(Rop1, Rbase, Z_R1);
  
<span class="line-new-header">--- 3857,12 ---</span>
  void MacroAssembler::compare_klass_ptr(Register Rop1, int64_t disp, Register Rbase, bool maybeNULL) {
  
    BLOCK_COMMENT(&quot;compare klass ptr {&quot;);
  
    if (UseCompressedClassPointers) {
<span class="line-modified">!     const int shift = CompressedKlassPointers::shift();</span>
<span class="line-modified">!     address   base  = CompressedKlassPointers::base();</span>
  
      assert((shift == 0) || (shift == LogKlassAlignmentInBytes), &quot;cKlass encoder detected bad shift&quot;);
      assert_different_registers(Rop1, Z_R0);
      assert_different_registers(Rop1, Rbase, Z_R1);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3961,12 ***</span>
  void MacroAssembler::compare_heap_oop(Register Rop1, Address mem, bool maybeNULL) {
    Register Rbase  = mem.baseOrR0();
    Register Rindex = mem.indexOrR0();
    int64_t  disp   = mem.disp();
  
<span class="line-modified">!   const int shift = Universe::narrow_oop_shift();</span>
<span class="line-modified">!   address   base  = Universe::narrow_oop_base();</span>
  
    assert(UseCompressedOops, &quot;must be on to call this method&quot;);
    assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this method&quot;);
    assert((shift == 0) || (shift == LogMinObjAlignmentInBytes), &quot;cOop encoder detected bad shift&quot;);
    assert_different_registers(Rop1, Z_R0);
<span class="line-new-header">--- 3991,12 ---</span>
  void MacroAssembler::compare_heap_oop(Register Rop1, Address mem, bool maybeNULL) {
    Register Rbase  = mem.baseOrR0();
    Register Rindex = mem.indexOrR0();
    int64_t  disp   = mem.disp();
  
<span class="line-modified">!   const int shift = CompressedOops::shift();</span>
<span class="line-modified">!   address   base  = CompressedOops::base();</span>
  
    assert(UseCompressedOops, &quot;must be on to call this method&quot;);
    assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this method&quot;);
    assert((shift == 0) || (shift == LogMinObjAlignmentInBytes), &quot;cOop encoder detected bad shift&quot;);
    assert_different_registers(Rop1, Z_R0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4073,13 ***</span>
  // only32bitValid is set, if later code only uses the lower 32 bits. In this
  // case we must not fix the upper 32 bits.
  void MacroAssembler::oop_encoder(Register Rdst, Register Rsrc, bool maybeNULL,
                                   Register Rbase, int pow2_offset, bool only32bitValid) {
  
<span class="line-modified">!   const address oop_base  = Universe::narrow_oop_base();</span>
<span class="line-modified">!   const int     oop_shift = Universe::narrow_oop_shift();</span>
<span class="line-modified">!   const bool    disjoint  = Universe::narrow_oop_base_disjoint();</span>
  
    assert(UseCompressedOops, &quot;must be on to call this method&quot;);
    assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this encoder&quot;);
    assert((oop_shift == 0) || (oop_shift == LogMinObjAlignmentInBytes), &quot;cOop encoder detected bad shift&quot;);
  
<span class="line-new-header">--- 4103,13 ---</span>
  // only32bitValid is set, if later code only uses the lower 32 bits. In this
  // case we must not fix the upper 32 bits.
  void MacroAssembler::oop_encoder(Register Rdst, Register Rsrc, bool maybeNULL,
                                   Register Rbase, int pow2_offset, bool only32bitValid) {
  
<span class="line-modified">!   const address oop_base  = CompressedOops::base();</span>
<span class="line-modified">!   const int     oop_shift = CompressedOops::shift();</span>
<span class="line-modified">!   const bool    disjoint  = CompressedOops::base_disjoint();</span>
  
    assert(UseCompressedOops, &quot;must be on to call this method&quot;);
    assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this encoder&quot;);
    assert((oop_shift == 0) || (oop_shift == LogMinObjAlignmentInBytes), &quot;cOop encoder detected bad shift&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4208,13 ***</span>
  //  - avoid Z_R0 for any of the argument registers.
  //  - keep Rdst and Rsrc distinct from Rbase. Rdst == Rsrc is ok for performance.
  //  - avoid Z_R1 for Rdst if Rdst == Rbase.
  void MacroAssembler::oop_decoder(Register Rdst, Register Rsrc, bool maybeNULL, Register Rbase, int pow2_offset) {
  
<span class="line-modified">!   const address oop_base  = Universe::narrow_oop_base();</span>
<span class="line-modified">!   const int     oop_shift = Universe::narrow_oop_shift();</span>
<span class="line-modified">!   const bool    disjoint  = Universe::narrow_oop_base_disjoint();</span>
  
    assert(UseCompressedOops, &quot;must be on to call this method&quot;);
    assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this decoder&quot;);
    assert((oop_shift == 0) || (oop_shift == LogMinObjAlignmentInBytes),
           &quot;cOop encoder detected bad shift&quot;);
<span class="line-new-header">--- 4238,13 ---</span>
  //  - avoid Z_R0 for any of the argument registers.
  //  - keep Rdst and Rsrc distinct from Rbase. Rdst == Rsrc is ok for performance.
  //  - avoid Z_R1 for Rdst if Rdst == Rbase.
  void MacroAssembler::oop_decoder(Register Rdst, Register Rsrc, bool maybeNULL, Register Rbase, int pow2_offset) {
  
<span class="line-modified">!   const address oop_base  = CompressedOops::base();</span>
<span class="line-modified">!   const int     oop_shift = CompressedOops::shift();</span>
<span class="line-modified">!   const bool    disjoint  = CompressedOops::base_disjoint();</span>
  
    assert(UseCompressedOops, &quot;must be on to call this method&quot;);
    assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this decoder&quot;);
    assert((oop_shift == 0) || (oop_shift == LogMinObjAlignmentInBytes),
           &quot;cOop encoder detected bad shift&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4337,73 ***</span>
  void MacroAssembler::resolve_oop_handle(Register result) {
    // OopHandle::resolve is an indirection.
    z_lg(result, 0, result);
  }
  
<span class="line-modified">! void MacroAssembler::load_mirror(Register mirror, Register method) {</span>
<span class="line-modified">!   mem2reg_opt(mirror, Address(method, Method::const_offset()));</span>
<span class="line-removed">-   mem2reg_opt(mirror, Address(mirror, ConstMethod::constants_offset()));</span>
    mem2reg_opt(mirror, Address(mirror, ConstantPool::pool_holder_offset_in_bytes()));
    mem2reg_opt(mirror, Address(mirror, Klass::java_mirror_offset()));
    resolve_oop_handle(mirror);
  }
  
  //---------------------------------------------------------------
  //---  Operations on arrays.
  //---------------------------------------------------------------
  
  // Compiler ensures base is doubleword aligned and cnt is #doublewords.
  // Emitter does not KILL cnt and base arguments, since they need to be copied to
  // work registers anyway.
  // Actually, only r0, r1, and r5 are killed.
<span class="line-modified">! unsigned int MacroAssembler::Clear_Array(Register cnt_arg, Register base_pointer_arg, Register src_addr, Register src_len) {</span>
<span class="line-removed">-   // Src_addr is evenReg.</span>
<span class="line-removed">-   // Src_len is odd_Reg.</span>
  
    int      block_start = offset();
<span class="line-removed">-   Register tmp_reg  = src_len; // Holds target instr addr for EX.</span>
    Register dst_len  = Z_R1;    // Holds dst len  for MVCLE.
    Register dst_addr = Z_R0;    // Holds dst addr for MVCLE.
  
    Label doXC, doMVCLE, done;
  
    BLOCK_COMMENT(&quot;Clear_Array {&quot;);
  
    // Check for zero len and convert to long.
<span class="line-modified">!   z_ltgfr(src_len, cnt_arg);      // Remember casted value for doSTG case.</span>
    z_bre(done);                    // Nothing to do if len == 0.
  
    // Prefetch data to be cleared.
    if (VM_Version::has_Prefetch()) {
      z_pfd(0x02,   0, Z_R0, base_pointer_arg);
      z_pfd(0x02, 256, Z_R0, base_pointer_arg);
    }
  
<span class="line-modified">!   z_sllg(dst_len, src_len, 3);    // #bytes to clear.</span>
<span class="line-modified">!   z_cghi(src_len, 32);            // Check for len &lt;= 256 bytes (&lt;=32 DW).</span>
<span class="line-modified">!   z_brnh(doXC);                   // If so, use executed XC to clear.</span>
  
    // MVCLE: initialize long arrays (general case).
    bind(doMVCLE);
    z_lgr(dst_addr, base_pointer_arg);
<span class="line-modified">!   clear_reg(src_len, true, false); // Src len of MVCLE is zero.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   MacroAssembler::move_long_ext(dst_addr, src_addr, 0);</span>
    z_bru(done);
  
    // XC: initialize short arrays.
    Label XC_template; // Instr template, never exec directly!
      bind(XC_template);
      z_xc(0,0,base_pointer_arg,0,base_pointer_arg);
  
    bind(doXC);
<span class="line-modified">!     add2reg(dst_len, -1);             // Get #bytes-1 for EXECUTE.</span>
      if (VM_Version::has_ExecuteExtensions()) {
<span class="line-modified">!       z_exrl(dst_len, XC_template);   // Execute XC with var. len.</span>
      } else {
<span class="line-modified">!       z_larl(tmp_reg, XC_template);</span>
<span class="line-modified">!       z_ex(dst_len,0,Z_R0,tmp_reg);   // Execute XC with var. len.</span>
      }
      // z_bru(done);      // fallthru
  
    bind(done);
  
<span class="line-new-header">--- 4367,76 ---</span>
  void MacroAssembler::resolve_oop_handle(Register result) {
    // OopHandle::resolve is an indirection.
    z_lg(result, 0, result);
  }
  
<span class="line-modified">! void MacroAssembler::load_mirror_from_const_method(Register mirror, Register const_method) {</span>
<span class="line-modified">!   mem2reg_opt(mirror, Address(const_method, ConstMethod::constants_offset()));</span>
    mem2reg_opt(mirror, Address(mirror, ConstantPool::pool_holder_offset_in_bytes()));
    mem2reg_opt(mirror, Address(mirror, Klass::java_mirror_offset()));
    resolve_oop_handle(mirror);
  }
  
<span class="line-added">+ void MacroAssembler::load_method_holder(Register holder, Register method) {</span>
<span class="line-added">+   mem2reg_opt(holder, Address(method, Method::const_offset()));</span>
<span class="line-added">+   mem2reg_opt(holder, Address(holder, ConstMethod::constants_offset()));</span>
<span class="line-added">+   mem2reg_opt(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  //---------------------------------------------------------------
  //---  Operations on arrays.
  //---------------------------------------------------------------
  
  // Compiler ensures base is doubleword aligned and cnt is #doublewords.
  // Emitter does not KILL cnt and base arguments, since they need to be copied to
  // work registers anyway.
  // Actually, only r0, r1, and r5 are killed.
<span class="line-modified">! unsigned int MacroAssembler::Clear_Array(Register cnt_arg, Register base_pointer_arg, Register odd_tmp_reg) {</span>
  
    int      block_start = offset();
    Register dst_len  = Z_R1;    // Holds dst len  for MVCLE.
    Register dst_addr = Z_R0;    // Holds dst addr for MVCLE.
  
    Label doXC, doMVCLE, done;
  
    BLOCK_COMMENT(&quot;Clear_Array {&quot;);
  
    // Check for zero len and convert to long.
<span class="line-modified">!   z_ltgfr(odd_tmp_reg, cnt_arg);</span>
    z_bre(done);                    // Nothing to do if len == 0.
  
    // Prefetch data to be cleared.
    if (VM_Version::has_Prefetch()) {
      z_pfd(0x02,   0, Z_R0, base_pointer_arg);
      z_pfd(0x02, 256, Z_R0, base_pointer_arg);
    }
  
<span class="line-modified">!   z_sllg(dst_len, odd_tmp_reg, 3); // #bytes to clear.</span>
<span class="line-modified">!   z_cghi(odd_tmp_reg, 32);         // Check for len &lt;= 256 bytes (&lt;=32 DW).</span>
<span class="line-modified">!   z_brnh(doXC);                    // If so, use executed XC to clear.</span>
  
    // MVCLE: initialize long arrays (general case).
    bind(doMVCLE);
    z_lgr(dst_addr, base_pointer_arg);
<span class="line-modified">!   // Pass 0 as source length to MVCLE: destination will be filled with padding byte 0.</span>
<span class="line-modified">!   // The even register of the register pair is not killed.</span>
<span class="line-modified">!   clear_reg(odd_tmp_reg, true, false);</span>
<span class="line-added">+   MacroAssembler::move_long_ext(dst_addr, as_Register(odd_tmp_reg-&gt;encoding()-1), 0);</span>
    z_bru(done);
  
    // XC: initialize short arrays.
    Label XC_template; // Instr template, never exec directly!
      bind(XC_template);
      z_xc(0,0,base_pointer_arg,0,base_pointer_arg);
  
    bind(doXC);
<span class="line-modified">!     add2reg(dst_len, -1);               // Get #bytes-1 for EXECUTE.</span>
      if (VM_Version::has_ExecuteExtensions()) {
<span class="line-modified">!       z_exrl(dst_len, XC_template);     // Execute XC with var. len.</span>
      } else {
<span class="line-modified">!       z_larl(odd_tmp_reg, XC_template);</span>
<span class="line-modified">!       z_ex(dst_len,0,Z_R0,odd_tmp_reg); // Execute XC with var. len.</span>
      }
      // z_bru(done);      // fallthru
  
    bind(done);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4461,21 ***</span>
  }
  
  // Compiler ensures base is doubleword aligned and cnt is #doublewords.
  // Emitter does not KILL cnt and base arguments, since they need to be copied to
  // work registers anyway.
<span class="line-modified">! // Actually, only r0, r1, r4, and r5 (which are work registers) are killed.</span>
  //
  // For very large arrays, exploit MVCLE H/W support.
  // MVCLE instruction automatically exploits H/W-optimized page mover.
  // - Bytes up to next page boundary are cleared with a series of XC to self.
  // - All full pages are cleared with the page mover H/W assist.
  // - Remaining bytes are again cleared by a series of XC to self.
  //
<span class="line-modified">! unsigned int MacroAssembler::Clear_Array_Const_Big(long cnt, Register base_pointer_arg, Register src_addr, Register src_len) {</span>
<span class="line-removed">-   // Src_addr is evenReg.</span>
<span class="line-removed">-   // Src_len is odd_Reg.</span>
  
    int      block_start = offset();
    Register dst_len  = Z_R1;      // Holds dst len  for MVCLE.
    Register dst_addr = Z_R0;      // Holds dst addr for MVCLE.
  
<span class="line-new-header">--- 4494,19 ---</span>
  }
  
  // Compiler ensures base is doubleword aligned and cnt is #doublewords.
  // Emitter does not KILL cnt and base arguments, since they need to be copied to
  // work registers anyway.
<span class="line-modified">! // Actually, only r0, r1, (which are work registers) and odd_tmp_reg are killed.</span>
  //
  // For very large arrays, exploit MVCLE H/W support.
  // MVCLE instruction automatically exploits H/W-optimized page mover.
  // - Bytes up to next page boundary are cleared with a series of XC to self.
  // - All full pages are cleared with the page mover H/W assist.
  // - Remaining bytes are again cleared by a series of XC to self.
  //
<span class="line-modified">! unsigned int MacroAssembler::Clear_Array_Const_Big(long cnt, Register base_pointer_arg, Register odd_tmp_reg) {</span>
  
    int      block_start = offset();
    Register dst_len  = Z_R1;      // Holds dst len  for MVCLE.
    Register dst_addr = Z_R0;      // Holds dst addr for MVCLE.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4484,15 ***</span>
    // Get len to clear.
    load_const_optimized(dst_len, (long)cnt*8L);  // in Bytes = #DW*8
  
    // Prepare other args to MVCLE.
    z_lgr(dst_addr, base_pointer_arg);
<span class="line-modified">!   // Indicate unused result.</span>
<span class="line-modified">!   (void) clear_reg(src_len, true, false);  // Src len of MVCLE is zero.</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // Clear.</span>
<span class="line-removed">-   MacroAssembler::move_long_ext(dst_addr, src_addr, 0);</span>
    BLOCK_COMMENT(&quot;} Clear_Array_Const_Big&quot;);
  
    int block_end = offset();
    return block_end - block_start;
  }
<span class="line-new-header">--- 4515,14 ---</span>
    // Get len to clear.
    load_const_optimized(dst_len, (long)cnt*8L);  // in Bytes = #DW*8
  
    // Prepare other args to MVCLE.
    z_lgr(dst_addr, base_pointer_arg);
<span class="line-modified">!   // Pass 0 as source length to MVCLE: destination will be filled with padding byte 0.</span>
<span class="line-modified">!   // The even register of the register pair is not killed.</span>
<span class="line-modified">!   (void) clear_reg(odd_tmp_reg, true, false);  // Src len of MVCLE is zero.</span>
<span class="line-modified">!   MacroAssembler::move_long_ext(dst_addr, as_Register(odd_tmp_reg-&gt;encoding() - 1), 0);</span>
    BLOCK_COMMENT(&quot;} Clear_Array_Const_Big&quot;);
  
    int block_end = offset();
    return block_end - block_start;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4561,10 ***</span>
<span class="line-new-header">--- 4591,11 ---</span>
  
    int block_end = offset();
    return block_end - block_start;
  }
  
<span class="line-added">+ #ifdef COMPILER2</span>
  //------------------------------------------------------
  //   Special String Intrinsics. Implementation
  //------------------------------------------------------
  
  // Intrinsics for CompactStrings
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5808,11 ***</span>
    }
    BLOCK_COMMENT(&quot;} string_indexof_char&quot;);
  
    return offset() - block_start;
  }
<span class="line-modified">! </span>
  
  //-------------------------------------------------
  //   Constants (scalar and oop) in constant pool
  //-------------------------------------------------
  
<span class="line-new-header">--- 5839,11 ---</span>
    }
    BLOCK_COMMENT(&quot;} string_indexof_char&quot;);
  
    return offset() - block_start;
  }
<span class="line-modified">! #endif</span>
  
  //-------------------------------------------------
  //   Constants (scalar and oop) in constant pool
  //-------------------------------------------------
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5862,11 ***</span>
  bool MacroAssembler::load_const_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc) {
    int     tocOffset = store_const_in_toc(a);
    if (tocOffset == -1) return false;
    address tocPos    = tocOffset + code()-&gt;consts()-&gt;start();
    assert((address)code()-&gt;consts()-&gt;start() != NULL, &quot;Please add CP address&quot;);
<span class="line-modified">! </span>
    load_long_pcrelative(dst, tocPos);
    return true;
  }
  
  bool MacroAssembler::load_oop_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc) {
<span class="line-new-header">--- 5893,11 ---</span>
  bool MacroAssembler::load_const_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc) {
    int     tocOffset = store_const_in_toc(a);
    if (tocOffset == -1) return false;
    address tocPos    = tocOffset + code()-&gt;consts()-&gt;start();
    assert((address)code()-&gt;consts()-&gt;start() != NULL, &quot;Please add CP address&quot;);
<span class="line-modified">!   relocate(a.rspec());</span>
    load_long_pcrelative(dst, tocPos);
    return true;
  }
  
  bool MacroAssembler::load_oop_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6121,100 ***</span>
    bind(retry);
    Assembler::z_trtt(r1, r2, m3);
    Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::generate_type_profiling(const Register Rdata,</span>
<span class="line-removed">-                                              const Register Rreceiver_klass,</span>
<span class="line-removed">-                                              const Register Rwanted_receiver_klass,</span>
<span class="line-removed">-                                              const Register Rmatching_row,</span>
<span class="line-removed">-                                              bool is_virtual_call) {</span>
<span class="line-removed">-   const int row_size = in_bytes(ReceiverTypeData::receiver_offset(1)) -</span>
<span class="line-removed">-                        in_bytes(ReceiverTypeData::receiver_offset(0));</span>
<span class="line-removed">-   const int num_rows = ReceiverTypeData::row_limit();</span>
<span class="line-removed">-   NearLabel found_free_row;</span>
<span class="line-removed">-   NearLabel do_increment;</span>
<span class="line-removed">-   NearLabel found_no_slot;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   BLOCK_COMMENT(&quot;type profiling {&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // search for:</span>
<span class="line-removed">-   //    a) The type given in Rwanted_receiver_klass.</span>
<span class="line-removed">-   //    b) The *first* empty row.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // First search for a) only, just running over b) with no regard.</span>
<span class="line-removed">-   // This is possible because</span>
<span class="line-removed">-   //    wanted_receiver_class == receiver_class  &amp;&amp;  wanted_receiver_class == 0</span>
<span class="line-removed">-   // is never true (receiver_class can&#39;t be zero).</span>
<span class="line-removed">-   for (int row_num = 0; row_num &lt; num_rows; row_num++) {</span>
<span class="line-removed">-     // Row_offset should be a well-behaved positive number. The generated code relies</span>
<span class="line-removed">-     // on that wrt constant code size. Add2reg can handle all row_offset values, but</span>
<span class="line-removed">-     // will have to vary generated code size.</span>
<span class="line-removed">-     int row_offset = in_bytes(ReceiverTypeData::receiver_offset(row_num));</span>
<span class="line-removed">-     assert(Displacement::is_shortDisp(row_offset), &quot;Limitation of generated code&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Is Rwanted_receiver_klass in this row?</span>
<span class="line-removed">-     if (VM_Version::has_CompareBranch()) {</span>
<span class="line-removed">-       z_lg(Rwanted_receiver_klass, row_offset, Z_R0, Rdata);</span>
<span class="line-removed">-       // Rmatching_row = Rdata + row_offset;</span>
<span class="line-removed">-       add2reg(Rmatching_row, row_offset, Rdata);</span>
<span class="line-removed">-       // if (*row_recv == (intptr_t) receiver_klass) goto fill_existing_slot;</span>
<span class="line-removed">-       compare64_and_branch(Rwanted_receiver_klass, Rreceiver_klass, Assembler::bcondEqual, do_increment);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       add2reg(Rmatching_row, row_offset, Rdata);</span>
<span class="line-removed">-       z_cg(Rreceiver_klass, row_offset, Z_R0, Rdata);</span>
<span class="line-removed">-       z_bre(do_increment);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Now that we did not find a match, let&#39;s search for b).</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // We could save the first calculation of Rmatching_row if we woud search for a) in reverse order.</span>
<span class="line-removed">-   // We would then end up here with Rmatching_row containing the value for row_num == 0.</span>
<span class="line-removed">-   // We would not see much benefit, if any at all, because the CPU can schedule</span>
<span class="line-removed">-   // two instructions together with a branch anyway.</span>
<span class="line-removed">-   for (int row_num = 0; row_num &lt; num_rows; row_num++) {</span>
<span class="line-removed">-     int row_offset = in_bytes(ReceiverTypeData::receiver_offset(row_num));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Has this row a zero receiver_klass, i.e. is it empty?</span>
<span class="line-removed">-     if (VM_Version::has_CompareBranch()) {</span>
<span class="line-removed">-       z_lg(Rwanted_receiver_klass, row_offset, Z_R0, Rdata);</span>
<span class="line-removed">-       // Rmatching_row = Rdata + row_offset</span>
<span class="line-removed">-       add2reg(Rmatching_row, row_offset, Rdata);</span>
<span class="line-removed">-       // if (*row_recv == (intptr_t) 0) goto found_free_row</span>
<span class="line-removed">-       compare64_and_branch(Rwanted_receiver_klass, (intptr_t)0, Assembler::bcondEqual, found_free_row);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       add2reg(Rmatching_row, row_offset, Rdata);</span>
<span class="line-removed">-       load_and_test_long(Rwanted_receiver_klass, Address(Rdata, row_offset));</span>
<span class="line-removed">-       z_bre(found_free_row);  // zero -&gt; Found a free row.</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // No match, no empty row found.</span>
<span class="line-removed">-   // Increment total counter to indicate polymorphic case.</span>
<span class="line-removed">-   if (is_virtual_call) {</span>
<span class="line-removed">-     add2mem_64(Address(Rdata, CounterData::count_offset()), 1, Rmatching_row);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   z_bru(found_no_slot);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Here we found an empty row, but we have not found Rwanted_receiver_klass.</span>
<span class="line-removed">-   // Rmatching_row holds the address to the first empty row.</span>
<span class="line-removed">-   bind(found_free_row);</span>
<span class="line-removed">-   // Store receiver_klass into empty slot.</span>
<span class="line-removed">-   z_stg(Rreceiver_klass, 0, Z_R0, Rmatching_row);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Increment the counter of Rmatching_row.</span>
<span class="line-removed">-   bind(do_increment);</span>
<span class="line-removed">-   ByteSize counter_offset = ReceiverTypeData::receiver_count_offset(0) - ReceiverTypeData::receiver_offset(0);</span>
<span class="line-removed">-   add2mem_64(Address(Rmatching_row, counter_offset), 1, Rdata);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(found_no_slot);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   BLOCK_COMMENT(&quot;} type profiling&quot;);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //---------------------------------------
  // Helpers for Intrinsic Emitters
  //---------------------------------------
  
  /**
<span class="line-new-header">--- 6152,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6871,30 ***</span>
    if (VerifyThread) {
      unimplemented(&quot;&quot;, 117);
    }
  }
  
  // Plausibility check for oops.
  void MacroAssembler::verify_oop(Register oop, const char* msg) {
    if (!VerifyOops) return;
  
    BLOCK_COMMENT(&quot;verify_oop {&quot;);
<span class="line-modified">!   Register tmp = Z_R0;</span>
<span class="line-modified">!   unsigned int nbytes_save = 5*BytesPerWord;</span>
<span class="line-modified">!   address entry = StubRoutines::verify_oop_subroutine_entry_address();</span>
  
    save_return_pc();
<span class="line-modified">!   push_frame_abi160(nbytes_save);</span>
<span class="line-modified">!   z_stmg(Z_R1, Z_R5, frame::z_abi_160_size, Z_SP);</span>
  
<span class="line-modified">!   z_lgr(Z_ARG2, oop);</span>
<span class="line-modified">!   load_const(Z_ARG1, (address) msg);</span>
<span class="line-modified">!   load_const(Z_R1, entry);</span>
    z_lg(Z_R1, 0, Z_R1);
    call_c(Z_R1);
  
<span class="line-modified">!   z_lmg(Z_R1, Z_R5, frame::z_abi_160_size, Z_SP);</span>
    pop_frame();
    restore_return_pc();
  
    BLOCK_COMMENT(&quot;} verify_oop &quot;);
  }
<span class="line-new-header">--- 6812,98 ---</span>
    if (VerifyThread) {
      unimplemented(&quot;&quot;, 117);
    }
  }
  
<span class="line-added">+ // Save and restore functions: Exclude Z_R0.</span>
<span class="line-added">+ void MacroAssembler::save_volatile_regs(Register dst, int offset, bool include_fp, bool include_flags) {</span>
<span class="line-added">+   z_stmg(Z_R1, Z_R5, offset, dst); offset += 5 * BytesPerWord;</span>
<span class="line-added">+   if (include_fp) {</span>
<span class="line-added">+     z_std(Z_F0, Address(dst, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_std(Z_F1, Address(dst, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_std(Z_F2, Address(dst, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_std(Z_F3, Address(dst, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_std(Z_F4, Address(dst, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_std(Z_F5, Address(dst, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_std(Z_F6, Address(dst, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_std(Z_F7, Address(dst, offset)); offset += BytesPerWord;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (include_flags) {</span>
<span class="line-added">+     Label done;</span>
<span class="line-added">+     z_mvi(Address(dst, offset), 2); // encoding: equal</span>
<span class="line-added">+     z_bre(done);</span>
<span class="line-added">+     z_mvi(Address(dst, offset), 4); // encoding: higher</span>
<span class="line-added">+     z_brh(done);</span>
<span class="line-added">+     z_mvi(Address(dst, offset), 1); // encoding: lower</span>
<span class="line-added">+     bind(done);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ void MacroAssembler::restore_volatile_regs(Register src, int offset, bool include_fp, bool include_flags) {</span>
<span class="line-added">+   z_lmg(Z_R1, Z_R5, offset, src); offset += 5 * BytesPerWord;</span>
<span class="line-added">+   if (include_fp) {</span>
<span class="line-added">+     z_ld(Z_F0, Address(src, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_ld(Z_F1, Address(src, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_ld(Z_F2, Address(src, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_ld(Z_F3, Address(src, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_ld(Z_F4, Address(src, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_ld(Z_F5, Address(src, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_ld(Z_F6, Address(src, offset)); offset += BytesPerWord;</span>
<span class="line-added">+     z_ld(Z_F7, Address(src, offset)); offset += BytesPerWord;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (include_flags) {</span>
<span class="line-added">+     z_cli(Address(src, offset), 2); // see encoding above</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Plausibility check for oops.
  void MacroAssembler::verify_oop(Register oop, const char* msg) {
    if (!VerifyOops) return;
  
    BLOCK_COMMENT(&quot;verify_oop {&quot;);
<span class="line-modified">!   unsigned int nbytes_save = (5 + 8 + 1) * BytesPerWord;</span>
<span class="line-modified">!   address entry_addr = StubRoutines::verify_oop_subroutine_entry_address();</span>
<span class="line-modified">! </span>
<span class="line-added">+   save_return_pc();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Push frame, but preserve flags</span>
<span class="line-added">+   z_lgr(Z_R0, Z_SP);</span>
<span class="line-added">+   z_lay(Z_SP, -((int64_t)nbytes_save + frame::z_abi_160_size), Z_SP);</span>
<span class="line-added">+   z_stg(Z_R0, _z_abi(callers_sp), Z_SP);</span>
<span class="line-added">+ </span>
<span class="line-added">+   save_volatile_regs(Z_SP, frame::z_abi_160_size, true, true);</span>
<span class="line-added">+ </span>
<span class="line-added">+   lgr_if_needed(Z_ARG2, oop);</span>
<span class="line-added">+   load_const_optimized(Z_ARG1, (address)msg);</span>
<span class="line-added">+   load_const_optimized(Z_R1, entry_addr);</span>
<span class="line-added">+   z_lg(Z_R1, 0, Z_R1);</span>
<span class="line-added">+   call_c(Z_R1);</span>
<span class="line-added">+ </span>
<span class="line-added">+   restore_volatile_regs(Z_SP, frame::z_abi_160_size, true, true);</span>
<span class="line-added">+   pop_frame();</span>
<span class="line-added">+   restore_return_pc();</span>
<span class="line-added">+ </span>
<span class="line-added">+   BLOCK_COMMENT(&quot;} verify_oop &quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void MacroAssembler::verify_oop_addr(Address addr, const char* msg) {</span>
<span class="line-added">+   if (!VerifyOops) return;</span>
<span class="line-added">+ </span>
<span class="line-added">+   BLOCK_COMMENT(&quot;verify_oop {&quot;);</span>
<span class="line-added">+   unsigned int nbytes_save = (5 + 8) * BytesPerWord;</span>
<span class="line-added">+   address entry_addr = StubRoutines::verify_oop_subroutine_entry_address();</span>
  
    save_return_pc();
<span class="line-modified">!   unsigned int frame_size = push_frame_abi160(nbytes_save); // kills Z_R0</span>
<span class="line-modified">!   save_volatile_regs(Z_SP, frame::z_abi_160_size, true, false);</span>
  
<span class="line-modified">!   z_lg(Z_ARG2, addr.plus_disp(frame_size));</span>
<span class="line-modified">!   load_const_optimized(Z_ARG1, (address)msg);</span>
<span class="line-modified">!   load_const_optimized(Z_R1, entry_addr);</span>
    z_lg(Z_R1, 0, Z_R1);
    call_c(Z_R1);
  
<span class="line-modified">!   restore_volatile_regs(Z_SP, frame::z_abi_160_size, true, false);</span>
    pop_frame();
    restore_return_pc();
  
    BLOCK_COMMENT(&quot;} verify_oop &quot;);
  }
</pre>
<center><a href="jniFastGetField_s390.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_s390.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
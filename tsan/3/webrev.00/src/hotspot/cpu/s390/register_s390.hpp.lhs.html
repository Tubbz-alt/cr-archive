<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/register_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
<a name="1" id="anc1"></a><span class="line-modified">  3  * Copyright (c) 2016, 2017 SAP SE. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_S390_REGISTER_S390_HPP
 27 #define CPU_S390_REGISTER_S390_HPP
 28 
 29 #include &quot;asm/register.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 30 #include &quot;vm_version_s390.hpp&quot;</span>
 31 
 32 class Address;
 33 class VMRegImpl;
 34 
 35 typedef VMRegImpl* VMReg;
 36 
 37 
 38 // z/Architecture registers, see &quot;LINUX for zSeries ELF ABI Supplement&quot;, IBM March 2001
 39 //
 40 //   r0-r1     General purpose (volatile)
 41 //   r2        Parameter and return value (volatile)
 42 //   r3        TOC pointer (volatile)
 43 //   r3-r5     Parameters (volatile)
 44 //   r6        Parameter (nonvolatile)
 45 //   r7-r11    Locals (nonvolatile)
 46 //   r12       Local, often used as GOT pointer (nonvolatile)
 47 //   r13       Local, often used as toc (nonvolatile)
 48 //   r14       return address (volatile)
 49 //   r15       stack pointer (nonvolatile)
 50 //
 51 //   f0,f2,f4,f6 Parameters (volatile)
 52 //   f1,f3,f5,f7 General purpose (volatile)
 53 //   f8-f15      General purpose (nonvolatile)
 54 
 55 
 56 //===========================
 57 //===  Integer Registers  ===
 58 //===========================
 59 
 60 // Use Register as shortcut.
 61 class RegisterImpl;
 62 typedef RegisterImpl* Register;
 63 
 64 // The implementation of integer registers for z/Architecture.
 65 
 66 inline Register as_Register(int encoding) {
 67   return (Register)(long)encoding;
 68 }
 69 
 70 class RegisterImpl: public AbstractRegisterImpl {
 71  public:
 72   enum {
 73     number_of_registers     = 16,
 74     number_of_arg_registers = 5
 75   };
 76 
 77   // general construction
 78   inline friend Register as_Register(int encoding);
 79 
 80   inline VMReg as_VMReg();
 81 
 82   // accessors
 83   int   encoding() const      { assert(is_valid(), &quot;invalid register&quot;); return value(); }
 84   const char* name() const;
 85 
 86   // testers
 87   bool is_valid() const       { return (0 &lt;= (value()&amp;0x7F) &amp;&amp; (value()&amp;0x7F) &lt; number_of_registers); }
 88   bool is_even() const        { return (encoding() &amp; 1) == 0; }
 89   bool is_volatile() const    { return (0 &lt;= (value()&amp;0x7F) &amp;&amp; (value()&amp;0x7F) &lt;= 5) || (value()&amp;0x7F)==14; }
 90   bool is_nonvolatile() const { return is_valid() &amp;&amp; !is_volatile(); }
 91 
 92  public:
 93   // derived registers, offsets, and addresses
 94   Register predecessor() const { return as_Register((encoding()-1) &amp; (number_of_registers-1)); }
 95   Register successor() const   { return as_Register((encoding() + 1) &amp; (number_of_registers-1)); }
 96 };
 97 
 98 // The integer registers of the z/Architecture.
 99 
100 CONSTANT_REGISTER_DECLARATION(Register, noreg, (-1));
101 
102 CONSTANT_REGISTER_DECLARATION(Register, Z_R0,   (0));
103 CONSTANT_REGISTER_DECLARATION(Register, Z_R1,   (1));
104 CONSTANT_REGISTER_DECLARATION(Register, Z_R2,   (2));
105 CONSTANT_REGISTER_DECLARATION(Register, Z_R3,   (3));
106 CONSTANT_REGISTER_DECLARATION(Register, Z_R4,   (4));
107 CONSTANT_REGISTER_DECLARATION(Register, Z_R5,   (5));
108 CONSTANT_REGISTER_DECLARATION(Register, Z_R6,   (6));
109 CONSTANT_REGISTER_DECLARATION(Register, Z_R7,   (7));
110 CONSTANT_REGISTER_DECLARATION(Register, Z_R8,   (8));
111 CONSTANT_REGISTER_DECLARATION(Register, Z_R9,   (9));
112 CONSTANT_REGISTER_DECLARATION(Register, Z_R10, (10));
113 CONSTANT_REGISTER_DECLARATION(Register, Z_R11, (11));
114 CONSTANT_REGISTER_DECLARATION(Register, Z_R12, (12));
115 CONSTANT_REGISTER_DECLARATION(Register, Z_R13, (13));
116 CONSTANT_REGISTER_DECLARATION(Register, Z_R14, (14));
117 CONSTANT_REGISTER_DECLARATION(Register, Z_R15, (15));
118 
119 
120 //=============================
121 //===  Condition Registers  ===
122 //=============================
123 
124 // Use ConditionRegister as shortcut
125 class ConditionRegisterImpl;
126 typedef ConditionRegisterImpl* ConditionRegister;
127 
128 // The implementation of condition register(s) for the z/Architecture.
129 
130 class ConditionRegisterImpl: public AbstractRegisterImpl {
131  public:
132 
133   enum {
134     number_of_registers = 1
135   };
136 
137   // accessors
138   int encoding() const {
139     assert(is_valid(), &quot;invalid register&quot;); return value();
140   }
141 
142   // testers
143   bool is_valid() const {
144     return (0 &lt;= value() &amp;&amp; value() &lt; number_of_registers);
145   }
146   bool is_volatile() const {
147     return true;
148   }
149   bool is_nonvolatile() const {
150     return false;
151   }
152 
153   // construction.
154   inline friend ConditionRegister as_ConditionRegister(int encoding);
155 
156   inline VMReg as_VMReg();
157 };
158 
159 inline ConditionRegister as_ConditionRegister(int encoding) {
160   assert(encoding &gt;= 0 &amp;&amp; encoding &lt; ConditionRegisterImpl::number_of_registers, &quot;bad condition register encoding&quot;);
161   return (ConditionRegister)(long)encoding;
162 }
163 
164 // The condition register of the z/Architecture.
165 
166 CONSTANT_REGISTER_DECLARATION(ConditionRegister, Z_CR, (0));
167 
168 // Because z/Architecture has so many registers, #define&#39;ing values for them is
169 // beneficial in code size and is worth the cost of some of the
170 // dangers of defines.
171 // If a particular file has a problem with these defines then it&#39;s possible
172 // to turn them off in that file by defining
173 // DONT_USE_REGISTER_DEFINES. Register_definitions_s390.cpp does that
174 // so that it&#39;s able to provide real definitions of these registers
175 // for use in debuggers and such.
176 
177 #ifndef DONT_USE_REGISTER_DEFINES
178 #define noreg ((Register)(noreg_RegisterEnumValue))
179 
180 #define Z_R0  ((Register)(Z_R0_RegisterEnumValue))
181 #define Z_R1  ((Register)(Z_R1_RegisterEnumValue))
182 #define Z_R2  ((Register)(Z_R2_RegisterEnumValue))
183 #define Z_R3  ((Register)(Z_R3_RegisterEnumValue))
184 #define Z_R4  ((Register)(Z_R4_RegisterEnumValue))
185 #define Z_R5  ((Register)(Z_R5_RegisterEnumValue))
186 #define Z_R6  ((Register)(Z_R6_RegisterEnumValue))
187 #define Z_R7  ((Register)(Z_R7_RegisterEnumValue))
188 #define Z_R8  ((Register)(Z_R8_RegisterEnumValue))
189 #define Z_R9  ((Register)(Z_R9_RegisterEnumValue))
190 #define Z_R10 ((Register)(Z_R10_RegisterEnumValue))
191 #define Z_R11 ((Register)(Z_R11_RegisterEnumValue))
192 #define Z_R12 ((Register)(Z_R12_RegisterEnumValue))
193 #define Z_R13 ((Register)(Z_R13_RegisterEnumValue))
194 #define Z_R14 ((Register)(Z_R14_RegisterEnumValue))
195 #define Z_R15 ((Register)(Z_R15_RegisterEnumValue))
196 
197 #define Z_CR ((ConditionRegister)(Z_CR_ConditionRegisterEnumValue))
198 #endif // DONT_USE_REGISTER_DEFINES
199 
200 
201 //=========================
202 //===  Float Registers  ===
203 //=========================
204 
205 // Use FloatRegister as shortcut
206 class FloatRegisterImpl;
207 typedef FloatRegisterImpl* FloatRegister;
208 
209 // The implementation of float registers for the z/Architecture.
210 
211 inline FloatRegister as_FloatRegister(int encoding) {
212   return (FloatRegister)(long)encoding;
213 }
214 
215 class FloatRegisterImpl: public AbstractRegisterImpl {
216  public:
217   enum {
218     number_of_registers     = 16,
219     number_of_arg_registers = 4
220   };
221 
222   // construction
223   inline friend FloatRegister as_FloatRegister(int encoding);
224 
225   inline VMReg as_VMReg();
226 
227   // accessors
228   int encoding() const                                {
229      assert(is_valid(), &quot;invalid register&quot;); return value();
230   }
231 
232   bool  is_valid() const          { return 0 &lt;= value() &amp;&amp; value() &lt; number_of_registers; }
233   bool is_volatile() const        { return (0 &lt;= (value()&amp;0x7F) &amp;&amp; (value()&amp;0x7F) &lt;= 7); }
234   bool is_nonvolatile() const     { return (8 &lt;= (value()&amp;0x7F) &amp;&amp; (value()&amp;0x7F) &lt;= 15); }
235 
236   const char* name() const;
237 
238   FloatRegister successor() const { return as_FloatRegister(encoding() + 1); }
239 };
240 
241 // The float registers of z/Architecture.
242 
243 CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg, (-1));
244 
245 CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F0,  (0));
246 CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F1,  (1));
247 CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F2,  (2));
248 CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F3,  (3));
249 CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F4,  (4));
250 CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F5,  (5));
251 CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F6,  (6));
252 CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F7,  (7));
253 CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F8,  (8));
254 CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F9,  (9));
255 CONSTANT_REGISTER_DECLARATION(FloatRegister, Z_F10, (10));
256 CONSTANT_REGISTER_DECLARATION(FloatRegister, Z_F11, (11));
257 CONSTANT_REGISTER_DECLARATION(FloatRegister, Z_F12, (12));
258 CONSTANT_REGISTER_DECLARATION(FloatRegister, Z_F13, (13));
259 CONSTANT_REGISTER_DECLARATION(FloatRegister, Z_F14, (14));
260 CONSTANT_REGISTER_DECLARATION(FloatRegister, Z_F15, (15));
261 
262 #ifndef DONT_USE_REGISTER_DEFINES
263 #define fnoreg ((FloatRegister)(fnoreg_FloatRegisterEnumValue))
264 #define Z_F0  ((FloatRegister)(   Z_F0_FloatRegisterEnumValue))
265 #define Z_F1  ((FloatRegister)(   Z_F1_FloatRegisterEnumValue))
266 #define Z_F2  ((FloatRegister)(   Z_F2_FloatRegisterEnumValue))
267 #define Z_F3  ((FloatRegister)(   Z_F3_FloatRegisterEnumValue))
268 #define Z_F4  ((FloatRegister)(   Z_F4_FloatRegisterEnumValue))
269 #define Z_F5  ((FloatRegister)(   Z_F5_FloatRegisterEnumValue))
270 #define Z_F6  ((FloatRegister)(   Z_F6_FloatRegisterEnumValue))
271 #define Z_F7  ((FloatRegister)(   Z_F7_FloatRegisterEnumValue))
272 #define Z_F8  ((FloatRegister)(   Z_F8_FloatRegisterEnumValue))
273 #define Z_F9  ((FloatRegister)(   Z_F9_FloatRegisterEnumValue))
274 #define Z_F10 ((FloatRegister)(  Z_F10_FloatRegisterEnumValue))
275 #define Z_F11 ((FloatRegister)(  Z_F11_FloatRegisterEnumValue))
276 #define Z_F12 ((FloatRegister)(  Z_F12_FloatRegisterEnumValue))
277 #define Z_F13 ((FloatRegister)(  Z_F13_FloatRegisterEnumValue))
278 #define Z_F14 ((FloatRegister)(  Z_F14_FloatRegisterEnumValue))
279 #define Z_F15 ((FloatRegister)(  Z_F15_FloatRegisterEnumValue))
280 #endif // DONT_USE_REGISTER_DEFINES
281 
282 // Single, Double and Quad fp reg classes. These exist to map the ADLC
283 // encoding for a floating point register, to the FloatRegister number
284 // desired by the macroassembler. A FloatRegister is a number between
285 // 0 and 31 passed around as a pointer. For ADLC, an fp register encoding
286 // is the actual bit encoding used by the z/Architecture hardware. When ADLC used
287 // the macroassembler to generate an instruction that references, e.g., a
288 // double fp reg, it passed the bit encoding to the macroassembler via
289 // as_FloatRegister, which, for double regs &gt; 30, returns an illegal
290 // register number.
291 //
292 // Therefore we provide the following classes for use by ADLC. Their
293 // sole purpose is to convert from z/Architecture register encodings to FloatRegisters.
294 // At some future time, we might replace FloatRegister with these classes,
295 // hence the definitions of as_xxxFloatRegister as class methods rather
296 // than as external inline routines.
297 
298 class SingleFloatRegisterImpl;
299 typedef SingleFloatRegisterImpl *SingleFloatRegister;
300 
301 class SingleFloatRegisterImpl {
302  public:
303   friend FloatRegister as_SingleFloatRegister(int encoding) {
304     assert(encoding &lt; 32, &quot;bad single float register encoding&quot;);
305     return as_FloatRegister(encoding);
306   }
307 };
308 
309 class DoubleFloatRegisterImpl;
310 typedef DoubleFloatRegisterImpl *DoubleFloatRegister;
311 
312 class DoubleFloatRegisterImpl {
313  public:
314   friend FloatRegister as_DoubleFloatRegister(int encoding) {
315     assert(encoding &lt; 32, &quot;bad double float register encoding&quot;);
316     return as_FloatRegister(((encoding &amp; 1) &lt;&lt; 5) | (encoding &amp; 0x1e));
317   }
318 };
319 
320 class QuadFloatRegisterImpl;
321 typedef QuadFloatRegisterImpl *QuadFloatRegister;
322 
323 class QuadFloatRegisterImpl {
324  public:
325   friend FloatRegister as_QuadFloatRegister(int encoding) {
326     assert(encoding &lt; 32 &amp;&amp; ((encoding &amp; 2) == 0), &quot;bad quad float register encoding&quot;);
327     return as_FloatRegister(((encoding &amp; 1) &lt;&lt; 5) | (encoding &amp; 0x1c));
328   }
329 };
330 
331 
332 //==========================
333 //===  Vector Registers  ===
334 //==========================
335 
336 // Use VectorRegister as shortcut
337 class VectorRegisterImpl;
338 typedef VectorRegisterImpl* VectorRegister;
339 
340 // The implementation of vector registers for z/Architecture.
341 
342 inline VectorRegister as_VectorRegister(int encoding) {
343   return (VectorRegister)(long)encoding;
344 }
345 
346 class VectorRegisterImpl: public AbstractRegisterImpl {
347  public:
348   enum {
349     number_of_registers     = 32,
350     number_of_arg_registers = 0
351   };
352 
353   // construction
354   inline friend VectorRegister as_VectorRegister(int encoding);
355 
356   inline VMReg as_VMReg();
357 
358   // accessors
359   int encoding() const                                {
360      assert(is_valid(), &quot;invalid register&quot;); return value();
361   }
362 
363   bool is_valid() const           { return  0 &lt;= value() &amp;&amp; value() &lt; number_of_registers; }
364   bool is_volatile() const        { return true; }
365   bool is_nonvolatile() const     { return false; }
366 
367   // Register fields in z/Architecture instructions are 4 bits wide, restricting the
368   // addressable register set size to 16.
369   // The vector register set size is 32, requiring an extension, by one bit, of the
370   // register encoding. This is accomplished by the introduction of a RXB field in the
371   // instruction. RXB = Register eXtension Bits.
372   // The RXB field contains the MSBs (most significant bit) of the vector register numbers
373   // used for this instruction. Assignment of MSB in RBX is by bit position of the
374   // register field in the instruction.
375   // Example:
376   //   The register field starting at bit position 12 in the instruction is assigned RXB bit 0b0100.
377   int64_t RXB_mask(int pos) {
378     if (encoding() &gt;= number_of_registers/2) {
379       switch (pos) {
380         case 8:   return ((int64_t)0b1000) &lt;&lt; 8; // actual bit pos: 36
381         case 12:  return ((int64_t)0b0100) &lt;&lt; 8; // actual bit pos: 37
382         case 16:  return ((int64_t)0b0010) &lt;&lt; 8; // actual bit pos: 38
383         case 32:  return ((int64_t)0b0001) &lt;&lt; 8; // actual bit pos: 39
384         default:
385           ShouldNotReachHere();
386       }
387     }
388     return 0;
389   }
390 
391   const char* name() const;
392 
393   VectorRegister successor() const { return as_VectorRegister(encoding() + 1); }
394 };
395 
396 // The Vector registers of z/Architecture.
397 
398 CONSTANT_REGISTER_DECLARATION(VectorRegister, vnoreg, (-1));
399 
400 CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V0,  (0));
401 CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V1,  (1));
402 CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V2,  (2));
403 CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V3,  (3));
404 CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V4,  (4));
405 CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V5,  (5));
406 CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V6,  (6));
407 CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V7,  (7));
408 CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V8,  (8));
409 CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V9,  (9));
410 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V10, (10));
411 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V11, (11));
412 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V12, (12));
413 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V13, (13));
414 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V14, (14));
415 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V15, (15));
416 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V16, (16));
417 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V17, (17));
418 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V18, (18));
419 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V19, (19));
420 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V20, (20));
421 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V21, (21));
422 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V22, (22));
423 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V23, (23));
424 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V24, (24));
425 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V25, (25));
426 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V26, (26));
427 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V27, (27));
428 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V28, (28));
429 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V29, (29));
430 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V30, (30));
431 CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V31, (31));
432 
433 #ifndef DONT_USE_REGISTER_DEFINES
434 #define vnoreg ((VectorRegister)(vnoreg_VectorRegisterEnumValue))
435 #define Z_V0  ((VectorRegister)(   Z_V0_VectorRegisterEnumValue))
436 #define Z_V1  ((VectorRegister)(   Z_V1_VectorRegisterEnumValue))
437 #define Z_V2  ((VectorRegister)(   Z_V2_VectorRegisterEnumValue))
438 #define Z_V3  ((VectorRegister)(   Z_V3_VectorRegisterEnumValue))
439 #define Z_V4  ((VectorRegister)(   Z_V4_VectorRegisterEnumValue))
440 #define Z_V5  ((VectorRegister)(   Z_V5_VectorRegisterEnumValue))
441 #define Z_V6  ((VectorRegister)(   Z_V6_VectorRegisterEnumValue))
442 #define Z_V7  ((VectorRegister)(   Z_V7_VectorRegisterEnumValue))
443 #define Z_V8  ((VectorRegister)(   Z_V8_VectorRegisterEnumValue))
444 #define Z_V9  ((VectorRegister)(   Z_V9_VectorRegisterEnumValue))
445 #define Z_V10 ((VectorRegister)(  Z_V10_VectorRegisterEnumValue))
446 #define Z_V11 ((VectorRegister)(  Z_V11_VectorRegisterEnumValue))
447 #define Z_V12 ((VectorRegister)(  Z_V12_VectorRegisterEnumValue))
448 #define Z_V13 ((VectorRegister)(  Z_V13_VectorRegisterEnumValue))
449 #define Z_V14 ((VectorRegister)(  Z_V14_VectorRegisterEnumValue))
450 #define Z_V15 ((VectorRegister)(  Z_V15_VectorRegisterEnumValue))
451 #define Z_V16 ((VectorRegister)(  Z_V16_VectorRegisterEnumValue))
452 #define Z_V17 ((VectorRegister)(  Z_V17_VectorRegisterEnumValue))
453 #define Z_V18 ((VectorRegister)(  Z_V18_VectorRegisterEnumValue))
454 #define Z_V19 ((VectorRegister)(  Z_V19_VectorRegisterEnumValue))
455 #define Z_V20 ((VectorRegister)(  Z_V20_VectorRegisterEnumValue))
456 #define Z_V21 ((VectorRegister)(  Z_V21_VectorRegisterEnumValue))
457 #define Z_V22 ((VectorRegister)(  Z_V22_VectorRegisterEnumValue))
458 #define Z_V23 ((VectorRegister)(  Z_V23_VectorRegisterEnumValue))
459 #define Z_V24 ((VectorRegister)(  Z_V24_VectorRegisterEnumValue))
460 #define Z_V25 ((VectorRegister)(  Z_V25_VectorRegisterEnumValue))
461 #define Z_V26 ((VectorRegister)(  Z_V26_VectorRegisterEnumValue))
462 #define Z_V27 ((VectorRegister)(  Z_V27_VectorRegisterEnumValue))
463 #define Z_V28 ((VectorRegister)(  Z_V28_VectorRegisterEnumValue))
464 #define Z_V29 ((VectorRegister)(  Z_V29_VectorRegisterEnumValue))
465 #define Z_V30 ((VectorRegister)(  Z_V30_VectorRegisterEnumValue))
466 #define Z_V31 ((VectorRegister)(  Z_V31_VectorRegisterEnumValue))
467 #endif // DONT_USE_REGISTER_DEFINES
468 
469 
470 // Need to know the total number of registers of all sorts for SharedInfo.
471 // Define a class that exports it.
472 
473 class ConcreteRegisterImpl : public AbstractRegisterImpl {
474  public:
475   enum {
476     number_of_registers =
477       (RegisterImpl::number_of_registers +
478       FloatRegisterImpl::number_of_registers)
479       * 2 // register halves
480       + 1 // condition code register
481   };
482   static const int max_gpr;
483   static const int max_fpr;
484 };
485 
486 
487 // Common register declarations used in assembler code.
488 REGISTER_DECLARATION(Register,      Z_EXC_OOP, Z_R2);
489 REGISTER_DECLARATION(Register,      Z_EXC_PC,  Z_R3);
490 REGISTER_DECLARATION(Register,      Z_RET,     Z_R2);
491 REGISTER_DECLARATION(Register,      Z_ARG1,    Z_R2);
492 REGISTER_DECLARATION(Register,      Z_ARG2,    Z_R3);
493 REGISTER_DECLARATION(Register,      Z_ARG3,    Z_R4);
494 REGISTER_DECLARATION(Register,      Z_ARG4,    Z_R5);
495 REGISTER_DECLARATION(Register,      Z_ARG5,    Z_R6);
496 REGISTER_DECLARATION(Register,      Z_SP,     Z_R15);
497 REGISTER_DECLARATION(FloatRegister, Z_FRET,    Z_F0);
498 REGISTER_DECLARATION(FloatRegister, Z_FARG1,   Z_F0);
499 REGISTER_DECLARATION(FloatRegister, Z_FARG2,   Z_F2);
500 REGISTER_DECLARATION(FloatRegister, Z_FARG3,   Z_F4);
501 REGISTER_DECLARATION(FloatRegister, Z_FARG4,   Z_F6);
502 
503 #ifndef DONT_USE_REGISTER_DEFINES
504 #define Z_EXC_OOP         AS_REGISTER(Register,  Z_R2)
505 #define Z_EXC_PC          AS_REGISTER(Register,  Z_R3)
506 #define Z_RET             AS_REGISTER(Register,  Z_R2)
507 #define Z_ARG1            AS_REGISTER(Register,  Z_R2)
508 #define Z_ARG2            AS_REGISTER(Register,  Z_R3)
509 #define Z_ARG3            AS_REGISTER(Register,  Z_R4)
510 #define Z_ARG4            AS_REGISTER(Register,  Z_R5)
511 #define Z_ARG5            AS_REGISTER(Register,  Z_R6)
512 #define Z_SP              AS_REGISTER(Register, Z_R15)
513 #define Z_FRET            AS_REGISTER(FloatRegister, Z_F0)
514 #define Z_FARG1           AS_REGISTER(FloatRegister, Z_F0)
515 #define Z_FARG2           AS_REGISTER(FloatRegister, Z_F2)
516 #define Z_FARG3           AS_REGISTER(FloatRegister, Z_F4)
517 #define Z_FARG4           AS_REGISTER(FloatRegister, Z_F6)
518 #endif
519 
520 // Register declarations to be used in frame manager assembly code.
521 // Use only non-volatile registers in order to keep values across C-calls.
522 
523 // Register to cache the integer value on top of the operand stack.
524 REGISTER_DECLARATION(Register, Z_tos,         Z_R2);
525 // Register to cache the fp value on top of the operand stack.
526 REGISTER_DECLARATION(FloatRegister, Z_ftos,   Z_F0);
527 // Expression stack pointer in interpreted java frame.
528 REGISTER_DECLARATION(Register, Z_esp,         Z_R7);
529 // Address of current thread.
530 REGISTER_DECLARATION(Register, Z_thread,      Z_R8);
531 // Address of current method. only valid in interpreter_entry.
532 REGISTER_DECLARATION(Register, Z_method,      Z_R9);
533 // Inline cache register. used by c1 and c2.
534 REGISTER_DECLARATION(Register, Z_inline_cache,Z_R9);
535 // Frame pointer of current interpreter frame. only valid while
536 // executing bytecodes.
537 REGISTER_DECLARATION(Register, Z_fp,          Z_R9);
538 // Address of the locals array in an interpreted java frame.
539 REGISTER_DECLARATION(Register, Z_locals,      Z_R12);
540 // Bytecode pointer.
541 REGISTER_DECLARATION(Register, Z_bcp,         Z_R13);
542 // Bytecode which is dispatched (short lived!).
543 REGISTER_DECLARATION(Register, Z_bytecode,    Z_R14);
544 #ifndef DONT_USE_REGISTER_DEFINES
545 #define Z_tos             AS_REGISTER(Register, Z_R2)
546 #define Z_ftos            AS_REGISTER(FloatRegister, Z_F0)
547 #define Z_esp             AS_REGISTER(Register, Z_R7)
548 #define Z_thread          AS_REGISTER(Register, Z_R8)
549 #define Z_method          AS_REGISTER(Register, Z_R9)
550 #define Z_inline_cache    AS_REGISTER(Register, Z_R9)
551 #define Z_fp              AS_REGISTER(Register, Z_R9)
552 #define Z_locals          AS_REGISTER(Register, Z_R12)
553 #define Z_bcp             AS_REGISTER(Register, Z_R13)
554 #define Z_bytecode        AS_REGISTER(Register, Z_R14)
555 #endif
556 
557 // Temporary registers to be used within frame manager. We can use
558 // the nonvolatiles because the call stub has saved them.
559 // Use only non-volatile registers in order to keep values across C-calls.
560 REGISTER_DECLARATION(Register, Z_tmp_1,  Z_R10);
561 REGISTER_DECLARATION(Register, Z_tmp_2,  Z_R11);
562 REGISTER_DECLARATION(Register, Z_tmp_3,  Z_R12);
563 REGISTER_DECLARATION(Register, Z_tmp_4,  Z_R13);
564 #ifndef DONT_USE_REGISTER_DEFINES
565 #define Z_tmp_1      AS_REGISTER(Register, Z_R10)
566 #define Z_tmp_2      AS_REGISTER(Register, Z_R11)
567 #define Z_tmp_3      AS_REGISTER(Register, Z_R12)
568 #define Z_tmp_4      AS_REGISTER(Register, Z_R13)
569 #endif
570 
571 // Scratch registers are volatile.
572 REGISTER_DECLARATION(Register, Z_R0_scratch, Z_R0);
573 REGISTER_DECLARATION(Register, Z_R1_scratch, Z_R1);
574 REGISTER_DECLARATION(FloatRegister, Z_fscratch_1, Z_F1);
575 #ifndef DONT_USE_REGISTER_DEFINES
576 #define Z_R0_scratch  AS_REGISTER(Register, Z_R0)
577 #define Z_R1_scratch  AS_REGISTER(Register, Z_R1)
578 #define Z_fscratch_1  AS_REGISTER(FloatRegister, Z_F1)
579 #endif
580 
581 
582 #endif // CPU_S390_REGISTER_S390_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
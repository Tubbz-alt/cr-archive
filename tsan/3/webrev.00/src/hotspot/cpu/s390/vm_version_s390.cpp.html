<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/s390/vm_version_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2016, 2019 SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;code/compiledIC.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;runtime/java.hpp&quot;
  33 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  34 #include &quot;runtime/vm_version.hpp&quot;
  35 
  36 # include &lt;sys/sysinfo.h&gt;
  37 
  38 bool VM_Version::_is_determine_features_test_running  = false;
  39 const char*   VM_Version::_model_string;
  40 
  41 unsigned long VM_Version::_features[_features_buffer_len]           = {0, 0, 0, 0};
  42 unsigned long VM_Version::_cipher_features[_features_buffer_len]    = {0, 0, 0, 0};
  43 unsigned long VM_Version::_msgdigest_features[_features_buffer_len] = {0, 0, 0, 0};
  44 unsigned int  VM_Version::_nfeatures                                = 0;
  45 unsigned int  VM_Version::_ncipher_features                         = 0;
  46 unsigned int  VM_Version::_nmsgdigest_features                      = 0;
  47 unsigned int  VM_Version::_Dcache_lineSize                          = DEFAULT_CACHE_LINE_SIZE;
  48 unsigned int  VM_Version::_Icache_lineSize                          = DEFAULT_CACHE_LINE_SIZE;
  49 
  50 static const char* z_gen[]     = {&quot;  &quot;,   &quot;G1&quot;,   &quot;G2&quot;, &quot;G3&quot;,    &quot;G4&quot;,     &quot;G5&quot;,      &quot;G6&quot;,   &quot;G7&quot;   };
  51 static const char* z_machine[] = {&quot;  &quot;, &quot;2064&quot;, &quot;2084&quot;, &quot;2094&quot;,  &quot;2097&quot;,   &quot;2817&quot;,    &quot;  &quot;,   &quot;2964&quot; };
  52 static const char* z_name[]    = {&quot;  &quot;, &quot;z900&quot;, &quot;z990&quot;, &quot;z9 EC&quot;, &quot;z10 EC&quot;, &quot;z196 EC&quot;, &quot;ec12&quot;, &quot;z13&quot;  };
  53 
  54 void VM_Version::initialize() {
  55   determine_features();      // Get processor capabilities.
  56   set_features_string();     // Set a descriptive feature indication.
  57 
  58   if (Verbose) {
  59     print_features();
  60   }
  61 
  62   intx cache_line_size = Dcache_lineSize(0);
  63 
  64 #ifdef COMPILER2
  65   MaxVectorSize = 8;
  66 #endif
  67 
  68   if (has_PrefetchRaw()) {
  69     if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {  // not preset
  70       // 0 = no prefetch.
  71       // 1 = Prefetch instructions for each allocation.
  72       // 2 = Use TLAB watermark to gate allocation prefetch.
  73       AllocatePrefetchStyle = 1;
  74     }
  75 
  76     if (AllocatePrefetchStyle &gt; 0) {  // Prefetching turned on at all?
  77       // Distance to prefetch ahead of allocation pointer.
  78       if (FLAG_IS_DEFAULT(AllocatePrefetchDistance) || (AllocatePrefetchDistance &lt; 0)) {  // not preset
  79         AllocatePrefetchDistance = 0;
  80       }
  81 
  82       // Number of lines to prefetch ahead of allocation pointer.
  83       if (FLAG_IS_DEFAULT(AllocatePrefetchLines) || (AllocatePrefetchLines &lt;= 0)) {      // not preset
  84         AllocatePrefetchLines = 3;
  85       }
  86 
  87       // Step size in bytes of sequential prefetch instructions.
  88       if (FLAG_IS_DEFAULT(AllocatePrefetchStepSize) || (AllocatePrefetchStepSize &lt;= 0)) { // not preset
  89         FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
  90       } else if (AllocatePrefetchStepSize &lt; cache_line_size) {
  91         FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
  92       } else {
  93         FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
  94       }
  95     } else {
  96       FLAG_SET_DEFAULT(AllocatePrefetchStyle, 0);
  97       AllocatePrefetchDistance = 0;
  98       AllocatePrefetchLines    = 0;
  99       // Can&#39;t be zero. Will SIGFPE during constraints checking.
 100       FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
 101     }
 102 
 103   } else {
 104     FLAG_SET_DEFAULT(AllocatePrefetchStyle, 0);
 105     AllocatePrefetchDistance = 0;
 106     AllocatePrefetchLines    = 0;
 107     // Can&#39;t be zero. Will SIGFPE during constraints checking.
 108     FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
 109   }
 110 
 111   // TODO:
 112   // On z/Architecture, cache line size is significantly large (256 bytes). Do we really need
 113   // to keep contended members that far apart? Performance tests are required.
 114   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &amp;&amp; (cache_line_size &gt; ContendedPaddingWidth)) {
 115     ContendedPaddingWidth = cache_line_size;
 116   }
 117 
 118   // On z/Architecture, the CRC32/CRC32C intrinsics are implemented &quot;by hand&quot;.
 119   // TODO: Provide implementation based on the vector instructions available from z13.
 120   // Note: The CHECKSUM instruction, which has been there since the very beginning
 121   //       (of z/Architecture), computes &quot;some kind of&quot; a checksum.
 122   //       It has nothing to do with the CRC32 algorithm.
 123   if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
 124     FLAG_SET_DEFAULT(UseCRC32Intrinsics, true);
 125   }
 126   if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 127     FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
 128   }
 129 
 130   // TODO: Provide implementation.
 131   if (UseAdler32Intrinsics) {
 132     warning(&quot;Adler32Intrinsics not available on this CPU.&quot;);
 133     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
 134   }
 135 
 136   // On z/Architecture, we take UseAES as the general switch to enable/disable the AES intrinsics.
 137   // The specific, and yet to be defined, switches UseAESxxxIntrinsics will then be set
 138   // depending on the actual machine capabilities.
 139   // Explicitly setting them via CmdLine option takes precedence, of course.
 140   // TODO: UseAESIntrinsics must be made keylength specific.
 141   // As of March 2015 and Java8, only AES128 is supported by the Java Cryptographic Extensions.
 142   // Therefore, UseAESIntrinsics is of minimal use at the moment.
 143   if (FLAG_IS_DEFAULT(UseAES) &amp;&amp; has_Crypto_AES()) {
 144     FLAG_SET_DEFAULT(UseAES, true);
 145   }
 146   if (UseAES &amp;&amp; !has_Crypto_AES()) {
 147     warning(&quot;AES instructions are not available on this CPU&quot;);
 148     FLAG_SET_DEFAULT(UseAES, false);
 149   }
 150   if (UseAES) {
 151     if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 152       FLAG_SET_DEFAULT(UseAESIntrinsics, true);
 153     }
 154   }
 155   if (UseAESIntrinsics &amp;&amp; !has_Crypto_AES()) {
 156     warning(&quot;AES intrinsics are not available on this CPU&quot;);
 157     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 158   }
 159   if (UseAESIntrinsics &amp;&amp; !UseAES) {
 160     warning(&quot;AES intrinsics require UseAES flag to be enabled. Intrinsics will be disabled.&quot;);
 161     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 162   }
 163 
 164   // TODO: implement AES/CTR intrinsics
 165   if (UseAESCTRIntrinsics) {
 166     warning(&quot;AES/CTR intrinsics are not available on this CPU&quot;);
 167     FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 168   }
 169 
 170   if (FLAG_IS_DEFAULT(UseGHASHIntrinsics) &amp;&amp; has_Crypto_GHASH()) {
 171     FLAG_SET_DEFAULT(UseGHASHIntrinsics, true);
 172   }
 173   if (UseGHASHIntrinsics &amp;&amp; !has_Crypto_GHASH()) {
 174     warning(&quot;GHASH intrinsics are not available on this CPU&quot;);
 175     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
 176   }
 177 
 178   if (FLAG_IS_DEFAULT(UseFMA)) {
 179     FLAG_SET_DEFAULT(UseFMA, true);
 180   }
 181 
 182   // On z/Architecture, we take UseSHA as the general switch to enable/disable the SHA intrinsics.
 183   // The specific switches UseSHAxxxIntrinsics will then be set depending on the actual
 184   // machine capabilities.
 185   // Explicitly setting them via CmdLine option takes precedence, of course.
 186   if (FLAG_IS_DEFAULT(UseSHA) &amp;&amp; has_Crypto_SHA()) {
 187     FLAG_SET_DEFAULT(UseSHA, true);
 188   }
 189   if (UseSHA &amp;&amp; !has_Crypto_SHA()) {
 190     warning(&quot;SHA instructions are not available on this CPU&quot;);
 191     FLAG_SET_DEFAULT(UseSHA, false);
 192   }
 193   if (UseSHA &amp;&amp; has_Crypto_SHA1()) {
 194     if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {
 195       FLAG_SET_DEFAULT(UseSHA1Intrinsics, true);
 196     }
 197   } else if (UseSHA1Intrinsics) {
 198     warning(&quot;Intrinsics for SHA-1 crypto hash functions not available on this CPU.&quot;);
 199     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
 200   }
 201   if (UseSHA &amp;&amp; has_Crypto_SHA256()) {
 202     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
 203       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
 204     }
 205   } else if (UseSHA256Intrinsics) {
 206     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
 207     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 208   }
 209   if (UseSHA &amp;&amp; has_Crypto_SHA512()) {
 210     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
 211       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
 212     }
 213   } else if (UseSHA512Intrinsics) {
 214     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
 215     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 216   }
 217 
 218   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
 219     FLAG_SET_DEFAULT(UseSHA, false);
 220   }
 221 
 222 #ifdef COMPILER2
 223   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
 224     FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);
 225   }
 226   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
 227     FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, true);
 228   }
 229   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
 230     FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, true);
 231   }
 232 #endif
 233   if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
 234     FLAG_SET_DEFAULT(UsePopCountInstruction, true);
 235   }
 236 
 237   // z/Architecture supports 8-byte compare-exchange operations
 238   // (see Atomic::cmpxchg)
 239   // and &#39;atomic long memory ops&#39; (see Unsafe_GetLongVolatile).
 240   _supports_cx8 = true;
 241 
 242   _supports_atomic_getadd4 = VM_Version::has_LoadAndALUAtomicV1();
 243   _supports_atomic_getadd8 = VM_Version::has_LoadAndALUAtomicV1();
 244 
 245   // z/Architecture supports unaligned memory accesses.
 246   // Performance penalty is negligible. An additional tick or so
 247   // is lost if the accessed data spans a cache line boundary.
 248   // Unaligned accesses are not atomic, of course.
 249   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
 250     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
 251   }
 252 }
 253 
 254 
 255 void VM_Version::set_features_string() {
 256 
 257   unsigned int ambiguity = 0;
 258   _model_string = z_name[0];
 259   if (is_z13()) {
 260     _features_string = &quot;System z G7-z13  (LDISP_fast, ExtImm, PCrel Load/Store, CmpB, Cond Load/Store, Interlocked Update, TxM, VectorInstr)&quot;;
 261     _model_string = z_name[7];
 262     ambiguity++;
 263   }
 264   if (is_ec12()) {
 265     _features_string = &quot;System z G6-EC12 (LDISP_fast, ExtImm, PCrel Load/Store, CmpB, Cond Load/Store, Interlocked Update, TxM)&quot;;
 266     _model_string = z_name[6];
 267     ambiguity++;
 268   }
 269   if (is_z196()) {
 270     _features_string = &quot;System z G5-z196 (LDISP_fast, ExtImm, PCrel Load/Store, CmpB, Cond Load/Store, Interlocked Update)&quot;;
 271     _model_string = z_name[5];
 272     ambiguity++;
 273   }
 274   if (is_z10()) {
 275     _features_string = &quot;System z G4-z10  (LDISP_fast, ExtImm, PCrel Load/Store, CmpB)&quot;;
 276     _model_string = z_name[4];
 277     ambiguity++;
 278   }
 279   if (is_z9()) {
 280     _features_string = &quot;System z G3-z9   (LDISP_fast, ExtImm), out-of-support as of 2016-04-01&quot;;
 281     _model_string = z_name[3];
 282     ambiguity++;
 283   }
 284   if (is_z990()) {
 285     _features_string = &quot;System z G2-z990 (LDISP_fast), out-of-support as of 2014-07-01&quot;;
 286     _model_string = z_name[2];
 287     ambiguity++;
 288   }
 289   if (is_z900()) {
 290     _features_string = &quot;System z G1-z900 (LDISP), out-of-support as of 2014-07-01&quot;;
 291     _model_string = z_name[1];
 292     ambiguity++;
 293   }
 294 
 295   if (ambiguity == 0) {
 296     _features_string = &quot;z/Architecture (unknown generation)&quot;;
 297   } else if (ambiguity &gt; 1) {
 298     tty-&gt;print_cr(&quot;*** WARNING *** Ambiguous z/Architecture detection, ambiguity = %d&quot;, ambiguity);
 299     tty-&gt;print_cr(&quot;                oldest detected generation is %s&quot;, _features_string);
 300     _features_string = &quot;z/Architecture (ambiguous detection)&quot;;
 301   }
 302 
 303   if (has_Crypto_AES()) {
 304     char buf[256];
 305     assert(strlen(_features_string) + 4 + 3*4 + 1 &lt; sizeof(buf), &quot;increase buffer size&quot;);
 306     jio_snprintf(buf, sizeof(buf), &quot;%s aes%s%s%s&quot;, // String &#39;aes&#39; must be surrounded by spaces so that jtreg tests recognize it.
 307                  _features_string,
 308                  has_Crypto_AES128() ? &quot; 128&quot; : &quot;&quot;,
 309                  has_Crypto_AES192() ? &quot; 192&quot; : &quot;&quot;,
 310                  has_Crypto_AES256() ? &quot; 256&quot; : &quot;&quot;);
 311     _features_string = os::strdup(buf);
 312   }
 313 
 314   if (has_Crypto_SHA()) {
 315     char buf[256];
 316     assert(strlen(_features_string) + 4 + 2 + 2*4 + 6 + 1 &lt; sizeof(buf), &quot;increase buffer size&quot;);
 317     // String &#39;sha1&#39; etc must be surrounded by spaces so that jtreg tests recognize it.
 318     jio_snprintf(buf, sizeof(buf), &quot;%s %s%s%s%s&quot;,
 319                  _features_string,
 320                  has_Crypto_SHA1()   ? &quot; sha1&quot;   : &quot;&quot;,
 321                  has_Crypto_SHA256() ? &quot; sha256&quot; : &quot;&quot;,
 322                  has_Crypto_SHA512() ? &quot; sha512&quot; : &quot;&quot;,
 323                  has_Crypto_GHASH()  ? &quot; ghash&quot;  : &quot;&quot;);
 324     if (has_Crypto_AES()) { os::free((void *)_features_string); }
 325     _features_string = os::strdup(buf);
 326   }
 327 }
 328 
 329 // featureBuffer - bit array indicating availability of various features
 330 // featureNum    - bit index of feature to be tested
 331 //                 Featurenum &lt; 0 requests test for any nonzero bit in featureBuffer.
 332 // bufLen        - length of featureBuffer in bits
 333 bool VM_Version::test_feature_bit(unsigned long* featureBuffer, int featureNum, unsigned int bufLen) {
 334   assert(bufLen &gt; 0,             &quot;buffer len must be positive&quot;);
 335   assert((bufLen &amp; 0x0007) == 0, &quot;unaligned buffer len&quot;);
 336   assert(((intptr_t)featureBuffer&amp;0x0007) == 0, &quot;unaligned feature buffer&quot;);
 337   if (featureNum &lt; 0) {
 338     // Any bit set at all?
 339     bool anyBit = false;
 340     for (size_t i = 0; i &lt; bufLen/(8*sizeof(long)); i++) {
 341       anyBit = anyBit || (featureBuffer[i] != 0);
 342     }
 343     return anyBit;
 344   } else {
 345     assert((unsigned int)featureNum &lt; bufLen,    &quot;feature index out of range&quot;);
 346     unsigned char* byteBuffer = (unsigned char*)featureBuffer;
 347     int   byteIndex  = featureNum/(8*sizeof(char));
 348     int   bitIndex   = featureNum%(8*sizeof(char));
 349     // Indexed bit set?
 350     return (byteBuffer[byteIndex] &amp; (1U&lt;&lt;(7-bitIndex))) != 0;
 351   }
 352 }
 353 
 354 void VM_Version::print_features_internal(const char* text, bool print_anyway) {
 355   tty-&gt;print_cr(&quot;%s %s&quot;,       text, features_string());
 356   tty-&gt;print(&quot;%s&quot;, text);
 357   for (unsigned int i = 0; i &lt; _nfeatures; i++) {
 358     tty-&gt;print(&quot;  0x%16.16lx&quot;, _features[i]);
 359   }
 360   tty-&gt;cr();
 361 
 362   if (Verbose || print_anyway) {
 363     // z900
 364     if (has_long_displacement()        ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;LongDispFacility&quot;);
 365     // z990
 366     if (has_long_displacement_fast()   ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;LongDispFacilityHighPerf&quot;);
 367     if (has_ETF2() &amp;&amp; has_ETF3()       ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ETF2 and ETF3&quot;);
 368     if (has_Crypto()                   ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;CryptoFacility&quot;);
 369     // z9
 370     if (has_extended_immediate()       ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ExtImmedFacility&quot;);
 371     if (has_StoreFacilityListExtended()) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;StoreFacilityListExtended&quot;);
 372     if (has_StoreClockFast()           ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;StoreClockFast&quot;);
 373     if (has_ETF2Enhancements()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ETF2 Enhancements&quot;);
 374     if (has_ETF3Enhancements()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ETF3 Enhancements&quot;);
 375     if (has_HFPUnnormalized()          ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;HFPUnnormalizedFacility&quot;);
 376     if (has_HFPMultiplyAndAdd()        ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;HFPMultiplyAndAddFacility&quot;);
 377     // z10
 378     if (has_ParsingEnhancements()      ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Parsing Enhancements&quot;);
 379     if (has_ExtractCPUtime()           ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ExtractCPUTime&quot;);
 380     if (has_CompareSwapStore()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;CompareSwapStore&quot;);
 381     if (has_GnrlInstrExtensions()      ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;General Instruction Extensions&quot;);
 382     if (has_CompareBranch()            ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Compare and Branch&quot;);
 383     if (has_CompareTrap()              ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Compare and Trap&quot;);
 384     if (has_RelativeLoadStore()        ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Relative Load/Store&quot;);
 385     if (has_MultiplySingleImm32()      ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;MultiplySingleImm32&quot;);
 386     if (has_Prefetch()                 ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Prefetch&quot;);
 387     if (has_MoveImmToMem()             ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Direct Moves Immediate to Memory&quot;);
 388     if (has_MemWithImmALUOps()         ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Direct ALU Ops Memory .op. Immediate&quot;);
 389     if (has_ExtractCPUAttributes()     ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Extract CPU Atributes&quot;);
 390     if (has_ExecuteExtensions()        ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;ExecuteExtensions&quot;);
 391     if (has_FPSupportEnhancements()    ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;FPSupportEnhancements&quot;);
 392     if (has_DecimalFloatingPoint()     ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;DecimalFloatingPoint&quot;);
 393     // z196
 394     if (has_DistinctOpnds()            ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Distinct Operands&quot;);
 395     if (has_InterlockedAccessV1()      ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;InterlockedAccess V1 (fast)&quot;);
 396     if (has_PopCount()                 ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;PopCount&quot;);
 397     if (has_LoadStoreConditional()     ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;LoadStoreConditional&quot;);
 398     if (has_HighWordInstr()            ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;HighWord Instructions&quot;);
 399     if (has_FastSync()                 ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;FastSync (bcr 14,0)&quot;);
 400     if (has_AtomicMemWithImmALUOps()   ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Atomic Direct ALU Ops Memory .op. Immediate&quot;);
 401     if (has_FPExtensions()             ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Floatingpoint Extensions&quot;);
 402     if (has_CryptoExt3()               ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Crypto Extensions 3&quot;);
 403     if (has_CryptoExt4()               ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Crypto Extensions 4&quot;);
 404     // EC12
 405     if (has_MiscInstrExt()             ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Miscelaneous Instruction Extensions&quot;);
 406     if (has_ExecutionHint()            ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Execution Hints (branch prediction)&quot;);
 407     if (has_ProcessorAssist()          ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Processor Assists&quot;);
 408     if (has_LoadAndTrap()              ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Load and Trap&quot;);
 409     if (has_TxMem()                    ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Transactional Memory&quot;);
 410     if (has_InterlockedAccessV2()      ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;InterlockedAccess V2 (fast)&quot;);
 411     if (has_DFPZonedConversion()       ) tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;DFP Zoned Conversions&quot;);
 412     // z13
 413     if (has_LoadStoreConditional2()    ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Load/Store Conditional 2&quot;);
 414     if (has_CryptoExt5()               ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Crypto Extensions 5&quot;);
 415     if (has_DFPPackedConversion()      ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;DFP Packed Conversions&quot;);
 416     if (has_VectorFacility()           ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;Vector Facility&quot;);
 417     // test switches
 418     if (has_TestFeature1Impl()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;TestFeature1Impl&quot;);
 419     if (has_TestFeature2Impl()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;TestFeature2Impl&quot;);
 420     if (has_TestFeature4Impl()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;TestFeature4Impl&quot;);
 421     if (has_TestFeature8Impl()         ) tty-&gt;print_cr(&quot;available: %s&quot;, &quot;TestFeature8Impl&quot;);
 422 
 423     if (has_Crypto()) {
 424       tty-&gt;cr();
 425       tty-&gt;print_cr(&quot;detailed availability of %s capabilities:&quot;, &quot;CryptoFacility&quot;);
 426       if (test_feature_bit(&amp;_cipher_features[0], -1, 2*Cipher::_featureBits)) {
 427         tty-&gt;cr();
 428         tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Message Cipher Functions&quot;);
 429       }
 430       if (test_feature_bit(&amp;_cipher_features[0], -1, (int)Cipher::_featureBits)) {
 431         tty-&gt;print_cr(&quot;    available Crypto Features of KM  (Cipher Message):&quot;);
 432         for (unsigned int i = 0; i &lt; Cipher::_featureBits; i++) {
 433           if (test_feature_bit(&amp;_cipher_features[0], i, (int)Cipher::_featureBits)) {
 434             switch (i) {
 435               case Cipher::_Query:              tty-&gt;print_cr(&quot;      available: KM   Query&quot;);                  break;
 436               case Cipher::_DEA:                tty-&gt;print_cr(&quot;      available: KM   DEA&quot;);                    break;
 437               case Cipher::_TDEA128:            tty-&gt;print_cr(&quot;      available: KM   TDEA-128&quot;);               break;
 438               case Cipher::_TDEA192:            tty-&gt;print_cr(&quot;      available: KM   TDEA-192&quot;);               break;
 439               case Cipher::_EncryptedDEA:       tty-&gt;print_cr(&quot;      available: KM   Encrypted DEA&quot;);          break;
 440               case Cipher::_EncryptedDEA128:    tty-&gt;print_cr(&quot;      available: KM   Encrypted DEA-128&quot;);      break;
 441               case Cipher::_EncryptedDEA192:    tty-&gt;print_cr(&quot;      available: KM   Encrypted DEA-192&quot;);      break;
 442               case Cipher::_AES128:             tty-&gt;print_cr(&quot;      available: KM   AES-128&quot;);                break;
 443               case Cipher::_AES192:             tty-&gt;print_cr(&quot;      available: KM   AES-192&quot;);                break;
 444               case Cipher::_AES256:             tty-&gt;print_cr(&quot;      available: KM   AES-256&quot;);                break;
 445               case Cipher::_EnccryptedAES128:   tty-&gt;print_cr(&quot;      available: KM   Encrypted-AES-128&quot;);      break;
 446               case Cipher::_EnccryptedAES192:   tty-&gt;print_cr(&quot;      available: KM   Encrypted-AES-192&quot;);      break;
 447               case Cipher::_EnccryptedAES256:   tty-&gt;print_cr(&quot;      available: KM   Encrypted-AES-256&quot;);      break;
 448               case Cipher::_XTSAES128:          tty-&gt;print_cr(&quot;      available: KM   XTS-AES-128&quot;);            break;
 449               case Cipher::_XTSAES256:          tty-&gt;print_cr(&quot;      available: KM   XTS-AES-256&quot;);            break;
 450               case Cipher::_EncryptedXTSAES128: tty-&gt;print_cr(&quot;      available: KM   XTS-Encrypted-AES-128&quot;);  break;
 451               case Cipher::_EncryptedXTSAES256: tty-&gt;print_cr(&quot;      available: KM   XTS-Encrypted-AES-256&quot;);  break;
 452               default: tty-&gt;print_cr(&quot;      available: unknown KM  code %d&quot;, i);      break;
 453             }
 454           }
 455         }
 456       }
 457       if (test_feature_bit(&amp;_cipher_features[2], -1, (int)Cipher::_featureBits)) {
 458         tty-&gt;print_cr(&quot;    available Crypto Features of KMC (Cipher Message with Chaining):&quot;);
 459         for (unsigned int i = 0; i &lt; Cipher::_featureBits; i++) {
 460             if (test_feature_bit(&amp;_cipher_features[2], i, (int)Cipher::_featureBits)) {
 461             switch (i) {
 462               case Cipher::_Query:              tty-&gt;print_cr(&quot;      available: KMC  Query&quot;);                  break;
 463               case Cipher::_DEA:                tty-&gt;print_cr(&quot;      available: KMC  DEA&quot;);                    break;
 464               case Cipher::_TDEA128:            tty-&gt;print_cr(&quot;      available: KMC  TDEA-128&quot;);               break;
 465               case Cipher::_TDEA192:            tty-&gt;print_cr(&quot;      available: KMC  TDEA-192&quot;);               break;
 466               case Cipher::_EncryptedDEA:       tty-&gt;print_cr(&quot;      available: KMC  Encrypted DEA&quot;);          break;
 467               case Cipher::_EncryptedDEA128:    tty-&gt;print_cr(&quot;      available: KMC  Encrypted DEA-128&quot;);      break;
 468               case Cipher::_EncryptedDEA192:    tty-&gt;print_cr(&quot;      available: KMC  Encrypted DEA-192&quot;);      break;
 469               case Cipher::_AES128:             tty-&gt;print_cr(&quot;      available: KMC  AES-128&quot;);                break;
 470               case Cipher::_AES192:             tty-&gt;print_cr(&quot;      available: KMC  AES-192&quot;);                break;
 471               case Cipher::_AES256:             tty-&gt;print_cr(&quot;      available: KMC  AES-256&quot;);                break;
 472               case Cipher::_EnccryptedAES128:   tty-&gt;print_cr(&quot;      available: KMC  Encrypted-AES-128&quot;);      break;
 473               case Cipher::_EnccryptedAES192:   tty-&gt;print_cr(&quot;      available: KMC  Encrypted-AES-192&quot;);      break;
 474               case Cipher::_EnccryptedAES256:   tty-&gt;print_cr(&quot;      available: KMC  Encrypted-AES-256&quot;);      break;
 475               case Cipher::_PRNG:               tty-&gt;print_cr(&quot;      available: KMC  PRNG&quot;);                   break;
 476               default: tty-&gt;print_cr(&quot;      available: unknown KMC code %d&quot;, i);      break;
 477             }
 478           }
 479         }
 480       }
 481 
 482       if (test_feature_bit(&amp;_msgdigest_features[0], -1, 2*MsgDigest::_featureBits)) {
 483         tty-&gt;cr();
 484         tty-&gt;print_cr(&quot;  available: %s&quot;, &quot;Message Digest Functions for SHA&quot;);
 485       }
 486       if (test_feature_bit(&amp;_msgdigest_features[0], -1, (int)MsgDigest::_featureBits)) {
 487         tty-&gt;print_cr(&quot;    available Features of KIMD (Msg Digest):&quot;);
 488         for (unsigned int i = 0; i &lt; MsgDigest::_featureBits; i++) {
 489             if (test_feature_bit(&amp;_msgdigest_features[0], i, (int)MsgDigest::_featureBits)) {
 490             switch (i) {
 491               case MsgDigest::_Query:  tty-&gt;print_cr(&quot;      available: KIMD Query&quot;);   break;
 492               case MsgDigest::_SHA1:   tty-&gt;print_cr(&quot;      available: KIMD SHA-1&quot;);   break;
 493               case MsgDigest::_SHA256: tty-&gt;print_cr(&quot;      available: KIMD SHA-256&quot;); break;
 494               case MsgDigest::_SHA512: tty-&gt;print_cr(&quot;      available: KIMD SHA-512&quot;); break;
 495               case MsgDigest::_GHASH:  tty-&gt;print_cr(&quot;      available: KIMD GHASH&quot;);   break;
 496               default: tty-&gt;print_cr(&quot;      available: unknown code %d&quot;, i);  break;
 497             }
 498           }
 499         }
 500       }
 501       if (test_feature_bit(&amp;_msgdigest_features[2], -1, (int)MsgDigest::_featureBits)) {
 502         tty-&gt;print_cr(&quot;    available Features of KLMD (Msg Digest):&quot;);
 503         for (unsigned int i = 0; i &lt; MsgDigest::_featureBits; i++) {
 504           if (test_feature_bit(&amp;_msgdigest_features[2], i, (int)MsgDigest::_featureBits)) {
 505             switch (i) {
 506               case MsgDigest::_Query:  tty-&gt;print_cr(&quot;      available: KLMD Query&quot;);   break;
 507               case MsgDigest::_SHA1:   tty-&gt;print_cr(&quot;      available: KLMD SHA-1&quot;);   break;
 508               case MsgDigest::_SHA256: tty-&gt;print_cr(&quot;      available: KLMD SHA-256&quot;); break;
 509               case MsgDigest::_SHA512: tty-&gt;print_cr(&quot;      available: KLMD SHA-512&quot;); break;
 510               default: tty-&gt;print_cr(&quot;      available: unknown code %d&quot;, i);  break;
 511             }
 512           }
 513         }
 514       }
 515     }
 516     if (ContendedPaddingWidth &gt; 0) {
 517       tty-&gt;cr();
 518       tty-&gt;print_cr(&quot;ContendedPaddingWidth &quot; INTX_FORMAT, ContendedPaddingWidth);
 519     }
 520   }
 521 }
 522 
 523 void VM_Version::print_platform_virtualization_info(outputStream* st) {
 524   // /proc/sysinfo contains interesting information about
 525   // - LPAR
 526   // - whole &quot;Box&quot; (CPUs )
 527   // - z/VM / KVM (VM&lt;nn&gt;); this is not available in an LPAR-only setup
 528   const char* kw[] = { &quot;LPAR&quot;, &quot;CPUs&quot;, &quot;VM&quot;, NULL };
 529   const char* info_file = &quot;/proc/sysinfo&quot;;
 530 
 531   if (!print_matching_lines_from_file(info_file, st, kw)) {
 532     st-&gt;print_cr(&quot;  &lt;%s Not Available&gt;&quot;, info_file);
 533   }
 534 }
 535 
 536 void VM_Version::print_features() {
 537   print_features_internal(&quot;Version:&quot;);
 538 }
 539 
 540 void VM_Version::reset_features(bool reset) {
 541   if (reset) {
 542     for (unsigned int i = 0; i &lt; _features_buffer_len; i++) {
 543       VM_Version::_features[i] = 0;
 544     }
 545   }
 546 }
 547 
 548 void VM_Version::set_features_z900(bool reset) {
 549   reset_features(reset);
 550 
 551   set_has_long_displacement();
 552   set_has_ETF2();
 553 }
 554 
 555 void VM_Version::set_features_z990(bool reset) {
 556   reset_features(reset);
 557 
 558   set_features_z900(false);
 559   set_has_ETF3();
 560   set_has_long_displacement_fast();
 561   set_has_HFPMultiplyAndAdd();
 562 }
 563 
 564 void VM_Version::set_features_z9(bool reset) {
 565   reset_features(reset);
 566 
 567   set_features_z990(false);
 568   set_has_StoreFacilityListExtended();
 569   // set_has_Crypto();   // Do not set, crypto features must be retrieved separately.
 570   set_has_ETF2Enhancements();
 571   set_has_ETF3Enhancements();
 572   set_has_extended_immediate();
 573   set_has_StoreClockFast();
 574   set_has_HFPUnnormalized();
 575 }
 576 
 577 void VM_Version::set_features_z10(bool reset) {
 578   reset_features(reset);
 579 
 580   set_features_z9(false);
 581   set_has_CompareSwapStore();
 582   set_has_RelativeLoadStore();
 583   set_has_CompareBranch();
 584   set_has_CompareTrap();
 585   set_has_MultiplySingleImm32();
 586   set_has_Prefetch();
 587   set_has_MoveImmToMem();
 588   set_has_MemWithImmALUOps();
 589   set_has_ExecuteExtensions();
 590   set_has_FPSupportEnhancements();
 591   set_has_DecimalFloatingPoint();
 592   set_has_ExtractCPUtime();
 593   set_has_CryptoExt3();
 594 }
 595 
 596 void VM_Version::set_features_z196(bool reset) {
 597   reset_features(reset);
 598 
 599   set_features_z10(false);
 600   set_has_InterlockedAccessV1();
 601   set_has_PopCount();
 602   set_has_LoadStoreConditional();
 603   set_has_HighWordInstr();
 604   set_has_FastSync();
 605   set_has_FPExtensions();
 606   set_has_DistinctOpnds();
 607   set_has_CryptoExt4();
 608 }
 609 
 610 void VM_Version::set_features_ec12(bool reset) {
 611   reset_features(reset);
 612 
 613   set_features_z196(false);
 614   set_has_MiscInstrExt();
 615   set_has_InterlockedAccessV2();
 616   set_has_LoadAndALUAtomicV2();
 617   set_has_TxMem();
 618 }
 619 
 620 void VM_Version::set_features_z13(bool reset) {
 621   reset_features(reset);
 622 
 623   set_features_ec12(false);
 624   set_has_LoadStoreConditional2();
 625   set_has_CryptoExt5();
 626   set_has_VectorFacility();
 627 }
 628 
 629 void VM_Version::set_features_from(const char* march) {
 630   bool err = false;
 631   bool prt = false;
 632 
 633   if ((march != NULL) &amp;&amp; (march[0] != &#39;\0&#39;)) {
 634     const int buf_len = 16;
 635     const int hdr_len =  5;
 636     char buf[buf_len];
 637     if (strlen(march) &gt;= hdr_len) {
 638       memcpy(buf, march, hdr_len);
 639       buf[hdr_len] = &#39;\00&#39;;
 640     } else {
 641       buf[0]       = &#39;\00&#39;;
 642     }
 643 
 644     if (!strcmp(march, &quot;z900&quot;)) {
 645       set_features_z900();
 646     } else if (!strcmp(march, &quot;z990&quot;)) {
 647         set_features_z990();
 648     } else if (!strcmp(march, &quot;z9&quot;)) {
 649         set_features_z9();
 650     } else if (!strcmp(march, &quot;z10&quot;)) {
 651         set_features_z10();
 652     } else if (!strcmp(march, &quot;z196&quot;)) {
 653         set_features_z196();
 654     } else if (!strcmp(march, &quot;ec12&quot;)) {
 655         set_features_ec12();
 656     } else if (!strcmp(march, &quot;z13&quot;)) {
 657         set_features_z13();
 658     } else if (!strcmp(buf, &quot;ztest&quot;)) {
 659       assert(!has_TestFeaturesImpl(), &quot;possible facility list flag conflict&quot;);
 660       if (strlen(march) &gt; hdr_len) {
 661         int itest = 0;
 662         if ((strlen(march)-hdr_len) &gt;= buf_len) err = true;
 663         if (!err) {
 664           memcpy(buf, &amp;march[hdr_len], strlen(march)-hdr_len);
 665           buf[strlen(march)-hdr_len] = &#39;\00&#39;;
 666           for (size_t i = 0; !err &amp;&amp; (i &lt; strlen(buf)); i++) {
 667             itest = itest*10 + buf[i]-&#39;0&#39;;
 668             err   = err || ((buf[i]-&#39;0&#39;) &lt; 0) || ((buf[i]-&#39;0&#39;) &gt; 9) || (itest &gt; 15);
 669           }
 670         }
 671         if (!err) {
 672           prt = true;
 673           if (itest &amp; 0x01) { set_has_TestFeature1Impl(); }
 674           if (itest &amp; 0x02) { set_has_TestFeature2Impl(); }
 675           if (itest &amp; 0x04) { set_has_TestFeature4Impl(); }
 676           if (itest &amp; 0x08) { set_has_TestFeature8Impl(); }
 677         }
 678       } else {
 679         prt = true;
 680         set_has_TestFeature1Impl();
 681         set_has_TestFeature2Impl();
 682         set_has_TestFeature4Impl();
 683         set_has_TestFeature8Impl();
 684       }
 685     } else {
 686       err = true;
 687     }
 688     if (!err) {
 689       set_features_string();
 690       if (prt || PrintAssembly) {
 691         print_features_internal(&quot;CPU Version as set by cmdline option:&quot;, prt);
 692       }
 693     } else {
 694       tty-&gt;print_cr(&quot;***Warning: Unsupported ProcessorArchitecture: %s, internal settings left undisturbed.&quot;, march);
 695     }
 696   }
 697 
 698 }
 699 
 700 static long (*getFeatures)(unsigned long*, int, int) = NULL;
 701 
 702 void VM_Version::set_getFeatures(address entryPoint) {
 703   if (getFeatures == NULL) {
 704     getFeatures = (long(*)(unsigned long*, int, int))entryPoint;
 705   }
 706 }
 707 
 708 long VM_Version::call_getFeatures(unsigned long* buffer, int buflen, int functionCode) {
 709   VM_Version::_is_determine_features_test_running = true;
 710   long functionResult = (*getFeatures)(buffer, buflen, functionCode);
 711   VM_Version::_is_determine_features_test_running = false;
 712   return functionResult;
 713 }
 714 
 715 // Helper function for &quot;extract cache attribute&quot; instruction.
 716 int VM_Version::calculate_ECAG_functionCode(unsigned int attributeIndication,
 717                                             unsigned int levelIndication,
 718                                             unsigned int typeIndication) {
 719   return (attributeIndication&lt;&lt;4) | (levelIndication&lt;&lt;1) | typeIndication;
 720 }
 721 
 722 void VM_Version::determine_features() {
 723 
 724   const int      cbuf_size = _code_buffer_len;
 725   const int      buf_len   = _features_buffer_len;
 726 
 727   // Allocate code buffer space for the detection code.
 728   ResourceMark    rm;
 729   CodeBuffer      cbuf(&quot;determine CPU features&quot;, cbuf_size, 0);
 730   MacroAssembler* a = new MacroAssembler(&amp;cbuf);
 731 
 732   // Emit code.
 733   set_getFeatures(a-&gt;pc());
 734   address   code = a-&gt;pc();
 735 
 736   // Try STFLE. Possible INVOP will cause defaults to be used.
 737   Label    getFEATURES;
 738   Label    getCPUFEATURES;                   // fcode = -1 (cache)
 739   Label    getCIPHERFEATURES;                // fcode = -2 (cipher)
 740   Label    getMSGDIGESTFEATURES;             // fcode = -3 (SHA)
 741   Label    getVECTORFEATURES;                // fcode = -4 (OS support for vector instructions)
 742   Label    errRTN;
 743   a-&gt;z_ltgfr(Z_R0, Z_ARG2);                  // Buf len to r0 and test.
 744   a-&gt;z_brl(getFEATURES);                     // negative -&gt; Get machine features not covered by facility list.
 745   a-&gt;z_lghi(Z_R1,0);
 746   a-&gt;z_brz(errRTN);                          // zero -&gt; Function code currently not used, indicate &quot;aborted&quot;.
 747 
 748   a-&gt;z_aghi(Z_R0, -1);
 749   a-&gt;z_stfle(0, Z_ARG1);
 750   a-&gt;z_lg(Z_R1, 0, Z_ARG1);                  // Get first DW of facility list.
 751   a-&gt;z_lgr(Z_RET, Z_R0);                     // Calculate rtn value for success.
 752   a-&gt;z_la(Z_RET, 1, Z_RET);
 753   a-&gt;z_brnz(errRTN);                         // Instr failed if non-zero CC.
 754   a-&gt;z_ltgr(Z_R1, Z_R1);                     // Instr failed if first DW == 0.
 755   a-&gt;z_bcr(Assembler::bcondNotZero, Z_R14);  // Successful return.
 756 
 757   a-&gt;bind(errRTN);
 758   a-&gt;z_lngr(Z_RET, Z_RET);
 759   a-&gt;z_ltgr(Z_R1, Z_R1);
 760   a-&gt;z_bcr(Assembler::bcondNotZero, Z_R14);  // Return &quot;buffer too small&quot;.
 761   a-&gt;z_xgr(Z_RET, Z_RET);
 762   a-&gt;z_br(Z_R14);                            // Return &quot;operation aborted&quot;.
 763 
 764   a-&gt;bind(getFEATURES);
 765   a-&gt;z_cghi(Z_R0, -1);                       // -1: Extract CPU attributes, currently: cache layout only.
 766   a-&gt;z_bre(getCPUFEATURES);
 767   a-&gt;z_cghi(Z_R0, -2);                       // -2: Extract detailed crypto capabilities (cipher instructions).
 768   a-&gt;z_bre(getCIPHERFEATURES);
 769   a-&gt;z_cghi(Z_R0, -3);                       // -3: Extract detailed crypto capabilities (msg digest instructions).
 770   a-&gt;z_bre(getMSGDIGESTFEATURES);
 771   a-&gt;z_cghi(Z_R0, -4);                       // -4: Verify vector instruction availability (OS support).
 772   a-&gt;z_bre(getVECTORFEATURES);
 773 
 774   a-&gt;z_xgr(Z_RET, Z_RET);                    // Not a valid function code.
 775   a-&gt;z_br(Z_R14);                            // Return &quot;operation aborted&quot;.
 776 
 777   // Try KIMD/KLMD query function to get details about msg digest (secure hash, SHA) instructions.
 778   a-&gt;bind(getMSGDIGESTFEATURES);
 779   a-&gt;z_lghi(Z_R0,(int)MsgDigest::_Query);    // query function code
 780   a-&gt;z_lgr(Z_R1,Z_R2);                       // param block addr, 2*16 bytes min size
 781   a-&gt;z_kimd(Z_R2,Z_R2);                      // Get available KIMD functions (bit pattern in param blk).
 782   a-&gt;z_la(Z_R1,16,Z_R1);                     // next param block addr
 783   a-&gt;z_klmd(Z_R2,Z_R2);                      // Get available KLMD functions (bit pattern in param blk).
 784   a-&gt;z_lghi(Z_RET,4);
 785   a-&gt;z_br(Z_R14);
 786 
 787   // Try KM/KMC query function to get details about crypto instructions.
 788   a-&gt;bind(getCIPHERFEATURES);
 789   a-&gt;z_lghi(Z_R0,(int)Cipher::_Query);       // query function code
 790   a-&gt;z_lgr(Z_R1,Z_R2);                       // param block addr, 2*16 bytes min size (KIMD/KLMD output)
 791   a-&gt;z_km(Z_R2,Z_R2);                        // get available KM functions
 792   a-&gt;z_la(Z_R1,16,Z_R1);                     // next param block addr
 793   a-&gt;z_kmc(Z_R2,Z_R2);                       // get available KMC functions
 794   a-&gt;z_lghi(Z_RET,4);
 795   a-&gt;z_br(Z_R14);
 796 
 797   // Use EXTRACT CPU ATTRIBUTE instruction to get information about cache layout.
 798   a-&gt;bind(getCPUFEATURES);
 799   a-&gt;z_xgr(Z_R0,Z_R0);                       // as recommended in instruction documentation
 800   a-&gt;z_ecag(Z_RET,Z_R0,0,Z_ARG3);            // Extract information as requested by Z_ARG1 contents.
 801   a-&gt;z_br(Z_R14);
 802 
 803   // Use a vector instruction to verify OS support. Will fail with SIGFPE if OS support is missing.
 804   a-&gt;bind(getVECTORFEATURES);
 805   a-&gt;z_vtm(Z_V0,Z_V0);                       // non-destructive vector instruction. Will cause SIGFPE if not supported.
 806   a-&gt;z_br(Z_R14);
 807 
 808   address code_end = a-&gt;pc();
 809   a-&gt;flush();
 810 
 811   cbuf.insts()-&gt;set_end(code_end);
 812 
 813   // Print the detection code.
 814   bool printVerbose = Verbose || PrintAssembly || PrintStubCode;
 815   if (printVerbose) {
 816     ttyLocker ttyl;
 817     tty-&gt;print_cr(&quot;Decoding CPU feature detection stub at &quot; INTPTR_FORMAT &quot; before execution:&quot;, p2i(code));
 818     tty-&gt;print_cr(&quot;Stub length is %ld bytes, codebuffer reserves %d bytes, %ld bytes spare.&quot;,
 819                   code_end-code, cbuf_size, cbuf_size-(code_end-code));
 820 
 821     // Use existing decode function. This enables the [MachCode] format which is needed to DecodeErrorFile.
 822     Disassembler::decode(&amp;cbuf, code, code_end, tty);
 823   }
 824 
 825   // Prepare for detection code execution and clear work buffer.
 826   _nfeatures        = 0;
 827   _ncipher_features = 0;
 828   unsigned long  buffer[buf_len];
 829 
 830   for (int i = 0; i &lt; buf_len; i++) {
 831     buffer[i] = 0L;
 832   }
 833 
 834   // execute code
 835   // Illegal instructions will be replaced by 0 in signal handler.
 836   // In case of problems, call_getFeatures will return a not-positive result.
 837   long used_len = call_getFeatures(buffer, buf_len, 0);
 838 
 839   bool ok;
 840   if (used_len == 1) {
 841     ok = true;
 842   } else if (used_len &gt; 1) {
 843     unsigned int used_lenU = (unsigned int)used_len;
 844     ok = true;
 845     for (unsigned int i = 1; i &lt; used_lenU; i++) {
 846       ok = ok &amp;&amp; (buffer[i] == 0L);
 847     }
 848     if (printVerbose &amp;&amp; !ok) {
 849       bool compact = false;
 850       tty-&gt;print_cr(&quot;Note: feature list has %d (i.e. more than one) array elements.&quot;, used_lenU);
 851       if (compact) {
 852         tty-&gt;print(&quot;non-zero feature list elements:&quot;);
 853         for (unsigned int i = 0; i &lt; used_lenU; i++) {
 854           tty-&gt;print(&quot;  [%d]: 0x%16.16lx&quot;, i, buffer[i]);
 855         }
 856         tty-&gt;cr();
 857       } else {
 858         for (unsigned int i = 0; i &lt; used_lenU; i++) {
 859           tty-&gt;print_cr(&quot;non-zero feature list[%d]: 0x%16.16lx&quot;, i, buffer[i]);
 860         }
 861       }
 862 
 863       if (compact) {
 864         tty-&gt;print_cr(&quot;Active features (compact view):&quot;);
 865         for (unsigned int k = 0; k &lt; used_lenU; k++) {
 866           tty-&gt;print_cr(&quot;  buffer[%d]:&quot;, k);
 867           for (unsigned int j = k*sizeof(long); j &lt; (k+1)*sizeof(long); j++) {
 868             bool line = false;
 869             for (unsigned int i = j*8; i &lt; (j+1)*8; i++) {
 870               bool bit  = test_feature_bit(buffer, i, used_lenU*sizeof(long)*8);
 871               if (bit) {
 872                 if (!line) {
 873                   tty-&gt;print(&quot;    byte[%d]:&quot;, j);
 874                   line = true;
 875                 }
 876                 tty-&gt;print(&quot;  [%3.3d]&quot;, i);
 877               }
 878             }
 879             if (line) {
 880               tty-&gt;cr();
 881             }
 882           }
 883         }
 884       } else {
 885         tty-&gt;print_cr(&quot;Active features (full view):&quot;);
 886         for (unsigned int k = 0; k &lt; used_lenU; k++) {
 887           tty-&gt;print_cr(&quot;  buffer[%d]:&quot;, k);
 888           for (unsigned int j = k*sizeof(long); j &lt; (k+1)*sizeof(long); j++) {
 889             tty-&gt;print(&quot;    byte[%d]:&quot;, j);
 890             for (unsigned int i = j*8; i &lt; (j+1)*8; i++) {
 891               bool bit  = test_feature_bit(buffer, i, used_lenU*sizeof(long)*8);
 892               if (bit) {
 893                 tty-&gt;print(&quot;  [%3.3d]&quot;, i);
 894               } else {
 895                 tty-&gt;print(&quot;       &quot;);
 896               }
 897             }
 898             tty-&gt;cr();
 899           }
 900         }
 901       }
 902     }
 903     ok = true;
 904   } else {  // No features retrieved if we reach here. Buffer too short or instr not available.
 905     if (used_len &lt; 0) {
 906       ok = false;
 907       if (printVerbose) {
 908         tty-&gt;print_cr(&quot;feature list buffer[%d] too short, required: buffer[%ld]&quot;, buf_len, -used_len);
 909       }
 910     } else {
 911       if (printVerbose) {
 912         tty-&gt;print_cr(&quot;feature list could not be retrieved. Running on z900 or z990? Trying to find out...&quot;);
 913       }
 914       used_len = call_getFeatures(buffer, 0, 0);       // Must provide at least two DW buffer elements!!!!
 915 
 916       ok = used_len &gt; 0;
 917       if (ok) {
 918         if (buffer[1]*10 &lt; buffer[0]) {
 919           set_features_z900();
 920         } else {
 921           set_features_z990();
 922         }
 923 
 924         if (printVerbose) {
 925           tty-&gt;print_cr(&quot;Note: high-speed long displacement test used %ld iterations.&quot;, used_len);
 926           tty-&gt;print_cr(&quot;      Positive displacement loads took %8.8lu microseconds.&quot;, buffer[1]);
 927           tty-&gt;print_cr(&quot;      Negative displacement loads took %8.8lu microseconds.&quot;, buffer[0]);
 928           if (has_long_displacement_fast()) {
 929             tty-&gt;print_cr(&quot;      assuming high-speed long displacement IS     available.&quot;);
 930           } else {
 931             tty-&gt;print_cr(&quot;      assuming high-speed long displacement is NOT available.&quot;);
 932           }
 933         }
 934       } else {
 935         if (printVerbose) {
 936           tty-&gt;print_cr(&quot;Note: high-speed long displacement test was not successful.&quot;);
 937           tty-&gt;print_cr(&quot;      assuming long displacement is NOT available.&quot;);
 938         }
 939       }
 940       return; // Do not copy buffer to _features, no test for cipher features.
 941     }
 942   }
 943 
 944   if (ok) {
 945     // Fill features buffer.
 946     // Clear work buffer.
 947     for (int i = 0; i &lt; buf_len; i++) {
 948       _features[i]           = buffer[i];
 949       _cipher_features[i]    = 0;
 950       _msgdigest_features[i] = 0;
 951       buffer[i]              = 0L;
 952     }
 953     _nfeatures = used_len;
 954   } else {
 955     for (int i = 0; i &lt; buf_len; i++) {
 956       _features[i]           = 0;
 957       _cipher_features[i]    = 0;
 958       _msgdigest_features[i] = 0;
 959       buffer[i]              = 0L;
 960     }
 961     _nfeatures = 0;
 962   }
 963 
 964   if (has_VectorFacility()) {
 965     // Verify that feature can actually be used. OS support required.
 966     call_getFeatures(buffer, -4, 0);
 967     if (printVerbose) {
 968       ttyLocker ttyl;
 969       if (has_VectorFacility()) {
 970         tty-&gt;print_cr(&quot;  Vector Facility has been verified to be supported by OS&quot;);
 971       } else {
 972         tty-&gt;print_cr(&quot;  Vector Facility has been disabled - not supported by OS&quot;);
 973       }
 974     }
 975   }
 976 
 977   // Extract Crypto Facility details.
 978   if (has_Crypto()) {
 979     // Get cipher features.
 980     used_len = call_getFeatures(buffer, -2, 0);
 981     for (int i = 0; i &lt; buf_len; i++) {
 982       _cipher_features[i] = buffer[i];
 983     }
 984     _ncipher_features = used_len;
 985 
 986     // Get msg digest features.
 987     used_len = call_getFeatures(buffer, -3, 0);
 988     for (int i = 0; i &lt; buf_len; i++) {
 989       _msgdigest_features[i] = buffer[i];
 990     }
 991     _nmsgdigest_features = used_len;
 992   }
 993 
 994   static int   levelProperties[_max_cache_levels];     // All property indications per level.
 995   static int   levelScope[_max_cache_levels];          // private/shared
 996   static const char* levelScopeText[4] = {&quot;No cache   &quot;,
 997                                           &quot;CPU private&quot;,
 998                                           &quot;shared     &quot;,
 999                                           &quot;reserved   &quot;};
1000 
1001   static int   levelType[_max_cache_levels];           // D/I/mixed
1002   static const char* levelTypeText[4]  = {&quot;separate D and I caches&quot;,
1003                                           &quot;I cache only           &quot;,
1004                                           &quot;D-cache only           &quot;,
1005                                           &quot;combined D/I cache     &quot;};
1006 
1007   static unsigned int levelReserved[_max_cache_levels];    // reserved property bits
1008   static unsigned int levelLineSize[_max_cache_levels];
1009   static unsigned int levelTotalSize[_max_cache_levels];
1010   static unsigned int levelAssociativity[_max_cache_levels];
1011 
1012 
1013   // Extract Cache Layout details.
1014   if (has_ExtractCPUAttributes() &amp;&amp; printVerbose) { // For information only, as of now.
1015     bool         lineSize_mismatch;
1016     bool         print_something;
1017     long         functionResult;
1018     unsigned int attributeIndication = 0; // 0..15
1019     unsigned int levelIndication     = 0; // 0..8
1020     unsigned int typeIndication      = 0; // 0..1 (D-Cache, I-Cache)
1021     int          functionCode        = calculate_ECAG_functionCode(attributeIndication, levelIndication, typeIndication);
1022 
1023     // Get cache topology.
1024     functionResult = call_getFeatures(buffer, -1, functionCode);
1025 
1026     for (unsigned int i = 0; i &lt; _max_cache_levels; i++) {
1027       if (functionResult &gt; 0) {
1028         int shiftVal          = 8*(_max_cache_levels-(i+1));
1029         levelProperties[i]    = (functionResult &amp; (0xffUL&lt;&lt;shiftVal)) &gt;&gt; shiftVal;
1030         levelReserved[i]      = (levelProperties[i] &amp; 0xf0) &gt;&gt; 4;
1031         levelScope[i]         = (levelProperties[i] &amp; 0x0c) &gt;&gt; 2;
1032         levelType[i]          = (levelProperties[i] &amp; 0x03);
1033       } else {
1034         levelProperties[i]    = 0;
1035         levelReserved[i]      = 0;
1036         levelScope[i]         = 0;
1037         levelType[i]          = 0;
1038       }
1039       levelLineSize[i]      = 0;
1040       levelTotalSize[i]     = 0;
1041       levelAssociativity[i] = 0;
1042     }
1043 
1044     tty-&gt;cr();
1045     tty-&gt;print_cr(&quot;------------------------------------&quot;);
1046     tty-&gt;print_cr(&quot;---  Cache Topology Information  ---&quot;);
1047     tty-&gt;print_cr(&quot;------------------------------------&quot;);
1048     for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1049       tty-&gt;print_cr(&quot;  Cache Level %d: &lt;scope&gt;  %s | &lt;type&gt;  %s&quot;,
1050                     i+1, levelScopeText[levelScope[i]], levelTypeText[levelType[i]]);
1051     }
1052 
1053     // Get D-cache details per level.
1054     _Dcache_lineSize   = 0;
1055     lineSize_mismatch  = false;
1056     print_something    = false;
1057     typeIndication     = 0; // 0..1 (D-Cache, I-Cache)
1058     for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1059       if ((levelType[i] == 0) || (levelType[i] == 2)) {
1060         print_something     = true;
1061 
1062         // Get cache line size of level i.
1063         attributeIndication   = 1;
1064         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1065         levelLineSize[i]      = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1066 
1067         // Get cache total size of level i.
1068         attributeIndication   = 2;
1069         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1070         levelTotalSize[i]     = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1071 
1072         // Get cache associativity of level i.
1073         attributeIndication   = 3;
1074         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1075         levelAssociativity[i] = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1076 
1077         _Dcache_lineSize      = _Dcache_lineSize == 0 ? levelLineSize[i] : _Dcache_lineSize;
1078         lineSize_mismatch     = lineSize_mismatch || (_Dcache_lineSize != levelLineSize[i]);
1079       } else {
1080         levelLineSize[i]      = 0;
1081       }
1082     }
1083 
1084     if (print_something) {
1085       tty-&gt;cr();
1086       tty-&gt;print_cr(&quot;------------------------------------&quot;);
1087       tty-&gt;print_cr(&quot;---  D-Cache Detail Information  ---&quot;);
1088       tty-&gt;print_cr(&quot;------------------------------------&quot;);
1089       if (lineSize_mismatch) {
1090         tty-&gt;print_cr(&quot;WARNING: D-Cache line size mismatch!&quot;);
1091       }
1092       for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1093         if (levelLineSize[i] &gt; 0) {
1094           tty-&gt;print_cr(&quot;  D-Cache Level %d: line size = %4d,  total size = %6dKB,  associativity = %2d&quot;,
1095                         i+1, levelLineSize[i], levelTotalSize[i]/(int)K, levelAssociativity[i]);
1096         }
1097       }
1098     }
1099 
1100     // Get I-cache details per level.
1101     _Icache_lineSize   = 0;
1102     lineSize_mismatch  = false;
1103     print_something    = false;
1104     typeIndication     = 1; // 0..1 (D-Cache, I-Cache)
1105     for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1106       if ((levelType[i] == 0) || (levelType[i] == 1)) {
1107         print_something     = true;
1108 
1109         // Get cache line size of level i.
1110         attributeIndication   = 1;
1111         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1112         levelLineSize[i]      = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1113 
1114         // Get cache total size of level i.
1115         attributeIndication   = 2;
1116         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1117         levelTotalSize[i]     = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1118 
1119         // Get cache associativity of level i.
1120         attributeIndication   = 3;
1121         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1122         levelAssociativity[i] = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1123 
1124         _Icache_lineSize      = _Icache_lineSize == 0 ? levelLineSize[i] : _Icache_lineSize;
1125         lineSize_mismatch     = lineSize_mismatch || (_Icache_lineSize != levelLineSize[i]);
1126       } else {
1127         levelLineSize[i]      = 0;
1128       }
1129     }
1130 
1131     if (print_something) {
1132       tty-&gt;cr();
1133       tty-&gt;print_cr(&quot;------------------------------------&quot;);
1134       tty-&gt;print_cr(&quot;---  I-Cache Detail Information  ---&quot;);
1135       tty-&gt;print_cr(&quot;------------------------------------&quot;);
1136       if (lineSize_mismatch) {
1137         tty-&gt;print_cr(&quot;WARNING: I-Cache line size mismatch!&quot;);
1138       }
1139       for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1140         if (levelLineSize[i] &gt; 0) {
1141           tty-&gt;print_cr(&quot;  I-Cache Level %d: line size = %4d,  total size = %6dKB,  associativity = %2d&quot;,
1142                         i+1, levelLineSize[i], levelTotalSize[i]/(int)K, levelAssociativity[i]);
1143         }
1144       }
1145     }
1146 
1147     // Get D/I-cache details per level.
1148     lineSize_mismatch  = false;
1149     print_something    = false;
1150     typeIndication     = 0; // 0..1 (D-Cache, I-Cache)
1151     for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1152       if (levelType[i] == 3) {
1153         print_something     = true;
1154 
1155         // Get cache line size of level i.
1156         attributeIndication   = 1;
1157         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1158         levelLineSize[i]      = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1159 
1160         // Get cache total size of level i.
1161         attributeIndication   = 2;
1162         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1163         levelTotalSize[i]     = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1164 
1165         // Get cache associativity of level i.
1166         attributeIndication   = 3;
1167         functionCode          = calculate_ECAG_functionCode(attributeIndication, i, typeIndication);
1168         levelAssociativity[i] = (unsigned int)call_getFeatures(buffer, -1, functionCode);
1169 
1170         _Dcache_lineSize      = _Dcache_lineSize == 0 ? levelLineSize[i] : _Dcache_lineSize;
1171         _Icache_lineSize      = _Icache_lineSize == 0 ? levelLineSize[i] : _Icache_lineSize;
1172         lineSize_mismatch     = lineSize_mismatch || (_Dcache_lineSize != levelLineSize[i])
1173                                                   || (_Icache_lineSize != levelLineSize[i]);
1174       } else {
1175         levelLineSize[i]      = 0;
1176       }
1177     }
1178 
1179     if (print_something) {
1180       tty-&gt;cr();
1181       tty-&gt;print_cr(&quot;--------------------------------------&quot;);
1182       tty-&gt;print_cr(&quot;---  D/I-Cache Detail Information  ---&quot;);
1183       tty-&gt;print_cr(&quot;--------------------------------------&quot;);
1184       if (lineSize_mismatch) {
1185         tty-&gt;print_cr(&quot;WARNING: D/I-Cache line size mismatch!&quot;);
1186       }
1187       for (unsigned int i = 0; (i &lt; _max_cache_levels) &amp;&amp; (levelProperties[i] != 0); i++) {
1188         if (levelLineSize[i] &gt; 0) {
1189           tty-&gt;print_cr(&quot;  D/I-Cache Level %d: line size = %4d,  total size = %6dKB,  associativity = %2d&quot;,
1190                         i+1, levelLineSize[i], levelTotalSize[i]/(int)K, levelAssociativity[i]);
1191         }
1192       }
1193     }
1194     tty-&gt;cr();
1195   }
1196   return;
1197 }
1198 
1199 unsigned long VM_Version::z_SIGILL() {
1200   unsigned long   ZeroBuffer = 0;
1201   unsigned long   work;
1202   asm(
1203     &quot;     LA      %[work],%[buffer]  \n\t&quot;   // Load address of buffer.
1204     &quot;     LARL    14,+6              \n\t&quot;   // Load address of faulting instruction.
1205     &quot;     BCR     15,%[work]         \n\t&quot;   // Branch into buffer, execute whatever is in there.
1206     : [buffer]  &quot;+Q&quot;  (ZeroBuffer)   /* outputs   */
1207     , [work]   &quot;=&amp;a&quot;  (work)         /* outputs   */
1208     :                                /* inputs    */
1209     : &quot;cc&quot;                           /* clobbered */
1210  );
1211   return ZeroBuffer;
1212 }
1213 
1214 unsigned long VM_Version::z_SIGSEGV() {
1215   unsigned long   ZeroBuffer = 0;
1216   unsigned long   work;
1217   asm(
1218     &quot;     LG      %[work],%[buffer]  \n\t&quot;   // Load zero address.
1219     &quot;     STG     %[work],0(,%[work])\n\t&quot;   // Store to address zero.
1220     : [buffer]  &quot;+Q&quot;  (ZeroBuffer)   /* outputs   */
1221     , [work]   &quot;=&amp;a&quot;  (work)         /* outputs   */
1222     :                                /* inputs    */
1223     : &quot;cc&quot;                           /* clobbered */
1224  );
1225   return ZeroBuffer;
1226 }
1227 
    </pre>
  </body>
</html>
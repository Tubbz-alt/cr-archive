<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/assembler_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
<a name="1" id="anc1"></a><span class="line-modified">   3  * Copyright (c) 2016, 2017 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #ifndef CPU_S390_ASSEMBLER_S390_HPP
  27 #define CPU_S390_ASSEMBLER_S390_HPP
  28 
  29 #undef  LUCY_DBG
  30 
  31 // Immediate is an abstraction to represent the various immediate
  32 // operands which exist on z/Architecture. Neither this class nor
  33 // instances hereof have an own state. It consists of methods only.
  34 class Immediate {
  35 
  36  public:
  37     static bool is_simm(int64_t x, unsigned int nbits) {
  38       // nbits &lt; 2   --&gt; false
  39       // nbits &gt;= 64 --&gt; true
  40       assert(2 &lt;= nbits &amp;&amp; nbits &lt; 64, &quot;Don&#39;t call, use statically known result.&quot;);
  41       const int64_t min      = -(1L &lt;&lt; (nbits-1));
  42       const int64_t maxplus1 =  (1L &lt;&lt; (nbits-1));
  43       return min &lt;= x &amp;&amp; x &lt; maxplus1;
  44     }
  45     static bool is_simm32(int64_t x) {
  46       return is_simm(x, 32);
  47     }
  48     static bool is_simm20(int64_t x) {
  49       return is_simm(x, 20);
  50     }
  51     static bool is_simm16(int64_t x) {
  52       return is_simm(x, 16);
  53     }
  54     static bool is_simm8(int64_t x) {
  55       return is_simm(x,  8);
  56     }
  57 
  58     // Test if x is within signed immediate range for nbits.
  59     static bool is_uimm(int64_t x, unsigned int nbits) {
  60       // nbits == 0  --&gt; false
  61       // nbits &gt;= 64 --&gt; true
  62       assert(1 &lt;= nbits &amp;&amp; nbits &lt; 64, &quot;don&#39;t call, use statically known result&quot;);
  63       const uint64_t xu       = (unsigned long)x;
  64       const uint64_t maxplus1 = 1UL &lt;&lt; nbits;
  65       return xu &lt; maxplus1; // Unsigned comparison. Negative inputs appear to be very large.
  66     }
  67     static bool is_uimm32(int64_t x) {
  68       return is_uimm(x, 32);
  69     }
  70     static bool is_uimm16(int64_t x) {
  71       return is_uimm(x, 16);
  72     }
  73     static bool is_uimm12(int64_t x) {
  74       return is_uimm(x, 12);
  75     }
  76     static bool is_uimm8(int64_t x) {
  77       return is_uimm(x,  8);
  78     }
  79 };
  80 
  81 // Displacement is an abstraction to represent the various
  82 // displacements which exist with addresses on z/ArchiTecture.
  83 // Neither this class nor instances hereof have an own state. It
  84 // consists of methods only.
  85 class Displacement {
  86 
  87  public: // These tests are used outside the (Macro)Assembler world, e.g. in ad-file.
  88 
  89   static bool is_longDisp(int64_t x) {  // Fits in a 20-bit displacement field.
  90     return Immediate::is_simm20(x);
  91   }
  92   static bool is_shortDisp(int64_t x) { // Fits in a 12-bit displacement field.
  93     return Immediate::is_uimm12(x);
  94   }
  95   static bool is_validDisp(int64_t x) { // Is a valid displacement, regardless of length constraints.
  96     return is_longDisp(x);
  97   }
  98 };
  99 
 100 // RelAddr is an abstraction to represent relative addresses in the
 101 // form they are used on z/Architecture for instructions which access
 102 // their operand with pc-relative addresses. Neither this class nor
 103 // instances hereof have an own state. It consists of methods only.
 104 class RelAddr {
 105 
 106  private: // No public use at all. Solely for (Macro)Assembler.
 107 
 108   static bool is_in_range_of_RelAddr(address target, address pc, bool shortForm) {
 109     // Guard against illegal branch targets, e.g. -1. Occurrences in
 110     // CompiledStaticCall and ad-file. Do not assert (it&#39;s a test
 111     // function!). Just return false in case of illegal operands.
 112     if ((((uint64_t)target) &amp; 0x0001L) != 0) return false;
 113     if ((((uint64_t)pc)     &amp; 0x0001L) != 0) return false;
 114 
 115     if (shortForm) {
 116       return Immediate::is_simm((int64_t)(target-pc), 17); // Relative short addresses can reach +/- 2**16 bytes.
 117     } else {
 118       return Immediate::is_simm((int64_t)(target-pc), 33); // Relative long addresses can reach +/- 2**32 bytes.
 119     }
 120   }
 121 
 122   static bool is_in_range_of_RelAddr16(address target, address pc) {
 123     return is_in_range_of_RelAddr(target, pc, true);
 124   }
 125   static bool is_in_range_of_RelAddr16(ptrdiff_t distance) {
 126     return is_in_range_of_RelAddr((address)distance, 0, true);
 127   }
 128 
 129   static bool is_in_range_of_RelAddr32(address target, address pc) {
 130     return is_in_range_of_RelAddr(target, pc, false);
 131   }
 132   static bool is_in_range_of_RelAddr32(ptrdiff_t distance) {
 133     return is_in_range_of_RelAddr((address)distance, 0, false);
 134   }
 135 
 136   static int pcrel_off(address target, address pc, bool shortForm) {
 137     assert(((uint64_t)target &amp; 0x0001L) == 0, &quot;target of a relative address must be aligned&quot;);
 138     assert(((uint64_t)pc     &amp; 0x0001L) == 0, &quot;origin of a relative address must be aligned&quot;);
 139 
 140     if ((target == NULL) || (target == pc)) {
 141       return 0;  // Yet unknown branch destination.
 142     } else {
 143       guarantee(is_in_range_of_RelAddr(target, pc, shortForm), &quot;target not within reach&quot;);
 144       return (int)((target - pc)&gt;&gt;1);
 145     }
 146   }
 147 
 148   static int pcrel_off16(address target, address pc) {
 149     return pcrel_off(target, pc, true);
 150   }
 151   static int pcrel_off16(ptrdiff_t distance) {
 152     return pcrel_off((address)distance, 0, true);
 153   }
 154 
 155   static int pcrel_off32(address target, address pc) {
 156     return pcrel_off(target, pc, false);
 157   }
 158   static int pcrel_off32(ptrdiff_t distance) {
 159     return pcrel_off((address)distance, 0, false);
 160   }
 161 
 162   static ptrdiff_t inv_pcrel_off16(int offset) {
 163     return ((ptrdiff_t)offset)&lt;&lt;1;
 164   }
 165 
 166   static ptrdiff_t inv_pcrel_off32(int offset) {
 167     return ((ptrdiff_t)offset)&lt;&lt;1;
 168   }
 169 
 170   friend class Assembler;
 171   friend class MacroAssembler;
 172   friend class NativeGeneralJump;
 173 };
 174 
 175 // Address is an abstraction used to represent a memory location
 176 // as passed to Z assembler instructions.
 177 //
 178 // Note: A register location is represented via a Register, not
 179 // via an address for efficiency &amp; simplicity reasons.
 180 class Address {
 181  private:
 182   Register _base;    // Base register.
 183   Register _index;   // Index register
 184   intptr_t _disp;    // Constant displacement.
 185 
 186  public:
 187   Address() :
 188     _base(noreg),
 189     _index(noreg),
 190     _disp(0) {}
 191 
 192   Address(Register base, Register index, intptr_t disp = 0) :
 193     _base(base),
 194     _index(index),
 195     _disp(disp) {}
 196 
 197   Address(Register base, intptr_t disp = 0) :
 198     _base(base),
 199     _index(noreg),
 200     _disp(disp) {}
 201 
 202   Address(Register base, RegisterOrConstant roc, intptr_t disp = 0) :
 203     _base(base),
 204     _index(noreg),
 205     _disp(disp) {
 206     if (roc.is_constant()) _disp += roc.as_constant(); else _index = roc.as_register();
 207   }
 208 
 209 #ifdef ASSERT
 210   // ByteSize is only a class when ASSERT is defined, otherwise it&#39;s an int.
 211   Address(Register base, ByteSize disp) :
 212     _base(base),
 213     _index(noreg),
 214     _disp(in_bytes(disp)) {}
 215 
 216   Address(Register base, Register index, ByteSize disp) :
 217     _base(base),
 218     _index(index),
 219     _disp(in_bytes(disp)) {}
 220 #endif
 221 
 222   // Aborts if disp is a register and base and index are set already.
 223   Address plus_disp(RegisterOrConstant disp) const {
 224     Address a = (*this);
 225     a._disp += disp.constant_or_zero();
 226     if (disp.is_register()) {
 227       if (a._index == noreg) {
 228         a._index = disp.as_register();
 229       } else {
 230         guarantee(_base == noreg, &quot;can not encode&quot;); a._base = disp.as_register();
 231       }
 232     }
 233     return a;
 234   }
 235 
 236   // A call to this is generated by adlc for replacement variable $xxx$$Address.
 237   static Address make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc);
 238 
 239   bool is_same_address(Address a) const {
 240     return _base == a._base &amp;&amp; _index == a._index &amp;&amp; _disp == a._disp;
 241   }
 242 
 243   // testers
 244   bool has_base()  const { return _base  != noreg; }
 245   bool has_index() const { return _index != noreg; }
 246   bool has_disp()  const { return true; } // There is no &quot;invalid&quot; value.
 247 
 248   bool is_disp12() const { return Immediate::is_uimm12(disp()); }
 249   bool is_disp20() const { return Immediate::is_simm20(disp()); }
 250   bool is_RSform()  { return has_base() &amp;&amp; !has_index() &amp;&amp; is_disp12(); }
 251   bool is_RSYform() { return has_base() &amp;&amp; !has_index() &amp;&amp; is_disp20(); }
 252   bool is_RXform()  { return has_base() &amp;&amp;  has_index() &amp;&amp; is_disp12(); }
 253   bool is_RXYform() { return has_base() &amp;&amp;  has_index() &amp;&amp; is_disp20(); }
 254 
 255   bool uses(Register r) { return _base == r || _index == r; };
 256 
 257   // accessors
 258   Register base()      const { return _base; }
 259   Register baseOrR0()  const { assert(_base  != Z_R0, &quot;&quot;); return _base  == noreg ? Z_R0 : _base; }
 260   Register index()     const { return _index; }
 261   Register indexOrR0() const { assert(_index != Z_R0, &quot;&quot;); return _index == noreg ? Z_R0 : _index; }
 262   intptr_t disp() const { return _disp; }
 263   // Specific version for short displacement instructions.
 264   int      disp12() const {
 265     assert(is_disp12(), &quot;displacement out of range for uimm12&quot;);
 266     return _disp;
 267   }
 268   // Specific version for long displacement instructions.
 269   int      disp20() const {
 270     assert(is_disp20(), &quot;displacement out of range for simm20&quot;);
 271     return _disp;
 272   }
 273   intptr_t value() const { return _disp; }
 274 
 275   friend class Assembler;
 276 };
 277 
 278 class AddressLiteral {
 279  private:
 280   address          _address;
 281   RelocationHolder _rspec;
 282 
 283   RelocationHolder rspec_from_rtype(relocInfo::relocType rtype, address addr) {
 284     switch (rtype) {
 285     case relocInfo::external_word_type:
 286       return external_word_Relocation::spec(addr);
 287     case relocInfo::internal_word_type:
 288       return internal_word_Relocation::spec(addr);
 289     case relocInfo::opt_virtual_call_type:
 290       return opt_virtual_call_Relocation::spec();
 291     case relocInfo::static_call_type:
 292       return static_call_Relocation::spec();
 293     case relocInfo::runtime_call_w_cp_type:
 294       return runtime_call_w_cp_Relocation::spec();
 295     case relocInfo::none:
 296       return RelocationHolder();
 297     default:
 298       ShouldNotReachHere();
 299       return RelocationHolder();
 300     }
 301   }
 302 
 303  protected:
 304   // creation
 305   AddressLiteral() : _address(NULL), _rspec(NULL) {}
 306 
 307  public:
 308   AddressLiteral(address addr, RelocationHolder const&amp; rspec)
 309     : _address(addr),
 310       _rspec(rspec) {}
 311 
 312   // Some constructors to avoid casting at the call site.
 313   AddressLiteral(jobject obj, RelocationHolder const&amp; rspec)
 314     : _address((address) obj),
 315       _rspec(rspec) {}
 316 
 317   AddressLiteral(intptr_t value, RelocationHolder const&amp; rspec)
 318     : _address((address) value),
 319       _rspec(rspec) {}
 320 
 321   AddressLiteral(address addr, relocInfo::relocType rtype = relocInfo::none)
 322     : _address((address) addr),
 323     _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 324 
 325   // Some constructors to avoid casting at the call site.
 326   AddressLiteral(address* addr, relocInfo::relocType rtype = relocInfo::none)
 327     : _address((address) addr),
 328     _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 329 
 330   AddressLiteral(bool* addr, relocInfo::relocType rtype = relocInfo::none)
 331     : _address((address) addr),
 332       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 333 
 334   AddressLiteral(const bool* addr, relocInfo::relocType rtype = relocInfo::none)
 335     : _address((address) addr),
 336       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 337 
 338   AddressLiteral(signed char* addr, relocInfo::relocType rtype = relocInfo::none)
 339     : _address((address) addr),
 340       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 341 
 342   AddressLiteral(int* addr, relocInfo::relocType rtype = relocInfo::none)
 343     : _address((address) addr),
 344       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 345 
 346   AddressLiteral(intptr_t addr, relocInfo::relocType rtype = relocInfo::none)
 347     : _address((address) addr),
 348       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 349 
 350   AddressLiteral(intptr_t* addr, relocInfo::relocType rtype = relocInfo::none)
 351     : _address((address) addr),
 352       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 353 
<a name="2" id="anc2"></a><span class="line-removed"> 354   AddressLiteral(oop addr, relocInfo::relocType rtype = relocInfo::none)</span>
<span class="line-removed"> 355     : _address((address) addr),</span>
<span class="line-removed"> 356       _rspec(rspec_from_rtype(rtype, (address) addr)) {}</span>
<span class="line-removed"> 357 </span>
<span class="line-removed"> 358   AddressLiteral(oop* addr, relocInfo::relocType rtype = relocInfo::none)</span>
<span class="line-removed"> 359     : _address((address) addr),</span>
<span class="line-removed"> 360       _rspec(rspec_from_rtype(rtype, (address) addr)) {}</span>
<span class="line-removed"> 361 </span>
 362   AddressLiteral(float* addr, relocInfo::relocType rtype = relocInfo::none)
 363     : _address((address) addr),
 364       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 365 
 366   AddressLiteral(double* addr, relocInfo::relocType rtype = relocInfo::none)
 367     : _address((address) addr),
 368       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 369 
 370   intptr_t value() const { return (intptr_t) _address; }
 371 
 372   const relocInfo::relocType rtype() const { return _rspec.type(); }
 373   const RelocationHolder&amp;    rspec() const { return _rspec; }
 374 
 375   RelocationHolder rspec(int offset) const {
 376     return offset == 0 ? _rspec : _rspec.plus(offset);
 377   }
 378 };
 379 
 380 // Convenience classes
 381 class ExternalAddress: public AddressLiteral {
 382  private:
 383   static relocInfo::relocType reloc_for_target(address target) {
 384     // Sometimes ExternalAddress is used for values which aren&#39;t
 385     // exactly addresses, like the card table base.
 386     // External_word_type can&#39;t be used for values in the first page
 387     // so just skip the reloc in that case.
 388     return external_word_Relocation::can_be_relocated(target) ? relocInfo::external_word_type : relocInfo::none;
 389   }
 390 
 391  public:
 392   ExternalAddress(address target) : AddressLiteral(target, reloc_for_target(          target)) {}
<a name="3" id="anc3"></a><span class="line-removed"> 393   ExternalAddress(oop*    target) : AddressLiteral(target, reloc_for_target((address) target)) {}</span>
 394 };
 395 
 396 // Argument is an abstraction used to represent an outgoing actual
 397 // argument or an incoming formal parameter, whether it resides in
 398 // memory or in a register, in a manner consistent with the
 399 // z/Architecture Application Binary Interface, or ABI. This is often
 400 // referred to as the native or C calling convention.
 401 class Argument {
 402  private:
 403   int _number;
 404   bool _is_in;
 405 
 406  public:
 407   enum {
 408     // Only 5 registers may contain integer parameters.
 409     n_register_parameters = 5,
 410     // Can have up to 4 floating registers.
 411     n_float_register_parameters = 4
 412   };
 413 
 414   // creation
 415   Argument(int number, bool is_in) : _number(number), _is_in(is_in) {}
 416   Argument(int number) : _number(number) {}
 417 
 418   int number() const { return _number; }
 419 
 420   Argument successor() const { return Argument(number() + 1); }
 421 
 422   // Locating register-based arguments:
 423   bool is_register() const { return _number &lt; n_register_parameters; }
 424 
 425   // Locating Floating Point register-based arguments:
 426   bool is_float_register() const { return _number &lt; n_float_register_parameters; }
 427 
 428   FloatRegister as_float_register() const {
 429     assert(is_float_register(), &quot;must be a register argument&quot;);
 430     return as_FloatRegister((number() *2) + 1);
 431   }
 432 
 433   FloatRegister as_double_register() const {
 434     assert(is_float_register(), &quot;must be a register argument&quot;);
 435     return as_FloatRegister((number() *2));
 436   }
 437 
 438   Register as_register() const {
 439     assert(is_register(), &quot;must be a register argument&quot;);
 440     return as_Register(number() + Z_ARG1-&gt;encoding());
 441   }
 442 
 443   // debugging
 444   const char* name() const;
 445 
 446   friend class Assembler;
 447 };
 448 
 449 
 450 // The z/Architecture Assembler: Pure assembler doing NO optimizations
 451 // on the instruction level; i.e., what you write is what you get. The
 452 // Assembler is generating code into a CodeBuffer.
 453 class Assembler : public AbstractAssembler {
 454  protected:
 455 
 456   friend class AbstractAssembler;
 457   friend class AddressLiteral;
 458 
 459   // Code patchers need various routines like inv_wdisp().
 460   friend class NativeInstruction;
 461 #ifndef COMPILER2
 462   friend class NativeGeneralJump;
 463 #endif
 464   friend class Relocation;
 465 
 466  public:
 467 
 468 // Addressing
 469 
 470 // address calculation
 471 #define LA_ZOPC     (unsigned  int)(0x41  &lt;&lt; 24)
 472 #define LAY_ZOPC    (unsigned long)(0xe3L &lt;&lt; 40 | 0x71L)
 473 #define LARL_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 0x00L &lt;&lt; 32)
 474 
 475 
 476 // Data Transfer
 477 
 478 // register to register transfer
 479 #define LR_ZOPC     (unsigned  int)(24 &lt;&lt; 8)
 480 #define LBR_ZOPC    (unsigned  int)(0xb926 &lt;&lt; 16)
 481 #define LHR_ZOPC    (unsigned  int)(0xb927 &lt;&lt; 16)
 482 #define LGBR_ZOPC   (unsigned  int)(0xb906 &lt;&lt; 16)
 483 #define LGHR_ZOPC   (unsigned  int)(0xb907 &lt;&lt; 16)
 484 #define LGFR_ZOPC   (unsigned  int)(0xb914 &lt;&lt; 16)
 485 #define LGR_ZOPC    (unsigned  int)(0xb904 &lt;&lt; 16)
 486 
 487 #define LLHR_ZOPC   (unsigned  int)(0xb995 &lt;&lt; 16)
 488 #define LLGCR_ZOPC  (unsigned  int)(0xb984 &lt;&lt; 16)
 489 #define LLGHR_ZOPC  (unsigned  int)(0xb985 &lt;&lt; 16)
 490 #define LLGTR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 23 &lt;&lt; 16)
 491 #define LLGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 22 &lt;&lt; 16)
 492 
 493 #define LTR_ZOPC    (unsigned  int)(18 &lt;&lt; 8)
 494 #define LTGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 18 &lt;&lt; 16)
 495 #define LTGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 2 &lt;&lt; 16)
 496 
 497 #define LER_ZOPC    (unsigned  int)(56 &lt;&lt; 8)
 498 #define LEDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 68 &lt;&lt; 16)
 499 #define LEXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 70 &lt;&lt; 16)
 500 #define LDEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 4 &lt;&lt; 16)
 501 #define LDR_ZOPC    (unsigned  int)(40 &lt;&lt; 8)
 502 #define LDXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 69 &lt;&lt; 16)
 503 #define LXEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 6 &lt;&lt; 16)
 504 #define LXDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 5 &lt;&lt; 16)
 505 #define LXR_ZOPC    (unsigned  int)(179 &lt;&lt; 24 | 101 &lt;&lt; 16)
 506 #define LTEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 2 &lt;&lt; 16)
 507 #define LTDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 18 &lt;&lt; 16)
 508 #define LTXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 66 &lt;&lt; 16)
 509 
 510 #define LRVR_ZOPC   (unsigned  int)(0xb91f &lt;&lt; 16)
 511 #define LRVGR_ZOPC  (unsigned  int)(0xb90f &lt;&lt; 16)
 512 
 513 #define LDGR_ZOPC   (unsigned  int)(0xb3c1 &lt;&lt; 16)                // z10
 514 #define LGDR_ZOPC   (unsigned  int)(0xb3cd &lt;&lt; 16)                // z10
 515 
 516 #define LOCR_ZOPC   (unsigned  int)(0xb9f2 &lt;&lt; 16)                // z196
 517 #define LOCGR_ZOPC  (unsigned  int)(0xb9e2 &lt;&lt; 16)                // z196
 518 
 519 // immediate to register transfer
 520 #define IIHH_ZOPC   (unsigned  int)(165 &lt;&lt; 24)
 521 #define IIHL_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 1 &lt;&lt; 16)
 522 #define IILH_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 2 &lt;&lt; 16)
 523 #define IILL_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 3 &lt;&lt; 16)
 524 #define IIHF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 8L &lt;&lt; 32)
 525 #define IILF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 9L &lt;&lt; 32)
 526 #define LLIHH_ZOPC  (unsigned  int)(165 &lt;&lt; 24 | 12 &lt;&lt; 16)
 527 #define LLIHL_ZOPC  (unsigned  int)(165 &lt;&lt; 24 | 13 &lt;&lt; 16)
 528 #define LLILH_ZOPC  (unsigned  int)(165 &lt;&lt; 24 | 14 &lt;&lt; 16)
 529 #define LLILL_ZOPC  (unsigned  int)(165 &lt;&lt; 24 | 15 &lt;&lt; 16)
 530 #define LLIHF_ZOPC  (unsigned long)(0xc0L &lt;&lt; 40 | 14L &lt;&lt; 32)
 531 #define LLILF_ZOPC  (unsigned long)(0xc0L &lt;&lt; 40 | 15L &lt;&lt; 32)
 532 #define LHI_ZOPC    (unsigned  int)(167 &lt;&lt; 24 | 8 &lt;&lt; 16)
 533 #define LGHI_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 9 &lt;&lt; 16)
 534 #define LGFI_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 1L &lt;&lt; 32)
 535 
 536 #define LZER_ZOPC   (unsigned  int)(0xb374 &lt;&lt; 16)
 537 #define LZDR_ZOPC   (unsigned  int)(0xb375 &lt;&lt; 16)
 538 
 539 // LOAD: memory to register transfer
 540 #define LB_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 118L)
 541 #define LH_ZOPC     (unsigned  int)(72 &lt;&lt; 24)
 542 #define LHY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 120L)
 543 #define L_ZOPC      (unsigned  int)(88 &lt;&lt; 24)
 544 #define LY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 88L)
 545 #define LT_ZOPC     (unsigned long)(0xe3L &lt;&lt; 40 | 0x12L)
 546 #define LGB_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 119L)
 547 #define LGH_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 21L)
 548 #define LGF_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 20L)
 549 #define LG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 4L)
 550 #define LTG_ZOPC    (unsigned long)(0xe3L &lt;&lt; 40 | 0x02L)
 551 #define LTGF_ZOPC   (unsigned long)(0xe3L &lt;&lt; 40 | 0x32L)
 552 
 553 #define LLC_ZOPC    (unsigned long)(0xe3L &lt;&lt; 40 | 0x94L)
 554 #define LLH_ZOPC    (unsigned long)(0xe3L &lt;&lt; 40 | 0x95L)
 555 #define LLGT_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 23L)
 556 #define LLGC_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 144L)
 557 #define LLGH_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 145L)
 558 #define LLGF_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 22L)
 559 
 560 #define IC_ZOPC     (unsigned  int)(0x43  &lt;&lt; 24)
 561 #define ICY_ZOPC    (unsigned long)(0xe3L &lt;&lt; 40 | 0x73L)
 562 #define ICM_ZOPC    (unsigned  int)(0xbf  &lt;&lt; 24)
 563 #define ICMY_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x81L)
 564 #define ICMH_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x80L)
 565 
 566 #define LRVH_ZOPC   (unsigned long)(0xe3L &lt;&lt; 40 | 0x1fL)
 567 #define LRV_ZOPC    (unsigned long)(0xe3L &lt;&lt; 40 | 0x1eL)
 568 #define LRVG_ZOPC   (unsigned long)(0xe3L &lt;&lt; 40 | 0x0fL)
 569 
 570 
 571 // LOAD relative: memory to register transfer
 572 #define LHRL_ZOPC   (unsigned long)(0xc4L &lt;&lt; 40 | 0x05L &lt;&lt; 32)  // z10
 573 #define LRL_ZOPC    (unsigned long)(0xc4L &lt;&lt; 40 | 0x0dL &lt;&lt; 32)  // z10
 574 #define LGHRL_ZOPC  (unsigned long)(0xc4L &lt;&lt; 40 | 0x04L &lt;&lt; 32)  // z10
 575 #define LGFRL_ZOPC  (unsigned long)(0xc4L &lt;&lt; 40 | 0x0cL &lt;&lt; 32)  // z10
 576 #define LGRL_ZOPC   (unsigned long)(0xc4L &lt;&lt; 40 | 0x08L &lt;&lt; 32)  // z10
 577 
 578 #define LLHRL_ZOPC  (unsigned long)(0xc4L &lt;&lt; 40 | 0x02L &lt;&lt; 32)  // z10
 579 #define LLGHRL_ZOPC (unsigned long)(0xc4L &lt;&lt; 40 | 0x06L &lt;&lt; 32)  // z10
 580 #define LLGFRL_ZOPC (unsigned long)(0xc4L &lt;&lt; 40 | 0x0eL &lt;&lt; 32)  // z10
 581 
 582 #define LOC_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0xf2L)        // z196
 583 #define LOCG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xe2L)        // z196
 584 
 585 
 586 // LOAD multiple registers at once
 587 #define LM_ZOPC     (unsigned  int)(0x98  &lt;&lt; 24)
 588 #define LMY_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x98L)
 589 #define LMG_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x04L)
 590 
 591 #define LE_ZOPC     (unsigned  int)(0x78 &lt;&lt; 24)
 592 #define LEY_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 100L)
 593 #define LDEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 4)
 594 #define LD_ZOPC     (unsigned  int)(0x68 &lt;&lt; 24)
 595 #define LDY_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 101L)
 596 #define LXEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 6)
 597 #define LXDB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 5)
 598 
 599 // STORE: register to memory transfer
 600 #define STC_ZOPC    (unsigned  int)(0x42 &lt;&lt; 24)
 601 #define STCY_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 114L)
 602 #define STH_ZOPC    (unsigned  int)(64 &lt;&lt; 24)
 603 #define STHY_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 112L)
 604 #define ST_ZOPC     (unsigned  int)(80 &lt;&lt; 24)
 605 #define STY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 80L)
 606 #define STG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 36L)
 607 
 608 #define STCM_ZOPC   (unsigned long)(0xbeL &lt;&lt; 24)
 609 #define STCMY_ZOPC  (unsigned long)(0xebL &lt;&lt; 40 | 0x2dL)
 610 #define STCMH_ZOPC  (unsigned long)(0xebL &lt;&lt; 40 | 0x2cL)
 611 
 612 // STORE relative: memory to register transfer
 613 #define STHRL_ZOPC  (unsigned long)(0xc4L &lt;&lt; 40 | 0x07L &lt;&lt; 32)  // z10
 614 #define STRL_ZOPC   (unsigned long)(0xc4L &lt;&lt; 40 | 0x0fL &lt;&lt; 32)  // z10
 615 #define STGRL_ZOPC  (unsigned long)(0xc4L &lt;&lt; 40 | 0x0bL &lt;&lt; 32)  // z10
 616 
 617 #define STOC_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xf3L)        // z196
 618 #define STOCG_ZOPC  (unsigned long)(0xebL &lt;&lt; 40 | 0xe3L)        // z196
 619 
 620 // STORE multiple registers at once
 621 #define STM_ZOPC    (unsigned  int)(0x90  &lt;&lt; 24)
 622 #define STMY_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x90L)
 623 #define STMG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x24L)
 624 
 625 #define STE_ZOPC    (unsigned  int)(0x70 &lt;&lt; 24)
 626 #define STEY_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 102L)
 627 #define STD_ZOPC    (unsigned  int)(0x60 &lt;&lt; 24)
 628 #define STDY_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 103L)
 629 
 630 // MOVE: immediate to memory transfer
 631 #define MVHHI_ZOPC  (unsigned long)(0xe5L &lt;&lt; 40 | 0x44L &lt;&lt; 32)   // z10
 632 #define MVHI_ZOPC   (unsigned long)(0xe5L &lt;&lt; 40 | 0x4cL &lt;&lt; 32)   // z10
 633 #define MVGHI_ZOPC  (unsigned long)(0xe5L &lt;&lt; 40 | 0x48L &lt;&lt; 32)   // z10
 634 
 635 
 636 //  ALU operations
 637 
 638 // Load Positive
 639 #define LPR_ZOPC    (unsigned  int)(16 &lt;&lt; 8)
 640 #define LPGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 16 &lt;&lt; 16)
 641 #define LPGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24)
 642 #define LPEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24)
 643 #define LPDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 16 &lt;&lt; 16)
 644 #define LPXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 64 &lt;&lt; 16)
 645 
 646 // Load Negative
 647 #define LNR_ZOPC    (unsigned  int)(17 &lt;&lt; 8)
 648 #define LNGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 17 &lt;&lt; 16)
 649 #define LNGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 1 &lt;&lt; 16)
 650 #define LNEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 1 &lt;&lt; 16)
 651 #define LNDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 17 &lt;&lt; 16)
 652 #define LNXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 65 &lt;&lt; 16)
 653 
 654 // Load Complement
 655 #define LCR_ZOPC    (unsigned  int)(19 &lt;&lt; 8)
 656 #define LCGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 19 &lt;&lt; 16)
 657 #define LCGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 3 &lt;&lt; 16)
 658 #define LCEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 3 &lt;&lt; 16)
 659 #define LCDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 19 &lt;&lt; 16)
 660 #define LCXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 67 &lt;&lt; 16)
 661 
 662 // Add
 663 // RR, signed
 664 #define AR_ZOPC     (unsigned  int)(26 &lt;&lt; 8)
 665 #define AGFR_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x18 &lt;&lt; 16)
 666 #define AGR_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x08 &lt;&lt; 16)
 667 // RRF, signed
 668 #define ARK_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00f8 &lt;&lt; 16)
 669 #define AGRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00e8 &lt;&lt; 16)
 670 // RI, signed
 671 #define AHI_ZOPC    (unsigned  int)(167 &lt;&lt; 24 | 10 &lt;&lt; 16)
 672 #define AFI_ZOPC    (unsigned long)(0xc2L &lt;&lt; 40 | 9L &lt;&lt; 32)
 673 #define AGHI_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 11 &lt;&lt; 16)
 674 #define AGFI_ZOPC   (unsigned long)(0xc2L &lt;&lt; 40 | 8L &lt;&lt; 32)
 675 // RIE, signed
 676 #define AHIK_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0x00d8L)
 677 #define AGHIK_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x00d9L)
 678 #define AIH_ZOPC    (unsigned long)(0xccL &lt;&lt; 40 | 0x08L &lt;&lt; 32)
 679 // RM, signed
 680 #define AHY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 122L)
 681 #define A_ZOPC      (unsigned  int)(90 &lt;&lt; 24)
 682 #define AY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 90L)
 683 #define AGF_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 24L)
 684 #define AG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 8L)
 685 // In-memory arithmetic (add signed, add logical with signed immediate).
 686 // MI, signed
 687 #define ASI_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x6aL)
 688 #define AGSI_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x7aL)
 689 
 690 // RR, Logical
 691 #define ALR_ZOPC    (unsigned  int)(30 &lt;&lt; 8)
 692 #define ALGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 26 &lt;&lt; 16)
 693 #define ALGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 10 &lt;&lt; 16)
 694 #define ALCGR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 136 &lt;&lt; 16)
 695 // RRF, Logical
 696 #define ALRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00fa &lt;&lt; 16)
 697 #define ALGRK_ZOPC  (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00ea &lt;&lt; 16)
 698 // RI, Logical
 699 #define ALFI_ZOPC   (unsigned long)(0xc2L &lt;&lt; 40 | 0x0bL &lt;&lt; 32)
 700 #define ALGFI_ZOPC  (unsigned long)(0xc2L &lt;&lt; 40 | 0x0aL &lt;&lt; 32)
 701 // RIE, Logical
 702 #define ALHSIK_ZOPC (unsigned long)(0xecL &lt;&lt; 40 | 0x00daL)
 703 #define ALGHSIK_ZOPC (unsigned long)(0xecL &lt;&lt; 40 | 0x00dbL)
 704 // RM, Logical
 705 #define AL_ZOPC     (unsigned  int)(0x5e &lt;&lt; 24)
 706 #define ALY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 94L)
 707 #define ALGF_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 26L)
 708 #define ALG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 10L)
 709 // In-memory arithmetic (add signed, add logical with signed immediate).
 710 // MI, Logical
 711 #define ALSI_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x6eL)
 712 #define ALGSI_ZOPC  (unsigned long)(0xebL &lt;&lt; 40 | 0x7eL)
 713 
 714 // RR, BFP
 715 #define AEBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 10 &lt;&lt; 16)
 716 #define ADBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 26 &lt;&lt; 16)
 717 #define AXBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 74 &lt;&lt; 16)
 718 // RM, BFP
 719 #define AEB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 10)
 720 #define ADB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 26)
 721 
 722 // Subtract
 723 // RR, signed
 724 #define SR_ZOPC     (unsigned  int)(27 &lt;&lt; 8)
 725 #define SGFR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 25 &lt;&lt; 16)
 726 #define SGR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 9 &lt;&lt; 16)
 727 // RRF, signed
 728 #define SRK_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00f9 &lt;&lt; 16)
 729 #define SGRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00e9 &lt;&lt; 16)
 730 //   RM, signed
 731 #define SH_ZOPC     (unsigned  int)(0x4b &lt;&lt; 24)
 732 #define SHY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 123L)
 733 #define S_ZOPC      (unsigned  int)(0x5B &lt;&lt; 24)
 734 #define SY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 91L)
 735 #define SGF_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 25)
 736 #define SG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 9)
 737 // RR, Logical
 738 #define SLR_ZOPC    (unsigned  int)(31 &lt;&lt; 8)
 739 #define SLGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 27 &lt;&lt; 16)
 740 #define SLGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 11 &lt;&lt; 16)
 741 // RIL, Logical
 742 #define SLFI_ZOPC   (unsigned long)(0xc2L &lt;&lt; 40 | 0x05L &lt;&lt; 32)
 743 #define SLGFI_ZOPC  (unsigned long)(0xc2L &lt;&lt; 40 | 0x04L &lt;&lt; 32)
 744 // RRF, Logical
 745 #define SLRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00fb &lt;&lt; 16)
 746 #define SLGRK_ZOPC  (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00eb &lt;&lt; 16)
 747 // RM, Logical
 748 #define SLY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 95L)
 749 #define SLGF_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 27L)
 750 #define SLG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 11L)
 751 
 752 // RR, BFP
 753 #define SEBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 11 &lt;&lt; 16)
 754 #define SDBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 27 &lt;&lt; 16)
 755 #define SXBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 75 &lt;&lt; 16)
 756 // RM, BFP
 757 #define SEB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 11)
 758 #define SDB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 27)
 759 
 760 // Multiply
 761 // RR, signed
 762 #define MR_ZOPC     (unsigned  int)(28 &lt;&lt; 8)
 763 #define MSR_ZOPC    (unsigned  int)(178 &lt;&lt; 24 | 82 &lt;&lt; 16)
 764 #define MSGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 28 &lt;&lt; 16)
 765 #define MSGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 12 &lt;&lt; 16)
 766 // RI, signed
 767 #define MHI_ZOPC    (unsigned  int)(167 &lt;&lt; 24 | 12 &lt;&lt; 16)
 768 #define MGHI_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 13 &lt;&lt; 16)
 769 #define MSFI_ZOPC   (unsigned long)(0xc2L &lt;&lt; 40 | 0x01L &lt;&lt; 32)   // z10
 770 #define MSGFI_ZOPC  (unsigned long)(0xc2L &lt;&lt; 40 | 0x00L &lt;&lt; 32)   // z10
 771 // RM, signed
 772 #define M_ZOPC      (unsigned  int)(92 &lt;&lt; 24)
 773 #define MS_ZOPC     (unsigned  int)(0x71 &lt;&lt; 24)
 774 #define MHY_ZOPC    (unsigned long)(0xe3L&lt;&lt; 40 | 0x7cL)
 775 #define MSY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 81L)
 776 #define MSGF_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 28L)
 777 #define MSG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 12L)
 778 // RR, unsigned
 779 #define MLR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 150 &lt;&lt; 16)
 780 #define MLGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 134 &lt;&lt; 16)
 781 // RM, unsigned
 782 #define ML_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 150L)
 783 #define MLG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 134L)
 784 
 785 // RR, BFP
 786 #define MEEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 23 &lt;&lt; 16)
 787 #define MDEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 12 &lt;&lt; 16)
 788 #define MDBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 28 &lt;&lt; 16)
 789 #define MXDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 7 &lt;&lt; 16)
 790 #define MXBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 76 &lt;&lt; 16)
 791 // RM, BFP
 792 #define MEEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 23)
 793 #define MDEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 12)
 794 #define MDB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 28)
 795 #define MXDB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 7)
 796 
 797 // Multiply-Add
 798 #define MAEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 14 &lt;&lt; 16)
 799 #define MADBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 30 &lt;&lt; 16)
 800 #define MSEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 15 &lt;&lt; 16)
 801 #define MSDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 31 &lt;&lt; 16)
 802 #define MAEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 14)
 803 #define MADB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 30)
 804 #define MSEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 15)
 805 #define MSDB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 31)
 806 
 807 // Divide
 808 // RR, signed
 809 #define DSGFR_ZOPC  (unsigned  int)(0xb91d &lt;&lt; 16)
 810 #define DSGR_ZOPC   (unsigned  int)(0xb90d &lt;&lt; 16)
 811 // RM, signed
 812 #define D_ZOPC      (unsigned  int)(93 &lt;&lt; 24)
 813 #define DSGF_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 29L)
 814 #define DSG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 13L)
 815 // RR, unsigned
 816 #define DLR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 151 &lt;&lt; 16)
 817 #define DLGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 135 &lt;&lt; 16)
 818 // RM, unsigned
 819 #define DL_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 151L)
 820 #define DLG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 135L)
 821 
 822 // RR, BFP
 823 #define DEBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 13 &lt;&lt; 16)
 824 #define DDBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 29 &lt;&lt; 16)
 825 #define DXBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 77 &lt;&lt; 16)
 826 // RM, BFP
 827 #define DEB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 13)
 828 #define DDB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 29)
 829 
 830 // Square Root
 831 // RR, BFP
 832 #define SQEBR_ZOPC  (unsigned  int)(0xb314 &lt;&lt; 16)
 833 #define SQDBR_ZOPC  (unsigned  int)(0xb315 &lt;&lt; 16)
 834 #define SQXBR_ZOPC  (unsigned  int)(0xb316 &lt;&lt; 16)
 835 // RM, BFP
 836 #define SQEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 20)
 837 #define SQDB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 21)
 838 
 839 // Compare and Test
 840 // RR, signed
 841 #define CR_ZOPC     (unsigned  int)(25 &lt;&lt; 8)
 842 #define CGFR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 48 &lt;&lt; 16)
 843 #define CGR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 32 &lt;&lt; 16)
 844 // RI, signed
 845 #define CHI_ZOPC    (unsigned  int)(167 &lt;&lt; 24 | 14 &lt;&lt; 16)
 846 #define CFI_ZOPC    (unsigned long)(0xc2L &lt;&lt; 40 | 0xdL &lt;&lt; 32)
 847 #define CGHI_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 15 &lt;&lt; 16)
 848 #define CGFI_ZOPC   (unsigned long)(0xc2L &lt;&lt; 40 | 0xcL &lt;&lt; 32)
 849 // RM, signed
 850 #define CH_ZOPC     (unsigned  int)(0x49 &lt;&lt; 24)
 851 #define CHY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 121L)
 852 #define C_ZOPC      (unsigned  int)(0x59 &lt;&lt; 24)
 853 #define CY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 89L)
 854 #define CGF_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 48L)
 855 #define CG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 32L)
 856 // RR, unsigned
 857 #define CLR_ZOPC    (unsigned  int)(21 &lt;&lt; 8)
 858 #define CLGFR_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 49 &lt;&lt; 16)
 859 #define CLGR_ZOPC   (unsigned  int)(185 &lt;&lt; 24 | 33 &lt;&lt; 16)
 860 // RIL, unsigned
 861 #define CLFI_ZOPC   (unsigned long)(0xc2L &lt;&lt; 40 | 0xfL &lt;&lt; 32)
 862 #define CLGFI_ZOPC  (unsigned long)(0xc2L &lt;&lt; 40 | 0xeL &lt;&lt; 32)
 863 // RM, unsigned
 864 #define CL_ZOPC     (unsigned  int)(0x55 &lt;&lt; 24)
 865 #define CLY_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 85L)
 866 #define CLGF_ZOPC   (unsigned long)(227L &lt;&lt; 40 | 49L)
 867 #define CLG_ZOPC    (unsigned long)(227L &lt;&lt; 40 | 33L)
 868 // RI, unsigned
 869 #define TMHH_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 2 &lt;&lt; 16)
 870 #define TMHL_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 3 &lt;&lt; 16)
 871 #define TMLH_ZOPC   (unsigned  int)(167 &lt;&lt; 24)
 872 #define TMLL_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 1 &lt;&lt; 16)
 873 
 874 // RR, BFP
 875 #define CEBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 9 &lt;&lt; 16)
 876 #define CDBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 25 &lt;&lt; 16)
 877 #define CXBR_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 73 &lt;&lt; 16)
 878 // RM, BFP
 879 #define CEB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 9)
 880 #define CDB_ZOPC    (unsigned long)(237L &lt;&lt; 40 | 25)
 881 
 882 // Shift
 883 // arithmetic
 884 #define SLA_ZOPC    (unsigned  int)(0x8b  &lt;&lt; 24)
 885 #define SLAK_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xddL)
 886 #define SLAG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x0bL)
 887 #define SRA_ZOPC    (unsigned  int)(0x8a  &lt;&lt; 24)
 888 #define SRAK_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xdcL)
 889 #define SRAG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x0aL)
 890 // logical
 891 #define SLL_ZOPC    (unsigned  int)(0x89  &lt;&lt; 24)
 892 #define SLLK_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xdfL)
 893 #define SLLG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x0dL)
 894 #define SRL_ZOPC    (unsigned  int)(0x88  &lt;&lt; 24)
 895 #define SRLK_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xdeL)
 896 #define SRLG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x0cL)
 897 
 898 // Rotate, then AND/XOR/OR/insert
 899 // rotate
 900 #define RLL_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x1dL)         // z10
 901 #define RLLG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x1cL)         // z10
 902 // rotate and {AND|XOR|OR|INS}
 903 #define RNSBG_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x54L)         // z196
 904 #define RXSBG_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x57L)         // z196
 905 #define ROSBG_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x56L)         // z196
 906 #define RISBG_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x55L)         // z196
 907 
 908 // AND
 909 // RR, signed
 910 #define NR_ZOPC     (unsigned  int)(20 &lt;&lt; 8)
 911 #define NGR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 128 &lt;&lt; 16)
 912 // RRF, signed
 913 #define NRK_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00f4 &lt;&lt; 16)
 914 #define NGRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00e4 &lt;&lt; 16)
 915 // RI, signed
 916 #define NIHH_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 4 &lt;&lt; 16)
 917 #define NIHL_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 5 &lt;&lt; 16)
 918 #define NILH_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 6 &lt;&lt; 16)
 919 #define NILL_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 7 &lt;&lt; 16)
 920 #define NIHF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 10L &lt;&lt; 32)
 921 #define NILF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 11L &lt;&lt; 32)
 922 // RM, signed
 923 #define N_ZOPC      (unsigned  int)(0x54 &lt;&lt; 24)
 924 #define NY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 84L)
 925 #define NG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 128L)
 926 
 927 // OR
 928 // RR, signed
 929 #define OR_ZOPC     (unsigned  int)(22 &lt;&lt; 8)
 930 #define OGR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 129 &lt;&lt; 16)
 931 // RRF, signed
 932 #define ORK_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00f6 &lt;&lt; 16)
 933 #define OGRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00e6 &lt;&lt; 16)
 934 // RI, signed
 935 #define OIHH_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 8 &lt;&lt; 16)
 936 #define OIHL_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 9 &lt;&lt; 16)
 937 #define OILH_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 10 &lt;&lt; 16)
 938 #define OILL_ZOPC   (unsigned  int)(165 &lt;&lt; 24 | 11 &lt;&lt; 16)
 939 #define OIHF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 12L &lt;&lt; 32)
 940 #define OILF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 13L &lt;&lt; 32)
 941 // RM, signed
 942 #define O_ZOPC      (unsigned  int)(0x56 &lt;&lt; 24)
 943 #define OY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 86L)
 944 #define OG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 129L)
 945 
 946 // XOR
 947 // RR, signed
 948 #define XR_ZOPC     (unsigned  int)(23 &lt;&lt; 8)
 949 #define XGR_ZOPC    (unsigned  int)(185 &lt;&lt; 24 | 130 &lt;&lt; 16)
 950 // RRF, signed
 951 #define XRK_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00f7 &lt;&lt; 16)
 952 #define XGRK_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x00e7 &lt;&lt; 16)
 953 // RI, signed
 954 #define XIHF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 6L &lt;&lt; 32)
 955 #define XILF_ZOPC   (unsigned long)(0xc0L &lt;&lt; 40 | 7L &lt;&lt; 32)
 956 // RM, signed
 957 #define X_ZOPC      (unsigned  int)(0x57 &lt;&lt; 24)
 958 #define XY_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 87L)
 959 #define XG_ZOPC     (unsigned long)(227L &lt;&lt; 40 | 130L)
 960 
 961 
 962 // Data Conversion
 963 
 964 // INT to BFP
 965 #define CEFBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 148 &lt;&lt; 16)
 966 #define CDFBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 149 &lt;&lt; 16)
 967 #define CXFBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 150 &lt;&lt; 16)
 968 #define CEGBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 164 &lt;&lt; 16)
 969 #define CDGBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 165 &lt;&lt; 16)
 970 #define CXGBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 166 &lt;&lt; 16)
 971 // BFP to INT
 972 #define CFEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 152 &lt;&lt; 16)
 973 #define CFDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 153 &lt;&lt; 16)
 974 #define CFXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 154 &lt;&lt; 16)
 975 #define CGEBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 168 &lt;&lt; 16)
 976 #define CGDBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 169 &lt;&lt; 16)
 977 #define CGXBR_ZOPC  (unsigned  int)(179 &lt;&lt; 24 | 170 &lt;&lt; 16)
 978 // INT to DEC
 979 #define CVD_ZOPC    (unsigned  int)(0x4e &lt;&lt; 24)
 980 #define CVDY_ZOPC   (unsigned long)(0xe3L &lt;&lt; 40 | 0x26L)
 981 #define CVDG_ZOPC   (unsigned long)(0xe3L &lt;&lt; 40 | 0x2eL)
 982 
 983 
 984 // BFP Control
 985 
 986 #define SRNM_ZOPC   (unsigned  int)(178 &lt;&lt; 24 | 153 &lt;&lt; 16)
 987 #define EFPC_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 140 &lt;&lt; 16)
 988 #define SFPC_ZOPC   (unsigned  int)(179 &lt;&lt; 24 | 132 &lt;&lt; 16)
 989 #define STFPC_ZOPC  (unsigned  int)(178 &lt;&lt; 24 | 156 &lt;&lt; 16)
 990 #define LFPC_ZOPC   (unsigned  int)(178 &lt;&lt; 24 | 157 &lt;&lt; 16)
 991 
 992 
 993 // Branch Instructions
 994 
 995 // Register
 996 #define BCR_ZOPC    (unsigned  int)(7 &lt;&lt; 8)
 997 #define BALR_ZOPC   (unsigned  int)(5 &lt;&lt; 8)
 998 #define BASR_ZOPC   (unsigned  int)(13 &lt;&lt; 8)
 999 #define BCTGR_ZOPC  (unsigned long)(0xb946 &lt;&lt; 16)
1000 // Absolute
1001 #define BC_ZOPC     (unsigned  int)(71 &lt;&lt; 24)
1002 #define BAL_ZOPC    (unsigned  int)(69 &lt;&lt; 24)
1003 #define BAS_ZOPC    (unsigned  int)(77 &lt;&lt; 24)
1004 #define BXH_ZOPC    (unsigned  int)(134 &lt;&lt; 24)
1005 #define BXHG_ZOPC   (unsigned long)(235L &lt;&lt; 40 | 68)
1006 // Relative
1007 #define BRC_ZOPC    (unsigned  int)(167 &lt;&lt; 24 | 4 &lt;&lt; 16)
1008 #define BRCL_ZOPC   (unsigned long)(192L &lt;&lt; 40 | 4L &lt;&lt; 32)
1009 #define BRAS_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 5 &lt;&lt; 16)
1010 #define BRASL_ZOPC  (unsigned long)(192L &lt;&lt; 40 | 5L &lt;&lt; 32)
1011 #define BRCT_ZOPC   (unsigned  int)(167 &lt;&lt; 24 | 6 &lt;&lt; 16)
1012 #define BRCTG_ZOPC  (unsigned  int)(167 &lt;&lt; 24 | 7 &lt;&lt; 16)
1013 #define BRXH_ZOPC   (unsigned  int)(132 &lt;&lt; 24)
1014 #define BRXHG_ZOPC  (unsigned long)(236L &lt;&lt; 40 | 68)
1015 #define BRXLE_ZOPC  (unsigned  int)(133 &lt;&lt; 24)
1016 #define BRXLG_ZOPC  (unsigned long)(236L &lt;&lt; 40 | 69)
1017 
1018 
1019 // Compare and Branch Instructions
1020 
1021 // signed comp reg/reg, branch Absolute
1022 #define CRB_ZOPC    (unsigned long)(0xecL &lt;&lt; 40 | 0xf6L)         // z10
1023 #define CGRB_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0xe4L)         // z10
1024 // signed comp reg/reg, branch Relative
1025 #define CRJ_ZOPC    (unsigned long)(0xecL &lt;&lt; 40 | 0x76L)         // z10
1026 #define CGRJ_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0x64L)         // z10
1027 // signed comp reg/imm, branch absolute
1028 #define CIB_ZOPC    (unsigned long)(0xecL &lt;&lt; 40 | 0xfeL)         // z10
1029 #define CGIB_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0xfcL)         // z10
1030 // signed comp reg/imm, branch relative
1031 #define CIJ_ZOPC    (unsigned long)(0xecL &lt;&lt; 40 | 0x7eL)         // z10
1032 #define CGIJ_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0x7cL)         // z10
1033 
1034 // unsigned comp reg/reg, branch Absolute
1035 #define CLRB_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0xf7L)         // z10
1036 #define CLGRB_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0xe5L)         // z10
1037 // unsigned comp reg/reg, branch Relative
1038 #define CLRJ_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0x77L)         // z10
1039 #define CLGRJ_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x65L)         // z10
1040 // unsigned comp reg/imm, branch absolute
1041 #define CLIB_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0xffL)         // z10
1042 #define CLGIB_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0xfdL)         // z10
1043 // unsigned comp reg/imm, branch relative
1044 #define CLIJ_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0x7fL)         // z10
1045 #define CLGIJ_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x7dL)         // z10
1046 
1047 // comp reg/reg, trap
1048 #define CRT_ZOPC    (unsigned  int)(0xb972 &lt;&lt; 16)                // z10
1049 #define CGRT_ZOPC   (unsigned  int)(0xb960 &lt;&lt; 16)                // z10
1050 #define CLRT_ZOPC   (unsigned  int)(0xb973 &lt;&lt; 16)                // z10
1051 #define CLGRT_ZOPC  (unsigned  int)(0xb961 &lt;&lt; 16)                // z10
1052 // comp reg/imm, trap
1053 #define CIT_ZOPC    (unsigned long)(0xecL &lt;&lt; 40 | 0x72L)         // z10
1054 #define CGIT_ZOPC   (unsigned long)(0xecL &lt;&lt; 40 | 0x70L)         // z10
1055 #define CLFIT_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x73L)         // z10
1056 #define CLGIT_ZOPC  (unsigned long)(0xecL &lt;&lt; 40 | 0x71L)         // z10
1057 
1058 
1059 // Direct Memory Operations
1060 
1061 // Compare
1062 #define CLI_ZOPC    (unsigned  int)(0x95  &lt;&lt; 24)
1063 #define CLIY_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x55L)
1064 #define CLC_ZOPC    (unsigned long)(0xd5L &lt;&lt; 40)
1065 #define CLCL_ZOPC   (unsigned  int)(0x0f  &lt;&lt;  8)
1066 #define CLCLE_ZOPC  (unsigned  int)(0xa9  &lt;&lt; 24)
1067 #define CLCLU_ZOPC  (unsigned long)(0xebL &lt;&lt; 40 | 0x8fL)
1068 
1069 // Move
1070 #define MVI_ZOPC    (unsigned  int)(0x92  &lt;&lt; 24)
1071 #define MVIY_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0x52L)
1072 #define MVC_ZOPC    (unsigned long)(0xd2L &lt;&lt; 40)
1073 #define MVCL_ZOPC   (unsigned  int)(0x0e  &lt;&lt;  8)
1074 #define MVCLE_ZOPC  (unsigned  int)(0xa8  &lt;&lt; 24)
1075 
1076 // Test
1077 #define TM_ZOPC     (unsigned  int)(0x91  &lt;&lt; 24)
1078 #define TMY_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x51L)
1079 
1080 // AND
1081 #define NI_ZOPC     (unsigned  int)(0x94  &lt;&lt; 24)
1082 #define NIY_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x54L)
1083 #define NC_ZOPC     (unsigned long)(0xd4L &lt;&lt; 40)
1084 
1085 // OR
1086 #define OI_ZOPC     (unsigned  int)(0x96  &lt;&lt; 24)
1087 #define OIY_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x56L)
1088 #define OC_ZOPC     (unsigned long)(0xd6L &lt;&lt; 40)
1089 
1090 // XOR
1091 #define XI_ZOPC     (unsigned  int)(0x97  &lt;&lt; 24)
1092 #define XIY_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x57L)
1093 #define XC_ZOPC     (unsigned long)(0xd7L &lt;&lt; 40)
1094 
1095 // Search String
1096 #define SRST_ZOPC   (unsigned  int)(178 &lt;&lt; 24 | 94 &lt;&lt; 16)
1097 #define SRSTU_ZOPC  (unsigned  int)(185 &lt;&lt; 24 | 190 &lt;&lt; 16)
1098 
1099 // Translate characters
1100 #define TROO_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x93 &lt;&lt; 16)
1101 #define TROT_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x92 &lt;&lt; 16)
1102 #define TRTO_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x91 &lt;&lt; 16)
1103 #define TRTT_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x90 &lt;&lt; 16)
1104 
1105 
1106 //---------------------------
1107 //--  Vector Instructions  --
1108 //---------------------------
1109 
1110 //---&lt;  Vector Support Instructions  &gt;---
1111 
1112 //---  Load (memory)  ---
1113 
1114 #define VLM_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x36L &lt;&lt; 0)   // load full vreg range (n * 128 bit)
1115 #define VL_ZOPC     (unsigned long)(0xe7L &lt;&lt; 40 | 0x06L &lt;&lt; 0)   // load full vreg (128 bit)
1116 #define VLEB_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x00L &lt;&lt; 0)   // load vreg element (8 bit)
1117 #define VLEH_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x01L &lt;&lt; 0)   // load vreg element (16 bit)
1118 #define VLEF_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x03L &lt;&lt; 0)   // load vreg element (32 bit)
1119 #define VLEG_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x02L &lt;&lt; 0)   // load vreg element (64 bit)
1120 
1121 #define VLREP_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x05L &lt;&lt; 0)   // load and replicate into all vector elements
1122 #define VLLEZ_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x04L &lt;&lt; 0)   // load logical element and zero.
1123 
1124 // vector register gather
1125 #define VGEF_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x13L &lt;&lt; 0)   // gather element (32 bit), V1(M3) = [D2(V2(M3),B2)]
1126 #define VGEG_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x12L &lt;&lt; 0)   // gather element (64 bit), V1(M3) = [D2(V2(M3),B2)]
1127 // vector register scatter
1128 #define VSCEF_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x1bL &lt;&lt; 0)   // vector scatter element FW
1129 #define VSCEG_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x1aL &lt;&lt; 0)   // vector scatter element DW
1130 
1131 #define VLBB_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x07L &lt;&lt; 0)   // load vreg to block boundary (load to alignment).
1132 #define VLL_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x37L &lt;&lt; 0)   // load vreg with length.
1133 
1134 //---  Load (register)  ---
1135 
1136 #define VLR_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x56L &lt;&lt; 0)   // copy full vreg (128 bit)
1137 #define VLGV_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x21L &lt;&lt; 0)   // copy vreg element -&gt; GR
1138 #define VLVG_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x22L &lt;&lt; 0)   // copy GR -&gt; vreg element
1139 #define VLVGP_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x62L &lt;&lt; 0)   // copy GR2, GR3 (disjoint pair) -&gt; vreg
1140 
1141 // vector register pack: cut in half the size the source vector elements
1142 #define VPK_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x94L &lt;&lt; 0)   // just cut
1143 #define VPKS_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x97L &lt;&lt; 0)   // saturate as signed values
1144 #define VPKLS_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x95L &lt;&lt; 0)   // saturate as unsigned values
1145 
1146 // vector register unpack: double in size the source vector elements
1147 #define VUPH_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xd7L &lt;&lt; 0)   // signed, left half of the source vector elements
1148 #define VUPLH_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xd5L &lt;&lt; 0)   // unsigned, left half of the source vector elements
1149 #define VUPL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xd6L &lt;&lt; 0)   // signed, right half of the source vector elements
1150 #define VUPLL_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xd4L &lt;&lt; 0)   // unsigned, right half of the source vector element
1151 
1152 // vector register merge
1153 #define VMRH_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x61L &lt;&lt; 0)   // register merge high (left half of source registers)
1154 #define VMRL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x60L &lt;&lt; 0)   // register merge low (right half of source registers)
1155 
1156 // vector register permute
1157 #define VPERM_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x8cL &lt;&lt; 0)   // vector permute
1158 #define VPDI_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x84L &lt;&lt; 0)   // vector permute DW immediate
1159 
1160 // vector register replicate
1161 #define VREP_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x4dL &lt;&lt; 0)   // vector replicate
1162 #define VREPI_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x45L &lt;&lt; 0)   // vector replicate immediate
1163 #define VSEL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x8dL &lt;&lt; 0)   // vector select
1164 
1165 #define VSEG_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x5fL &lt;&lt; 0)   // vector sign-extend to DW (rightmost element in each DW).
1166 
1167 //---  Load (immediate)  ---
1168 
1169 #define VLEIB_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x40L &lt;&lt; 0)   // load vreg element (16 bit imm to 8 bit)
1170 #define VLEIH_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x41L &lt;&lt; 0)   // load vreg element (16 bit imm to 16 bit)
1171 #define VLEIF_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x43L &lt;&lt; 0)   // load vreg element (16 bit imm to 32 bit)
1172 #define VLEIG_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x42L &lt;&lt; 0)   // load vreg element (16 bit imm to 64 bit)
1173 
1174 //---  Store  ---
1175 
1176 #define VSTM_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x3eL &lt;&lt; 0)   // store full vreg range (n * 128 bit)
1177 #define VST_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x0eL &lt;&lt; 0)   // store full vreg (128 bit)
1178 #define VSTEB_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x08L &lt;&lt; 0)   // store vreg element (8 bit)
1179 #define VSTEH_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x09L &lt;&lt; 0)   // store vreg element (16 bit)
1180 #define VSTEF_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x0bL &lt;&lt; 0)   // store vreg element (32 bit)
1181 #define VSTEG_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x0aL &lt;&lt; 0)   // store vreg element (64 bit)
1182 #define VSTL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x3fL &lt;&lt; 0)   // store vreg with length.
1183 
1184 //---  Misc  ---
1185 
1186 #define VGM_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x46L &lt;&lt; 0)   // generate bit  mask, [start..end] = &#39;1&#39;, else &#39;0&#39;
1187 #define VGBM_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x44L &lt;&lt; 0)   // generate byte mask, bits(imm16) -&gt; bytes
1188 
1189 //---&lt;  Vector Arithmetic Instructions  &gt;---
1190 
1191 // Load
1192 #define VLC_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xdeL &lt;&lt; 0)   // V1 := -V2,   element size = 2**m
1193 #define VLP_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xdfL &lt;&lt; 0)   // V1 := |V2|,  element size = 2**m
1194 
1195 // ADD
1196 #define VA_ZOPC     (unsigned long)(0xe7L &lt;&lt; 40 | 0xf3L &lt;&lt; 0)   // V1 := V2 + V3, element size = 2**m
1197 #define VACC_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xf1L &lt;&lt; 0)   // V1 := carry(V2 + V3), element size = 2**m
1198 
1199 // SUB
1200 #define VS_ZOPC     (unsigned long)(0xe7L &lt;&lt; 40 | 0xf7L &lt;&lt; 0)   // V1 := V2 - V3, element size = 2**m
1201 #define VSCBI_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xf5L &lt;&lt; 0)   // V1 := borrow(V2 - V3), element size = 2**m
1202 
1203 // MUL
1204 #define VML_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xa2L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m
1205 #define VMH_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xa3L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m
1206 #define VMLH_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xa1L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m, unsigned
1207 #define VME_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xa6L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m
1208 #define VMLE_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xa4L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m, unsigned
1209 #define VMO_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xa7L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m
1210 #define VMLO_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xa5L &lt;&lt; 0)   // V1 := V2 * V3, element size = 2**m, unsigned
1211 
1212 // MUL &amp; ADD
1213 #define VMAL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xaaL &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m
1214 #define VMAH_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xabL &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m
1215 #define VMALH_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xa9L &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m, unsigned
1216 #define VMAE_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xaeL &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m
1217 #define VMALE_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xacL &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m, unsigned
1218 #define VMAO_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xafL &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m
1219 #define VMALO_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xadL &lt;&lt; 0)   // V1 := V2 * V3 + V4, element size = 2**m, unsigned
1220 
1221 // Vector SUM
1222 #define VSUM_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x64L &lt;&lt; 0)   // V1[j] := toFW(sum(V2[i]) + V3[j]), subelements: byte or HW
1223 #define VSUMG_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x65L &lt;&lt; 0)   // V1[j] := toDW(sum(V2[i]) + V3[j]), subelements: HW or FW
1224 #define VSUMQ_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x67L &lt;&lt; 0)   // V1[j] := toQW(sum(V2[i]) + V3[j]), subelements: FW or DW
1225 
1226 // Average
1227 #define VAVG_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xf2L &lt;&lt; 0)   // V1 := (V2+V3+1)/2, signed,   element size = 2**m
1228 #define VAVGL_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xf0L &lt;&lt; 0)   // V1 := (V2+V3+1)/2, unsigned, element size = 2**m
1229 
1230 // VECTOR Galois Field Multiply Sum
1231 #define VGFM_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xb4L &lt;&lt; 0)
1232 #define VGFMA_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0xbcL &lt;&lt; 0)
1233 
1234 //---&lt;  Vector Logical Instructions  &gt;---
1235 
1236 // AND
1237 #define VN_ZOPC     (unsigned long)(0xe7L &lt;&lt; 40 | 0x68L &lt;&lt; 0)   // V1 := V2 &amp; V3,  element size = 2**m
1238 #define VNC_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x69L &lt;&lt; 0)   // V1 := V2 &amp; ~V3, element size = 2**m
1239 
1240 // XOR
1241 #define VX_ZOPC     (unsigned long)(0xe7L &lt;&lt; 40 | 0x6dL &lt;&lt; 0)   // V1 := V2 ^ V3,  element size = 2**m
1242 
1243 // NOR
1244 #define VNO_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x6bL &lt;&lt; 0)   // V1 := !(V2 | V3),  element size = 2**m
1245 
1246 // OR
1247 #define VO_ZOPC     (unsigned long)(0xe7L &lt;&lt; 40 | 0x6aL &lt;&lt; 0)   // V1 := V2 | V3,  element size = 2**m
1248 
1249 // Comparison (element-wise)
1250 #define VCEQ_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xf8L &lt;&lt; 0)   // V1 := (V2 == V3) ? 0xffff : 0x0000, element size = 2**m
1251 #define VCH_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xfbL &lt;&lt; 0)   // V1 := (V2  &gt; V3) ? 0xffff : 0x0000, element size = 2**m, signed
1252 #define VCHL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xf9L &lt;&lt; 0)   // V1 := (V2  &gt; V3) ? 0xffff : 0x0000, element size = 2**m, unsigned
1253 
1254 // Max/Min (element-wise)
1255 #define VMX_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xffL &lt;&lt; 0)   // V1 := (V2 &gt; V3) ? V2 : V3, element size = 2**m, signed
1256 #define VMXL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xfdL &lt;&lt; 0)   // V1 := (V2 &gt; V3) ? V2 : V3, element size = 2**m, unsigned
1257 #define VMN_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xfeL &lt;&lt; 0)   // V1 := (V2 &lt; V3) ? V2 : V3, element size = 2**m, signed
1258 #define VMNL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0xfcL &lt;&lt; 0)   // V1 := (V2 &lt; V3) ? V2 : V3, element size = 2**m, unsigned
1259 
1260 // Leading/Trailing Zeros, population count
1261 #define VCLZ_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x53L &lt;&lt; 0)   // V1 := leadingzeros(V2),  element size = 2**m
1262 #define VCTZ_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x52L &lt;&lt; 0)   // V1 := trailingzeros(V2), element size = 2**m
1263 #define VPOPCT_ZOPC (unsigned long)(0xe7L &lt;&lt; 40 | 0x50L &lt;&lt; 0)   // V1 := popcount(V2), bytewise!!
1264 
1265 // Rotate/Shift
1266 #define VERLLV_ZOPC (unsigned long)(0xe7L &lt;&lt; 40 | 0x73L &lt;&lt; 0)   // V1 := rotateleft(V2), rotate count in V3 element
1267 #define VERLL_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x33L &lt;&lt; 0)   // V1 := rotateleft(V3), rotate count from d2(b2).
1268 #define VERIM_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x72L &lt;&lt; 0)   // Rotate then insert under mask. Read Principles of Operation!!
1269 
1270 #define VESLV_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x70L &lt;&lt; 0)   // V1 := SLL(V2, V3), unsigned, element-wise
1271 #define VESL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x30L &lt;&lt; 0)   // V1 := SLL(V3), unsigned, shift count from d2(b2).
1272 
1273 #define VESRAV_ZOPC (unsigned long)(0xe7L &lt;&lt; 40 | 0x7AL &lt;&lt; 0)   // V1 := SRA(V2, V3), signed, element-wise
1274 #define VESRA_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x3AL &lt;&lt; 0)   // V1 := SRA(V3), signed, shift count from d2(b2).
1275 #define VESRLV_ZOPC (unsigned long)(0xe7L &lt;&lt; 40 | 0x78L &lt;&lt; 0)   // V1 := SRL(V2, V3), unsigned, element-wise
1276 #define VESRL_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x38L &lt;&lt; 0)   // V1 := SRL(V3), unsigned, shift count from d2(b2).
1277 
1278 #define VSL_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0x74L &lt;&lt; 0)   // V1 := SLL(V2), unsigned, bit-count
1279 #define VSLB_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x75L &lt;&lt; 0)   // V1 := SLL(V2), unsigned, byte-count
1280 #define VSLDB_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x77L &lt;&lt; 0)   // V1 := SLL((V2,V3)), unsigned, byte-count
1281 
1282 #define VSRA_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x7eL &lt;&lt; 0)   // V1 := SRA(V2), signed, bit-count
1283 #define VSRAB_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x7fL &lt;&lt; 0)   // V1 := SRA(V2), signed, byte-count
1284 #define VSRL_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x7cL &lt;&lt; 0)   // V1 := SRL(V2), unsigned, bit-count
1285 #define VSRLB_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x7dL &lt;&lt; 0)   // V1 := SRL(V2), unsigned, byte-count
1286 
1287 // Test under Mask
1288 #define VTM_ZOPC    (unsigned long)(0xe7L &lt;&lt; 40 | 0xd8L &lt;&lt; 0)   // Like TM, set CC according to state of selected bits.
1289 
1290 //---&lt;  Vector String Instructions  &gt;---
1291 #define VFAE_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x82L &lt;&lt; 0)   // Find any element
1292 #define VFEE_ZOPC   (unsigned long)(0xe7L &lt;&lt; 40 | 0x80L &lt;&lt; 0)   // Find element equal
1293 #define VFENE_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x81L &lt;&lt; 0)   // Find element not equal
1294 #define VSTRC_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x8aL &lt;&lt; 0)   // String range compare
1295 #define VISTR_ZOPC  (unsigned long)(0xe7L &lt;&lt; 40 | 0x5cL &lt;&lt; 0)   // Isolate String
1296 
1297 
1298 //--------------------------------
1299 //--  Miscellaneous Operations  --
1300 //--------------------------------
1301 
1302 // Execute
1303 #define EX_ZOPC     (unsigned  int)(68L &lt;&lt; 24)
1304 #define EXRL_ZOPC   (unsigned long)(0xc6L &lt;&lt; 40 | 0x00L &lt;&lt; 32)  // z10
1305 
1306 // Compare and Swap
1307 #define CS_ZOPC     (unsigned  int)(0xba &lt;&lt; 24)
1308 #define CSY_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x14L)
1309 #define CSG_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0x30L)
1310 
1311 // Interlocked-Update
1312 #define LAA_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0xf8L)         // z196
1313 #define LAAG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xe8L)         // z196
1314 #define LAAL_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xfaL)         // z196
1315 #define LAALG_ZOPC  (unsigned long)(0xebL &lt;&lt; 40 | 0xeaL)         // z196
1316 #define LAN_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0xf4L)         // z196
1317 #define LANG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xe4L)         // z196
1318 #define LAX_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0xf7L)         // z196
1319 #define LAXG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xe7L)         // z196
1320 #define LAO_ZOPC    (unsigned long)(0xebL &lt;&lt; 40 | 0xf6L)         // z196
1321 #define LAOG_ZOPC   (unsigned long)(0xebL &lt;&lt; 40 | 0xe6L)         // z196
1322 
1323 // System Functions
1324 #define STCKF_ZOPC  (unsigned  int)(0xb2 &lt;&lt; 24 | 0x7c &lt;&lt; 16)
1325 #define STFLE_ZOPC  (unsigned  int)(0xb2 &lt;&lt; 24 | 0xb0 &lt;&lt; 16)
1326 #define ECTG_ZOPC   (unsigned long)(0xc8L &lt;&lt;40 | 0x01L &lt;&lt; 32)    // z10
1327 #define ECAG_ZOPC   (unsigned long)(0xebL &lt;&lt;40 | 0x4cL)          // z10
1328 
1329 // Execution Prediction
1330 #define PFD_ZOPC    (unsigned long)(0xe3L &lt;&lt;40 | 0x36L)          // z10
1331 #define PFDRL_ZOPC  (unsigned long)(0xc6L &lt;&lt;40 | 0x02L &lt;&lt; 32)    // z10
1332 #define BPP_ZOPC    (unsigned long)(0xc7L &lt;&lt;40)                  // branch prediction preload  -- EC12
1333 #define BPRP_ZOPC   (unsigned long)(0xc5L &lt;&lt;40)                  // branch prediction preload  -- EC12
1334 
1335 // Transaction Control
1336 #define TBEGIN_ZOPC  (unsigned long)(0xe560L &lt;&lt; 32)              // tx begin                   -- EC12
1337 #define TBEGINC_ZOPC (unsigned long)(0xe561L &lt;&lt; 32)              // tx begin (constrained)     -- EC12
1338 #define TEND_ZOPC    (unsigned  int)(0xb2f8  &lt;&lt; 16)              // tx end                     -- EC12
1339 #define TABORT_ZOPC  (unsigned  int)(0xb2fc  &lt;&lt; 16)              // tx abort                   -- EC12
1340 #define ETND_ZOPC    (unsigned  int)(0xb2ec  &lt;&lt; 16)              // tx nesting depth           -- EC12
1341 #define PPA_ZOPC     (unsigned  int)(0xb2e8  &lt;&lt; 16)              // tx processor assist        -- EC12
1342 
1343 // Crypto and Checksum
1344 #define CKSM_ZOPC   (unsigned  int)(0xb2 &lt;&lt; 24 | 0x41 &lt;&lt; 16)     // checksum. This is NOT CRC32
1345 #define KM_ZOPC     (unsigned  int)(0xb9 &lt;&lt; 24 | 0x2e &lt;&lt; 16)     // cipher
1346 #define KMC_ZOPC    (unsigned  int)(0xb9 &lt;&lt; 24 | 0x2f &lt;&lt; 16)     // cipher
1347 #define KIMD_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x3e &lt;&lt; 16)     // SHA (msg digest)
1348 #define KLMD_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x3f &lt;&lt; 16)     // SHA (msg digest)
1349 #define KMAC_ZOPC   (unsigned  int)(0xb9 &lt;&lt; 24 | 0x1e &lt;&lt; 16)     // Message Authentication Code
1350 
1351 // Various
1352 #define TCEB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 16)
1353 #define TCDB_ZOPC   (unsigned long)(237L &lt;&lt; 40 | 17)
1354 #define TAM_ZOPC    (unsigned long)(267)
1355 
1356 #define FLOGR_ZOPC  (unsigned  int)(0xb9 &lt;&lt; 24 | 0x83 &lt;&lt; 16)
1357 #define POPCNT_ZOPC (unsigned  int)(0xb9e1 &lt;&lt; 16)
1358 #define AHHHR_ZOPC  (unsigned  int)(0xb9c8 &lt;&lt; 16)
1359 #define AHHLR_ZOPC  (unsigned  int)(0xb9d8 &lt;&lt; 16)
1360 
1361 
1362 // OpCode field masks
1363 
1364 #define RI_MASK     (unsigned  int)(0xff  &lt;&lt; 24 | 0x0f &lt;&lt; 16)
1365 #define RRE_MASK    (unsigned  int)(0xff  &lt;&lt; 24 | 0xff &lt;&lt; 16)
1366 #define RSI_MASK    (unsigned  int)(0xff  &lt;&lt; 24)
1367 #define RIE_MASK    (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1368 #define RIL_MASK    (unsigned long)(0xffL &lt;&lt; 40 | 0x0fL &lt;&lt; 32)
1369 
1370 #define BASR_MASK   (unsigned  int)(0xff &lt;&lt; 8)
1371 #define BCR_MASK    (unsigned  int)(0xff &lt;&lt; 8)
1372 #define BRC_MASK    (unsigned  int)(0xff &lt;&lt; 24 | 0x0f &lt;&lt; 16)
1373 #define LGHI_MASK   (unsigned  int)(0xff &lt;&lt; 24 | 0x0f &lt;&lt; 16)
1374 #define LLI_MASK    (unsigned  int)(0xff &lt;&lt; 24 | 0x0f &lt;&lt; 16)
1375 #define II_MASK     (unsigned  int)(0xff &lt;&lt; 24 | 0x0f &lt;&lt; 16)
1376 #define LLIF_MASK   (unsigned long)(0xffL &lt;&lt; 40 | 0x0fL &lt;&lt; 32)
1377 #define IIF_MASK    (unsigned long)(0xffL &lt;&lt; 40 | 0x0fL &lt;&lt; 32)
1378 #define BRASL_MASK  (unsigned long)(0xffL &lt;&lt; 40 | 0x0fL &lt;&lt; 32)
1379 #define TM_MASK     (unsigned  int)(0xff &lt;&lt; 24)
1380 #define TMY_MASK    (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1381 #define LB_MASK     (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1382 #define LH_MASK     (unsigned int)(0xff &lt;&lt; 24)
1383 #define L_MASK      (unsigned int)(0xff &lt;&lt; 24)
1384 #define LY_MASK     (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1385 #define LG_MASK     (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1386 #define LLGH_MASK   (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1387 #define LLGF_MASK   (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1388 #define SLAG_MASK   (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1389 #define LARL_MASK   (unsigned long)(0xff0fL &lt;&lt; 32)
1390 #define LGRL_MASK   (unsigned long)(0xff0fL &lt;&lt; 32)
1391 #define LE_MASK     (unsigned int)(0xff &lt;&lt; 24)
1392 #define LD_MASK     (unsigned int)(0xff &lt;&lt; 24)
1393 #define ST_MASK     (unsigned int)(0xff &lt;&lt; 24)
1394 #define STC_MASK    (unsigned int)(0xff &lt;&lt; 24)
1395 #define STG_MASK    (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1396 #define STH_MASK    (unsigned int)(0xff &lt;&lt; 24)
1397 #define STE_MASK    (unsigned int)(0xff &lt;&lt; 24)
1398 #define STD_MASK    (unsigned int)(0xff &lt;&lt; 24)
1399 #define CMPBRANCH_MASK (unsigned long)(0xffL &lt;&lt; 40 | 0xffL)
1400 #define REL_LONG_MASK  (unsigned long)(0xff0fL &lt;&lt; 32)
1401 
1402  public:
1403   // Condition code masks. Details:
1404   // - Mask bit#3 must be zero for all compare and branch/trap instructions to ensure
1405   //   future compatibility.
1406   // - For all arithmetic instructions which set the condition code, mask bit#3
1407   //   indicates overflow (&quot;unordered&quot; in float operations).
1408   // - &quot;unordered&quot; float comparison results have to be treated as low.
1409   // - When overflow/unordered is detected, none of the branch conditions is true,
1410   //   except for bcondOverflow/bcondNotOrdered and bcondAlways.
1411   // - For INT comparisons, the inverse condition can be calculated as (14-cond).
1412   // - For FLOAT comparisons, the inverse condition can be calculated as (15-cond).
1413   enum branch_condition {
1414     bcondNever       =  0,
1415     bcondAlways      = 15,
1416 
1417     // Specific names. Make use of lightweight sync.
1418     // Full and lightweight sync operation.
1419     bcondFullSync    = 15,
1420     bcondLightSync   = 14,
1421     bcondNop         =  0,
1422 
1423     // arithmetic compare instructions
1424     // arithmetic load and test, insert instructions
1425     // Mask bit#3 must be zero for future compatibility.
1426     bcondEqual       =  8,
1427     bcondNotEqual    =  6,
1428     bcondLow         =  4,
1429     bcondNotLow      = 10,
1430     bcondHigh        =  2,
1431     bcondNotHigh     = 12,
1432     // arithmetic calculation instructions
1433     // Mask bit#3 indicates overflow if detected by instr.
1434     // Mask bit#3 = 0 (overflow is not handled by compiler).
1435     bcondOverflow    =  1,
1436     bcondNotOverflow = 14,
1437     bcondZero        =  bcondEqual,
1438     bcondNotZero     =  bcondNotEqual,
1439     bcondNegative    =  bcondLow,
1440     bcondNotNegative =  bcondNotLow,
1441     bcondPositive    =  bcondHigh,
1442     bcondNotPositive =  bcondNotHigh,
1443     bcondNotOrdered  =  1,  // float comparisons
1444     bcondOrdered     = 14,  // float comparisons
1445     bcondLowOrNotOrdered  =  bcondLow  | bcondNotOrdered,  // float comparisons
1446     bcondHighOrNotOrdered =  bcondHigh | bcondNotOrdered,  // float comparisons
1447     bcondNotLowOrNotOrdered   =  bcondNotLow   | bcondNotOrdered,  // float comparisons
1448     bcondNotHighOrNotOrdered  =  bcondNotHigh  | bcondNotOrdered,  // float comparisons
1449     bcondNotEqualOrNotOrdered =  bcondNotEqual | bcondNotOrdered,  // float comparisons
1450     // unsigned arithmetic calculation instructions
1451     // Mask bit#0 is not used by these instructions.
1452     // There is no indication of overflow for these instr.
1453     bcondLogZero_NoCarry     =  8,
1454     bcondLogZero_Carry       =  2,
1455     // bcondLogZero_Borrow      =  8,  // This CC is never generated.
1456     bcondLogZero_NoBorrow    =  2,
1457     bcondLogZero             =  bcondLogZero_Carry | bcondLogZero_NoCarry,
1458     bcondLogNotZero_NoCarry  =  4,
1459     bcondLogNotZero_Carry    =  1,
1460     bcondLogNotZero_Borrow   =  4,
1461     bcondLogNotZero_NoBorrow =  1,
1462     bcondLogNotZero          =  bcondLogNotZero_Carry | bcondLogNotZero_NoCarry,
1463     bcondLogCarry            =  bcondLogZero_Carry | bcondLogNotZero_Carry,
1464     bcondLogBorrow           =  /* bcondLogZero_Borrow | */ bcondLogNotZero_Borrow,
1465     // Vector compare instructions
1466     bcondVAlltrue    =  8,  // All  vector elements evaluate true
1467     bcondVMixed      =  4,  // Some vector elements evaluate true, some false
1468     bcondVAllfalse   =  1,  // All  vector elements evaluate false
1469     // string search instructions
1470     bcondFound       =  4,
1471     bcondNotFound    =  2,
1472     bcondInterrupted =  1,
1473     // bit test instructions
1474     bcondAllZero     =  8,
1475     bcondMixed       =  6,
1476     bcondAllOne      =  1,
1477     bcondNotAllZero  =  7 // for tmll
1478   };
1479 
1480   enum Condition {
1481     // z/Architecture
1482     negative         = 0,
1483     less             = 0,
1484     positive         = 1,
1485     greater          = 1,
1486     zero             = 2,
1487     equal            = 2,
1488     summary_overflow = 3,
1489   };
1490 
1491   // Rounding mode for float-2-int conversions.
1492   enum RoundingMode {
1493     current_mode      = 0,   // Mode taken from FPC register.
1494     biased_to_nearest = 1,
1495     to_nearest        = 4,
1496     to_zero           = 5,
1497     to_plus_infinity  = 6,
1498     to_minus_infinity = 7
1499   };
1500 
1501   // Vector Register Element Type.
1502   enum VRegElemType {
1503     VRET_BYTE   = 0,
1504     VRET_HW     = 1,
1505     VRET_FW     = 2,
1506     VRET_DW     = 3,
1507     VRET_QW     = 4
1508   };
1509 
1510   // Vector Operation Result Control.
1511   //   This is a set of flags used in some vector instructions to control
1512   //   the result (side) effects of instruction execution.
1513   enum VOpRC {
1514     VOPRC_CCSET    = 0b0001, // set the CC.
1515     VOPRC_CCIGN    = 0b0000, // ignore, don&#39;t set CC.
1516     VOPRC_ZS       = 0b0010, // Zero Search. Additional, elementwise, comparison against zero.
1517     VOPRC_NOZS     = 0b0000, // No Zero Search.
1518     VOPRC_RTBYTEIX = 0b0100, // generate byte index to lowest element with true comparison.
1519     VOPRC_RTBITVEC = 0b0000, // generate bit vector, all 1s for true, all 0s for false element comparisons.
1520     VOPRC_INVERT   = 0b1000, // invert comparison results.
1521     VOPRC_NOINVERT = 0b0000  // use comparison results as is, do not invert.
1522   };
1523 
1524   // Inverse condition code, i.e. determine &quot;15 - cc&quot; for a given condition code cc.
1525   static branch_condition inverse_condition(branch_condition cc);
1526   static branch_condition inverse_float_condition(branch_condition cc);
1527 
1528 
1529   //-----------------------------------------------
1530   // instruction property getter methods
1531   //-----------------------------------------------
1532 
1533   // Calculate length of instruction.
<a name="4" id="anc4"></a><span class="line-modified">1534   static int instr_len(unsigned char *instr);</span>
1535 
1536   // Longest instructions are 6 bytes on z/Architecture.
<a name="5" id="anc5"></a><span class="line-modified">1537   static int instr_maxlen() { return 6; }</span>
1538 
1539   // Average instruction is 4 bytes on z/Architecture (just a guess).
<a name="6" id="anc6"></a><span class="line-modified">1540   static int instr_avglen() { return 4; }</span>
1541 
1542   // Shortest instructions are 2 bytes on z/Architecture.
<a name="7" id="anc7"></a><span class="line-modified">1543   static int instr_minlen() { return 2; }</span>
1544 
1545   // Move instruction at pc right-justified into passed long int.
1546   // Return instr len in bytes as function result.
1547   static unsigned int get_instruction(unsigned char *pc, unsigned long *instr);
1548 
1549   // Move instruction in passed (long int) into storage at pc.
1550   // This code is _NOT_ MT-safe!!
1551   static void set_instruction(unsigned char *pc, unsigned long instr, unsigned int len) {
1552     memcpy(pc, ((unsigned char *)&amp;instr)+sizeof(unsigned long)-len, len);
1553   }
1554 
1555 
1556   //------------------------------------------
1557   // instruction field test methods
1558   //------------------------------------------
1559 
1560   // Only used once in s390.ad to implement Matcher::is_short_branch_offset().
1561   static bool is_within_range_of_RelAddr16(address target, address origin) {
1562     return RelAddr::is_in_range_of_RelAddr16(target, origin);
1563   }
1564 
1565 
1566   //----------------------------------
1567   // some diagnostic output
1568   //----------------------------------
1569 
1570   static void print_dbg_msg(outputStream* out, unsigned long inst, const char* msg, int ilen) PRODUCT_RETURN;
1571   static void dump_code_range(outputStream* out, address pc, const unsigned int range, const char* msg = &quot; &quot;) PRODUCT_RETURN;
1572 
1573  protected:
1574 
1575   //-------------------------------------------------------
1576   // instruction field helper methods (internal)
1577   //-------------------------------------------------------
1578 
1579   // Return a mask of 1s between hi_bit and lo_bit (inclusive).
1580   static long fmask(unsigned int hi_bit, unsigned int lo_bit) {
1581     assert(hi_bit &gt;= lo_bit &amp;&amp; hi_bit &lt; 48, &quot;bad bits&quot;);
1582     return ((1L&lt;&lt;(hi_bit-lo_bit+1)) - 1) &lt;&lt; lo_bit;
1583   }
1584 
1585   // extract u_field
1586   // unsigned value
1587   static long inv_u_field(long x, int hi_bit, int lo_bit) {
1588     return (x &amp; fmask(hi_bit, lo_bit)) &gt;&gt; lo_bit;
1589   }
1590 
1591   // extract s_field
1592   // Signed value, may need sign extension.
1593   static long inv_s_field(long x, int hi_bit, int lo_bit) {
1594     x = inv_u_field(x, hi_bit, lo_bit);
1595     // Highest extracted bit set -&gt; sign extension.
1596     return (x &gt;= (1L&lt;&lt;(hi_bit-lo_bit)) ? x | ((-1L)&lt;&lt;(hi_bit-lo_bit)) : x);
1597   }
1598 
1599   // Extract primary opcode from instruction.
1600   static int z_inv_op(int  x) { return inv_u_field(x, 31, 24); }
1601   static int z_inv_op(long x) { return inv_u_field(x, 47, 40); }
1602 
1603   static int inv_reg( long x, int s, int len) { return inv_u_field(x, (len-s)-1, (len-s)-4); }  // Regs are encoded in 4 bits.
1604   static int inv_mask(long x, int s, int len) { return inv_u_field(x, (len-s)-1, (len-s)-8); }  // Mask is 8 bits long.
1605   static int inv_simm16_48(long x) { return (inv_s_field(x, 31, 16)); }                         // 6-byte instructions only
1606   static int inv_simm16(long x)    { return (inv_s_field(x, 15,  0)); }                         // 4-byte instructions only
1607   static int inv_simm20(long x)    { return (inv_u_field(x, 27, 16) |                           // 6-byte instructions only
1608                                              inv_s_field(x, 15, 8)&lt;&lt;12); }
1609   static int inv_simm32(long x)    { return (inv_s_field(x, 31,  0)); }                         // 6-byte instructions only
1610   static int inv_uimm12(long x)    { return (inv_u_field(x, 11,  0)); }                         // 4-byte instructions only
1611 
1612   // Encode u_field from long value.
1613   static long u_field(long x, int hi_bit, int lo_bit) {
1614     long r = x &lt;&lt; lo_bit;
1615     assert((r &amp; ~fmask(hi_bit, lo_bit))   == 0, &quot;value out of range&quot;);
1616     assert(inv_u_field(r, hi_bit, lo_bit) == x, &quot;just checking&quot;);
1617     return r;
1618   }
1619 
1620   static int64_t rsmask_48( Address a) { assert(a.is_RSform(),  &quot;bad address format&quot;); return rsmask_48( a.disp12(), a.base()); }
1621   static int64_t rxmask_48( Address a) {      if (a.is_RXform())  { return rxmask_48( a.disp12(), a.index(), a.base()); }
1622                                          else if (a.is_RSform())  { return rsmask_48( a.disp12(),            a.base()); }
1623                                          else                     { guarantee(false, &quot;bad address format&quot;);  return 0;  }
1624                                        }
1625   static int64_t rsymask_48(Address a) { assert(a.is_RSYform(), &quot;bad address format&quot;); return rsymask_48(a.disp20(), a.base()); }
1626   static int64_t rxymask_48(Address a) {      if (a.is_RXYform()) { return rxymask_48( a.disp20(), a.index(), a.base()); }
1627                                          else if (a.is_RSYform()) { return rsymask_48( a.disp20(),            a.base()); }
1628                                          else                     { guarantee(false, &quot;bad address format&quot;);  return 0;   }
1629                                        }
1630 
1631   static int64_t rsmask_48( int64_t d2, Register b2)              { return uimm12(d2, 20, 48)                   | regz(b2, 16, 48); }
1632   static int64_t rxmask_48( int64_t d2, Register x2, Register b2) { return uimm12(d2, 20, 48) | reg(x2, 12, 48) | regz(b2, 16, 48); }
1633   static int64_t rsymask_48(int64_t d2, Register b2)              { return simm20(d2)                           | regz(b2, 16, 48); }
1634   static int64_t rxymask_48(int64_t d2, Register x2, Register b2) { return simm20(d2)         | reg(x2, 12, 48) | regz(b2, 16, 48); }
1635 
1636   // Address calculated from d12(vx,b) - vx is vector index register.
1637   static int64_t rvmask_48( int64_t d2, VectorRegister x2, Register b2) { return uimm12(d2, 20, 48) | vreg(x2, 12) | regz(b2, 16, 48); }
1638 
1639   static int64_t vreg_mask(VectorRegister v, int pos) {
1640     return vreg(v, pos) | v-&gt;RXB_mask(pos);
1641   }
1642 
1643   // Vector Element Size Control. 4-bit field which indicates the size of the vector elements.
1644   static int64_t vesc_mask(int64_t size, int min_size, int max_size, int pos) {
1645     // min_size - minimum element size. Not all instructions support element sizes beginning with &quot;byte&quot;.
1646     // max_size - maximum element size. Not all instructions support element sizes up to &quot;QW&quot;.
1647     assert((min_size &lt;= size) &amp;&amp; (size &lt;= max_size), &quot;element size control out of range&quot;);
1648     return uimm4(size, pos, 48);
1649   }
1650 
1651   // Vector Element IndeX. 4-bit field which indexes the target vector element.
1652   static int64_t veix_mask(int64_t ix, int el_size, int pos) {
1653     // el_size - size of the vector element. This is a VRegElemType enum value.
1654     // ix      - vector element index.
1655     int max_ix = -1;
1656     switch (el_size) {
1657       case VRET_BYTE: max_ix = 15; break;
1658       case VRET_HW:   max_ix =  7; break;
1659       case VRET_FW:   max_ix =  3; break;
1660       case VRET_DW:   max_ix =  1; break;
1661       case VRET_QW:   max_ix =  0; break;
1662       default:        guarantee(false, &quot;bad vector element size %d&quot;, el_size); break;
1663     }
1664     assert((0 &lt;= ix) &amp;&amp; (ix &lt;= max_ix), &quot;element size out of range (0 &lt;= %ld &lt;= %d)&quot;, ix, max_ix);
1665     return uimm4(ix, pos, 48);
1666   }
1667 
1668   // Vector Operation Result Control. 4-bit field.
1669   static int64_t voprc_any(int64_t flags, int pos, int64_t allowed_flags = 0b1111) {
1670     assert((flags &amp; allowed_flags) == flags, &quot;Invalid VOPRC_* flag combination: %d&quot;, (int)flags);
1671     return uimm4(flags, pos, 48);
1672   }
1673 
1674   // Vector Operation Result Control. Condition code setting.
1675   static int64_t voprc_ccmask(int64_t flags, int pos) {
1676     return voprc_any(flags, pos, VOPRC_CCIGN | VOPRC_CCSET);
1677   }
1678 
1679  public:
1680 
1681   //--------------------------------------------------
1682   // instruction field construction methods
1683   //--------------------------------------------------
1684 
1685   // Compute relative address (32 bit) for branch.
1686   // Only used once in nativeInst_s390.cpp.
1687   static intptr_t z_pcrel_off(address dest, address pc) {
1688     return RelAddr::pcrel_off32(dest, pc);
1689   }
1690 
1691   // Extract 20-bit signed displacement.
1692   // Only used in disassembler_s390.cpp for temp enhancements.
1693   static int inv_simm20_xx(address iLoc) {
1694     unsigned long instr = 0;
1695     unsigned long iLen  = get_instruction(iLoc, &amp;instr);
1696     return inv_simm20(instr);
1697   }
1698 
1699   // unsigned immediate, in low bits, nbits long
1700   static long uimm(long x, int nbits) {
1701     assert(Immediate::is_uimm(x, nbits), &quot;unsigned constant out of range&quot;);
1702     return x &amp; fmask(nbits - 1, 0);
1703   }
1704 
1705   // Cast &#39;1&#39; to long to avoid sign extension if nbits = 32.
1706   // signed immediate, in low bits, nbits long
1707   static long simm(long x, int nbits) {
1708     assert(Immediate::is_simm(x, nbits), &quot;value out of range&quot;);
1709     return x &amp; fmask(nbits - 1, 0);
1710   }
1711 
1712   static long imm(int64_t x, int nbits) {
1713     // Assert that x can be represented with nbits bits ignoring the sign bits,
1714     // i.e. the more higher bits should all be 0 or 1.
1715     assert((x &gt;&gt; nbits) == 0 || (x &gt;&gt; nbits) == -1, &quot;value out of range&quot;);
1716     return x &amp; fmask(nbits-1, 0);
1717   }
1718 
1719   // A 20-bit displacement is only in instructions of the
1720   // RSY, RXY, or SIY format. In these instructions, the D
1721   // field consists of a DL (low) field in bit positions 20-31
1722   // and of a DH (high) field in bit positions 32-39. The
1723   // value of the displacement is formed by appending the
1724   // contents of the DH field to the left of the contents of
1725   // the DL field.
1726   static long simm20(int64_t ui20) {
1727     assert(Immediate::is_simm(ui20, 20), &quot;value out of range&quot;);
1728     return ( ((ui20        &amp; 0xfffL) &lt;&lt; (48-32)) |  // DL
1729             (((ui20 &gt;&gt; 12) &amp;  0xffL) &lt;&lt; (48-40)));  // DH
1730   }
1731 
1732   static long reg(Register r, int s, int len)  { return u_field(r-&gt;encoding(), (len-s)-1, (len-s)-4); }
1733   static long reg(int r, int s, int len)       { return u_field(r,             (len-s)-1, (len-s)-4); }
1734   static long regt(Register r, int s, int len) { return reg(r, s, len); }
1735   static long regz(Register r, int s, int len) { assert(r != Z_R0, &quot;cannot use register R0 in memory access&quot;); return reg(r, s, len); }
1736 
1737   static long uimm4( int64_t ui4,  int s, int len) { return uimm(ui4,   4) &lt;&lt; (len-s-4);  }
1738   static long uimm6( int64_t ui6,  int s, int len) { return uimm(ui6,   6) &lt;&lt; (len-s-6);  }
1739   static long uimm8( int64_t ui8,  int s, int len) { return uimm(ui8,   8) &lt;&lt; (len-s-8);  }
1740   static long uimm12(int64_t ui12, int s, int len) { return uimm(ui12, 12) &lt;&lt; (len-s-12); }
1741   static long uimm16(int64_t ui16, int s, int len) { return uimm(ui16, 16) &lt;&lt; (len-s-16); }
1742   static long uimm32(int64_t ui32, int s, int len) { return uimm((unsigned)ui32, 32) &lt;&lt; (len-s-32); } // prevent sign extension
1743 
1744   static long simm8( int64_t si8,  int s, int len) { return simm(si8,   8) &lt;&lt; (len-s-8);  }
1745   static long simm12(int64_t si12, int s, int len) { return simm(si12, 12) &lt;&lt; (len-s-12); }
1746   static long simm16(int64_t si16, int s, int len) { return simm(si16, 16) &lt;&lt; (len-s-16); }
1747   static long simm24(int64_t si24, int s, int len) { return simm(si24, 24) &lt;&lt; (len-s-24); }
1748   static long simm32(int64_t si32, int s, int len) { return simm(si32, 32) &lt;&lt; (len-s-32); }
1749 
1750   static long imm8( int64_t i8,  int s, int len)   { return imm(i8,   8) &lt;&lt; (len-s-8);  }
1751   static long imm12(int64_t i12, int s, int len)   { return imm(i12, 12) &lt;&lt; (len-s-12); }
1752   static long imm16(int64_t i16, int s, int len)   { return imm(i16, 16) &lt;&lt; (len-s-16); }
1753   static long imm24(int64_t i24, int s, int len)   { return imm(i24, 24) &lt;&lt; (len-s-24); }
1754   static long imm32(int64_t i32, int s, int len)   { return imm(i32, 32) &lt;&lt; (len-s-32); }
1755 
1756   static long vreg(VectorRegister v, int pos)      { const int len = 48; return u_field(v-&gt;encoding()&amp;0x0f, (len-pos)-1, (len-pos)-4) | v-&gt;RXB_mask(pos); }
1757 
1758   static long fregt(FloatRegister r, int s, int len) { return freg(r,s,len); }
1759   static long freg( FloatRegister r, int s, int len) { return u_field(r-&gt;encoding(), (len-s)-1, (len-s)-4); }
1760 
1761   // Rounding mode for float-2-int conversions.
1762   static long rounding_mode(RoundingMode m, int s, int len) {
1763     assert(m != 2 &amp;&amp; m != 3, &quot;invalid mode&quot;);
1764     return uimm(m, 4) &lt;&lt; (len-s-4);
1765   }
1766 
1767   //--------------------------------------------
1768   // instruction field getter methods
1769   //--------------------------------------------
1770 
1771   static int get_imm32(address a, int instruction_number) {
1772     int imm;
1773     int *p =((int *)(a + 2 + 6 * instruction_number));
1774     imm = *p;
1775     return imm;
1776   }
1777 
1778   static short get_imm16(address a, int instruction_number) {
1779     short imm;
1780     short *p =((short *)a) + 2 * instruction_number + 1;
1781     imm = *p;
1782     return imm;
1783   }
1784 
1785 
1786   //--------------------------------------------
1787   // instruction field setter methods
1788   //--------------------------------------------
1789 
1790   static void set_imm32(address a, int64_t s) {
1791     assert(Immediate::is_simm32(s) || Immediate::is_uimm32(s), &quot;to big&quot;);
1792     int* p = (int *) (a + 2);
1793     *p = s;
1794   }
1795 
1796   static void set_imm16(int* instr, int64_t s) {
1797     assert(Immediate::is_simm16(s) || Immediate::is_uimm16(s), &quot;to big&quot;);
1798     short* p = ((short *)instr) + 1;
1799     *p = s;
1800   }
1801 
1802  public:
1803 
1804   static unsigned int align(unsigned int x, unsigned int a) { return ((x + (a - 1)) &amp; ~(a - 1)); }
1805   static bool    is_aligned(unsigned int x, unsigned int a) { return (0 == x % a); }
1806 
1807   inline void emit_16(int x);
1808   inline void emit_32(int x);
1809   inline void emit_48(long x);
1810 
1811   // Compare and control flow instructions
1812   // =====================================
1813 
1814   // See also commodity routines compare64_and_branch(), compare32_and_branch().
1815 
1816   // compare instructions
1817   // compare register
1818   inline void z_cr(  Register r1, Register r2);                          // compare (r1, r2)        ; int32
1819   inline void z_cgr( Register r1, Register r2);                          // compare (r1, r2)        ; int64
1820   inline void z_cgfr(Register r1, Register r2);                          // compare (r1, r2)        ; int64 &lt;--&gt; int32
1821    // compare immediate
1822   inline void z_chi( Register r1, int64_t i2);                           // compare (r1, i2_imm16)  ; int32
1823   inline void z_cfi( Register r1, int64_t i2);                           // compare (r1, i2_imm32)  ; int32
1824   inline void z_cghi(Register r1, int64_t i2);                           // compare (r1, i2_imm16)  ; int64
1825   inline void z_cgfi(Register r1, int64_t i2);                           // compare (r1, i2_imm32)  ; int64
1826    // compare memory
1827   inline void z_ch(  Register r1, const Address &amp;a);                     // compare (r1, *(a))               ; int32 &lt;--&gt; int16
1828   inline void z_ch(  Register r1, int64_t d2, Register x2, Register b2); // compare (r1, *(d2_uimm12+x2+b2)) ; int32 &lt;--&gt; int16
1829   inline void z_c(   Register r1, const Address &amp;a);                     // compare (r1, *(a))               ; int32
1830   inline void z_c(   Register r1, int64_t d2, Register x2, Register b2); // compare (r1, *(d2_uimm12+x2+b2)) ; int32
1831   inline void z_cy(  Register r1, int64_t d2, Register x2, Register b2); // compare (r1, *(d2_uimm20+x2+b2)) ; int32
1832   inline void z_cy(  Register r1, int64_t d2, Register b2);              // compare (r1, *(d2_uimm20+x2+b2)) ; int32
1833   inline void z_cy(  Register r1, const Address&amp; a);                     // compare (r1, *(a))               ; int32
1834    //inline void z_cgf(Register r1,const Address &amp;a);                    // compare (r1, *(a))               ; int64 &lt;--&gt; int32
1835    //inline void z_cgf(Register r1,int64_t d2, Register x2, Register b2);// compare (r1, *(d2_uimm12+x2+b2)) ; int64 &lt;--&gt; int32
1836   inline void z_cg(  Register r1, const Address &amp;a);                     // compare (r1, *(a))               ; int64
1837   inline void z_cg(  Register r1, int64_t d2, Register x2, Register b2); // compare (r1, *(d2_imm20+x2+b2))  ; int64
1838 
1839    // compare logical instructions
1840    // compare register
1841   inline void z_clr(  Register r1, Register r2);                         // compare (r1, r2)                 ; uint32
1842   inline void z_clgr( Register r1, Register r2);                         // compare (r1, r2)                 ; uint64
1843    // compare immediate
1844   inline void z_clfi( Register r1, int64_t i2);                          // compare (r1, i2_uimm32)          ; uint32
1845   inline void z_clgfi(Register r1, int64_t i2);                          // compare (r1, i2_uimm32)          ; uint64
1846   inline void z_cl(   Register r1, const Address &amp;a);                    // compare (r1, *(a)                ; uint32
1847   inline void z_cl(   Register r1, int64_t d2, Register x2, Register b2);// compare (r1, *(d2_uimm12+x2+b2)  ; uint32
1848   inline void z_cly(  Register r1, int64_t d2, Register x2, Register b2);// compare (r1, *(d2_uimm20+x2+b2)) ; uint32
1849   inline void z_cly(  Register r1, int64_t d2, Register b2);             // compare (r1, *(d2_uimm20+x2+b2)) ; uint32
1850   inline void z_cly(  Register r1, const Address&amp; a);                    // compare (r1, *(a))               ; uint32
1851   inline void z_clg(  Register r1, const Address &amp;a);                    // compare (r1, *(a)                ; uint64
1852   inline void z_clg(  Register r1, int64_t d2, Register x2, Register b2);// compare (r1, *(d2_imm20+x2+b2)   ; uint64
1853 
1854   // test under mask
1855   inline void z_tmll(Register r1, int64_t i2);           // test under mask, see docu
1856   inline void z_tmlh(Register r1, int64_t i2);           // test under mask, see docu
1857   inline void z_tmhl(Register r1, int64_t i2);           // test under mask, see docu
1858   inline void z_tmhh(Register r1, int64_t i2);           // test under mask, see docu
1859 
1860   // branch instructions
1861   inline void z_bc(  branch_condition m1, int64_t d2, Register x2, Register b2);// branch  m1 ? pc = (d2_uimm12+x2+b2)
1862   inline void z_bcr( branch_condition m1, Register r2);                         // branch (m1 &amp;&amp; r2!=R0) ? pc = r2
1863   inline void z_brc( branch_condition i1, int64_t i2);                          // branch  i1 ? pc = pc + i2_imm16
1864   inline void z_brc( branch_condition i1, address a);                           // branch  i1 ? pc = a
1865   inline void z_brc( branch_condition i1, Label&amp; L);                            // branch  i1 ? pc = Label
1866   //inline void z_brcl(branch_condition i1, int64_t i2);                        // branch  i1 ? pc = pc + i2_imm32
1867   inline void z_brcl(branch_condition i1, address a);                           // branch  i1 ? pc = a
1868   inline void z_brcl(branch_condition i1, Label&amp; L);                            // branch  i1 ? pc = Label
1869   inline void z_bctgr(Register r1, Register r2);         // branch on count r1 -= 1; (r1!=0) ? pc = r2  ; r1 is int64
1870 
1871   // branch unconditional / always
1872   inline void z_br(Register r2);                         // branch to r2, nop if r2 == Z_R0
1873 
1874 
1875   // See also commodity routines compare64_and_branch(), compare32_and_branch().
1876   // signed comparison and branch
1877   inline void z_crb( Register r1, Register r2, branch_condition m3, int64_t d4, Register b4); // (r1 m3 r2) ? goto b4+d4      ; int32  -- z10
1878   inline void z_cgrb(Register r1, Register r2, branch_condition m3, int64_t d4, Register b4); // (r1 m3 r2) ? goto b4+d4      ; int64  -- z10
1879   inline void z_crj( Register r1, Register r2, branch_condition m3, Label&amp; L);                // (r1 m3 r2) ? goto L          ; int32  -- z10
1880   inline void z_crj( Register r1, Register r2, branch_condition m3, address a4);              // (r1 m3 r2) ? goto (pc+a4&lt;&lt;1) ; int32  -- z10
1881   inline void z_cgrj(Register r1, Register r2, branch_condition m3, Label&amp; L);                // (r1 m3 r2) ? goto L          ; int64  -- z10
1882   inline void z_cgrj(Register r1, Register r2, branch_condition m3, address a4);              // (r1 m3 r2) ? goto (pc+a4&lt;&lt;1) ; int64  -- z10
1883   inline void z_cib( Register r1, int64_t i2, branch_condition m3, int64_t d4, Register b4);  // (r1 m3 i2_imm8) ? goto b4+d4      ; int32  -- z10
1884   inline void z_cgib(Register r1, int64_t i2, branch_condition m3, int64_t d4, Register b4);  // (r1 m3 i2_imm8) ? goto b4+d4      ; int64  -- z10
1885   inline void z_cij( Register r1, int64_t i2, branch_condition m3, Label&amp; L);                 // (r1 m3 i2_imm8) ? goto L          ; int32  -- z10
1886   inline void z_cij( Register r1, int64_t i2, branch_condition m3, address a4);               // (r1 m3 i2_imm8) ? goto (pc+a4&lt;&lt;1) ; int32  -- z10
1887   inline void z_cgij(Register r1, int64_t i2, branch_condition m3, Label&amp; L);                 // (r1 m3 i2_imm8) ? goto L          ; int64  -- z10
1888   inline void z_cgij(Register r1, int64_t i2, branch_condition m3, address a4);               // (r1 m3 i2_imm8) ? goto (pc+a4&lt;&lt;1) ; int64  -- z10
1889   // unsigned comparison and branch
1890   inline void z_clrb( Register r1, Register r2, branch_condition m3, int64_t d4, Register b4);// (r1 m3 r2) ? goto b4+d4      ; uint32  -- z10
1891   inline void z_clgrb(Register r1, Register r2, branch_condition m3, int64_t d4, Register b4);// (r1 m3 r2) ? goto b4+d4      ; uint64  -- z10
1892   inline void z_clrj( Register r1, Register r2, branch_condition m3, Label&amp; L);               // (r1 m3 r2) ? goto L          ; uint32  -- z10
1893   inline void z_clrj( Register r1, Register r2, branch_condition m3, address a4);             // (r1 m3 r2) ? goto (pc+a4&lt;&lt;1) ; uint32  -- z10
1894   inline void z_clgrj(Register r1, Register r2, branch_condition m3, Label&amp; L);               // (r1 m3 r2) ? goto L          ; uint64  -- z10
1895   inline void z_clgrj(Register r1, Register r2, branch_condition m3, address a4);             // (r1 m3 r2) ? goto (pc+a4&lt;&lt;1) ; uint64  -- z10
1896   inline void z_clib( Register r1, int64_t i2, branch_condition m3, int64_t d4, Register b4); // (r1 m3 i2_uimm8) ? goto b4+d4      ; uint32  -- z10
1897   inline void z_clgib(Register r1, int64_t i2, branch_condition m3, int64_t d4, Register b4); // (r1 m3 i2_uimm8) ? goto b4+d4      ; uint64  -- z10
1898   inline void z_clij( Register r1, int64_t i2, branch_condition m3, Label&amp; L);                // (r1 m3 i2_uimm8) ? goto L          ; uint32  -- z10
1899   inline void z_clij( Register r1, int64_t i2, branch_condition m3, address a4);              // (r1 m3 i2_uimm8) ? goto (pc+a4&lt;&lt;1) ; uint32  -- z10
1900   inline void z_clgij(Register r1, int64_t i2, branch_condition m3, Label&amp; L);                // (r1 m3 i2_uimm8) ? goto L          ; uint64  -- z10
1901   inline void z_clgij(Register r1, int64_t i2, branch_condition m3, address a4);              // (r1 m3 i2_uimm8) ? goto (pc+a4&lt;&lt;1) ; uint64  -- z10
1902 
1903   // Compare and trap instructions.
1904   // signed comparison
1905   inline void z_crt(Register r1,  Register r2, int64_t m3);  // (r1 m3 r2)        ? trap ; int32  -- z10
1906   inline void z_cgrt(Register r1, Register r2, int64_t m3);  // (r1 m3 r2)        ? trap ; int64  -- z10
1907   inline void z_cit(Register r1,  int64_t i2, int64_t m3);   // (r1 m3 i2_imm16)  ? trap ; int32  -- z10
1908   inline void z_cgit(Register r1, int64_t i2, int64_t m3);   // (r1 m3 i2_imm16)  ? trap ; int64  -- z10
1909   // unsigned comparison
1910   inline void z_clrt(Register r1,  Register r2, int64_t m3); // (r1 m3 r2)        ? trap ; uint32 -- z10
1911   inline void z_clgrt(Register r1, Register r2, int64_t m3); // (r1 m3 r2)        ? trap ; uint64 -- z10
1912   inline void z_clfit(Register r1,  int64_t i2, int64_t m3); // (r1 m3 i2_uimm16) ? trap ; uint32 -- z10
1913   inline void z_clgit(Register r1, int64_t i2, int64_t m3);  // (r1 m3 i2_uimm16) ? trap ; uint64 -- z10
1914 
1915   inline void z_illtrap();
1916   inline void z_illtrap(int id);
1917   inline void z_illtrap_eyecatcher(unsigned short xpattern, unsigned short pattern);
1918 
1919 
1920   // load address, add for addresses
1921   // ===============================
1922 
1923   // The versions without suffix z assert that the base reg is != Z_R0.
1924   // Z_R0 is interpreted as constant &#39;0&#39;. The variants with Address operand
1925   // check this automatically, so no two versions are needed.
1926   inline void z_layz(Register r1, int64_t d2, Register x2, Register b2); // Special version. Allows Z_R0 as base reg.
1927   inline void z_lay(Register r1, const Address &amp;a);                      // r1 = a
1928   inline void z_lay(Register r1, int64_t d2, Register x2, Register b2);  // r1 = d2_imm20+x2+b2
1929   inline void z_laz(Register r1, int64_t d2, Register x2, Register b2);  // Special version. Allows Z_R0 as base reg.
1930   inline void z_la(Register r1, const Address &amp;a);                       // r1 = a                ; unsigned immediate!
1931   inline void z_la(Register r1, int64_t d2, Register x2, Register b2);   // r1 = d2_uimm12+x2+b2  ; unsigned immediate!
1932   inline void z_larl(Register r1, int64_t i2);                           // r1 = pc + i2_imm32&lt;&lt;1;
1933   inline void z_larl(Register r1, address a2);                           // r1 = pc + i2_imm32&lt;&lt;1;
1934 
1935   // Load instructions for integers
1936   // ==============================
1937 
1938   // Address as base + index + offset
1939   inline void z_lb( Register r1, const Address &amp;a);                     // load r1 = *(a)              ; int32 &lt;- int8
1940   inline void z_lb( Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm20+x2+b2) ; int32 &lt;- int8
1941   inline void z_lh( Register r1, const Address &amp;a);                     // load r1 = *(a)              ; int32 &lt;- int16
1942   inline void z_lh( Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_uimm12+x2+b2); int32 &lt;- int16
1943   inline void z_lhy(Register r1, const Address &amp;a);                     // load r1 = *(a)              ; int32 &lt;- int16
1944   inline void z_lhy(Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm20+x2+b2) ; int32 &lt;- int16
1945   inline void z_l(  Register r1, const Address&amp; a);                     // load r1 = *(a)              ; int32
1946   inline void z_l(  Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_uimm12+x2+b2); int32
1947   inline void z_ly( Register r1, const Address&amp; a);                     // load r1 = *(a)              ; int32
1948   inline void z_ly( Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm20+x2+b2) ; int32
1949 
1950   inline void z_lgb(Register r1, const Address &amp;a);                     // load r1 = *(a)              ; int64 &lt;- int8
1951   inline void z_lgb(Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm20+x2+b2) ; int64 &lt;- int8
1952   inline void z_lgh(Register r1, const Address &amp;a);                     // load r1 = *(a)              ; int64 &lt;- int16
1953   inline void z_lgh(Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm12+x2+b2) ; int64 &lt;- int16
1954   inline void z_lgf(Register r1, const Address &amp;a);                     // load r1 = *(a)              ; int64 &lt;- int32
1955   inline void z_lgf(Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm20+x2+b2) ; int64 &lt;- int32
1956   inline void z_lg( Register r1, const Address&amp; a);                     // load r1 = *(a)              ; int64 &lt;- int64
1957   inline void z_lg( Register r1, int64_t d2, Register x2, Register b2); // load r1 = *(d2_imm20+x2+b2) ; int64 &lt;- int64
1958 
1959   // load and test
1960   inline void z_lt(  Register r1, const Address &amp;a);                    // load and test r1 = *(a)              ; int32
1961   inline void z_lt(  Register r1, int64_t d2, Register x2, Register b2);// load and test r1 = *(d2_imm20+x2+b2) ; int32
1962   inline void z_ltg( Register r1, const Address &amp;a);                    // load and test r1 = *(a)              ; int64
1963   inline void z_ltg( Register r1, int64_t d2, Register x2, Register b2);// load and test r1 = *(d2_imm20+x2+b2) ; int64
1964   inline void z_ltgf(Register r1, const Address &amp;a);                    // load and test r1 = *(a)              ; int64 &lt;- int32
1965   inline void z_ltgf(Register r1, int64_t d2, Register x2, Register b2);// load and test r1 = *(d2_imm20+x2+b2) ; int64 &lt;- int32
1966 
1967   // load unsigned integer - zero extended
1968   inline void z_llc( Register r1, const Address&amp; a);                    // load r1 = *(a)              ; uint32 &lt;- uint8
1969   inline void z_llc( Register r1, int64_t d2, Register x2, Register b2);// load r1 = *(d2_imm20+x2+b2) ; uint32 &lt;- uint8
1970   inline void z_llh( Register r1, const Address&amp; a);                    // load r1 = *(a)              ; uint32 &lt;- uint16
1971   inline void z_llh( Register r1, int64_t d2, Register x2, Register b2);// load r1 = *(d2_imm20+x2+b2) ; uint32 &lt;- uint16
1972   inline void z_llgc(Register r1, const Address&amp; a);                    // load r1 = *(a)              ; uint64 &lt;- uint8
1973   inline void z_llgc(Register r1, int64_t d2, Register x2, Register b2);// load r1 = *(d2_imm20+x2+b2) ; uint64 &lt;- uint8
1974   inline void z_llgc( Register r1, int64_t d2, Register b2);            // load r1 = *(d2_imm20+b2)    ; uint64 &lt;- uint8
1975   inline void z_llgh(Register r1, const Address&amp; a);                    // load r1 = *(a)              ; uint64 &lt;- uint16
1976   inline void z_llgh(Register r1, int64_t d2, Register x2, Register b2);// load r1 = *(d2_imm20+x2+b2) ; uint64 &lt;- uint16
1977   inline void z_llgf(Register r1, const Address&amp; a);                    // load r1 = *(a)              ; uint64 &lt;- uint32
1978   inline void z_llgf(Register r1, int64_t d2, Register x2, Register b2);// load r1 = *(d2_imm20+x2+b2) ; uint64 &lt;- uint32
1979 
1980   // pc relative addressing
1981   inline void z_lhrl( Register r1, int64_t i2);   // load r1 = *(pc + i2_imm32&lt;&lt;1) ; int32 &lt;- int16    -- z10
1982   inline void z_lrl(  Register r1, int64_t i2);   // load r1 = *(pc + i2_imm32&lt;&lt;1) ; int32             -- z10
1983   inline void z_lghrl(Register r1, int64_t i2);   // load r1 = *(pc + i2_imm32&lt;&lt;1) ; int64 &lt;- int16    -- z10
1984   inline void z_lgfrl(Register r1, int64_t i2);   // load r1 = *(pc + i2_imm32&lt;&lt;1) ; int64 &lt;- int32    -- z10
1985   inline void z_lgrl( Register r1, int64_t i2);   // load r1 = *(pc + i2_imm32&lt;&lt;1) ; int64             -- z10
1986 
1987   inline void z_llhrl( Register r1, int64_t i2);  // load r1 = *(pc + i2_imm32&lt;&lt;1) ; uint32 &lt;- uint16  -- z10
1988   inline void z_llghrl(Register r1, int64_t i2);  // load r1 = *(pc + i2_imm32&lt;&lt;1) ; uint64 &lt;- uint16  -- z10
1989   inline void z_llgfrl(Register r1, int64_t i2);  // load r1 = *(pc + i2_imm32&lt;&lt;1) ; uint64 &lt;- uint32  -- z10
1990 
1991   // Store instructions for integers
1992   // ===============================
1993 
1994   // Address as base + index + offset
1995   inline void z_stc( Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int8
1996   inline void z_stc( Register r1, int64_t d2, Register x2, Register b2); // store *(d2_uimm12+x2+b2) = r1  ; int8
1997   inline void z_stcy(Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int8
1998   inline void z_stcy(Register r1, int64_t d2, Register x2, Register b2); // store *(d2_imm20+x2+b2)  = r1  ; int8
1999   inline void z_sth( Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int16
2000   inline void z_sth( Register r1, int64_t d2, Register x2, Register b2); // store *(d2_uimm12+x2+b2) = r1  ; int16
2001   inline void z_sthy(Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int16
2002   inline void z_sthy(Register r1, int64_t d2, Register x2, Register b2); // store *(d2_imm20+x2+b2)  = r1  ; int16
2003   inline void z_st(  Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int32
2004   inline void z_st(  Register r1, int64_t d2, Register x2, Register b2); // store *(d2_uimm12+x2+b2) = r1  ; int32
2005   inline void z_sty( Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int32
2006   inline void z_sty( Register r1, int64_t d2, Register x2, Register b2); // store *(d2_imm20+x2+b2)  = r1  ; int32
2007   inline void z_stg( Register r1, const Address &amp;d);                     // store *(a)               = r1  ; int64
2008   inline void z_stg( Register r1, int64_t d2, Register x2, Register b2); // store *(d2_uimm12+x2+b2) = r1  ; int64
2009 
2010   inline void z_stcm( Register r1, int64_t m3, int64_t d2, Register b2); // store character under mask
2011   inline void z_stcmy(Register r1, int64_t m3, int64_t d2, Register b2); // store character under mask
2012   inline void z_stcmh(Register r1, int64_t m3, int64_t d2, Register b2); // store character under mask
2013 
2014   // pc relative addressing
2015   inline void z_sthrl(Register r1, int64_t i2);   // store *(pc + i2_imm32&lt;&lt;1) = r1 ; int16  -- z10
2016   inline void z_strl( Register r1, int64_t i2);   // store *(pc + i2_imm32&lt;&lt;1) = r1 ; int32  -- z10
2017   inline void z_stgrl(Register r1, int64_t i2);   // store *(pc + i2_imm32&lt;&lt;1) = r1 ; int64  -- z10
2018 
2019 
2020   // Load and store immediates
2021   // =========================
2022 
2023   // load immediate
2024   inline void z_lhi( Register r1, int64_t i2);                  // r1 = i2_imm16    ; int32 &lt;- int16
2025   inline void z_lghi(Register r1, int64_t i2);                  // r1 = i2_imm16    ; int64 &lt;- int16
2026   inline void z_lgfi(Register r1, int64_t i2);                  // r1 = i2_imm32    ; int64 &lt;- int32
2027 
2028   inline void z_llihf(Register r1, int64_t i2);                 // r1 = i2_imm32    ; uint64 &lt;- (uint32&lt;&lt;32)
2029   inline void z_llilf(Register r1, int64_t i2);                 // r1 = i2_imm32    ; uint64 &lt;- uint32
2030   inline void z_llihh(Register r1, int64_t i2);                 // r1 = i2_imm16    ; uint64 &lt;- (uint16&lt;&lt;48)
2031   inline void z_llihl(Register r1, int64_t i2);                 // r1 = i2_imm16    ; uint64 &lt;- (uint16&lt;&lt;32)
2032   inline void z_llilh(Register r1, int64_t i2);                 // r1 = i2_imm16    ; uint64 &lt;- (uint16&lt;&lt;16)
2033   inline void z_llill(Register r1, int64_t i2);                 // r1 = i2_imm16    ; uint64 &lt;- uint16
2034 
2035   // insert immediate
2036   inline void z_ic(  Register r1, int64_t d2, Register x2, Register b2); // insert character
2037   inline void z_icy( Register r1, int64_t d2, Register x2, Register b2); // insert character
2038   inline void z_icm( Register r1, int64_t m3, int64_t d2, Register b2);  // insert character under mask
2039   inline void z_icmy(Register r1, int64_t m3, int64_t d2, Register b2);  // insert character under mask
2040   inline void z_icmh(Register r1, int64_t m3, int64_t d2, Register b2);  // insert character under mask
2041 
2042   inline void z_iihh(Register r1, int64_t i2);                  // insert immediate  r1[ 0-15] = i2_imm16
2043   inline void z_iihl(Register r1, int64_t i2);                  // insert immediate  r1[16-31] = i2_imm16
2044   inline void z_iilh(Register r1, int64_t i2);                  // insert immediate  r1[32-47] = i2_imm16
2045   inline void z_iill(Register r1, int64_t i2);                  // insert immediate  r1[48-63] = i2_imm16
2046   inline void z_iihf(Register r1, int64_t i2);                  // insert immediate  r1[32-63] = i2_imm32
2047   inline void z_iilf(Register r1, int64_t i2);                  // insert immediate  r1[ 0-31] = i2_imm32
2048 
2049   // store immediate
2050   inline void z_mvhhi(const Address &amp;d, int64_t i2);            // store *(d)           = i2_imm16 ; int16
2051   inline void z_mvhhi(int64_t d1, Register b1, int64_t i2);     // store *(d1_imm12+b1) = i2_imm16 ; int16
2052   inline void z_mvhi( const Address &amp;d, int64_t i2);            // store *(d)           = i2_imm16 ; int32
2053   inline void z_mvhi( int64_t d1, Register b1, int64_t i2);     // store *(d1_imm12+b1) = i2_imm16 ; int32
2054   inline void z_mvghi(const Address &amp;d, int64_t i2);            // store *(d)           = i2_imm16 ; int64
2055   inline void z_mvghi(int64_t d1, Register b1, int64_t i2);     // store *(d1_imm12+b1) = i2_imm16 ; int64
2056 
2057   // Move and Convert instructions
2058   // =============================
2059 
2060   // move, sign extend
2061   inline void z_lbr(Register r1, Register r2);             // move r1 = r2 ; int32  &lt;- int8
2062   inline void z_lhr( Register r1, Register r2);            // move r1 = r2 ; int32  &lt;- int16
2063   inline void z_lr(Register r1, Register r2);              // move r1 = r2 ; int32, no sign extension
2064   inline void z_lgbr(Register r1, Register r2);            // move r1 = r2 ; int64  &lt;- int8
2065   inline void z_lghr(Register r1, Register r2);            // move r1 = r2 ; int64  &lt;- int16
2066   inline void z_lgfr(Register r1, Register r2);            // move r1 = r2 ; int64  &lt;- int32
2067   inline void z_lgr(Register r1, Register r2);             // move r1 = r2 ; int64
2068   // move, zero extend
2069   inline void z_llhr( Register r1, Register r2);           // move r1 = r2 ; uint32 &lt;- uint16
2070   inline void z_llgcr(Register r1, Register r2);           // move r1 = r2 ; uint64 &lt;- uint8
2071   inline void z_llghr(Register r1, Register r2);           // move r1 = r2 ; uint64 &lt;- uint16
2072   inline void z_llgfr(Register r1, Register r2);           // move r1 = r2 ; uint64 &lt;- uint32
2073 
2074   // move and test register
2075   inline void z_ltr(Register r1, Register r2);             // load/move and test r1 = r2; int32
2076   inline void z_ltgr(Register r1, Register r2);            // load/move and test r1 = r2; int64
2077   inline void z_ltgfr(Register r1, Register r2);           // load/move and test r1 = r2; int64 &lt;-- int32
2078 
2079   // move and byte-reverse
2080   inline void z_lrvr( Register r1, Register r2);           // move and reverse byte order r1 = r2; int32
2081   inline void z_lrvgr(Register r1, Register r2);           // move and reverse byte order r1 = r2; int64
2082 
2083 
2084   // Arithmetic instructions (Integer only)
2085   // ======================================
2086   // For float arithmetic instructions scroll further down
2087   // Add logical differs in the condition codes set!
2088 
2089   // add registers
2090   inline void z_ar(   Register r1, Register r2);                      // add         r1 = r1 + r2  ; int32
2091   inline void z_agr(  Register r1, Register r2);                      // add         r1 = r1 + r2  ; int64
2092   inline void z_agfr( Register r1, Register r2);                      // add         r1 = r1 + r2  ; int64 &lt;- int32
2093   inline void z_ark(  Register r1, Register r2, Register r3);         // add         r1 = r2 + r3  ; int32
2094   inline void z_agrk( Register r1, Register r2, Register r3);         // add         r1 = r2 + r3  ; int64
2095 
2096   inline void z_alr(  Register r1, Register r2);                      // add logical r1 = r1 + r2  ; int32
2097   inline void z_algr( Register r1, Register r2);                      // add logical r1 = r1 + r2  ; int64
2098   inline void z_algfr(Register r1, Register r2);                      // add logical r1 = r1 + r2  ; int64 &lt;- int32
2099   inline void z_alrk( Register r1, Register r2, Register r3);         // add logical r1 = r2 + r3  ; int32
2100   inline void z_algrk(Register r1, Register r2, Register r3);         // add logical r1 = r2 + r3  ; int64
2101   inline void z_alcgr(Register r1, Register r2);                      // add logical with carry r1 = r1 + r2 + c  ; int64
2102 
2103   // add immediate
2104   inline void z_ahi(  Register r1, int64_t i2);                       // add         r1 = r1 + i2_imm16 ; int32
2105   inline void z_afi(  Register r1, int64_t i2);                       // add         r1 = r1 + i2_imm32 ; int32
2106   inline void z_alfi( Register r1, int64_t i2);                       // add         r1 = r1 + i2_imm32 ; int32
2107   inline void z_aghi( Register r1, int64_t i2);                       // add logical r1 = r1 + i2_imm16 ; int64
2108   inline void z_agfi( Register r1, int64_t i2);                       // add         r1 = r1 + i2_imm32 ; int64
2109   inline void z_algfi(Register r1, int64_t i2);                       // add logical r1 = r1 + i2_imm32 ; int64
2110   inline void z_ahik( Register r1, Register r3, int64_t i2);          // add         r1 = r3 + i2_imm16 ; int32
2111   inline void z_aghik(Register r1, Register r3, int64_t i2);          // add         r1 = r3 + i2_imm16 ; int64
2112   inline void z_aih(  Register r1, int64_t i2);                       // add         r1 = r1 + i2_imm32 ; int32 (HiWord)
2113 
2114   // add memory
2115   inline void z_a( Register r1, int64_t d2, Register x2, Register b2);  // add r1 = r1 + *(d2_uimm12+s2+b2) ; int32
2116   inline void z_ay(  Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_imm20+s2+b2)  ; int32
2117   inline void z_ag(  Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_imm20+s2+b2)  ; int64
2118   inline void z_agf( Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_imm20+x2+b2)  ; int64 &lt;- int32
2119   inline void z_al(  Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_uimm12+x2+b2) ; int32
2120   inline void z_aly( Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_imm20+x2+b2)  ; int32
2121   inline void z_alg( Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_imm20+x2+b2)  ; int64
2122   inline void z_algf(Register r1, int64_t d2, Register x2, Register b2);// add r1 = r1 + *(d2_imm20+x2+b2)  ; int64 &lt;- int32
2123   inline void z_a(   Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int32
2124   inline void z_ay(  Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int32
2125   inline void z_al(  Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int32
2126   inline void z_aly( Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int32
2127   inline void z_ag(  Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int64
2128   inline void z_agf( Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int64 &lt;- int32
2129   inline void z_alg( Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int64
2130   inline void z_algf(Register r1, const Address&amp; a);                  // add r1 = r1 + *(a)               ; int64 &lt;- int32
2131 
2132 
2133   inline void z_alhsik( Register r1, Register r3, int64_t i2);    // add logical r1 = r3 + i2_imm16   ; int32
2134   inline void z_alghsik(Register r1, Register r3, int64_t i2);    // add logical r1 = r3 + i2_imm16   ; int64
2135 
2136   inline void z_asi(  int64_t d1, Register b1, int64_t i2);       // add           *(d1_imm20+b1) += i2_imm8 ; int32   -- z10
2137   inline void z_agsi( int64_t d1, Register b1, int64_t i2);       // add           *(d1_imm20+b1) += i2_imm8 ; int64   -- z10
2138   inline void z_alsi( int64_t d1, Register b1, int64_t i2);       // add logical   *(d1_imm20+b1) += i2_imm8 ; uint32  -- z10
2139   inline void z_algsi(int64_t d1, Register b1, int64_t i2);       // add logical   *(d1_imm20+b1) += i2_imm8 ; uint64  -- z10
2140   inline void z_asi(  const Address&amp; d, int64_t i2);              // add           *(d) += i2_imm8           ; int32   -- z10
2141   inline void z_agsi( const Address&amp; d, int64_t i2);              // add           *(d) += i2_imm8           ; int64   -- z10
2142   inline void z_alsi( const Address&amp; d, int64_t i2);              // add logical   *(d) += i2_imm8           ; uint32  -- z10
2143   inline void z_algsi(const Address&amp; d, int64_t i2);              // add logical   *(d) += i2_imm8           ; uint64  -- z10
2144 
2145   // sign adjustment
2146   inline void z_lcr(  Register r1, Register r2 = noreg);              // neg r1 = -r2   ; int32
2147   inline void z_lcgr( Register r1, Register r2 = noreg);              // neg r1 = -r2   ; int64
2148   inline void z_lcgfr(Register r1, Register r2);                      // neg r1 = -r2   ; int64 &lt;- int32
2149   inline void z_lnr(  Register r1, Register r2 = noreg);              // neg r1 = -|r2| ; int32
2150   inline void z_lngr( Register r1, Register r2 = noreg);              // neg r1 = -|r2| ; int64
2151   inline void z_lngfr(Register r1, Register r2);                      // neg r1 = -|r2| ; int64 &lt;- int32
2152   inline void z_lpr(  Register r1, Register r2 = noreg);              //     r1 =  |r2| ; int32
2153   inline void z_lpgr( Register r1, Register r2 = noreg);              //     r1 =  |r2| ; int64
2154   inline void z_lpgfr(Register r1, Register r2);                      //     r1 =  |r2| ; int64 &lt;- int32
2155 
2156   // subtract intstructions
2157   // sub registers
2158   inline void z_sr(   Register r1, Register r2);                      // sub         r1 = r1 - r2                ; int32
2159   inline void z_sgr(  Register r1, Register r2);                      // sub         r1 = r1 - r2                ; int64
2160   inline void z_sgfr( Register r1, Register r2);                      // sub         r1 = r1 - r2                ; int64 &lt;- int32
2161   inline void z_srk(  Register r1, Register r2, Register r3);         // sub         r1 = r2 - r3                ; int32
2162   inline void z_sgrk( Register r1, Register r2, Register r3);         // sub         r1 = r2 - r3                ; int64
2163 
2164   inline void z_slr(  Register r1, Register r2);                      // sub logical r1 = r1 - r2                ; int32
2165   inline void z_slgr( Register r1, Register r2);                      // sub logical r1 = r1 - r2                ; int64
2166   inline void z_slgfr(Register r1, Register r2);                      // sub logical r1 = r1 - r2                ; int64 &lt;- int32
2167   inline void z_slrk( Register r1, Register r2, Register r3);         // sub logical r1 = r2 - r3                ; int32
2168   inline void z_slgrk(Register r1, Register r2, Register r3);         // sub logical r1 = r2 - r3                ; int64
2169   inline void z_slfi( Register r1, int64_t i2);                       // sub logical r1 = r1 - i2_uimm32         ; int32
2170   inline void z_slgfi(Register r1, int64_t i2);                       // add logical r1 = r1 - i2_uimm32         ; int64
2171 
2172   // sub memory
2173   inline void z_s(   Register r1, int64_t d2, Register x2, Register b2);  // sub         r1 = r1 - *(d2_imm12+x2+b2) ; int32
2174   inline void z_sy(  Register r1, int64_t d2, Register x2, Register b2);  // sub         r1 = r1 + *(d2_imm20+s2+b2) ; int32
2175   inline void z_sg(  Register r1, int64_t d2, Register x2, Register b2);  // sub         r1 = r1 - *(d2_imm12+x2+b2) ; int64
2176   inline void z_sgf( Register r1, int64_t d2, Register x2, Register b2);  // sub         r1 = r1 - *(d2_imm12+x2+b2) ; int64 - int32
2177   inline void z_slg( Register r1, int64_t d2, Register x2, Register b2);  // sub logical r1 = r1 - *(d2_imm20+x2+b2) ; uint64
2178   inline void z_slgf(Register r1, int64_t d2, Register x2, Register b2);  // sub logical r1 = r1 - *(d2_imm20+x2+b2) ; uint64 - uint32
2179   inline void z_s(   Register r1, const Address&amp; a);                      // sub         r1 = r1 - *(a)              ; int32
2180   inline void z_sy(  Register r1, const Address&amp; a);                      // sub         r1 = r1 - *(a)              ; int32
2181   inline void z_sg(  Register r1, const Address&amp; a);                      // sub         r1 = r1 - *(a)              ; int64
2182   inline void z_sgf( Register r1, const Address&amp; a);                      // sub         r1 = r1 - *(a)              ; int64 - int32
2183   inline void z_slg( Register r1, const Address&amp; a);                      // sub         r1 = r1 - *(a)              ; uint64
2184   inline void z_slgf(Register r1, const Address&amp; a);                      // sub         r1 = r1 - *(a)              ; uint64 - uint32
2185 
2186   inline void z_sh(  Register r1, int64_t d2, Register x2, Register b2);  // sub         r1 = r1 - *(d2_imm12+x2+b2) ; int32 - int16
2187   inline void z_shy( Register r1, int64_t d2, Register x2, Register b2);  // sub         r1 = r1 - *(d2_imm20+x2+b2) ; int32 - int16
2188   inline void z_sh(  Register r1, const Address &amp;a);                      // sub         r1 = r1 - *(d2_imm12+x2+b2) ; int32 - int16
2189   inline void z_shy( Register r1, const Address &amp;a);                      // sub         r1 = r1 - *(d2_imm20+x2+b2) ; int32 - int16
2190 
2191   // Multiplication instructions
2192   // mul registers
2193   inline void z_msr(  Register r1, Register r2);                          // mul r1 = r1 * r2          ; int32
2194   inline void z_msgr( Register r1, Register r2);                          // mul r1 = r1 * r2          ; int64
2195   inline void z_msgfr(Register r1, Register r2);                          // mul r1 = r1 * r2          ; int64 &lt;- int32
2196   inline void z_mlr(  Register r1, Register r2);                          // mul r1 = r1 * r2          ; int32 unsigned
2197   inline void z_mlgr( Register r1, Register r2);                          // mul r1 = r1 * r2          ; int64 unsigned
2198   // mul register - memory
2199   inline void z_mhy( Register r1, int64_t d2, Register x2, Register b2);  // mul r1 = r1 * *(d2+x2+b2)
2200   inline void z_msy( Register r1, int64_t d2, Register x2, Register b2);  // mul r1 = r1 * *(d2+x2+b2)
2201   inline void z_msg( Register r1, int64_t d2, Register x2, Register b2);  // mul r1 = r1 * *(d2+x2+b2)
2202   inline void z_msgf(Register r1, int64_t d2, Register x2, Register b2);  // mul r1 = r1 * *(d2+x2+b2)
2203   inline void z_ml(  Register r1, int64_t d2, Register x2, Register b2);  // mul r1 = r1 * *(d2+x2+b2)
2204   inline void z_mlg( Register r1, int64_t d2, Register x2, Register b2);  // mul r1 = r1 * *(d2+x2+b2)
2205   inline void z_mhy( Register r1, const Address&amp; a);                      // mul r1 = r1 * *(a)
2206   inline void z_msy( Register r1, const Address&amp; a);                      // mul r1 = r1 * *(a)
2207   inline void z_msg( Register r1, const Address&amp; a);                      // mul r1 = r1 * *(a)
2208   inline void z_msgf(Register r1, const Address&amp; a);                      // mul r1 = r1 * *(a)
2209   inline void z_ml(  Register r1, const Address&amp; a);                      // mul r1 = r1 * *(a)
2210   inline void z_mlg( Register r1, const Address&amp; a);                      // mul r1 = r1 * *(a)
2211 
2212   inline void z_msfi( Register r1, int64_t i2);   // mult r1 = r1 * i2_imm32;   int32  -- z10
2213   inline void z_msgfi(Register r1, int64_t i2);   // mult r1 = r1 * i2_imm32;   int64  -- z10
2214   inline void z_mhi(  Register r1, int64_t i2);   // mult r1 = r1 * i2_imm16;   int32
2215   inline void z_mghi( Register r1, int64_t i2);   // mult r1 = r1 * i2_imm16;   int64
2216 
2217   // Division instructions
2218   inline void z_dsgr( Register r1, Register r2);      // div  r1 = r1 / r2               ; int64/int32 needs reg pair!
2219   inline void z_dsgfr(Register r1, Register r2);      // div  r1 = r1 / r2               ; int64/int32 needs reg pair!
2220 
2221 
2222   // Logic instructions
2223   // ===================
2224 
2225   // and
2226   inline void z_n(   Register r1, int64_t d2, Register x2, Register b2);
2227   inline void z_ny(  Register r1, int64_t d2, Register x2, Register b2);
2228   inline void z_ng(  Register r1, int64_t d2, Register x2, Register b2);
2229   inline void z_n(   Register r1, const Address&amp; a);
2230   inline void z_ny(  Register r1, const Address&amp; a);
2231   inline void z_ng(  Register r1, const Address&amp; a);
2232 
2233   inline void z_nr(  Register r1, Register r2);               // and r1 = r1 &amp; r2         ; int32
2234   inline void z_ngr( Register r1, Register r2);               // and r1 = r1 &amp; r2         ; int64
2235   inline void z_nrk( Register r1, Register r2, Register r3);  // and r1 = r2 &amp; r3         ; int32
2236   inline void z_ngrk(Register r1, Register r2, Register r3);  // and r1 = r2 &amp; r3         ; int64
2237 
2238   inline void z_nihh(Register r1, int64_t i2);                // and r1 = r1 &amp; i2_imm16   ; and only for bits  0-15
2239   inline void z_nihl(Register r1, int64_t i2);                // and r1 = r1 &amp; i2_imm16   ; and only for bits 16-31
2240   inline void z_nilh(Register r1, int64_t i2);                // and r1 = r1 &amp; i2_imm16   ; and only for bits 32-47
2241   inline void z_nill(Register r1, int64_t i2);                // and r1 = r1 &amp; i2_imm16   ; and only for bits 48-63
2242   inline void z_nihf(Register r1, int64_t i2);                // and r1 = r1 &amp; i2_imm32   ; and only for bits  0-31
2243   inline void z_nilf(Register r1, int64_t i2);                // and r1 = r1 &amp; i2_imm32   ; and only for bits 32-63  see also MacroAssembler::nilf.
2244 
2245   // or
2246   inline void z_o(   Register r1, int64_t d2, Register x2, Register b2);
2247   inline void z_oy(  Register r1, int64_t d2, Register x2, Register b2);
2248   inline void z_og(  Register r1, int64_t d2, Register x2, Register b2);
2249   inline void z_o(   Register r1, const Address&amp; a);
2250   inline void z_oy(  Register r1, const Address&amp; a);
2251   inline void z_og(  Register r1, const Address&amp; a);
2252 
2253   inline void z_or(  Register r1, Register r2);               // or r1 = r1 | r2; int32
2254   inline void z_ogr( Register r1, Register r2);               // or r1 = r1 | r2; int64
2255   inline void z_ork( Register r1, Register r2, Register r3);  // or r1 = r2 | r3         ; int32
2256   inline void z_ogrk(Register r1, Register r2, Register r3);  // or r1 = r2 | r3         ; int64
2257 
2258   inline void z_oihh(Register r1, int64_t i2);                // or r1 = r1 | i2_imm16   ; or only for bits  0-15
2259   inline void z_oihl(Register r1, int64_t i2);                // or r1 = r1 | i2_imm16   ; or only for bits 16-31
2260   inline void z_oilh(Register r1, int64_t i2);                // or r1 = r1 | i2_imm16   ; or only for bits 32-47
2261   inline void z_oill(Register r1, int64_t i2);                // or r1 = r1 | i2_imm16   ; or only for bits 48-63
2262   inline void z_oihf(Register r1, int64_t i2);                // or r1 = r1 | i2_imm32   ; or only for bits  0-31
2263   inline void z_oilf(Register r1, int64_t i2);                // or r1 = r1 | i2_imm32   ; or only for bits 32-63
2264 
2265   // xor
2266   inline void z_x(   Register r1, int64_t d2, Register x2, Register b2);
2267   inline void z_xy(  Register r1, int64_t d2, Register x2, Register b2);
2268   inline void z_xg(  Register r1, int64_t d2, Register x2, Register b2);
2269   inline void z_x(   Register r1, const Address&amp; a);
2270   inline void z_xy(  Register r1, const Address&amp; a);
2271   inline void z_xg(  Register r1, const Address&amp; a);
2272 
2273   inline void z_xr(  Register r1, Register r2);               // xor r1 = r1 ^ r2         ; int32
2274   inline void z_xgr( Register r1, Register r2);               // xor r1 = r1 ^ r2         ; int64
2275   inline void z_xrk( Register r1, Register r2, Register r3);  // xor r1 = r2 ^ r3         ; int32
2276   inline void z_xgrk(Register r1, Register r2, Register r3);  // xor r1 = r2 ^ r3         ; int64
2277 
2278   inline void z_xihf(Register r1, int64_t i2);                // xor r1 = r1 ^ i2_imm32   ; or only for bits  0-31
2279   inline void z_xilf(Register r1, int64_t i2);                // xor r1 = r1 ^ i2_imm32   ; or only for bits 32-63
2280 
2281   // shift
2282   inline void z_sla( Register r1,              int64_t d2, Register b2=Z_R0); // shift left  r1 = r1 &lt;&lt; ((d2+b2)&amp;0x3f) ; int32, only 31 bits shifted, sign preserved!
2283   inline void z_slak(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift left  r1 = r3 &lt;&lt; ((d2+b2)&amp;0x3f) ; int32, only 31 bits shifted, sign preserved!
2284   inline void z_slag(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift left  r1 = r3 &lt;&lt; ((d2+b2)&amp;0x3f) ; int64, only 63 bits shifted, sign preserved!
2285   inline void z_sra( Register r1,              int64_t d2, Register b2=Z_R0); // shift right r1 = r1 &gt;&gt; ((d2+b2)&amp;0x3f) ; int32, sign extended
2286   inline void z_srak(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift right r1 = r3 &gt;&gt; ((d2+b2)&amp;0x3f) ; int32, sign extended
2287   inline void z_srag(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift right r1 = r3 &gt;&gt; ((d2+b2)&amp;0x3f) ; int64, sign extended
2288   inline void z_sll( Register r1,              int64_t d2, Register b2=Z_R0); // shift left  r1 = r1 &lt;&lt; ((d2+b2)&amp;0x3f) ; int32, zeros added
2289   inline void z_sllk(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift left  r1 = r3 &lt;&lt; ((d2+b2)&amp;0x3f) ; int32, zeros added
2290   inline void z_sllg(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift left  r1 = r3 &lt;&lt; ((d2+b2)&amp;0x3f) ; int64, zeros added
2291   inline void z_srl( Register r1,              int64_t d2, Register b2=Z_R0); // shift right r1 = r1 &gt;&gt; ((d2+b2)&amp;0x3f) ; int32, zero extended
2292   inline void z_srlk(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift right r1 = r3 &gt;&gt; ((d2+b2)&amp;0x3f) ; int32, zero extended
2293   inline void z_srlg(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // shift right r1 = r3 &gt;&gt; ((d2+b2)&amp;0x3f) ; int64, zero extended
2294 
2295   // rotate
2296   inline void z_rll( Register r1, Register r3, int64_t d2, Register b2=Z_R0); // rot r1 = r3 &lt;&lt; (d2+b2 &amp; 0x3f) ; int32  -- z10
2297   inline void z_rllg(Register r1, Register r3, int64_t d2, Register b2=Z_R0); // rot r1 = r3 &lt;&lt; (d2+b2 &amp; 0x3f) ; int64  -- z10
2298 
2299   // rotate the AND/XOR/OR/insert
2300   inline void z_rnsbg( Register r1, Register r2, int64_t spos3, int64_t epos4, int64_t nrot5, bool test_only = false); // rotate then AND selected bits  -- z196
2301   inline void z_rxsbg( Register r1, Register r2, int64_t spos3, int64_t epos4, int64_t nrot5, bool test_only = false); // rotate then XOR selected bits  -- z196
2302   inline void z_rosbg( Register r1, Register r2, int64_t spos3, int64_t epos4, int64_t nrot5, bool test_only = false); // rotate then OR  selected bits  -- z196
2303   inline void z_risbg( Register r1, Register r2, int64_t spos3, int64_t epos4, int64_t nrot5, bool zero_rest = false); // rotate then INS selected bits  -- z196
2304 
2305 
2306   // memory-immediate instructions (8-bit immediate)
2307   // ===============================================
2308 
2309   inline void z_cli( int64_t d1, Register b1, int64_t i2); // compare *(d1_imm12+b1) ^= i2_imm8           ; int8
2310   inline void z_mvi( int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1)  = i2_imm8           ; int8
2311   inline void z_tm(  int64_t d1, Register b1, int64_t i2); // test    *(d1_imm12+b1) against mask i2_imm8 ; int8
2312   inline void z_ni(  int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1) &amp;= i2_imm8           ; int8
2313   inline void z_oi(  int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1) |= i2_imm8           ; int8
2314   inline void z_xi(  int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1) ^= i2_imm8           ; int8
2315   inline void z_cliy(int64_t d1, Register b1, int64_t i2); // compare *(d1_imm12+b1) ^= i2_imm8           ; int8
2316   inline void z_mviy(int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1)  = i2_imm8           ; int8
2317   inline void z_tmy( int64_t d1, Register b1, int64_t i2); // test    *(d1_imm12+b1) against mask i2_imm8 ; int8
2318   inline void z_niy( int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1) &amp;= i2_imm8           ; int8
2319   inline void z_oiy( int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1) |= i2_imm8           ; int8
2320   inline void z_xiy( int64_t d1, Register b1, int64_t i2); // store   *(d1_imm12+b1) ^= i2_imm8           ; int8
2321   inline void z_cli( const Address&amp; a, int64_t imm8);      // compare *(a)           ^= imm8              ; int8
2322   inline void z_mvi( const Address&amp; a, int64_t imm8);      // store   *(a)            = imm8              ; int8
2323   inline void z_tm(  const Address&amp; a, int64_t imm8);      // test    *(a)           against mask imm8    ; int8
2324   inline void z_ni(  const Address&amp; a, int64_t imm8);      // store   *(a)           &amp;= imm8              ; int8
2325   inline void z_oi(  const Address&amp; a, int64_t imm8);      // store   *(a)           |= imm8              ; int8
2326   inline void z_xi(  const Address&amp; a, int64_t imm8);      // store   *(a)           ^= imm8              ; int8
2327   inline void z_cliy(const Address&amp; a, int64_t imm8);      // compare *(a)           ^= imm8              ; int8
2328   inline void z_mviy(const Address&amp; a, int64_t imm8);      // store   *(a)            = imm8              ; int8
2329   inline void z_tmy( const Address&amp; a, int64_t imm8);      // test    *(a)           against mask imm8    ; int8
2330   inline void z_niy( const Address&amp; a, int64_t imm8);      // store   *(a)           &amp;= imm8              ; int8
2331   inline void z_oiy( const Address&amp; a, int64_t imm8);      // store   *(a)           |= imm8              ; int8
2332   inline void z_xiy( const Address&amp; a, int64_t imm8);      // store   *(a)           ^= imm8              ; int8
2333 
2334 
2335   //------------------------------
2336   // Interlocked-Update
2337   //------------------------------
2338   inline void z_laa(  Register r1, Register r3, int64_t d2, Register b2);   // load and add    int32, signed   -- z196
2339   inline void z_laag( Register r1, Register r3, int64_t d2, Register b2);   // load and add    int64, signed   -- z196
2340   inline void z_laal( Register r1, Register r3, int64_t d2, Register b2);   // load and add    int32, unsigned -- z196
2341   inline void z_laalg(Register r1, Register r3, int64_t d2, Register b2);   // load and add    int64, unsigned -- z196
2342   inline void z_lan(  Register r1, Register r3, int64_t d2, Register b2);   // load and and    int32           -- z196
2343   inline void z_lang( Register r1, Register r3, int64_t d2, Register b2);   // load and and    int64           -- z196
2344   inline void z_lax(  Register r1, Register r3, int64_t d2, Register b2);   // load and xor    int32           -- z196
2345   inline void z_laxg( Register r1, Register r3, int64_t d2, Register b2);   // load and xor    int64           -- z196
2346   inline void z_lao(  Register r1, Register r3, int64_t d2, Register b2);   // load and or     int32           -- z196
2347   inline void z_laog( Register r1, Register r3, int64_t d2, Register b2);   // load and or     int64           -- z196
2348 
2349   inline void z_laa(  Register r1, Register r3, const Address&amp; a);          // load and add    int32, signed   -- z196
2350   inline void z_laag( Register r1, Register r3, const Address&amp; a);          // load and add    int64, signed   -- z196
2351   inline void z_laal( Register r1, Register r3, const Address&amp; a);          // load and add    int32, unsigned -- z196
2352   inline void z_laalg(Register r1, Register r3, const Address&amp; a);          // load and add    int64, unsigned -- z196
2353   inline void z_lan(  Register r1, Register r3, const Address&amp; a);          // load and and    int32           -- z196
2354   inline void z_lang( Register r1, Register r3, const Address&amp; a);          // load and and    int64           -- z196
2355   inline void z_lax(  Register r1, Register r3, const Address&amp; a);          // load and xor    int32           -- z196
2356   inline void z_laxg( Register r1, Register r3, const Address&amp; a);          // load and xor    int64           -- z196
2357   inline void z_lao(  Register r1, Register r3, const Address&amp; a);          // load and or     int32           -- z196
2358   inline void z_laog( Register r1, Register r3, const Address&amp; a);          // load and or     int64           -- z196
2359 
2360   //--------------------------------
2361   // Execution Prediction
2362   //--------------------------------
2363   inline void z_pfd(  int64_t m1, int64_t d2, Register x2, Register b2);  // prefetch
2364   inline void z_pfd(  int64_t m1, Address a);
2365   inline void z_pfdrl(int64_t m1, int64_t i2);                            // prefetch
2366   inline void z_bpp(  int64_t m1, int64_t i2, int64_t d3, Register b3);   // branch prediction    -- EC12
2367   inline void z_bprp( int64_t m1, int64_t i2, int64_t i3);                // branch prediction    -- EC12
2368 
2369   //-------------------------------
2370   // Transaction Control
2371   //-------------------------------
2372   inline void z_tbegin(int64_t d1, Register b1, int64_t i2);          // begin transaction               -- EC12
2373   inline void z_tbeginc(int64_t d1, Register b1, int64_t i2);         // begin transaction (constrained) -- EC12
2374   inline void z_tend();                                               // end transaction                 -- EC12
2375   inline void z_tabort(int64_t d2, Register b2);                      // abort transaction               -- EC12
2376   inline void z_etnd(Register r1);                                    // extract tx nesting depth        -- EC12
2377   inline void z_ppa(Register r1, Register r2, int64_t m3);            // perform processor assist        -- EC12
2378 
2379   //---------------------------------
2380   // Conditional Execution
2381   //---------------------------------
2382   inline void z_locr( Register r1, Register r2, branch_condition cc);             // if (cc) load r1 = r2               ; int32 -- z196
2383   inline void z_locgr(Register r1, Register r2, branch_condition cc);             // if (cc) load r1 = r2               ; int64 -- z196
2384   inline void z_loc(  Register r1, int64_t d2, Register b2, branch_condition cc); // if (cc) load r1 = *(d2_simm20+b2)  ; int32 -- z196
2385   inline void z_locg( Register r1, int64_t d2, Register b2, branch_condition cc); // if (cc) load r1 = *(d2_simm20+b2)  ; int64 -- z196
2386   inline void z_loc(  Register r1, const Address&amp; a, branch_condition cc);        // if (cc) load r1 = *(a)             ; int32 -- z196
2387   inline void z_locg( Register r1, const Address&amp; a, branch_condition cc);        // if (cc) load r1 = *(a)             ; int64 -- z196
2388   inline void z_stoc( Register r1, int64_t d2, Register b2, branch_condition cc); // if (cc) store *(d2_simm20+b2) = r1 ; int32 -- z196
2389   inline void z_stocg(Register r1, int64_t d2, Register b2, branch_condition cc); // if (cc) store *(d2_simm20+b2) = r1 ; int64 -- z196
2390 
2391 
2392   // Complex CISC instructions
2393   // ==========================
2394 
2395   inline void z_cksm(Register r1, Register r2);                       // checksum. This is NOT CRC32
2396   inline void z_km(  Register r1, Register r2);                       // cipher message
2397   inline void z_kmc( Register r1, Register r2);                       // cipher message with chaining
2398   inline void z_kimd(Register r1, Register r2);                       // msg digest (SHA)
2399   inline void z_klmd(Register r1, Register r2);                       // msg digest (SHA)
2400   inline void z_kmac(Register r1, Register r2);                       // msg authentication code
2401 
2402   inline void z_ex(Register r1, int64_t d2, Register x2, Register b2);// execute
2403   inline void z_exrl(Register r1, int64_t i2);                        // execute relative long         -- z10
2404   inline void z_exrl(Register r1, address a2);                        // execute relative long         -- z10
2405 
2406   inline void z_ectg(int64_t d1, Register b1, int64_t d2, Register b2, Register r3);  // extract cpu time
2407   inline void z_ecag(Register r1, Register r3, int64_t d2, Register b2);              // extract CPU attribute
2408 
2409   inline void z_srst(Register r1, Register r2);                       // search string
2410   inline void z_srstu(Register r1, Register r2);                      // search string unicode
2411 
2412   inline void z_mvc(const Address&amp; d, const Address&amp; s, int64_t l);               // move l bytes
2413   inline void z_mvc(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2); // move l+1 bytes
2414   inline void z_mvcle(Register r1, Register r3, int64_t d2, Register b2=Z_R0);    // move region of memory
2415 
2416   inline void z_stfle(int64_t d2, Register b2);                            // store facility list extended
2417 
2418   inline void z_nc(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2);// and *(d1+b1) = *(d1+l+b1) &amp; *(d2+b2) ; d1, d2: uimm12, ands l+1 bytes
2419   inline void z_oc(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2);//  or *(d1+b1) = *(d1+l+b1) | *(d2+b2) ; d1, d2: uimm12,  ors l+1 bytes
2420   inline void z_xc(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2);// xor *(d1+b1) = *(d1+l+b1) ^ *(d2+b2) ; d1, d2: uimm12, xors l+1 bytes
2421   inline void z_nc(Address dst, int64_t len, Address src2);                     // and *dst = *dst &amp; *src2, ands len bytes in memory
2422   inline void z_oc(Address dst, int64_t len, Address src2);                     //  or *dst = *dst | *src2,  ors len bytes in memory
2423   inline void z_xc(Address dst, int64_t len, Address src2);                     // xor *dst = *dst ^ *src2, xors len bytes in memory
2424 
2425   // compare instructions
2426   inline void z_clc(int64_t d1, int64_t l, Register b1, int64_t d2, Register b2);  // compare (*(d1_uimm12+b1), *(d1_uimm12+b1)) ; compare l bytes
2427   inline void z_clcle(Register r1, Register r3, int64_t d2, Register b2);  // compare logical long extended, see docu
2428   inline void z_clclu(Register r1, Register r3, int64_t d2, Register b2);  // compare logical long unicode, see docu
2429 
2430   // Translate characters
2431   inline void z_troo(Register r1, Register r2, int64_t m3);
2432   inline void z_trot(Register r1, Register r2, int64_t m3);
2433   inline void z_trto(Register r1, Register r2, int64_t m3);
2434   inline void z_trtt(Register r1, Register r2, int64_t m3);
2435 
2436 
2437   //---------------------------
2438   //--  Vector Instructions  --
2439   //---------------------------
2440 
2441   //---&lt;  Vector Support Instructions  &gt;---
2442 
2443   // Load (transfer from memory)
2444   inline void z_vlm(   VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2445   inline void z_vl(    VectorRegister v1, int64_t d2, Register x2, Register b2);
2446   inline void z_vleb(  VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2447   inline void z_vleh(  VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2448   inline void z_vlef(  VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2449   inline void z_vleg(  VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2450 
2451   // Gather/Scatter
2452   inline void z_vgef(  VectorRegister v1, int64_t d2, VectorRegister vx2, Register b2, int64_t m3);
2453   inline void z_vgeg(  VectorRegister v1, int64_t d2, VectorRegister vx2, Register b2, int64_t m3);
2454 
2455   inline void z_vscef( VectorRegister v1, int64_t d2, VectorRegister vx2, Register b2, int64_t m3);
2456   inline void z_vsceg( VectorRegister v1, int64_t d2, VectorRegister vx2, Register b2, int64_t m3);
2457 
2458   // load and replicate
2459   inline void z_vlrep( VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2460   inline void z_vlrepb(VectorRegister v1, int64_t d2, Register x2, Register b2);
2461   inline void z_vlreph(VectorRegister v1, int64_t d2, Register x2, Register b2);
2462   inline void z_vlrepf(VectorRegister v1, int64_t d2, Register x2, Register b2);
2463   inline void z_vlrepg(VectorRegister v1, int64_t d2, Register x2, Register b2);
2464 
2465   inline void z_vllez( VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2466   inline void z_vllezb(VectorRegister v1, int64_t d2, Register x2, Register b2);
2467   inline void z_vllezh(VectorRegister v1, int64_t d2, Register x2, Register b2);
2468   inline void z_vllezf(VectorRegister v1, int64_t d2, Register x2, Register b2);
2469   inline void z_vllezg(VectorRegister v1, int64_t d2, Register x2, Register b2);
2470 
2471   inline void z_vlbb(  VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2472   inline void z_vll(   VectorRegister v1, Register r3, int64_t d2, Register b2);
2473 
2474   // Load (register to register)
2475   inline void z_vlr(   VectorRegister v1, VectorRegister v2);
2476 
2477   inline void z_vlgv(  Register r1, VectorRegister v3, int64_t d2, Register b2, int64_t m4);
2478   inline void z_vlgvb( Register r1, VectorRegister v3, int64_t d2, Register b2);
2479   inline void z_vlgvh( Register r1, VectorRegister v3, int64_t d2, Register b2);
2480   inline void z_vlgvf( Register r1, VectorRegister v3, int64_t d2, Register b2);
2481   inline void z_vlgvg( Register r1, VectorRegister v3, int64_t d2, Register b2);
2482 
2483   inline void z_vlvg(  VectorRegister v1, Register r3, int64_t d2, Register b2, int64_t m4);
2484   inline void z_vlvgb( VectorRegister v1, Register r3, int64_t d2, Register b2);
2485   inline void z_vlvgh( VectorRegister v1, Register r3, int64_t d2, Register b2);
2486   inline void z_vlvgf( VectorRegister v1, Register r3, int64_t d2, Register b2);
2487   inline void z_vlvgg( VectorRegister v1, Register r3, int64_t d2, Register b2);
2488 
2489   inline void z_vlvgp( VectorRegister v1, Register r2, Register r3);
2490 
2491   // vector register pack
2492   inline void z_vpk(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2493   inline void z_vpkh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2494   inline void z_vpkf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2495   inline void z_vpkg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2496 
2497   inline void z_vpks(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4, int64_t cc5);
2498   inline void z_vpksh( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2499   inline void z_vpksf( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2500   inline void z_vpksg( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2501   inline void z_vpkshs(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2502   inline void z_vpksfs(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2503   inline void z_vpksgs(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2504 
2505   inline void z_vpkls(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4, int64_t cc5);
2506   inline void z_vpklsh( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2507   inline void z_vpklsf( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2508   inline void z_vpklsg( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2509   inline void z_vpklshs(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2510   inline void z_vpklsfs(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2511   inline void z_vpklsgs(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2512 
2513   // vector register unpack (sign-extended)
2514   inline void z_vuph(   VectorRegister v1, VectorRegister v2, int64_t m3);
2515   inline void z_vuphb(  VectorRegister v1, VectorRegister v2);
2516   inline void z_vuphh(  VectorRegister v1, VectorRegister v2);
2517   inline void z_vuphf(  VectorRegister v1, VectorRegister v2);
2518   inline void z_vupl(   VectorRegister v1, VectorRegister v2, int64_t m3);
2519   inline void z_vuplb(  VectorRegister v1, VectorRegister v2);
2520   inline void z_vuplh(  VectorRegister v1, VectorRegister v2);
2521   inline void z_vuplf(  VectorRegister v1, VectorRegister v2);
2522 
2523   // vector register unpack (zero-extended)
2524   inline void z_vuplh(  VectorRegister v1, VectorRegister v2, int64_t m3);
2525   inline void z_vuplhb( VectorRegister v1, VectorRegister v2);
2526   inline void z_vuplhh( VectorRegister v1, VectorRegister v2);
2527   inline void z_vuplhf( VectorRegister v1, VectorRegister v2);
2528   inline void z_vupll(  VectorRegister v1, VectorRegister v2, int64_t m3);
2529   inline void z_vupllb( VectorRegister v1, VectorRegister v2);
2530   inline void z_vupllh( VectorRegister v1, VectorRegister v2);
2531   inline void z_vupllf( VectorRegister v1, VectorRegister v2);
2532 
2533   // vector register merge high/low
2534   inline void z_vmrh( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2535   inline void z_vmrhb(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2536   inline void z_vmrhh(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2537   inline void z_vmrhf(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2538   inline void z_vmrhg(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2539 
2540   inline void z_vmrl( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2541   inline void z_vmrlb(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2542   inline void z_vmrlh(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2543   inline void z_vmrlf(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2544   inline void z_vmrlg(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2545 
2546   // vector register permute
2547   inline void z_vperm( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4);
2548   inline void z_vpdi(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t        m4);
2549 
2550   // vector register replicate
2551   inline void z_vrep(  VectorRegister v1, VectorRegister v3, int64_t imm2, int64_t m4);
2552   inline void z_vrepb( VectorRegister v1, VectorRegister v3, int64_t imm2);
2553   inline void z_vreph( VectorRegister v1, VectorRegister v3, int64_t imm2);
2554   inline void z_vrepf( VectorRegister v1, VectorRegister v3, int64_t imm2);
2555   inline void z_vrepg( VectorRegister v1, VectorRegister v3, int64_t imm2);
2556   inline void z_vrepi( VectorRegister v1, int64_t imm2,      int64_t m3);
2557   inline void z_vrepib(VectorRegister v1, int64_t imm2);
2558   inline void z_vrepih(VectorRegister v1, int64_t imm2);
2559   inline void z_vrepif(VectorRegister v1, int64_t imm2);
2560   inline void z_vrepig(VectorRegister v1, int64_t imm2);
2561 
2562   inline void z_vsel(  VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4);
2563   inline void z_vseg(  VectorRegister v1, VectorRegister v2, int64_t imm3);
2564 
2565   // Load (immediate)
2566   inline void z_vleib( VectorRegister v1, int64_t imm2, int64_t m3);
2567   inline void z_vleih( VectorRegister v1, int64_t imm2, int64_t m3);
2568   inline void z_vleif( VectorRegister v1, int64_t imm2, int64_t m3);
2569   inline void z_vleig( VectorRegister v1, int64_t imm2, int64_t m3);
2570 
2571   // Store
2572   inline void z_vstm(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2573   inline void z_vst(   VectorRegister v1, int64_t d2, Register x2, Register b2);
2574   inline void z_vsteb( VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2575   inline void z_vsteh( VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2576   inline void z_vstef( VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2577   inline void z_vsteg( VectorRegister v1, int64_t d2, Register x2, Register b2, int64_t m3);
2578   inline void z_vstl(  VectorRegister v1, Register r3, int64_t d2, Register b2);
2579 
2580   // Misc
2581   inline void z_vgm(   VectorRegister v1, int64_t imm2, int64_t imm3, int64_t m4);
2582   inline void z_vgmb(  VectorRegister v1, int64_t imm2, int64_t imm3);
2583   inline void z_vgmh(  VectorRegister v1, int64_t imm2, int64_t imm3);
2584   inline void z_vgmf(  VectorRegister v1, int64_t imm2, int64_t imm3);
2585   inline void z_vgmg(  VectorRegister v1, int64_t imm2, int64_t imm3);
2586 
2587   inline void z_vgbm(  VectorRegister v1, int64_t imm2);
2588   inline void z_vzero( VectorRegister v1); // preferred method to set vreg to all zeroes
2589   inline void z_vone(  VectorRegister v1); // preferred method to set vreg to all ones
2590 
2591   //---&lt;  Vector Arithmetic Instructions  &gt;---
2592 
2593   // Load
2594   inline void z_vlc(    VectorRegister v1, VectorRegister v2, int64_t m3);
2595   inline void z_vlcb(   VectorRegister v1, VectorRegister v2);
2596   inline void z_vlch(   VectorRegister v1, VectorRegister v2);
2597   inline void z_vlcf(   VectorRegister v1, VectorRegister v2);
2598   inline void z_vlcg(   VectorRegister v1, VectorRegister v2);
2599   inline void z_vlp(    VectorRegister v1, VectorRegister v2, int64_t m3);
2600   inline void z_vlpb(   VectorRegister v1, VectorRegister v2);
2601   inline void z_vlph(   VectorRegister v1, VectorRegister v2);
2602   inline void z_vlpf(   VectorRegister v1, VectorRegister v2);
2603   inline void z_vlpg(   VectorRegister v1, VectorRegister v2);
2604 
2605   // ADD
2606   inline void z_va(     VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2607   inline void z_vab(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2608   inline void z_vah(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2609   inline void z_vaf(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2610   inline void z_vag(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2611   inline void z_vaq(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2612   inline void z_vacc(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2613   inline void z_vaccb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2614   inline void z_vacch(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2615   inline void z_vaccf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2616   inline void z_vaccg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2617   inline void z_vaccq(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2618 
2619   // SUB
2620   inline void z_vs(     VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2621   inline void z_vsb(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2622   inline void z_vsh(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2623   inline void z_vsf(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2624   inline void z_vsg(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2625   inline void z_vsq(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2626   inline void z_vscbi(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2627   inline void z_vscbib( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2628   inline void z_vscbih( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2629   inline void z_vscbif( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2630   inline void z_vscbig( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2631   inline void z_vscbiq( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2632 
2633   // MULTIPLY
2634   inline void z_vml(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2635   inline void z_vmh(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2636   inline void z_vmlh(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2637   inline void z_vme(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2638   inline void z_vmle(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2639   inline void z_vmo(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2640   inline void z_vmlo(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2641 
2642   // MULTIPLY &amp; ADD
2643   inline void z_vmal(   VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2644   inline void z_vmah(   VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2645   inline void z_vmalh(  VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2646   inline void z_vmae(   VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2647   inline void z_vmale(  VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2648   inline void z_vmao(   VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2649   inline void z_vmalo(  VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2650 
2651   // VECTOR SUM
2652   inline void z_vsum(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2653   inline void z_vsumb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2654   inline void z_vsumh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2655   inline void z_vsumg(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2656   inline void z_vsumgh( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2657   inline void z_vsumgf( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2658   inline void z_vsumq(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2659   inline void z_vsumqf( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2660   inline void z_vsumqg( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2661 
2662   // Average
2663   inline void z_vavg(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2664   inline void z_vavgb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2665   inline void z_vavgh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2666   inline void z_vavgf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2667   inline void z_vavgg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2668   inline void z_vavgl(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2669   inline void z_vavglb( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2670   inline void z_vavglh( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2671   inline void z_vavglf( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2672   inline void z_vavglg( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2673 
2674   // VECTOR Galois Field Multiply Sum
2675   inline void z_vgfm(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2676   inline void z_vgfmb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2677   inline void z_vgfmh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2678   inline void z_vgfmf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2679   inline void z_vgfmg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2680   // VECTOR Galois Field Multiply Sum and Accumulate
2681   inline void z_vgfma(  VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t m5);
2682   inline void z_vgfmab( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4);
2683   inline void z_vgfmah( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4);
2684   inline void z_vgfmaf( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4);
2685   inline void z_vgfmag( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4);
2686 
2687   //---&lt;  Vector Logical Instructions  &gt;---
2688 
2689   // AND
2690   inline void z_vn(     VectorRegister v1, VectorRegister v2, VectorRegister v3);
2691   inline void z_vnc(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2692 
2693   // XOR
2694   inline void z_vx(     VectorRegister v1, VectorRegister v2, VectorRegister v3);
2695 
2696   // NOR
2697   inline void z_vno(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2698 
2699   // OR
2700   inline void z_vo(     VectorRegister v1, VectorRegister v2, VectorRegister v3);
2701 
2702   // Comparison (element-wise)
2703   inline void z_vceq(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4, int64_t cc5);
2704   inline void z_vceqb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2705   inline void z_vceqh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2706   inline void z_vceqf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2707   inline void z_vceqg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2708   inline void z_vceqbs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2709   inline void z_vceqhs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2710   inline void z_vceqfs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2711   inline void z_vceqgs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2712   inline void z_vch(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4, int64_t cc5);
2713   inline void z_vchb(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2714   inline void z_vchh(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2715   inline void z_vchf(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2716   inline void z_vchg(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2717   inline void z_vchbs(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2718   inline void z_vchhs(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2719   inline void z_vchfs(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2720   inline void z_vchgs(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2721   inline void z_vchl(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4, int64_t cc5);
2722   inline void z_vchlb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2723   inline void z_vchlh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2724   inline void z_vchlf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2725   inline void z_vchlg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2726   inline void z_vchlbs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2727   inline void z_vchlhs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2728   inline void z_vchlfs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2729   inline void z_vchlgs( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2730 
2731   // Max/Min (element-wise)
2732   inline void z_vmx(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2733   inline void z_vmxb(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2734   inline void z_vmxh(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2735   inline void z_vmxf(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2736   inline void z_vmxg(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2737   inline void z_vmxl(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2738   inline void z_vmxlb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2739   inline void z_vmxlh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2740   inline void z_vmxlf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2741   inline void z_vmxlg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2742   inline void z_vmn(    VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2743   inline void z_vmnb(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2744   inline void z_vmnh(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2745   inline void z_vmnf(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2746   inline void z_vmng(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2747   inline void z_vmnl(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t m4);
2748   inline void z_vmnlb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2749   inline void z_vmnlh(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2750   inline void z_vmnlf(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2751   inline void z_vmnlg(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2752 
2753   // Leading/Trailing Zeros, population count
2754   inline void z_vclz(   VectorRegister v1, VectorRegister v2, int64_t m3);
2755   inline void z_vclzb(  VectorRegister v1, VectorRegister v2);
2756   inline void z_vclzh(  VectorRegister v1, VectorRegister v2);
2757   inline void z_vclzf(  VectorRegister v1, VectorRegister v2);
2758   inline void z_vclzg(  VectorRegister v1, VectorRegister v2);
2759   inline void z_vctz(   VectorRegister v1, VectorRegister v2, int64_t m3);
2760   inline void z_vctzb(  VectorRegister v1, VectorRegister v2);
2761   inline void z_vctzh(  VectorRegister v1, VectorRegister v2);
2762   inline void z_vctzf(  VectorRegister v1, VectorRegister v2);
2763   inline void z_vctzg(  VectorRegister v1, VectorRegister v2);
2764   inline void z_vpopct( VectorRegister v1, VectorRegister v2, int64_t m3);
2765 
2766   // Rotate/Shift
2767   inline void z_verllv( VectorRegister v1, VectorRegister v2, VectorRegister v3,               int64_t m4);
2768   inline void z_verllvb(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2769   inline void z_verllvh(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2770   inline void z_verllvf(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2771   inline void z_verllvg(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2772   inline void z_verll(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2,         int64_t m4);
2773   inline void z_verllb( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2774   inline void z_verllh( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2775   inline void z_verllf( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2776   inline void z_verllg( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2777   inline void z_verim(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4, int64_t m5);
2778   inline void z_verimb( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4);
2779   inline void z_verimh( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4);
2780   inline void z_verimf( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4);
2781   inline void z_verimg( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4);
2782 
2783   inline void z_veslv(  VectorRegister v1, VectorRegister v2, VectorRegister v3,               int64_t m4);
2784   inline void z_veslvb( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2785   inline void z_veslvh( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2786   inline void z_veslvf( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2787   inline void z_veslvg( VectorRegister v1, VectorRegister v2, VectorRegister v3);
2788   inline void z_vesl(   VectorRegister v1, VectorRegister v3, int64_t d2, Register b2,         int64_t m4);
2789   inline void z_veslb(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2790   inline void z_veslh(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2791   inline void z_veslf(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2792   inline void z_veslg(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2793 
2794   inline void z_vesrav( VectorRegister v1, VectorRegister v2, VectorRegister v3,               int64_t m4);
2795   inline void z_vesravb(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2796   inline void z_vesravh(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2797   inline void z_vesravf(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2798   inline void z_vesravg(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2799   inline void z_vesra(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2,         int64_t m4);
2800   inline void z_vesrab( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2801   inline void z_vesrah( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2802   inline void z_vesraf( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2803   inline void z_vesrag( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2804   inline void z_vesrlv( VectorRegister v1, VectorRegister v2, VectorRegister v3,               int64_t m4);
2805   inline void z_vesrlvb(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2806   inline void z_vesrlvh(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2807   inline void z_vesrlvf(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2808   inline void z_vesrlvg(VectorRegister v1, VectorRegister v2, VectorRegister v3);
2809   inline void z_vesrl(  VectorRegister v1, VectorRegister v3, int64_t d2, Register b2,         int64_t m4);
2810   inline void z_vesrlb( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2811   inline void z_vesrlh( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2812   inline void z_vesrlf( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2813   inline void z_vesrlg( VectorRegister v1, VectorRegister v3, int64_t d2, Register b2);
2814 
2815   inline void z_vsl(    VectorRegister v1, VectorRegister v2, VectorRegister v3);
2816   inline void z_vslb(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2817   inline void z_vsldb(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4);
2818 
2819   inline void z_vsra(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2820   inline void z_vsrab(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2821   inline void z_vsrl(   VectorRegister v1, VectorRegister v2, VectorRegister v3);
2822   inline void z_vsrlb(  VectorRegister v1, VectorRegister v2, VectorRegister v3);
2823 
2824   // Test under Mask
2825   inline void z_vtm(    VectorRegister v1, VectorRegister v2);
2826 
2827   //---&lt;  Vector String Instructions  &gt;---
2828   inline void z_vfae(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4, int64_t cc5);   // Find any element
2829   inline void z_vfaeb(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2830   inline void z_vfaeh(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2831   inline void z_vfaef(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2832   inline void z_vfee(   VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4, int64_t cc5);   // Find element equal
2833   inline void z_vfeeb(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2834   inline void z_vfeeh(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2835   inline void z_vfeef(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2836   inline void z_vfene(  VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t imm4, int64_t cc5);   // Find element not equal
2837   inline void z_vfeneb( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2838   inline void z_vfeneh( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2839   inline void z_vfenef( VectorRegister v1, VectorRegister v2, VectorRegister v3, int64_t cc5);
2840   inline void z_vstrc(  VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t imm5, int64_t cc6);   // String range compare
2841   inline void z_vstrcb( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t cc6);
2842   inline void z_vstrch( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t cc6);
2843   inline void z_vstrcf( VectorRegister v1, VectorRegister v2, VectorRegister v3, VectorRegister v4, int64_t cc6);
2844   inline void z_vistr(  VectorRegister v1, VectorRegister v2, int64_t imm3, int64_t cc5);                      // Isolate String
2845   inline void z_vistrb( VectorRegister v1, VectorRegister v2, int64_t cc5);
2846   inline void z_vistrh( VectorRegister v1, VectorRegister v2, int64_t cc5);
2847   inline void z_vistrf( VectorRegister v1, VectorRegister v2, int64_t cc5);
2848   inline void z_vistrbs(VectorRegister v1, VectorRegister v2);
2849   inline void z_vistrhs(VectorRegister v1, VectorRegister v2);
2850   inline void z_vistrfs(VectorRegister v1, VectorRegister v2);
2851 
2852 
2853   // Floatingpoint instructions
2854   // ==========================
2855 
2856   // compare instructions
2857   inline void z_cebr(FloatRegister r1, FloatRegister r2);                     // compare (r1, r2)                ; float
2858   inline void z_ceb(FloatRegister r1, int64_t d2, Register x2, Register b2);  // compare (r1, *(d2_imm12+x2+b2)) ; float
2859   inline void z_ceb(FloatRegister r1, const Address &amp;a);                      // compare (r1, *(d2_imm12+x2+b2)) ; float
2860   inline void z_cdbr(FloatRegister r1, FloatRegister r2);                     // compare (r1, r2)                ; double
2861   inline void z_cdb(FloatRegister r1, int64_t d2, Register x2, Register b2);  // compare (r1, *(d2_imm12+x2+b2)) ; double
2862   inline void z_cdb(FloatRegister r1, const Address &amp;a);                      // compare (r1, *(d2_imm12+x2+b2)) ; double
2863 
2864   // load instructions
2865   inline void z_le( FloatRegister r1, int64_t d2, Register x2, Register b2);   // load r1 = *(d2_uimm12+x2+b2) ; float
2866   inline void z_ley(FloatRegister r1, int64_t d2, Register x2, Register b2);   // load r1 = *(d2_imm20+x2+b2)  ; float
2867   inline void z_ld( FloatRegister r1, int64_t d2, Register x2, Register b2);   // load r1 = *(d2_uimm12+x2+b2) ; double
2868   inline void z_ldy(FloatRegister r1, int64_t d2, Register x2, Register b2);   // load r1 = *(d2_imm20+x2+b2)  ; double
2869   inline void z_le( FloatRegister r1, const Address &amp;a);                       // load r1 = *(a)               ; float
2870   inline void z_ley(FloatRegister r1, const Address &amp;a);                       // load r1 = *(a)               ; float
2871   inline void z_ld( FloatRegister r1, const Address &amp;a);                       // load r1 = *(a)               ; double
2872   inline void z_ldy(FloatRegister r1, const Address &amp;a);                       // load r1 = *(a)               ; double
2873 
2874   // store instructions
2875   inline void z_ste( FloatRegister r1, int64_t d2, Register x2, Register b2);  // store *(d2_uimm12+x2+b2) = r1  ; float
2876   inline void z_stey(FloatRegister r1, int64_t d2, Register x2, Register b2);  // store *(d2_imm20+x2+b2)  = r1  ; float
2877   inline void z_std( FloatRegister r1, int64_t d2, Register x2, Register b2);  // store *(d2_uimm12+x2+b2) = r1  ; double
2878   inline void z_stdy(FloatRegister r1, int64_t d2, Register x2, Register b2);  // store *(d2_imm20+x2+b2)  = r1  ; double
2879   inline void z_ste( FloatRegister r1, const Address &amp;a);                      // store *(a)               = r1  ; float
2880   inline void z_stey(FloatRegister r1, const Address &amp;a);                      // store *(a)               = r1  ; float
2881   inline void z_std( FloatRegister r1, const Address &amp;a);                      // store *(a)               = r1  ; double
2882   inline void z_stdy(FloatRegister r1, const Address &amp;a);                      // store *(a)               = r1  ; double
2883 
2884   // load and store immediates
2885   inline void z_lzer(FloatRegister r1);                                 // r1 = 0     ; single
2886   inline void z_lzdr(FloatRegister r1);                                 // r1 = 0     ; double
2887 
2888   // Move and Convert instructions
2889   inline void z_ler(FloatRegister r1, FloatRegister r2);                // move         r1 = r2 ; float
2890   inline void z_ldr(FloatRegister r1, FloatRegister r2);                // move         r1 = r2 ; double
2891   inline void z_ledbr(FloatRegister r1, FloatRegister r2);              // conv / round r1 = r2 ; float &lt;- double
2892   inline void z_ldebr(FloatRegister r1, FloatRegister r2);              // conv         r1 = r2 ; double &lt;- float
2893 
2894   // move between integer and float registers
2895   inline void z_cefbr( FloatRegister r1, Register r2);                  // r1 = r2; float  &lt;-- int32
2896   inline void z_cdfbr( FloatRegister r1, Register r2);                  // r1 = r2; double &lt;-- int32
2897   inline void z_cegbr( FloatRegister r1, Register r2);                  // r1 = r2; float  &lt;-- int64
2898   inline void z_cdgbr( FloatRegister r1, Register r2);                  // r1 = r2; double &lt;-- int64
2899 
2900   // rounding mode for float-2-int conversions
2901   inline void z_cfebr(Register r1, FloatRegister r2, RoundingMode m);   // conv r1 = r2  ; int32 &lt;-- float
2902   inline void z_cfdbr(Register r1, FloatRegister r2, RoundingMode m);   // conv r1 = r2  ; int32 &lt;-- double
2903   inline void z_cgebr(Register r1, FloatRegister r2, RoundingMode m);   // conv r1 = r2  ; int64 &lt;-- float
2904   inline void z_cgdbr(Register r1, FloatRegister r2, RoundingMode m);   // conv r1 = r2  ; int64 &lt;-- double
2905 
2906   inline void z_ldgr(FloatRegister r1, Register r2);   // fr1 = r2  ; what kind of conversion?  -- z10
2907   inline void z_lgdr(Register r1, FloatRegister r2);   // r1  = fr2 ; what kind of conversion?  -- z10
2908 
2909 
2910   // ADD
2911   inline void z_aebr(FloatRegister f1, FloatRegister f2);                      // f1 = f1 + f2               ; float
2912   inline void z_adbr(FloatRegister f1, FloatRegister f2);                      // f1 = f1 + f2               ; double
2913   inline void z_aeb( FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 + *(d2+x2+b2)      ; float
2914   inline void z_adb( FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 + *(d2+x2+b2)      ; double
2915   inline void z_aeb( FloatRegister f1, const Address&amp; a);                      // f1 = f1 + *(a)             ; float
2916   inline void z_adb( FloatRegister f1, const Address&amp; a);                      // f1 = f1 + *(a)             ; double
2917 
2918   // SUB
2919   inline void z_sebr(FloatRegister f1, FloatRegister f2);                      // f1 = f1 - f2               ; float
2920   inline void z_sdbr(FloatRegister f1, FloatRegister f2);                      // f1 = f1 - f2               ; double
2921   inline void z_seb( FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 - *(d2+x2+b2)      ; float
2922   inline void z_sdb( FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 - *(d2+x2+b2)      ; double
2923   inline void z_seb( FloatRegister f1, const Address&amp; a);                      // f1 = f1 - *(a)             ; float
2924   inline void z_sdb( FloatRegister f1, const Address&amp; a);                      // f1 = f1 - *(a)             ; double
2925   // negate
2926   inline void z_lcebr(FloatRegister r1, FloatRegister r2);                     // neg r1 = -r2   ; float
2927   inline void z_lcdbr(FloatRegister r1, FloatRegister r2);                     // neg r1 = -r2   ; double
2928 
2929   // Absolute value, monadic if fr2 == noreg.
2930   inline void z_lpdbr( FloatRegister fr1, FloatRegister fr2 = fnoreg);         // fr1 = |fr2|
2931 
2932 
2933   // MUL
2934   inline void z_meebr(FloatRegister f1, FloatRegister f2);                      // f1 = f1 * f2               ; float
2935   inline void z_mdbr( FloatRegister f1, FloatRegister f2);                      // f1 = f1 * f2               ; double
2936   inline void z_meeb( FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 * *(d2+x2+b2)      ; float
2937   inline void z_mdb(  FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 * *(d2+x2+b2)      ; double
2938   inline void z_meeb( FloatRegister f1, const Address&amp; a);
2939   inline void z_mdb(  FloatRegister f1, const Address&amp; a);
2940 
2941   // MUL-ADD
2942   inline void z_maebr(FloatRegister f1, FloatRegister f3, FloatRegister f2);    // f1 = f3 * f2 + f1          ; float
2943   inline void z_madbr(FloatRegister f1, FloatRegister f3, FloatRegister f2);    // f1 = f3 * f2 + f1          ; double
2944   inline void z_msebr(FloatRegister f1, FloatRegister f3, FloatRegister f2);    // f1 = f3 * f2 - f1          ; float
2945   inline void z_msdbr(FloatRegister f1, FloatRegister f3, FloatRegister f2);    // f1 = f3 * f2 - f1          ; double
2946   inline void z_maeb(FloatRegister f1, FloatRegister f3, int64_t d2, Register x2, Register b2); // f1 = f3 * *(d2+x2+b2) + f1 ; float
2947   inline void z_madb(FloatRegister f1, FloatRegister f3, int64_t d2, Register x2, Register b2); // f1 = f3 * *(d2+x2+b2) + f1 ; double
2948   inline void z_mseb(FloatRegister f1, FloatRegister f3, int64_t d2, Register x2, Register b2); // f1 = f3 * *(d2+x2+b2) - f1 ; float
2949   inline void z_msdb(FloatRegister f1, FloatRegister f3, int64_t d2, Register x2, Register b2); // f1 = f3 * *(d2+x2+b2) - f1 ; double
2950   inline void z_maeb(FloatRegister f1, FloatRegister f3, const Address&amp; a);
2951   inline void z_madb(FloatRegister f1, FloatRegister f3, const Address&amp; a);
2952   inline void z_mseb(FloatRegister f1, FloatRegister f3, const Address&amp; a);
2953   inline void z_msdb(FloatRegister f1, FloatRegister f3, const Address&amp; a);
2954 
2955   // DIV
2956   inline void z_debr( FloatRegister f1, FloatRegister f2);                      // f1 = f1 / f2               ; float
2957   inline void z_ddbr( FloatRegister f1, FloatRegister f2);                      // f1 = f1 / f2               ; double
2958   inline void z_deb(  FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 / *(d2+x2+b2)      ; float
2959   inline void z_ddb(  FloatRegister f1, int64_t d2, Register x2, Register b2);  // f1 = f1 / *(d2+x2+b2)      ; double
2960   inline void z_deb(  FloatRegister f1, const Address&amp; a);                      // f1 = f1 / *(a)             ; float
2961   inline void z_ddb(  FloatRegister f1, const Address&amp; a);                      // f1 = f1 / *(a)             ; double
2962 
2963   // square root
2964   inline void z_sqdbr(FloatRegister fr1, FloatRegister fr2);                    // fr1 = sqrt(fr2)            ; double
2965   inline void z_sqdb( FloatRegister fr1, int64_t d2, Register x2, Register b2); // fr1 = srqt( *(d2+x2+b2)
2966   inline void z_sqdb( FloatRegister fr1, int64_t d2, Register b2);              // fr1 = srqt( *(d2+b2)
2967 
2968   // Nop instruction
2969   // ===============
2970 
2971   // branch never (nop)
2972   inline void z_nop();
2973   inline void nop(); // Used by shared code.
2974 
2975   // ===============================================================================================
2976 
2977   // Simplified emitters:
2978   // ====================
2979 
2980 
2981   // Some memory instructions without index register (just convenience).
2982   inline void z_layz(Register r1, int64_t d2, Register b2 = Z_R0);
2983   inline void z_lay(Register r1, int64_t d2, Register b2);
2984   inline void z_laz(Register r1, int64_t d2, Register b2);
2985   inline void z_la(Register r1, int64_t d2, Register b2);
2986   inline void z_l(Register r1, int64_t d2, Register b2);
2987   inline void z_ly(Register r1, int64_t d2, Register b2);
2988   inline void z_lg(Register r1, int64_t d2, Register b2);
2989   inline void z_st(Register r1, int64_t d2, Register b2);
2990   inline void z_sty(Register r1, int64_t d2, Register b2);
2991   inline void z_stg(Register r1, int64_t d2, Register b2);
2992   inline void z_lgf(Register r1, int64_t d2, Register b2);
2993   inline void z_lgh(Register r1, int64_t d2, Register b2);
2994   inline void z_llgh(Register r1, int64_t d2, Register b2);
2995   inline void z_llgf(Register r1, int64_t d2, Register b2);
2996   inline void z_lgb(Register r1, int64_t d2, Register b2);
2997   inline void z_cl( Register r1, int64_t d2, Register b2);
2998   inline void z_c(Register r1, int64_t d2, Register b2);
2999   inline void z_cg(Register r1, int64_t d2, Register b2);
3000   inline void z_sh(Register r1, int64_t d2, Register b2);
3001   inline void z_shy(Register r1, int64_t d2, Register b2);
3002   inline void z_ste(FloatRegister r1, int64_t d2, Register b2);
3003   inline void z_std(FloatRegister r1, int64_t d2, Register b2);
3004   inline void z_stdy(FloatRegister r1, int64_t d2, Register b2);
3005   inline void z_stey(FloatRegister r1, int64_t d2, Register b2);
3006   inline void z_ld(FloatRegister r1, int64_t d2, Register b2);
3007   inline void z_ldy(FloatRegister r1, int64_t d2, Register b2);
3008   inline void z_le(FloatRegister r1, int64_t d2, Register b2);
3009   inline void z_ley(FloatRegister r1, int64_t d2, Register b2);
3010 
3011   inline void z_agf(Register r1, int64_t d2, Register b2);
3012 
3013   inline void z_exrl(Register r1, Label&amp; L);
3014   inline void z_larl(Register r1, Label&amp; L);
3015   inline void z_bru( Label&amp; L);
3016   inline void z_brul(Label&amp; L);
3017   inline void z_brul(address a);
3018   inline void z_brh( Label&amp; L);
3019   inline void z_brl( Label&amp; L);
3020   inline void z_bre( Label&amp; L);
3021   inline void z_brnh(Label&amp; L);
3022   inline void z_brnl(Label&amp; L);
3023   inline void z_brne(Label&amp; L);
3024   inline void z_brz( Label&amp; L);
3025   inline void z_brnz(Label&amp; L);
3026   inline void z_brnaz(Label&amp; L);
3027   inline void z_braz(Label&amp; L);
3028   inline void z_brnp(Label&amp; L);
3029 
3030   inline void z_btrue( Label&amp; L);
3031   inline void z_bfalse(Label&amp; L);
3032 
3033   inline void z_bvat(Label&amp; L);   // all true
3034   inline void z_bvnt(Label&amp; L);   // not all true (mixed or all false)
3035   inline void z_bvmix(Label&amp; L);  // mixed true and false
3036   inline void z_bvaf(Label&amp; L);   // not all false (mixed or all true)
3037   inline void z_bvnf(Label&amp; L);   // all false
3038 
3039   inline void z_brno( Label&amp; L);
3040 
3041 
3042   inline void z_basr(Register r1, Register r2);
3043   inline void z_brasl(Register r1, address a);
3044   inline void z_brct(Register r1, address a);
3045   inline void z_brct(Register r1, Label&amp; L);
3046 
3047   inline void z_brxh(Register r1, Register r3, address a);
3048   inline void z_brxh(Register r1, Register r3, Label&amp; L);
3049 
3050   inline void z_brxle(Register r1, Register r3, address a);
3051   inline void z_brxle(Register r1, Register r3, Label&amp; L);
3052 
3053   inline void z_brxhg(Register r1, Register r3, address a);
3054   inline void z_brxhg(Register r1, Register r3, Label&amp; L);
3055 
3056   inline void z_brxlg(Register r1, Register r3, address a);
3057   inline void z_brxlg(Register r1, Register r3, Label&amp; L);
3058 
3059   // Ppopulation count intrinsics.
3060   inline void z_flogr(Register r1, Register r2);    // find leftmost one
3061   inline void z_popcnt(Register r1, Register r2);   // population count
3062   inline void z_ahhhr(Register r1, Register r2, Register r3);   // ADD halfword high high
3063   inline void z_ahhlr(Register r1, Register r2, Register r3);   // ADD halfword high low
3064 
3065   inline void z_tam();
3066   inline void z_stckf(int64_t d2, Register b2);
3067   inline void z_stm( Register r1, Register r3, int64_t d2, Register b2);
3068   inline void z_stmy(Register r1, Register r3, int64_t d2, Register b2);
3069   inline void z_stmg(Register r1, Register r3, int64_t d2, Register b2);
3070   inline void z_lm( Register r1, Register r3, int64_t d2, Register b2);
3071   inline void z_lmy(Register r1, Register r3, int64_t d2, Register b2);
3072   inline void z_lmg(Register r1, Register r3, int64_t d2, Register b2);
3073 
3074   inline void z_cs( Register r1, Register r3, int64_t d2, Register b2);
3075   inline void z_csy(Register r1, Register r3, int64_t d2, Register b2);
3076   inline void z_csg(Register r1, Register r3, int64_t d2, Register b2);
3077   inline void z_cs( Register r1, Register r3, const Address&amp; a);
3078   inline void z_csy(Register r1, Register r3, const Address&amp; a);
3079   inline void z_csg(Register r1, Register r3, const Address&amp; a);
3080 
3081   inline void z_cvd(Register r1, int64_t d2, Register x2, Register b2);
3082   inline void z_cvdg(Register r1, int64_t d2, Register x2, Register b2);
3083   inline void z_cvd(Register r1, int64_t d2, Register b2);
3084   inline void z_cvdg(Register r1, int64_t d2, Register b2);
3085 
3086   // Instruction queries:
3087   // instruction properties and recognize emitted instructions
3088   // ===========================================================
3089 
3090   static int nop_size() { return 2; }
3091 
3092   static int z_brul_size() { return 6; }
3093 
3094   static bool is_z_basr(short x) {
3095     return (BASR_ZOPC == (x &amp; BASR_MASK));
3096   }
3097   static bool is_z_algr(long x) {
3098     return (ALGR_ZOPC == (x &amp; RRE_MASK));
3099   }
3100   static bool is_z_lb(long x) {
3101     return (LB_ZOPC == (x &amp; LB_MASK));
3102   }
3103   static bool is_z_lh(int x) {
3104     return (LH_ZOPC == (x &amp; LH_MASK));
3105   }
3106   static bool is_z_l(int x) {
3107     return (L_ZOPC == (x &amp; L_MASK));
3108   }
3109   static bool is_z_lgr(long x) {
3110     return (LGR_ZOPC == (x &amp; RRE_MASK));
3111   }
3112   static bool is_z_ly(long x) {
3113     return (LY_ZOPC == (x &amp; LY_MASK));
3114   }
3115   static bool is_z_lg(long x) {
3116     return (LG_ZOPC == (x &amp; LG_MASK));
3117   }
3118   static bool is_z_llgh(long x) {
3119     return (LLGH_ZOPC == (x &amp; LLGH_MASK));
3120   }
3121   static bool is_z_llgf(long x) {
3122     return (LLGF_ZOPC == (x &amp; LLGF_MASK));
3123   }
3124   static bool is_z_le(int x) {
3125     return (LE_ZOPC == (x &amp; LE_MASK));
3126   }
3127   static bool is_z_ld(int x) {
3128     return (LD_ZOPC == (x &amp; LD_MASK));
3129   }
3130   static bool is_z_st(int x) {
3131     return (ST_ZOPC == (x &amp; ST_MASK));
3132   }
3133   static bool is_z_stc(int x) {
3134     return (STC_ZOPC == (x &amp; STC_MASK));
3135   }
3136   static bool is_z_stg(long x) {
3137     return (STG_ZOPC == (x &amp; STG_MASK));
3138   }
3139   static bool is_z_sth(int x) {
3140     return (STH_ZOPC == (x &amp; STH_MASK));
3141   }
3142   static bool is_z_ste(int x) {
3143     return (STE_ZOPC == (x &amp; STE_MASK));
3144   }
3145   static bool is_z_std(int x) {
3146     return (STD_ZOPC == (x &amp; STD_MASK));
3147   }
3148   static bool is_z_slag(long x) {
3149     return (SLAG_ZOPC == (x &amp; SLAG_MASK));
3150   }
3151   static bool is_z_tmy(long x) {
3152     return (TMY_ZOPC == (x &amp; TMY_MASK));
3153   }
3154   static bool is_z_tm(long x) {
3155     return ((unsigned int)TM_ZOPC == (x &amp; (unsigned int)TM_MASK));
3156   }
3157   static bool is_z_bcr(long x) {
3158     return (BCR_ZOPC == (x &amp; BCR_MASK));
3159   }
3160   static bool is_z_nop(long x) {
3161     return is_z_bcr(x) &amp;&amp; ((x &amp; 0x00ff) == 0);
3162   }
3163   static bool is_z_nop(address x) {
3164     return is_z_nop(* (short *) x);
3165   }
3166   static bool is_z_br(long x) {
3167     return is_z_bcr(x) &amp;&amp; ((x &amp; 0x00f0) == 0x00f0);
3168   }
3169   static bool is_z_brc(long x, int cond) {
3170     return ((unsigned int)BRC_ZOPC == (x &amp; BRC_MASK)) &amp;&amp; ((cond&lt;&lt;20) == (x &amp; 0x00f00000U));
3171   }
3172   // Make use of lightweight sync.
3173   static bool is_z_sync_full(long x) {
3174     return is_z_bcr(x) &amp;&amp; (((x &amp; 0x00f0)&gt;&gt;4)==bcondFullSync) &amp;&amp; ((x &amp; 0x000f)==0x0000);
3175   }
3176   static bool is_z_sync_light(long x) {
3177     return is_z_bcr(x) &amp;&amp; (((x &amp; 0x00f0)&gt;&gt;4)==bcondLightSync) &amp;&amp; ((x &amp; 0x000f)==0x0000);
3178   }
3179   static bool is_z_sync(long x) {
3180     return is_z_sync_full(x) || is_z_sync_light(x);
3181   }
3182 
3183   static bool is_z_brasl(long x) {
3184     return (BRASL_ZOPC == (x &amp; BRASL_MASK));
3185   }
3186   static bool is_z_brasl(address a) {
3187   long x = (*((long *)a))&gt;&gt;16;
3188    return is_z_brasl(x);
3189   }
3190   static bool is_z_larl(long x) {
3191     return (LARL_ZOPC == (x &amp; LARL_MASK));
3192   }
3193   static bool is_z_lgrl(long x) {
3194     return (LGRL_ZOPC == (x &amp; LGRL_MASK));
3195   }
3196   static bool is_z_lgrl(address a) {
3197   long x = (*((long *)a))&gt;&gt;16;
3198    return is_z_lgrl(x);
3199   }
3200 
3201   static bool is_z_lghi(unsigned long x) {
3202     return (unsigned int)LGHI_ZOPC == (x &amp; (unsigned int)LGHI_MASK);
3203   }
3204 
3205   static bool is_z_llill(unsigned long x) {
3206     return (unsigned int)LLILL_ZOPC == (x &amp; (unsigned int)LLI_MASK);
3207   }
3208   static bool is_z_llilh(unsigned long x) {
3209     return (unsigned int)LLILH_ZOPC == (x &amp; (unsigned int)LLI_MASK);
3210   }
3211   static bool is_z_llihl(unsigned long x) {
3212     return (unsigned int)LLIHL_ZOPC == (x &amp; (unsigned int)LLI_MASK);
3213   }
3214   static bool is_z_llihh(unsigned long x) {
3215     return (unsigned int)LLIHH_ZOPC == (x &amp; (unsigned int)LLI_MASK);
3216   }
3217   static bool is_z_llilf(unsigned long x) {
3218     return LLILF_ZOPC == (x &amp; LLIF_MASK);
3219   }
3220   static bool is_z_llihf(unsigned long x) {
3221     return LLIHF_ZOPC == (x &amp; LLIF_MASK);
3222   }
3223 
3224   static bool is_z_iill(unsigned long x) {
3225     return (unsigned int)IILL_ZOPC == (x &amp; (unsigned int)II_MASK);
3226   }
3227   static bool is_z_iilh(unsigned long x) {
3228     return (unsigned int)IILH_ZOPC == (x &amp; (unsigned int)II_MASK);
3229   }
3230   static bool is_z_iihl(unsigned long x) {
3231     return (unsigned int)IIHL_ZOPC == (x &amp; (unsigned int)II_MASK);
3232   }
3233   static bool is_z_iihh(unsigned long x) {
3234     return (unsigned int)IIHH_ZOPC == (x &amp; (unsigned int)II_MASK);
3235   }
3236   static bool is_z_iilf(unsigned long x) {
3237     return IILF_ZOPC == (x &amp; IIF_MASK);
3238   }
3239   static bool is_z_iihf(unsigned long x) {
3240     return IIHF_ZOPC == (x &amp; IIF_MASK);
3241   }
3242 
3243   static inline bool is_equal(unsigned long inst, unsigned long idef);
3244   static inline bool is_equal(unsigned long inst, unsigned long idef, unsigned long imask);
3245   static inline bool is_equal(address iloc, unsigned long idef);
3246   static inline bool is_equal(address iloc, unsigned long idef, unsigned long imask);
3247 
3248   static inline bool is_sigtrap_range_check(address pc);
3249   static inline bool is_sigtrap_zero_check(address pc);
3250 
3251   //-----------------
3252   // memory barriers
3253   //-----------------
3254   // machine barrier instructions:
3255   //
3256   // - z_sync            Two-way memory barrier, aka fence.
3257   //                     Only load-after-store-order is not guaranteed in the
3258   //                     z/Architecture memory model, i.e. only &#39;fence&#39; is needed.
3259   //
3260   // semantic barrier instructions:
3261   // (as defined in orderAccess.hpp)
3262   //
3263   // - z_release         orders Store|Store,   empty implementation
3264   //                            Load|Store
3265   // - z_acquire         orders Load|Store,    empty implementation
3266   //                            Load|Load
3267   // - z_fence           orders Store|Store,   implemented as z_sync.
3268   //                            Load|Store,
3269   //                            Load|Load,
3270   //                            Store|Load
3271   //
3272   // For this implementation to be correct, we need H/W fixes on (very) old H/W:
3273   //          For z990, it is Driver-55:  MCL232 in the J13484 (i390/ML) Stream.
3274   //          For z9,   it is Driver-67:  MCL065 in the G40963 (i390/ML) Stream.
3275   // These drivers are a prereq. Otherwise, memory synchronization will not work.
3276 
3277   inline void z_sync();
3278   inline void z_release();
3279   inline void z_acquire();
3280   inline void z_fence();
3281 
3282   // Creation
3283   Assembler(CodeBuffer* code) : AbstractAssembler(code) { }
3284 
3285 };
3286 
3287 #endif // CPU_S390_ASSEMBLER_S390_HPP
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
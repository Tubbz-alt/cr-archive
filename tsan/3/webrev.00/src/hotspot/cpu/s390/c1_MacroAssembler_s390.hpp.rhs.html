<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/c1_MacroAssembler_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2016 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_S390_C1_MACROASSEMBLER_S390_HPP
 27 #define CPU_S390_C1_MACROASSEMBLER_S390_HPP
 28 
 29   void pd_init() { /* nothing to do */ }
 30 
 31  public:
 32   void try_allocate(
 33     Register obj,                      // result: Pointer to object after successful allocation.
 34     Register var_size_in_bytes,        // Object size in bytes if unknown at compile time; invalid otherwise.
 35     int      con_size_in_bytes,        // Object size in bytes if   known at compile time.
 36     Register t1,                       // temp register
 37     Label&amp;   slow_case                 // Continuation point if fast allocation fails.
 38   );
 39 
 40   void initialize_header(Register obj, Register klass, Register len, Register Rzero, Register t1);
 41   void initialize_body(Register objectFields, Register len_in_bytes, Register Rzero);
 42 
 43   // locking
<a name="1" id="anc1"></a><span class="line-modified"> 44   // hdr     : Used to hold locked markWord to be CASed into obj, contents destroyed.</span>
 45   // obj     : Must point to the object to lock, contents preserved.
 46   // disp_hdr: Must point to the displaced header location, contents preserved.
 47   // Returns code offset at which to add null check debug information.
 48   void lock_object(Register hdr, Register obj, Register disp_hdr, Label&amp; slow_case);
 49 
 50   // unlocking
<a name="2" id="anc2"></a><span class="line-modified"> 51   // hdr     : Used to hold original markWord to be CASed back into obj, contents destroyed.</span>
 52   // obj     : Must point to the object to lock, contents preserved.
 53   // disp_hdr: Must point to the displaced header location, contents destroyed.
 54   void unlock_object(Register hdr, Register obj, Register lock, Label&amp; slow_case);
 55 
 56   void initialize_object(
 57     Register obj,                      // result: Pointer to object after successful allocation.
 58     Register klass,                    // object klass
 59     Register var_size_in_bytes,        // Object size in bytes if unknown at compile time; invalid otherwise.
 60     int      con_size_in_bytes,        // Object size in bytes if   known at compile time.
 61     Register t1,                       // temp register
 62     Register t2                        // temp register
 63   );
 64 
 65   // Allocation of fixed-size objects.
 66   // This can also be used to allocate fixed-size arrays, by setting
 67   // hdr_size correctly and storing the array length afterwards.
 68   void allocate_object(
 69     Register obj,                      // result: Pointer to object after successful allocation.
 70     Register t1,                       // temp register
 71     Register t2,                       // temp register
 72     int      hdr_size,                 // object header size in words
 73     int      obj_size,                 // object size in words
 74     Register klass,                    // object klass
 75     Label&amp;   slow_case                 // Continuation point if fast allocation fails.
 76   );
 77 
 78   enum {
 79     max_array_allocation_length = 0x01000000 // Sparc friendly value, requires sethi only.
 80   };
 81 
 82   // Allocation of arrays.
 83   void allocate_array(
 84     Register obj,                      // result: Pointer to array after successful allocation.
 85     Register len,                      // array length
 86     Register t1,                       // temp register
 87     Register t2,                       // temp register
 88     int      hdr_size,                 // object header size in words
 89     int      elt_size,                 // element size in bytes
 90     Register klass,                    // object klass
 91     Label&amp;   slow_case                 // Continuation point if fast allocation fails.
 92   );
 93 
 94   // Invalidates registers in this window.
 95   void invalidate_registers(Register preserve1 = noreg, Register preserve2 = noreg,
 96                             Register preserve3 = noreg) PRODUCT_RETURN;
 97 
 98   // This platform only uses signal-based null checks. The Label is not needed.
 99   void null_check(Register r, Label *Lnull = NULL) { MacroAssembler::null_check(r); }
100 
101 #endif // CPU_S390_C1_MACROASSEMBLER_S390_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
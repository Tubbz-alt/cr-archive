<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/frame_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;interpreter/interpreter.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 29 #include &quot;oops/markOop.hpp&quot;</span>

 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/frame.inline.hpp&quot;
 32 #include &quot;runtime/handles.inline.hpp&quot;
 33 #include &quot;runtime/javaCalls.hpp&quot;
 34 #include &quot;runtime/monitorChunk.hpp&quot;
 35 #include &quot;runtime/os.inline.hpp&quot;
 36 #include &quot;runtime/signature.hpp&quot;
 37 #include &quot;runtime/stubCodeGenerator.hpp&quot;
 38 #include &quot;runtime/stubRoutines.hpp&quot;
 39 #include &quot;vmreg_s390.inline.hpp&quot;
 40 #ifdef COMPILER1
 41 #include &quot;c1/c1_Runtime1.hpp&quot;
 42 #include &quot;runtime/vframeArray.hpp&quot;
 43 #endif
 44 
 45 // Major contributions by Aha, AS.
 46 
 47 #ifdef ASSERT
 48 void RegisterMap::check_location_valid() {
 49 }
 50 #endif // ASSERT
 51 
 52 
 53 // Profiling/safepoint support
 54 
 55 bool frame::safe_for_sender(JavaThread *thread) {
 56   bool safe = false;
 57   address sp = (address)_sp;
 58   address fp = (address)_fp;
 59   address unextended_sp = (address)_unextended_sp;
 60 
<a name="3" id="anc3"></a><span class="line-modified"> 61   // Consider stack guards when trying to determine &quot;safe&quot; stack pointers</span>
<span class="line-removed"> 62   static size_t stack_guard_size = os::uses_stack_guard_pages() ?</span>
<span class="line-removed"> 63     JavaThread::stack_red_zone_size() + JavaThread::stack_yellow_reserved_zone_size() : 0;</span>
<span class="line-removed"> 64   size_t usable_stack_size = thread-&gt;stack_size() - stack_guard_size;</span>
<span class="line-removed"> 65 </span>
 66   // sp must be within the usable part of the stack (not in guards)
<a name="4" id="anc4"></a><span class="line-modified"> 67   bool sp_safe = (sp &lt; thread-&gt;stack_base()) &amp;&amp;</span>
<span class="line-removed"> 68                  (sp &gt;= thread-&gt;stack_base() - usable_stack_size);</span>
<span class="line-removed"> 69 </span>
<span class="line-removed"> 70 </span>
<span class="line-removed"> 71   if (!sp_safe) {</span>
 72     return false;
 73   }
 74 
 75   // Unextended sp must be within the stack
 76   bool unextended_sp_safe = (unextended_sp &lt; thread-&gt;stack_base());
 77 
 78   if (!unextended_sp_safe) {
 79     return false;
 80   }
 81 
 82   // An fp must be within the stack and above (but not equal) sp.
<a name="5" id="anc5"></a><span class="line-modified"> 83   bool fp_safe = (fp &lt;= thread-&gt;stack_base()) &amp;&amp;  (fp &gt; sp);</span>
 84   // An interpreter fp must be within the stack and above (but not equal) sp.
 85   // Moreover, it must be at least the size of the z_ijava_state structure.
<a name="6" id="anc6"></a><span class="line-modified"> 86   bool fp_interp_safe = (fp &lt;= thread-&gt;stack_base()) &amp;&amp; (fp &gt; sp) &amp;&amp;</span>
 87     ((fp - sp) &gt;= z_ijava_state_size);
 88 
 89   // We know sp/unextended_sp are safe, only fp is questionable here
 90 
 91   // If the current frame is known to the code cache then we can attempt to
 92   // to construct the sender and do some validation of it. This goes a long way
 93   // toward eliminating issues when we get in frame construction code
 94 
 95   if (_cb != NULL ) {
 96     // Entry frame checks
 97     if (is_entry_frame()) {
 98       // An entry frame must have a valid fp.
 99       return fp_safe &amp;&amp; is_entry_frame_valid(thread);
100     }
101 
102     // Now check if the frame is complete and the test is
103     // reliable. Unfortunately we can only check frame completeness for
104     // runtime stubs. Other generic buffer blobs are more
105     // problematic so we just assume they are OK. Adapter blobs never have a
106     // complete frame and are never OK. nmethods should be OK on s390.
107     if (!_cb-&gt;is_frame_complete_at(_pc)) {
108       if (_cb-&gt;is_adapter_blob() || _cb-&gt;is_runtime_stub()) {
109         return false;
110       }
111     }
112 
113     // Could just be some random pointer within the codeBlob.
114     if (!_cb-&gt;code_contains(_pc)) {
115       return false;
116     }
117 
118     if (is_interpreted_frame() &amp;&amp; !fp_interp_safe) {
119       return false;
120     }
121 
122     z_abi_160* sender_abi = (z_abi_160*) fp;
123     intptr_t* sender_sp = (intptr_t*) sender_abi-&gt;callers_sp;
124     address   sender_pc = (address) sender_abi-&gt;return_pc;
125 
126     // We must always be able to find a recognizable pc.
127     CodeBlob* sender_blob = CodeCache::find_blob_unsafe(sender_pc);
128     if (sender_blob == NULL) {
129       return false;
130     }
131 
132     // Could be a zombie method
133     if (sender_blob-&gt;is_zombie() || sender_blob-&gt;is_unloaded()) {
134       return false;
135     }
136 
137     // It should be safe to construct the sender though it might not be valid.
138 
139     frame sender(sender_sp, sender_pc);
140 
141     // Do we have a valid fp?
142     address sender_fp = (address) sender.fp();
143 
144     // sender_fp must be within the stack and above (but not
145     // equal) current frame&#39;s fp.
<a name="7" id="anc7"></a><span class="line-modified">146     if (sender_fp &gt; thread-&gt;stack_base() || sender_fp &lt;= fp) {</span>
147         return false;
148     }
149 
150     // If the potential sender is the interpreter then we can do some more checking.
151     if (Interpreter::contains(sender_pc)) {
152       return sender.is_interpreted_frame_valid(thread);
153     }
154 
155     // Could just be some random pointer within the codeBlob.
156     if (!sender.cb()-&gt;code_contains(sender_pc)) {
157       return false;
158     }
159 
160     // We should never be able to see an adapter if the current frame is something from code cache.
161     if (sender_blob-&gt;is_adapter_blob()) {
162       return false;
163     }
164 
165     if (sender.is_entry_frame()) {
166       return sender.is_entry_frame_valid(thread);
167     }
168 
169     // Frame size is always greater than zero. If the sender frame size is zero or less,
170     // something is really weird and we better give up.
171     if (sender_blob-&gt;frame_size() &lt;= 0) {
172       return false;
173     }
174 
175     return true;
176   }
177 
178   // Must be native-compiled frame. Since sender will try and use fp to find
179   // linkages it must be safe
180 
181   if (!fp_safe) {
182     return false;
183   }
184 
185   return true;
186 }
187 
188 bool frame::is_interpreted_frame() const {
189   return Interpreter::contains(pc());
190 }
191 
192 // sender_sp
193 
194 intptr_t* frame::interpreter_frame_sender_sp() const {
195   return sender_sp();
196 }
197 
198 frame frame::sender_for_entry_frame(RegisterMap *map) const {
199   assert(map != NULL, &quot;map must be set&quot;);
200   // Java frame called from C. Skip all C frames and return top C
201   // frame of that chunk as the sender.
202   JavaFrameAnchor* jfa = entry_frame_call_wrapper()-&gt;anchor();
203 
204   assert(!entry_frame_is_first(), &quot;next Java sp must be non zero&quot;);
205   assert(jfa-&gt;last_Java_sp() &gt; _sp, &quot;must be above this frame on stack&quot;);
206 
207   map-&gt;clear();
208 
209   assert(map-&gt;include_argument_oops(), &quot;should be set by clear&quot;);
210 
211   if (jfa-&gt;last_Java_pc() != NULL) {
212     frame fr(jfa-&gt;last_Java_sp(), jfa-&gt;last_Java_pc());
213     return fr;
214   }
215   // Last_java_pc is not set if we come here from compiled code.
216   frame fr(jfa-&gt;last_Java_sp());
217   return fr;
218 }
219 
220 frame frame::sender_for_interpreter_frame(RegisterMap *map) const {
221   // Pass callers sender_sp as unextended_sp.
222   return frame(sender_sp(), sender_pc(), (intptr_t*)(ijava_state()-&gt;sender_sp));
223 }
224 
225 frame frame::sender_for_compiled_frame(RegisterMap *map) const {
226   assert(map != NULL, &quot;map must be set&quot;);
227   // Frame owned by compiler.
228 
229   address pc = *compiled_sender_pc_addr(_cb);
230   frame caller(compiled_sender_sp(_cb), pc);
231 
232   // Now adjust the map.
233 
234   // Get the rest.
235   if (map-&gt;update_map()) {
236     // Tell GC to use argument oopmaps for some runtime stubs that need it.
237     map-&gt;set_include_argument_oops(_cb-&gt;caller_must_gc_arguments(map-&gt;thread()));
238     if (_cb-&gt;oop_maps() != NULL) {
239       OopMapSet::update_register_map(this, map);
240     }
241   }
242 
243   return caller;
244 }
245 
246 intptr_t* frame::compiled_sender_sp(CodeBlob* cb) const {
247   return sender_sp();
248 }
249 
250 address* frame::compiled_sender_pc_addr(CodeBlob* cb) const {
251   return sender_pc_addr();
252 }
253 
254 frame frame::sender(RegisterMap* map) const {
255   // Default is we don&#39;t have to follow them. The sender_for_xxx will
256   // update it accordingly.
257   map-&gt;set_include_argument_oops(false);
258 
259   if (is_entry_frame()) {
260     return sender_for_entry_frame(map);
261   }
262   if (is_interpreted_frame()) {
263     return sender_for_interpreter_frame(map);
264   }
265   assert(_cb == CodeCache::find_blob(pc()),&quot;Must be the same&quot;);
266   if (_cb != NULL) {
267     return sender_for_compiled_frame(map);
268   }
269   // Must be native-compiled frame, i.e. the marshaling code for native
270   // methods that exists in the core system.
271   return frame(sender_sp(), sender_pc());
272 }
273 
274 void frame::patch_pc(Thread* thread, address pc) {
275   if (TracePcPatching) {
276     tty-&gt;print_cr(&quot;patch_pc at address  &quot; PTR_FORMAT &quot; [&quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT &quot;] &quot;,
277                   p2i(&amp;((address*) _sp)[-1]), p2i(((address*) _sp)[-1]), p2i(pc));
278   }
279   own_abi()-&gt;return_pc = (uint64_t)pc;
280   _cb = CodeCache::find_blob(pc);
281   address original_pc = CompiledMethod::get_deopt_original_pc(this);
282   if (original_pc != NULL) {
283     assert(original_pc == _pc, &quot;expected original to be stored before patching&quot;);
284     _deopt_state = is_deoptimized;
285     // Leave _pc as is.
286   } else {
287     _deopt_state = not_deoptimized;
288     _pc = pc;
289   }
290 }
291 
292 bool frame::is_interpreted_frame_valid(JavaThread* thread) const {
293   // Is there anything to do?
294   assert(is_interpreted_frame(), &quot;Not an interpreted frame&quot;);
295   return true;
296 }
297 
298 BasicType frame::interpreter_frame_result(oop* oop_result, jvalue* value_result) {
299   assert(is_interpreted_frame(), &quot;interpreted frame expected&quot;);
300   Method* method = interpreter_frame_method();
301   BasicType type = method-&gt;result_type();
302 
303   if (method-&gt;is_native()) {
304     address lresult = (address)&amp;(ijava_state()-&gt;lresult);
305     address fresult = (address)&amp;(ijava_state()-&gt;fresult);
306 
307     switch (type) {
308       case T_OBJECT:
309       case T_ARRAY: {
310         *oop_result = (oop) (void*) ijava_state()-&gt;oop_tmp;
311         break;
312       }
313       // We use std/stfd to store the values.
314       case T_BOOLEAN : value_result-&gt;z = (jboolean) *(unsigned long*)lresult; break;
315       case T_INT     : value_result-&gt;i = (jint)     *(long*)lresult;          break;
316       case T_CHAR    : value_result-&gt;c = (jchar)    *(unsigned long*)lresult; break;
317       case T_SHORT   : value_result-&gt;s = (jshort)   *(long*)lresult;          break;
318       case T_BYTE    : value_result-&gt;z = (jbyte)    *(long*)lresult;          break;
319       case T_LONG    : value_result-&gt;j = (jlong)    *(long*)lresult;          break;
320       case T_FLOAT   : value_result-&gt;f = (jfloat)   *(float*)fresult;        break;
321       case T_DOUBLE  : value_result-&gt;d = (jdouble)  *(double*)fresult;        break;
322       case T_VOID    : break; // Nothing to do.
323       default        : ShouldNotReachHere();
324     }
325   } else {
326     intptr_t* tos_addr = interpreter_frame_tos_address();
327     switch (type) {
328       case T_OBJECT:
329       case T_ARRAY: {
330        oop obj = *(oop*)tos_addr;
331        assert(obj == NULL || Universe::heap()-&gt;is_in(obj), &quot;sanity check&quot;);
332        *oop_result = obj;
333        break;
334       }
335       case T_BOOLEAN : value_result-&gt;z = (jboolean) *(jint*)tos_addr; break;
336       case T_BYTE    : value_result-&gt;b = (jbyte) *(jint*)tos_addr; break;
337       case T_CHAR    : value_result-&gt;c = (jchar) *(jint*)tos_addr; break;
338       case T_SHORT   : value_result-&gt;s = (jshort) *(jint*)tos_addr; break;
339       case T_INT     : value_result-&gt;i = *(jint*)tos_addr; break;
340       case T_LONG    : value_result-&gt;j = *(jlong*)tos_addr; break;
341       case T_FLOAT   : value_result-&gt;f = *(jfloat*)tos_addr; break;
342       case T_DOUBLE  : value_result-&gt;d = *(jdouble*)tos_addr; break;
343       case T_VOID    : break; // Nothing to do.
344       default        : ShouldNotReachHere();
345     }
346   }
347 
348   return type;
349 }
350 
351 
352 // Dump all frames starting a given C stack-pointer.
353 // Use max_frames to limit the number of traced frames.
354 void frame::back_trace(outputStream* st, intptr_t* start_sp, intptr_t* top_pc, unsigned long flags, int max_frames) {
355 
356   static char buf[ 150 ];
357 
358   bool print_outgoing_arguments = flags &amp; 0x1;
359   bool print_istate_pointers    = flags &amp; 0x2;
360   int num = 0;
361 
362   intptr_t* current_sp = (intptr_t*) start_sp;
363   int last_num_jargs = 0;
364   int frame_type = 0;
365   int last_frame_type = 0;
366 
367   while (current_sp) {
368     intptr_t* current_fp = (intptr_t*) *current_sp;
369     address   current_pc = (num == 0)
370                            ? (address) top_pc
371                            : (address) *((intptr_t*)(((address) current_sp) + _z_abi(return_pc)));
372 
373     if ((intptr_t*) current_fp != 0 &amp;&amp; (intptr_t*) current_fp &lt;= current_sp) {
374       st-&gt;print_cr(&quot;ERROR: corrupt stack&quot;);
375       return;
376     }
377 
378     st-&gt;print(&quot;#%-3d &quot;, num);
379     const char* type_name = &quot;    &quot;;
380     const char* function_name = NULL;
381 
382     // Detect current frame&#39;s frame_type, default to &#39;C frame&#39;.
383     frame_type = 0;
384 
385     CodeBlob* blob = NULL;
386 
387     if (Interpreter::contains(current_pc)) {
388       frame_type = 1;
389     } else if (StubRoutines::contains(current_pc)) {
390       if (StubRoutines::returns_to_call_stub(current_pc)) {
391         frame_type = 2;
392       } else {
393         frame_type = 4;
394         type_name = &quot;stu&quot;;
395         StubCodeDesc* desc = StubCodeDesc::desc_for (current_pc);
396         if (desc) {
397           function_name = desc-&gt;name();
398         } else {
399           function_name = &quot;unknown stub&quot;;
400         }
401       }
402     } else if (CodeCache::contains(current_pc)) {
403       blob = CodeCache::find_blob_unsafe(current_pc);
404       if (blob) {
405         if (blob-&gt;is_nmethod()) {
406           frame_type = 3;
407         } else if (blob-&gt;is_deoptimization_stub()) {
408           frame_type = 4;
409           type_name = &quot;deo&quot;;
410           function_name = &quot;deoptimization blob&quot;;
411         } else if (blob-&gt;is_uncommon_trap_stub()) {
412           frame_type = 4;
413           type_name = &quot;uct&quot;;
414           function_name = &quot;uncommon trap blob&quot;;
415         } else if (blob-&gt;is_exception_stub()) {
416           frame_type = 4;
417           type_name = &quot;exc&quot;;
418           function_name = &quot;exception blob&quot;;
419         } else if (blob-&gt;is_safepoint_stub()) {
420           frame_type = 4;
421           type_name = &quot;saf&quot;;
422           function_name = &quot;safepoint blob&quot;;
423         } else if (blob-&gt;is_runtime_stub()) {
424           frame_type = 4;
425           type_name = &quot;run&quot;;
426           function_name = ((RuntimeStub *)blob)-&gt;name();
427         } else if (blob-&gt;is_method_handles_adapter_blob()) {
428           frame_type = 4;
429           type_name = &quot;mha&quot;;
430           function_name = &quot;method handles adapter blob&quot;;
431         } else {
432           frame_type = 4;
433           type_name = &quot;blo&quot;;
434           function_name = &quot;unknown code blob&quot;;
435         }
436       } else {
437         frame_type = 4;
438         type_name = &quot;blo&quot;;
439         function_name = &quot;unknown code blob&quot;;
440       }
441     }
442 
443     st-&gt;print(&quot;sp=&quot; PTR_FORMAT &quot; &quot;, p2i(current_sp));
444 
445     if (frame_type == 0) {
446       current_pc = (address) *((intptr_t*)(((address) current_sp) + _z_abi(gpr14)));
447     }
448 
449     st-&gt;print(&quot;pc=&quot; PTR_FORMAT &quot; &quot;, p2i(current_pc));
450     st-&gt;print(&quot; &quot;);
451 
452     switch (frame_type) {
453       case 0: // C frame:
454         {
455           st-&gt;print(&quot;    &quot;);
456           if (current_pc == 0) {
457             st-&gt;print(&quot;? &quot;);
458           } else {
459              // name
460             int func_offset;
461             char demangled_name[256];
462             int demangled_name_len = 256;
463             if (os::dll_address_to_function_name(current_pc, demangled_name, demangled_name_len, &amp;func_offset)) {
464               demangled_name[demangled_name_len-1] = &#39;\0&#39;;
465               st-&gt;print(func_offset == -1 ? &quot;%s &quot; : &quot;%s+0x%x&quot;, demangled_name, func_offset);
466             } else {
467               st-&gt;print(&quot;? &quot;);
468             }
469           }
470         }
471         break;
472 
473       case 1: // interpreter frame:
474         {
475           st-&gt;print(&quot; i  &quot;);
476 
477           if (last_frame_type != 1) last_num_jargs = 8;
478 
479           // name
480           Method* method = *(Method**)((address)current_fp + _z_ijava_state_neg(method));
481           if (method) {
482             ResourceMark rm;
483             if (method-&gt;is_synchronized()) st-&gt;print(&quot;synchronized &quot;);
484             if (method-&gt;is_static()) st-&gt;print(&quot;static &quot;);
485             if (method-&gt;is_native()) st-&gt;print(&quot;native &quot;);
486             method-&gt;name_and_sig_as_C_string(buf, sizeof(buf));
487             st-&gt;print(&quot;%s &quot;, buf);
488           }
489           else
490             st-&gt;print(&quot;? &quot;);
491 
492           intptr_t* tos = (intptr_t*) *(intptr_t*)((address)current_fp + _z_ijava_state_neg(esp));
493           if (print_istate_pointers) {
494             st-&gt;cr();
495             st-&gt;print(&quot;     &quot;);
496             st-&gt;print(&quot;ts=&quot; PTR_FORMAT &quot; &quot;, p2i(tos));
497           }
498 
499           // Dump some Java stack slots.
500           if (print_outgoing_arguments) {
501             if (method-&gt;is_native()) {
502 #ifdef ASSERT
503               intptr_t* cargs = (intptr_t*) (((address)current_sp) + _z_abi(carg_1));
504               for (int i = 0; i &lt; last_num_jargs; i++) {
505                 // Cargs is not prepushed.
506                 st-&gt;cr();
507                 st-&gt;print(&quot;        &quot;);
508                 st-&gt;print(PTR_FORMAT, *(cargs));
509                 cargs++;
510               }
511 #endif /* ASSERT */
512             }
513             else {
514               if (tos) {
515                 for (int i = 0; i &lt; last_num_jargs; i++) {
516                   // tos+0 is prepushed, ignore.
517                   tos++;
518                   if (tos &gt;= (intptr_t *)((address)current_fp + _z_ijava_state_neg(monitors)))
519                     break;
520                   st-&gt;cr();
521                   st-&gt;print(&quot;        &quot;);
522                   st-&gt;print(PTR_FORMAT &quot; %+.3e %+.3le&quot;, *(tos), *(float*)(tos), *(double*)(tos));
523                 }
524               }
525             }
526             last_num_jargs = method-&gt;size_of_parameters();
527           }
528         }
529         break;
530 
531       case 2: // entry frame:
532         {
533           st-&gt;print(&quot;v2i &quot;);
534 
535           // name
536           st-&gt;print(&quot;call stub&quot;);
537         }
538         break;
539 
540       case 3: // compiled frame:
541         {
542           st-&gt;print(&quot; c  &quot;);
543 
544           // name
545           Method* method = ((nmethod *)blob)-&gt;method();
546           if (method) {
547             ResourceMark rm;
548             method-&gt;name_and_sig_as_C_string(buf, sizeof(buf));
549             st-&gt;print(&quot;%s &quot;, buf);
550           }
551           else
552             st-&gt;print(&quot;? &quot;);
553         }
554         break;
555 
556       case 4: // named frames
557         {
558           st-&gt;print(&quot;%s &quot;, type_name);
559 
560           // name
561           if (function_name)
562             st-&gt;print(&quot;%s&quot;, function_name);
563         }
564         break;
565 
566       default:
567         break;
568     }
569 
570     st-&gt;cr();
571     st-&gt;flush();
572 
573     current_sp = current_fp;
574     last_frame_type = frame_type;
575     num++;
576     // Check for maximum # of frames, and stop when reached.
577     if (max_frames &gt; 0 &amp;&amp; --max_frames == 0)
578       break;
579   }
580 
581 }
582 
583 // Convenience function for calls from the debugger.
584 
585 extern &quot;C&quot; void bt(intptr_t* start_sp,intptr_t* top_pc) {
586   frame::back_trace(tty,start_sp, top_pc, 0);
587 }
588 
589 extern &quot;C&quot; void bt_full(intptr_t* start_sp,intptr_t* top_pc) {
590   frame::back_trace(tty,start_sp, top_pc, (unsigned long)(long)-1);
591 }
592 
593 
594 // Function for tracing a limited number of frames.
595 // Use this one if you only need to see the &quot;top of stack&quot; frames.
596 extern &quot;C&quot; void bt_max(intptr_t *start_sp, intptr_t *top_pc, int max_frames) {
597   frame::back_trace(tty, start_sp, top_pc, 0, max_frames);
598 }
599 
600 #if !defined(PRODUCT)
601 
602 #define DESCRIBE_ADDRESS(name) \
603   values.describe(frame_no, (intptr_t*)&amp;ijava_state()-&gt;name, #name);
604 
605 void frame::describe_pd(FrameValues&amp; values, int frame_no) {
606   if (is_interpreted_frame()) {
607     // Describe z_ijava_state elements.
608     DESCRIBE_ADDRESS(method);
609     DESCRIBE_ADDRESS(locals);
610     DESCRIBE_ADDRESS(monitors);
611     DESCRIBE_ADDRESS(cpoolCache);
612     DESCRIBE_ADDRESS(bcp);
613     DESCRIBE_ADDRESS(mdx);
614     DESCRIBE_ADDRESS(esp);
615     DESCRIBE_ADDRESS(sender_sp);
616     DESCRIBE_ADDRESS(top_frame_sp);
617     DESCRIBE_ADDRESS(oop_tmp);
618     DESCRIBE_ADDRESS(lresult);
619     DESCRIBE_ADDRESS(fresult);
620   }
621 }
622 
623 
624 void frame::pd_ps() {}
625 #endif // !PRODUCT
626 
627 intptr_t *frame::initial_deoptimization_info() {
628   // Used to reset the saved FP.
629   return fp();
630 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/assembler_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="abstractInterpreter_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_s390.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/assembler_s390.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">   3  * Copyright (c) 2016, 2017 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
 334   AddressLiteral(const bool* addr, relocInfo::relocType rtype = relocInfo::none)
 335     : _address((address) addr),
 336       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 337 
 338   AddressLiteral(signed char* addr, relocInfo::relocType rtype = relocInfo::none)
 339     : _address((address) addr),
 340       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 341 
 342   AddressLiteral(int* addr, relocInfo::relocType rtype = relocInfo::none)
 343     : _address((address) addr),
 344       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 345 
 346   AddressLiteral(intptr_t addr, relocInfo::relocType rtype = relocInfo::none)
 347     : _address((address) addr),
 348       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 349 
 350   AddressLiteral(intptr_t* addr, relocInfo::relocType rtype = relocInfo::none)
 351     : _address((address) addr),
 352       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 353 
<span class="line-removed"> 354   AddressLiteral(oop addr, relocInfo::relocType rtype = relocInfo::none)</span>
<span class="line-removed"> 355     : _address((address) addr),</span>
<span class="line-removed"> 356       _rspec(rspec_from_rtype(rtype, (address) addr)) {}</span>
<span class="line-removed"> 357 </span>
<span class="line-removed"> 358   AddressLiteral(oop* addr, relocInfo::relocType rtype = relocInfo::none)</span>
<span class="line-removed"> 359     : _address((address) addr),</span>
<span class="line-removed"> 360       _rspec(rspec_from_rtype(rtype, (address) addr)) {}</span>
<span class="line-removed"> 361 </span>
 362   AddressLiteral(float* addr, relocInfo::relocType rtype = relocInfo::none)
 363     : _address((address) addr),
 364       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 365 
 366   AddressLiteral(double* addr, relocInfo::relocType rtype = relocInfo::none)
 367     : _address((address) addr),
 368       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 369 
 370   intptr_t value() const { return (intptr_t) _address; }
 371 
 372   const relocInfo::relocType rtype() const { return _rspec.type(); }
 373   const RelocationHolder&amp;    rspec() const { return _rspec; }
 374 
 375   RelocationHolder rspec(int offset) const {
 376     return offset == 0 ? _rspec : _rspec.plus(offset);
 377   }
 378 };
 379 
 380 // Convenience classes
 381 class ExternalAddress: public AddressLiteral {
 382  private:
 383   static relocInfo::relocType reloc_for_target(address target) {
 384     // Sometimes ExternalAddress is used for values which aren&#39;t
 385     // exactly addresses, like the card table base.
 386     // External_word_type can&#39;t be used for values in the first page
 387     // so just skip the reloc in that case.
 388     return external_word_Relocation::can_be_relocated(target) ? relocInfo::external_word_type : relocInfo::none;
 389   }
 390 
 391  public:
 392   ExternalAddress(address target) : AddressLiteral(target, reloc_for_target(          target)) {}
<span class="line-removed"> 393   ExternalAddress(oop*    target) : AddressLiteral(target, reloc_for_target((address) target)) {}</span>
 394 };
 395 
 396 // Argument is an abstraction used to represent an outgoing actual
 397 // argument or an incoming formal parameter, whether it resides in
 398 // memory or in a register, in a manner consistent with the
 399 // z/Architecture Application Binary Interface, or ABI. This is often
 400 // referred to as the native or C calling convention.
 401 class Argument {
 402  private:
 403   int _number;
 404   bool _is_in;
 405 
 406  public:
 407   enum {
 408     // Only 5 registers may contain integer parameters.
 409     n_register_parameters = 5,
 410     // Can have up to 4 floating registers.
 411     n_float_register_parameters = 4
 412   };
 413 
</pre>
<hr />
<pre>
1514     VOPRC_CCSET    = 0b0001, // set the CC.
1515     VOPRC_CCIGN    = 0b0000, // ignore, don&#39;t set CC.
1516     VOPRC_ZS       = 0b0010, // Zero Search. Additional, elementwise, comparison against zero.
1517     VOPRC_NOZS     = 0b0000, // No Zero Search.
1518     VOPRC_RTBYTEIX = 0b0100, // generate byte index to lowest element with true comparison.
1519     VOPRC_RTBITVEC = 0b0000, // generate bit vector, all 1s for true, all 0s for false element comparisons.
1520     VOPRC_INVERT   = 0b1000, // invert comparison results.
1521     VOPRC_NOINVERT = 0b0000  // use comparison results as is, do not invert.
1522   };
1523 
1524   // Inverse condition code, i.e. determine &quot;15 - cc&quot; for a given condition code cc.
1525   static branch_condition inverse_condition(branch_condition cc);
1526   static branch_condition inverse_float_condition(branch_condition cc);
1527 
1528 
1529   //-----------------------------------------------
1530   // instruction property getter methods
1531   //-----------------------------------------------
1532 
1533   // Calculate length of instruction.
<span class="line-modified">1534   static int instr_len(unsigned char *instr);</span>
1535 
1536   // Longest instructions are 6 bytes on z/Architecture.
<span class="line-modified">1537   static int instr_maxlen() { return 6; }</span>
1538 
1539   // Average instruction is 4 bytes on z/Architecture (just a guess).
<span class="line-modified">1540   static int instr_avglen() { return 4; }</span>
1541 
1542   // Shortest instructions are 2 bytes on z/Architecture.
<span class="line-modified">1543   static int instr_minlen() { return 2; }</span>
1544 
1545   // Move instruction at pc right-justified into passed long int.
1546   // Return instr len in bytes as function result.
1547   static unsigned int get_instruction(unsigned char *pc, unsigned long *instr);
1548 
1549   // Move instruction in passed (long int) into storage at pc.
1550   // This code is _NOT_ MT-safe!!
1551   static void set_instruction(unsigned char *pc, unsigned long instr, unsigned int len) {
1552     memcpy(pc, ((unsigned char *)&amp;instr)+sizeof(unsigned long)-len, len);
1553   }
1554 
1555 
1556   //------------------------------------------
1557   // instruction field test methods
1558   //------------------------------------------
1559 
1560   // Only used once in s390.ad to implement Matcher::is_short_branch_offset().
1561   static bool is_within_range_of_RelAddr16(address target, address origin) {
1562     return RelAddr::is_in_range_of_RelAddr16(target, origin);
1563   }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">   3  * Copyright (c) 2016, 2019 SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
 334   AddressLiteral(const bool* addr, relocInfo::relocType rtype = relocInfo::none)
 335     : _address((address) addr),
 336       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 337 
 338   AddressLiteral(signed char* addr, relocInfo::relocType rtype = relocInfo::none)
 339     : _address((address) addr),
 340       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 341 
 342   AddressLiteral(int* addr, relocInfo::relocType rtype = relocInfo::none)
 343     : _address((address) addr),
 344       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 345 
 346   AddressLiteral(intptr_t addr, relocInfo::relocType rtype = relocInfo::none)
 347     : _address((address) addr),
 348       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 349 
 350   AddressLiteral(intptr_t* addr, relocInfo::relocType rtype = relocInfo::none)
 351     : _address((address) addr),
 352       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 353 








 354   AddressLiteral(float* addr, relocInfo::relocType rtype = relocInfo::none)
 355     : _address((address) addr),
 356       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 357 
 358   AddressLiteral(double* addr, relocInfo::relocType rtype = relocInfo::none)
 359     : _address((address) addr),
 360       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 361 
 362   intptr_t value() const { return (intptr_t) _address; }
 363 
 364   const relocInfo::relocType rtype() const { return _rspec.type(); }
 365   const RelocationHolder&amp;    rspec() const { return _rspec; }
 366 
 367   RelocationHolder rspec(int offset) const {
 368     return offset == 0 ? _rspec : _rspec.plus(offset);
 369   }
 370 };
 371 
 372 // Convenience classes
 373 class ExternalAddress: public AddressLiteral {
 374  private:
 375   static relocInfo::relocType reloc_for_target(address target) {
 376     // Sometimes ExternalAddress is used for values which aren&#39;t
 377     // exactly addresses, like the card table base.
 378     // External_word_type can&#39;t be used for values in the first page
 379     // so just skip the reloc in that case.
 380     return external_word_Relocation::can_be_relocated(target) ? relocInfo::external_word_type : relocInfo::none;
 381   }
 382 
 383  public:
 384   ExternalAddress(address target) : AddressLiteral(target, reloc_for_target(          target)) {}

 385 };
 386 
 387 // Argument is an abstraction used to represent an outgoing actual
 388 // argument or an incoming formal parameter, whether it resides in
 389 // memory or in a register, in a manner consistent with the
 390 // z/Architecture Application Binary Interface, or ABI. This is often
 391 // referred to as the native or C calling convention.
 392 class Argument {
 393  private:
 394   int _number;
 395   bool _is_in;
 396 
 397  public:
 398   enum {
 399     // Only 5 registers may contain integer parameters.
 400     n_register_parameters = 5,
 401     // Can have up to 4 floating registers.
 402     n_float_register_parameters = 4
 403   };
 404 
</pre>
<hr />
<pre>
1505     VOPRC_CCSET    = 0b0001, // set the CC.
1506     VOPRC_CCIGN    = 0b0000, // ignore, don&#39;t set CC.
1507     VOPRC_ZS       = 0b0010, // Zero Search. Additional, elementwise, comparison against zero.
1508     VOPRC_NOZS     = 0b0000, // No Zero Search.
1509     VOPRC_RTBYTEIX = 0b0100, // generate byte index to lowest element with true comparison.
1510     VOPRC_RTBITVEC = 0b0000, // generate bit vector, all 1s for true, all 0s for false element comparisons.
1511     VOPRC_INVERT   = 0b1000, // invert comparison results.
1512     VOPRC_NOINVERT = 0b0000  // use comparison results as is, do not invert.
1513   };
1514 
1515   // Inverse condition code, i.e. determine &quot;15 - cc&quot; for a given condition code cc.
1516   static branch_condition inverse_condition(branch_condition cc);
1517   static branch_condition inverse_float_condition(branch_condition cc);
1518 
1519 
1520   //-----------------------------------------------
1521   // instruction property getter methods
1522   //-----------------------------------------------
1523 
1524   // Calculate length of instruction.
<span class="line-modified">1525   static unsigned int instr_len(unsigned char *instr);</span>
1526 
1527   // Longest instructions are 6 bytes on z/Architecture.
<span class="line-modified">1528   static unsigned int instr_maxlen() { return 6; }</span>
1529 
1530   // Average instruction is 4 bytes on z/Architecture (just a guess).
<span class="line-modified">1531   static unsigned int instr_avglen() { return 4; }</span>
1532 
1533   // Shortest instructions are 2 bytes on z/Architecture.
<span class="line-modified">1534   static unsigned int instr_minlen() { return 2; }</span>
1535 
1536   // Move instruction at pc right-justified into passed long int.
1537   // Return instr len in bytes as function result.
1538   static unsigned int get_instruction(unsigned char *pc, unsigned long *instr);
1539 
1540   // Move instruction in passed (long int) into storage at pc.
1541   // This code is _NOT_ MT-safe!!
1542   static void set_instruction(unsigned char *pc, unsigned long instr, unsigned int len) {
1543     memcpy(pc, ((unsigned char *)&amp;instr)+sizeof(unsigned long)-len, len);
1544   }
1545 
1546 
1547   //------------------------------------------
1548   // instruction field test methods
1549   //------------------------------------------
1550 
1551   // Only used once in s390.ad to implement Matcher::is_short_branch_offset().
1552   static bool is_within_range_of_RelAddr16(address target, address origin) {
1553     return RelAddr::is_in_range_of_RelAddr16(target, origin);
1554   }
</pre>
</td>
</tr>
</table>
<center><a href="abstractInterpreter_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_s390.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
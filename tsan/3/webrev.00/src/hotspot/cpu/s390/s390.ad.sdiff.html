<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/s390.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="relocInfo_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/s390.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">    3 // Copyright (c) 2017, SAP SE. All rights reserved.</span>
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
</pre>
<hr />
<pre>
  457 // Longs in 1 register. Aligned adjacent hi/lo pairs.
  458 reg_class z_long_reg(
  459 /*Z_R0_H,Z_R0*/     // R0
  460 /*Z_R1_H,Z_R1*/
  461   Z_R2_H,Z_R2,
  462   Z_R3_H,Z_R3,
  463   Z_R4_H,Z_R4,
  464   Z_R5_H,Z_R5,
  465   Z_R6_H,Z_R6,
  466   Z_R7_H,Z_R7,
  467 /*Z_R8_H,Z_R8,*/    // Z_thread
  468   Z_R9_H,Z_R9,
  469   Z_R10_H,Z_R10,
  470   Z_R11_H,Z_R11,
  471   Z_R12_H,Z_R12,
  472   Z_R13_H,Z_R13
  473 /*Z_R14_H,Z_R14,*/  // return_pc
  474 /*Z_R15_H,Z_R15*/   // SP
  475 );
  476 













  477 
  478 // Special Class for Condition Code Flags Register
  479 
  480 reg_class z_condition_reg(
  481   Z_CR
  482 );
  483 
  484 // Scratch register for late profiling. Callee saved.
  485 reg_class z_rscratch2_bits64_reg(Z_R2_H, Z_R2);
  486 
  487 
  488 // Float Register Classes
  489 
  490 reg_class z_flt_reg(
  491   Z_F0,
  492 /*Z_F1,*/ // scratch
  493   Z_F2,
  494   Z_F3,
  495   Z_F4,
  496   Z_F5,
</pre>
<hr />
<pre>
  837   // account for that. See bugs 4446381, 4468289, 4497237.
  838   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  839     st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
  840   }
  841   st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
  842   st-&gt;print(&quot;\t&quot;);
  843 }
  844 #endif
  845 
  846 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  847   Compile* C = ra_-&gt;C;
  848   MacroAssembler _masm(&amp;cbuf);
  849 
  850   __ verify_thread();
  851 
  852   size_t framesize = C-&gt;frame_size_in_bytes();
  853   size_t bangsize  = C-&gt;bang_size_in_bytes();
  854 
  855   assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  856 

















  857   // Calls to C2R adapters often do not accept exceptional returns.
  858   // We require that their callers must bang for them. But be
  859   // careful, because some VM calls (such as call site linkage) can
  860   // use several kilobytes of stack. But the stack safety zone should
  861   // account for that. See bugs 4446381, 4468289, 4497237.
  862   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  863     __ generate_stack_overflow_check(bangsize);
  864   }
  865 
  866   assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
  867   __ save_return_pc();
  868 
  869   // The z/Architecture abi is already accounted for in `framesize&#39; via the
  870   // &#39;out_preserve_stack_slots&#39; declaration.
  871   __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  872 
  873   if (C-&gt;has_mach_constant_base_node()) {
  874     // NOTE: We set the table base offset here because users might be
  875     // emitted before MachConstantBaseNode.
  876     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
</pre>
<hr />
<pre>
 1358     // The ic_miss_stub will handle the null pointer exception.
 1359     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1360     __ z_br(R1_ic_miss_stub_addr);
 1361     __ bind(valid);
 1362   }
 1363 
 1364   // Check whether this method is the proper implementation for the class of
 1365   // the receiver (ic miss check).
 1366   {
 1367     Label valid;
 1368     // Compare cached class against klass from receiver.
 1369     // This also does an implicit null check!
 1370     __ compare_klass_ptr(ic_klass, klass_offset, R2_receiver, false);
 1371     __ z_bre(valid);
 1372     // The inline cache points to the wrong method. Call the
 1373     // ic_miss_stub to find the proper method.
 1374     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1375     __ z_br(R1_ic_miss_stub_addr);
 1376     __ bind(valid);
 1377   }
<span class="line-removed"> 1378 </span>
 1379 }
 1380 
 1381 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1382   // Determine size dynamically.
 1383   return MachNode::size(ra_);
 1384 }
 1385 
 1386 //=============================================================================
 1387 
 1388 %} // interrupt source section
 1389 
 1390 source_hpp %{ // Header information of the source block.
 1391 
 1392 class HandlerImpl {
 1393  public:
 1394 
 1395   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 1396   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 1397 
 1398   static uint size_exception_handler() {
</pre>
<hr />
<pre>
 1505 
 1506     case Op_GetAndAddI:
 1507     case Op_GetAndAddL:
 1508       return true;
 1509       // return VM_Version::has_AtomicMemWithImmALUOps();
 1510     case Op_GetAndSetI:
 1511     case Op_GetAndSetL:
 1512     case Op_GetAndSetP:
 1513     case Op_GetAndSetN:
 1514       return true;  // General CAS implementation, always available.
 1515 
 1516     default:
 1517       return true;  // Per default match rules are supported.
 1518                     // BUT: make sure match rule is not disabled by a false predicate!
 1519   }
 1520 
 1521   return true;  // Per default match rules are supported.
 1522                 // BUT: make sure match rule is not disabled by a false predicate!
 1523 }
 1524 
<span class="line-modified"> 1525 const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {</span>
 1526   // TODO
 1527   // Identify extra cases that we might want to provide match rules for
 1528   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen.
 1529   bool ret_value = match_rule_supported(opcode);
 1530   // Add rules here.
 1531 
 1532   return ret_value;  // Per default match rules are supported.
 1533 }
 1534 
 1535 int Matcher::regnum_to_fpu_offset(int regnum) {
 1536   ShouldNotReachHere();
 1537   return regnum - 32; // The FP registers are in the second chunk.
 1538 }
 1539 
 1540 const bool Matcher::has_predicated_vectors(void) {
 1541   return false;
 1542 }
 1543 
 1544 const int Matcher::float_pressure(int default_pressure_threshold) {
 1545   return default_pressure_threshold;
</pre>
<hr />
<pre>
 1612 }
 1613 
 1614 // Should correspond to setting above
 1615 const bool Matcher::init_array_count_is_in_bytes = false;
 1616 
 1617 // Suppress CMOVL. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1618 const int Matcher::long_cmove_cost() { return ConditionalMoveLimit; }
 1619 
 1620 // Suppress CMOVF. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1621 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1622 
 1623 // Does the CPU require postalloc expand (see block.cpp for description of postalloc expand)?
 1624 const bool Matcher::require_postalloc_expand = false;
 1625 
 1626 // Do we need to mask the count passed to shift instructions or does
 1627 // the cpu only look at the lower 5/6 bits anyway?
 1628 // 32bit shifts mask in emitter, 64bit shifts need no mask.
 1629 // Constant shift counts are handled in Ideal phase.
 1630 const bool Matcher::need_masked_shift_count = false;
 1631 


















 1632 // Set this as clone_shift_expressions.
 1633 bool Matcher::narrow_oop_use_complex_address() {
<span class="line-modified"> 1634   if (Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0) return true;</span>
 1635   return false;
 1636 }
 1637 
 1638 bool Matcher::narrow_klass_use_complex_address() {
 1639   NOT_LP64(ShouldNotCallThis());
 1640   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1641   // TODO HS25: z port if (MatchDecodeNodes) return true;
 1642   return false;
 1643 }
 1644 
 1645 bool Matcher::const_oop_prefer_decode() {
 1646   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
<span class="line-modified"> 1647   return Universe::narrow_oop_base() == NULL;</span>
 1648 }
 1649 
 1650 bool Matcher::const_klass_prefer_decode() {
 1651   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified"> 1652   return Universe::narrow_klass_base() == NULL;</span>
 1653 }
 1654 
 1655 // Is it better to copy float constants, or load them directly from memory?
 1656 // Most RISCs will have to materialize an address into a
 1657 // register first, so they would do better to copy the constant from stack.
 1658 const bool Matcher::rematerialize_float_constants = false;
 1659 
 1660 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1661 // needed. Else we split the double into 2 integer pieces and move it
 1662 // piece-by-piece. Only happens when passing doubles into C code as the
 1663 // Java calling convention forces doubles to be aligned.
 1664 const bool Matcher::misaligned_doubles_ok = true;
 1665 
<span class="line-modified"> 1666 // Advertise here if the CPU requires explicit rounding operations</span>
<span class="line-removed"> 1667 // to implement the UseStrictFP mode.</span>
 1668 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1669 
 1670 // Do floats take an entire double register or just half?
 1671 //
 1672 // A float in resides in a zarch double register. When storing it by
 1673 // z_std, it cannot be restored in C-code by reloading it as a double
 1674 // and casting it into a float afterwards.
 1675 bool Matcher::float_in_double() { return false; }
 1676 
 1677 // Do ints take an entire long register or just half?
 1678 // The relevant question is how the int is callee-saved:
 1679 // the whole long is written but de-opt&#39;ing will have to extract
 1680 // the relevant 32 bits.
 1681 const bool Matcher::int_in_long = true;
 1682 
 1683 // Constants for c2c and c calling conventions.
 1684 
 1685 const MachRegisterNumbers z_iarg_reg[5] = {
 1686   Z_R2_num, Z_R3_num, Z_R4_num, Z_R5_num, Z_R6_num
 1687 };
</pre>
<hr />
<pre>
 3361 operand rarg4RegN() %{
 3362   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3363   match(iRegN);
 3364   format %{ %}
 3365   interface(REG_INTER);
 3366 %}
 3367 
 3368 operand rarg5RegN() %{
 3369   constraint(ALLOC_IN_RC(z_rarg5_ptrN_reg));
 3370   match(iRegN);
 3371   format %{ %}
 3372   interface(REG_INTER);
 3373 %}
 3374 
 3375 // Long Register
 3376 operand iRegL() %{
 3377   constraint(ALLOC_IN_RC(z_long_reg));
 3378   match(RegL);
 3379   match(revenRegL);
 3380   match(roddRegL);

 3381   match(rarg1RegL);
 3382   match(rarg5RegL);
 3383   format %{ %}
 3384   interface(REG_INTER);
 3385 %}
 3386 
 3387 // revenRegL and roddRegL constitute and even-odd-pair.
 3388 operand revenRegL() %{
 3389   constraint(ALLOC_IN_RC(z_rarg3_long_reg));
 3390   match(iRegL);
 3391   format %{ %}
 3392   interface(REG_INTER);
 3393 %}
 3394 
 3395 // revenRegL and roddRegL constitute and even-odd-pair.
 3396 operand roddRegL() %{
 3397   constraint(ALLOC_IN_RC(z_rarg4_long_reg));
 3398   match(iRegL);
 3399   format %{ %}
 3400   interface(REG_INTER);
 3401 %}
 3402 








 3403 operand rarg1RegL() %{
 3404   constraint(ALLOC_IN_RC(z_rarg1_long_reg));
 3405   match(iRegL);
 3406   format %{ %}
 3407   interface(REG_INTER);
 3408 %}
 3409 
 3410 operand rarg5RegL() %{
 3411   constraint(ALLOC_IN_RC(z_rarg5_long_reg));
 3412   match(iRegL);
 3413   format %{ %}
 3414   interface(REG_INTER);
 3415 %}
 3416 
 3417 // Condition Code Flag Registers
 3418 operand flagsReg() %{
 3419   constraint(ALLOC_IN_RC(z_condition_reg));
 3420   match(RegFlags);
 3421   format %{ &quot;CR&quot; %}
 3422   interface(REG_INTER);
</pre>
<hr />
<pre>
 3468   interface(REG_INTER);
 3469 %}
 3470 
 3471 operand compiler_method_oop_regP(iRegP reg) %{
 3472   constraint(ALLOC_IN_RC(z_r1_RegP)); // compiler_method_oop_reg
 3473   match(reg);
 3474   format %{ %}
 3475   interface(REG_INTER);
 3476 %}
 3477 
 3478 operand interpreter_method_oop_regP(iRegP reg) %{
 3479   constraint(ALLOC_IN_RC(z_r9_regP)); // interpreter_method_oop_reg
 3480   match(reg);
 3481   format %{ %}
 3482   interface(REG_INTER);
 3483 %}
 3484 
 3485 // Operands to remove register moves in unscaled mode.
 3486 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 3487 operand iRegP2N(iRegP reg) %{
<span class="line-modified"> 3488   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; _leaf-&gt;as_EncodeP()-&gt;in(0) == NULL);</span>
 3489   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3490   match(EncodeP reg);
 3491   format %{ &quot;$reg&quot; %}
 3492   interface(REG_INTER)
 3493 %}
 3494 
 3495 operand iRegN2P(iRegN reg) %{
<span class="line-modified"> 3496   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0 &amp;&amp;</span>
 3497             _leaf-&gt;as_DecodeN()-&gt;in(0) == NULL);
 3498   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3499   match(DecodeN reg);
 3500   format %{ &quot;$reg&quot; %}
 3501   interface(REG_INTER)
 3502 %}
 3503 
 3504 
 3505 //----------Complex Operands---------------------------------------------------
 3506 
 3507 // Indirect Memory Reference
 3508 operand indirect(memoryRegP base) %{
 3509   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3510   match(base);
 3511   op_cost(1);
 3512   format %{ &quot;#0[,$base]&quot; %}
 3513   interface(MEMORY_INTER) %{
 3514     base($base);
 3515     index(0xffffFFFF); // noreg
 3516     scale(0x0);
</pre>
<hr />
<pre>
 4279 // Load Double - UNaligned
 4280 instruct loadD_unaligned(regD dst, memory mem) %{
 4281   match(Set dst (LoadD_unaligned mem));
 4282   ins_cost(MEMORY_REF_COST);
 4283   size(Z_DISP_SIZE);
 4284   format %{ &quot;LD(Y)    $dst,$mem&quot; %}
 4285   opcode(LDY_ZOPC, LD_ZOPC);
 4286   ins_encode(z_form_rt_mem_opt(dst, mem));
 4287   ins_pipe(pipe_class_dummy);
 4288 %}
 4289 
 4290 
 4291 //----------------------
 4292 //  IMMEDIATES
 4293 //----------------------
 4294 
 4295 instruct loadConI(iRegI dst, immI src) %{
 4296   match(Set dst src);
 4297   ins_cost(DEFAULT_COST);
 4298   size(6);
<span class="line-modified"> 4299   format %{ &quot;LGFI     $dst,$src\t # (int)&quot; %}</span>
 4300   ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4301   ins_pipe(pipe_class_dummy);
 4302 %}
 4303 
 4304 instruct loadConI16(iRegI dst, immI16 src) %{
 4305   match(Set dst src);
 4306   ins_cost(DEFAULT_COST_LOW);
 4307   size(4);
<span class="line-modified"> 4308   format %{ &quot;LGHI     $dst,$src\t # (int)&quot; %}</span>
 4309   ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4310   ins_pipe(pipe_class_dummy);
 4311 %}
 4312 
 4313 instruct loadConI_0(iRegI dst, immI_0 src, flagsReg cr) %{
 4314   match(Set dst src);
 4315   effect(KILL cr);
 4316   ins_cost(DEFAULT_COST_LOW);
 4317   size(4);
 4318   format %{ &quot;loadConI $dst,$src\t # (int) XGR because ZERO is loaded&quot; %}
 4319   opcode(XGR_ZOPC);
 4320   ins_encode(z_rreform(dst, dst));
 4321   ins_pipe(pipe_class_dummy);
 4322 %}
 4323 
 4324 instruct loadConUI16(iRegI dst, uimmI16 src) %{
 4325   match(Set dst src);
 4326   // TODO: s390 port size(FIXED_SIZE);
 4327   format %{ &quot;LLILL    $dst,$src&quot; %}
 4328   opcode(LLILL_ZOPC);
</pre>
<hr />
<pre>
 4684 // See cOop encoding classes for elaborate comment.
 4685 
 4686 // Moved here because it is needed in expand rules for encode.
 4687 // Long negation.
 4688 instruct negL_reg_reg(iRegL dst, immL_0 zero, iRegL src, flagsReg cr) %{
 4689   match(Set dst (SubL zero src));
 4690   effect(KILL cr);
 4691   size(4);
 4692   format %{ &quot;NEG     $dst, $src\t # long&quot; %}
 4693   ins_encode %{ __ z_lcgr($dst$$Register, $src$$Register); %}
 4694   ins_pipe(pipe_class_dummy);
 4695 %}
 4696 
 4697 // Load Compressed Pointer
 4698 
 4699 // Load narrow oop
 4700 instruct loadN(iRegN dst, memory mem) %{
 4701   match(Set dst (LoadN mem));
 4702   ins_cost(MEMORY_REF_COST);
 4703   size(Z_DISP3_SIZE);
<span class="line-modified"> 4704   format %{ &quot;LoadN  $dst,$mem\t# (cOop)&quot; %}</span>
 4705   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4706   ins_encode(z_form_rt_mem_opt(dst, mem));
 4707   ins_pipe(pipe_class_dummy);
 4708 %}
 4709 
 4710 // Load narrow Klass Pointer
 4711 instruct loadNKlass(iRegN dst, memory mem) %{
 4712   match(Set dst (LoadNKlass mem));
 4713   ins_cost(MEMORY_REF_COST);
 4714   size(Z_DISP3_SIZE);
<span class="line-modified"> 4715   format %{ &quot;LoadNKlass $dst,$mem\t# (klass cOop)&quot; %}</span>
 4716   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4717   ins_encode(z_form_rt_mem_opt(dst, mem));
 4718   ins_pipe(pipe_class_dummy);
 4719 %}
 4720 
 4721 // Load constant Compressed Pointer
 4722 
 4723 instruct loadConN(iRegN dst, immN src) %{
 4724   match(Set dst src);
 4725   ins_cost(DEFAULT_COST);
 4726   size(6);
 4727   format %{ &quot;loadConN    $dst,$src\t # (cOop)&quot; %}
 4728   ins_encode %{
 4729     AddressLiteral cOop = __ constant_oop_address((jobject)$src$$constant);
 4730     __ relocate(cOop.rspec(), 1);
 4731     __ load_narrow_oop($dst$$Register, (narrowOop)cOop.value());
 4732   %}
 4733   ins_pipe(pipe_class_dummy);
 4734 %}
 4735 
</pre>
<hr />
<pre>
 4745 %}
 4746 
 4747 instruct loadConNKlass(iRegN dst, immNKlass src) %{
 4748   match(Set dst src);
 4749   ins_cost(DEFAULT_COST);
 4750   size(6);
 4751   format %{ &quot;loadConNKlass $dst,$src\t # (cKlass)&quot; %}
 4752   ins_encode %{
 4753     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4754     __ relocate(NKlass.rspec(), 1);
 4755     __ load_narrow_klass($dst$$Register, (Klass*)NKlass.value());
 4756   %}
 4757   ins_pipe(pipe_class_dummy);
 4758 %}
 4759 
 4760 // Load and Decode Compressed Pointer
 4761 // optimized variants for Unscaled cOops
 4762 
 4763 instruct decodeLoadN(iRegP dst, memory mem) %{
 4764   match(Set dst (DecodeN (LoadN mem)));
<span class="line-modified"> 4765   predicate(false &amp;&amp; (Universe::narrow_oop_base()==NULL)&amp;&amp;(Universe::narrow_oop_shift()==0));</span>
 4766   ins_cost(MEMORY_REF_COST);
 4767   size(Z_DISP3_SIZE);
<span class="line-modified"> 4768   format %{ &quot;DecodeLoadN  $dst,$mem\t# (cOop Load+Decode)&quot; %}</span>
 4769   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4770   ins_encode(z_form_rt_mem_opt(dst, mem));
 4771   ins_pipe(pipe_class_dummy);
 4772 %}
 4773 
 4774 instruct decodeLoadNKlass(iRegP dst, memory mem) %{
 4775   match(Set dst (DecodeNKlass (LoadNKlass mem)));
<span class="line-modified"> 4776   predicate(false &amp;&amp; (Universe::narrow_klass_base()==NULL)&amp;&amp;(Universe::narrow_klass_shift()==0));</span>
 4777   ins_cost(MEMORY_REF_COST);
 4778   size(Z_DISP3_SIZE);
<span class="line-modified"> 4779   format %{ &quot;DecodeLoadNKlass  $dst,$mem\t# (load/decode NKlass)&quot; %}</span>
 4780   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4781   ins_encode(z_form_rt_mem_opt(dst, mem));
 4782   ins_pipe(pipe_class_dummy);
 4783 %}
 4784 
 4785 instruct decodeLoadConNKlass(iRegP dst, immNKlass src) %{
 4786   match(Set dst (DecodeNKlass src));
 4787   ins_cost(3 * DEFAULT_COST);
 4788   size(12);
 4789   format %{ &quot;DecodeLoadConNKlass  $dst,$src\t # decode(cKlass)&quot; %}
 4790   ins_encode %{
 4791     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4792     __ relocate(NKlass.rspec(), 1);
 4793     __ load_const($dst$$Register, (Klass*)NKlass.value());
 4794   %}
 4795   ins_pipe(pipe_class_dummy);
 4796 %}
 4797 
 4798 // Decode Compressed Pointer
 4799 
 4800 // General decoder
 4801 instruct decodeN(iRegP dst, iRegN src, flagsReg cr) %{
 4802   match(Set dst (DecodeN src));
 4803   effect(KILL cr);
<span class="line-modified"> 4804   predicate(Universe::narrow_oop_base() == NULL || !ExpandLoadingBaseDecode);</span>
 4805   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4806   // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4807   format %{ &quot;decodeN  $dst,$src\t# (decode cOop)&quot; %}</span>
 4808   ins_encode %{  __ oop_decoder($dst$$Register, $src$$Register, true); %}
 4809   ins_pipe(pipe_class_dummy);
 4810 %}
 4811 
 4812 // General Klass decoder
 4813 instruct decodeKlass(iRegP dst, iRegN src, flagsReg cr) %{
 4814   match(Set dst (DecodeNKlass src));
 4815   effect(KILL cr);
 4816   ins_cost(3 * DEFAULT_COST);
 4817   format %{ &quot;decode_klass $dst,$src&quot; %}
 4818   ins_encode %{ __ decode_klass_not_null($dst$$Register, $src$$Register); %}
 4819   ins_pipe(pipe_class_dummy);
 4820 %}
 4821 
 4822 // General decoder
 4823 instruct decodeN_NN(iRegP dst, iRegN src, flagsReg cr) %{
 4824   match(Set dst (DecodeN src));
 4825   effect(KILL cr);
 4826   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4827              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified"> 4828             (Universe::narrow_oop_base()== NULL || !ExpandLoadingBaseDecode_NN));</span>
 4829   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4830   // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4831   format %{ &quot;decodeN  $dst,$src\t# (decode cOop NN)&quot; %}</span>
 4832   ins_encode %{ __ oop_decoder($dst$$Register, $src$$Register, false); %}
 4833   ins_pipe(pipe_class_dummy);
 4834 %}
 4835 
 4836   instruct loadBase(iRegL dst, immL baseImm) %{
 4837     effect(DEF dst, USE baseImm);
 4838     predicate(false);
 4839     format %{ &quot;llihl    $dst=$baseImm \t// load heap base&quot; %}
 4840     ins_encode %{ __ get_oop_base($dst$$Register, $baseImm$$constant); %}
 4841     ins_pipe(pipe_class_dummy);
 4842   %}
 4843 
 4844   // Decoder for heapbased mode peeling off loading the base.
 4845   instruct decodeN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4846     match(Set dst (DecodeN src base));
 4847     // Note: Effect TEMP dst was used with the intention to get
 4848     // different regs for dst and base, but this has caused ADLC to
 4849     // generate wrong code. Oop_decoder generates additional lgr when
 4850     // dst==base.
 4851     effect(KILL cr);
 4852     predicate(false);
 4853     // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4854     format %{ &quot;decodeN  $dst = ($src == 0) ? NULL : ($src &lt;&lt; 3) + $base + pow2_offset\t# (decode cOop)&quot; %}</span>
 4855     ins_encode %{
 4856       __ oop_decoder($dst$$Register, $src$$Register, true, $base$$Register,
<span class="line-modified"> 4857                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)Universe::narrow_oop_base()));</span>
 4858     %}
 4859     ins_pipe(pipe_class_dummy);
 4860   %}
 4861 
 4862   // Decoder for heapbased mode peeling off loading the base.
 4863   instruct decodeN_NN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4864     match(Set dst (DecodeN src base));
 4865     effect(KILL cr);
 4866     predicate(false);
 4867     // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4868     format %{ &quot;decodeN  $dst = ($src &lt;&lt; 3) + $base + pow2_offset\t# (decode cOop)&quot; %}</span>
 4869     ins_encode %{
 4870       __ oop_decoder($dst$$Register, $src$$Register, false, $base$$Register,
<span class="line-modified"> 4871                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)Universe::narrow_oop_base()));</span>
 4872     %}
 4873     ins_pipe(pipe_class_dummy);
 4874   %}
 4875 
 4876 // Decoder for heapbased mode peeling off loading the base.
 4877 instruct decodeN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4878   match(Set dst (DecodeN src));
<span class="line-modified"> 4879   predicate(Universe::narrow_oop_base() != NULL &amp;&amp; ExpandLoadingBaseDecode);</span>
 4880   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4881   // TODO: s390 port size(VARIABLE_SIZE);
 4882   expand %{
<span class="line-modified"> 4883     immL baseImm %{ (jlong)(intptr_t)Universe::narrow_oop_base() %}</span>
 4884     iRegL base;
 4885     loadBase(base, baseImm);
 4886     decodeN_base(dst, src, base, cr);
 4887   %}
 4888 %}
 4889 
 4890 // Decoder for heapbased mode peeling off loading the base.
 4891 instruct decodeN_NN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4892   match(Set dst (DecodeN src));
 4893   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4894              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified"> 4895             Universe::narrow_oop_base() != NULL &amp;&amp; ExpandLoadingBaseDecode_NN);</span>
 4896   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4897   // TODO: s390 port size(VARIABLE_SIZE);
 4898   expand %{
<span class="line-modified"> 4899     immL baseImm %{ (jlong)(intptr_t)Universe::narrow_oop_base() %}</span>
 4900     iRegL base;
 4901     loadBase(base, baseImm);
 4902     decodeN_NN_base(dst, src, base, cr);
 4903   %}
 4904 %}
 4905 
 4906 //  Encode Compressed Pointer
 4907 
 4908 // General encoder
 4909 instruct encodeP(iRegN dst, iRegP src, flagsReg cr) %{
 4910   match(Set dst (EncodeP src));
 4911   effect(KILL cr);
 4912   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
<span class="line-modified"> 4913             (Universe::narrow_oop_base() == 0 ||</span>
<span class="line-modified"> 4914              Universe::narrow_oop_base_disjoint() ||</span>
 4915              !ExpandLoadingBaseEncode));
 4916   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4917   // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4918   format %{ &quot;encodeP  $dst,$src\t# (encode cOop)&quot; %}</span>
 4919   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, true, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 4920   ins_pipe(pipe_class_dummy);
 4921 %}
 4922 
 4923 // General class encoder
 4924 instruct encodeKlass(iRegN dst, iRegP src, flagsReg cr) %{
 4925   match(Set dst (EncodePKlass src));
 4926   effect(KILL cr);
 4927   format %{ &quot;encode_klass $dst,$src&quot; %}
 4928   ins_encode %{ __ encode_klass_not_null($dst$$Register, $src$$Register); %}
 4929   ins_pipe(pipe_class_dummy);
 4930 %}
 4931 
 4932 instruct encodeP_NN(iRegN dst, iRegP src, flagsReg cr) %{
 4933   match(Set dst (EncodeP src));
 4934   effect(KILL cr);
 4935   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
<span class="line-modified"> 4936             (Universe::narrow_oop_base() == 0 ||</span>
<span class="line-modified"> 4937              Universe::narrow_oop_base_disjoint() ||</span>
 4938              !ExpandLoadingBaseEncode_NN));
 4939   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4940   // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4941   format %{ &quot;encodeP  $dst,$src\t# (encode cOop)&quot; %}</span>
 4942   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 4943   ins_pipe(pipe_class_dummy);
 4944 %}
 4945 
 4946   // Encoder for heapbased mode peeling off loading the base.
 4947   instruct encodeP_base(iRegN dst, iRegP src, iRegL base) %{
 4948     match(Set dst (EncodeP src (Binary base dst)));
 4949     effect(TEMP_DEF dst);
 4950     predicate(false);
 4951     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4952     // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4953     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + pow2_offset\t# (encode cOop)&quot; %}</span>
 4954     ins_encode %{
 4955       jlong offset = -(jlong)MacroAssembler::get_oop_base_pow2_offset
<span class="line-modified"> 4956         (((uint64_t)(intptr_t)Universe::narrow_oop_base()) &gt;&gt; Universe::narrow_oop_shift());</span>
 4957       __ oop_encoder($dst$$Register, $src$$Register, true, $base$$Register, offset);
 4958     %}
 4959     ins_pipe(pipe_class_dummy);
 4960   %}
 4961 
 4962   // Encoder for heapbased mode peeling off loading the base.
 4963   instruct encodeP_NN_base(iRegN dst, iRegP src, iRegL base, immL pow2_offset) %{
 4964     match(Set dst (EncodeP src base));
 4965     effect(USE pow2_offset);
 4966     predicate(false);
 4967     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4968     // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4969     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + $pow2_offset\t# (encode cOop)&quot; %}</span>
 4970     ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, $base$$Register, $pow2_offset$$constant); %}
 4971     ins_pipe(pipe_class_dummy);
 4972   %}
 4973 
 4974 // Encoder for heapbased mode peeling off loading the base.
 4975 instruct encodeP_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 4976   match(Set dst (EncodeP src));
 4977   effect(KILL cr);
 4978   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
<span class="line-modified"> 4979             (Universe::narrow_oop_base_overlaps() &amp;&amp; ExpandLoadingBaseEncode));</span>
 4980   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4981   // TODO: s390 port size(VARIABLE_SIZE);
 4982   expand %{
<span class="line-modified"> 4983     immL baseImm %{ ((jlong)(intptr_t)Universe::narrow_oop_base()) &gt;&gt; Universe::narrow_oop_shift() %}</span>
 4984     immL_0 zero %{ (0) %}
 4985     flagsReg ccr;
 4986     iRegL base;
 4987     iRegL negBase;
 4988     loadBase(base, baseImm);
 4989     negL_reg_reg(negBase, zero, base, ccr);
 4990     encodeP_base(dst, src, negBase);
 4991   %}
 4992 %}
 4993 
 4994 // Encoder for heapbased mode peeling off loading the base.
 4995 instruct encodeP_NN_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 4996   match(Set dst (EncodeP src));
 4997   effect(KILL cr);
 4998   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
<span class="line-modified"> 4999             (Universe::narrow_oop_base_overlaps() &amp;&amp; ExpandLoadingBaseEncode_NN));</span>
 5000   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5001   // TODO: s390 port size(VARIABLE_SIZE);
 5002   expand %{
<span class="line-modified"> 5003     immL baseImm %{ (jlong)(intptr_t)Universe::narrow_oop_base() %}</span>
<span class="line-modified"> 5004     immL pow2_offset %{ -(jlong)MacroAssembler::get_oop_base_pow2_offset(((uint64_t)(intptr_t)Universe::narrow_oop_base())) %}</span>
 5005     immL_0 zero %{ 0 %}
 5006     flagsReg ccr;
 5007     iRegL base;
 5008     iRegL negBase;
 5009     loadBase(base, baseImm);
 5010     negL_reg_reg(negBase, zero, base, ccr);
 5011     encodeP_NN_base(dst, src, negBase, pow2_offset);
 5012   %}
 5013 %}
 5014 
 5015 //  Store Compressed Pointer
 5016 
 5017 // Store Compressed Pointer
 5018 instruct storeN(memory mem, iRegN_P2N src) %{
 5019   match(Set mem (StoreN mem src));
 5020   ins_cost(MEMORY_REF_COST);
 5021   size(Z_DISP_SIZE);
<span class="line-modified"> 5022   format %{ &quot;ST      $src,$mem\t# (cOop)&quot; %}</span>
 5023   opcode(STY_ZOPC, ST_ZOPC);
 5024   ins_encode(z_form_rt_mem_opt(src, mem));
 5025   ins_pipe(pipe_class_dummy);
 5026 %}
 5027 
 5028 // Store Compressed Klass pointer
 5029 instruct storeNKlass(memory mem, iRegN src) %{
 5030   match(Set mem (StoreNKlass mem src));
 5031   ins_cost(MEMORY_REF_COST);
 5032   size(Z_DISP_SIZE);
<span class="line-modified"> 5033   format %{ &quot;ST      $src,$mem\t# (cKlass)&quot; %}</span>
 5034   opcode(STY_ZOPC, ST_ZOPC);
 5035   ins_encode(z_form_rt_mem_opt(src, mem));
 5036   ins_pipe(pipe_class_dummy);
 5037 %}
 5038 
 5039 // Compare Compressed Pointers
 5040 
 5041 instruct compN_iRegN(iRegN_P2N src1, iRegN_P2N src2, flagsReg cr) %{
 5042   match(Set cr (CmpN src1 src2));
 5043   ins_cost(DEFAULT_COST);
 5044   size(2);
<span class="line-modified"> 5045   format %{ &quot;CLR     $src1,$src2\t# (cOop)&quot; %}</span>
 5046   opcode(CLR_ZOPC);
 5047   ins_encode(z_rrform(src1, src2));
 5048   ins_pipe(pipe_class_dummy);
 5049 %}
 5050 
 5051 instruct compN_iRegN_immN(iRegN_P2N src1, immN src2, flagsReg cr) %{
 5052   match(Set cr (CmpN src1 src2));
 5053   ins_cost(DEFAULT_COST);
 5054   size(6);
<span class="line-modified"> 5055   format %{ &quot;CLFI    $src1,$src2\t# (cOop) compare immediate narrow&quot; %}</span>
 5056   ins_encode %{
 5057     AddressLiteral cOop = __ constant_oop_address((jobject)$src2$$constant);
 5058     __ relocate(cOop.rspec(), 1);
 5059     __ compare_immediate_narrow_oop($src1$$Register, (narrowOop)cOop.value());
 5060   %}
 5061   ins_pipe(pipe_class_dummy);
 5062 %}
 5063 
 5064 instruct compNKlass_iRegN_immN(iRegN src1, immNKlass src2, flagsReg cr) %{
 5065   match(Set cr (CmpN src1 src2));
 5066   ins_cost(DEFAULT_COST);
 5067   size(6);
<span class="line-modified"> 5068   format %{ &quot;CLFI    $src1,$src2\t# (NKlass) compare immediate narrow&quot; %}</span>
 5069   ins_encode %{
 5070     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src2$$constant);
 5071     __ relocate(NKlass.rspec(), 1);
 5072     __ compare_immediate_narrow_klass($src1$$Register, (Klass*)NKlass.value());
 5073   %}
 5074   ins_pipe(pipe_class_dummy);
 5075 %}
 5076 
 5077 instruct compN_iRegN_immN0(iRegN_P2N src1, immN0 src2, flagsReg cr) %{
 5078   match(Set cr (CmpN src1 src2));
 5079   ins_cost(DEFAULT_COST);
 5080   size(2);
<span class="line-modified"> 5081   format %{ &quot;LTR     $src1,$src2\t# (cOop) LTR because comparing against zero&quot; %}</span>
 5082   opcode(LTR_ZOPC);
 5083   ins_encode(z_rrform(src1, src1));
 5084   ins_pipe(pipe_class_dummy);
 5085 %}
 5086 
 5087 
 5088 //----------MemBar Instructions-----------------------------------------------
 5089 
 5090 // Memory barrier flavors
 5091 
 5092 instruct membar_acquire() %{
 5093   match(MemBarAcquire);
 5094   match(LoadFence);
 5095   ins_cost(4*MEMORY_REF_COST);
 5096   size(0);
 5097   format %{ &quot;MEMBAR-acquire&quot; %}
 5098   ins_encode %{ __ z_acquire(); %}
 5099   ins_pipe(pipe_class_dummy);
 5100 %}
 5101 
</pre>
<hr />
<pre>
 5354   ins_encode(/*empty*/);
 5355   ins_pipe(pipe_class_dummy);
 5356 %}
 5357 
 5358 instruct castPP(iRegP dst) %{
 5359   match(Set dst (CastPP dst));
 5360   size(0);
 5361   format %{ &quot;# castPP of $dst&quot; %}
 5362   ins_encode(/*empty*/);
 5363   ins_pipe(pipe_class_dummy);
 5364 %}
 5365 
 5366 instruct castII(iRegI dst) %{
 5367   match(Set dst (CastII dst));
 5368   size(0);
 5369   format %{ &quot;# castII of $dst&quot; %}
 5370   ins_encode(/*empty*/);
 5371   ins_pipe(pipe_class_dummy);
 5372 %}
 5373 








 5374 
 5375 //----------Conditional_store--------------------------------------------------
 5376 // Conditional-store of the updated heap-top.
 5377 // Used during allocation of the shared heap.
 5378 // Sets flags (EQ) on success.
 5379 
 5380 // Implement LoadPLocked. Must be ordered against changes of the memory location
 5381 // by storePConditional.
 5382 // Don&#39;t know whether this is ever used.
 5383 instruct loadPLocked(iRegP dst, memory mem) %{
 5384   match(Set dst (LoadPLocked mem));
 5385   ins_cost(MEMORY_REF_COST);
 5386   size(Z_DISP3_SIZE);
 5387   format %{ &quot;LG      $dst,$mem\t # LoadPLocked&quot; %}
 5388   opcode(LG_ZOPC, LG_ZOPC);
 5389   ins_encode(z_form_rt_mem_opt(dst, mem));
 5390   ins_pipe(pipe_class_dummy);
 5391 %}
 5392 
 5393 // As compareAndSwapP, but return flag register instead of boolean value in
</pre>
<hr />
<pre>
 6170   opcode(AGFI_ZOPC);
 6171   ins_encode(z_rilform_signed(dst, src));
 6172   ins_pipe(pipe_class_dummy);
 6173 %}
 6174 
 6175 // REG = REG1 + REG2 + IMM
 6176 
 6177 instruct addP_reg_reg_imm12(iRegP dst, memoryRegP src1, iRegL src2, uimmL12 con) %{
 6178   match(Set dst (AddP (AddP src1 src2) con));
 6179   predicate( PreferLAoverADD);
 6180   ins_cost(DEFAULT_COST_LOW);
 6181   size(4);
 6182   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6183   opcode(LA_ZOPC);
 6184   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6185   ins_pipe(pipe_class_dummy);
 6186 %}
 6187 
 6188 instruct addP_regN_reg_imm12(iRegP dst, iRegP_N2P src1, iRegL src2, uimmL12 con) %{
 6189   match(Set dst (AddP (AddP src1 src2) con));
<span class="line-modified"> 6190   predicate( PreferLAoverADD &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0);</span>
 6191   ins_cost(DEFAULT_COST_LOW);
 6192   size(4);
 6193   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6194   opcode(LA_ZOPC);
 6195   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6196   ins_pipe(pipe_class_dummy);
 6197 %}
 6198 
 6199 instruct addP_reg_reg_imm20(iRegP dst, memoryRegP src1, iRegL src2, immL20 con) %{
 6200   match(Set dst (AddP (AddP src1 src2) con));
 6201   predicate(PreferLAoverADD);
 6202   ins_cost(DEFAULT_COST);
 6203   // TODO: s390 port size(FIXED_SIZE);
 6204   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6205   opcode(LAY_ZOPC);
 6206   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6207   ins_pipe(pipe_class_dummy);
 6208 %}
 6209 
 6210 instruct addP_regN_reg_imm20(iRegP dst, iRegP_N2P src1, iRegL src2, immL20 con) %{
 6211   match(Set dst (AddP (AddP src1 src2) con));
<span class="line-modified"> 6212   predicate( PreferLAoverADD &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0);</span>
 6213   ins_cost(DEFAULT_COST);
 6214   // TODO: s390 port size(FIXED_SIZE);
 6215   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6216   opcode(LAY_ZOPC);
 6217   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6218   ins_pipe(pipe_class_dummy);
 6219 %}
 6220 
 6221 // MEM = MEM + IMM
 6222 
 6223 // Add Immediate to 8-byte memory operand and result
 6224 instruct addP_mem_imm(memoryRSY mem, immL8 src, flagsReg cr) %{
 6225   match(Set mem (StoreP mem (AddP (LoadP mem) src)));
 6226   effect(KILL cr);
 6227   predicate(VM_Version::has_MemWithImmALUOps());
 6228   ins_cost(MEMORY_REF_COST);
 6229   size(6);
 6230   format %{ &quot;AGSI    $mem,$src\t # direct mem add 8 (ptr)&quot; %}
 6231   opcode(AGSI_ZOPC);
 6232   ins_encode(z_siyform(mem, src));
</pre>
<hr />
<pre>
 6756       __ z_lghi(Z_R0_scratch, divisor);
 6757       __ z_lgr($dst$$Register-&gt;successor(), $src1$$Register);
 6758       __ z_dsgr($dst$$Register /* Dst is even part of a register pair. */, Z_R0_scratch);  // Instruction kills tmp.
 6759     } else {
 6760       __ clear_reg($dst$$Register, true, false);
 6761     }
 6762   %}
 6763   ins_pipe(pipe_class_dummy);
 6764 %}
 6765 
 6766 // SHIFT
 6767 
 6768 // Shift left logical
 6769 
 6770 // Register Shift Left variable
 6771 instruct sllI_reg_reg(iRegI dst, iRegI src, iRegI nbits, flagsReg cr) %{
 6772   match(Set dst (LShiftI src nbits));
 6773   effect(KILL cr); // R1 is killed, too.
 6774   ins_cost(3 * DEFAULT_COST);
 6775   size(14);
<span class="line-modified"> 6776   format %{ &quot;SLL     $dst,$src,[$nbits] &amp; 31\t# use RISC-like SLLG also for int&quot; %}</span>
 6777   ins_encode %{
 6778     __ z_lgr(Z_R1_scratch, $nbits$$Register);
 6779     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6780     __ z_sllg($dst$$Register, $src$$Register, 0, Z_R1_scratch);
 6781   %}
 6782   ins_pipe(pipe_class_dummy);
 6783 %}
 6784 
 6785 // Register Shift Left Immediate
 6786 // Constant shift count is masked in ideal graph already.
 6787 instruct sllI_reg_imm(iRegI dst, iRegI src, immI nbits) %{
 6788   match(Set dst (LShiftI src nbits));
 6789   size(6);
<span class="line-modified"> 6790   format %{ &quot;SLL     $dst,$src,$nbits\t# use RISC-like SLLG also for int&quot; %}</span>
 6791   ins_encode %{
 6792     int Nbit = $nbits$$constant;
 6793     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6794     __ z_sllg($dst$$Register, $src$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6795   %}
 6796   ins_pipe(pipe_class_dummy);
 6797 %}
 6798 
 6799 // Register Shift Left Immediate by 1bit
 6800 instruct sllI_reg_imm_1(iRegI dst, iRegI src, immI_1 nbits) %{
 6801   match(Set dst (LShiftI src nbits));
 6802   predicate(PreferLAoverADD);
 6803   ins_cost(DEFAULT_COST_LOW);
 6804   size(4);
 6805   format %{ &quot;LA      $dst,#0($src,$src)\t # SLL by 1 (int)&quot; %}
 6806   ins_encode %{ __ z_la($dst$$Register, 0, $src$$Register, $src$$Register); %}
 6807   ins_pipe(pipe_class_dummy);
 6808 %}
 6809 
 6810 // Register Shift Left Long
</pre>
<hr />
<pre>
 7086   %}
 7087   ins_pipe(pipe_class_dummy);
 7088 %}
 7089 
 7090 instruct overflowSubL_reg_imm(flagsReg cr, iRegL op1, immL op2) %{
 7091   match(Set cr (OverflowSubL op1 op2));
 7092   effect(DEF cr, USE op1, USE op2);
 7093   // TODO: s390 port size(VARIABLE_SIZE);
 7094   format %{ &quot;SGR     $op1,$op2\t # overflow check long&quot; %}
 7095   ins_encode %{
 7096     __ load_const_optimized(Z_R1_scratch, $op2$$constant);
 7097     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7098     __ z_sgr(Z_R0_scratch, Z_R1_scratch);
 7099   %}
 7100   ins_pipe(pipe_class_dummy);
 7101 %}
 7102 
 7103 instruct overflowNegI_rReg(flagsReg cr, immI_0 zero, iRegI op2) %{
 7104   match(Set cr (OverflowSubI zero op2));
 7105   effect(DEF cr, USE op2);
<span class="line-modified"> 7106   format %{ &quot;NEG    $op2\t# overflow check int&quot; %}</span>
 7107   ins_encode %{
 7108     __ clear_reg(Z_R0_scratch, false, false);
 7109     __ z_sr(Z_R0_scratch, $op2$$Register);
 7110   %}
 7111   ins_pipe(pipe_class_dummy);
 7112 %}
 7113 
 7114 instruct overflowNegL_rReg(flagsReg cr, immL_0 zero, iRegL op2) %{
 7115   match(Set cr (OverflowSubL zero op2));
 7116   effect(DEF cr, USE op2);
<span class="line-modified"> 7117   format %{ &quot;NEGG    $op2\t# overflow check long&quot; %}</span>
 7118   ins_encode %{
 7119     __ clear_reg(Z_R0_scratch, true, false);
 7120     __ z_sgr(Z_R0_scratch, $op2$$Register);
 7121   %}
 7122   ins_pipe(pipe_class_dummy);
 7123 %}
 7124 
 7125 // No intrinsics for multiplication, since there is no easy way
 7126 // to check for overflow.
 7127 
 7128 
 7129 //----------Floating Point Arithmetic Instructions-----------------------------
 7130 
 7131 //  ADD
 7132 
 7133 //  Add float single precision
 7134 instruct addF_reg_reg(regF dst, regF src, flagsReg cr) %{
 7135   match(Set dst (AddF dst src));
 7136   effect(KILL cr);
 7137   ins_cost(ALU_REG_COST);
</pre>
<hr />
<pre>
 8516   size(4);
 8517   format %{ &quot;CLGR    $op1,$op2\t # ptr&quot; %}
 8518   opcode(CLGR_ZOPC);
 8519   ins_encode(z_rreform(op1, op2));
 8520   ins_pipe(pipe_class_dummy);
 8521 %}
 8522 
 8523 instruct compP_reg_imm0(flagsReg cr, iRegP_N2P op1, immP0 op2) %{
 8524   match(Set cr (CmpP op1 op2));
 8525   ins_cost(DEFAULT_COST_LOW);
 8526   size(4);
 8527   format %{ &quot;LTGR    $op1, $op1\t # ptr&quot; %}
 8528   opcode(LTGR_ZOPC);
 8529   ins_encode(z_rreform(op1, op1));
 8530   ins_pipe(pipe_class_dummy);
 8531 %}
 8532 
 8533 // Don&#39;t use LTGFR which performs sign extend.
 8534 instruct compP_decode_reg_imm0(flagsReg cr, iRegN op1, immP0 op2) %{
 8535   match(Set cr (CmpP (DecodeN op1) op2));
<span class="line-modified"> 8536   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0);</span>
 8537   ins_cost(DEFAULT_COST_LOW);
 8538   size(2);
 8539   format %{ &quot;LTR    $op1, $op1\t # ptr&quot; %}
 8540   opcode(LTR_ZOPC);
 8541   ins_encode(z_rrform(op1, op1));
 8542   ins_pipe(pipe_class_dummy);
 8543 %}
 8544 
 8545 instruct compP_reg_mem(iRegP dst, memory src, flagsReg cr)%{
 8546   match(Set cr (CmpP dst (LoadP src)));
 8547   ins_cost(MEMORY_REF_COST);
 8548   size(Z_DISP3_SIZE);
 8549   format %{ &quot;CLG     $dst, $src\t # ptr&quot; %}
 8550   opcode(CLG_ZOPC, CLG_ZOPC);
 8551   ins_encode(z_form_rt_mem_opt(dst, src));
 8552   ins_pipe(pipe_class_dummy);
 8553 %}
 8554 
 8555 //----------Max and Min--------------------------------------------------------
 8556 
</pre>
<hr />
<pre>
 9152 // Direct Branch.
 9153 instruct branchFar(label labl) %{
 9154   match(Goto);
 9155   effect(USE labl);
 9156   ins_cost(BRANCH_COST);
 9157   size(6);
 9158   format %{ &quot;BRUL   $labl&quot; %}
 9159   ins_encode(z_enc_brul(labl));
 9160   ins_pipe(pipe_class_dummy);
 9161   // This is not a short variant of a branch, but the long variant.
 9162   ins_short_branch(0);
 9163 %}
 9164 
 9165 // Conditional Near Branch
 9166 instruct branchCon(cmpOp cmp, flagsReg cr, label lbl) %{
 9167   // Same match rule as `branchConFar&#39;.
 9168   match(If cmp cr);
 9169   effect(USE lbl);
 9170   ins_cost(BRANCH_COST);
 9171   size(4);
<span class="line-modified"> 9172   format %{ &quot;branch_con_short,$cmp   $cr, $lbl&quot; %}</span>
 9173   ins_encode(z_enc_branch_con_short(cmp, lbl));
 9174   ins_pipe(pipe_class_dummy);
 9175   // If set to 1 this indicates that the current instruction is a
 9176   // short variant of a long branch. This avoids using this
 9177   // instruction in first-pass matching. It will then only be used in
 9178   // the `Shorten_branches&#39; pass.
 9179   ins_short_branch(1);
 9180 %}
 9181 
 9182 // This is for cases when the z/Architecture conditional branch instruction
 9183 // does not reach far enough. So we emit a far branch here, which is
 9184 // more expensive.
 9185 //
 9186 // Conditional Far Branch
 9187 instruct branchConFar(cmpOp cmp, flagsReg cr, label lbl) %{
 9188   // Same match rule as `branchCon&#39;.
 9189   match(If cmp cr);
 9190   effect(USE cr, USE lbl);
 9191   // Make more expensive to prefer compare_and_branch over separate instructions.
 9192   ins_cost(2 * BRANCH_COST);
 9193   size(6);
<span class="line-modified"> 9194   format %{ &quot;branch_con_far,$cmp   $cr, $lbl&quot; %}</span>
 9195   ins_encode(z_enc_branch_con_far(cmp, lbl));
 9196   ins_pipe(pipe_class_dummy);
 9197   // This is not a short variant of a branch, but the long variant..
 9198   ins_short_branch(0);
 9199 %}
 9200 
 9201 instruct branchLoopEnd(cmpOp cmp, flagsReg cr, label labl) %{
 9202   match(CountedLoopEnd cmp cr);
 9203   effect(USE labl);
 9204   ins_cost(BRANCH_COST);
 9205   size(4);
 9206   format %{ &quot;branch_con_short,$cmp   $labl\t # counted loop end&quot; %}
 9207   ins_encode(z_enc_branch_con_short(cmp, labl));
 9208   ins_pipe(pipe_class_dummy);
 9209   // If set to 1 this indicates that the current instruction is a
 9210   // short variant of a long branch. This avoids using this
 9211   // instruction in first-pass matching. It will then only be used in
 9212   // the `Shorten_branches&#39; pass.
 9213   ins_short_branch(1);
 9214 %}
</pre>
<hr />
<pre>
 9743 instruct CallLeafNoFPDirect(method meth) %{
 9744   match(CallLeafNoFP);
 9745   effect(USE meth);
 9746   ins_cost(CALL_COST);
 9747   // TODO: s390 port size(VARIABLE_SIZE);
 9748   ins_num_consts(1);
 9749   format %{ &quot;CALL,runtime leaf nofp $meth&quot; %}
 9750   ins_encode( z_enc_java_to_runtime_call(meth) );
 9751   ins_pipe(pipe_class_dummy);
 9752   ins_alignment(2);
 9753 %}
 9754 
 9755 // Tail Call; Jump from runtime stub to Java code.
 9756 // Also known as an &#39;interprocedural jump&#39;.
 9757 // Target of jump will eventually return to caller.
 9758 // TailJump below removes the return address.
 9759 instruct TailCalljmpInd(iRegP jump_target, inline_cache_regP method_oop) %{
 9760   match(TailCall jump_target method_oop);
 9761   ins_cost(CALL_COST);
 9762   size(2);
<span class="line-modified"> 9763   format %{ &quot;Jmp     $jump_target\t# $method_oop holds method oop&quot; %}</span>
 9764   ins_encode %{ __ z_br($jump_target$$Register); %}
 9765   ins_pipe(pipe_class_dummy);
 9766 %}
 9767 
 9768 // Return Instruction
 9769 instruct Ret() %{
 9770   match(Return);
 9771   size(2);
 9772   format %{ &quot;BR(Z_R14) // branch to link register&quot; %}
 9773   ins_encode %{ __ z_br(Z_R14); %}
 9774   ins_pipe(pipe_class_dummy);
 9775 %}
 9776 
 9777 // Tail Jump; remove the return address; jump to target.
 9778 // TailCall above leaves the return address around.
 9779 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
 9780 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
 9781 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
 9782 // in %i0.
 9783 instruct tailjmpInd(iRegP jump_target, rarg1RegP ex_oop) %{
</pre>
<hr />
<pre>
 9882   match(Set pcc (FastUnlock oop box));
 9883   effect(TEMP tmp1, TEMP tmp2);
 9884   ins_cost(100);
 9885   // TODO: s390 port size(FIXED_SIZE);  // emitted code depends on UseBiasedLocking being on/off.
 9886   format %{ &quot;FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5&quot; %}
 9887   ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,
 9888                                                UseBiasedLocking &amp;&amp; !UseOptoBiasInlining); %}
 9889   ins_pipe(pipe_class_dummy);
 9890 %}
 9891 
 9892 instruct inlineCallClearArrayConst(SSlenDW cnt, iRegP_N2P base, Universe dummy, flagsReg cr) %{
 9893   match(Set dummy (ClearArray cnt base));
 9894   effect(KILL cr);
 9895   ins_cost(100);
 9896   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to varying #instructions.
 9897   format %{ &quot;ClearArrayConst $cnt,$base&quot; %}
 9898   ins_encode %{ __ Clear_Array_Const($cnt$$constant, $base$$Register); %}
 9899   ins_pipe(pipe_class_dummy);
 9900 %}
 9901 
<span class="line-modified"> 9902 instruct inlineCallClearArrayConstBig(immL cnt, iRegP_N2P base, Universe dummy, revenRegL srcA, roddRegL srcL, flagsReg cr) %{</span>
 9903   match(Set dummy (ClearArray cnt base));
<span class="line-modified"> 9904   effect(TEMP srcA, TEMP srcL, KILL cr); // R0, R1 are killed, too.</span>
 9905   ins_cost(200);
 9906   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to optimized constant loader.
 9907   format %{ &quot;ClearArrayConstBig $cnt,$base&quot; %}
<span class="line-modified"> 9908   ins_encode %{ __ Clear_Array_Const_Big($cnt$$constant, $base$$Register, $srcA$$Register, $srcL$$Register); %}</span>
 9909   ins_pipe(pipe_class_dummy);
 9910 %}
 9911 
<span class="line-modified"> 9912 instruct inlineCallClearArray(iRegL cnt, iRegP_N2P base, Universe dummy, revenRegL srcA, roddRegL srcL, flagsReg cr) %{</span>
 9913   match(Set dummy (ClearArray cnt base));
<span class="line-modified"> 9914   effect(TEMP srcA, TEMP srcL, KILL cr); // R0, R1 are killed, too.</span>
 9915   ins_cost(300);
 9916   // TODO: s390 port size(FIXED_SIZE);  // z/Architecture: emitted code depends on PreferLAoverADD being on/off.
 9917   format %{ &quot;ClearArrayVar $cnt,$base&quot; %}
<span class="line-modified"> 9918   ins_encode %{ __ Clear_Array($cnt$$Register, $base$$Register, $srcA$$Register, $srcL$$Register); %}</span>
 9919   ins_pipe(pipe_class_dummy);
 9920 %}
 9921 
 9922 // ============================================================================
 9923 // CompactStrings
 9924 
 9925 // String equals
 9926 instruct string_equalsL(iRegP str1, iRegP str2, iRegI cnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
 9927   match(Set result (StrEquals (Binary str1 str2) cnt));
 9928   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
 9929   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
 9930   ins_cost(300);
 9931   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result&quot; %}
 9932   ins_encode %{
 9933     __ array_equals(false, $str1$$Register, $str2$$Register,
 9934                     $cnt$$Register, $oddReg$$Register, $evenReg$$Register,
 9935                     $result$$Register, true /* byte */);
 9936   %}
 9937   ins_pipe(pipe_class_dummy);
 9938 %}
</pre>
<hr />
<pre>
10751 instruct loadV8(iRegL dst, memory mem) %{
10752   match(Set dst (LoadVector mem));
10753   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
10754   ins_cost(MEMORY_REF_COST);
10755   // TODO: s390 port size(VARIABLE_SIZE);
10756   format %{ &quot;LG      $dst,$mem\t # L(packed8B)&quot; %}
10757   opcode(LG_ZOPC, LG_ZOPC);
10758   ins_encode(z_form_rt_mem_opt(dst, mem));
10759   ins_pipe(pipe_class_dummy);
10760 %}
10761 
10762 //----------POPULATION COUNT RULES--------------------------------------------
10763 
10764 // Byte reverse
10765 
10766 instruct bytes_reverse_int(iRegI dst, iRegI src) %{
10767   match(Set dst (ReverseBytesI src));
10768   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10769   ins_cost(DEFAULT_COST);
10770   size(4);
<span class="line-modified">10771   format %{ &quot;LRVR    $dst,$src\t# byte reverse int&quot; %}</span>
10772   opcode(LRVR_ZOPC);
10773   ins_encode(z_rreform(dst, src));
10774   ins_pipe(pipe_class_dummy);
10775 %}
10776 
10777 instruct bytes_reverse_long(iRegL dst, iRegL src) %{
10778   match(Set dst (ReverseBytesL src));
10779   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10780   ins_cost(DEFAULT_COST);
10781   // TODO: s390 port size(FIXED_SIZE);
<span class="line-modified">10782   format %{ &quot;LRVGR   $dst,$src\t# byte reverse long&quot; %}</span>
10783   opcode(LRVGR_ZOPC);
10784   ins_encode(z_rreform(dst, src));
10785   ins_pipe(pipe_class_dummy);
10786 %}
10787 
10788 // Leading zeroes
10789 
10790 // The instruction FLOGR (Find Leftmost One in Grande (64bit) Register)
10791 // returns the bit position of the leftmost 1 in the 64bit source register.
10792 // As the bits are numbered from left to right (0..63), the returned
10793 // position index is equivalent to the number of leading zeroes.
10794 // If no 1-bit is found (i.e. the regsiter contains zero), the instruction
10795 // returns position 64. That&#39;s exactly what we need.
10796 
10797 instruct countLeadingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10798   match(Set dst (CountLeadingZerosI src));
10799   effect(KILL tmp, KILL cr);
10800   ins_cost(3 * DEFAULT_COST);
10801   size(14);
<span class="line-modified">10802   format %{ &quot;SLLG    $dst,$src,32\t# no need to always count 32 zeroes first\n\t&quot;</span>
<span class="line-modified">10803             &quot;IILH    $dst,0x8000 \t# insert \&quot;stop bit\&quot; to force result 32 for zero src.\n\t&quot;</span>
10804             &quot;FLOGR   $dst,$dst&quot;
10805          %}
10806   ins_encode %{
10807     // Performance experiments indicate that &quot;FLOGR&quot; is using some kind of
10808     // iteration to find the leftmost &quot;1&quot; bit.
10809     //
10810     // The prior implementation zero-extended the 32-bit argument to 64 bit,
10811     // thus forcing &quot;FLOGR&quot; to count 32 bits of which we know they are zero.
10812     // We could gain measurable speedup in micro benchmark:
10813     //
10814     //               leading   trailing
10815     //   z10:   int     2.04       1.68
10816     //         long     1.00       1.02
10817     //   z196:  int     0.99       1.23
10818     //         long     1.00       1.11
10819     //
10820     // By shifting the argument into the high-word instead of zero-extending it.
10821     // The add&#39;l branch on condition (taken for a zero argument, very infrequent,
10822     // good prediction) is well compensated for by the savings.
10823     //
10824     // We leave the previous implementation in for some time in the future when
10825     // the &quot;FLOGR&quot; instruction may become less iterative.
10826 
10827     // Version 2: shows 62%(z9), 204%(z10), -1%(z196) improvement over original
10828     __ z_sllg($dst$$Register, $src$$Register, 32); // No need to always count 32 zeroes first.
10829     __ z_iilh($dst$$Register, 0x8000);   // Insert &quot;stop bit&quot; to force result 32 for zero src.
10830     __ z_flogr($dst$$Register, $dst$$Register);
10831   %}
10832   ins_pipe(pipe_class_dummy);
10833 %}
10834 
10835 instruct countLeadingZerosL(revenRegI dst, iRegL src, roddRegI tmp, flagsReg cr) %{
10836   match(Set dst (CountLeadingZerosL src));
10837   effect(KILL tmp, KILL cr);
10838   ins_cost(DEFAULT_COST);
10839   size(4);
<span class="line-modified">10840   format %{ &quot;FLOGR   $dst,$src \t# count leading zeros (long)\n\t&quot; %}</span>
10841   ins_encode %{ __ z_flogr($dst$$Register, $src$$Register); %}
10842   ins_pipe(pipe_class_dummy);
10843 %}
10844 
10845 // trailing zeroes
10846 
10847 // We transform the trailing zeroes problem to a leading zeroes problem
10848 // such that can use the FLOGR instruction to our advantage.
10849 
10850 // With
10851 //   tmp1 = src - 1
10852 // we flip all trailing zeroes to ones and the rightmost one to zero.
10853 // All other bits remain unchanged.
10854 // With the complement
10855 //   tmp2 = ~src
10856 // we get all ones in the trailing zeroes positions. Thus,
10857 //   tmp3 = tmp1 &amp; tmp2
10858 // yields ones in the trailing zeroes positions and zeroes elsewhere.
10859 // Now we can apply FLOGR and get 64-(trailing zeroes).
10860 instruct countTrailingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10861   match(Set dst (CountTrailingZerosI src));
10862   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
10863   ins_cost(8 * DEFAULT_COST);
10864   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
<span class="line-modified">10865   format %{ &quot;LLGFR   $dst,$src  \t# clear upper 32 bits (we are dealing with int)\n\t&quot;</span>
<span class="line-modified">10866             &quot;LCGFR   $tmp,$src  \t# load 2&#39;s complement (32-&gt;64 bit)\n\t&quot;</span>
<span class="line-modified">10867             &quot;AGHI    $dst,-1    \t# tmp1 = src-1\n\t&quot;</span>
<span class="line-modified">10868             &quot;AGHI    $tmp,-1    \t# tmp2 = -src-1 = ~src\n\t&quot;</span>
<span class="line-modified">10869             &quot;NGR     $dst,$tmp  \t# tmp3 = tmp1&amp;tmp2\n\t&quot;</span>
<span class="line-modified">10870             &quot;FLOGR   $dst,$dst  \t# count trailing zeros (int)\n\t&quot;</span>
<span class="line-modified">10871             &quot;AHI     $dst,-64   \t# tmp4 = 64-(trailing zeroes)-64\n\t&quot;</span>
<span class="line-modified">10872             &quot;LCR     $dst,$dst  \t# res = -tmp4&quot;</span>
10873          %}
10874   ins_encode %{
10875     Register Rdst = $dst$$Register;
10876     Register Rsrc = $src$$Register;
10877     // Rtmp only needed for for zero-argument shortcut. With kill effect in
10878     // match rule Rsrc = roddReg would be possible, saving one register.
10879     Register Rtmp = $tmp$$Register;
10880 
10881     assert_different_registers(Rdst, Rsrc, Rtmp);
10882 
10883     // Algorithm:
10884     // - Isolate the least significant (rightmost) set bit using (src &amp; (-src)).
10885     //   All other bits in the result are zero.
10886     // - Find the &quot;leftmost one&quot; bit position in the single-bit result from previous step.
10887     // - 63-(&quot;leftmost one&quot; bit position) gives the # of trailing zeros.
10888 
10889     // Version 2: shows 79%(z9), 68%(z10), 23%(z196) improvement over original.
10890     Label done;
10891     __ load_const_optimized(Rdst, 32); // Prepare for shortcut (zero argument), result will be 32.
10892     __ z_lcgfr(Rtmp, Rsrc);
</pre>
<hr />
<pre>
10898                                        // into upper half of reg. Not relevant with sllg below.
10899     __ z_sllg(Rdst, Rtmp, 32);         // Shift interesting contents to upper half of register.
10900     __ z_bre(done);                    // Shortcut for argument = 1, result will be 0.
10901                                        // Depends on CC set by ahi above.
10902                                        // Taken very infrequently, good prediction, no BHT entry.
10903                                        // Branch delayed to have Rdst set correctly (Rtmp == 0(32bit)
10904                                        // after SLLG Rdst == 0(64bit)).
10905     __ z_flogr(Rdst, Rdst);            // Kills tmp which is the oddReg for dst.
10906     __ add2reg(Rdst,  -32);            // 32-pos(leftmost1) is #trailing zeros
10907     __ z_lcgfr(Rdst, Rdst);            // Provide 64bit result at no cost.
10908     __ bind(done);
10909   %}
10910   ins_pipe(pipe_class_dummy);
10911 %}
10912 
10913 instruct countTrailingZerosL(revenRegI dst, iRegL src, roddRegL tmp, flagsReg cr) %{
10914   match(Set dst (CountTrailingZerosL src));
10915   effect(TEMP_DEF dst, KILL tmp, KILL cr);
10916   ins_cost(8 * DEFAULT_COST);
10917   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
<span class="line-modified">10918   format %{ &quot;LCGR    $dst,$src  \t# preserve src\n\t&quot;</span>
<span class="line-modified">10919             &quot;NGR     $dst,$src  \t#&quot;</span>
<span class="line-modified">10920             &quot;AGHI    $dst,-1    \t# tmp1 = src-1\n\t&quot;</span>
<span class="line-modified">10921             &quot;FLOGR   $dst,$dst  \t# count trailing zeros (long), kill $tmp\n\t&quot;</span>
<span class="line-modified">10922             &quot;AHI     $dst,-64   \t# tmp4 = 64-(trailing zeroes)-64\n\t&quot;</span>
<span class="line-modified">10923             &quot;LCR     $dst,$dst  \t#&quot;</span>
10924          %}
10925   ins_encode %{
10926     Register Rdst = $dst$$Register;
10927     Register Rsrc = $src$$Register;
10928     assert_different_registers(Rdst, Rsrc); // Rtmp == Rsrc allowed.
10929 
10930     // New version: shows 5%(z9), 2%(z10), 11%(z196) improvement over original.
10931     __ z_lcgr(Rdst, Rsrc);
10932     __ z_ngr(Rdst, Rsrc);
10933     __ add2reg(Rdst,   -1);
10934     __ z_flogr(Rdst, Rdst); // Kills tmp which is the oddReg for dst.
10935     __ add2reg(Rdst,  -64);
10936     __ z_lcgfr(Rdst, Rdst); // Provide 64bit result at no cost.
10937   %}
10938   ins_pipe(pipe_class_dummy);
10939 %}
10940 
10941 
10942 // bit count
10943 
10944 instruct popCountI(iRegI dst, iRegI src, iRegI tmp, flagsReg cr) %{
10945   match(Set dst (PopCountI src));
10946   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
10947   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
10948   ins_cost(DEFAULT_COST);
10949   size(24);
<span class="line-modified">10950   format %{ &quot;POPCNT  $dst,$src\t# pop count int&quot; %}</span>
10951   ins_encode %{
10952     Register Rdst = $dst$$Register;
10953     Register Rsrc = $src$$Register;
10954     Register Rtmp = $tmp$$Register;
10955 
10956     // Prefer compile-time assertion over run-time SIGILL.
10957     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
10958     assert_different_registers(Rdst, Rtmp);
10959 
10960     // Version 2: shows 10%(z196) improvement over original.
10961     __ z_popcnt(Rdst, Rsrc);
10962     __ z_srlg(Rtmp, Rdst, 16); // calc  byte4+byte6 and byte5+byte7
10963     __ z_alr(Rdst, Rtmp);      //   into byte6 and byte7
10964     __ z_srlg(Rtmp, Rdst,  8); // calc (byte4+byte6) + (byte5+byte7)
10965     __ z_alr(Rdst, Rtmp);      //   into byte7
10966     __ z_llgcr(Rdst, Rdst);    // zero-extend sum
10967   %}
10968   ins_pipe(pipe_class_dummy);
10969 %}
10970 
10971 instruct popCountL(iRegI dst, iRegL src, iRegL tmp, flagsReg cr) %{
10972   match(Set dst (PopCountL src));
10973   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
10974   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
10975   ins_cost(DEFAULT_COST);
10976   // TODO: s390 port size(FIXED_SIZE);
<span class="line-modified">10977   format %{ &quot;POPCNT  $dst,$src\t# pop count long&quot; %}</span>
10978   ins_encode %{
10979     Register Rdst = $dst$$Register;
10980     Register Rsrc = $src$$Register;
10981     Register Rtmp = $tmp$$Register;
10982 
10983     // Prefer compile-time assertion over run-time SIGILL.
10984     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
10985     assert_different_registers(Rdst, Rtmp);
10986 
10987     // Original version. Using LA instead of algr seems to be a really bad idea (-35%).
10988     __ z_popcnt(Rdst, Rsrc);
10989     __ z_ahhlr(Rdst, Rdst, Rdst);
10990     __ z_sllg(Rtmp, Rdst, 16);
10991     __ z_algr(Rdst, Rtmp);
10992     __ z_sllg(Rtmp, Rdst,  8);
10993     __ z_algr(Rdst, Rtmp);
10994     __ z_srlg(Rdst, Rdst, 56);
10995   %}
10996   ins_pipe(pipe_class_dummy);
10997 %}
10998 
10999 //----------SMARTSPILL RULES---------------------------------------------------
11000 // These must follow all instruction definitions as they use the names
11001 // defined in the instructions definitions.
11002 
11003 // ============================================================================
11004 // TYPE PROFILING RULES
<span class="line-removed">11005 </span>
</pre>
</td>
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">    3 // Copyright (c) 2017, 2019 SAP SE. All rights reserved.</span>
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
</pre>
<hr />
<pre>
  457 // Longs in 1 register. Aligned adjacent hi/lo pairs.
  458 reg_class z_long_reg(
  459 /*Z_R0_H,Z_R0*/     // R0
  460 /*Z_R1_H,Z_R1*/
  461   Z_R2_H,Z_R2,
  462   Z_R3_H,Z_R3,
  463   Z_R4_H,Z_R4,
  464   Z_R5_H,Z_R5,
  465   Z_R6_H,Z_R6,
  466   Z_R7_H,Z_R7,
  467 /*Z_R8_H,Z_R8,*/    // Z_thread
  468   Z_R9_H,Z_R9,
  469   Z_R10_H,Z_R10,
  470   Z_R11_H,Z_R11,
  471   Z_R12_H,Z_R12,
  472   Z_R13_H,Z_R13
  473 /*Z_R14_H,Z_R14,*/  // return_pc
  474 /*Z_R15_H,Z_R15*/   // SP
  475 );
  476 
<span class="line-added">  477 // z_long_reg without even registers</span>
<span class="line-added">  478 reg_class z_long_odd_reg(</span>
<span class="line-added">  479 /*Z_R0_H,Z_R0*/     // R0</span>
<span class="line-added">  480 /*Z_R1_H,Z_R1*/</span>
<span class="line-added">  481   Z_R3_H,Z_R3,</span>
<span class="line-added">  482   Z_R5_H,Z_R5,</span>
<span class="line-added">  483   Z_R7_H,Z_R7,</span>
<span class="line-added">  484   Z_R9_H,Z_R9,</span>
<span class="line-added">  485   Z_R11_H,Z_R11,</span>
<span class="line-added">  486   Z_R13_H,Z_R13</span>
<span class="line-added">  487 /*Z_R14_H,Z_R14,*/  // return_pc</span>
<span class="line-added">  488 /*Z_R15_H,Z_R15*/   // SP</span>
<span class="line-added">  489 );</span>
  490 
  491 // Special Class for Condition Code Flags Register
  492 
  493 reg_class z_condition_reg(
  494   Z_CR
  495 );
  496 
  497 // Scratch register for late profiling. Callee saved.
  498 reg_class z_rscratch2_bits64_reg(Z_R2_H, Z_R2);
  499 
  500 
  501 // Float Register Classes
  502 
  503 reg_class z_flt_reg(
  504   Z_F0,
  505 /*Z_F1,*/ // scratch
  506   Z_F2,
  507   Z_F3,
  508   Z_F4,
  509   Z_F5,
</pre>
<hr />
<pre>
  850   // account for that. See bugs 4446381, 4468289, 4497237.
  851   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  852     st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
  853   }
  854   st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
  855   st-&gt;print(&quot;\t&quot;);
  856 }
  857 #endif
  858 
  859 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  860   Compile* C = ra_-&gt;C;
  861   MacroAssembler _masm(&amp;cbuf);
  862 
  863   __ verify_thread();
  864 
  865   size_t framesize = C-&gt;frame_size_in_bytes();
  866   size_t bangsize  = C-&gt;bang_size_in_bytes();
  867 
  868   assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  869 
<span class="line-added">  870   if (C-&gt;clinit_barrier_on_entry()) {</span>
<span class="line-added">  871     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-added">  872 </span>
<span class="line-added">  873     Label L_skip_barrier;</span>
<span class="line-added">  874     Register klass = Z_R1_scratch;</span>
<span class="line-added">  875 </span>
<span class="line-added">  876     // Notify OOP recorder (don&#39;t need the relocation)</span>
<span class="line-added">  877     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());</span>
<span class="line-added">  878     __ load_const_optimized(klass, md.value());</span>
<span class="line-added">  879     __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added">  880 </span>
<span class="line-added">  881     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());</span>
<span class="line-added">  882     __ z_br(klass);</span>
<span class="line-added">  883 </span>
<span class="line-added">  884     __ bind(L_skip_barrier);</span>
<span class="line-added">  885   }</span>
<span class="line-added">  886 </span>
  887   // Calls to C2R adapters often do not accept exceptional returns.
  888   // We require that their callers must bang for them. But be
  889   // careful, because some VM calls (such as call site linkage) can
  890   // use several kilobytes of stack. But the stack safety zone should
  891   // account for that. See bugs 4446381, 4468289, 4497237.
  892   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  893     __ generate_stack_overflow_check(bangsize);
  894   }
  895 
  896   assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
  897   __ save_return_pc();
  898 
  899   // The z/Architecture abi is already accounted for in `framesize&#39; via the
  900   // &#39;out_preserve_stack_slots&#39; declaration.
  901   __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  902 
  903   if (C-&gt;has_mach_constant_base_node()) {
  904     // NOTE: We set the table base offset here because users might be
  905     // emitted before MachConstantBaseNode.
  906     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
</pre>
<hr />
<pre>
 1388     // The ic_miss_stub will handle the null pointer exception.
 1389     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1390     __ z_br(R1_ic_miss_stub_addr);
 1391     __ bind(valid);
 1392   }
 1393 
 1394   // Check whether this method is the proper implementation for the class of
 1395   // the receiver (ic miss check).
 1396   {
 1397     Label valid;
 1398     // Compare cached class against klass from receiver.
 1399     // This also does an implicit null check!
 1400     __ compare_klass_ptr(ic_klass, klass_offset, R2_receiver, false);
 1401     __ z_bre(valid);
 1402     // The inline cache points to the wrong method. Call the
 1403     // ic_miss_stub to find the proper method.
 1404     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1405     __ z_br(R1_ic_miss_stub_addr);
 1406     __ bind(valid);
 1407   }

 1408 }
 1409 
 1410 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1411   // Determine size dynamically.
 1412   return MachNode::size(ra_);
 1413 }
 1414 
 1415 //=============================================================================
 1416 
 1417 %} // interrupt source section
 1418 
 1419 source_hpp %{ // Header information of the source block.
 1420 
 1421 class HandlerImpl {
 1422  public:
 1423 
 1424   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 1425   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 1426 
 1427   static uint size_exception_handler() {
</pre>
<hr />
<pre>
 1534 
 1535     case Op_GetAndAddI:
 1536     case Op_GetAndAddL:
 1537       return true;
 1538       // return VM_Version::has_AtomicMemWithImmALUOps();
 1539     case Op_GetAndSetI:
 1540     case Op_GetAndSetL:
 1541     case Op_GetAndSetP:
 1542     case Op_GetAndSetN:
 1543       return true;  // General CAS implementation, always available.
 1544 
 1545     default:
 1546       return true;  // Per default match rules are supported.
 1547                     // BUT: make sure match rule is not disabled by a false predicate!
 1548   }
 1549 
 1550   return true;  // Per default match rules are supported.
 1551                 // BUT: make sure match rule is not disabled by a false predicate!
 1552 }
 1553 
<span class="line-modified"> 1554 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {</span>
 1555   // TODO
 1556   // Identify extra cases that we might want to provide match rules for
 1557   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen.
 1558   bool ret_value = match_rule_supported(opcode);
 1559   // Add rules here.
 1560 
 1561   return ret_value;  // Per default match rules are supported.
 1562 }
 1563 
 1564 int Matcher::regnum_to_fpu_offset(int regnum) {
 1565   ShouldNotReachHere();
 1566   return regnum - 32; // The FP registers are in the second chunk.
 1567 }
 1568 
 1569 const bool Matcher::has_predicated_vectors(void) {
 1570   return false;
 1571 }
 1572 
 1573 const int Matcher::float_pressure(int default_pressure_threshold) {
 1574   return default_pressure_threshold;
</pre>
<hr />
<pre>
 1641 }
 1642 
 1643 // Should correspond to setting above
 1644 const bool Matcher::init_array_count_is_in_bytes = false;
 1645 
 1646 // Suppress CMOVL. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1647 const int Matcher::long_cmove_cost() { return ConditionalMoveLimit; }
 1648 
 1649 // Suppress CMOVF. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1650 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1651 
 1652 // Does the CPU require postalloc expand (see block.cpp for description of postalloc expand)?
 1653 const bool Matcher::require_postalloc_expand = false;
 1654 
 1655 // Do we need to mask the count passed to shift instructions or does
 1656 // the cpu only look at the lower 5/6 bits anyway?
 1657 // 32bit shifts mask in emitter, 64bit shifts need no mask.
 1658 // Constant shift counts are handled in Ideal phase.
 1659 const bool Matcher::need_masked_shift_count = false;
 1660 
<span class="line-added"> 1661 // No support for generic vector operands.</span>
<span class="line-added"> 1662 const bool Matcher::supports_generic_vector_operands  = false;</span>
<span class="line-added"> 1663 </span>
<span class="line-added"> 1664 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {</span>
<span class="line-added"> 1665   ShouldNotReachHere(); // generic vector operands not supported</span>
<span class="line-added"> 1666   return NULL;</span>
<span class="line-added"> 1667 }</span>
<span class="line-added"> 1668 </span>
<span class="line-added"> 1669 bool Matcher::is_generic_reg2reg_move(MachNode* m) {</span>
<span class="line-added"> 1670   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added"> 1671   return false;</span>
<span class="line-added"> 1672 }</span>
<span class="line-added"> 1673 </span>
<span class="line-added"> 1674 bool Matcher::is_generic_vector(MachOper* opnd)  {</span>
<span class="line-added"> 1675   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added"> 1676   return false;</span>
<span class="line-added"> 1677 }</span>
<span class="line-added"> 1678 </span>
 1679 // Set this as clone_shift_expressions.
 1680 bool Matcher::narrow_oop_use_complex_address() {
<span class="line-modified"> 1681   if (CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0) return true;</span>
 1682   return false;
 1683 }
 1684 
 1685 bool Matcher::narrow_klass_use_complex_address() {
 1686   NOT_LP64(ShouldNotCallThis());
 1687   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1688   // TODO HS25: z port if (MatchDecodeNodes) return true;
 1689   return false;
 1690 }
 1691 
 1692 bool Matcher::const_oop_prefer_decode() {
 1693   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
<span class="line-modified"> 1694   return CompressedOops::base() == NULL;</span>
 1695 }
 1696 
 1697 bool Matcher::const_klass_prefer_decode() {
 1698   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified"> 1699   return CompressedKlassPointers::base() == NULL;</span>
 1700 }
 1701 
 1702 // Is it better to copy float constants, or load them directly from memory?
 1703 // Most RISCs will have to materialize an address into a
 1704 // register first, so they would do better to copy the constant from stack.
 1705 const bool Matcher::rematerialize_float_constants = false;
 1706 
 1707 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1708 // needed. Else we split the double into 2 integer pieces and move it
 1709 // piece-by-piece. Only happens when passing doubles into C code as the
 1710 // Java calling convention forces doubles to be aligned.
 1711 const bool Matcher::misaligned_doubles_ok = true;
 1712 
<span class="line-modified"> 1713 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>

 1714 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1715 
 1716 // Do floats take an entire double register or just half?
 1717 //
 1718 // A float in resides in a zarch double register. When storing it by
 1719 // z_std, it cannot be restored in C-code by reloading it as a double
 1720 // and casting it into a float afterwards.
 1721 bool Matcher::float_in_double() { return false; }
 1722 
 1723 // Do ints take an entire long register or just half?
 1724 // The relevant question is how the int is callee-saved:
 1725 // the whole long is written but de-opt&#39;ing will have to extract
 1726 // the relevant 32 bits.
 1727 const bool Matcher::int_in_long = true;
 1728 
 1729 // Constants for c2c and c calling conventions.
 1730 
 1731 const MachRegisterNumbers z_iarg_reg[5] = {
 1732   Z_R2_num, Z_R3_num, Z_R4_num, Z_R5_num, Z_R6_num
 1733 };
</pre>
<hr />
<pre>
 3407 operand rarg4RegN() %{
 3408   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3409   match(iRegN);
 3410   format %{ %}
 3411   interface(REG_INTER);
 3412 %}
 3413 
 3414 operand rarg5RegN() %{
 3415   constraint(ALLOC_IN_RC(z_rarg5_ptrN_reg));
 3416   match(iRegN);
 3417   format %{ %}
 3418   interface(REG_INTER);
 3419 %}
 3420 
 3421 // Long Register
 3422 operand iRegL() %{
 3423   constraint(ALLOC_IN_RC(z_long_reg));
 3424   match(RegL);
 3425   match(revenRegL);
 3426   match(roddRegL);
<span class="line-added"> 3427   match(allRoddRegL);</span>
 3428   match(rarg1RegL);
 3429   match(rarg5RegL);
 3430   format %{ %}
 3431   interface(REG_INTER);
 3432 %}
 3433 
 3434 // revenRegL and roddRegL constitute and even-odd-pair.
 3435 operand revenRegL() %{
 3436   constraint(ALLOC_IN_RC(z_rarg3_long_reg));
 3437   match(iRegL);
 3438   format %{ %}
 3439   interface(REG_INTER);
 3440 %}
 3441 
 3442 // revenRegL and roddRegL constitute and even-odd-pair.
 3443 operand roddRegL() %{
 3444   constraint(ALLOC_IN_RC(z_rarg4_long_reg));
 3445   match(iRegL);
 3446   format %{ %}
 3447   interface(REG_INTER);
 3448 %}
 3449 
<span class="line-added"> 3450 // available odd registers for iRegL</span>
<span class="line-added"> 3451 operand allRoddRegL() %{</span>
<span class="line-added"> 3452   constraint(ALLOC_IN_RC(z_long_odd_reg));</span>
<span class="line-added"> 3453   match(iRegL);</span>
<span class="line-added"> 3454   format %{ %}</span>
<span class="line-added"> 3455   interface(REG_INTER);</span>
<span class="line-added"> 3456 %}</span>
<span class="line-added"> 3457 </span>
 3458 operand rarg1RegL() %{
 3459   constraint(ALLOC_IN_RC(z_rarg1_long_reg));
 3460   match(iRegL);
 3461   format %{ %}
 3462   interface(REG_INTER);
 3463 %}
 3464 
 3465 operand rarg5RegL() %{
 3466   constraint(ALLOC_IN_RC(z_rarg5_long_reg));
 3467   match(iRegL);
 3468   format %{ %}
 3469   interface(REG_INTER);
 3470 %}
 3471 
 3472 // Condition Code Flag Registers
 3473 operand flagsReg() %{
 3474   constraint(ALLOC_IN_RC(z_condition_reg));
 3475   match(RegFlags);
 3476   format %{ &quot;CR&quot; %}
 3477   interface(REG_INTER);
</pre>
<hr />
<pre>
 3523   interface(REG_INTER);
 3524 %}
 3525 
 3526 operand compiler_method_oop_regP(iRegP reg) %{
 3527   constraint(ALLOC_IN_RC(z_r1_RegP)); // compiler_method_oop_reg
 3528   match(reg);
 3529   format %{ %}
 3530   interface(REG_INTER);
 3531 %}
 3532 
 3533 operand interpreter_method_oop_regP(iRegP reg) %{
 3534   constraint(ALLOC_IN_RC(z_r9_regP)); // interpreter_method_oop_reg
 3535   match(reg);
 3536   format %{ %}
 3537   interface(REG_INTER);
 3538 %}
 3539 
 3540 // Operands to remove register moves in unscaled mode.
 3541 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 3542 operand iRegP2N(iRegP reg) %{
<span class="line-modified"> 3543   predicate(CompressedOops::shift() == 0 &amp;&amp; _leaf-&gt;as_EncodeP()-&gt;in(0) == NULL);</span>
 3544   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3545   match(EncodeP reg);
 3546   format %{ &quot;$reg&quot; %}
 3547   interface(REG_INTER)
 3548 %}
 3549 
 3550 operand iRegN2P(iRegN reg) %{
<span class="line-modified"> 3551   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0 &amp;&amp;</span>
 3552             _leaf-&gt;as_DecodeN()-&gt;in(0) == NULL);
 3553   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3554   match(DecodeN reg);
 3555   format %{ &quot;$reg&quot; %}
 3556   interface(REG_INTER)
 3557 %}
 3558 
 3559 
 3560 //----------Complex Operands---------------------------------------------------
 3561 
 3562 // Indirect Memory Reference
 3563 operand indirect(memoryRegP base) %{
 3564   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3565   match(base);
 3566   op_cost(1);
 3567   format %{ &quot;#0[,$base]&quot; %}
 3568   interface(MEMORY_INTER) %{
 3569     base($base);
 3570     index(0xffffFFFF); // noreg
 3571     scale(0x0);
</pre>
<hr />
<pre>
 4334 // Load Double - UNaligned
 4335 instruct loadD_unaligned(regD dst, memory mem) %{
 4336   match(Set dst (LoadD_unaligned mem));
 4337   ins_cost(MEMORY_REF_COST);
 4338   size(Z_DISP_SIZE);
 4339   format %{ &quot;LD(Y)    $dst,$mem&quot; %}
 4340   opcode(LDY_ZOPC, LD_ZOPC);
 4341   ins_encode(z_form_rt_mem_opt(dst, mem));
 4342   ins_pipe(pipe_class_dummy);
 4343 %}
 4344 
 4345 
 4346 //----------------------
 4347 //  IMMEDIATES
 4348 //----------------------
 4349 
 4350 instruct loadConI(iRegI dst, immI src) %{
 4351   match(Set dst src);
 4352   ins_cost(DEFAULT_COST);
 4353   size(6);
<span class="line-modified"> 4354   format %{ &quot;LGFI    $dst,$src\t # (int)&quot; %}</span>
 4355   ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4356   ins_pipe(pipe_class_dummy);
 4357 %}
 4358 
 4359 instruct loadConI16(iRegI dst, immI16 src) %{
 4360   match(Set dst src);
 4361   ins_cost(DEFAULT_COST_LOW);
 4362   size(4);
<span class="line-modified"> 4363   format %{ &quot;LGHI    $dst,$src\t # (int)&quot; %}</span>
 4364   ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4365   ins_pipe(pipe_class_dummy);
 4366 %}
 4367 
 4368 instruct loadConI_0(iRegI dst, immI_0 src, flagsReg cr) %{
 4369   match(Set dst src);
 4370   effect(KILL cr);
 4371   ins_cost(DEFAULT_COST_LOW);
 4372   size(4);
 4373   format %{ &quot;loadConI $dst,$src\t # (int) XGR because ZERO is loaded&quot; %}
 4374   opcode(XGR_ZOPC);
 4375   ins_encode(z_rreform(dst, dst));
 4376   ins_pipe(pipe_class_dummy);
 4377 %}
 4378 
 4379 instruct loadConUI16(iRegI dst, uimmI16 src) %{
 4380   match(Set dst src);
 4381   // TODO: s390 port size(FIXED_SIZE);
 4382   format %{ &quot;LLILL    $dst,$src&quot; %}
 4383   opcode(LLILL_ZOPC);
</pre>
<hr />
<pre>
 4739 // See cOop encoding classes for elaborate comment.
 4740 
 4741 // Moved here because it is needed in expand rules for encode.
 4742 // Long negation.
 4743 instruct negL_reg_reg(iRegL dst, immL_0 zero, iRegL src, flagsReg cr) %{
 4744   match(Set dst (SubL zero src));
 4745   effect(KILL cr);
 4746   size(4);
 4747   format %{ &quot;NEG     $dst, $src\t # long&quot; %}
 4748   ins_encode %{ __ z_lcgr($dst$$Register, $src$$Register); %}
 4749   ins_pipe(pipe_class_dummy);
 4750 %}
 4751 
 4752 // Load Compressed Pointer
 4753 
 4754 // Load narrow oop
 4755 instruct loadN(iRegN dst, memory mem) %{
 4756   match(Set dst (LoadN mem));
 4757   ins_cost(MEMORY_REF_COST);
 4758   size(Z_DISP3_SIZE);
<span class="line-modified"> 4759   format %{ &quot;LoadN   $dst,$mem\t # (cOop)&quot; %}</span>
 4760   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4761   ins_encode(z_form_rt_mem_opt(dst, mem));
 4762   ins_pipe(pipe_class_dummy);
 4763 %}
 4764 
 4765 // Load narrow Klass Pointer
 4766 instruct loadNKlass(iRegN dst, memory mem) %{
 4767   match(Set dst (LoadNKlass mem));
 4768   ins_cost(MEMORY_REF_COST);
 4769   size(Z_DISP3_SIZE);
<span class="line-modified"> 4770   format %{ &quot;LoadNKlass $dst,$mem\t # (klass cOop)&quot; %}</span>
 4771   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4772   ins_encode(z_form_rt_mem_opt(dst, mem));
 4773   ins_pipe(pipe_class_dummy);
 4774 %}
 4775 
 4776 // Load constant Compressed Pointer
 4777 
 4778 instruct loadConN(iRegN dst, immN src) %{
 4779   match(Set dst src);
 4780   ins_cost(DEFAULT_COST);
 4781   size(6);
 4782   format %{ &quot;loadConN    $dst,$src\t # (cOop)&quot; %}
 4783   ins_encode %{
 4784     AddressLiteral cOop = __ constant_oop_address((jobject)$src$$constant);
 4785     __ relocate(cOop.rspec(), 1);
 4786     __ load_narrow_oop($dst$$Register, (narrowOop)cOop.value());
 4787   %}
 4788   ins_pipe(pipe_class_dummy);
 4789 %}
 4790 
</pre>
<hr />
<pre>
 4800 %}
 4801 
 4802 instruct loadConNKlass(iRegN dst, immNKlass src) %{
 4803   match(Set dst src);
 4804   ins_cost(DEFAULT_COST);
 4805   size(6);
 4806   format %{ &quot;loadConNKlass $dst,$src\t # (cKlass)&quot; %}
 4807   ins_encode %{
 4808     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4809     __ relocate(NKlass.rspec(), 1);
 4810     __ load_narrow_klass($dst$$Register, (Klass*)NKlass.value());
 4811   %}
 4812   ins_pipe(pipe_class_dummy);
 4813 %}
 4814 
 4815 // Load and Decode Compressed Pointer
 4816 // optimized variants for Unscaled cOops
 4817 
 4818 instruct decodeLoadN(iRegP dst, memory mem) %{
 4819   match(Set dst (DecodeN (LoadN mem)));
<span class="line-modified"> 4820   predicate(false &amp;&amp; (CompressedOops::base()==NULL)&amp;&amp;(CompressedOops::shift()==0));</span>
 4821   ins_cost(MEMORY_REF_COST);
 4822   size(Z_DISP3_SIZE);
<span class="line-modified"> 4823   format %{ &quot;DecodeLoadN  $dst,$mem\t # (cOop Load+Decode)&quot; %}</span>
 4824   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4825   ins_encode(z_form_rt_mem_opt(dst, mem));
 4826   ins_pipe(pipe_class_dummy);
 4827 %}
 4828 
 4829 instruct decodeLoadNKlass(iRegP dst, memory mem) %{
 4830   match(Set dst (DecodeNKlass (LoadNKlass mem)));
<span class="line-modified"> 4831   predicate(false &amp;&amp; (CompressedKlassPointers::base()==NULL)&amp;&amp;(CompressedKlassPointers::shift()==0));</span>
 4832   ins_cost(MEMORY_REF_COST);
 4833   size(Z_DISP3_SIZE);
<span class="line-modified"> 4834   format %{ &quot;DecodeLoadNKlass  $dst,$mem\t # (load/decode NKlass)&quot; %}</span>
 4835   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4836   ins_encode(z_form_rt_mem_opt(dst, mem));
 4837   ins_pipe(pipe_class_dummy);
 4838 %}
 4839 
 4840 instruct decodeLoadConNKlass(iRegP dst, immNKlass src) %{
 4841   match(Set dst (DecodeNKlass src));
 4842   ins_cost(3 * DEFAULT_COST);
 4843   size(12);
 4844   format %{ &quot;DecodeLoadConNKlass  $dst,$src\t # decode(cKlass)&quot; %}
 4845   ins_encode %{
 4846     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4847     __ relocate(NKlass.rspec(), 1);
 4848     __ load_const($dst$$Register, (Klass*)NKlass.value());
 4849   %}
 4850   ins_pipe(pipe_class_dummy);
 4851 %}
 4852 
 4853 // Decode Compressed Pointer
 4854 
 4855 // General decoder
 4856 instruct decodeN(iRegP dst, iRegN src, flagsReg cr) %{
 4857   match(Set dst (DecodeN src));
 4858   effect(KILL cr);
<span class="line-modified"> 4859   predicate(CompressedOops::base() == NULL || !ExpandLoadingBaseDecode);</span>
 4860   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4861   // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4862   format %{ &quot;decodeN  $dst,$src\t # (decode cOop)&quot; %}</span>
 4863   ins_encode %{  __ oop_decoder($dst$$Register, $src$$Register, true); %}
 4864   ins_pipe(pipe_class_dummy);
 4865 %}
 4866 
 4867 // General Klass decoder
 4868 instruct decodeKlass(iRegP dst, iRegN src, flagsReg cr) %{
 4869   match(Set dst (DecodeNKlass src));
 4870   effect(KILL cr);
 4871   ins_cost(3 * DEFAULT_COST);
 4872   format %{ &quot;decode_klass $dst,$src&quot; %}
 4873   ins_encode %{ __ decode_klass_not_null($dst$$Register, $src$$Register); %}
 4874   ins_pipe(pipe_class_dummy);
 4875 %}
 4876 
 4877 // General decoder
 4878 instruct decodeN_NN(iRegP dst, iRegN src, flagsReg cr) %{
 4879   match(Set dst (DecodeN src));
 4880   effect(KILL cr);
 4881   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4882              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified"> 4883             (CompressedOops::base()== NULL || !ExpandLoadingBaseDecode_NN));</span>
 4884   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4885   // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4886   format %{ &quot;decodeN  $dst,$src\t # (decode cOop NN)&quot; %}</span>
 4887   ins_encode %{ __ oop_decoder($dst$$Register, $src$$Register, false); %}
 4888   ins_pipe(pipe_class_dummy);
 4889 %}
 4890 
 4891   instruct loadBase(iRegL dst, immL baseImm) %{
 4892     effect(DEF dst, USE baseImm);
 4893     predicate(false);
 4894     format %{ &quot;llihl    $dst=$baseImm \t// load heap base&quot; %}
 4895     ins_encode %{ __ get_oop_base($dst$$Register, $baseImm$$constant); %}
 4896     ins_pipe(pipe_class_dummy);
 4897   %}
 4898 
 4899   // Decoder for heapbased mode peeling off loading the base.
 4900   instruct decodeN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4901     match(Set dst (DecodeN src base));
 4902     // Note: Effect TEMP dst was used with the intention to get
 4903     // different regs for dst and base, but this has caused ADLC to
 4904     // generate wrong code. Oop_decoder generates additional lgr when
 4905     // dst==base.
 4906     effect(KILL cr);
 4907     predicate(false);
 4908     // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4909     format %{ &quot;decodeN  $dst = ($src == 0) ? NULL : ($src &lt;&lt; 3) + $base + pow2_offset\t # (decode cOop)&quot; %}</span>
 4910     ins_encode %{
 4911       __ oop_decoder($dst$$Register, $src$$Register, true, $base$$Register,
<span class="line-modified"> 4912                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)CompressedOops::base()));</span>
 4913     %}
 4914     ins_pipe(pipe_class_dummy);
 4915   %}
 4916 
 4917   // Decoder for heapbased mode peeling off loading the base.
 4918   instruct decodeN_NN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4919     match(Set dst (DecodeN src base));
 4920     effect(KILL cr);
 4921     predicate(false);
 4922     // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4923     format %{ &quot;decodeN  $dst = ($src &lt;&lt; 3) + $base + pow2_offset\t # (decode cOop)&quot; %}</span>
 4924     ins_encode %{
 4925       __ oop_decoder($dst$$Register, $src$$Register, false, $base$$Register,
<span class="line-modified"> 4926                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)CompressedOops::base()));</span>
 4927     %}
 4928     ins_pipe(pipe_class_dummy);
 4929   %}
 4930 
 4931 // Decoder for heapbased mode peeling off loading the base.
 4932 instruct decodeN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4933   match(Set dst (DecodeN src));
<span class="line-modified"> 4934   predicate(CompressedOops::base() != NULL &amp;&amp; ExpandLoadingBaseDecode);</span>
 4935   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4936   // TODO: s390 port size(VARIABLE_SIZE);
 4937   expand %{
<span class="line-modified"> 4938     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}</span>
 4939     iRegL base;
 4940     loadBase(base, baseImm);
 4941     decodeN_base(dst, src, base, cr);
 4942   %}
 4943 %}
 4944 
 4945 // Decoder for heapbased mode peeling off loading the base.
 4946 instruct decodeN_NN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4947   match(Set dst (DecodeN src));
 4948   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4949              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified"> 4950             CompressedOops::base() != NULL &amp;&amp; ExpandLoadingBaseDecode_NN);</span>
 4951   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4952   // TODO: s390 port size(VARIABLE_SIZE);
 4953   expand %{
<span class="line-modified"> 4954     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}</span>
 4955     iRegL base;
 4956     loadBase(base, baseImm);
 4957     decodeN_NN_base(dst, src, base, cr);
 4958   %}
 4959 %}
 4960 
 4961 //  Encode Compressed Pointer
 4962 
 4963 // General encoder
 4964 instruct encodeP(iRegN dst, iRegP src, flagsReg cr) %{
 4965   match(Set dst (EncodeP src));
 4966   effect(KILL cr);
 4967   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
<span class="line-modified"> 4968             (CompressedOops::base() == 0 ||</span>
<span class="line-modified"> 4969              CompressedOops::base_disjoint() ||</span>
 4970              !ExpandLoadingBaseEncode));
 4971   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4972   // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4973   format %{ &quot;encodeP  $dst,$src\t # (encode cOop)&quot; %}</span>
 4974   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, true, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 4975   ins_pipe(pipe_class_dummy);
 4976 %}
 4977 
 4978 // General class encoder
 4979 instruct encodeKlass(iRegN dst, iRegP src, flagsReg cr) %{
 4980   match(Set dst (EncodePKlass src));
 4981   effect(KILL cr);
 4982   format %{ &quot;encode_klass $dst,$src&quot; %}
 4983   ins_encode %{ __ encode_klass_not_null($dst$$Register, $src$$Register); %}
 4984   ins_pipe(pipe_class_dummy);
 4985 %}
 4986 
 4987 instruct encodeP_NN(iRegN dst, iRegP src, flagsReg cr) %{
 4988   match(Set dst (EncodeP src));
 4989   effect(KILL cr);
 4990   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
<span class="line-modified"> 4991             (CompressedOops::base() == 0 ||</span>
<span class="line-modified"> 4992              CompressedOops::base_disjoint() ||</span>
 4993              !ExpandLoadingBaseEncode_NN));
 4994   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4995   // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 4996   format %{ &quot;encodeP  $dst,$src\t # (encode cOop)&quot; %}</span>
 4997   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 4998   ins_pipe(pipe_class_dummy);
 4999 %}
 5000 
 5001   // Encoder for heapbased mode peeling off loading the base.
 5002   instruct encodeP_base(iRegN dst, iRegP src, iRegL base) %{
 5003     match(Set dst (EncodeP src (Binary base dst)));
 5004     effect(TEMP_DEF dst);
 5005     predicate(false);
 5006     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 5007     // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 5008     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + pow2_offset\t # (encode cOop)&quot; %}</span>
 5009     ins_encode %{
 5010       jlong offset = -(jlong)MacroAssembler::get_oop_base_pow2_offset
<span class="line-modified"> 5011         (((uint64_t)(intptr_t)CompressedOops::base()) &gt;&gt; CompressedOops::shift());</span>
 5012       __ oop_encoder($dst$$Register, $src$$Register, true, $base$$Register, offset);
 5013     %}
 5014     ins_pipe(pipe_class_dummy);
 5015   %}
 5016 
 5017   // Encoder for heapbased mode peeling off loading the base.
 5018   instruct encodeP_NN_base(iRegN dst, iRegP src, iRegL base, immL pow2_offset) %{
 5019     match(Set dst (EncodeP src base));
 5020     effect(USE pow2_offset);
 5021     predicate(false);
 5022     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 5023     // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified"> 5024     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + $pow2_offset\t # (encode cOop)&quot; %}</span>
 5025     ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, $base$$Register, $pow2_offset$$constant); %}
 5026     ins_pipe(pipe_class_dummy);
 5027   %}
 5028 
 5029 // Encoder for heapbased mode peeling off loading the base.
 5030 instruct encodeP_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 5031   match(Set dst (EncodeP src));
 5032   effect(KILL cr);
 5033   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
<span class="line-modified"> 5034             (CompressedOops::base_overlaps() &amp;&amp; ExpandLoadingBaseEncode));</span>
 5035   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5036   // TODO: s390 port size(VARIABLE_SIZE);
 5037   expand %{
<span class="line-modified"> 5038     immL baseImm %{ ((jlong)(intptr_t)CompressedOops::base()) &gt;&gt; CompressedOops::shift() %}</span>
 5039     immL_0 zero %{ (0) %}
 5040     flagsReg ccr;
 5041     iRegL base;
 5042     iRegL negBase;
 5043     loadBase(base, baseImm);
 5044     negL_reg_reg(negBase, zero, base, ccr);
 5045     encodeP_base(dst, src, negBase);
 5046   %}
 5047 %}
 5048 
 5049 // Encoder for heapbased mode peeling off loading the base.
 5050 instruct encodeP_NN_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 5051   match(Set dst (EncodeP src));
 5052   effect(KILL cr);
 5053   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
<span class="line-modified"> 5054             (CompressedOops::base_overlaps() &amp;&amp; ExpandLoadingBaseEncode_NN));</span>
 5055   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5056   // TODO: s390 port size(VARIABLE_SIZE);
 5057   expand %{
<span class="line-modified"> 5058     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}</span>
<span class="line-modified"> 5059     immL pow2_offset %{ -(jlong)MacroAssembler::get_oop_base_pow2_offset(((uint64_t)(intptr_t)CompressedOops::base())) %}</span>
 5060     immL_0 zero %{ 0 %}
 5061     flagsReg ccr;
 5062     iRegL base;
 5063     iRegL negBase;
 5064     loadBase(base, baseImm);
 5065     negL_reg_reg(negBase, zero, base, ccr);
 5066     encodeP_NN_base(dst, src, negBase, pow2_offset);
 5067   %}
 5068 %}
 5069 
 5070 //  Store Compressed Pointer
 5071 
 5072 // Store Compressed Pointer
 5073 instruct storeN(memory mem, iRegN_P2N src) %{
 5074   match(Set mem (StoreN mem src));
 5075   ins_cost(MEMORY_REF_COST);
 5076   size(Z_DISP_SIZE);
<span class="line-modified"> 5077   format %{ &quot;ST      $src,$mem\t # (cOop)&quot; %}</span>
 5078   opcode(STY_ZOPC, ST_ZOPC);
 5079   ins_encode(z_form_rt_mem_opt(src, mem));
 5080   ins_pipe(pipe_class_dummy);
 5081 %}
 5082 
 5083 // Store Compressed Klass pointer
 5084 instruct storeNKlass(memory mem, iRegN src) %{
 5085   match(Set mem (StoreNKlass mem src));
 5086   ins_cost(MEMORY_REF_COST);
 5087   size(Z_DISP_SIZE);
<span class="line-modified"> 5088   format %{ &quot;ST      $src,$mem\t # (cKlass)&quot; %}</span>
 5089   opcode(STY_ZOPC, ST_ZOPC);
 5090   ins_encode(z_form_rt_mem_opt(src, mem));
 5091   ins_pipe(pipe_class_dummy);
 5092 %}
 5093 
 5094 // Compare Compressed Pointers
 5095 
 5096 instruct compN_iRegN(iRegN_P2N src1, iRegN_P2N src2, flagsReg cr) %{
 5097   match(Set cr (CmpN src1 src2));
 5098   ins_cost(DEFAULT_COST);
 5099   size(2);
<span class="line-modified"> 5100   format %{ &quot;CLR     $src1,$src2\t # (cOop)&quot; %}</span>
 5101   opcode(CLR_ZOPC);
 5102   ins_encode(z_rrform(src1, src2));
 5103   ins_pipe(pipe_class_dummy);
 5104 %}
 5105 
 5106 instruct compN_iRegN_immN(iRegN_P2N src1, immN src2, flagsReg cr) %{
 5107   match(Set cr (CmpN src1 src2));
 5108   ins_cost(DEFAULT_COST);
 5109   size(6);
<span class="line-modified"> 5110   format %{ &quot;CLFI    $src1,$src2\t # (cOop) compare immediate narrow&quot; %}</span>
 5111   ins_encode %{
 5112     AddressLiteral cOop = __ constant_oop_address((jobject)$src2$$constant);
 5113     __ relocate(cOop.rspec(), 1);
 5114     __ compare_immediate_narrow_oop($src1$$Register, (narrowOop)cOop.value());
 5115   %}
 5116   ins_pipe(pipe_class_dummy);
 5117 %}
 5118 
 5119 instruct compNKlass_iRegN_immN(iRegN src1, immNKlass src2, flagsReg cr) %{
 5120   match(Set cr (CmpN src1 src2));
 5121   ins_cost(DEFAULT_COST);
 5122   size(6);
<span class="line-modified"> 5123   format %{ &quot;CLFI    $src1,$src2\t # (NKlass) compare immediate narrow&quot; %}</span>
 5124   ins_encode %{
 5125     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src2$$constant);
 5126     __ relocate(NKlass.rspec(), 1);
 5127     __ compare_immediate_narrow_klass($src1$$Register, (Klass*)NKlass.value());
 5128   %}
 5129   ins_pipe(pipe_class_dummy);
 5130 %}
 5131 
 5132 instruct compN_iRegN_immN0(iRegN_P2N src1, immN0 src2, flagsReg cr) %{
 5133   match(Set cr (CmpN src1 src2));
 5134   ins_cost(DEFAULT_COST);
 5135   size(2);
<span class="line-modified"> 5136   format %{ &quot;LTR     $src1,$src2\t # (cOop) LTR because comparing against zero&quot; %}</span>
 5137   opcode(LTR_ZOPC);
 5138   ins_encode(z_rrform(src1, src1));
 5139   ins_pipe(pipe_class_dummy);
 5140 %}
 5141 
 5142 
 5143 //----------MemBar Instructions-----------------------------------------------
 5144 
 5145 // Memory barrier flavors
 5146 
 5147 instruct membar_acquire() %{
 5148   match(MemBarAcquire);
 5149   match(LoadFence);
 5150   ins_cost(4*MEMORY_REF_COST);
 5151   size(0);
 5152   format %{ &quot;MEMBAR-acquire&quot; %}
 5153   ins_encode %{ __ z_acquire(); %}
 5154   ins_pipe(pipe_class_dummy);
 5155 %}
 5156 
</pre>
<hr />
<pre>
 5409   ins_encode(/*empty*/);
 5410   ins_pipe(pipe_class_dummy);
 5411 %}
 5412 
 5413 instruct castPP(iRegP dst) %{
 5414   match(Set dst (CastPP dst));
 5415   size(0);
 5416   format %{ &quot;# castPP of $dst&quot; %}
 5417   ins_encode(/*empty*/);
 5418   ins_pipe(pipe_class_dummy);
 5419 %}
 5420 
 5421 instruct castII(iRegI dst) %{
 5422   match(Set dst (CastII dst));
 5423   size(0);
 5424   format %{ &quot;# castII of $dst&quot; %}
 5425   ins_encode(/*empty*/);
 5426   ins_pipe(pipe_class_dummy);
 5427 %}
 5428 
<span class="line-added"> 5429 instruct castLL(iRegL dst) %{</span>
<span class="line-added"> 5430   match(Set dst (CastLL dst));</span>
<span class="line-added"> 5431   size(0);</span>
<span class="line-added"> 5432   format %{ &quot;# castLL of $dst&quot; %}</span>
<span class="line-added"> 5433   ins_encode(/*empty*/);</span>
<span class="line-added"> 5434   ins_pipe(pipe_class_dummy);</span>
<span class="line-added"> 5435 %}</span>
<span class="line-added"> 5436 </span>
 5437 
 5438 //----------Conditional_store--------------------------------------------------
 5439 // Conditional-store of the updated heap-top.
 5440 // Used during allocation of the shared heap.
 5441 // Sets flags (EQ) on success.
 5442 
 5443 // Implement LoadPLocked. Must be ordered against changes of the memory location
 5444 // by storePConditional.
 5445 // Don&#39;t know whether this is ever used.
 5446 instruct loadPLocked(iRegP dst, memory mem) %{
 5447   match(Set dst (LoadPLocked mem));
 5448   ins_cost(MEMORY_REF_COST);
 5449   size(Z_DISP3_SIZE);
 5450   format %{ &quot;LG      $dst,$mem\t # LoadPLocked&quot; %}
 5451   opcode(LG_ZOPC, LG_ZOPC);
 5452   ins_encode(z_form_rt_mem_opt(dst, mem));
 5453   ins_pipe(pipe_class_dummy);
 5454 %}
 5455 
 5456 // As compareAndSwapP, but return flag register instead of boolean value in
</pre>
<hr />
<pre>
 6233   opcode(AGFI_ZOPC);
 6234   ins_encode(z_rilform_signed(dst, src));
 6235   ins_pipe(pipe_class_dummy);
 6236 %}
 6237 
 6238 // REG = REG1 + REG2 + IMM
 6239 
 6240 instruct addP_reg_reg_imm12(iRegP dst, memoryRegP src1, iRegL src2, uimmL12 con) %{
 6241   match(Set dst (AddP (AddP src1 src2) con));
 6242   predicate( PreferLAoverADD);
 6243   ins_cost(DEFAULT_COST_LOW);
 6244   size(4);
 6245   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6246   opcode(LA_ZOPC);
 6247   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6248   ins_pipe(pipe_class_dummy);
 6249 %}
 6250 
 6251 instruct addP_regN_reg_imm12(iRegP dst, iRegP_N2P src1, iRegL src2, uimmL12 con) %{
 6252   match(Set dst (AddP (AddP src1 src2) con));
<span class="line-modified"> 6253   predicate( PreferLAoverADD &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);</span>
 6254   ins_cost(DEFAULT_COST_LOW);
 6255   size(4);
 6256   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6257   opcode(LA_ZOPC);
 6258   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6259   ins_pipe(pipe_class_dummy);
 6260 %}
 6261 
 6262 instruct addP_reg_reg_imm20(iRegP dst, memoryRegP src1, iRegL src2, immL20 con) %{
 6263   match(Set dst (AddP (AddP src1 src2) con));
 6264   predicate(PreferLAoverADD);
 6265   ins_cost(DEFAULT_COST);
 6266   // TODO: s390 port size(FIXED_SIZE);
 6267   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6268   opcode(LAY_ZOPC);
 6269   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6270   ins_pipe(pipe_class_dummy);
 6271 %}
 6272 
 6273 instruct addP_regN_reg_imm20(iRegP dst, iRegP_N2P src1, iRegL src2, immL20 con) %{
 6274   match(Set dst (AddP (AddP src1 src2) con));
<span class="line-modified"> 6275   predicate( PreferLAoverADD &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);</span>
 6276   ins_cost(DEFAULT_COST);
 6277   // TODO: s390 port size(FIXED_SIZE);
 6278   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6279   opcode(LAY_ZOPC);
 6280   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6281   ins_pipe(pipe_class_dummy);
 6282 %}
 6283 
 6284 // MEM = MEM + IMM
 6285 
 6286 // Add Immediate to 8-byte memory operand and result
 6287 instruct addP_mem_imm(memoryRSY mem, immL8 src, flagsReg cr) %{
 6288   match(Set mem (StoreP mem (AddP (LoadP mem) src)));
 6289   effect(KILL cr);
 6290   predicate(VM_Version::has_MemWithImmALUOps());
 6291   ins_cost(MEMORY_REF_COST);
 6292   size(6);
 6293   format %{ &quot;AGSI    $mem,$src\t # direct mem add 8 (ptr)&quot; %}
 6294   opcode(AGSI_ZOPC);
 6295   ins_encode(z_siyform(mem, src));
</pre>
<hr />
<pre>
 6819       __ z_lghi(Z_R0_scratch, divisor);
 6820       __ z_lgr($dst$$Register-&gt;successor(), $src1$$Register);
 6821       __ z_dsgr($dst$$Register /* Dst is even part of a register pair. */, Z_R0_scratch);  // Instruction kills tmp.
 6822     } else {
 6823       __ clear_reg($dst$$Register, true, false);
 6824     }
 6825   %}
 6826   ins_pipe(pipe_class_dummy);
 6827 %}
 6828 
 6829 // SHIFT
 6830 
 6831 // Shift left logical
 6832 
 6833 // Register Shift Left variable
 6834 instruct sllI_reg_reg(iRegI dst, iRegI src, iRegI nbits, flagsReg cr) %{
 6835   match(Set dst (LShiftI src nbits));
 6836   effect(KILL cr); // R1 is killed, too.
 6837   ins_cost(3 * DEFAULT_COST);
 6838   size(14);
<span class="line-modified"> 6839   format %{ &quot;SLL     $dst,$src,[$nbits] &amp; 31\t # use RISC-like SLLG also for int&quot; %}</span>
 6840   ins_encode %{
 6841     __ z_lgr(Z_R1_scratch, $nbits$$Register);
 6842     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6843     __ z_sllg($dst$$Register, $src$$Register, 0, Z_R1_scratch);
 6844   %}
 6845   ins_pipe(pipe_class_dummy);
 6846 %}
 6847 
 6848 // Register Shift Left Immediate
 6849 // Constant shift count is masked in ideal graph already.
 6850 instruct sllI_reg_imm(iRegI dst, iRegI src, immI nbits) %{
 6851   match(Set dst (LShiftI src nbits));
 6852   size(6);
<span class="line-modified"> 6853   format %{ &quot;SLL     $dst,$src,$nbits\t # use RISC-like SLLG also for int&quot; %}</span>
 6854   ins_encode %{
 6855     int Nbit = $nbits$$constant;
 6856     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6857     __ z_sllg($dst$$Register, $src$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6858   %}
 6859   ins_pipe(pipe_class_dummy);
 6860 %}
 6861 
 6862 // Register Shift Left Immediate by 1bit
 6863 instruct sllI_reg_imm_1(iRegI dst, iRegI src, immI_1 nbits) %{
 6864   match(Set dst (LShiftI src nbits));
 6865   predicate(PreferLAoverADD);
 6866   ins_cost(DEFAULT_COST_LOW);
 6867   size(4);
 6868   format %{ &quot;LA      $dst,#0($src,$src)\t # SLL by 1 (int)&quot; %}
 6869   ins_encode %{ __ z_la($dst$$Register, 0, $src$$Register, $src$$Register); %}
 6870   ins_pipe(pipe_class_dummy);
 6871 %}
 6872 
 6873 // Register Shift Left Long
</pre>
<hr />
<pre>
 7149   %}
 7150   ins_pipe(pipe_class_dummy);
 7151 %}
 7152 
 7153 instruct overflowSubL_reg_imm(flagsReg cr, iRegL op1, immL op2) %{
 7154   match(Set cr (OverflowSubL op1 op2));
 7155   effect(DEF cr, USE op1, USE op2);
 7156   // TODO: s390 port size(VARIABLE_SIZE);
 7157   format %{ &quot;SGR     $op1,$op2\t # overflow check long&quot; %}
 7158   ins_encode %{
 7159     __ load_const_optimized(Z_R1_scratch, $op2$$constant);
 7160     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7161     __ z_sgr(Z_R0_scratch, Z_R1_scratch);
 7162   %}
 7163   ins_pipe(pipe_class_dummy);
 7164 %}
 7165 
 7166 instruct overflowNegI_rReg(flagsReg cr, immI_0 zero, iRegI op2) %{
 7167   match(Set cr (OverflowSubI zero op2));
 7168   effect(DEF cr, USE op2);
<span class="line-modified"> 7169   format %{ &quot;NEG    $op2\t # overflow check int&quot; %}</span>
 7170   ins_encode %{
 7171     __ clear_reg(Z_R0_scratch, false, false);
 7172     __ z_sr(Z_R0_scratch, $op2$$Register);
 7173   %}
 7174   ins_pipe(pipe_class_dummy);
 7175 %}
 7176 
 7177 instruct overflowNegL_rReg(flagsReg cr, immL_0 zero, iRegL op2) %{
 7178   match(Set cr (OverflowSubL zero op2));
 7179   effect(DEF cr, USE op2);
<span class="line-modified"> 7180   format %{ &quot;NEGG    $op2\t # overflow check long&quot; %}</span>
 7181   ins_encode %{
 7182     __ clear_reg(Z_R0_scratch, true, false);
 7183     __ z_sgr(Z_R0_scratch, $op2$$Register);
 7184   %}
 7185   ins_pipe(pipe_class_dummy);
 7186 %}
 7187 
 7188 // No intrinsics for multiplication, since there is no easy way
 7189 // to check for overflow.
 7190 
 7191 
 7192 //----------Floating Point Arithmetic Instructions-----------------------------
 7193 
 7194 //  ADD
 7195 
 7196 //  Add float single precision
 7197 instruct addF_reg_reg(regF dst, regF src, flagsReg cr) %{
 7198   match(Set dst (AddF dst src));
 7199   effect(KILL cr);
 7200   ins_cost(ALU_REG_COST);
</pre>
<hr />
<pre>
 8579   size(4);
 8580   format %{ &quot;CLGR    $op1,$op2\t # ptr&quot; %}
 8581   opcode(CLGR_ZOPC);
 8582   ins_encode(z_rreform(op1, op2));
 8583   ins_pipe(pipe_class_dummy);
 8584 %}
 8585 
 8586 instruct compP_reg_imm0(flagsReg cr, iRegP_N2P op1, immP0 op2) %{
 8587   match(Set cr (CmpP op1 op2));
 8588   ins_cost(DEFAULT_COST_LOW);
 8589   size(4);
 8590   format %{ &quot;LTGR    $op1, $op1\t # ptr&quot; %}
 8591   opcode(LTGR_ZOPC);
 8592   ins_encode(z_rreform(op1, op1));
 8593   ins_pipe(pipe_class_dummy);
 8594 %}
 8595 
 8596 // Don&#39;t use LTGFR which performs sign extend.
 8597 instruct compP_decode_reg_imm0(flagsReg cr, iRegN op1, immP0 op2) %{
 8598   match(Set cr (CmpP (DecodeN op1) op2));
<span class="line-modified"> 8599   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);</span>
 8600   ins_cost(DEFAULT_COST_LOW);
 8601   size(2);
 8602   format %{ &quot;LTR    $op1, $op1\t # ptr&quot; %}
 8603   opcode(LTR_ZOPC);
 8604   ins_encode(z_rrform(op1, op1));
 8605   ins_pipe(pipe_class_dummy);
 8606 %}
 8607 
 8608 instruct compP_reg_mem(iRegP dst, memory src, flagsReg cr)%{
 8609   match(Set cr (CmpP dst (LoadP src)));
 8610   ins_cost(MEMORY_REF_COST);
 8611   size(Z_DISP3_SIZE);
 8612   format %{ &quot;CLG     $dst, $src\t # ptr&quot; %}
 8613   opcode(CLG_ZOPC, CLG_ZOPC);
 8614   ins_encode(z_form_rt_mem_opt(dst, src));
 8615   ins_pipe(pipe_class_dummy);
 8616 %}
 8617 
 8618 //----------Max and Min--------------------------------------------------------
 8619 
</pre>
<hr />
<pre>
 9215 // Direct Branch.
 9216 instruct branchFar(label labl) %{
 9217   match(Goto);
 9218   effect(USE labl);
 9219   ins_cost(BRANCH_COST);
 9220   size(6);
 9221   format %{ &quot;BRUL   $labl&quot; %}
 9222   ins_encode(z_enc_brul(labl));
 9223   ins_pipe(pipe_class_dummy);
 9224   // This is not a short variant of a branch, but the long variant.
 9225   ins_short_branch(0);
 9226 %}
 9227 
 9228 // Conditional Near Branch
 9229 instruct branchCon(cmpOp cmp, flagsReg cr, label lbl) %{
 9230   // Same match rule as `branchConFar&#39;.
 9231   match(If cmp cr);
 9232   effect(USE lbl);
 9233   ins_cost(BRANCH_COST);
 9234   size(4);
<span class="line-modified"> 9235   format %{ &quot;branch_con_short,$cmp   $lbl&quot; %}</span>
 9236   ins_encode(z_enc_branch_con_short(cmp, lbl));
 9237   ins_pipe(pipe_class_dummy);
 9238   // If set to 1 this indicates that the current instruction is a
 9239   // short variant of a long branch. This avoids using this
 9240   // instruction in first-pass matching. It will then only be used in
 9241   // the `Shorten_branches&#39; pass.
 9242   ins_short_branch(1);
 9243 %}
 9244 
 9245 // This is for cases when the z/Architecture conditional branch instruction
 9246 // does not reach far enough. So we emit a far branch here, which is
 9247 // more expensive.
 9248 //
 9249 // Conditional Far Branch
 9250 instruct branchConFar(cmpOp cmp, flagsReg cr, label lbl) %{
 9251   // Same match rule as `branchCon&#39;.
 9252   match(If cmp cr);
 9253   effect(USE cr, USE lbl);
 9254   // Make more expensive to prefer compare_and_branch over separate instructions.
 9255   ins_cost(2 * BRANCH_COST);
 9256   size(6);
<span class="line-modified"> 9257   format %{ &quot;branch_con_far,$cmp   $lbl&quot; %}</span>
 9258   ins_encode(z_enc_branch_con_far(cmp, lbl));
 9259   ins_pipe(pipe_class_dummy);
 9260   // This is not a short variant of a branch, but the long variant..
 9261   ins_short_branch(0);
 9262 %}
 9263 
 9264 instruct branchLoopEnd(cmpOp cmp, flagsReg cr, label labl) %{
 9265   match(CountedLoopEnd cmp cr);
 9266   effect(USE labl);
 9267   ins_cost(BRANCH_COST);
 9268   size(4);
 9269   format %{ &quot;branch_con_short,$cmp   $labl\t # counted loop end&quot; %}
 9270   ins_encode(z_enc_branch_con_short(cmp, labl));
 9271   ins_pipe(pipe_class_dummy);
 9272   // If set to 1 this indicates that the current instruction is a
 9273   // short variant of a long branch. This avoids using this
 9274   // instruction in first-pass matching. It will then only be used in
 9275   // the `Shorten_branches&#39; pass.
 9276   ins_short_branch(1);
 9277 %}
</pre>
<hr />
<pre>
 9806 instruct CallLeafNoFPDirect(method meth) %{
 9807   match(CallLeafNoFP);
 9808   effect(USE meth);
 9809   ins_cost(CALL_COST);
 9810   // TODO: s390 port size(VARIABLE_SIZE);
 9811   ins_num_consts(1);
 9812   format %{ &quot;CALL,runtime leaf nofp $meth&quot; %}
 9813   ins_encode( z_enc_java_to_runtime_call(meth) );
 9814   ins_pipe(pipe_class_dummy);
 9815   ins_alignment(2);
 9816 %}
 9817 
 9818 // Tail Call; Jump from runtime stub to Java code.
 9819 // Also known as an &#39;interprocedural jump&#39;.
 9820 // Target of jump will eventually return to caller.
 9821 // TailJump below removes the return address.
 9822 instruct TailCalljmpInd(iRegP jump_target, inline_cache_regP method_oop) %{
 9823   match(TailCall jump_target method_oop);
 9824   ins_cost(CALL_COST);
 9825   size(2);
<span class="line-modified"> 9826   format %{ &quot;Jmp     $jump_target\t # $method_oop holds method oop&quot; %}</span>
 9827   ins_encode %{ __ z_br($jump_target$$Register); %}
 9828   ins_pipe(pipe_class_dummy);
 9829 %}
 9830 
 9831 // Return Instruction
 9832 instruct Ret() %{
 9833   match(Return);
 9834   size(2);
 9835   format %{ &quot;BR(Z_R14) // branch to link register&quot; %}
 9836   ins_encode %{ __ z_br(Z_R14); %}
 9837   ins_pipe(pipe_class_dummy);
 9838 %}
 9839 
 9840 // Tail Jump; remove the return address; jump to target.
 9841 // TailCall above leaves the return address around.
 9842 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
 9843 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
 9844 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
 9845 // in %i0.
 9846 instruct tailjmpInd(iRegP jump_target, rarg1RegP ex_oop) %{
</pre>
<hr />
<pre>
 9945   match(Set pcc (FastUnlock oop box));
 9946   effect(TEMP tmp1, TEMP tmp2);
 9947   ins_cost(100);
 9948   // TODO: s390 port size(FIXED_SIZE);  // emitted code depends on UseBiasedLocking being on/off.
 9949   format %{ &quot;FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5&quot; %}
 9950   ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,
 9951                                                UseBiasedLocking &amp;&amp; !UseOptoBiasInlining); %}
 9952   ins_pipe(pipe_class_dummy);
 9953 %}
 9954 
 9955 instruct inlineCallClearArrayConst(SSlenDW cnt, iRegP_N2P base, Universe dummy, flagsReg cr) %{
 9956   match(Set dummy (ClearArray cnt base));
 9957   effect(KILL cr);
 9958   ins_cost(100);
 9959   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to varying #instructions.
 9960   format %{ &quot;ClearArrayConst $cnt,$base&quot; %}
 9961   ins_encode %{ __ Clear_Array_Const($cnt$$constant, $base$$Register); %}
 9962   ins_pipe(pipe_class_dummy);
 9963 %}
 9964 
<span class="line-modified"> 9965 instruct inlineCallClearArrayConstBig(immL cnt, iRegP_N2P base, Universe dummy, allRoddRegL tmpL, flagsReg cr) %{</span>
 9966   match(Set dummy (ClearArray cnt base));
<span class="line-modified"> 9967   effect(TEMP tmpL, KILL cr); // R0, R1 are killed, too.</span>
 9968   ins_cost(200);
 9969   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to optimized constant loader.
 9970   format %{ &quot;ClearArrayConstBig $cnt,$base&quot; %}
<span class="line-modified"> 9971   ins_encode %{ __ Clear_Array_Const_Big($cnt$$constant, $base$$Register, $tmpL$$Register); %}</span>
 9972   ins_pipe(pipe_class_dummy);
 9973 %}
 9974 
<span class="line-modified"> 9975 instruct inlineCallClearArray(iRegL cnt, iRegP_N2P base, Universe dummy, allRoddRegL tmpL, flagsReg cr) %{</span>
 9976   match(Set dummy (ClearArray cnt base));
<span class="line-modified"> 9977   effect(TEMP tmpL, KILL cr); // R0, R1 are killed, too.</span>
 9978   ins_cost(300);
 9979   // TODO: s390 port size(FIXED_SIZE);  // z/Architecture: emitted code depends on PreferLAoverADD being on/off.
 9980   format %{ &quot;ClearArrayVar $cnt,$base&quot; %}
<span class="line-modified"> 9981   ins_encode %{ __ Clear_Array($cnt$$Register, $base$$Register, $tmpL$$Register); %}</span>
 9982   ins_pipe(pipe_class_dummy);
 9983 %}
 9984 
 9985 // ============================================================================
 9986 // CompactStrings
 9987 
 9988 // String equals
 9989 instruct string_equalsL(iRegP str1, iRegP str2, iRegI cnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
 9990   match(Set result (StrEquals (Binary str1 str2) cnt));
 9991   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
 9992   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
 9993   ins_cost(300);
 9994   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result&quot; %}
 9995   ins_encode %{
 9996     __ array_equals(false, $str1$$Register, $str2$$Register,
 9997                     $cnt$$Register, $oddReg$$Register, $evenReg$$Register,
 9998                     $result$$Register, true /* byte */);
 9999   %}
10000   ins_pipe(pipe_class_dummy);
10001 %}
</pre>
<hr />
<pre>
10814 instruct loadV8(iRegL dst, memory mem) %{
10815   match(Set dst (LoadVector mem));
10816   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
10817   ins_cost(MEMORY_REF_COST);
10818   // TODO: s390 port size(VARIABLE_SIZE);
10819   format %{ &quot;LG      $dst,$mem\t # L(packed8B)&quot; %}
10820   opcode(LG_ZOPC, LG_ZOPC);
10821   ins_encode(z_form_rt_mem_opt(dst, mem));
10822   ins_pipe(pipe_class_dummy);
10823 %}
10824 
10825 //----------POPULATION COUNT RULES--------------------------------------------
10826 
10827 // Byte reverse
10828 
10829 instruct bytes_reverse_int(iRegI dst, iRegI src) %{
10830   match(Set dst (ReverseBytesI src));
10831   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10832   ins_cost(DEFAULT_COST);
10833   size(4);
<span class="line-modified">10834   format %{ &quot;LRVR    $dst,$src\t # byte reverse int&quot; %}</span>
10835   opcode(LRVR_ZOPC);
10836   ins_encode(z_rreform(dst, src));
10837   ins_pipe(pipe_class_dummy);
10838 %}
10839 
10840 instruct bytes_reverse_long(iRegL dst, iRegL src) %{
10841   match(Set dst (ReverseBytesL src));
10842   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10843   ins_cost(DEFAULT_COST);
10844   // TODO: s390 port size(FIXED_SIZE);
<span class="line-modified">10845   format %{ &quot;LRVGR   $dst,$src\t # byte reverse long&quot; %}</span>
10846   opcode(LRVGR_ZOPC);
10847   ins_encode(z_rreform(dst, src));
10848   ins_pipe(pipe_class_dummy);
10849 %}
10850 
10851 // Leading zeroes
10852 
10853 // The instruction FLOGR (Find Leftmost One in Grande (64bit) Register)
10854 // returns the bit position of the leftmost 1 in the 64bit source register.
10855 // As the bits are numbered from left to right (0..63), the returned
10856 // position index is equivalent to the number of leading zeroes.
10857 // If no 1-bit is found (i.e. the regsiter contains zero), the instruction
10858 // returns position 64. That&#39;s exactly what we need.
10859 
10860 instruct countLeadingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10861   match(Set dst (CountLeadingZerosI src));
10862   effect(KILL tmp, KILL cr);
10863   ins_cost(3 * DEFAULT_COST);
10864   size(14);
<span class="line-modified">10865   format %{ &quot;SLLG    $dst,$src,32\t # no need to always count 32 zeroes first\n\t&quot;</span>
<span class="line-modified">10866             &quot;IILH    $dst,0x8000 \t # insert \&quot;stop bit\&quot; to force result 32 for zero src.\n\t&quot;</span>
10867             &quot;FLOGR   $dst,$dst&quot;
10868          %}
10869   ins_encode %{
10870     // Performance experiments indicate that &quot;FLOGR&quot; is using some kind of
10871     // iteration to find the leftmost &quot;1&quot; bit.
10872     //
10873     // The prior implementation zero-extended the 32-bit argument to 64 bit,
10874     // thus forcing &quot;FLOGR&quot; to count 32 bits of which we know they are zero.
10875     // We could gain measurable speedup in micro benchmark:
10876     //
10877     //               leading   trailing
10878     //   z10:   int     2.04       1.68
10879     //         long     1.00       1.02
10880     //   z196:  int     0.99       1.23
10881     //         long     1.00       1.11
10882     //
10883     // By shifting the argument into the high-word instead of zero-extending it.
10884     // The add&#39;l branch on condition (taken for a zero argument, very infrequent,
10885     // good prediction) is well compensated for by the savings.
10886     //
10887     // We leave the previous implementation in for some time in the future when
10888     // the &quot;FLOGR&quot; instruction may become less iterative.
10889 
10890     // Version 2: shows 62%(z9), 204%(z10), -1%(z196) improvement over original
10891     __ z_sllg($dst$$Register, $src$$Register, 32); // No need to always count 32 zeroes first.
10892     __ z_iilh($dst$$Register, 0x8000);   // Insert &quot;stop bit&quot; to force result 32 for zero src.
10893     __ z_flogr($dst$$Register, $dst$$Register);
10894   %}
10895   ins_pipe(pipe_class_dummy);
10896 %}
10897 
10898 instruct countLeadingZerosL(revenRegI dst, iRegL src, roddRegI tmp, flagsReg cr) %{
10899   match(Set dst (CountLeadingZerosL src));
10900   effect(KILL tmp, KILL cr);
10901   ins_cost(DEFAULT_COST);
10902   size(4);
<span class="line-modified">10903   format %{ &quot;FLOGR   $dst,$src \t # count leading zeros (long)\n\t&quot; %}</span>
10904   ins_encode %{ __ z_flogr($dst$$Register, $src$$Register); %}
10905   ins_pipe(pipe_class_dummy);
10906 %}
10907 
10908 // trailing zeroes
10909 
10910 // We transform the trailing zeroes problem to a leading zeroes problem
10911 // such that can use the FLOGR instruction to our advantage.
10912 
10913 // With
10914 //   tmp1 = src - 1
10915 // we flip all trailing zeroes to ones and the rightmost one to zero.
10916 // All other bits remain unchanged.
10917 // With the complement
10918 //   tmp2 = ~src
10919 // we get all ones in the trailing zeroes positions. Thus,
10920 //   tmp3 = tmp1 &amp; tmp2
10921 // yields ones in the trailing zeroes positions and zeroes elsewhere.
10922 // Now we can apply FLOGR and get 64-(trailing zeroes).
10923 instruct countTrailingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10924   match(Set dst (CountTrailingZerosI src));
10925   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
10926   ins_cost(8 * DEFAULT_COST);
10927   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
<span class="line-modified">10928   format %{ &quot;LLGFR   $dst,$src  \t # clear upper 32 bits (we are dealing with int)\n\t&quot;</span>
<span class="line-modified">10929             &quot;LCGFR   $tmp,$src  \t # load 2&#39;s complement (32-&gt;64 bit)\n\t&quot;</span>
<span class="line-modified">10930             &quot;AGHI    $dst,-1    \t # tmp1 = src-1\n\t&quot;</span>
<span class="line-modified">10931             &quot;AGHI    $tmp,-1    \t # tmp2 = -src-1 = ~src\n\t&quot;</span>
<span class="line-modified">10932             &quot;NGR     $dst,$tmp  \t # tmp3 = tmp1&amp;tmp2\n\t&quot;</span>
<span class="line-modified">10933             &quot;FLOGR   $dst,$dst  \t # count trailing zeros (int)\n\t&quot;</span>
<span class="line-modified">10934             &quot;AHI     $dst,-64   \t # tmp4 = 64-(trailing zeroes)-64\n\t&quot;</span>
<span class="line-modified">10935             &quot;LCR     $dst,$dst  \t # res = -tmp4&quot;</span>
10936          %}
10937   ins_encode %{
10938     Register Rdst = $dst$$Register;
10939     Register Rsrc = $src$$Register;
10940     // Rtmp only needed for for zero-argument shortcut. With kill effect in
10941     // match rule Rsrc = roddReg would be possible, saving one register.
10942     Register Rtmp = $tmp$$Register;
10943 
10944     assert_different_registers(Rdst, Rsrc, Rtmp);
10945 
10946     // Algorithm:
10947     // - Isolate the least significant (rightmost) set bit using (src &amp; (-src)).
10948     //   All other bits in the result are zero.
10949     // - Find the &quot;leftmost one&quot; bit position in the single-bit result from previous step.
10950     // - 63-(&quot;leftmost one&quot; bit position) gives the # of trailing zeros.
10951 
10952     // Version 2: shows 79%(z9), 68%(z10), 23%(z196) improvement over original.
10953     Label done;
10954     __ load_const_optimized(Rdst, 32); // Prepare for shortcut (zero argument), result will be 32.
10955     __ z_lcgfr(Rtmp, Rsrc);
</pre>
<hr />
<pre>
10961                                        // into upper half of reg. Not relevant with sllg below.
10962     __ z_sllg(Rdst, Rtmp, 32);         // Shift interesting contents to upper half of register.
10963     __ z_bre(done);                    // Shortcut for argument = 1, result will be 0.
10964                                        // Depends on CC set by ahi above.
10965                                        // Taken very infrequently, good prediction, no BHT entry.
10966                                        // Branch delayed to have Rdst set correctly (Rtmp == 0(32bit)
10967                                        // after SLLG Rdst == 0(64bit)).
10968     __ z_flogr(Rdst, Rdst);            // Kills tmp which is the oddReg for dst.
10969     __ add2reg(Rdst,  -32);            // 32-pos(leftmost1) is #trailing zeros
10970     __ z_lcgfr(Rdst, Rdst);            // Provide 64bit result at no cost.
10971     __ bind(done);
10972   %}
10973   ins_pipe(pipe_class_dummy);
10974 %}
10975 
10976 instruct countTrailingZerosL(revenRegI dst, iRegL src, roddRegL tmp, flagsReg cr) %{
10977   match(Set dst (CountTrailingZerosL src));
10978   effect(TEMP_DEF dst, KILL tmp, KILL cr);
10979   ins_cost(8 * DEFAULT_COST);
10980   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
<span class="line-modified">10981   format %{ &quot;LCGR    $dst,$src  \t # preserve src\n\t&quot;</span>
<span class="line-modified">10982             &quot;NGR     $dst,$src  \t #\n\t&quot;</span>
<span class="line-modified">10983             &quot;AGHI    $dst,-1    \t # tmp1 = src-1\n\t&quot;</span>
<span class="line-modified">10984             &quot;FLOGR   $dst,$dst  \t # count trailing zeros (long), kill $tmp\n\t&quot;</span>
<span class="line-modified">10985             &quot;AHI     $dst,-64   \t # tmp4 = 64-(trailing zeroes)-64\n\t&quot;</span>
<span class="line-modified">10986             &quot;LCR     $dst,$dst  \t #&quot;</span>
10987          %}
10988   ins_encode %{
10989     Register Rdst = $dst$$Register;
10990     Register Rsrc = $src$$Register;
10991     assert_different_registers(Rdst, Rsrc); // Rtmp == Rsrc allowed.
10992 
10993     // New version: shows 5%(z9), 2%(z10), 11%(z196) improvement over original.
10994     __ z_lcgr(Rdst, Rsrc);
10995     __ z_ngr(Rdst, Rsrc);
10996     __ add2reg(Rdst,   -1);
10997     __ z_flogr(Rdst, Rdst); // Kills tmp which is the oddReg for dst.
10998     __ add2reg(Rdst,  -64);
10999     __ z_lcgfr(Rdst, Rdst); // Provide 64bit result at no cost.
11000   %}
11001   ins_pipe(pipe_class_dummy);
11002 %}
11003 
11004 
11005 // bit count
11006 
11007 instruct popCountI(iRegI dst, iRegI src, iRegI tmp, flagsReg cr) %{
11008   match(Set dst (PopCountI src));
11009   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
11010   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
11011   ins_cost(DEFAULT_COST);
11012   size(24);
<span class="line-modified">11013   format %{ &quot;POPCNT  $dst,$src\t # pop count int&quot; %}</span>
11014   ins_encode %{
11015     Register Rdst = $dst$$Register;
11016     Register Rsrc = $src$$Register;
11017     Register Rtmp = $tmp$$Register;
11018 
11019     // Prefer compile-time assertion over run-time SIGILL.
11020     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
11021     assert_different_registers(Rdst, Rtmp);
11022 
11023     // Version 2: shows 10%(z196) improvement over original.
11024     __ z_popcnt(Rdst, Rsrc);
11025     __ z_srlg(Rtmp, Rdst, 16); // calc  byte4+byte6 and byte5+byte7
11026     __ z_alr(Rdst, Rtmp);      //   into byte6 and byte7
11027     __ z_srlg(Rtmp, Rdst,  8); // calc (byte4+byte6) + (byte5+byte7)
11028     __ z_alr(Rdst, Rtmp);      //   into byte7
11029     __ z_llgcr(Rdst, Rdst);    // zero-extend sum
11030   %}
11031   ins_pipe(pipe_class_dummy);
11032 %}
11033 
11034 instruct popCountL(iRegI dst, iRegL src, iRegL tmp, flagsReg cr) %{
11035   match(Set dst (PopCountL src));
11036   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
11037   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
11038   ins_cost(DEFAULT_COST);
11039   // TODO: s390 port size(FIXED_SIZE);
<span class="line-modified">11040   format %{ &quot;POPCNT  $dst,$src\t # pop count long&quot; %}</span>
11041   ins_encode %{
11042     Register Rdst = $dst$$Register;
11043     Register Rsrc = $src$$Register;
11044     Register Rtmp = $tmp$$Register;
11045 
11046     // Prefer compile-time assertion over run-time SIGILL.
11047     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
11048     assert_different_registers(Rdst, Rtmp);
11049 
11050     // Original version. Using LA instead of algr seems to be a really bad idea (-35%).
11051     __ z_popcnt(Rdst, Rsrc);
11052     __ z_ahhlr(Rdst, Rdst, Rdst);
11053     __ z_sllg(Rtmp, Rdst, 16);
11054     __ z_algr(Rdst, Rtmp);
11055     __ z_sllg(Rtmp, Rdst,  8);
11056     __ z_algr(Rdst, Rtmp);
11057     __ z_srlg(Rdst, Rdst, 56);
11058   %}
11059   ins_pipe(pipe_class_dummy);
11060 %}
11061 
11062 //----------SMARTSPILL RULES---------------------------------------------------
11063 // These must follow all instruction definitions as they use the names
11064 // defined in the instructions definitions.
11065 
11066 // ============================================================================
11067 // TYPE PROFILING RULES

</pre>
</td>
</tr>
</table>
<center><a href="relocInfo_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
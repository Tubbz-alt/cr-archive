diff a/src/hotspot/cpu/s390/stubGenerator_s390.cpp b/src/hotspot/cpu/s390/stubGenerator_s390.cpp
--- a/src/hotspot/cpu/s390/stubGenerator_s390.cpp
+++ b/src/hotspot/cpu/s390/stubGenerator_s390.cpp
@@ -28,10 +28,11 @@
 #include "registerSaver_s390.hpp"
 #include "gc/shared/barrierSet.hpp"
 #include "gc/shared/barrierSetAssembler.hpp"
 #include "interpreter/interpreter.hpp"
 #include "interpreter/interp_masm.hpp"
+#include "memory/universe.hpp"
 #include "nativeInst_s390.hpp"
 #include "oops/instanceOop.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/oop.inline.hpp"
 #include "prims/methodHandles.hpp"
@@ -39,10 +40,11 @@
 #include "runtime/handles.inline.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "runtime/stubCodeGenerator.hpp"
 #include "runtime/stubRoutines.hpp"
 #include "runtime/thread.inline.hpp"
+#include "utilities/powerOfTwo.hpp"
 
 // Declaration and definition of StubGenerator (no .hpp file).
 // For a more detailed description of the stub routine structure
 // see the comment in stubRoutines.hpp.
 
@@ -664,10 +666,21 @@
     __ z_br(Z_R14);
 
     return start;
   }
 
+#if !defined(PRODUCT)
+  // Wrapper which calls oopDesc::is_oop_or_null()
+  // Only called by MacroAssembler::verify_oop
+  static void verify_oop_helper(const char* message, oopDesc* o) {
+    if (!oopDesc::is_oop_or_null(o)) {
+      fatal("%s. oop: " PTR_FORMAT, message, p2i(o));
+    }
+    ++ StubRoutines::_verify_oop_count;
+  }
+#endif
+
   // Return address of code to be called from code generated by
   // MacroAssembler::verify_oop.
   //
   // Don't generate, rather use C++ code.
   address generate_verify_oop_subroutine() {
@@ -676,10 +689,15 @@
     // about the dynamic code generation, but the stub without
     // code (code_size == 0) confuses opjitconv
     // StubCodeMark mark(this, "StubRoutines", "verify_oop_stub");
 
     address start = 0;
+
+#if !defined(PRODUCT)
+    start = CAST_FROM_FN_PTR(address, verify_oop_helper);
+#endif
+
     return start;
   }
 
   // This is to test that the count register contains a positive int value.
   // Required because C2 does not respect int to long conversion for stub calls.

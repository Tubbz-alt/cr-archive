<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/interp_masm_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2016, 2017 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_S390_INTERP_MASM_S390_HPP
 27 #define CPU_S390_INTERP_MASM_S390_HPP
 28 
 29 #include &quot;asm/macroAssembler.hpp&quot;
 30 #include &quot;interpreter/invocationCounter.hpp&quot;
 31 
 32 // This file specializes the assember with interpreter-specific macros.
 33 
 34 class InterpreterMacroAssembler: public MacroAssembler {
 35 
 36  protected:
 37   // Interpreter specific version of call_VM_base().
 38   virtual void call_VM_leaf_base(address entry_point);
 39   virtual void call_VM_leaf_base(address entry_point, bool allow_relocation);
 40 
 41   virtual void call_VM_base(Register oop_result,
 42                             Register last_java_sp,
 43                             address  entry_point,
 44                             bool check_exceptions);
 45   virtual void call_VM_base(Register oop_result,
 46                             Register last_java_sp,
 47                             address  entry_point,
 48                             bool allow_relocation,
 49                             bool check_exceptions);
 50 
 51   // Base routine for all dispatches.
 52   void dispatch_base(TosState state, address* table, bool generate_poll = false);
 53 
 54  public:
 55   InterpreterMacroAssembler(CodeBuffer* c)
 56     : MacroAssembler(c) {}
 57 
 58   virtual void check_and_handle_popframe(Register java_thread);
 59   virtual void check_and_handle_earlyret(Register java_thread);
 60 
 61   void jump_to_entry(address entry, Register Rscratch);
 62 
 63   virtual void load_earlyret_value(TosState state);
 64 
 65   static const Address l_tmp;
 66   static const Address d_tmp;
 67 
 68   // Handy address generation macros.
 69 #define thread_(field_name) Address(Z_thread, JavaThread::field_name ## _offset())
 70 #define method_(field_name) Address(Z_method, Method::field_name ## _offset())
 71 #define method2_(Rmethod, field_name) Address(Rmethod, Method::field_name ## _offset())
 72 
 73   // Helper routine for frame allocation/deallocation.
 74   // Compute the delta by which the caller&#39;s SP has to
 75   // be adjusted to accomodate for the non-argument locals.
 76   void compute_extra_locals_size_in_bytes(Register args_size, Register locals_size, Register delta);
 77 
 78   // dispatch routines
 79   void dispatch_prolog(TosState state, int step = 0);
 80   void dispatch_epilog(TosState state, int step = 0);
 81   void dispatch_only(TosState state, bool generate_poll = false);
 82   // Dispatch normal table via Z_bytecode (assume Z_bytecode is loaded already).
 83   void dispatch_only_normal(TosState state);
 84   void dispatch_normal(TosState state);
 85   void dispatch_next(TosState state, int step = 0, bool generate_poll = false);
 86   void dispatch_next_noverify_oop(TosState state, int step = 0);
 87   void dispatch_via(TosState state, address* table);
 88 
 89   void narrow(Register result, Register ret_type);
 90 
 91   // Jump to an invoked target.
 92   void prepare_to_jump_from_interpreted(Register method);
 93   void jump_from_interpreted(Register method, Register temp);
 94 
 95   // Removes the current activation (incl. unlocking of monitors).
 96   // Additionally this code is used for earlyReturn in which case we
 97   // want to skip throwing an exception and installing an exception.
 98   void remove_activation(TosState state,
 99                          Register return_pc,
100                          bool throw_monitor_exception = true,
101                          bool install_monitor_exception = true,
102                          bool notify_jvmti = true);
103 
104  public:
105   // Super call_VM calls - correspond to MacroAssembler::call_VM(_leaf) calls.
106   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
107   void super_call_VM(Register thread_cache, Register oop_result, Register last_java_sp,
108                      address entry_point, Register arg_1, Register arg_2, bool check_exception = true);
109 
110   // Generate a subtype check: branch to ok_is_subtype if sub_klass is
111   // a subtype of super_klass. Blows registers tmp1, tmp2 and tmp3.
112   void gen_subtype_check(Register sub_klass, Register super_klass, Register tmp1, Register tmp2, Label &amp;ok_is_subtype);
113 
114   void get_cache_and_index_at_bcp(Register cache, Register cpe_offset, int bcp_offset, size_t index_size = sizeof(u2));
115   void get_cache_and_index_and_bytecode_at_bcp(Register cache, Register cpe_offset, Register bytecode,
116                                                int byte_no, int bcp_offset, size_t index_size = sizeof(u2));
117   void get_cache_entry_pointer_at_bcp(Register cache, Register tmp, int bcp_offset, size_t index_size = sizeof(u2));
118   void get_cache_index_at_bcp(Register index, int bcp_offset, size_t index_size = sizeof(u2));
119   void load_resolved_reference_at_index(Register result, Register index);
120   // load cpool-&gt;resolved_klass_at(index)
121   void load_resolved_klass_at_offset(Register cpool, Register offset, Register iklass);
122 
<a name="1" id="anc1"></a><span class="line-added">123   void load_resolved_method_at_index(int byte_no, Register cache, Register cpe_offset, Register method);</span>
<span class="line-added">124 </span>
125   // Pop topmost element from stack. It just disappears. Useful if
126   // consumed previously by access via stackTop().
127   void popx(int len);
128   void pop_i()   { popx(1); }
129   void pop_ptr() { popx(1); }
130   void pop_l()   { popx(2); }
131   void pop_f()   { popx(1); }
132   void pop_d()   { popx(2); }
133   // Get Address object of stack top. No checks. No pop.
134   // Purpose: provide address of stack operand to exploit reg-mem operations.
135   // Avoid RISC-like mem2reg - reg-reg-op sequence.
136   Address stackTop();
137 
138   // Helpers for expression stack.
139   void pop_i(     Register r);
140   void pop_ptr(   Register r);
141   void pop_l(     Register r);
142   void pop_f(FloatRegister f);
143   void pop_d(FloatRegister f);
144 
145   void push_i(     Register r = Z_tos);
146   void push_ptr(   Register r = Z_tos);
147   void push_l(     Register r = Z_tos);
148   void push_f(FloatRegister f = Z_ftos);
149   void push_d(FloatRegister f = Z_ftos);
150 
151   // Helpers for swap and dup.
152   void load_ptr(int n, Register val);
153   void store_ptr(int n, Register val);
154 
155   void pop (TosState state);           // transition vtos -&gt; state
156   void push(TosState state);           // transition state -&gt; vtos
157   void empty_expression_stack(void);
158 
159 #ifdef ASSERT
160   void verify_sp(Register Rsp, Register Rtemp);
161   void verify_esp(Register Resp, Register Rtemp); // Verify that Resp points to a word in the operand stack.
162 #endif // ASSERT
163 
164  public:
165   void if_cmp(Condition cc, bool ptr_compare);
166 
167   // Accessors to the template interpreter state.
168 
169   void asm_assert_ijava_state_magic(Register tmp) PRODUCT_RETURN;
170 
171   void save_bcp();
172 
173   void restore_bcp();
174 
175   void save_esp();
176 
177   void restore_esp();
178 
179   void get_monitors(Register reg);
180 
181   void save_monitors(Register reg);
182 
183   void get_mdp(Register mdp);
184 
185   void save_mdp(Register mdp);
186 
187   // Values that are only read (besides initialization).
188   void restore_locals();
189 
190   void get_method(Register reg);
191 
192   // Load values from bytecode stream:
193 
194   enum signedOrNot { Signed, Unsigned };
195   enum setCCOrNot  { set_CC,  dont_set_CC };
196 
197   void get_2_byte_integer_at_bcp(Register    Rdst,
198                                  int         bcp_offset,
199                                  signedOrNot is_signed  );
200 
201   void get_4_byte_integer_at_bcp(Register   Rdst,
202                                  int        bcp_offset,
203                                  setCCOrNot should_set_CC = dont_set_CC);
204 
205   // common code
206 
207   void field_offset_at(int n, Register tmp, Register dest, Register base);
208   int  field_offset_at(Register object, address bcp, int offset);
209   void fast_iaaccess(int n, address bcp);
210   void fast_iaputfield(address bcp, bool do_store_check);
211 
212   void index_check(Register array, Register index, int index_shift, Register tmp, Register res);
213   void index_check_without_pop(Register array, Register index, int index_shift, Register tmp, Register res);
214 
215   void get_constant_pool(Register Rdst);
216   void get_constant_pool_cache(Register Rdst);
217   void get_cpool_and_tags(Register Rcpool, Register Rtags);
218   void is_a(Label&amp; L);
219 
220 
221   // --------------------------------------------------
222 
223   void unlock_if_synchronized_method(TosState state, bool throw_monitor_exception = true, bool install_monitor_exception = true);
224 
225   void add_monitor_to_stack(bool stack_is_empty,
226                             Register Rtemp,
227                             Register Rtemp2,
228                             Register Rtemp3);
229 
230   void access_local_int(Register index, Register dst);
231   void access_local_ptr(Register index, Register dst);
232   void access_local_long(Register index, Register dst);
233   void access_local_float(Register index, FloatRegister dst);
234   void access_local_double(Register index, FloatRegister dst);
235 #ifdef ASSERT
236   void check_for_regarea_stomp(Register Rindex, int offset, Register Rlimit, Register Rscratch, Register Rscratch1);
237 #endif // ASSERT
238   void store_local_int(Register index, Register src);
239   void store_local_ptr(Register index, Register src);
240   void store_local_long(Register index, Register src);
241   void store_local_float(Register index, FloatRegister src);
242   void store_local_double(Register index, FloatRegister src);
243 
244 
245   Address first_local_in_stack();
246   static int top_most_monitor_byte_offset(); // Offset in bytes to top of monitor block.
247   Address top_most_monitor();
248   void compute_stack_base(Register Rdest);
249 
250   enum LoadOrStore { load, store };
251   void static_iload_or_store(int which_local, LoadOrStore direction, Register Rtmp);
252   void static_aload_or_store(int which_local, LoadOrStore direction, Register Rtmp);
253   void static_dload_or_store(int which_local, LoadOrStore direction);
254 
255   void static_iinc(          int which_local, jint increment, Register Rtmp, Register Rtmp2);
256 
257   void get_method_counters(Register Rmethod, Register Rcounters, Label&amp; skip);
258   void increment_invocation_counter(Register Rcounters, Register RctrSum);
259   void increment_backedge_counter(Register Rcounters, Register RctrSum);
260   void test_backedge_count_for_osr(Register backedge_count, Register branch_bcp, Register Rtmp);
261 
262   void record_static_call_in_profile(Register Rentry, Register Rtmp);
263   void record_receiver_call_in_profile(Register Rklass, Register Rentry, Register Rtmp);
264 
265   // Object locking
266   void lock_object  (Register lock_reg, Register obj_reg);
267   void unlock_object(Register lock_reg, Register obj_reg=noreg);
268 
269   // Interpreter profiling operations
270   void set_method_data_pointer_for_bcp();
271   void test_method_data_pointer(Register mdp, Label&amp; zero_continue);
272   void verify_method_data_pointer();
273 
274   void set_mdp_data_at(Register mdp_in, int constant, Register value);
275   void increment_mdp_data_at(Register mdp_in, int constant,
276                              Register tmp = Z_R1_scratch, bool decrement = false);
277   void increment_mask_and_jump(Address counter_addr,
278                                int increment, Address mask,
279                                Register scratch, bool preloaded,
280                                branch_condition cond, Label* where);
281   void set_mdp_flag_at(Register mdp_in, int flag_constant);
282   void test_mdp_data_at(Register mdp_in, int offset, Register value,
283                         Register test_value_out,
284                         Label&amp; not_equal_continue);
285 
286   void record_klass_in_profile(Register receiver, Register mdp,
287                                Register reg2, bool is_virtual_call);
288   void record_klass_in_profile_helper(Register receiver, Register mdp,
289                                       Register reg2, int start_row,
290                                       Label&amp; done, bool is_virtual_call);
291 
292   void update_mdp_by_offset(Register mdp_in, int offset_of_offset);
293   void update_mdp_by_offset(Register mdp_in, Register dataidx, int offset_of_disp);
294   void update_mdp_by_constant(Register mdp_in, int constant);
295   void update_mdp_for_ret(Register return_bci);
296 
297   void profile_taken_branch(Register mdp, Register bumped_count);
298   void profile_not_taken_branch(Register mdp);
299   void profile_call(Register mdp);
300   void profile_final_call(Register mdp);
301   void profile_virtual_call(Register receiver, Register mdp,
302                             Register scratch2,
303                             bool receiver_can_be_null = false);
304   void profile_ret(Register return_bci, Register mdp);
305   void profile_null_seen(Register mdp);
306   void profile_typecheck(Register mdp, Register klass, Register scratch);
307   void profile_typecheck_failed(Register mdp, Register tmp);
308   void profile_switch_default(Register mdp);
309   void profile_switch_case(Register index_in_scratch, Register mdp,
310                            Register scratch1, Register scratch2);
311 
312   void profile_obj_type(Register obj, Address mdo_addr, Register klass, bool cmp_done = false);
313   void profile_arguments_type(Register mdp, Register callee, Register tmp, bool is_virtual);
314   void profile_return_type(Register mdp, Register ret, Register tmp);
315   void profile_parameters_type(Register mdp, Register tmp1, Register tmp2);
316 
317   // Debugging
318   void verify_oop(Register reg, TosState state = atos);    // Only if +VerifyOops &amp;&amp; state == atos.
319   void verify_oop_or_return_address(Register reg, Register rtmp); // for astore
320   void verify_FPU(int stack_depth, TosState state = ftos);
321 
322   // JVMTI helpers
323   void skip_if_jvmti_mode(Label &amp;Lskip, Register Rscratch = Z_R0);
324 
325   // support for JVMTI/Dtrace
326   typedef enum { NotifyJVMTI, SkipNotifyJVMTI } NotifyMethodExitMode;
327   void notify_method_entry();
328   void notify_method_exit(bool native_method, TosState state, NotifyMethodExitMode mode);
329 
330   // Pop the topmost TOP_IJAVA_FRAME and set it&#39;s sender_sp as new Z_SP.
331   // The return pc is loaded into the Register return_pc.
332   void pop_interpreter_frame(Register return_pc, Register tmp1, Register tmp2);
333 };
334 
335 #endif // CPU_S390_INTERP_MASM_S390_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
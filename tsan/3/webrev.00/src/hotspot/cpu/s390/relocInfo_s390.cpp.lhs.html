<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/relocInfo_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2016 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &quot;precompiled.hpp&quot;
 27 #include &quot;asm/assembler.inline.hpp&quot;
 28 #include &quot;code/relocInfo.hpp&quot;
 29 #include &quot;nativeInst_s390.hpp&quot;
 30 #include &quot;oops/oop.inline.hpp&quot;
 31 #include &quot;runtime/safepoint.hpp&quot;
 32 
 33 void Relocation::pd_set_data_value(address x, intptr_t o, bool verify_only) {
 34   // we don&#39;t support splitting of relocations, so o must be zero:
 35   assert(o == 0, &quot;tried to split relocations&quot;);
 36   if (!verify_only) {
 37     switch (format()) {
 38       case relocInfo::uncompressed_format:
 39         nativeMovConstReg_at(addr())-&gt;set_data_plain(((intptr_t)x) + o, code());
 40         break;
 41       case relocInfo::compressed_format:
 42         if (type() == relocInfo::metadata_type)
 43           nativeMovConstReg_at(addr())-&gt;set_narrow_klass(((intptr_t)x) + o);
 44         else if (type() == relocInfo::oop_type)
 45           nativeMovConstReg_at(addr())-&gt;set_narrow_oop(((intptr_t)x) + o);
 46         else
 47           guarantee(false, &quot;bad relocInfo type for relocInfo::narrow_oop_format&quot;);
 48         break;
 49       case relocInfo::pcrel_addr_format:  // patch target location
 50         nativeMovConstReg_at(addr())-&gt;set_pcrel_addr(((intptr_t)x) + o, code());
 51         break;
 52       case relocInfo::pcrel_data_format:  // patch data at target location
 53         nativeMovConstReg_at(addr())-&gt;set_pcrel_data(((intptr_t)x) + o, code());
 54         break;
 55       default:
 56         assert(false, &quot;not a valid relocInfo format&quot;);
 57         break;
 58     }
 59   } else {
 60     // TODO: Reading of narrow oops out of code stream is not implemented
 61     // (see nativeMovConstReg::data()). Implement this if you want to verify.
 62     // assert(x == (address) nativeMovConstReg_at(addr())-&gt;data(), &quot;Instructions must match&quot;);
 63     switch (format()) {
 64       case relocInfo::uncompressed_format:
 65         break;
 66       case relocInfo::compressed_format:
 67         break;
 68       case relocInfo::pcrel_addr_format:
 69         break;
 70       case relocInfo::pcrel_data_format:
 71         break;
 72       default:
 73         assert(false, &quot;not a valid relocInfo format&quot;);
 74         break;
 75     }
 76   }
 77 }
 78 
 79 address Relocation::pd_call_destination(address orig_addr) {
 80   address   inst_addr = addr();
 81 
 82   if (NativeFarCall::is_far_call_at(inst_addr)) {
 83     if (!ShortenBranches) {
 84       if (MacroAssembler::is_call_far_pcrelative(inst_addr)) {
 85         address a1 = MacroAssembler::get_target_addr_pcrel(orig_addr+MacroAssembler::nop_size());
 86 #ifdef ASSERT
 87         address a2 = MacroAssembler::get_target_addr_pcrel(inst_addr+MacroAssembler::nop_size());
 88         address a3 = nativeFarCall_at(orig_addr)-&gt;destination();
 89         address a4 = nativeFarCall_at(inst_addr)-&gt;destination();
 90         if ((a1 != a3) || (a2 != a4)) {
 91           unsigned int range = 128;
 92           Assembler::dump_code_range(tty, inst_addr, range, &quot;pc-relative call w/o ShortenBranches?&quot;);
 93           Assembler::dump_code_range(tty, orig_addr, range, &quot;pc-relative call w/o ShortenBranches?&quot;);
 94           assert(false, &quot;pc-relative call w/o ShortenBranches?&quot;);
 95         }
 96 #endif
 97         return a1;
 98       }
 99       return (address)(-1);
100     }
101     NativeFarCall* call;
102     if (orig_addr == NULL) {
103       call = nativeFarCall_at(inst_addr);
104     } else {
105       // must access location (in CP) where destination is stored in unmoved code, because load from CP is pc-relative
106       call = nativeFarCall_at(orig_addr);
107     }
108     return call-&gt;destination();
109   }
110 
111   if (NativeCall::is_call_at(inst_addr)) {
112     NativeCall* call = nativeCall_at(inst_addr);
113     if (call-&gt;is_pcrelative()) {
114       intptr_t off = inst_addr - orig_addr;
115       return (address) (call-&gt;destination()-off);
116     }
117   }
118 
119   return (address) nativeMovConstReg_at(inst_addr)-&gt;data();
120 }
121 
122 void Relocation::pd_set_call_destination(address x) {
123   address inst_addr = addr();
124 
125   if (NativeFarCall::is_far_call_at(inst_addr)) {
126     if (!ShortenBranches) {
127       if (MacroAssembler::is_call_far_pcrelative(inst_addr)) {
128         address a1 = MacroAssembler::get_target_addr_pcrel(inst_addr+MacroAssembler::nop_size());
129 #ifdef ASSERT
130         address a3 = nativeFarCall_at(inst_addr)-&gt;destination();
131         if (a1 != a3) {
132           unsigned int range = 128;
133           Assembler::dump_code_range(tty, inst_addr, range, &quot;pc-relative call w/o ShortenBranches?&quot;);
134           assert(false, &quot;pc-relative call w/o ShortenBranches?&quot;);
135         }
136 #endif
137         nativeFarCall_at(inst_addr)-&gt;set_destination(x, 0);
138         return;
139       }
140       assert(x == (address)-1, &quot;consistency check&quot;);
141       return;
142     }
143     int toc_offset = -1;
144     if (type() == relocInfo::runtime_call_w_cp_type) {
145       toc_offset = ((runtime_call_w_cp_Relocation *)this)-&gt;get_constant_pool_offset();
146     }
147     if (toc_offset&gt;=0) {
148       NativeFarCall* call = nativeFarCall_at(inst_addr);
149       call-&gt;set_destination(x, toc_offset);
150       return;
151     }
152   }
153 
154   if (NativeCall::is_call_at(inst_addr)) {
155     NativeCall* call = nativeCall_at(inst_addr);
156     if (call-&gt;is_pcrelative()) {
157       call-&gt;set_destination_mt_safe(x);
158       return;
159     }
160   }
161 
162   // constant is absolute, must use x
163   nativeMovConstReg_at(inst_addr)-&gt;set_data(((intptr_t)x));
164 }
165 
166 
<a name="1" id="anc1"></a><span class="line-removed">167 // store the new target address into an oop_Relocation cell, if any</span>
<span class="line-removed">168 // return indication if update happened.</span>
<span class="line-removed">169 bool relocInfo::update_oop_pool(address begin, address end, address newTarget, CodeBlob* cb) {</span>
<span class="line-removed">170 </span>
<span class="line-removed">171   //  Try to find the CodeBlob, if not given by caller</span>
<span class="line-removed">172   if (cb == NULL) cb = CodeCache::find_blob(begin);</span>
<span class="line-removed">173 #ifdef ASSERT</span>
<span class="line-removed">174   else</span>
<span class="line-removed">175     assert(cb == CodeCache::find_blob(begin), &quot;consistency&quot;);</span>
<span class="line-removed">176 #endif</span>
<span class="line-removed">177 </span>
<span class="line-removed">178   //  &#39;RelocIterator&#39; requires an nmethod</span>
<span class="line-removed">179   nmethod*  nm = cb ? cb-&gt;as_nmethod_or_null() : NULL;</span>
<span class="line-removed">180   if (nm != NULL) {</span>
<span class="line-removed">181     RelocIterator iter(nm, begin, end);</span>
<span class="line-removed">182     oop* oop_addr = NULL;</span>
<span class="line-removed">183     Metadata** metadata_addr = NULL;</span>
<span class="line-removed">184     while (iter.next()) {</span>
<span class="line-removed">185       if (iter.type() == relocInfo::oop_type) {</span>
<span class="line-removed">186         oop_Relocation *r = iter.oop_reloc();</span>
<span class="line-removed">187         if (oop_addr == NULL) {</span>
<span class="line-removed">188           oop_addr = r-&gt;oop_addr();</span>
<span class="line-removed">189           *oop_addr = (oop)newTarget;</span>
<span class="line-removed">190         } else {</span>
<span class="line-removed">191           assert(oop_addr == r-&gt;oop_addr(), &quot;must be only one set-oop here&quot;);</span>
<span class="line-removed">192         }</span>
<span class="line-removed">193       }</span>
<span class="line-removed">194       if (iter.type() == relocInfo::metadata_type) {</span>
<span class="line-removed">195         metadata_Relocation *r = iter.metadata_reloc();</span>
<span class="line-removed">196         if (metadata_addr == NULL) {</span>
<span class="line-removed">197           metadata_addr = r-&gt;metadata_addr();</span>
<span class="line-removed">198           *metadata_addr = (Metadata*)newTarget;</span>
<span class="line-removed">199         } else {</span>
<span class="line-removed">200           assert(metadata_addr == r-&gt;metadata_addr(), &quot;must be only one set-metadata here&quot;);</span>
<span class="line-removed">201         }</span>
<span class="line-removed">202       }</span>
<span class="line-removed">203     }</span>
<span class="line-removed">204     return oop_addr || metadata_addr;</span>
<span class="line-removed">205   }</span>
<span class="line-removed">206   return false;</span>
<span class="line-removed">207 }</span>
<span class="line-removed">208 </span>
<span class="line-removed">209 </span>
210 address* Relocation::pd_address_in_code() {
211  ShouldNotReachHere();
212  return 0;
213 }
214 
215 address Relocation::pd_get_address_from_code() {
216    return  (address) (nativeMovConstReg_at(addr())-&gt;data());
217 }
218 
219 void poll_Relocation::fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) {
220 }
221 
222 void metadata_Relocation::pd_fix_value(address x) {
223 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
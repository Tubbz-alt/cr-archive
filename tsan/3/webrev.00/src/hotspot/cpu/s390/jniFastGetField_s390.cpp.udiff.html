<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/s390/jniFastGetField_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interpreterRT_s390.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_s390.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/jniFastGetField_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,23 +22,122 @@</span>
   * questions.
   *
   */
  
  #include &quot;precompiled.hpp&quot;
<span class="udiff-line-added">+ #include &quot;asm/macroAssembler.inline.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shared/barrierSet.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;gc/shared/barrierSetAssembler.hpp&quot;</span>
<span class="udiff-line-added">+ #include &quot;memory/resourceArea.hpp&quot;</span>
  #include &quot;prims/jniFastGetField.hpp&quot;
  #include &quot;prims/jvm_misc.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/safepoint.hpp&quot;</span>
  
  // TSO ensures that loads are blocking and ordered with respect to
  // to earlier loads, so we don&#39;t need LoadLoad membars.
  
  #define __ masm-&gt;
  
  #define BUFFER_SIZE 30*sizeof(jint)
  
<span class="udiff-line-added">+ // Common register usage:</span>
<span class="udiff-line-added">+ // Z_RET/Z_FRET: result</span>
<span class="udiff-line-added">+ // Z_ARG1:       jni env</span>
<span class="udiff-line-added">+ // Z_ARG2:       obj</span>
<span class="udiff-line-added">+ // Z_ARG3:       jfield id</span>
<span class="udiff-line-added">+ </span>
  address JNI_FastGetField::generate_fast_get_int_field0(BasicType type) {
<span class="udiff-line-modified-removed">-   // Don&#39;t use fast jni accessors.</span>
<span class="udiff-line-modified-removed">-   return (address) -1;</span>
<span class="udiff-line-modified-added">+   const char *name;</span>
<span class="udiff-line-modified-added">+   switch (type) {</span>
<span class="udiff-line-added">+     case T_BOOLEAN: name = &quot;jni_fast_GetBooleanField&quot;; break;</span>
<span class="udiff-line-added">+     case T_BYTE:    name = &quot;jni_fast_GetByteField&quot;;    break;</span>
<span class="udiff-line-added">+     case T_CHAR:    name = &quot;jni_fast_GetCharField&quot;;    break;</span>
<span class="udiff-line-added">+     case T_SHORT:   name = &quot;jni_fast_GetShortField&quot;;   break;</span>
<span class="udiff-line-added">+     case T_INT:     name = &quot;jni_fast_GetIntField&quot;;     break;</span>
<span class="udiff-line-added">+     case T_LONG:    name = &quot;jni_fast_GetLongField&quot;;    break;</span>
<span class="udiff-line-added">+     case T_FLOAT:   name = &quot;jni_fast_GetFloatField&quot;;   break;</span>
<span class="udiff-line-added">+     case T_DOUBLE:  name = &quot;jni_fast_GetDoubleField&quot;;  break;</span>
<span class="udiff-line-added">+     default:        ShouldNotReachHere();</span>
<span class="udiff-line-added">+       name = NULL;  // unreachable</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   ResourceMark rm;</span>
<span class="udiff-line-added">+   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE);</span>
<span class="udiff-line-added">+   CodeBuffer cbuf(blob);</span>
<span class="udiff-line-added">+   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);</span>
<span class="udiff-line-added">+   address fast_entry = __ pc();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Label slow;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // We can only kill the remaining volatile registers.</span>
<span class="udiff-line-added">+   const Register Rcounter = Z_ARG4,</span>
<span class="udiff-line-added">+                  Robj     = Z_R1_scratch,</span>
<span class="udiff-line-added">+                  Rtmp     = Z_R0_scratch;</span>
<span class="udiff-line-added">+   __ load_const_optimized(Robj, SafepointSynchronize::safepoint_counter_addr());</span>
<span class="udiff-line-added">+   __ z_lg(Rcounter, Address(Robj));</span>
<span class="udiff-line-added">+   __ z_tmll(Rcounter, 1);</span>
<span class="udiff-line-added">+   __ z_brnaz(slow);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (JvmtiExport::can_post_field_access()) {</span>
<span class="udiff-line-added">+     // Check to see if a field access watch has been set before we</span>
<span class="udiff-line-added">+     // take the fast path.</span>
<span class="udiff-line-added">+     __ load_const_optimized(Robj, JvmtiExport::get_field_access_count_addr());</span>
<span class="udiff-line-added">+     __ z_lt(Robj, Address(Robj));</span>
<span class="udiff-line-added">+     __ z_brne(slow);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ z_lgr(Robj, Z_ARG2);</span>
<span class="udiff-line-added">+   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();</span>
<span class="udiff-line-added">+   bs-&gt;try_resolve_jobject_in_native(masm, Z_ARG1, Robj, Rtmp, slow);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ z_srlg(Rtmp, Z_ARG3, 2); // offset</span>
<span class="udiff-line-added">+   __ z_agr(Robj, Rtmp);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   assert(count &lt; LIST_CAPACITY, &quot;LIST_CAPACITY too small&quot;);</span>
<span class="udiff-line-added">+   speculative_load_pclist[count] = __ pc();   // Used by the segfault handler</span>
<span class="udiff-line-added">+   bool is_fp = false;</span>
<span class="udiff-line-added">+   switch (type) {</span>
<span class="udiff-line-added">+     case T_BOOLEAN: __ z_llgc(Rtmp, Address(Robj)); break;</span>
<span class="udiff-line-added">+     case T_BYTE:    __ z_lgb( Rtmp, Address(Robj)); break;</span>
<span class="udiff-line-added">+     case T_CHAR:    __ z_llgh(Rtmp, Address(Robj)); break;</span>
<span class="udiff-line-added">+     case T_SHORT:   __ z_lgh( Rtmp, Address(Robj)); break;</span>
<span class="udiff-line-added">+     case T_INT:     __ z_lgf( Rtmp, Address(Robj)); break;</span>
<span class="udiff-line-added">+     case T_LONG:    __ z_lg(  Rtmp, Address(Robj)); break;</span>
<span class="udiff-line-added">+     case T_FLOAT:   __ mem2freg_opt(Z_FRET, Address(Robj), false); is_fp = true; break;</span>
<span class="udiff-line-added">+     case T_DOUBLE:  __ mem2freg_opt(Z_FRET, Address(Robj), true ); is_fp = true; break;</span>
<span class="udiff-line-added">+     default:        ShouldNotReachHere();</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ load_const_optimized(Robj, SafepointSynchronize::safepoint_counter_addr());</span>
<span class="udiff-line-added">+   __ z_cg(Rcounter, Address(Robj));</span>
<span class="udiff-line-added">+   __ z_brne(slow);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!is_fp) {</span>
<span class="udiff-line-added">+     __ z_lgr(Z_RET, Rtmp);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   __ z_br(Z_R14);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   slowcase_entry_pclist[count++] = __ pc();</span>
<span class="udiff-line-added">+   __ bind(slow);</span>
<span class="udiff-line-added">+   address slow_case_addr;</span>
<span class="udiff-line-added">+   switch (type) {</span>
<span class="udiff-line-added">+     case T_BOOLEAN: slow_case_addr = jni_GetBooleanField_addr(); break;</span>
<span class="udiff-line-added">+     case T_BYTE:    slow_case_addr = jni_GetByteField_addr();    break;</span>
<span class="udiff-line-added">+     case T_CHAR:    slow_case_addr = jni_GetCharField_addr();    break;</span>
<span class="udiff-line-added">+     case T_SHORT:   slow_case_addr = jni_GetShortField_addr();   break;</span>
<span class="udiff-line-added">+     case T_INT:     slow_case_addr = jni_GetIntField_addr();     break;</span>
<span class="udiff-line-added">+     case T_LONG:    slow_case_addr = jni_GetLongField_addr();    break;</span>
<span class="udiff-line-added">+     case T_FLOAT:   slow_case_addr = jni_GetFloatField_addr();   break;</span>
<span class="udiff-line-added">+     case T_DOUBLE:  slow_case_addr = jni_GetDoubleField_addr();  break;</span>
<span class="udiff-line-added">+     default:        ShouldNotReachHere();</span>
<span class="udiff-line-added">+       slow_case_addr = NULL;  // unreachable</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   __ load_const_optimized(Robj, slow_case_addr);</span>
<span class="udiff-line-added">+   __ z_br(Robj); // tail call</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   __ flush();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return fast_entry;</span>
  }
  
  address JNI_FastGetField::generate_fast_get_boolean_field() {
    return generate_fast_get_int_field0(T_BOOLEAN);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -58,21 +157,15 @@</span>
  address JNI_FastGetField::generate_fast_get_int_field() {
    return generate_fast_get_int_field0(T_INT);
  }
  
  address JNI_FastGetField::generate_fast_get_long_field() {
<span class="udiff-line-modified-removed">-   // Don&#39;t use fast jni accessors.</span>
<span class="udiff-line-removed">-   return (address) -1;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- address JNI_FastGetField::generate_fast_get_float_field0(BasicType type) {</span>
<span class="udiff-line-removed">-   // Don&#39;t use fast jni accessors.</span>
<span class="udiff-line-removed">-   return (address) -1;</span>
<span class="udiff-line-modified-added">+   return generate_fast_get_int_field0(T_LONG);</span>
  }
  
  address JNI_FastGetField::generate_fast_get_float_field() {
<span class="udiff-line-modified-removed">-   return generate_fast_get_float_field0(T_FLOAT);</span>
<span class="udiff-line-modified-added">+   return generate_fast_get_int_field0(T_FLOAT);</span>
  }
  
  address JNI_FastGetField::generate_fast_get_double_field() {
<span class="udiff-line-modified-removed">-   return generate_fast_get_float_field0(T_DOUBLE);</span>
<span class="udiff-line-modified-added">+   return generate_fast_get_int_field0(T_DOUBLE);</span>
  }
</pre>
<center><a href="interpreterRT_s390.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_s390.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/s390/s390.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="relocInfo_s390.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_s390.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/s390.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  //
<span class="line-modified">! // Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">! // Copyright (c) 2017, SAP SE. All rights reserved.</span>
  // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  //
  // This code is free software; you can redistribute it and/or modify it
  // under the terms of the GNU General Public License version 2 only, as
  // published by the Free Software Foundation.
<span class="line-new-header">--- 1,8 ---</span>
  //
<span class="line-modified">! // Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">! // Copyright (c) 2017, 2019 SAP SE. All rights reserved.</span>
  // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  //
  // This code is free software; you can redistribute it and/or modify it
  // under the terms of the GNU General Public License version 2 only, as
  // published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 472,10 ***</span>
<span class="line-new-header">--- 472,23 ---</span>
    Z_R13_H,Z_R13
  /*Z_R14_H,Z_R14,*/  // return_pc
  /*Z_R15_H,Z_R15*/   // SP
  );
  
<span class="line-added">+ // z_long_reg without even registers</span>
<span class="line-added">+ reg_class z_long_odd_reg(</span>
<span class="line-added">+ /*Z_R0_H,Z_R0*/     // R0</span>
<span class="line-added">+ /*Z_R1_H,Z_R1*/</span>
<span class="line-added">+   Z_R3_H,Z_R3,</span>
<span class="line-added">+   Z_R5_H,Z_R5,</span>
<span class="line-added">+   Z_R7_H,Z_R7,</span>
<span class="line-added">+   Z_R9_H,Z_R9,</span>
<span class="line-added">+   Z_R11_H,Z_R11,</span>
<span class="line-added">+   Z_R13_H,Z_R13</span>
<span class="line-added">+ /*Z_R14_H,Z_R14,*/  // return_pc</span>
<span class="line-added">+ /*Z_R15_H,Z_R15*/   // SP</span>
<span class="line-added">+ );</span>
  
  // Special Class for Condition Code Flags Register
  
  reg_class z_condition_reg(
    Z_CR
</pre>
<hr />
<pre>
<span class="line-old-header">*** 852,10 ***</span>
<span class="line-new-header">--- 865,27 ---</span>
    size_t framesize = C-&gt;frame_size_in_bytes();
    size_t bangsize  = C-&gt;bang_size_in_bytes();
  
    assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  
<span class="line-added">+   if (C-&gt;clinit_barrier_on_entry()) {</span>
<span class="line-added">+     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Label L_skip_barrier;</span>
<span class="line-added">+     Register klass = Z_R1_scratch;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Notify OOP recorder (don&#39;t need the relocation)</span>
<span class="line-added">+     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());</span>
<span class="line-added">+     __ load_const_optimized(klass, md.value());</span>
<span class="line-added">+     __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());</span>
<span class="line-added">+     __ z_br(klass);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ bind(L_skip_barrier);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Calls to C2R adapters often do not accept exceptional returns.
    // We require that their callers must bang for them. But be
    // careful, because some VM calls (such as call site linkage) can
    // use several kilobytes of stack. But the stack safety zone should
    // account for that. See bugs 4446381, 4468289, 4497237.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1373,11 ***</span>
      // ic_miss_stub to find the proper method.
      __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
      __ z_br(R1_ic_miss_stub_addr);
      __ bind(valid);
    }
<span class="line-removed">- </span>
  }
  
  uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
    // Determine size dynamically.
    return MachNode::size(ra_);
<span class="line-new-header">--- 1403,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1520,11 ***</span>
  
    return true;  // Per default match rules are supported.
                  // BUT: make sure match rule is not disabled by a false predicate!
  }
  
<span class="line-modified">! const bool Matcher::match_rule_supported_vector(int opcode, int vlen) {</span>
    // TODO
    // Identify extra cases that we might want to provide match rules for
    // e.g. Op_ vector nodes and other intrinsics while guarding with vlen.
    bool ret_value = match_rule_supported(opcode);
    // Add rules here.
<span class="line-new-header">--- 1549,11 ---</span>
  
    return true;  // Per default match rules are supported.
                  // BUT: make sure match rule is not disabled by a false predicate!
  }
  
<span class="line-modified">! const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {</span>
    // TODO
    // Identify extra cases that we might want to provide match rules for
    // e.g. Op_ vector nodes and other intrinsics while guarding with vlen.
    bool ret_value = match_rule_supported(opcode);
    // Add rules here.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1627,13 ***</span>
  // the cpu only look at the lower 5/6 bits anyway?
  // 32bit shifts mask in emitter, 64bit shifts need no mask.
  // Constant shift counts are handled in Ideal phase.
  const bool Matcher::need_masked_shift_count = false;
  
  // Set this as clone_shift_expressions.
  bool Matcher::narrow_oop_use_complex_address() {
<span class="line-modified">!   if (Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0) return true;</span>
    return false;
  }
  
  bool Matcher::narrow_klass_use_complex_address() {
    NOT_LP64(ShouldNotCallThis());
<span class="line-new-header">--- 1656,31 ---</span>
  // the cpu only look at the lower 5/6 bits anyway?
  // 32bit shifts mask in emitter, 64bit shifts need no mask.
  // Constant shift counts are handled in Ideal phase.
  const bool Matcher::need_masked_shift_count = false;
  
<span class="line-added">+ // No support for generic vector operands.</span>
<span class="line-added">+ const bool Matcher::supports_generic_vector_operands  = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+ MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {</span>
<span class="line-added">+   ShouldNotReachHere(); // generic vector operands not supported</span>
<span class="line-added">+   return NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Matcher::is_generic_reg2reg_move(MachNode* m) {</span>
<span class="line-added">+   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool Matcher::is_generic_vector(MachOper* opnd)  {</span>
<span class="line-added">+   ShouldNotReachHere();  // generic vector operands not supported</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Set this as clone_shift_expressions.
  bool Matcher::narrow_oop_use_complex_address() {
<span class="line-modified">!   if (CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0) return true;</span>
    return false;
  }
  
  bool Matcher::narrow_klass_use_complex_address() {
    NOT_LP64(ShouldNotCallThis());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1642,16 ***</span>
    return false;
  }
  
  bool Matcher::const_oop_prefer_decode() {
    // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
<span class="line-modified">!   return Universe::narrow_oop_base() == NULL;</span>
  }
  
  bool Matcher::const_klass_prefer_decode() {
    // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified">!   return Universe::narrow_klass_base() == NULL;</span>
  }
  
  // Is it better to copy float constants, or load them directly from memory?
  // Most RISCs will have to materialize an address into a
  // register first, so they would do better to copy the constant from stack.
<span class="line-new-header">--- 1689,16 ---</span>
    return false;
  }
  
  bool Matcher::const_oop_prefer_decode() {
    // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
<span class="line-modified">!   return CompressedOops::base() == NULL;</span>
  }
  
  bool Matcher::const_klass_prefer_decode() {
    // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified">!   return CompressedKlassPointers::base() == NULL;</span>
  }
  
  // Is it better to copy float constants, or load them directly from memory?
  // Most RISCs will have to materialize an address into a
  // register first, so they would do better to copy the constant from stack.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1661,12 ***</span>
  // needed. Else we split the double into 2 integer pieces and move it
  // piece-by-piece. Only happens when passing doubles into C code as the
  // Java calling convention forces doubles to be aligned.
  const bool Matcher::misaligned_doubles_ok = true;
  
<span class="line-modified">! // Advertise here if the CPU requires explicit rounding operations</span>
<span class="line-removed">- // to implement the UseStrictFP mode.</span>
  const bool Matcher::strict_fp_requires_explicit_rounding = false;
  
  // Do floats take an entire double register or just half?
  //
  // A float in resides in a zarch double register. When storing it by
<span class="line-new-header">--- 1708,11 ---</span>
  // needed. Else we split the double into 2 integer pieces and move it
  // piece-by-piece. Only happens when passing doubles into C code as the
  // Java calling convention forces doubles to be aligned.
  const bool Matcher::misaligned_doubles_ok = true;
  
<span class="line-modified">! // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>
  const bool Matcher::strict_fp_requires_explicit_rounding = false;
  
  // Do floats take an entire double register or just half?
  //
  // A float in resides in a zarch double register. When storing it by
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3376,10 ***</span>
<span class="line-new-header">--- 3422,11 ---</span>
  operand iRegL() %{
    constraint(ALLOC_IN_RC(z_long_reg));
    match(RegL);
    match(revenRegL);
    match(roddRegL);
<span class="line-added">+   match(allRoddRegL);</span>
    match(rarg1RegL);
    match(rarg5RegL);
    format %{ %}
    interface(REG_INTER);
  %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3398,10 ***</span>
<span class="line-new-header">--- 3445,18 ---</span>
    match(iRegL);
    format %{ %}
    interface(REG_INTER);
  %}
  
<span class="line-added">+ // available odd registers for iRegL</span>
<span class="line-added">+ operand allRoddRegL() %{</span>
<span class="line-added">+   constraint(ALLOC_IN_RC(z_long_odd_reg));</span>
<span class="line-added">+   match(iRegL);</span>
<span class="line-added">+   format %{ %}</span>
<span class="line-added">+   interface(REG_INTER);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  operand rarg1RegL() %{
    constraint(ALLOC_IN_RC(z_rarg1_long_reg));
    match(iRegL);
    format %{ %}
    interface(REG_INTER);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3483,19 ***</span>
  %}
  
  // Operands to remove register moves in unscaled mode.
  // Match read/write registers with an EncodeP node if neither shift nor add are required.
  operand iRegP2N(iRegP reg) %{
<span class="line-modified">!   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; _leaf-&gt;as_EncodeP()-&gt;in(0) == NULL);</span>
    constraint(ALLOC_IN_RC(z_memory_ptr_reg));
    match(EncodeP reg);
    format %{ &quot;$reg&quot; %}
    interface(REG_INTER)
  %}
  
  operand iRegN2P(iRegN reg) %{
<span class="line-modified">!   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0 &amp;&amp;</span>
              _leaf-&gt;as_DecodeN()-&gt;in(0) == NULL);
    constraint(ALLOC_IN_RC(z_memory_ptr_reg));
    match(DecodeN reg);
    format %{ &quot;$reg&quot; %}
    interface(REG_INTER)
<span class="line-new-header">--- 3538,19 ---</span>
  %}
  
  // Operands to remove register moves in unscaled mode.
  // Match read/write registers with an EncodeP node if neither shift nor add are required.
  operand iRegP2N(iRegP reg) %{
<span class="line-modified">!   predicate(CompressedOops::shift() == 0 &amp;&amp; _leaf-&gt;as_EncodeP()-&gt;in(0) == NULL);</span>
    constraint(ALLOC_IN_RC(z_memory_ptr_reg));
    match(EncodeP reg);
    format %{ &quot;$reg&quot; %}
    interface(REG_INTER)
  %}
  
  operand iRegN2P(iRegN reg) %{
<span class="line-modified">!   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0 &amp;&amp;</span>
              _leaf-&gt;as_DecodeN()-&gt;in(0) == NULL);
    constraint(ALLOC_IN_RC(z_memory_ptr_reg));
    match(DecodeN reg);
    format %{ &quot;$reg&quot; %}
    interface(REG_INTER)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4294,20 ***</span>
  
  instruct loadConI(iRegI dst, immI src) %{
    match(Set dst src);
    ins_cost(DEFAULT_COST);
    size(6);
<span class="line-modified">!   format %{ &quot;LGFI     $dst,$src\t # (int)&quot; %}</span>
    ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct loadConI16(iRegI dst, immI16 src) %{
    match(Set dst src);
    ins_cost(DEFAULT_COST_LOW);
    size(4);
<span class="line-modified">!   format %{ &quot;LGHI     $dst,$src\t # (int)&quot; %}</span>
    ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct loadConI_0(iRegI dst, immI_0 src, flagsReg cr) %{
<span class="line-new-header">--- 4349,20 ---</span>
  
  instruct loadConI(iRegI dst, immI src) %{
    match(Set dst src);
    ins_cost(DEFAULT_COST);
    size(6);
<span class="line-modified">!   format %{ &quot;LGFI    $dst,$src\t # (int)&quot; %}</span>
    ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct loadConI16(iRegI dst, immI16 src) %{
    match(Set dst src);
    ins_cost(DEFAULT_COST_LOW);
    size(4);
<span class="line-modified">!   format %{ &quot;LGHI    $dst,$src\t # (int)&quot; %}</span>
    ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct loadConI_0(iRegI dst, immI_0 src, flagsReg cr) %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4699,22 ***</span>
  // Load narrow oop
  instruct loadN(iRegN dst, memory mem) %{
    match(Set dst (LoadN mem));
    ins_cost(MEMORY_REF_COST);
    size(Z_DISP3_SIZE);
<span class="line-modified">!   format %{ &quot;LoadN  $dst,$mem\t# (cOop)&quot; %}</span>
    opcode(LLGF_ZOPC, LLGF_ZOPC);
    ins_encode(z_form_rt_mem_opt(dst, mem));
    ins_pipe(pipe_class_dummy);
  %}
  
  // Load narrow Klass Pointer
  instruct loadNKlass(iRegN dst, memory mem) %{
    match(Set dst (LoadNKlass mem));
    ins_cost(MEMORY_REF_COST);
    size(Z_DISP3_SIZE);
<span class="line-modified">!   format %{ &quot;LoadNKlass $dst,$mem\t# (klass cOop)&quot; %}</span>
    opcode(LLGF_ZOPC, LLGF_ZOPC);
    ins_encode(z_form_rt_mem_opt(dst, mem));
    ins_pipe(pipe_class_dummy);
  %}
  
<span class="line-new-header">--- 4754,22 ---</span>
  // Load narrow oop
  instruct loadN(iRegN dst, memory mem) %{
    match(Set dst (LoadN mem));
    ins_cost(MEMORY_REF_COST);
    size(Z_DISP3_SIZE);
<span class="line-modified">!   format %{ &quot;LoadN   $dst,$mem\t # (cOop)&quot; %}</span>
    opcode(LLGF_ZOPC, LLGF_ZOPC);
    ins_encode(z_form_rt_mem_opt(dst, mem));
    ins_pipe(pipe_class_dummy);
  %}
  
  // Load narrow Klass Pointer
  instruct loadNKlass(iRegN dst, memory mem) %{
    match(Set dst (LoadNKlass mem));
    ins_cost(MEMORY_REF_COST);
    size(Z_DISP3_SIZE);
<span class="line-modified">!   format %{ &quot;LoadNKlass $dst,$mem\t # (klass cOop)&quot; %}</span>
    opcode(LLGF_ZOPC, LLGF_ZOPC);
    ins_encode(z_form_rt_mem_opt(dst, mem));
    ins_pipe(pipe_class_dummy);
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4760,25 ***</span>
  // Load and Decode Compressed Pointer
  // optimized variants for Unscaled cOops
  
  instruct decodeLoadN(iRegP dst, memory mem) %{
    match(Set dst (DecodeN (LoadN mem)));
<span class="line-modified">!   predicate(false &amp;&amp; (Universe::narrow_oop_base()==NULL)&amp;&amp;(Universe::narrow_oop_shift()==0));</span>
    ins_cost(MEMORY_REF_COST);
    size(Z_DISP3_SIZE);
<span class="line-modified">!   format %{ &quot;DecodeLoadN  $dst,$mem\t# (cOop Load+Decode)&quot; %}</span>
    opcode(LLGF_ZOPC, LLGF_ZOPC);
    ins_encode(z_form_rt_mem_opt(dst, mem));
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct decodeLoadNKlass(iRegP dst, memory mem) %{
    match(Set dst (DecodeNKlass (LoadNKlass mem)));
<span class="line-modified">!   predicate(false &amp;&amp; (Universe::narrow_klass_base()==NULL)&amp;&amp;(Universe::narrow_klass_shift()==0));</span>
    ins_cost(MEMORY_REF_COST);
    size(Z_DISP3_SIZE);
<span class="line-modified">!   format %{ &quot;DecodeLoadNKlass  $dst,$mem\t# (load/decode NKlass)&quot; %}</span>
    opcode(LLGF_ZOPC, LLGF_ZOPC);
    ins_encode(z_form_rt_mem_opt(dst, mem));
    ins_pipe(pipe_class_dummy);
  %}
  
<span class="line-new-header">--- 4815,25 ---</span>
  // Load and Decode Compressed Pointer
  // optimized variants for Unscaled cOops
  
  instruct decodeLoadN(iRegP dst, memory mem) %{
    match(Set dst (DecodeN (LoadN mem)));
<span class="line-modified">!   predicate(false &amp;&amp; (CompressedOops::base()==NULL)&amp;&amp;(CompressedOops::shift()==0));</span>
    ins_cost(MEMORY_REF_COST);
    size(Z_DISP3_SIZE);
<span class="line-modified">!   format %{ &quot;DecodeLoadN  $dst,$mem\t # (cOop Load+Decode)&quot; %}</span>
    opcode(LLGF_ZOPC, LLGF_ZOPC);
    ins_encode(z_form_rt_mem_opt(dst, mem));
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct decodeLoadNKlass(iRegP dst, memory mem) %{
    match(Set dst (DecodeNKlass (LoadNKlass mem)));
<span class="line-modified">!   predicate(false &amp;&amp; (CompressedKlassPointers::base()==NULL)&amp;&amp;(CompressedKlassPointers::shift()==0));</span>
    ins_cost(MEMORY_REF_COST);
    size(Z_DISP3_SIZE);
<span class="line-modified">!   format %{ &quot;DecodeLoadNKlass  $dst,$mem\t # (load/decode NKlass)&quot; %}</span>
    opcode(LLGF_ZOPC, LLGF_ZOPC);
    ins_encode(z_form_rt_mem_opt(dst, mem));
    ins_pipe(pipe_class_dummy);
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4799,14 ***</span>
  
  // General decoder
  instruct decodeN(iRegP dst, iRegN src, flagsReg cr) %{
    match(Set dst (DecodeN src));
    effect(KILL cr);
<span class="line-modified">!   predicate(Universe::narrow_oop_base() == NULL || !ExpandLoadingBaseDecode);</span>
    ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!   format %{ &quot;decodeN  $dst,$src\t# (decode cOop)&quot; %}</span>
    ins_encode %{  __ oop_decoder($dst$$Register, $src$$Register, true); %}
    ins_pipe(pipe_class_dummy);
  %}
  
  // General Klass decoder
<span class="line-new-header">--- 4854,14 ---</span>
  
  // General decoder
  instruct decodeN(iRegP dst, iRegN src, flagsReg cr) %{
    match(Set dst (DecodeN src));
    effect(KILL cr);
<span class="line-modified">!   predicate(CompressedOops::base() == NULL || !ExpandLoadingBaseDecode);</span>
    ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!   format %{ &quot;decodeN  $dst,$src\t # (decode cOop)&quot; %}</span>
    ins_encode %{  __ oop_decoder($dst$$Register, $src$$Register, true); %}
    ins_pipe(pipe_class_dummy);
  %}
  
  // General Klass decoder
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4823,14 ***</span>
  instruct decodeN_NN(iRegP dst, iRegN src, flagsReg cr) %{
    match(Set dst (DecodeN src));
    effect(KILL cr);
    predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
               n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified">!             (Universe::narrow_oop_base()== NULL || !ExpandLoadingBaseDecode_NN));</span>
    ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!   format %{ &quot;decodeN  $dst,$src\t# (decode cOop NN)&quot; %}</span>
    ins_encode %{ __ oop_decoder($dst$$Register, $src$$Register, false); %}
    ins_pipe(pipe_class_dummy);
  %}
  
    instruct loadBase(iRegL dst, immL baseImm) %{
<span class="line-new-header">--- 4878,14 ---</span>
  instruct decodeN_NN(iRegP dst, iRegN src, flagsReg cr) %{
    match(Set dst (DecodeN src));
    effect(KILL cr);
    predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
               n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified">!             (CompressedOops::base()== NULL || !ExpandLoadingBaseDecode_NN));</span>
    ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!   format %{ &quot;decodeN  $dst,$src\t # (decode cOop NN)&quot; %}</span>
    ins_encode %{ __ oop_decoder($dst$$Register, $src$$Register, false); %}
    ins_pipe(pipe_class_dummy);
  %}
  
    instruct loadBase(iRegL dst, immL baseImm) %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4849,40 ***</span>
      // generate wrong code. Oop_decoder generates additional lgr when
      // dst==base.
      effect(KILL cr);
      predicate(false);
      // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!     format %{ &quot;decodeN  $dst = ($src == 0) ? NULL : ($src &lt;&lt; 3) + $base + pow2_offset\t# (decode cOop)&quot; %}</span>
      ins_encode %{
        __ oop_decoder($dst$$Register, $src$$Register, true, $base$$Register,
<span class="line-modified">!                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)Universe::narrow_oop_base()));</span>
      %}
      ins_pipe(pipe_class_dummy);
    %}
  
    // Decoder for heapbased mode peeling off loading the base.
    instruct decodeN_NN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
      match(Set dst (DecodeN src base));
      effect(KILL cr);
      predicate(false);
      // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!     format %{ &quot;decodeN  $dst = ($src &lt;&lt; 3) + $base + pow2_offset\t# (decode cOop)&quot; %}</span>
      ins_encode %{
        __ oop_decoder($dst$$Register, $src$$Register, false, $base$$Register,
<span class="line-modified">!                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)Universe::narrow_oop_base()));</span>
      %}
      ins_pipe(pipe_class_dummy);
    %}
  
  // Decoder for heapbased mode peeling off loading the base.
  instruct decodeN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
    match(Set dst (DecodeN src));
<span class="line-modified">!   predicate(Universe::narrow_oop_base() != NULL &amp;&amp; ExpandLoadingBaseDecode);</span>
    ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
    expand %{
<span class="line-modified">!     immL baseImm %{ (jlong)(intptr_t)Universe::narrow_oop_base() %}</span>
      iRegL base;
      loadBase(base, baseImm);
      decodeN_base(dst, src, base, cr);
    %}
  %}
<span class="line-new-header">--- 4904,40 ---</span>
      // generate wrong code. Oop_decoder generates additional lgr when
      // dst==base.
      effect(KILL cr);
      predicate(false);
      // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!     format %{ &quot;decodeN  $dst = ($src == 0) ? NULL : ($src &lt;&lt; 3) + $base + pow2_offset\t # (decode cOop)&quot; %}</span>
      ins_encode %{
        __ oop_decoder($dst$$Register, $src$$Register, true, $base$$Register,
<span class="line-modified">!                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)CompressedOops::base()));</span>
      %}
      ins_pipe(pipe_class_dummy);
    %}
  
    // Decoder for heapbased mode peeling off loading the base.
    instruct decodeN_NN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
      match(Set dst (DecodeN src base));
      effect(KILL cr);
      predicate(false);
      // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!     format %{ &quot;decodeN  $dst = ($src &lt;&lt; 3) + $base + pow2_offset\t # (decode cOop)&quot; %}</span>
      ins_encode %{
        __ oop_decoder($dst$$Register, $src$$Register, false, $base$$Register,
<span class="line-modified">!                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)CompressedOops::base()));</span>
      %}
      ins_pipe(pipe_class_dummy);
    %}
  
  // Decoder for heapbased mode peeling off loading the base.
  instruct decodeN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
    match(Set dst (DecodeN src));
<span class="line-modified">!   predicate(CompressedOops::base() != NULL &amp;&amp; ExpandLoadingBaseDecode);</span>
    ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
    expand %{
<span class="line-modified">!     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}</span>
      iRegL base;
      loadBase(base, baseImm);
      decodeN_base(dst, src, base, cr);
    %}
  %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4890,15 ***</span>
  // Decoder for heapbased mode peeling off loading the base.
  instruct decodeN_NN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
    match(Set dst (DecodeN src));
    predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
               n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified">!             Universe::narrow_oop_base() != NULL &amp;&amp; ExpandLoadingBaseDecode_NN);</span>
    ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
    expand %{
<span class="line-modified">!     immL baseImm %{ (jlong)(intptr_t)Universe::narrow_oop_base() %}</span>
      iRegL base;
      loadBase(base, baseImm);
      decodeN_NN_base(dst, src, base, cr);
    %}
  %}
<span class="line-new-header">--- 4945,15 ---</span>
  // Decoder for heapbased mode peeling off loading the base.
  instruct decodeN_NN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
    match(Set dst (DecodeN src));
    predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
               n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
<span class="line-modified">!             CompressedOops::base() != NULL &amp;&amp; ExpandLoadingBaseDecode_NN);</span>
    ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
    expand %{
<span class="line-modified">!     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}</span>
      iRegL base;
      loadBase(base, baseImm);
      decodeN_NN_base(dst, src, base, cr);
    %}
  %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4908,16 ***</span>
  // General encoder
  instruct encodeP(iRegN dst, iRegP src, flagsReg cr) %{
    match(Set dst (EncodeP src));
    effect(KILL cr);
    predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
<span class="line-modified">!             (Universe::narrow_oop_base() == 0 ||</span>
<span class="line-modified">!              Universe::narrow_oop_base_disjoint() ||</span>
               !ExpandLoadingBaseEncode));
    ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!   format %{ &quot;encodeP  $dst,$src\t# (encode cOop)&quot; %}</span>
    ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, true, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
    ins_pipe(pipe_class_dummy);
  %}
  
  // General class encoder
<span class="line-new-header">--- 4963,16 ---</span>
  // General encoder
  instruct encodeP(iRegN dst, iRegP src, flagsReg cr) %{
    match(Set dst (EncodeP src));
    effect(KILL cr);
    predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
<span class="line-modified">!             (CompressedOops::base() == 0 ||</span>
<span class="line-modified">!              CompressedOops::base_disjoint() ||</span>
               !ExpandLoadingBaseEncode));
    ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!   format %{ &quot;encodeP  $dst,$src\t # (encode cOop)&quot; %}</span>
    ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, true, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
    ins_pipe(pipe_class_dummy);
  %}
  
  // General class encoder
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4931,16 ***</span>
  
  instruct encodeP_NN(iRegN dst, iRegP src, flagsReg cr) %{
    match(Set dst (EncodeP src));
    effect(KILL cr);
    predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
<span class="line-modified">!             (Universe::narrow_oop_base() == 0 ||</span>
<span class="line-modified">!              Universe::narrow_oop_base_disjoint() ||</span>
               !ExpandLoadingBaseEncode_NN));
    ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!   format %{ &quot;encodeP  $dst,$src\t# (encode cOop)&quot; %}</span>
    ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
    ins_pipe(pipe_class_dummy);
  %}
  
    // Encoder for heapbased mode peeling off loading the base.
<span class="line-new-header">--- 4986,16 ---</span>
  
  instruct encodeP_NN(iRegN dst, iRegP src, flagsReg cr) %{
    match(Set dst (EncodeP src));
    effect(KILL cr);
    predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
<span class="line-modified">!             (CompressedOops::base() == 0 ||</span>
<span class="line-modified">!              CompressedOops::base_disjoint() ||</span>
               !ExpandLoadingBaseEncode_NN));
    ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!   format %{ &quot;encodeP  $dst,$src\t # (encode cOop)&quot; %}</span>
    ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
    ins_pipe(pipe_class_dummy);
  %}
  
    // Encoder for heapbased mode peeling off loading the base.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4948,14 ***</span>
      match(Set dst (EncodeP src (Binary base dst)));
      effect(TEMP_DEF dst);
      predicate(false);
      ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
      // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + pow2_offset\t# (encode cOop)&quot; %}</span>
      ins_encode %{
        jlong offset = -(jlong)MacroAssembler::get_oop_base_pow2_offset
<span class="line-modified">!         (((uint64_t)(intptr_t)Universe::narrow_oop_base()) &gt;&gt; Universe::narrow_oop_shift());</span>
        __ oop_encoder($dst$$Register, $src$$Register, true, $base$$Register, offset);
      %}
      ins_pipe(pipe_class_dummy);
    %}
  
<span class="line-new-header">--- 5003,14 ---</span>
      match(Set dst (EncodeP src (Binary base dst)));
      effect(TEMP_DEF dst);
      predicate(false);
      ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
      // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + pow2_offset\t # (encode cOop)&quot; %}</span>
      ins_encode %{
        jlong offset = -(jlong)MacroAssembler::get_oop_base_pow2_offset
<span class="line-modified">!         (((uint64_t)(intptr_t)CompressedOops::base()) &gt;&gt; CompressedOops::shift());</span>
        __ oop_encoder($dst$$Register, $src$$Register, true, $base$$Register, offset);
      %}
      ins_pipe(pipe_class_dummy);
    %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4964,25 ***</span>
      match(Set dst (EncodeP src base));
      effect(USE pow2_offset);
      predicate(false);
      ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
      // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + $pow2_offset\t# (encode cOop)&quot; %}</span>
      ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, $base$$Register, $pow2_offset$$constant); %}
      ins_pipe(pipe_class_dummy);
    %}
  
  // Encoder for heapbased mode peeling off loading the base.
  instruct encodeP_Ex(iRegN dst, iRegP src, flagsReg cr) %{
    match(Set dst (EncodeP src));
    effect(KILL cr);
    predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
<span class="line-modified">!             (Universe::narrow_oop_base_overlaps() &amp;&amp; ExpandLoadingBaseEncode));</span>
    ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
    expand %{
<span class="line-modified">!     immL baseImm %{ ((jlong)(intptr_t)Universe::narrow_oop_base()) &gt;&gt; Universe::narrow_oop_shift() %}</span>
      immL_0 zero %{ (0) %}
      flagsReg ccr;
      iRegL base;
      iRegL negBase;
      loadBase(base, baseImm);
<span class="line-new-header">--- 5019,25 ---</span>
      match(Set dst (EncodeP src base));
      effect(USE pow2_offset);
      predicate(false);
      ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
      // TODO: s390 port size(VARIABLE_SIZE);
<span class="line-modified">!     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + $pow2_offset\t # (encode cOop)&quot; %}</span>
      ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, $base$$Register, $pow2_offset$$constant); %}
      ins_pipe(pipe_class_dummy);
    %}
  
  // Encoder for heapbased mode peeling off loading the base.
  instruct encodeP_Ex(iRegN dst, iRegP src, flagsReg cr) %{
    match(Set dst (EncodeP src));
    effect(KILL cr);
    predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
<span class="line-modified">!             (CompressedOops::base_overlaps() &amp;&amp; ExpandLoadingBaseEncode));</span>
    ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
    expand %{
<span class="line-modified">!     immL baseImm %{ ((jlong)(intptr_t)CompressedOops::base()) &gt;&gt; CompressedOops::shift() %}</span>
      immL_0 zero %{ (0) %}
      flagsReg ccr;
      iRegL base;
      iRegL negBase;
      loadBase(base, baseImm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4994,16 ***</span>
  // Encoder for heapbased mode peeling off loading the base.
  instruct encodeP_NN_Ex(iRegN dst, iRegP src, flagsReg cr) %{
    match(Set dst (EncodeP src));
    effect(KILL cr);
    predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
<span class="line-modified">!             (Universe::narrow_oop_base_overlaps() &amp;&amp; ExpandLoadingBaseEncode_NN));</span>
    ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
    expand %{
<span class="line-modified">!     immL baseImm %{ (jlong)(intptr_t)Universe::narrow_oop_base() %}</span>
<span class="line-modified">!     immL pow2_offset %{ -(jlong)MacroAssembler::get_oop_base_pow2_offset(((uint64_t)(intptr_t)Universe::narrow_oop_base())) %}</span>
      immL_0 zero %{ 0 %}
      flagsReg ccr;
      iRegL base;
      iRegL negBase;
      loadBase(base, baseImm);
<span class="line-new-header">--- 5049,16 ---</span>
  // Encoder for heapbased mode peeling off loading the base.
  instruct encodeP_NN_Ex(iRegN dst, iRegP src, flagsReg cr) %{
    match(Set dst (EncodeP src));
    effect(KILL cr);
    predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
<span class="line-modified">!             (CompressedOops::base_overlaps() &amp;&amp; ExpandLoadingBaseEncode_NN));</span>
    ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
    // TODO: s390 port size(VARIABLE_SIZE);
    expand %{
<span class="line-modified">!     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}</span>
<span class="line-modified">!     immL pow2_offset %{ -(jlong)MacroAssembler::get_oop_base_pow2_offset(((uint64_t)(intptr_t)CompressedOops::base())) %}</span>
      immL_0 zero %{ 0 %}
      flagsReg ccr;
      iRegL base;
      iRegL negBase;
      loadBase(base, baseImm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5017,22 ***</span>
  // Store Compressed Pointer
  instruct storeN(memory mem, iRegN_P2N src) %{
    match(Set mem (StoreN mem src));
    ins_cost(MEMORY_REF_COST);
    size(Z_DISP_SIZE);
<span class="line-modified">!   format %{ &quot;ST      $src,$mem\t# (cOop)&quot; %}</span>
    opcode(STY_ZOPC, ST_ZOPC);
    ins_encode(z_form_rt_mem_opt(src, mem));
    ins_pipe(pipe_class_dummy);
  %}
  
  // Store Compressed Klass pointer
  instruct storeNKlass(memory mem, iRegN src) %{
    match(Set mem (StoreNKlass mem src));
    ins_cost(MEMORY_REF_COST);
    size(Z_DISP_SIZE);
<span class="line-modified">!   format %{ &quot;ST      $src,$mem\t# (cKlass)&quot; %}</span>
    opcode(STY_ZOPC, ST_ZOPC);
    ins_encode(z_form_rt_mem_opt(src, mem));
    ins_pipe(pipe_class_dummy);
  %}
  
<span class="line-new-header">--- 5072,22 ---</span>
  // Store Compressed Pointer
  instruct storeN(memory mem, iRegN_P2N src) %{
    match(Set mem (StoreN mem src));
    ins_cost(MEMORY_REF_COST);
    size(Z_DISP_SIZE);
<span class="line-modified">!   format %{ &quot;ST      $src,$mem\t # (cOop)&quot; %}</span>
    opcode(STY_ZOPC, ST_ZOPC);
    ins_encode(z_form_rt_mem_opt(src, mem));
    ins_pipe(pipe_class_dummy);
  %}
  
  // Store Compressed Klass pointer
  instruct storeNKlass(memory mem, iRegN src) %{
    match(Set mem (StoreNKlass mem src));
    ins_cost(MEMORY_REF_COST);
    size(Z_DISP_SIZE);
<span class="line-modified">!   format %{ &quot;ST      $src,$mem\t # (cKlass)&quot; %}</span>
    opcode(STY_ZOPC, ST_ZOPC);
    ins_encode(z_form_rt_mem_opt(src, mem));
    ins_pipe(pipe_class_dummy);
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5040,21 ***</span>
  
  instruct compN_iRegN(iRegN_P2N src1, iRegN_P2N src2, flagsReg cr) %{
    match(Set cr (CmpN src1 src2));
    ins_cost(DEFAULT_COST);
    size(2);
<span class="line-modified">!   format %{ &quot;CLR     $src1,$src2\t# (cOop)&quot; %}</span>
    opcode(CLR_ZOPC);
    ins_encode(z_rrform(src1, src2));
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct compN_iRegN_immN(iRegN_P2N src1, immN src2, flagsReg cr) %{
    match(Set cr (CmpN src1 src2));
    ins_cost(DEFAULT_COST);
    size(6);
<span class="line-modified">!   format %{ &quot;CLFI    $src1,$src2\t# (cOop) compare immediate narrow&quot; %}</span>
    ins_encode %{
      AddressLiteral cOop = __ constant_oop_address((jobject)$src2$$constant);
      __ relocate(cOop.rspec(), 1);
      __ compare_immediate_narrow_oop($src1$$Register, (narrowOop)cOop.value());
    %}
<span class="line-new-header">--- 5095,21 ---</span>
  
  instruct compN_iRegN(iRegN_P2N src1, iRegN_P2N src2, flagsReg cr) %{
    match(Set cr (CmpN src1 src2));
    ins_cost(DEFAULT_COST);
    size(2);
<span class="line-modified">!   format %{ &quot;CLR     $src1,$src2\t # (cOop)&quot; %}</span>
    opcode(CLR_ZOPC);
    ins_encode(z_rrform(src1, src2));
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct compN_iRegN_immN(iRegN_P2N src1, immN src2, flagsReg cr) %{
    match(Set cr (CmpN src1 src2));
    ins_cost(DEFAULT_COST);
    size(6);
<span class="line-modified">!   format %{ &quot;CLFI    $src1,$src2\t # (cOop) compare immediate narrow&quot; %}</span>
    ins_encode %{
      AddressLiteral cOop = __ constant_oop_address((jobject)$src2$$constant);
      __ relocate(cOop.rspec(), 1);
      __ compare_immediate_narrow_oop($src1$$Register, (narrowOop)cOop.value());
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5063,11 ***</span>
  
  instruct compNKlass_iRegN_immN(iRegN src1, immNKlass src2, flagsReg cr) %{
    match(Set cr (CmpN src1 src2));
    ins_cost(DEFAULT_COST);
    size(6);
<span class="line-modified">!   format %{ &quot;CLFI    $src1,$src2\t# (NKlass) compare immediate narrow&quot; %}</span>
    ins_encode %{
      AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src2$$constant);
      __ relocate(NKlass.rspec(), 1);
      __ compare_immediate_narrow_klass($src1$$Register, (Klass*)NKlass.value());
    %}
<span class="line-new-header">--- 5118,11 ---</span>
  
  instruct compNKlass_iRegN_immN(iRegN src1, immNKlass src2, flagsReg cr) %{
    match(Set cr (CmpN src1 src2));
    ins_cost(DEFAULT_COST);
    size(6);
<span class="line-modified">!   format %{ &quot;CLFI    $src1,$src2\t # (NKlass) compare immediate narrow&quot; %}</span>
    ins_encode %{
      AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src2$$constant);
      __ relocate(NKlass.rspec(), 1);
      __ compare_immediate_narrow_klass($src1$$Register, (Klass*)NKlass.value());
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5076,11 ***</span>
  
  instruct compN_iRegN_immN0(iRegN_P2N src1, immN0 src2, flagsReg cr) %{
    match(Set cr (CmpN src1 src2));
    ins_cost(DEFAULT_COST);
    size(2);
<span class="line-modified">!   format %{ &quot;LTR     $src1,$src2\t# (cOop) LTR because comparing against zero&quot; %}</span>
    opcode(LTR_ZOPC);
    ins_encode(z_rrform(src1, src1));
    ins_pipe(pipe_class_dummy);
  %}
  
<span class="line-new-header">--- 5131,11 ---</span>
  
  instruct compN_iRegN_immN0(iRegN_P2N src1, immN0 src2, flagsReg cr) %{
    match(Set cr (CmpN src1 src2));
    ins_cost(DEFAULT_COST);
    size(2);
<span class="line-modified">!   format %{ &quot;LTR     $src1,$src2\t # (cOop) LTR because comparing against zero&quot; %}</span>
    opcode(LTR_ZOPC);
    ins_encode(z_rrform(src1, src1));
    ins_pipe(pipe_class_dummy);
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5369,10 ***</span>
<span class="line-new-header">--- 5424,18 ---</span>
    format %{ &quot;# castII of $dst&quot; %}
    ins_encode(/*empty*/);
    ins_pipe(pipe_class_dummy);
  %}
  
<span class="line-added">+ instruct castLL(iRegL dst) %{</span>
<span class="line-added">+   match(Set dst (CastLL dst));</span>
<span class="line-added">+   size(0);</span>
<span class="line-added">+   format %{ &quot;# castLL of $dst&quot; %}</span>
<span class="line-added">+   ins_encode(/*empty*/);</span>
<span class="line-added">+   ins_pipe(pipe_class_dummy);</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  
  //----------Conditional_store--------------------------------------------------
  // Conditional-store of the updated heap-top.
  // Used during allocation of the shared heap.
  // Sets flags (EQ) on success.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6185,11 ***</span>
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct addP_regN_reg_imm12(iRegP dst, iRegP_N2P src1, iRegL src2, uimmL12 con) %{
    match(Set dst (AddP (AddP src1 src2) con));
<span class="line-modified">!   predicate( PreferLAoverADD &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0);</span>
    ins_cost(DEFAULT_COST_LOW);
    size(4);
    format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
    opcode(LA_ZOPC);
    ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
<span class="line-new-header">--- 6248,11 ---</span>
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct addP_regN_reg_imm12(iRegP dst, iRegP_N2P src1, iRegL src2, uimmL12 con) %{
    match(Set dst (AddP (AddP src1 src2) con));
<span class="line-modified">!   predicate( PreferLAoverADD &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);</span>
    ins_cost(DEFAULT_COST_LOW);
    size(4);
    format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
    opcode(LA_ZOPC);
    ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6207,11 ***</span>
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct addP_regN_reg_imm20(iRegP dst, iRegP_N2P src1, iRegL src2, immL20 con) %{
    match(Set dst (AddP (AddP src1 src2) con));
<span class="line-modified">!   predicate( PreferLAoverADD &amp;&amp; Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0);</span>
    ins_cost(DEFAULT_COST);
    // TODO: s390 port size(FIXED_SIZE);
    format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
    opcode(LAY_ZOPC);
    ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
<span class="line-new-header">--- 6270,11 ---</span>
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct addP_regN_reg_imm20(iRegP dst, iRegP_N2P src1, iRegL src2, immL20 con) %{
    match(Set dst (AddP (AddP src1 src2) con));
<span class="line-modified">!   predicate( PreferLAoverADD &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);</span>
    ins_cost(DEFAULT_COST);
    // TODO: s390 port size(FIXED_SIZE);
    format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
    opcode(LAY_ZOPC);
    ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6771,11 ***</span>
  instruct sllI_reg_reg(iRegI dst, iRegI src, iRegI nbits, flagsReg cr) %{
    match(Set dst (LShiftI src nbits));
    effect(KILL cr); // R1 is killed, too.
    ins_cost(3 * DEFAULT_COST);
    size(14);
<span class="line-modified">!   format %{ &quot;SLL     $dst,$src,[$nbits] &amp; 31\t# use RISC-like SLLG also for int&quot; %}</span>
    ins_encode %{
      __ z_lgr(Z_R1_scratch, $nbits$$Register);
      __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
      __ z_sllg($dst$$Register, $src$$Register, 0, Z_R1_scratch);
    %}
<span class="line-new-header">--- 6834,11 ---</span>
  instruct sllI_reg_reg(iRegI dst, iRegI src, iRegI nbits, flagsReg cr) %{
    match(Set dst (LShiftI src nbits));
    effect(KILL cr); // R1 is killed, too.
    ins_cost(3 * DEFAULT_COST);
    size(14);
<span class="line-modified">!   format %{ &quot;SLL     $dst,$src,[$nbits] &amp; 31\t # use RISC-like SLLG also for int&quot; %}</span>
    ins_encode %{
      __ z_lgr(Z_R1_scratch, $nbits$$Register);
      __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
      __ z_sllg($dst$$Register, $src$$Register, 0, Z_R1_scratch);
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6785,11 ***</span>
  // Register Shift Left Immediate
  // Constant shift count is masked in ideal graph already.
  instruct sllI_reg_imm(iRegI dst, iRegI src, immI nbits) %{
    match(Set dst (LShiftI src nbits));
    size(6);
<span class="line-modified">!   format %{ &quot;SLL     $dst,$src,$nbits\t# use RISC-like SLLG also for int&quot; %}</span>
    ins_encode %{
      int Nbit = $nbits$$constant;
      assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
      __ z_sllg($dst$$Register, $src$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
    %}
<span class="line-new-header">--- 6848,11 ---</span>
  // Register Shift Left Immediate
  // Constant shift count is masked in ideal graph already.
  instruct sllI_reg_imm(iRegI dst, iRegI src, immI nbits) %{
    match(Set dst (LShiftI src nbits));
    size(6);
<span class="line-modified">!   format %{ &quot;SLL     $dst,$src,$nbits\t # use RISC-like SLLG also for int&quot; %}</span>
    ins_encode %{
      int Nbit = $nbits$$constant;
      assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
      __ z_sllg($dst$$Register, $src$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
    %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7101,22 ***</span>
  %}
  
  instruct overflowNegI_rReg(flagsReg cr, immI_0 zero, iRegI op2) %{
    match(Set cr (OverflowSubI zero op2));
    effect(DEF cr, USE op2);
<span class="line-modified">!   format %{ &quot;NEG    $op2\t# overflow check int&quot; %}</span>
    ins_encode %{
      __ clear_reg(Z_R0_scratch, false, false);
      __ z_sr(Z_R0_scratch, $op2$$Register);
    %}
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct overflowNegL_rReg(flagsReg cr, immL_0 zero, iRegL op2) %{
    match(Set cr (OverflowSubL zero op2));
    effect(DEF cr, USE op2);
<span class="line-modified">!   format %{ &quot;NEGG    $op2\t# overflow check long&quot; %}</span>
    ins_encode %{
      __ clear_reg(Z_R0_scratch, true, false);
      __ z_sgr(Z_R0_scratch, $op2$$Register);
    %}
    ins_pipe(pipe_class_dummy);
<span class="line-new-header">--- 7164,22 ---</span>
  %}
  
  instruct overflowNegI_rReg(flagsReg cr, immI_0 zero, iRegI op2) %{
    match(Set cr (OverflowSubI zero op2));
    effect(DEF cr, USE op2);
<span class="line-modified">!   format %{ &quot;NEG    $op2\t # overflow check int&quot; %}</span>
    ins_encode %{
      __ clear_reg(Z_R0_scratch, false, false);
      __ z_sr(Z_R0_scratch, $op2$$Register);
    %}
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct overflowNegL_rReg(flagsReg cr, immL_0 zero, iRegL op2) %{
    match(Set cr (OverflowSubL zero op2));
    effect(DEF cr, USE op2);
<span class="line-modified">!   format %{ &quot;NEGG    $op2\t # overflow check long&quot; %}</span>
    ins_encode %{
      __ clear_reg(Z_R0_scratch, true, false);
      __ z_sgr(Z_R0_scratch, $op2$$Register);
    %}
    ins_pipe(pipe_class_dummy);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8531,11 ***</span>
  %}
  
  // Don&#39;t use LTGFR which performs sign extend.
  instruct compP_decode_reg_imm0(flagsReg cr, iRegN op1, immP0 op2) %{
    match(Set cr (CmpP (DecodeN op1) op2));
<span class="line-modified">!   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_oop_shift() == 0);</span>
    ins_cost(DEFAULT_COST_LOW);
    size(2);
    format %{ &quot;LTR    $op1, $op1\t # ptr&quot; %}
    opcode(LTR_ZOPC);
    ins_encode(z_rrform(op1, op1));
<span class="line-new-header">--- 8594,11 ---</span>
  %}
  
  // Don&#39;t use LTGFR which performs sign extend.
  instruct compP_decode_reg_imm0(flagsReg cr, iRegN op1, immP0 op2) %{
    match(Set cr (CmpP (DecodeN op1) op2));
<span class="line-modified">!   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);</span>
    ins_cost(DEFAULT_COST_LOW);
    size(2);
    format %{ &quot;LTR    $op1, $op1\t # ptr&quot; %}
    opcode(LTR_ZOPC);
    ins_encode(z_rrform(op1, op1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9167,11 ***</span>
    // Same match rule as `branchConFar&#39;.
    match(If cmp cr);
    effect(USE lbl);
    ins_cost(BRANCH_COST);
    size(4);
<span class="line-modified">!   format %{ &quot;branch_con_short,$cmp   $cr, $lbl&quot; %}</span>
    ins_encode(z_enc_branch_con_short(cmp, lbl));
    ins_pipe(pipe_class_dummy);
    // If set to 1 this indicates that the current instruction is a
    // short variant of a long branch. This avoids using this
    // instruction in first-pass matching. It will then only be used in
<span class="line-new-header">--- 9230,11 ---</span>
    // Same match rule as `branchConFar&#39;.
    match(If cmp cr);
    effect(USE lbl);
    ins_cost(BRANCH_COST);
    size(4);
<span class="line-modified">!   format %{ &quot;branch_con_short,$cmp   $lbl&quot; %}</span>
    ins_encode(z_enc_branch_con_short(cmp, lbl));
    ins_pipe(pipe_class_dummy);
    // If set to 1 this indicates that the current instruction is a
    // short variant of a long branch. This avoids using this
    // instruction in first-pass matching. It will then only be used in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9189,11 ***</span>
    match(If cmp cr);
    effect(USE cr, USE lbl);
    // Make more expensive to prefer compare_and_branch over separate instructions.
    ins_cost(2 * BRANCH_COST);
    size(6);
<span class="line-modified">!   format %{ &quot;branch_con_far,$cmp   $cr, $lbl&quot; %}</span>
    ins_encode(z_enc_branch_con_far(cmp, lbl));
    ins_pipe(pipe_class_dummy);
    // This is not a short variant of a branch, but the long variant..
    ins_short_branch(0);
  %}
<span class="line-new-header">--- 9252,11 ---</span>
    match(If cmp cr);
    effect(USE cr, USE lbl);
    // Make more expensive to prefer compare_and_branch over separate instructions.
    ins_cost(2 * BRANCH_COST);
    size(6);
<span class="line-modified">!   format %{ &quot;branch_con_far,$cmp   $lbl&quot; %}</span>
    ins_encode(z_enc_branch_con_far(cmp, lbl));
    ins_pipe(pipe_class_dummy);
    // This is not a short variant of a branch, but the long variant..
    ins_short_branch(0);
  %}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9758,11 ***</span>
  // TailJump below removes the return address.
  instruct TailCalljmpInd(iRegP jump_target, inline_cache_regP method_oop) %{
    match(TailCall jump_target method_oop);
    ins_cost(CALL_COST);
    size(2);
<span class="line-modified">!   format %{ &quot;Jmp     $jump_target\t# $method_oop holds method oop&quot; %}</span>
    ins_encode %{ __ z_br($jump_target$$Register); %}
    ins_pipe(pipe_class_dummy);
  %}
  
  // Return Instruction
<span class="line-new-header">--- 9821,11 ---</span>
  // TailJump below removes the return address.
  instruct TailCalljmpInd(iRegP jump_target, inline_cache_regP method_oop) %{
    match(TailCall jump_target method_oop);
    ins_cost(CALL_COST);
    size(2);
<span class="line-modified">!   format %{ &quot;Jmp     $jump_target\t # $method_oop holds method oop&quot; %}</span>
    ins_encode %{ __ z_br($jump_target$$Register); %}
    ins_pipe(pipe_class_dummy);
  %}
  
  // Return Instruction
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9897,27 ***</span>
    format %{ &quot;ClearArrayConst $cnt,$base&quot; %}
    ins_encode %{ __ Clear_Array_Const($cnt$$constant, $base$$Register); %}
    ins_pipe(pipe_class_dummy);
  %}
  
<span class="line-modified">! instruct inlineCallClearArrayConstBig(immL cnt, iRegP_N2P base, Universe dummy, revenRegL srcA, roddRegL srcL, flagsReg cr) %{</span>
    match(Set dummy (ClearArray cnt base));
<span class="line-modified">!   effect(TEMP srcA, TEMP srcL, KILL cr); // R0, R1 are killed, too.</span>
    ins_cost(200);
    // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to optimized constant loader.
    format %{ &quot;ClearArrayConstBig $cnt,$base&quot; %}
<span class="line-modified">!   ins_encode %{ __ Clear_Array_Const_Big($cnt$$constant, $base$$Register, $srcA$$Register, $srcL$$Register); %}</span>
    ins_pipe(pipe_class_dummy);
  %}
  
<span class="line-modified">! instruct inlineCallClearArray(iRegL cnt, iRegP_N2P base, Universe dummy, revenRegL srcA, roddRegL srcL, flagsReg cr) %{</span>
    match(Set dummy (ClearArray cnt base));
<span class="line-modified">!   effect(TEMP srcA, TEMP srcL, KILL cr); // R0, R1 are killed, too.</span>
    ins_cost(300);
    // TODO: s390 port size(FIXED_SIZE);  // z/Architecture: emitted code depends on PreferLAoverADD being on/off.
    format %{ &quot;ClearArrayVar $cnt,$base&quot; %}
<span class="line-modified">!   ins_encode %{ __ Clear_Array($cnt$$Register, $base$$Register, $srcA$$Register, $srcL$$Register); %}</span>
    ins_pipe(pipe_class_dummy);
  %}
  
  // ============================================================================
  // CompactStrings
<span class="line-new-header">--- 9960,27 ---</span>
    format %{ &quot;ClearArrayConst $cnt,$base&quot; %}
    ins_encode %{ __ Clear_Array_Const($cnt$$constant, $base$$Register); %}
    ins_pipe(pipe_class_dummy);
  %}
  
<span class="line-modified">! instruct inlineCallClearArrayConstBig(immL cnt, iRegP_N2P base, Universe dummy, allRoddRegL tmpL, flagsReg cr) %{</span>
    match(Set dummy (ClearArray cnt base));
<span class="line-modified">!   effect(TEMP tmpL, KILL cr); // R0, R1 are killed, too.</span>
    ins_cost(200);
    // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to optimized constant loader.
    format %{ &quot;ClearArrayConstBig $cnt,$base&quot; %}
<span class="line-modified">!   ins_encode %{ __ Clear_Array_Const_Big($cnt$$constant, $base$$Register, $tmpL$$Register); %}</span>
    ins_pipe(pipe_class_dummy);
  %}
  
<span class="line-modified">! instruct inlineCallClearArray(iRegL cnt, iRegP_N2P base, Universe dummy, allRoddRegL tmpL, flagsReg cr) %{</span>
    match(Set dummy (ClearArray cnt base));
<span class="line-modified">!   effect(TEMP tmpL, KILL cr); // R0, R1 are killed, too.</span>
    ins_cost(300);
    // TODO: s390 port size(FIXED_SIZE);  // z/Architecture: emitted code depends on PreferLAoverADD being on/off.
    format %{ &quot;ClearArrayVar $cnt,$base&quot; %}
<span class="line-modified">!   ins_encode %{ __ Clear_Array($cnt$$Register, $base$$Register, $tmpL$$Register); %}</span>
    ins_pipe(pipe_class_dummy);
  %}
  
  // ============================================================================
  // CompactStrings
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10766,22 ***</span>
  instruct bytes_reverse_int(iRegI dst, iRegI src) %{
    match(Set dst (ReverseBytesI src));
    predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
    ins_cost(DEFAULT_COST);
    size(4);
<span class="line-modified">!   format %{ &quot;LRVR    $dst,$src\t# byte reverse int&quot; %}</span>
    opcode(LRVR_ZOPC);
    ins_encode(z_rreform(dst, src));
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct bytes_reverse_long(iRegL dst, iRegL src) %{
    match(Set dst (ReverseBytesL src));
    predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
    ins_cost(DEFAULT_COST);
    // TODO: s390 port size(FIXED_SIZE);
<span class="line-modified">!   format %{ &quot;LRVGR   $dst,$src\t# byte reverse long&quot; %}</span>
    opcode(LRVGR_ZOPC);
    ins_encode(z_rreform(dst, src));
    ins_pipe(pipe_class_dummy);
  %}
  
<span class="line-new-header">--- 10829,22 ---</span>
  instruct bytes_reverse_int(iRegI dst, iRegI src) %{
    match(Set dst (ReverseBytesI src));
    predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
    ins_cost(DEFAULT_COST);
    size(4);
<span class="line-modified">!   format %{ &quot;LRVR    $dst,$src\t # byte reverse int&quot; %}</span>
    opcode(LRVR_ZOPC);
    ins_encode(z_rreform(dst, src));
    ins_pipe(pipe_class_dummy);
  %}
  
  instruct bytes_reverse_long(iRegL dst, iRegL src) %{
    match(Set dst (ReverseBytesL src));
    predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
    ins_cost(DEFAULT_COST);
    // TODO: s390 port size(FIXED_SIZE);
<span class="line-modified">!   format %{ &quot;LRVGR   $dst,$src\t # byte reverse long&quot; %}</span>
    opcode(LRVGR_ZOPC);
    ins_encode(z_rreform(dst, src));
    ins_pipe(pipe_class_dummy);
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10797,12 ***</span>
  instruct countLeadingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
    match(Set dst (CountLeadingZerosI src));
    effect(KILL tmp, KILL cr);
    ins_cost(3 * DEFAULT_COST);
    size(14);
<span class="line-modified">!   format %{ &quot;SLLG    $dst,$src,32\t# no need to always count 32 zeroes first\n\t&quot;</span>
<span class="line-modified">!             &quot;IILH    $dst,0x8000 \t# insert \&quot;stop bit\&quot; to force result 32 for zero src.\n\t&quot;</span>
              &quot;FLOGR   $dst,$dst&quot;
           %}
    ins_encode %{
      // Performance experiments indicate that &quot;FLOGR&quot; is using some kind of
      // iteration to find the leftmost &quot;1&quot; bit.
<span class="line-new-header">--- 10860,12 ---</span>
  instruct countLeadingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
    match(Set dst (CountLeadingZerosI src));
    effect(KILL tmp, KILL cr);
    ins_cost(3 * DEFAULT_COST);
    size(14);
<span class="line-modified">!   format %{ &quot;SLLG    $dst,$src,32\t # no need to always count 32 zeroes first\n\t&quot;</span>
<span class="line-modified">!             &quot;IILH    $dst,0x8000 \t # insert \&quot;stop bit\&quot; to force result 32 for zero src.\n\t&quot;</span>
              &quot;FLOGR   $dst,$dst&quot;
           %}
    ins_encode %{
      // Performance experiments indicate that &quot;FLOGR&quot; is using some kind of
      // iteration to find the leftmost &quot;1&quot; bit.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10835,11 ***</span>
  instruct countLeadingZerosL(revenRegI dst, iRegL src, roddRegI tmp, flagsReg cr) %{
    match(Set dst (CountLeadingZerosL src));
    effect(KILL tmp, KILL cr);
    ins_cost(DEFAULT_COST);
    size(4);
<span class="line-modified">!   format %{ &quot;FLOGR   $dst,$src \t# count leading zeros (long)\n\t&quot; %}</span>
    ins_encode %{ __ z_flogr($dst$$Register, $src$$Register); %}
    ins_pipe(pipe_class_dummy);
  %}
  
  // trailing zeroes
<span class="line-new-header">--- 10898,11 ---</span>
  instruct countLeadingZerosL(revenRegI dst, iRegL src, roddRegI tmp, flagsReg cr) %{
    match(Set dst (CountLeadingZerosL src));
    effect(KILL tmp, KILL cr);
    ins_cost(DEFAULT_COST);
    size(4);
<span class="line-modified">!   format %{ &quot;FLOGR   $dst,$src \t # count leading zeros (long)\n\t&quot; %}</span>
    ins_encode %{ __ z_flogr($dst$$Register, $src$$Register); %}
    ins_pipe(pipe_class_dummy);
  %}
  
  // trailing zeroes
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10860,18 ***</span>
  instruct countTrailingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
    match(Set dst (CountTrailingZerosI src));
    effect(TEMP_DEF dst, TEMP tmp, KILL cr);
    ins_cost(8 * DEFAULT_COST);
    // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
<span class="line-modified">!   format %{ &quot;LLGFR   $dst,$src  \t# clear upper 32 bits (we are dealing with int)\n\t&quot;</span>
<span class="line-modified">!             &quot;LCGFR   $tmp,$src  \t# load 2&#39;s complement (32-&gt;64 bit)\n\t&quot;</span>
<span class="line-modified">!             &quot;AGHI    $dst,-1    \t# tmp1 = src-1\n\t&quot;</span>
<span class="line-modified">!             &quot;AGHI    $tmp,-1    \t# tmp2 = -src-1 = ~src\n\t&quot;</span>
<span class="line-modified">!             &quot;NGR     $dst,$tmp  \t# tmp3 = tmp1&amp;tmp2\n\t&quot;</span>
<span class="line-modified">!             &quot;FLOGR   $dst,$dst  \t# count trailing zeros (int)\n\t&quot;</span>
<span class="line-modified">!             &quot;AHI     $dst,-64   \t# tmp4 = 64-(trailing zeroes)-64\n\t&quot;</span>
<span class="line-modified">!             &quot;LCR     $dst,$dst  \t# res = -tmp4&quot;</span>
           %}
    ins_encode %{
      Register Rdst = $dst$$Register;
      Register Rsrc = $src$$Register;
      // Rtmp only needed for for zero-argument shortcut. With kill effect in
<span class="line-new-header">--- 10923,18 ---</span>
  instruct countTrailingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
    match(Set dst (CountTrailingZerosI src));
    effect(TEMP_DEF dst, TEMP tmp, KILL cr);
    ins_cost(8 * DEFAULT_COST);
    // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
<span class="line-modified">!   format %{ &quot;LLGFR   $dst,$src  \t # clear upper 32 bits (we are dealing with int)\n\t&quot;</span>
<span class="line-modified">!             &quot;LCGFR   $tmp,$src  \t # load 2&#39;s complement (32-&gt;64 bit)\n\t&quot;</span>
<span class="line-modified">!             &quot;AGHI    $dst,-1    \t # tmp1 = src-1\n\t&quot;</span>
<span class="line-modified">!             &quot;AGHI    $tmp,-1    \t # tmp2 = -src-1 = ~src\n\t&quot;</span>
<span class="line-modified">!             &quot;NGR     $dst,$tmp  \t # tmp3 = tmp1&amp;tmp2\n\t&quot;</span>
<span class="line-modified">!             &quot;FLOGR   $dst,$dst  \t # count trailing zeros (int)\n\t&quot;</span>
<span class="line-modified">!             &quot;AHI     $dst,-64   \t # tmp4 = 64-(trailing zeroes)-64\n\t&quot;</span>
<span class="line-modified">!             &quot;LCR     $dst,$dst  \t # res = -tmp4&quot;</span>
           %}
    ins_encode %{
      Register Rdst = $dst$$Register;
      Register Rsrc = $src$$Register;
      // Rtmp only needed for for zero-argument shortcut. With kill effect in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10913,16 ***</span>
  instruct countTrailingZerosL(revenRegI dst, iRegL src, roddRegL tmp, flagsReg cr) %{
    match(Set dst (CountTrailingZerosL src));
    effect(TEMP_DEF dst, KILL tmp, KILL cr);
    ins_cost(8 * DEFAULT_COST);
    // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
<span class="line-modified">!   format %{ &quot;LCGR    $dst,$src  \t# preserve src\n\t&quot;</span>
<span class="line-modified">!             &quot;NGR     $dst,$src  \t#&quot;</span>
<span class="line-modified">!             &quot;AGHI    $dst,-1    \t# tmp1 = src-1\n\t&quot;</span>
<span class="line-modified">!             &quot;FLOGR   $dst,$dst  \t# count trailing zeros (long), kill $tmp\n\t&quot;</span>
<span class="line-modified">!             &quot;AHI     $dst,-64   \t# tmp4 = 64-(trailing zeroes)-64\n\t&quot;</span>
<span class="line-modified">!             &quot;LCR     $dst,$dst  \t#&quot;</span>
           %}
    ins_encode %{
      Register Rdst = $dst$$Register;
      Register Rsrc = $src$$Register;
      assert_different_registers(Rdst, Rsrc); // Rtmp == Rsrc allowed.
<span class="line-new-header">--- 10976,16 ---</span>
  instruct countTrailingZerosL(revenRegI dst, iRegL src, roddRegL tmp, flagsReg cr) %{
    match(Set dst (CountTrailingZerosL src));
    effect(TEMP_DEF dst, KILL tmp, KILL cr);
    ins_cost(8 * DEFAULT_COST);
    // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
<span class="line-modified">!   format %{ &quot;LCGR    $dst,$src  \t # preserve src\n\t&quot;</span>
<span class="line-modified">!             &quot;NGR     $dst,$src  \t #\n\t&quot;</span>
<span class="line-modified">!             &quot;AGHI    $dst,-1    \t # tmp1 = src-1\n\t&quot;</span>
<span class="line-modified">!             &quot;FLOGR   $dst,$dst  \t # count trailing zeros (long), kill $tmp\n\t&quot;</span>
<span class="line-modified">!             &quot;AHI     $dst,-64   \t # tmp4 = 64-(trailing zeroes)-64\n\t&quot;</span>
<span class="line-modified">!             &quot;LCR     $dst,$dst  \t #&quot;</span>
           %}
    ins_encode %{
      Register Rdst = $dst$$Register;
      Register Rsrc = $src$$Register;
      assert_different_registers(Rdst, Rsrc); // Rtmp == Rsrc allowed.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10945,11 ***</span>
    match(Set dst (PopCountI src));
    effect(TEMP_DEF dst, TEMP tmp, KILL cr);
    predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
    ins_cost(DEFAULT_COST);
    size(24);
<span class="line-modified">!   format %{ &quot;POPCNT  $dst,$src\t# pop count int&quot; %}</span>
    ins_encode %{
      Register Rdst = $dst$$Register;
      Register Rsrc = $src$$Register;
      Register Rtmp = $tmp$$Register;
  
<span class="line-new-header">--- 11008,11 ---</span>
    match(Set dst (PopCountI src));
    effect(TEMP_DEF dst, TEMP tmp, KILL cr);
    predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
    ins_cost(DEFAULT_COST);
    size(24);
<span class="line-modified">!   format %{ &quot;POPCNT  $dst,$src\t # pop count int&quot; %}</span>
    ins_encode %{
      Register Rdst = $dst$$Register;
      Register Rsrc = $src$$Register;
      Register Rtmp = $tmp$$Register;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 10972,11 ***</span>
    match(Set dst (PopCountL src));
    effect(TEMP_DEF dst, TEMP tmp, KILL cr);
    predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
    ins_cost(DEFAULT_COST);
    // TODO: s390 port size(FIXED_SIZE);
<span class="line-modified">!   format %{ &quot;POPCNT  $dst,$src\t# pop count long&quot; %}</span>
    ins_encode %{
      Register Rdst = $dst$$Register;
      Register Rsrc = $src$$Register;
      Register Rtmp = $tmp$$Register;
  
<span class="line-new-header">--- 11035,11 ---</span>
    match(Set dst (PopCountL src));
    effect(TEMP_DEF dst, TEMP tmp, KILL cr);
    predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
    ins_cost(DEFAULT_COST);
    // TODO: s390 port size(FIXED_SIZE);
<span class="line-modified">!   format %{ &quot;POPCNT  $dst,$src\t # pop count long&quot; %}</span>
    ins_encode %{
      Register Rdst = $dst$$Register;
      Register Rsrc = $src$$Register;
      Register Rtmp = $tmp$$Register;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 11000,6 ***</span>
  // These must follow all instruction definitions as they use the names
  // defined in the instructions definitions.
  
  // ============================================================================
  // TYPE PROFILING RULES
<span class="line-removed">- </span>
<span class="line-new-header">--- 11063,5 ---</span>
</pre>
<center><a href="relocInfo_s390.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_s390.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
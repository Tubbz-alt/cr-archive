<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/c1_LIRGenerator_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2016, 2017, SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;c1/c1_Compilation.hpp&quot;
  28 #include &quot;c1/c1_FrameMap.hpp&quot;
  29 #include &quot;c1/c1_Instruction.hpp&quot;
  30 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  32 #include &quot;c1/c1_Runtime1.hpp&quot;
  33 #include &quot;c1/c1_ValueStack.hpp&quot;
  34 #include &quot;ci/ciArray.hpp&quot;
  35 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  36 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  37 #include &quot;runtime/sharedRuntime.hpp&quot;
  38 #include &quot;runtime/stubRoutines.hpp&quot;
  39 #include &quot;vmreg_s390.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  40 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  41 
  42 #ifdef ASSERT
  43 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  44 #else
  45 #define __ gen()-&gt;lir()-&gt;
  46 #endif
  47 
  48 void LIRItem::load_byte_item() {
  49   // Byte loads use same registers as other loads.
  50   load_item();
  51 }
  52 
  53 void LIRItem::load_nonconstant(int bits) {
  54   LIR_Opr r = value()-&gt;operand();
  55   if (_gen-&gt;can_inline_as_constant(value(), bits)) {
  56     if (!r-&gt;is_constant()) {
  57       r = LIR_OprFact::value_type(value()-&gt;type());
  58     }
  59     _result = r;
  60   } else {
  61     load_item();
  62   }
  63 }
  64 
  65 //--------------------------------------------------------------
  66 //               LIRGenerator
  67 //--------------------------------------------------------------
  68 
  69 LIR_Opr LIRGenerator::exceptionOopOpr() { return FrameMap::as_oop_opr(Z_EXC_OOP); }
  70 LIR_Opr LIRGenerator::exceptionPcOpr()  { return FrameMap::as_opr(Z_EXC_PC); }
  71 LIR_Opr LIRGenerator::divInOpr()        { return FrameMap::Z_R11_opr; }
  72 LIR_Opr LIRGenerator::divOutOpr()       { return FrameMap::Z_R11_opr; }
  73 LIR_Opr LIRGenerator::remOutOpr()       { return FrameMap::Z_R10_opr; }
  74 LIR_Opr LIRGenerator::ldivInOpr()       { return FrameMap::Z_R11_long_opr; }
  75 LIR_Opr LIRGenerator::ldivOutOpr()      { return FrameMap::Z_R11_long_opr; }
  76 LIR_Opr LIRGenerator::lremOutOpr()      { return FrameMap::Z_R10_long_opr; }
  77 LIR_Opr LIRGenerator::syncLockOpr()     { return new_register(T_INT); }
  78 LIR_Opr LIRGenerator::syncTempOpr()     { return FrameMap::Z_R13_opr; }
  79 LIR_Opr LIRGenerator::getThreadTemp()   { return LIR_OprFact::illegalOpr; }
  80 
  81 LIR_Opr LIRGenerator::result_register_for (ValueType* type, bool callee) {
  82   LIR_Opr opr;
  83   switch (type-&gt;tag()) {
  84     case intTag:    opr = FrameMap::Z_R2_opr;        break;
  85     case objectTag: opr = FrameMap::Z_R2_oop_opr;    break;
  86     case longTag:   opr = FrameMap::Z_R2_long_opr;   break;
  87     case floatTag:  opr = FrameMap::Z_F0_opr;        break;
  88     case doubleTag: opr = FrameMap::Z_F0_double_opr; break;
  89 
  90     case addressTag:
  91     default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
  92   }
  93 
  94   assert(opr-&gt;type_field() == as_OprType(as_BasicType(type)), &quot;type mismatch&quot;);
  95   return opr;
  96 }
  97 
  98 LIR_Opr LIRGenerator::rlock_byte(BasicType type) {
  99   return new_register(T_INT);
 100 }
 101 
 102 //--------- Loading items into registers. --------------------------------
 103 
 104 // z/Architecture cannot inline all constants.
 105 bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {
 106   if (v-&gt;type()-&gt;as_IntConstant() != NULL) {
 107     return Immediate::is_simm16(v-&gt;type()-&gt;as_IntConstant()-&gt;value());
 108   } else if (v-&gt;type()-&gt;as_LongConstant() != NULL) {
 109     return Immediate::is_simm16(v-&gt;type()-&gt;as_LongConstant()-&gt;value());
 110   } else if (v-&gt;type()-&gt;as_ObjectConstant() != NULL) {
 111     return v-&gt;type()-&gt;as_ObjectConstant()-&gt;value()-&gt;is_null_object();
 112   } else {
 113     return false;
 114   }
 115 }
 116 
 117 bool LIRGenerator::can_inline_as_constant(Value i, int bits) const {
 118   if (i-&gt;type()-&gt;as_IntConstant() != NULL) {
 119     return Assembler::is_simm(i-&gt;type()-&gt;as_IntConstant()-&gt;value(), bits);
 120   } else if (i-&gt;type()-&gt;as_LongConstant() != NULL) {
 121     return Assembler::is_simm(i-&gt;type()-&gt;as_LongConstant()-&gt;value(), bits);
 122   } else {
 123     return can_store_as_constant(i, as_BasicType(i-&gt;type()));
 124   }
 125 }
 126 
 127 bool LIRGenerator::can_inline_as_constant(LIR_Const* c) const {
 128   if (c-&gt;type() == T_INT) {
 129     return Immediate::is_simm20(c-&gt;as_jint());
 130   } else   if (c-&gt;type() == T_LONG) {
 131     return Immediate::is_simm20(c-&gt;as_jlong());
 132   }
 133   return false;
 134 }
 135 
 136 LIR_Opr LIRGenerator::safepoint_poll_register() {
 137   return new_register(longType);
 138 }
 139 
 140 LIR_Address* LIRGenerator::generate_address(LIR_Opr base, LIR_Opr index,
 141                                             int shift, int disp, BasicType type) {
 142   assert(base-&gt;is_register(), &quot;must be&quot;);
 143   if (index-&gt;is_constant()) {
 144     intx large_disp = disp;
 145     LIR_Const *constant = index-&gt;as_constant_ptr();
 146     if (constant-&gt;type() == T_LONG) {
 147       large_disp += constant-&gt;as_jlong() &lt;&lt; shift;
 148     } else {
 149       large_disp += (intx)(constant-&gt;as_jint()) &lt;&lt; shift;
 150     }
 151     if (Displacement::is_validDisp(large_disp)) {
 152       return new LIR_Address(base, large_disp, type);
 153     }
 154     // Index is illegal so replace it with the displacement loaded into a register.
 155     index = new_pointer_register();
 156     __ move(LIR_OprFact::intptrConst(large_disp), index);
 157     return new LIR_Address(base, index, type);
 158   } else {
 159     if (shift &gt; 0) {
 160       LIR_Opr tmp = new_pointer_register();
 161       __ shift_left(index, shift, tmp);
 162       index = tmp;
 163     }
 164     return new LIR_Address(base, index, disp, type);
 165   }
 166 }
 167 
 168 LIR_Address* LIRGenerator::emit_array_address(LIR_Opr array_opr, LIR_Opr index_opr,
 169                                               BasicType type) {
 170   int elem_size = type2aelembytes(type);
 171   int shift = exact_log2(elem_size);
 172   int offset_in_bytes = arrayOopDesc::base_offset_in_bytes(type);
 173 
 174   LIR_Address* addr;
 175   if (index_opr-&gt;is_constant()) {
 176     addr = new LIR_Address(array_opr,
 177                            offset_in_bytes + (intx)(index_opr-&gt;as_jint()) * elem_size, type);
 178   } else {
 179     if (index_opr-&gt;type() == T_INT) {
 180       LIR_Opr tmp = new_register(T_LONG);
 181       __ convert(Bytecodes::_i2l, index_opr, tmp);
 182       index_opr = tmp;
 183     }
 184     if (shift &gt; 0) {
 185       __ shift_left(index_opr, shift, index_opr);
 186     }
 187     addr = new LIR_Address(array_opr,
 188                            index_opr,
 189                            offset_in_bytes, type);
 190   }
 191   return addr;
 192 }
 193 
 194 LIR_Opr LIRGenerator::load_immediate(int x, BasicType type) {
 195   LIR_Opr r = LIR_OprFact::illegalOpr;
 196   if (type == T_LONG) {
 197     r = LIR_OprFact::longConst(x);
 198   } else if (type == T_INT) {
 199     r = LIR_OprFact::intConst(x);
 200   } else {
 201     ShouldNotReachHere();
 202   }
 203   return r;
 204 }
 205 
 206 void LIRGenerator::increment_counter(address counter, BasicType type, int step) {
 207   LIR_Opr pointer = new_pointer_register();
 208   __ move(LIR_OprFact::intptrConst(counter), pointer);
 209   LIR_Address* addr = new LIR_Address(pointer, type);
 210   increment_counter(addr, step);
 211 }
 212 
 213 void LIRGenerator::increment_counter(LIR_Address* addr, int step) {
 214   __ add((LIR_Opr)addr, LIR_OprFact::intConst(step), (LIR_Opr)addr);
 215 }
 216 
 217 void LIRGenerator::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
 218   LIR_Opr scratch = FrameMap::Z_R1_opr;
 219   __ load(new LIR_Address(base, disp, T_INT), scratch, info);
 220   __ cmp(condition, scratch, c);
 221 }
 222 
 223 void LIRGenerator::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Opr base, int disp, BasicType type, CodeEmitInfo* info) {
 224   __ cmp_reg_mem(condition, reg, new LIR_Address(base, disp, type), info);
 225 }
 226 
 227 bool LIRGenerator::strength_reduce_multiply(LIR_Opr left, int c, LIR_Opr result, LIR_Opr tmp) {
 228   if (tmp-&gt;is_valid()) {
 229     if (is_power_of_2(c + 1)) {
 230       __ move(left, tmp);
 231       __ shift_left(left, log2_int(c + 1), left);
 232       __ sub(left, tmp, result);
 233       return true;
 234     } else if (is_power_of_2(c - 1)) {
 235       __ move(left, tmp);
 236       __ shift_left(left, log2_int(c - 1), left);
 237       __ add(left, tmp, result);
 238       return true;
 239     }
 240   }
 241   return false;
 242 }
 243 
 244 void LIRGenerator::store_stack_parameter (LIR_Opr item, ByteSize offset_from_sp) {
 245   BasicType type = item-&gt;type();
 246   __ store(item, new LIR_Address(FrameMap::Z_SP_opr, in_bytes(offset_from_sp), type));
 247 }
 248 
 249 //----------------------------------------------------------------------
 250 //             visitor functions
 251 //----------------------------------------------------------------------
 252 
 253 void LIRGenerator::array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci) {
 254   LIR_Opr tmp1 = new_register(objectType);
 255   LIR_Opr tmp2 = new_register(objectType);
 256   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
 257   __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 258 }
 259 
 260 void LIRGenerator::do_MonitorEnter(MonitorEnter* x) {
 261   assert(x-&gt;is_pinned(),&quot;&quot;);
 262   LIRItem obj(x-&gt;obj(), this);
 263   obj.load_item();
 264 
 265   set_no_result(x);
 266 
 267   // &quot;lock&quot; stores the address of the monitor stack slot, so this is not an oop.
 268   LIR_Opr lock = new_register(T_INT);
 269 
 270   CodeEmitInfo* info_for_exception = NULL;
 271   if (x-&gt;needs_null_check()) {
 272     info_for_exception = state_for (x);
 273   }
 274   // This CodeEmitInfo must not have the xhandlers because here the
 275   // object is already locked (xhandlers expect object to be unlocked).
 276   CodeEmitInfo* info = state_for (x, x-&gt;state(), true);
 277   monitor_enter(obj.result(), lock, syncTempOpr(), LIR_OprFact::illegalOpr,
 278                 x-&gt;monitor_no(), info_for_exception, info);
 279 }
 280 
 281 void LIRGenerator::do_MonitorExit(MonitorExit* x) {
 282   assert(x-&gt;is_pinned(),&quot;&quot;);
 283 
 284   LIRItem obj(x-&gt;obj(), this);
 285   obj.dont_load_item();
 286 
 287   LIR_Opr lock = new_register(T_INT);
 288   LIR_Opr obj_temp = new_register(T_INT);
 289   set_no_result(x);
 290   monitor_exit(obj_temp, lock, syncTempOpr(), LIR_OprFact::illegalOpr, x-&gt;monitor_no());
 291 }
 292 
 293 // _ineg, _lneg, _fneg, _dneg
 294 void LIRGenerator::do_NegateOp(NegateOp* x) {
 295   LIRItem value(x-&gt;x(), this);
 296   value.load_item();
 297   LIR_Opr reg = rlock_result(x);
 298   __ negate(value.result(), reg);
 299 }
 300 
 301 // for _fadd, _fmul, _fsub, _fdiv, _frem
 302 //     _dadd, _dmul, _dsub, _ddiv, _drem
 303 void LIRGenerator::do_ArithmeticOp_FPU(ArithmeticOp* x) {
 304   LIRItem left(x-&gt;x(),  this);
 305   LIRItem right(x-&gt;y(), this);
 306   LIRItem* left_arg  = &amp;left;
 307   LIRItem* right_arg = &amp;right;
 308   assert(!left.is_stack(), &quot;can&#39;t both be memory operands&quot;);
 309   left.load_item();
 310 
 311   if (right.is_register() || right.is_constant()) {
 312     right.load_item();
 313   } else {
 314     right.dont_load_item();
 315   }
 316 
 317   if ((x-&gt;op() == Bytecodes::_frem) || (x-&gt;op() == Bytecodes::_drem)) {
 318     address entry;
 319     switch (x-&gt;op()) {
 320     case Bytecodes::_frem:
 321       entry = CAST_FROM_FN_PTR(address, SharedRuntime::frem);
 322       break;
 323     case Bytecodes::_drem:
 324       entry = CAST_FROM_FN_PTR(address, SharedRuntime::drem);
 325       break;
 326     default:
 327       ShouldNotReachHere();
 328     }
 329     LIR_Opr result = call_runtime(x-&gt;x(), x-&gt;y(), entry, x-&gt;type(), NULL);
 330     set_result(x, result);
 331   } else {
 332     LIR_Opr reg = rlock(x);
 333     LIR_Opr tmp = LIR_OprFact::illegalOpr;
 334     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);
 335     set_result(x, reg);
 336   }
 337 }
 338 
 339 // for _ladd, _lmul, _lsub, _ldiv, _lrem
 340 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 341   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem) {
 342     // Use shifts if divisior is a power of 2 otherwise use DSGR instruction.
 343     // Instruction: DSGR R1, R2
 344     // input : R1+1: dividend   (R1, R1+1 designate a register pair, R1 must be even)
 345     //         R2:   divisor
 346     //
 347     // output: R1+1: quotient
 348     //         R1:   remainder
 349     //
 350     // Register selection: R1:   Z_R10
 351     //                     R1+1: Z_R11
 352     //                     R2:   to be chosen by register allocator (linear scan)
 353 
 354     // R1, and R1+1 will be destroyed.
 355 
 356     LIRItem right(x-&gt;y(), this);
 357     LIRItem left(x-&gt;x() , this);   // Visit left second, so that the is_register test is valid.
 358 
 359     // Call state_for before load_item_force because state_for may
 360     // force the evaluation of other instructions that are needed for
 361     // correct debug info. Otherwise the live range of the fix
 362     // register might be too long.
 363     CodeEmitInfo* info = state_for (x);
 364 
 365     LIR_Opr result = rlock_result(x);
 366     LIR_Opr result_reg = result;
 367     LIR_Opr tmp = LIR_OprFact::illegalOpr;
 368     LIR_Opr divisor_opr = right.result();
 369     if (divisor_opr-&gt;is_constant() &amp;&amp; is_power_of_2(divisor_opr-&gt;as_jlong())) {
 370       left.load_item();
 371       right.dont_load_item();
 372     } else {
 373       left.load_item_force(ldivInOpr());
 374       right.load_item();
 375 
 376       // DSGR instruction needs register pair.
 377       if (x-&gt;op() == Bytecodes::_ldiv) {
 378         result_reg = ldivOutOpr();
 379         tmp        = lremOutOpr();
 380       } else {
 381         result_reg = lremOutOpr();
 382         tmp        = ldivOutOpr();
 383       }
 384     }
 385 
 386     if (!ImplicitDiv0Checks) {
 387       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
 388       __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));
 389       // Idiv/irem cannot trap (passing info would generate an assertion).
 390       info = NULL;
 391     }
 392 
 393     if (x-&gt;op() == Bytecodes::_lrem) {
 394       __ irem(left.result(), right.result(), result_reg, tmp, info);
 395     } else if (x-&gt;op() == Bytecodes::_ldiv) {
 396       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 397     } else {
 398       ShouldNotReachHere();
 399     }
 400 
 401     if (result_reg != result) {
 402       __ move(result_reg, result);
 403     }
 404   } else {
 405     LIRItem left(x-&gt;x(), this);
 406     LIRItem right(x-&gt;y(), this);
 407 
 408     left.load_item();
 409     right.load_nonconstant(32);
 410     rlock_result(x);
 411     arithmetic_op_long(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), NULL);
 412   }
 413 }
 414 
 415 // for: _iadd, _imul, _isub, _idiv, _irem
 416 void LIRGenerator::do_ArithmeticOp_Int(ArithmeticOp* x) {
 417   if (x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem) {
 418     // Use shifts if divisior is a power of 2 otherwise use DSGFR instruction.
 419     // Instruction: DSGFR R1, R2
 420     // input : R1+1: dividend   (R1, R1+1 designate a register pair, R1 must be even)
 421     //         R2:   divisor
 422     //
 423     // output: R1+1: quotient
 424     //         R1:   remainder
 425     //
 426     // Register selection: R1:   Z_R10
 427     //                     R1+1: Z_R11
 428     //                     R2:   To be chosen by register allocator (linear scan).
 429 
 430     // R1, and R1+1 will be destroyed.
 431 
 432     LIRItem right(x-&gt;y(), this);
 433     LIRItem left(x-&gt;x() , this);   // Visit left second, so that the is_register test is valid.
 434 
 435     // Call state_for before load_item_force because state_for may
 436     // force the evaluation of other instructions that are needed for
 437     // correct debug info. Otherwise the live range of the fix
 438     // register might be too long.
 439     CodeEmitInfo* info = state_for (x);
 440 
 441     LIR_Opr result = rlock_result(x);
 442     LIR_Opr result_reg = result;
 443     LIR_Opr tmp = LIR_OprFact::illegalOpr;
 444     LIR_Opr divisor_opr = right.result();
 445     if (divisor_opr-&gt;is_constant() &amp;&amp; is_power_of_2(divisor_opr-&gt;as_jint())) {
 446       left.load_item();
 447       right.dont_load_item();
 448     } else {
 449       left.load_item_force(divInOpr());
 450       right.load_item();
 451 
 452       // DSGFR instruction needs register pair.
 453       if (x-&gt;op() == Bytecodes::_idiv) {
 454         result_reg = divOutOpr();
 455         tmp        = remOutOpr();
 456       } else {
 457         result_reg = remOutOpr();
 458         tmp        = divOutOpr();
 459       }
 460     }
 461 
 462     if (!ImplicitDiv0Checks) {
 463       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::intConst(0));
 464       __ branch(lir_cond_equal, T_INT, new DivByZeroStub(info));
 465       // Idiv/irem cannot trap (passing info would generate an assertion).
 466       info = NULL;
 467     }
 468 
 469     if (x-&gt;op() == Bytecodes::_irem) {
 470       __ irem(left.result(), right.result(), result_reg, tmp, info);
 471     } else if (x-&gt;op() == Bytecodes::_idiv) {
 472       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 473     } else {
 474       ShouldNotReachHere();
 475     }
 476 
 477     if (result_reg != result) {
 478       __ move(result_reg, result);
 479     }
 480   } else {
 481     LIRItem left(x-&gt;x(),  this);
 482     LIRItem right(x-&gt;y(), this);
 483     LIRItem* left_arg = &amp;left;
 484     LIRItem* right_arg = &amp;right;
 485     if (x-&gt;is_commutative() &amp;&amp; left.is_stack() &amp;&amp; right.is_register()) {
 486       // swap them if left is real stack (or cached) and right is real register(not cached)
 487       left_arg = &amp;right;
 488       right_arg = &amp;left;
 489     }
 490 
 491     left_arg-&gt;load_item();
 492 
 493     // Do not need to load right, as we can handle stack and constants.
 494     if (x-&gt;op() == Bytecodes::_imul) {
 495       bool use_tmp = false;
 496       if (right_arg-&gt;is_constant()) {
 497         int iconst = right_arg-&gt;get_jint_constant();
 498         if (is_power_of_2(iconst - 1) || is_power_of_2(iconst + 1)) {
 499           use_tmp = true;
 500         }
 501       }
 502       right_arg-&gt;dont_load_item();
 503       LIR_Opr tmp = LIR_OprFact::illegalOpr;
 504       if (use_tmp) {
 505         tmp = new_register(T_INT);
 506       }
 507       rlock_result(x);
 508 
 509       arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), tmp);
 510     } else {
 511       right_arg-&gt;dont_load_item();
 512       rlock_result(x);
 513       LIR_Opr tmp = LIR_OprFact::illegalOpr;
 514       arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), tmp);
 515     }
 516   }
 517 }
 518 
 519 void LIRGenerator::do_ArithmeticOp(ArithmeticOp* x) {
 520   // If an operand with use count 1 is the left operand, then it is
 521   // likely that no move for 2-operand-LIR-form is necessary.
 522   if (x-&gt;is_commutative() &amp;&amp; x-&gt;y()-&gt;as_Constant() == NULL &amp;&amp; x-&gt;x()-&gt;use_count() &gt; x-&gt;y()-&gt;use_count()) {
 523     x-&gt;swap_operands();
 524   }
 525 
 526   ValueTag tag = x-&gt;type()-&gt;tag();
 527   assert(x-&gt;x()-&gt;type()-&gt;tag() == tag &amp;&amp; x-&gt;y()-&gt;type()-&gt;tag() == tag, &quot;wrong parameters&quot;);
 528   switch (tag) {
 529     case floatTag:
 530     case doubleTag: do_ArithmeticOp_FPU(x);  return;
 531     case longTag:   do_ArithmeticOp_Long(x); return;
 532     case intTag:    do_ArithmeticOp_Int(x);  return;
 533     default:
 534       ShouldNotReachHere();
 535   }
 536 }
 537 
 538 // _ishl, _lshl, _ishr, _lshr, _iushr, _lushr
 539 void LIRGenerator::do_ShiftOp(ShiftOp* x) {
 540   // count must always be in rcx
 541   LIRItem value(x-&gt;x(), this);
 542   LIRItem count(x-&gt;y(), this);
 543 
 544   ValueTag elemType = x-&gt;type()-&gt;tag();
 545   bool must_load_count = !count.is_constant();
 546   if (must_load_count) {
 547     count.load_item();
 548   } else {
 549     count.dont_load_item();
 550   }
 551   value.load_item();
 552   LIR_Opr reg = rlock_result(x);
 553 
 554   shift_op(x-&gt;op(), reg, value.result(), count.result(), LIR_OprFact::illegalOpr);
 555 }
 556 
 557 // _iand, _land, _ior, _lor, _ixor, _lxor
 558 void LIRGenerator::do_LogicOp(LogicOp* x) {
 559   // IF an operand with use count 1 is the left operand, then it is
 560   // likely that no move for 2-operand-LIR-form is necessary.
 561   if (x-&gt;is_commutative() &amp;&amp; x-&gt;y()-&gt;as_Constant() == NULL &amp;&amp; x-&gt;x()-&gt;use_count() &gt; x-&gt;y()-&gt;use_count()) {
 562     x-&gt;swap_operands();
 563   }
 564 
 565   LIRItem left(x-&gt;x(), this);
 566   LIRItem right(x-&gt;y(), this);
 567 
 568   left.load_item();
 569   right.load_nonconstant(32);
 570   LIR_Opr reg = rlock_result(x);
 571 
 572   logic_op(x-&gt;op(), reg, left.result(), right.result());
 573 }
 574 
 575 // _lcmp, _fcmpl, _fcmpg, _dcmpl, _dcmpg
 576 void LIRGenerator::do_CompareOp(CompareOp* x) {
 577   LIRItem left(x-&gt;x(), this);
 578   LIRItem right(x-&gt;y(), this);
 579   left.load_item();
 580   right.load_item();
 581   LIR_Opr reg = rlock_result(x);
 582   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 583     Bytecodes::Code code = x-&gt;op();
 584     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 585   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 586     __ lcmp2int(left.result(), right.result(), reg);
 587   } else {
 588     ShouldNotReachHere();
 589   }
 590 }
 591 
 592 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 593   LIR_Opr t1 = LIR_OprFact::illegalOpr;
 594   LIR_Opr t2 = LIR_OprFact::illegalOpr;
 595   cmp_value.load_item();
 596   new_value.load_item();
 597   if (type == T_OBJECT) {
 598     if (UseCompressedOops) {
 599       t1 = new_register(T_OBJECT);
 600       t2 = new_register(T_OBJECT);
 601     }
 602     __ cas_obj(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), t1, t2);
 603   } else if (type == T_INT) {
 604     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), t1, t2);
 605   } else if (type == T_LONG) {
 606     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), t1, t2);
 607   } else {
 608     ShouldNotReachHere();
 609   }
 610   // Generate conditional move of boolean result.
 611   LIR_Opr result = new_register(T_INT);
 612   __ cmove(lir_cond_equal, LIR_OprFact::intConst(1), LIR_OprFact::intConst(0),
 613            result, type);
 614   return result;
 615 }
 616 
 617 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 618   Unimplemented(); // Currently not supported on this platform.
 619   return LIR_OprFact::illegalOpr;
 620 }
 621 
 622 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 623   LIR_Opr result = new_register(type);
 624   value.load_item();
 625   __ xadd(addr, value.result(), result, LIR_OprFact::illegalOpr);
 626   return result;
 627 }
 628 
 629 void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {
 630   switch (x-&gt;id()) {
 631     case vmIntrinsics::_dabs:
 632     case vmIntrinsics::_dsqrt: {
 633       assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
 634       LIRItem value(x-&gt;argument_at(0), this);
 635       value.load_item();
 636       LIR_Opr dst = rlock_result(x);
 637 
 638       switch (x-&gt;id()) {
 639         case vmIntrinsics::_dsqrt: {
 640           __ sqrt(value.result(), dst, LIR_OprFact::illegalOpr);
 641           break;
 642         }
 643         case vmIntrinsics::_dabs: {
 644           __ abs(value.result(), dst, LIR_OprFact::illegalOpr);
 645           break;
 646         }
 647         default:
 648           ShouldNotReachHere();
 649       }
 650       break;
 651     }
 652     case vmIntrinsics::_dsin:   // fall through
 653     case vmIntrinsics::_dcos:   // fall through
 654     case vmIntrinsics::_dtan:   // fall through
 655     case vmIntrinsics::_dlog:   // fall through
 656     case vmIntrinsics::_dlog10: // fall through
 657     case vmIntrinsics::_dexp: {
 658       assert(x-&gt;number_of_arguments() == 1, &quot;wrong type&quot;);
 659 
 660       address runtime_entry = NULL;
 661       switch (x-&gt;id()) {
 662         case vmIntrinsics::_dsin:
 663           runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dsin);
 664           break;
 665         case vmIntrinsics::_dcos:
 666           runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dcos);
 667           break;
 668         case vmIntrinsics::_dtan:
 669           runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dtan);
 670           break;
 671         case vmIntrinsics::_dlog:
 672           runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dlog);
 673           break;
 674         case vmIntrinsics::_dlog10:
 675           runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dlog10);
 676           break;
 677         case vmIntrinsics::_dexp:
 678           runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dexp);
 679           break;
 680         default:
 681           ShouldNotReachHere();
 682       }
 683 
 684       LIR_Opr result = call_runtime(x-&gt;argument_at(0), runtime_entry, x-&gt;type(), NULL);
 685       set_result(x, result);
 686       break;
 687     }
 688     case vmIntrinsics::_dpow: {
 689       assert(x-&gt;number_of_arguments() == 2, &quot;wrong type&quot;);
 690       address runtime_entry = CAST_FROM_FN_PTR(address, SharedRuntime::dpow);
 691       LIR_Opr result = call_runtime(x-&gt;argument_at(0), x-&gt;argument_at(1), runtime_entry, x-&gt;type(), NULL);
 692       set_result(x, result);
 693       break;
 694     }
 695     default:
 696       break;
 697   }
 698 }
 699 
 700 void LIRGenerator::do_ArrayCopy(Intrinsic* x) {
 701   assert(x-&gt;number_of_arguments() == 5, &quot;wrong type&quot;);
 702 
 703   // Copy stubs possibly call C code, e.g. G1 barriers, so we need to reserve room
 704   // for the C ABI (see frame::z_abi_160).
 705   BasicTypeArray sig; // Empty signature is precise enough.
 706   frame_map()-&gt;c_calling_convention(&amp;sig);
 707 
 708   // Make all state_for calls early since they can emit code.
 709   CodeEmitInfo* info = state_for (x, x-&gt;state());
 710 
 711   LIRItem src(x-&gt;argument_at(0), this);
 712   LIRItem src_pos(x-&gt;argument_at(1), this);
 713   LIRItem dst(x-&gt;argument_at(2), this);
 714   LIRItem dst_pos(x-&gt;argument_at(3), this);
 715   LIRItem length(x-&gt;argument_at(4), this);
 716 
 717   // Operands for arraycopy must use fixed registers, otherwise
 718   // LinearScan will fail allocation (because arraycopy always needs a
 719   // call).
 720 
 721   src.load_item_force     (FrameMap::as_oop_opr(Z_ARG1));
 722   src_pos.load_item_force (FrameMap::as_opr(Z_ARG2));
 723   dst.load_item_force     (FrameMap::as_oop_opr(Z_ARG3));
 724   dst_pos.load_item_force (FrameMap::as_opr(Z_ARG4));
 725   length.load_item_force  (FrameMap::as_opr(Z_ARG5));
 726 
 727   LIR_Opr tmp =            FrameMap::as_opr(Z_R7);
 728 
 729   set_no_result(x);
 730 
 731   int flags;
 732   ciArrayKlass* expected_type;
 733   arraycopy_helper(x, &amp;flags, &amp;expected_type);
 734 
 735   __ arraycopy(src.result(), src_pos.result(), dst.result(), dst_pos.result(),
 736                length.result(), tmp, expected_type, flags, info); // does add_safepoint
 737 }
 738 
 739 // _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f
 740 // _i2b, _i2c, _i2s
 741 void LIRGenerator::do_Convert(Convert* x) {
 742   LIRItem value(x-&gt;value(), this);
 743 
 744   value.load_item();
 745   LIR_Opr reg = rlock_result(x);
 746   __ convert(x-&gt;op(), value.result(), reg);
 747 }
 748 
 749 void LIRGenerator::do_NewInstance(NewInstance* x) {
 750   print_if_not_loaded(x);
 751 
 752   // This instruction can be deoptimized in the slow path : use
 753   // Z_R2 as result register.
 754   const LIR_Opr reg = result_register_for (x-&gt;type());
 755 
 756   CodeEmitInfo* info = state_for (x, x-&gt;state());
 757   LIR_Opr tmp1 = FrameMap::Z_R12_oop_opr;
 758   LIR_Opr tmp2 = FrameMap::Z_R13_oop_opr;
 759   LIR_Opr tmp3 = reg;
 760   LIR_Opr tmp4 = LIR_OprFact::illegalOpr;
 761   LIR_Opr klass_reg = FrameMap::Z_R11_metadata_opr;
 762   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(), tmp1, tmp2, tmp3, tmp4, klass_reg, info);
 763   LIR_Opr result = rlock_result(x);
 764   __ move(reg, result);
 765 }
 766 
 767 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
 768   CodeEmitInfo* info = state_for (x, x-&gt;state());
 769 
 770   LIRItem length(x-&gt;length(), this);
 771   length.load_item();
 772 
 773   LIR_Opr reg = result_register_for (x-&gt;type());
 774   LIR_Opr tmp1 = FrameMap::Z_R12_oop_opr;
 775   LIR_Opr tmp2 = FrameMap::Z_R13_oop_opr;
 776   LIR_Opr tmp3 = reg;
 777   LIR_Opr tmp4 = LIR_OprFact::illegalOpr;
 778   LIR_Opr klass_reg = FrameMap::Z_R11_metadata_opr;
 779   LIR_Opr len = length.result();
 780   BasicType elem_type = x-&gt;elt_type();
 781 
 782   __ metadata2reg(ciTypeArrayKlass::make(elem_type)-&gt;constant_encoding(), klass_reg);
 783 
 784   CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len, reg, info);
 785   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);
 786 
 787   LIR_Opr result = rlock_result(x);
 788   __ move(reg, result);
 789 }
 790 
 791 void LIRGenerator::do_NewObjectArray(NewObjectArray* x) {
 792   // Evaluate state_for early since it may emit code.
 793   CodeEmitInfo* info = state_for (x, x-&gt;state());
 794   // In case of patching (i.e., object class is not yet loaded), we need to reexecute the instruction
 795   // and therefore provide the state before the parameters have been consumed.
 796   CodeEmitInfo* patching_info = NULL;
 797   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
 798     patching_info = state_for (x, x-&gt;state_before());
 799   }
 800 
 801   LIRItem length(x-&gt;length(), this);
 802   length.load_item();
 803 
 804   const LIR_Opr reg = result_register_for (x-&gt;type());
 805   LIR_Opr tmp1 = FrameMap::Z_R12_oop_opr;
 806   LIR_Opr tmp2 = FrameMap::Z_R13_oop_opr;
 807   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
 808   LIR_Opr tmp4 = LIR_OprFact::illegalOpr;
 809   LIR_Opr klass_reg = FrameMap::Z_R11_metadata_opr;
 810   LIR_Opr len = length.result();
 811 
 812   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info);
 813   ciKlass* obj = ciObjArrayKlass::make(x-&gt;klass());
 814   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
 815     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
 816   }
 817   klass2reg_with_patching(klass_reg, obj, patching_info);
 818   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);
 819 
 820   LIR_Opr result = rlock_result(x);
 821   __ move(reg, result);
 822 }
 823 
 824 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
 825   Values* dims = x-&gt;dims();
 826   int i = dims-&gt;length();
 827   LIRItemList* items = new LIRItemList(i, i, NULL);
 828   while (i-- &gt; 0) {
 829     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
 830     items-&gt;at_put(i, size);
 831   }
 832 
 833   // Evaluate state_for early since it may emit code.
 834   CodeEmitInfo* patching_info = NULL;
 835   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
 836     patching_info = state_for (x, x-&gt;state_before());
 837 
 838     // Cannot re-use same xhandlers for multiple CodeEmitInfos, so
 839     // clone all handlers (NOTE: Usually this is handled transparently
 840     // by the CodeEmitInfo cloning logic in CodeStub constructors but
 841     // is done explicitly here because a stub isn&#39;t being used).
 842     x-&gt;set_exception_handlers(new XHandlers(x-&gt;exception_handlers()));
 843   }
 844   CodeEmitInfo* info = state_for (x, x-&gt;state());
 845 
 846   i = dims-&gt;length();
 847   while (--i &gt;= 0) {
 848     LIRItem* size = items-&gt;at(i);
 849     size-&gt;load_nonconstant(32);
 850     // FrameMap::_reserved_argument_area_size includes the dimensions varargs, because
 851     // it&#39;s initialized to hir()-&gt;max_stack() when the FrameMap is created.
 852     store_stack_parameter(size-&gt;result(), in_ByteSize(i*sizeof(jint) + FrameMap::first_available_sp_in_frame));
 853   }
 854 
 855   LIR_Opr klass_reg = FrameMap::Z_R3_metadata_opr;
 856   klass2reg_with_patching(klass_reg, x-&gt;klass(), patching_info);
 857 
 858   LIR_Opr rank = FrameMap::Z_R4_opr;
 859   __ move(LIR_OprFact::intConst(x-&gt;rank()), rank);
 860   LIR_Opr varargs = FrameMap::Z_R5_opr;
 861   __ leal(LIR_OprFact::address(new LIR_Address(FrameMap::Z_SP_opr, FrameMap::first_available_sp_in_frame, T_INT)),
 862           varargs);
 863   LIR_OprList* args = new LIR_OprList(3);
 864   args-&gt;append(klass_reg);
 865   args-&gt;append(rank);
 866   args-&gt;append(varargs);
 867   LIR_Opr reg = result_register_for (x-&gt;type());
 868   __ call_runtime(Runtime1::entry_for (Runtime1::new_multi_array_id),
 869                   LIR_OprFact::illegalOpr,
 870                   reg, args, info);
 871 
 872   LIR_Opr result = rlock_result(x);
 873   __ move(reg, result);
 874 }
 875 
 876 void LIRGenerator::do_BlockBegin(BlockBegin* x) {
 877   // Nothing to do.
 878 }
 879 
 880 void LIRGenerator::do_CheckCast(CheckCast* x) {
 881   LIRItem obj(x-&gt;obj(), this);
 882 
 883   CodeEmitInfo* patching_info = NULL;
 884   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
 885     // Must do this before locking the destination register as an oop register,
 886     // and before the obj is loaded (the latter is for deoptimization).
 887     patching_info = state_for (x, x-&gt;state_before());
 888   }
 889   obj.load_item();
 890 
 891   // info for exceptions
 892   CodeEmitInfo* info_for_exception =
 893       (x-&gt;needs_exception_state() ? state_for(x) :
 894                                     state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
 895 
 896   CodeStub* stub;
 897   if (x-&gt;is_incompatible_class_change_check()) {
 898     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
 899     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);
 900   } else if (x-&gt;is_invokespecial_receiver_check()) {
 901     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
 902     stub = new DeoptimizeStub(info_for_exception,
 903                               Deoptimization::Reason_class_check,
 904                               Deoptimization::Action_none);
 905   } else {
 906     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);
 907   }
 908   LIR_Opr reg = rlock_result(x);
 909   LIR_Opr tmp1 = new_register(objectType);
 910   LIR_Opr tmp2 = new_register(objectType);
 911   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
 912   __ checkcast(reg, obj.result(), x-&gt;klass(),
 913                tmp1, tmp2, tmp3,
 914                x-&gt;direct_compare(), info_for_exception, patching_info, stub,
 915                x-&gt;profiled_method(), x-&gt;profiled_bci());
 916 }
 917 
 918 
 919 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
 920   LIRItem obj(x-&gt;obj(), this);
 921   CodeEmitInfo* patching_info = NULL;
 922   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
 923     patching_info = state_for (x, x-&gt;state_before());
 924   }
 925   // Ensure the result register is not the input register because the
 926   // result is initialized before the patching safepoint.
 927   obj.load_item();
 928   LIR_Opr out_reg = rlock_result(x);
 929   LIR_Opr tmp1 = new_register(objectType);
 930   LIR_Opr tmp2 = new_register(objectType);
 931   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
 932   __ instanceof(out_reg, obj.result(), x-&gt;klass(), tmp1, tmp2, tmp3,
 933                 x-&gt;direct_compare(), patching_info,
 934                 x-&gt;profiled_method(), x-&gt;profiled_bci());
 935 }
 936 
 937 
 938 void LIRGenerator::do_If (If* x) {
 939   assert(x-&gt;number_of_sux() == 2, &quot;inconsistency&quot;);
 940   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
 941   bool is_safepoint = x-&gt;is_safepoint();
 942 
 943   If::Condition cond = x-&gt;cond();
 944 
 945   LIRItem xitem(x-&gt;x(), this);
 946   LIRItem yitem(x-&gt;y(), this);
 947   LIRItem* xin = &amp;xitem;
 948   LIRItem* yin = &amp;yitem;
 949 
 950   if (tag == longTag) {
 951     // For longs, only conditions &quot;eql&quot;, &quot;neq&quot;, &quot;lss&quot;, &quot;geq&quot; are valid;
 952     // mirror for other conditions.
 953     if (cond == If::gtr || cond == If::leq) {
 954       cond = Instruction::mirror(cond);
 955       xin = &amp;yitem;
 956       yin = &amp;xitem;
 957     }
 958     xin-&gt;set_destroys_register();
 959   }
 960   xin-&gt;load_item();
 961   // TODO: don&#39;t load long constants != 0L
 962   if (tag == longTag &amp;&amp; yin-&gt;is_constant() &amp;&amp; yin-&gt;get_jlong_constant() == 0 &amp;&amp; (cond == If::eql || cond == If::neq)) {
 963     // inline long zero
 964     yin-&gt;dont_load_item();
 965   } else if (tag == longTag || tag == floatTag || tag == doubleTag) {
 966     // Longs cannot handle constants at right side.
 967     yin-&gt;load_item();
 968   } else {
 969     yin-&gt;dont_load_item();
 970   }
 971 
 972   LIR_Opr left = xin-&gt;result();
 973   LIR_Opr right = yin-&gt;result();
 974 
 975   set_no_result(x);
 976 
 977   // Add safepoint before generating condition code so it can be recomputed.
 978   if (x-&gt;is_safepoint()) {
 979     // Increment backedge counter if needed.
 980     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
 981         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
 982     // Use safepoint_poll_register() instead of LIR_OprFact::illegalOpr.
 983     __ safepoint(safepoint_poll_register(), state_for (x, x-&gt;state_before()));
 984   }
 985 
 986   __ cmp(lir_cond(cond), left, right);
 987   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
 988   profile_branch(x, cond);
 989   move_to_phi(x-&gt;state());
 990   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 991     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());
 992   } else {
 993     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());
 994   }
 995   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
 996   __ jump(x-&gt;default_sux());
 997 }
 998 
 999 LIR_Opr LIRGenerator::getThreadPointer() {
1000   return FrameMap::as_pointer_opr(Z_thread);
1001 }
1002 
1003 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1004   __ move(LIR_OprFact::intConst(block-&gt;block_id()), FrameMap::Z_R2_opr);
1005   LIR_OprList* args = new LIR_OprList(1);
1006   args-&gt;append(FrameMap::Z_R2_opr);
1007   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
1008   __ call_runtime_leaf(func, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, args);
1009 }
1010 
1011 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1012                                         CodeEmitInfo* info) {
1013   __ store(value, address, info);
1014 }
1015 
1016 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1017                                        CodeEmitInfo* info) {
1018   __ load(address, result, info);
1019 }
1020 
1021 void LIRGenerator::do_update_CRC32(Intrinsic* x) {
1022   assert(UseCRC32Intrinsics, &quot;or should not be here&quot;);
1023   LIR_Opr result = rlock_result(x);
1024 
1025   switch (x-&gt;id()) {
1026     case vmIntrinsics::_updateCRC32: {
1027       LIRItem crc(x-&gt;argument_at(0), this);
1028       LIRItem val(x-&gt;argument_at(1), this);
1029       // Registers destroyed by update_crc32.
1030       crc.set_destroys_register();
1031       val.set_destroys_register();
1032       crc.load_item();
1033       val.load_item();
1034       __ update_crc32(crc.result(), val.result(), result);
1035       break;
1036     }
1037     case vmIntrinsics::_updateBytesCRC32:
1038     case vmIntrinsics::_updateByteBufferCRC32: {
1039       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32);
1040 
1041       LIRItem crc(x-&gt;argument_at(0), this);
1042       LIRItem buf(x-&gt;argument_at(1), this);
1043       LIRItem off(x-&gt;argument_at(2), this);
1044       LIRItem len(x-&gt;argument_at(3), this);
1045       buf.load_item();
1046       off.load_nonconstant();
1047 
1048       LIR_Opr index = off.result();
1049       int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
1050       if (off.result()-&gt;is_constant()) {
1051         index = LIR_OprFact::illegalOpr;
1052         offset += off.result()-&gt;as_jint();
1053       }
1054       LIR_Opr base_op = buf.result();
1055 
1056       if (index-&gt;is_valid()) {
1057         LIR_Opr tmp = new_register(T_LONG);
1058         __ convert(Bytecodes::_i2l, index, tmp);
1059         index = tmp;
1060       }
1061 
1062       LIR_Address* a = new LIR_Address(base_op, index, offset, T_BYTE);
1063 
1064       BasicTypeList signature(3);
1065       signature.append(T_INT);
1066       signature.append(T_ADDRESS);
1067       signature.append(T_INT);
1068       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1069       const LIR_Opr result_reg = result_register_for (x-&gt;type());
1070 
1071       LIR_Opr arg1 = cc-&gt;at(0);
1072       LIR_Opr arg2 = cc-&gt;at(1);
1073       LIR_Opr arg3 = cc-&gt;at(2);
1074 
1075       crc.load_item_force(arg1); // We skip int-&gt;long conversion here, because CRC32 stub doesn&#39;t care about high bits.
1076       __ leal(LIR_OprFact::address(a), arg2);
1077       len.load_item_force(arg3); // We skip int-&gt;long conversion here, because CRC32 stub expects int.
1078 
1079       __ call_runtime_leaf(StubRoutines::updateBytesCRC32(), LIR_OprFact::illegalOpr, result_reg, cc-&gt;args());
1080       __ move(result_reg, result);
1081       break;
1082     }
1083     default: {
1084       ShouldNotReachHere();
1085     }
1086   }
1087 }
1088 
1089 void LIRGenerator::do_update_CRC32C(Intrinsic* x) {
1090   assert(UseCRC32CIntrinsics, &quot;or should not be here&quot;);
1091   LIR_Opr result = rlock_result(x);
1092 
1093   switch (x-&gt;id()) {
1094     case vmIntrinsics::_updateBytesCRC32C:
1095     case vmIntrinsics::_updateDirectByteBufferCRC32C: {
1096       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32C);
1097 
1098       LIRItem crc(x-&gt;argument_at(0), this);
1099       LIRItem buf(x-&gt;argument_at(1), this);
1100       LIRItem off(x-&gt;argument_at(2), this);
1101       LIRItem end(x-&gt;argument_at(3), this);
1102       buf.load_item();
1103       off.load_nonconstant();
1104       end.load_nonconstant();
1105 
1106       // len = end - off
1107       LIR_Opr len  = end.result();
1108       LIR_Opr tmpA = new_register(T_INT);
1109       LIR_Opr tmpB = new_register(T_INT);
1110       __ move(end.result(), tmpA);
1111       __ move(off.result(), tmpB);
1112       __ sub(tmpA, tmpB, tmpA);
1113       len = tmpA;
1114 
1115       LIR_Opr index = off.result();
1116       int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
1117       if (off.result()-&gt;is_constant()) {
1118         index = LIR_OprFact::illegalOpr;
1119         offset += off.result()-&gt;as_jint();
1120       }
1121       LIR_Opr base_op = buf.result();
1122 
1123       if (index-&gt;is_valid()) {
1124         LIR_Opr tmp = new_register(T_LONG);
1125         __ convert(Bytecodes::_i2l, index, tmp);
1126         index = tmp;
1127       }
1128 
1129       LIR_Address* a = new LIR_Address(base_op, index, offset, T_BYTE);
1130 
1131       BasicTypeList signature(3);
1132       signature.append(T_INT);
1133       signature.append(T_ADDRESS);
1134       signature.append(T_INT);
1135       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1136       const LIR_Opr result_reg = result_register_for (x-&gt;type());
1137 
1138       LIR_Opr arg1 = cc-&gt;at(0);
1139       LIR_Opr arg2 = cc-&gt;at(1);
1140       LIR_Opr arg3 = cc-&gt;at(2);
1141 
1142       crc.load_item_force(arg1); // We skip int-&gt;long conversion here, because CRC32C stub doesn&#39;t care about high bits.
1143       __ leal(LIR_OprFact::address(a), arg2);
1144       __ move(len, cc-&gt;at(2));   // We skip int-&gt;long conversion here, because CRC32C stub expects int.
1145 
1146       __ call_runtime_leaf(StubRoutines::updateBytesCRC32C(), LIR_OprFact::illegalOpr, result_reg, cc-&gt;args());
1147       __ move(result_reg, result);
1148       break;
1149     }
1150     default: {
1151       ShouldNotReachHere();
1152     }
1153   }
1154 }
1155 
1156 void LIRGenerator::do_FmaIntrinsic(Intrinsic* x) {
1157   assert(x-&gt;number_of_arguments() == 3, &quot;wrong type&quot;);
1158   assert(UseFMA, &quot;Needs FMA instructions support.&quot;);
1159   LIRItem value(x-&gt;argument_at(0), this);
1160   LIRItem value1(x-&gt;argument_at(1), this);
1161   LIRItem value2(x-&gt;argument_at(2), this);
1162 
1163   value2.set_destroys_register();
1164 
1165   value.load_item();
1166   value1.load_item();
1167   value2.load_item();
1168 
1169   LIR_Opr calc_input = value.result();
1170   LIR_Opr calc_input1 = value1.result();
1171   LIR_Opr calc_input2 = value2.result();
1172   LIR_Opr calc_result = rlock_result(x);
1173 
1174   switch (x-&gt;id()) {
1175   case vmIntrinsics::_fmaD:   __ fmad(calc_input, calc_input1, calc_input2, calc_result); break;
1176   case vmIntrinsics::_fmaF:   __ fmaf(calc_input, calc_input1, calc_input2, calc_result); break;
1177   default:                    ShouldNotReachHere();
1178   }
1179 }
1180 
1181 void LIRGenerator::do_vectorizedMismatch(Intrinsic* x) {
1182   fatal(&quot;vectorizedMismatch intrinsic is not implemented on this platform&quot;);
1183 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/macroAssembler_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/macroAssembler_s390.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">   3  * Copyright (c) 2016, 2018, SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
 696   // The rest of the type check; must be wired to a corresponding fast path.
 697   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 698   // The temp_reg can be noreg, if no temps are available.
 699   // It can also be sub_klass or super_klass, meaning it&#39;s OK to kill that one.
 700   // Updates the sub&#39;s secondary super cache as necessary.
 701   void check_klass_subtype_slow_path(Register Rsubklass,
 702                                      Register Rsuperklas,
 703                                      Register Rarray_ptr, // tmp
 704                                      Register Rlength,    // tmp
 705                                      Label* L_success,
 706                                      Label* L_failure);
 707 
 708   // Simplified, combined version, good for typical uses.
 709   // Falls through on failure.
 710   void check_klass_subtype(Register sub_klass,
 711                            Register super_klass,
 712                            Register temp1_reg,
 713                            Register temp2_reg,
 714                            Label&amp;   L_success);
 715 





 716   // Increment a counter at counter_address when the eq condition code is set.
 717   // Kills registers tmp1_reg and tmp2_reg and preserves the condition code.
 718   void increment_counter_eq(address counter_address, Register tmp1_reg, Register tmp2_reg);
 719   // Biased locking support
 720   // Upon entry,obj_reg must contain the target object, and mark_reg
 721   // must contain the target object&#39;s header.
 722   // Destroys mark_reg if an attempt is made to bias an anonymously
 723   // biased lock. In this case a failure will go either to the slow
 724   // case or fall through with the notEqual condition code set with
 725   // the expectation that the slow case in the runtime will be called.
 726   // In the fall-through case where the CAS-based lock is done,
 727   // mark_reg is not destroyed.
 728   void biased_locking_enter(Register obj_reg, Register mark_reg, Register temp_reg,
 729                             Register temp2_reg, Label&amp; done, Label* slow_case = NULL);
 730   // Upon entry, the base register of mark_addr must contain the oop.
 731   // Destroys temp_reg.
 732   // If allow_delay_slot_filling is set to true, the next instruction
 733   // emitted after this one will go in an annulled delay slot if the
 734   // biased locking exit case failed.
 735   void biased_locking_exit(Register mark_addr, Register temp_reg, Label&amp; done);
</pre>
<hr />
<pre>
 806                        Register tmp1, Register tmp2, Register tmp3);
 807   void access_load_at(BasicType type, DecoratorSet decorators,
 808                       const Address&amp; addr, Register dst,
 809                       Register tmp1, Register tmp2, Label *is_null = NULL);
 810 
 811  public:
 812   // tmp1 and tmp2 are used with decorators ON_PHANTOM_OOP_REF or ON_WEAK_OOP_REF.
 813   void load_heap_oop(Register dest, const Address &amp;a,
 814                      Register tmp1, Register tmp2,
 815                      DecoratorSet decorators = 0, Label *is_null = NULL);
 816   void store_heap_oop(Register Roop, const Address &amp;a,
 817                       Register tmp1, Register tmp2, Register tmp3,
 818                       DecoratorSet decorators = 0);
 819 
 820   void oop_encoder(Register Rdst, Register Rsrc, bool maybeNULL,
 821                    Register Rbase = Z_R1, int pow2_offset = -1, bool only32bitValid = false);
 822   void oop_decoder(Register Rdst, Register Rsrc, bool maybeNULL,
 823                    Register Rbase = Z_R1, int pow2_offset = -1);
 824 
 825   void resolve_oop_handle(Register result);
<span class="line-modified"> 826   void load_mirror(Register mirror, Register method);</span>

 827 
 828   //--------------------------
 829   //---  Operations on arrays.
 830   //--------------------------
<span class="line-modified"> 831   unsigned int Clear_Array(Register cnt_arg, Register base_pointer_arg, Register src_addr, Register src_len);</span>
 832   unsigned int Clear_Array_Const(long cnt, Register base);
<span class="line-modified"> 833   unsigned int Clear_Array_Const_Big(long cnt, Register base_pointer_arg, Register src_addr, Register src_len);</span>
 834   unsigned int CopyRawMemory_AlignedDisjoint(Register src_reg, Register dst_reg,
 835                                              Register cnt_reg,
 836                                              Register tmp1_reg, Register tmp2_reg);
 837 
 838   //-------------------------------------------
 839   // Special String Intrinsics Implementation.
 840   //-------------------------------------------
 841   // Intrinsics for CompactStrings
 842   //   Restores: src, dst
 843   //   Uses:     cnt
 844   //   Kills:    tmp, Z_R0, Z_R1.
 845   //   Early clobber: result.
 846   //   Boolean precise controls accuracy of result value.

 847   unsigned int string_compress(Register result, Register src, Register dst, Register cnt,
 848                                Register tmp,    bool precise);
 849 
 850   // Inflate byte[] to char[].
 851   unsigned int string_inflate_trot(Register src, Register dst, Register cnt, Register tmp);
 852 
 853   // Inflate byte[] to char[].
 854   //   Restores: src, dst
 855   //   Uses:     cnt
 856   //   Kills:    tmp, Z_R0, Z_R1.
 857   unsigned int string_inflate(Register src, Register dst, Register cnt, Register tmp);
 858 
 859   // Inflate byte[] to char[], length known at compile time.
 860   //   Restores: src, dst
 861   //   Kills:    tmp, Z_R0, Z_R1.
 862   // Note:
 863   //   len is signed int. Counts # characters, not bytes.
 864   unsigned int string_inflate_const(Register src, Register dst, Register tmp, int len);
 865 
 866   // Kills src.
 867   unsigned int has_negatives(Register result, Register src, Register cnt,
 868                              Register odd_reg, Register even_reg, Register tmp);
 869 
 870   unsigned int string_compare(Register str1, Register str2, Register cnt1, Register cnt2,
 871                               Register odd_reg, Register even_reg, Register result, int ae);
 872 
 873   unsigned int array_equals(bool is_array_equ, Register ary1, Register ary2, Register limit,
 874                             Register odd_reg, Register even_reg, Register result, bool is_byte);
 875 
 876   unsigned int string_indexof(Register result, Register haystack, Register haycnt,
 877                               Register needle, Register needlecnt, int needlecntval,
 878                               Register odd_reg, Register even_reg, int ae);
 879 
 880   unsigned int string_indexof_char(Register result, Register haystack, Register haycnt,
 881                                    Register needle, jchar needleChar, Register odd_reg, Register even_reg, bool is_byte);

 882 
 883   // Emit an oop const to the constant pool and set a relocation info
 884   // with address current_pc. Return the TOC offset of the constant.
 885   int store_const_in_toc(AddressLiteral&amp; val);
 886   int store_oop_in_toc(AddressLiteral&amp; oop);
 887   // Emit an oop const to the constant pool via store_oop_in_toc, or
 888   // emit a scalar const to the constant pool via store_const_in_toc,
 889   // and load the constant into register dst.
 890   bool load_const_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc = noreg);
 891   // Get CPU version dependent size of load_const sequence.
 892   // The returned value is valid only for code sequences
 893   // generated by load_const, not load_const_optimized.
 894   static int load_const_from_toc_size() {
 895     return load_long_pcrelative_size();
 896   }
 897   bool load_oop_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc = noreg);
 898   static intptr_t get_const_from_toc(address pc);
 899   static void     set_const_in_toc(address pc, unsigned long new_data, CodeBlob *cb);
 900 
 901   // Dynamic TOC.
 902   static bool is_load_const(address a);
 903   static bool is_load_const_from_toc_pcrelative(address a);
 904   static bool is_load_const_from_toc(address a) { return is_load_const_from_toc_pcrelative(a); }
 905 
 906   // PCrelative TOC access.
 907   static bool is_call_byregister(address a) { return is_z_basr(*(short*)a); }
 908   static bool is_load_const_from_toc_call(address a);
 909   static bool is_load_const_call(address a);
 910   static int load_const_call_size() { return load_const_size() + call_byregister_size(); }
 911   static int load_const_from_toc_call_size() { return load_const_from_toc_size() + call_byregister_size(); }
 912   // Offset is +/- 2**32 -&gt; use long.
 913   static long get_load_const_from_toc_offset(address a);
 914 
<span class="line-removed"> 915 </span>
<span class="line-removed"> 916   void generate_type_profiling(const Register Rdata,</span>
<span class="line-removed"> 917                                const Register Rreceiver_klass,</span>
<span class="line-removed"> 918                                const Register Rwanted_receiver_klass,</span>
<span class="line-removed"> 919                                const Register Rmatching_row,</span>
<span class="line-removed"> 920                                bool is_virtual_call);</span>
<span class="line-removed"> 921 </span>
 922   // Bit operations for single register operands.
 923   inline void lshift(Register r, int places, bool doubl = true);   // &lt;&lt;
 924   inline void rshift(Register r, int places, bool doubl = true);   // &gt;&gt;
 925 
 926   //
 927   // Debugging
 928   //
 929 
 930   // Assert on CC (condition code in CPU state).
 931   void asm_assert(bool check_equal, const char* msg, int id) PRODUCT_RETURN;
 932   void asm_assert_low(const char *msg, int id) PRODUCT_RETURN;
 933   void asm_assert_high(const char *msg, int id) PRODUCT_RETURN;
 934   void asm_assert_eq(const char* msg, int id) { asm_assert(true, msg, id); }
 935   void asm_assert_ne(const char* msg, int id) { asm_assert(false, msg, id); }
 936 
 937   void asm_assert_static(bool check_equal, const char* msg, int id) PRODUCT_RETURN;
 938 
 939  private:
 940   // Emit assertions.
 941   void asm_assert_mems_zero(bool check_equal, bool allow_relocation, int size, int64_t mem_offset,
</pre>
<hr />
<pre>
 955     asm_assert_mems_zero(false, true, 8, mem_offset, mem_base, msg, id);
 956   }
 957 
 958   inline void asm_assert_mem4_is_zero_static(int64_t mem_offset, Register mem_base, const char* msg, int id) {
 959     asm_assert_mems_zero(true,  false, 4, mem_offset, mem_base, msg, id);
 960   }
 961   inline void asm_assert_mem8_is_zero_static(int64_t mem_offset, Register mem_base, const char* msg, int id) {
 962     asm_assert_mems_zero(true,  false, 8, mem_offset, mem_base, msg, id);
 963   }
 964   inline void asm_assert_mem4_isnot_zero_static(int64_t mem_offset, Register mem_base, const char* msg, int id) {
 965     asm_assert_mems_zero(false, false, 4, mem_offset, mem_base, msg, id);
 966   }
 967   inline void asm_assert_mem8_isnot_zero_static(int64_t mem_offset, Register mem_base, const char* msg, int id) {
 968     asm_assert_mems_zero(false, false, 8, mem_offset, mem_base, msg, id);
 969   }
 970   void asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id) PRODUCT_RETURN;
 971 
 972   // Verify Z_thread contents.
 973   void verify_thread();
 974 




 975   // Only if +VerifyOops.

 976   void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);


 977 
 978   // TODO: verify_method and klass metadata (compare against vptr?).
 979   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 980   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line) {}
 981 
 982 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 983 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 984 
 985  private:
 986   // Generate printout in stop().
 987   static const char* stop_types[];
 988   enum {
 989     stop_stop               = 0,
 990     stop_untested           = 1,
 991     stop_unimplemented      = 2,
 992     stop_shouldnotreachhere = 3,
 993     stop_end                = 4
 994   };
 995   // Prints msg and stops execution.
 996   void    stop(int type, const char* msg, int id = 0);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="line-modified">   3  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
 696   // The rest of the type check; must be wired to a corresponding fast path.
 697   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 698   // The temp_reg can be noreg, if no temps are available.
 699   // It can also be sub_klass or super_klass, meaning it&#39;s OK to kill that one.
 700   // Updates the sub&#39;s secondary super cache as necessary.
 701   void check_klass_subtype_slow_path(Register Rsubklass,
 702                                      Register Rsuperklas,
 703                                      Register Rarray_ptr, // tmp
 704                                      Register Rlength,    // tmp
 705                                      Label* L_success,
 706                                      Label* L_failure);
 707 
 708   // Simplified, combined version, good for typical uses.
 709   // Falls through on failure.
 710   void check_klass_subtype(Register sub_klass,
 711                            Register super_klass,
 712                            Register temp1_reg,
 713                            Register temp2_reg,
 714                            Label&amp;   L_success);
 715 
<span class="line-added"> 716   void clinit_barrier(Register klass,</span>
<span class="line-added"> 717                       Register thread,</span>
<span class="line-added"> 718                       Label* L_fast_path = NULL,</span>
<span class="line-added"> 719                       Label* L_slow_path = NULL);</span>
<span class="line-added"> 720 </span>
 721   // Increment a counter at counter_address when the eq condition code is set.
 722   // Kills registers tmp1_reg and tmp2_reg and preserves the condition code.
 723   void increment_counter_eq(address counter_address, Register tmp1_reg, Register tmp2_reg);
 724   // Biased locking support
 725   // Upon entry,obj_reg must contain the target object, and mark_reg
 726   // must contain the target object&#39;s header.
 727   // Destroys mark_reg if an attempt is made to bias an anonymously
 728   // biased lock. In this case a failure will go either to the slow
 729   // case or fall through with the notEqual condition code set with
 730   // the expectation that the slow case in the runtime will be called.
 731   // In the fall-through case where the CAS-based lock is done,
 732   // mark_reg is not destroyed.
 733   void biased_locking_enter(Register obj_reg, Register mark_reg, Register temp_reg,
 734                             Register temp2_reg, Label&amp; done, Label* slow_case = NULL);
 735   // Upon entry, the base register of mark_addr must contain the oop.
 736   // Destroys temp_reg.
 737   // If allow_delay_slot_filling is set to true, the next instruction
 738   // emitted after this one will go in an annulled delay slot if the
 739   // biased locking exit case failed.
 740   void biased_locking_exit(Register mark_addr, Register temp_reg, Label&amp; done);
</pre>
<hr />
<pre>
 811                        Register tmp1, Register tmp2, Register tmp3);
 812   void access_load_at(BasicType type, DecoratorSet decorators,
 813                       const Address&amp; addr, Register dst,
 814                       Register tmp1, Register tmp2, Label *is_null = NULL);
 815 
 816  public:
 817   // tmp1 and tmp2 are used with decorators ON_PHANTOM_OOP_REF or ON_WEAK_OOP_REF.
 818   void load_heap_oop(Register dest, const Address &amp;a,
 819                      Register tmp1, Register tmp2,
 820                      DecoratorSet decorators = 0, Label *is_null = NULL);
 821   void store_heap_oop(Register Roop, const Address &amp;a,
 822                       Register tmp1, Register tmp2, Register tmp3,
 823                       DecoratorSet decorators = 0);
 824 
 825   void oop_encoder(Register Rdst, Register Rsrc, bool maybeNULL,
 826                    Register Rbase = Z_R1, int pow2_offset = -1, bool only32bitValid = false);
 827   void oop_decoder(Register Rdst, Register Rsrc, bool maybeNULL,
 828                    Register Rbase = Z_R1, int pow2_offset = -1);
 829 
 830   void resolve_oop_handle(Register result);
<span class="line-modified"> 831   void load_mirror_from_const_method(Register mirror, Register const_method);</span>
<span class="line-added"> 832   void load_method_holder(Register holder, Register method);</span>
 833 
 834   //--------------------------
 835   //---  Operations on arrays.
 836   //--------------------------
<span class="line-modified"> 837   unsigned int Clear_Array(Register cnt_arg, Register base_pointer_arg, Register odd_tmp_reg);</span>
 838   unsigned int Clear_Array_Const(long cnt, Register base);
<span class="line-modified"> 839   unsigned int Clear_Array_Const_Big(long cnt, Register base_pointer_arg, Register odd_tmp_reg);</span>
 840   unsigned int CopyRawMemory_AlignedDisjoint(Register src_reg, Register dst_reg,
 841                                              Register cnt_reg,
 842                                              Register tmp1_reg, Register tmp2_reg);
 843 
 844   //-------------------------------------------
 845   // Special String Intrinsics Implementation.
 846   //-------------------------------------------
 847   // Intrinsics for CompactStrings
 848   //   Restores: src, dst
 849   //   Uses:     cnt
 850   //   Kills:    tmp, Z_R0, Z_R1.
 851   //   Early clobber: result.
 852   //   Boolean precise controls accuracy of result value.
<span class="line-added"> 853 #ifdef COMPILER2</span>
 854   unsigned int string_compress(Register result, Register src, Register dst, Register cnt,
 855                                Register tmp,    bool precise);
 856 
 857   // Inflate byte[] to char[].
 858   unsigned int string_inflate_trot(Register src, Register dst, Register cnt, Register tmp);
 859 
 860   // Inflate byte[] to char[].
 861   //   Restores: src, dst
 862   //   Uses:     cnt
 863   //   Kills:    tmp, Z_R0, Z_R1.
 864   unsigned int string_inflate(Register src, Register dst, Register cnt, Register tmp);
 865 
 866   // Inflate byte[] to char[], length known at compile time.
 867   //   Restores: src, dst
 868   //   Kills:    tmp, Z_R0, Z_R1.
 869   // Note:
 870   //   len is signed int. Counts # characters, not bytes.
 871   unsigned int string_inflate_const(Register src, Register dst, Register tmp, int len);
 872 
 873   // Kills src.
 874   unsigned int has_negatives(Register result, Register src, Register cnt,
 875                              Register odd_reg, Register even_reg, Register tmp);
 876 
 877   unsigned int string_compare(Register str1, Register str2, Register cnt1, Register cnt2,
 878                               Register odd_reg, Register even_reg, Register result, int ae);
 879 
 880   unsigned int array_equals(bool is_array_equ, Register ary1, Register ary2, Register limit,
 881                             Register odd_reg, Register even_reg, Register result, bool is_byte);
 882 
 883   unsigned int string_indexof(Register result, Register haystack, Register haycnt,
 884                               Register needle, Register needlecnt, int needlecntval,
 885                               Register odd_reg, Register even_reg, int ae);
 886 
 887   unsigned int string_indexof_char(Register result, Register haystack, Register haycnt,
 888                                    Register needle, jchar needleChar, Register odd_reg, Register even_reg, bool is_byte);
<span class="line-added"> 889 #endif</span>
 890 
 891   // Emit an oop const to the constant pool and set a relocation info
 892   // with address current_pc. Return the TOC offset of the constant.
 893   int store_const_in_toc(AddressLiteral&amp; val);
 894   int store_oop_in_toc(AddressLiteral&amp; oop);
 895   // Emit an oop const to the constant pool via store_oop_in_toc, or
 896   // emit a scalar const to the constant pool via store_const_in_toc,
 897   // and load the constant into register dst.
 898   bool load_const_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc = noreg);
 899   // Get CPU version dependent size of load_const sequence.
 900   // The returned value is valid only for code sequences
 901   // generated by load_const, not load_const_optimized.
 902   static int load_const_from_toc_size() {
 903     return load_long_pcrelative_size();
 904   }
 905   bool load_oop_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc = noreg);
 906   static intptr_t get_const_from_toc(address pc);
 907   static void     set_const_in_toc(address pc, unsigned long new_data, CodeBlob *cb);
 908 
 909   // Dynamic TOC.
 910   static bool is_load_const(address a);
 911   static bool is_load_const_from_toc_pcrelative(address a);
 912   static bool is_load_const_from_toc(address a) { return is_load_const_from_toc_pcrelative(a); }
 913 
 914   // PCrelative TOC access.
 915   static bool is_call_byregister(address a) { return is_z_basr(*(short*)a); }
 916   static bool is_load_const_from_toc_call(address a);
 917   static bool is_load_const_call(address a);
 918   static int load_const_call_size() { return load_const_size() + call_byregister_size(); }
 919   static int load_const_from_toc_call_size() { return load_const_from_toc_size() + call_byregister_size(); }
 920   // Offset is +/- 2**32 -&gt; use long.
 921   static long get_load_const_from_toc_offset(address a);
 922 







 923   // Bit operations for single register operands.
 924   inline void lshift(Register r, int places, bool doubl = true);   // &lt;&lt;
 925   inline void rshift(Register r, int places, bool doubl = true);   // &gt;&gt;
 926 
 927   //
 928   // Debugging
 929   //
 930 
 931   // Assert on CC (condition code in CPU state).
 932   void asm_assert(bool check_equal, const char* msg, int id) PRODUCT_RETURN;
 933   void asm_assert_low(const char *msg, int id) PRODUCT_RETURN;
 934   void asm_assert_high(const char *msg, int id) PRODUCT_RETURN;
 935   void asm_assert_eq(const char* msg, int id) { asm_assert(true, msg, id); }
 936   void asm_assert_ne(const char* msg, int id) { asm_assert(false, msg, id); }
 937 
 938   void asm_assert_static(bool check_equal, const char* msg, int id) PRODUCT_RETURN;
 939 
 940  private:
 941   // Emit assertions.
 942   void asm_assert_mems_zero(bool check_equal, bool allow_relocation, int size, int64_t mem_offset,
</pre>
<hr />
<pre>
 956     asm_assert_mems_zero(false, true, 8, mem_offset, mem_base, msg, id);
 957   }
 958 
 959   inline void asm_assert_mem4_is_zero_static(int64_t mem_offset, Register mem_base, const char* msg, int id) {
 960     asm_assert_mems_zero(true,  false, 4, mem_offset, mem_base, msg, id);
 961   }
 962   inline void asm_assert_mem8_is_zero_static(int64_t mem_offset, Register mem_base, const char* msg, int id) {
 963     asm_assert_mems_zero(true,  false, 8, mem_offset, mem_base, msg, id);
 964   }
 965   inline void asm_assert_mem4_isnot_zero_static(int64_t mem_offset, Register mem_base, const char* msg, int id) {
 966     asm_assert_mems_zero(false, false, 4, mem_offset, mem_base, msg, id);
 967   }
 968   inline void asm_assert_mem8_isnot_zero_static(int64_t mem_offset, Register mem_base, const char* msg, int id) {
 969     asm_assert_mems_zero(false, false, 8, mem_offset, mem_base, msg, id);
 970   }
 971   void asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id) PRODUCT_RETURN;
 972 
 973   // Verify Z_thread contents.
 974   void verify_thread();
 975 
<span class="line-added"> 976   // Save and restore functions: Exclude Z_R0.</span>
<span class="line-added"> 977   void save_volatile_regs(   Register dst, int offset, bool include_fp, bool include_flags);</span>
<span class="line-added"> 978   void restore_volatile_regs(Register src, int offset, bool include_fp, bool include_flags);</span>
<span class="line-added"> 979 </span>
 980   // Only if +VerifyOops.
<span class="line-added"> 981   // Kills Z_R0.</span>
 982   void verify_oop(Register reg, const char* s = &quot;broken oop&quot;);
<span class="line-added"> 983   // Kills Z_R0, condition code.</span>
<span class="line-added"> 984   void verify_oop_addr(Address addr, const char* msg = &quot;contains broken oop&quot;);</span>
 985 
 986   // TODO: verify_method and klass metadata (compare against vptr?).
 987   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 988   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line) {}
 989 
 990 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 991 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 992 
 993  private:
 994   // Generate printout in stop().
 995   static const char* stop_types[];
 996   enum {
 997     stop_stop               = 0,
 998     stop_untested           = 1,
 999     stop_unimplemented      = 2,
1000     stop_shouldnotreachhere = 3,
1001     stop_end                = 4
1002   };
1003   // Prints msg and stops execution.
1004   void    stop(int type, const char* msg, int id = 0);
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
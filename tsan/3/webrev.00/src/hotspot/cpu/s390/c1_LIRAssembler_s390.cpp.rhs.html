<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/c1_LIRAssembler_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
<a name="2" id="anc2"></a><span class="line-modified">  36 #include &quot;memory/universe.hpp&quot;</span>

  37 #include &quot;nativeInst_s390.hpp&quot;
  38 #include &quot;oops/objArrayKlass.hpp&quot;
  39 #include &quot;runtime/frame.inline.hpp&quot;
  40 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  41 #include &quot;runtime/sharedRuntime.hpp&quot;
<a name="3" id="anc3"></a><span class="line-added">  42 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  43 #include &quot;vmreg_s390.inline.hpp&quot;
  44 
  45 #define __ _masm-&gt;
  46 
  47 #ifndef PRODUCT
  48 #undef __
  49 #define __ (Verbose ? (_masm-&gt;block_comment(FILE_AND_LINE),_masm) : _masm)-&gt;
  50 #endif
  51 
  52 //------------------------------------------------------------
  53 
  54 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  55   // Not used on ZARCH_64
  56   ShouldNotCallThis();
  57   return false;
  58 }
  59 
  60 LIR_Opr LIR_Assembler::receiverOpr() {
  61   return FrameMap::Z_R2_oop_opr;
  62 }
  63 
  64 LIR_Opr LIR_Assembler::osrBufferPointer() {
  65   return FrameMap::Z_R2_opr;
  66 }
  67 
  68 int LIR_Assembler::initial_frame_size_in_bytes() const {
  69   return in_bytes(frame_map()-&gt;framesize_in_bytes());
  70 }
  71 
  72 // Inline cache check: done before the frame is built.
  73 // The inline cached class is in Z_inline_cache(Z_R9).
  74 // We fetch the class of the receiver and compare it with the cached class.
  75 // If they do not match we jump to the slow case.
  76 int LIR_Assembler::check_icache() {
  77   Register receiver = receiverOpr()-&gt;as_register();
  78   int offset = __ offset();
  79   __ inline_cache_check(receiver, Z_inline_cache);
  80   return offset;
  81 }
  82 
<a name="4" id="anc4"></a><span class="line-added">  83 void LIR_Assembler::clinit_barrier(ciMethod* method) {</span>
<span class="line-added">  84   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-added">  85 </span>
<span class="line-added">  86   Label L_skip_barrier;</span>
<span class="line-added">  87   Register klass = Z_R1_scratch;</span>
<span class="line-added">  88 </span>
<span class="line-added">  89   metadata2reg(method-&gt;holder()-&gt;constant_encoding(), klass);</span>
<span class="line-added">  90   __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added">  91 </span>
<span class="line-added">  92   __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());</span>
<span class="line-added">  93   __ z_br(klass);</span>
<span class="line-added">  94 </span>
<span class="line-added">  95   __ bind(L_skip_barrier);</span>
<span class="line-added">  96 }</span>
<span class="line-added">  97 </span>
  98 void LIR_Assembler::osr_entry() {
  99   // On-stack-replacement entry sequence (interpreter frame layout described in interpreter_sparc.cpp):
 100   //
 101   //   1. Create a new compiled activation.
 102   //   2. Initialize local variables in the compiled activation. The expression stack must be empty
 103   //      at the osr_bci; it is not initialized.
 104   //   3. Jump to the continuation address in compiled code to resume execution.
 105 
 106   // OSR entry point
 107   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 108   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 109   ValueStack* entry_state = osr_entry-&gt;end()-&gt;state();
 110   int number_of_locks = entry_state-&gt;locks_size();
 111 
 112   // Create a frame for the compiled activation.
 113   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 114 
 115   // OSR buffer is
 116   //
 117   // locals[nlocals-1..0]
 118   // monitors[number_of_locks-1..0]
 119   //
 120   // Locals is a direct copy of the interpreter frame so in the osr buffer
 121   // the first slot in the local array is the last local from the interpreter
 122   // and the last slot is local[0] (receiver) from the interpreter
 123   //
 124   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 125   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 126   // in the interpreter frame (the method lock if a sync method)
 127 
 128   // Initialize monitors in the compiled activation.
 129   //   I0: pointer to osr buffer
 130   //
 131   // All other registers are dead at this point and the locals will be
 132   // copied into place by code emitted in the IR.
 133 
 134   Register OSR_buf = osrBufferPointer()-&gt;as_register();
 135   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 136     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 137       (2 * BytesPerWord) * (number_of_locks - 1);
 138     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 139     // the OSR buffer using 2 word entries: first the lock and then
 140     // the oop.
 141     for (int i = 0; i &lt; number_of_locks; i++) {
 142       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 143       // Verify the interpreter&#39;s monitor has a non-null object.
 144       __ asm_assert_mem8_isnot_zero(slot_offset + 1*BytesPerWord, OSR_buf, &quot;locked object is NULL&quot;, __LINE__);
 145       // Copy the lock field into the compiled activation.
 146       __ z_lg(Z_R1_scratch, slot_offset + 0, OSR_buf);
 147       __ z_stg(Z_R1_scratch, frame_map()-&gt;address_for_monitor_lock(i));
 148       __ z_lg(Z_R1_scratch, slot_offset + 1*BytesPerWord, OSR_buf);
 149       __ z_stg(Z_R1_scratch, frame_map()-&gt;address_for_monitor_object(i));
 150     }
 151   }
 152 }
 153 
 154 // --------------------------------------------------------------------------------------------
 155 
 156 address LIR_Assembler::emit_call_c(address a) {
 157   __ align_call_far_patchable(__ pc());
 158   address call_addr = __ call_c_opt(a);
 159   if (call_addr == NULL) {
 160     bailout(&quot;const section overflow&quot;);
 161   }
 162   return call_addr;
 163 }
 164 
 165 int LIR_Assembler::emit_exception_handler() {
 166   // If the last instruction is a call (typically to do a throw which
 167   // is coming at the end after block reordering) the return address
 168   // must still point into the code area in order to avoid assertion
 169   // failures when searching for the corresponding bci. =&gt; Add a nop.
 170   // (was bug 5/14/1999 - gri)
 171   __ nop();
 172 
 173   // Generate code for exception handler.
 174   address handler_base = __ start_a_stub(exception_handler_size());
 175   if (handler_base == NULL) {
 176     // Not enough space left for the handler.
 177     bailout(&quot;exception handler overflow&quot;);
 178     return -1;
 179   }
 180 
 181   int offset = code_offset();
 182 
 183   address a = Runtime1::entry_for (Runtime1::handle_exception_from_callee_id);
 184   address call_addr = emit_call_c(a);
 185   CHECK_BAILOUT_(-1);
 186   __ should_not_reach_here();
 187   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 188   __ end_a_stub();
 189 
 190   return offset;
 191 }
 192 
 193 // Emit the code to remove the frame from the stack in the exception
 194 // unwind path.
 195 int LIR_Assembler::emit_unwind_handler() {
 196 #ifndef PRODUCT
 197   if (CommentedAssembly) {
 198     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 199   }
 200 #endif
 201 
 202   int offset = code_offset();
 203   Register exception_oop_callee_saved = Z_R10; // Z_R10 is callee-saved.
 204   Register Rtmp1                      = Z_R11;
 205   Register Rtmp2                      = Z_R12;
 206 
 207   // Fetch the exception from TLS and clear out exception related thread state.
 208   Address exc_oop_addr = Address(Z_thread, JavaThread::exception_oop_offset());
 209   Address exc_pc_addr  = Address(Z_thread, JavaThread::exception_pc_offset());
 210   __ z_lg(Z_EXC_OOP, exc_oop_addr);
 211   __ clear_mem(exc_oop_addr, sizeof(oop));
 212   __ clear_mem(exc_pc_addr, sizeof(intptr_t));
 213 
 214   __ bind(_unwind_handler_entry);
 215   __ verify_not_null_oop(Z_EXC_OOP);
 216   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 217     __ lgr_if_needed(exception_oop_callee_saved, Z_EXC_OOP); // Preserve the exception.
 218   }
 219 
 220   // Preform needed unlocking.
 221   MonitorExitStub* stub = NULL;
 222   if (method()-&gt;is_synchronized()) {
 223     // Runtime1::monitorexit_id expects lock address in Z_R1_scratch.
 224     LIR_Opr lock = FrameMap::as_opr(Z_R1_scratch);
 225     monitor_address(0, lock);
 226     stub = new MonitorExitStub(lock, true, 0);
 227     __ unlock_object(Rtmp1, Rtmp2, lock-&gt;as_register(), *stub-&gt;entry());
 228     __ bind(*stub-&gt;continuation());
 229   }
 230 
 231   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 232     ShouldNotReachHere(); // Not supported.
 233 #if 0
 234     __ mov(rdi, r15_thread);
 235     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 236     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 237 #endif
 238   }
 239 
 240   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 241     __ lgr_if_needed(Z_EXC_OOP, exception_oop_callee_saved);  // Restore the exception.
 242   }
 243 
 244   // Remove the activation and dispatch to the unwind handler.
 245   __ pop_frame();
 246   __ z_lg(Z_EXC_PC, _z_abi16(return_pc), Z_SP);
 247 
 248   // Z_EXC_OOP: exception oop
 249   // Z_EXC_PC: exception pc
 250 
 251   // Dispatch to the unwind logic.
 252   __ load_const_optimized(Z_R5, Runtime1::entry_for (Runtime1::unwind_exception_id));
 253   __ z_br(Z_R5);
 254 
 255   // Emit the slow path assembly.
 256   if (stub != NULL) {
 257     stub-&gt;emit_code(this);
 258   }
 259 
 260   return offset;
 261 }
 262 
 263 int LIR_Assembler::emit_deopt_handler() {
 264   // If the last instruction is a call (typically to do a throw which
 265   // is coming at the end after block reordering) the return address
 266   // must still point into the code area in order to avoid assertion
 267   // failures when searching for the corresponding bci. =&gt; Add a nop.
 268   // (was bug 5/14/1999 - gri)
 269   __ nop();
 270 
 271   // Generate code for exception handler.
 272   address handler_base = __ start_a_stub(deopt_handler_size());
 273   if (handler_base == NULL) {
 274     // Not enough space left for the handler.
 275     bailout(&quot;deopt handler overflow&quot;);
 276     return -1;
 277   }  int offset = code_offset();
 278   // Size must be constant (see HandlerImpl::emit_deopt_handler).
 279   __ load_const(Z_R1_scratch, SharedRuntime::deopt_blob()-&gt;unpack());
 280   __ call(Z_R1_scratch);
 281   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 282   __ end_a_stub();
 283 
 284   return offset;
 285 }
 286 
 287 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 288   if (o == NULL) {
 289     __ clear_reg(reg, true/*64bit*/, false/*set cc*/); // Must not kill cc set by cmove.
 290   } else {
 291     AddressLiteral a = __ allocate_oop_address(o);
 292     bool success = __ load_oop_from_toc(reg, a, reg);
 293     if (!success) {
 294       bailout(&quot;const section overflow&quot;);
 295     }
 296   }
 297 }
 298 
 299 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 300   // Allocate a new index in table to hold the object once it&#39;s been patched.
 301   int oop_index = __ oop_recorder()-&gt;allocate_oop_index(NULL);
 302   PatchingStub* patch = new PatchingStub(_masm, patching_id(info), oop_index);
 303 
 304   AddressLiteral addrlit((intptr_t)0, oop_Relocation::spec(oop_index));
 305   assert(addrlit.rspec().type() == relocInfo::oop_type, &quot;must be an oop reloc&quot;);
 306   // The NULL will be dynamically patched later so the sequence to
 307   // load the address literal must not be optimized.
 308   __ load_const(reg, addrlit);
 309 
 310   patching_epilog(patch, lir_patch_normal, reg, info);
 311 }
 312 
 313 void LIR_Assembler::metadata2reg(Metadata* md, Register reg) {
 314   bool success = __ set_metadata_constant(md, reg);
 315   if (!success) {
 316     bailout(&quot;const section overflow&quot;);
 317     return;
 318   }
 319 }
 320 
 321 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo *info) {
 322   // Allocate a new index in table to hold the klass once it&#39;s been patched.
 323   int index = __ oop_recorder()-&gt;allocate_metadata_index(NULL);
 324   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id, index);
 325   AddressLiteral addrlit((intptr_t)0, metadata_Relocation::spec(index));
 326   assert(addrlit.rspec().type() == relocInfo::metadata_type, &quot;must be an metadata reloc&quot;);
 327   // The NULL will be dynamically patched later so the sequence to
 328   // load the address literal must not be optimized.
 329   __ load_const(reg, addrlit);
 330 
 331   patching_epilog(patch, lir_patch_normal, reg, info);
 332 }
 333 
 334 void LIR_Assembler::emit_op3(LIR_Op3* op) {
 335   switch (op-&gt;code()) {
 336     case lir_idiv:
 337     case lir_irem:
 338       arithmetic_idiv(op-&gt;code(),
 339                       op-&gt;in_opr1(),
 340                       op-&gt;in_opr2(),
 341                       op-&gt;in_opr3(),
 342                       op-&gt;result_opr(),
 343                       op-&gt;info());
 344       break;
 345     case lir_fmad: {
 346       const FloatRegister opr1 = op-&gt;in_opr1()-&gt;as_double_reg(),
 347                           opr2 = op-&gt;in_opr2()-&gt;as_double_reg(),
 348                           opr3 = op-&gt;in_opr3()-&gt;as_double_reg(),
 349                           res  = op-&gt;result_opr()-&gt;as_double_reg();
 350       __ z_madbr(opr3, opr1, opr2);
 351       if (res != opr3) { __ z_ldr(res, opr3); }
 352     } break;
 353     case lir_fmaf: {
 354       const FloatRegister opr1 = op-&gt;in_opr1()-&gt;as_float_reg(),
 355                           opr2 = op-&gt;in_opr2()-&gt;as_float_reg(),
 356                           opr3 = op-&gt;in_opr3()-&gt;as_float_reg(),
 357                           res  = op-&gt;result_opr()-&gt;as_float_reg();
 358       __ z_maebr(opr3, opr1, opr2);
 359       if (res != opr3) { __ z_ler(res, opr3); }
 360     } break;
 361     default: ShouldNotReachHere(); break;
 362   }
 363 }
 364 
 365 
 366 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
 367 #ifdef ASSERT
 368   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
 369   if (op-&gt;block() != NULL)  { _branch_target_blocks.append(op-&gt;block()); }
 370   if (op-&gt;ublock() != NULL) { _branch_target_blocks.append(op-&gt;ublock()); }
 371 #endif
 372 
 373   if (op-&gt;cond() == lir_cond_always) {
 374     if (op-&gt;info() != NULL) { add_debug_info_for_branch(op-&gt;info()); }
 375     __ branch_optimized(Assembler::bcondAlways, *(op-&gt;label()));
 376   } else {
 377     Assembler::branch_condition acond = Assembler::bcondZero;
 378     if (op-&gt;code() == lir_cond_float_branch) {
 379       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
 380       __ branch_optimized(Assembler::bcondNotOrdered, *(op-&gt;ublock()-&gt;label()));
 381     }
 382     switch (op-&gt;cond()) {
 383       case lir_cond_equal:        acond = Assembler::bcondEqual;     break;
 384       case lir_cond_notEqual:     acond = Assembler::bcondNotEqual;  break;
 385       case lir_cond_less:         acond = Assembler::bcondLow;       break;
 386       case lir_cond_lessEqual:    acond = Assembler::bcondNotHigh;   break;
 387       case lir_cond_greaterEqual: acond = Assembler::bcondNotLow;    break;
 388       case lir_cond_greater:      acond = Assembler::bcondHigh;      break;
 389       case lir_cond_belowEqual:   acond = Assembler::bcondNotHigh;   break;
 390       case lir_cond_aboveEqual:   acond = Assembler::bcondNotLow;    break;
 391       default:                         ShouldNotReachHere();
 392     }
 393     __ branch_optimized(acond,*(op-&gt;label()));
 394   }
 395 }
 396 
 397 
 398 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
 399   LIR_Opr src  = op-&gt;in_opr();
 400   LIR_Opr dest = op-&gt;result_opr();
 401 
 402   switch (op-&gt;bytecode()) {
 403     case Bytecodes::_i2l:
 404       __ move_reg_if_needed(dest-&gt;as_register_lo(), T_LONG, src-&gt;as_register(), T_INT);
 405       break;
 406 
 407     case Bytecodes::_l2i:
 408       __ move_reg_if_needed(dest-&gt;as_register(), T_INT, src-&gt;as_register_lo(), T_LONG);
 409       break;
 410 
 411     case Bytecodes::_i2b:
 412       __ move_reg_if_needed(dest-&gt;as_register(), T_BYTE, src-&gt;as_register(), T_INT);
 413       break;
 414 
 415     case Bytecodes::_i2c:
 416       __ move_reg_if_needed(dest-&gt;as_register(), T_CHAR, src-&gt;as_register(), T_INT);
 417       break;
 418 
 419     case Bytecodes::_i2s:
 420       __ move_reg_if_needed(dest-&gt;as_register(), T_SHORT, src-&gt;as_register(), T_INT);
 421       break;
 422 
 423     case Bytecodes::_f2d:
 424       assert(dest-&gt;is_double_fpu(), &quot;check&quot;);
 425       __ move_freg_if_needed(dest-&gt;as_double_reg(), T_DOUBLE, src-&gt;as_float_reg(), T_FLOAT);
 426       break;
 427 
 428     case Bytecodes::_d2f:
 429       assert(dest-&gt;is_single_fpu(), &quot;check&quot;);
 430       __ move_freg_if_needed(dest-&gt;as_float_reg(), T_FLOAT, src-&gt;as_double_reg(), T_DOUBLE);
 431       break;
 432 
 433     case Bytecodes::_i2f:
 434       __ z_cefbr(dest-&gt;as_float_reg(), src-&gt;as_register());
 435       break;
 436 
 437     case Bytecodes::_i2d:
 438       __ z_cdfbr(dest-&gt;as_double_reg(), src-&gt;as_register());
 439       break;
 440 
 441     case Bytecodes::_l2f:
 442       __ z_cegbr(dest-&gt;as_float_reg(), src-&gt;as_register_lo());
 443       break;
 444     case Bytecodes::_l2d:
 445       __ z_cdgbr(dest-&gt;as_double_reg(), src-&gt;as_register_lo());
 446       break;
 447 
 448     case Bytecodes::_f2i:
 449     case Bytecodes::_f2l: {
 450       Label done;
 451       FloatRegister Rsrc = src-&gt;as_float_reg();
 452       Register Rdst = (op-&gt;bytecode() == Bytecodes::_f2i ? dest-&gt;as_register() : dest-&gt;as_register_lo());
 453       __ clear_reg(Rdst, true, false);
 454       __ z_cebr(Rsrc, Rsrc);
 455       __ z_brno(done); // NaN -&gt; 0
 456       if (op-&gt;bytecode() == Bytecodes::_f2i) {
 457         __ z_cfebr(Rdst, Rsrc, Assembler::to_zero);
 458       } else { // op-&gt;bytecode() == Bytecodes::_f2l
 459         __ z_cgebr(Rdst, Rsrc, Assembler::to_zero);
 460       }
 461       __ bind(done);
 462     }
 463     break;
 464 
 465     case Bytecodes::_d2i:
 466     case Bytecodes::_d2l: {
 467       Label done;
 468       FloatRegister Rsrc = src-&gt;as_double_reg();
 469       Register Rdst = (op-&gt;bytecode() == Bytecodes::_d2i ? dest-&gt;as_register() : dest-&gt;as_register_lo());
 470       __ clear_reg(Rdst, true, false);  // Don&#39;t set CC.
 471       __ z_cdbr(Rsrc, Rsrc);
 472       __ z_brno(done); // NaN -&gt; 0
 473       if (op-&gt;bytecode() == Bytecodes::_d2i) {
 474         __ z_cfdbr(Rdst, Rsrc, Assembler::to_zero);
 475       } else { // Bytecodes::_d2l
 476         __ z_cgdbr(Rdst, Rsrc, Assembler::to_zero);
 477       }
 478       __ bind(done);
 479     }
 480     break;
 481 
 482     default: ShouldNotReachHere();
 483   }
 484 }
 485 
 486 void LIR_Assembler::align_call(LIR_Code code) {
 487   // End of call instruction must be 4 byte aligned.
 488   int offset = __ offset();
 489   switch (code) {
 490     case lir_icvirtual_call:
 491       offset += MacroAssembler::load_const_from_toc_size();
 492       // no break
 493     case lir_static_call:
 494     case lir_optvirtual_call:
 495     case lir_dynamic_call:
 496       offset += NativeCall::call_far_pcrelative_displacement_offset;
 497       break;
 498     case lir_virtual_call:   // currently, sparc-specific for niagara
 499     default: ShouldNotReachHere();
 500   }
 501   if ((offset &amp; (NativeCall::call_far_pcrelative_displacement_alignment-1)) != 0) {
 502     __ nop();
 503   }
 504 }
 505 
 506 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
 507   assert((__ offset() + NativeCall::call_far_pcrelative_displacement_offset) % NativeCall::call_far_pcrelative_displacement_alignment == 0,
 508          &quot;must be aligned (offset=%d)&quot;, __ offset());
 509   assert(rtype == relocInfo::none ||
 510          rtype == relocInfo::opt_virtual_call_type ||
 511          rtype == relocInfo::static_call_type, &quot;unexpected rtype&quot;);
 512   // Prepend each BRASL with a nop.
 513   __ relocate(rtype);
 514   __ z_nop();
 515   __ z_brasl(Z_R14, op-&gt;addr());
 516   add_call_info(code_offset(), op-&gt;info());
 517 }
 518 
 519 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
 520   address virtual_call_oop_addr = NULL;
 521   AddressLiteral empty_ic((address) Universe::non_oop_word());
 522   virtual_call_oop_addr = __ pc();
 523   bool success = __ load_const_from_toc(Z_inline_cache, empty_ic);
 524   if (!success) {
 525     bailout(&quot;const section overflow&quot;);
 526     return;
 527   }
 528 
 529   // CALL to fixup routine. Fixup routine uses ScopeDesc info
 530   // to determine who we intended to call.
 531   __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr));
 532   call(op, relocInfo::none);
 533 }
 534 
 535 // not supported
 536 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
 537   ShouldNotReachHere();
 538 }
 539 
 540 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 541   if (from_reg != to_reg) __ z_lgr(to_reg, from_reg);
 542 }
 543 
 544 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 545   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 546   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 547   LIR_Const* c = src-&gt;as_constant_ptr();
 548 
 549   unsigned int lmem = 0;
 550   unsigned int lcon = 0;
 551   int64_t cbits = 0;
 552   Address dest_addr;
 553   switch (c-&gt;type()) {
 554     case T_INT:  // fall through
 555     case T_FLOAT:
 556       dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 557       lmem = 4; lcon = 4; cbits = c-&gt;as_jint_bits();
 558       break;
 559 
 560     case T_ADDRESS:
 561       dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 562       lmem = 8; lcon = 4; cbits = c-&gt;as_jint_bits();
 563       break;
 564 
 565     case T_OBJECT:
 566       dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 567       if (c-&gt;as_jobject() == NULL) {
 568         __ store_const(dest_addr, (int64_t)NULL_WORD, 8, 8);
 569       } else {
 570         jobject2reg(c-&gt;as_jobject(), Z_R1_scratch);
 571         __ reg2mem_opt(Z_R1_scratch, dest_addr, true);
 572       }
 573       return;
 574 
 575     case T_LONG:  // fall through
 576     case T_DOUBLE:
 577       dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 578       lmem = 8; lcon = 8; cbits = (int64_t)(c-&gt;as_jlong_bits());
 579       break;
 580 
 581     default:
 582       ShouldNotReachHere();
 583   }
 584 
 585   __ store_const(dest_addr, cbits, lmem, lcon);
 586 }
 587 
 588 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 589   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 590   assert(dest-&gt;is_address(), &quot;should not call otherwise&quot;);
 591 
 592   LIR_Const* c = src-&gt;as_constant_ptr();
 593   Address addr = as_Address(dest-&gt;as_address_ptr());
 594 
 595   int store_offset = -1;
 596 
 597   if (dest-&gt;as_address_ptr()-&gt;index()-&gt;is_valid()) {
 598     switch (type) {
 599       case T_INT:    // fall through
 600       case T_FLOAT:
 601         __ load_const_optimized(Z_R0_scratch, c-&gt;as_jint_bits());
 602         store_offset = __ offset();
 603         if (Immediate::is_uimm12(addr.disp())) {
 604           __ z_st(Z_R0_scratch, addr);
 605         } else {
 606           __ z_sty(Z_R0_scratch, addr);
 607         }
 608         break;
 609 
 610       case T_ADDRESS:
 611         __ load_const_optimized(Z_R1_scratch, c-&gt;as_jint_bits());
 612         store_offset = __ reg2mem_opt(Z_R1_scratch, addr, true);
 613         break;
 614 
 615       case T_OBJECT:  // fall through
 616       case T_ARRAY:
 617         if (c-&gt;as_jobject() == NULL) {
 618           if (UseCompressedOops &amp;&amp; !wide) {
 619             __ clear_reg(Z_R1_scratch, false);
 620             store_offset = __ reg2mem_opt(Z_R1_scratch, addr, false);
 621           } else {
 622             __ clear_reg(Z_R1_scratch, true);
 623             store_offset = __ reg2mem_opt(Z_R1_scratch, addr, true);
 624           }
 625         } else {
 626           jobject2reg(c-&gt;as_jobject(), Z_R1_scratch);
 627           if (UseCompressedOops &amp;&amp; !wide) {
 628             __ encode_heap_oop(Z_R1_scratch);
 629             store_offset = __ reg2mem_opt(Z_R1_scratch, addr, false);
 630           } else {
 631             store_offset = __ reg2mem_opt(Z_R1_scratch, addr, true);
 632           }
 633         }
 634         assert(store_offset &gt;= 0, &quot;check&quot;);
 635         break;
 636 
 637       case T_LONG:    // fall through
 638       case T_DOUBLE:
 639         __ load_const_optimized(Z_R1_scratch, (int64_t)(c-&gt;as_jlong_bits()));
 640         store_offset = __ reg2mem_opt(Z_R1_scratch, addr, true);
 641         break;
 642 
 643       case T_BOOLEAN: // fall through
 644       case T_BYTE:
 645         __ load_const_optimized(Z_R0_scratch, (int8_t)(c-&gt;as_jint()));
 646         store_offset = __ offset();
 647         if (Immediate::is_uimm12(addr.disp())) {
 648           __ z_stc(Z_R0_scratch, addr);
 649         } else {
 650           __ z_stcy(Z_R0_scratch, addr);
 651         }
 652         break;
 653 
 654       case T_CHAR:    // fall through
 655       case T_SHORT:
 656         __ load_const_optimized(Z_R0_scratch, (int16_t)(c-&gt;as_jint()));
 657         store_offset = __ offset();
 658         if (Immediate::is_uimm12(addr.disp())) {
 659           __ z_sth(Z_R0_scratch, addr);
 660         } else {
 661           __ z_sthy(Z_R0_scratch, addr);
 662         }
 663         break;
 664 
 665       default:
 666         ShouldNotReachHere();
 667     }
 668 
 669   } else { // no index
 670 
 671     unsigned int lmem = 0;
 672     unsigned int lcon = 0;
 673     int64_t cbits = 0;
 674 
 675     switch (type) {
 676       case T_INT:    // fall through
 677       case T_FLOAT:
 678         lmem = 4; lcon = 4; cbits = c-&gt;as_jint_bits();
 679         break;
 680 
 681       case T_ADDRESS:
 682         lmem = 8; lcon = 4; cbits = c-&gt;as_jint_bits();
 683         break;
 684 
 685       case T_OBJECT:  // fall through
 686       case T_ARRAY:
 687         if (c-&gt;as_jobject() == NULL) {
 688           if (UseCompressedOops &amp;&amp; !wide) {
 689             store_offset = __ store_const(addr, (int32_t)NULL_WORD, 4, 4);
 690           } else {
 691             store_offset = __ store_const(addr, (int64_t)NULL_WORD, 8, 8);
 692           }
 693         } else {
 694           jobject2reg(c-&gt;as_jobject(), Z_R1_scratch);
 695           if (UseCompressedOops &amp;&amp; !wide) {
 696             __ encode_heap_oop(Z_R1_scratch);
 697             store_offset = __ reg2mem_opt(Z_R1_scratch, addr, false);
 698           } else {
 699             store_offset = __ reg2mem_opt(Z_R1_scratch, addr, true);
 700           }
 701         }
 702         assert(store_offset &gt;= 0, &quot;check&quot;);
 703         break;
 704 
 705       case T_LONG:    // fall through
 706       case T_DOUBLE:
 707         lmem = 8; lcon = 8; cbits = (int64_t)(c-&gt;as_jlong_bits());
 708         break;
 709 
 710       case T_BOOLEAN: // fall through
 711       case T_BYTE:
 712         lmem = 1; lcon = 1; cbits = (int8_t)(c-&gt;as_jint());
 713         break;
 714 
 715       case T_CHAR:    // fall through
 716       case T_SHORT:
 717         lmem = 2; lcon = 2; cbits = (int16_t)(c-&gt;as_jint());
 718         break;
 719 
 720       default:
 721         ShouldNotReachHere();
 722     }
 723 
 724     if (store_offset == -1) {
 725       store_offset = __ store_const(addr, cbits, lmem, lcon);
 726       assert(store_offset &gt;= 0, &quot;check&quot;);
 727     }
 728   }
 729 
 730   if (info != NULL) {
 731     add_debug_info_for_null_check(store_offset, info);
 732   }
 733 }
 734 
 735 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 736   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 737   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 738   LIR_Const* c = src-&gt;as_constant_ptr();
 739 
 740   switch (c-&gt;type()) {
 741     case T_INT: {
 742       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 743       __ load_const_optimized(dest-&gt;as_register(), c-&gt;as_jint());
 744       break;
 745     }
 746 
 747     case T_ADDRESS: {
 748       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 749       __ load_const_optimized(dest-&gt;as_register(), c-&gt;as_jint());
 750       break;
 751     }
 752 
 753     case T_LONG: {
 754       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 755       __ load_const_optimized(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 756       break;
 757     }
 758 
 759     case T_OBJECT: {
 760       if (patch_code != lir_patch_none) {
 761         jobject2reg_with_patching(dest-&gt;as_register(), info);
 762       } else {
 763         jobject2reg(c-&gt;as_jobject(), dest-&gt;as_register());
 764       }
 765       break;
 766     }
 767 
 768     case T_METADATA: {
 769       if (patch_code != lir_patch_none) {
 770         klass2reg_with_patching(dest-&gt;as_register(), info);
 771       } else {
 772         metadata2reg(c-&gt;as_metadata(), dest-&gt;as_register());
 773       }
 774       break;
 775     }
 776 
 777     case T_FLOAT: {
 778       Register toc_reg = Z_R1_scratch;
 779       __ load_toc(toc_reg);
 780       address const_addr = __ float_constant(c-&gt;as_jfloat());
 781       if (const_addr == NULL) {
 782         bailout(&quot;const section overflow&quot;);
 783         break;
 784       }
 785       int displ = const_addr - _masm-&gt;code()-&gt;consts()-&gt;start();
 786       if (dest-&gt;is_single_fpu()) {
 787         __ z_ley(dest-&gt;as_float_reg(), displ, toc_reg);
 788       } else {
 789         assert(dest-&gt;is_single_cpu(), &quot;Must be a cpu register.&quot;);
 790         __ z_ly(dest-&gt;as_register(), displ, toc_reg);
 791       }
 792     }
 793     break;
 794 
 795     case T_DOUBLE: {
 796       Register toc_reg = Z_R1_scratch;
 797       __ load_toc(toc_reg);
 798       address const_addr = __ double_constant(c-&gt;as_jdouble());
 799       if (const_addr == NULL) {
 800         bailout(&quot;const section overflow&quot;);
 801         break;
 802       }
 803       int displ = const_addr - _masm-&gt;code()-&gt;consts()-&gt;start();
 804       if (dest-&gt;is_double_fpu()) {
 805         __ z_ldy(dest-&gt;as_double_reg(), displ, toc_reg);
 806       } else {
 807         assert(dest-&gt;is_double_cpu(), &quot;Must be a long register.&quot;);
 808         __ z_lg(dest-&gt;as_register_lo(), displ, toc_reg);
 809       }
 810     }
 811     break;
 812 
 813     default:
 814       ShouldNotReachHere();
 815   }
 816 }
 817 
 818 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 819   if (addr-&gt;base()-&gt;is_illegal()) {
 820     Unimplemented();
 821   }
 822 
 823   Register base = addr-&gt;base()-&gt;as_pointer_register();
 824 
 825   if (addr-&gt;index()-&gt;is_illegal()) {
 826     return Address(base, addr-&gt;disp());
 827   } else if (addr-&gt;index()-&gt;is_cpu_register()) {
 828     Register index = addr-&gt;index()-&gt;as_pointer_register();
 829     return Address(base, index, addr-&gt;disp());
 830   } else if (addr-&gt;index()-&gt;is_constant()) {
 831     intptr_t addr_offset = addr-&gt;index()-&gt;as_constant_ptr()-&gt;as_jint() + addr-&gt;disp();
 832     return Address(base, addr_offset);
 833   } else {
 834     ShouldNotReachHere();
 835     return Address();
 836   }
 837 }
 838 
 839 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
 840   switch (type) {
 841     case T_INT:
 842     case T_FLOAT: {
 843       Register tmp = Z_R1_scratch;
 844       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
 845       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 846       __ mem2reg_opt(tmp, from, false);
 847       __ reg2mem_opt(tmp, to, false);
 848       break;
 849     }
 850     case T_ADDRESS:
 851     case T_OBJECT: {
 852       Register tmp = Z_R1_scratch;
 853       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
 854       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 855       __ mem2reg_opt(tmp, from, true);
 856       __ reg2mem_opt(tmp, to, true);
 857       break;
 858     }
 859     case T_LONG:
 860     case T_DOUBLE: {
 861       Register tmp = Z_R1_scratch;
 862       Address from = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
 863       Address to   = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
 864       __ mem2reg_opt(tmp, from, true);
 865       __ reg2mem_opt(tmp, to, true);
 866       break;
 867     }
 868 
 869     default:
 870       ShouldNotReachHere();
 871   }
 872 }
 873 
 874 // 4-byte accesses only! Don&#39;t use it to access 8 bytes!
 875 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 876   ShouldNotCallThis();
 877   return 0; // unused
 878 }
 879 
 880 // 4-byte accesses only! Don&#39;t use it to access 8 bytes!
 881 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 882   ShouldNotCallThis();
 883   return 0; // unused
 884 }
 885 
 886 void LIR_Assembler::mem2reg(LIR_Opr src_opr, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code,
 887                             CodeEmitInfo* info, bool wide, bool unaligned) {
 888 
 889   assert(type != T_METADATA, &quot;load of metadata ptr not supported&quot;);
 890   LIR_Address* addr = src_opr-&gt;as_address_ptr();
 891   LIR_Opr to_reg = dest;
 892 
 893   Register src = addr-&gt;base()-&gt;as_pointer_register();
 894   Register disp_reg = Z_R0;
 895   int disp_value = addr-&gt;disp();
 896   bool needs_patching = (patch_code != lir_patch_none);
 897 
 898   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
<a name="5" id="anc5"></a><span class="line-modified"> 899     __ verify_oop(src, FILE_AND_LINE);</span>
 900   }
 901 
 902   PatchingStub* patch = NULL;
 903   if (needs_patching) {
 904     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 905     assert(!to_reg-&gt;is_double_cpu() ||
 906            patch_code == lir_patch_none ||
 907            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
 908   }
 909 
 910   if (addr-&gt;index()-&gt;is_illegal()) {
 911     if (!Immediate::is_simm20(disp_value)) {
 912       if (needs_patching) {
 913         __ load_const(Z_R1_scratch, (intptr_t)0);
 914       } else {
 915         __ load_const_optimized(Z_R1_scratch, disp_value);
 916       }
 917       disp_reg = Z_R1_scratch;
 918       disp_value = 0;
 919     }
 920   } else {
 921     if (!Immediate::is_simm20(disp_value)) {
 922       __ load_const_optimized(Z_R1_scratch, disp_value);
 923       __ z_la(Z_R1_scratch, 0, Z_R1_scratch, addr-&gt;index()-&gt;as_register());
 924       disp_reg = Z_R1_scratch;
 925       disp_value = 0;
 926     }
 927     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
 928   }
 929 
 930   // Remember the offset of the load. The patching_epilog must be done
 931   // before the call to add_debug_info, otherwise the PcDescs don&#39;t get
 932   // entered in increasing order.
 933   int offset = code_offset();
 934 
 935   assert(disp_reg != Z_R0 || Immediate::is_simm20(disp_value), &quot;should have set this up&quot;);
 936 
 937   bool short_disp = Immediate::is_uimm12(disp_value);
 938 
 939   switch (type) {
 940     case T_BOOLEAN: // fall through
 941     case T_BYTE  :  __ z_lb(dest-&gt;as_register(),   disp_value, disp_reg, src); break;
 942     case T_CHAR  :  __ z_llgh(dest-&gt;as_register(), disp_value, disp_reg, src); break;
 943     case T_SHORT :
 944       if (short_disp) {
 945                     __ z_lh(dest-&gt;as_register(),   disp_value, disp_reg, src);
 946       } else {
 947                     __ z_lhy(dest-&gt;as_register(),  disp_value, disp_reg, src);
 948       }
 949       break;
 950     case T_INT   :
 951       if (short_disp) {
 952                     __ z_l(dest-&gt;as_register(),    disp_value, disp_reg, src);
 953       } else {
 954                     __ z_ly(dest-&gt;as_register(),   disp_value, disp_reg, src);
 955       }
 956       break;
 957     case T_ADDRESS:
 958       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
 959         __ z_llgf(dest-&gt;as_register(), disp_value, disp_reg, src);
 960         __ decode_klass_not_null(dest-&gt;as_register());
 961       } else {
 962         __ z_lg(dest-&gt;as_register(), disp_value, disp_reg, src);
 963       }
 964       break;
 965     case T_ARRAY : // fall through
 966     case T_OBJECT:
 967     {
 968       if (UseCompressedOops &amp;&amp; !wide) {
 969         __ z_llgf(dest-&gt;as_register(), disp_value, disp_reg, src);
 970         __ oop_decoder(dest-&gt;as_register(), dest-&gt;as_register(), true);
 971       } else {
 972         __ z_lg(dest-&gt;as_register(), disp_value, disp_reg, src);
 973       }
<a name="6" id="anc6"></a><span class="line-added"> 974       __ verify_oop(dest-&gt;as_register(), FILE_AND_LINE);</span>
 975       break;
 976     }
 977     case T_FLOAT:
 978       if (short_disp) {
 979                     __ z_le(dest-&gt;as_float_reg(),  disp_value, disp_reg, src);
 980       } else {
 981                     __ z_ley(dest-&gt;as_float_reg(), disp_value, disp_reg, src);
 982       }
 983       break;
 984     case T_DOUBLE:
 985       if (short_disp) {
 986                     __ z_ld(dest-&gt;as_double_reg(),  disp_value, disp_reg, src);
 987       } else {
 988                     __ z_ldy(dest-&gt;as_double_reg(), disp_value, disp_reg, src);
 989       }
 990       break;
 991     case T_LONG  :  __ z_lg(dest-&gt;as_register_lo(), disp_value, disp_reg, src); break;
 992     default      : ShouldNotReachHere();
 993   }
<a name="7" id="anc7"></a>


 994 
 995   if (patch != NULL) {
 996     patching_epilog(patch, patch_code, src, info);
 997   }
 998   if (info != NULL) add_debug_info_for_null_check(offset, info);
 999 }
1000 
1001 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1002   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
1003   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1004 
1005   if (dest-&gt;is_single_cpu()) {
<a name="8" id="anc8"></a><span class="line-modified">1006     if (is_reference_type(type)) {</span>
1007       __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), true);
<a name="9" id="anc9"></a><span class="line-modified">1008       __ verify_oop(dest-&gt;as_register(), FILE_AND_LINE);</span>
<span class="line-modified">1009     } else if (type == T_METADATA || type == T_ADDRESS) {</span>
1010       __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), true);
1011     } else {
1012       __ mem2reg_opt(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()), false);
1013     }
1014   } else if (dest-&gt;is_double_cpu()) {
1015     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1016     __ mem2reg_opt(dest-&gt;as_register_lo(), src_addr_LO, true);
1017   } else if (dest-&gt;is_single_fpu()) {
1018     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1019     __ mem2freg_opt(dest-&gt;as_float_reg(), src_addr, false);
1020   } else if (dest-&gt;is_double_fpu()) {
1021     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1022     __ mem2freg_opt(dest-&gt;as_double_reg(), src_addr, true);
1023   } else {
1024     ShouldNotReachHere();
1025   }
1026 }
1027 
1028 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
1029   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
1030   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
1031 
1032   if (src-&gt;is_single_cpu()) {
1033     const Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
<a name="10" id="anc10"></a><span class="line-modified">1034     if (is_reference_type(type)) {</span>
<span class="line-modified">1035       __ verify_oop(src-&gt;as_register(), FILE_AND_LINE);</span>
1036       __ reg2mem_opt(src-&gt;as_register(), dst, true);
<a name="11" id="anc11"></a><span class="line-modified">1037     } else if (type == T_METADATA || type == T_ADDRESS) {</span>
1038       __ reg2mem_opt(src-&gt;as_register(), dst, true);
1039     } else {
1040       __ reg2mem_opt(src-&gt;as_register(), dst, false);
1041     }
1042   } else if (src-&gt;is_double_cpu()) {
1043     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1044     __ reg2mem_opt(src-&gt;as_register_lo(), dstLO, true);
1045   } else if (src-&gt;is_single_fpu()) {
1046     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1047     __ freg2mem_opt(src-&gt;as_float_reg(), dst_addr, false);
1048   } else if (src-&gt;is_double_fpu()) {
1049     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1050     __ freg2mem_opt(src-&gt;as_double_reg(), dst_addr, true);
1051   } else {
1052     ShouldNotReachHere();
1053   }
1054 }
1055 
1056 void LIR_Assembler::reg2reg(LIR_Opr from_reg, LIR_Opr to_reg) {
1057   if (from_reg-&gt;is_float_kind() &amp;&amp; to_reg-&gt;is_float_kind()) {
1058     if (from_reg-&gt;is_double_fpu()) {
1059       // double to double moves
1060       assert(to_reg-&gt;is_double_fpu(), &quot;should match&quot;);
1061       __ z_ldr(to_reg-&gt;as_double_reg(), from_reg-&gt;as_double_reg());
1062     } else {
1063       // float to float moves
1064       assert(to_reg-&gt;is_single_fpu(), &quot;should match&quot;);
1065       __ z_ler(to_reg-&gt;as_float_reg(), from_reg-&gt;as_float_reg());
1066     }
1067   } else if (!from_reg-&gt;is_float_kind() &amp;&amp; !to_reg-&gt;is_float_kind()) {
1068     if (from_reg-&gt;is_double_cpu()) {
1069       __ z_lgr(to_reg-&gt;as_pointer_register(), from_reg-&gt;as_pointer_register());
1070     } else if (to_reg-&gt;is_double_cpu()) {
1071       // int to int moves
1072       __ z_lgr(to_reg-&gt;as_register_lo(), from_reg-&gt;as_register());
1073     } else {
1074       // int to int moves
1075       __ z_lgr(to_reg-&gt;as_register(), from_reg-&gt;as_register());
1076     }
1077   } else {
1078     ShouldNotReachHere();
1079   }
<a name="12" id="anc12"></a><span class="line-modified">1080   if (is_reference_type(to_reg-&gt;type())) {</span>
<span class="line-modified">1081     __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);</span>
1082   }
1083 }
1084 
1085 void LIR_Assembler::reg2mem(LIR_Opr from, LIR_Opr dest_opr, BasicType type,
1086                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
1087                             bool wide, bool unaligned) {
1088   assert(type != T_METADATA, &quot;store of metadata ptr not supported&quot;);
1089   LIR_Address* addr = dest_opr-&gt;as_address_ptr();
1090 
1091   Register dest = addr-&gt;base()-&gt;as_pointer_register();
1092   Register disp_reg = Z_R0;
1093   int disp_value = addr-&gt;disp();
1094   bool needs_patching = (patch_code != lir_patch_none);
1095 
1096   if (addr-&gt;base()-&gt;is_oop_register()) {
<a name="13" id="anc13"></a><span class="line-modified">1097     __ verify_oop(dest, FILE_AND_LINE);</span>
1098   }
1099 
1100   PatchingStub* patch = NULL;
1101   if (needs_patching) {
1102     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1103     assert(!from-&gt;is_double_cpu() ||
1104            patch_code == lir_patch_none ||
1105            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1106   }
1107 
1108   assert(!needs_patching || (!Immediate::is_simm20(disp_value) &amp;&amp; addr-&gt;index()-&gt;is_illegal()), &quot;assumption&quot;);
1109   if (addr-&gt;index()-&gt;is_illegal()) {
1110     if (!Immediate::is_simm20(disp_value)) {
1111       if (needs_patching) {
1112         __ load_const(Z_R1_scratch, (intptr_t)0);
1113       } else {
1114         __ load_const_optimized(Z_R1_scratch, disp_value);
1115       }
1116       disp_reg = Z_R1_scratch;
1117       disp_value = 0;
1118     }
1119   } else {
1120     if (!Immediate::is_simm20(disp_value)) {
1121       __ load_const_optimized(Z_R1_scratch, disp_value);
1122       __ z_la(Z_R1_scratch, 0, Z_R1_scratch, addr-&gt;index()-&gt;as_register());
1123       disp_reg = Z_R1_scratch;
1124       disp_value = 0;
1125     }
1126     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1127   }
1128 
1129   assert(disp_reg != Z_R0 || Immediate::is_simm20(disp_value), &quot;should have set this up&quot;);
1130 
<a name="14" id="anc14"></a><span class="line-modified">1131   if (is_reference_type(type)) {</span>
<span class="line-modified">1132     __ verify_oop(from-&gt;as_register(), FILE_AND_LINE);</span>
1133   }
1134 
1135   bool short_disp = Immediate::is_uimm12(disp_value);
1136 
1137   // Remember the offset of the store. The patching_epilog must be done
1138   // before the call to add_debug_info_for_null_check, otherwise the PcDescs don&#39;t get
1139   // entered in increasing order.
1140   int offset = code_offset();
1141   switch (type) {
1142     case T_BOOLEAN: // fall through
1143     case T_BYTE  :
1144       if (short_disp) {
1145                     __ z_stc(from-&gt;as_register(),  disp_value, disp_reg, dest);
1146       } else {
1147                     __ z_stcy(from-&gt;as_register(), disp_value, disp_reg, dest);
1148       }
1149       break;
1150     case T_CHAR  : // fall through
1151     case T_SHORT :
1152       if (short_disp) {
1153                     __ z_sth(from-&gt;as_register(),  disp_value, disp_reg, dest);
1154       } else {
1155                     __ z_sthy(from-&gt;as_register(), disp_value, disp_reg, dest);
1156       }
1157       break;
1158     case T_INT   :
1159       if (short_disp) {
1160                     __ z_st(from-&gt;as_register(),  disp_value, disp_reg, dest);
1161       } else {
1162                     __ z_sty(from-&gt;as_register(), disp_value, disp_reg, dest);
1163       }
1164       break;
1165     case T_LONG  :  __ z_stg(from-&gt;as_register_lo(), disp_value, disp_reg, dest); break;
1166     case T_ADDRESS: __ z_stg(from-&gt;as_register(),    disp_value, disp_reg, dest); break;
1167       break;
1168     case T_ARRAY : // fall through
1169     case T_OBJECT:
1170       {
1171         if (UseCompressedOops &amp;&amp; !wide) {
1172           Register compressed_src = Z_R14;
1173           __ oop_encoder(compressed_src, from-&gt;as_register(), true, (disp_reg != Z_R1) ? Z_R1 : Z_R0, -1, true);
1174           offset = code_offset();
1175           if (short_disp) {
1176             __ z_st(compressed_src,  disp_value, disp_reg, dest);
1177           } else {
1178             __ z_sty(compressed_src, disp_value, disp_reg, dest);
1179           }
1180         } else {
1181           __ z_stg(from-&gt;as_register(), disp_value, disp_reg, dest);
1182         }
1183         break;
1184       }
1185     case T_FLOAT :
1186       if (short_disp) {
1187         __ z_ste(from-&gt;as_float_reg(),  disp_value, disp_reg, dest);
1188       } else {
1189         __ z_stey(from-&gt;as_float_reg(), disp_value, disp_reg, dest);
1190       }
1191       break;
1192     case T_DOUBLE:
1193       if (short_disp) {
1194         __ z_std(from-&gt;as_double_reg(),  disp_value, disp_reg, dest);
1195       } else {
1196         __ z_stdy(from-&gt;as_double_reg(), disp_value, disp_reg, dest);
1197       }
1198       break;
1199     default: ShouldNotReachHere();
1200   }
1201 
1202   if (patch != NULL) {
1203     patching_epilog(patch, patch_code, dest, info);
1204   }
1205 
1206   if (info != NULL) add_debug_info_for_null_check(offset, info);
1207 }
1208 
1209 
1210 void LIR_Assembler::return_op(LIR_Opr result) {
1211   assert(result-&gt;is_illegal() ||
1212          (result-&gt;is_single_cpu() &amp;&amp; result-&gt;as_register() == Z_R2) ||
1213          (result-&gt;is_double_cpu() &amp;&amp; result-&gt;as_register_lo() == Z_R2) ||
1214          (result-&gt;is_single_fpu() &amp;&amp; result-&gt;as_float_reg() == Z_F0) ||
1215          (result-&gt;is_double_fpu() &amp;&amp; result-&gt;as_double_reg() == Z_F0), &quot;convention&quot;);
1216 
1217   if (SafepointMechanism::uses_thread_local_poll()) {
1218     __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));
1219   } else {
1220     AddressLiteral pp(os::get_polling_page());
1221     __ load_const_optimized(Z_R1_scratch, pp);
1222   }
1223 
1224   // Pop the frame before the safepoint code.
1225   __ pop_frame_restore_retPC(initial_frame_size_in_bytes());
1226 
1227   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
1228     __ reserved_stack_check(Z_R14);
1229   }
1230 
1231   // We need to mark the code position where the load from the safepoint
1232   // polling page was emitted as relocInfo::poll_return_type here.
1233   __ relocate(relocInfo::poll_return_type);
1234   __ load_from_polling_page(Z_R1_scratch);
1235 
1236   __ z_br(Z_R14); // Return to caller.
1237 }
1238 
1239 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
1240   const Register poll_addr = tmp-&gt;as_register_lo();
1241   if (SafepointMechanism::uses_thread_local_poll()) {
1242     __ z_lg(poll_addr, Address(Z_thread, Thread::polling_page_offset()));
1243   } else {
1244     AddressLiteral pp(os::get_polling_page());
1245     __ load_const_optimized(poll_addr, pp);
1246   }
1247   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
1248   add_debug_info_for_branch(info);
1249   int offset = __ offset();
1250   __ relocate(relocInfo::poll_type);
1251   __ load_from_polling_page(poll_addr);
1252   return offset;
1253 }
1254 
1255 void LIR_Assembler::emit_static_call_stub() {
1256 
1257   // Stub is fixed up when the corresponding call is converted from calling
1258   // compiled code to calling interpreted code.
1259 
1260   address call_pc = __ pc();
1261   address stub = __ start_a_stub(call_stub_size());
1262   if (stub == NULL) {
1263     bailout(&quot;static call stub overflow&quot;);
1264     return;
1265   }
1266 
1267   int start = __ offset();
1268 
1269   __ relocate(static_stub_Relocation::spec(call_pc));
1270 
1271   // See also Matcher::interpreter_method_oop_reg().
1272   AddressLiteral meta = __ allocate_metadata_address(NULL);
1273   bool success = __ load_const_from_toc(Z_method, meta);
1274 
1275   __ set_inst_mark();
1276   AddressLiteral a((address)-1);
1277   success = success &amp;&amp; __ load_const_from_toc(Z_R1, a);
1278   if (!success) {
1279     bailout(&quot;const section overflow&quot;);
1280     return;
1281   }
1282 
1283   __ z_br(Z_R1);
1284   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
1285   __ end_a_stub(); // Update current stubs pointer and restore insts_end.
1286 }
1287 
1288 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1289   bool unsigned_comp = condition == lir_cond_belowEqual || condition == lir_cond_aboveEqual;
1290   if (opr1-&gt;is_single_cpu()) {
1291     Register reg1 = opr1-&gt;as_register();
1292     if (opr2-&gt;is_single_cpu()) {
1293       // cpu register - cpu register
<a name="15" id="anc15"></a><span class="line-modified">1294       if (is_reference_type(opr1-&gt;type())) {</span>
1295         __ z_clgr(reg1, opr2-&gt;as_register());
1296       } else {
<a name="16" id="anc16"></a><span class="line-modified">1297         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);</span>
1298         if (unsigned_comp) {
1299           __ z_clr(reg1, opr2-&gt;as_register());
1300         } else {
1301           __ z_cr(reg1, opr2-&gt;as_register());
1302         }
1303       }
1304     } else if (opr2-&gt;is_stack()) {
1305       // cpu register - stack
<a name="17" id="anc17"></a><span class="line-modified">1306       if (is_reference_type(opr1-&gt;type())) {</span>
1307         __ z_cg(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
1308       } else {
1309         if (unsigned_comp) {
1310           __ z_cly(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
1311         } else {
1312           __ z_cy(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
1313         }
1314       }
1315     } else if (opr2-&gt;is_constant()) {
1316       // cpu register - constant
1317       LIR_Const* c = opr2-&gt;as_constant_ptr();
1318       if (c-&gt;type() == T_INT) {
1319         if (unsigned_comp) {
1320           __ z_clfi(reg1, c-&gt;as_jint());
1321         } else {
1322           __ z_cfi(reg1, c-&gt;as_jint());
1323         }
<a name="18" id="anc18"></a><span class="line-modified">1324       } else if (c-&gt;type() == T_METADATA) {</span>
<span class="line-added">1325         // We only need, for now, comparison with NULL for metadata.</span>
<span class="line-added">1326         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);</span>
<span class="line-added">1327         Metadata* m = c-&gt;as_metadata();</span>
<span class="line-added">1328         if (m == NULL) {</span>
<span class="line-added">1329           __ z_cghi(reg1, 0);</span>
<span class="line-added">1330         } else {</span>
<span class="line-added">1331           ShouldNotReachHere();</span>
<span class="line-added">1332         }</span>
<span class="line-added">1333       } else if (is_reference_type(c-&gt;type())) {</span>
1334         // In 64bit oops are single register.
1335         jobject o = c-&gt;as_jobject();
1336         if (o == NULL) {
1337           __ z_ltgr(reg1, reg1);
1338         } else {
1339           jobject2reg(o, Z_R1_scratch);
1340           __ z_cgr(reg1, Z_R1_scratch);
1341         }
1342       } else {
1343         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
1344       }
1345       // cpu register - address
1346     } else if (opr2-&gt;is_address()) {
1347       if (op-&gt;info() != NULL) {
1348         add_debug_info_for_null_check_here(op-&gt;info());
1349       }
1350       if (unsigned_comp) {
1351         __ z_cly(reg1, as_Address(opr2-&gt;as_address_ptr()));
1352       } else {
1353         __ z_cy(reg1, as_Address(opr2-&gt;as_address_ptr()));
1354       }
1355     } else {
1356       ShouldNotReachHere();
1357     }
1358 
1359   } else if (opr1-&gt;is_double_cpu()) {
1360     assert(!unsigned_comp, &quot;unexpected&quot;);
1361     Register xlo = opr1-&gt;as_register_lo();
1362     Register xhi = opr1-&gt;as_register_hi();
1363     if (opr2-&gt;is_double_cpu()) {
1364       __ z_cgr(xlo, opr2-&gt;as_register_lo());
1365     } else if (opr2-&gt;is_constant()) {
1366       // cpu register - constant 0
1367       assert(opr2-&gt;as_jlong() == (jlong)0, &quot;only handles zero&quot;);
1368       __ z_ltgr(xlo, xlo);
1369     } else {
1370       ShouldNotReachHere();
1371     }
1372 
1373   } else if (opr1-&gt;is_single_fpu()) {
1374     if (opr2-&gt;is_single_fpu()) {
1375       __ z_cebr(opr1-&gt;as_float_reg(), opr2-&gt;as_float_reg());
1376     } else {
1377       // stack slot
1378       Address addr = frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix());
1379       if (Immediate::is_uimm12(addr.disp())) {
1380         __ z_ceb(opr1-&gt;as_float_reg(), addr);
1381       } else {
1382         __ z_ley(Z_fscratch_1, addr);
1383         __ z_cebr(opr1-&gt;as_float_reg(), Z_fscratch_1);
1384       }
1385     }
1386   } else if (opr1-&gt;is_double_fpu()) {
1387     if (opr2-&gt;is_double_fpu()) {
1388     __ z_cdbr(opr1-&gt;as_double_reg(), opr2-&gt;as_double_reg());
1389     } else {
1390       // stack slot
1391       Address addr = frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix());
1392       if (Immediate::is_uimm12(addr.disp())) {
1393         __ z_cdb(opr1-&gt;as_double_reg(), addr);
1394       } else {
1395         __ z_ldy(Z_fscratch_1, addr);
1396         __ z_cdbr(opr1-&gt;as_double_reg(), Z_fscratch_1);
1397       }
1398     }
1399   } else {
1400     ShouldNotReachHere();
1401   }
1402 }
1403 
1404 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op) {
1405   Label    done;
1406   Register dreg = dst-&gt;as_register();
1407 
1408   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
1409     assert((left-&gt;is_single_fpu() &amp;&amp; right-&gt;is_single_fpu()) ||
1410            (left-&gt;is_double_fpu() &amp;&amp; right-&gt;is_double_fpu()), &quot;unexpected operand types&quot;);
1411     bool is_single = left-&gt;is_single_fpu();
1412     bool is_unordered_less = (code == lir_ucmp_fd2i);
1413     FloatRegister lreg = is_single ? left-&gt;as_float_reg() : left-&gt;as_double_reg();
1414     FloatRegister rreg = is_single ? right-&gt;as_float_reg() : right-&gt;as_double_reg();
1415     if (is_single) {
1416       __ z_cebr(lreg, rreg);
1417     } else {
1418       __ z_cdbr(lreg, rreg);
1419     }
1420     if (VM_Version::has_LoadStoreConditional()) {
1421       Register one       = Z_R0_scratch;
1422       Register minus_one = Z_R1_scratch;
1423       __ z_lghi(minus_one, -1);
1424       __ z_lghi(one,  1);
1425       __ z_lghi(dreg, 0);
1426       __ z_locgr(dreg, one,       is_unordered_less ? Assembler::bcondHigh            : Assembler::bcondHighOrNotOrdered);
1427       __ z_locgr(dreg, minus_one, is_unordered_less ? Assembler::bcondLowOrNotOrdered : Assembler::bcondLow);
1428     } else {
1429       __ clear_reg(dreg, true, false);
1430       __ z_bre(done); // if (left == right) dst = 0
1431 
1432       // if (left &gt; right || ((code ~= cmpg) &amp;&amp; (left &lt;&gt; right)) dst := 1
1433       __ z_lhi(dreg, 1);
1434       __ z_brc(is_unordered_less ? Assembler::bcondHigh : Assembler::bcondHighOrNotOrdered, done);
1435 
1436       // if (left &lt; right || ((code ~= cmpl) &amp;&amp; (left &lt;&gt; right)) dst := -1
1437       __ z_lhi(dreg, -1);
1438     }
1439   } else {
1440     assert(code == lir_cmp_l2i, &quot;check&quot;);
1441     if (VM_Version::has_LoadStoreConditional()) {
1442       Register one       = Z_R0_scratch;
1443       Register minus_one = Z_R1_scratch;
1444       __ z_cgr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
1445       __ z_lghi(minus_one, -1);
1446       __ z_lghi(one,  1);
1447       __ z_lghi(dreg, 0);
1448       __ z_locgr(dreg, one, Assembler::bcondHigh);
1449       __ z_locgr(dreg, minus_one, Assembler::bcondLow);
1450     } else {
1451       __ z_cgr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
1452       __ z_lghi(dreg,  0);     // eq value
1453       __ z_bre(done);
1454       __ z_lghi(dreg,  1);     // gt value
1455       __ z_brh(done);
1456       __ z_lghi(dreg, -1);     // lt value
1457     }
1458   }
1459   __ bind(done);
1460 }
1461 
1462 // result = condition ? opr1 : opr2
1463 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1464   Assembler::branch_condition acond = Assembler::bcondEqual, ncond = Assembler::bcondNotEqual;
1465   switch (condition) {
1466     case lir_cond_equal:        acond = Assembler::bcondEqual;    ncond = Assembler::bcondNotEqual; break;
1467     case lir_cond_notEqual:     acond = Assembler::bcondNotEqual; ncond = Assembler::bcondEqual;    break;
1468     case lir_cond_less:         acond = Assembler::bcondLow;      ncond = Assembler::bcondNotLow;   break;
1469     case lir_cond_lessEqual:    acond = Assembler::bcondNotHigh;  ncond = Assembler::bcondHigh;     break;
1470     case lir_cond_greaterEqual: acond = Assembler::bcondNotLow;   ncond = Assembler::bcondLow;      break;
1471     case lir_cond_greater:      acond = Assembler::bcondHigh;     ncond = Assembler::bcondNotHigh;  break;
1472     case lir_cond_belowEqual:   acond = Assembler::bcondNotHigh;  ncond = Assembler::bcondHigh;     break;
1473     case lir_cond_aboveEqual:   acond = Assembler::bcondNotLow;   ncond = Assembler::bcondLow;      break;
1474     default:                    ShouldNotReachHere();
1475   }
1476 
1477   if (opr1-&gt;is_cpu_register()) {
1478     reg2reg(opr1, result);
1479   } else if (opr1-&gt;is_stack()) {
1480     stack2reg(opr1, result, result-&gt;type());
1481   } else if (opr1-&gt;is_constant()) {
1482     const2reg(opr1, result, lir_patch_none, NULL);
1483   } else {
1484     ShouldNotReachHere();
1485   }
1486 
1487   if (VM_Version::has_LoadStoreConditional() &amp;&amp; !opr2-&gt;is_constant()) {
1488     // Optimized version that does not require a branch.
1489     if (opr2-&gt;is_single_cpu()) {
1490       assert(opr2-&gt;cpu_regnr() != result-&gt;cpu_regnr(), &quot;opr2 already overwritten by previous move&quot;);
1491       __ z_locgr(result-&gt;as_register(), opr2-&gt;as_register(), ncond);
1492     } else if (opr2-&gt;is_double_cpu()) {
1493       assert(opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
1494       assert(opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
1495       __ z_locgr(result-&gt;as_register_lo(), opr2-&gt;as_register_lo(), ncond);
1496     } else if (opr2-&gt;is_single_stack()) {
1497       __ z_loc(result-&gt;as_register(), frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()), ncond);
1498     } else if (opr2-&gt;is_double_stack()) {
1499       __ z_locg(result-&gt;as_register_lo(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix()), ncond);
1500     } else {
1501       ShouldNotReachHere();
1502     }
1503   } else {
1504     Label skip;
1505     __ z_brc(acond, skip);
1506     if (opr2-&gt;is_cpu_register()) {
1507       reg2reg(opr2, result);
1508     } else if (opr2-&gt;is_stack()) {
1509       stack2reg(opr2, result, result-&gt;type());
1510     } else if (opr2-&gt;is_constant()) {
1511       const2reg(opr2, result, lir_patch_none, NULL);
1512     } else {
1513       ShouldNotReachHere();
1514     }
1515     __ bind(skip);
1516   }
1517 }
1518 
1519 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest,
1520                              CodeEmitInfo* info, bool pop_fpu_stack) {
1521   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
1522 
1523   if (left-&gt;is_single_cpu()) {
1524     assert(left == dest, &quot;left and dest must be equal&quot;);
1525     Register lreg = left-&gt;as_register();
1526 
1527     if (right-&gt;is_single_cpu()) {
1528       // cpu register - cpu register
1529       Register rreg = right-&gt;as_register();
1530       switch (code) {
1531         case lir_add: __ z_ar (lreg, rreg); break;
1532         case lir_sub: __ z_sr (lreg, rreg); break;
1533         case lir_mul: __ z_msr(lreg, rreg); break;
1534         default: ShouldNotReachHere();
1535       }
1536 
1537     } else if (right-&gt;is_stack()) {
1538       // cpu register - stack
1539       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
1540       switch (code) {
1541         case lir_add: __ z_ay(lreg, raddr); break;
1542         case lir_sub: __ z_sy(lreg, raddr); break;
1543         default: ShouldNotReachHere();
1544       }
1545 
1546     } else if (right-&gt;is_constant()) {
1547       // cpu register - constant
1548       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
1549       switch (code) {
1550         case lir_add: __ z_agfi(lreg, c);  break;
1551         case lir_sub: __ z_agfi(lreg, -c); break; // note: -min_jint == min_jint
1552         case lir_mul: __ z_msfi(lreg, c);  break;
1553         default: ShouldNotReachHere();
1554       }
1555 
1556     } else {
1557       ShouldNotReachHere();
1558     }
1559 
1560   } else if (left-&gt;is_double_cpu()) {
1561     assert(left == dest, &quot;left and dest must be equal&quot;);
1562     Register lreg_lo = left-&gt;as_register_lo();
1563     Register lreg_hi = left-&gt;as_register_hi();
1564 
1565     if (right-&gt;is_double_cpu()) {
1566       // cpu register - cpu register
1567       Register rreg_lo = right-&gt;as_register_lo();
1568       Register rreg_hi = right-&gt;as_register_hi();
1569       assert_different_registers(lreg_lo, rreg_lo);
1570       switch (code) {
1571         case lir_add:
1572           __ z_agr(lreg_lo, rreg_lo);
1573           break;
1574         case lir_sub:
1575           __ z_sgr(lreg_lo, rreg_lo);
1576           break;
1577         case lir_mul:
1578           __ z_msgr(lreg_lo, rreg_lo);
1579           break;
1580         default:
1581           ShouldNotReachHere();
1582       }
1583 
1584     } else if (right-&gt;is_constant()) {
1585       // cpu register - constant
1586       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong_bits();
1587       switch (code) {
1588         case lir_add: __ z_agfi(lreg_lo, c); break;
1589         case lir_sub:
1590           if (c != min_jint) {
1591                       __ z_agfi(lreg_lo, -c);
1592           } else {
1593             // -min_jint cannot be represented as simm32 in z_agfi
1594             // min_jint sign extended:      0xffffffff80000000
1595             // -min_jint as 64 bit integer: 0x0000000080000000
1596             // 0x80000000 can be represented as uimm32 in z_algfi
1597             // lreg_lo := lreg_lo + -min_jint == lreg_lo + 0x80000000
1598                       __ z_algfi(lreg_lo, UCONST64(0x80000000));
1599           }
1600           break;
1601         case lir_mul: __ z_msgfi(lreg_lo, c); break;
1602         default:
1603           ShouldNotReachHere();
1604       }
1605 
1606     } else {
1607       ShouldNotReachHere();
1608     }
1609 
1610   } else if (left-&gt;is_single_fpu()) {
1611     assert(left == dest, &quot;left and dest must be equal&quot;);
1612     FloatRegister lreg = left-&gt;as_float_reg();
1613     FloatRegister rreg = right-&gt;is_single_fpu() ? right-&gt;as_float_reg() : fnoreg;
1614     Address raddr;
1615 
1616     if (rreg == fnoreg) {
1617       assert(right-&gt;is_single_stack(), &quot;constants should be loaded into register&quot;);
1618       raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
1619       if (!Immediate::is_uimm12(raddr.disp())) {
1620         __ mem2freg_opt(rreg = Z_fscratch_1, raddr, false);
1621       }
1622     }
1623 
1624     if (rreg != fnoreg) {
1625       switch (code) {
1626         case lir_add: __ z_aebr(lreg, rreg);  break;
1627         case lir_sub: __ z_sebr(lreg, rreg);  break;
1628         case lir_mul_strictfp: // fall through
1629         case lir_mul: __ z_meebr(lreg, rreg); break;
1630         case lir_div_strictfp: // fall through
1631         case lir_div: __ z_debr(lreg, rreg);  break;
1632         default: ShouldNotReachHere();
1633       }
1634     } else {
1635       switch (code) {
1636         case lir_add: __ z_aeb(lreg, raddr);  break;
1637         case lir_sub: __ z_seb(lreg, raddr);  break;
1638         case lir_mul_strictfp: // fall through
1639         case lir_mul: __ z_meeb(lreg, raddr);  break;
1640         case lir_div_strictfp: // fall through
1641         case lir_div: __ z_deb(lreg, raddr);  break;
1642         default: ShouldNotReachHere();
1643       }
1644     }
1645   } else if (left-&gt;is_double_fpu()) {
1646     assert(left == dest, &quot;left and dest must be equal&quot;);
1647     FloatRegister lreg = left-&gt;as_double_reg();
1648     FloatRegister rreg = right-&gt;is_double_fpu() ? right-&gt;as_double_reg() : fnoreg;
1649     Address raddr;
1650 
1651     if (rreg == fnoreg) {
1652       assert(right-&gt;is_double_stack(), &quot;constants should be loaded into register&quot;);
1653       raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
1654       if (!Immediate::is_uimm12(raddr.disp())) {
1655         __ mem2freg_opt(rreg = Z_fscratch_1, raddr, true);
1656       }
1657     }
1658 
1659     if (rreg != fnoreg) {
1660       switch (code) {
1661         case lir_add: __ z_adbr(lreg, rreg); break;
1662         case lir_sub: __ z_sdbr(lreg, rreg); break;
1663         case lir_mul_strictfp: // fall through
1664         case lir_mul: __ z_mdbr(lreg, rreg); break;
1665         case lir_div_strictfp: // fall through
1666         case lir_div: __ z_ddbr(lreg, rreg); break;
1667         default: ShouldNotReachHere();
1668       }
1669     } else {
1670       switch (code) {
1671         case lir_add: __ z_adb(lreg, raddr); break;
1672         case lir_sub: __ z_sdb(lreg, raddr); break;
1673         case lir_mul_strictfp: // fall through
1674         case lir_mul: __ z_mdb(lreg, raddr); break;
1675         case lir_div_strictfp: // fall through
1676         case lir_div: __ z_ddb(lreg, raddr); break;
1677         default: ShouldNotReachHere();
1678       }
1679     }
1680   } else if (left-&gt;is_address()) {
1681     assert(left == dest, &quot;left and dest must be equal&quot;);
1682     assert(code == lir_add, &quot;unsupported operation&quot;);
1683     assert(right-&gt;is_constant(), &quot;unsupported operand&quot;);
1684     jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
1685     LIR_Address* lir_addr = left-&gt;as_address_ptr();
1686     Address addr = as_Address(lir_addr);
1687     switch (lir_addr-&gt;type()) {
1688       case T_INT:
1689         __ add2mem_32(addr, c, Z_R1_scratch);
1690         break;
1691       case T_LONG:
1692         __ add2mem_64(addr, c, Z_R1_scratch);
1693         break;
1694       default:
1695         ShouldNotReachHere();
1696     }
1697   } else {
1698     ShouldNotReachHere();
1699   }
1700 }
1701 
<a name="19" id="anc19"></a>



1702 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
1703   switch (code) {
1704     case lir_sqrt: {
1705       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for dsqrt&quot;);
1706       FloatRegister src_reg = value-&gt;as_double_reg();
1707       FloatRegister dst_reg = dest-&gt;as_double_reg();
1708       __ z_sqdbr(dst_reg, src_reg);
1709       break;
1710     }
1711     case lir_abs: {
1712       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for fabs&quot;);
1713       FloatRegister src_reg = value-&gt;as_double_reg();
1714       FloatRegister dst_reg = dest-&gt;as_double_reg();
1715       __ z_lpdbr(dst_reg, src_reg);
1716       break;
1717     }
1718     default: {
1719       ShouldNotReachHere();
1720       break;
1721     }
1722   }
1723 }
1724 
1725 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
1726   if (left-&gt;is_single_cpu()) {
1727     Register reg = left-&gt;as_register();
1728     if (right-&gt;is_constant()) {
1729       int val = right-&gt;as_constant_ptr()-&gt;as_jint();
1730       switch (code) {
1731         case lir_logic_and: __ z_nilf(reg, val); break;
1732         case lir_logic_or:  __ z_oilf(reg, val); break;
1733         case lir_logic_xor: __ z_xilf(reg, val); break;
1734         default: ShouldNotReachHere();
1735       }
1736     } else if (right-&gt;is_stack()) {
1737       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
1738       switch (code) {
1739         case lir_logic_and: __ z_ny(reg, raddr); break;
1740         case lir_logic_or:  __ z_oy(reg, raddr); break;
1741         case lir_logic_xor: __ z_xy(reg, raddr); break;
1742         default: ShouldNotReachHere();
1743       }
1744     } else {
1745       Register rright = right-&gt;as_register();
1746       switch (code) {
1747         case lir_logic_and: __ z_nr(reg, rright); break;
1748         case lir_logic_or : __ z_or(reg, rright); break;
1749         case lir_logic_xor: __ z_xr(reg, rright); break;
1750         default: ShouldNotReachHere();
1751       }
1752     }
1753     move_regs(reg, dst-&gt;as_register());
1754   } else {
1755     Register l_lo = left-&gt;as_register_lo();
1756     if (right-&gt;is_constant()) {
1757       __ load_const_optimized(Z_R1_scratch, right-&gt;as_constant_ptr()-&gt;as_jlong());
1758       switch (code) {
1759         case lir_logic_and:
1760           __ z_ngr(l_lo, Z_R1_scratch);
1761           break;
1762         case lir_logic_or:
1763           __ z_ogr(l_lo, Z_R1_scratch);
1764           break;
1765         case lir_logic_xor:
1766           __ z_xgr(l_lo, Z_R1_scratch);
1767           break;
1768         default: ShouldNotReachHere();
1769       }
1770     } else {
1771       Register r_lo;
<a name="20" id="anc20"></a><span class="line-modified">1772       if (is_reference_type(right-&gt;type())) {</span>
1773         r_lo = right-&gt;as_register();
1774       } else {
1775         r_lo = right-&gt;as_register_lo();
1776       }
1777       switch (code) {
1778         case lir_logic_and:
1779           __ z_ngr(l_lo, r_lo);
1780           break;
1781         case lir_logic_or:
1782           __ z_ogr(l_lo, r_lo);
1783           break;
1784         case lir_logic_xor:
1785           __ z_xgr(l_lo, r_lo);
1786           break;
1787         default: ShouldNotReachHere();
1788       }
1789     }
1790 
1791     Register dst_lo = dst-&gt;as_register_lo();
1792 
1793     move_regs(l_lo, dst_lo);
1794   }
1795 }
1796 
1797 // See operand selection in LIRGenerator::do_ArithmeticOp_Int().
1798 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
1799   if (left-&gt;is_double_cpu()) {
1800     // 64 bit integer case
1801     assert(left-&gt;is_double_cpu(), &quot;left must be register&quot;);
<a name="21" id="anc21"></a><span class="line-modified">1802     assert(right-&gt;is_double_cpu() || is_power_of_2(right-&gt;as_jlong()),</span>
1803            &quot;right must be register or power of 2 constant&quot;);
1804     assert(result-&gt;is_double_cpu(), &quot;result must be register&quot;);
1805 
1806     Register lreg = left-&gt;as_register_lo();
1807     Register dreg = result-&gt;as_register_lo();
1808 
1809     if (right-&gt;is_constant()) {
1810       // Convert division by a power of two into some shifts and logical operations.
1811       Register treg1 = Z_R0_scratch;
1812       Register treg2 = Z_R1_scratch;
1813       jlong divisor = right-&gt;as_jlong();
1814       jlong log_divisor = log2_long(right-&gt;as_jlong());
1815 
1816       if (divisor == min_jlong) {
1817         // Min_jlong is special. Result is &#39;0&#39; except for min_jlong/min_jlong = 1.
1818         if (dreg == lreg) {
1819           NearLabel done;
1820           __ load_const_optimized(treg2, min_jlong);
1821           __ z_cgr(lreg, treg2);
1822           __ z_lghi(dreg, 0);           // Preserves condition code.
1823           __ z_brne(done);
1824           __ z_lghi(dreg, 1);           // min_jlong / min_jlong = 1
1825           __ bind(done);
1826         } else {
1827           assert_different_registers(dreg, lreg);
1828           NearLabel done;
1829           __ z_lghi(dreg, 0);
1830           __ compare64_and_branch(lreg, min_jlong, Assembler::bcondNotEqual, done);
1831           __ z_lghi(dreg, 1);
1832           __ bind(done);
1833         }
1834         return;
1835       }
1836       __ move_reg_if_needed(dreg, T_LONG, lreg, T_LONG);
1837       if (divisor == 2) {
1838         __ z_srlg(treg2, dreg, 63);     // dividend &lt; 0 ? 1 : 0
1839       } else {
1840         __ z_srag(treg2, dreg, 63);     // dividend &lt; 0 ? -1 : 0
1841         __ and_imm(treg2, divisor - 1, treg1, true);
1842       }
1843       if (code == lir_idiv) {
1844         __ z_agr(dreg, treg2);
1845         __ z_srag(dreg, dreg, log_divisor);
1846       } else {
1847         assert(code == lir_irem, &quot;check&quot;);
1848         __ z_agr(treg2, dreg);
1849         __ and_imm(treg2, ~(divisor - 1), treg1, true);
1850         __ z_sgr(dreg, treg2);
1851       }
1852       return;
1853     }
1854 
1855     // Divisor is not a power of 2 constant.
1856     Register rreg = right-&gt;as_register_lo();
1857     Register treg = temp-&gt;as_register_lo();
1858     assert(right-&gt;is_double_cpu(), &quot;right must be register&quot;);
1859     assert(lreg == Z_R11, &quot;see ldivInOpr()&quot;);
1860     assert(rreg != lreg, &quot;right register must not be same as left register&quot;);
1861     assert((code == lir_idiv &amp;&amp; dreg == Z_R11 &amp;&amp; treg == Z_R10) ||
1862            (code == lir_irem &amp;&amp; dreg == Z_R10 &amp;&amp; treg == Z_R11), &quot;see ldivInOpr(), ldivOutOpr(), lremOutOpr()&quot;);
1863 
1864     Register R1 = lreg-&gt;predecessor();
1865     Register R2 = rreg;
1866     assert(code != lir_idiv || lreg==dreg, &quot;see code below&quot;);
1867     if (code == lir_idiv) {
1868       __ z_lcgr(lreg, lreg);
1869     } else {
1870       __ clear_reg(dreg, true, false);
1871     }
1872     NearLabel done;
1873     __ compare64_and_branch(R2, -1, Assembler::bcondEqual, done);
1874     if (code == lir_idiv) {
1875       __ z_lcgr(lreg, lreg); // Revert lcgr above.
1876     }
1877     if (ImplicitDiv0Checks) {
1878       // No debug info because the idiv won&#39;t trap.
1879       // Add_debug_info_for_div0 would instantiate another DivByZeroStub,
1880       // which is unnecessary, too.
1881       add_debug_info_for_div0(__ offset(), info);
1882     }
1883     __ z_dsgr(R1, R2);
1884     __ bind(done);
1885     return;
1886   }
1887 
1888   // 32 bit integer case
1889 
1890   assert(left-&gt;is_single_cpu(), &quot;left must be register&quot;);
1891   assert(right-&gt;is_single_cpu() || is_power_of_2(right-&gt;as_jint()), &quot;right must be register or power of 2 constant&quot;);
1892   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
1893 
1894   Register lreg = left-&gt;as_register();
1895   Register dreg = result-&gt;as_register();
1896 
1897   if (right-&gt;is_constant()) {
1898     // Convert division by a power of two into some shifts and logical operations.
1899     Register treg1 = Z_R0_scratch;
1900     Register treg2 = Z_R1_scratch;
1901     jlong divisor = right-&gt;as_jint();
1902     jlong log_divisor = log2_long(right-&gt;as_jint());
1903     __ move_reg_if_needed(dreg, T_LONG, lreg, T_INT); // sign extend
1904     if (divisor == 2) {
1905       __ z_srlg(treg2, dreg, 63);     // dividend &lt; 0 ?  1 : 0
1906     } else {
1907       __ z_srag(treg2, dreg, 63);     // dividend &lt; 0 ? -1 : 0
1908       __ and_imm(treg2, divisor - 1, treg1, true);
1909     }
1910     if (code == lir_idiv) {
1911       __ z_agr(dreg, treg2);
1912       __ z_srag(dreg, dreg, log_divisor);
1913     } else {
1914       assert(code == lir_irem, &quot;check&quot;);
1915       __ z_agr(treg2, dreg);
1916       __ and_imm(treg2, ~(divisor - 1), treg1, true);
1917       __ z_sgr(dreg, treg2);
1918     }
1919     return;
1920   }
1921 
1922   // Divisor is not a power of 2 constant.
1923   Register rreg = right-&gt;as_register();
1924   Register treg = temp-&gt;as_register();
1925   assert(right-&gt;is_single_cpu(), &quot;right must be register&quot;);
1926   assert(lreg == Z_R11, &quot;left register must be rax,&quot;);
1927   assert(rreg != lreg, &quot;right register must not be same as left register&quot;);
1928   assert((code == lir_idiv &amp;&amp; dreg == Z_R11 &amp;&amp; treg == Z_R10)
1929       || (code == lir_irem &amp;&amp; dreg == Z_R10 &amp;&amp; treg == Z_R11), &quot;see divInOpr(), divOutOpr(), remOutOpr()&quot;);
1930 
1931   Register R1 = lreg-&gt;predecessor();
1932   Register R2 = rreg;
1933   __ move_reg_if_needed(lreg, T_LONG, lreg, T_INT); // sign extend
1934   if (ImplicitDiv0Checks) {
1935     // No debug info because the idiv won&#39;t trap.
1936     // Add_debug_info_for_div0 would instantiate another DivByZeroStub,
1937     // which is unnecessary, too.
1938     add_debug_info_for_div0(__ offset(), info);
1939   }
1940   __ z_dsgfr(R1, R2);
1941 }
1942 
1943 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
1944   assert(exceptionOop-&gt;as_register() == Z_EXC_OOP, &quot;should match&quot;);
1945   assert(exceptionPC-&gt;as_register() == Z_EXC_PC, &quot;should match&quot;);
1946 
1947   // Exception object is not added to oop map by LinearScan
1948   // (LinearScan assumes that no oops are in fixed registers).
1949   info-&gt;add_register_oop(exceptionOop);
1950 
1951   // Reuse the debug info from the safepoint poll for the throw op itself.
1952   __ get_PC(Z_EXC_PC);
1953   add_call_info(__ offset(), info); // for exception handler
1954   address stub = Runtime1::entry_for (compilation()-&gt;has_fpu_code() ? Runtime1::handle_exception_id
1955                                                                     : Runtime1::handle_exception_nofpu_id);
1956   emit_call_c(stub);
1957 }
1958 
1959 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
1960   assert(exceptionOop-&gt;as_register() == Z_EXC_OOP, &quot;should match&quot;);
1961 
1962   __ branch_optimized(Assembler::bcondAlways, _unwind_handler_entry);
1963 }
1964 
1965 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
1966   ciArrayKlass* default_type = op-&gt;expected_type();
1967   Register src = op-&gt;src()-&gt;as_register();
1968   Register dst = op-&gt;dst()-&gt;as_register();
1969   Register src_pos = op-&gt;src_pos()-&gt;as_register();
1970   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
1971   Register length  = op-&gt;length()-&gt;as_register();
1972   Register tmp = op-&gt;tmp()-&gt;as_register();
1973 
1974   CodeStub* stub = op-&gt;stub();
1975   int flags = op-&gt;flags();
1976   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
1977   if (basic_type == T_ARRAY) basic_type = T_OBJECT;
1978 
1979   // If we don&#39;t know anything, just go through the generic arraycopy.
1980   if (default_type == NULL) {
1981     address copyfunc_addr = StubRoutines::generic_arraycopy();
1982 
1983     if (copyfunc_addr == NULL) {
1984       // Take a slow path for generic arraycopy.
1985       __ branch_optimized(Assembler::bcondAlways, *stub-&gt;entry());
1986       __ bind(*stub-&gt;continuation());
1987       return;
1988     }
1989 
<a name="22" id="anc22"></a>
1990     // Save outgoing arguments in callee saved registers (C convention) in case
1991     // a call to System.arraycopy is needed.
1992     Register callee_saved_src     = Z_R10;
1993     Register callee_saved_src_pos = Z_R11;
1994     Register callee_saved_dst     = Z_R12;
1995     Register callee_saved_dst_pos = Z_R13;
1996     Register callee_saved_length  = Z_ARG5; // Z_ARG5 == Z_R6 is callee saved.
1997 
1998     __ lgr_if_needed(callee_saved_src, src);
1999     __ lgr_if_needed(callee_saved_src_pos, src_pos);
2000     __ lgr_if_needed(callee_saved_dst, dst);
2001     __ lgr_if_needed(callee_saved_dst_pos, dst_pos);
2002     __ lgr_if_needed(callee_saved_length, length);
2003 
2004     // C function requires 64 bit values.
2005     __ z_lgfr(src_pos, src_pos);
2006     __ z_lgfr(dst_pos, dst_pos);
2007     __ z_lgfr(length, length);
2008 
2009     // Pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint.
2010 
2011     // The arguments are in the corresponding registers.
2012     assert(Z_ARG1 == src,     &quot;assumption&quot;);
2013     assert(Z_ARG2 == src_pos, &quot;assumption&quot;);
2014     assert(Z_ARG3 == dst,     &quot;assumption&quot;);
2015     assert(Z_ARG4 == dst_pos, &quot;assumption&quot;);
2016     assert(Z_ARG5 == length,  &quot;assumption&quot;);
2017 #ifndef PRODUCT
2018     if (PrintC1Statistics) {
2019       __ load_const_optimized(Z_R1_scratch, (address)&amp;Runtime1::_generic_arraycopystub_cnt);
2020       __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);
2021     }
2022 #endif
2023     emit_call_c(copyfunc_addr);
2024     CHECK_BAILOUT();
2025 
2026     __ compare32_and_branch(Z_RET, (intptr_t)0, Assembler::bcondEqual, *stub-&gt;continuation());
2027 
2028     __ z_lgr(tmp, Z_RET);
2029     __ z_xilf(tmp, -1);
2030 
2031     // Restore values from callee saved registers so they are where the stub
2032     // expects them.
2033     __ lgr_if_needed(src, callee_saved_src);
2034     __ lgr_if_needed(src_pos, callee_saved_src_pos);
2035     __ lgr_if_needed(dst, callee_saved_dst);
2036     __ lgr_if_needed(dst_pos, callee_saved_dst_pos);
2037     __ lgr_if_needed(length, callee_saved_length);
2038 
2039     __ z_sr(length, tmp);
2040     __ z_ar(src_pos, tmp);
2041     __ z_ar(dst_pos, tmp);
2042     __ branch_optimized(Assembler::bcondAlways, *stub-&gt;entry());
2043 
2044     __ bind(*stub-&gt;continuation());
2045     return;
2046   }
2047 
2048   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
2049 
2050   int elem_size = type2aelembytes(basic_type);
2051   int shift_amount;
2052 
2053   switch (elem_size) {
2054     case 1 :
2055       shift_amount = 0;
2056       break;
2057     case 2 :
2058       shift_amount = 1;
2059       break;
2060     case 4 :
2061       shift_amount = 2;
2062       break;
2063     case 8 :
2064       shift_amount = 3;
2065       break;
2066     default:
2067       shift_amount = -1;
2068       ShouldNotReachHere();
2069   }
2070 
2071   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
2072   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
2073   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
2074   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
2075 
2076   // Length and pos&#39;s are all sign extended at this point on 64bit.
2077 
2078   // test for NULL
2079   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
2080     __ compareU64_and_branch(src, (intptr_t)0, Assembler::bcondZero, *stub-&gt;entry());
2081   }
2082   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
2083     __ compareU64_and_branch(dst, (intptr_t)0, Assembler::bcondZero, *stub-&gt;entry());
2084   }
2085 
2086   // Check if negative.
2087   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
2088     __ compare32_and_branch(src_pos, (intptr_t)0, Assembler::bcondLow, *stub-&gt;entry());
2089   }
2090   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
2091     __ compare32_and_branch(dst_pos, (intptr_t)0, Assembler::bcondLow, *stub-&gt;entry());
2092   }
2093 
2094   // If the compiler was not able to prove that exact type of the source or the destination
2095   // of the arraycopy is an array type, check at runtime if the source or the destination is
2096   // an instance type.
2097   if (flags &amp; LIR_OpArrayCopy::type_check) {
2098     assert(Klass::_lh_neutral_value == 0, &quot;or replace z_lt instructions&quot;);
2099 
2100     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2101       __ load_klass(tmp, dst);
2102       __ z_lt(tmp, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2103       __ branch_optimized(Assembler::bcondNotLow, *stub-&gt;entry());
2104     }
2105 
2106     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2107       __ load_klass(tmp, src);
2108       __ z_lt(tmp, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2109       __ branch_optimized(Assembler::bcondNotLow, *stub-&gt;entry());
2110     }
2111   }
2112 
2113   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
2114     __ z_la(tmp, Address(src_pos, length));
2115     __ z_cl(tmp, src_length_addr);
2116     __ branch_optimized(Assembler::bcondHigh, *stub-&gt;entry());
2117   }
2118   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
2119     __ z_la(tmp, Address(dst_pos, length));
2120     __ z_cl(tmp, dst_length_addr);
2121     __ branch_optimized(Assembler::bcondHigh, *stub-&gt;entry());
2122   }
2123 
2124   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
2125     __ z_ltr(length, length);
2126     __ branch_optimized(Assembler::bcondNegative, *stub-&gt;entry());
2127   }
2128 
2129   // Stubs require 64 bit values.
2130   __ z_lgfr(src_pos, src_pos); // int -&gt; long
2131   __ z_lgfr(dst_pos, dst_pos); // int -&gt; long
2132   __ z_lgfr(length, length);   // int -&gt; long
2133 
2134   if (flags &amp; LIR_OpArrayCopy::type_check) {
2135     // We don&#39;t know the array types are compatible.
2136     if (basic_type != T_OBJECT) {
2137       // Simple test for basic type arrays.
2138       if (UseCompressedClassPointers) {
2139         __ z_l(tmp, src_klass_addr);
2140         __ z_c(tmp, dst_klass_addr);
2141       } else {
2142         __ z_lg(tmp, src_klass_addr);
2143         __ z_cg(tmp, dst_klass_addr);
2144       }
2145       __ branch_optimized(Assembler::bcondNotEqual, *stub-&gt;entry());
2146     } else {
2147       // For object arrays, if src is a sub class of dst then we can
2148       // safely do the copy.
2149       NearLabel cont, slow;
2150       Register src_klass = Z_R1_scratch;
2151       Register dst_klass = Z_R10;
2152 
2153       __ load_klass(src_klass, src);
2154       __ load_klass(dst_klass, dst);
2155 
2156       __ check_klass_subtype_fast_path(src_klass, dst_klass, tmp, &amp;cont, &amp;slow, NULL);
2157 
2158       store_parameter(src_klass, 0); // sub
2159       store_parameter(dst_klass, 1); // super
2160       emit_call_c(Runtime1::entry_for (Runtime1::slow_subtype_check_id));
<a name="23" id="anc23"></a><span class="line-modified">2161       CHECK_BAILOUT2(cont, slow);</span>
2162       // Sets condition code 0 for match (2 otherwise).
2163       __ branch_optimized(Assembler::bcondEqual, cont);
2164 
2165       __ bind(slow);
2166 
2167       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2168       if (copyfunc_addr != NULL) { // use stub if available
2169         // Src is not a sub class of dst so we have to do a
2170         // per-element check.
2171 
2172         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2173         if ((flags &amp; mask) != mask) {
2174           // Check that at least both of them object arrays.
2175           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2176 
2177           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2178             __ load_klass(tmp, src);
2179           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2180             __ load_klass(tmp, dst);
2181           }
2182           Address klass_lh_addr(tmp, Klass::layout_helper_offset());
2183           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2184           __ load_const_optimized(Z_R1_scratch, objArray_lh);
2185           __ z_c(Z_R1_scratch, klass_lh_addr);
2186           __ branch_optimized(Assembler::bcondNotEqual, *stub-&gt;entry());
2187         }
2188 
2189         // Save outgoing arguments in callee saved registers (C convention) in case
2190         // a call to System.arraycopy is needed.
2191         Register callee_saved_src     = Z_R10;
2192         Register callee_saved_src_pos = Z_R11;
2193         Register callee_saved_dst     = Z_R12;
2194         Register callee_saved_dst_pos = Z_R13;
2195         Register callee_saved_length  = Z_ARG5; // Z_ARG5 == Z_R6 is callee saved.
2196 
2197         __ lgr_if_needed(callee_saved_src, src);
2198         __ lgr_if_needed(callee_saved_src_pos, src_pos);
2199         __ lgr_if_needed(callee_saved_dst, dst);
2200         __ lgr_if_needed(callee_saved_dst_pos, dst_pos);
2201         __ lgr_if_needed(callee_saved_length, length);
2202 
2203         __ z_llgfr(length, length); // Higher 32bits must be null.
2204 
2205         __ z_sllg(Z_ARG1, src_pos, shift_amount); // index -&gt; byte offset
2206         __ z_sllg(Z_ARG2, dst_pos, shift_amount); // index -&gt; byte offset
2207 
2208         __ z_la(Z_ARG1, Address(src, Z_ARG1, arrayOopDesc::base_offset_in_bytes(basic_type)));
2209         assert_different_registers(Z_ARG1, dst, dst_pos, length);
2210         __ z_la(Z_ARG2, Address(dst, Z_ARG2, arrayOopDesc::base_offset_in_bytes(basic_type)));
2211         assert_different_registers(Z_ARG2, dst, length);
2212 
2213         __ z_lgr(Z_ARG3, length);
2214         assert_different_registers(Z_ARG3, dst);
2215 
2216         __ load_klass(Z_ARG5, dst);
2217         __ z_lg(Z_ARG5, Address(Z_ARG5, ObjArrayKlass::element_klass_offset()));
2218         __ z_lg(Z_ARG4, Address(Z_ARG5, Klass::super_check_offset_offset()));
2219         emit_call_c(copyfunc_addr);
<a name="24" id="anc24"></a><span class="line-modified">2220         CHECK_BAILOUT2(cont, slow);</span>
2221 
2222 #ifndef PRODUCT
2223         if (PrintC1Statistics) {
2224           NearLabel failed;
2225           __ compareU32_and_branch(Z_RET, (intptr_t)0, Assembler::bcondNotEqual, failed);
2226           __ load_const_optimized(Z_R1_scratch, (address)&amp;Runtime1::_arraycopy_checkcast_cnt);
2227           __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);
2228           __ bind(failed);
2229         }
2230 #endif
2231 
2232         __ compareU32_and_branch(Z_RET, (intptr_t)0, Assembler::bcondEqual, *stub-&gt;continuation());
2233 
2234 #ifndef PRODUCT
2235         if (PrintC1Statistics) {
2236           __ load_const_optimized(Z_R1_scratch, (address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt);
2237           __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);
2238         }
2239 #endif
2240 
2241         __ z_lgr(tmp, Z_RET);
2242         __ z_xilf(tmp, -1);
2243 
2244         // Restore previously spilled arguments
2245         __ lgr_if_needed(src, callee_saved_src);
2246         __ lgr_if_needed(src_pos, callee_saved_src_pos);
2247         __ lgr_if_needed(dst, callee_saved_dst);
2248         __ lgr_if_needed(dst_pos, callee_saved_dst_pos);
2249         __ lgr_if_needed(length, callee_saved_length);
2250 
2251         __ z_sr(length, tmp);
2252         __ z_ar(src_pos, tmp);
2253         __ z_ar(dst_pos, tmp);
2254       }
2255 
2256       __ branch_optimized(Assembler::bcondAlways, *stub-&gt;entry());
2257 
2258       __ bind(cont);
2259     }
2260   }
2261 
2262 #ifdef ASSERT
2263   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2264     // Sanity check the known type with the incoming class. For the
2265     // primitive case the types must match exactly with src.klass and
2266     // dst.klass each exactly matching the default type. For the
2267     // object array case, if no type check is needed then either the
2268     // dst type is exactly the expected type and the src type is a
2269     // subtype which we can&#39;t check or src is the same array as dst
2270     // but not necessarily exactly of type default_type.
2271     NearLabel known_ok, halt;
2272     metadata2reg(default_type-&gt;constant_encoding(), tmp);
2273     if (UseCompressedClassPointers) {
2274       __ encode_klass_not_null(tmp);
2275     }
2276 
2277     if (basic_type != T_OBJECT) {
2278       if (UseCompressedClassPointers)         { __ z_c (tmp, dst_klass_addr); }
2279       else                                    { __ z_cg(tmp, dst_klass_addr); }
2280       __ branch_optimized(Assembler::bcondNotEqual, halt);
2281       if (UseCompressedClassPointers)         { __ z_c (tmp, src_klass_addr); }
2282       else                                    { __ z_cg(tmp, src_klass_addr); }
2283       __ branch_optimized(Assembler::bcondEqual, known_ok);
2284     } else {
2285       if (UseCompressedClassPointers)         { __ z_c (tmp, dst_klass_addr); }
2286       else                                    { __ z_cg(tmp, dst_klass_addr); }
2287       __ branch_optimized(Assembler::bcondEqual, known_ok);
2288       __ compareU64_and_branch(src, dst, Assembler::bcondEqual, known_ok);
2289     }
2290     __ bind(halt);
2291     __ stop(&quot;incorrect type information in arraycopy&quot;);
2292     __ bind(known_ok);
2293   }
2294 #endif
2295 
2296 #ifndef PRODUCT
2297   if (PrintC1Statistics) {
2298     __ load_const_optimized(Z_R1_scratch, Runtime1::arraycopy_count_address(basic_type));
2299     __ add2mem_32(Address(Z_R1_scratch), 1, Z_R0_scratch);
2300   }
2301 #endif
2302 
2303   __ z_sllg(tmp, src_pos, shift_amount); // index -&gt; byte offset
2304   __ z_sllg(Z_R1_scratch, dst_pos, shift_amount); // index -&gt; byte offset
2305 
2306   assert_different_registers(Z_ARG1, dst, dst_pos, length);
2307   __ z_la(Z_ARG1, Address(src, tmp, arrayOopDesc::base_offset_in_bytes(basic_type)));
2308   assert_different_registers(Z_ARG2, length);
2309   __ z_la(Z_ARG2, Address(dst, Z_R1_scratch, arrayOopDesc::base_offset_in_bytes(basic_type)));
2310   __ lgr_if_needed(Z_ARG3, length);
2311 
2312   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2313   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2314   const char *name;
2315   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2316   __ call_VM_leaf(entry);
2317 
2318   __ bind(*stub-&gt;continuation());
2319 }
2320 
2321 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2322   if (dest-&gt;is_single_cpu()) {
2323     if (left-&gt;type() == T_OBJECT) {
2324       switch (code) {
2325         case lir_shl:  __ z_sllg (dest-&gt;as_register(), left-&gt;as_register(), 0, count-&gt;as_register()); break;
2326         case lir_shr:  __ z_srag (dest-&gt;as_register(), left-&gt;as_register(), 0, count-&gt;as_register()); break;
2327         case lir_ushr: __ z_srlg (dest-&gt;as_register(), left-&gt;as_register(), 0, count-&gt;as_register()); break;
2328         default: ShouldNotReachHere();
2329       }
2330     } else {
2331       assert(code == lir_shl || left == dest, &quot;left and dest must be equal for 2 operand form right shifts&quot;);
2332       Register masked_count = Z_R1_scratch;
2333       __ z_lr(masked_count, count-&gt;as_register());
2334       __ z_nill(masked_count, 31);
2335       switch (code) {
2336         case lir_shl:  __ z_sllg (dest-&gt;as_register(), left-&gt;as_register(), 0, masked_count); break;
2337         case lir_shr:  __ z_sra  (dest-&gt;as_register(), 0, masked_count); break;
2338         case lir_ushr: __ z_srl  (dest-&gt;as_register(), 0, masked_count); break;
2339         default: ShouldNotReachHere();
2340       }
2341     }
2342   } else {
2343     switch (code) {
2344       case lir_shl:  __ z_sllg (dest-&gt;as_register_lo(), left-&gt;as_register_lo(), 0, count-&gt;as_register()); break;
2345       case lir_shr:  __ z_srag (dest-&gt;as_register_lo(), left-&gt;as_register_lo(), 0, count-&gt;as_register()); break;
2346       case lir_ushr: __ z_srlg (dest-&gt;as_register_lo(), left-&gt;as_register_lo(), 0, count-&gt;as_register()); break;
2347       default: ShouldNotReachHere();
2348     }
2349   }
2350 }
2351 
2352 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2353   if (left-&gt;type() == T_OBJECT) {
2354     count = count &amp; 63;  // Shouldn&#39;t shift by more than sizeof(intptr_t).
2355     Register l = left-&gt;as_register();
2356     Register d = dest-&gt;as_register_lo();
2357     switch (code) {
2358       case lir_shl:  __ z_sllg (d, l, count); break;
2359       case lir_shr:  __ z_srag (d, l, count); break;
2360       case lir_ushr: __ z_srlg (d, l, count); break;
2361       default: ShouldNotReachHere();
2362     }
2363     return;
2364   }
2365   if (dest-&gt;is_single_cpu()) {
2366     assert(code == lir_shl || left == dest, &quot;left and dest must be equal for 2 operand form right shifts&quot;);
2367     count = count &amp; 0x1F; // Java spec
2368     switch (code) {
2369       case lir_shl:  __ z_sllg (dest-&gt;as_register(), left-&gt;as_register(), count); break;
2370       case lir_shr:  __ z_sra  (dest-&gt;as_register(), count); break;
2371       case lir_ushr: __ z_srl  (dest-&gt;as_register(), count); break;
2372       default: ShouldNotReachHere();
2373     }
2374   } else if (dest-&gt;is_double_cpu()) {
2375     count = count &amp; 63; // Java spec
2376     Register l = left-&gt;as_pointer_register();
2377     Register d = dest-&gt;as_pointer_register();
2378     switch (code) {
2379       case lir_shl:  __ z_sllg (d, l, count); break;
2380       case lir_shr:  __ z_srag (d, l, count); break;
2381       case lir_ushr: __ z_srlg (d, l, count); break;
2382       default: ShouldNotReachHere();
2383     }
2384   } else {
2385     ShouldNotReachHere();
2386   }
2387 }
2388 
2389 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
2390   if (op-&gt;init_check()) {
2391     // Make sure klass is initialized &amp; doesn&#39;t have finalizer.
2392     const int state_offset = in_bytes(InstanceKlass::init_state_offset());
2393     Register iklass = op-&gt;klass()-&gt;as_register();
2394     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
2395     if (Immediate::is_uimm12(state_offset)) {
2396       __ z_cli(state_offset, iklass, InstanceKlass::fully_initialized);
2397     } else {
2398       __ z_cliy(state_offset, iklass, InstanceKlass::fully_initialized);
2399     }
2400     __ branch_optimized(Assembler::bcondNotEqual, *op-&gt;stub()-&gt;entry()); // Use long branch, because slow_case might be far.
2401   }
2402   __ allocate_object(op-&gt;obj()-&gt;as_register(),
2403                      op-&gt;tmp1()-&gt;as_register(),
2404                      op-&gt;tmp2()-&gt;as_register(),
2405                      op-&gt;header_size(),
2406                      op-&gt;object_size(),
2407                      op-&gt;klass()-&gt;as_register(),
2408                      *op-&gt;stub()-&gt;entry());
2409   __ bind(*op-&gt;stub()-&gt;continuation());
<a name="25" id="anc25"></a><span class="line-modified">2410   __ verify_oop(op-&gt;obj()-&gt;as_register(), FILE_AND_LINE);</span>
2411 }
2412 
2413 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
2414   Register len = op-&gt;len()-&gt;as_register();
2415   __ move_reg_if_needed(len, T_LONG, len, T_INT); // sign extend
2416 
2417   if (UseSlowPath ||
<a name="26" id="anc26"></a><span class="line-modified">2418       (!UseFastNewObjectArray &amp;&amp; (is_reference_type(op-&gt;type()))) ||</span>
<span class="line-modified">2419       (!UseFastNewTypeArray   &amp;&amp; (!is_reference_type(op-&gt;type())))) {</span>
2420     __ z_brul(*op-&gt;stub()-&gt;entry());
2421   } else {
2422     __ allocate_array(op-&gt;obj()-&gt;as_register(),
2423                       op-&gt;len()-&gt;as_register(),
2424                       op-&gt;tmp1()-&gt;as_register(),
2425                       op-&gt;tmp2()-&gt;as_register(),
2426                       arrayOopDesc::header_size(op-&gt;type()),
2427                       type2aelembytes(op-&gt;type()),
2428                       op-&gt;klass()-&gt;as_register(),
2429                       *op-&gt;stub()-&gt;entry());
2430   }
2431   __ bind(*op-&gt;stub()-&gt;continuation());
2432 }
2433 
2434 void LIR_Assembler::type_profile_helper(Register mdo, ciMethodData *md, ciProfileData *data,
2435                                         Register recv, Register tmp1, Label* update_done) {
2436   uint i;
2437   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2438     Label next_test;
2439     // See if the receiver is receiver[n].
2440     Address receiver_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
2441     __ z_cg(recv, receiver_addr);
2442     __ z_brne(next_test);
2443     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
2444     __ add2mem_64(data_addr, DataLayout::counter_increment, tmp1);
2445     __ branch_optimized(Assembler::bcondAlways, *update_done);
2446     __ bind(next_test);
2447   }
2448 
2449   // Didn&#39;t find receiver; find next empty slot and fill it in.
2450   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2451     Label next_test;
2452     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
2453     __ z_ltg(Z_R0_scratch, recv_addr);
2454     __ z_brne(next_test);
2455     __ z_stg(recv, recv_addr);
2456     __ load_const_optimized(tmp1, DataLayout::counter_increment);
2457     __ z_stg(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)), mdo);
2458     __ branch_optimized(Assembler::bcondAlways, *update_done);
2459     __ bind(next_test);
2460   }
2461 }
2462 
2463 void LIR_Assembler::setup_md_access(ciMethod* method, int bci,
2464                                     ciMethodData*&amp; md, ciProfileData*&amp; data, int&amp; mdo_offset_bias) {
2465   Unimplemented();
2466 }
2467 
2468 void LIR_Assembler::store_parameter(Register r, int param_num) {
2469   assert(param_num &gt;= 0, &quot;invalid num&quot;);
2470   int offset_in_bytes = param_num * BytesPerWord + FrameMap::first_available_sp_in_frame;
2471   assert(offset_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2472   __ z_stg(r, offset_in_bytes, Z_SP);
2473 }
2474 
2475 void LIR_Assembler::store_parameter(jint c, int param_num) {
2476   assert(param_num &gt;= 0, &quot;invalid num&quot;);
2477   int offset_in_bytes = param_num * BytesPerWord + FrameMap::first_available_sp_in_frame;
2478   assert(offset_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2479   __ store_const(Address(Z_SP, offset_in_bytes), c, Z_R1_scratch, true);
2480 }
2481 
2482 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
2483   // We always need a stub for the failure case.
2484   CodeStub* stub = op-&gt;stub();
2485   Register obj = op-&gt;object()-&gt;as_register();
2486   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2487   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2488   Register dst = op-&gt;result_opr()-&gt;as_register();
2489   Register Rtmp1 = Z_R1_scratch;
2490   ciKlass* k = op-&gt;klass();
2491 
2492   assert(!op-&gt;tmp3()-&gt;is_valid(), &quot;tmp3&#39;s not needed&quot;);
2493 
2494   // Check if it needs to be profiled.
2495   ciMethodData* md = NULL;
2496   ciProfileData* data = NULL;
2497 
2498   if (op-&gt;should_profile()) {
2499     ciMethod* method = op-&gt;profiled_method();
2500     assert(method != NULL, &quot;Should have method&quot;);
2501     int bci = op-&gt;profiled_bci();
2502     md = method-&gt;method_data_or_null();
2503     assert(md != NULL, &quot;Sanity&quot;);
2504     data = md-&gt;bci_to_data(bci);
2505     assert(data != NULL,                &quot;need data for type check&quot;);
2506     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
2507   }
2508 
2509   // Temp operands do not overlap with inputs, if this is their last
2510   // use (end of range is exclusive), so a register conflict is possible.
2511   if (obj == k_RInfo) {
2512     k_RInfo = dst;
2513   } else if (obj == klass_RInfo) {
2514     klass_RInfo = dst;
2515   }
2516   assert_different_registers(obj, k_RInfo, klass_RInfo);
2517 
2518   if (op-&gt;should_profile()) {
2519     NearLabel not_null;
2520     __ compareU64_and_branch(obj, (intptr_t) 0, Assembler::bcondNotEqual, not_null);
2521     // Object is null; update MDO and exit.
2522     Register mdo = klass_RInfo;
2523     metadata2reg(md-&gt;constant_encoding(), mdo);
2524     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::header_offset()));
2525     int header_bits = DataLayout::flag_mask_to_header_mask(BitData::null_seen_byte_constant());
2526     __ or2mem_8(data_addr, header_bits);
2527     __ branch_optimized(Assembler::bcondAlways, *obj_is_null);
2528     __ bind(not_null);
2529   } else {
2530     __ compareU64_and_branch(obj, (intptr_t) 0, Assembler::bcondEqual, *obj_is_null);
2531   }
2532 
2533   NearLabel profile_cast_failure, profile_cast_success;
2534   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
2535   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
2536 
2537   // Patching may screw with our temporaries on sparc,
2538   // so let&#39;s do it before loading the class.
2539   if (k-&gt;is_loaded()) {
2540     metadata2reg(k-&gt;constant_encoding(), k_RInfo);
2541   } else {
2542     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
2543   }
2544   assert(obj != k_RInfo, &quot;must be different&quot;);
2545 
<a name="27" id="anc27"></a><span class="line-modified">2546   __ verify_oop(obj, FILE_AND_LINE);</span>
2547 
2548   // Get object class.
2549   // Not a safepoint as obj null check happens earlier.
2550   if (op-&gt;fast_check()) {
2551     if (UseCompressedClassPointers) {
2552       __ load_klass(klass_RInfo, obj);
2553       __ compareU64_and_branch(k_RInfo, klass_RInfo, Assembler::bcondNotEqual, *failure_target);
2554     } else {
2555       __ z_cg(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
2556       __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
2557     }
2558     // Successful cast, fall through to profile or jump.
2559   } else {
2560     bool need_slow_path = !k-&gt;is_loaded() ||
2561                           ((int) k-&gt;super_check_offset() == in_bytes(Klass::secondary_super_cache_offset()));
2562     intptr_t super_check_offset = k-&gt;is_loaded() ? k-&gt;super_check_offset() : -1L;
2563     __ load_klass(klass_RInfo, obj);
2564     // Perform the fast part of the checking logic.
2565     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1,
2566                                      (need_slow_path ? success_target : NULL),
2567                                      failure_target, NULL,
2568                                      RegisterOrConstant(super_check_offset));
2569     if (need_slow_path) {
2570       // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2571       address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
2572       store_parameter(klass_RInfo, 0); // sub
2573       store_parameter(k_RInfo, 1);     // super
2574       emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
<a name="28" id="anc28"></a><span class="line-modified">2575       CHECK_BAILOUT2(profile_cast_failure, profile_cast_success);</span>
2576       __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
2577       // Fall through to success case.
2578     }
2579   }
2580 
2581   if (op-&gt;should_profile()) {
2582     Register mdo = klass_RInfo, recv = k_RInfo;
2583     assert_different_registers(obj, mdo, recv);
2584     __ bind(profile_cast_success);
2585     metadata2reg(md-&gt;constant_encoding(), mdo);
2586     __ load_klass(recv, obj);
2587     type_profile_helper(mdo, md, data, recv, Rtmp1, success);
2588     __ branch_optimized(Assembler::bcondAlways, *success);
2589 
2590     __ bind(profile_cast_failure);
2591     metadata2reg(md-&gt;constant_encoding(), mdo);
2592     __ add2mem_64(Address(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset())), -(int)DataLayout::counter_increment, Rtmp1);
2593     __ branch_optimized(Assembler::bcondAlways, *failure);
2594   } else {
2595     __ branch_optimized(Assembler::bcondAlways, *success);
2596   }
2597 }
2598 
2599 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
2600   LIR_Code code = op-&gt;code();
2601   if (code == lir_store_check) {
2602     Register value = op-&gt;object()-&gt;as_register();
2603     Register array = op-&gt;array()-&gt;as_register();
2604     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2605     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2606     Register Rtmp1 = Z_R1_scratch;
2607 
2608     CodeStub* stub = op-&gt;stub();
2609 
2610     // Check if it needs to be profiled.
2611     ciMethodData* md = NULL;
2612     ciProfileData* data = NULL;
2613 
2614     assert_different_registers(value, k_RInfo, klass_RInfo);
2615 
2616     if (op-&gt;should_profile()) {
2617       ciMethod* method = op-&gt;profiled_method();
2618       assert(method != NULL, &quot;Should have method&quot;);
2619       int bci = op-&gt;profiled_bci();
2620       md = method-&gt;method_data_or_null();
2621       assert(md != NULL, &quot;Sanity&quot;);
2622       data = md-&gt;bci_to_data(bci);
2623       assert(data != NULL,                &quot;need data for type check&quot;);
2624       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
2625     }
2626     NearLabel profile_cast_success, profile_cast_failure, done;
2627     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
2628     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
2629 
2630     if (op-&gt;should_profile()) {
2631       NearLabel not_null;
2632       __ compareU64_and_branch(value, (intptr_t) 0, Assembler::bcondNotEqual, not_null);
2633       // Object is null; update MDO and exit.
2634       Register mdo = klass_RInfo;
2635       metadata2reg(md-&gt;constant_encoding(), mdo);
2636       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::header_offset()));
2637       int header_bits = DataLayout::flag_mask_to_header_mask(BitData::null_seen_byte_constant());
2638       __ or2mem_8(data_addr, header_bits);
2639       __ branch_optimized(Assembler::bcondAlways, done);
2640       __ bind(not_null);
2641     } else {
2642       __ compareU64_and_branch(value, (intptr_t) 0, Assembler::bcondEqual, done);
2643     }
2644 
2645     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
2646     __ load_klass(k_RInfo, array);
2647     __ load_klass(klass_RInfo, value);
2648 
2649     // Get instance klass (it&#39;s already uncompressed).
2650     __ z_lg(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
2651     // Perform the fast part of the checking logic.
2652     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
2653     // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2654     address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);
2655     store_parameter(klass_RInfo, 0); // sub
2656     store_parameter(k_RInfo, 1);     // super
2657     emit_call_c(a); // Sets condition code 0 for match (2 otherwise).
<a name="29" id="anc29"></a><span class="line-modified">2658     CHECK_BAILOUT3(profile_cast_success, profile_cast_failure, done);</span>
2659     __ branch_optimized(Assembler::bcondNotEqual, *failure_target);
2660     // Fall through to success case.
2661 
2662     if (op-&gt;should_profile()) {
2663       Register mdo = klass_RInfo, recv = k_RInfo;
2664       assert_different_registers(value, mdo, recv);
2665       __ bind(profile_cast_success);
2666       metadata2reg(md-&gt;constant_encoding(), mdo);
2667       __ load_klass(recv, value);
2668       type_profile_helper(mdo, md, data, recv, Rtmp1, &amp;done);
2669       __ branch_optimized(Assembler::bcondAlways, done);
2670 
2671       __ bind(profile_cast_failure);
2672       metadata2reg(md-&gt;constant_encoding(), mdo);
2673       __ add2mem_64(Address(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset())), -(int)DataLayout::counter_increment, Rtmp1);
2674       __ branch_optimized(Assembler::bcondAlways, *stub-&gt;entry());
2675     }
2676 
2677     __ bind(done);
2678   } else {
2679     if (code == lir_checkcast) {
2680       Register obj = op-&gt;object()-&gt;as_register();
2681       Register dst = op-&gt;result_opr()-&gt;as_register();
2682       NearLabel success;
2683       emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
2684       __ bind(success);
2685       __ lgr_if_needed(dst, obj);
2686     } else {
2687       if (code == lir_instanceof) {
2688         Register obj = op-&gt;object()-&gt;as_register();
2689         Register dst = op-&gt;result_opr()-&gt;as_register();
2690         NearLabel success, failure, done;
2691         emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
2692         __ bind(failure);
2693         __ clear_reg(dst);
2694         __ branch_optimized(Assembler::bcondAlways, done);
2695         __ bind(success);
2696         __ load_const_optimized(dst, 1);
2697         __ bind(done);
2698       } else {
2699         ShouldNotReachHere();
2700       }
2701     }
2702   }
2703 }
2704 
2705 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
2706   Register addr = op-&gt;addr()-&gt;as_pointer_register();
2707   Register t1_cmp = Z_R1_scratch;
2708   if (op-&gt;code() == lir_cas_long) {
2709     assert(VM_Version::supports_cx8(), &quot;wrong machine&quot;);
2710     Register cmp_value_lo = op-&gt;cmp_value()-&gt;as_register_lo();
2711     Register new_value_lo = op-&gt;new_value()-&gt;as_register_lo();
2712     __ z_lgr(t1_cmp, cmp_value_lo);
2713     // Perform the compare and swap operation.
2714     __ z_csg(t1_cmp, new_value_lo, 0, addr);
2715   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj) {
2716     Register cmp_value = op-&gt;cmp_value()-&gt;as_register();
2717     Register new_value = op-&gt;new_value()-&gt;as_register();
2718     if (op-&gt;code() == lir_cas_obj) {
2719       if (UseCompressedOops) {
2720                  t1_cmp = op-&gt;tmp1()-&gt;as_register();
2721         Register t2_new = op-&gt;tmp2()-&gt;as_register();
2722         assert_different_registers(cmp_value, new_value, addr, t1_cmp, t2_new);
2723         __ oop_encoder(t1_cmp, cmp_value, true /*maybe null*/);
2724         __ oop_encoder(t2_new, new_value, true /*maybe null*/);
2725         __ z_cs(t1_cmp, t2_new, 0, addr);
2726       } else {
2727         __ z_lgr(t1_cmp, cmp_value);
2728         __ z_csg(t1_cmp, new_value, 0, addr);
2729       }
2730     } else {
2731       __ z_lr(t1_cmp, cmp_value);
2732       __ z_cs(t1_cmp, new_value, 0, addr);
2733     }
2734   } else {
2735     ShouldNotReachHere(); // new lir_cas_??
2736   }
2737 }
2738 
<a name="30" id="anc30"></a>







2739 void LIR_Assembler::breakpoint() {
2740   Unimplemented();
2741   //  __ breakpoint_trap();
2742 }
2743 
2744 void LIR_Assembler::push(LIR_Opr opr) {
2745   ShouldNotCallThis(); // unused
2746 }
2747 
2748 void LIR_Assembler::pop(LIR_Opr opr) {
2749   ShouldNotCallThis(); // unused
2750 }
2751 
2752 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst_opr) {
2753   Address addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
2754   __ add2reg(dst_opr-&gt;as_register(), addr.disp(), addr.base());
2755 }
2756 
2757 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2758   Register obj = op-&gt;obj_opr()-&gt;as_register();  // May not be an oop.
2759   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2760   Register lock = op-&gt;lock_opr()-&gt;as_register();
2761   if (!UseFastLocking) {
2762     __ branch_optimized(Assembler::bcondAlways, *op-&gt;stub()-&gt;entry());
2763   } else if (op-&gt;code() == lir_lock) {
2764     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2765     // Add debug info for NullPointerException only if one is possible.
2766     if (op-&gt;info() != NULL) {
2767       add_debug_info_for_null_check_here(op-&gt;info());
2768     }
2769     __ lock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2770     // done
2771   } else if (op-&gt;code() == lir_unlock) {
2772     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2773     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2774   } else {
2775     ShouldNotReachHere();
2776   }
2777   __ bind(*op-&gt;stub()-&gt;continuation());
2778 }
2779 
2780 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2781   ciMethod* method = op-&gt;profiled_method();
2782   int bci          = op-&gt;profiled_bci();
2783   ciMethod* callee = op-&gt;profiled_callee();
2784 
2785   // Update counter for all call types.
2786   ciMethodData* md = method-&gt;method_data_or_null();
2787   assert(md != NULL, &quot;Sanity&quot;);
2788   ciProfileData* data = md-&gt;bci_to_data(bci);
2789   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2790   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2791   Register mdo  = op-&gt;mdo()-&gt;as_register();
2792   assert(op-&gt;tmp1()-&gt;is_double_cpu(), &quot;tmp1 must be allocated&quot;);
2793   Register tmp1 = op-&gt;tmp1()-&gt;as_register_lo();
2794   metadata2reg(md-&gt;constant_encoding(), mdo);
2795 
2796   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
2797   // Perform additional virtual call profiling for invokevirtual and
2798   // invokeinterface bytecodes
2799   if (op-&gt;should_profile_receiver_type()) {
2800     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2801     Register recv = op-&gt;recv()-&gt;as_register();
2802     assert_different_registers(mdo, tmp1, recv);
2803     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2804     ciKlass* known_klass = op-&gt;known_holder();
2805     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2806       // We know the type that will be seen at this call site; we can
2807       // statically update the MethodData* rather than needing to do
2808       // dynamic tests on the receiver type.
2809 
2810       // NOTE: we should probably put a lock around this search to
2811       // avoid collisions by concurrent compilations.
2812       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2813       uint i;
2814       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2815         ciKlass* receiver = vc_data-&gt;receiver(i);
2816         if (known_klass-&gt;equals(receiver)) {
2817           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2818           __ add2mem_64(data_addr, DataLayout::counter_increment, tmp1);
2819           return;
2820         }
2821       }
2822 
2823       // Receiver type not found in profile data. Select an empty slot.
2824 
2825       // Note that this is less efficient than it should be because it
2826       // always does a write to the receiver part of the
2827       // VirtualCallData rather than just the first time.
2828       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2829         ciKlass* receiver = vc_data-&gt;receiver(i);
2830         if (receiver == NULL) {
2831           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
2832           metadata2reg(known_klass-&gt;constant_encoding(), tmp1);
2833           __ z_stg(tmp1, recv_addr);
2834           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2835           __ add2mem_64(data_addr, DataLayout::counter_increment, tmp1);
2836           return;
2837         }
2838       }
2839     } else {
2840       __ load_klass(recv, recv);
2841       NearLabel update_done;
2842       type_profile_helper(mdo, md, data, recv, tmp1, &amp;update_done);
2843       // Receiver did not match any saved receiver and there is no empty row for it.
2844       // Increment total counter to indicate polymorphic case.
2845       __ add2mem_64(counter_addr, DataLayout::counter_increment, tmp1);
2846       __ bind(update_done);
2847     }
2848   } else {
2849     // static call
2850     __ add2mem_64(counter_addr, DataLayout::counter_increment, tmp1);
2851   }
2852 }
2853 
2854 void LIR_Assembler::align_backward_branch_target() {
2855   __ align(OptoLoopAlignment);
2856 }
2857 
2858 void LIR_Assembler::emit_delay(LIR_OpDelay* op) {
2859   ShouldNotCallThis(); // There are no delay slots on ZARCH_64.
2860 }
2861 
2862 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
2863   // tmp must be unused
2864   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2865   assert(left-&gt;is_register(), &quot;can only handle registers&quot;);
2866 
2867   if (left-&gt;is_single_cpu()) {
2868     __ z_lcr(dest-&gt;as_register(), left-&gt;as_register());
2869   } else if (left-&gt;is_single_fpu()) {
2870     __ z_lcebr(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
2871   } else if (left-&gt;is_double_fpu()) {
2872     __ z_lcdbr(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
2873   } else {
2874     assert(left-&gt;is_double_cpu(), &quot;Must be a long&quot;);
2875     __ z_lcgr(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
2876   }
2877 }
2878 
<a name="31" id="anc31"></a>











2879 void LIR_Assembler::rt_call(LIR_Opr result, address dest,
2880                             const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
2881   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
2882   emit_call_c(dest);
2883   CHECK_BAILOUT();
2884   if (info != NULL) {
2885     add_call_info_here(info);
2886   }
2887 }
2888 
2889 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
2890   ShouldNotCallThis(); // not needed on ZARCH_64
2891 }
2892 
2893 void LIR_Assembler::membar() {
2894   __ z_fence();
2895 }
2896 
2897 void LIR_Assembler::membar_acquire() {
2898   __ z_acquire();
2899 }
2900 
2901 void LIR_Assembler::membar_release() {
2902   __ z_release();
2903 }
2904 
2905 void LIR_Assembler::membar_loadload() {
2906   __ z_acquire();
2907 }
2908 
2909 void LIR_Assembler::membar_storestore() {
2910   __ z_release();
2911 }
2912 
2913 void LIR_Assembler::membar_loadstore() {
2914   __ z_acquire();
2915 }
2916 
2917 void LIR_Assembler::membar_storeload() {
2918   __ z_fence();
2919 }
2920 
2921 void LIR_Assembler::on_spin_wait() {
2922   Unimplemented();
2923 }
2924 
2925 void LIR_Assembler::leal(LIR_Opr addr_opr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
2926   assert(patch_code == lir_patch_none, &quot;Patch code not supported&quot;);
2927   LIR_Address* addr = addr_opr-&gt;as_address_ptr();
2928   assert(addr-&gt;scale() == LIR_Address::times_1, &quot;scaling unsupported&quot;);
2929   __ load_address(dest-&gt;as_pointer_register(), as_Address(addr));
2930 }
2931 
2932 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
2933   ShouldNotCallThis(); // unused
2934 }
2935 
2936 #ifdef ASSERT
2937 // Emit run-time assertion.
2938 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
2939   Unimplemented();
2940 }
2941 #endif
2942 
2943 void LIR_Assembler::peephole(LIR_List*) {
2944   // Do nothing for now.
2945 }
2946 
2947 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
2948   assert(code == lir_xadd, &quot;lir_xchg not supported&quot;);
2949   Address src_addr = as_Address(src-&gt;as_address_ptr());
2950   Register base = src_addr.base();
2951   intptr_t disp = src_addr.disp();
2952   if (src_addr.index()-&gt;is_valid()) {
2953     // LAA and LAAG do not support index register.
2954     __ load_address(Z_R1_scratch, src_addr);
2955     base = Z_R1_scratch;
2956     disp = 0;
2957   }
2958   if (data-&gt;type() == T_INT) {
2959     __ z_laa(dest-&gt;as_register(), data-&gt;as_register(), disp, base);
2960   } else if (data-&gt;type() == T_LONG) {
2961     assert(data-&gt;as_register_lo() == data-&gt;as_register_hi(), &quot;should be a single register&quot;);
2962     __ z_laag(dest-&gt;as_register_lo(), data-&gt;as_register_lo(), disp, base);
2963   } else {
2964     ShouldNotReachHere();
2965   }
2966 }
2967 
2968 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
2969   Register obj = op-&gt;obj()-&gt;as_register();
2970   Register tmp1 = op-&gt;tmp()-&gt;as_pointer_register();
2971   Register tmp2 = Z_R1_scratch;
2972   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
2973   ciKlass* exact_klass = op-&gt;exact_klass();
2974   intptr_t current_klass = op-&gt;current_klass();
2975   bool not_null = op-&gt;not_null();
2976   bool no_conflict = op-&gt;no_conflict();
2977 
2978   Label update, next, none, null_seen, init_klass;
2979 
2980   bool do_null = !not_null;
2981   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
2982   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
2983 
2984   assert(do_null || do_update, &quot;why are we here?&quot;);
2985   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
2986 
<a name="32" id="anc32"></a><span class="line-modified">2987   __ verify_oop(obj, FILE_AND_LINE);</span>
2988 
2989   if (do_null || tmp1 != obj DEBUG_ONLY(|| true)) {
2990     __ z_ltgr(tmp1, obj);
2991   }
2992   if (do_null) {
2993     __ z_brnz(update);
2994     if (!TypeEntries::was_null_seen(current_klass)) {
2995       __ z_lg(tmp1, mdo_addr);
2996       __ z_oill(tmp1, TypeEntries::null_seen);
2997       __ z_stg(tmp1, mdo_addr);
2998     }
2999     if (do_update) {
3000       __ z_bru(next);
3001     }
3002   } else {
3003     __ asm_assert_ne(&quot;unexpect null obj&quot;, __LINE__);
3004   }
3005 
3006   __ bind(update);
3007 
3008   if (do_update) {
3009 #ifdef ASSERT
3010     if (exact_klass != NULL) {
3011       __ load_klass(tmp1, tmp1);
3012       metadata2reg(exact_klass-&gt;constant_encoding(), tmp2);
3013       __ z_cgr(tmp1, tmp2);
3014       __ asm_assert_eq(&quot;exact klass and actual klass differ&quot;, __LINE__);
3015     }
3016 #endif
3017 
3018     Label do_update;
3019     __ z_lg(tmp2, mdo_addr);
3020 
3021     if (!no_conflict) {
3022       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3023         if (exact_klass != NULL) {
3024           metadata2reg(exact_klass-&gt;constant_encoding(), tmp1);
3025         } else {
3026           __ load_klass(tmp1, tmp1);
3027         }
3028 
3029         // Klass seen before: nothing to do (regardless of unknown bit).
3030         __ z_lgr(Z_R0_scratch, tmp2);
3031         assert(Immediate::is_uimm(~TypeEntries::type_klass_mask, 16), &quot;or change following instruction&quot;);
3032         __ z_nill(Z_R0_scratch, TypeEntries::type_klass_mask &amp; 0xFFFF);
3033         __ compareU64_and_branch(Z_R0_scratch, tmp1, Assembler::bcondEqual, next);
3034 
3035         // Already unknown: Nothing to do anymore.
3036         __ z_tmll(tmp2, TypeEntries::type_unknown);
3037         __ z_brc(Assembler::bcondAllOne, next);
3038 
3039         if (TypeEntries::is_type_none(current_klass)) {
3040           __ z_lgr(Z_R0_scratch, tmp2);
3041           assert(Immediate::is_uimm(~TypeEntries::type_mask, 16), &quot;or change following instruction&quot;);
3042           __ z_nill(Z_R0_scratch, TypeEntries::type_mask &amp; 0xFFFF);
3043           __ compareU64_and_branch(Z_R0_scratch, (intptr_t)0, Assembler::bcondEqual, init_klass);
3044         }
3045       } else {
3046         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3047                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3048 
3049         // Already unknown: Nothing to do anymore.
3050         __ z_tmll(tmp2, TypeEntries::type_unknown);
3051         __ z_brc(Assembler::bcondAllOne, next);
3052       }
3053 
3054       // Different than before. Cannot keep accurate profile.
3055       __ z_oill(tmp2, TypeEntries::type_unknown);
3056       __ z_bru(do_update);
3057     } else {
3058       // There&#39;s a single possible klass at this profile point.
3059       assert(exact_klass != NULL, &quot;should be&quot;);
3060       if (TypeEntries::is_type_none(current_klass)) {
3061         metadata2reg(exact_klass-&gt;constant_encoding(), tmp1);
3062         __ z_lgr(Z_R0_scratch, tmp2);
3063         assert(Immediate::is_uimm(~TypeEntries::type_klass_mask, 16), &quot;or change following instruction&quot;);
3064         __ z_nill(Z_R0_scratch, TypeEntries::type_klass_mask &amp; 0xFFFF);
3065         __ compareU64_and_branch(Z_R0_scratch, tmp1, Assembler::bcondEqual, next);
3066 #ifdef ASSERT
3067         {
3068           Label ok;
3069           __ z_lgr(Z_R0_scratch, tmp2);
3070           assert(Immediate::is_uimm(~TypeEntries::type_mask, 16), &quot;or change following instruction&quot;);
3071           __ z_nill(Z_R0_scratch, TypeEntries::type_mask &amp; 0xFFFF);
3072           __ compareU64_and_branch(Z_R0_scratch, (intptr_t)0, Assembler::bcondEqual, ok);
3073           __ stop(&quot;unexpected profiling mismatch&quot;);
3074           __ bind(ok);
3075         }
3076 #endif
3077 
3078       } else {
3079         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3080                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3081 
3082         // Already unknown: Nothing to do anymore.
3083         __ z_tmll(tmp2, TypeEntries::type_unknown);
3084         __ z_brc(Assembler::bcondAllOne, next);
3085         __ z_oill(tmp2, TypeEntries::type_unknown);
3086         __ z_bru(do_update);
3087       }
3088     }
3089 
3090     __ bind(init_klass);
3091     // Combine klass and null_seen bit (only used if (tmp &amp; type_mask)==0).
3092     __ z_ogr(tmp2, tmp1);
3093 
3094     __ bind(do_update);
3095     __ z_stg(tmp2, mdo_addr);
3096 
3097     __ bind(next);
3098   }
3099 }
3100 
3101 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3102   assert(op-&gt;crc()-&gt;is_single_cpu(), &quot;crc must be register&quot;);
3103   assert(op-&gt;val()-&gt;is_single_cpu(), &quot;byte value must be register&quot;);
3104   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3105   Register crc = op-&gt;crc()-&gt;as_register();
3106   Register val = op-&gt;val()-&gt;as_register();
3107   Register res = op-&gt;result_opr()-&gt;as_register();
3108 
3109   assert_different_registers(val, crc, res);
3110 
3111   __ load_const_optimized(res, StubRoutines::crc_table_addr());
3112   __ kernel_crc32_singleByteReg(crc, val, res, true);
3113   __ z_lgfr(res, crc);
3114 }
3115 
3116 #undef __
<a name="33" id="anc33"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="33" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/macroAssembler_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2016, 2018, SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/codeBuffer.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;oops/accessDecorators.hpp&quot;
  38 #include &quot;oops/compressedOops.inline.hpp&quot;
  39 #include &quot;oops/klass.inline.hpp&quot;
<a name="2" id="anc2"></a>
  40 #include &quot;opto/compile.hpp&quot;
  41 #include &quot;opto/intrinsicnode.hpp&quot;
  42 #include &quot;opto/matcher.hpp&quot;
<a name="3" id="anc3"></a>
  43 #include &quot;prims/methodHandles.hpp&quot;
  44 #include &quot;registerSaver_s390.hpp&quot;
  45 #include &quot;runtime/biasedLocking.hpp&quot;
  46 #include &quot;runtime/icache.hpp&quot;
  47 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  48 #include &quot;runtime/objectMonitor.hpp&quot;
  49 #include &quot;runtime/os.hpp&quot;
  50 #include &quot;runtime/safepoint.hpp&quot;
  51 #include &quot;runtime/safepointMechanism.hpp&quot;
  52 #include &quot;runtime/sharedRuntime.hpp&quot;
  53 #include &quot;runtime/stubRoutines.hpp&quot;
  54 #include &quot;utilities/events.hpp&quot;
  55 #include &quot;utilities/macros.hpp&quot;
<a name="4" id="anc4"></a>
  56 
  57 #include &lt;ucontext.h&gt;
  58 
  59 #define BLOCK_COMMENT(str) block_comment(str)
  60 #define BIND(label)        bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  61 
  62 // Move 32-bit register if destination and source are different.
  63 void MacroAssembler::lr_if_needed(Register rd, Register rs) {
  64   if (rs != rd) { z_lr(rd, rs); }
  65 }
  66 
  67 // Move register if destination and source are different.
  68 void MacroAssembler::lgr_if_needed(Register rd, Register rs) {
  69   if (rs != rd) { z_lgr(rd, rs); }
  70 }
  71 
  72 // Zero-extend 32-bit register into 64-bit register if destination and source are different.
  73 void MacroAssembler::llgfr_if_needed(Register rd, Register rs) {
  74   if (rs != rd) { z_llgfr(rd, rs); }
  75 }
  76 
  77 // Move float register if destination and source are different.
  78 void MacroAssembler::ldr_if_needed(FloatRegister rd, FloatRegister rs) {
  79   if (rs != rd) { z_ldr(rd, rs); }
  80 }
  81 
  82 // Move integer register if destination and source are different.
  83 // It is assumed that shorter-than-int types are already
  84 // appropriately sign-extended.
  85 void MacroAssembler::move_reg_if_needed(Register dst, BasicType dst_type, Register src,
  86                                         BasicType src_type) {
  87   assert((dst_type != T_FLOAT) &amp;&amp; (dst_type != T_DOUBLE), &quot;use move_freg for float types&quot;);
  88   assert((src_type != T_FLOAT) &amp;&amp; (src_type != T_DOUBLE), &quot;use move_freg for float types&quot;);
  89 
  90   if (dst_type == src_type) {
  91     lgr_if_needed(dst, src); // Just move all 64 bits.
  92     return;
  93   }
  94 
  95   switch (dst_type) {
  96     // Do not support these types for now.
  97     //  case T_BOOLEAN:
  98     case T_BYTE:  // signed byte
  99       switch (src_type) {
 100         case T_INT:
 101           z_lgbr(dst, src);
 102           break;
 103         default:
 104           ShouldNotReachHere();
 105       }
 106       return;
 107 
 108     case T_CHAR:
 109     case T_SHORT:
 110       switch (src_type) {
 111         case T_INT:
 112           if (dst_type == T_CHAR) {
 113             z_llghr(dst, src);
 114           } else {
 115             z_lghr(dst, src);
 116           }
 117           break;
 118         default:
 119           ShouldNotReachHere();
 120       }
 121       return;
 122 
 123     case T_INT:
 124       switch (src_type) {
 125         case T_BOOLEAN:
 126         case T_BYTE:
 127         case T_CHAR:
 128         case T_SHORT:
 129         case T_INT:
 130         case T_LONG:
 131         case T_OBJECT:
 132         case T_ARRAY:
 133         case T_VOID:
 134         case T_ADDRESS:
 135           lr_if_needed(dst, src);
 136           // llgfr_if_needed(dst, src);  // zero-extend (in case we need to find a bug).
 137           return;
 138 
 139         default:
 140           assert(false, &quot;non-integer src type&quot;);
 141           return;
 142       }
 143     case T_LONG:
 144       switch (src_type) {
 145         case T_BOOLEAN:
 146         case T_BYTE:
 147         case T_CHAR:
 148         case T_SHORT:
 149         case T_INT:
 150           z_lgfr(dst, src); // sign extension
 151           return;
 152 
 153         case T_LONG:
 154         case T_OBJECT:
 155         case T_ARRAY:
 156         case T_VOID:
 157         case T_ADDRESS:
 158           lgr_if_needed(dst, src);
 159           return;
 160 
 161         default:
 162           assert(false, &quot;non-integer src type&quot;);
 163           return;
 164       }
 165       return;
 166     case T_OBJECT:
 167     case T_ARRAY:
 168     case T_VOID:
 169     case T_ADDRESS:
 170       switch (src_type) {
 171         // These types don&#39;t make sense to be converted to pointers:
 172         //      case T_BOOLEAN:
 173         //      case T_BYTE:
 174         //      case T_CHAR:
 175         //      case T_SHORT:
 176 
 177         case T_INT:
 178           z_llgfr(dst, src); // zero extension
 179           return;
 180 
 181         case T_LONG:
 182         case T_OBJECT:
 183         case T_ARRAY:
 184         case T_VOID:
 185         case T_ADDRESS:
 186           lgr_if_needed(dst, src);
 187           return;
 188 
 189         default:
 190           assert(false, &quot;non-integer src type&quot;);
 191           return;
 192       }
 193       return;
 194     default:
 195       assert(false, &quot;non-integer dst type&quot;);
 196       return;
 197   }
 198 }
 199 
 200 // Move float register if destination and source are different.
 201 void MacroAssembler::move_freg_if_needed(FloatRegister dst, BasicType dst_type,
 202                                          FloatRegister src, BasicType src_type) {
 203   assert((dst_type == T_FLOAT) || (dst_type == T_DOUBLE), &quot;use move_reg for int types&quot;);
 204   assert((src_type == T_FLOAT) || (src_type == T_DOUBLE), &quot;use move_reg for int types&quot;);
 205   if (dst_type == src_type) {
 206     ldr_if_needed(dst, src); // Just move all 64 bits.
 207   } else {
 208     switch (dst_type) {
 209       case T_FLOAT:
 210         assert(src_type == T_DOUBLE, &quot;invalid float type combination&quot;);
 211         z_ledbr(dst, src);
 212         return;
 213       case T_DOUBLE:
 214         assert(src_type == T_FLOAT, &quot;invalid float type combination&quot;);
 215         z_ldebr(dst, src);
 216         return;
 217       default:
 218         assert(false, &quot;non-float dst type&quot;);
 219         return;
 220     }
 221   }
 222 }
 223 
 224 // Optimized emitter for reg to mem operations.
 225 // Uses modern instructions if running on modern hardware, classic instructions
 226 // otherwise. Prefers (usually shorter) classic instructions if applicable.
 227 // Data register (reg) cannot be used as work register.
 228 //
 229 // Don&#39;t rely on register locking, instead pass a scratch register (Z_R0 by default).
 230 // CAUTION! Passing registers &gt;= Z_R2 may produce bad results on old CPUs!
 231 void MacroAssembler::freg2mem_opt(FloatRegister reg,
 232                                   int64_t       disp,
 233                                   Register      index,
 234                                   Register      base,
 235                                   void (MacroAssembler::*modern) (FloatRegister, int64_t, Register, Register),
 236                                   void (MacroAssembler::*classic)(FloatRegister, int64_t, Register, Register),
 237                                   Register      scratch) {
 238   index = (index == noreg) ? Z_R0 : index;
 239   if (Displacement::is_shortDisp(disp)) {
 240     (this-&gt;*classic)(reg, disp, index, base);
 241   } else {
 242     if (Displacement::is_validDisp(disp)) {
 243       (this-&gt;*modern)(reg, disp, index, base);
 244     } else {
 245       if (scratch != Z_R0 &amp;&amp; scratch != Z_R1) {
 246         (this-&gt;*modern)(reg, disp, index, base);      // Will fail with disp out of range.
 247       } else {
 248         if (scratch != Z_R0) {   // scratch == Z_R1
 249           if ((scratch == index) || (index == base)) {
 250             (this-&gt;*modern)(reg, disp, index, base);  // Will fail with disp out of range.
 251           } else {
 252             add2reg(scratch, disp, base);
 253             (this-&gt;*classic)(reg, 0, index, scratch);
 254             if (base == scratch) {
 255               add2reg(base, -disp);  // Restore base.
 256             }
 257           }
 258         } else {   // scratch == Z_R0
 259           z_lgr(scratch, base);
 260           add2reg(base, disp);
 261           (this-&gt;*classic)(reg, 0, index, base);
 262           z_lgr(base, scratch);      // Restore base.
 263         }
 264       }
 265     }
 266   }
 267 }
 268 
 269 void MacroAssembler::freg2mem_opt(FloatRegister reg, const Address &amp;a, bool is_double) {
 270   if (is_double) {
 271     freg2mem_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_FFUN(z_stdy), CLASSIC_FFUN(z_std));
 272   } else {
 273     freg2mem_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_FFUN(z_stey), CLASSIC_FFUN(z_ste));
 274   }
 275 }
 276 
 277 // Optimized emitter for mem to reg operations.
 278 // Uses modern instructions if running on modern hardware, classic instructions
 279 // otherwise. Prefers (usually shorter) classic instructions if applicable.
 280 // data register (reg) cannot be used as work register.
 281 //
 282 // Don&#39;t rely on register locking, instead pass a scratch register (Z_R0 by default).
 283 // CAUTION! Passing registers &gt;= Z_R2 may produce bad results on old CPUs!
 284 void MacroAssembler::mem2freg_opt(FloatRegister reg,
 285                                   int64_t       disp,
 286                                   Register      index,
 287                                   Register      base,
 288                                   void (MacroAssembler::*modern) (FloatRegister, int64_t, Register, Register),
 289                                   void (MacroAssembler::*classic)(FloatRegister, int64_t, Register, Register),
 290                                   Register      scratch) {
 291   index = (index == noreg) ? Z_R0 : index;
 292   if (Displacement::is_shortDisp(disp)) {
 293     (this-&gt;*classic)(reg, disp, index, base);
 294   } else {
 295     if (Displacement::is_validDisp(disp)) {
 296       (this-&gt;*modern)(reg, disp, index, base);
 297     } else {
 298       if (scratch != Z_R0 &amp;&amp; scratch != Z_R1) {
 299         (this-&gt;*modern)(reg, disp, index, base);      // Will fail with disp out of range.
 300       } else {
 301         if (scratch != Z_R0) {   // scratch == Z_R1
 302           if ((scratch == index) || (index == base)) {
 303             (this-&gt;*modern)(reg, disp, index, base);  // Will fail with disp out of range.
 304           } else {
 305             add2reg(scratch, disp, base);
 306             (this-&gt;*classic)(reg, 0, index, scratch);
 307             if (base == scratch) {
 308               add2reg(base, -disp);  // Restore base.
 309             }
 310           }
 311         } else {   // scratch == Z_R0
 312           z_lgr(scratch, base);
 313           add2reg(base, disp);
 314           (this-&gt;*classic)(reg, 0, index, base);
 315           z_lgr(base, scratch);      // Restore base.
 316         }
 317       }
 318     }
 319   }
 320 }
 321 
 322 void MacroAssembler::mem2freg_opt(FloatRegister reg, const Address &amp;a, bool is_double) {
 323   if (is_double) {
 324     mem2freg_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_FFUN(z_ldy), CLASSIC_FFUN(z_ld));
 325   } else {
 326     mem2freg_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_FFUN(z_ley), CLASSIC_FFUN(z_le));
 327   }
 328 }
 329 
 330 // Optimized emitter for reg to mem operations.
 331 // Uses modern instructions if running on modern hardware, classic instructions
 332 // otherwise. Prefers (usually shorter) classic instructions if applicable.
 333 // Data register (reg) cannot be used as work register.
 334 //
 335 // Don&#39;t rely on register locking, instead pass a scratch register
 336 // (Z_R0 by default)
 337 // CAUTION! passing registers &gt;= Z_R2 may produce bad results on old CPUs!
 338 void MacroAssembler::reg2mem_opt(Register reg,
 339                                  int64_t  disp,
 340                                  Register index,
 341                                  Register base,
 342                                  void (MacroAssembler::*modern) (Register, int64_t, Register, Register),
 343                                  void (MacroAssembler::*classic)(Register, int64_t, Register, Register),
 344                                  Register scratch) {
 345   index = (index == noreg) ? Z_R0 : index;
 346   if (Displacement::is_shortDisp(disp)) {
 347     (this-&gt;*classic)(reg, disp, index, base);
 348   } else {
 349     if (Displacement::is_validDisp(disp)) {
 350       (this-&gt;*modern)(reg, disp, index, base);
 351     } else {
 352       if (scratch != Z_R0 &amp;&amp; scratch != Z_R1) {
 353         (this-&gt;*modern)(reg, disp, index, base);      // Will fail with disp out of range.
 354       } else {
 355         if (scratch != Z_R0) {   // scratch == Z_R1
 356           if ((scratch == index) || (index == base)) {
 357             (this-&gt;*modern)(reg, disp, index, base);  // Will fail with disp out of range.
 358           } else {
 359             add2reg(scratch, disp, base);
 360             (this-&gt;*classic)(reg, 0, index, scratch);
 361             if (base == scratch) {
 362               add2reg(base, -disp);  // Restore base.
 363             }
 364           }
 365         } else {   // scratch == Z_R0
 366           if ((scratch == reg) || (scratch == base) || (reg == base)) {
 367             (this-&gt;*modern)(reg, disp, index, base);  // Will fail with disp out of range.
 368           } else {
 369             z_lgr(scratch, base);
 370             add2reg(base, disp);
 371             (this-&gt;*classic)(reg, 0, index, base);
 372             z_lgr(base, scratch);    // Restore base.
 373           }
 374         }
 375       }
 376     }
 377   }
 378 }
 379 
 380 int MacroAssembler::reg2mem_opt(Register reg, const Address &amp;a, bool is_double) {
 381   int store_offset = offset();
 382   if (is_double) {
 383     reg2mem_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_IFUN(z_stg), CLASSIC_IFUN(z_stg));
 384   } else {
 385     reg2mem_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_IFUN(z_sty), CLASSIC_IFUN(z_st));
 386   }
 387   return store_offset;
 388 }
 389 
 390 // Optimized emitter for mem to reg operations.
 391 // Uses modern instructions if running on modern hardware, classic instructions
 392 // otherwise. Prefers (usually shorter) classic instructions if applicable.
 393 // Data register (reg) will be used as work register where possible.
 394 void MacroAssembler::mem2reg_opt(Register reg,
 395                                  int64_t  disp,
 396                                  Register index,
 397                                  Register base,
 398                                  void (MacroAssembler::*modern) (Register, int64_t, Register, Register),
 399                                  void (MacroAssembler::*classic)(Register, int64_t, Register, Register)) {
 400   index = (index == noreg) ? Z_R0 : index;
 401   if (Displacement::is_shortDisp(disp)) {
 402     (this-&gt;*classic)(reg, disp, index, base);
 403   } else {
 404     if (Displacement::is_validDisp(disp)) {
 405       (this-&gt;*modern)(reg, disp, index, base);
 406     } else {
 407       if ((reg == index) &amp;&amp; (reg == base)) {
 408         z_sllg(reg, reg, 1);
 409         add2reg(reg, disp);
 410         (this-&gt;*classic)(reg, 0, noreg, reg);
 411       } else if ((reg == index) &amp;&amp; (reg != Z_R0)) {
 412         add2reg(reg, disp);
 413         (this-&gt;*classic)(reg, 0, reg, base);
 414       } else if (reg == base) {
 415         add2reg(reg, disp);
 416         (this-&gt;*classic)(reg, 0, index, reg);
 417       } else if (reg != Z_R0) {
 418         add2reg(reg, disp, base);
 419         (this-&gt;*classic)(reg, 0, index, reg);
 420       } else { // reg == Z_R0 &amp;&amp; reg != base here
 421         add2reg(base, disp);
 422         (this-&gt;*classic)(reg, 0, index, base);
 423         add2reg(base, -disp);
 424       }
 425     }
 426   }
 427 }
 428 
 429 void MacroAssembler::mem2reg_opt(Register reg, const Address &amp;a, bool is_double) {
 430   if (is_double) {
 431     z_lg(reg, a);
 432   } else {
 433     mem2reg_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_IFUN(z_ly), CLASSIC_IFUN(z_l));
 434   }
 435 }
 436 
 437 void MacroAssembler::mem2reg_signed_opt(Register reg, const Address &amp;a) {
 438   mem2reg_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_IFUN(z_lgf), CLASSIC_IFUN(z_lgf));
 439 }
 440 
 441 void MacroAssembler::and_imm(Register r, long mask,
 442                              Register tmp /* = Z_R0 */,
 443                              bool wide    /* = false */) {
 444   assert(wide || Immediate::is_simm32(mask), &quot;mask value too large&quot;);
 445 
 446   if (!wide) {
 447     z_nilf(r, mask);
 448     return;
 449   }
 450 
 451   assert(r != tmp, &quot; need a different temporary register !&quot;);
 452   load_const_optimized(tmp, mask);
 453   z_ngr(r, tmp);
 454 }
 455 
 456 // Calculate the 1&#39;s complement.
 457 // Note: The condition code is neither preserved nor correctly set by this code!!!
 458 // Note: (wide == false) does not protect the high order half of the target register
 459 //       from alteration. It only serves as optimization hint for 32-bit results.
 460 void MacroAssembler::not_(Register r1, Register r2, bool wide) {
 461 
 462   if ((r2 == noreg) || (r2 == r1)) { // Calc 1&#39;s complement in place.
 463     z_xilf(r1, -1);
 464     if (wide) {
 465       z_xihf(r1, -1);
 466     }
 467   } else { // Distinct src and dst registers.
 468     load_const_optimized(r1, -1);
 469     z_xgr(r1, r2);
 470   }
 471 }
 472 
 473 unsigned long MacroAssembler::create_mask(int lBitPos, int rBitPos) {
 474   assert(lBitPos &gt;=  0,      &quot;zero is  leftmost bit position&quot;);
 475   assert(rBitPos &lt;= 63,      &quot;63   is rightmost bit position&quot;);
 476   assert(lBitPos &lt;= rBitPos, &quot;inverted selection interval&quot;);
 477   return (lBitPos == 0 ? (unsigned long)(-1L) : ((1UL&lt;&lt;(63-lBitPos+1))-1)) &amp; (~((1UL&lt;&lt;(63-rBitPos))-1));
 478 }
 479 
 480 // Helper function for the &quot;Rotate_then_&lt;logicalOP&gt;&quot; emitters.
 481 // Rotate src, then mask register contents such that only bits in range survive.
 482 // For oneBits == false, all bits not in range are set to 0. Useful for deleting all bits outside range.
 483 // For oneBits == true,  all bits not in range are set to 1. Useful for preserving all bits outside range.
 484 // The caller must ensure that the selected range only contains bits with defined value.
 485 void MacroAssembler::rotate_then_mask(Register dst, Register src, int lBitPos, int rBitPos,
 486                                       int nRotate, bool src32bit, bool dst32bit, bool oneBits) {
 487   assert(!(dst32bit &amp;&amp; lBitPos &lt; 32), &quot;selection interval out of range for int destination&quot;);
 488   bool sll4rll = (nRotate &gt;= 0) &amp;&amp; (nRotate &lt;= (63-rBitPos)); // Substitute SLL(G) for RLL(G).
 489   bool srl4rll = (nRotate &lt;  0) &amp;&amp; (-nRotate &lt;= lBitPos);     // Substitute SRL(G) for RLL(G).
 490   //  Pre-determine which parts of dst will be zero after shift/rotate.
 491   bool llZero  =  sll4rll &amp;&amp; (nRotate &gt;= 16);
 492   bool lhZero  = (sll4rll &amp;&amp; (nRotate &gt;= 32)) || (srl4rll &amp;&amp; (nRotate &lt;= -48));
 493   bool lfZero  = llZero &amp;&amp; lhZero;
 494   bool hlZero  = (sll4rll &amp;&amp; (nRotate &gt;= 48)) || (srl4rll &amp;&amp; (nRotate &lt;= -32));
 495   bool hhZero  =                                 (srl4rll &amp;&amp; (nRotate &lt;= -16));
 496   bool hfZero  = hlZero &amp;&amp; hhZero;
 497 
 498   // rotate then mask src operand.
 499   // if oneBits == true,  all bits outside selected range are 1s.
 500   // if oneBits == false, all bits outside selected range are 0s.
 501   if (src32bit) {   // There might be garbage in the upper 32 bits which will get masked away.
 502     if (dst32bit) {
 503       z_rll(dst, src, nRotate);   // Copy and rotate, upper half of reg remains undisturbed.
 504     } else {
 505       if      (sll4rll) { z_sllg(dst, src,  nRotate); }
 506       else if (srl4rll) { z_srlg(dst, src, -nRotate); }
 507       else              { z_rllg(dst, src,  nRotate); }
 508     }
 509   } else {
 510     if      (sll4rll) { z_sllg(dst, src,  nRotate); }
 511     else if (srl4rll) { z_srlg(dst, src, -nRotate); }
 512     else              { z_rllg(dst, src,  nRotate); }
 513   }
 514 
 515   unsigned long  range_mask    = create_mask(lBitPos, rBitPos);
 516   unsigned int   range_mask_h  = (unsigned int)(range_mask &gt;&gt; 32);
 517   unsigned int   range_mask_l  = (unsigned int)range_mask;
 518   unsigned short range_mask_hh = (unsigned short)(range_mask &gt;&gt; 48);
 519   unsigned short range_mask_hl = (unsigned short)(range_mask &gt;&gt; 32);
 520   unsigned short range_mask_lh = (unsigned short)(range_mask &gt;&gt; 16);
 521   unsigned short range_mask_ll = (unsigned short)range_mask;
 522   // Works for z9 and newer H/W.
 523   if (oneBits) {
 524     if ((~range_mask_l) != 0)                { z_oilf(dst, ~range_mask_l); } // All bits outside range become 1s.
 525     if (((~range_mask_h) != 0) &amp;&amp; !dst32bit) { z_oihf(dst, ~range_mask_h); }
 526   } else {
 527     // All bits outside range become 0s
 528     if (((~range_mask_l) != 0) &amp;&amp;              !lfZero) {
 529       z_nilf(dst, range_mask_l);
 530     }
 531     if (((~range_mask_h) != 0) &amp;&amp; !dst32bit &amp;&amp; !hfZero) {
 532       z_nihf(dst, range_mask_h);
 533     }
 534   }
 535 }
 536 
 537 // Rotate src, then insert selected range from rotated src into dst.
 538 // Clear dst before, if requested.
 539 void MacroAssembler::rotate_then_insert(Register dst, Register src, int lBitPos, int rBitPos,
 540                                         int nRotate, bool clear_dst) {
 541   // This version does not depend on src being zero-extended int2long.
 542   nRotate &amp;= 0x003f;                                       // For risbg, pretend it&#39;s an unsigned value.
 543   z_risbg(dst, src, lBitPos, rBitPos, nRotate, clear_dst); // Rotate, then insert selected, clear the rest.
 544 }
 545 
 546 // Rotate src, then and selected range from rotated src into dst.
 547 // Set condition code only if so requested. Otherwise it is unpredictable.
 548 // See performance note in macroAssembler_s390.hpp for important information.
 549 void MacroAssembler::rotate_then_and(Register dst, Register src, int lBitPos, int rBitPos,
 550                                      int nRotate, bool test_only) {
 551   guarantee(!test_only, &quot;Emitter not fit for test_only instruction variant.&quot;);
 552   // This version does not depend on src being zero-extended int2long.
 553   nRotate &amp;= 0x003f;                                       // For risbg, pretend it&#39;s an unsigned value.
 554   z_rxsbg(dst, src, lBitPos, rBitPos, nRotate, test_only); // Rotate, then xor selected.
 555 }
 556 
 557 // Rotate src, then or selected range from rotated src into dst.
 558 // Set condition code only if so requested. Otherwise it is unpredictable.
 559 // See performance note in macroAssembler_s390.hpp for important information.
 560 void MacroAssembler::rotate_then_or(Register dst, Register src,  int  lBitPos,  int  rBitPos,
 561                                     int nRotate, bool test_only) {
 562   guarantee(!test_only, &quot;Emitter not fit for test_only instruction variant.&quot;);
 563   // This version does not depend on src being zero-extended int2long.
 564   nRotate &amp;= 0x003f;                                       // For risbg, pretend it&#39;s an unsigned value.
 565   z_rosbg(dst, src, lBitPos, rBitPos, nRotate, test_only); // Rotate, then xor selected.
 566 }
 567 
 568 // Rotate src, then xor selected range from rotated src into dst.
 569 // Set condition code only if so requested. Otherwise it is unpredictable.
 570 // See performance note in macroAssembler_s390.hpp for important information.
 571 void MacroAssembler::rotate_then_xor(Register dst, Register src,  int  lBitPos,  int  rBitPos,
 572                                      int nRotate, bool test_only) {
 573   guarantee(!test_only, &quot;Emitter not fit for test_only instruction variant.&quot;);
 574     // This version does not depend on src being zero-extended int2long.
 575   nRotate &amp;= 0x003f;                                       // For risbg, pretend it&#39;s an unsigned value.
 576   z_rxsbg(dst, src, lBitPos, rBitPos, nRotate, test_only); // Rotate, then xor selected.
 577 }
 578 
 579 void MacroAssembler::add64(Register r1, RegisterOrConstant inc) {
 580   if (inc.is_register()) {
 581     z_agr(r1, inc.as_register());
 582   } else { // constant
 583     intptr_t imm = inc.as_constant();
 584     add2reg(r1, imm);
 585   }
 586 }
 587 // Helper function to multiply the 64bit contents of a register by a 16bit constant.
 588 // The optimization tries to avoid the mghi instruction, since it uses the FPU for
 589 // calculation and is thus rather slow.
 590 //
 591 // There is no handling for special cases, e.g. cval==0 or cval==1.
 592 //
 593 // Returns len of generated code block.
 594 unsigned int MacroAssembler::mul_reg64_const16(Register rval, Register work, int cval) {
 595   int block_start = offset();
 596 
 597   bool sign_flip = cval &lt; 0;
 598   cval = sign_flip ? -cval : cval;
 599 
 600   BLOCK_COMMENT(&quot;Reg64*Con16 {&quot;);
 601 
 602   int bit1 = cval &amp; -cval;
 603   if (bit1 == cval) {
 604     z_sllg(rval, rval, exact_log2(bit1));
 605     if (sign_flip) { z_lcgr(rval, rval); }
 606   } else {
 607     int bit2 = (cval-bit1) &amp; -(cval-bit1);
 608     if ((bit1+bit2) == cval) {
 609       z_sllg(work, rval, exact_log2(bit1));
 610       z_sllg(rval, rval, exact_log2(bit2));
 611       z_agr(rval, work);
 612       if (sign_flip) { z_lcgr(rval, rval); }
 613     } else {
 614       if (sign_flip) { z_mghi(rval, -cval); }
 615       else           { z_mghi(rval,  cval); }
 616     }
 617   }
 618   BLOCK_COMMENT(&quot;} Reg64*Con16&quot;);
 619 
 620   int block_end = offset();
 621   return block_end - block_start;
 622 }
 623 
 624 // Generic operation r1 := r2 + imm.
 625 //
 626 // Should produce the best code for each supported CPU version.
 627 // r2 == noreg yields r1 := r1 + imm
 628 // imm == 0 emits either no instruction or r1 := r2 !
 629 // NOTES: 1) Don&#39;t use this function where fixed sized
 630 //           instruction sequences are required!!!
 631 //        2) Don&#39;t use this function if condition code
 632 //           setting is required!
 633 //        3) Despite being declared as int64_t, the parameter imm
 634 //           must be a simm_32 value (= signed 32-bit integer).
 635 void MacroAssembler::add2reg(Register r1, int64_t imm, Register r2) {
 636   assert(Immediate::is_simm32(imm), &quot;probably an implicit conversion went wrong&quot;);
 637 
 638   if (r2 == noreg) { r2 = r1; }
 639 
 640   // Handle special case imm == 0.
 641   if (imm == 0) {
 642     lgr_if_needed(r1, r2);
 643     // Nothing else to do.
 644     return;
 645   }
 646 
 647   if (!PreferLAoverADD || (r2 == Z_R0)) {
 648     bool distinctOpnds = VM_Version::has_DistinctOpnds();
 649 
 650     // Can we encode imm in 16 bits signed?
 651     if (Immediate::is_simm16(imm)) {
 652       if (r1 == r2) {
 653         z_aghi(r1, imm);
 654         return;
 655       }
 656       if (distinctOpnds) {
 657         z_aghik(r1, r2, imm);
 658         return;
 659       }
 660       z_lgr(r1, r2);
 661       z_aghi(r1, imm);
 662       return;
 663     }
 664   } else {
 665     // Can we encode imm in 12 bits unsigned?
 666     if (Displacement::is_shortDisp(imm)) {
 667       z_la(r1, imm, r2);
 668       return;
 669     }
 670     // Can we encode imm in 20 bits signed?
 671     if (Displacement::is_validDisp(imm)) {
 672       // Always use LAY instruction, so we don&#39;t need the tmp register.
 673       z_lay(r1, imm, r2);
 674       return;
 675     }
 676 
 677   }
 678 
 679   // Can handle it (all possible values) with long immediates.
 680   lgr_if_needed(r1, r2);
 681   z_agfi(r1, imm);
 682 }
 683 
 684 // Generic operation r := b + x + d
 685 //
 686 // Addition of several operands with address generation semantics - sort of:
 687 //  - no restriction on the registers. Any register will do for any operand.
 688 //  - x == noreg: operand will be disregarded.
 689 //  - b == noreg: will use (contents of) result reg as operand (r := r + d).
 690 //  - x == Z_R0:  just disregard
 691 //  - b == Z_R0:  use as operand. This is not address generation semantics!!!
 692 //
 693 // The same restrictions as on add2reg() are valid!!!
 694 void MacroAssembler::add2reg_with_index(Register r, int64_t d, Register x, Register b) {
 695   assert(Immediate::is_simm32(d), &quot;probably an implicit conversion went wrong&quot;);
 696 
 697   if (x == noreg) { x = Z_R0; }
 698   if (b == noreg) { b = r; }
 699 
 700   // Handle special case x == R0.
 701   if (x == Z_R0) {
 702     // Can simply add the immediate value to the base register.
 703     add2reg(r, d, b);
 704     return;
 705   }
 706 
 707   if (!PreferLAoverADD || (b == Z_R0)) {
 708     bool distinctOpnds = VM_Version::has_DistinctOpnds();
 709     // Handle special case d == 0.
 710     if (d == 0) {
 711       if (b == x)        { z_sllg(r, b, 1); return; }
 712       if (r == x)        { z_agr(r, b);     return; }
 713       if (r == b)        { z_agr(r, x);     return; }
 714       if (distinctOpnds) { z_agrk(r, x, b); return; }
 715       z_lgr(r, b);
 716       z_agr(r, x);
 717     } else {
 718       if (x == b)             { z_sllg(r, x, 1); }
 719       else if (r == x)        { z_agr(r, b); }
 720       else if (r == b)        { z_agr(r, x); }
 721       else if (distinctOpnds) { z_agrk(r, x, b); }
 722       else {
 723         z_lgr(r, b);
 724         z_agr(r, x);
 725       }
 726       add2reg(r, d);
 727     }
 728   } else {
 729     // Can we encode imm in 12 bits unsigned?
 730     if (Displacement::is_shortDisp(d)) {
 731       z_la(r, d, x, b);
 732       return;
 733     }
 734     // Can we encode imm in 20 bits signed?
 735     if (Displacement::is_validDisp(d)) {
 736       z_lay(r, d, x, b);
 737       return;
 738     }
 739     z_la(r, 0, x, b);
 740     add2reg(r, d);
 741   }
 742 }
 743 
 744 // Generic emitter (32bit) for direct memory increment.
 745 // For optimal code, do not specify Z_R0 as temp register.
 746 void MacroAssembler::add2mem_32(const Address &amp;a, int64_t imm, Register tmp) {
 747   if (VM_Version::has_MemWithImmALUOps() &amp;&amp; Immediate::is_simm8(imm)) {
 748     z_asi(a, imm);
 749   } else {
 750     z_lgf(tmp, a);
 751     add2reg(tmp, imm);
 752     z_st(tmp, a);
 753   }
 754 }
 755 
 756 void MacroAssembler::add2mem_64(const Address &amp;a, int64_t imm, Register tmp) {
 757   if (VM_Version::has_MemWithImmALUOps() &amp;&amp; Immediate::is_simm8(imm)) {
 758     z_agsi(a, imm);
 759   } else {
 760     z_lg(tmp, a);
 761     add2reg(tmp, imm);
 762     z_stg(tmp, a);
 763   }
 764 }
 765 
 766 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed) {
 767   switch (size_in_bytes) {
 768     case  8: z_lg(dst, src); break;
 769     case  4: is_signed ? z_lgf(dst, src) : z_llgf(dst, src); break;
 770     case  2: is_signed ? z_lgh(dst, src) : z_llgh(dst, src); break;
 771     case  1: is_signed ? z_lgb(dst, src) : z_llgc(dst, src); break;
 772     default: ShouldNotReachHere();
 773   }
 774 }
 775 
 776 void MacroAssembler::store_sized_value(Register src, Address dst, size_t size_in_bytes) {
 777   switch (size_in_bytes) {
 778     case  8: z_stg(src, dst); break;
 779     case  4: z_st(src, dst); break;
 780     case  2: z_sth(src, dst); break;
 781     case  1: z_stc(src, dst); break;
 782     default: ShouldNotReachHere();
 783   }
 784 }
 785 
 786 // Split a si20 offset (20bit, signed) into an ui12 offset (12bit, unsigned) and
 787 // a high-order summand in register tmp.
 788 //
 789 // return value: &lt;  0: No split required, si20 actually has property uimm12.
 790 //               &gt;= 0: Split performed. Use return value as uimm12 displacement and
 791 //                     tmp as index register.
 792 int MacroAssembler::split_largeoffset(int64_t si20_offset, Register tmp, bool fixed_codelen, bool accumulate) {
 793   assert(Immediate::is_simm20(si20_offset), &quot;sanity&quot;);
 794   int lg_off = (int)si20_offset &amp;  0x0fff; // Punch out low-order 12 bits, always positive.
 795   int ll_off = (int)si20_offset &amp; ~0x0fff; // Force low-order 12 bits to zero.
 796   assert((Displacement::is_shortDisp(si20_offset) &amp;&amp; (ll_off == 0)) ||
 797          !Displacement::is_shortDisp(si20_offset), &quot;unexpected offset values&quot;);
 798   assert((lg_off+ll_off) == si20_offset, &quot;offset splitup error&quot;);
 799 
 800   Register work = accumulate? Z_R0 : tmp;
 801 
 802   if (fixed_codelen) {          // Len of code = 10 = 4 + 6.
 803     z_lghi(work, ll_off&gt;&gt;12);   // Implicit sign extension.
 804     z_slag(work, work, 12);
 805   } else {                      // Len of code = 0..10.
 806     if (ll_off == 0) { return -1; }
 807     // ll_off has 8 significant bits (at most) plus sign.
 808     if ((ll_off &amp; 0x0000f000) == 0) {    // Non-zero bits only in upper halfbyte.
 809       z_llilh(work, ll_off &gt;&gt; 16);
 810       if (ll_off &lt; 0) {                  // Sign-extension required.
 811         z_lgfr(work, work);
 812       }
 813     } else {
 814       if ((ll_off &amp; 0x000f0000) == 0) {  // Non-zero bits only in lower halfbyte.
 815         z_llill(work, ll_off);
 816       } else {                           // Non-zero bits in both halfbytes.
 817         z_lghi(work, ll_off&gt;&gt;12);        // Implicit sign extension.
 818         z_slag(work, work, 12);
 819       }
 820     }
 821   }
 822   if (accumulate) { z_algr(tmp, work); } // len of code += 4
 823   return lg_off;
 824 }
 825 
 826 void MacroAssembler::load_float_largeoffset(FloatRegister t, int64_t si20, Register a, Register tmp) {
 827   if (Displacement::is_validDisp(si20)) {
 828     z_ley(t, si20, a);
 829   } else {
 830     // Fixed_codelen = true is a simple way to ensure that the size of load_float_largeoffset
 831     // does not depend on si20 (scratch buffer emit size == code buffer emit size for constant
 832     // pool loads).
 833     bool accumulate    = true;
 834     bool fixed_codelen = true;
 835     Register work;
 836 
 837     if (fixed_codelen) {
 838       z_lgr(tmp, a);  // Lgr_if_needed not applicable due to fixed_codelen.
 839     } else {
 840       accumulate = (a == tmp);
 841     }
 842     work = tmp;
 843 
 844     int disp12 = split_largeoffset(si20, work, fixed_codelen, accumulate);
 845     if (disp12 &lt; 0) {
 846       z_le(t, si20, work);
 847     } else {
 848       if (accumulate) {
 849         z_le(t, disp12, work);
 850       } else {
 851         z_le(t, disp12, work, a);
 852       }
 853     }
 854   }
 855 }
 856 
 857 void MacroAssembler::load_double_largeoffset(FloatRegister t, int64_t si20, Register a, Register tmp) {
 858   if (Displacement::is_validDisp(si20)) {
 859     z_ldy(t, si20, a);
 860   } else {
 861     // Fixed_codelen = true is a simple way to ensure that the size of load_double_largeoffset
 862     // does not depend on si20 (scratch buffer emit size == code buffer emit size for constant
 863     // pool loads).
 864     bool accumulate    = true;
 865     bool fixed_codelen = true;
 866     Register work;
 867 
 868     if (fixed_codelen) {
 869       z_lgr(tmp, a);  // Lgr_if_needed not applicable due to fixed_codelen.
 870     } else {
 871       accumulate = (a == tmp);
 872     }
 873     work = tmp;
 874 
 875     int disp12 = split_largeoffset(si20, work, fixed_codelen, accumulate);
 876     if (disp12 &lt; 0) {
 877       z_ld(t, si20, work);
 878     } else {
 879       if (accumulate) {
 880         z_ld(t, disp12, work);
 881       } else {
 882         z_ld(t, disp12, work, a);
 883       }
 884     }
 885   }
 886 }
 887 
 888 // PCrelative TOC access.
 889 // Returns distance (in bytes) from current position to start of consts section.
 890 // Returns 0 (zero) if no consts section exists or if it has size zero.
 891 long MacroAssembler::toc_distance() {
 892   CodeSection* cs = code()-&gt;consts();
 893   return (long)((cs != NULL) ? cs-&gt;start()-pc() : 0);
 894 }
 895 
 896 // Implementation on x86/sparc assumes that constant and instruction section are
 897 // adjacent, but this doesn&#39;t hold. Two special situations may occur, that we must
 898 // be able to handle:
 899 //   1. const section may be located apart from the inst section.
 900 //   2. const section may be empty
 901 // In both cases, we use the const section&#39;s start address to compute the &quot;TOC&quot;,
 902 // this seems to occur only temporarily; in the final step we always seem to end up
 903 // with the pc-relatice variant.
 904 //
 905 // PC-relative offset could be +/-2**32 -&gt; use long for disp
 906 // Furthermore: makes no sense to have special code for
 907 // adjacent const and inst sections.
 908 void MacroAssembler::load_toc(Register Rtoc) {
 909   // Simply use distance from start of const section (should be patched in the end).
 910   long disp = toc_distance();
 911 
 912   RelocationHolder rspec = internal_word_Relocation::spec(pc() + disp);
 913   relocate(rspec);
 914   z_larl(Rtoc, RelAddr::pcrel_off32(disp));  // Offset is in halfwords.
 915 }
 916 
 917 // PCrelative TOC access.
 918 // Load from anywhere pcrelative (with relocation of load instr)
 919 void MacroAssembler::load_long_pcrelative(Register Rdst, address dataLocation) {
 920   address          pc             = this-&gt;pc();
 921   ptrdiff_t        total_distance = dataLocation - pc;
 922   RelocationHolder rspec          = internal_word_Relocation::spec(dataLocation);
 923 
 924   assert((total_distance &amp; 0x01L) == 0, &quot;halfword alignment is mandatory&quot;);
 925   assert(total_distance != 0, &quot;sanity&quot;);
 926 
 927   // Some extra safety net.
 928   if (!RelAddr::is_in_range_of_RelAddr32(total_distance)) {
 929     guarantee(RelAddr::is_in_range_of_RelAddr32(total_distance), &quot;load_long_pcrelative can&#39;t handle distance &quot; INTPTR_FORMAT, total_distance);
 930   }
 931 
 932   (this)-&gt;relocate(rspec, relocInfo::pcrel_addr_format);
 933   z_lgrl(Rdst, RelAddr::pcrel_off32(total_distance));
 934 }
 935 
 936 
 937 // PCrelative TOC access.
 938 // Load from anywhere pcrelative (with relocation of load instr)
 939 // loaded addr has to be relocated when added to constant pool.
 940 void MacroAssembler::load_addr_pcrelative(Register Rdst, address addrLocation) {
 941   address          pc             = this-&gt;pc();
 942   ptrdiff_t        total_distance = addrLocation - pc;
 943   RelocationHolder rspec          = internal_word_Relocation::spec(addrLocation);
 944 
 945   assert((total_distance &amp; 0x01L) == 0, &quot;halfword alignment is mandatory&quot;);
 946 
 947   // Some extra safety net.
 948   if (!RelAddr::is_in_range_of_RelAddr32(total_distance)) {
 949     guarantee(RelAddr::is_in_range_of_RelAddr32(total_distance), &quot;load_long_pcrelative can&#39;t handle distance &quot; INTPTR_FORMAT, total_distance);
 950   }
 951 
 952   (this)-&gt;relocate(rspec, relocInfo::pcrel_addr_format);
 953   z_lgrl(Rdst, RelAddr::pcrel_off32(total_distance));
 954 }
 955 
 956 // Generic operation: load a value from memory and test.
 957 // CondCode indicates the sign (&lt;0, ==0, &gt;0) of the loaded value.
 958 void MacroAssembler::load_and_test_byte(Register dst, const Address &amp;a) {
 959   z_lb(dst, a);
 960   z_ltr(dst, dst);
 961 }
 962 
 963 void MacroAssembler::load_and_test_short(Register dst, const Address &amp;a) {
 964   int64_t disp = a.disp20();
 965   if (Displacement::is_shortDisp(disp)) {
 966     z_lh(dst, a);
 967   } else if (Displacement::is_longDisp(disp)) {
 968     z_lhy(dst, a);
 969   } else {
 970     guarantee(false, &quot;displacement out of range&quot;);
 971   }
 972   z_ltr(dst, dst);
 973 }
 974 
 975 void MacroAssembler::load_and_test_int(Register dst, const Address &amp;a) {
 976   z_lt(dst, a);
 977 }
 978 
 979 void MacroAssembler::load_and_test_int2long(Register dst, const Address &amp;a) {
 980   z_ltgf(dst, a);
 981 }
 982 
 983 void MacroAssembler::load_and_test_long(Register dst, const Address &amp;a) {
 984   z_ltg(dst, a);
 985 }
 986 
 987 // Test a bit in memory.
 988 void MacroAssembler::testbit(const Address &amp;a, unsigned int bit) {
 989   assert(a.index() == noreg, &quot;no index reg allowed in testbit&quot;);
 990   if (bit &lt;= 7) {
 991     z_tm(a.disp() + 3, a.base(), 1 &lt;&lt; bit);
 992   } else if (bit &lt;= 15) {
 993     z_tm(a.disp() + 2, a.base(), 1 &lt;&lt; (bit - 8));
 994   } else if (bit &lt;= 23) {
 995     z_tm(a.disp() + 1, a.base(), 1 &lt;&lt; (bit - 16));
 996   } else if (bit &lt;= 31) {
 997     z_tm(a.disp() + 0, a.base(), 1 &lt;&lt; (bit - 24));
 998   } else {
 999     ShouldNotReachHere();
1000   }
1001 }
1002 
1003 // Test a bit in a register. Result is reflected in CC.
1004 void MacroAssembler::testbit(Register r, unsigned int bitPos) {
1005   if (bitPos &lt; 16) {
1006     z_tmll(r, 1U&lt;&lt;bitPos);
1007   } else if (bitPos &lt; 32) {
1008     z_tmlh(r, 1U&lt;&lt;(bitPos-16));
1009   } else if (bitPos &lt; 48) {
1010     z_tmhl(r, 1U&lt;&lt;(bitPos-32));
1011   } else if (bitPos &lt; 64) {
1012     z_tmhh(r, 1U&lt;&lt;(bitPos-48));
1013   } else {
1014     ShouldNotReachHere();
1015   }
1016 }
1017 
1018 void MacroAssembler::prefetch_read(Address a) {
1019   z_pfd(1, a.disp20(), a.indexOrR0(), a.base());
1020 }
1021 void MacroAssembler::prefetch_update(Address a) {
1022   z_pfd(2, a.disp20(), a.indexOrR0(), a.base());
1023 }
1024 
1025 // Clear a register, i.e. load const zero into reg.
1026 // Return len (in bytes) of generated instruction(s).
1027 // whole_reg: Clear 64 bits if true, 32 bits otherwise.
1028 // set_cc:    Use instruction that sets the condition code, if true.
1029 int MacroAssembler::clear_reg(Register r, bool whole_reg, bool set_cc) {
1030   unsigned int start_off = offset();
1031   if (whole_reg) {
1032     set_cc ? z_xgr(r, r) : z_laz(r, 0, Z_R0);
1033   } else {  // Only 32bit register.
1034     set_cc ? z_xr(r, r) : z_lhi(r, 0);
1035   }
1036   return offset() - start_off;
1037 }
1038 
1039 #ifdef ASSERT
1040 int MacroAssembler::preset_reg(Register r, unsigned long pattern, int pattern_len) {
1041   switch (pattern_len) {
1042     case 1:
1043       pattern = (pattern &amp; 0x000000ff)  | ((pattern &amp; 0x000000ff)&lt;&lt;8);
1044     case 2:
1045       pattern = (pattern &amp; 0x0000ffff)  | ((pattern &amp; 0x0000ffff)&lt;&lt;16);
1046     case 4:
1047       pattern = (pattern &amp; 0xffffffffL) | ((pattern &amp; 0xffffffffL)&lt;&lt;32);
1048     case 8:
1049       return load_const_optimized_rtn_len(r, pattern, true);
1050       break;
1051     default:
1052       guarantee(false, &quot;preset_reg: bad len&quot;);
1053   }
1054   return 0;
1055 }
1056 #endif
1057 
1058 // addr: Address descriptor of memory to clear index register will not be used !
1059 // size: Number of bytes to clear.
1060 //    !!! DO NOT USE THEM FOR ATOMIC MEMORY CLEARING !!!
1061 //    !!! Use store_const() instead                  !!!
1062 void MacroAssembler::clear_mem(const Address&amp; addr, unsigned size) {
1063   guarantee(size &lt;= 256, &quot;MacroAssembler::clear_mem: size too large&quot;);
1064 
1065   if (size == 1) {
1066     z_mvi(addr, 0);
1067     return;
1068   }
1069 
1070   switch (size) {
1071     case 2: z_mvhhi(addr, 0);
1072       return;
1073     case 4: z_mvhi(addr, 0);
1074       return;
1075     case 8: z_mvghi(addr, 0);
1076       return;
1077     default: ; // Fallthru to xc.
1078   }
1079 
1080   z_xc(addr, size, addr);
1081 }
1082 
1083 void MacroAssembler::align(int modulus) {
1084   while (offset() % modulus != 0) z_nop();
1085 }
1086 
1087 // Special version for non-relocateable code if required alignment
1088 // is larger than CodeEntryAlignment.
1089 void MacroAssembler::align_address(int modulus) {
1090   while ((uintptr_t)pc() % modulus != 0) z_nop();
1091 }
1092 
1093 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
1094                                          Register temp_reg,
1095                                          int64_t extra_slot_offset) {
1096   // On Z, we can have index and disp in an Address. So don&#39;t call argument_offset,
1097   // which issues an unnecessary add instruction.
1098   int stackElementSize = Interpreter::stackElementSize;
1099   int64_t offset = extra_slot_offset * stackElementSize;
1100   const Register argbase = Z_esp;
1101   if (arg_slot.is_constant()) {
1102     offset += arg_slot.as_constant() * stackElementSize;
1103     return Address(argbase, offset);
1104   }
1105   // else
1106   assert(temp_reg != noreg, &quot;must specify&quot;);
1107   assert(temp_reg != Z_ARG1, &quot;base and index are conflicting&quot;);
1108   z_sllg(temp_reg, arg_slot.as_register(), exact_log2(stackElementSize)); // tempreg = arg_slot &lt;&lt; 3
1109   return Address(argbase, temp_reg, offset);
1110 }
1111 
1112 
1113 //===================================================================
1114 //===   START   C O N S T A N T S   I N   C O D E   S T R E A M   ===
1115 //===================================================================
1116 //===            P A T CH A B L E   C O N S T A N T S             ===
1117 //===================================================================
1118 
1119 
1120 //---------------------------------------------------
1121 //  Load (patchable) constant into register
1122 //---------------------------------------------------
1123 
1124 
1125 // Load absolute address (and try to optimize).
1126 //   Note: This method is usable only for position-fixed code,
1127 //         referring to a position-fixed target location.
1128 //         If not so, relocations and patching must be used.
1129 void MacroAssembler::load_absolute_address(Register d, address addr) {
1130   assert(addr != NULL, &quot;should not happen&quot;);
1131   BLOCK_COMMENT(&quot;load_absolute_address:&quot;);
1132   if (addr == NULL) {
1133     z_larl(d, pc()); // Dummy emit for size calc.
1134     return;
1135   }
1136 
1137   if (RelAddr::is_in_range_of_RelAddr32(addr, pc())) {
1138     z_larl(d, addr);
1139     return;
1140   }
1141 
1142   load_const_optimized(d, (long)addr);
1143 }
1144 
1145 // Load a 64bit constant.
1146 // Patchable code sequence, but not atomically patchable.
1147 // Make sure to keep code size constant -&gt; no value-dependent optimizations.
1148 // Do not kill condition code.
1149 void MacroAssembler::load_const(Register t, long x) {
1150   // Note: Right shift is only cleanly defined for unsigned types
1151   //       or for signed types with nonnegative values.
1152   Assembler::z_iihf(t, (long)((unsigned long)x &gt;&gt; 32));
1153   Assembler::z_iilf(t, (long)((unsigned long)x &amp; 0xffffffffUL));
1154 }
1155 
1156 // Load a 32bit constant into a 64bit register, sign-extend or zero-extend.
1157 // Patchable code sequence, but not atomically patchable.
1158 // Make sure to keep code size constant -&gt; no value-dependent optimizations.
1159 // Do not kill condition code.
1160 void MacroAssembler::load_const_32to64(Register t, int64_t x, bool sign_extend) {
1161   if (sign_extend) { Assembler::z_lgfi(t, x); }
1162   else             { Assembler::z_llilf(t, x); }
1163 }
1164 
1165 // Load narrow oop constant, no decompression.
1166 void MacroAssembler::load_narrow_oop(Register t, narrowOop a) {
1167   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
1168   load_const_32to64(t, a, false /*sign_extend*/);
1169 }
1170 
1171 // Load narrow klass constant, compression required.
1172 void MacroAssembler::load_narrow_klass(Register t, Klass* k) {
1173   assert(UseCompressedClassPointers, &quot;must be on to call this method&quot;);
<a name="5" id="anc5"></a><span class="line-modified">1174   narrowKlass encoded_k = Klass::encode_klass(k);</span>
1175   load_const_32to64(t, encoded_k, false /*sign_extend*/);
1176 }
1177 
1178 //------------------------------------------------------
1179 //  Compare (patchable) constant with register.
1180 //------------------------------------------------------
1181 
1182 // Compare narrow oop in reg with narrow oop constant, no decompression.
1183 void MacroAssembler::compare_immediate_narrow_oop(Register oop1, narrowOop oop2) {
1184   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
1185 
1186   Assembler::z_clfi(oop1, oop2);
1187 }
1188 
1189 // Compare narrow oop in reg with narrow oop constant, no decompression.
1190 void MacroAssembler::compare_immediate_narrow_klass(Register klass1, Klass* klass2) {
1191   assert(UseCompressedClassPointers, &quot;must be on to call this method&quot;);
<a name="6" id="anc6"></a><span class="line-modified">1192   narrowKlass encoded_k = Klass::encode_klass(klass2);</span>
1193 
1194   Assembler::z_clfi(klass1, encoded_k);
1195 }
1196 
1197 //----------------------------------------------------------
1198 //  Check which kind of load_constant we have here.
1199 //----------------------------------------------------------
1200 
1201 // Detection of CPU version dependent load_const sequence.
1202 // The detection is valid only for code sequences generated by load_const,
1203 // not load_const_optimized.
1204 bool MacroAssembler::is_load_const(address a) {
1205   unsigned long inst1, inst2;
1206   unsigned int  len1,  len2;
1207 
1208   len1 = get_instruction(a, &amp;inst1);
1209   len2 = get_instruction(a + len1, &amp;inst2);
1210 
1211   return is_z_iihf(inst1) &amp;&amp; is_z_iilf(inst2);
1212 }
1213 
1214 // Detection of CPU version dependent load_const_32to64 sequence.
1215 // Mostly used for narrow oops and narrow Klass pointers.
1216 // The detection is valid only for code sequences generated by load_const_32to64.
1217 bool MacroAssembler::is_load_const_32to64(address pos) {
1218   unsigned long inst1, inst2;
1219   unsigned int len1;
1220 
1221   len1 = get_instruction(pos, &amp;inst1);
1222   return is_z_llilf(inst1);
1223 }
1224 
1225 // Detection of compare_immediate_narrow sequence.
1226 // The detection is valid only for code sequences generated by compare_immediate_narrow_oop.
1227 bool MacroAssembler::is_compare_immediate32(address pos) {
1228   return is_equal(pos, CLFI_ZOPC, RIL_MASK);
1229 }
1230 
1231 // Detection of compare_immediate_narrow sequence.
1232 // The detection is valid only for code sequences generated by compare_immediate_narrow_oop.
1233 bool MacroAssembler::is_compare_immediate_narrow_oop(address pos) {
1234   return is_compare_immediate32(pos);
1235   }
1236 
1237 // Detection of compare_immediate_narrow sequence.
1238 // The detection is valid only for code sequences generated by compare_immediate_narrow_klass.
1239 bool MacroAssembler::is_compare_immediate_narrow_klass(address pos) {
1240   return is_compare_immediate32(pos);
1241 }
1242 
1243 //-----------------------------------
1244 //  patch the load_constant
1245 //-----------------------------------
1246 
1247 // CPU-version dependend patching of load_const.
1248 void MacroAssembler::patch_const(address a, long x) {
1249   assert(is_load_const(a), &quot;not a load of a constant&quot;);
1250   // Note: Right shift is only cleanly defined for unsigned types
1251   //       or for signed types with nonnegative values.
1252   set_imm32((address)a, (long)((unsigned long)x &gt;&gt; 32));
1253   set_imm32((address)(a + 6), (long)((unsigned long)x &amp; 0xffffffffUL));
1254 }
1255 
1256 // Patching the value of CPU version dependent load_const_32to64 sequence.
1257 // The passed ptr MUST be in compressed format!
1258 int MacroAssembler::patch_load_const_32to64(address pos, int64_t np) {
1259   assert(is_load_const_32to64(pos), &quot;not a load of a narrow ptr (oop or klass)&quot;);
1260 
1261   set_imm32(pos, np);
1262   return 6;
1263 }
1264 
1265 // Patching the value of CPU version dependent compare_immediate_narrow sequence.
1266 // The passed ptr MUST be in compressed format!
1267 int MacroAssembler::patch_compare_immediate_32(address pos, int64_t np) {
1268   assert(is_compare_immediate32(pos), &quot;not a compressed ptr compare&quot;);
1269 
1270   set_imm32(pos, np);
1271   return 6;
1272 }
1273 
1274 // Patching the immediate value of CPU version dependent load_narrow_oop sequence.
1275 // The passed ptr must NOT be in compressed format!
1276 int MacroAssembler::patch_load_narrow_oop(address pos, oop o) {
1277   assert(UseCompressedOops, &quot;Can only patch compressed oops&quot;);
1278 
1279   narrowOop no = CompressedOops::encode(o);
1280   return patch_load_const_32to64(pos, no);
1281 }
1282 
1283 // Patching the immediate value of CPU version dependent load_narrow_klass sequence.
1284 // The passed ptr must NOT be in compressed format!
1285 int MacroAssembler::patch_load_narrow_klass(address pos, Klass* k) {
1286   assert(UseCompressedClassPointers, &quot;Can only patch compressed klass pointers&quot;);
1287 
<a name="7" id="anc7"></a><span class="line-modified">1288   narrowKlass nk = Klass::encode_klass(k);</span>
1289   return patch_load_const_32to64(pos, nk);
1290 }
1291 
1292 // Patching the immediate value of CPU version dependent compare_immediate_narrow_oop sequence.
1293 // The passed ptr must NOT be in compressed format!
1294 int MacroAssembler::patch_compare_immediate_narrow_oop(address pos, oop o) {
1295   assert(UseCompressedOops, &quot;Can only patch compressed oops&quot;);
1296 
1297   narrowOop no = CompressedOops::encode(o);
1298   return patch_compare_immediate_32(pos, no);
1299 }
1300 
1301 // Patching the immediate value of CPU version dependent compare_immediate_narrow_klass sequence.
1302 // The passed ptr must NOT be in compressed format!
1303 int MacroAssembler::patch_compare_immediate_narrow_klass(address pos, Klass* k) {
1304   assert(UseCompressedClassPointers, &quot;Can only patch compressed klass pointers&quot;);
1305 
<a name="8" id="anc8"></a><span class="line-modified">1306   narrowKlass nk = Klass::encode_klass(k);</span>
1307   return patch_compare_immediate_32(pos, nk);
1308 }
1309 
1310 //------------------------------------------------------------------------
1311 //  Extract the constant from a load_constant instruction stream.
1312 //------------------------------------------------------------------------
1313 
1314 // Get constant from a load_const sequence.
1315 long MacroAssembler::get_const(address a) {
1316   assert(is_load_const(a), &quot;not a load of a constant&quot;);
1317   unsigned long x;
1318   x =  (((unsigned long) (get_imm32(a,0) &amp; 0xffffffff)) &lt;&lt; 32);
1319   x |= (((unsigned long) (get_imm32(a,1) &amp; 0xffffffff)));
1320   return (long) x;
1321 }
1322 
1323 //--------------------------------------
1324 //  Store a constant in memory.
1325 //--------------------------------------
1326 
1327 // General emitter to move a constant to memory.
1328 // The store is atomic.
1329 //  o Address must be given in RS format (no index register)
1330 //  o Displacement should be 12bit unsigned for efficiency. 20bit signed also supported.
1331 //  o Constant can be 1, 2, 4, or 8 bytes, signed or unsigned.
1332 //  o Memory slot can be 1, 2, 4, or 8 bytes, signed or unsigned.
1333 //  o Memory slot must be at least as wide as constant, will assert otherwise.
1334 //  o Signed constants will sign-extend, unsigned constants will zero-extend to slot width.
1335 int MacroAssembler::store_const(const Address &amp;dest, long imm,
1336                                 unsigned int lm, unsigned int lc,
1337                                 Register scratch) {
1338   int64_t  disp = dest.disp();
1339   Register base = dest.base();
1340   assert(!dest.has_index(), &quot;not supported&quot;);
1341   assert((lm==1)||(lm==2)||(lm==4)||(lm==8), &quot;memory   length not supported&quot;);
1342   assert((lc==1)||(lc==2)||(lc==4)||(lc==8), &quot;constant length not supported&quot;);
1343   assert(lm&gt;=lc, &quot;memory slot too small&quot;);
1344   assert(lc==8 || Immediate::is_simm(imm, lc*8), &quot;const out of range&quot;);
1345   assert(Displacement::is_validDisp(disp), &quot;displacement out of range&quot;);
1346 
1347   bool is_shortDisp = Displacement::is_shortDisp(disp);
1348   int store_offset = -1;
1349 
1350   // For target len == 1 it&#39;s easy.
1351   if (lm == 1) {
1352     store_offset = offset();
1353     if (is_shortDisp) {
1354       z_mvi(disp, base, imm);
1355       return store_offset;
1356     } else {
1357       z_mviy(disp, base, imm);
1358       return store_offset;
1359     }
1360   }
1361 
1362   // All the &quot;good stuff&quot; takes an unsigned displacement.
1363   if (is_shortDisp) {
1364     // NOTE: Cannot use clear_mem for imm==0, because it is not atomic.
1365 
1366     store_offset = offset();
1367     switch (lm) {
1368       case 2:  // Lc == 1 handled correctly here, even for unsigned. Instruction does no widening.
1369         z_mvhhi(disp, base, imm);
1370         return store_offset;
1371       case 4:
1372         if (Immediate::is_simm16(imm)) {
1373           z_mvhi(disp, base, imm);
1374           return store_offset;
1375         }
1376         break;
1377       case 8:
1378         if (Immediate::is_simm16(imm)) {
1379           z_mvghi(disp, base, imm);
1380           return store_offset;
1381         }
1382         break;
1383       default:
1384         ShouldNotReachHere();
1385         break;
1386     }
1387   }
1388 
1389   //  Can&#39;t optimize, so load value and store it.
1390   guarantee(scratch != noreg, &quot; need a scratch register here !&quot;);
1391   if (imm != 0) {
1392     load_const_optimized(scratch, imm);  // Preserves CC anyway.
1393   } else {
1394     // Leave CC alone!!
1395     (void) clear_reg(scratch, true, false); // Indicate unused result.
1396   }
1397 
1398   store_offset = offset();
1399   if (is_shortDisp) {
1400     switch (lm) {
1401       case 2:
1402         z_sth(scratch, disp, Z_R0, base);
1403         return store_offset;
1404       case 4:
1405         z_st(scratch, disp, Z_R0, base);
1406         return store_offset;
1407       case 8:
1408         z_stg(scratch, disp, Z_R0, base);
1409         return store_offset;
1410       default:
1411         ShouldNotReachHere();
1412         break;
1413     }
1414   } else {
1415     switch (lm) {
1416       case 2:
1417         z_sthy(scratch, disp, Z_R0, base);
1418         return store_offset;
1419       case 4:
1420         z_sty(scratch, disp, Z_R0, base);
1421         return store_offset;
1422       case 8:
1423         z_stg(scratch, disp, Z_R0, base);
1424         return store_offset;
1425       default:
1426         ShouldNotReachHere();
1427         break;
1428     }
1429   }
1430   return -1; // should not reach here
1431 }
1432 
1433 //===================================================================
1434 //===       N O T   P A T CH A B L E   C O N S T A N T S          ===
1435 //===================================================================
1436 
1437 // Load constant x into register t with a fast instrcution sequence
1438 // depending on the bits in x. Preserves CC under all circumstances.
1439 int MacroAssembler::load_const_optimized_rtn_len(Register t, long x, bool emit) {
1440   if (x == 0) {
1441     int len;
1442     if (emit) {
1443       len = clear_reg(t, true, false);
1444     } else {
1445       len = 4;
1446     }
1447     return len;
1448   }
1449 
1450   if (Immediate::is_simm16(x)) {
1451     if (emit) { z_lghi(t, x); }
1452     return 4;
1453   }
1454 
1455   // 64 bit value: | part1 | part2 | part3 | part4 |
1456   // At least one part is not zero!
1457   // Note: Right shift is only cleanly defined for unsigned types
1458   //       or for signed types with nonnegative values.
1459   int part1 = (int)((unsigned long)x &gt;&gt; 48) &amp; 0x0000ffff;
1460   int part2 = (int)((unsigned long)x &gt;&gt; 32) &amp; 0x0000ffff;
1461   int part3 = (int)((unsigned long)x &gt;&gt; 16) &amp; 0x0000ffff;
1462   int part4 = (int)x &amp; 0x0000ffff;
1463   int part12 = (int)((unsigned long)x &gt;&gt; 32);
1464   int part34 = (int)x;
1465 
1466   // Lower word only (unsigned).
1467   if (part12 == 0) {
1468     if (part3 == 0) {
1469       if (emit) z_llill(t, part4);
1470       return 4;
1471     }
1472     if (part4 == 0) {
1473       if (emit) z_llilh(t, part3);
1474       return 4;
1475     }
1476     if (emit) z_llilf(t, part34);
1477     return 6;
1478   }
1479 
1480   // Upper word only.
1481   if (part34 == 0) {
1482     if (part1 == 0) {
1483       if (emit) z_llihl(t, part2);
1484       return 4;
1485     }
1486     if (part2 == 0) {
1487       if (emit) z_llihh(t, part1);
1488       return 4;
1489     }
1490     if (emit) z_llihf(t, part12);
1491     return 6;
1492   }
1493 
1494   // Lower word only (signed).
1495   if ((part1 == 0x0000ffff) &amp;&amp; (part2 == 0x0000ffff) &amp;&amp; ((part3 &amp; 0x00008000) != 0)) {
1496     if (emit) z_lgfi(t, part34);
1497     return 6;
1498   }
1499 
1500   int len = 0;
1501 
1502   if ((part1 == 0) || (part2 == 0)) {
1503     if (part1 == 0) {
1504       if (emit) z_llihl(t, part2);
1505       len += 4;
1506     } else {
1507       if (emit) z_llihh(t, part1);
1508       len += 4;
1509     }
1510   } else {
1511     if (emit) z_llihf(t, part12);
1512     len += 6;
1513   }
1514 
1515   if ((part3 == 0) || (part4 == 0)) {
1516     if (part3 == 0) {
1517       if (emit) z_iill(t, part4);
1518       len += 4;
1519     } else {
1520       if (emit) z_iilh(t, part3);
1521       len += 4;
1522     }
1523   } else {
1524     if (emit) z_iilf(t, part34);
1525     len += 6;
1526   }
1527   return len;
1528 }
1529 
1530 //=====================================================================
1531 //===     H I G H E R   L E V E L   B R A N C H   E M I T T E R S   ===
1532 //=====================================================================
1533 
1534 // Note: In the worst case, one of the scratch registers is destroyed!!!
1535 void MacroAssembler::compare32_and_branch(Register r1, RegisterOrConstant x2, branch_condition cond, Label&amp; lbl) {
1536   // Right operand is constant.
1537   if (x2.is_constant()) {
1538     jlong value = x2.as_constant();
1539     compare_and_branch_optimized(r1, value, cond, lbl, /*len64=*/false, /*has_sign=*/true);
1540     return;
1541   }
1542 
1543   // Right operand is in register.
1544   compare_and_branch_optimized(r1, x2.as_register(), cond, lbl, /*len64=*/false, /*has_sign=*/true);
1545 }
1546 
1547 // Note: In the worst case, one of the scratch registers is destroyed!!!
1548 void MacroAssembler::compareU32_and_branch(Register r1, RegisterOrConstant x2, branch_condition cond, Label&amp; lbl) {
1549   // Right operand is constant.
1550   if (x2.is_constant()) {
1551     jlong value = x2.as_constant();
1552     compare_and_branch_optimized(r1, value, cond, lbl, /*len64=*/false, /*has_sign=*/false);
1553     return;
1554   }
1555 
1556   // Right operand is in register.
1557   compare_and_branch_optimized(r1, x2.as_register(), cond, lbl, /*len64=*/false, /*has_sign=*/false);
1558 }
1559 
1560 // Note: In the worst case, one of the scratch registers is destroyed!!!
1561 void MacroAssembler::compare64_and_branch(Register r1, RegisterOrConstant x2, branch_condition cond, Label&amp; lbl) {
1562   // Right operand is constant.
1563   if (x2.is_constant()) {
1564     jlong value = x2.as_constant();
1565     compare_and_branch_optimized(r1, value, cond, lbl, /*len64=*/true, /*has_sign=*/true);
1566     return;
1567   }
1568 
1569   // Right operand is in register.
1570   compare_and_branch_optimized(r1, x2.as_register(), cond, lbl, /*len64=*/true, /*has_sign=*/true);
1571 }
1572 
1573 void MacroAssembler::compareU64_and_branch(Register r1, RegisterOrConstant x2, branch_condition cond, Label&amp; lbl) {
1574   // Right operand is constant.
1575   if (x2.is_constant()) {
1576     jlong value = x2.as_constant();
1577     compare_and_branch_optimized(r1, value, cond, lbl, /*len64=*/true, /*has_sign=*/false);
1578     return;
1579   }
1580 
1581   // Right operand is in register.
1582   compare_and_branch_optimized(r1, x2.as_register(), cond, lbl, /*len64=*/true, /*has_sign=*/false);
1583 }
1584 
1585 // Generate an optimal branch to the branch target.
1586 // Optimal means that a relative branch (brc or brcl) is used if the
1587 // branch distance is short enough. Loading the target address into a
1588 // register and branching via reg is used as fallback only.
1589 //
1590 // Used registers:
1591 //   Z_R1 - work reg. Holds branch target address.
1592 //          Used in fallback case only.
1593 //
1594 // This version of branch_optimized is good for cases where the target address is known
1595 // and constant, i.e. is never changed (no relocation, no patching).
1596 void MacroAssembler::branch_optimized(Assembler::branch_condition cond, address branch_addr) {
1597   address branch_origin = pc();
1598 
1599   if (RelAddr::is_in_range_of_RelAddr16(branch_addr, branch_origin)) {
1600     z_brc(cond, branch_addr);
1601   } else if (RelAddr::is_in_range_of_RelAddr32(branch_addr, branch_origin)) {
1602     z_brcl(cond, branch_addr);
1603   } else {
1604     load_const_optimized(Z_R1, branch_addr);  // CC must not get killed by load_const_optimized.
1605     z_bcr(cond, Z_R1);
1606   }
1607 }
1608 
1609 // This version of branch_optimized is good for cases where the target address
1610 // is potentially not yet known at the time the code is emitted.
1611 //
1612 // One very common case is a branch to an unbound label which is handled here.
1613 // The caller might know (or hope) that the branch distance is short enough
1614 // to be encoded in a 16bit relative address. In this case he will pass a
1615 // NearLabel branch_target.
1616 // Care must be taken with unbound labels. Each call to target(label) creates
1617 // an entry in the patch queue for that label to patch all references of the label
1618 // once it gets bound. Those recorded patch locations must be patchable. Otherwise,
1619 // an assertion fires at patch time.
1620 void MacroAssembler::branch_optimized(Assembler::branch_condition cond, Label&amp; branch_target) {
1621   if (branch_target.is_bound()) {
1622     address branch_addr = target(branch_target);
1623     branch_optimized(cond, branch_addr);
1624   } else if (branch_target.is_near()) {
1625     z_brc(cond, branch_target);  // Caller assures that the target will be in range for z_brc.
1626   } else {
1627     z_brcl(cond, branch_target); // Let&#39;s hope target is in range. Otherwise, we will abort at patch time.
1628   }
1629 }
1630 
1631 // Generate an optimal compare and branch to the branch target.
1632 // Optimal means that a relative branch (clgrj, brc or brcl) is used if the
1633 // branch distance is short enough. Loading the target address into a
1634 // register and branching via reg is used as fallback only.
1635 //
1636 // Input:
1637 //   r1 - left compare operand
1638 //   r2 - right compare operand
1639 void MacroAssembler::compare_and_branch_optimized(Register r1,
1640                                                   Register r2,
1641                                                   Assembler::branch_condition cond,
1642                                                   address  branch_addr,
1643                                                   bool     len64,
1644                                                   bool     has_sign) {
1645   unsigned int casenum = (len64?2:0)+(has_sign?0:1);
1646 
1647   address branch_origin = pc();
1648   if (VM_Version::has_CompareBranch() &amp;&amp; RelAddr::is_in_range_of_RelAddr16(branch_addr, branch_origin)) {
1649     switch (casenum) {
1650       case 0: z_crj( r1, r2, cond, branch_addr); break;
1651       case 1: z_clrj (r1, r2, cond, branch_addr); break;
1652       case 2: z_cgrj(r1, r2, cond, branch_addr); break;
1653       case 3: z_clgrj(r1, r2, cond, branch_addr); break;
1654       default: ShouldNotReachHere(); break;
1655     }
1656   } else {
1657     switch (casenum) {
1658       case 0: z_cr( r1, r2); break;
1659       case 1: z_clr(r1, r2); break;
1660       case 2: z_cgr(r1, r2); break;
1661       case 3: z_clgr(r1, r2); break;
1662       default: ShouldNotReachHere(); break;
1663     }
1664     branch_optimized(cond, branch_addr);
1665   }
1666 }
1667 
1668 // Generate an optimal compare and branch to the branch target.
1669 // Optimal means that a relative branch (clgij, brc or brcl) is used if the
1670 // branch distance is short enough. Loading the target address into a
1671 // register and branching via reg is used as fallback only.
1672 //
1673 // Input:
1674 //   r1 - left compare operand (in register)
1675 //   x2 - right compare operand (immediate)
1676 void MacroAssembler::compare_and_branch_optimized(Register r1,
1677                                                   jlong    x2,
1678                                                   Assembler::branch_condition cond,
1679                                                   Label&amp;   branch_target,
1680                                                   bool     len64,
1681                                                   bool     has_sign) {
1682   address      branch_origin = pc();
1683   bool         x2_imm8       = (has_sign &amp;&amp; Immediate::is_simm8(x2)) || (!has_sign &amp;&amp; Immediate::is_uimm8(x2));
1684   bool         is_RelAddr16  = branch_target.is_near() ||
1685                                (branch_target.is_bound() &amp;&amp;
1686                                 RelAddr::is_in_range_of_RelAddr16(target(branch_target), branch_origin));
1687   unsigned int casenum       = (len64?2:0)+(has_sign?0:1);
1688 
1689   if (VM_Version::has_CompareBranch() &amp;&amp; is_RelAddr16 &amp;&amp; x2_imm8) {
1690     switch (casenum) {
1691       case 0: z_cij( r1, x2, cond, branch_target); break;
1692       case 1: z_clij(r1, x2, cond, branch_target); break;
1693       case 2: z_cgij(r1, x2, cond, branch_target); break;
1694       case 3: z_clgij(r1, x2, cond, branch_target); break;
1695       default: ShouldNotReachHere(); break;
1696     }
1697     return;
1698   }
1699 
1700   if (x2 == 0) {
1701     switch (casenum) {
1702       case 0: z_ltr(r1, r1); break;
1703       case 1: z_ltr(r1, r1); break; // Caution: unsigned test only provides zero/notZero indication!
1704       case 2: z_ltgr(r1, r1); break;
1705       case 3: z_ltgr(r1, r1); break; // Caution: unsigned test only provides zero/notZero indication!
1706       default: ShouldNotReachHere(); break;
1707     }
1708   } else {
1709     if ((has_sign &amp;&amp; Immediate::is_simm16(x2)) || (!has_sign &amp;&amp; Immediate::is_uimm(x2, 15))) {
1710       switch (casenum) {
1711         case 0: z_chi(r1, x2); break;
1712         case 1: z_chi(r1, x2); break; // positive immediate &lt; 2**15
1713         case 2: z_cghi(r1, x2); break;
1714         case 3: z_cghi(r1, x2); break; // positive immediate &lt; 2**15
1715         default: break;
1716       }
1717     } else if ( (has_sign &amp;&amp; Immediate::is_simm32(x2)) || (!has_sign &amp;&amp; Immediate::is_uimm32(x2)) ) {
1718       switch (casenum) {
1719         case 0: z_cfi( r1, x2); break;
1720         case 1: z_clfi(r1, x2); break;
1721         case 2: z_cgfi(r1, x2); break;
1722         case 3: z_clgfi(r1, x2); break;
1723         default: ShouldNotReachHere(); break;
1724       }
1725     } else {
1726       // No instruction with immediate operand possible, so load into register.
1727       Register scratch = (r1 != Z_R0) ? Z_R0 : Z_R1;
1728       load_const_optimized(scratch, x2);
1729       switch (casenum) {
1730         case 0: z_cr( r1, scratch); break;
1731         case 1: z_clr(r1, scratch); break;
1732         case 2: z_cgr(r1, scratch); break;
1733         case 3: z_clgr(r1, scratch); break;
1734         default: ShouldNotReachHere(); break;
1735       }
1736     }
1737   }
1738   branch_optimized(cond, branch_target);
1739 }
1740 
1741 // Generate an optimal compare and branch to the branch target.
1742 // Optimal means that a relative branch (clgrj, brc or brcl) is used if the
1743 // branch distance is short enough. Loading the target address into a
1744 // register and branching via reg is used as fallback only.
1745 //
1746 // Input:
1747 //   r1 - left compare operand
1748 //   r2 - right compare operand
1749 void MacroAssembler::compare_and_branch_optimized(Register r1,
1750                                                   Register r2,
1751                                                   Assembler::branch_condition cond,
1752                                                   Label&amp;   branch_target,
1753                                                   bool     len64,
1754                                                   bool     has_sign) {
1755   unsigned int casenum = (len64 ? 2 : 0) + (has_sign ? 0 : 1);
1756 
1757   if (branch_target.is_bound()) {
1758     address branch_addr = target(branch_target);
1759     compare_and_branch_optimized(r1, r2, cond, branch_addr, len64, has_sign);
1760   } else {
1761     if (VM_Version::has_CompareBranch() &amp;&amp; branch_target.is_near()) {
1762       switch (casenum) {
1763         case 0: z_crj(  r1, r2, cond, branch_target); break;
1764         case 1: z_clrj( r1, r2, cond, branch_target); break;
1765         case 2: z_cgrj( r1, r2, cond, branch_target); break;
1766         case 3: z_clgrj(r1, r2, cond, branch_target); break;
1767         default: ShouldNotReachHere(); break;
1768       }
1769     } else {
1770       switch (casenum) {
1771         case 0: z_cr( r1, r2); break;
1772         case 1: z_clr(r1, r2); break;
1773         case 2: z_cgr(r1, r2); break;
1774         case 3: z_clgr(r1, r2); break;
1775         default: ShouldNotReachHere(); break;
1776       }
1777       branch_optimized(cond, branch_target);
1778     }
1779   }
1780 }
1781 
1782 //===========================================================================
1783 //===   END     H I G H E R   L E V E L   B R A N C H   E M I T T E R S   ===
1784 //===========================================================================
1785 
1786 AddressLiteral MacroAssembler::allocate_metadata_address(Metadata* obj) {
1787   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1788   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
1789   RelocationHolder rspec = metadata_Relocation::spec(index);
1790   return AddressLiteral((address)obj, rspec);
1791 }
1792 
1793 AddressLiteral MacroAssembler::constant_metadata_address(Metadata* obj) {
1794   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1795   int index = oop_recorder()-&gt;find_index(obj);
1796   RelocationHolder rspec = metadata_Relocation::spec(index);
1797   return AddressLiteral((address)obj, rspec);
1798 }
1799 
1800 AddressLiteral MacroAssembler::allocate_oop_address(jobject obj) {
1801   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1802   int oop_index = oop_recorder()-&gt;allocate_oop_index(obj);
1803   return AddressLiteral(address(obj), oop_Relocation::spec(oop_index));
1804 }
1805 
1806 AddressLiteral MacroAssembler::constant_oop_address(jobject obj) {
1807   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1808   int oop_index = oop_recorder()-&gt;find_index(obj);
1809   return AddressLiteral(address(obj), oop_Relocation::spec(oop_index));
1810 }
1811 
1812 // NOTE: destroys r
1813 void MacroAssembler::c2bool(Register r, Register t) {
1814   z_lcr(t, r);   // t = -r
1815   z_or(r, t);    // r = -r OR r
1816   z_srl(r, 31);  // Yields 0 if r was 0, 1 otherwise.
1817 }
1818 
1819 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
1820                                                       Register tmp,
1821                                                       int offset) {
1822   intptr_t value = *delayed_value_addr;
1823   if (value != 0) {
1824     return RegisterOrConstant(value + offset);
1825   }
1826 
1827   BLOCK_COMMENT(&quot;delayed_value {&quot;);
1828   // Load indirectly to solve generation ordering problem.
1829   load_absolute_address(tmp, (address) delayed_value_addr); // tmp = a;
1830   z_lg(tmp, 0, tmp);                   // tmp = *tmp;
1831 
1832 #ifdef ASSERT
1833   NearLabel L;
1834   compare64_and_branch(tmp, (intptr_t)0L, Assembler::bcondNotEqual, L);
1835   z_illtrap();
1836   bind(L);
1837 #endif
1838 
1839   if (offset != 0) {
1840     z_agfi(tmp, offset);               // tmp = tmp + offset;
1841   }
1842 
1843   BLOCK_COMMENT(&quot;} delayed_value&quot;);
1844   return RegisterOrConstant(tmp);
1845 }
1846 
1847 // Patch instruction `inst&#39; at offset `inst_pos&#39; to refer to `dest_pos&#39;
1848 // and return the resulting instruction.
1849 // Dest_pos and inst_pos are 32 bit only. These parms can only designate
1850 // relative positions.
1851 // Use correct argument types. Do not pre-calculate distance.
1852 unsigned long MacroAssembler::patched_branch(address dest_pos, unsigned long inst, address inst_pos) {
1853   int c = 0;
1854   unsigned long patched_inst = 0;
1855   if (is_call_pcrelative_short(inst) ||
1856       is_branch_pcrelative_short(inst) ||
1857       is_branchoncount_pcrelative_short(inst) ||
1858       is_branchonindex32_pcrelative_short(inst)) {
1859     c = 1;
1860     int m = fmask(15, 0);    // simm16(-1, 16, 32);
1861     int v = simm16(RelAddr::pcrel_off16(dest_pos, inst_pos), 16, 32);
1862     patched_inst = (inst &amp; ~m) | v;
1863   } else if (is_compareandbranch_pcrelative_short(inst)) {
1864     c = 2;
1865     long m = fmask(31, 16);  // simm16(-1, 16, 48);
1866     long v = simm16(RelAddr::pcrel_off16(dest_pos, inst_pos), 16, 48);
1867     patched_inst = (inst &amp; ~m) | v;
1868   } else if (is_branchonindex64_pcrelative_short(inst)) {
1869     c = 3;
1870     long m = fmask(31, 16);  // simm16(-1, 16, 48);
1871     long v = simm16(RelAddr::pcrel_off16(dest_pos, inst_pos), 16, 48);
1872     patched_inst = (inst &amp; ~m) | v;
1873   } else if (is_call_pcrelative_long(inst) || is_branch_pcrelative_long(inst)) {
1874     c = 4;
1875     long m = fmask(31, 0);  // simm32(-1, 16, 48);
1876     long v = simm32(RelAddr::pcrel_off32(dest_pos, inst_pos), 16, 48);
1877     patched_inst = (inst &amp; ~m) | v;
1878   } else if (is_pcrelative_long(inst)) { // These are the non-branch pc-relative instructions.
1879     c = 5;
1880     long m = fmask(31, 0);  // simm32(-1, 16, 48);
1881     long v = simm32(RelAddr::pcrel_off32(dest_pos, inst_pos), 16, 48);
1882     patched_inst = (inst &amp; ~m) | v;
1883   } else {
1884     print_dbg_msg(tty, inst, &quot;not a relative branch&quot;, 0);
1885     dump_code_range(tty, inst_pos, 32, &quot;not a pcrelative branch&quot;);
1886     ShouldNotReachHere();
1887   }
1888 
1889   long new_off = get_pcrel_offset(patched_inst);
1890   if (new_off != (dest_pos-inst_pos)) {
1891     tty-&gt;print_cr(&quot;case %d: dest_pos = %p, inst_pos = %p, disp = %ld(%12.12lx)&quot;, c, dest_pos, inst_pos, new_off, new_off);
1892     print_dbg_msg(tty, inst,         &quot;&lt;- original instruction: branch patching error&quot;, 0);
1893     print_dbg_msg(tty, patched_inst, &quot;&lt;- patched  instruction: branch patching error&quot;, 0);
1894 #ifdef LUCY_DBG
1895     VM_Version::z_SIGSEGV();
1896 #endif
1897     ShouldNotReachHere();
1898   }
1899   return patched_inst;
1900 }
1901 
1902 // Only called when binding labels (share/vm/asm/assembler.cpp)
1903 // Pass arguments as intended. Do not pre-calculate distance.
1904 void MacroAssembler::pd_patch_instruction(address branch, address target, const char* file, int line) {
1905   unsigned long stub_inst;
1906   int           inst_len = get_instruction(branch, &amp;stub_inst);
1907 
1908   set_instruction(branch, patched_branch(target, stub_inst, branch), inst_len);
1909 }
1910 
1911 
1912 // Extract relative address (aka offset).
1913 // inv_simm16 works for 4-byte instructions only.
1914 // compare and branch instructions are 6-byte and have a 16bit offset &quot;in the middle&quot;.
1915 long MacroAssembler::get_pcrel_offset(unsigned long inst) {
1916 
1917   if (MacroAssembler::is_pcrelative_short(inst)) {
1918     if (((inst&amp;0xFFFFffff00000000UL) == 0) &amp;&amp; ((inst&amp;0x00000000FFFF0000UL) != 0)) {
1919       return RelAddr::inv_pcrel_off16(inv_simm16(inst));
1920     } else {
1921       return RelAddr::inv_pcrel_off16(inv_simm16_48(inst));
1922     }
1923   }
1924 
1925   if (MacroAssembler::is_pcrelative_long(inst)) {
1926     return RelAddr::inv_pcrel_off32(inv_simm32(inst));
1927   }
1928 
1929   print_dbg_msg(tty, inst, &quot;not a pcrelative instruction&quot;, 6);
1930 #ifdef LUCY_DBG
1931   VM_Version::z_SIGSEGV();
1932 #else
1933   ShouldNotReachHere();
1934 #endif
1935   return -1;
1936 }
1937 
1938 long MacroAssembler::get_pcrel_offset(address pc) {
1939   unsigned long inst;
1940   unsigned int  len = get_instruction(pc, &amp;inst);
1941 
1942 #ifdef ASSERT
1943   long offset;
1944   if (MacroAssembler::is_pcrelative_short(inst) || MacroAssembler::is_pcrelative_long(inst)) {
1945     offset = get_pcrel_offset(inst);
1946   } else {
1947     offset = -1;
1948   }
1949 
1950   if (offset == -1) {
1951     dump_code_range(tty, pc, 32, &quot;not a pcrelative instruction&quot;);
1952 #ifdef LUCY_DBG
1953     VM_Version::z_SIGSEGV();
1954 #else
1955     ShouldNotReachHere();
1956 #endif
1957   }
1958   return offset;
1959 #else
1960   return get_pcrel_offset(inst);
1961 #endif // ASSERT
1962 }
1963 
1964 // Get target address from pc-relative instructions.
1965 address MacroAssembler::get_target_addr_pcrel(address pc) {
1966   assert(is_pcrelative_long(pc), &quot;not a pcrelative instruction&quot;);
1967   return pc + get_pcrel_offset(pc);
1968 }
1969 
1970 // Patch pc relative load address.
1971 void MacroAssembler::patch_target_addr_pcrel(address pc, address con) {
1972   unsigned long inst;
1973   // Offset is +/- 2**32 -&gt; use long.
1974   ptrdiff_t distance = con - pc;
1975 
1976   get_instruction(pc, &amp;inst);
1977 
1978   if (is_pcrelative_short(inst)) {
1979     *(short *)(pc+2) = RelAddr::pcrel_off16(con, pc);  // Instructions are at least 2-byte aligned, no test required.
1980 
1981     // Some extra safety net.
1982     if (!RelAddr::is_in_range_of_RelAddr16(distance)) {
1983       print_dbg_msg(tty, inst, &quot;distance out of range (16bit)&quot;, 4);
1984       dump_code_range(tty, pc, 32, &quot;distance out of range (16bit)&quot;);
1985       guarantee(RelAddr::is_in_range_of_RelAddr16(distance), &quot;too far away (more than +/- 2**16&quot;);
1986     }
1987     return;
1988   }
1989 
1990   if (is_pcrelative_long(inst)) {
1991     *(int *)(pc+2)   = RelAddr::pcrel_off32(con, pc);
1992 
1993     // Some Extra safety net.
1994     if (!RelAddr::is_in_range_of_RelAddr32(distance)) {
1995       print_dbg_msg(tty, inst, &quot;distance out of range (32bit)&quot;, 6);
1996       dump_code_range(tty, pc, 32, &quot;distance out of range (32bit)&quot;);
1997       guarantee(RelAddr::is_in_range_of_RelAddr32(distance), &quot;too far away (more than +/- 2**32&quot;);
1998     }
1999     return;
2000   }
2001 
2002   guarantee(false, &quot;not a pcrelative instruction to patch!&quot;);
2003 }
2004 
2005 // &quot;Current PC&quot; here means the address just behind the basr instruction.
2006 address MacroAssembler::get_PC(Register result) {
2007   z_basr(result, Z_R0); // Don&#39;t branch, just save next instruction address in result.
2008   return pc();
2009 }
2010 
2011 // Get current PC + offset.
2012 // Offset given in bytes, must be even!
2013 // &quot;Current PC&quot; here means the address of the larl instruction plus the given offset.
2014 address MacroAssembler::get_PC(Register result, int64_t offset) {
2015   address here = pc();
2016   z_larl(result, offset/2); // Save target instruction address in result.
2017   return here + offset;
2018 }
2019 
2020 void MacroAssembler::instr_size(Register size, Register pc) {
2021   // Extract 2 most significant bits of current instruction.
2022   z_llgc(size, Address(pc));
2023   z_srl(size, 6);
2024   // Compute (x+3)&amp;6 which translates 0-&gt;2, 1-&gt;4, 2-&gt;4, 3-&gt;6.
2025   z_ahi(size, 3);
2026   z_nill(size, 6);
2027 }
2028 
2029 // Resize_frame with SP(new) = SP(old) - [offset].
2030 void MacroAssembler::resize_frame_sub(Register offset, Register fp, bool load_fp)
2031 {
2032   assert_different_registers(offset, fp, Z_SP);
2033   if (load_fp) { z_lg(fp, _z_abi(callers_sp), Z_SP); }
2034 
2035   z_sgr(Z_SP, offset);
2036   z_stg(fp, _z_abi(callers_sp), Z_SP);
2037 }
2038 
2039 // Resize_frame with SP(new) = [newSP] + offset.
2040 //   This emitter is useful if we already have calculated a pointer
2041 //   into the to-be-allocated stack space, e.g. with special alignment properties,
2042 //   but need some additional space, e.g. for spilling.
2043 //   newSP    is the pre-calculated pointer. It must not be modified.
2044 //   fp       holds, or is filled with, the frame pointer.
2045 //   offset   is the additional increment which is added to addr to form the new SP.
2046 //            Note: specify a negative value to reserve more space!
2047 //   load_fp == true  only indicates that fp is not pre-filled with the frame pointer.
2048 //                    It does not guarantee that fp contains the frame pointer at the end.
2049 void MacroAssembler::resize_frame_abs_with_offset(Register newSP, Register fp, int offset, bool load_fp) {
2050   assert_different_registers(newSP, fp, Z_SP);
2051 
2052   if (load_fp) {
2053     z_lg(fp, _z_abi(callers_sp), Z_SP);
2054   }
2055 
2056   add2reg(Z_SP, offset, newSP);
2057   z_stg(fp, _z_abi(callers_sp), Z_SP);
2058 }
2059 
2060 // Resize_frame with SP(new) = [newSP].
2061 //   load_fp == true  only indicates that fp is not pre-filled with the frame pointer.
2062 //                    It does not guarantee that fp contains the frame pointer at the end.
2063 void MacroAssembler::resize_frame_absolute(Register newSP, Register fp, bool load_fp) {
2064   assert_different_registers(newSP, fp, Z_SP);
2065 
2066   if (load_fp) {
2067     z_lg(fp, _z_abi(callers_sp), Z_SP); // need to use load/store.
2068   }
2069 
2070   z_lgr(Z_SP, newSP);
2071   if (newSP != Z_R0) { // make sure we generate correct code, no matter what register newSP uses.
2072     z_stg(fp, _z_abi(callers_sp), newSP);
2073   } else {
2074     z_stg(fp, _z_abi(callers_sp), Z_SP);
2075   }
2076 }
2077 
2078 // Resize_frame with SP(new) = SP(old) + offset.
2079 void MacroAssembler::resize_frame(RegisterOrConstant offset, Register fp, bool load_fp) {
2080   assert_different_registers(fp, Z_SP);
2081 
2082   if (load_fp) {
2083     z_lg(fp, _z_abi(callers_sp), Z_SP);
2084   }
2085   add64(Z_SP, offset);
2086   z_stg(fp, _z_abi(callers_sp), Z_SP);
2087 }
2088 
2089 void MacroAssembler::push_frame(Register bytes, Register old_sp, bool copy_sp, bool bytes_with_inverted_sign) {
2090 #ifdef ASSERT
2091   assert_different_registers(bytes, old_sp, Z_SP);
2092   if (!copy_sp) {
2093     z_cgr(old_sp, Z_SP);
2094     asm_assert_eq(&quot;[old_sp]!=[Z_SP]&quot;, 0x211);
2095   }
2096 #endif
2097   if (copy_sp) { z_lgr(old_sp, Z_SP); }
2098   if (bytes_with_inverted_sign) {
2099     z_agr(Z_SP, bytes);
2100   } else {
2101     z_sgr(Z_SP, bytes); // Z_sgfr sufficient, but probably not faster.
2102   }
2103   z_stg(old_sp, _z_abi(callers_sp), Z_SP);
2104 }
2105 
2106 unsigned int MacroAssembler::push_frame(unsigned int bytes, Register scratch) {
2107   long offset = Assembler::align(bytes, frame::alignment_in_bytes);
2108   assert(offset &gt; 0, &quot;should push a frame with positive size, size = %ld.&quot;, offset);
2109   assert(Displacement::is_validDisp(-offset), &quot;frame size out of range, size = %ld&quot;, offset);
2110 
2111   // We must not write outside the current stack bounds (given by Z_SP).
2112   // Thus, we have to first update Z_SP and then store the previous SP as stack linkage.
2113   // We rely on Z_R0 by default to be available as scratch.
2114   z_lgr(scratch, Z_SP);
2115   add2reg(Z_SP, -offset);
2116   z_stg(scratch, _z_abi(callers_sp), Z_SP);
2117 #ifdef ASSERT
2118   // Just make sure nobody uses the value in the default scratch register.
2119   // When another register is used, the caller might rely on it containing the frame pointer.
2120   if (scratch == Z_R0) {
2121     z_iihf(scratch, 0xbaadbabe);
2122     z_iilf(scratch, 0xdeadbeef);
2123   }
2124 #endif
2125   return offset;
2126 }
2127 
2128 // Push a frame of size `bytes&#39; plus abi160 on top.
2129 unsigned int MacroAssembler::push_frame_abi160(unsigned int bytes) {
2130   BLOCK_COMMENT(&quot;push_frame_abi160 {&quot;);
2131   unsigned int res = push_frame(bytes + frame::z_abi_160_size);
2132   BLOCK_COMMENT(&quot;} push_frame_abi160&quot;);
2133   return res;
2134 }
2135 
2136 // Pop current C frame.
2137 void MacroAssembler::pop_frame() {
2138   BLOCK_COMMENT(&quot;pop_frame:&quot;);
2139   Assembler::z_lg(Z_SP, _z_abi(callers_sp), Z_SP);
2140 }
2141 
2142 // Pop current C frame and restore return PC register (Z_R14).
2143 void MacroAssembler::pop_frame_restore_retPC(int frame_size_in_bytes) {
2144   BLOCK_COMMENT(&quot;pop_frame_restore_retPC:&quot;);
2145   int retPC_offset = _z_abi16(return_pc) + frame_size_in_bytes;
2146   // If possible, pop frame by add instead of load (a penny saved is a penny got :-).
2147   if (Displacement::is_validDisp(retPC_offset)) {
2148     z_lg(Z_R14, retPC_offset, Z_SP);
2149     add2reg(Z_SP, frame_size_in_bytes);
2150   } else {
2151     add2reg(Z_SP, frame_size_in_bytes);
2152     restore_return_pc();
2153   }
2154 }
2155 
2156 void MacroAssembler::call_VM_leaf_base(address entry_point, bool allow_relocation) {
2157   if (allow_relocation) {
2158     call_c(entry_point);
2159   } else {
2160     call_c_static(entry_point);
2161   }
2162 }
2163 
2164 void MacroAssembler::call_VM_leaf_base(address entry_point) {
2165   bool allow_relocation = true;
2166   call_VM_leaf_base(entry_point, allow_relocation);
2167 }
2168 
2169 void MacroAssembler::call_VM_base(Register oop_result,
2170                                   Register last_java_sp,
2171                                   address  entry_point,
2172                                   bool     allow_relocation,
2173                                   bool     check_exceptions) { // Defaults to true.
2174   // Allow_relocation indicates, if true, that the generated code shall
2175   // be fit for code relocation or referenced data relocation. In other
2176   // words: all addresses must be considered variable. PC-relative addressing
2177   // is not possible then.
2178   // On the other hand, if (allow_relocation == false), addresses and offsets
2179   // may be considered stable, enabling us to take advantage of some PC-relative
2180   // addressing tweaks. These might improve performance and reduce code size.
2181 
2182   // Determine last_java_sp register.
2183   if (!last_java_sp-&gt;is_valid()) {
2184     last_java_sp = Z_SP;  // Load Z_SP as SP.
2185   }
2186 
2187   set_top_ijava_frame_at_SP_as_last_Java_frame(last_java_sp, Z_R1, allow_relocation);
2188 
2189   // ARG1 must hold thread address.
2190   z_lgr(Z_ARG1, Z_thread);
2191 
2192   address return_pc = NULL;
2193   if (allow_relocation) {
2194     return_pc = call_c(entry_point);
2195   } else {
2196     return_pc = call_c_static(entry_point);
2197   }
2198 
2199   reset_last_Java_frame(allow_relocation);
2200 
2201   // C++ interp handles this in the interpreter.
2202   check_and_handle_popframe(Z_thread);
2203   check_and_handle_earlyret(Z_thread);
2204 
2205   // Check for pending exceptions.
2206   if (check_exceptions) {
2207     // Check for pending exceptions (java_thread is set upon return).
2208     load_and_test_long(Z_R0_scratch, Address(Z_thread, Thread::pending_exception_offset()));
2209 
2210     // This used to conditionally jump to forward_exception however it is
2211     // possible if we relocate that the branch will not reach. So we must jump
2212     // around so we can always reach.
2213 
2214     Label ok;
2215     z_bre(ok); // Bcondequal is the same as bcondZero.
2216     call_stub(StubRoutines::forward_exception_entry());
2217     bind(ok);
2218   }
2219 
2220   // Get oop result if there is one and reset the value in the thread.
2221   if (oop_result-&gt;is_valid()) {
2222     get_vm_result(oop_result);
2223   }
2224 
2225   _last_calls_return_pc = return_pc;  // Wipe out other (error handling) calls.
2226 }
2227 
2228 void MacroAssembler::call_VM_base(Register oop_result,
2229                                   Register last_java_sp,
2230                                   address  entry_point,
2231                                   bool     check_exceptions) { // Defaults to true.
2232   bool allow_relocation = true;
2233   call_VM_base(oop_result, last_java_sp, entry_point, allow_relocation, check_exceptions);
2234 }
2235 
2236 // VM calls without explicit last_java_sp.
2237 
2238 void MacroAssembler::call_VM(Register oop_result, address entry_point, bool check_exceptions) {
2239   // Call takes possible detour via InterpreterMacroAssembler.
2240   call_VM_base(oop_result, noreg, entry_point, true, check_exceptions);
2241 }
2242 
2243 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, bool check_exceptions) {
2244   // Z_ARG1 is reserved for the thread.
2245   lgr_if_needed(Z_ARG2, arg_1);
2246   call_VM(oop_result, entry_point, check_exceptions);
2247 }
2248 
2249 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, bool check_exceptions) {
2250   // Z_ARG1 is reserved for the thread.
2251   lgr_if_needed(Z_ARG2, arg_1);
2252   assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2253   lgr_if_needed(Z_ARG3, arg_2);
2254   call_VM(oop_result, entry_point, check_exceptions);
2255 }
2256 
2257 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2,
2258                              Register arg_3, bool check_exceptions) {
2259   // Z_ARG1 is reserved for the thread.
2260   lgr_if_needed(Z_ARG2, arg_1);
2261   assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2262   lgr_if_needed(Z_ARG3, arg_2);
2263   assert(arg_3 != Z_ARG2 &amp;&amp; arg_3 != Z_ARG3, &quot;smashed argument&quot;);
2264   lgr_if_needed(Z_ARG4, arg_3);
2265   call_VM(oop_result, entry_point, check_exceptions);
2266 }
2267 
2268 // VM static calls without explicit last_java_sp.
2269 
2270 void MacroAssembler::call_VM_static(Register oop_result, address entry_point, bool check_exceptions) {
2271   // Call takes possible detour via InterpreterMacroAssembler.
2272   call_VM_base(oop_result, noreg, entry_point, false, check_exceptions);
2273 }
2274 
2275 void MacroAssembler::call_VM_static(Register oop_result, address entry_point, Register arg_1, Register arg_2,
2276                                     Register arg_3, bool check_exceptions) {
2277   // Z_ARG1 is reserved for the thread.
2278   lgr_if_needed(Z_ARG2, arg_1);
2279   assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2280   lgr_if_needed(Z_ARG3, arg_2);
2281   assert(arg_3 != Z_ARG2 &amp;&amp; arg_3 != Z_ARG3, &quot;smashed argument&quot;);
2282   lgr_if_needed(Z_ARG4, arg_3);
2283   call_VM_static(oop_result, entry_point, check_exceptions);
2284 }
2285 
2286 // VM calls with explicit last_java_sp.
2287 
2288 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, bool check_exceptions) {
2289   // Call takes possible detour via InterpreterMacroAssembler.
2290   call_VM_base(oop_result, last_java_sp, entry_point, true, check_exceptions);
2291 }
2292 
2293 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions) {
2294    // Z_ARG1 is reserved for the thread.
2295    lgr_if_needed(Z_ARG2, arg_1);
2296    call_VM(oop_result, last_java_sp, entry_point, check_exceptions);
2297 }
2298 
2299 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1,
2300                              Register arg_2, bool check_exceptions) {
2301    // Z_ARG1 is reserved for the thread.
2302    lgr_if_needed(Z_ARG2, arg_1);
2303    assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2304    lgr_if_needed(Z_ARG3, arg_2);
2305    call_VM(oop_result, last_java_sp, entry_point, check_exceptions);
2306 }
2307 
2308 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1,
2309                              Register arg_2, Register arg_3, bool check_exceptions) {
2310   // Z_ARG1 is reserved for the thread.
2311   lgr_if_needed(Z_ARG2, arg_1);
2312   assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2313   lgr_if_needed(Z_ARG3, arg_2);
2314   assert(arg_3 != Z_ARG2 &amp;&amp; arg_3 != Z_ARG3, &quot;smashed argument&quot;);
2315   lgr_if_needed(Z_ARG4, arg_3);
2316   call_VM(oop_result, last_java_sp, entry_point, check_exceptions);
2317 }
2318 
2319 // VM leaf calls.
2320 
2321 void MacroAssembler::call_VM_leaf(address entry_point) {
2322   // Call takes possible detour via InterpreterMacroAssembler.
2323   call_VM_leaf_base(entry_point, true);
2324 }
2325 
2326 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_1) {
2327   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2328   call_VM_leaf(entry_point);
2329 }
2330 
2331 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_1, Register arg_2) {
2332   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2333   assert(arg_2 != Z_ARG1, &quot;smashed argument&quot;);
2334   if (arg_2 != noreg) lgr_if_needed(Z_ARG2, arg_2);
2335   call_VM_leaf(entry_point);
2336 }
2337 
2338 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3) {
2339   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2340   assert(arg_2 != Z_ARG1, &quot;smashed argument&quot;);
2341   if (arg_2 != noreg) lgr_if_needed(Z_ARG2, arg_2);
2342   assert(arg_3 != Z_ARG1 &amp;&amp; arg_3 != Z_ARG2, &quot;smashed argument&quot;);
2343   if (arg_3 != noreg) lgr_if_needed(Z_ARG3, arg_3);
2344   call_VM_leaf(entry_point);
2345 }
2346 
2347 // Static VM leaf calls.
2348 // Really static VM leaf calls are never patched.
2349 
2350 void MacroAssembler::call_VM_leaf_static(address entry_point) {
2351   // Call takes possible detour via InterpreterMacroAssembler.
2352   call_VM_leaf_base(entry_point, false);
2353 }
2354 
2355 void MacroAssembler::call_VM_leaf_static(address entry_point, Register arg_1) {
2356   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2357   call_VM_leaf_static(entry_point);
2358 }
2359 
2360 void MacroAssembler::call_VM_leaf_static(address entry_point, Register arg_1, Register arg_2) {
2361   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2362   assert(arg_2 != Z_ARG1, &quot;smashed argument&quot;);
2363   if (arg_2 != noreg) lgr_if_needed(Z_ARG2, arg_2);
2364   call_VM_leaf_static(entry_point);
2365 }
2366 
2367 void MacroAssembler::call_VM_leaf_static(address entry_point, Register arg_1, Register arg_2, Register arg_3) {
2368   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2369   assert(arg_2 != Z_ARG1, &quot;smashed argument&quot;);
2370   if (arg_2 != noreg) lgr_if_needed(Z_ARG2, arg_2);
2371   assert(arg_3 != Z_ARG1 &amp;&amp; arg_3 != Z_ARG2, &quot;smashed argument&quot;);
2372   if (arg_3 != noreg) lgr_if_needed(Z_ARG3, arg_3);
2373   call_VM_leaf_static(entry_point);
2374 }
2375 
2376 // Don&#39;t use detour via call_c(reg).
2377 address MacroAssembler::call_c(address function_entry) {
2378   load_const(Z_R1, function_entry);
2379   return call(Z_R1);
2380 }
2381 
2382 // Variant for really static (non-relocatable) calls which are never patched.
2383 address MacroAssembler::call_c_static(address function_entry) {
2384   load_absolute_address(Z_R1, function_entry);
2385 #if 0 // def ASSERT
2386   // Verify that call site did not move.
2387   load_const_optimized(Z_R0, function_entry);
2388   z_cgr(Z_R1, Z_R0);
2389   z_brc(bcondEqual, 3);
2390   z_illtrap(0xba);
2391 #endif
2392   return call(Z_R1);
2393 }
2394 
2395 address MacroAssembler::call_c_opt(address function_entry) {
2396   bool success = call_far_patchable(function_entry, -2 /* emit relocation + constant */);
2397   _last_calls_return_pc = success ? pc() : NULL;
2398   return _last_calls_return_pc;
2399 }
2400 
2401 // Identify a call_far_patchable instruction: LARL + LG + BASR
2402 //
2403 //    nop                   ; optionally, if required for alignment
2404 //    lgrl rx,A(TOC entry)  ; PC-relative access into constant pool
2405 //    basr Z_R14,rx         ; end of this instruction must be aligned to a word boundary
2406 //
2407 // Code pattern will eventually get patched into variant2 (see below for detection code).
2408 //
2409 bool MacroAssembler::is_call_far_patchable_variant0_at(address instruction_addr) {
2410   address iaddr = instruction_addr;
2411 
2412   // Check for the actual load instruction.
2413   if (!is_load_const_from_toc(iaddr)) { return false; }
2414   iaddr += load_const_from_toc_size();
2415 
2416   // Check for the call (BASR) instruction, finally.
2417   assert(iaddr-instruction_addr+call_byregister_size() == call_far_patchable_size(), &quot;size mismatch&quot;);
2418   return is_call_byregister(iaddr);
2419 }
2420 
2421 // Identify a call_far_patchable instruction: BRASL
2422 //
2423 // Code pattern to suits atomic patching:
2424 //    nop                       ; Optionally, if required for alignment.
2425 //    nop    ...                ; Multiple filler nops to compensate for size difference (variant0 is longer).
2426 //    nop                       ; For code pattern detection: Prepend each BRASL with a nop.
2427 //    brasl  Z_R14,&lt;reladdr&gt;    ; End of code must be 4-byte aligned !
2428 bool MacroAssembler::is_call_far_patchable_variant2_at(address instruction_addr) {
2429   const address call_addr = (address)((intptr_t)instruction_addr + call_far_patchable_size() - call_far_pcrelative_size());
2430 
2431   // Check for correct number of leading nops.
2432   address iaddr;
2433   for (iaddr = instruction_addr; iaddr &lt; call_addr; iaddr += nop_size()) {
2434     if (!is_z_nop(iaddr)) { return false; }
2435   }
2436   assert(iaddr == call_addr, &quot;sanity&quot;);
2437 
2438   // --&gt; Check for call instruction.
2439   if (is_call_far_pcrelative(call_addr)) {
2440     assert(call_addr-instruction_addr+call_far_pcrelative_size() == call_far_patchable_size(), &quot;size mismatch&quot;);
2441     return true;
2442   }
2443 
2444   return false;
2445 }
2446 
2447 // Emit a NOT mt-safely patchable 64 bit absolute call.
2448 // If toc_offset == -2, then the destination of the call (= target) is emitted
2449 //                      to the constant pool and a runtime_call relocation is added
2450 //                      to the code buffer.
2451 // If toc_offset != -2, target must already be in the constant pool at
2452 //                      _ctableStart+toc_offset (a caller can retrieve toc_offset
2453 //                      from the runtime_call relocation).
2454 // Special handling of emitting to scratch buffer when there is no constant pool.
2455 // Slightly changed code pattern. We emit an additional nop if we would
2456 // not end emitting at a word aligned address. This is to ensure
2457 // an atomically patchable displacement in brasl instructions.
2458 //
2459 // A call_far_patchable comes in different flavors:
2460 //  - LARL(CP) / LG(CP) / BR (address in constant pool, access via CP register)
2461 //  - LGRL(CP) / BR          (address in constant pool, pc-relative accesss)
2462 //  - BRASL                  (relative address of call target coded in instruction)
2463 // All flavors occupy the same amount of space. Length differences are compensated
2464 // by leading nops, such that the instruction sequence always ends at the same
2465 // byte offset. This is required to keep the return offset constant.
2466 // Furthermore, the return address (the end of the instruction sequence) is forced
2467 // to be on a 4-byte boundary. This is required for atomic patching, should we ever
2468 // need to patch the call target of the BRASL flavor.
2469 // RETURN value: false, if no constant pool entry could be allocated, true otherwise.
2470 bool MacroAssembler::call_far_patchable(address target, int64_t tocOffset) {
2471   // Get current pc and ensure word alignment for end of instr sequence.
2472   const address start_pc = pc();
2473   const intptr_t       start_off = offset();
2474   assert(!call_far_patchable_requires_alignment_nop(start_pc), &quot;call_far_patchable requires aligned address&quot;);
2475   const ptrdiff_t      dist      = (ptrdiff_t)(target - (start_pc + 2)); // Prepend each BRASL with a nop.
2476   const bool emit_target_to_pool = (tocOffset == -2) &amp;&amp; !code_section()-&gt;scratch_emit();
2477   const bool emit_relative_call  = !emit_target_to_pool &amp;&amp;
2478                                    RelAddr::is_in_range_of_RelAddr32(dist) &amp;&amp;
2479                                    ReoptimizeCallSequences &amp;&amp;
2480                                    !code_section()-&gt;scratch_emit();
2481 
2482   if (emit_relative_call) {
2483     // Add padding to get the same size as below.
2484     const unsigned int padding = call_far_patchable_size() - call_far_pcrelative_size();
2485     unsigned int current_padding;
2486     for (current_padding = 0; current_padding &lt; padding; current_padding += nop_size()) { z_nop(); }
2487     assert(current_padding == padding, &quot;sanity&quot;);
2488 
2489     // relative call: len = 2(nop) + 6 (brasl)
2490     // CodeBlob resize cannot occur in this case because
2491     // this call is emitted into pre-existing space.
2492     z_nop(); // Prepend each BRASL with a nop.
2493     z_brasl(Z_R14, target);
2494   } else {
2495     // absolute call: Get address from TOC.
2496     // len = (load TOC){6|0} + (load from TOC){6} + (basr){2} = {14|8}
2497     if (emit_target_to_pool) {
2498       // When emitting the call for the first time, we do not need to use
2499       // the pc-relative version. It will be patched anyway, when the code
2500       // buffer is copied.
2501       // Relocation is not needed when !ReoptimizeCallSequences.
2502       relocInfo::relocType rt = ReoptimizeCallSequences ? relocInfo::runtime_call_w_cp_type : relocInfo::none;
2503       AddressLiteral dest(target, rt);
2504       // Store_oop_in_toc() adds dest to the constant table. As side effect, this kills
2505       // inst_mark(). Reset if possible.
2506       bool reset_mark = (inst_mark() == pc());
2507       tocOffset = store_oop_in_toc(dest);
2508       if (reset_mark) { set_inst_mark(); }
2509       if (tocOffset == -1) {
2510         return false; // Couldn&#39;t create constant pool entry.
2511       }
2512     }
2513     assert(offset() == start_off, &quot;emit no code before this point!&quot;);
2514 
2515     address tocPos = pc() + tocOffset;
2516     if (emit_target_to_pool) {
2517       tocPos = code()-&gt;consts()-&gt;start() + tocOffset;
2518     }
2519     load_long_pcrelative(Z_R14, tocPos);
2520     z_basr(Z_R14, Z_R14);
2521   }
2522 
2523 #ifdef ASSERT
2524   // Assert that we can identify the emitted call.
2525   assert(is_call_far_patchable_at(addr_at(start_off)), &quot;can&#39;t identify emitted call&quot;);
2526   assert(offset() == start_off+call_far_patchable_size(), &quot;wrong size&quot;);
2527 
2528   if (emit_target_to_pool) {
2529     assert(get_dest_of_call_far_patchable_at(addr_at(start_off), code()-&gt;consts()-&gt;start()) == target,
2530            &quot;wrong encoding of dest address&quot;);
2531   }
2532 #endif
2533   return true; // success
2534 }
2535 
2536 // Identify a call_far_patchable instruction.
2537 // For more detailed information see header comment of call_far_patchable.
2538 bool MacroAssembler::is_call_far_patchable_at(address instruction_addr) {
2539   return is_call_far_patchable_variant2_at(instruction_addr)  || // short version: BRASL
2540          is_call_far_patchable_variant0_at(instruction_addr);    // long version LARL + LG + BASR
2541 }
2542 
2543 // Does the call_far_patchable instruction use a pc-relative encoding
2544 // of the call destination?
2545 bool MacroAssembler::is_call_far_patchable_pcrelative_at(address instruction_addr) {
2546   // Variant 2 is pc-relative.
2547   return is_call_far_patchable_variant2_at(instruction_addr);
2548 }
2549 
2550 bool MacroAssembler::is_call_far_pcrelative(address instruction_addr) {
2551   // Prepend each BRASL with a nop.
2552   return is_z_nop(instruction_addr) &amp;&amp; is_z_brasl(instruction_addr + nop_size());  // Match at position after one nop required.
2553 }
2554 
2555 // Set destination address of a call_far_patchable instruction.
2556 void MacroAssembler::set_dest_of_call_far_patchable_at(address instruction_addr, address dest, int64_t tocOffset) {
2557   ResourceMark rm;
2558 
2559   // Now that CP entry is verified, patch call to a pc-relative call (if circumstances permit).
2560   int code_size = MacroAssembler::call_far_patchable_size();
2561   CodeBuffer buf(instruction_addr, code_size);
2562   MacroAssembler masm(&amp;buf);
2563   masm.call_far_patchable(dest, tocOffset);
2564   ICache::invalidate_range(instruction_addr, code_size); // Empty on z.
2565 }
2566 
2567 // Get dest address of a call_far_patchable instruction.
2568 address MacroAssembler::get_dest_of_call_far_patchable_at(address instruction_addr, address ctable) {
2569   // Dynamic TOC: absolute address in constant pool.
2570   // Check variant2 first, it is more frequent.
2571 
2572   // Relative address encoded in call instruction.
2573   if (is_call_far_patchable_variant2_at(instruction_addr)) {
2574     return MacroAssembler::get_target_addr_pcrel(instruction_addr + nop_size()); // Prepend each BRASL with a nop.
2575 
2576   // Absolute address in constant pool.
2577   } else if (is_call_far_patchable_variant0_at(instruction_addr)) {
2578     address iaddr = instruction_addr;
2579 
2580     long    tocOffset = get_load_const_from_toc_offset(iaddr);
2581     address tocLoc    = iaddr + tocOffset;
2582     return *(address *)(tocLoc);
2583   } else {
2584     fprintf(stderr, &quot;MacroAssembler::get_dest_of_call_far_patchable_at has a problem at %p:\n&quot;, instruction_addr);
2585     fprintf(stderr, &quot;not a call_far_patchable: %16.16lx %16.16lx, len = %d\n&quot;,
2586             *(unsigned long*)instruction_addr,
2587             *(unsigned long*)(instruction_addr+8),
2588             call_far_patchable_size());
2589     Disassembler::decode(instruction_addr, instruction_addr+call_far_patchable_size());
2590     ShouldNotReachHere();
2591     return NULL;
2592   }
2593 }
2594 
2595 void MacroAssembler::align_call_far_patchable(address pc) {
2596   if (call_far_patchable_requires_alignment_nop(pc)) { z_nop(); }
2597 }
2598 
2599 void MacroAssembler::check_and_handle_earlyret(Register java_thread) {
2600 }
2601 
2602 void MacroAssembler::check_and_handle_popframe(Register java_thread) {
2603 }
2604 
2605 // Read from the polling page.
2606 // Use TM or TMY instruction, depending on read offset.
2607 //   offset = 0: Use TM, safepoint polling.
2608 //   offset &lt; 0: Use TMY, profiling safepoint polling.
2609 void MacroAssembler::load_from_polling_page(Register polling_page_address, int64_t offset) {
2610   if (Immediate::is_uimm12(offset)) {
2611     z_tm(offset, polling_page_address, mask_safepoint);
2612   } else {
2613     z_tmy(offset, polling_page_address, mask_profiling);
2614   }
2615 }
2616 
2617 // Check whether z_instruction is a read access to the polling page
2618 // which was emitted by load_from_polling_page(..).
2619 bool MacroAssembler::is_load_from_polling_page(address instr_loc) {
2620   unsigned long z_instruction;
2621   unsigned int  ilen = get_instruction(instr_loc, &amp;z_instruction);
2622 
2623   if (ilen == 2) { return false; } // It&#39;s none of the allowed instructions.
2624 
2625   if (ilen == 4) {
2626     if (!is_z_tm(z_instruction)) { return false; } // It&#39;s len=4, but not a z_tm. fail.
2627 
2628     int ms = inv_mask(z_instruction,8,32);  // mask
2629     int ra = inv_reg(z_instruction,16,32);  // base register
2630     int ds = inv_uimm12(z_instruction);     // displacement
2631 
2632     if (!(ds == 0 &amp;&amp; ra != 0 &amp;&amp; ms == mask_safepoint)) {
2633       return false; // It&#39;s not a z_tm(0, ra, mask_safepoint). Fail.
2634     }
2635 
2636   } else { /* if (ilen == 6) */
2637 
2638     assert(!is_z_lg(z_instruction), &quot;old form (LG) polling page access. Please fix and use TM(Y).&quot;);
2639 
2640     if (!is_z_tmy(z_instruction)) { return false; } // It&#39;s len=6, but not a z_tmy. fail.
2641 
2642     int ms = inv_mask(z_instruction,8,48);  // mask
2643     int ra = inv_reg(z_instruction,16,48);  // base register
2644     int ds = inv_simm20(z_instruction);     // displacement
2645   }
2646 
2647   return true;
2648 }
2649 
2650 // Extract poll address from instruction and ucontext.
2651 address MacroAssembler::get_poll_address(address instr_loc, void* ucontext) {
2652   assert(ucontext != NULL, &quot;must have ucontext&quot;);
2653   ucontext_t* uc = (ucontext_t*) ucontext;
2654   unsigned long z_instruction;
2655   unsigned int ilen = get_instruction(instr_loc, &amp;z_instruction);
2656 
2657   if (ilen == 4 &amp;&amp; is_z_tm(z_instruction)) {
2658     int ra = inv_reg(z_instruction, 16, 32);  // base register
2659     int ds = inv_uimm12(z_instruction);       // displacement
2660     address addr = (address)uc-&gt;uc_mcontext.gregs[ra];
2661     return addr + ds;
2662   } else if (ilen == 6 &amp;&amp; is_z_tmy(z_instruction)) {
2663     int ra = inv_reg(z_instruction, 16, 48);  // base register
2664     int ds = inv_simm20(z_instruction);       // displacement
2665     address addr = (address)uc-&gt;uc_mcontext.gregs[ra];
2666     return addr + ds;
2667   }
2668 
2669   ShouldNotReachHere();
2670   return NULL;
2671 }
2672 
2673 // Extract poll register from instruction.
2674 uint MacroAssembler::get_poll_register(address instr_loc) {
2675   unsigned long z_instruction;
2676   unsigned int ilen = get_instruction(instr_loc, &amp;z_instruction);
2677 
2678   if (ilen == 4 &amp;&amp; is_z_tm(z_instruction)) {
2679     return (uint)inv_reg(z_instruction, 16, 32);  // base register
2680   } else if (ilen == 6 &amp;&amp; is_z_tmy(z_instruction)) {
2681     return (uint)inv_reg(z_instruction, 16, 48);  // base register
2682   }
2683 
2684   ShouldNotReachHere();
2685   return 0;
2686 }
2687 
2688 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register temp_reg) {
2689   if (SafepointMechanism::uses_thread_local_poll()) {
2690     const Address poll_byte_addr(Z_thread, in_bytes(Thread::polling_page_offset()) + 7 /* Big Endian */);
2691     // Armed page has poll_bit set.
2692     z_tm(poll_byte_addr, SafepointMechanism::poll_bit());
2693     z_brnaz(slow_path);
2694   } else {
2695     load_const_optimized(temp_reg, SafepointSynchronize::address_of_state());
2696     z_cli(/*SafepointSynchronize::sz_state()*/4-1, temp_reg, SafepointSynchronize::_not_synchronized);
2697     z_brne(slow_path);
2698   }
2699 }
2700 
2701 // Don&#39;t rely on register locking, always use Z_R1 as scratch register instead.
2702 void MacroAssembler::bang_stack_with_offset(int offset) {
2703   // Stack grows down, caller passes positive offset.
2704   assert(offset &gt; 0, &quot;must bang with positive offset&quot;);
2705   if (Displacement::is_validDisp(-offset)) {
2706     z_tmy(-offset, Z_SP, mask_stackbang);
2707   } else {
2708     add2reg(Z_R1, -offset, Z_SP);    // Do not destroy Z_SP!!!
2709     z_tm(0, Z_R1, mask_stackbang);  // Just banging.
2710   }
2711 }
2712 
2713 void MacroAssembler::reserved_stack_check(Register return_pc) {
2714   // Test if reserved zone needs to be enabled.
2715   Label no_reserved_zone_enabling;
2716   assert(return_pc == Z_R14, &quot;Return pc must be in R14 before z_br() to StackOverflow stub.&quot;);
2717   BLOCK_COMMENT(&quot;reserved_stack_check {&quot;);
2718 
2719   z_clg(Z_SP, Address(Z_thread, JavaThread::reserved_stack_activation_offset()));
2720   z_brl(no_reserved_zone_enabling);
2721 
2722   // Enable reserved zone again, throw stack overflow exception.
2723   save_return_pc();
2724   push_frame_abi160(0);
2725   call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), Z_thread);
2726   pop_frame();
2727   restore_return_pc();
2728 
2729   load_const_optimized(Z_R1, StubRoutines::throw_delayed_StackOverflowError_entry());
2730   // Don&#39;t use call() or z_basr(), they will invalidate Z_R14 which contains the return pc.
2731   z_br(Z_R1);
2732 
2733   should_not_reach_here();
2734 
2735   bind(no_reserved_zone_enabling);
2736   BLOCK_COMMENT(&quot;} reserved_stack_check&quot;);
2737 }
2738 
2739 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
2740 void MacroAssembler::tlab_allocate(Register obj,
2741                                    Register var_size_in_bytes,
2742                                    int con_size_in_bytes,
2743                                    Register t1,
2744                                    Label&amp; slow_case) {
2745   assert_different_registers(obj, var_size_in_bytes, t1);
2746   Register end = t1;
2747   Register thread = Z_thread;
2748 
2749   z_lg(obj, Address(thread, JavaThread::tlab_top_offset()));
2750   if (var_size_in_bytes == noreg) {
2751     z_lay(end, Address(obj, con_size_in_bytes));
2752   } else {
2753     z_lay(end, Address(obj, var_size_in_bytes));
2754   }
2755   z_cg(end, Address(thread, JavaThread::tlab_end_offset()));
2756   branch_optimized(bcondHigh, slow_case);
2757 
2758   // Update the tlab top pointer.
2759   z_stg(end, Address(thread, JavaThread::tlab_top_offset()));
2760 
2761   // Recover var_size_in_bytes if necessary.
2762   if (var_size_in_bytes == end) {
2763     z_sgr(var_size_in_bytes, obj);
2764   }
2765 }
2766 
2767 // Emitter for interface method lookup.
2768 //   input: recv_klass, intf_klass, itable_index
2769 //   output: method_result
2770 //   kills: itable_index, temp1_reg, Z_R0, Z_R1
2771 // TODO: Temp2_reg is unused. we may use this emitter also in the itable stubs.
2772 // If the register is still not needed then, remove it.
2773 void MacroAssembler::lookup_interface_method(Register           recv_klass,
2774                                              Register           intf_klass,
2775                                              RegisterOrConstant itable_index,
2776                                              Register           method_result,
2777                                              Register           temp1_reg,
2778                                              Label&amp;             no_such_interface,
2779                                              bool               return_method) {
2780 
2781   const Register vtable_len = temp1_reg;    // Used to compute itable_entry_addr.
2782   const Register itable_entry_addr = Z_R1_scratch;
2783   const Register itable_interface = Z_R0_scratch;
2784 
2785   BLOCK_COMMENT(&quot;lookup_interface_method {&quot;);
2786 
2787   // Load start of itable entries into itable_entry_addr.
2788   z_llgf(vtable_len, Address(recv_klass, Klass::vtable_length_offset()));
2789   z_sllg(vtable_len, vtable_len, exact_log2(vtableEntry::size_in_bytes()));
2790 
2791   // Loop over all itable entries until desired interfaceOop(Rinterface) found.
2792   const int vtable_base_offset = in_bytes(Klass::vtable_start_offset());
2793 
2794   add2reg_with_index(itable_entry_addr,
2795                      vtable_base_offset + itableOffsetEntry::interface_offset_in_bytes(),
2796                      recv_klass, vtable_len);
2797 
2798   const int itable_offset_search_inc = itableOffsetEntry::size() * wordSize;
2799   Label     search;
2800 
2801   bind(search);
2802 
2803   // Handle IncompatibleClassChangeError.
2804   // If the entry is NULL then we&#39;ve reached the end of the table
2805   // without finding the expected interface, so throw an exception.
2806   load_and_test_long(itable_interface, Address(itable_entry_addr));
2807   z_bre(no_such_interface);
2808 
2809   add2reg(itable_entry_addr, itable_offset_search_inc);
2810   z_cgr(itable_interface, intf_klass);
2811   z_brne(search);
2812 
2813   // Entry found and itable_entry_addr points to it, get offset of vtable for interface.
2814   if (return_method) {
2815     const int vtable_offset_offset = (itableOffsetEntry::offset_offset_in_bytes() -
2816                                       itableOffsetEntry::interface_offset_in_bytes()) -
2817                                      itable_offset_search_inc;
2818 
2819     // Compute itableMethodEntry and get method and entry point
2820     // we use addressing with index and displacement, since the formula
2821     // for computing the entry&#39;s offset has a fixed and a dynamic part,
2822     // the latter depending on the matched interface entry and on the case,
2823     // that the itable index has been passed as a register, not a constant value.
2824     int method_offset = itableMethodEntry::method_offset_in_bytes();
2825                              // Fixed part (displacement), common operand.
2826     Register itable_offset = method_result;  // Dynamic part (index register).
2827 
2828     if (itable_index.is_register()) {
2829        // Compute the method&#39;s offset in that register, for the formula, see the
2830        // else-clause below.
2831        z_sllg(itable_offset, itable_index.as_register(), exact_log2(itableMethodEntry::size() * wordSize));
2832        z_agf(itable_offset, vtable_offset_offset, itable_entry_addr);
2833     } else {
2834       // Displacement increases.
2835       method_offset += itableMethodEntry::size() * wordSize * itable_index.as_constant();
2836 
2837       // Load index from itable.
2838       z_llgf(itable_offset, vtable_offset_offset, itable_entry_addr);
2839     }
2840 
2841     // Finally load the method&#39;s oop.
2842     z_lg(method_result, method_offset, itable_offset, recv_klass);
2843   }
2844   BLOCK_COMMENT(&quot;} lookup_interface_method&quot;);
2845 }
2846 
2847 // Lookup for virtual method invocation.
2848 void MacroAssembler::lookup_virtual_method(Register           recv_klass,
2849                                            RegisterOrConstant vtable_index,
2850                                            Register           method_result) {
2851   assert_different_registers(recv_klass, vtable_index.register_or_noreg());
2852   assert(vtableEntry::size() * wordSize == wordSize,
2853          &quot;else adjust the scaling in the code below&quot;);
2854 
2855   BLOCK_COMMENT(&quot;lookup_virtual_method {&quot;);
2856 
2857   const int base = in_bytes(Klass::vtable_start_offset());
2858 
2859   if (vtable_index.is_constant()) {
2860     // Load with base + disp.
2861     Address vtable_entry_addr(recv_klass,
2862                               vtable_index.as_constant() * wordSize +
2863                               base +
2864                               vtableEntry::method_offset_in_bytes());
2865 
2866     z_lg(method_result, vtable_entry_addr);
2867   } else {
2868     // Shift index properly and load with base + index + disp.
2869     Register vindex = vtable_index.as_register();
2870     Address  vtable_entry_addr(recv_klass, vindex,
2871                                base + vtableEntry::method_offset_in_bytes());
2872 
2873     z_sllg(vindex, vindex, exact_log2(wordSize));
2874     z_lg(method_result, vtable_entry_addr);
2875   }
2876   BLOCK_COMMENT(&quot;} lookup_virtual_method&quot;);
2877 }
2878 
2879 // Factor out code to call ic_miss_handler.
2880 // Generate code to call the inline cache miss handler.
2881 //
2882 // In most cases, this code will be generated out-of-line.
2883 // The method parameters are intended to provide some variability.
2884 //   ICM          - Label which has to be bound to the start of useful code (past any traps).
2885 //   trapMarker   - Marking byte for the generated illtrap instructions (if any).
2886 //                  Any value except 0x00 is supported.
2887 //                  = 0x00 - do not generate illtrap instructions.
2888 //                         use nops to fill ununsed space.
2889 //   requiredSize - required size of the generated code. If the actually
2890 //                  generated code is smaller, use padding instructions to fill up.
2891 //                  = 0 - no size requirement, no padding.
2892 //   scratch      - scratch register to hold branch target address.
2893 //
2894 //  The method returns the code offset of the bound label.
2895 unsigned int MacroAssembler::call_ic_miss_handler(Label&amp; ICM, int trapMarker, int requiredSize, Register scratch) {
2896   intptr_t startOffset = offset();
2897 
2898   // Prevent entry at content_begin().
2899   if (trapMarker != 0) {
2900     z_illtrap(trapMarker);
2901   }
2902 
2903   // Load address of inline cache miss code into scratch register
2904   // and branch to cache miss handler.
2905   BLOCK_COMMENT(&quot;IC miss handler {&quot;);
2906   BIND(ICM);
2907   unsigned int   labelOffset = offset();
2908   AddressLiteral icmiss(SharedRuntime::get_ic_miss_stub());
2909 
2910   load_const_optimized(scratch, icmiss);
2911   z_br(scratch);
2912 
2913   // Fill unused space.
2914   if (requiredSize &gt; 0) {
2915     while ((offset() - startOffset) &lt; requiredSize) {
2916       if (trapMarker == 0) {
2917         z_nop();
2918       } else {
2919         z_illtrap(trapMarker);
2920       }
2921     }
2922   }
2923   BLOCK_COMMENT(&quot;} IC miss handler&quot;);
2924   return labelOffset;
2925 }
2926 
2927 void MacroAssembler::nmethod_UEP(Label&amp; ic_miss) {
<a name="9" id="anc9"></a><span class="line-modified">2928   Register ic_reg       = as_Register(Matcher::inline_cache_reg_encode());</span>
2929   int      klass_offset = oopDesc::klass_offset_in_bytes();
2930   if (!ImplicitNullChecks || MacroAssembler::needs_explicit_null_check(klass_offset)) {
2931     if (VM_Version::has_CompareBranch()) {
2932       z_cgij(Z_ARG1, 0, Assembler::bcondEqual, ic_miss);
2933     } else {
2934       z_ltgr(Z_ARG1, Z_ARG1);
2935       z_bre(ic_miss);
2936     }
2937   }
2938   // Compare cached class against klass from receiver.
2939   compare_klass_ptr(ic_reg, klass_offset, Z_ARG1, false);
2940   z_brne(ic_miss);
2941 }
2942 
2943 void MacroAssembler::check_klass_subtype_fast_path(Register   sub_klass,
2944                                                    Register   super_klass,
2945                                                    Register   temp1_reg,
2946                                                    Label*     L_success,
2947                                                    Label*     L_failure,
2948                                                    Label*     L_slow_path,
2949                                                    RegisterOrConstant super_check_offset) {
2950 
2951   const int sc_offset  = in_bytes(Klass::secondary_super_cache_offset());
2952   const int sco_offset = in_bytes(Klass::super_check_offset_offset());
2953 
2954   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
2955   bool need_slow_path = (must_load_sco ||
2956                          super_check_offset.constant_or_zero() == sc_offset);
2957 
2958   // Input registers must not overlap.
2959   assert_different_registers(sub_klass, super_klass, temp1_reg);
2960   if (super_check_offset.is_register()) {
2961     assert_different_registers(sub_klass, super_klass,
2962                                super_check_offset.as_register());
2963   } else if (must_load_sco) {
2964     assert(temp1_reg != noreg, &quot;supply either a temp or a register offset&quot;);
2965   }
2966 
2967   const Register Rsuper_check_offset = temp1_reg;
2968 
2969   NearLabel L_fallthrough;
2970   int label_nulls = 0;
2971   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
2972   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
2973   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
2974   assert(label_nulls &lt;= 1 ||
2975          (L_slow_path == &amp;L_fallthrough &amp;&amp; label_nulls &lt;= 2 &amp;&amp; !need_slow_path),
2976          &quot;at most one NULL in the batch, usually&quot;);
2977 
2978   BLOCK_COMMENT(&quot;check_klass_subtype_fast_path {&quot;);
2979   // If the pointers are equal, we are done (e.g., String[] elements).
2980   // This self-check enables sharing of secondary supertype arrays among
2981   // non-primary types such as array-of-interface. Otherwise, each such
2982   // type would need its own customized SSA.
2983   // We move this check to the front of the fast path because many
2984   // type checks are in fact trivially successful in this manner,
2985   // so we get a nicely predicted branch right at the start of the check.
2986   compare64_and_branch(sub_klass, super_klass, bcondEqual, *L_success);
2987 
2988   // Check the supertype display, which is uint.
2989   if (must_load_sco) {
2990     z_llgf(Rsuper_check_offset, sco_offset, super_klass);
2991     super_check_offset = RegisterOrConstant(Rsuper_check_offset);
2992   }
2993   Address super_check_addr(sub_klass, super_check_offset, 0);
2994   z_cg(super_klass, super_check_addr); // compare w/ displayed supertype
2995 
2996   // This check has worked decisively for primary supers.
2997   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
2998   // (Secondary supers are interfaces and very deeply nested subtypes.)
2999   // This works in the same check above because of a tricky aliasing
3000   // between the super_cache and the primary super display elements.
3001   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
3002   // Note that the cache is updated below if it does not help us find
3003   // what we need immediately.
3004   // So if it was a primary super, we can just fail immediately.
3005   // Otherwise, it&#39;s the slow path for us (no success at this point).
3006 
3007   // Hacked jmp, which may only be used just before L_fallthrough.
3008 #define final_jmp(label)                                                \
3009   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3010   else                            { branch_optimized(Assembler::bcondAlways, label); } /*omit semicolon*/
3011 
3012   if (super_check_offset.is_register()) {
3013     branch_optimized(Assembler::bcondEqual, *L_success);
3014     z_cfi(super_check_offset.as_register(), sc_offset);
3015     if (L_failure == &amp;L_fallthrough) {
3016       branch_optimized(Assembler::bcondEqual, *L_slow_path);
3017     } else {
3018       branch_optimized(Assembler::bcondNotEqual, *L_failure);
3019       final_jmp(*L_slow_path);
3020     }
3021   } else if (super_check_offset.as_constant() == sc_offset) {
3022     // Need a slow path; fast failure is impossible.
3023     if (L_slow_path == &amp;L_fallthrough) {
3024       branch_optimized(Assembler::bcondEqual, *L_success);
3025     } else {
3026       branch_optimized(Assembler::bcondNotEqual, *L_slow_path);
3027       final_jmp(*L_success);
3028     }
3029   } else {
3030     // No slow path; it&#39;s a fast decision.
3031     if (L_failure == &amp;L_fallthrough) {
3032       branch_optimized(Assembler::bcondEqual, *L_success);
3033     } else {
3034       branch_optimized(Assembler::bcondNotEqual, *L_failure);
3035       final_jmp(*L_success);
3036     }
3037   }
3038 
3039   bind(L_fallthrough);
3040 #undef local_brc
3041 #undef final_jmp
3042   BLOCK_COMMENT(&quot;} check_klass_subtype_fast_path&quot;);
3043   // fallthru (to slow path)
3044 }
3045 
3046 void MacroAssembler::check_klass_subtype_slow_path(Register Rsubklass,
3047                                                    Register Rsuperklass,
3048                                                    Register Rarray_ptr,  // tmp
3049                                                    Register Rlength,     // tmp
3050                                                    Label* L_success,
3051                                                    Label* L_failure) {
3052   // Input registers must not overlap.
3053   // Also check for R1 which is explicitely used here.
3054   assert_different_registers(Z_R1, Rsubklass, Rsuperklass, Rarray_ptr, Rlength);
3055   NearLabel L_fallthrough;
3056   int label_nulls = 0;
3057   if (L_success == NULL) { L_success = &amp;L_fallthrough; label_nulls++; }
3058   if (L_failure == NULL) { L_failure = &amp;L_fallthrough; label_nulls++; }
3059   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3060 
3061   const int ss_offset = in_bytes(Klass::secondary_supers_offset());
3062   const int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3063 
3064   const int length_offset = Array&lt;Klass*&gt;::length_offset_in_bytes();
3065   const int base_offset   = Array&lt;Klass*&gt;::base_offset_in_bytes();
3066 
3067   // Hacked jmp, which may only be used just before L_fallthrough.
3068 #define final_jmp(label)                                                \
3069   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3070   else                            branch_optimized(Assembler::bcondAlways, label) /*omit semicolon*/
3071 
3072   NearLabel loop_iterate, loop_count, match;
3073 
3074   BLOCK_COMMENT(&quot;check_klass_subtype_slow_path {&quot;);
3075   z_lg(Rarray_ptr, ss_offset, Rsubklass);
3076 
3077   load_and_test_int(Rlength, Address(Rarray_ptr, length_offset));
3078   branch_optimized(Assembler::bcondZero, *L_failure);
3079 
3080   // Oops in table are NO MORE compressed.
3081   z_cg(Rsuperklass, base_offset, Rarray_ptr); // Check array element for match.
3082   z_bre(match);                               // Shortcut for array length = 1.
3083 
3084   // No match yet, so we must walk the array&#39;s elements.
3085   z_lngfr(Rlength, Rlength);
3086   z_sllg(Rlength, Rlength, LogBytesPerWord); // -#bytes of cache array
3087   z_llill(Z_R1, BytesPerWord);               // Set increment/end index.
3088   add2reg(Rlength, 2 * BytesPerWord);        // start index  = -(n-2)*BytesPerWord
3089   z_slgr(Rarray_ptr, Rlength);               // start addr: +=  (n-2)*BytesPerWord
3090   z_bru(loop_count);
3091 
3092   BIND(loop_iterate);
3093   z_cg(Rsuperklass, base_offset, Rlength, Rarray_ptr); // Check array element for match.
3094   z_bre(match);
3095   BIND(loop_count);
3096   z_brxlg(Rlength, Z_R1, loop_iterate);
3097 
3098   // Rsuperklass not found among secondary super classes -&gt; failure.
3099   branch_optimized(Assembler::bcondAlways, *L_failure);
3100 
3101   // Got a hit. Return success (zero result). Set cache.
3102   // Cache load doesn&#39;t happen here. For speed it is directly emitted by the compiler.
3103 
3104   BIND(match);
3105 
3106   z_stg(Rsuperklass, sc_offset, Rsubklass); // Save result to cache.
3107 
3108   final_jmp(*L_success);
3109 
3110   // Exit to the surrounding code.
3111   BIND(L_fallthrough);
3112 #undef local_brc
3113 #undef final_jmp
3114   BLOCK_COMMENT(&quot;} check_klass_subtype_slow_path&quot;);
3115 }
3116 
3117 // Emitter for combining fast and slow path.
3118 void MacroAssembler::check_klass_subtype(Register sub_klass,
3119                                          Register super_klass,
3120                                          Register temp1_reg,
3121                                          Register temp2_reg,
3122                                          Label&amp;   L_success) {
3123   NearLabel failure;
3124   BLOCK_COMMENT(err_msg(&quot;check_klass_subtype(%s subclass of %s) {&quot;, sub_klass-&gt;name(), super_klass-&gt;name()));
3125   check_klass_subtype_fast_path(sub_klass, super_klass, temp1_reg,
3126                                 &amp;L_success, &amp;failure, NULL);
3127   check_klass_subtype_slow_path(sub_klass, super_klass,
3128                                 temp1_reg, temp2_reg, &amp;L_success, NULL);
3129   BIND(failure);
3130   BLOCK_COMMENT(&quot;} check_klass_subtype&quot;);
3131 }
3132 
<a name="10" id="anc10"></a>


























3133 // Increment a counter at counter_address when the eq condition code is
3134 // set. Kills registers tmp1_reg and tmp2_reg and preserves the condition code.
3135 void MacroAssembler::increment_counter_eq(address counter_address, Register tmp1_reg, Register tmp2_reg) {
3136   Label l;
3137   z_brne(l);
3138   load_const(tmp1_reg, counter_address);
3139   add2mem_32(Address(tmp1_reg), 1, tmp2_reg);
3140   z_cr(tmp1_reg, tmp1_reg); // Set cc to eq.
3141   bind(l);
3142 }
3143 
3144 // Semantics are dependent on the slow_case label:
3145 //   If the slow_case label is not NULL, failure to biased-lock the object
3146 //   transfers control to the location of the slow_case label. If the
3147 //   object could be biased-locked, control is transferred to the done label.
3148 //   The condition code is unpredictable.
3149 //
3150 //   If the slow_case label is NULL, failure to biased-lock the object results
3151 //   in a transfer of control to the done label with a condition code of not_equal.
3152 //   If the biased-lock could be successfully obtained, control is transfered to
3153 //   the done label with a condition code of equal.
3154 //   It is mandatory to react on the condition code At the done label.
3155 //
3156 void MacroAssembler::biased_locking_enter(Register  obj_reg,
3157                                           Register  mark_reg,
3158                                           Register  temp_reg,
3159                                           Register  temp2_reg,    // May be Z_RO!
3160                                           Label    &amp;done,
3161                                           Label    *slow_case) {
3162   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
3163   assert_different_registers(obj_reg, mark_reg, temp_reg, temp2_reg);
3164 
3165   Label cas_label; // Try, if implemented, CAS locking. Fall thru to slow path otherwise.
3166 
3167   BLOCK_COMMENT(&quot;biased_locking_enter {&quot;);
3168 
3169   // Biased locking
3170   // See whether the lock is currently biased toward our thread and
3171   // whether the epoch is still valid.
3172   // Note that the runtime guarantees sufficient alignment of JavaThread
3173   // pointers to allow age to be placed into low bits.
<a name="11" id="anc11"></a><span class="line-modified">3174   assert(markOopDesc::age_shift == markOopDesc::lock_bits + markOopDesc::biased_lock_bits,</span>
3175          &quot;biased locking makes assumptions about bit layout&quot;);
3176   z_lr(temp_reg, mark_reg);
<a name="12" id="anc12"></a><span class="line-modified">3177   z_nilf(temp_reg, markOopDesc::biased_lock_mask_in_place);</span>
<span class="line-modified">3178   z_chi(temp_reg, markOopDesc::biased_lock_pattern);</span>
3179   z_brne(cas_label);  // Try cas if object is not biased, i.e. cannot be biased locked.
3180 
3181   load_prototype_header(temp_reg, obj_reg);
<a name="13" id="anc13"></a><span class="line-modified">3182   load_const_optimized(temp2_reg, ~((int) markOopDesc::age_mask_in_place));</span>
3183 
3184   z_ogr(temp_reg, Z_thread);
3185   z_xgr(temp_reg, mark_reg);
3186   z_ngr(temp_reg, temp2_reg);
3187   if (PrintBiasedLockingStatistics) {
3188     increment_counter_eq((address) BiasedLocking::biased_lock_entry_count_addr(), mark_reg, temp2_reg);
3189     // Restore mark_reg.
3190     z_lg(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);
3191   }
3192   branch_optimized(Assembler::bcondEqual, done);  // Biased lock obtained, return success.
3193 
3194   Label try_revoke_bias;
3195   Label try_rebias;
3196   Address mark_addr = Address(obj_reg, oopDesc::mark_offset_in_bytes());
3197 
3198   //----------------------------------------------------------------------------
3199   // At this point we know that the header has the bias pattern and
3200   // that we are not the bias owner in the current epoch. We need to
3201   // figure out more details about the state of the header in order to
3202   // know what operations can be legally performed on the object&#39;s
3203   // header.
3204 
3205   // If the low three bits in the xor result aren&#39;t clear, that means
3206   // the prototype header is no longer biased and we have to revoke
3207   // the bias on this object.
<a name="14" id="anc14"></a><span class="line-modified">3208   z_tmll(temp_reg, markOopDesc::biased_lock_mask_in_place);</span>
3209   z_brnaz(try_revoke_bias);
3210 
3211   // Biasing is still enabled for this data type. See whether the
3212   // epoch of the current bias is still valid, meaning that the epoch
3213   // bits of the mark word are equal to the epoch bits of the
3214   // prototype header. (Note that the prototype header&#39;s epoch bits
3215   // only change at a safepoint.) If not, attempt to rebias the object
3216   // toward the current thread. Note that we must be absolutely sure
3217   // that the current epoch is invalid in order to do this because
3218   // otherwise the manipulations it performs on the mark word are
3219   // illegal.
<a name="15" id="anc15"></a><span class="line-modified">3220   z_tmll(temp_reg, markOopDesc::epoch_mask_in_place);</span>
3221   z_brnaz(try_rebias);
3222 
3223   //----------------------------------------------------------------------------
3224   // The epoch of the current bias is still valid but we know nothing
3225   // about the owner; it might be set or it might be clear. Try to
3226   // acquire the bias of the object using an atomic operation. If this
3227   // fails we will go in to the runtime to revoke the object&#39;s bias.
3228   // Note that we first construct the presumed unbiased header so we
3229   // don&#39;t accidentally blow away another thread&#39;s valid bias.
<a name="16" id="anc16"></a><span class="line-modified">3230   z_nilf(mark_reg, markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place |</span>
<span class="line-modified">3231          markOopDesc::epoch_mask_in_place);</span>
3232   z_lgr(temp_reg, Z_thread);
3233   z_llgfr(mark_reg, mark_reg);
3234   z_ogr(temp_reg, mark_reg);
3235 
3236   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
3237 
3238   z_csg(mark_reg, temp_reg, 0, obj_reg);
3239 
3240   // If the biasing toward our thread failed, this means that
3241   // another thread succeeded in biasing it toward itself and we
3242   // need to revoke that bias. The revocation will occur in the
3243   // interpreter runtime in the slow case.
3244 
3245   if (PrintBiasedLockingStatistics) {
3246     increment_counter_eq((address) BiasedLocking::anonymously_biased_lock_entry_count_addr(),
3247                          temp_reg, temp2_reg);
3248   }
3249   if (slow_case != NULL) {
3250     branch_optimized(Assembler::bcondNotEqual, *slow_case); // Biased lock not obtained, need to go the long way.
3251   }
3252   branch_optimized(Assembler::bcondAlways, done);           // Biased lock status given in condition code.
3253 
3254   //----------------------------------------------------------------------------
3255   bind(try_rebias);
3256   // At this point we know the epoch has expired, meaning that the
3257   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
3258   // circumstances _only_, we are allowed to use the current header&#39;s
3259   // value as the comparison value when doing the cas to acquire the
3260   // bias in the current epoch. In other words, we allow transfer of
3261   // the bias from one thread to another directly in this situation.
3262 
<a name="17" id="anc17"></a><span class="line-modified">3263   z_nilf(mark_reg, markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place);</span>
3264   load_prototype_header(temp_reg, obj_reg);
3265   z_llgfr(mark_reg, mark_reg);
3266 
3267   z_ogr(temp_reg, Z_thread);
3268 
3269   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
3270 
3271   z_csg(mark_reg, temp_reg, 0, obj_reg);
3272 
3273   // If the biasing toward our thread failed, this means that
3274   // another thread succeeded in biasing it toward itself and we
3275   // need to revoke that bias. The revocation will occur in the
3276   // interpreter runtime in the slow case.
3277 
3278   if (PrintBiasedLockingStatistics) {
3279     increment_counter_eq((address) BiasedLocking::rebiased_lock_entry_count_addr(), temp_reg, temp2_reg);
3280   }
3281   if (slow_case != NULL) {
3282     branch_optimized(Assembler::bcondNotEqual, *slow_case);  // Biased lock not obtained, need to go the long way.
3283   }
3284   z_bru(done);           // Biased lock status given in condition code.
3285 
3286   //----------------------------------------------------------------------------
3287   bind(try_revoke_bias);
3288   // The prototype mark in the klass doesn&#39;t have the bias bit set any
3289   // more, indicating that objects of this data type are not supposed
3290   // to be biased any more. We are going to try to reset the mark of
3291   // this object to the prototype value and fall through to the
3292   // CAS-based locking scheme. Note that if our CAS fails, it means
3293   // that another thread raced us for the privilege of revoking the
3294   // bias of this particular object, so it&#39;s okay to continue in the
3295   // normal locking code.
3296   load_prototype_header(temp_reg, obj_reg);
3297 
3298   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
3299 
3300   z_csg(mark_reg, temp_reg, 0, obj_reg);
3301 
3302   // Fall through to the normal CAS-based lock, because no matter what
3303   // the result of the above CAS, some thread must have succeeded in
3304   // removing the bias bit from the object&#39;s header.
3305   if (PrintBiasedLockingStatistics) {
3306     // z_cgr(mark_reg, temp2_reg);
3307     increment_counter_eq((address) BiasedLocking::revoked_lock_entry_count_addr(), temp_reg, temp2_reg);
3308   }
3309 
3310   bind(cas_label);
3311   BLOCK_COMMENT(&quot;} biased_locking_enter&quot;);
3312 }
3313 
3314 void MacroAssembler::biased_locking_exit(Register mark_addr, Register temp_reg, Label&amp; done) {
3315   // Check for biased locking unlock case, which is a no-op
3316   // Note: we do not have to check the thread ID for two reasons.
3317   // First, the interpreter checks for IllegalMonitorStateException at
3318   // a higher level. Second, if the bias was revoked while we held the
3319   // lock, the object could not be rebiased toward another thread, so
3320   // the bias bit would be clear.
3321   BLOCK_COMMENT(&quot;biased_locking_exit {&quot;);
3322 
3323   z_lg(temp_reg, 0, mark_addr);
<a name="18" id="anc18"></a><span class="line-modified">3324   z_nilf(temp_reg, markOopDesc::biased_lock_mask_in_place);</span>
3325 
<a name="19" id="anc19"></a><span class="line-modified">3326   z_chi(temp_reg, markOopDesc::biased_lock_pattern);</span>
3327   z_bre(done);
3328   BLOCK_COMMENT(&quot;} biased_locking_exit&quot;);
3329 }
3330 
3331 void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {
3332   Register displacedHeader = temp1;
3333   Register currentHeader = temp1;
3334   Register temp = temp2;
3335   NearLabel done, object_has_monitor;
3336 
3337   BLOCK_COMMENT(&quot;compiler_fast_lock_object {&quot;);
3338 
<a name="20" id="anc20"></a><span class="line-modified">3339   // Load markOop from oop into mark.</span>
3340   z_lg(displacedHeader, 0, oop);
3341 
3342   if (try_bias) {
3343     biased_locking_enter(oop, displacedHeader, temp, Z_R0, done);
3344   }
3345 
3346   // Handle existing monitor.
3347   // The object has an existing monitor iff (mark &amp; monitor_value) != 0.
<a name="21" id="anc21"></a><span class="line-modified">3348   guarantee(Immediate::is_uimm16(markOopDesc::monitor_value), &quot;must be half-word&quot;);</span>
3349   z_lr(temp, displacedHeader);
<a name="22" id="anc22"></a><span class="line-modified">3350   z_nill(temp, markOopDesc::monitor_value);</span>
3351   z_brne(object_has_monitor);
3352 
<a name="23" id="anc23"></a><span class="line-modified">3353   // Set mark to markOop | markOopDesc::unlocked_value.</span>
<span class="line-modified">3354   z_oill(displacedHeader, markOopDesc::unlocked_value);</span>
3355 
3356   // Load Compare Value application register.
3357 
3358   // Initialize the box (must happen before we update the object mark).
3359   z_stg(displacedHeader, BasicLock::displaced_header_offset_in_bytes(), box);
3360 
3361   // Memory Fence (in cmpxchgd)
<a name="24" id="anc24"></a><span class="line-modified">3362   // Compare object markOop with mark and if equal exchange scratch1 with object markOop.</span>
3363 
3364   // If the compare-and-swap succeeded, then we found an unlocked object and we
3365   // have now locked it.
3366   z_csg(displacedHeader, box, 0, oop);
3367   assert(currentHeader==displacedHeader, &quot;must be same register&quot;); // Identified two registers from z/Architecture.
3368   z_bre(done);
3369 
3370   // We did not see an unlocked object so try the fast recursive case.
3371 
3372   z_sgr(currentHeader, Z_SP);
<a name="25" id="anc25"></a><span class="line-modified">3373   load_const_optimized(temp, (~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place));</span>
3374 
3375   z_ngr(currentHeader, temp);
3376   //   z_brne(done);
3377   //   z_release();
3378   z_stg(currentHeader/*==0 or not 0*/, BasicLock::displaced_header_offset_in_bytes(), box);
3379 
3380   z_bru(done);
3381 
3382   Register zero = temp;
<a name="26" id="anc26"></a><span class="line-modified">3383   Register monitor_tagged = displacedHeader; // Tagged with markOopDesc::monitor_value.</span>
3384   bind(object_has_monitor);
3385   // The object&#39;s monitor m is unlocked iff m-&gt;owner == NULL,
3386   // otherwise m-&gt;owner may contain a thread or a stack address.
3387   //
3388   // Try to CAS m-&gt;owner from NULL to current thread.
3389   z_lghi(zero, 0);
3390   // If m-&gt;owner is null, then csg succeeds and sets m-&gt;owner=THREAD and CR=EQ.
3391   z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor_tagged);
3392   // Store a non-null value into the box.
3393   z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);
3394 #ifdef ASSERT
3395   z_brne(done);
3396   // We&#39;ve acquired the monitor, check some invariants.
3397   // Invariant 1: _recursions should be 0.
3398   asm_assert_mem8_is_zero(OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions), monitor_tagged,
3399                           &quot;monitor-&gt;_recursions should be 0&quot;, -1);
3400   z_ltgr(zero, zero); // Set CR=EQ.
3401 #endif
3402   bind(done);
3403 
3404   BLOCK_COMMENT(&quot;} compiler_fast_lock_object&quot;);
3405   // If locking was successful, CR should indicate &#39;EQ&#39;.
3406   // The compiler or the native wrapper generates a branch to the runtime call
3407   // _complete_monitor_locking_Java.
3408 }
3409 
3410 void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {
3411   Register displacedHeader = temp1;
3412   Register currentHeader = temp2;
3413   Register temp = temp1;
3414   Register monitor = temp2;
3415 
3416   Label done, object_has_monitor;
3417 
3418   BLOCK_COMMENT(&quot;compiler_fast_unlock_object {&quot;);
3419 
3420   if (try_bias) {
3421     biased_locking_exit(oop, currentHeader, done);
3422   }
3423 
3424   // Find the lock address and load the displaced header from the stack.
3425   // if the displaced header is zero, we have a recursive unlock.
3426   load_and_test_long(displacedHeader, Address(box, BasicLock::displaced_header_offset_in_bytes()));
3427   z_bre(done);
3428 
3429   // Handle existing monitor.
3430   // The object has an existing monitor iff (mark &amp; monitor_value) != 0.
3431   z_lg(currentHeader, oopDesc::mark_offset_in_bytes(), oop);
<a name="27" id="anc27"></a><span class="line-modified">3432   guarantee(Immediate::is_uimm16(markOopDesc::monitor_value), &quot;must be half-word&quot;);</span>
<span class="line-modified">3433   z_nill(currentHeader, markOopDesc::monitor_value);</span>
3434   z_brne(object_has_monitor);
3435 
3436   // Check if it is still a light weight lock, this is true if we see
<a name="28" id="anc28"></a><span class="line-modified">3437   // the stack address of the basicLock in the markOop of the object</span>
3438   // copy box to currentHeader such that csg does not kill it.
3439   z_lgr(currentHeader, box);
3440   z_csg(currentHeader, displacedHeader, 0, oop);
3441   z_bru(done); // Csg sets CR as desired.
3442 
3443   // Handle existing monitor.
3444   bind(object_has_monitor);
3445   z_lg(currentHeader, oopDesc::mark_offset_in_bytes(), oop);    // CurrentHeader is tagged with monitor_value set.
3446   load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));
3447   z_brne(done);
3448   load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));
3449   z_brne(done);
3450   load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));
3451   z_brne(done);
3452   load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));
3453   z_brne(done);
3454   z_release();
3455   z_stg(temp/*=0*/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);
3456 
3457   bind(done);
3458 
3459   BLOCK_COMMENT(&quot;} compiler_fast_unlock_object&quot;);
3460   // flag == EQ indicates success
3461   // flag == NE indicates failure
3462 }
3463 
3464 void MacroAssembler::resolve_jobject(Register value, Register tmp1, Register tmp2) {
3465   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3466   bs-&gt;resolve_jobject(this, value, tmp1, tmp2);
3467 }
3468 
3469 // Last_Java_sp must comply to the rules in frame_s390.hpp.
3470 void MacroAssembler::set_last_Java_frame(Register last_Java_sp, Register last_Java_pc, bool allow_relocation) {
3471   BLOCK_COMMENT(&quot;set_last_Java_frame {&quot;);
3472 
3473   // Always set last_Java_pc and flags first because once last_Java_sp
3474   // is visible has_last_Java_frame is true and users will look at the
3475   // rest of the fields. (Note: flags should always be zero before we
3476   // get here so doesn&#39;t need to be set.)
3477 
3478   // Verify that last_Java_pc was zeroed on return to Java.
3479   if (allow_relocation) {
3480     asm_assert_mem8_is_zero(in_bytes(JavaThread::last_Java_pc_offset()),
3481                             Z_thread,
3482                             &quot;last_Java_pc not zeroed before leaving Java&quot;,
3483                             0x200);
3484   } else {
3485     asm_assert_mem8_is_zero_static(in_bytes(JavaThread::last_Java_pc_offset()),
3486                                    Z_thread,
3487                                    &quot;last_Java_pc not zeroed before leaving Java&quot;,
3488                                    0x200);
3489   }
3490 
3491   // When returning from calling out from Java mode the frame anchor&#39;s
3492   // last_Java_pc will always be set to NULL. It is set here so that
3493   // if we are doing a call to native (not VM) that we capture the
3494   // known pc and don&#39;t have to rely on the native call having a
3495   // standard frame linkage where we can find the pc.
3496   if (last_Java_pc!=noreg) {
3497     z_stg(last_Java_pc, Address(Z_thread, JavaThread::last_Java_pc_offset()));
3498   }
3499 
3500   // This membar release is not required on z/Architecture, since the sequence of stores
3501   // in maintained. Nevertheless, we leave it in to document the required ordering.
3502   // The implementation of z_release() should be empty.
3503   // z_release();
3504 
3505   z_stg(last_Java_sp, Address(Z_thread, JavaThread::last_Java_sp_offset()));
3506   BLOCK_COMMENT(&quot;} set_last_Java_frame&quot;);
3507 }
3508 
3509 void MacroAssembler::reset_last_Java_frame(bool allow_relocation) {
3510   BLOCK_COMMENT(&quot;reset_last_Java_frame {&quot;);
3511 
3512   if (allow_relocation) {
3513     asm_assert_mem8_isnot_zero(in_bytes(JavaThread::last_Java_sp_offset()),
3514                                Z_thread,
3515                                &quot;SP was not set, still zero&quot;,
3516                                0x202);
3517   } else {
3518     asm_assert_mem8_isnot_zero_static(in_bytes(JavaThread::last_Java_sp_offset()),
3519                                       Z_thread,
3520                                       &quot;SP was not set, still zero&quot;,
3521                                       0x202);
3522   }
3523 
3524   // _last_Java_sp = 0
3525   // Clearing storage must be atomic here, so don&#39;t use clear_mem()!
3526   store_const(Address(Z_thread, JavaThread::last_Java_sp_offset()), 0);
3527 
3528   // _last_Java_pc = 0
3529   store_const(Address(Z_thread, JavaThread::last_Java_pc_offset()), 0);
3530 
3531   BLOCK_COMMENT(&quot;} reset_last_Java_frame&quot;);
3532   return;
3533 }
3534 
3535 void MacroAssembler::set_top_ijava_frame_at_SP_as_last_Java_frame(Register sp, Register tmp1, bool allow_relocation) {
3536   assert_different_registers(sp, tmp1);
3537 
3538   // We cannot trust that code generated by the C++ compiler saves R14
3539   // to z_abi_160.return_pc, because sometimes it spills R14 using stmg at
3540   // z_abi_160.gpr14 (e.g. InterpreterRuntime::_new()).
3541   // Therefore we load the PC into tmp1 and let set_last_Java_frame() save
3542   // it into the frame anchor.
3543   get_PC(tmp1);
3544   set_last_Java_frame(/*sp=*/sp, /*pc=*/tmp1, allow_relocation);
3545 }
3546 
3547 void MacroAssembler::set_thread_state(JavaThreadState new_state) {
3548   z_release();
3549 
3550   assert(Immediate::is_uimm16(_thread_max_state), &quot;enum value out of range for instruction&quot;);
3551   assert(sizeof(JavaThreadState) == sizeof(int), &quot;enum value must have base type int&quot;);
3552   store_const(Address(Z_thread, JavaThread::thread_state_offset()), new_state, Z_R0, false);
3553 }
3554 
3555 void MacroAssembler::get_vm_result(Register oop_result) {
3556   verify_thread();
3557 
3558   z_lg(oop_result, Address(Z_thread, JavaThread::vm_result_offset()));
3559   clear_mem(Address(Z_thread, JavaThread::vm_result_offset()), sizeof(void*));
3560 
<a name="29" id="anc29"></a><span class="line-modified">3561   verify_oop(oop_result);</span>
3562 }
3563 
3564 void MacroAssembler::get_vm_result_2(Register result) {
3565   verify_thread();
3566 
3567   z_lg(result, Address(Z_thread, JavaThread::vm_result_2_offset()));
3568   clear_mem(Address(Z_thread, JavaThread::vm_result_2_offset()), sizeof(void*));
3569 }
3570 
3571 // We require that C code which does not return a value in vm_result will
3572 // leave it undisturbed.
3573 void MacroAssembler::set_vm_result(Register oop_result) {
3574   z_stg(oop_result, Address(Z_thread, JavaThread::vm_result_offset()));
3575 }
3576 
3577 // Explicit null checks (used for method handle code).
3578 void MacroAssembler::null_check(Register reg, Register tmp, int64_t offset) {
3579   if (!ImplicitNullChecks) {
3580     NearLabel ok;
3581 
3582     compare64_and_branch(reg, (intptr_t) 0, Assembler::bcondNotEqual, ok);
3583 
3584     // We just put the address into reg if it was 0 (tmp==Z_R0 is allowed so we can&#39;t use it for the address).
3585     address exception_entry = Interpreter::throw_NullPointerException_entry();
3586     load_absolute_address(reg, exception_entry);
3587     z_br(reg);
3588 
3589     bind(ok);
3590   } else {
3591     if (needs_explicit_null_check((intptr_t)offset)) {
3592       // Provoke OS NULL exception if reg = NULL by
3593       // accessing M[reg] w/o changing any registers.
3594       z_lg(tmp, 0, reg);
3595     }
3596     // else
3597       // Nothing to do, (later) access of M[reg + offset]
3598       // will provoke OS NULL exception if reg = NULL.
3599   }
3600 }
3601 
3602 //-------------------------------------
3603 //  Compressed Klass Pointers
3604 //-------------------------------------
3605 
3606 // Klass oop manipulations if compressed.
3607 void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
3608   Register current = (src != noreg) ? src : dst; // Klass is in dst if no src provided. (dst == src) also possible.
<a name="30" id="anc30"></a><span class="line-modified">3609   address  base    = Universe::narrow_klass_base();</span>
<span class="line-modified">3610   int      shift   = Universe::narrow_klass_shift();</span>
3611   assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3612 
3613   BLOCK_COMMENT(&quot;cKlass encoder {&quot;);
3614 
3615 #ifdef ASSERT
3616   Label ok;
3617   z_tmll(current, KlassAlignmentInBytes-1); // Check alignment.
3618   z_brc(Assembler::bcondAllZero, ok);
3619   // The plain disassembler does not recognize illtrap. It instead displays
3620   // a 32-bit value. Issueing two illtraps assures the disassembler finds
3621   // the proper beginning of the next instruction.
3622   z_illtrap(0xee);
3623   z_illtrap(0xee);
3624   bind(ok);
3625 #endif
3626 
3627   if (base != NULL) {
3628     unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3629     unsigned int base_l = (unsigned int)((unsigned long)base);
3630     if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3631       lgr_if_needed(dst, current);
3632       z_aih(dst, -((int)base_h));     // Base has no set bits in lower half.
3633     } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3634       lgr_if_needed(dst, current);
3635       z_agfi(dst, -(int)base_l);
3636     } else {
3637       load_const(Z_R0, base);
3638       lgr_if_needed(dst, current);
3639       z_sgr(dst, Z_R0);
3640     }
3641     current = dst;
3642   }
3643   if (shift != 0) {
3644     assert (LogKlassAlignmentInBytes == shift, &quot;decode alg wrong&quot;);
3645     z_srlg(dst, current, shift);
3646     current = dst;
3647   }
3648   lgr_if_needed(dst, current); // Move may be required (if neither base nor shift != 0).
3649 
3650   BLOCK_COMMENT(&quot;} cKlass encoder&quot;);
3651 }
3652 
3653 // This function calculates the size of the code generated by
3654 //   decode_klass_not_null(register dst, Register src)
3655 // when (Universe::heap() != NULL). Hence, if the instructions
3656 // it generates change, then this method needs to be updated.
3657 int MacroAssembler::instr_size_for_decode_klass_not_null() {
<a name="31" id="anc31"></a><span class="line-modified">3658   address  base    = Universe::narrow_klass_base();</span>
<span class="line-modified">3659   int shift_size   = Universe::narrow_klass_shift() == 0 ? 0 : 6; /* sllg */</span>
3660   int addbase_size = 0;
3661   assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3662 
3663   if (base != NULL) {
3664     unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3665     unsigned int base_l = (unsigned int)((unsigned long)base);
3666     if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3667       addbase_size += 6; /* aih */
3668     } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3669       addbase_size += 6; /* algfi */
3670     } else {
3671       addbase_size += load_const_size();
3672       addbase_size += 4; /* algr */
3673     }
3674   }
3675 #ifdef ASSERT
3676   addbase_size += 10;
3677   addbase_size += 2; // Extra sigill.
3678 #endif
3679   return addbase_size + shift_size;
3680 }
3681 
3682 // !!! If the instructions that get generated here change
3683 //     then function instr_size_for_decode_klass_not_null()
3684 //     needs to get updated.
3685 // This variant of decode_klass_not_null() must generate predictable code!
3686 // The code must only depend on globally known parameters.
3687 void MacroAssembler::decode_klass_not_null(Register dst) {
<a name="32" id="anc32"></a><span class="line-modified">3688   address  base    = Universe::narrow_klass_base();</span>
<span class="line-modified">3689   int      shift   = Universe::narrow_klass_shift();</span>
3690   int      beg_off = offset();
3691   assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3692 
3693   BLOCK_COMMENT(&quot;cKlass decoder (const size) {&quot;);
3694 
3695   if (shift != 0) { // Shift required?
3696     z_sllg(dst, dst, shift);
3697   }
3698   if (base != NULL) {
3699     unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3700     unsigned int base_l = (unsigned int)((unsigned long)base);
3701     if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3702       z_aih(dst, base_h);     // Base has no set bits in lower half.
3703     } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3704       z_algfi(dst, base_l);   // Base has no set bits in upper half.
3705     } else {
3706       load_const(Z_R0, base); // Base has set bits everywhere.
3707       z_algr(dst, Z_R0);
3708     }
3709   }
3710 
3711 #ifdef ASSERT
3712   Label ok;
3713   z_tmll(dst, KlassAlignmentInBytes-1); // Check alignment.
3714   z_brc(Assembler::bcondAllZero, ok);
3715   // The plain disassembler does not recognize illtrap. It instead displays
3716   // a 32-bit value. Issueing two illtraps assures the disassembler finds
3717   // the proper beginning of the next instruction.
3718   z_illtrap(0xd1);
3719   z_illtrap(0xd1);
3720   bind(ok);
3721 #endif
3722   assert(offset() == beg_off + instr_size_for_decode_klass_not_null(), &quot;Code gen mismatch.&quot;);
3723 
3724   BLOCK_COMMENT(&quot;} cKlass decoder (const size)&quot;);
3725 }
3726 
3727 // This variant of decode_klass_not_null() is for cases where
3728 //  1) the size of the generated instructions may vary
3729 //  2) the result is (potentially) stored in a register different from the source.
3730 void MacroAssembler::decode_klass_not_null(Register dst, Register src) {
<a name="33" id="anc33"></a><span class="line-modified">3731   address base  = Universe::narrow_klass_base();</span>
<span class="line-modified">3732   int     shift = Universe::narrow_klass_shift();</span>
3733   assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3734 
3735   BLOCK_COMMENT(&quot;cKlass decoder {&quot;);
3736 
3737   if (src == noreg) src = dst;
3738 
3739   if (shift != 0) { // Shift or at least move required?
3740     z_sllg(dst, src, shift);
3741   } else {
3742     lgr_if_needed(dst, src);
3743   }
3744 
3745   if (base != NULL) {
3746     unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3747     unsigned int base_l = (unsigned int)((unsigned long)base);
3748     if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3749       z_aih(dst, base_h);     // Base has not set bits in lower half.
3750     } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3751       z_algfi(dst, base_l);   // Base has no set bits in upper half.
3752     } else {
3753       load_const_optimized(Z_R0, base); // Base has set bits everywhere.
3754       z_algr(dst, Z_R0);
3755     }
3756   }
3757 
3758 #ifdef ASSERT
3759   Label ok;
3760   z_tmll(dst, KlassAlignmentInBytes-1); // Check alignment.
3761   z_brc(Assembler::bcondAllZero, ok);
3762   // The plain disassembler does not recognize illtrap. It instead displays
3763   // a 32-bit value. Issueing two illtraps assures the disassembler finds
3764   // the proper beginning of the next instruction.
3765   z_illtrap(0xd2);
3766   z_illtrap(0xd2);
3767   bind(ok);
3768 #endif
3769   BLOCK_COMMENT(&quot;} cKlass decoder&quot;);
3770 }
3771 
3772 void MacroAssembler::load_klass(Register klass, Address mem) {
3773   if (UseCompressedClassPointers) {
3774     z_llgf(klass, mem);
3775     // Attention: no null check here!
3776     decode_klass_not_null(klass);
3777   } else {
3778     z_lg(klass, mem);
3779   }
3780 }
3781 
3782 void MacroAssembler::load_klass(Register klass, Register src_oop) {
3783   if (UseCompressedClassPointers) {
3784     z_llgf(klass, oopDesc::klass_offset_in_bytes(), src_oop);
3785     // Attention: no null check here!
3786     decode_klass_not_null(klass);
3787   } else {
3788     z_lg(klass, oopDesc::klass_offset_in_bytes(), src_oop);
3789   }
3790 }
3791 
3792 void MacroAssembler::load_prototype_header(Register Rheader, Register Rsrc_oop) {
3793   assert_different_registers(Rheader, Rsrc_oop);
3794   load_klass(Rheader, Rsrc_oop);
3795   z_lg(Rheader, Address(Rheader, Klass::prototype_header_offset()));
3796 }
3797 
3798 void MacroAssembler::store_klass(Register klass, Register dst_oop, Register ck) {
3799   if (UseCompressedClassPointers) {
3800     assert_different_registers(dst_oop, klass, Z_R0);
3801     if (ck == noreg) ck = klass;
3802     encode_klass_not_null(ck, klass);
3803     z_st(ck, Address(dst_oop, oopDesc::klass_offset_in_bytes()));
3804   } else {
3805     z_stg(klass, Address(dst_oop, oopDesc::klass_offset_in_bytes()));
3806   }
3807 }
3808 
3809 void MacroAssembler::store_klass_gap(Register s, Register d) {
3810   if (UseCompressedClassPointers) {
3811     assert(s != d, &quot;not enough registers&quot;);
3812     // Support s = noreg.
3813     if (s != noreg) {
3814       z_st(s, Address(d, oopDesc::klass_gap_offset_in_bytes()));
3815     } else {
3816       z_mvhi(Address(d, oopDesc::klass_gap_offset_in_bytes()), 0);
3817     }
3818   }
3819 }
3820 
3821 // Compare klass ptr in memory against klass ptr in register.
3822 //
3823 // Rop1            - klass in register, always uncompressed.
3824 // disp            - Offset of klass in memory, compressed/uncompressed, depending on runtime flag.
3825 // Rbase           - Base address of cKlass in memory.
3826 // maybeNULL       - True if Rop1 possibly is a NULL.
3827 void MacroAssembler::compare_klass_ptr(Register Rop1, int64_t disp, Register Rbase, bool maybeNULL) {
3828 
3829   BLOCK_COMMENT(&quot;compare klass ptr {&quot;);
3830 
3831   if (UseCompressedClassPointers) {
<a name="34" id="anc34"></a><span class="line-modified">3832     const int shift = Universe::narrow_klass_shift();</span>
<span class="line-modified">3833     address   base  = Universe::narrow_klass_base();</span>
3834 
3835     assert((shift == 0) || (shift == LogKlassAlignmentInBytes), &quot;cKlass encoder detected bad shift&quot;);
3836     assert_different_registers(Rop1, Z_R0);
3837     assert_different_registers(Rop1, Rbase, Z_R1);
3838 
3839     // First encode register oop and then compare with cOop in memory.
3840     // This sequence saves an unnecessary cOop load and decode.
3841     if (base == NULL) {
3842       if (shift == 0) {
3843         z_cl(Rop1, disp, Rbase);     // Unscaled
3844       } else {
3845         z_srlg(Z_R0, Rop1, shift);   // ZeroBased
3846         z_cl(Z_R0, disp, Rbase);
3847       }
3848     } else {                         // HeapBased
3849 #ifdef ASSERT
3850       bool     used_R0 = true;
3851       bool     used_R1 = true;
3852 #endif
3853       Register current = Rop1;
3854       Label    done;
3855 
3856       if (maybeNULL) {       // NULL ptr must be preserved!
3857         z_ltgr(Z_R0, current);
3858         z_bre(done);
3859         current = Z_R0;
3860       }
3861 
3862       unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3863       unsigned int base_l = (unsigned int)((unsigned long)base);
3864       if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3865         lgr_if_needed(Z_R0, current);
3866         z_aih(Z_R0, -((int)base_h));     // Base has no set bits in lower half.
3867       } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3868         lgr_if_needed(Z_R0, current);
3869         z_agfi(Z_R0, -(int)base_l);
3870       } else {
3871         int pow2_offset = get_oop_base_complement(Z_R1, ((uint64_t)(intptr_t)base));
3872         add2reg_with_index(Z_R0, pow2_offset, Z_R1, Rop1); // Subtract base by adding complement.
3873       }
3874 
3875       if (shift != 0) {
3876         z_srlg(Z_R0, Z_R0, shift);
3877       }
3878       bind(done);
3879       z_cl(Z_R0, disp, Rbase);
3880 #ifdef ASSERT
3881       if (used_R0) preset_reg(Z_R0, 0xb05bUL, 2);
3882       if (used_R1) preset_reg(Z_R1, 0xb06bUL, 2);
3883 #endif
3884     }
3885   } else {
3886     z_clg(Rop1, disp, Z_R0, Rbase);
3887   }
3888   BLOCK_COMMENT(&quot;} compare klass ptr&quot;);
3889 }
3890 
3891 //---------------------------
3892 //  Compressed oops
3893 //---------------------------
3894 
3895 void MacroAssembler::encode_heap_oop(Register oop) {
3896   oop_encoder(oop, oop, true /*maybe null*/);
3897 }
3898 
3899 void MacroAssembler::encode_heap_oop_not_null(Register oop) {
3900   oop_encoder(oop, oop, false /*not null*/);
3901 }
3902 
3903 // Called with something derived from the oop base. e.g. oop_base&gt;&gt;3.
3904 int MacroAssembler::get_oop_base_pow2_offset(uint64_t oop_base) {
3905   unsigned int oop_base_ll = ((unsigned int)(oop_base &gt;&gt;  0)) &amp; 0xffff;
3906   unsigned int oop_base_lh = ((unsigned int)(oop_base &gt;&gt; 16)) &amp; 0xffff;
3907   unsigned int oop_base_hl = ((unsigned int)(oop_base &gt;&gt; 32)) &amp; 0xffff;
3908   unsigned int oop_base_hh = ((unsigned int)(oop_base &gt;&gt; 48)) &amp; 0xffff;
3909   unsigned int n_notzero_parts = (oop_base_ll == 0 ? 0:1)
3910                                + (oop_base_lh == 0 ? 0:1)
3911                                + (oop_base_hl == 0 ? 0:1)
3912                                + (oop_base_hh == 0 ? 0:1);
3913 
3914   assert(oop_base != 0, &quot;This is for HeapBased cOops only&quot;);
3915 
3916   if (n_notzero_parts != 1) { //  Check if oop_base is just a few pages shy of a power of 2.
3917     uint64_t pow2_offset = 0x10000 - oop_base_ll;
3918     if (pow2_offset &lt; 0x8000) {  // This might not be necessary.
3919       uint64_t oop_base2 = oop_base + pow2_offset;
3920 
3921       oop_base_ll = ((unsigned int)(oop_base2 &gt;&gt;  0)) &amp; 0xffff;
3922       oop_base_lh = ((unsigned int)(oop_base2 &gt;&gt; 16)) &amp; 0xffff;
3923       oop_base_hl = ((unsigned int)(oop_base2 &gt;&gt; 32)) &amp; 0xffff;
3924       oop_base_hh = ((unsigned int)(oop_base2 &gt;&gt; 48)) &amp; 0xffff;
3925       n_notzero_parts = (oop_base_ll == 0 ? 0:1) +
3926                         (oop_base_lh == 0 ? 0:1) +
3927                         (oop_base_hl == 0 ? 0:1) +
3928                         (oop_base_hh == 0 ? 0:1);
3929       if (n_notzero_parts == 1) {
3930         assert(-(int64_t)pow2_offset != (int64_t)-1, &quot;We use -1 to signal uninitialized base register&quot;);
3931         return -pow2_offset;
3932       }
3933     }
3934   }
3935   return 0;
3936 }
3937 
3938 // If base address is offset from a straight power of two by just a few pages,
3939 // return this offset to the caller for a possible later composite add.
3940 // TODO/FIX: will only work correctly for 4k pages.
3941 int MacroAssembler::get_oop_base(Register Rbase, uint64_t oop_base) {
3942   int pow2_offset = get_oop_base_pow2_offset(oop_base);
3943 
3944   load_const_optimized(Rbase, oop_base - pow2_offset); // Best job possible.
3945 
3946   return pow2_offset;
3947 }
3948 
3949 int MacroAssembler::get_oop_base_complement(Register Rbase, uint64_t oop_base) {
3950   int offset = get_oop_base(Rbase, oop_base);
3951   z_lcgr(Rbase, Rbase);
3952   return -offset;
3953 }
3954 
3955 // Compare compressed oop in memory against oop in register.
3956 // Rop1            - Oop in register.
3957 // disp            - Offset of cOop in memory.
3958 // Rbase           - Base address of cOop in memory.
3959 // maybeNULL       - True if Rop1 possibly is a NULL.
3960 // maybeNULLtarget - Branch target for Rop1 == NULL, if flow control shall NOT continue with compare instruction.
3961 void MacroAssembler::compare_heap_oop(Register Rop1, Address mem, bool maybeNULL) {
3962   Register Rbase  = mem.baseOrR0();
3963   Register Rindex = mem.indexOrR0();
3964   int64_t  disp   = mem.disp();
3965 
<a name="35" id="anc35"></a><span class="line-modified">3966   const int shift = Universe::narrow_oop_shift();</span>
<span class="line-modified">3967   address   base  = Universe::narrow_oop_base();</span>
3968 
3969   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
3970   assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this method&quot;);
3971   assert((shift == 0) || (shift == LogMinObjAlignmentInBytes), &quot;cOop encoder detected bad shift&quot;);
3972   assert_different_registers(Rop1, Z_R0);
3973   assert_different_registers(Rop1, Rbase, Z_R1);
3974   assert_different_registers(Rop1, Rindex, Z_R1);
3975 
3976   BLOCK_COMMENT(&quot;compare heap oop {&quot;);
3977 
3978   // First encode register oop and then compare with cOop in memory.
3979   // This sequence saves an unnecessary cOop load and decode.
3980   if (base == NULL) {
3981     if (shift == 0) {
3982       z_cl(Rop1, disp, Rindex, Rbase);  // Unscaled
3983     } else {
3984       z_srlg(Z_R0, Rop1, shift);        // ZeroBased
3985       z_cl(Z_R0, disp, Rindex, Rbase);
3986     }
3987   } else {                              // HeapBased
3988 #ifdef ASSERT
3989     bool  used_R0 = true;
3990     bool  used_R1 = true;
3991 #endif
3992     Label done;
3993     int   pow2_offset = get_oop_base_complement(Z_R1, ((uint64_t)(intptr_t)base));
3994 
3995     if (maybeNULL) {       // NULL ptr must be preserved!
3996       z_ltgr(Z_R0, Rop1);
3997       z_bre(done);
3998     }
3999 
4000     add2reg_with_index(Z_R0, pow2_offset, Z_R1, Rop1);
4001     z_srlg(Z_R0, Z_R0, shift);
4002 
4003     bind(done);
4004     z_cl(Z_R0, disp, Rindex, Rbase);
4005 #ifdef ASSERT
4006     if (used_R0) preset_reg(Z_R0, 0xb05bUL, 2);
4007     if (used_R1) preset_reg(Z_R1, 0xb06bUL, 2);
4008 #endif
4009   }
4010   BLOCK_COMMENT(&quot;} compare heap oop&quot;);
4011 }
4012 
4013 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators,
4014                                      const Address&amp; addr, Register val,
4015                                      Register tmp1, Register tmp2, Register tmp3) {
4016   assert((decorators &amp; ~(AS_RAW | IN_HEAP | IN_NATIVE | IS_ARRAY | IS_NOT_NULL |
4017                          ON_UNKNOWN_OOP_REF)) == 0, &quot;unsupported decorator&quot;);
4018   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4019   decorators = AccessInternal::decorator_fixup(decorators);
4020   bool as_raw = (decorators &amp; AS_RAW) != 0;
4021   if (as_raw) {
4022     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type,
4023                                       addr, val,
4024                                       tmp1, tmp2, tmp3);
4025   } else {
4026     bs-&gt;store_at(this, decorators, type,
4027                  addr, val,
4028                  tmp1, tmp2, tmp3);
4029   }
4030 }
4031 
4032 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators,
4033                                     const Address&amp; addr, Register dst,
4034                                     Register tmp1, Register tmp2, Label *is_null) {
4035   assert((decorators &amp; ~(AS_RAW | IN_HEAP | IN_NATIVE | IS_ARRAY | IS_NOT_NULL |
4036                          ON_PHANTOM_OOP_REF | ON_WEAK_OOP_REF)) == 0, &quot;unsupported decorator&quot;);
4037   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4038   decorators = AccessInternal::decorator_fixup(decorators);
4039   bool as_raw = (decorators &amp; AS_RAW) != 0;
4040   if (as_raw) {
4041     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type,
4042                                      addr, dst,
4043                                      tmp1, tmp2, is_null);
4044   } else {
4045     bs-&gt;load_at(this, decorators, type,
4046                 addr, dst,
4047                 tmp1, tmp2, is_null);
4048   }
4049 }
4050 
4051 void MacroAssembler::load_heap_oop(Register dest, const Address &amp;a,
4052                                    Register tmp1, Register tmp2,
4053                                    DecoratorSet decorators, Label *is_null) {
4054   access_load_at(T_OBJECT, IN_HEAP | decorators, a, dest, tmp1, tmp2, is_null);
4055 }
4056 
4057 void MacroAssembler::store_heap_oop(Register Roop, const Address &amp;a,
4058                                     Register tmp1, Register tmp2, Register tmp3,
4059                                     DecoratorSet decorators) {
4060   access_store_at(T_OBJECT, IN_HEAP | decorators, a, Roop, tmp1, tmp2, tmp3);
4061 }
4062 
4063 //-------------------------------------------------
4064 // Encode compressed oop. Generally usable encoder.
4065 //-------------------------------------------------
4066 // Rsrc - contains regular oop on entry. It remains unchanged.
4067 // Rdst - contains compressed oop on exit.
4068 // Rdst and Rsrc may indicate same register, in which case Rsrc does not remain unchanged.
4069 //
4070 // Rdst must not indicate scratch register Z_R1 (Z_R1_scratch) for functionality.
4071 // Rdst should not indicate scratch register Z_R0 (Z_R0_scratch) for performance.
4072 //
4073 // only32bitValid is set, if later code only uses the lower 32 bits. In this
4074 // case we must not fix the upper 32 bits.
4075 void MacroAssembler::oop_encoder(Register Rdst, Register Rsrc, bool maybeNULL,
4076                                  Register Rbase, int pow2_offset, bool only32bitValid) {
4077 
<a name="36" id="anc36"></a><span class="line-modified">4078   const address oop_base  = Universe::narrow_oop_base();</span>
<span class="line-modified">4079   const int     oop_shift = Universe::narrow_oop_shift();</span>
<span class="line-modified">4080   const bool    disjoint  = Universe::narrow_oop_base_disjoint();</span>
4081 
4082   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
4083   assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this encoder&quot;);
4084   assert((oop_shift == 0) || (oop_shift == LogMinObjAlignmentInBytes), &quot;cOop encoder detected bad shift&quot;);
4085 
4086   if (disjoint || (oop_base == NULL)) {
4087     BLOCK_COMMENT(&quot;cOop encoder zeroBase {&quot;);
4088     if (oop_shift == 0) {
4089       if (oop_base != NULL &amp;&amp; !only32bitValid) {
4090         z_llgfr(Rdst, Rsrc); // Clear upper bits in case the register will be decoded again.
4091       } else {
4092         lgr_if_needed(Rdst, Rsrc);
4093       }
4094     } else {
4095       z_srlg(Rdst, Rsrc, oop_shift);
4096       if (oop_base != NULL &amp;&amp; !only32bitValid) {
4097         z_llgfr(Rdst, Rdst); // Clear upper bits in case the register will be decoded again.
4098       }
4099     }
4100     BLOCK_COMMENT(&quot;} cOop encoder zeroBase&quot;);
4101     return;
4102   }
4103 
4104   bool used_R0 = false;
4105   bool used_R1 = false;
4106 
4107   BLOCK_COMMENT(&quot;cOop encoder general {&quot;);
4108   assert_different_registers(Rdst, Z_R1);
4109   assert_different_registers(Rsrc, Rbase);
4110   if (maybeNULL) {
4111     Label done;
4112     // We reorder shifting and subtracting, so that we can compare
4113     // and shift in parallel:
4114     //
4115     // cycle 0:  potential LoadN, base = &lt;const&gt;
4116     // cycle 1:  base = !base     dst = src &gt;&gt; 3,    cmp cr = (src != 0)
4117     // cycle 2:  if (cr) br,      dst = dst + base + offset
4118 
4119     // Get oop_base components.
4120     if (pow2_offset == -1) {
4121       if (Rdst == Rbase) {
4122         if (Rdst == Z_R1 || Rsrc == Z_R1) {
4123           Rbase = Z_R0;
4124           used_R0 = true;
4125         } else {
4126           Rdst = Z_R1;
4127           used_R1 = true;
4128         }
4129       }
4130       if (Rbase == Z_R1) {
4131         used_R1 = true;
4132       }
4133       pow2_offset = get_oop_base_complement(Rbase, ((uint64_t)(intptr_t)oop_base) &gt;&gt; oop_shift);
4134     }
4135     assert_different_registers(Rdst, Rbase);
4136 
4137     // Check for NULL oop (must be left alone) and shift.
4138     if (oop_shift != 0) {  // Shift out alignment bits
4139       if (((intptr_t)oop_base&amp;0xc000000000000000L) == 0L) { // We are sure: no single address will have the leftmost bit set.
4140         z_srag(Rdst, Rsrc, oop_shift);  // Arithmetic shift sets the condition code.
4141       } else {
4142         z_srlg(Rdst, Rsrc, oop_shift);
4143         z_ltgr(Rsrc, Rsrc);  // This is the recommended way of testing for zero.
4144         // This probably is faster, as it does not write a register. No!
4145         // z_cghi(Rsrc, 0);
4146       }
4147     } else {
4148       z_ltgr(Rdst, Rsrc);   // Move NULL to result register.
4149     }
4150     z_bre(done);
4151 
4152     // Subtract oop_base components.
4153     if ((Rdst == Z_R0) || (Rbase == Z_R0)) {
4154       z_algr(Rdst, Rbase);
4155       if (pow2_offset != 0) { add2reg(Rdst, pow2_offset); }
4156     } else {
4157       add2reg_with_index(Rdst, pow2_offset, Rbase, Rdst);
4158     }
4159     if (!only32bitValid) {
4160       z_llgfr(Rdst, Rdst); // Clear upper bits in case the register will be decoded again.
4161     }
4162     bind(done);
4163 
4164   } else {  // not null
4165     // Get oop_base components.
4166     if (pow2_offset == -1) {
4167       pow2_offset = get_oop_base_complement(Rbase, (uint64_t)(intptr_t)oop_base);
4168     }
4169 
4170     // Subtract oop_base components and shift.
4171     if (Rdst == Z_R0 || Rsrc == Z_R0 || Rbase == Z_R0) {
4172       // Don&#39;t use lay instruction.
4173       if (Rdst == Rsrc) {
4174         z_algr(Rdst, Rbase);
4175       } else {
4176         lgr_if_needed(Rdst, Rbase);
4177         z_algr(Rdst, Rsrc);
4178       }
4179       if (pow2_offset != 0) add2reg(Rdst, pow2_offset);
4180     } else {
4181       add2reg_with_index(Rdst, pow2_offset, Rbase, Rsrc);
4182     }
4183     if (oop_shift != 0) {   // Shift out alignment bits.
4184       z_srlg(Rdst, Rdst, oop_shift);
4185     }
4186     if (!only32bitValid) {
4187       z_llgfr(Rdst, Rdst); // Clear upper bits in case the register will be decoded again.
4188     }
4189   }
4190 #ifdef ASSERT
4191   if (used_R0 &amp;&amp; Rdst != Z_R0 &amp;&amp; Rsrc != Z_R0) { preset_reg(Z_R0, 0xb01bUL, 2); }
4192   if (used_R1 &amp;&amp; Rdst != Z_R1 &amp;&amp; Rsrc != Z_R1) { preset_reg(Z_R1, 0xb02bUL, 2); }
4193 #endif
4194   BLOCK_COMMENT(&quot;} cOop encoder general&quot;);
4195 }
4196 
4197 //-------------------------------------------------
4198 // decode compressed oop. Generally usable decoder.
4199 //-------------------------------------------------
4200 // Rsrc - contains compressed oop on entry.
4201 // Rdst - contains regular oop on exit.
4202 // Rdst and Rsrc may indicate same register.
4203 // Rdst must not be the same register as Rbase, if Rbase was preloaded (before call).
4204 // Rdst can be the same register as Rbase. Then, either Z_R0 or Z_R1 must be available as scratch.
4205 // Rbase - register to use for the base
4206 // pow2_offset - offset of base to nice value. If -1, base must be loaded.
4207 // For performance, it is good to
4208 //  - avoid Z_R0 for any of the argument registers.
4209 //  - keep Rdst and Rsrc distinct from Rbase. Rdst == Rsrc is ok for performance.
4210 //  - avoid Z_R1 for Rdst if Rdst == Rbase.
4211 void MacroAssembler::oop_decoder(Register Rdst, Register Rsrc, bool maybeNULL, Register Rbase, int pow2_offset) {
4212 
<a name="37" id="anc37"></a><span class="line-modified">4213   const address oop_base  = Universe::narrow_oop_base();</span>
<span class="line-modified">4214   const int     oop_shift = Universe::narrow_oop_shift();</span>
<span class="line-modified">4215   const bool    disjoint  = Universe::narrow_oop_base_disjoint();</span>
4216 
4217   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
4218   assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this decoder&quot;);
4219   assert((oop_shift == 0) || (oop_shift == LogMinObjAlignmentInBytes),
4220          &quot;cOop encoder detected bad shift&quot;);
4221 
4222   // cOops are always loaded zero-extended from memory. No explicit zero-extension necessary.
4223 
4224   if (oop_base != NULL) {
4225     unsigned int oop_base_hl = ((unsigned int)((uint64_t)(intptr_t)oop_base &gt;&gt; 32)) &amp; 0xffff;
4226     unsigned int oop_base_hh = ((unsigned int)((uint64_t)(intptr_t)oop_base &gt;&gt; 48)) &amp; 0xffff;
4227     unsigned int oop_base_hf = ((unsigned int)((uint64_t)(intptr_t)oop_base &gt;&gt; 32)) &amp; 0xFFFFffff;
4228     if (disjoint &amp;&amp; (oop_base_hl == 0 || oop_base_hh == 0)) {
4229       BLOCK_COMMENT(&quot;cOop decoder disjointBase {&quot;);
4230       // We do not need to load the base. Instead, we can install the upper bits
4231       // with an OR instead of an ADD.
4232       Label done;
4233 
4234       // Rsrc contains a narrow oop. Thus we are sure the leftmost &lt;oop_shift&gt; bits will never be set.
4235       if (maybeNULL) {  // NULL ptr must be preserved!
4236         z_slag(Rdst, Rsrc, oop_shift);  // Arithmetic shift sets the condition code.
4237         z_bre(done);
4238       } else {
4239         z_sllg(Rdst, Rsrc, oop_shift);  // Logical shift leaves condition code alone.
4240       }
4241       if ((oop_base_hl != 0) &amp;&amp; (oop_base_hh != 0)) {
4242         z_oihf(Rdst, oop_base_hf);
4243       } else if (oop_base_hl != 0) {
4244         z_oihl(Rdst, oop_base_hl);
4245       } else {
4246         assert(oop_base_hh != 0, &quot;not heapbased mode&quot;);
4247         z_oihh(Rdst, oop_base_hh);
4248       }
4249       bind(done);
4250       BLOCK_COMMENT(&quot;} cOop decoder disjointBase&quot;);
4251     } else {
4252       BLOCK_COMMENT(&quot;cOop decoder general {&quot;);
4253       // There are three decode steps:
4254       //   scale oop offset (shift left)
4255       //   get base (in reg) and pow2_offset (constant)
4256       //   add base, pow2_offset, and oop offset
4257       // The following register overlap situations may exist:
4258       // Rdst == Rsrc,  Rbase any other
4259       //   not a problem. Scaling in-place leaves Rbase undisturbed.
4260       //   Loading Rbase does not impact the scaled offset.
4261       // Rdst == Rbase, Rsrc  any other
4262       //   scaling would destroy a possibly preloaded Rbase. Loading Rbase
4263       //   would destroy the scaled offset.
4264       //   Remedy: use Rdst_tmp if Rbase has been preloaded.
4265       //           use Rbase_tmp if base has to be loaded.
4266       // Rsrc == Rbase, Rdst  any other
4267       //   Only possible without preloaded Rbase.
4268       //   Loading Rbase does not destroy compressed oop because it was scaled into Rdst before.
4269       // Rsrc == Rbase, Rdst == Rbase
4270       //   Only possible without preloaded Rbase.
4271       //   Loading Rbase would destroy compressed oop. Scaling in-place is ok.
4272       //   Remedy: use Rbase_tmp.
4273       //
4274       Label    done;
4275       Register Rdst_tmp       = Rdst;
4276       Register Rbase_tmp      = Rbase;
4277       bool     used_R0        = false;
4278       bool     used_R1        = false;
4279       bool     base_preloaded = pow2_offset &gt;= 0;
4280       guarantee(!(base_preloaded &amp;&amp; (Rsrc == Rbase)), &quot;Register clash, check caller&quot;);
4281       assert(oop_shift != 0, &quot;room for optimization&quot;);
4282 
4283       // Check if we need to use scratch registers.
4284       if (Rdst == Rbase) {
4285         assert(!(((Rdst == Z_R0) &amp;&amp; (Rsrc == Z_R1)) || ((Rdst == Z_R1) &amp;&amp; (Rsrc == Z_R0))), &quot;need a scratch reg&quot;);
4286         if (Rdst != Rsrc) {
4287           if (base_preloaded) { Rdst_tmp  = (Rdst == Z_R1) ? Z_R0 : Z_R1; }
4288           else                { Rbase_tmp = (Rdst == Z_R1) ? Z_R0 : Z_R1; }
4289         } else {
4290           Rbase_tmp = (Rdst == Z_R1) ? Z_R0 : Z_R1;
4291         }
4292       }
4293       if (base_preloaded) lgr_if_needed(Rbase_tmp, Rbase);
4294 
4295       // Scale oop and check for NULL.
4296       // Rsrc contains a narrow oop. Thus we are sure the leftmost &lt;oop_shift&gt; bits will never be set.
4297       if (maybeNULL) {  // NULL ptr must be preserved!
4298         z_slag(Rdst_tmp, Rsrc, oop_shift);  // Arithmetic shift sets the condition code.
4299         z_bre(done);
4300       } else {
4301         z_sllg(Rdst_tmp, Rsrc, oop_shift);  // Logical shift leaves condition code alone.
4302       }
4303 
4304       // Get oop_base components.
4305       if (!base_preloaded) {
4306         pow2_offset = get_oop_base(Rbase_tmp, (uint64_t)(intptr_t)oop_base);
4307       }
4308 
4309       // Add up all components.
4310       if ((Rbase_tmp == Z_R0) || (Rdst_tmp == Z_R0)) {
4311         z_algr(Rdst_tmp, Rbase_tmp);
4312         if (pow2_offset != 0) { add2reg(Rdst_tmp, pow2_offset); }
4313       } else {
4314         add2reg_with_index(Rdst_tmp, pow2_offset, Rbase_tmp, Rdst_tmp);
4315       }
4316 
4317       bind(done);
4318       lgr_if_needed(Rdst, Rdst_tmp);
4319 #ifdef ASSERT
4320       if (used_R0 &amp;&amp; Rdst != Z_R0 &amp;&amp; Rsrc != Z_R0) { preset_reg(Z_R0, 0xb03bUL, 2); }
4321       if (used_R1 &amp;&amp; Rdst != Z_R1 &amp;&amp; Rsrc != Z_R1) { preset_reg(Z_R1, 0xb04bUL, 2); }
4322 #endif
4323       BLOCK_COMMENT(&quot;} cOop decoder general&quot;);
4324     }
4325   } else {
4326     BLOCK_COMMENT(&quot;cOop decoder zeroBase {&quot;);
4327     if (oop_shift == 0) {
4328       lgr_if_needed(Rdst, Rsrc);
4329     } else {
4330       z_sllg(Rdst, Rsrc, oop_shift);
4331     }
4332     BLOCK_COMMENT(&quot;} cOop decoder zeroBase&quot;);
4333   }
4334 }
4335 
4336 // ((OopHandle)result).resolve();
4337 void MacroAssembler::resolve_oop_handle(Register result) {
4338   // OopHandle::resolve is an indirection.
4339   z_lg(result, 0, result);
4340 }
4341 
<a name="38" id="anc38"></a><span class="line-modified">4342 void MacroAssembler::load_mirror(Register mirror, Register method) {</span>
<span class="line-modified">4343   mem2reg_opt(mirror, Address(method, Method::const_offset()));</span>
<span class="line-removed">4344   mem2reg_opt(mirror, Address(mirror, ConstMethod::constants_offset()));</span>
4345   mem2reg_opt(mirror, Address(mirror, ConstantPool::pool_holder_offset_in_bytes()));
4346   mem2reg_opt(mirror, Address(mirror, Klass::java_mirror_offset()));
4347   resolve_oop_handle(mirror);
4348 }
4349 
<a name="39" id="anc39"></a>





4350 //---------------------------------------------------------------
4351 //---  Operations on arrays.
4352 //---------------------------------------------------------------
4353 
4354 // Compiler ensures base is doubleword aligned and cnt is #doublewords.
4355 // Emitter does not KILL cnt and base arguments, since they need to be copied to
4356 // work registers anyway.
4357 // Actually, only r0, r1, and r5 are killed.
<a name="40" id="anc40"></a><span class="line-modified">4358 unsigned int MacroAssembler::Clear_Array(Register cnt_arg, Register base_pointer_arg, Register src_addr, Register src_len) {</span>
<span class="line-removed">4359   // Src_addr is evenReg.</span>
<span class="line-removed">4360   // Src_len is odd_Reg.</span>
4361 
4362   int      block_start = offset();
<a name="41" id="anc41"></a><span class="line-removed">4363   Register tmp_reg  = src_len; // Holds target instr addr for EX.</span>
4364   Register dst_len  = Z_R1;    // Holds dst len  for MVCLE.
4365   Register dst_addr = Z_R0;    // Holds dst addr for MVCLE.
4366 
4367   Label doXC, doMVCLE, done;
4368 
4369   BLOCK_COMMENT(&quot;Clear_Array {&quot;);
4370 
4371   // Check for zero len and convert to long.
<a name="42" id="anc42"></a><span class="line-modified">4372   z_ltgfr(src_len, cnt_arg);      // Remember casted value for doSTG case.</span>
4373   z_bre(done);                    // Nothing to do if len == 0.
4374 
4375   // Prefetch data to be cleared.
4376   if (VM_Version::has_Prefetch()) {
4377     z_pfd(0x02,   0, Z_R0, base_pointer_arg);
4378     z_pfd(0x02, 256, Z_R0, base_pointer_arg);
4379   }
4380 
<a name="43" id="anc43"></a><span class="line-modified">4381   z_sllg(dst_len, src_len, 3);    // #bytes to clear.</span>
<span class="line-modified">4382   z_cghi(src_len, 32);            // Check for len &lt;= 256 bytes (&lt;=32 DW).</span>
<span class="line-modified">4383   z_brnh(doXC);                   // If so, use executed XC to clear.</span>
4384 
4385   // MVCLE: initialize long arrays (general case).
4386   bind(doMVCLE);
4387   z_lgr(dst_addr, base_pointer_arg);
<a name="44" id="anc44"></a><span class="line-modified">4388   clear_reg(src_len, true, false); // Src len of MVCLE is zero.</span>
<span class="line-modified">4389 </span>
<span class="line-modified">4390   MacroAssembler::move_long_ext(dst_addr, src_addr, 0);</span>

4391   z_bru(done);
4392 
4393   // XC: initialize short arrays.
4394   Label XC_template; // Instr template, never exec directly!
4395     bind(XC_template);
4396     z_xc(0,0,base_pointer_arg,0,base_pointer_arg);
4397 
4398   bind(doXC);
<a name="45" id="anc45"></a><span class="line-modified">4399     add2reg(dst_len, -1);             // Get #bytes-1 for EXECUTE.</span>
4400     if (VM_Version::has_ExecuteExtensions()) {
<a name="46" id="anc46"></a><span class="line-modified">4401       z_exrl(dst_len, XC_template);   // Execute XC with var. len.</span>
4402     } else {
<a name="47" id="anc47"></a><span class="line-modified">4403       z_larl(tmp_reg, XC_template);</span>
<span class="line-modified">4404       z_ex(dst_len,0,Z_R0,tmp_reg);   // Execute XC with var. len.</span>
4405     }
4406     // z_bru(done);      // fallthru
4407 
4408   bind(done);
4409 
4410   BLOCK_COMMENT(&quot;} Clear_Array&quot;);
4411 
4412   int block_end = offset();
4413   return block_end - block_start;
4414 }
4415 
4416 // Compiler ensures base is doubleword aligned and cnt is count of doublewords.
4417 // Emitter does not KILL any arguments nor work registers.
4418 // Emitter generates up to 16 XC instructions, depending on the array length.
4419 unsigned int MacroAssembler::Clear_Array_Const(long cnt, Register base) {
4420   int  block_start    = offset();
4421   int  off;
4422   int  lineSize_Bytes = AllocatePrefetchStepSize;
4423   int  lineSize_DW    = AllocatePrefetchStepSize&gt;&gt;LogBytesPerWord;
4424   bool doPrefetch     = VM_Version::has_Prefetch();
4425   int  XC_maxlen      = 256;
4426   int  numXCInstr     = cnt &gt; 0 ? (cnt*BytesPerWord-1)/XC_maxlen+1 : 0;
4427 
4428   BLOCK_COMMENT(&quot;Clear_Array_Const {&quot;);
4429   assert(cnt*BytesPerWord &lt;= 4096, &quot;ClearArrayConst can handle 4k only&quot;);
4430 
4431   // Do less prefetching for very short arrays.
4432   if (numXCInstr &gt; 0) {
4433     // Prefetch only some cache lines, then begin clearing.
4434     if (doPrefetch) {
4435       if (cnt*BytesPerWord &lt;= lineSize_Bytes/4) {  // If less than 1/4 of a cache line to clear,
4436         z_pfd(0x02, 0, Z_R0, base);                // prefetch just the first cache line.
4437       } else {
4438         assert(XC_maxlen == lineSize_Bytes, &quot;ClearArrayConst needs 256B cache lines&quot;);
4439         for (off = 0; (off &lt; AllocatePrefetchLines) &amp;&amp; (off &lt;= numXCInstr); off ++) {
4440           z_pfd(0x02, off*lineSize_Bytes, Z_R0, base);
4441         }
4442       }
4443     }
4444 
4445     for (off=0; off&lt;(numXCInstr-1); off++) {
4446       z_xc(off*XC_maxlen, XC_maxlen-1, base, off*XC_maxlen, base);
4447 
4448       // Prefetch some cache lines in advance.
4449       if (doPrefetch &amp;&amp; (off &lt;= numXCInstr-AllocatePrefetchLines)) {
4450         z_pfd(0x02, (off+AllocatePrefetchLines)*lineSize_Bytes, Z_R0, base);
4451       }
4452     }
4453     if (off*XC_maxlen &lt; cnt*BytesPerWord) {
4454       z_xc(off*XC_maxlen, (cnt*BytesPerWord-off*XC_maxlen)-1, base, off*XC_maxlen, base);
4455     }
4456   }
4457   BLOCK_COMMENT(&quot;} Clear_Array_Const&quot;);
4458 
4459   int block_end = offset();
4460   return block_end - block_start;
4461 }
4462 
4463 // Compiler ensures base is doubleword aligned and cnt is #doublewords.
4464 // Emitter does not KILL cnt and base arguments, since they need to be copied to
4465 // work registers anyway.
<a name="48" id="anc48"></a><span class="line-modified">4466 // Actually, only r0, r1, r4, and r5 (which are work registers) are killed.</span>
4467 //
4468 // For very large arrays, exploit MVCLE H/W support.
4469 // MVCLE instruction automatically exploits H/W-optimized page mover.
4470 // - Bytes up to next page boundary are cleared with a series of XC to self.
4471 // - All full pages are cleared with the page mover H/W assist.
4472 // - Remaining bytes are again cleared by a series of XC to self.
4473 //
<a name="49" id="anc49"></a><span class="line-modified">4474 unsigned int MacroAssembler::Clear_Array_Const_Big(long cnt, Register base_pointer_arg, Register src_addr, Register src_len) {</span>
<span class="line-removed">4475   // Src_addr is evenReg.</span>
<span class="line-removed">4476   // Src_len is odd_Reg.</span>
4477 
4478   int      block_start = offset();
4479   Register dst_len  = Z_R1;      // Holds dst len  for MVCLE.
4480   Register dst_addr = Z_R0;      // Holds dst addr for MVCLE.
4481 
4482   BLOCK_COMMENT(&quot;Clear_Array_Const_Big {&quot;);
4483 
4484   // Get len to clear.
4485   load_const_optimized(dst_len, (long)cnt*8L);  // in Bytes = #DW*8
4486 
4487   // Prepare other args to MVCLE.
4488   z_lgr(dst_addr, base_pointer_arg);
<a name="50" id="anc50"></a><span class="line-modified">4489   // Indicate unused result.</span>
<span class="line-modified">4490   (void) clear_reg(src_len, true, false);  // Src len of MVCLE is zero.</span>
<span class="line-modified">4491 </span>
<span class="line-modified">4492   // Clear.</span>
<span class="line-removed">4493   MacroAssembler::move_long_ext(dst_addr, src_addr, 0);</span>
4494   BLOCK_COMMENT(&quot;} Clear_Array_Const_Big&quot;);
4495 
4496   int block_end = offset();
4497   return block_end - block_start;
4498 }
4499 
4500 // Allocator.
4501 unsigned int MacroAssembler::CopyRawMemory_AlignedDisjoint(Register src_reg, Register dst_reg,
4502                                                            Register cnt_reg,
4503                                                            Register tmp1_reg, Register tmp2_reg) {
4504   // Tmp1 is oddReg.
4505   // Tmp2 is evenReg.
4506 
4507   int block_start = offset();
4508   Label doMVC, doMVCLE, done, MVC_template;
4509 
4510   BLOCK_COMMENT(&quot;CopyRawMemory_AlignedDisjoint {&quot;);
4511 
4512   // Check for zero len and convert to long.
4513   z_ltgfr(cnt_reg, cnt_reg);      // Remember casted value for doSTG case.
4514   z_bre(done);                    // Nothing to do if len == 0.
4515 
4516   z_sllg(Z_R1, cnt_reg, 3);       // Dst len in bytes. calc early to have the result ready.
4517 
4518   z_cghi(cnt_reg, 32);            // Check for len &lt;= 256 bytes (&lt;=32 DW).
4519   z_brnh(doMVC);                  // If so, use executed MVC to clear.
4520 
4521   bind(doMVCLE);                  // A lot of data (more than 256 bytes).
4522   // Prep dest reg pair.
4523   z_lgr(Z_R0, dst_reg);           // dst addr
4524   // Dst len already in Z_R1.
4525   // Prep src reg pair.
4526   z_lgr(tmp2_reg, src_reg);       // src addr
4527   z_lgr(tmp1_reg, Z_R1);          // Src len same as dst len.
4528 
4529   // Do the copy.
4530   move_long_ext(Z_R0, tmp2_reg, 0xb0); // Bypass cache.
4531   z_bru(done);                         // All done.
4532 
4533   bind(MVC_template);             // Just some data (not more than 256 bytes).
4534   z_mvc(0, 0, dst_reg, 0, src_reg);
4535 
4536   bind(doMVC);
4537 
4538   if (VM_Version::has_ExecuteExtensions()) {
4539     add2reg(Z_R1, -1);
4540   } else {
4541     add2reg(tmp1_reg, -1, Z_R1);
4542     z_larl(Z_R1, MVC_template);
4543   }
4544 
4545   if (VM_Version::has_Prefetch()) {
4546     z_pfd(1,  0,Z_R0,src_reg);
4547     z_pfd(2,  0,Z_R0,dst_reg);
4548     //    z_pfd(1,256,Z_R0,src_reg);    // Assume very short copy.
4549     //    z_pfd(2,256,Z_R0,dst_reg);
4550   }
4551 
4552   if (VM_Version::has_ExecuteExtensions()) {
4553     z_exrl(Z_R1, MVC_template);
4554   } else {
4555     z_ex(tmp1_reg, 0, Z_R0, Z_R1);
4556   }
4557 
4558   bind(done);
4559 
4560   BLOCK_COMMENT(&quot;} CopyRawMemory_AlignedDisjoint&quot;);
4561 
4562   int block_end = offset();
4563   return block_end - block_start;
4564 }
4565 
<a name="51" id="anc51"></a>
4566 //------------------------------------------------------
4567 //   Special String Intrinsics. Implementation
4568 //------------------------------------------------------
4569 
4570 // Intrinsics for CompactStrings
4571 
4572 // Compress char[] to byte[].
4573 //   Restores: src, dst
4574 //   Uses:     cnt
4575 //   Kills:    tmp, Z_R0, Z_R1.
4576 //   Early clobber: result.
4577 // Note:
4578 //   cnt is signed int. Do not rely on high word!
4579 //       counts # characters, not bytes.
4580 // The result is the number of characters copied before the first incompatible character was found.
4581 // If precise is true, the processing stops exactly at this point. Otherwise, the result may be off
4582 // by a few bytes. The result always indicates the number of copied characters.
4583 // When used as a character index, the returned value points to the first incompatible character.
4584 //
4585 // Note: Does not behave exactly like package private StringUTF16 compress java implementation in case of failure:
4586 // - Different number of characters may have been written to dead array (if precise is false).
4587 // - Returns a number &lt;cnt instead of 0. (Result gets compared with cnt.)
4588 unsigned int MacroAssembler::string_compress(Register result, Register src, Register dst, Register cnt,
4589                                              Register tmp,    bool precise) {
4590   assert_different_registers(Z_R0, Z_R1, result, src, dst, cnt, tmp);
4591 
4592   if (precise) {
4593     BLOCK_COMMENT(&quot;encode_iso_array {&quot;);
4594   } else {
4595     BLOCK_COMMENT(&quot;string_compress {&quot;);
4596   }
4597   int  block_start = offset();
4598 
4599   Register       Rsrc  = src;
4600   Register       Rdst  = dst;
4601   Register       Rix   = tmp;
4602   Register       Rcnt  = cnt;
4603   Register       Rmask = result;  // holds incompatibility check mask until result value is stored.
4604   Label          ScalarShortcut, AllDone;
4605 
4606   z_iilf(Rmask, 0xFF00FF00);
4607   z_iihf(Rmask, 0xFF00FF00);
4608 
4609 #if 0  // Sacrifice shortcuts for code compactness
4610   {
4611     //---&lt;  shortcuts for short strings (very frequent)   &gt;---
4612     //   Strings with 4 and 8 characters were fond to occur very frequently.
4613     //   Therefore, we handle them right away with minimal overhead.
4614     Label     skipShortcut, skip4Shortcut, skip8Shortcut;
4615     Register  Rout = Z_R0;
4616     z_chi(Rcnt, 4);
4617     z_brne(skip4Shortcut);                 // 4 characters are very frequent
4618       z_lg(Z_R0, 0, Rsrc);                 // Treat exactly 4 characters specially.
4619       if (VM_Version::has_DistinctOpnds()) {
4620         Rout = Z_R0;
4621         z_ngrk(Rix, Z_R0, Rmask);
4622       } else {
4623         Rout = Rix;
4624         z_lgr(Rix, Z_R0);
4625         z_ngr(Z_R0, Rmask);
4626       }
4627       z_brnz(skipShortcut);
4628       z_stcmh(Rout, 5, 0, Rdst);
4629       z_stcm(Rout,  5, 2, Rdst);
4630       z_lgfr(result, Rcnt);
4631       z_bru(AllDone);
4632     bind(skip4Shortcut);
4633 
4634     z_chi(Rcnt, 8);
4635     z_brne(skip8Shortcut);                 // There&#39;s more to do...
4636       z_lmg(Z_R0, Z_R1, 0, Rsrc);          // Treat exactly 8 characters specially.
4637       if (VM_Version::has_DistinctOpnds()) {
4638         Rout = Z_R0;
4639         z_ogrk(Rix, Z_R0, Z_R1);
4640         z_ngr(Rix, Rmask);
4641       } else {
4642         Rout = Rix;
4643         z_lgr(Rix, Z_R0);
4644         z_ogr(Z_R0, Z_R1);
4645         z_ngr(Z_R0, Rmask);
4646       }
4647       z_brnz(skipShortcut);
4648       z_stcmh(Rout, 5, 0, Rdst);
4649       z_stcm(Rout,  5, 2, Rdst);
4650       z_stcmh(Z_R1, 5, 4, Rdst);
4651       z_stcm(Z_R1,  5, 6, Rdst);
4652       z_lgfr(result, Rcnt);
4653       z_bru(AllDone);
4654 
4655     bind(skip8Shortcut);
4656     clear_reg(Z_R0, true, false);          // #characters already processed (none). Precond for scalar loop.
4657     z_brl(ScalarShortcut);                 // Just a few characters
4658 
4659     bind(skipShortcut);
4660   }
4661 #endif
4662   clear_reg(Z_R0);                         // make sure register is properly initialized.
4663 
4664   if (VM_Version::has_VectorFacility()) {
4665     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.
4666                                            // Otherwise just do nothing in vector mode.
4667                                            // Must be multiple of 2*(vector register length in chars (8 HW = 128 bits)).
4668     const int  log_min_vcnt = exact_log2(min_vcnt);
4669     Label      VectorLoop, VectorDone, VectorBreak;
4670 
4671     VectorRegister Vtmp1      = Z_V16;
4672     VectorRegister Vtmp2      = Z_V17;
4673     VectorRegister Vmask      = Z_V18;
4674     VectorRegister Vzero      = Z_V19;
4675     VectorRegister Vsrc_first = Z_V20;
4676     VectorRegister Vsrc_last  = Z_V23;
4677 
4678     assert((Vsrc_last-&gt;encoding() - Vsrc_first-&gt;encoding() + 1) == min_vcnt/8, &quot;logic error&quot;);
4679     assert(VM_Version::has_DistinctOpnds(), &quot;Assumption when has_VectorFacility()&quot;);
4680     z_srak(Rix, Rcnt, log_min_vcnt);       // # vector loop iterations
4681     z_brz(VectorDone);                     // not enough data for vector loop
4682 
4683     z_vzero(Vzero);                        // all zeroes
4684     z_vgmh(Vmask, 0, 7);                   // generate 0xff00 mask for all 2-byte elements
4685     z_sllg(Z_R0, Rix, log_min_vcnt);       // remember #chars that will be processed by vector loop
4686 
4687     bind(VectorLoop);
4688       z_vlm(Vsrc_first, Vsrc_last, 0, Rsrc);
4689       add2reg(Rsrc, min_vcnt*2);
4690 
4691       //---&lt;  check for incompatible character  &gt;---
4692       z_vo(Vtmp1, Z_V20, Z_V21);
4693       z_vo(Vtmp2, Z_V22, Z_V23);
4694       z_vo(Vtmp1, Vtmp1, Vtmp2);
4695       z_vn(Vtmp1, Vtmp1, Vmask);
4696       z_vceqhs(Vtmp1, Vtmp1, Vzero);       // high half of all chars must be zero for successful compress.
4697       z_bvnt(VectorBreak);                 // break vector loop if not all vector elements compare eq -&gt; incompatible character found.
4698                                            // re-process data from current iteration in break handler.
4699 
4700       //---&lt;  pack &amp; store characters  &gt;---
4701       z_vpkh(Vtmp1, Z_V20, Z_V21);         // pack (src1, src2) -&gt; tmp1
4702       z_vpkh(Vtmp2, Z_V22, Z_V23);         // pack (src3, src4) -&gt; tmp2
4703       z_vstm(Vtmp1, Vtmp2, 0, Rdst);       // store packed string
4704       add2reg(Rdst, min_vcnt);
4705 
4706       z_brct(Rix, VectorLoop);
4707 
4708     z_bru(VectorDone);
4709 
4710     bind(VectorBreak);
4711       add2reg(Rsrc, -min_vcnt*2);          // Fix Rsrc. Rsrc was already updated, but Rdst and Rix are not.
4712       z_sll(Rix, log_min_vcnt);            // # chars processed so far in VectorLoop, excl. current iteration.
4713       z_sr(Z_R0, Rix);                     // correct # chars processed in total.
4714 
4715     bind(VectorDone);
4716   }
4717 
4718   {
4719     const int  min_cnt     =  8;           // Minimum #characters required to use unrolled loop.
4720                                            // Otherwise just do nothing in unrolled loop.
4721                                            // Must be multiple of 8.
4722     const int  log_min_cnt = exact_log2(min_cnt);
4723     Label      UnrolledLoop, UnrolledDone, UnrolledBreak;
4724 
4725     if (VM_Version::has_DistinctOpnds()) {
4726       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to compress in unrolled loop
4727     } else {
4728       z_lr(Rix, Rcnt);
4729       z_sr(Rix, Z_R0);
4730     }
4731     z_sra(Rix, log_min_cnt);             // unrolled loop count
4732     z_brz(UnrolledDone);
4733 
4734     bind(UnrolledLoop);
4735       z_lmg(Z_R0, Z_R1, 0, Rsrc);
4736       if (precise) {
4737         z_ogr(Z_R1, Z_R0);                 // check all 8 chars for incompatibility
4738         z_ngr(Z_R1, Rmask);
4739         z_brnz(UnrolledBreak);
4740 
4741         z_lg(Z_R1, 8, Rsrc);               // reload destroyed register
4742         z_stcmh(Z_R0, 5, 0, Rdst);
4743         z_stcm(Z_R0,  5, 2, Rdst);
4744       } else {
4745         z_stcmh(Z_R0, 5, 0, Rdst);
4746         z_stcm(Z_R0,  5, 2, Rdst);
4747 
4748         z_ogr(Z_R0, Z_R1);
4749         z_ngr(Z_R0, Rmask);
4750         z_brnz(UnrolledBreak);
4751       }
4752       z_stcmh(Z_R1, 5, 4, Rdst);
4753       z_stcm(Z_R1,  5, 6, Rdst);
4754 
4755       add2reg(Rsrc, min_cnt*2);
4756       add2reg(Rdst, min_cnt);
4757       z_brct(Rix, UnrolledLoop);
4758 
4759     z_lgfr(Z_R0, Rcnt);                    // # chars processed in total after unrolled loop.
4760     z_nilf(Z_R0, ~(min_cnt-1));
4761     z_tmll(Rcnt, min_cnt-1);
4762     z_brnaz(ScalarShortcut);               // if all bits zero, there is nothing left to do for scalar loop.
4763                                            // Rix == 0 in all cases.
4764     z_sllg(Z_R1, Rcnt, 1);                 // # src bytes already processed. Only lower 32 bits are valid!
4765                                            //   Z_R1 contents must be treated as unsigned operand! For huge strings,
4766                                            //   (Rcnt &gt;= 2**30), the value may spill into the sign bit by sllg.
4767     z_lgfr(result, Rcnt);                  // all characters processed.
4768     z_slgfr(Rdst, Rcnt);                   // restore ptr
4769     z_slgfr(Rsrc, Z_R1);                   // restore ptr, double the element count for Rsrc restore
4770     z_bru(AllDone);
4771 
4772     bind(UnrolledBreak);
4773     z_lgfr(Z_R0, Rcnt);                    // # chars processed in total after unrolled loop
4774     z_nilf(Z_R0, ~(min_cnt-1));
4775     z_sll(Rix, log_min_cnt);               // # chars not yet processed in UnrolledLoop (due to break), broken iteration not included.
4776     z_sr(Z_R0, Rix);                       // fix # chars processed OK so far.
4777     if (!precise) {
4778       z_lgfr(result, Z_R0);
4779       z_sllg(Z_R1, Z_R0, 1);               // # src bytes already processed. Only lower 32 bits are valid!
4780                                            //   Z_R1 contents must be treated as unsigned operand! For huge strings,
4781                                            //   (Rcnt &gt;= 2**30), the value may spill into the sign bit by sllg.
4782       z_aghi(result, min_cnt/2);           // min_cnt/2 characters have already been written
4783                                            // but ptrs were not updated yet.
4784       z_slgfr(Rdst, Z_R0);                 // restore ptr
4785       z_slgfr(Rsrc, Z_R1);                 // restore ptr, double the element count for Rsrc restore
4786       z_bru(AllDone);
4787     }
4788     bind(UnrolledDone);
4789   }
4790 
4791   {
4792     Label     ScalarLoop, ScalarDone, ScalarBreak;
4793 
4794     bind(ScalarShortcut);
4795     z_ltgfr(result, Rcnt);
4796     z_brz(AllDone);
4797 
4798 #if 0  // Sacrifice shortcuts for code compactness
4799     {
4800       //---&lt;  Special treatment for very short strings (one or two characters)  &gt;---
4801       //   For these strings, we are sure that the above code was skipped.
4802       //   Thus, no registers were modified, register restore is not required.
4803       Label     ScalarDoit, Scalar2Char;
4804       z_chi(Rcnt, 2);
4805       z_brh(ScalarDoit);
4806       z_llh(Z_R1,  0, Z_R0, Rsrc);
4807       z_bre(Scalar2Char);
4808       z_tmll(Z_R1, 0xff00);
4809       z_lghi(result, 0);                   // cnt == 1, first char invalid, no chars successfully processed
4810       z_brnaz(AllDone);
4811       z_stc(Z_R1,  0, Z_R0, Rdst);
4812       z_lghi(result, 1);
4813       z_bru(AllDone);
4814 
4815       bind(Scalar2Char);
4816       z_llh(Z_R0,  2, Z_R0, Rsrc);
4817       z_tmll(Z_R1, 0xff00);
4818       z_lghi(result, 0);                   // cnt == 2, first char invalid, no chars successfully processed
4819       z_brnaz(AllDone);
4820       z_stc(Z_R1,  0, Z_R0, Rdst);
4821       z_tmll(Z_R0, 0xff00);
4822       z_lghi(result, 1);                   // cnt == 2, second char invalid, one char successfully processed
4823       z_brnaz(AllDone);
4824       z_stc(Z_R0,  1, Z_R0, Rdst);
4825       z_lghi(result, 2);
4826       z_bru(AllDone);
4827 
4828       bind(ScalarDoit);
4829     }
4830 #endif
4831 
4832     if (VM_Version::has_DistinctOpnds()) {
4833       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to compress in unrolled loop
4834     } else {
4835       z_lr(Rix, Rcnt);
4836       z_sr(Rix, Z_R0);
4837     }
4838     z_lgfr(result, Rcnt);                  // # processed characters (if all runs ok).
4839     z_brz(ScalarDone);                     // uses CC from Rix calculation
4840 
4841     bind(ScalarLoop);
4842       z_llh(Z_R1, 0, Z_R0, Rsrc);
4843       z_tmll(Z_R1, 0xff00);
4844       z_brnaz(ScalarBreak);
4845       z_stc(Z_R1, 0, Z_R0, Rdst);
4846       add2reg(Rsrc, 2);
4847       add2reg(Rdst, 1);
4848       z_brct(Rix, ScalarLoop);
4849 
4850     z_bru(ScalarDone);
4851 
4852     bind(ScalarBreak);
4853     z_sr(result, Rix);
4854 
4855     bind(ScalarDone);
4856     z_sgfr(Rdst, result);                  // restore ptr
4857     z_sgfr(Rsrc, result);                  // restore ptr, double the element count for Rsrc restore
4858     z_sgfr(Rsrc, result);
4859   }
4860   bind(AllDone);
4861 
4862   if (precise) {
4863     BLOCK_COMMENT(&quot;} encode_iso_array&quot;);
4864   } else {
4865     BLOCK_COMMENT(&quot;} string_compress&quot;);
4866   }
4867   return offset() - block_start;
4868 }
4869 
4870 // Inflate byte[] to char[].
4871 unsigned int MacroAssembler::string_inflate_trot(Register src, Register dst, Register cnt, Register tmp) {
4872   int block_start = offset();
4873 
4874   BLOCK_COMMENT(&quot;string_inflate {&quot;);
4875 
4876   Register stop_char = Z_R0;
4877   Register table     = Z_R1;
4878   Register src_addr  = tmp;
4879 
4880   assert_different_registers(Z_R0, Z_R1, tmp, src, dst, cnt);
4881   assert(dst-&gt;encoding()%2 == 0, &quot;must be even reg&quot;);
4882   assert(cnt-&gt;encoding()%2 == 1, &quot;must be odd reg&quot;);
4883   assert(cnt-&gt;encoding() - dst-&gt;encoding() == 1, &quot;must be even/odd pair&quot;);
4884 
4885   StubRoutines::zarch::generate_load_trot_table_addr(this, table);  // kills Z_R0 (if ASSERT)
4886   clear_reg(stop_char);  // Stop character. Not used here, but initialized to have a defined value.
4887   lgr_if_needed(src_addr, src);
4888   z_llgfr(cnt, cnt);     // # src characters, must be a positive simm32.
4889 
4890   translate_ot(dst, src_addr, /* mask = */ 0x0001);
4891 
4892   BLOCK_COMMENT(&quot;} string_inflate&quot;);
4893 
4894   return offset() - block_start;
4895 }
4896 
4897 // Inflate byte[] to char[].
4898 //   Restores: src, dst
4899 //   Uses:     cnt
4900 //   Kills:    tmp, Z_R0, Z_R1.
4901 // Note:
4902 //   cnt is signed int. Do not rely on high word!
4903 //       counts # characters, not bytes.
4904 unsigned int MacroAssembler::string_inflate(Register src, Register dst, Register cnt, Register tmp) {
4905   assert_different_registers(Z_R0, Z_R1, src, dst, cnt, tmp);
4906 
4907   BLOCK_COMMENT(&quot;string_inflate {&quot;);
4908   int block_start = offset();
4909 
4910   Register   Rcnt = cnt;   // # characters (src: bytes, dst: char (2-byte)), remaining after current loop.
4911   Register   Rix  = tmp;   // loop index
4912   Register   Rsrc = src;   // addr(src array)
4913   Register   Rdst = dst;   // addr(dst array)
4914   Label      ScalarShortcut, AllDone;
4915 
4916 #if 0  // Sacrifice shortcuts for code compactness
4917   {
4918     //---&lt;  shortcuts for short strings (very frequent)   &gt;---
4919     Label   skipShortcut, skip4Shortcut;
4920     z_ltr(Rcnt, Rcnt);                     // absolutely nothing to do for strings of len == 0.
4921     z_brz(AllDone);
4922     clear_reg(Z_R0);                       // make sure registers are properly initialized.
4923     clear_reg(Z_R1);
4924     z_chi(Rcnt, 4);
4925     z_brne(skip4Shortcut);                 // 4 characters are very frequent
4926       z_icm(Z_R0, 5,    0, Rsrc);          // Treat exactly 4 characters specially.
4927       z_icm(Z_R1, 5,    2, Rsrc);
4928       z_stm(Z_R0, Z_R1, 0, Rdst);
4929       z_bru(AllDone);
4930     bind(skip4Shortcut);
4931 
4932     z_chi(Rcnt, 8);
4933     z_brh(skipShortcut);                   // There&#39;s a lot to do...
4934     z_lgfr(Z_R0, Rcnt);                    // remaining #characters (&lt;= 8). Precond for scalar loop.
4935                                            // This does not destroy the &quot;register cleared&quot; state of Z_R0.
4936     z_brl(ScalarShortcut);                 // Just a few characters
4937       z_icmh(Z_R0, 5, 0, Rsrc);            // Treat exactly 8 characters specially.
4938       z_icmh(Z_R1, 5, 4, Rsrc);
4939       z_icm(Z_R0,  5, 2, Rsrc);
4940       z_icm(Z_R1,  5, 6, Rsrc);
4941       z_stmg(Z_R0, Z_R1, 0, Rdst);
4942       z_bru(AllDone);
4943     bind(skipShortcut);
4944   }
4945 #endif
4946   clear_reg(Z_R0);                         // make sure register is properly initialized.
4947 
4948   if (VM_Version::has_VectorFacility()) {
4949     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.
4950                                            // Otherwise just do nothing in vector mode.
4951                                            // Must be multiple of vector register length (16 bytes = 128 bits).
4952     const int  log_min_vcnt = exact_log2(min_vcnt);
4953     Label      VectorLoop, VectorDone;
4954 
4955     assert(VM_Version::has_DistinctOpnds(), &quot;Assumption when has_VectorFacility()&quot;);
4956     z_srak(Rix, Rcnt, log_min_vcnt);       // calculate # vector loop iterations
4957     z_brz(VectorDone);                     // skip if none
4958 
4959     z_sllg(Z_R0, Rix, log_min_vcnt);       // remember #chars that will be processed by vector loop
4960 
4961     bind(VectorLoop);
4962       z_vlm(Z_V20, Z_V21, 0, Rsrc);        // get next 32 characters (single-byte)
4963       add2reg(Rsrc, min_vcnt);
4964 
4965       z_vuplhb(Z_V22, Z_V20);              // V2 &lt;- (expand) V0(high)
4966       z_vupllb(Z_V23, Z_V20);              // V3 &lt;- (expand) V0(low)
4967       z_vuplhb(Z_V24, Z_V21);              // V4 &lt;- (expand) V1(high)
4968       z_vupllb(Z_V25, Z_V21);              // V5 &lt;- (expand) V1(low)
4969       z_vstm(Z_V22, Z_V25, 0, Rdst);       // store next 32 bytes
4970       add2reg(Rdst, min_vcnt*2);
4971 
4972       z_brct(Rix, VectorLoop);
4973 
4974     bind(VectorDone);
4975   }
4976 
4977   const int  min_cnt     =  8;             // Minimum #characters required to use unrolled scalar loop.
4978                                            // Otherwise just do nothing in unrolled scalar mode.
4979                                            // Must be multiple of 8.
4980   {
4981     const int  log_min_cnt = exact_log2(min_cnt);
4982     Label      UnrolledLoop, UnrolledDone;
4983 
4984 
4985     if (VM_Version::has_DistinctOpnds()) {
4986       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to process in unrolled loop
4987     } else {
4988       z_lr(Rix, Rcnt);
4989       z_sr(Rix, Z_R0);
4990     }
4991     z_sra(Rix, log_min_cnt);               // unrolled loop count
4992     z_brz(UnrolledDone);
4993 
4994     clear_reg(Z_R0);
4995     clear_reg(Z_R1);
4996 
4997     bind(UnrolledLoop);
4998       z_icmh(Z_R0, 5, 0, Rsrc);
4999       z_icmh(Z_R1, 5, 4, Rsrc);
5000       z_icm(Z_R0,  5, 2, Rsrc);
5001       z_icm(Z_R1,  5, 6, Rsrc);
5002       add2reg(Rsrc, min_cnt);
5003 
5004       z_stmg(Z_R0, Z_R1, 0, Rdst);
5005 
5006       add2reg(Rdst, min_cnt*2);
5007       z_brct(Rix, UnrolledLoop);
5008 
5009     bind(UnrolledDone);
5010     z_lgfr(Z_R0, Rcnt);                    // # chars left over after unrolled loop.
5011     z_nilf(Z_R0, min_cnt-1);
5012     z_brnz(ScalarShortcut);                // if zero, there is nothing left to do for scalar loop.
5013                                            // Rix == 0 in all cases.
5014     z_sgfr(Z_R0, Rcnt);                    // negative # characters the ptrs have been advanced previously.
5015     z_agr(Rdst, Z_R0);                     // restore ptr, double the element count for Rdst restore.
5016     z_agr(Rdst, Z_R0);
5017     z_agr(Rsrc, Z_R0);                     // restore ptr.
5018     z_bru(AllDone);
5019   }
5020 
5021   {
5022     bind(ScalarShortcut);
5023     // Z_R0 must contain remaining # characters as 64-bit signed int here.
5024     //      register contents is preserved over scalar processing (for register fixup).
5025 
5026 #if 0  // Sacrifice shortcuts for code compactness
5027     {
5028       Label      ScalarDefault;
5029       z_chi(Rcnt, 2);
5030       z_brh(ScalarDefault);
5031       z_llc(Z_R0,  0, Z_R0, Rsrc);     // 6 bytes
5032       z_sth(Z_R0,  0, Z_R0, Rdst);     // 4 bytes
5033       z_brl(AllDone);
5034       z_llc(Z_R0,  1, Z_R0, Rsrc);     // 6 bytes
5035       z_sth(Z_R0,  2, Z_R0, Rdst);     // 4 bytes
5036       z_bru(AllDone);
5037       bind(ScalarDefault);
5038     }
5039 #endif
5040 
5041     Label   CodeTable;
5042     // Some comments on Rix calculation:
5043     //  - Rcnt is small, therefore no bits shifted out of low word (sll(g) instructions).
5044     //  - high word of both Rix and Rcnt may contain garbage
5045     //  - the final lngfr takes care of that garbage, extending the sign to high word
5046     z_sllg(Rix, Z_R0, 2);                // calculate 10*Rix = (4*Rix + Rix)*2
5047     z_ar(Rix, Z_R0);
5048     z_larl(Z_R1, CodeTable);
5049     z_sll(Rix, 1);
5050     z_lngfr(Rix, Rix);      // ix range: [0..7], after inversion &amp; mult: [-(7*12)..(0*12)].
5051     z_bc(Assembler::bcondAlways, 0, Rix, Z_R1);
5052 
5053     z_llc(Z_R1,  6, Z_R0, Rsrc);  // 6 bytes
5054     z_sth(Z_R1, 12, Z_R0, Rdst);  // 4 bytes
5055 
5056     z_llc(Z_R1,  5, Z_R0, Rsrc);
5057     z_sth(Z_R1, 10, Z_R0, Rdst);
5058 
5059     z_llc(Z_R1,  4, Z_R0, Rsrc);
5060     z_sth(Z_R1,  8, Z_R0, Rdst);
5061 
5062     z_llc(Z_R1,  3, Z_R0, Rsrc);
5063     z_sth(Z_R1,  6, Z_R0, Rdst);
5064 
5065     z_llc(Z_R1,  2, Z_R0, Rsrc);
5066     z_sth(Z_R1,  4, Z_R0, Rdst);
5067 
5068     z_llc(Z_R1,  1, Z_R0, Rsrc);
5069     z_sth(Z_R1,  2, Z_R0, Rdst);
5070 
5071     z_llc(Z_R1,  0, Z_R0, Rsrc);
5072     z_sth(Z_R1,  0, Z_R0, Rdst);
5073     bind(CodeTable);
5074 
5075     z_chi(Rcnt, 8);                        // no fixup for small strings. Rdst, Rsrc were not modified.
5076     z_brl(AllDone);
5077 
5078     z_sgfr(Z_R0, Rcnt);                    // # characters the ptrs have been advanced previously.
5079     z_agr(Rdst, Z_R0);                     // restore ptr, double the element count for Rdst restore.
5080     z_agr(Rdst, Z_R0);
5081     z_agr(Rsrc, Z_R0);                     // restore ptr.
5082   }
5083   bind(AllDone);
5084 
5085   BLOCK_COMMENT(&quot;} string_inflate&quot;);
5086   return offset() - block_start;
5087 }
5088 
5089 // Inflate byte[] to char[], length known at compile time.
5090 //   Restores: src, dst
5091 //   Kills:    tmp, Z_R0, Z_R1.
5092 // Note:
5093 //   len is signed int. Counts # characters, not bytes.
5094 unsigned int MacroAssembler::string_inflate_const(Register src, Register dst, Register tmp, int len) {
5095   assert_different_registers(Z_R0, Z_R1, src, dst, tmp);
5096 
5097   BLOCK_COMMENT(&quot;string_inflate_const {&quot;);
5098   int block_start = offset();
5099 
5100   Register   Rix  = tmp;   // loop index
5101   Register   Rsrc = src;   // addr(src array)
5102   Register   Rdst = dst;   // addr(dst array)
5103   Label      ScalarShortcut, AllDone;
5104   int        nprocessed = 0;
5105   int        src_off    = 0;  // compensate for saved (optimized away) ptr advancement.
5106   int        dst_off    = 0;  // compensate for saved (optimized away) ptr advancement.
5107   bool       restore_inputs = false;
5108   bool       workreg_clear  = false;
5109 
5110   if ((len &gt;= 32) &amp;&amp; VM_Version::has_VectorFacility()) {
5111     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.
5112                                            // Otherwise just do nothing in vector mode.
5113                                            // Must be multiple of vector register length (16 bytes = 128 bits).
5114     const int  log_min_vcnt = exact_log2(min_vcnt);
5115     const int  iterations   = (len - nprocessed) &gt;&gt; log_min_vcnt;
5116     nprocessed             += iterations &lt;&lt; log_min_vcnt;
5117     Label      VectorLoop;
5118 
5119     if (iterations == 1) {
5120       z_vlm(Z_V20, Z_V21, 0+src_off, Rsrc);  // get next 32 characters (single-byte)
5121       z_vuplhb(Z_V22, Z_V20);                // V2 &lt;- (expand) V0(high)
5122       z_vupllb(Z_V23, Z_V20);                // V3 &lt;- (expand) V0(low)
5123       z_vuplhb(Z_V24, Z_V21);                // V4 &lt;- (expand) V1(high)
5124       z_vupllb(Z_V25, Z_V21);                // V5 &lt;- (expand) V1(low)
5125       z_vstm(Z_V22, Z_V25, 0+dst_off, Rdst); // store next 32 bytes
5126 
5127       src_off += min_vcnt;
5128       dst_off += min_vcnt*2;
5129     } else {
5130       restore_inputs = true;
5131 
5132       z_lgfi(Rix, len&gt;&gt;log_min_vcnt);
5133       bind(VectorLoop);
5134         z_vlm(Z_V20, Z_V21, 0, Rsrc);        // get next 32 characters (single-byte)
5135         add2reg(Rsrc, min_vcnt);
5136 
5137         z_vuplhb(Z_V22, Z_V20);              // V2 &lt;- (expand) V0(high)
5138         z_vupllb(Z_V23, Z_V20);              // V3 &lt;- (expand) V0(low)
5139         z_vuplhb(Z_V24, Z_V21);              // V4 &lt;- (expand) V1(high)
5140         z_vupllb(Z_V25, Z_V21);              // V5 &lt;- (expand) V1(low)
5141         z_vstm(Z_V22, Z_V25, 0, Rdst);       // store next 32 bytes
5142         add2reg(Rdst, min_vcnt*2);
5143 
5144         z_brct(Rix, VectorLoop);
5145     }
5146   }
5147 
5148   if (((len-nprocessed) &gt;= 16) &amp;&amp; VM_Version::has_VectorFacility()) {
5149     const int  min_vcnt     = 16;          // Minimum #characters required to use vector instructions.
5150                                            // Otherwise just do nothing in vector mode.
5151                                            // Must be multiple of vector register length (16 bytes = 128 bits).
5152     const int  log_min_vcnt = exact_log2(min_vcnt);
5153     const int  iterations   = (len - nprocessed) &gt;&gt; log_min_vcnt;
5154     nprocessed             += iterations &lt;&lt; log_min_vcnt;
5155     assert(iterations == 1, &quot;must be!&quot;);
5156 
5157     z_vl(Z_V20, 0+src_off, Z_R0, Rsrc);    // get next 16 characters (single-byte)
5158     z_vuplhb(Z_V22, Z_V20);                // V2 &lt;- (expand) V0(high)
5159     z_vupllb(Z_V23, Z_V20);                // V3 &lt;- (expand) V0(low)
5160     z_vstm(Z_V22, Z_V23, 0+dst_off, Rdst); // store next 32 bytes
5161 
5162     src_off += min_vcnt;
5163     dst_off += min_vcnt*2;
5164   }
5165 
5166   if ((len-nprocessed) &gt; 8) {
5167     const int  min_cnt     =  8;           // Minimum #characters required to use unrolled scalar loop.
5168                                            // Otherwise just do nothing in unrolled scalar mode.
5169                                            // Must be multiple of 8.
5170     const int  log_min_cnt = exact_log2(min_cnt);
5171     const int  iterations  = (len - nprocessed) &gt;&gt; log_min_cnt;
5172     nprocessed     += iterations &lt;&lt; log_min_cnt;
5173 
5174     //---&lt;  avoid loop overhead/ptr increment for small # iterations  &gt;---
5175     if (iterations &lt;= 2) {
5176       clear_reg(Z_R0);
5177       clear_reg(Z_R1);
5178       workreg_clear = true;
5179 
5180       z_icmh(Z_R0, 5, 0+src_off, Rsrc);
5181       z_icmh(Z_R1, 5, 4+src_off, Rsrc);
5182       z_icm(Z_R0,  5, 2+src_off, Rsrc);
5183       z_icm(Z_R1,  5, 6+src_off, Rsrc);
5184       z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);
5185 
5186       src_off += min_cnt;
5187       dst_off += min_cnt*2;
5188     }
5189 
5190     if (iterations == 2) {
5191       z_icmh(Z_R0, 5, 0+src_off, Rsrc);
5192       z_icmh(Z_R1, 5, 4+src_off, Rsrc);
5193       z_icm(Z_R0,  5, 2+src_off, Rsrc);
5194       z_icm(Z_R1,  5, 6+src_off, Rsrc);
5195       z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);
5196 
5197       src_off += min_cnt;
5198       dst_off += min_cnt*2;
5199     }
5200 
5201     if (iterations &gt; 2) {
5202       Label      UnrolledLoop;
5203       restore_inputs  = true;
5204 
5205       clear_reg(Z_R0);
5206       clear_reg(Z_R1);
5207       workreg_clear = true;
5208 
5209       z_lgfi(Rix, iterations);
5210       bind(UnrolledLoop);
5211         z_icmh(Z_R0, 5, 0, Rsrc);
5212         z_icmh(Z_R1, 5, 4, Rsrc);
5213         z_icm(Z_R0,  5, 2, Rsrc);
5214         z_icm(Z_R1,  5, 6, Rsrc);
5215         add2reg(Rsrc, min_cnt);
5216 
5217         z_stmg(Z_R0, Z_R1, 0, Rdst);
5218         add2reg(Rdst, min_cnt*2);
5219 
5220         z_brct(Rix, UnrolledLoop);
5221     }
5222   }
5223 
5224   if ((len-nprocessed) &gt; 0) {
5225     switch (len-nprocessed) {
5226       case 8:
5227         if (!workreg_clear) {
5228           clear_reg(Z_R0);
5229           clear_reg(Z_R1);
5230         }
5231         z_icmh(Z_R0, 5, 0+src_off, Rsrc);
5232         z_icmh(Z_R1, 5, 4+src_off, Rsrc);
5233         z_icm(Z_R0,  5, 2+src_off, Rsrc);
5234         z_icm(Z_R1,  5, 6+src_off, Rsrc);
5235         z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);
5236         break;
5237       case 7:
5238         if (!workreg_clear) {
5239           clear_reg(Z_R0);
5240           clear_reg(Z_R1);
5241         }
5242         clear_reg(Rix);
5243         z_icm(Z_R0,  5, 0+src_off, Rsrc);
5244         z_icm(Z_R1,  5, 2+src_off, Rsrc);
5245         z_icm(Rix,   5, 4+src_off, Rsrc);
5246         z_stm(Z_R0,  Z_R1, 0+dst_off, Rdst);
5247         z_llc(Z_R0,  6+src_off, Z_R0, Rsrc);
5248         z_st(Rix,    8+dst_off, Z_R0, Rdst);
5249         z_sth(Z_R0, 12+dst_off, Z_R0, Rdst);
5250         break;
5251       case 6:
5252         if (!workreg_clear) {
5253           clear_reg(Z_R0);
5254           clear_reg(Z_R1);
5255         }
5256         clear_reg(Rix);
5257         z_icm(Z_R0, 5, 0+src_off, Rsrc);
5258         z_icm(Z_R1, 5, 2+src_off, Rsrc);
5259         z_icm(Rix,  5, 4+src_off, Rsrc);
5260         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);
5261         z_st(Rix,   8+dst_off, Z_R0, Rdst);
5262         break;
5263       case 5:
5264         if (!workreg_clear) {
5265           clear_reg(Z_R0);
5266           clear_reg(Z_R1);
5267         }
5268         z_icm(Z_R0, 5, 0+src_off, Rsrc);
5269         z_icm(Z_R1, 5, 2+src_off, Rsrc);
5270         z_llc(Rix,  4+src_off, Z_R0, Rsrc);
5271         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);
5272         z_sth(Rix,  8+dst_off, Z_R0, Rdst);
5273         break;
5274       case 4:
5275         if (!workreg_clear) {
5276           clear_reg(Z_R0);
5277           clear_reg(Z_R1);
5278         }
5279         z_icm(Z_R0, 5, 0+src_off, Rsrc);
5280         z_icm(Z_R1, 5, 2+src_off, Rsrc);
5281         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);
5282         break;
5283       case 3:
5284         if (!workreg_clear) {
5285           clear_reg(Z_R0);
5286         }
5287         z_llc(Z_R1, 2+src_off, Z_R0, Rsrc);
5288         z_icm(Z_R0, 5, 0+src_off, Rsrc);
5289         z_sth(Z_R1, 4+dst_off, Z_R0, Rdst);
5290         z_st(Z_R0,  0+dst_off, Rdst);
5291         break;
5292       case 2:
5293         z_llc(Z_R0, 0+src_off, Z_R0, Rsrc);
5294         z_llc(Z_R1, 1+src_off, Z_R0, Rsrc);
5295         z_sth(Z_R0, 0+dst_off, Z_R0, Rdst);
5296         z_sth(Z_R1, 2+dst_off, Z_R0, Rdst);
5297         break;
5298       case 1:
5299         z_llc(Z_R0, 0+src_off, Z_R0, Rsrc);
5300         z_sth(Z_R0, 0+dst_off, Z_R0, Rdst);
5301         break;
5302       default:
5303         guarantee(false, &quot;Impossible&quot;);
5304         break;
5305     }
5306     src_off   +=  len-nprocessed;
5307     dst_off   += (len-nprocessed)*2;
5308     nprocessed = len;
5309   }
5310 
5311   //---&lt; restore modified input registers  &gt;---
5312   if ((nprocessed &gt; 0) &amp;&amp; restore_inputs) {
5313     z_agfi(Rsrc, -(nprocessed-src_off));
5314     if (nprocessed &lt; 1000000000) { // avoid int overflow
5315       z_agfi(Rdst, -(nprocessed*2-dst_off));
5316     } else {
5317       z_agfi(Rdst, -(nprocessed-dst_off));
5318       z_agfi(Rdst, -nprocessed);
5319     }
5320   }
5321 
5322   BLOCK_COMMENT(&quot;} string_inflate_const&quot;);
5323   return offset() - block_start;
5324 }
5325 
5326 // Kills src.
5327 unsigned int MacroAssembler::has_negatives(Register result, Register src, Register cnt,
5328                                            Register odd_reg, Register even_reg, Register tmp) {
5329   int block_start = offset();
5330   Label Lloop1, Lloop2, Lslow, Lnotfound, Ldone;
5331   const Register addr = src, mask = tmp;
5332 
5333   BLOCK_COMMENT(&quot;has_negatives {&quot;);
5334 
5335   z_llgfr(Z_R1, cnt);      // Number of bytes to read. (Must be a positive simm32.)
5336   z_llilf(mask, 0x80808080);
5337   z_lhi(result, 1);        // Assume true.
5338   // Last possible addr for fast loop.
5339   z_lay(odd_reg, -16, Z_R1, src);
5340   z_chi(cnt, 16);
5341   z_brl(Lslow);
5342 
5343   // ind1: index, even_reg: index increment, odd_reg: index limit
5344   z_iihf(mask, 0x80808080);
5345   z_lghi(even_reg, 16);
5346 
5347   bind(Lloop1); // 16 bytes per iteration.
5348   z_lg(Z_R0, Address(addr));
5349   z_lg(Z_R1, Address(addr, 8));
5350   z_ogr(Z_R0, Z_R1);
5351   z_ngr(Z_R0, mask);
5352   z_brne(Ldone);           // If found return 1.
5353   z_brxlg(addr, even_reg, Lloop1);
5354 
5355   bind(Lslow);
5356   z_aghi(odd_reg, 16-1);   // Last possible addr for slow loop.
5357   z_lghi(even_reg, 1);
5358   z_cgr(addr, odd_reg);
5359   z_brh(Lnotfound);
5360 
5361   bind(Lloop2); // 1 byte per iteration.
5362   z_cli(Address(addr), 0x80);
5363   z_brnl(Ldone);           // If found return 1.
5364   z_brxlg(addr, even_reg, Lloop2);
5365 
5366   bind(Lnotfound);
5367   z_lhi(result, 0);
5368 
5369   bind(Ldone);
5370 
5371   BLOCK_COMMENT(&quot;} has_negatives&quot;);
5372 
5373   return offset() - block_start;
5374 }
5375 
5376 // kill: cnt1, cnt2, odd_reg, even_reg; early clobber: result
5377 unsigned int MacroAssembler::string_compare(Register str1, Register str2,
5378                                             Register cnt1, Register cnt2,
5379                                             Register odd_reg, Register even_reg, Register result, int ae) {
5380   int block_start = offset();
5381 
5382   assert_different_registers(str1, cnt1, cnt2, odd_reg, even_reg, result);
5383   assert_different_registers(str2, cnt1, cnt2, odd_reg, even_reg, result);
5384 
5385   // If strings are equal up to min length, return the length difference.
5386   const Register diff = result, // Pre-set result with length difference.
5387                  min  = cnt1,   // min number of bytes
5388                  tmp  = cnt2;
5389 
5390   // Note: Making use of the fact that compareTo(a, b) == -compareTo(b, a)
5391   // we interchange str1 and str2 in the UL case and negate the result.
5392   // Like this, str1 is always latin1 encoded, except for the UU case.
5393   // In addition, we need 0 (or sign which is 0) extend when using 64 bit register.
5394   const bool used_as_LU = (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL);
5395 
5396   BLOCK_COMMENT(&quot;string_compare {&quot;);
5397 
5398   if (used_as_LU) {
5399     z_srl(cnt2, 1);
5400   }
5401 
5402   // See if the lengths are different, and calculate min in cnt1.
5403   // Save diff in case we need it for a tie-breaker.
5404 
5405   // diff = cnt1 - cnt2
5406   if (VM_Version::has_DistinctOpnds()) {
5407     z_srk(diff, cnt1, cnt2);
5408   } else {
5409     z_lr(diff, cnt1);
5410     z_sr(diff, cnt2);
5411   }
5412   if (str1 != str2) {
5413     if (VM_Version::has_LoadStoreConditional()) {
5414       z_locr(min, cnt2, Assembler::bcondHigh);
5415     } else {
5416       Label Lskip;
5417       z_brl(Lskip);    // min ok if cnt1 &lt; cnt2
5418       z_lr(min, cnt2); // min = cnt2
5419       bind(Lskip);
5420     }
5421   }
5422 
5423   if (ae == StrIntrinsicNode::UU) {
5424     z_sra(diff, 1);
5425   }
5426   if (str1 != str2) {
5427     Label Ldone;
5428     if (used_as_LU) {
5429       // Loop which searches the first difference character by character.
5430       Label Lloop;
5431       const Register ind1 = Z_R1,
5432                      ind2 = min;
5433       int stride1 = 1, stride2 = 2; // See comment above.
5434 
5435       // ind1: index, even_reg: index increment, odd_reg: index limit
5436       z_llilf(ind1, (unsigned int)(-stride1));
5437       z_lhi(even_reg, stride1);
5438       add2reg(odd_reg, -stride1, min);
5439       clear_reg(ind2); // kills min
5440 
5441       bind(Lloop);
5442       z_brxh(ind1, even_reg, Ldone);
5443       z_llc(tmp, Address(str1, ind1));
5444       z_llh(Z_R0, Address(str2, ind2));
5445       z_ahi(ind2, stride2);
5446       z_sr(tmp, Z_R0);
5447       z_bre(Lloop);
5448 
5449       z_lr(result, tmp);
5450 
5451     } else {
5452       // Use clcle in fast loop (only for same encoding).
5453       z_lgr(Z_R0, str1);
5454       z_lgr(even_reg, str2);
5455       z_llgfr(Z_R1, min);
5456       z_llgfr(odd_reg, min);
5457 
5458       if (ae == StrIntrinsicNode::LL) {
5459         compare_long_ext(Z_R0, even_reg, 0);
5460       } else {
5461         compare_long_uni(Z_R0, even_reg, 0);
5462       }
5463       z_bre(Ldone);
5464       z_lgr(Z_R1, Z_R0);
5465       if (ae == StrIntrinsicNode::LL) {
5466         z_llc(Z_R0, Address(even_reg));
5467         z_llc(result, Address(Z_R1));
5468       } else {
5469         z_llh(Z_R0, Address(even_reg));
5470         z_llh(result, Address(Z_R1));
5471       }
5472       z_sr(result, Z_R0);
5473     }
5474 
5475     // Otherwise, return the difference between the first mismatched chars.
5476     bind(Ldone);
5477   }
5478 
5479   if (ae == StrIntrinsicNode::UL) {
5480     z_lcr(result, result); // Negate result (see note above).
5481   }
5482 
5483   BLOCK_COMMENT(&quot;} string_compare&quot;);
5484 
5485   return offset() - block_start;
5486 }
5487 
5488 unsigned int MacroAssembler::array_equals(bool is_array_equ, Register ary1, Register ary2, Register limit,
5489                                           Register odd_reg, Register even_reg, Register result, bool is_byte) {
5490   int block_start = offset();
5491 
5492   BLOCK_COMMENT(&quot;array_equals {&quot;);
5493 
5494   assert_different_registers(ary1, limit, odd_reg, even_reg);
5495   assert_different_registers(ary2, limit, odd_reg, even_reg);
5496 
5497   Label Ldone, Ldone_true, Ldone_false, Lclcle, CLC_template;
5498   int base_offset = 0;
5499 
5500   if (ary1 != ary2) {
5501     if (is_array_equ) {
5502       base_offset = arrayOopDesc::base_offset_in_bytes(is_byte ? T_BYTE : T_CHAR);
5503 
5504       // Return true if the same array.
5505       compareU64_and_branch(ary1, ary2, Assembler::bcondEqual, Ldone_true);
5506 
5507       // Return false if one of them is NULL.
5508       compareU64_and_branch(ary1, (intptr_t)0, Assembler::bcondEqual, Ldone_false);
5509       compareU64_and_branch(ary2, (intptr_t)0, Assembler::bcondEqual, Ldone_false);
5510 
5511       // Load the lengths of arrays.
5512       z_llgf(odd_reg, Address(ary1, arrayOopDesc::length_offset_in_bytes()));
5513 
5514       // Return false if the two arrays are not equal length.
5515       z_c(odd_reg, Address(ary2, arrayOopDesc::length_offset_in_bytes()));
5516       z_brne(Ldone_false);
5517 
5518       // string len in bytes (right operand)
5519       if (!is_byte) {
5520         z_chi(odd_reg, 128);
5521         z_sll(odd_reg, 1); // preserves flags
5522         z_brh(Lclcle);
5523       } else {
5524         compareU32_and_branch(odd_reg, (intptr_t)256, Assembler::bcondHigh, Lclcle);
5525       }
5526     } else {
5527       z_llgfr(odd_reg, limit); // Need to zero-extend prior to using the value.
5528       compareU32_and_branch(limit, (intptr_t)256, Assembler::bcondHigh, Lclcle);
5529     }
5530 
5531 
5532     // Use clc instruction for up to 256 bytes.
5533     {
5534       Register str1_reg = ary1,
5535           str2_reg = ary2;
5536       if (is_array_equ) {
5537         str1_reg = Z_R1;
5538         str2_reg = even_reg;
5539         add2reg(str1_reg, base_offset, ary1); // string addr (left operand)
5540         add2reg(str2_reg, base_offset, ary2); // string addr (right operand)
5541       }
5542       z_ahi(odd_reg, -1); // Clc uses decremented limit. Also compare result to 0.
5543       z_brl(Ldone_true);
5544       // Note: We could jump to the template if equal.
5545 
5546       assert(VM_Version::has_ExecuteExtensions(), &quot;unsupported hardware&quot;);
5547       z_exrl(odd_reg, CLC_template);
5548       z_bre(Ldone_true);
5549       // fall through
5550 
5551       bind(Ldone_false);
5552       clear_reg(result);
5553       z_bru(Ldone);
5554 
5555       bind(CLC_template);
5556       z_clc(0, 0, str1_reg, 0, str2_reg);
5557     }
5558 
5559     // Use clcle instruction.
5560     {
5561       bind(Lclcle);
5562       add2reg(even_reg, base_offset, ary2); // string addr (right operand)
5563       add2reg(Z_R0, base_offset, ary1);     // string addr (left operand)
5564 
5565       z_lgr(Z_R1, odd_reg); // string len in bytes (left operand)
5566       if (is_byte) {
5567         compare_long_ext(Z_R0, even_reg, 0);
5568       } else {
5569         compare_long_uni(Z_R0, even_reg, 0);
5570       }
5571       z_lghi(result, 0); // Preserve flags.
5572       z_brne(Ldone);
5573     }
5574   }
5575   // fall through
5576 
5577   bind(Ldone_true);
5578   z_lghi(result, 1); // All characters are equal.
5579   bind(Ldone);
5580 
5581   BLOCK_COMMENT(&quot;} array_equals&quot;);
5582 
5583   return offset() - block_start;
5584 }
5585 
5586 // kill: haycnt, needlecnt, odd_reg, even_reg; early clobber: result
5587 unsigned int MacroAssembler::string_indexof(Register result, Register haystack, Register haycnt,
5588                                             Register needle, Register needlecnt, int needlecntval,
5589                                             Register odd_reg, Register even_reg, int ae) {
5590   int block_start = offset();
5591 
5592   // Ensure 0&lt;needlecnt&lt;=haycnt in ideal graph as prerequisite!
5593   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);
5594   const int h_csize = (ae == StrIntrinsicNode::LL) ? 1 : 2;
5595   const int n_csize = (ae == StrIntrinsicNode::UU) ? 2 : 1;
5596   Label L_needle1, L_Found, L_NotFound;
5597 
5598   BLOCK_COMMENT(&quot;string_indexof {&quot;);
5599 
5600   if (needle == haystack) {
5601     z_lhi(result, 0);
5602   } else {
5603 
5604   // Load first character of needle (R0 used by search_string instructions).
5605   if (n_csize == 2) { z_llgh(Z_R0, Address(needle)); } else { z_llgc(Z_R0, Address(needle)); }
5606 
5607   // Compute last haystack addr to use if no match gets found.
5608   if (needlecnt != noreg) { // variable needlecnt
5609     z_ahi(needlecnt, -1); // Remaining characters after first one.
5610     z_sr(haycnt, needlecnt); // Compute index succeeding last element to compare.
5611     if (n_csize == 2) { z_sll(needlecnt, 1); } // In bytes.
5612   } else { // constant needlecnt
5613     assert((needlecntval &amp; 0x7fff) == needlecntval, &quot;must be positive simm16 immediate&quot;);
5614     // Compute index succeeding last element to compare.
5615     if (needlecntval != 1) { z_ahi(haycnt, 1 - needlecntval); }
5616   }
5617 
5618   z_llgfr(haycnt, haycnt); // Clear high half.
5619   z_lgr(result, haystack); // Final result will be computed from needle start pointer.
5620   if (h_csize == 2) { z_sll(haycnt, 1); } // Scale to number of bytes.
5621   z_agr(haycnt, haystack); // Point to address succeeding last element (haystack+scale*(haycnt-needlecnt+1)).
5622 
5623   if (h_csize != n_csize) {
5624     assert(ae == StrIntrinsicNode::UL, &quot;Invalid encoding&quot;);
5625 
5626     if (needlecnt != noreg || needlecntval != 1) {
5627       if (needlecnt != noreg) {
5628         compare32_and_branch(needlecnt, (intptr_t)0, Assembler::bcondEqual, L_needle1);
5629       }
5630 
5631       // Main Loop: UL version (now we have at least 2 characters).
5632       Label L_OuterLoop, L_InnerLoop, L_Skip;
5633       bind(L_OuterLoop); // Search for 1st 2 characters.
5634       z_lgr(Z_R1, haycnt);
5635       MacroAssembler::search_string_uni(Z_R1, result);
5636       z_brc(Assembler::bcondNotFound, L_NotFound);
5637       z_lgr(result, Z_R1);
5638 
5639       z_lghi(Z_R1, n_csize);
5640       z_lghi(even_reg, h_csize);
5641       bind(L_InnerLoop);
5642       z_llgc(odd_reg, Address(needle, Z_R1));
5643       z_ch(odd_reg, Address(result, even_reg));
5644       z_brne(L_Skip);
5645       if (needlecnt != noreg) { z_cr(Z_R1, needlecnt); } else { z_chi(Z_R1, needlecntval - 1); }
5646       z_brnl(L_Found);
5647       z_aghi(Z_R1, n_csize);
5648       z_aghi(even_reg, h_csize);
5649       z_bru(L_InnerLoop);
5650 
5651       bind(L_Skip);
5652       z_aghi(result, h_csize); // This is the new address we want to use for comparing.
5653       z_bru(L_OuterLoop);
5654     }
5655 
5656   } else {
5657     const intptr_t needle_bytes = (n_csize == 2) ? ((needlecntval - 1) &lt;&lt; 1) : (needlecntval - 1);
5658     Label L_clcle;
5659 
5660     if (needlecnt != noreg || (needlecntval != 1 &amp;&amp; needle_bytes &lt;= 256)) {
5661       if (needlecnt != noreg) {
5662         compare32_and_branch(needlecnt, 256, Assembler::bcondHigh, L_clcle);
5663         z_ahi(needlecnt, -1); // remaining bytes -1 (for CLC)
5664         z_brl(L_needle1);
5665       }
5666 
5667       // Main Loop: clc version (now we have at least 2 characters).
5668       Label L_OuterLoop, CLC_template;
5669       bind(L_OuterLoop); // Search for 1st 2 characters.
5670       z_lgr(Z_R1, haycnt);
5671       if (h_csize == 1) {
5672         MacroAssembler::search_string(Z_R1, result);
5673       } else {
5674         MacroAssembler::search_string_uni(Z_R1, result);
5675       }
5676       z_brc(Assembler::bcondNotFound, L_NotFound);
5677       z_lgr(result, Z_R1);
5678 
5679       if (needlecnt != noreg) {
5680         assert(VM_Version::has_ExecuteExtensions(), &quot;unsupported hardware&quot;);
5681         z_exrl(needlecnt, CLC_template);
5682       } else {
5683         z_clc(h_csize, needle_bytes -1, Z_R1, n_csize, needle);
5684       }
5685       z_bre(L_Found);
5686       z_aghi(result, h_csize); // This is the new address we want to use for comparing.
5687       z_bru(L_OuterLoop);
5688 
5689       if (needlecnt != noreg) {
5690         bind(CLC_template);
5691         z_clc(h_csize, 0, Z_R1, n_csize, needle);
5692       }
5693     }
5694 
5695     if (needlecnt != noreg || needle_bytes &gt; 256) {
5696       bind(L_clcle);
5697 
5698       // Main Loop: clcle version (now we have at least 256 bytes).
5699       Label L_OuterLoop, CLC_template;
5700       bind(L_OuterLoop); // Search for 1st 2 characters.
5701       z_lgr(Z_R1, haycnt);
5702       if (h_csize == 1) {
5703         MacroAssembler::search_string(Z_R1, result);
5704       } else {
5705         MacroAssembler::search_string_uni(Z_R1, result);
5706       }
5707       z_brc(Assembler::bcondNotFound, L_NotFound);
5708 
5709       add2reg(Z_R0, n_csize, needle);
5710       add2reg(even_reg, h_csize, Z_R1);
5711       z_lgr(result, Z_R1);
5712       if (needlecnt != noreg) {
5713         z_llgfr(Z_R1, needlecnt); // needle len in bytes (left operand)
5714         z_llgfr(odd_reg, needlecnt);
5715       } else {
5716         load_const_optimized(Z_R1, needle_bytes);
5717         if (Immediate::is_simm16(needle_bytes)) { z_lghi(odd_reg, needle_bytes); } else { z_lgr(odd_reg, Z_R1); }
5718       }
5719       if (h_csize == 1) {
5720         compare_long_ext(Z_R0, even_reg, 0);
5721       } else {
5722         compare_long_uni(Z_R0, even_reg, 0);
5723       }
5724       z_bre(L_Found);
5725 
5726       if (n_csize == 2) { z_llgh(Z_R0, Address(needle)); } else { z_llgc(Z_R0, Address(needle)); } // Reload.
5727       z_aghi(result, h_csize); // This is the new address we want to use for comparing.
5728       z_bru(L_OuterLoop);
5729     }
5730   }
5731 
5732   if (needlecnt != noreg || needlecntval == 1) {
5733     bind(L_needle1);
5734 
5735     // Single needle character version.
5736     if (h_csize == 1) {
5737       MacroAssembler::search_string(haycnt, result);
5738     } else {
5739       MacroAssembler::search_string_uni(haycnt, result);
5740     }
5741     z_lgr(result, haycnt);
5742     z_brc(Assembler::bcondFound, L_Found);
5743   }
5744 
5745   bind(L_NotFound);
5746   add2reg(result, -1, haystack); // Return -1.
5747 
5748   bind(L_Found); // Return index (or -1 in fallthrough case).
5749   z_sgr(result, haystack);
5750   if (h_csize == 2) { z_srag(result, result, exact_log2(sizeof(jchar))); }
5751   }
5752   BLOCK_COMMENT(&quot;} string_indexof&quot;);
5753 
5754   return offset() - block_start;
5755 }
5756 
5757 // early clobber: result
5758 unsigned int MacroAssembler::string_indexof_char(Register result, Register haystack, Register haycnt,
5759                                                  Register needle, jchar needleChar, Register odd_reg, Register even_reg, bool is_byte) {
5760   int block_start = offset();
5761 
5762   BLOCK_COMMENT(&quot;string_indexof_char {&quot;);
5763 
5764   if (needle == haystack) {
5765     z_lhi(result, 0);
5766   } else {
5767 
5768   Label Ldone;
5769 
5770   z_llgfr(odd_reg, haycnt);  // Preset loop ctr/searchrange end.
5771   if (needle == noreg) {
5772     load_const_optimized(Z_R0, (unsigned long)needleChar);
5773   } else {
5774     if (is_byte) {
5775       z_llgcr(Z_R0, needle); // First (and only) needle char.
5776     } else {
5777       z_llghr(Z_R0, needle); // First (and only) needle char.
5778     }
5779   }
5780 
5781   if (!is_byte) {
5782     z_agr(odd_reg, odd_reg); // Calc #bytes to be processed with SRSTU.
5783   }
5784 
5785   z_lgr(even_reg, haystack); // haystack addr
5786   z_agr(odd_reg, haystack);  // First char after range end.
5787   z_lghi(result, -1);
5788 
5789   if (is_byte) {
5790     MacroAssembler::search_string(odd_reg, even_reg);
5791   } else {
5792     MacroAssembler::search_string_uni(odd_reg, even_reg);
5793   }
5794   z_brc(Assembler::bcondNotFound, Ldone);
5795   if (is_byte) {
5796     if (VM_Version::has_DistinctOpnds()) {
5797       z_sgrk(result, odd_reg, haystack);
5798     } else {
5799       z_sgr(odd_reg, haystack);
5800       z_lgr(result, odd_reg);
5801     }
5802   } else {
5803     z_slgr(odd_reg, haystack);
5804     z_srlg(result, odd_reg, exact_log2(sizeof(jchar)));
5805   }
5806 
5807   bind(Ldone);
5808   }
5809   BLOCK_COMMENT(&quot;} string_indexof_char&quot;);
5810 
5811   return offset() - block_start;
5812 }
<a name="52" id="anc52"></a><span class="line-modified">5813 </span>
5814 
5815 //-------------------------------------------------
5816 //   Constants (scalar and oop) in constant pool
5817 //-------------------------------------------------
5818 
5819 // Add a non-relocated constant to the CP.
5820 int MacroAssembler::store_const_in_toc(AddressLiteral&amp; val) {
5821   long    value  = val.value();
5822   address tocPos = long_constant(value);
5823 
5824   if (tocPos != NULL) {
5825     int tocOffset = (int)(tocPos - code()-&gt;consts()-&gt;start());
5826     return tocOffset;
5827   }
5828   // Address_constant returned NULL, so no constant entry has been created.
5829   // In that case, we return a &quot;fatal&quot; offset, just in case that subsequently
5830   // generated access code is executed.
5831   return -1;
5832 }
5833 
5834 // Returns the TOC offset where the address is stored.
5835 // Add a relocated constant to the CP.
5836 int MacroAssembler::store_oop_in_toc(AddressLiteral&amp; oop) {
5837   // Use RelocationHolder::none for the constant pool entry.
5838   // Otherwise we will end up with a failing NativeCall::verify(x),
5839   // where x is the address of the constant pool entry.
5840   address tocPos = address_constant((address)oop.value(), RelocationHolder::none);
5841 
5842   if (tocPos != NULL) {
5843     int              tocOffset = (int)(tocPos - code()-&gt;consts()-&gt;start());
5844     RelocationHolder rsp = oop.rspec();
5845     Relocation      *rel = rsp.reloc();
5846 
5847     // Store toc_offset in relocation, used by call_far_patchable.
5848     if ((relocInfo::relocType)rel-&gt;type() == relocInfo::runtime_call_w_cp_type) {
5849       ((runtime_call_w_cp_Relocation *)(rel))-&gt;set_constant_pool_offset(tocOffset);
5850     }
5851     // Relocate at the load&#39;s pc.
5852     relocate(rsp);
5853 
5854     return tocOffset;
5855   }
5856   // Address_constant returned NULL, so no constant entry has been created
5857   // in that case, we return a &quot;fatal&quot; offset, just in case that subsequently
5858   // generated access code is executed.
5859   return -1;
5860 }
5861 
5862 bool MacroAssembler::load_const_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc) {
5863   int     tocOffset = store_const_in_toc(a);
5864   if (tocOffset == -1) return false;
5865   address tocPos    = tocOffset + code()-&gt;consts()-&gt;start();
5866   assert((address)code()-&gt;consts()-&gt;start() != NULL, &quot;Please add CP address&quot;);
<a name="53" id="anc53"></a><span class="line-modified">5867 </span>
5868   load_long_pcrelative(dst, tocPos);
5869   return true;
5870 }
5871 
5872 bool MacroAssembler::load_oop_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc) {
5873   int     tocOffset = store_oop_in_toc(a);
5874   if (tocOffset == -1) return false;
5875   address tocPos    = tocOffset + code()-&gt;consts()-&gt;start();
5876   assert((address)code()-&gt;consts()-&gt;start() != NULL, &quot;Please add CP address&quot;);
5877 
5878   load_addr_pcrelative(dst, tocPos);
5879   return true;
5880 }
5881 
5882 // If the instruction sequence at the given pc is a load_const_from_toc
5883 // sequence, return the value currently stored at the referenced position
5884 // in the TOC.
5885 intptr_t MacroAssembler::get_const_from_toc(address pc) {
5886 
5887   assert(is_load_const_from_toc(pc), &quot;must be load_const_from_pool&quot;);
5888 
5889   long    offset  = get_load_const_from_toc_offset(pc);
5890   address dataLoc = NULL;
5891   if (is_load_const_from_toc_pcrelative(pc)) {
5892     dataLoc = pc + offset;
5893   } else {
5894     CodeBlob* cb = CodeCache::find_blob_unsafe(pc);   // Else we get assertion if nmethod is zombie.
5895     assert(cb &amp;&amp; cb-&gt;is_nmethod(), &quot;sanity&quot;);
5896     nmethod* nm = (nmethod*)cb;
5897     dataLoc = nm-&gt;ctable_begin() + offset;
5898   }
5899   return *(intptr_t *)dataLoc;
5900 }
5901 
5902 // If the instruction sequence at the given pc is a load_const_from_toc
5903 // sequence, copy the passed-in new_data value into the referenced
5904 // position in the TOC.
5905 void MacroAssembler::set_const_in_toc(address pc, unsigned long new_data, CodeBlob *cb) {
5906   assert(is_load_const_from_toc(pc), &quot;must be load_const_from_pool&quot;);
5907 
5908   long    offset = MacroAssembler::get_load_const_from_toc_offset(pc);
5909   address dataLoc = NULL;
5910   if (is_load_const_from_toc_pcrelative(pc)) {
5911     dataLoc = pc+offset;
5912   } else {
5913     nmethod* nm = CodeCache::find_nmethod(pc);
5914     assert((cb == NULL) || (nm == (nmethod*)cb), &quot;instruction address should be in CodeBlob&quot;);
5915     dataLoc = nm-&gt;ctable_begin() + offset;
5916   }
5917   if (*(unsigned long *)dataLoc != new_data) { // Prevent cache invalidation: update only if necessary.
5918     *(unsigned long *)dataLoc = new_data;
5919   }
5920 }
5921 
5922 // Dynamic TOC. Getter must only be called if &quot;a&quot; is a load_const_from_toc
5923 // site. Verify by calling is_load_const_from_toc() before!!
5924 // Offset is +/- 2**32 -&gt; use long.
5925 long MacroAssembler::get_load_const_from_toc_offset(address a) {
5926   assert(is_load_const_from_toc_pcrelative(a), &quot;expected pc relative load&quot;);
5927   //  expected code sequence:
5928   //    z_lgrl(t, simm32);    len = 6
5929   unsigned long inst;
5930   unsigned int  len = get_instruction(a, &amp;inst);
5931   return get_pcrel_offset(inst);
5932 }
5933 
5934 //**********************************************************************************
5935 //  inspection of generated instruction sequences for a particular pattern
5936 //**********************************************************************************
5937 
5938 bool MacroAssembler::is_load_const_from_toc_pcrelative(address a) {
5939 #ifdef ASSERT
5940   unsigned long inst;
5941   unsigned int  len = get_instruction(a+2, &amp;inst);
5942   if ((len == 6) &amp;&amp; is_load_pcrelative_long(a) &amp;&amp; is_call_pcrelative_long(inst)) {
5943     const int range = 128;
5944     Assembler::dump_code_range(tty, a, range, &quot;instr(a) == z_lgrl &amp;&amp; instr(a+2) == z_brasl&quot;);
5945     VM_Version::z_SIGSEGV();
5946   }
5947 #endif
5948   // expected code sequence:
5949   //   z_lgrl(t, relAddr32);    len = 6
5950   //TODO: verify accessed data is in CP, if possible.
5951   return is_load_pcrelative_long(a);  // TODO: might be too general. Currently, only lgrl is used.
5952 }
5953 
5954 bool MacroAssembler::is_load_const_from_toc_call(address a) {
5955   return is_load_const_from_toc(a) &amp;&amp; is_call_byregister(a + load_const_from_toc_size());
5956 }
5957 
5958 bool MacroAssembler::is_load_const_call(address a) {
5959   return is_load_const(a) &amp;&amp; is_call_byregister(a + load_const_size());
5960 }
5961 
5962 //-------------------------------------------------
5963 //   Emitters for some really CICS instructions
5964 //-------------------------------------------------
5965 
5966 void MacroAssembler::move_long_ext(Register dst, Register src, unsigned int pad) {
5967   assert(dst-&gt;encoding()%2==0, &quot;must be an even/odd register pair&quot;);
5968   assert(src-&gt;encoding()%2==0, &quot;must be an even/odd register pair&quot;);
5969   assert(pad&lt;256, &quot;must be a padding BYTE&quot;);
5970 
5971   Label retry;
5972   bind(retry);
5973   Assembler::z_mvcle(dst, src, pad);
5974   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
5975 }
5976 
5977 void MacroAssembler::compare_long_ext(Register left, Register right, unsigned int pad) {
5978   assert(left-&gt;encoding() % 2 == 0, &quot;must be an even/odd register pair&quot;);
5979   assert(right-&gt;encoding() % 2 == 0, &quot;must be an even/odd register pair&quot;);
5980   assert(pad&lt;256, &quot;must be a padding BYTE&quot;);
5981 
5982   Label retry;
5983   bind(retry);
5984   Assembler::z_clcle(left, right, pad, Z_R0);
5985   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
5986 }
5987 
5988 void MacroAssembler::compare_long_uni(Register left, Register right, unsigned int pad) {
5989   assert(left-&gt;encoding() % 2 == 0, &quot;must be an even/odd register pair&quot;);
5990   assert(right-&gt;encoding() % 2 == 0, &quot;must be an even/odd register pair&quot;);
5991   assert(pad&lt;=0xfff, &quot;must be a padding HALFWORD&quot;);
5992   assert(VM_Version::has_ETF2(), &quot;instruction must be available&quot;);
5993 
5994   Label retry;
5995   bind(retry);
5996   Assembler::z_clclu(left, right, pad, Z_R0);
5997   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
5998 }
5999 
6000 void MacroAssembler::search_string(Register end, Register start) {
6001   assert(end-&gt;encoding() != 0, &quot;end address must not be in R0&quot;);
6002   assert(start-&gt;encoding() != 0, &quot;start address must not be in R0&quot;);
6003 
6004   Label retry;
6005   bind(retry);
6006   Assembler::z_srst(end, start);
6007   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6008 }
6009 
6010 void MacroAssembler::search_string_uni(Register end, Register start) {
6011   assert(end-&gt;encoding() != 0, &quot;end address must not be in R0&quot;);
6012   assert(start-&gt;encoding() != 0, &quot;start address must not be in R0&quot;);
6013   assert(VM_Version::has_ETF3(), &quot;instruction must be available&quot;);
6014 
6015   Label retry;
6016   bind(retry);
6017   Assembler::z_srstu(end, start);
6018   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6019 }
6020 
6021 void MacroAssembler::kmac(Register srcBuff) {
6022   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
6023   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer/len must be an even/odd register pair&quot;);
6024 
6025   Label retry;
6026   bind(retry);
6027   Assembler::z_kmac(Z_R0, srcBuff);
6028   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6029 }
6030 
6031 void MacroAssembler::kimd(Register srcBuff) {
6032   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
6033   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer/len must be an even/odd register pair&quot;);
6034 
6035   Label retry;
6036   bind(retry);
6037   Assembler::z_kimd(Z_R0, srcBuff);
6038   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6039 }
6040 
6041 void MacroAssembler::klmd(Register srcBuff) {
6042   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
6043   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer/len must be an even/odd register pair&quot;);
6044 
6045   Label retry;
6046   bind(retry);
6047   Assembler::z_klmd(Z_R0, srcBuff);
6048   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6049 }
6050 
6051 void MacroAssembler::km(Register dstBuff, Register srcBuff) {
6052   // DstBuff and srcBuff are allowed to be the same register (encryption in-place).
6053   // DstBuff and srcBuff storage must not overlap destructively, and neither must overlap the parameter block.
6054   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
6055   assert(dstBuff-&gt;encoding() % 2 == 0, &quot;dst buffer addr must be an even register&quot;);
6056   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer addr/len must be an even/odd register pair&quot;);
6057 
6058   Label retry;
6059   bind(retry);
6060   Assembler::z_km(dstBuff, srcBuff);
6061   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6062 }
6063 
6064 void MacroAssembler::kmc(Register dstBuff, Register srcBuff) {
6065   // DstBuff and srcBuff are allowed to be the same register (encryption in-place).
6066   // DstBuff and srcBuff storage must not overlap destructively, and neither must overlap the parameter block.
6067   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
6068   assert(dstBuff-&gt;encoding() % 2 == 0, &quot;dst buffer addr must be an even register&quot;);
6069   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer addr/len must be an even/odd register pair&quot;);
6070 
6071   Label retry;
6072   bind(retry);
6073   Assembler::z_kmc(dstBuff, srcBuff);
6074   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6075 }
6076 
6077 void MacroAssembler::cksm(Register crcBuff, Register srcBuff) {
6078   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer addr/len must be an even/odd register pair&quot;);
6079 
6080   Label retry;
6081   bind(retry);
6082   Assembler::z_cksm(crcBuff, srcBuff);
6083   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6084 }
6085 
6086 void MacroAssembler::translate_oo(Register r1, Register r2, uint m3) {
6087   assert(r1-&gt;encoding() % 2 == 0, &quot;dst addr/src len must be an even/odd register pair&quot;);
6088   assert((m3 &amp; 0b1110) == 0, &quot;Unused mask bits must be zero&quot;);
6089 
6090   Label retry;
6091   bind(retry);
6092   Assembler::z_troo(r1, r2, m3);
6093   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6094 }
6095 
6096 void MacroAssembler::translate_ot(Register r1, Register r2, uint m3) {
6097   assert(r1-&gt;encoding() % 2 == 0, &quot;dst addr/src len must be an even/odd register pair&quot;);
6098   assert((m3 &amp; 0b1110) == 0, &quot;Unused mask bits must be zero&quot;);
6099 
6100   Label retry;
6101   bind(retry);
6102   Assembler::z_trot(r1, r2, m3);
6103   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6104 }
6105 
6106 void MacroAssembler::translate_to(Register r1, Register r2, uint m3) {
6107   assert(r1-&gt;encoding() % 2 == 0, &quot;dst addr/src len must be an even/odd register pair&quot;);
6108   assert((m3 &amp; 0b1110) == 0, &quot;Unused mask bits must be zero&quot;);
6109 
6110   Label retry;
6111   bind(retry);
6112   Assembler::z_trto(r1, r2, m3);
6113   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6114 }
6115 
6116 void MacroAssembler::translate_tt(Register r1, Register r2, uint m3) {
6117   assert(r1-&gt;encoding() % 2 == 0, &quot;dst addr/src len must be an even/odd register pair&quot;);
6118   assert((m3 &amp; 0b1110) == 0, &quot;Unused mask bits must be zero&quot;);
6119 
6120   Label retry;
6121   bind(retry);
6122   Assembler::z_trtt(r1, r2, m3);
6123   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6124 }
6125 
<a name="54" id="anc54"></a><span class="line-removed">6126 </span>
<span class="line-removed">6127 void MacroAssembler::generate_type_profiling(const Register Rdata,</span>
<span class="line-removed">6128                                              const Register Rreceiver_klass,</span>
<span class="line-removed">6129                                              const Register Rwanted_receiver_klass,</span>
<span class="line-removed">6130                                              const Register Rmatching_row,</span>
<span class="line-removed">6131                                              bool is_virtual_call) {</span>
<span class="line-removed">6132   const int row_size = in_bytes(ReceiverTypeData::receiver_offset(1)) -</span>
<span class="line-removed">6133                        in_bytes(ReceiverTypeData::receiver_offset(0));</span>
<span class="line-removed">6134   const int num_rows = ReceiverTypeData::row_limit();</span>
<span class="line-removed">6135   NearLabel found_free_row;</span>
<span class="line-removed">6136   NearLabel do_increment;</span>
<span class="line-removed">6137   NearLabel found_no_slot;</span>
<span class="line-removed">6138 </span>
<span class="line-removed">6139   BLOCK_COMMENT(&quot;type profiling {&quot;);</span>
<span class="line-removed">6140 </span>
<span class="line-removed">6141   // search for:</span>
<span class="line-removed">6142   //    a) The type given in Rwanted_receiver_klass.</span>
<span class="line-removed">6143   //    b) The *first* empty row.</span>
<span class="line-removed">6144 </span>
<span class="line-removed">6145   // First search for a) only, just running over b) with no regard.</span>
<span class="line-removed">6146   // This is possible because</span>
<span class="line-removed">6147   //    wanted_receiver_class == receiver_class  &amp;&amp;  wanted_receiver_class == 0</span>
<span class="line-removed">6148   // is never true (receiver_class can&#39;t be zero).</span>
<span class="line-removed">6149   for (int row_num = 0; row_num &lt; num_rows; row_num++) {</span>
<span class="line-removed">6150     // Row_offset should be a well-behaved positive number. The generated code relies</span>
<span class="line-removed">6151     // on that wrt constant code size. Add2reg can handle all row_offset values, but</span>
<span class="line-removed">6152     // will have to vary generated code size.</span>
<span class="line-removed">6153     int row_offset = in_bytes(ReceiverTypeData::receiver_offset(row_num));</span>
<span class="line-removed">6154     assert(Displacement::is_shortDisp(row_offset), &quot;Limitation of generated code&quot;);</span>
<span class="line-removed">6155 </span>
<span class="line-removed">6156     // Is Rwanted_receiver_klass in this row?</span>
<span class="line-removed">6157     if (VM_Version::has_CompareBranch()) {</span>
<span class="line-removed">6158       z_lg(Rwanted_receiver_klass, row_offset, Z_R0, Rdata);</span>
<span class="line-removed">6159       // Rmatching_row = Rdata + row_offset;</span>
<span class="line-removed">6160       add2reg(Rmatching_row, row_offset, Rdata);</span>
<span class="line-removed">6161       // if (*row_recv == (intptr_t) receiver_klass) goto fill_existing_slot;</span>
<span class="line-removed">6162       compare64_and_branch(Rwanted_receiver_klass, Rreceiver_klass, Assembler::bcondEqual, do_increment);</span>
<span class="line-removed">6163     } else {</span>
<span class="line-removed">6164       add2reg(Rmatching_row, row_offset, Rdata);</span>
<span class="line-removed">6165       z_cg(Rreceiver_klass, row_offset, Z_R0, Rdata);</span>
<span class="line-removed">6166       z_bre(do_increment);</span>
<span class="line-removed">6167     }</span>
<span class="line-removed">6168   }</span>
<span class="line-removed">6169 </span>
<span class="line-removed">6170   // Now that we did not find a match, let&#39;s search for b).</span>
<span class="line-removed">6171 </span>
<span class="line-removed">6172   // We could save the first calculation of Rmatching_row if we woud search for a) in reverse order.</span>
<span class="line-removed">6173   // We would then end up here with Rmatching_row containing the value for row_num == 0.</span>
<span class="line-removed">6174   // We would not see much benefit, if any at all, because the CPU can schedule</span>
<span class="line-removed">6175   // two instructions together with a branch anyway.</span>
<span class="line-removed">6176   for (int row_num = 0; row_num &lt; num_rows; row_num++) {</span>
<span class="line-removed">6177     int row_offset = in_bytes(ReceiverTypeData::receiver_offset(row_num));</span>
<span class="line-removed">6178 </span>
<span class="line-removed">6179     // Has this row a zero receiver_klass, i.e. is it empty?</span>
<span class="line-removed">6180     if (VM_Version::has_CompareBranch()) {</span>
<span class="line-removed">6181       z_lg(Rwanted_receiver_klass, row_offset, Z_R0, Rdata);</span>
<span class="line-removed">6182       // Rmatching_row = Rdata + row_offset</span>
<span class="line-removed">6183       add2reg(Rmatching_row, row_offset, Rdata);</span>
<span class="line-removed">6184       // if (*row_recv == (intptr_t) 0) goto found_free_row</span>
<span class="line-removed">6185       compare64_and_branch(Rwanted_receiver_klass, (intptr_t)0, Assembler::bcondEqual, found_free_row);</span>
<span class="line-removed">6186     } else {</span>
<span class="line-removed">6187       add2reg(Rmatching_row, row_offset, Rdata);</span>
<span class="line-removed">6188       load_and_test_long(Rwanted_receiver_klass, Address(Rdata, row_offset));</span>
<span class="line-removed">6189       z_bre(found_free_row);  // zero -&gt; Found a free row.</span>
<span class="line-removed">6190     }</span>
<span class="line-removed">6191   }</span>
<span class="line-removed">6192 </span>
<span class="line-removed">6193   // No match, no empty row found.</span>
<span class="line-removed">6194   // Increment total counter to indicate polymorphic case.</span>
<span class="line-removed">6195   if (is_virtual_call) {</span>
<span class="line-removed">6196     add2mem_64(Address(Rdata, CounterData::count_offset()), 1, Rmatching_row);</span>
<span class="line-removed">6197   }</span>
<span class="line-removed">6198   z_bru(found_no_slot);</span>
<span class="line-removed">6199 </span>
<span class="line-removed">6200   // Here we found an empty row, but we have not found Rwanted_receiver_klass.</span>
<span class="line-removed">6201   // Rmatching_row holds the address to the first empty row.</span>
<span class="line-removed">6202   bind(found_free_row);</span>
<span class="line-removed">6203   // Store receiver_klass into empty slot.</span>
<span class="line-removed">6204   z_stg(Rreceiver_klass, 0, Z_R0, Rmatching_row);</span>
<span class="line-removed">6205 </span>
<span class="line-removed">6206   // Increment the counter of Rmatching_row.</span>
<span class="line-removed">6207   bind(do_increment);</span>
<span class="line-removed">6208   ByteSize counter_offset = ReceiverTypeData::receiver_count_offset(0) - ReceiverTypeData::receiver_offset(0);</span>
<span class="line-removed">6209   add2mem_64(Address(Rmatching_row, counter_offset), 1, Rdata);</span>
<span class="line-removed">6210 </span>
<span class="line-removed">6211   bind(found_no_slot);</span>
<span class="line-removed">6212 </span>
<span class="line-removed">6213   BLOCK_COMMENT(&quot;} type profiling&quot;);</span>
<span class="line-removed">6214 }</span>
<span class="line-removed">6215 </span>
6216 //---------------------------------------
6217 // Helpers for Intrinsic Emitters
6218 //---------------------------------------
6219 
6220 /**
6221  * uint32_t crc;
6222  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
6223  */
6224 void MacroAssembler::fold_byte_crc32(Register crc, Register val, Register table, Register tmp) {
6225   assert_different_registers(crc, table, tmp);
6226   assert_different_registers(val, table);
6227   if (crc == val) {      // Must rotate first to use the unmodified value.
6228     rotate_then_insert(tmp, val, 56-2, 63-2, 2, true);  // Insert byte 7 of val, shifted left by 2, into byte 6..7 of tmp, clear the rest.
6229     z_srl(crc, 8);       // Unsigned shift, clear leftmost 8 bits.
6230   } else {
6231     z_srl(crc, 8);       // Unsigned shift, clear leftmost 8 bits.
6232     rotate_then_insert(tmp, val, 56-2, 63-2, 2, true);  // Insert byte 7 of val, shifted left by 2, into byte 6..7 of tmp, clear the rest.
6233   }
6234   z_x(crc, Address(table, tmp, 0));
6235 }
6236 
6237 /**
6238  * uint32_t crc;
6239  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
6240  */
6241 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
6242   fold_byte_crc32(crc, crc, table, tmp);
6243 }
6244 
6245 /**
6246  * Emits code to update CRC-32 with a byte value according to constants in table.
6247  *
6248  * @param [in,out]crc Register containing the crc.
6249  * @param [in]val     Register containing the byte to fold into the CRC.
6250  * @param [in]table   Register containing the table of crc constants.
6251  *
6252  * uint32_t crc;
6253  * val = crc_table[(val ^ crc) &amp; 0xFF];
6254  * crc = val ^ (crc &gt;&gt; 8);
6255  */
6256 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
6257   z_xr(val, crc);
6258   fold_byte_crc32(crc, val, table, val);
6259 }
6260 
6261 
6262 /**
6263  * @param crc   register containing existing CRC (32-bit)
6264  * @param buf   register pointing to input byte buffer (byte*)
6265  * @param len   register containing number of bytes
6266  * @param table register pointing to CRC table
6267  */
6268 void MacroAssembler::update_byteLoop_crc32(Register crc, Register buf, Register len, Register table, Register data) {
6269   assert_different_registers(crc, buf, len, table, data);
6270 
6271   Label L_mainLoop, L_done;
6272   const int mainLoop_stepping = 1;
6273 
6274   // Process all bytes in a single-byte loop.
6275   z_ltr(len, len);
6276   z_brnh(L_done);
6277 
6278   bind(L_mainLoop);
6279     z_llgc(data, Address(buf, (intptr_t)0));// Current byte of input buffer (zero extended). Avoids garbage in upper half of register.
6280     add2reg(buf, mainLoop_stepping);        // Advance buffer position.
6281     update_byte_crc32(crc, data, table);
6282     z_brct(len, L_mainLoop);                // Iterate.
6283 
6284   bind(L_done);
6285 }
6286 
6287 /**
6288  * Emits code to update CRC-32 with a 4-byte value according to constants in table.
6289  * Implementation according to jdk/src/share/native/java/util/zip/zlib-1.2.8/crc32.c.
6290  *
6291  */
6292 void MacroAssembler::update_1word_crc32(Register crc, Register buf, Register table, int bufDisp, int bufInc,
6293                                         Register t0,  Register t1,  Register t2,    Register t3) {
6294   // This is what we implement (the DOBIG4 part):
6295   //
6296   // #define DOBIG4 c ^= *++buf4; \
6297   //         c = crc_table[4][c &amp; 0xff] ^ crc_table[5][(c &gt;&gt; 8) &amp; 0xff] ^ \
6298   //             crc_table[6][(c &gt;&gt; 16) &amp; 0xff] ^ crc_table[7][c &gt;&gt; 24]
6299   // #define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
6300   // Pre-calculate (constant) column offsets, use columns 4..7 for big-endian.
6301   const int ix0 = 4*(4*CRC32_COLUMN_SIZE);
6302   const int ix1 = 5*(4*CRC32_COLUMN_SIZE);
6303   const int ix2 = 6*(4*CRC32_COLUMN_SIZE);
6304   const int ix3 = 7*(4*CRC32_COLUMN_SIZE);
6305 
6306   // XOR crc with next four bytes of buffer.
6307   lgr_if_needed(t0, crc);
6308   z_x(t0, Address(buf, bufDisp));
6309   if (bufInc != 0) {
6310     add2reg(buf, bufInc);
6311   }
6312 
6313   // Chop crc into 4 single-byte pieces, shifted left 2 bits, to form the table indices.
6314   rotate_then_insert(t3, t0, 56-2, 63-2, 2,    true);  // ((c &gt;&gt;  0) &amp; 0xff) &lt;&lt; 2
6315   rotate_then_insert(t2, t0, 56-2, 63-2, 2-8,  true);  // ((c &gt;&gt;  8) &amp; 0xff) &lt;&lt; 2
6316   rotate_then_insert(t1, t0, 56-2, 63-2, 2-16, true);  // ((c &gt;&gt; 16) &amp; 0xff) &lt;&lt; 2
6317   rotate_then_insert(t0, t0, 56-2, 63-2, 2-24, true);  // ((c &gt;&gt; 24) &amp; 0xff) &lt;&lt; 2
6318 
6319   // XOR indexed table values to calculate updated crc.
6320   z_ly(t2, Address(table, t2, (intptr_t)ix1));
6321   z_ly(t0, Address(table, t0, (intptr_t)ix3));
6322   z_xy(t2, Address(table, t3, (intptr_t)ix0));
6323   z_xy(t0, Address(table, t1, (intptr_t)ix2));
6324   z_xr(t0, t2);           // Now t0 contains the updated CRC value.
6325   lgr_if_needed(crc, t0);
6326 }
6327 
6328 /**
6329  * @param crc   register containing existing CRC (32-bit)
6330  * @param buf   register pointing to input byte buffer (byte*)
6331  * @param len   register containing number of bytes
6332  * @param table register pointing to CRC table
6333  *
6334  * uses Z_R10..Z_R13 as work register. Must be saved/restored by caller!
6335  */
6336 void MacroAssembler::kernel_crc32_1word(Register crc, Register buf, Register len, Register table,
6337                                         Register t0,  Register t1,  Register t2,  Register t3,
6338                                         bool invertCRC) {
6339   assert_different_registers(crc, buf, len, table);
6340 
6341   Label L_mainLoop, L_tail;
6342   Register  data = t0;
6343   Register  ctr  = Z_R0;
6344   const int mainLoop_stepping = 4;
6345   const int log_stepping      = exact_log2(mainLoop_stepping);
6346 
6347   // Don&#39;t test for len &lt;= 0 here. This pathological case should not occur anyway.
6348   // Optimizing for it by adding a test and a branch seems to be a waste of CPU cycles.
6349   // The situation itself is detected and handled correctly by the conditional branches
6350   // following aghi(len, -stepping) and aghi(len, +stepping).
6351 
6352   if (invertCRC) {
6353     not_(crc, noreg, false);           // 1s complement of crc
6354   }
6355 
6356   // Check for short (&lt;4 bytes) buffer.
6357   z_srag(ctr, len, log_stepping);
6358   z_brnh(L_tail);
6359 
6360   z_lrvr(crc, crc);          // Revert byte order because we are dealing with big-endian data.
6361   rotate_then_insert(len, len, 64-log_stepping, 63, 0, true); // #bytes for tailLoop
6362 
6363   BIND(L_mainLoop);
6364     update_1word_crc32(crc, buf, table, 0, mainLoop_stepping, crc, t1, t2, t3);
6365     z_brct(ctr, L_mainLoop); // Iterate.
6366 
6367   z_lrvr(crc, crc);          // Revert byte order back to original.
6368 
6369   // Process last few (&lt;8) bytes of buffer.
6370   BIND(L_tail);
6371   update_byteLoop_crc32(crc, buf, len, table, data);
6372 
6373   if (invertCRC) {
6374     not_(crc, noreg, false);           // 1s complement of crc
6375   }
6376 }
6377 
6378 /**
6379  * @param crc   register containing existing CRC (32-bit)
6380  * @param buf   register pointing to input byte buffer (byte*)
6381  * @param len   register containing number of bytes
6382  * @param table register pointing to CRC table
6383  */
6384 void MacroAssembler::kernel_crc32_1byte(Register crc, Register buf, Register len, Register table,
6385                                         Register t0,  Register t1,  Register t2,  Register t3,
6386                                         bool invertCRC) {
6387   assert_different_registers(crc, buf, len, table);
6388   Register data = t0;
6389 
6390   if (invertCRC) {
6391     not_(crc, noreg, false);           // 1s complement of crc
6392   }
6393 
6394   update_byteLoop_crc32(crc, buf, len, table, data);
6395 
6396   if (invertCRC) {
6397     not_(crc, noreg, false);           // 1s complement of crc
6398   }
6399 }
6400 
6401 void MacroAssembler::kernel_crc32_singleByte(Register crc, Register buf, Register len, Register table, Register tmp,
6402                                              bool invertCRC) {
6403   assert_different_registers(crc, buf, len, table, tmp);
6404 
6405   if (invertCRC) {
6406     not_(crc, noreg, false);           // 1s complement of crc
6407   }
6408 
6409   z_llgc(tmp, Address(buf, (intptr_t)0));  // Current byte of input buffer (zero extended). Avoids garbage in upper half of register.
6410   update_byte_crc32(crc, tmp, table);
6411 
6412   if (invertCRC) {
6413     not_(crc, noreg, false);           // 1s complement of crc
6414   }
6415 }
6416 
6417 void MacroAssembler::kernel_crc32_singleByteReg(Register crc, Register val, Register table,
6418                                                 bool invertCRC) {
6419   assert_different_registers(crc, val, table);
6420 
6421   if (invertCRC) {
6422     not_(crc, noreg, false);           // 1s complement of crc
6423   }
6424 
6425   update_byte_crc32(crc, val, table);
6426 
6427   if (invertCRC) {
6428     not_(crc, noreg, false);           // 1s complement of crc
6429   }
6430 }
6431 
6432 //
6433 // Code for BigInteger::multiplyToLen() intrinsic.
6434 //
6435 
6436 // dest_lo += src1 + src2
6437 // dest_hi += carry1 + carry2
6438 // Z_R7 is destroyed !
6439 void MacroAssembler::add2_with_carry(Register dest_hi, Register dest_lo,
6440                                      Register src1, Register src2) {
6441   clear_reg(Z_R7);
6442   z_algr(dest_lo, src1);
6443   z_alcgr(dest_hi, Z_R7);
6444   z_algr(dest_lo, src2);
6445   z_alcgr(dest_hi, Z_R7);
6446 }
6447 
6448 // Multiply 64 bit by 64 bit first loop.
6449 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart,
6450                                            Register x_xstart,
6451                                            Register y, Register y_idx,
6452                                            Register z,
6453                                            Register carry,
6454                                            Register product,
6455                                            Register idx, Register kdx) {
6456   // jlong carry, x[], y[], z[];
6457   // for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx--, kdx--) {
6458   //   huge_128 product = y[idx] * x[xstart] + carry;
6459   //   z[kdx] = (jlong)product;
6460   //   carry  = (jlong)(product &gt;&gt;&gt; 64);
6461   // }
6462   // z[xstart] = carry;
6463 
6464   Label L_first_loop, L_first_loop_exit;
6465   Label L_one_x, L_one_y, L_multiply;
6466 
6467   z_aghi(xstart, -1);
6468   z_brl(L_one_x);   // Special case: length of x is 1.
6469 
6470   // Load next two integers of x.
6471   z_sllg(Z_R1_scratch, xstart, LogBytesPerInt);
6472   mem2reg_opt(x_xstart, Address(x, Z_R1_scratch, 0));
6473 
6474 
6475   bind(L_first_loop);
6476 
6477   z_aghi(idx, -1);
6478   z_brl(L_first_loop_exit);
6479   z_aghi(idx, -1);
6480   z_brl(L_one_y);
6481 
6482   // Load next two integers of y.
6483   z_sllg(Z_R1_scratch, idx, LogBytesPerInt);
6484   mem2reg_opt(y_idx, Address(y, Z_R1_scratch, 0));
6485 
6486 
6487   bind(L_multiply);
6488 
6489   Register multiplicand = product-&gt;successor();
6490   Register product_low = multiplicand;
6491 
6492   lgr_if_needed(multiplicand, x_xstart);
6493   z_mlgr(product, y_idx);     // multiplicand * y_idx -&gt; product::multiplicand
6494   clear_reg(Z_R7);
6495   z_algr(product_low, carry); // Add carry to result.
6496   z_alcgr(product, Z_R7);     // Add carry of the last addition.
6497   add2reg(kdx, -2);
6498 
6499   // Store result.
6500   z_sllg(Z_R7, kdx, LogBytesPerInt);
6501   reg2mem_opt(product_low, Address(z, Z_R7, 0));
6502   lgr_if_needed(carry, product);
6503   z_bru(L_first_loop);
6504 
6505 
6506   bind(L_one_y); // Load one 32 bit portion of y as (0,value).
6507 
6508   clear_reg(y_idx);
6509   mem2reg_opt(y_idx, Address(y, (intptr_t) 0), false);
6510   z_bru(L_multiply);
6511 
6512 
6513   bind(L_one_x); // Load one 32 bit portion of x as (0,value).
6514 
6515   clear_reg(x_xstart);
6516   mem2reg_opt(x_xstart, Address(x, (intptr_t) 0), false);
6517   z_bru(L_first_loop);
6518 
6519   bind(L_first_loop_exit);
6520 }
6521 
6522 // Multiply 64 bit by 64 bit and add 128 bit.
6523 void MacroAssembler::multiply_add_128_x_128(Register x_xstart, Register y,
6524                                             Register z,
6525                                             Register yz_idx, Register idx,
6526                                             Register carry, Register product,
6527                                             int offset) {
6528   // huge_128 product = (y[idx] * x_xstart) + z[kdx] + carry;
6529   // z[kdx] = (jlong)product;
6530 
6531   Register multiplicand = product-&gt;successor();
6532   Register product_low = multiplicand;
6533 
6534   z_sllg(Z_R7, idx, LogBytesPerInt);
6535   mem2reg_opt(yz_idx, Address(y, Z_R7, offset));
6536 
6537   lgr_if_needed(multiplicand, x_xstart);
6538   z_mlgr(product, yz_idx); // multiplicand * yz_idx -&gt; product::multiplicand
6539   mem2reg_opt(yz_idx, Address(z, Z_R7, offset));
6540 
6541   add2_with_carry(product, product_low, carry, yz_idx);
6542 
6543   z_sllg(Z_R7, idx, LogBytesPerInt);
6544   reg2mem_opt(product_low, Address(z, Z_R7, offset));
6545 
6546 }
6547 
6548 // Multiply 128 bit by 128 bit. Unrolled inner loop.
6549 void MacroAssembler::multiply_128_x_128_loop(Register x_xstart,
6550                                              Register y, Register z,
6551                                              Register yz_idx, Register idx,
6552                                              Register jdx,
6553                                              Register carry, Register product,
6554                                              Register carry2) {
6555   // jlong carry, x[], y[], z[];
6556   // int kdx = ystart+1;
6557   // for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
6558   //   huge_128 product = (y[idx+1] * x_xstart) + z[kdx+idx+1] + carry;
6559   //   z[kdx+idx+1] = (jlong)product;
6560   //   jlong carry2 = (jlong)(product &gt;&gt;&gt; 64);
6561   //   product = (y[idx] * x_xstart) + z[kdx+idx] + carry2;
6562   //   z[kdx+idx] = (jlong)product;
6563   //   carry = (jlong)(product &gt;&gt;&gt; 64);
6564   // }
6565   // idx += 2;
6566   // if (idx &gt; 0) {
6567   //   product = (y[idx] * x_xstart) + z[kdx+idx] + carry;
6568   //   z[kdx+idx] = (jlong)product;
6569   //   carry = (jlong)(product &gt;&gt;&gt; 64);
6570   // }
6571 
6572   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
6573 
6574   // scale the index
6575   lgr_if_needed(jdx, idx);
6576   and_imm(jdx, 0xfffffffffffffffcL);
6577   rshift(jdx, 2);
6578 
6579 
6580   bind(L_third_loop);
6581 
6582   z_aghi(jdx, -1);
6583   z_brl(L_third_loop_exit);
6584   add2reg(idx, -4);
6585 
6586   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 8);
6587   lgr_if_needed(carry2, product);
6588 
6589   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry2, product, 0);
6590   lgr_if_needed(carry, product);
6591   z_bru(L_third_loop);
6592 
6593 
6594   bind(L_third_loop_exit);  // Handle any left-over operand parts.
6595 
6596   and_imm(idx, 0x3);
6597   z_brz(L_post_third_loop_done);
6598 
6599   Label L_check_1;
6600 
6601   z_aghi(idx, -2);
6602   z_brl(L_check_1);
6603 
6604   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 0);
6605   lgr_if_needed(carry, product);
6606 
6607 
6608   bind(L_check_1);
6609 
6610   add2reg(idx, 0x2);
6611   and_imm(idx, 0x1);
6612   z_aghi(idx, -1);
6613   z_brl(L_post_third_loop_done);
6614 
6615   Register   multiplicand = product-&gt;successor();
6616   Register   product_low = multiplicand;
6617 
6618   z_sllg(Z_R7, idx, LogBytesPerInt);
6619   clear_reg(yz_idx);
6620   mem2reg_opt(yz_idx, Address(y, Z_R7, 0), false);
6621   lgr_if_needed(multiplicand, x_xstart);
6622   z_mlgr(product, yz_idx); // multiplicand * yz_idx -&gt; product::multiplicand
6623   clear_reg(yz_idx);
6624   mem2reg_opt(yz_idx, Address(z, Z_R7, 0), false);
6625 
6626   add2_with_carry(product, product_low, yz_idx, carry);
6627 
6628   z_sllg(Z_R7, idx, LogBytesPerInt);
6629   reg2mem_opt(product_low, Address(z, Z_R7, 0), false);
6630   rshift(product_low, 32);
6631 
6632   lshift(product, 32);
6633   z_ogr(product_low, product);
6634   lgr_if_needed(carry, product_low);
6635 
6636   bind(L_post_third_loop_done);
6637 }
6638 
6639 void MacroAssembler::multiply_to_len(Register x, Register xlen,
6640                                      Register y, Register ylen,
6641                                      Register z,
6642                                      Register tmp1, Register tmp2,
6643                                      Register tmp3, Register tmp4,
6644                                      Register tmp5) {
6645   ShortBranchVerifier sbv(this);
6646 
6647   assert_different_registers(x, xlen, y, ylen, z,
6648                              tmp1, tmp2, tmp3, tmp4, tmp5, Z_R1_scratch, Z_R7);
6649   assert_different_registers(x, xlen, y, ylen, z,
6650                              tmp1, tmp2, tmp3, tmp4, tmp5, Z_R8);
6651 
6652   z_stmg(Z_R7, Z_R13, _z_abi(gpr7), Z_SP);
6653 
6654   // In openJdk, we store the argument as 32-bit value to slot.
6655   Address zlen(Z_SP, _z_abi(remaining_cargs));  // Int in long on big endian.
6656 
6657   const Register idx = tmp1;
6658   const Register kdx = tmp2;
6659   const Register xstart = tmp3;
6660 
6661   const Register y_idx = tmp4;
6662   const Register carry = tmp5;
6663   const Register product  = Z_R0_scratch;
6664   const Register x_xstart = Z_R8;
6665 
6666   // First Loop.
6667   //
6668   //   final static long LONG_MASK = 0xffffffffL;
6669   //   int xstart = xlen - 1;
6670   //   int ystart = ylen - 1;
6671   //   long carry = 0;
6672   //   for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
6673   //     long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
6674   //     z[kdx] = (int)product;
6675   //     carry = product &gt;&gt;&gt; 32;
6676   //   }
6677   //   z[xstart] = (int)carry;
6678   //
6679 
6680   lgr_if_needed(idx, ylen);  // idx = ylen
6681   z_llgf(kdx, zlen);         // C2 does not respect int to long conversion for stub calls, thus load zero-extended.
6682   clear_reg(carry);          // carry = 0
6683 
6684   Label L_done;
6685 
6686   lgr_if_needed(xstart, xlen);
6687   z_aghi(xstart, -1);
6688   z_brl(L_done);
6689 
6690   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
6691 
6692   NearLabel L_second_loop;
6693   compare64_and_branch(kdx, RegisterOrConstant((intptr_t) 0), bcondEqual, L_second_loop);
6694 
6695   NearLabel L_carry;
6696   z_aghi(kdx, -1);
6697   z_brz(L_carry);
6698 
6699   // Store lower 32 bits of carry.
6700   z_sllg(Z_R1_scratch, kdx, LogBytesPerInt);
6701   reg2mem_opt(carry, Address(z, Z_R1_scratch, 0), false);
6702   rshift(carry, 32);
6703   z_aghi(kdx, -1);
6704 
6705 
6706   bind(L_carry);
6707 
6708   // Store upper 32 bits of carry.
6709   z_sllg(Z_R1_scratch, kdx, LogBytesPerInt);
6710   reg2mem_opt(carry, Address(z, Z_R1_scratch, 0), false);
6711 
6712   // Second and third (nested) loops.
6713   //
6714   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
6715   //   carry = 0;
6716   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
6717   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
6718   //                    (z[k] &amp; LONG_MASK) + carry;
6719   //     z[k] = (int)product;
6720   //     carry = product &gt;&gt;&gt; 32;
6721   //   }
6722   //   z[i] = (int)carry;
6723   // }
6724   //
6725   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = rdx
6726 
6727   const Register jdx = tmp1;
6728 
6729   bind(L_second_loop);
6730 
6731   clear_reg(carry);           // carry = 0;
6732   lgr_if_needed(jdx, ylen);   // j = ystart+1
6733 
6734   z_aghi(xstart, -1);         // i = xstart-1;
6735   z_brl(L_done);
6736 
6737   // Use free slots in the current stackframe instead of push/pop.
6738   Address zsave(Z_SP, _z_abi(carg_1));
6739   reg2mem_opt(z, zsave);
6740 
6741 
6742   Label L_last_x;
6743 
6744   z_sllg(Z_R1_scratch, xstart, LogBytesPerInt);
6745   load_address(z, Address(z, Z_R1_scratch, 4)); // z = z + k - j
6746   z_aghi(xstart, -1);                           // i = xstart-1;
6747   z_brl(L_last_x);
6748 
6749   z_sllg(Z_R1_scratch, xstart, LogBytesPerInt);
6750   mem2reg_opt(x_xstart, Address(x, Z_R1_scratch, 0));
6751 
6752 
6753   Label L_third_loop_prologue;
6754 
6755   bind(L_third_loop_prologue);
6756 
6757   Address xsave(Z_SP, _z_abi(carg_2));
6758   Address xlensave(Z_SP, _z_abi(carg_3));
6759   Address ylensave(Z_SP, _z_abi(carg_4));
6760 
6761   reg2mem_opt(x, xsave);
6762   reg2mem_opt(xstart, xlensave);
6763   reg2mem_opt(ylen, ylensave);
6764 
6765 
6766   multiply_128_x_128_loop(x_xstart, y, z, y_idx, jdx, ylen, carry, product, x);
6767 
6768   mem2reg_opt(z, zsave);
6769   mem2reg_opt(x, xsave);
6770   mem2reg_opt(xlen, xlensave);   // This is the decrement of the loop counter!
6771   mem2reg_opt(ylen, ylensave);
6772 
6773   add2reg(tmp3, 1, xlen);
6774   z_sllg(Z_R1_scratch, tmp3, LogBytesPerInt);
6775   reg2mem_opt(carry, Address(z, Z_R1_scratch, 0), false);
6776   z_aghi(tmp3, -1);
6777   z_brl(L_done);
6778 
6779   rshift(carry, 32);
6780   z_sllg(Z_R1_scratch, tmp3, LogBytesPerInt);
6781   reg2mem_opt(carry, Address(z, Z_R1_scratch, 0), false);
6782   z_bru(L_second_loop);
6783 
6784   // Next infrequent code is moved outside loops.
6785   bind(L_last_x);
6786 
6787   clear_reg(x_xstart);
6788   mem2reg_opt(x_xstart, Address(x, (intptr_t) 0), false);
6789   z_bru(L_third_loop_prologue);
6790 
6791   bind(L_done);
6792 
6793   z_lmg(Z_R7, Z_R13, _z_abi(gpr7), Z_SP);
6794 }
6795 
6796 #ifndef PRODUCT
6797 // Assert if CC indicates &quot;not equal&quot; (check_equal==true) or &quot;equal&quot; (check_equal==false).
6798 void MacroAssembler::asm_assert(bool check_equal, const char *msg, int id) {
6799   Label ok;
6800   if (check_equal) {
6801     z_bre(ok);
6802   } else {
6803     z_brne(ok);
6804   }
6805   stop(msg, id);
6806   bind(ok);
6807 }
6808 
6809 // Assert if CC indicates &quot;low&quot;.
6810 void MacroAssembler::asm_assert_low(const char *msg, int id) {
6811   Label ok;
6812   z_brnl(ok);
6813   stop(msg, id);
6814   bind(ok);
6815 }
6816 
6817 // Assert if CC indicates &quot;high&quot;.
6818 void MacroAssembler::asm_assert_high(const char *msg, int id) {
6819   Label ok;
6820   z_brnh(ok);
6821   stop(msg, id);
6822   bind(ok);
6823 }
6824 
6825 // Assert if CC indicates &quot;not equal&quot; (check_equal==true) or &quot;equal&quot; (check_equal==false)
6826 // generate non-relocatable code.
6827 void MacroAssembler::asm_assert_static(bool check_equal, const char *msg, int id) {
6828   Label ok;
6829   if (check_equal) { z_bre(ok); }
6830   else             { z_brne(ok); }
6831   stop_static(msg, id);
6832   bind(ok);
6833 }
6834 
6835 void MacroAssembler::asm_assert_mems_zero(bool check_equal, bool allow_relocation, int size, int64_t mem_offset,
6836                                           Register mem_base, const char* msg, int id) {
6837   switch (size) {
6838     case 4:
6839       load_and_test_int(Z_R0, Address(mem_base, mem_offset));
6840       break;
6841     case 8:
6842       load_and_test_long(Z_R0,  Address(mem_base, mem_offset));
6843       break;
6844     default:
6845       ShouldNotReachHere();
6846   }
6847   if (allow_relocation) { asm_assert(check_equal, msg, id); }
6848   else                  { asm_assert_static(check_equal, msg, id); }
6849 }
6850 
6851 // Check the condition
6852 //   expected_size == FP - SP
6853 // after transformation:
6854 //   expected_size - FP + SP == 0
6855 // Destroys Register expected_size if no tmp register is passed.
6856 void MacroAssembler::asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id) {
6857   if (tmp == noreg) {
6858     tmp = expected_size;
6859   } else {
6860     if (tmp != expected_size) {
6861       z_lgr(tmp, expected_size);
6862     }
6863     z_algr(tmp, Z_SP);
6864     z_slg(tmp, 0, Z_R0, Z_SP);
6865     asm_assert_eq(msg, id);
6866   }
6867 }
6868 #endif // !PRODUCT
6869 
6870 void MacroAssembler::verify_thread() {
6871   if (VerifyThread) {
6872     unimplemented(&quot;&quot;, 117);
6873   }
6874 }
6875 
<a name="55" id="anc55"></a>







































6876 // Plausibility check for oops.
6877 void MacroAssembler::verify_oop(Register oop, const char* msg) {
6878   if (!VerifyOops) return;
6879 
6880   BLOCK_COMMENT(&quot;verify_oop {&quot;);
<a name="56" id="anc56"></a><span class="line-modified">6881   Register tmp = Z_R0;</span>
<span class="line-modified">6882   unsigned int nbytes_save = 5*BytesPerWord;</span>
<span class="line-modified">6883   address entry = StubRoutines::verify_oop_subroutine_entry_address();</span>




























6884 
6885   save_return_pc();
<a name="57" id="anc57"></a><span class="line-modified">6886   push_frame_abi160(nbytes_save);</span>
<span class="line-modified">6887   z_stmg(Z_R1, Z_R5, frame::z_abi_160_size, Z_SP);</span>
6888 
<a name="58" id="anc58"></a><span class="line-modified">6889   z_lgr(Z_ARG2, oop);</span>
<span class="line-modified">6890   load_const(Z_ARG1, (address) msg);</span>
<span class="line-modified">6891   load_const(Z_R1, entry);</span>
6892   z_lg(Z_R1, 0, Z_R1);
6893   call_c(Z_R1);
6894 
<a name="59" id="anc59"></a><span class="line-modified">6895   z_lmg(Z_R1, Z_R5, frame::z_abi_160_size, Z_SP);</span>
6896   pop_frame();
6897   restore_return_pc();
6898 
6899   BLOCK_COMMENT(&quot;} verify_oop &quot;);
6900 }
6901 
6902 const char* MacroAssembler::stop_types[] = {
6903   &quot;stop&quot;,
6904   &quot;untested&quot;,
6905   &quot;unimplemented&quot;,
6906   &quot;shouldnotreachhere&quot;
6907 };
6908 
6909 static void stop_on_request(const char* tp, const char* msg) {
6910   tty-&gt;print(&quot;Z assembly code requires stop: (%s) %s\n&quot;, tp, msg);
6911   guarantee(false, &quot;Z assembly code requires stop: %s&quot;, msg);
6912 }
6913 
6914 void MacroAssembler::stop(int type, const char* msg, int id) {
6915   BLOCK_COMMENT(err_msg(&quot;stop: %s {&quot;, msg));
6916 
6917   // Setup arguments.
6918   load_const(Z_ARG1, (void*) stop_types[type%stop_end]);
6919   load_const(Z_ARG2, (void*) msg);
6920   get_PC(Z_R14);     // Following code pushes a frame without entering a new function. Use current pc as return address.
6921   save_return_pc();  // Saves return pc Z_R14.
6922   push_frame_abi160(0);
6923   call_VM_leaf(CAST_FROM_FN_PTR(address, stop_on_request), Z_ARG1, Z_ARG2);
6924   // The plain disassembler does not recognize illtrap. It instead displays
6925   // a 32-bit value. Issueing two illtraps assures the disassembler finds
6926   // the proper beginning of the next instruction.
6927   z_illtrap(); // Illegal instruction.
6928   z_illtrap(); // Illegal instruction.
6929 
6930   BLOCK_COMMENT(&quot; } stop&quot;);
6931 }
6932 
6933 // Special version of stop() for code size reduction.
6934 // Reuses the previously generated call sequence, if any.
6935 // Generates the call sequence on its own, if necessary.
6936 // Note: This code will work only in non-relocatable code!
6937 //       The relative address of the data elements (arg1, arg2) must not change.
6938 //       The reentry point must not move relative to it&#39;s users. This prerequisite
6939 //       should be given for &quot;hand-written&quot; code, if all chain calls are in the same code blob.
6940 //       Generated code must not undergo any transformation, e.g. ShortenBranches, to be safe.
6941 address MacroAssembler::stop_chain(address reentry, int type, const char* msg, int id, bool allow_relocation) {
6942   BLOCK_COMMENT(err_msg(&quot;stop_chain(%s,%s): %s {&quot;, reentry==NULL?&quot;init&quot;:&quot;cont&quot;, allow_relocation?&quot;reloc &quot;:&quot;static&quot;, msg));
6943 
6944   // Setup arguments.
6945   if (allow_relocation) {
6946     // Relocatable version (for comparison purposes). Remove after some time.
6947     load_const(Z_ARG1, (void*) stop_types[type%stop_end]);
6948     load_const(Z_ARG2, (void*) msg);
6949   } else {
6950     load_absolute_address(Z_ARG1, (address)stop_types[type%stop_end]);
6951     load_absolute_address(Z_ARG2, (address)msg);
6952   }
6953   if ((reentry != NULL) &amp;&amp; RelAddr::is_in_range_of_RelAddr16(reentry, pc())) {
6954     BLOCK_COMMENT(&quot;branch to reentry point:&quot;);
6955     z_brc(bcondAlways, reentry);
6956   } else {
6957     BLOCK_COMMENT(&quot;reentry point:&quot;);
6958     reentry = pc();      // Re-entry point for subsequent stop calls.
6959     save_return_pc();    // Saves return pc Z_R14.
6960     push_frame_abi160(0);
6961     if (allow_relocation) {
6962       reentry = NULL;    // Prevent reentry if code relocation is allowed.
6963       call_VM_leaf(CAST_FROM_FN_PTR(address, stop_on_request), Z_ARG1, Z_ARG2);
6964     } else {
6965       call_VM_leaf_static(CAST_FROM_FN_PTR(address, stop_on_request), Z_ARG1, Z_ARG2);
6966     }
6967     z_illtrap(); // Illegal instruction as emergency stop, should the above call return.
6968   }
6969   BLOCK_COMMENT(&quot; } stop_chain&quot;);
6970 
6971   return reentry;
6972 }
6973 
6974 // Special version of stop() for code size reduction.
6975 // Assumes constant relative addresses for data and runtime call.
6976 void MacroAssembler::stop_static(int type, const char* msg, int id) {
6977   stop_chain(NULL, type, msg, id, false);
6978 }
6979 
6980 void MacroAssembler::stop_subroutine() {
6981   unimplemented(&quot;stop_subroutine&quot;, 710);
6982 }
6983 
6984 // Prints msg to stdout from within generated code..
6985 void MacroAssembler::warn(const char* msg) {
6986   RegisterSaver::save_live_registers(this, RegisterSaver::all_registers, Z_R14);
6987   load_absolute_address(Z_R1, (address) warning);
6988   load_absolute_address(Z_ARG1, (address) msg);
6989   (void) call(Z_R1);
6990   RegisterSaver::restore_live_registers(this, RegisterSaver::all_registers);
6991 }
6992 
6993 #ifndef PRODUCT
6994 
6995 // Write pattern 0x0101010101010101 in region [low-before, high+after].
6996 void MacroAssembler::zap_from_to(Register low, Register high, Register val, Register addr, int before, int after) {
6997   if (!ZapEmptyStackFields) return;
6998   BLOCK_COMMENT(&quot;zap memory region {&quot;);
6999   load_const_optimized(val, 0x0101010101010101);
7000   int size = before + after;
7001   if (low == high &amp;&amp; size &lt; 5 &amp;&amp; size &gt; 0) {
7002     int offset = -before*BytesPerWord;
7003     for (int i = 0; i &lt; size; ++i) {
7004       z_stg(val, Address(low, offset));
7005       offset +=(1*BytesPerWord);
7006     }
7007   } else {
7008     add2reg(addr, -before*BytesPerWord, low);
7009     if (after) {
7010 #ifdef ASSERT
7011       jlong check = after * BytesPerWord;
7012       assert(Immediate::is_simm32(check) &amp;&amp; Immediate::is_simm32(-check), &quot;value not encodable !&quot;);
7013 #endif
7014       add2reg(high, after * BytesPerWord);
7015     }
7016     NearLabel loop;
7017     bind(loop);
7018     z_stg(val, Address(addr));
7019     add2reg(addr, 8);
7020     compare64_and_branch(addr, high, bcondNotHigh, loop);
7021     if (after) {
7022       add2reg(high, -after * BytesPerWord);
7023     }
7024   }
7025   BLOCK_COMMENT(&quot;} zap memory region&quot;);
7026 }
7027 #endif // !PRODUCT
7028 
7029 SkipIfEqual::SkipIfEqual(MacroAssembler* masm, const bool* flag_addr, bool value, Register _rscratch) {
7030   _masm = masm;
7031   _masm-&gt;load_absolute_address(_rscratch, (address)flag_addr);
7032   _masm-&gt;load_and_test_int(_rscratch, Address(_rscratch));
7033   if (value) {
7034     _masm-&gt;z_brne(_label); // Skip if true, i.e. != 0.
7035   } else {
7036     _masm-&gt;z_bre(_label);  // Skip if false, i.e. == 0.
7037   }
7038 }
7039 
7040 SkipIfEqual::~SkipIfEqual() {
7041   _masm-&gt;bind(_label);
7042 }
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>
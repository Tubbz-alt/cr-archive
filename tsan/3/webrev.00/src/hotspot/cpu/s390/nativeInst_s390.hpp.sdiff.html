<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/nativeInst_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="nativeInst_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="register_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/nativeInst_s390.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
473 // reference location is moved. That happens when executable code is relocated.
474 
475 class NativeMovConstReg: public NativeInstruction {
476  public:
477 
478   enum z_specific_constants {
479     instruction_size = 10 // Used in shared code for calls with reloc_info.
480   };
481 
482   // address instruction_address() const { return addr_at(0); }
483 
484   // The current instruction might be located at an offset.
485   address next_instruction_address(int offset = 0) const;
486 
487   // (The [set_]data accessor respects oop_type relocs also.)
488   intptr_t data() const;
489 
490   // Patch data in code stream.
491   address set_data_plain(intptr_t x, CodeBlob *code);
492   // Patch data in code stream and oop pool if necessary.
<span class="line-modified">493   void set_data(intptr_t x);</span>
494 
495   // Patch narrow oop constant in code stream.
496   void set_narrow_oop(intptr_t data);
497   void set_narrow_klass(intptr_t data);
<span class="line-modified">498   void set_pcrel_addr(intptr_t addr, CompiledMethod *nm = NULL, bool copy_back_to_oop_pool=false);</span>
<span class="line-modified">499   void set_pcrel_data(intptr_t data, CompiledMethod *nm = NULL, bool copy_back_to_oop_pool=false);</span>
500 
501   void verify();
502 
503   // unit test stuff
504   static void test();
505 
506   // Creation.
507   friend NativeMovConstReg* nativeMovConstReg_at(address address) {
508     NativeMovConstReg* test = (NativeMovConstReg*)address;
509     #ifdef ASSERT
510       test-&gt;verify();
511     #endif
512     return test;
513   }
514 };
515 
516 
517 #ifdef COMPILER1
518 //---------------------------------
519 //  N a t i v e M o v R e g M e m
520 //---------------------------------
521 
522 // Interface to manipulate a code sequence that performs a memory access (load/store).
523 // The code is the patchable version of memory accesses generated by
524 // LIR_Assembler::reg2mem() and LIR_Assembler::mem2reg().
525 //
526 // Loading the offset for the mem access is target of the manipulation.
527 //
528 // The instruction sequence looks like this:
529 //   iihf        %r1,$bits1              ; load offset for mem access
530 //   iilf        %r1,$bits2
531 //   [compress oop]                      ; optional, load only
532 //   load/store  %r2,0(%r1,%r2)          ; memory access
533 
534 class NativeMovRegMem;
535 inline NativeMovRegMem* nativeMovRegMem_at (address address);
536 class NativeMovRegMem: public NativeInstruction {
537  public:






538   intptr_t offset() const {
539     return nativeMovConstReg_at(addr_at(0))-&gt;data();
540   }
541   void set_offset(intptr_t x) {
542     nativeMovConstReg_at(addr_at(0))-&gt;set_data(x);
543   }
544   void add_offset_in_bytes(intptr_t radd_offset) {
545     set_offset(offset() + radd_offset);
546   }
547   void verify();
548 
549  private:
550   friend inline NativeMovRegMem* nativeMovRegMem_at(address address) {
551     NativeMovRegMem* test = (NativeMovRegMem*)address;
552     #ifdef ASSERT
553       test-&gt;verify();
554     #endif
555     return test;
556   }
557 };
</pre>
</td>
<td>
<hr />
<pre>
473 // reference location is moved. That happens when executable code is relocated.
474 
475 class NativeMovConstReg: public NativeInstruction {
476  public:
477 
478   enum z_specific_constants {
479     instruction_size = 10 // Used in shared code for calls with reloc_info.
480   };
481 
482   // address instruction_address() const { return addr_at(0); }
483 
484   // The current instruction might be located at an offset.
485   address next_instruction_address(int offset = 0) const;
486 
487   // (The [set_]data accessor respects oop_type relocs also.)
488   intptr_t data() const;
489 
490   // Patch data in code stream.
491   address set_data_plain(intptr_t x, CodeBlob *code);
492   // Patch data in code stream and oop pool if necessary.
<span class="line-modified">493   void set_data(intptr_t x, relocInfo::relocType expected_type = relocInfo::none);</span>
494 
495   // Patch narrow oop constant in code stream.
496   void set_narrow_oop(intptr_t data);
497   void set_narrow_klass(intptr_t data);
<span class="line-modified">498   void set_pcrel_addr(intptr_t addr, CompiledMethod *nm = NULL);</span>
<span class="line-modified">499   void set_pcrel_data(intptr_t data, CompiledMethod *nm = NULL);</span>
500 
501   void verify();
502 
503   // unit test stuff
504   static void test();
505 
506   // Creation.
507   friend NativeMovConstReg* nativeMovConstReg_at(address address) {
508     NativeMovConstReg* test = (NativeMovConstReg*)address;
509     #ifdef ASSERT
510       test-&gt;verify();
511     #endif
512     return test;
513   }
514 };
515 
516 
517 #ifdef COMPILER1
518 //---------------------------------
519 //  N a t i v e M o v R e g M e m
520 //---------------------------------
521 
522 // Interface to manipulate a code sequence that performs a memory access (load/store).
523 // The code is the patchable version of memory accesses generated by
524 // LIR_Assembler::reg2mem() and LIR_Assembler::mem2reg().
525 //
526 // Loading the offset for the mem access is target of the manipulation.
527 //
528 // The instruction sequence looks like this:
529 //   iihf        %r1,$bits1              ; load offset for mem access
530 //   iilf        %r1,$bits2
531 //   [compress oop]                      ; optional, load only
532 //   load/store  %r2,0(%r1,%r2)          ; memory access
533 
534 class NativeMovRegMem;
535 inline NativeMovRegMem* nativeMovRegMem_at (address address);
536 class NativeMovRegMem: public NativeInstruction {
537  public:
<span class="line-added">538   enum z_specific_constants {</span>
<span class="line-added">539     instruction_size = 12 // load_const used with access_field_id</span>
<span class="line-added">540   };</span>
<span class="line-added">541 </span>
<span class="line-added">542   int num_bytes_to_end_of_patch() const { return instruction_size; }</span>
<span class="line-added">543 </span>
544   intptr_t offset() const {
545     return nativeMovConstReg_at(addr_at(0))-&gt;data();
546   }
547   void set_offset(intptr_t x) {
548     nativeMovConstReg_at(addr_at(0))-&gt;set_data(x);
549   }
550   void add_offset_in_bytes(intptr_t radd_offset) {
551     set_offset(offset() + radd_offset);
552   }
553   void verify();
554 
555  private:
556   friend inline NativeMovRegMem* nativeMovRegMem_at(address address) {
557     NativeMovRegMem* test = (NativeMovRegMem*)address;
558     #ifdef ASSERT
559       test-&gt;verify();
560     #endif
561     return test;
562   }
563 };
</pre>
</td>
</tr>
</table>
<center><a href="nativeInst_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="register_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
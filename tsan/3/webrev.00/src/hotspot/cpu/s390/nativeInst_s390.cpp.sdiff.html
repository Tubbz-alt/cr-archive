<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/nativeInst_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodHandles_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/nativeInst_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
458     // before. The value of the src argument is not related to the
459     // branch target.
460     next_address = next_instruction_address();
461   }
462 
463   else {
464     tty-&gt;print_cr(&quot;WARNING: detected an unrecognized code pattern at loc = %p -&gt; 0x%8.8x %8.8x&quot;,
465                   loc, *((unsigned int*)loc), *((unsigned int*)(loc+4)));
466     next_address = next_instruction_address(); // Failure should be handled in next_instruction_address().
467 #ifdef LUCY_DBG
468     VM_Version::z_SIGSEGV();
469 #endif
470   }
471 
472   return next_address;
473 }
474 
475 // Divided up in set_data_plain() which patches the instruction in the
476 // code stream and set_data() which additionally patches the oop pool
477 // if necessary.
<span class="line-modified">478 void NativeMovConstReg::set_data(intptr_t src) {</span>
479   // Also store the value into an oop_Relocation cell, if any.
480   CodeBlob *cb = CodeCache::find_blob(instruction_address());
<span class="line-modified">481   address next_address = set_data_plain(src, cb);</span>
<span class="line-modified">482 </span>
<span class="line-modified">483   relocInfo::update_oop_pool(instruction_address(), next_address, (address)src, cb);</span>






























484 }
485 
486 void NativeMovConstReg::set_narrow_oop(intptr_t data) {
487   const address start = addr_at(0);
488   int           range = 0;
489   if (MacroAssembler::is_load_narrow_oop(start)) {
490     range = MacroAssembler::patch_load_narrow_oop(start, cast_to_oop &lt;intptr_t&gt; (data));
491   } else if (MacroAssembler::is_compare_immediate_narrow_oop(start)) {
492     range = MacroAssembler::patch_compare_immediate_narrow_oop(start, cast_to_oop &lt;intptr_t&gt;(data));
493   } else {
494     fatal(&quot;this is not a `NativeMovConstReg::narrow_oop&#39; site&quot;);
495   }
496   ICache::invalidate_range(start, range);
497 }
498 
499 // Compressed klass ptrs. patch narrow klass constant.
500 void NativeMovConstReg::set_narrow_klass(intptr_t data) {
501   const address start = addr_at(0);
502   int           range = 0;
503   if (MacroAssembler::is_load_narrow_klass(start)) {
504     range = MacroAssembler::patch_load_narrow_klass(start, (Klass*)data);
505   } else if (MacroAssembler::is_compare_immediate_narrow_klass(start)) {
506     range = MacroAssembler::patch_compare_immediate_narrow_klass(start, (Klass*)data);
507   } else {
508     fatal(&quot;this is not a `NativeMovConstReg::narrow_klass&#39; site&quot;);
509   }
510   ICache::invalidate_range(start, range);
511 }
512 
<span class="line-modified">513 void NativeMovConstReg::set_pcrel_addr(intptr_t newTarget, CompiledMethod *passed_nm /* = NULL */, bool copy_back_to_oop_pool) {</span>
514   address next_address;
515   address loc = addr_at(0);
516 
517   if (MacroAssembler::is_load_addr_pcrel(loc)) {
518     address oldTarget = MacroAssembler::get_target_addr_pcrel(loc);
519     MacroAssembler::patch_target_addr_pcrel(loc, (address)newTarget);
520 
521     ICache::invalidate_range(loc, MacroAssembler::load_addr_pcrel_size());
522     next_address = loc + MacroAssembler::load_addr_pcrel_size();
523   } else if (MacroAssembler::is_load_const_from_toc_pcrelative(loc) ) {  // Load constant from TOC.
524     address oldTarget = MacroAssembler::get_target_addr_pcrel(loc);
525     MacroAssembler::patch_target_addr_pcrel(loc, (address)newTarget);
526 
527     ICache::invalidate_range(loc, MacroAssembler::load_const_from_toc_size());
528     next_address = loc + MacroAssembler::load_const_from_toc_size();
529   } else if (MacroAssembler::is_call_far_patchable_pcrelative_at(loc)) {
530     assert(ShortenBranches, &quot;Wait a minute! A pc-relative call w/o ShortenBranches?&quot;);
531     next_address = next_instruction_address();
532   } else {
533     assert(false, &quot;Not a NativeMovConstReg site for set_pcrel_addr&quot;);
534     next_address = next_instruction_address(); // Failure should be handled in next_instruction_address().
535   }
<span class="line-removed">536 </span>
<span class="line-removed">537   if (copy_back_to_oop_pool) {</span>
<span class="line-removed">538     if (relocInfo::update_oop_pool(instruction_address(), next_address, (address)newTarget, NULL)) {</span>
<span class="line-removed">539       ((NativeMovConstReg*)instruction_address())-&gt;dump(64, &quot;NativeMovConstReg::set_pcrel_addr(): found oop reloc for pcrel_addr&quot;);</span>
<span class="line-removed">540 #ifdef LUCY_DBG</span>
<span class="line-removed">541       VM_Version::z_SIGSEGV();</span>
<span class="line-removed">542 #else</span>
<span class="line-removed">543       assert(false, &quot;Ooooops: found oop reloc for pcrel_addr&quot;);</span>
<span class="line-removed">544 #endif</span>
<span class="line-removed">545     }</span>
<span class="line-removed">546   }</span>
547 }
548 
<span class="line-modified">549 void NativeMovConstReg::set_pcrel_data(intptr_t newData, CompiledMethod *passed_nm /* = NULL */, bool copy_back_to_oop_pool) {</span>
550   address  next_address;
551   address  loc = addr_at(0);
552 
553   if (MacroAssembler::is_load_const_from_toc(loc) ) {  // Load constant from TOC.
554     // Offset is +/- 2**32 -&gt; use long.
555     long     offset  = MacroAssembler::get_load_const_from_toc_offset(loc);
556     address  target  = MacroAssembler::get_target_addr_pcrel(loc);
557     intptr_t oldData = *(intptr_t*)target;
558     if (oldData != newData) { // Update only if data changes. Prevents cache invalidation.
559       *(intptr_t *)(target) = newData;
560     }
561 
562     // ICache::invalidate_range(target, sizeof(unsigned long));  // No ICache invalidate for CP data.
563     next_address = loc + MacroAssembler::load_const_from_toc_size();
564   } else if (MacroAssembler::is_call_far_pcrelative(loc)) {
565     ((NativeMovConstReg*)loc)-&gt;dump(64, &quot;NativeMovConstReg::set_pcrel_data() has a problem: setting data for a pc-relative call?&quot;);
566 #ifdef LUCY_DBG
567     VM_Version::z_SIGSEGV();
568 #else
569     assert(false, &quot;Ooooops: setting data for a pc-relative call&quot;);
570 #endif
571     next_address = next_instruction_address();
572   } else {
573     assert(false, &quot;Not a NativeMovConstReg site for set_pcrel_data&quot;);
574     next_address = next_instruction_address(); // Failure should be handled in next_instruction_address().
575   }
<span class="line-removed">576 </span>
<span class="line-removed">577   if (copy_back_to_oop_pool) {</span>
<span class="line-removed">578     if (relocInfo::update_oop_pool(instruction_address(), next_address, (address)newData, NULL)) {</span>
<span class="line-removed">579       ((NativeMovConstReg*)instruction_address())-&gt;dump(64, &quot;NativeMovConstReg::set_pcrel_data(): found oop reloc for pcrel_data&quot;);</span>
<span class="line-removed">580 #ifdef LUCY_DBG</span>
<span class="line-removed">581       VM_Version::z_SIGSEGV();</span>
<span class="line-removed">582 #else</span>
<span class="line-removed">583       assert(false, &quot;Ooooops: found oop reloc for pcrel_data&quot;);</span>
<span class="line-removed">584 #endif</span>
<span class="line-removed">585     }</span>
<span class="line-removed">586   }</span>
587 }
588 
589 #ifdef COMPILER1
590 //--------------------------------
591 //  N a t i v e M o v R e g M e m
592 //--------------------------------
593 
594 void NativeMovRegMem::verify() {
595   address l1 = addr_at(0);
596   address l2 = addr_at(MacroAssembler::load_const_size());
597 
598   if (!MacroAssembler::is_load_const(l1)) {
599     tty-&gt;cr();
600     tty-&gt;print_cr(&quot;NativeMovRegMem::verify(): verifying addr &quot; PTR_FORMAT, p2i(l1));
601     tty-&gt;cr();
602     ((NativeMovRegMem*)l1)-&gt;dump(64, &quot;NativeMovConstReg::verify()&quot;);
603     fatal(&quot;this is not a `NativeMovRegMem&#39; site&quot;);
604   }
605 
606   unsigned long inst1;
</pre>
</td>
<td>
<hr />
<pre>
458     // before. The value of the src argument is not related to the
459     // branch target.
460     next_address = next_instruction_address();
461   }
462 
463   else {
464     tty-&gt;print_cr(&quot;WARNING: detected an unrecognized code pattern at loc = %p -&gt; 0x%8.8x %8.8x&quot;,
465                   loc, *((unsigned int*)loc), *((unsigned int*)(loc+4)));
466     next_address = next_instruction_address(); // Failure should be handled in next_instruction_address().
467 #ifdef LUCY_DBG
468     VM_Version::z_SIGSEGV();
469 #endif
470   }
471 
472   return next_address;
473 }
474 
475 // Divided up in set_data_plain() which patches the instruction in the
476 // code stream and set_data() which additionally patches the oop pool
477 // if necessary.
<span class="line-modified">478 void NativeMovConstReg::set_data(intptr_t data, relocInfo::relocType expected_type) {</span>
479   // Also store the value into an oop_Relocation cell, if any.
480   CodeBlob *cb = CodeCache::find_blob(instruction_address());
<span class="line-modified">481   address next_address = set_data_plain(data, cb);</span>
<span class="line-modified">482 </span>
<span class="line-modified">483   // &#39;RelocIterator&#39; requires an nmethod</span>
<span class="line-added">484   nmethod* nm = cb ? cb-&gt;as_nmethod_or_null() : NULL;</span>
<span class="line-added">485   if (nm != NULL) {</span>
<span class="line-added">486     RelocIterator iter(nm, instruction_address(), next_address);</span>
<span class="line-added">487     oop* oop_addr = NULL;</span>
<span class="line-added">488     Metadata** metadata_addr = NULL;</span>
<span class="line-added">489     while (iter.next()) {</span>
<span class="line-added">490       if (iter.type() == relocInfo::oop_type) {</span>
<span class="line-added">491         oop_Relocation *r = iter.oop_reloc();</span>
<span class="line-added">492         if (oop_addr == NULL) {</span>
<span class="line-added">493           oop_addr = r-&gt;oop_addr();</span>
<span class="line-added">494           *oop_addr = cast_to_oop(data);</span>
<span class="line-added">495         } else {</span>
<span class="line-added">496           assert(oop_addr == r-&gt;oop_addr(), &quot;must be only one set-oop here&quot;);</span>
<span class="line-added">497         }</span>
<span class="line-added">498       }</span>
<span class="line-added">499       if (iter.type() == relocInfo::metadata_type) {</span>
<span class="line-added">500         metadata_Relocation *r = iter.metadata_reloc();</span>
<span class="line-added">501         if (metadata_addr == NULL) {</span>
<span class="line-added">502           metadata_addr = r-&gt;metadata_addr();</span>
<span class="line-added">503           *metadata_addr = (Metadata*)data;</span>
<span class="line-added">504         } else {</span>
<span class="line-added">505           assert(metadata_addr == r-&gt;metadata_addr(), &quot;must be only one set-metadata here&quot;);</span>
<span class="line-added">506         }</span>
<span class="line-added">507       }</span>
<span class="line-added">508     }</span>
<span class="line-added">509     assert(expected_type == relocInfo::none ||</span>
<span class="line-added">510           (expected_type == relocInfo::metadata_type &amp;&amp; metadata_addr != NULL) ||</span>
<span class="line-added">511           (expected_type == relocInfo::oop_type &amp;&amp; oop_addr != NULL),</span>
<span class="line-added">512           &quot;%s relocation not found&quot;, expected_type == relocInfo::oop_type ? &quot;oop&quot; : &quot;metadata&quot;);</span>
<span class="line-added">513   }</span>
514 }
515 
516 void NativeMovConstReg::set_narrow_oop(intptr_t data) {
517   const address start = addr_at(0);
518   int           range = 0;
519   if (MacroAssembler::is_load_narrow_oop(start)) {
520     range = MacroAssembler::patch_load_narrow_oop(start, cast_to_oop &lt;intptr_t&gt; (data));
521   } else if (MacroAssembler::is_compare_immediate_narrow_oop(start)) {
522     range = MacroAssembler::patch_compare_immediate_narrow_oop(start, cast_to_oop &lt;intptr_t&gt;(data));
523   } else {
524     fatal(&quot;this is not a `NativeMovConstReg::narrow_oop&#39; site&quot;);
525   }
526   ICache::invalidate_range(start, range);
527 }
528 
529 // Compressed klass ptrs. patch narrow klass constant.
530 void NativeMovConstReg::set_narrow_klass(intptr_t data) {
531   const address start = addr_at(0);
532   int           range = 0;
533   if (MacroAssembler::is_load_narrow_klass(start)) {
534     range = MacroAssembler::patch_load_narrow_klass(start, (Klass*)data);
535   } else if (MacroAssembler::is_compare_immediate_narrow_klass(start)) {
536     range = MacroAssembler::patch_compare_immediate_narrow_klass(start, (Klass*)data);
537   } else {
538     fatal(&quot;this is not a `NativeMovConstReg::narrow_klass&#39; site&quot;);
539   }
540   ICache::invalidate_range(start, range);
541 }
542 
<span class="line-modified">543 void NativeMovConstReg::set_pcrel_addr(intptr_t newTarget, CompiledMethod *passed_nm /* = NULL */) {</span>
544   address next_address;
545   address loc = addr_at(0);
546 
547   if (MacroAssembler::is_load_addr_pcrel(loc)) {
548     address oldTarget = MacroAssembler::get_target_addr_pcrel(loc);
549     MacroAssembler::patch_target_addr_pcrel(loc, (address)newTarget);
550 
551     ICache::invalidate_range(loc, MacroAssembler::load_addr_pcrel_size());
552     next_address = loc + MacroAssembler::load_addr_pcrel_size();
553   } else if (MacroAssembler::is_load_const_from_toc_pcrelative(loc) ) {  // Load constant from TOC.
554     address oldTarget = MacroAssembler::get_target_addr_pcrel(loc);
555     MacroAssembler::patch_target_addr_pcrel(loc, (address)newTarget);
556 
557     ICache::invalidate_range(loc, MacroAssembler::load_const_from_toc_size());
558     next_address = loc + MacroAssembler::load_const_from_toc_size();
559   } else if (MacroAssembler::is_call_far_patchable_pcrelative_at(loc)) {
560     assert(ShortenBranches, &quot;Wait a minute! A pc-relative call w/o ShortenBranches?&quot;);
561     next_address = next_instruction_address();
562   } else {
563     assert(false, &quot;Not a NativeMovConstReg site for set_pcrel_addr&quot;);
564     next_address = next_instruction_address(); // Failure should be handled in next_instruction_address().
565   }











566 }
567 
<span class="line-modified">568 void NativeMovConstReg::set_pcrel_data(intptr_t newData, CompiledMethod *passed_nm /* = NULL */) {</span>
569   address  next_address;
570   address  loc = addr_at(0);
571 
572   if (MacroAssembler::is_load_const_from_toc(loc) ) {  // Load constant from TOC.
573     // Offset is +/- 2**32 -&gt; use long.
574     long     offset  = MacroAssembler::get_load_const_from_toc_offset(loc);
575     address  target  = MacroAssembler::get_target_addr_pcrel(loc);
576     intptr_t oldData = *(intptr_t*)target;
577     if (oldData != newData) { // Update only if data changes. Prevents cache invalidation.
578       *(intptr_t *)(target) = newData;
579     }
580 
581     // ICache::invalidate_range(target, sizeof(unsigned long));  // No ICache invalidate for CP data.
582     next_address = loc + MacroAssembler::load_const_from_toc_size();
583   } else if (MacroAssembler::is_call_far_pcrelative(loc)) {
584     ((NativeMovConstReg*)loc)-&gt;dump(64, &quot;NativeMovConstReg::set_pcrel_data() has a problem: setting data for a pc-relative call?&quot;);
585 #ifdef LUCY_DBG
586     VM_Version::z_SIGSEGV();
587 #else
588     assert(false, &quot;Ooooops: setting data for a pc-relative call&quot;);
589 #endif
590     next_address = next_instruction_address();
591   } else {
592     assert(false, &quot;Not a NativeMovConstReg site for set_pcrel_data&quot;);
593     next_address = next_instruction_address(); // Failure should be handled in next_instruction_address().
594   }











595 }
596 
597 #ifdef COMPILER1
598 //--------------------------------
599 //  N a t i v e M o v R e g M e m
600 //--------------------------------
601 
602 void NativeMovRegMem::verify() {
603   address l1 = addr_at(0);
604   address l2 = addr_at(MacroAssembler::load_const_size());
605 
606   if (!MacroAssembler::is_load_const(l1)) {
607     tty-&gt;cr();
608     tty-&gt;print_cr(&quot;NativeMovRegMem::verify(): verifying addr &quot; PTR_FORMAT, p2i(l1));
609     tty-&gt;cr();
610     ((NativeMovRegMem*)l1)-&gt;dump(64, &quot;NativeMovConstReg::verify()&quot;);
611     fatal(&quot;this is not a `NativeMovRegMem&#39; site&quot;);
612   }
613 
614   unsigned long inst1;
</pre>
</td>
</tr>
</table>
<center><a href="methodHandles_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="nativeInst_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
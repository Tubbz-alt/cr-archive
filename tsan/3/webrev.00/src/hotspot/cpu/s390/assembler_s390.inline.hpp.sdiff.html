<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/assembler_s390.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_CodeStubs_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/assembler_s390.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1327 inline void Assembler::z_brne(  Label&amp; L) { z_brc(bcondNotEqual, target(L)); }
1328 inline void Assembler::z_brz(   Label&amp; L) { z_brc(bcondZero, target(L)); }
1329 inline void Assembler::z_brnz(  Label&amp; L) { z_brc(bcondNotZero, target(L)); }
1330 inline void Assembler::z_braz(  Label&amp; L) { z_brc(bcondAllZero, target(L)); }
1331 inline void Assembler::z_brnaz( Label&amp; L) { z_brc(bcondNotAllZero, target(L)); }
1332 inline void Assembler::z_brnp(  Label&amp; L) { z_brc( bcondNotPositive, target( L)); }
1333 inline void Assembler::z_btrue( Label&amp; L) { z_brc(bcondAllOne, target(L)); }
1334 inline void Assembler::z_bfalse(Label&amp; L) { z_brc(bcondAllZero, target(L)); }
1335 inline void Assembler::z_bvat(  Label&amp; L) { z_brc(bcondVAlltrue, target(L)); }
1336 inline void Assembler::z_bvnt(  Label&amp; L) { z_brc((Assembler::branch_condition)(bcondVMixed | bcondVAllfalse), target(L)); }
1337 inline void Assembler::z_bvmix( Label&amp; L) { z_brc(bcondVMixed, target(L)); }
1338 inline void Assembler::z_bvaf(  Label&amp; L) { z_brc(bcondVAllfalse, target(L)); }
1339 inline void Assembler::z_bvnf(  Label&amp; L) { z_brc((Assembler::branch_condition)(bcondVMixed | bcondVAlltrue), target(L)); }
1340 inline void Assembler::z_brno(  Label&amp; L) { z_brc(bcondNotOrdered, target(L)); }
1341 inline void Assembler::z_brc( branch_condition m, Label&amp; L) { z_brc(m, target(L)); }
1342 inline void Assembler::z_brcl(branch_condition m, Label&amp; L) { z_brcl(m, target(L)); }
1343 
1344 
1345 // Instruction must start at passed address.
1346 // Extra check for illtraps with ID.
<span class="line-modified">1347 inline int Assembler::instr_len(unsigned char *instr) {</span>
1348   switch ((*instr) &gt;&gt; 6) {
1349     case 0: return 2;
1350     case 1: // fallthru
1351     case 2: return 4;
1352     case 3: return 6;
1353     default:
1354       // Control can&#39;t reach here.
1355       // The switch expression examines just the leftmost two bytes
1356       // of the main opcode. So the range of values is just [0..3].
1357       // Having a default clause makes the compiler happy.
1358       ShouldNotReachHere();
1359       return 0;
1360   }
1361 }
1362 
1363 // Move instr at pc right-justified into passed long int.
1364 // Return instr len in bytes as function result.
1365 // Note: 2-byte instr don&#39;t really need to be accessed unsigned
1366 // because leftmost two bits are always zero. We use
1367 // unsigned here for reasons of uniformity.
</pre>
</td>
<td>
<hr />
<pre>
1327 inline void Assembler::z_brne(  Label&amp; L) { z_brc(bcondNotEqual, target(L)); }
1328 inline void Assembler::z_brz(   Label&amp; L) { z_brc(bcondZero, target(L)); }
1329 inline void Assembler::z_brnz(  Label&amp; L) { z_brc(bcondNotZero, target(L)); }
1330 inline void Assembler::z_braz(  Label&amp; L) { z_brc(bcondAllZero, target(L)); }
1331 inline void Assembler::z_brnaz( Label&amp; L) { z_brc(bcondNotAllZero, target(L)); }
1332 inline void Assembler::z_brnp(  Label&amp; L) { z_brc( bcondNotPositive, target( L)); }
1333 inline void Assembler::z_btrue( Label&amp; L) { z_brc(bcondAllOne, target(L)); }
1334 inline void Assembler::z_bfalse(Label&amp; L) { z_brc(bcondAllZero, target(L)); }
1335 inline void Assembler::z_bvat(  Label&amp; L) { z_brc(bcondVAlltrue, target(L)); }
1336 inline void Assembler::z_bvnt(  Label&amp; L) { z_brc((Assembler::branch_condition)(bcondVMixed | bcondVAllfalse), target(L)); }
1337 inline void Assembler::z_bvmix( Label&amp; L) { z_brc(bcondVMixed, target(L)); }
1338 inline void Assembler::z_bvaf(  Label&amp; L) { z_brc(bcondVAllfalse, target(L)); }
1339 inline void Assembler::z_bvnf(  Label&amp; L) { z_brc((Assembler::branch_condition)(bcondVMixed | bcondVAlltrue), target(L)); }
1340 inline void Assembler::z_brno(  Label&amp; L) { z_brc(bcondNotOrdered, target(L)); }
1341 inline void Assembler::z_brc( branch_condition m, Label&amp; L) { z_brc(m, target(L)); }
1342 inline void Assembler::z_brcl(branch_condition m, Label&amp; L) { z_brcl(m, target(L)); }
1343 
1344 
1345 // Instruction must start at passed address.
1346 // Extra check for illtraps with ID.
<span class="line-modified">1347 inline unsigned int Assembler::instr_len(unsigned char *instr) {</span>
1348   switch ((*instr) &gt;&gt; 6) {
1349     case 0: return 2;
1350     case 1: // fallthru
1351     case 2: return 4;
1352     case 3: return 6;
1353     default:
1354       // Control can&#39;t reach here.
1355       // The switch expression examines just the leftmost two bytes
1356       // of the main opcode. So the range of values is just [0..3].
1357       // Having a default clause makes the compiler happy.
1358       ShouldNotReachHere();
1359       return 0;
1360   }
1361 }
1362 
1363 // Move instr at pc right-justified into passed long int.
1364 // Return instr len in bytes as function result.
1365 // Note: 2-byte instr don&#39;t really need to be accessed unsigned
1366 // because leftmost two bits are always zero. We use
1367 // unsigned here for reasons of uniformity.
</pre>
</td>
</tr>
</table>
<center><a href="assembler_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_CodeStubs_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
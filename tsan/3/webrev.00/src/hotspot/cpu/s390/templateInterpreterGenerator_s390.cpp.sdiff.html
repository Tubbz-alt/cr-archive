<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/templateInterpreterGenerator_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubGenerator_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/templateInterpreterGenerator_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2016, 2018, SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
 804 void TemplateInterpreterGenerator::generate_counter_overflow(Label&amp; do_continue) {
 805   // InterpreterRuntime::frequency_counter_overflow takes two
 806   // arguments, the first (thread) is passed by call_VM, the second
 807   // indicates if the counter overflow occurs at a backwards branch
 808   // (NULL bcp). We pass zero for it. The call returns the address
 809   // of the verified entry point for the method or NULL if the
 810   // compilation did not complete (either went background or bailed
 811   // out).
 812   __ clear_reg(Z_ARG2);
 813   __ call_VM(noreg,
 814              CAST_FROM_FN_PTR(address, InterpreterRuntime::frequency_counter_overflow),
 815              Z_ARG2);
 816   __ z_bru(do_continue);
 817 }
 818 
 819 void TemplateInterpreterGenerator::generate_stack_overflow_check(Register frame_size, Register tmp1) {
 820   Register tmp2 = Z_R1_scratch;
 821   const int page_size = os::vm_page_size();
 822   NearLabel after_frame_check;
 823 
<span class="line-modified"> 824   BLOCK_COMMENT(&quot;counter_overflow {&quot;);</span>
 825 
 826   assert_different_registers(frame_size, tmp1);
 827 
 828   // Stack banging is sufficient overflow check if frame_size &lt; page_size.
 829   if (Immediate::is_uimm(page_size, 15)) {
 830     __ z_chi(frame_size, page_size);
 831     __ z_brl(after_frame_check);
 832   } else {
 833     __ load_const_optimized(tmp1, page_size);
 834     __ compareU32_and_branch(frame_size, tmp1, Assembler::bcondLow, after_frame_check);
 835   }
 836 
 837   // Get the stack base, and in debug, verify it is non-zero.
 838   __ z_lg(tmp1, thread_(stack_base));
 839 #ifdef ASSERT
 840   address reentry = NULL;
 841   NearLabel base_not_zero;
 842   __ compareU64_and_branch(tmp1, (intptr_t)0L, Assembler::bcondNotEqual, base_not_zero);
 843   reentry = __ stop_chain_static(reentry, &quot;stack base is zero in generate_stack_overflow_check&quot;);
 844   __ bind(base_not_zero);
</pre>
<hr />
<pre>
 866   // the bottom of the stack.
 867   __ compareU64_and_branch(Z_SP, tmp1, Assembler::bcondHigh, after_frame_check);
 868 
 869   // The stack will overflow, throw an exception.
 870 
 871   // Restore SP to sender&#39;s sp. This is necessary if the sender&#39;s frame is an
 872   // extended compiled frame (see gen_c2i_adapter()) and safer anyway in case of
 873   // JSR292 adaptations.
 874   __ resize_frame_absolute(Z_R10, tmp1, true/*load_fp*/);
 875 
 876   // Note also that the restored frame is not necessarily interpreted.
 877   // Use the shared runtime version of the StackOverflowError.
 878   assert(StubRoutines::throw_StackOverflowError_entry() != NULL, &quot;stub not yet generated&quot;);
 879   AddressLiteral stub(StubRoutines::throw_StackOverflowError_entry());
 880   __ load_absolute_address(tmp1, StubRoutines::throw_StackOverflowError_entry());
 881   __ z_br(tmp1);
 882 
 883   // If you get to here, then there is enough stack space.
 884   __ bind(after_frame_check);
 885 
<span class="line-modified"> 886   BLOCK_COMMENT(&quot;} counter_overflow&quot;);</span>
 887 }
 888 
 889 // Allocate monitor and lock method (asm interpreter).
 890 //
 891 // Args:
 892 //   Z_locals: locals
 893 
 894 void TemplateInterpreterGenerator::lock_method(void) {
 895 
 896   BLOCK_COMMENT(&quot;lock_method {&quot;);
 897 
 898   // Synchronize method.
 899   const Register method = Z_tmp_2;
 900   __ get_method(method);
 901 
 902 #ifdef ASSERT
 903   address reentry = NULL;
 904   {
 905     Label L;
 906     __ testbit(method2_(method, access_flags), JVM_ACC_SYNCHRONIZED_BIT);
</pre>
<hr />
<pre>
 910   }
 911 #endif // ASSERT
 912 
 913   // Get synchronization object.
 914   const Register object = Z_tmp_2;
 915 
 916   {
 917     Label     done;
 918     Label     static_method;
 919 
 920     __ testbit(method2_(method, access_flags), JVM_ACC_STATIC_BIT);
 921     __ z_btrue(static_method);
 922 
 923     // non-static method: Load receiver obj from stack.
 924     __ mem2reg_opt(object, Address(Z_locals, Interpreter::local_offset_in_bytes(0)));
 925     __ z_bru(done);
 926 
 927     __ bind(static_method);
 928 
 929     // Lock the java mirror.
<span class="line-modified"> 930     __ load_mirror(object, method);</span>


 931 #ifdef ASSERT
 932     {
 933       NearLabel L;
 934       __ compare64_and_branch(object, (intptr_t) 0, Assembler::bcondNotEqual, L);
 935       reentry = __ stop_chain_static(reentry, &quot;synchronization object is NULL&quot;);
 936       __ bind(L);
 937     }
 938 #endif // ASSERT
 939 
 940     __ bind(done);
 941   }
 942 
 943   __ add_monitor_to_stack(true, Z_ARG3, Z_ARG4, Z_ARG5); // Allocate monitor elem.
 944   // Store object and lock it.
 945   __ get_monitors(Z_tmp_1);
 946   __ reg2mem_opt(object, Address(Z_tmp_1, BasicObjectLock::obj_offset_in_bytes()));
 947   __ lock_object(Z_tmp_1, object);
 948 
 949   BLOCK_COMMENT(&quot;} lock_method&quot;);
 950 }
</pre>
<hr />
<pre>
 974   //  stack layout
 975   //
 976   //   F1 [TOP_IJAVA_FRAME_ABI]              &lt;-- Z_SP, Z_R10 (see note below)
 977   //      [F1&#39;s operand stack (unused)]
 978   //      [F1&#39;s outgoing Java arguments]     &lt;-- Z_esp
 979   //      [F1&#39;s operand stack (non args)]
 980   //      [monitors]      (optional)
 981   //      [IJAVA_STATE]
 982   //
 983   //   F2 [PARENT_IJAVA_FRAME_ABI]
 984   //      ...
 985   //
 986   //  0x000
 987   //
 988   // Note: Z_R10, the sender sp, will be below Z_SP if F1 was extended by a c2i adapter.
 989 
 990   //=============================================================================
 991   // Allocate space for locals other than the parameters, the
 992   // interpreter state, monitors, and the expression stack.
 993 
<span class="line-modified"> 994   const Register local_count     = Z_ARG5;</span>
<span class="line-modified"> 995   const Register fp              = Z_tmp_2;</span>

 996 
 997   BLOCK_COMMENT(&quot;generate_fixed_frame {&quot;);
<span class="line-removed"> 998 </span>
 999   {
1000   // local registers
1001   const Register top_frame_size  = Z_ARG2;
1002   const Register sp_after_resize = Z_ARG3;
1003   const Register max_stack       = Z_ARG4;
1004 
<span class="line-modified">1005   // local_count = method-&gt;constMethod-&gt;max_locals();</span>
<span class="line-modified">1006   __ z_lg(Z_R1_scratch, Address(Z_method, Method::const_offset()));</span>
<span class="line-modified">1007   __ z_llgh(local_count, Address(Z_R1_scratch, ConstMethod::size_of_locals_offset()));</span>
1008 
1009   if (native_call) {
1010     // If we&#39;re calling a native method, we replace max_stack (which is
1011     // zero) with space for the worst-case signature handler varargs
1012     // vector, which is:
1013     //   max_stack = max(Argument::n_register_parameters, parameter_count+2);
1014     //
1015     // We add two slots to the parameter_count, one for the jni
1016     // environment and one for a possible native mirror. We allocate
1017     // space for at least the number of ABI registers, even though
1018     // InterpreterRuntime::slow_signature_handler won&#39;t write more than
1019     // parameter_count+2 words when it creates the varargs vector at the
1020     // top of the stack. The generated slow signature handler will just
1021     // load trash into registers beyond the necessary number. We&#39;re
1022     // still going to cut the stack back by the ABI register parameter
1023     // count so as to get SP+16 pointing at the ABI outgoing parameter
1024     // area, so we need to allocate at least that much even though we&#39;re
1025     // going to throw it away.
1026     //
<span class="line-removed">1027 </span>
<span class="line-removed">1028     __ z_lg(Z_R1_scratch, Address(Z_method, Method::const_offset()));</span>
<span class="line-removed">1029     __ z_llgh(max_stack,  Address(Z_R1_scratch, ConstMethod::size_of_parameters_offset()));</span>
1030     __ add2reg(max_stack, 2);
1031 
1032     NearLabel passing_args_on_stack;
1033 
1034     // max_stack in bytes
1035     __ z_sllg(max_stack, max_stack, LogBytesPerWord);
1036 
1037     int argument_registers_in_bytes = Argument::n_register_parameters &lt;&lt; LogBytesPerWord;
1038     __ compare64_and_branch(max_stack, argument_registers_in_bytes, Assembler::bcondNotLow, passing_args_on_stack);
1039 
1040     __ load_const_optimized(max_stack, argument_registers_in_bytes);
1041 
1042     __ bind(passing_args_on_stack);
1043   } else {
1044     // !native_call
<span class="line-modified">1045     __ z_lg(max_stack, method_(const));</span>

1046 
1047     // Calculate number of non-parameter locals (in slots):
<span class="line-modified">1048     __ z_lg(Z_R1_scratch, Address(Z_method, Method::const_offset()));</span>
<span class="line-removed">1049     __ z_sh(local_count, Address(Z_R1_scratch, ConstMethod::size_of_parameters_offset()));</span>
1050 
1051     // max_stack = method-&gt;max_stack();
<span class="line-modified">1052     __ z_llgh(max_stack, Address(max_stack, ConstMethod::max_stack_offset()));</span>
1053     // max_stack in bytes
1054     __ z_sllg(max_stack, max_stack, LogBytesPerWord);
1055   }
1056 
1057   // Resize (i.e. normally shrink) the top frame F1 ...
1058   //   F1      [TOP_IJAVA_FRAME_ABI]          &lt;-- Z_SP, Z_R10
1059   //           F1&#39;s operand stack (free)
1060   //           ...
1061   //           F1&#39;s operand stack (free)      &lt;-- Z_esp
1062   //           F1&#39;s outgoing Java arg m
1063   //           ...
1064   //           F1&#39;s outgoing Java arg 0
1065   //           ...
1066   //
1067   //  ... into a parent frame (Z_R10 holds F1&#39;s SP before any modification, see also above)
1068   //
1069   //           +......................+
1070   //           :                      :        &lt;-- Z_R10, saved below as F0&#39;s z_ijava_state.sender_sp
1071   //           :                      :
1072   //   F1      [PARENT_IJAVA_FRAME_ABI]        &lt;-- Z_SP       \
1073   //           F0&#39;s non arg local                             | = delta
1074   //           ...                                            |
1075   //           F0&#39;s non arg local              &lt;-- Z_esp      /
1076   //           F1&#39;s outgoing Java arg m
1077   //           ...
1078   //           F1&#39;s outgoing Java arg 0
1079   //           ...
1080   //
1081   // then push the new top frame F0.
1082   //
1083   //   F0      [TOP_IJAVA_FRAME_ABI]    = frame::z_top_ijava_frame_abi_size \
1084   //           [operand stack]          = max_stack                          | = top_frame_size
1085   //           [IJAVA_STATE]            = frame::z_ijava_state_size         /
1086 
1087   // sp_after_resize = Z_esp - delta
1088   //
1089   // delta = PARENT_IJAVA_FRAME_ABI + (locals_count - params_count)
1090 
1091   __ add2reg(sp_after_resize, (Interpreter::stackElementSize) - (frame::z_parent_ijava_frame_abi_size), Z_esp);
<span class="line-modified">1092   __ z_sllg(Z_R0_scratch, local_count, LogBytesPerWord); // Params have already been subtracted from local_count.</span>
<span class="line-modified">1093   __ z_slgr(sp_after_resize, Z_R0_scratch);</span>


1094 
1095   // top_frame_size = TOP_IJAVA_FRAME_ABI + max_stack + size of interpreter state
1096   __ add2reg(top_frame_size,
1097              frame::z_top_ijava_frame_abi_size +
<span class="line-modified">1098              frame::z_ijava_state_size +</span>
<span class="line-removed">1099              frame::interpreter_frame_monitor_size() * wordSize,</span>
1100              max_stack);
1101 
1102   if (!native_call) {
1103     // Stack overflow check.
1104     // Native calls don&#39;t need the stack size check since they have no
1105     // expression stack and the arguments are already on the stack and
1106     // we only add a handful of words to the stack.
<span class="line-modified">1107     Register frame_size = max_stack; // Reuse the regiser for max_stack.</span>
1108     __ z_lgr(frame_size, Z_SP);
1109     __ z_sgr(frame_size, sp_after_resize);
1110     __ z_agr(frame_size, top_frame_size);
1111     generate_stack_overflow_check(frame_size, fp/*tmp1*/);
1112   }
1113 
1114   DEBUG_ONLY(__ z_cg(Z_R14, _z_abi16(return_pc), Z_SP));
1115   __ asm_assert_eq(&quot;killed Z_R14&quot;, 0);
1116   __ resize_frame_absolute(sp_after_resize, fp, true);
1117   __ save_return_pc(Z_R14);
1118 
1119   // ... and push the new frame F0.
1120   __ push_frame(top_frame_size, fp, true /*copy_sp*/, false);
1121   }
1122 
1123   //=============================================================================
1124   // Initialize the new frame F0: initialize interpreter state.
1125 
1126   {
1127   // locals
1128   const Register local_addr = Z_ARG4;
1129 
1130   BLOCK_COMMENT(&quot;generate_fixed_frame: initialize interpreter state {&quot;);
1131 
1132 #ifdef ASSERT
1133   // Set the magic number (using local_addr as tmp register).
1134   __ load_const_optimized(local_addr, frame::z_istate_magic_number);
1135   __ z_stg(local_addr, _z_ijava_state_neg(magic), fp);
1136 #endif
1137 
1138   // Save sender SP from F1 (i.e. before it was potentially modified by an
<span class="line-modified">1139   // adapter) into F0&#39;s interpreter state. We us it as well to revert</span>
1140   // resizing the frame above.
1141   __ z_stg(Z_R10, _z_ijava_state_neg(sender_sp), fp);
1142 
<span class="line-modified">1143   // Load cp cache and save it at the and of this block.</span>
<span class="line-modified">1144   __ z_lg(Z_R1_scratch, Address(Z_method,    Method::const_offset()));</span>
<span class="line-removed">1145   __ z_lg(Z_R1_scratch, Address(Z_R1_scratch, ConstMethod::constants_offset()));</span>
1146   __ z_lg(Z_R1_scratch, Address(Z_R1_scratch, ConstantPool::cache_offset_in_bytes()));
1147 
1148   // z_ijava_state-&gt;method = method;
1149   __ z_stg(Z_method, _z_ijava_state_neg(method), fp);
1150 
1151   // Point locals at the first argument. Method&#39;s locals are the
1152   // parameters on top of caller&#39;s expression stack.
1153   // Tos points past last Java argument.
1154 
<span class="line-removed">1155   __ z_lg(Z_locals, Address(Z_method, Method::const_offset()));</span>
<span class="line-removed">1156   __ z_llgh(Z_locals /*parameter_count words*/,</span>
<span class="line-removed">1157             Address(Z_locals, ConstMethod::size_of_parameters_offset()));</span>
<span class="line-removed">1158   __ z_sllg(Z_locals /*parameter_count bytes*/, Z_locals /*parameter_count*/, LogBytesPerWord);</span>
1159   __ z_agr(Z_locals, Z_esp);
1160   // z_ijava_state-&gt;locals - i*BytesPerWord points to i-th Java local (i starts at 0)
1161   // z_ijava_state-&gt;locals = Z_esp + parameter_count bytes
1162   __ z_stg(Z_locals, _z_ijava_state_neg(locals), fp);
1163 
1164   // z_ijava_state-&gt;oop_temp = NULL;
1165   __ store_const(Address(fp, oop_tmp_offset), 0);
1166 
1167   // Initialize z_ijava_state-&gt;mdx.
1168   Register Rmdp = Z_bcp;
1169   // native_call: assert that mdo == NULL
1170   const bool check_for_mdo = !native_call DEBUG_ONLY(|| native_call);
1171   if (ProfileInterpreter &amp;&amp; check_for_mdo) {
1172     Label get_continue;
1173 
1174     __ load_and_test_long(Rmdp, method_(method_data));
1175     __ z_brz(get_continue);
1176     DEBUG_ONLY(if (native_call) __ stop(&quot;native methods don&#39;t have a mdo&quot;));
1177     __ add2reg(Rmdp, in_bytes(MethodData::data_offset()));
1178     __ bind(get_continue);
1179   }
1180   __ z_stg(Rmdp, _z_ijava_state_neg(mdx), fp);
1181 
1182   // Initialize z_ijava_state-&gt;bcp and Z_bcp.
1183   if (native_call) {
1184     __ clear_reg(Z_bcp); // Must initialize. Will get written into frame where GC reads it.
1185   } else {
<span class="line-modified">1186     __ z_lg(Z_bcp, method_(const));</span>
<span class="line-removed">1187     __ add2reg(Z_bcp, in_bytes(ConstMethod::codes_offset()));</span>
1188   }
1189   __ z_stg(Z_bcp, _z_ijava_state_neg(bcp), fp);
1190 
1191   // no monitors and empty operand stack
1192   // =&gt; z_ijava_state-&gt;monitors points to the top slot in IJAVA_STATE.
1193   // =&gt; Z_ijava_state-&gt;esp points one slot above into the operand stack.
1194   // z_ijava_state-&gt;monitors = fp - frame::z_ijava_state_size - Interpreter::stackElementSize;
1195   // z_ijava_state-&gt;esp = Z_esp = z_ijava_state-&gt;monitors;
1196   __ add2reg(Z_esp, -frame::z_ijava_state_size, fp);
1197   __ z_stg(Z_esp, _z_ijava_state_neg(monitors), fp);
1198   __ add2reg(Z_esp, -Interpreter::stackElementSize);
1199   __ z_stg(Z_esp, _z_ijava_state_neg(esp), fp);
1200 
1201   // z_ijava_state-&gt;cpoolCache = Z_R1_scratch (see load above);
1202   __ z_stg(Z_R1_scratch, _z_ijava_state_neg(cpoolCache), fp);
1203 
1204   // Get mirror and store it in the frame as GC root for this Method*.
<span class="line-modified">1205   __ load_mirror(Z_R1_scratch, Z_method);</span>
1206   __ z_stg(Z_R1_scratch, _z_ijava_state_neg(mirror), fp);
1207 
1208   BLOCK_COMMENT(&quot;} generate_fixed_frame: initialize interpreter state&quot;);
1209 
1210   //=============================================================================
1211   if (!native_call) {
<span class="line-removed">1212     // Fill locals with 0x0s.</span>
<span class="line-removed">1213     NearLabel locals_zeroed;</span>
<span class="line-removed">1214     NearLabel doXC;</span>
<span class="line-removed">1215 </span>
1216     // Local_count is already num_locals_slots - num_param_slots.
<span class="line-modified">1217     __ compare64_and_branch(local_count, (intptr_t)0L, Assembler::bcondNotHigh, locals_zeroed);</span>
<span class="line-modified">1218 </span>
<span class="line-modified">1219     // Advance local_addr to point behind locals (creates positive incr. in loop).</span>
<span class="line-removed">1220     __ z_lg(Z_R1_scratch, Address(Z_method, Method::const_offset()));</span>
<span class="line-removed">1221     __ z_llgh(Z_R0_scratch, Address(Z_R1_scratch, ConstMethod::size_of_locals_offset()));</span>
<span class="line-removed">1222     __ add2reg(Z_R0_scratch, -1);</span>
<span class="line-removed">1223 </span>
<span class="line-removed">1224     __ z_lgr(local_addr/*locals*/, Z_locals);</span>
1225     __ z_sllg(Z_R0_scratch, Z_R0_scratch, LogBytesPerWord);
<span class="line-removed">1226     __ z_sllg(local_count, local_count, LogBytesPerWord); // Local_count are non param locals.</span>
1227     __ z_sgr(local_addr, Z_R0_scratch);
1228 
<span class="line-modified">1229     if (VM_Version::has_Prefetch()) {</span>
<span class="line-removed">1230       __ z_pfd(0x02, 0, Z_R0, local_addr);</span>
<span class="line-removed">1231       __ z_pfd(0x02, 256, Z_R0, local_addr);</span>
<span class="line-removed">1232     }</span>
<span class="line-removed">1233 </span>
<span class="line-removed">1234     // Can&#39;t optimise for Z10 using &quot;compare and branch&quot; (immediate value is too big).</span>
<span class="line-removed">1235     __ z_cghi(local_count, 256);</span>
<span class="line-removed">1236     __ z_brnh(doXC);</span>
<span class="line-removed">1237 </span>
<span class="line-removed">1238     // MVCLE: Initialize if quite a lot locals.</span>
<span class="line-removed">1239     //  __ bind(doMVCLE);</span>
<span class="line-removed">1240     __ z_lgr(Z_R0_scratch, local_addr);</span>
<span class="line-removed">1241     __ z_lgr(Z_R1_scratch, local_count);</span>
<span class="line-removed">1242     __ clear_reg(Z_ARG2);        // Src len of MVCLE is zero.</span>
<span class="line-removed">1243 </span>
<span class="line-removed">1244     __ MacroAssembler::move_long_ext(Z_R0_scratch, Z_ARG1, 0);</span>
<span class="line-removed">1245     __ z_bru(locals_zeroed);</span>
<span class="line-removed">1246 </span>
<span class="line-removed">1247     Label  XC_template;</span>
<span class="line-removed">1248     __ bind(XC_template);</span>
<span class="line-removed">1249     __ z_xc(0, 0, local_addr, 0, local_addr);</span>
<span class="line-removed">1250 </span>
<span class="line-removed">1251     __ bind(doXC);</span>
<span class="line-removed">1252     __ z_bctgr(local_count, Z_R0);                  // Get #bytes-1 for EXECUTE.</span>
<span class="line-removed">1253     if (VM_Version::has_ExecuteExtensions()) {</span>
<span class="line-removed">1254       __ z_exrl(local_count, XC_template);          // Execute XC with variable length.</span>
<span class="line-removed">1255     } else {</span>
<span class="line-removed">1256       __ z_larl(Z_R1_scratch, XC_template);</span>
<span class="line-removed">1257       __ z_ex(local_count, 0, Z_R0, Z_R1_scratch);  // Execute XC with variable length.</span>
<span class="line-removed">1258     }</span>
<span class="line-removed">1259 </span>
<span class="line-removed">1260     __ bind(locals_zeroed);</span>
1261   }
1262 
1263   }
1264   // Finally set the frame pointer, destroying Z_method.
1265   assert(Z_fp == Z_method, &quot;maybe set Z_fp earlier if other register than Z_method&quot;);
1266   // Oprofile analysis suggests to keep a copy in a register to be used by
1267   // generate_counter_incr().
1268   __ z_lgr(Z_ARG2, Z_method);
1269   __ z_lgr(Z_fp, fp);
1270 
1271   BLOCK_COMMENT(&quot;} generate_fixed_frame&quot;);
1272 }
1273 
1274 // Various method entries
1275 
1276 // Math function, frame manager must set up an interpreter state, etc.
1277 address TemplateInterpreterGenerator::generate_math_entry(AbstractInterpreter::MethodKind kind) {
1278 
1279   // Decide what to do: Use same platform specific instructions and runtime calls as compilers.
1280   bool use_instruction = false;
</pre>
<hr />
<pre>
1513 
1514   __ bind(call_signature_handler);
1515 
1516   // We have a TOP_IJAVA_FRAME here, which belongs to us.
1517   __ set_top_ijava_frame_at_SP_as_last_Java_frame(Z_SP, Z_R1/*tmp*/);
1518 
1519   // Call signature handler and pass locals address in Z_ARG1.
1520   __ z_lgr(Z_ARG1, Z_locals);
1521   __ call_stub(signature_handler_entry);
1522   // Save result handler returned by signature handler.
1523   __ z_lgr(Rresult_handler, Z_RET);
1524 
1525   // Reload method (the slow signature handler may block for GC).
1526   __ get_method(Rmethod);
1527 
1528   // Pass mirror handle if static call.
1529   {
1530     Label method_is_not_static;
1531     __ testbit(method2_(Rmethod, access_flags), JVM_ACC_STATIC_BIT);
1532     __ z_bfalse(method_is_not_static);
<span class="line-modified">1533     // Get mirror.</span>
<span class="line-modified">1534     __ load_mirror(Z_R1, Rmethod);</span>
1535     // z_ijava_state.oop_temp = pool_holder-&gt;klass_part()-&gt;java_mirror();
1536     __ z_stg(Z_R1, oop_tmp_offset, Z_fp);
1537     // Pass handle to mirror as 2nd argument to JNI method.
1538     __ add2reg(Z_ARG2, oop_tmp_offset, Z_fp);
1539     __ bind(method_is_not_static);
1540   }
1541 
1542   // Pass JNIEnv address as first parameter.
1543   __ add2reg(Z_ARG1, in_bytes(JavaThread::jni_environment_offset()), Z_thread);
1544 
1545   // Note: last java frame has been set above already. The pc from there
1546   // is precise enough.
1547 
1548   // Get native function entry point before we change the thread state.
1549   __ z_lg(Z_R1/*native_method_entry*/, method2_(Rmethod, native_function));
1550 
1551   //=============================================================================
1552   // Transition from _thread_in_Java to _thread_in_native. As soon as
1553   // we make this change the safepoint code needs to be certain that
1554   // the last Java frame we established is good. The pc in that frame
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="line-modified">   3  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.</span>
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
</pre>
<hr />
<pre>
 804 void TemplateInterpreterGenerator::generate_counter_overflow(Label&amp; do_continue) {
 805   // InterpreterRuntime::frequency_counter_overflow takes two
 806   // arguments, the first (thread) is passed by call_VM, the second
 807   // indicates if the counter overflow occurs at a backwards branch
 808   // (NULL bcp). We pass zero for it. The call returns the address
 809   // of the verified entry point for the method or NULL if the
 810   // compilation did not complete (either went background or bailed
 811   // out).
 812   __ clear_reg(Z_ARG2);
 813   __ call_VM(noreg,
 814              CAST_FROM_FN_PTR(address, InterpreterRuntime::frequency_counter_overflow),
 815              Z_ARG2);
 816   __ z_bru(do_continue);
 817 }
 818 
 819 void TemplateInterpreterGenerator::generate_stack_overflow_check(Register frame_size, Register tmp1) {
 820   Register tmp2 = Z_R1_scratch;
 821   const int page_size = os::vm_page_size();
 822   NearLabel after_frame_check;
 823 
<span class="line-modified"> 824   BLOCK_COMMENT(&quot;stack_overflow_check {&quot;);</span>
 825 
 826   assert_different_registers(frame_size, tmp1);
 827 
 828   // Stack banging is sufficient overflow check if frame_size &lt; page_size.
 829   if (Immediate::is_uimm(page_size, 15)) {
 830     __ z_chi(frame_size, page_size);
 831     __ z_brl(after_frame_check);
 832   } else {
 833     __ load_const_optimized(tmp1, page_size);
 834     __ compareU32_and_branch(frame_size, tmp1, Assembler::bcondLow, after_frame_check);
 835   }
 836 
 837   // Get the stack base, and in debug, verify it is non-zero.
 838   __ z_lg(tmp1, thread_(stack_base));
 839 #ifdef ASSERT
 840   address reentry = NULL;
 841   NearLabel base_not_zero;
 842   __ compareU64_and_branch(tmp1, (intptr_t)0L, Assembler::bcondNotEqual, base_not_zero);
 843   reentry = __ stop_chain_static(reentry, &quot;stack base is zero in generate_stack_overflow_check&quot;);
 844   __ bind(base_not_zero);
</pre>
<hr />
<pre>
 866   // the bottom of the stack.
 867   __ compareU64_and_branch(Z_SP, tmp1, Assembler::bcondHigh, after_frame_check);
 868 
 869   // The stack will overflow, throw an exception.
 870 
 871   // Restore SP to sender&#39;s sp. This is necessary if the sender&#39;s frame is an
 872   // extended compiled frame (see gen_c2i_adapter()) and safer anyway in case of
 873   // JSR292 adaptations.
 874   __ resize_frame_absolute(Z_R10, tmp1, true/*load_fp*/);
 875 
 876   // Note also that the restored frame is not necessarily interpreted.
 877   // Use the shared runtime version of the StackOverflowError.
 878   assert(StubRoutines::throw_StackOverflowError_entry() != NULL, &quot;stub not yet generated&quot;);
 879   AddressLiteral stub(StubRoutines::throw_StackOverflowError_entry());
 880   __ load_absolute_address(tmp1, StubRoutines::throw_StackOverflowError_entry());
 881   __ z_br(tmp1);
 882 
 883   // If you get to here, then there is enough stack space.
 884   __ bind(after_frame_check);
 885 
<span class="line-modified"> 886   BLOCK_COMMENT(&quot;} stack_overflow_check&quot;);</span>
 887 }
 888 
 889 // Allocate monitor and lock method (asm interpreter).
 890 //
 891 // Args:
 892 //   Z_locals: locals
 893 
 894 void TemplateInterpreterGenerator::lock_method(void) {
 895 
 896   BLOCK_COMMENT(&quot;lock_method {&quot;);
 897 
 898   // Synchronize method.
 899   const Register method = Z_tmp_2;
 900   __ get_method(method);
 901 
 902 #ifdef ASSERT
 903   address reentry = NULL;
 904   {
 905     Label L;
 906     __ testbit(method2_(method, access_flags), JVM_ACC_SYNCHRONIZED_BIT);
</pre>
<hr />
<pre>
 910   }
 911 #endif // ASSERT
 912 
 913   // Get synchronization object.
 914   const Register object = Z_tmp_2;
 915 
 916   {
 917     Label     done;
 918     Label     static_method;
 919 
 920     __ testbit(method2_(method, access_flags), JVM_ACC_STATIC_BIT);
 921     __ z_btrue(static_method);
 922 
 923     // non-static method: Load receiver obj from stack.
 924     __ mem2reg_opt(object, Address(Z_locals, Interpreter::local_offset_in_bytes(0)));
 925     __ z_bru(done);
 926 
 927     __ bind(static_method);
 928 
 929     // Lock the java mirror.
<span class="line-modified"> 930     // Load mirror from interpreter frame.</span>
<span class="line-added"> 931     __ z_lg(object, _z_ijava_state_neg(mirror), Z_fp);</span>
<span class="line-added"> 932 </span>
 933 #ifdef ASSERT
 934     {
 935       NearLabel L;
 936       __ compare64_and_branch(object, (intptr_t) 0, Assembler::bcondNotEqual, L);
 937       reentry = __ stop_chain_static(reentry, &quot;synchronization object is NULL&quot;);
 938       __ bind(L);
 939     }
 940 #endif // ASSERT
 941 
 942     __ bind(done);
 943   }
 944 
 945   __ add_monitor_to_stack(true, Z_ARG3, Z_ARG4, Z_ARG5); // Allocate monitor elem.
 946   // Store object and lock it.
 947   __ get_monitors(Z_tmp_1);
 948   __ reg2mem_opt(object, Address(Z_tmp_1, BasicObjectLock::obj_offset_in_bytes()));
 949   __ lock_object(Z_tmp_1, object);
 950 
 951   BLOCK_COMMENT(&quot;} lock_method&quot;);
 952 }
</pre>
<hr />
<pre>
 976   //  stack layout
 977   //
 978   //   F1 [TOP_IJAVA_FRAME_ABI]              &lt;-- Z_SP, Z_R10 (see note below)
 979   //      [F1&#39;s operand stack (unused)]
 980   //      [F1&#39;s outgoing Java arguments]     &lt;-- Z_esp
 981   //      [F1&#39;s operand stack (non args)]
 982   //      [monitors]      (optional)
 983   //      [IJAVA_STATE]
 984   //
 985   //   F2 [PARENT_IJAVA_FRAME_ABI]
 986   //      ...
 987   //
 988   //  0x000
 989   //
 990   // Note: Z_R10, the sender sp, will be below Z_SP if F1 was extended by a c2i adapter.
 991 
 992   //=============================================================================
 993   // Allocate space for locals other than the parameters, the
 994   // interpreter state, monitors, and the expression stack.
 995 
<span class="line-modified"> 996   const Register local_count  = Z_ARG5;</span>
<span class="line-modified"> 997   const Register fp           = Z_tmp_2;</span>
<span class="line-added"> 998   const Register const_method = Z_ARG1;</span>
 999 
1000   BLOCK_COMMENT(&quot;generate_fixed_frame {&quot;);

1001   {
1002   // local registers
1003   const Register top_frame_size  = Z_ARG2;
1004   const Register sp_after_resize = Z_ARG3;
1005   const Register max_stack       = Z_ARG4;
1006 
<span class="line-modified">1007   __ z_lg(const_method, Address(Z_method, Method::const_offset()));</span>
<span class="line-modified">1008   __ z_llgh(max_stack, Address(const_method, ConstMethod::size_of_parameters_offset()));</span>
<span class="line-modified">1009   __ z_sllg(Z_locals /*parameter_count bytes*/, max_stack /*parameter_count*/, LogBytesPerWord);</span>
1010 
1011   if (native_call) {
1012     // If we&#39;re calling a native method, we replace max_stack (which is
1013     // zero) with space for the worst-case signature handler varargs
1014     // vector, which is:
1015     //   max_stack = max(Argument::n_register_parameters, parameter_count+2);
1016     //
1017     // We add two slots to the parameter_count, one for the jni
1018     // environment and one for a possible native mirror. We allocate
1019     // space for at least the number of ABI registers, even though
1020     // InterpreterRuntime::slow_signature_handler won&#39;t write more than
1021     // parameter_count+2 words when it creates the varargs vector at the
1022     // top of the stack. The generated slow signature handler will just
1023     // load trash into registers beyond the necessary number. We&#39;re
1024     // still going to cut the stack back by the ABI register parameter
1025     // count so as to get SP+16 pointing at the ABI outgoing parameter
1026     // area, so we need to allocate at least that much even though we&#39;re
1027     // going to throw it away.
1028     //



1029     __ add2reg(max_stack, 2);
1030 
1031     NearLabel passing_args_on_stack;
1032 
1033     // max_stack in bytes
1034     __ z_sllg(max_stack, max_stack, LogBytesPerWord);
1035 
1036     int argument_registers_in_bytes = Argument::n_register_parameters &lt;&lt; LogBytesPerWord;
1037     __ compare64_and_branch(max_stack, argument_registers_in_bytes, Assembler::bcondNotLow, passing_args_on_stack);
1038 
1039     __ load_const_optimized(max_stack, argument_registers_in_bytes);
1040 
1041     __ bind(passing_args_on_stack);
1042   } else {
1043     // !native_call
<span class="line-modified">1044     // local_count = method-&gt;constMethod-&gt;max_locals();</span>
<span class="line-added">1045     __ z_llgh(local_count, Address(const_method, ConstMethod::size_of_locals_offset()));</span>
1046 
1047     // Calculate number of non-parameter locals (in slots):
<span class="line-modified">1048     __ z_sgr(local_count, max_stack);</span>

1049 
1050     // max_stack = method-&gt;max_stack();
<span class="line-modified">1051     __ z_llgh(max_stack, Address(const_method, ConstMethod::max_stack_offset()));</span>
1052     // max_stack in bytes
1053     __ z_sllg(max_stack, max_stack, LogBytesPerWord);
1054   }
1055 
1056   // Resize (i.e. normally shrink) the top frame F1 ...
1057   //   F1      [TOP_IJAVA_FRAME_ABI]          &lt;-- Z_SP, Z_R10
1058   //           F1&#39;s operand stack (free)
1059   //           ...
1060   //           F1&#39;s operand stack (free)      &lt;-- Z_esp
1061   //           F1&#39;s outgoing Java arg m
1062   //           ...
1063   //           F1&#39;s outgoing Java arg 0
1064   //           ...
1065   //
1066   //  ... into a parent frame (Z_R10 holds F1&#39;s SP before any modification, see also above)
1067   //
1068   //           +......................+
1069   //           :                      :        &lt;-- Z_R10, saved below as F0&#39;s z_ijava_state.sender_sp
1070   //           :                      :
1071   //   F1      [PARENT_IJAVA_FRAME_ABI]        &lt;-- Z_SP       \
1072   //           F0&#39;s non arg local                             | = delta
1073   //           ...                                            |
1074   //           F0&#39;s non arg local              &lt;-- Z_esp      /
1075   //           F1&#39;s outgoing Java arg m
1076   //           ...
1077   //           F1&#39;s outgoing Java arg 0
1078   //           ...
1079   //
1080   // then push the new top frame F0.
1081   //
1082   //   F0      [TOP_IJAVA_FRAME_ABI]    = frame::z_top_ijava_frame_abi_size \
1083   //           [operand stack]          = max_stack                          | = top_frame_size
1084   //           [IJAVA_STATE]            = frame::z_ijava_state_size         /
1085 
1086   // sp_after_resize = Z_esp - delta
1087   //
1088   // delta = PARENT_IJAVA_FRAME_ABI + (locals_count - params_count)
1089 
1090   __ add2reg(sp_after_resize, (Interpreter::stackElementSize) - (frame::z_parent_ijava_frame_abi_size), Z_esp);
<span class="line-modified">1091   if (!native_call) {</span>
<span class="line-modified">1092     __ z_sllg(Z_R0_scratch, local_count, LogBytesPerWord); // Params have already been subtracted from local_count.</span>
<span class="line-added">1093     __ z_slgr(sp_after_resize, Z_R0_scratch);</span>
<span class="line-added">1094   }</span>
1095 
1096   // top_frame_size = TOP_IJAVA_FRAME_ABI + max_stack + size of interpreter state
1097   __ add2reg(top_frame_size,
1098              frame::z_top_ijava_frame_abi_size +
<span class="line-modified">1099              frame::z_ijava_state_size,</span>

1100              max_stack);
1101 
1102   if (!native_call) {
1103     // Stack overflow check.
1104     // Native calls don&#39;t need the stack size check since they have no
1105     // expression stack and the arguments are already on the stack and
1106     // we only add a handful of words to the stack.
<span class="line-modified">1107     Register frame_size = max_stack; // Reuse the register for max_stack.</span>
1108     __ z_lgr(frame_size, Z_SP);
1109     __ z_sgr(frame_size, sp_after_resize);
1110     __ z_agr(frame_size, top_frame_size);
1111     generate_stack_overflow_check(frame_size, fp/*tmp1*/);
1112   }
1113 
1114   DEBUG_ONLY(__ z_cg(Z_R14, _z_abi16(return_pc), Z_SP));
1115   __ asm_assert_eq(&quot;killed Z_R14&quot;, 0);
1116   __ resize_frame_absolute(sp_after_resize, fp, true);
1117   __ save_return_pc(Z_R14);
1118 
1119   // ... and push the new frame F0.
1120   __ push_frame(top_frame_size, fp, true /*copy_sp*/, false);
1121   }
1122 
1123   //=============================================================================
1124   // Initialize the new frame F0: initialize interpreter state.
1125 
1126   {
1127   // locals
1128   const Register local_addr = Z_ARG4;
1129 
1130   BLOCK_COMMENT(&quot;generate_fixed_frame: initialize interpreter state {&quot;);
1131 
1132 #ifdef ASSERT
1133   // Set the magic number (using local_addr as tmp register).
1134   __ load_const_optimized(local_addr, frame::z_istate_magic_number);
1135   __ z_stg(local_addr, _z_ijava_state_neg(magic), fp);
1136 #endif
1137 
1138   // Save sender SP from F1 (i.e. before it was potentially modified by an
<span class="line-modified">1139   // adapter) into F0&#39;s interpreter state. We use it as well to revert</span>
1140   // resizing the frame above.
1141   __ z_stg(Z_R10, _z_ijava_state_neg(sender_sp), fp);
1142 
<span class="line-modified">1143   // Load cp cache and save it at the end of this block.</span>
<span class="line-modified">1144   __ z_lg(Z_R1_scratch, Address(const_method, ConstMethod::constants_offset()));</span>

1145   __ z_lg(Z_R1_scratch, Address(Z_R1_scratch, ConstantPool::cache_offset_in_bytes()));
1146 
1147   // z_ijava_state-&gt;method = method;
1148   __ z_stg(Z_method, _z_ijava_state_neg(method), fp);
1149 
1150   // Point locals at the first argument. Method&#39;s locals are the
1151   // parameters on top of caller&#39;s expression stack.
1152   // Tos points past last Java argument.
1153 




1154   __ z_agr(Z_locals, Z_esp);
1155   // z_ijava_state-&gt;locals - i*BytesPerWord points to i-th Java local (i starts at 0)
1156   // z_ijava_state-&gt;locals = Z_esp + parameter_count bytes
1157   __ z_stg(Z_locals, _z_ijava_state_neg(locals), fp);
1158 
1159   // z_ijava_state-&gt;oop_temp = NULL;
1160   __ store_const(Address(fp, oop_tmp_offset), 0);
1161 
1162   // Initialize z_ijava_state-&gt;mdx.
1163   Register Rmdp = Z_bcp;
1164   // native_call: assert that mdo == NULL
1165   const bool check_for_mdo = !native_call DEBUG_ONLY(|| native_call);
1166   if (ProfileInterpreter &amp;&amp; check_for_mdo) {
1167     Label get_continue;
1168 
1169     __ load_and_test_long(Rmdp, method_(method_data));
1170     __ z_brz(get_continue);
1171     DEBUG_ONLY(if (native_call) __ stop(&quot;native methods don&#39;t have a mdo&quot;));
1172     __ add2reg(Rmdp, in_bytes(MethodData::data_offset()));
1173     __ bind(get_continue);
1174   }
1175   __ z_stg(Rmdp, _z_ijava_state_neg(mdx), fp);
1176 
1177   // Initialize z_ijava_state-&gt;bcp and Z_bcp.
1178   if (native_call) {
1179     __ clear_reg(Z_bcp); // Must initialize. Will get written into frame where GC reads it.
1180   } else {
<span class="line-modified">1181     __ add2reg(Z_bcp, in_bytes(ConstMethod::codes_offset()), const_method);</span>

1182   }
1183   __ z_stg(Z_bcp, _z_ijava_state_neg(bcp), fp);
1184 
1185   // no monitors and empty operand stack
1186   // =&gt; z_ijava_state-&gt;monitors points to the top slot in IJAVA_STATE.
1187   // =&gt; Z_ijava_state-&gt;esp points one slot above into the operand stack.
1188   // z_ijava_state-&gt;monitors = fp - frame::z_ijava_state_size - Interpreter::stackElementSize;
1189   // z_ijava_state-&gt;esp = Z_esp = z_ijava_state-&gt;monitors;
1190   __ add2reg(Z_esp, -frame::z_ijava_state_size, fp);
1191   __ z_stg(Z_esp, _z_ijava_state_neg(monitors), fp);
1192   __ add2reg(Z_esp, -Interpreter::stackElementSize);
1193   __ z_stg(Z_esp, _z_ijava_state_neg(esp), fp);
1194 
1195   // z_ijava_state-&gt;cpoolCache = Z_R1_scratch (see load above);
1196   __ z_stg(Z_R1_scratch, _z_ijava_state_neg(cpoolCache), fp);
1197 
1198   // Get mirror and store it in the frame as GC root for this Method*.
<span class="line-modified">1199   __ load_mirror_from_const_method(Z_R1_scratch, const_method);</span>
1200   __ z_stg(Z_R1_scratch, _z_ijava_state_neg(mirror), fp);
1201 
1202   BLOCK_COMMENT(&quot;} generate_fixed_frame: initialize interpreter state&quot;);
1203 
1204   //=============================================================================
1205   if (!native_call) {




1206     // Local_count is already num_locals_slots - num_param_slots.
<span class="line-modified">1207     // Start of locals: local_addr = Z_locals - locals size + 1 slot</span>
<span class="line-modified">1208     __ z_llgh(Z_R0_scratch, Address(const_method, ConstMethod::size_of_locals_offset()));</span>
<span class="line-modified">1209     __ add2reg(local_addr, BytesPerWord, Z_locals);</span>





1210     __ z_sllg(Z_R0_scratch, Z_R0_scratch, LogBytesPerWord);

1211     __ z_sgr(local_addr, Z_R0_scratch);
1212 
<span class="line-modified">1213     __ Clear_Array(local_count, local_addr, Z_ARG2);</span>































1214   }
1215 
1216   }
1217   // Finally set the frame pointer, destroying Z_method.
1218   assert(Z_fp == Z_method, &quot;maybe set Z_fp earlier if other register than Z_method&quot;);
1219   // Oprofile analysis suggests to keep a copy in a register to be used by
1220   // generate_counter_incr().
1221   __ z_lgr(Z_ARG2, Z_method);
1222   __ z_lgr(Z_fp, fp);
1223 
1224   BLOCK_COMMENT(&quot;} generate_fixed_frame&quot;);
1225 }
1226 
1227 // Various method entries
1228 
1229 // Math function, frame manager must set up an interpreter state, etc.
1230 address TemplateInterpreterGenerator::generate_math_entry(AbstractInterpreter::MethodKind kind) {
1231 
1232   // Decide what to do: Use same platform specific instructions and runtime calls as compilers.
1233   bool use_instruction = false;
</pre>
<hr />
<pre>
1466 
1467   __ bind(call_signature_handler);
1468 
1469   // We have a TOP_IJAVA_FRAME here, which belongs to us.
1470   __ set_top_ijava_frame_at_SP_as_last_Java_frame(Z_SP, Z_R1/*tmp*/);
1471 
1472   // Call signature handler and pass locals address in Z_ARG1.
1473   __ z_lgr(Z_ARG1, Z_locals);
1474   __ call_stub(signature_handler_entry);
1475   // Save result handler returned by signature handler.
1476   __ z_lgr(Rresult_handler, Z_RET);
1477 
1478   // Reload method (the slow signature handler may block for GC).
1479   __ get_method(Rmethod);
1480 
1481   // Pass mirror handle if static call.
1482   {
1483     Label method_is_not_static;
1484     __ testbit(method2_(Rmethod, access_flags), JVM_ACC_STATIC_BIT);
1485     __ z_bfalse(method_is_not_static);
<span class="line-modified">1486     // Load mirror from interpreter frame.</span>
<span class="line-modified">1487     __ z_lg(Z_R1, _z_ijava_state_neg(mirror), Z_fp);</span>
1488     // z_ijava_state.oop_temp = pool_holder-&gt;klass_part()-&gt;java_mirror();
1489     __ z_stg(Z_R1, oop_tmp_offset, Z_fp);
1490     // Pass handle to mirror as 2nd argument to JNI method.
1491     __ add2reg(Z_ARG2, oop_tmp_offset, Z_fp);
1492     __ bind(method_is_not_static);
1493   }
1494 
1495   // Pass JNIEnv address as first parameter.
1496   __ add2reg(Z_ARG1, in_bytes(JavaThread::jni_environment_offset()), Z_thread);
1497 
1498   // Note: last java frame has been set above already. The pc from there
1499   // is precise enough.
1500 
1501   // Get native function entry point before we change the thread state.
1502   __ z_lg(Z_R1/*native_method_entry*/, method2_(Rmethod, native_function));
1503 
1504   //=============================================================================
1505   // Transition from _thread_in_Java to _thread_in_native. As soon as
1506   // we make this change the safepoint code needs to be certain that
1507   // the last Java frame we established is good. The pc in that frame
</pre>
</td>
</tr>
</table>
<center><a href="stubGenerator_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
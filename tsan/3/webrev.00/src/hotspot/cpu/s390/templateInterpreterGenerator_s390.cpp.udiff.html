<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/s390/templateInterpreterGenerator_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubGenerator_s390.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_s390.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/templateInterpreterGenerator_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,8 +1,8 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, 2018, SAP SE. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -819,11 +819,11 @@</span>
  void TemplateInterpreterGenerator::generate_stack_overflow_check(Register frame_size, Register tmp1) {
    Register tmp2 = Z_R1_scratch;
    const int page_size = os::vm_page_size();
    NearLabel after_frame_check;
  
<span class="udiff-line-modified-removed">-   BLOCK_COMMENT(&quot;counter_overflow {&quot;);</span>
<span class="udiff-line-modified-added">+   BLOCK_COMMENT(&quot;stack_overflow_check {&quot;);</span>
  
    assert_different_registers(frame_size, tmp1);
  
    // Stack banging is sufficient overflow check if frame_size &lt; page_size.
    if (Immediate::is_uimm(page_size, 15)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -881,11 +881,11 @@</span>
    __ z_br(tmp1);
  
    // If you get to here, then there is enough stack space.
    __ bind(after_frame_check);
  
<span class="udiff-line-modified-removed">-   BLOCK_COMMENT(&quot;} counter_overflow&quot;);</span>
<span class="udiff-line-modified-added">+   BLOCK_COMMENT(&quot;} stack_overflow_check&quot;);</span>
  }
  
  // Allocate monitor and lock method (asm interpreter).
  //
  // Args:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -925,11 +925,13 @@</span>
      __ z_bru(done);
  
      __ bind(static_method);
  
      // Lock the java mirror.
<span class="udiff-line-modified-removed">-     __ load_mirror(object, method);</span>
<span class="udiff-line-modified-added">+     // Load mirror from interpreter frame.</span>
<span class="udiff-line-added">+     __ z_lg(object, _z_ijava_state_neg(mirror), Z_fp);</span>
<span class="udiff-line-added">+ </span>
  #ifdef ASSERT
      {
        NearLabel L;
        __ compare64_and_branch(object, (intptr_t) 0, Assembler::bcondNotEqual, L);
        reentry = __ stop_chain_static(reentry, &quot;synchronization object is NULL&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -989,24 +991,24 @@</span>
  
    //=============================================================================
    // Allocate space for locals other than the parameters, the
    // interpreter state, monitors, and the expression stack.
  
<span class="udiff-line-modified-removed">-   const Register local_count     = Z_ARG5;</span>
<span class="udiff-line-modified-removed">-   const Register fp              = Z_tmp_2;</span>
<span class="udiff-line-modified-added">+   const Register local_count  = Z_ARG5;</span>
<span class="udiff-line-modified-added">+   const Register fp           = Z_tmp_2;</span>
<span class="udiff-line-added">+   const Register const_method = Z_ARG1;</span>
  
    BLOCK_COMMENT(&quot;generate_fixed_frame {&quot;);
<span class="udiff-line-removed">- </span>
    {
    // local registers
    const Register top_frame_size  = Z_ARG2;
    const Register sp_after_resize = Z_ARG3;
    const Register max_stack       = Z_ARG4;
  
<span class="udiff-line-modified-removed">-   // local_count = method-&gt;constMethod-&gt;max_locals();</span>
<span class="udiff-line-modified-removed">-   __ z_lg(Z_R1_scratch, Address(Z_method, Method::const_offset()));</span>
<span class="udiff-line-modified-removed">-   __ z_llgh(local_count, Address(Z_R1_scratch, ConstMethod::size_of_locals_offset()));</span>
<span class="udiff-line-modified-added">+   __ z_lg(const_method, Address(Z_method, Method::const_offset()));</span>
<span class="udiff-line-modified-added">+   __ z_llgh(max_stack, Address(const_method, ConstMethod::size_of_parameters_offset()));</span>
<span class="udiff-line-modified-added">+   __ z_sllg(Z_locals /*parameter_count bytes*/, max_stack /*parameter_count*/, LogBytesPerWord);</span>
  
    if (native_call) {
      // If we&#39;re calling a native method, we replace max_stack (which is
      // zero) with space for the worst-case signature handler varargs
      // vector, which is:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1022,13 +1024,10 @@</span>
      // still going to cut the stack back by the ABI register parameter
      // count so as to get SP+16 pointing at the ABI outgoing parameter
      // area, so we need to allocate at least that much even though we&#39;re
      // going to throw it away.
      //
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     __ z_lg(Z_R1_scratch, Address(Z_method, Method::const_offset()));</span>
<span class="udiff-line-removed">-     __ z_llgh(max_stack,  Address(Z_R1_scratch, ConstMethod::size_of_parameters_offset()));</span>
      __ add2reg(max_stack, 2);
  
      NearLabel passing_args_on_stack;
  
      // max_stack in bytes
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1040,18 +1039,18 @@</span>
      __ load_const_optimized(max_stack, argument_registers_in_bytes);
  
      __ bind(passing_args_on_stack);
    } else {
      // !native_call
<span class="udiff-line-modified-removed">-     __ z_lg(max_stack, method_(const));</span>
<span class="udiff-line-modified-added">+     // local_count = method-&gt;constMethod-&gt;max_locals();</span>
<span class="udiff-line-added">+     __ z_llgh(local_count, Address(const_method, ConstMethod::size_of_locals_offset()));</span>
  
      // Calculate number of non-parameter locals (in slots):
<span class="udiff-line-modified-removed">-     __ z_lg(Z_R1_scratch, Address(Z_method, Method::const_offset()));</span>
<span class="udiff-line-removed">-     __ z_sh(local_count, Address(Z_R1_scratch, ConstMethod::size_of_parameters_offset()));</span>
<span class="udiff-line-modified-added">+     __ z_sgr(local_count, max_stack);</span>
  
      // max_stack = method-&gt;max_stack();
<span class="udiff-line-modified-removed">-     __ z_llgh(max_stack, Address(max_stack, ConstMethod::max_stack_offset()));</span>
<span class="udiff-line-modified-added">+     __ z_llgh(max_stack, Address(const_method, ConstMethod::max_stack_offset()));</span>
      // max_stack in bytes
      __ z_sllg(max_stack, max_stack, LogBytesPerWord);
    }
  
    // Resize (i.e. normally shrink) the top frame F1 ...
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1087,26 +1086,27 @@</span>
    // sp_after_resize = Z_esp - delta
    //
    // delta = PARENT_IJAVA_FRAME_ABI + (locals_count - params_count)
  
    __ add2reg(sp_after_resize, (Interpreter::stackElementSize) - (frame::z_parent_ijava_frame_abi_size), Z_esp);
<span class="udiff-line-modified-removed">-   __ z_sllg(Z_R0_scratch, local_count, LogBytesPerWord); // Params have already been subtracted from local_count.</span>
<span class="udiff-line-modified-removed">-   __ z_slgr(sp_after_resize, Z_R0_scratch);</span>
<span class="udiff-line-modified-added">+   if (!native_call) {</span>
<span class="udiff-line-modified-added">+     __ z_sllg(Z_R0_scratch, local_count, LogBytesPerWord); // Params have already been subtracted from local_count.</span>
<span class="udiff-line-added">+     __ z_slgr(sp_after_resize, Z_R0_scratch);</span>
<span class="udiff-line-added">+   }</span>
  
    // top_frame_size = TOP_IJAVA_FRAME_ABI + max_stack + size of interpreter state
    __ add2reg(top_frame_size,
               frame::z_top_ijava_frame_abi_size +
<span class="udiff-line-modified-removed">-              frame::z_ijava_state_size +</span>
<span class="udiff-line-removed">-              frame::interpreter_frame_monitor_size() * wordSize,</span>
<span class="udiff-line-modified-added">+              frame::z_ijava_state_size,</span>
               max_stack);
  
    if (!native_call) {
      // Stack overflow check.
      // Native calls don&#39;t need the stack size check since they have no
      // expression stack and the arguments are already on the stack and
      // we only add a handful of words to the stack.
<span class="udiff-line-modified-removed">-     Register frame_size = max_stack; // Reuse the regiser for max_stack.</span>
<span class="udiff-line-modified-added">+     Register frame_size = max_stack; // Reuse the register for max_stack.</span>
      __ z_lgr(frame_size, Z_SP);
      __ z_sgr(frame_size, sp_after_resize);
      __ z_agr(frame_size, top_frame_size);
      generate_stack_overflow_check(frame_size, fp/*tmp1*/);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1134,30 +1134,25 @@</span>
    __ load_const_optimized(local_addr, frame::z_istate_magic_number);
    __ z_stg(local_addr, _z_ijava_state_neg(magic), fp);
  #endif
  
    // Save sender SP from F1 (i.e. before it was potentially modified by an
<span class="udiff-line-modified-removed">-   // adapter) into F0&#39;s interpreter state. We us it as well to revert</span>
<span class="udiff-line-modified-added">+   // adapter) into F0&#39;s interpreter state. We use it as well to revert</span>
    // resizing the frame above.
    __ z_stg(Z_R10, _z_ijava_state_neg(sender_sp), fp);
  
<span class="udiff-line-modified-removed">-   // Load cp cache and save it at the and of this block.</span>
<span class="udiff-line-modified-removed">-   __ z_lg(Z_R1_scratch, Address(Z_method,    Method::const_offset()));</span>
<span class="udiff-line-removed">-   __ z_lg(Z_R1_scratch, Address(Z_R1_scratch, ConstMethod::constants_offset()));</span>
<span class="udiff-line-modified-added">+   // Load cp cache and save it at the end of this block.</span>
<span class="udiff-line-modified-added">+   __ z_lg(Z_R1_scratch, Address(const_method, ConstMethod::constants_offset()));</span>
    __ z_lg(Z_R1_scratch, Address(Z_R1_scratch, ConstantPool::cache_offset_in_bytes()));
  
    // z_ijava_state-&gt;method = method;
    __ z_stg(Z_method, _z_ijava_state_neg(method), fp);
  
    // Point locals at the first argument. Method&#39;s locals are the
    // parameters on top of caller&#39;s expression stack.
    // Tos points past last Java argument.
  
<span class="udiff-line-removed">-   __ z_lg(Z_locals, Address(Z_method, Method::const_offset()));</span>
<span class="udiff-line-removed">-   __ z_llgh(Z_locals /*parameter_count words*/,</span>
<span class="udiff-line-removed">-             Address(Z_locals, ConstMethod::size_of_parameters_offset()));</span>
<span class="udiff-line-removed">-   __ z_sllg(Z_locals /*parameter_count bytes*/, Z_locals /*parameter_count*/, LogBytesPerWord);</span>
    __ z_agr(Z_locals, Z_esp);
    // z_ijava_state-&gt;locals - i*BytesPerWord points to i-th Java local (i starts at 0)
    // z_ijava_state-&gt;locals = Z_esp + parameter_count bytes
    __ z_stg(Z_locals, _z_ijava_state_neg(locals), fp);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1181,12 +1176,11 @@</span>
  
    // Initialize z_ijava_state-&gt;bcp and Z_bcp.
    if (native_call) {
      __ clear_reg(Z_bcp); // Must initialize. Will get written into frame where GC reads it.
    } else {
<span class="udiff-line-modified-removed">-     __ z_lg(Z_bcp, method_(const));</span>
<span class="udiff-line-removed">-     __ add2reg(Z_bcp, in_bytes(ConstMethod::codes_offset()));</span>
<span class="udiff-line-modified-added">+     __ add2reg(Z_bcp, in_bytes(ConstMethod::codes_offset()), const_method);</span>
    }
    __ z_stg(Z_bcp, _z_ijava_state_neg(bcp), fp);
  
    // no monitors and empty operand stack
    // =&gt; z_ijava_state-&gt;monitors points to the top slot in IJAVA_STATE.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1200,66 +1194,25 @@</span>
  
    // z_ijava_state-&gt;cpoolCache = Z_R1_scratch (see load above);
    __ z_stg(Z_R1_scratch, _z_ijava_state_neg(cpoolCache), fp);
  
    // Get mirror and store it in the frame as GC root for this Method*.
<span class="udiff-line-modified-removed">-   __ load_mirror(Z_R1_scratch, Z_method);</span>
<span class="udiff-line-modified-added">+   __ load_mirror_from_const_method(Z_R1_scratch, const_method);</span>
    __ z_stg(Z_R1_scratch, _z_ijava_state_neg(mirror), fp);
  
    BLOCK_COMMENT(&quot;} generate_fixed_frame: initialize interpreter state&quot;);
  
    //=============================================================================
    if (!native_call) {
<span class="udiff-line-removed">-     // Fill locals with 0x0s.</span>
<span class="udiff-line-removed">-     NearLabel locals_zeroed;</span>
<span class="udiff-line-removed">-     NearLabel doXC;</span>
<span class="udiff-line-removed">- </span>
      // Local_count is already num_locals_slots - num_param_slots.
<span class="udiff-line-modified-removed">-     __ compare64_and_branch(local_count, (intptr_t)0L, Assembler::bcondNotHigh, locals_zeroed);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     // Advance local_addr to point behind locals (creates positive incr. in loop).</span>
<span class="udiff-line-removed">-     __ z_lg(Z_R1_scratch, Address(Z_method, Method::const_offset()));</span>
<span class="udiff-line-removed">-     __ z_llgh(Z_R0_scratch, Address(Z_R1_scratch, ConstMethod::size_of_locals_offset()));</span>
<span class="udiff-line-removed">-     __ add2reg(Z_R0_scratch, -1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     __ z_lgr(local_addr/*locals*/, Z_locals);</span>
<span class="udiff-line-modified-added">+     // Start of locals: local_addr = Z_locals - locals size + 1 slot</span>
<span class="udiff-line-modified-added">+     __ z_llgh(Z_R0_scratch, Address(const_method, ConstMethod::size_of_locals_offset()));</span>
<span class="udiff-line-modified-added">+     __ add2reg(local_addr, BytesPerWord, Z_locals);</span>
      __ z_sllg(Z_R0_scratch, Z_R0_scratch, LogBytesPerWord);
<span class="udiff-line-removed">-     __ z_sllg(local_count, local_count, LogBytesPerWord); // Local_count are non param locals.</span>
      __ z_sgr(local_addr, Z_R0_scratch);
  
<span class="udiff-line-modified-removed">-     if (VM_Version::has_Prefetch()) {</span>
<span class="udiff-line-removed">-       __ z_pfd(0x02, 0, Z_R0, local_addr);</span>
<span class="udiff-line-removed">-       __ z_pfd(0x02, 256, Z_R0, local_addr);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Can&#39;t optimise for Z10 using &quot;compare and branch&quot; (immediate value is too big).</span>
<span class="udiff-line-removed">-     __ z_cghi(local_count, 256);</span>
<span class="udiff-line-removed">-     __ z_brnh(doXC);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // MVCLE: Initialize if quite a lot locals.</span>
<span class="udiff-line-removed">-     //  __ bind(doMVCLE);</span>
<span class="udiff-line-removed">-     __ z_lgr(Z_R0_scratch, local_addr);</span>
<span class="udiff-line-removed">-     __ z_lgr(Z_R1_scratch, local_count);</span>
<span class="udiff-line-removed">-     __ clear_reg(Z_ARG2);        // Src len of MVCLE is zero.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     __ MacroAssembler::move_long_ext(Z_R0_scratch, Z_ARG1, 0);</span>
<span class="udiff-line-removed">-     __ z_bru(locals_zeroed);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Label  XC_template;</span>
<span class="udiff-line-removed">-     __ bind(XC_template);</span>
<span class="udiff-line-removed">-     __ z_xc(0, 0, local_addr, 0, local_addr);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     __ bind(doXC);</span>
<span class="udiff-line-removed">-     __ z_bctgr(local_count, Z_R0);                  // Get #bytes-1 for EXECUTE.</span>
<span class="udiff-line-removed">-     if (VM_Version::has_ExecuteExtensions()) {</span>
<span class="udiff-line-removed">-       __ z_exrl(local_count, XC_template);          // Execute XC with variable length.</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       __ z_larl(Z_R1_scratch, XC_template);</span>
<span class="udiff-line-removed">-       __ z_ex(local_count, 0, Z_R0, Z_R1_scratch);  // Execute XC with variable length.</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     __ bind(locals_zeroed);</span>
<span class="udiff-line-modified-added">+     __ Clear_Array(local_count, local_addr, Z_ARG2);</span>
    }
  
    }
    // Finally set the frame pointer, destroying Z_method.
    assert(Z_fp == Z_method, &quot;maybe set Z_fp earlier if other register than Z_method&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1528,12 +1481,12 @@</span>
    // Pass mirror handle if static call.
    {
      Label method_is_not_static;
      __ testbit(method2_(Rmethod, access_flags), JVM_ACC_STATIC_BIT);
      __ z_bfalse(method_is_not_static);
<span class="udiff-line-modified-removed">-     // Get mirror.</span>
<span class="udiff-line-modified-removed">-     __ load_mirror(Z_R1, Rmethod);</span>
<span class="udiff-line-modified-added">+     // Load mirror from interpreter frame.</span>
<span class="udiff-line-modified-added">+     __ z_lg(Z_R1, _z_ijava_state_neg(mirror), Z_fp);</span>
      // z_ijava_state.oop_temp = pool_holder-&gt;klass_part()-&gt;java_mirror();
      __ z_stg(Z_R1, oop_tmp_offset, Z_fp);
      // Pass handle to mirror as 2nd argument to JNI method.
      __ add2reg(Z_ARG2, oop_tmp_offset, Z_fp);
      __ bind(method_is_not_static);
</pre>
<center><a href="stubGenerator_s390.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_s390.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
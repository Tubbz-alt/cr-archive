diff a/src/hotspot/cpu/s390/assembler_s390.hpp b/src/hotspot/cpu/s390/assembler_s390.hpp
--- a/src/hotspot/cpu/s390/assembler_s390.hpp
+++ b/src/hotspot/cpu/s390/assembler_s390.hpp
@@ -1,8 +1,8 @@
 /*
  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2016, 2017 SAP SE. All rights reserved.
+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -349,18 +349,10 @@
 
   AddressLiteral(intptr_t* addr, relocInfo::relocType rtype = relocInfo::none)
     : _address((address) addr),
       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 
-  AddressLiteral(oop addr, relocInfo::relocType rtype = relocInfo::none)
-    : _address((address) addr),
-      _rspec(rspec_from_rtype(rtype, (address) addr)) {}
-
-  AddressLiteral(oop* addr, relocInfo::relocType rtype = relocInfo::none)
-    : _address((address) addr),
-      _rspec(rspec_from_rtype(rtype, (address) addr)) {}
-
   AddressLiteral(float* addr, relocInfo::relocType rtype = relocInfo::none)
     : _address((address) addr),
       _rspec(rspec_from_rtype(rtype, (address) addr)) {}
 
   AddressLiteral(double* addr, relocInfo::relocType rtype = relocInfo::none)
@@ -388,11 +380,10 @@
     return external_word_Relocation::can_be_relocated(target) ? relocInfo::external_word_type : relocInfo::none;
   }
 
  public:
   ExternalAddress(address target) : AddressLiteral(target, reloc_for_target(          target)) {}
-  ExternalAddress(oop*    target) : AddressLiteral(target, reloc_for_target((address) target)) {}
 };
 
 // Argument is an abstraction used to represent an outgoing actual
 // argument or an incoming formal parameter, whether it resides in
 // memory or in a register, in a manner consistent with the
@@ -1529,20 +1520,20 @@
   //-----------------------------------------------
   // instruction property getter methods
   //-----------------------------------------------
 
   // Calculate length of instruction.
-  static int instr_len(unsigned char *instr);
+  static unsigned int instr_len(unsigned char *instr);
 
   // Longest instructions are 6 bytes on z/Architecture.
-  static int instr_maxlen() { return 6; }
+  static unsigned int instr_maxlen() { return 6; }
 
   // Average instruction is 4 bytes on z/Architecture (just a guess).
-  static int instr_avglen() { return 4; }
+  static unsigned int instr_avglen() { return 4; }
 
   // Shortest instructions are 2 bytes on z/Architecture.
-  static int instr_minlen() { return 2; }
+  static unsigned int instr_minlen() { return 2; }
 
   // Move instruction at pc right-justified into passed long int.
   // Return instr len in bytes as function result.
   static unsigned int get_instruction(unsigned char *pc, unsigned long *instr);
 

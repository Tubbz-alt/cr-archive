<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="x86_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../zero/assembler_zero.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 



  270 // Singleton class for RDI pointer register
  271 reg_class ptr_rdi_reg(RDI, RDI_H);
  272 
  273 // Singleton class for stack pointer
  274 reg_class ptr_rsp_reg(RSP, RSP_H);
  275 
  276 // Singleton class for TLS pointer
  277 reg_class ptr_r15_reg(R15, R15_H);
  278 
  279 // Singleton class for RAX long register
  280 reg_class long_rax_reg(RAX, RAX_H);
  281 
  282 // Singleton class for RCX long register
  283 reg_class long_rcx_reg(RCX, RCX_H);
  284 
  285 // Singleton class for RDX long register
  286 reg_class long_rdx_reg(RDX, RDX_H);
  287 
  288 // Singleton class for RAX int register
  289 reg_class int_rax_reg(RAX);
</pre>
<hr />
<pre>
  529 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  530   cbuf.insts()-&gt;emit_int64(d64);
  531 }
  532 
  533 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  534 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  535                     int d32,
  536                     relocInfo::relocType reloc,
  537                     int format)
  538 {
  539   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  540   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  541   cbuf.insts()-&gt;emit_int32(d32);
  542 }
  543 
  544 // emit 32 bit value and construct relocation entry from RelocationHolder
  545 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  546 #ifdef ASSERT
  547   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  548       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
<span class="line-modified">  549     assert(Universe::heap()-&gt;is_in_reserved((address)(intptr_t)d32), &quot;should be real oop&quot;);</span>
  550     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  551   }
  552 #endif
  553   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  554   cbuf.insts()-&gt;emit_int32(d32);
  555 }
  556 
  557 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  558   address next_ip = cbuf.insts_end() + 4;
  559   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  560                  external_word_Relocation::spec(addr),
  561                  RELOC_DISP32);
  562 }
  563 
  564 
  565 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  566 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  567   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  568   cbuf.insts()-&gt;emit_int64(d64);
  569 }
  570 
  571 // emit 64 bit value and construct relocation entry from RelocationHolder
  572 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  573 #ifdef ASSERT
  574   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  575       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
<span class="line-modified">  576     assert(Universe::heap()-&gt;is_in_reserved((address)d64), &quot;should be real oop&quot;);</span>
  577     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  578   }
  579 #endif
  580   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  581   cbuf.insts()-&gt;emit_int64(d64);
  582 }
  583 
  584 // Access stack slot for load or store
  585 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  586 {
  587   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  588   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  589     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  590     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  591     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  592   } else {
  593     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  594     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  595     emit_d32(cbuf, disp);     // Displacement // R/M byte
  596   }
</pre>
<hr />
<pre>
  857   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  860     st-&gt;print(&quot;\n\t&quot;);
  861     st-&gt;print(&quot;je      fast_entry\t&quot;);
  862     st-&gt;print(&quot;\n\t&quot;);
  863     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  864     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  865   }
  866   st-&gt;cr();
  867 }
  868 #endif
  869 
  870 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  871   Compile* C = ra_-&gt;C;
  872   MacroAssembler _masm(&amp;cbuf);
  873 
  874   int framesize = C-&gt;frame_size_in_bytes();
  875   int bangsize = C-&gt;bang_size_in_bytes();
  876 















  877   __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);
  878 
  879   C-&gt;set_frame_complete(cbuf.insts_size());
  880 
  881   if (C-&gt;has_mach_constant_base_node()) {
  882     // NOTE: We set the table base offset here because users might be
  883     // emitted before MachConstantBaseNode.
  884     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
  885     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  886   }
  887 }
  888 
  889 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
  890 {
  891   return MachNode::size(ra_); // too many variables; just compute it
  892                               // the hard way
  893 }
  894 
  895 int MachPrologNode::reloc() const
  896 {
</pre>
<hr />
<pre>
  901 #ifndef PRODUCT
  902 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  903 {
  904   Compile* C = ra_-&gt;C;
  905   if (generate_vzeroupper(C)) {
  906     st-&gt;print(&quot;vzeroupper&quot;);
  907     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  908   }
  909 
  910   int framesize = C-&gt;frame_size_in_bytes();
  911   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  912   // Remove word for return adr already pushed
  913   // and RBP
  914   framesize -= 2*wordSize;
  915 
  916   if (framesize) {
  917     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  918     st-&gt;print(&quot;\t&quot;);
  919   }
  920 
<span class="line-modified">  921   st-&gt;print_cr(&quot;popq   rbp&quot;);</span>
  922   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  923     st-&gt;print(&quot;\t&quot;);
  924     if (SafepointMechanism::uses_thread_local_poll()) {
<span class="line-modified">  925       st-&gt;print_cr(&quot;movq   rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;</span>
<span class="line-modified">  926                    &quot;testl  rax, [rscratch1]\t&quot;</span>
  927                    &quot;# Safepoint: poll for GC&quot;);
  928     } else if (Assembler::is_polling_page_far()) {
<span class="line-modified">  929       st-&gt;print_cr(&quot;movq   rscratch1, #polling_page_address\n\t&quot;</span>
<span class="line-modified">  930                    &quot;testl  rax, [rscratch1]\t&quot;</span>
  931                    &quot;# Safepoint: poll for GC&quot;);
  932     } else {
<span class="line-modified">  933       st-&gt;print_cr(&quot;testl  rax, [rip + #offset_to_poll_page]\t&quot;</span>
  934                    &quot;# Safepoint: poll for GC&quot;);
  935     }
  936   }
  937 }
  938 #endif
  939 
  940 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  941 {
  942   Compile* C = ra_-&gt;C;
  943   MacroAssembler _masm(&amp;cbuf);
  944 
  945   if (generate_vzeroupper(C)) {
  946     // Clear upper bits of YMM registers when current compiled code uses
  947     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  948     __ vzeroupper();
  949   }
  950 
  951   int framesize = C-&gt;frame_size_in_bytes();
  952   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  953   // Remove word for return adr already pushed
</pre>
<hr />
<pre>
 1026 };
 1027 
 1028 static enum RC rc_class(OptoReg::Name reg)
 1029 {
 1030   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1031 
 1032   if (OptoReg::is_stack(reg)) return rc_stack;
 1033 
 1034   VMReg r = OptoReg::as_VMReg(reg);
 1035 
 1036   if (r-&gt;is_Register()) return rc_int;
 1037 
 1038   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
 1039   return rc_float;
 1040 }
 1041 
 1042 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1043 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1044                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1045 
<span class="line-modified"> 1046 static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,</span>
<span class="line-modified"> 1047                             int stack_offset, int reg, uint ireg, outputStream* st);</span>
 1048 
 1049 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1050                                       int dst_offset, uint ireg, outputStream* st) {
 1051   if (cbuf) {
 1052     MacroAssembler _masm(cbuf);
 1053     switch (ireg) {
 1054     case Op_VecS:
 1055       __ movq(Address(rsp, -8), rax);
 1056       __ movl(rax, Address(rsp, src_offset));
 1057       __ movl(Address(rsp, dst_offset), rax);
 1058       __ movq(rax, Address(rsp, -8));
 1059       break;
 1060     case Op_VecD:
 1061       __ pushq(Address(rsp, src_offset));
 1062       __ popq (Address(rsp, dst_offset));
 1063       break;
 1064     case Op_VecX:
 1065       __ pushq(Address(rsp, src_offset));
 1066       __ popq (Address(rsp, dst_offset));
 1067       __ pushq(Address(rsp, src_offset+8));
</pre>
<hr />
<pre>
 1645 
 1646 bool Matcher::narrow_oop_use_complex_address() {
 1647   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1648   return (LogMinObjAlignmentInBytes &lt;= 3);
 1649 }
 1650 
 1651 bool Matcher::narrow_klass_use_complex_address() {
 1652   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1653   return (LogKlassAlignmentInBytes &lt;= 3);
 1654 }
 1655 
 1656 bool Matcher::const_oop_prefer_decode() {
 1657   // Prefer ConN+DecodeN over ConP.
 1658   return true;
 1659 }
 1660 
 1661 bool Matcher::const_klass_prefer_decode() {
 1662   // TODO: Either support matching DecodeNKlass (heap-based) in operand
 1663   //       or condisider the following:
 1664   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified"> 1665   //return Universe::narrow_klass_base() == NULL;</span>
 1666   return true;
 1667 }
 1668 
 1669 // Is it better to copy float constants, or load them directly from
 1670 // memory?  Intel can load a float constant from a direct address,
 1671 // requiring no extra registers.  Most RISCs will have to materialize
 1672 // an address into a register first, so they would do better to copy
 1673 // the constant from stack.
 1674 const bool Matcher::rematerialize_float_constants = true; // XXX
 1675 
 1676 // If CPU can load and store mis-aligned doubles directly then no
 1677 // fixup is needed.  Else we split the double into 2 integer pieces
 1678 // and move it piece-by-piece.  Only happens when passing doubles into
 1679 // C code as the Java calling convention forces doubles to be aligned.
 1680 const bool Matcher::misaligned_doubles_ok = true;
 1681 
 1682 // No-op on amd64
 1683 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1684 
<span class="line-modified"> 1685 // Advertise here if the CPU requires explicit rounding operations to</span>
<span class="line-modified"> 1686 // implement the UseStrictFP mode.</span>
<span class="line-removed"> 1687 const bool Matcher::strict_fp_requires_explicit_rounding = true;</span>
 1688 
 1689 // Are floats conerted to double when stored to stack during deoptimization?
 1690 // On x64 it is stored without convertion so we can use normal access.
 1691 bool Matcher::float_in_double() { return false; }
 1692 
 1693 // Do ints take an entire long register or just half?
 1694 const bool Matcher::int_in_long = true;
 1695 
 1696 // Return whether or not this register is ever used as an argument.
 1697 // This function is used on startup to build the trampoline stubs in
 1698 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1699 // call in the trampoline, and arguments in those registers not be
 1700 // available to the callee.
 1701 bool Matcher::can_be_java_arg(int reg)
 1702 {
 1703   return
 1704     reg ==  RDI_num || reg == RDI_H_num ||
 1705     reg ==  RSI_num || reg == RSI_H_num ||
 1706     reg ==  RDX_num || reg == RDX_H_num ||
 1707     reg ==  RCX_num || reg == RCX_H_num ||
</pre>
<hr />
<pre>
 3084 %{
 3085   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3086   match(ConL);
 3087 
 3088   op_cost(10);
 3089   format %{ %}
 3090   interface(CONST_INTER);
 3091 %}
 3092 
 3093 // Long Immediate 32-bit signed
 3094 operand immL32()
 3095 %{
 3096   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3097   match(ConL);
 3098 
 3099   op_cost(15);
 3100   format %{ %}
 3101   interface(CONST_INTER);
 3102 %}
 3103 




















 3104 // Long Immediate zero
 3105 operand immL0()
 3106 %{
 3107   predicate(n-&gt;get_long() == 0L);
 3108   match(ConL);
 3109 
 3110   op_cost(10);
 3111   format %{ %}
 3112   interface(CONST_INTER);
 3113 %}
 3114 
 3115 // Constant for increment
 3116 operand immL1()
 3117 %{
 3118   predicate(n-&gt;get_long() == 1);
 3119   match(ConL);
 3120 
 3121   format %{ %}
 3122   interface(CONST_INTER);
 3123 %}
</pre>
<hr />
<pre>
 3478 operand rbx_RegP()
 3479 %{
 3480   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3481   match(RegP);
 3482   match(rRegP);
 3483 
 3484   format %{ %}
 3485   interface(REG_INTER);
 3486 %}
 3487 
 3488 operand rsi_RegP()
 3489 %{
 3490   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3491   match(RegP);
 3492   match(rRegP);
 3493 
 3494   format %{ %}
 3495   interface(REG_INTER);
 3496 %}
 3497 










 3498 // Used in rep stosq
 3499 operand rdi_RegP()
 3500 %{
 3501   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3502   match(RegP);
 3503   match(rRegP);
 3504 
 3505   format %{ %}
 3506   interface(REG_INTER);
 3507 %}
 3508 
 3509 operand r15_RegP()
 3510 %{
 3511   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3512   match(RegP);
 3513   match(rRegP);
 3514 
 3515   format %{ %}
 3516   interface(REG_INTER);
 3517 %}
</pre>
<hr />
<pre>
 3655 %}
 3656 
 3657 // Double register operands
 3658 operand legRegD() %{
 3659    constraint(ALLOC_IN_RC(double_reg_legacy));
 3660    match(RegD);
 3661 
 3662    format %{ %}
 3663    interface(REG_INTER);
 3664 %}
 3665 
 3666 // Double register operands
 3667 operand vlRegD() %{
 3668    constraint(ALLOC_IN_RC(double_reg_vl));
 3669    match(RegD);
 3670 
 3671    format %{ %}
 3672    interface(REG_INTER);
 3673 %}
 3674 
<span class="line-removed"> 3675 // Vectors</span>
<span class="line-removed"> 3676 operand vecS() %{</span>
<span class="line-removed"> 3677   constraint(ALLOC_IN_RC(vectors_reg_vlbwdq));</span>
<span class="line-removed"> 3678   match(VecS);</span>
<span class="line-removed"> 3679 </span>
<span class="line-removed"> 3680   format %{ %}</span>
<span class="line-removed"> 3681   interface(REG_INTER);</span>
<span class="line-removed"> 3682 %}</span>
<span class="line-removed"> 3683 </span>
<span class="line-removed"> 3684 // Vectors</span>
<span class="line-removed"> 3685 operand legVecS() %{</span>
<span class="line-removed"> 3686   constraint(ALLOC_IN_RC(vectors_reg_legacy));</span>
<span class="line-removed"> 3687   match(VecS);</span>
<span class="line-removed"> 3688 </span>
<span class="line-removed"> 3689   format %{ %}</span>
<span class="line-removed"> 3690   interface(REG_INTER);</span>
<span class="line-removed"> 3691 %}</span>
<span class="line-removed"> 3692 </span>
<span class="line-removed"> 3693 operand vecD() %{</span>
<span class="line-removed"> 3694   constraint(ALLOC_IN_RC(vectord_reg_vlbwdq));</span>
<span class="line-removed"> 3695   match(VecD);</span>
<span class="line-removed"> 3696 </span>
<span class="line-removed"> 3697   format %{ %}</span>
<span class="line-removed"> 3698   interface(REG_INTER);</span>
<span class="line-removed"> 3699 %}</span>
<span class="line-removed"> 3700 </span>
<span class="line-removed"> 3701 operand legVecD() %{</span>
<span class="line-removed"> 3702   constraint(ALLOC_IN_RC(vectord_reg_legacy));</span>
<span class="line-removed"> 3703   match(VecD);</span>
<span class="line-removed"> 3704 </span>
<span class="line-removed"> 3705   format %{ %}</span>
<span class="line-removed"> 3706   interface(REG_INTER);</span>
<span class="line-removed"> 3707 %}</span>
<span class="line-removed"> 3708 </span>
<span class="line-removed"> 3709 operand vecX() %{</span>
<span class="line-removed"> 3710   constraint(ALLOC_IN_RC(vectorx_reg_vlbwdq));</span>
<span class="line-removed"> 3711   match(VecX);</span>
<span class="line-removed"> 3712 </span>
<span class="line-removed"> 3713   format %{ %}</span>
<span class="line-removed"> 3714   interface(REG_INTER);</span>
<span class="line-removed"> 3715 %}</span>
<span class="line-removed"> 3716 </span>
<span class="line-removed"> 3717 operand legVecX() %{</span>
<span class="line-removed"> 3718   constraint(ALLOC_IN_RC(vectorx_reg_legacy));</span>
<span class="line-removed"> 3719   match(VecX);</span>
<span class="line-removed"> 3720 </span>
<span class="line-removed"> 3721   format %{ %}</span>
<span class="line-removed"> 3722   interface(REG_INTER);</span>
<span class="line-removed"> 3723 %}</span>
<span class="line-removed"> 3724 </span>
<span class="line-removed"> 3725 operand vecY() %{</span>
<span class="line-removed"> 3726   constraint(ALLOC_IN_RC(vectory_reg_vlbwdq));</span>
<span class="line-removed"> 3727   match(VecY);</span>
<span class="line-removed"> 3728 </span>
<span class="line-removed"> 3729   format %{ %}</span>
<span class="line-removed"> 3730   interface(REG_INTER);</span>
<span class="line-removed"> 3731 %}</span>
<span class="line-removed"> 3732 </span>
<span class="line-removed"> 3733 operand legVecY() %{</span>
<span class="line-removed"> 3734   constraint(ALLOC_IN_RC(vectory_reg_legacy));</span>
<span class="line-removed"> 3735   match(VecY);</span>
<span class="line-removed"> 3736 </span>
<span class="line-removed"> 3737   format %{ %}</span>
<span class="line-removed"> 3738   interface(REG_INTER);</span>
<span class="line-removed"> 3739 %}</span>
<span class="line-removed"> 3740 </span>
 3741 //----------Memory Operands----------------------------------------------------
 3742 // Direct Memory Operand
 3743 // operand direct(immP addr)
 3744 // %{
 3745 //   match(addr);
 3746 
 3747 //   format %{ &quot;[$addr]&quot; %}
 3748 //   interface(MEMORY_INTER) %{
 3749 //     base(0xFFFFFFFF);
 3750 //     index(0x4);
 3751 //     scale(0x0);
 3752 //     disp($addr);
 3753 //   %}
 3754 // %}
 3755 
 3756 // Indirect Memory Operand
 3757 operand indirect(any_RegP reg)
 3758 %{
 3759   constraint(ALLOC_IN_RC(ptr_reg));
 3760   match(reg);
</pre>
<hr />
<pre>
 3897 
 3898 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3899 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3900 %{
 3901   constraint(ALLOC_IN_RC(ptr_reg));
 3902   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3903   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3904 
 3905   op_cost(10);
 3906   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3907   interface(MEMORY_INTER) %{
 3908     base($reg);
 3909     index($idx);
 3910     scale($scale);
 3911     disp($off);
 3912   %}
 3913 %}
 3914 
 3915 // Indirect Narrow Oop Plus Offset Operand
 3916 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
<span class="line-modified"> 3917 // we can&#39;t free r12 even with Universe::narrow_oop_base() == NULL.</span>
 3918 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
<span class="line-modified"> 3919   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() == Address::times_8));</span>
 3920   constraint(ALLOC_IN_RC(ptr_reg));
 3921   match(AddP (DecodeN reg) off);
 3922 
 3923   op_cost(10);
 3924   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3925   interface(MEMORY_INTER) %{
 3926     base(0xc); // R12
 3927     index($reg);
 3928     scale(0x3);
 3929     disp($off);
 3930   %}
 3931 %}
 3932 
 3933 // Indirect Memory Operand
 3934 operand indirectNarrow(rRegN reg)
 3935 %{
<span class="line-modified"> 3936   predicate(Universe::narrow_oop_shift() == 0);</span>
 3937   constraint(ALLOC_IN_RC(ptr_reg));
 3938   match(DecodeN reg);
 3939 
 3940   format %{ &quot;[$reg]&quot; %}
 3941   interface(MEMORY_INTER) %{
 3942     base($reg);
 3943     index(0x4);
 3944     scale(0x0);
 3945     disp(0x0);
 3946   %}
 3947 %}
 3948 
 3949 // Indirect Memory Plus Short Offset Operand
 3950 operand indOffset8Narrow(rRegN reg, immL8 off)
 3951 %{
<span class="line-modified"> 3952   predicate(Universe::narrow_oop_shift() == 0);</span>
 3953   constraint(ALLOC_IN_RC(ptr_reg));
 3954   match(AddP (DecodeN reg) off);
 3955 
 3956   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3957   interface(MEMORY_INTER) %{
 3958     base($reg);
 3959     index(0x4);
 3960     scale(0x0);
 3961     disp($off);
 3962   %}
 3963 %}
 3964 
 3965 // Indirect Memory Plus Long Offset Operand
 3966 operand indOffset32Narrow(rRegN reg, immL32 off)
 3967 %{
<span class="line-modified"> 3968   predicate(Universe::narrow_oop_shift() == 0);</span>
 3969   constraint(ALLOC_IN_RC(ptr_reg));
 3970   match(AddP (DecodeN reg) off);
 3971 
 3972   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3973   interface(MEMORY_INTER) %{
 3974     base($reg);
 3975     index(0x4);
 3976     scale(0x0);
 3977     disp($off);
 3978   %}
 3979 %}
 3980 
 3981 // Indirect Memory Plus Index Register Plus Offset Operand
 3982 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3983 %{
<span class="line-modified"> 3984   predicate(Universe::narrow_oop_shift() == 0);</span>
 3985   constraint(ALLOC_IN_RC(ptr_reg));
 3986   match(AddP (AddP (DecodeN reg) lreg) off);
 3987 
 3988   op_cost(10);
 3989   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3990   interface(MEMORY_INTER) %{
 3991     base($reg);
 3992     index($lreg);
 3993     scale(0x0);
 3994     disp($off);
 3995   %}
 3996 %}
 3997 
 3998 // Indirect Memory Plus Index Register Plus Offset Operand
 3999 operand indIndexNarrow(rRegN reg, rRegL lreg)
 4000 %{
<span class="line-modified"> 4001   predicate(Universe::narrow_oop_shift() == 0);</span>
 4002   constraint(ALLOC_IN_RC(ptr_reg));
 4003   match(AddP (DecodeN reg) lreg);
 4004 
 4005   op_cost(10);
 4006   format %{&quot;[$reg + $lreg]&quot; %}
 4007   interface(MEMORY_INTER) %{
 4008     base($reg);
 4009     index($lreg);
 4010     scale(0x0);
 4011     disp(0x0);
 4012   %}
 4013 %}
 4014 
 4015 // Indirect Memory Times Scale Plus Index Register
 4016 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 4017 %{
<span class="line-modified"> 4018   predicate(Universe::narrow_oop_shift() == 0);</span>
 4019   constraint(ALLOC_IN_RC(ptr_reg));
 4020   match(AddP (DecodeN reg) (LShiftL lreg scale));
 4021 
 4022   op_cost(10);
 4023   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 4024   interface(MEMORY_INTER) %{
 4025     base($reg);
 4026     index($lreg);
 4027     scale($scale);
 4028     disp(0x0);
 4029   %}
 4030 %}
 4031 
 4032 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4033 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 4034 %{
<span class="line-modified"> 4035   predicate(Universe::narrow_oop_shift() == 0);</span>
 4036   constraint(ALLOC_IN_RC(ptr_reg));
 4037   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 4038 
 4039   op_cost(10);
 4040   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 4041   interface(MEMORY_INTER) %{
 4042     base($reg);
 4043     index($lreg);
 4044     scale($scale);
 4045     disp($off);
 4046   %}
 4047 %}
 4048 
 4049 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 4050 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4051 %{
 4052   constraint(ALLOC_IN_RC(ptr_reg));
<span class="line-modified"> 4053   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);</span>
 4054   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4055 
 4056   op_cost(10);
 4057   format %{&quot;[$reg + $off + $idx]&quot; %}
 4058   interface(MEMORY_INTER) %{
 4059     base($reg);
 4060     index($idx);
 4061     scale(0x0);
 4062     disp($off);
 4063   %}
 4064 %}
 4065 
 4066 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4067 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4068 %{
 4069   constraint(ALLOC_IN_RC(ptr_reg));
<span class="line-modified"> 4070   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);</span>
 4071   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4072 
 4073   op_cost(10);
 4074   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4075   interface(MEMORY_INTER) %{
 4076     base($reg);
 4077     index($idx);
 4078     scale($scale);
 4079     disp($off);
 4080   %}
 4081 %}
 4082 
 4083 //----------Special Memory Operands--------------------------------------------
 4084 // Stack Slot Operand - This operand is used for loading and storing temporary
 4085 //                      values on the stack where a match requires a value to
 4086 //                      flow through memory.
 4087 operand stackSlotP(sRegP reg)
 4088 %{
 4089   constraint(ALLOC_IN_RC(stack_slots));
 4090   // No match rule because this operand is only generated in matching
</pre>
<hr />
<pre>
 4228 
 4229 
 4230 // Floating comparisons that can be fixed up with extra conditional jumps
 4231 operand cmpOpUCF2() %{
 4232   match(Bool);
 4233   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4234             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4235   format %{ &quot;&quot; %}
 4236   interface(COND_INTER) %{
 4237     equal(0x4, &quot;e&quot;);
 4238     not_equal(0x5, &quot;ne&quot;);
 4239     less(0x2, &quot;b&quot;);
 4240     greater_equal(0x3, &quot;nb&quot;);
 4241     less_equal(0x6, &quot;be&quot;);
 4242     greater(0x7, &quot;nbe&quot;);
 4243     overflow(0x0, &quot;o&quot;);
 4244     no_overflow(0x1, &quot;no&quot;);
 4245   %}
 4246 %}
 4247 
<span class="line-removed"> 4248 // Operands for bound floating pointer register arguments</span>
<span class="line-removed"> 4249 operand rxmm0() %{</span>
<span class="line-removed"> 4250   constraint(ALLOC_IN_RC(xmm0_reg));</span>
<span class="line-removed"> 4251   match(VecX);</span>
<span class="line-removed"> 4252   format%{%}</span>
<span class="line-removed"> 4253   interface(REG_INTER);</span>
<span class="line-removed"> 4254 %}</span>
<span class="line-removed"> 4255 operand rxmm1() %{</span>
<span class="line-removed"> 4256   constraint(ALLOC_IN_RC(xmm1_reg));</span>
<span class="line-removed"> 4257   match(VecX);</span>
<span class="line-removed"> 4258   format%{%}</span>
<span class="line-removed"> 4259   interface(REG_INTER);</span>
<span class="line-removed"> 4260 %}</span>
<span class="line-removed"> 4261 operand rxmm2() %{</span>
<span class="line-removed"> 4262   constraint(ALLOC_IN_RC(xmm2_reg));</span>
<span class="line-removed"> 4263   match(VecX);</span>
<span class="line-removed"> 4264   format%{%}</span>
<span class="line-removed"> 4265   interface(REG_INTER);</span>
<span class="line-removed"> 4266 %}</span>
<span class="line-removed"> 4267 operand rxmm3() %{</span>
<span class="line-removed"> 4268   constraint(ALLOC_IN_RC(xmm3_reg));</span>
<span class="line-removed"> 4269   match(VecX);</span>
<span class="line-removed"> 4270   format%{%}</span>
<span class="line-removed"> 4271   interface(REG_INTER);</span>
<span class="line-removed"> 4272 %}</span>
<span class="line-removed"> 4273 operand rxmm4() %{</span>
<span class="line-removed"> 4274   constraint(ALLOC_IN_RC(xmm4_reg));</span>
<span class="line-removed"> 4275   match(VecX);</span>
<span class="line-removed"> 4276   format%{%}</span>
<span class="line-removed"> 4277   interface(REG_INTER);</span>
<span class="line-removed"> 4278 %}</span>
<span class="line-removed"> 4279 operand rxmm5() %{</span>
<span class="line-removed"> 4280   constraint(ALLOC_IN_RC(xmm5_reg));</span>
<span class="line-removed"> 4281   match(VecX);</span>
<span class="line-removed"> 4282   format%{%}</span>
<span class="line-removed"> 4283   interface(REG_INTER);</span>
<span class="line-removed"> 4284 %}</span>
<span class="line-removed"> 4285 operand rxmm6() %{</span>
<span class="line-removed"> 4286   constraint(ALLOC_IN_RC(xmm6_reg));</span>
<span class="line-removed"> 4287   match(VecX);</span>
<span class="line-removed"> 4288   format%{%}</span>
<span class="line-removed"> 4289   interface(REG_INTER);</span>
<span class="line-removed"> 4290 %}</span>
<span class="line-removed"> 4291 operand rxmm7() %{</span>
<span class="line-removed"> 4292   constraint(ALLOC_IN_RC(xmm7_reg));</span>
<span class="line-removed"> 4293   match(VecX);</span>
<span class="line-removed"> 4294   format%{%}</span>
<span class="line-removed"> 4295   interface(REG_INTER);</span>
<span class="line-removed"> 4296 %}</span>
<span class="line-removed"> 4297 operand rxmm8() %{</span>
<span class="line-removed"> 4298   constraint(ALLOC_IN_RC(xmm8_reg));</span>
<span class="line-removed"> 4299   match(VecX);</span>
<span class="line-removed"> 4300   format%{%}</span>
<span class="line-removed"> 4301   interface(REG_INTER);</span>
<span class="line-removed"> 4302 %}</span>
<span class="line-removed"> 4303 operand rxmm9() %{</span>
<span class="line-removed"> 4304   constraint(ALLOC_IN_RC(xmm9_reg));</span>
<span class="line-removed"> 4305   match(VecX);</span>
<span class="line-removed"> 4306   format%{%}</span>
<span class="line-removed"> 4307   interface(REG_INTER);</span>
<span class="line-removed"> 4308 %}</span>
<span class="line-removed"> 4309 operand rxmm10() %{</span>
<span class="line-removed"> 4310   constraint(ALLOC_IN_RC(xmm10_reg));</span>
<span class="line-removed"> 4311   match(VecX);</span>
<span class="line-removed"> 4312   format%{%}</span>
<span class="line-removed"> 4313   interface(REG_INTER);</span>
<span class="line-removed"> 4314 %}</span>
<span class="line-removed"> 4315 operand rxmm11() %{</span>
<span class="line-removed"> 4316   constraint(ALLOC_IN_RC(xmm11_reg));</span>
<span class="line-removed"> 4317   match(VecX);</span>
<span class="line-removed"> 4318   format%{%}</span>
<span class="line-removed"> 4319   interface(REG_INTER);</span>
<span class="line-removed"> 4320 %}</span>
<span class="line-removed"> 4321 operand rxmm12() %{</span>
<span class="line-removed"> 4322   constraint(ALLOC_IN_RC(xmm12_reg));</span>
<span class="line-removed"> 4323   match(VecX);</span>
<span class="line-removed"> 4324   format%{%}</span>
<span class="line-removed"> 4325   interface(REG_INTER);</span>
<span class="line-removed"> 4326 %}</span>
<span class="line-removed"> 4327 operand rxmm13() %{</span>
<span class="line-removed"> 4328   constraint(ALLOC_IN_RC(xmm13_reg));</span>
<span class="line-removed"> 4329   match(VecX);</span>
<span class="line-removed"> 4330   format%{%}</span>
<span class="line-removed"> 4331   interface(REG_INTER);</span>
<span class="line-removed"> 4332 %}</span>
<span class="line-removed"> 4333 operand rxmm14() %{</span>
<span class="line-removed"> 4334   constraint(ALLOC_IN_RC(xmm14_reg));</span>
<span class="line-removed"> 4335   match(VecX);</span>
<span class="line-removed"> 4336   format%{%}</span>
<span class="line-removed"> 4337   interface(REG_INTER);</span>
<span class="line-removed"> 4338 %}</span>
<span class="line-removed"> 4339 operand rxmm15() %{</span>
<span class="line-removed"> 4340   constraint(ALLOC_IN_RC(xmm15_reg));</span>
<span class="line-removed"> 4341   match(VecX);</span>
<span class="line-removed"> 4342   format%{%}</span>
<span class="line-removed"> 4343   interface(REG_INTER);</span>
<span class="line-removed"> 4344 %}</span>
<span class="line-removed"> 4345 operand rxmm16() %{</span>
<span class="line-removed"> 4346   constraint(ALLOC_IN_RC(xmm16_reg));</span>
<span class="line-removed"> 4347   match(VecX);</span>
<span class="line-removed"> 4348   format%{%}</span>
<span class="line-removed"> 4349   interface(REG_INTER);</span>
<span class="line-removed"> 4350 %}</span>
<span class="line-removed"> 4351 operand rxmm17() %{</span>
<span class="line-removed"> 4352   constraint(ALLOC_IN_RC(xmm17_reg));</span>
<span class="line-removed"> 4353   match(VecX);</span>
<span class="line-removed"> 4354   format%{%}</span>
<span class="line-removed"> 4355   interface(REG_INTER);</span>
<span class="line-removed"> 4356 %}</span>
<span class="line-removed"> 4357 operand rxmm18() %{</span>
<span class="line-removed"> 4358   constraint(ALLOC_IN_RC(xmm18_reg));</span>
<span class="line-removed"> 4359   match(VecX);</span>
<span class="line-removed"> 4360   format%{%}</span>
<span class="line-removed"> 4361   interface(REG_INTER);</span>
<span class="line-removed"> 4362 %}</span>
<span class="line-removed"> 4363 operand rxmm19() %{</span>
<span class="line-removed"> 4364   constraint(ALLOC_IN_RC(xmm19_reg));</span>
<span class="line-removed"> 4365   match(VecX);</span>
<span class="line-removed"> 4366   format%{%}</span>
<span class="line-removed"> 4367   interface(REG_INTER);</span>
<span class="line-removed"> 4368 %}</span>
<span class="line-removed"> 4369 operand rxmm20() %{</span>
<span class="line-removed"> 4370   constraint(ALLOC_IN_RC(xmm20_reg));</span>
<span class="line-removed"> 4371   match(VecX);</span>
<span class="line-removed"> 4372   format%{%}</span>
<span class="line-removed"> 4373   interface(REG_INTER);</span>
<span class="line-removed"> 4374 %}</span>
<span class="line-removed"> 4375 operand rxmm21() %{</span>
<span class="line-removed"> 4376   constraint(ALLOC_IN_RC(xmm21_reg));</span>
<span class="line-removed"> 4377   match(VecX);</span>
<span class="line-removed"> 4378   format%{%}</span>
<span class="line-removed"> 4379   interface(REG_INTER);</span>
<span class="line-removed"> 4380 %}</span>
<span class="line-removed"> 4381 operand rxmm22() %{</span>
<span class="line-removed"> 4382   constraint(ALLOC_IN_RC(xmm22_reg));</span>
<span class="line-removed"> 4383   match(VecX);</span>
<span class="line-removed"> 4384   format%{%}</span>
<span class="line-removed"> 4385   interface(REG_INTER);</span>
<span class="line-removed"> 4386 %}</span>
<span class="line-removed"> 4387 operand rxmm23() %{</span>
<span class="line-removed"> 4388   constraint(ALLOC_IN_RC(xmm23_reg));</span>
<span class="line-removed"> 4389   match(VecX);</span>
<span class="line-removed"> 4390   format%{%}</span>
<span class="line-removed"> 4391   interface(REG_INTER);</span>
<span class="line-removed"> 4392 %}</span>
<span class="line-removed"> 4393 operand rxmm24() %{</span>
<span class="line-removed"> 4394   constraint(ALLOC_IN_RC(xmm24_reg));</span>
<span class="line-removed"> 4395   match(VecX);</span>
<span class="line-removed"> 4396   format%{%}</span>
<span class="line-removed"> 4397   interface(REG_INTER);</span>
<span class="line-removed"> 4398 %}</span>
<span class="line-removed"> 4399 operand rxmm25() %{</span>
<span class="line-removed"> 4400   constraint(ALLOC_IN_RC(xmm25_reg));</span>
<span class="line-removed"> 4401   match(VecX);</span>
<span class="line-removed"> 4402   format%{%}</span>
<span class="line-removed"> 4403   interface(REG_INTER);</span>
<span class="line-removed"> 4404 %}</span>
<span class="line-removed"> 4405 operand rxmm26() %{</span>
<span class="line-removed"> 4406   constraint(ALLOC_IN_RC(xmm26_reg));</span>
<span class="line-removed"> 4407   match(VecX);</span>
<span class="line-removed"> 4408   format%{%}</span>
<span class="line-removed"> 4409   interface(REG_INTER);</span>
<span class="line-removed"> 4410 %}</span>
<span class="line-removed"> 4411 operand rxmm27() %{</span>
<span class="line-removed"> 4412   constraint(ALLOC_IN_RC(xmm27_reg));</span>
<span class="line-removed"> 4413   match(VecX);</span>
<span class="line-removed"> 4414   format%{%}</span>
<span class="line-removed"> 4415   interface(REG_INTER);</span>
<span class="line-removed"> 4416 %}</span>
<span class="line-removed"> 4417 operand rxmm28() %{</span>
<span class="line-removed"> 4418   constraint(ALLOC_IN_RC(xmm28_reg));</span>
<span class="line-removed"> 4419   match(VecX);</span>
<span class="line-removed"> 4420   format%{%}</span>
<span class="line-removed"> 4421   interface(REG_INTER);</span>
<span class="line-removed"> 4422 %}</span>
<span class="line-removed"> 4423 operand rxmm29() %{</span>
<span class="line-removed"> 4424   constraint(ALLOC_IN_RC(xmm29_reg));</span>
<span class="line-removed"> 4425   match(VecX);</span>
<span class="line-removed"> 4426   format%{%}</span>
<span class="line-removed"> 4427   interface(REG_INTER);</span>
<span class="line-removed"> 4428 %}</span>
<span class="line-removed"> 4429 operand rxmm30() %{</span>
<span class="line-removed"> 4430   constraint(ALLOC_IN_RC(xmm30_reg));</span>
<span class="line-removed"> 4431   match(VecX);</span>
<span class="line-removed"> 4432   format%{%}</span>
<span class="line-removed"> 4433   interface(REG_INTER);</span>
<span class="line-removed"> 4434 %}</span>
<span class="line-removed"> 4435 operand rxmm31() %{</span>
<span class="line-removed"> 4436   constraint(ALLOC_IN_RC(xmm31_reg));</span>
<span class="line-removed"> 4437   match(VecX);</span>
<span class="line-removed"> 4438   format%{%}</span>
<span class="line-removed"> 4439   interface(REG_INTER);</span>
<span class="line-removed"> 4440 %}</span>
<span class="line-removed"> 4441 </span>
 4442 //----------OPERAND CLASSES----------------------------------------------------
 4443 // Operand Classes are groups of operands that are used as to simplify
 4444 // instruction definitions by not requiring the AD writer to specify separate
 4445 // instructions for every form of operand when the instruction accepts
 4446 // multiple operand types with the same basic encoding and format.  The classic
 4447 // case of this is memory operands.
 4448 
 4449 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4450                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
 4451                indCompressedOopOffset,
 4452                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4453                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4454                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4455 
 4456 //----------PIPELINE-----------------------------------------------------------
 4457 // Rules which define the behavior of the target architectures pipeline.
 4458 pipeline %{
 4459 
 4460 //----------ATTRIBUTES---------------------------------------------------------
 4461 attributes %{
</pre>
<hr />
<pre>
 5314 
 5315   ins_pipe(ialu_reg_mem); // XXX
 5316 %}
 5317 
 5318 // Load Range
 5319 instruct loadRange(rRegI dst, memory mem)
 5320 %{
 5321   match(Set dst (LoadRange mem));
 5322 
 5323   ins_cost(125); // XXX
 5324   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5325   opcode(0x8B);
 5326   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5327   ins_pipe(ialu_reg_mem);
 5328 %}
 5329 
 5330 // Load Pointer
 5331 instruct loadP(rRegP dst, memory mem)
 5332 %{
 5333   match(Set dst (LoadP mem));

 5334 
 5335   ins_cost(125); // XXX
 5336   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5337   opcode(0x8B);
 5338   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5339   ins_pipe(ialu_reg_mem); // XXX
 5340 %}
 5341 
 5342 // Load Compressed Pointer
 5343 instruct loadN(rRegN dst, memory mem)
 5344 %{
 5345    match(Set dst (LoadN mem));
 5346 
 5347    ins_cost(125); // XXX
 5348    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5349    ins_encode %{
 5350      __ movl($dst$$Register, $mem$$Address);
 5351    %}
 5352    ins_pipe(ialu_reg_mem); // XXX
 5353 %}
</pre>
<hr />
<pre>
 5511   match(Set dst (MaxF a b));
 5512   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5513   format %{
 5514      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5515      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5516      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5517      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5518      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5519   %}
 5520   ins_encode %{
 5521     int vector_len = Assembler::AVX_128bit;
 5522     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5523     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5524     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5525     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5526     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5527  %}
 5528   ins_pipe( pipe_slow );
 5529 %}
 5530 
<span class="line-modified"> 5531 instruct maxF_reduction_reg(regF dst, regF a, regF b, regF xmmt, rRegI tmp, rFlagsReg cr) %{</span>
 5532   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5533   match(Set dst (MaxF a b));
 5534   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5535 
 5536   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5537   ins_encode %{
 5538     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5539                     false /*min*/, true /*single*/);
 5540   %}
 5541   ins_pipe( pipe_slow );
 5542 %}
 5543 
 5544 // max = java.lang.Math.max(double a, double b)
 5545 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5546   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5547   match(Set dst (MaxD a b));
 5548   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5549   format %{
 5550      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5551      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5552      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5553      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5554      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5555   %}
 5556   ins_encode %{
 5557     int vector_len = Assembler::AVX_128bit;
 5558     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5559     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5560     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5561     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5562     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5563   %}
 5564   ins_pipe( pipe_slow );
 5565 %}
 5566 
<span class="line-modified"> 5567 instruct maxD_reduction_reg(regD dst, regD a, regD b, regD xmmt, rRegL tmp, rFlagsReg cr) %{</span>
 5568   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5569   match(Set dst (MaxD a b));
 5570   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5571 
 5572   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5573   ins_encode %{
 5574     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5575                     false /*min*/, false /*single*/);
 5576   %}
 5577   ins_pipe( pipe_slow );
 5578 %}
 5579 
 5580 // min = java.lang.Math.min(float a, float b)
 5581 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5582   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5583   match(Set dst (MinF a b));
 5584   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5585   format %{
 5586      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5587      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5588      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5589      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5590      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5591   %}
 5592   ins_encode %{
 5593     int vector_len = Assembler::AVX_128bit;
 5594     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5595     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5596     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5597     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5598     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5599   %}
 5600   ins_pipe( pipe_slow );
 5601 %}
 5602 
<span class="line-modified"> 5603 instruct minF_reduction_reg(regF dst, regF a, regF b, regF xmmt, rRegI tmp, rFlagsReg cr) %{</span>
 5604   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5605   match(Set dst (MinF a b));
 5606   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5607 
 5608   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5609   ins_encode %{
 5610     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5611                     true /*min*/, true /*single*/);
 5612   %}
 5613   ins_pipe( pipe_slow );
 5614 %}
 5615 
 5616 // min = java.lang.Math.min(double a, double b)
 5617 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5618   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5619   match(Set dst (MinD a b));
 5620   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5621   format %{
 5622      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5623      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5624      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5625      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5626      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5627   %}
 5628   ins_encode %{
 5629     int vector_len = Assembler::AVX_128bit;
 5630     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5631     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5632     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5633     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5634     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5635   %}
 5636   ins_pipe( pipe_slow );
 5637 %}
 5638 
<span class="line-modified"> 5639 instruct minD_reduction_reg(regD dst, regD a, regD b, regD xmmt, rRegL tmp, rFlagsReg cr) %{</span>
 5640   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5641   match(Set dst (MinD a b));
 5642   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5643 
 5644   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5645   ins_encode %{
 5646     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5647                     true /*min*/, false /*single*/);
 5648   %}
 5649   ins_pipe( pipe_slow );
 5650 %}
 5651 
 5652 // Load Effective Address
 5653 instruct leaP8(rRegP dst, indOffset8 mem)
 5654 %{
 5655   match(Set dst mem);
 5656 
 5657   ins_cost(110); // XXX
 5658   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5659   opcode(0x8D);
</pre>
<hr />
<pre>
 5735   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5736   opcode(0x8D);
 5737   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5738   ins_pipe(ialu_reg_reg_fat);
 5739 %}
 5740 
 5741 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5742 %{
 5743   match(Set dst mem);
 5744 
 5745   ins_cost(110);
 5746   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5747   opcode(0x8D);
 5748   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5749   ins_pipe(ialu_reg_reg_fat);
 5750 %}
 5751 
 5752 // Load Effective Address which uses Narrow (32-bits) oop
 5753 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5754 %{
<span class="line-modified"> 5755   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() != 0));</span>
 5756   match(Set dst mem);
 5757 
 5758   ins_cost(110);
 5759   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5760   opcode(0x8D);
 5761   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5762   ins_pipe(ialu_reg_reg_fat);
 5763 %}
 5764 
 5765 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5766 %{
<span class="line-modified"> 5767   predicate(Universe::narrow_oop_shift() == 0);</span>
 5768   match(Set dst mem);
 5769 
 5770   ins_cost(110); // XXX
 5771   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5772   opcode(0x8D);
 5773   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5774   ins_pipe(ialu_reg_reg_fat);
 5775 %}
 5776 
 5777 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5778 %{
<span class="line-modified"> 5779   predicate(Universe::narrow_oop_shift() == 0);</span>
 5780   match(Set dst mem);
 5781 
 5782   ins_cost(110);
 5783   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5784   opcode(0x8D);
 5785   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5786   ins_pipe(ialu_reg_reg_fat);
 5787 %}
 5788 
 5789 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5790 %{
<span class="line-modified"> 5791   predicate(Universe::narrow_oop_shift() == 0);</span>
 5792   match(Set dst mem);
 5793 
 5794   ins_cost(110);
 5795   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5796   opcode(0x8D);
 5797   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5798   ins_pipe(ialu_reg_reg_fat);
 5799 %}
 5800 
 5801 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5802 %{
<span class="line-modified"> 5803   predicate(Universe::narrow_oop_shift() == 0);</span>
 5804   match(Set dst mem);
 5805 
 5806   ins_cost(110);
 5807   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5808   opcode(0x8D);
 5809   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5810   ins_pipe(ialu_reg_reg_fat);
 5811 %}
 5812 
 5813 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5814 %{
<span class="line-modified"> 5815   predicate(Universe::narrow_oop_shift() == 0);</span>
 5816   match(Set dst mem);
 5817 
 5818   ins_cost(110);
 5819   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5820   opcode(0x8D);
 5821   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5822   ins_pipe(ialu_reg_reg_fat);
 5823 %}
 5824 
 5825 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5826 %{
<span class="line-modified"> 5827   predicate(Universe::narrow_oop_shift() == 0);</span>
 5828   match(Set dst mem);
 5829 
 5830   ins_cost(110);
 5831   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5832   opcode(0x8D);
 5833   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5834   ins_pipe(ialu_reg_reg_fat);
 5835 %}
 5836 
 5837 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5838 %{
<span class="line-modified"> 5839   predicate(Universe::narrow_oop_shift() == 0);</span>
 5840   match(Set dst mem);
 5841 
 5842   ins_cost(110);
 5843   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5844   opcode(0x8D);
 5845   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5846   ins_pipe(ialu_reg_reg_fat);
 5847 %}
 5848 
 5849 instruct loadConI(rRegI dst, immI src)
 5850 %{
 5851   match(Set dst src);
 5852 
 5853   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5854   ins_encode(load_immI(dst, src));
 5855   ins_pipe(ialu_reg_fat); // XXX
 5856 %}
 5857 
 5858 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5859 %{
</pre>
<hr />
<pre>
 6183   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6184   opcode(0x89);
 6185   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 6186   ins_pipe(ialu_mem_reg); // XXX
 6187 %}
 6188 
 6189 // Store Pointer
 6190 instruct storeP(memory mem, any_RegP src)
 6191 %{
 6192   match(Set mem (StoreP mem src));
 6193 
 6194   ins_cost(125); // XXX
 6195   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 6196   opcode(0x89);
 6197   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 6198   ins_pipe(ialu_mem_reg);
 6199 %}
 6200 
 6201 instruct storeImmP0(memory mem, immP0 zero)
 6202 %{
<span class="line-modified"> 6203   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6204   match(Set mem (StoreP mem zero));
 6205 
 6206   ins_cost(125); // XXX
 6207   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 6208   ins_encode %{
 6209     __ movq($mem$$Address, r12);
 6210   %}
 6211   ins_pipe(ialu_mem_reg);
 6212 %}
 6213 
 6214 // Store NULL Pointer, mark word, or other simple pointer constant.
 6215 instruct storeImmP(memory mem, immP31 src)
 6216 %{
 6217   match(Set mem (StoreP mem src));
 6218 
 6219   ins_cost(150); // XXX
 6220   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 6221   opcode(0xC7); /* C7 /0 */
 6222   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6223   ins_pipe(ialu_mem_imm);
</pre>
<hr />
<pre>
 6233   ins_encode %{
 6234     __ movl($mem$$Address, $src$$Register);
 6235   %}
 6236   ins_pipe(ialu_mem_reg);
 6237 %}
 6238 
 6239 instruct storeNKlass(memory mem, rRegN src)
 6240 %{
 6241   match(Set mem (StoreNKlass mem src));
 6242 
 6243   ins_cost(125); // XXX
 6244   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6245   ins_encode %{
 6246     __ movl($mem$$Address, $src$$Register);
 6247   %}
 6248   ins_pipe(ialu_mem_reg);
 6249 %}
 6250 
 6251 instruct storeImmN0(memory mem, immN0 zero)
 6252 %{
<span class="line-modified"> 6253   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_klass_base() == NULL);</span>
 6254   match(Set mem (StoreN mem zero));
 6255 
 6256   ins_cost(125); // XXX
 6257   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6258   ins_encode %{
 6259     __ movl($mem$$Address, r12);
 6260   %}
 6261   ins_pipe(ialu_mem_reg);
 6262 %}
 6263 
 6264 instruct storeImmN(memory mem, immN src)
 6265 %{
 6266   match(Set mem (StoreN mem src));
 6267 
 6268   ins_cost(150); // XXX
 6269   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6270   ins_encode %{
 6271     address con = (address)$src$$constant;
 6272     if (con == NULL) {
 6273       __ movl($mem$$Address, (int32_t)0);
</pre>
<hr />
<pre>
 6276     }
 6277   %}
 6278   ins_pipe(ialu_mem_imm);
 6279 %}
 6280 
 6281 instruct storeImmNKlass(memory mem, immNKlass src)
 6282 %{
 6283   match(Set mem (StoreNKlass mem src));
 6284 
 6285   ins_cost(150); // XXX
 6286   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6287   ins_encode %{
 6288     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6289   %}
 6290   ins_pipe(ialu_mem_imm);
 6291 %}
 6292 
 6293 // Store Integer Immediate
 6294 instruct storeImmI0(memory mem, immI0 zero)
 6295 %{
<span class="line-modified"> 6296   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6297   match(Set mem (StoreI mem zero));
 6298 
 6299   ins_cost(125); // XXX
 6300   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6301   ins_encode %{
 6302     __ movl($mem$$Address, r12);
 6303   %}
 6304   ins_pipe(ialu_mem_reg);
 6305 %}
 6306 
 6307 instruct storeImmI(memory mem, immI src)
 6308 %{
 6309   match(Set mem (StoreI mem src));
 6310 
 6311   ins_cost(150);
 6312   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6313   opcode(0xC7); /* C7 /0 */
 6314   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6315   ins_pipe(ialu_mem_imm);
 6316 %}
 6317 
 6318 // Store Long Immediate
 6319 instruct storeImmL0(memory mem, immL0 zero)
 6320 %{
<span class="line-modified"> 6321   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6322   match(Set mem (StoreL mem zero));
 6323 
 6324   ins_cost(125); // XXX
 6325   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6326   ins_encode %{
 6327     __ movq($mem$$Address, r12);
 6328   %}
 6329   ins_pipe(ialu_mem_reg);
 6330 %}
 6331 
 6332 instruct storeImmL(memory mem, immL32 src)
 6333 %{
 6334   match(Set mem (StoreL mem src));
 6335 
 6336   ins_cost(150);
 6337   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6338   opcode(0xC7); /* C7 /0 */
 6339   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6340   ins_pipe(ialu_mem_imm);
 6341 %}
 6342 
 6343 // Store Short/Char Immediate
 6344 instruct storeImmC0(memory mem, immI0 zero)
 6345 %{
<span class="line-modified"> 6346   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6347   match(Set mem (StoreC mem zero));
 6348 
 6349   ins_cost(125); // XXX
 6350   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6351   ins_encode %{
 6352     __ movw($mem$$Address, r12);
 6353   %}
 6354   ins_pipe(ialu_mem_reg);
 6355 %}
 6356 
 6357 instruct storeImmI16(memory mem, immI16 src)
 6358 %{
 6359   predicate(UseStoreImmI16);
 6360   match(Set mem (StoreC mem src));
 6361 
 6362   ins_cost(150);
 6363   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6364   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6365   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6366   ins_pipe(ialu_mem_imm);
 6367 %}
 6368 
 6369 // Store Byte Immediate
 6370 instruct storeImmB0(memory mem, immI0 zero)
 6371 %{
<span class="line-modified"> 6372   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6373   match(Set mem (StoreB mem zero));
 6374 
 6375   ins_cost(125); // XXX
 6376   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6377   ins_encode %{
 6378     __ movb($mem$$Address, r12);
 6379   %}
 6380   ins_pipe(ialu_mem_reg);
 6381 %}
 6382 
 6383 instruct storeImmB(memory mem, immI8 src)
 6384 %{
 6385   match(Set mem (StoreB mem src));
 6386 
 6387   ins_cost(150); // XXX
 6388   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6389   opcode(0xC6); /* C6 /0 */
 6390   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6391   ins_pipe(ialu_mem_imm);
 6392 %}
 6393 
 6394 // Store CMS card-mark Immediate
 6395 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6396 %{
<span class="line-modified"> 6397   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6398   match(Set mem (StoreCM mem zero));
 6399 
 6400   ins_cost(125); // XXX
 6401   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6402   ins_encode %{
 6403     __ movb($mem$$Address, r12);
 6404   %}
 6405   ins_pipe(ialu_mem_reg);
 6406 %}
 6407 
 6408 instruct storeImmCM0(memory mem, immI0 src)
 6409 %{
 6410   match(Set mem (StoreCM mem src));
 6411 
 6412   ins_cost(150); // XXX
 6413   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6414   opcode(0xC6); /* C6 /0 */
 6415   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6416   ins_pipe(ialu_mem_imm);
 6417 %}
 6418 
 6419 // Store Float
 6420 instruct storeF(memory mem, regF src)
 6421 %{
 6422   match(Set mem (StoreF mem src));
 6423 
 6424   ins_cost(95); // XXX
 6425   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6426   ins_encode %{
 6427     __ movflt($mem$$Address, $src$$XMMRegister);
 6428   %}
 6429   ins_pipe(pipe_slow); // XXX
 6430 %}
 6431 
 6432 // Store immediate Float value (it is faster than store from XMM register)
 6433 instruct storeF0(memory mem, immF0 zero)
 6434 %{
<span class="line-modified"> 6435   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6436   match(Set mem (StoreF mem zero));
 6437 
 6438   ins_cost(25); // XXX
 6439   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6440   ins_encode %{
 6441     __ movl($mem$$Address, r12);
 6442   %}
 6443   ins_pipe(ialu_mem_reg);
 6444 %}
 6445 
 6446 instruct storeF_imm(memory mem, immF src)
 6447 %{
 6448   match(Set mem (StoreF mem src));
 6449 
 6450   ins_cost(50);
 6451   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6452   opcode(0xC7); /* C7 /0 */
 6453   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6454   ins_pipe(ialu_mem_imm);
 6455 %}
 6456 
 6457 // Store Double
 6458 instruct storeD(memory mem, regD src)
 6459 %{
 6460   match(Set mem (StoreD mem src));
 6461 
 6462   ins_cost(95); // XXX
 6463   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6464   ins_encode %{
 6465     __ movdbl($mem$$Address, $src$$XMMRegister);
 6466   %}
 6467   ins_pipe(pipe_slow); // XXX
 6468 %}
 6469 
 6470 // Store immediate double 0.0 (it is faster than store from XMM register)
 6471 instruct storeD0_imm(memory mem, immD0 src)
 6472 %{
<span class="line-modified"> 6473   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));</span>
 6474   match(Set mem (StoreD mem src));
 6475 
 6476   ins_cost(50);
 6477   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6478   opcode(0xC7); /* C7 /0 */
 6479   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6480   ins_pipe(ialu_mem_imm);
 6481 %}
 6482 
 6483 instruct storeD0(memory mem, immD0 zero)
 6484 %{
<span class="line-modified"> 6485   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6486   match(Set mem (StoreD mem zero));
 6487 
 6488   ins_cost(25); // XXX
 6489   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6490   ins_encode %{
 6491     __ movq($mem$$Address, r12);
 6492   %}
 6493   ins_pipe(ialu_mem_reg);
 6494 %}
 6495 
 6496 instruct storeSSI(stackSlotI dst, rRegI src)
 6497 %{
 6498   match(Set dst src);
 6499 
 6500   ins_cost(100);
 6501   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6502   opcode(0x89);
 6503   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6504   ins_pipe( ialu_mem_reg );
 6505 %}
</pre>
<hr />
<pre>
 6533   ins_cost(95); // XXX
 6534   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6535   ins_encode %{
 6536     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6537   %}
 6538   ins_pipe(pipe_slow); // XXX
 6539 %}
 6540 
 6541 instruct storeSSD(stackSlotD dst, regD src)
 6542 %{
 6543   match(Set dst src);
 6544 
 6545   ins_cost(95); // XXX
 6546   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6547   ins_encode %{
 6548     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6549   %}
 6550   ins_pipe(pipe_slow); // XXX
 6551 %}
 6552 









































 6553 //----------BSWAP Instructions-------------------------------------------------
 6554 instruct bytes_reverse_int(rRegI dst) %{
 6555   match(Set dst (ReverseBytesI dst));
 6556 
 6557   format %{ &quot;bswapl  $dst&quot; %}
 6558   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6559   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6560   ins_pipe( ialu_reg );
 6561 %}
 6562 
 6563 instruct bytes_reverse_long(rRegL dst) %{
 6564   match(Set dst (ReverseBytesL dst));
 6565 
 6566   format %{ &quot;bswapq  $dst&quot; %}
 6567   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6568   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6569   ins_pipe( ialu_reg);
 6570 %}
 6571 
 6572 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
</pre>
<hr />
<pre>
 6902   %}
 6903   ins_pipe(ialu_reg_reg); // XXX
 6904 %}
 6905 
 6906 // Convert oop into int for vectors alignment masking
 6907 instruct convP2I(rRegI dst, rRegP src)
 6908 %{
 6909   match(Set dst (ConvL2I (CastP2X src)));
 6910 
 6911   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6912   ins_encode %{
 6913     __ movl($dst$$Register, $src$$Register);
 6914   %}
 6915   ins_pipe(ialu_reg_reg); // XXX
 6916 %}
 6917 
 6918 // Convert compressed oop into int for vectors alignment masking
 6919 // in case of 32bit oops (heap &lt; 4Gb).
 6920 instruct convN2I(rRegI dst, rRegN src)
 6921 %{
<span class="line-modified"> 6922   predicate(Universe::narrow_oop_shift() == 0);</span>
 6923   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6924 
 6925   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6926   ins_encode %{
 6927     __ movl($dst$$Register, $src$$Register);
 6928   %}
 6929   ins_pipe(ialu_reg_reg); // XXX
 6930 %}
 6931 
 6932 // Convert oop pointer into compressed form
 6933 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6934   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6935   match(Set dst (EncodeP src));
 6936   effect(KILL cr);
 6937   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6938   ins_encode %{
 6939     Register s = $src$$Register;
 6940     Register d = $dst$$Register;
 6941     if (s != d) {
 6942       __ movq(d, s);
</pre>
<hr />
<pre>
 7690 %{
 7691   match(Set dst (CastPP dst));
 7692 
 7693   size(0);
 7694   format %{ &quot;# castPP of $dst&quot; %}
 7695   ins_encode(/* empty encoding */);
 7696   ins_pipe(empty);
 7697 %}
 7698 
 7699 instruct castII(rRegI dst)
 7700 %{
 7701   match(Set dst (CastII dst));
 7702 
 7703   size(0);
 7704   format %{ &quot;# castII of $dst&quot; %}
 7705   ins_encode(/* empty encoding */);
 7706   ins_cost(0);
 7707   ins_pipe(empty);
 7708 %}
 7709 











 7710 // LoadP-locked same as a regular LoadP when used with compare-swap
 7711 instruct loadPLocked(rRegP dst, memory mem)
 7712 %{
 7713   match(Set dst (LoadPLocked mem));
 7714 
 7715   ins_cost(125); // XXX
 7716   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7717   opcode(0x8B);
 7718   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7719   ins_pipe(ialu_reg_mem); // XXX
 7720 %}
 7721 
 7722 // Conditional-store of the updated heap-top.
 7723 // Used during allocation of the shared heap.
 7724 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7725 
 7726 instruct storePConditional(memory heap_top_ptr,
 7727                            rax_RegP oldval, rRegP newval,
 7728                            rFlagsReg cr)
 7729 %{

 7730   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7731 
 7732   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7733             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7734   opcode(0x0F, 0xB1);
 7735   ins_encode(lock_prefix,
 7736              REX_reg_mem_wide(newval, heap_top_ptr),
 7737              OpcP, OpcS,
 7738              reg_mem(newval, heap_top_ptr));
 7739   ins_pipe(pipe_cmpxchg);
 7740 %}
 7741 
 7742 // Conditional-store of an int value.
 7743 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7744 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7745 %{
 7746   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7747   effect(KILL oldval);
 7748 
 7749   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
</pre>
<hr />
<pre>
 7761 %{
 7762   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7763   effect(KILL oldval);
 7764 
 7765   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7766   opcode(0x0F, 0xB1);
 7767   ins_encode(lock_prefix,
 7768              REX_reg_mem_wide(newval, mem),
 7769              OpcP, OpcS,
 7770              reg_mem(newval, mem));
 7771   ins_pipe(pipe_cmpxchg);
 7772 %}
 7773 
 7774 
 7775 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7776 instruct compareAndSwapP(rRegI res,
 7777                          memory mem_ptr,
 7778                          rax_RegP oldval, rRegP newval,
 7779                          rFlagsReg cr)
 7780 %{
<span class="line-modified"> 7781   predicate(VM_Version::supports_cx8());</span>
 7782   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7783   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7784   effect(KILL cr, KILL oldval);
 7785 
 7786   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7787             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7788             &quot;sete    $res\n\t&quot;
 7789             &quot;movzbl  $res, $res&quot; %}
 7790   opcode(0x0F, 0xB1);
 7791   ins_encode(lock_prefix,
 7792              REX_reg_mem_wide(newval, mem_ptr),
 7793              OpcP, OpcS,
 7794              reg_mem(newval, mem_ptr),
 7795              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7796              REX_reg_breg(res, res), // movzbl
 7797              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7798   ins_pipe( pipe_cmpxchg );
 7799 %}
 7800 
 7801 instruct compareAndSwapL(rRegI res,
</pre>
<hr />
<pre>
 8003                           rFlagsReg cr) %{
 8004   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 8005   effect(KILL cr);
 8006 
 8007   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 8008             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 8009   opcode(0x0F, 0xB1);
 8010   ins_encode(lock_prefix,
 8011              REX_reg_mem(newval, mem_ptr),
 8012              OpcP, OpcS,
 8013              reg_mem(newval, mem_ptr)  // lock cmpxchg
 8014           );
 8015   ins_pipe( pipe_cmpxchg );
 8016 %}
 8017 
 8018 instruct compareAndExchangeP(
 8019                          memory mem_ptr,
 8020                          rax_RegP oldval, rRegP newval,
 8021                          rFlagsReg cr)
 8022 %{
<span class="line-modified"> 8023   predicate(VM_Version::supports_cx8());</span>
 8024   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 8025   effect(KILL cr);
 8026 
 8027   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 8028             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 8029   opcode(0x0F, 0xB1);
 8030   ins_encode(lock_prefix,
 8031              REX_reg_mem_wide(newval, mem_ptr),
 8032              OpcP, OpcS,
 8033              reg_mem(newval, mem_ptr)  // lock cmpxchg
 8034           );
 8035   ins_pipe( pipe_cmpxchg );
 8036 %}
 8037 
 8038 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 8039   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 8040   match(Set dummy (GetAndAddB mem add));
 8041   effect(KILL cr);
 8042   format %{ &quot;ADDB  [$mem],$add&quot; %}
 8043   ins_encode %{
</pre>
<hr />
<pre>
 8148 instruct xchgI( memory mem, rRegI newval) %{
 8149   match(Set newval (GetAndSetI mem newval));
 8150   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 8151   ins_encode %{
 8152     __ xchgl($newval$$Register, $mem$$Address);
 8153   %}
 8154   ins_pipe( pipe_cmpxchg );
 8155 %}
 8156 
 8157 instruct xchgL( memory mem, rRegL newval) %{
 8158   match(Set newval (GetAndSetL mem newval));
 8159   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 8160   ins_encode %{
 8161     __ xchgq($newval$$Register, $mem$$Address);
 8162   %}
 8163   ins_pipe( pipe_cmpxchg );
 8164 %}
 8165 
 8166 instruct xchgP( memory mem, rRegP newval) %{
 8167   match(Set newval (GetAndSetP mem newval));

 8168   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 8169   ins_encode %{
 8170     __ xchgq($newval$$Register, $mem$$Address);
 8171   %}
 8172   ins_pipe( pipe_cmpxchg );
 8173 %}
 8174 
 8175 instruct xchgN( memory mem, rRegN newval) %{
 8176   match(Set newval (GetAndSetN mem newval));
 8177   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 8178   ins_encode %{
 8179     __ xchgl($newval$$Register, $mem$$Address);
 8180   %}
 8181   ins_pipe( pipe_cmpxchg );
 8182 %}
 8183 














































 8184 //----------Subtraction Instructions-------------------------------------------
 8185 
 8186 // Integer Subtraction Instructions
 8187 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8188 %{
 8189   match(Set dst (SubI dst src));
 8190   effect(KILL cr);
 8191 
 8192   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8193   opcode(0x2B);
 8194   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8195   ins_pipe(ialu_reg_reg);
 8196 %}
 8197 
 8198 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8199 %{
 8200   match(Set dst (SubI dst src));
 8201   effect(KILL cr);
 8202 
 8203   format %{ &quot;subl    $dst, $src\t# int&quot; %}
</pre>
<hr />
<pre>
 9902   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9903   opcode(0x21); /* Opcode 21 /r */
 9904   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9905   ins_pipe(ialu_mem_reg);
 9906 %}
 9907 
 9908 // And Memory with Immediate
 9909 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9910 %{
 9911   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9912   effect(KILL cr);
 9913 
 9914   ins_cost(125);
 9915   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9916   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9917   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9918              RM_opc_mem(secondary, dst), Con8or32(src));
 9919   ins_pipe(ialu_mem_imm);
 9920 %}
 9921 

















 9922 // BMI1 instructions
 9923 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9924   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9925   predicate(UseBMI1Instructions);
 9926   effect(KILL cr);
 9927 
 9928   ins_cost(125);
 9929   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9930 
 9931   ins_encode %{
 9932     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9933   %}
 9934   ins_pipe(ialu_reg_mem);
 9935 %}
 9936 
 9937 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9938   match(Set dst (AndL (XorL src1 minus_1) src2));
 9939   predicate(UseBMI1Instructions);
 9940   effect(KILL cr);
 9941 
</pre>
<hr />
<pre>
10095   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10096   opcode(0x09); /* Opcode 09 /r */
10097   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10098   ins_pipe(ialu_mem_reg);
10099 %}
10100 
10101 // Or Memory with Immediate
10102 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10103 %{
10104   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10105   effect(KILL cr);
10106 
10107   ins_cost(125);
10108   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10109   opcode(0x81, 0x1); /* Opcode 81 /1 id */
10110   ins_encode(REX_mem_wide(dst), OpcSE(src),
10111              RM_opc_mem(secondary, dst), Con8or32(src));
10112   ins_pipe(ialu_mem_imm);
10113 %}
10114 

















10115 // Xor Instructions
10116 // Xor Register with Register
10117 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10118 %{
10119   match(Set dst (XorL dst src));
10120   effect(KILL cr);
10121 
10122   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10123   opcode(0x33);
10124   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10125   ins_pipe(ialu_reg_reg);
10126 %}
10127 
10128 // Xor Register with Immediate -1
10129 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10130   match(Set dst (XorL dst imm));
10131 
10132   format %{ &quot;notq   $dst&quot; %}
10133   ins_encode %{
10134      __ notq($dst$$Register);
</pre>
<hr />
<pre>
10240 
10241 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10242 %{
10243   match(Set dst (CmpLTMask dst zero));
10244   effect(KILL cr);
10245 
10246   ins_cost(100);
10247   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10248   ins_encode %{
10249   __ sarl($dst$$Register, 31);
10250   %}
10251   ins_pipe(ialu_reg);
10252 %}
10253 
10254 /* Better to save a register than avoid a branch */
10255 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10256 %{
10257   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10258   effect(KILL cr);
10259   ins_cost(300);
<span class="line-modified">10260   format %{ &quot;subl   $p,$q\t# cadd_cmpLTMask\n\t&quot;</span>
<span class="line-modified">10261             &quot;jge    done\n\t&quot;</span>
<span class="line-modified">10262             &quot;addl   $p,$y\n&quot;</span>
<span class="line-modified">10263             &quot;done:  &quot; %}</span>
10264   ins_encode %{
10265     Register Rp = $p$$Register;
10266     Register Rq = $q$$Register;
10267     Register Ry = $y$$Register;
10268     Label done;
10269     __ subl(Rp, Rq);
10270     __ jccb(Assembler::greaterEqual, done);
10271     __ addl(Rp, Ry);
10272     __ bind(done);
10273   %}
10274   ins_pipe(pipe_cmplt);
10275 %}
10276 
10277 /* Better to save a register than avoid a branch */
10278 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10279 %{
10280   match(Set y (AndI (CmpLTMask p q) y));
10281   effect(KILL cr);
10282 
10283   ins_cost(300);
10284 
<span class="line-modified">10285   format %{ &quot;cmpl     $p, $q\t# and_cmpLTMask\n\t&quot;</span>
<span class="line-modified">10286             &quot;jlt      done\n\t&quot;</span>
<span class="line-modified">10287             &quot;xorl     $y, $y\n&quot;</span>
<span class="line-modified">10288             &quot;done:  &quot; %}</span>
10289   ins_encode %{
10290     Register Rp = $p$$Register;
10291     Register Rq = $q$$Register;
10292     Register Ry = $y$$Register;
10293     Label done;
10294     __ cmpl(Rp, Rq);
10295     __ jccb(Assembler::less, done);
10296     __ xorl(Ry, Ry);
10297     __ bind(done);
10298   %}
10299   ins_pipe(pipe_cmplt);
10300 %}
10301 
10302 
10303 //---------- FP Instructions------------------------------------------------
10304 
10305 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10306 %{
10307   match(Set cr (CmpF src1 src2));
10308 
</pre>
<hr />
<pre>
10581   match(Set dst (CmpD3 src con));
10582   effect(KILL cr);
10583 
10584   ins_cost(275);
10585   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10586             &quot;movl    $dst, #-1\n\t&quot;
10587             &quot;jp,s    done\n\t&quot;
10588             &quot;jb,s    done\n\t&quot;
10589             &quot;setne   $dst\n\t&quot;
10590             &quot;movzbl  $dst, $dst\n&quot;
10591     &quot;done:&quot; %}
10592   ins_encode %{
10593     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10594     emit_cmpfp3(_masm, $dst$$Register);
10595   %}
10596   ins_pipe(pipe_slow);
10597 %}
10598 
10599 //----------Arithmetic Conversion Instructions---------------------------------
10600 
<span class="line-removed">10601 instruct roundFloat_nop(regF dst)</span>
<span class="line-removed">10602 %{</span>
<span class="line-removed">10603   match(Set dst (RoundFloat dst));</span>
<span class="line-removed">10604 </span>
<span class="line-removed">10605   ins_cost(0);</span>
<span class="line-removed">10606   ins_encode();</span>
<span class="line-removed">10607   ins_pipe(empty);</span>
<span class="line-removed">10608 %}</span>
<span class="line-removed">10609 </span>
<span class="line-removed">10610 instruct roundDouble_nop(regD dst)</span>
<span class="line-removed">10611 %{</span>
<span class="line-removed">10612   match(Set dst (RoundDouble dst));</span>
<span class="line-removed">10613 </span>
<span class="line-removed">10614   ins_cost(0);</span>
<span class="line-removed">10615   ins_encode();</span>
<span class="line-removed">10616   ins_pipe(empty);</span>
<span class="line-removed">10617 %}</span>
<span class="line-removed">10618 </span>
10619 instruct convF2D_reg_reg(regD dst, regF src)
10620 %{
10621   match(Set dst (ConvF2D src));
10622 
10623   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10624   ins_encode %{
10625     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10626   %}
10627   ins_pipe(pipe_slow); // XXX
10628 %}
10629 
10630 instruct convF2D_reg_mem(regD dst, memory src)
10631 %{
10632   match(Set dst (ConvF2D (LoadF src)));
10633 
10634   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10635   ins_encode %{
10636     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10637   %}
10638   ins_pipe(pipe_slow); // XXX
</pre>
<hr />
<pre>
10648   %}
10649   ins_pipe(pipe_slow); // XXX
10650 %}
10651 
10652 instruct convD2F_reg_mem(regF dst, memory src)
10653 %{
10654   match(Set dst (ConvD2F (LoadD src)));
10655 
10656   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10657   ins_encode %{
10658     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10659   %}
10660   ins_pipe(pipe_slow); // XXX
10661 %}
10662 
10663 // XXX do mem variants
10664 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10665 %{
10666   match(Set dst (ConvF2I src));
10667   effect(KILL cr);
<span class="line-modified">10668 </span>
<span class="line-removed">10669   format %{ &quot;cvttss2sil $dst, $src\t# f2i\n\t&quot;</span>
<span class="line-removed">10670             &quot;cmpl    $dst, #0x80000000\n\t&quot;</span>
<span class="line-removed">10671             &quot;jne,s   done\n\t&quot;</span>
<span class="line-removed">10672             &quot;subq    rsp, #8\n\t&quot;</span>
<span class="line-removed">10673             &quot;movss   [rsp], $src\n\t&quot;</span>
<span class="line-removed">10674             &quot;call    f2i_fixup\n\t&quot;</span>
<span class="line-removed">10675             &quot;popq    $dst\n&quot;</span>
<span class="line-removed">10676     &quot;done:   &quot;%}</span>
10677   ins_encode %{
<span class="line-modified">10678     Label done;</span>
<span class="line-removed">10679     __ cvttss2sil($dst$$Register, $src$$XMMRegister);</span>
<span class="line-removed">10680     __ cmpl($dst$$Register, 0x80000000);</span>
<span class="line-removed">10681     __ jccb(Assembler::notEqual, done);</span>
<span class="line-removed">10682     __ subptr(rsp, 8);</span>
<span class="line-removed">10683     __ movflt(Address(rsp, 0), $src$$XMMRegister);</span>
<span class="line-removed">10684     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));</span>
<span class="line-removed">10685     __ pop($dst$$Register);</span>
<span class="line-removed">10686     __ bind(done);</span>
10687   %}
10688   ins_pipe(pipe_slow);
10689 %}
10690 
10691 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10692 %{
10693   match(Set dst (ConvF2L src));
10694   effect(KILL cr);
<span class="line-modified">10695 </span>
<span class="line-removed">10696   format %{ &quot;cvttss2siq $dst, $src\t# f2l\n\t&quot;</span>
<span class="line-removed">10697             &quot;cmpq    $dst, [0x8000000000000000]\n\t&quot;</span>
<span class="line-removed">10698             &quot;jne,s   done\n\t&quot;</span>
<span class="line-removed">10699             &quot;subq    rsp, #8\n\t&quot;</span>
<span class="line-removed">10700             &quot;movss   [rsp], $src\n\t&quot;</span>
<span class="line-removed">10701             &quot;call    f2l_fixup\n\t&quot;</span>
<span class="line-removed">10702             &quot;popq    $dst\n&quot;</span>
<span class="line-removed">10703     &quot;done:   &quot;%}</span>
10704   ins_encode %{
<span class="line-modified">10705     Label done;</span>
<span class="line-removed">10706     __ cvttss2siq($dst$$Register, $src$$XMMRegister);</span>
<span class="line-removed">10707     __ cmp64($dst$$Register,</span>
<span class="line-removed">10708              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));</span>
<span class="line-removed">10709     __ jccb(Assembler::notEqual, done);</span>
<span class="line-removed">10710     __ subptr(rsp, 8);</span>
<span class="line-removed">10711     __ movflt(Address(rsp, 0), $src$$XMMRegister);</span>
<span class="line-removed">10712     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));</span>
<span class="line-removed">10713     __ pop($dst$$Register);</span>
<span class="line-removed">10714     __ bind(done);</span>
10715   %}
10716   ins_pipe(pipe_slow);
10717 %}
10718 
10719 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10720 %{
10721   match(Set dst (ConvD2I src));
10722   effect(KILL cr);
<span class="line-modified">10723 </span>
<span class="line-removed">10724   format %{ &quot;cvttsd2sil $dst, $src\t# d2i\n\t&quot;</span>
<span class="line-removed">10725             &quot;cmpl    $dst, #0x80000000\n\t&quot;</span>
<span class="line-removed">10726             &quot;jne,s   done\n\t&quot;</span>
<span class="line-removed">10727             &quot;subq    rsp, #8\n\t&quot;</span>
<span class="line-removed">10728             &quot;movsd   [rsp], $src\n\t&quot;</span>
<span class="line-removed">10729             &quot;call    d2i_fixup\n\t&quot;</span>
<span class="line-removed">10730             &quot;popq    $dst\n&quot;</span>
<span class="line-removed">10731     &quot;done:   &quot;%}</span>
10732   ins_encode %{
<span class="line-modified">10733     Label done;</span>
<span class="line-removed">10734     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);</span>
<span class="line-removed">10735     __ cmpl($dst$$Register, 0x80000000);</span>
<span class="line-removed">10736     __ jccb(Assembler::notEqual, done);</span>
<span class="line-removed">10737     __ subptr(rsp, 8);</span>
<span class="line-removed">10738     __ movdbl(Address(rsp, 0), $src$$XMMRegister);</span>
<span class="line-removed">10739     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));</span>
<span class="line-removed">10740     __ pop($dst$$Register);</span>
<span class="line-removed">10741     __ bind(done);</span>
10742   %}
10743   ins_pipe(pipe_slow);
10744 %}
10745 
10746 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10747 %{
10748   match(Set dst (ConvD2L src));
10749   effect(KILL cr);
<span class="line-modified">10750 </span>
<span class="line-removed">10751   format %{ &quot;cvttsd2siq $dst, $src\t# d2l\n\t&quot;</span>
<span class="line-removed">10752             &quot;cmpq    $dst, [0x8000000000000000]\n\t&quot;</span>
<span class="line-removed">10753             &quot;jne,s   done\n\t&quot;</span>
<span class="line-removed">10754             &quot;subq    rsp, #8\n\t&quot;</span>
<span class="line-removed">10755             &quot;movsd   [rsp], $src\n\t&quot;</span>
<span class="line-removed">10756             &quot;call    d2l_fixup\n\t&quot;</span>
<span class="line-removed">10757             &quot;popq    $dst\n&quot;</span>
<span class="line-removed">10758     &quot;done:   &quot;%}</span>
10759   ins_encode %{
<span class="line-modified">10760     Label done;</span>
<span class="line-removed">10761     __ cvttsd2siq($dst$$Register, $src$$XMMRegister);</span>
<span class="line-removed">10762     __ cmp64($dst$$Register,</span>
<span class="line-removed">10763              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));</span>
<span class="line-removed">10764     __ jccb(Assembler::notEqual, done);</span>
<span class="line-removed">10765     __ subptr(rsp, 8);</span>
<span class="line-removed">10766     __ movdbl(Address(rsp, 0), $src$$XMMRegister);</span>
<span class="line-removed">10767     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));</span>
<span class="line-removed">10768     __ pop($dst$$Register);</span>
<span class="line-removed">10769     __ bind(done);</span>
10770   %}
10771   ins_pipe(pipe_slow);
10772 %}
10773 
10774 instruct convI2F_reg_reg(regF dst, rRegI src)
10775 %{
10776   predicate(!UseXmmI2F);
10777   match(Set dst (ConvI2F src));
10778 
10779   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10780   ins_encode %{
10781     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10782   %}
10783   ins_pipe(pipe_slow); // XXX
10784 %}
10785 
10786 instruct convI2F_reg_mem(regF dst, memory src)
10787 %{
10788   match(Set dst (ConvI2F (LoadI src)));
10789 
</pre>
<hr />
<pre>
11218        $$emit$$&quot;dec     rcx\n\t&quot;
11219        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11220        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11221        $$emit$$&quot;add     0x8,rax\n\t&quot;
11222        $$emit$$&quot;dec     rcx\n\t&quot;
11223        $$emit$$&quot;jge     L_sloop\n\t&quot;
11224        $$emit$$&quot;# L_end:\n\t&quot;
11225     } else {
11226        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
11227        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11228     }
11229   %}
11230   ins_encode %{
11231     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11232                  $tmp$$XMMRegister, true);
11233   %}
11234   ins_pipe(pipe_slow);
11235 %}
11236 
11237 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<span class="line-modified">11238                          rax_RegI result, legVecS tmp1, rFlagsReg cr)</span>
11239 %{
11240   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11241   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11242   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11243 
11244   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11245   ins_encode %{
11246     __ string_compare($str1$$Register, $str2$$Register,
11247                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11248                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11249   %}
11250   ins_pipe( pipe_slow );
11251 %}
11252 
11253 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<span class="line-modified">11254                          rax_RegI result, legVecS tmp1, rFlagsReg cr)</span>
11255 %{
11256   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11257   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11258   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11259 
11260   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11261   ins_encode %{
11262     __ string_compare($str1$$Register, $str2$$Register,
11263                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11264                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11265   %}
11266   ins_pipe( pipe_slow );
11267 %}
11268 
11269 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<span class="line-modified">11270                           rax_RegI result, legVecS tmp1, rFlagsReg cr)</span>
11271 %{
11272   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11273   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11274   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11275 
11276   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11277   ins_encode %{
11278     __ string_compare($str1$$Register, $str2$$Register,
11279                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11280                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11281   %}
11282   ins_pipe( pipe_slow );
11283 %}
11284 
11285 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
<span class="line-modified">11286                           rax_RegI result, legVecS tmp1, rFlagsReg cr)</span>
11287 %{
11288   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11289   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11290   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11291 
11292   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11293   ins_encode %{
11294     __ string_compare($str2$$Register, $str1$$Register,
11295                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11296                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11297   %}
11298   ins_pipe( pipe_slow );
11299 %}
11300 
11301 // fast search of substring with known size.
11302 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<span class="line-modified">11303                              rbx_RegI result, legVecS vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
11304 %{
11305   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11306   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">11307   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11308 
<span class="line-modified">11309   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
11310   ins_encode %{
11311     int icnt2 = (int)$int_cnt2$$constant;
11312     if (icnt2 &gt;= 16) {
11313       // IndexOf for constant substrings with size &gt;= 16 elements
11314       // which don&#39;t need to be loaded through stack.
11315       __ string_indexofC8($str1$$Register, $str2$$Register,
11316                           $cnt1$$Register, $cnt2$$Register,
11317                           icnt2, $result$$Register,
<span class="line-modified">11318                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11319     } else {
11320       // Small strings are loaded through stack if they cross page boundary.
11321       __ string_indexof($str1$$Register, $str2$$Register,
11322                         $cnt1$$Register, $cnt2$$Register,
11323                         icnt2, $result$$Register,
<span class="line-modified">11324                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11325     }
11326   %}
11327   ins_pipe( pipe_slow );
11328 %}
11329 
11330 // fast search of substring with known size.
11331 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<span class="line-modified">11332                              rbx_RegI result, legVecS vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
11333 %{
11334   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11335   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">11336   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11337 
<span class="line-modified">11338   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
11339   ins_encode %{
11340     int icnt2 = (int)$int_cnt2$$constant;
11341     if (icnt2 &gt;= 8) {
11342       // IndexOf for constant substrings with size &gt;= 8 elements
11343       // which don&#39;t need to be loaded through stack.
11344       __ string_indexofC8($str1$$Register, $str2$$Register,
11345                           $cnt1$$Register, $cnt2$$Register,
11346                           icnt2, $result$$Register,
<span class="line-modified">11347                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11348     } else {
11349       // Small strings are loaded through stack if they cross page boundary.
11350       __ string_indexof($str1$$Register, $str2$$Register,
11351                         $cnt1$$Register, $cnt2$$Register,
11352                         icnt2, $result$$Register,
<span class="line-modified">11353                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11354     }
11355   %}
11356   ins_pipe( pipe_slow );
11357 %}
11358 
11359 // fast search of substring with known size.
11360 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<span class="line-modified">11361                              rbx_RegI result, legVecS vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
11362 %{
11363   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11364   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">11365   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11366 
<span class="line-modified">11367   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
11368   ins_encode %{
11369     int icnt2 = (int)$int_cnt2$$constant;
11370     if (icnt2 &gt;= 8) {
11371       // IndexOf for constant substrings with size &gt;= 8 elements
11372       // which don&#39;t need to be loaded through stack.
11373       __ string_indexofC8($str1$$Register, $str2$$Register,
11374                           $cnt1$$Register, $cnt2$$Register,
11375                           icnt2, $result$$Register,
<span class="line-modified">11376                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11377     } else {
11378       // Small strings are loaded through stack if they cross page boundary.
11379       __ string_indexof($str1$$Register, $str2$$Register,
11380                         $cnt1$$Register, $cnt2$$Register,
11381                         icnt2, $result$$Register,
<span class="line-modified">11382                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11383     }
11384   %}
11385   ins_pipe( pipe_slow );
11386 %}
11387 
11388 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<span class="line-modified">11389                          rbx_RegI result, legVecS vec, rcx_RegI tmp, rFlagsReg cr)</span>
11390 %{
11391   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11392   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">11393   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11394 
11395   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11396   ins_encode %{
11397     __ string_indexof($str1$$Register, $str2$$Register,
11398                       $cnt1$$Register, $cnt2$$Register,
11399                       (-1), $result$$Register,
<span class="line-modified">11400                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11401   %}
11402   ins_pipe( pipe_slow );
11403 %}
11404 
11405 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<span class="line-modified">11406                          rbx_RegI result, legVecS vec, rcx_RegI tmp, rFlagsReg cr)</span>
11407 %{
11408   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11409   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">11410   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11411 
11412   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11413   ins_encode %{
11414     __ string_indexof($str1$$Register, $str2$$Register,
11415                       $cnt1$$Register, $cnt2$$Register,
11416                       (-1), $result$$Register,
<span class="line-modified">11417                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11418   %}
11419   ins_pipe( pipe_slow );
11420 %}
11421 
11422 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<span class="line-modified">11423                          rbx_RegI result, legVecS vec, rcx_RegI tmp, rFlagsReg cr)</span>
11424 %{
11425   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11426   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">11427   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11428 
11429   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11430   ins_encode %{
11431     __ string_indexof($str1$$Register, $str2$$Register,
11432                       $cnt1$$Register, $cnt2$$Register,
11433                       (-1), $result$$Register,
<span class="line-modified">11434                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11435   %}
11436   ins_pipe( pipe_slow );
11437 %}
11438 
11439 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
<span class="line-modified">11440                               rbx_RegI result, legVecS vec1, legVecS vec2, legVecS vec3, rcx_RegI tmp, rFlagsReg cr)</span>
11441 %{
11442   predicate(UseSSE42Intrinsics);
11443   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
<span class="line-modified">11444   effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);</span>
11445   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11446   ins_encode %{
11447     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
<span class="line-modified">11448                            $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);</span>
11449   %}
11450   ins_pipe( pipe_slow );
11451 %}
11452 
11453 // fast string equals
11454 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
<span class="line-modified">11455                        legVecS tmp1, legVecS tmp2, rbx_RegI tmp3, rFlagsReg cr)</span>
11456 %{
11457   match(Set result (StrEquals (Binary str1 str2) cnt));
11458   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11459 
11460   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11461   ins_encode %{
11462     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11463                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11464                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11465   %}
11466   ins_pipe( pipe_slow );
11467 %}
11468 
11469 // fast array equals
11470 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
<span class="line-modified">11471                        legVecS tmp1, legVecS tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)</span>
11472 %{
11473   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11474   match(Set result (AryEq ary1 ary2));
11475   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11476 
11477   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11478   ins_encode %{
11479     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11480                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11481                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11482   %}
11483   ins_pipe( pipe_slow );
11484 %}
11485 
11486 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
<span class="line-modified">11487                       legVecS tmp1, legVecS tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)</span>
11488 %{
11489   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11490   match(Set result (AryEq ary1 ary2));
11491   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11492 
11493   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11494   ins_encode %{
11495     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11496                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11497                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11498   %}
11499   ins_pipe( pipe_slow );
11500 %}
11501 
11502 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
<span class="line-modified">11503                       legVecS tmp1, legVecS tmp2, rbx_RegI tmp3, rFlagsReg cr)</span>
11504 %{
11505   match(Set result (HasNegatives ary1 len));
11506   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11507 
11508   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11509   ins_encode %{
11510     __ has_negatives($ary1$$Register, $len$$Register,
11511                      $result$$Register, $tmp3$$Register,
11512                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11513   %}
11514   ins_pipe( pipe_slow );
11515 %}
11516 
11517 // fast char[] to byte[] compression
<span class="line-modified">11518 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legVecS tmp1, legVecS tmp2, legVecS tmp3, legVecS tmp4,</span>
11519                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11520   match(Set result (StrCompressedCopy src (Binary dst len)));
11521   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11522 
11523   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11524   ins_encode %{
11525     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11526                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11527                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11528   %}
11529   ins_pipe( pipe_slow );
11530 %}
11531 
11532 // fast byte[] to char[] inflation
11533 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
<span class="line-modified">11534                         legVecS tmp1, rcx_RegI tmp2, rFlagsReg cr) %{</span>
11535   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11536   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11537 
11538   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11539   ins_encode %{
11540     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11541                           $tmp1$$XMMRegister, $tmp2$$Register);
11542   %}
11543   ins_pipe( pipe_slow );
11544 %}
11545 
11546 // encode char[] to byte[] in ISO_8859_1
11547 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
<span class="line-modified">11548                           legVecS tmp1, legVecS tmp2, legVecS tmp3, legVecS tmp4,</span>
11549                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11550   match(Set result (EncodeISOArray src (Binary dst len)));
11551   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11552 
11553   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11554   ins_encode %{
11555     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11556                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11557                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11558   %}
11559   ins_pipe( pipe_slow );
11560 %}
11561 
11562 //----------Overflow Math Instructions-----------------------------------------
11563 
11564 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11565 %{
11566   match(Set cr (OverflowAddI op1 op2));
11567   effect(DEF cr, USE_KILL op1, USE op2);
11568 
</pre>
<hr />
<pre>
11825   opcode(0x3B); /* Opcode 3B /r */
11826   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11827   ins_pipe(ialu_cr_reg_mem);
11828 %}
11829 
11830 // // // Cisc-spilled version of cmpU_rReg
11831 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11832 // //%{
11833 // //  match(Set cr (CmpU (LoadI op1) op2));
11834 // //
11835 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11836 // //  ins_cost(500);
11837 // //  opcode(0x39);  /* Opcode 39 /r */
11838 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11839 // //%}
11840 
11841 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11842 %{
11843   match(Set cr (CmpU src zero));
11844 
<span class="line-modified">11845   format %{ &quot;testl  $src, $src\t# unsigned&quot; %}</span>
11846   opcode(0x85);
11847   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11848   ins_pipe(ialu_cr_reg_imm);
11849 %}
11850 
11851 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11852 %{
11853   match(Set cr (CmpP op1 op2));
11854 
11855   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11856   opcode(0x3B); /* Opcode 3B /r */
11857   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11858   ins_pipe(ialu_cr_reg_reg);
11859 %}
11860 
11861 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11862 %{
11863   match(Set cr (CmpP op1 (LoadP op2)));

11864 
11865   ins_cost(500); // XXX
11866   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11867   opcode(0x3B); /* Opcode 3B /r */
11868   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11869   ins_pipe(ialu_cr_reg_mem);
11870 %}
11871 
11872 // // // Cisc-spilled version of cmpP_rReg
11873 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11874 // //%{
11875 // //  match(Set cr (CmpP (LoadP op1) op2));
11876 // //
11877 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11878 // //  ins_cost(500);
11879 // //  opcode(0x39);  /* Opcode 39 /r */
11880 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11881 // //%}
11882 
11883 // XXX this is generalized by compP_rReg_mem???
11884 // Compare raw pointer (used in out-of-heap check).
11885 // Only works because non-oop pointers must be raw pointers
11886 // and raw pointers have no anti-dependencies.
11887 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11888 %{
<span class="line-modified">11889   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none);</span>

11890   match(Set cr (CmpP op1 (LoadP op2)));
11891 
11892   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11893   opcode(0x3B); /* Opcode 3B /r */
11894   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11895   ins_pipe(ialu_cr_reg_mem);
11896 %}
11897 
11898 // This will generate a signed flags result. This should be OK since
11899 // any compare to a zero should be eq/neq.
11900 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11901 %{
11902   match(Set cr (CmpP src zero));
11903 
11904   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11905   opcode(0x85);
11906   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11907   ins_pipe(ialu_cr_reg_imm);
11908 %}
11909 
11910 // This will generate a signed flags result. This should be OK since
11911 // any compare to a zero should be eq/neq.
11912 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11913 %{
<span class="line-modified">11914   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));</span>

11915   match(Set cr (CmpP (LoadP op) zero));
11916 
11917   ins_cost(500); // XXX
11918   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11919   opcode(0xF7); /* Opcode F7 /0 */
11920   ins_encode(REX_mem_wide(op),
11921              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11922   ins_pipe(ialu_cr_reg_imm);
11923 %}
11924 
11925 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11926 %{
<span class="line-modified">11927   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>


11928   match(Set cr (CmpP (LoadP mem) zero));
11929 
11930   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11931   ins_encode %{
11932     __ cmpq(r12, $mem$$Address);
11933   %}
11934   ins_pipe(ialu_cr_reg_mem);
11935 %}
11936 
11937 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11938 %{
11939   match(Set cr (CmpN op1 op2));
11940 
11941   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11942   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11943   ins_pipe(ialu_cr_reg_reg);
11944 %}
11945 
11946 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11947 %{
</pre>
<hr />
<pre>
11989 %{
11990   match(Set cr (CmpN src (LoadNKlass mem)));
11991 
11992   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
11993   ins_encode %{
11994     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11995   %}
11996   ins_pipe(ialu_cr_reg_mem);
11997 %}
11998 
11999 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
12000   match(Set cr (CmpN src zero));
12001 
12002   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
12003   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
12004   ins_pipe(ialu_cr_reg_imm);
12005 %}
12006 
12007 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
12008 %{
<span class="line-modified">12009   predicate(Universe::narrow_oop_base() != NULL);</span>
12010   match(Set cr (CmpN (LoadN mem) zero));
12011 
12012   ins_cost(500); // XXX
12013   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
12014   ins_encode %{
12015     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
12016   %}
12017   ins_pipe(ialu_cr_reg_mem);
12018 %}
12019 
12020 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
12021 %{
<span class="line-modified">12022   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
12023   match(Set cr (CmpN (LoadN mem) zero));
12024 
12025   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
12026   ins_encode %{
12027     __ cmpl(r12, $mem$$Address);
12028   %}
12029   ins_pipe(ialu_cr_reg_mem);
12030 %}
12031 
12032 // Yanked all unsigned pointer compare operations.
12033 // Pointer compares are done with CmpP which is already unsigned.
12034 
12035 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
12036 %{
12037   match(Set cr (CmpL op1 op2));
12038 
12039   format %{ &quot;cmpq    $op1, $op2&quot; %}
12040   opcode(0x3B);  /* Opcode 3B /r */
12041   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
12042   ins_pipe(ialu_cr_reg_reg);
</pre>
<hr />
<pre>
12368   effect(USE labl);
12369 
12370   ins_cost(300);
12371   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12372             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12373   size(10);
12374   ins_encode %{
12375     Label* L = $labl$$label;
12376     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12377     __ restorevectmask();
12378   %}
12379   ins_pipe(pipe_jcc);
12380 %}
12381 
12382 // Jump Direct Conditional - using unsigned comparison
12383 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12384   match(If cop cmp);
12385   effect(USE labl);
12386 
12387   ins_cost(300);
<span class="line-modified">12388   format %{ &quot;j$cop,u  $labl&quot; %}</span>
12389   size(6);
12390   ins_encode %{
12391     Label* L = $labl$$label;
12392     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12393   %}
12394   ins_pipe(pipe_jcc);
12395 %}
12396 
12397 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12398   match(If cop cmp);
12399   effect(USE labl);
12400 
12401   ins_cost(200);
<span class="line-modified">12402   format %{ &quot;j$cop,u  $labl&quot; %}</span>
12403   size(6);
12404   ins_encode %{
12405     Label* L = $labl$$label;
12406     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12407   %}
12408   ins_pipe(pipe_jcc);
12409 %}
12410 
12411 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12412   match(If cop cmp);
12413   effect(USE labl);
12414 
12415   ins_cost(200);
12416   format %{ $$template
12417     if ($cop$$cmpcode == Assembler::notEqual) {
<span class="line-modified">12418       $$emit$$&quot;jp,u   $labl\n\t&quot;</span>
12419       $$emit$$&quot;j$cop,u   $labl&quot;
12420     } else {
<span class="line-modified">12421       $$emit$$&quot;jp,u   done\n\t&quot;</span>
12422       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12423       $$emit$$&quot;done:&quot;
12424     }
12425   %}
12426   ins_encode %{
12427     Label* l = $labl$$label;
12428     if ($cop$$cmpcode == Assembler::notEqual) {
12429       __ jcc(Assembler::parity, *l, false);
12430       __ jcc(Assembler::notEqual, *l, false);
12431     } else if ($cop$$cmpcode == Assembler::equal) {
12432       Label done;
12433       __ jccb(Assembler::parity, done);
12434       __ jcc(Assembler::equal, *l, false);
12435       __ bind(done);
12436     } else {
12437        ShouldNotReachHere();
12438     }
12439   %}
12440   ins_pipe(pipe_jcc);
12441 %}
</pre>
<hr />
<pre>
12603   effect(USE labl);
12604 
12605   ins_cost(300);
12606   format %{ &quot;j$cop,us  $labl&quot; %}
12607   size(2);
12608   ins_encode %{
12609     Label* L = $labl$$label;
12610     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12611   %}
12612   ins_pipe(pipe_jcc);
12613   ins_short_branch(1);
12614 %}
12615 
12616 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12617   match(If cop cmp);
12618   effect(USE labl);
12619 
12620   ins_cost(300);
12621   format %{ $$template
12622     if ($cop$$cmpcode == Assembler::notEqual) {
<span class="line-modified">12623       $$emit$$&quot;jp,u,s   $labl\n\t&quot;</span>
<span class="line-modified">12624       $$emit$$&quot;j$cop,u,s   $labl&quot;</span>
12625     } else {
<span class="line-modified">12626       $$emit$$&quot;jp,u,s   done\n\t&quot;</span>
12627       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12628       $$emit$$&quot;done:&quot;
12629     }
12630   %}
12631   size(4);
12632   ins_encode %{
12633     Label* l = $labl$$label;
12634     if ($cop$$cmpcode == Assembler::notEqual) {
12635       __ jccb(Assembler::parity, *l);
12636       __ jccb(Assembler::notEqual, *l);
12637     } else if ($cop$$cmpcode == Assembler::equal) {
12638       Label done;
12639       __ jccb(Assembler::parity, done);
12640       __ jccb(Assembler::equal, *l);
12641       __ bind(done);
12642     } else {
12643        ShouldNotReachHere();
12644     }
12645   %}
12646   ins_pipe(pipe_jcc);
</pre>
<hr />
<pre>
12682 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12683   match(Set cr (FastUnlock object box));
12684   effect(TEMP tmp, USE_KILL box);
12685   ins_cost(300);
12686   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12687   ins_encode %{
12688     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12689   %}
12690   ins_pipe(pipe_slow);
12691 %}
12692 
12693 
12694 // ============================================================================
12695 // Safepoint Instructions
12696 instruct safePoint_poll(rFlagsReg cr)
12697 %{
12698   predicate(!Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
12699   match(SafePoint);
12700   effect(KILL cr);
12701 
<span class="line-modified">12702   format %{ &quot;testl  rax, [rip + #offset_to_poll_page]\t&quot;</span>
12703             &quot;# Safepoint: poll for GC&quot; %}
12704   ins_cost(125);
12705   ins_encode %{
12706     AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
12707     __ testl(rax, addr);
12708   %}
12709   ins_pipe(ialu_reg_mem);
12710 %}
12711 
12712 instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)
12713 %{
12714   predicate(Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
12715   match(SafePoint poll);
12716   effect(KILL cr, USE poll);
12717 
<span class="line-modified">12718   format %{ &quot;testl  rax, [$poll]\t&quot;</span>
12719             &quot;# Safepoint: poll for GC&quot; %}
12720   ins_cost(125);
12721   ins_encode %{
12722     __ relocate(relocInfo::poll_type);
12723     __ testl(rax, Address($poll$$Register, 0));
12724   %}
12725   ins_pipe(ialu_reg_mem);
12726 %}
12727 
12728 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12729 %{
12730   predicate(SafepointMechanism::uses_thread_local_poll());
12731   match(SafePoint poll);
12732   effect(KILL cr, USE poll);
12733 
<span class="line-modified">12734   format %{ &quot;testl  rax, [$poll]\t&quot;</span>
12735             &quot;# Safepoint: poll for GC&quot; %}
12736   ins_cost(125);
12737   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12738   ins_encode %{
12739     __ relocate(relocInfo::poll_type);
12740     address pre_pc = __ pc();
12741     __ testl(rax, Address($poll$$Register, 0));
12742     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12743   %}
12744   ins_pipe(ialu_reg_mem);
12745 %}
12746 
12747 // ============================================================================
12748 // Procedure Call/Return Instructions
12749 // Call Java Static Instruction
12750 // Note: If this code changes, the corresponding ret_addr_offset() and
12751 //       compute_padding() functions will have to be adjusted.
12752 instruct CallStaticJavaDirect(method meth) %{
12753   match(CallStaticJava);
12754   effect(USE meth);
</pre>
</td>
<td>
<hr />
<pre>
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 
<span class="line-added">  270 // Singleton class for RBP pointer register</span>
<span class="line-added">  271 reg_class ptr_rbp_reg(RBP, RBP_H);</span>
<span class="line-added">  272 </span>
  273 // Singleton class for RDI pointer register
  274 reg_class ptr_rdi_reg(RDI, RDI_H);
  275 
  276 // Singleton class for stack pointer
  277 reg_class ptr_rsp_reg(RSP, RSP_H);
  278 
  279 // Singleton class for TLS pointer
  280 reg_class ptr_r15_reg(R15, R15_H);
  281 
  282 // Singleton class for RAX long register
  283 reg_class long_rax_reg(RAX, RAX_H);
  284 
  285 // Singleton class for RCX long register
  286 reg_class long_rcx_reg(RCX, RCX_H);
  287 
  288 // Singleton class for RDX long register
  289 reg_class long_rdx_reg(RDX, RDX_H);
  290 
  291 // Singleton class for RAX int register
  292 reg_class int_rax_reg(RAX);
</pre>
<hr />
<pre>
  532 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  533   cbuf.insts()-&gt;emit_int64(d64);
  534 }
  535 
  536 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  537 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  538                     int d32,
  539                     relocInfo::relocType reloc,
  540                     int format)
  541 {
  542   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  543   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  544   cbuf.insts()-&gt;emit_int32(d32);
  545 }
  546 
  547 // emit 32 bit value and construct relocation entry from RelocationHolder
  548 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  549 #ifdef ASSERT
  550   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  551       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
<span class="line-modified">  552     assert(Universe::heap()-&gt;is_in((address)(intptr_t)d32), &quot;should be real oop&quot;);</span>
  553     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  554   }
  555 #endif
  556   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  557   cbuf.insts()-&gt;emit_int32(d32);
  558 }
  559 
  560 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  561   address next_ip = cbuf.insts_end() + 4;
  562   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  563                  external_word_Relocation::spec(addr),
  564                  RELOC_DISP32);
  565 }
  566 
  567 
  568 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  569 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  570   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  571   cbuf.insts()-&gt;emit_int64(d64);
  572 }
  573 
  574 // emit 64 bit value and construct relocation entry from RelocationHolder
  575 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  576 #ifdef ASSERT
  577   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  578       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
<span class="line-modified">  579     assert(Universe::heap()-&gt;is_in((address)d64), &quot;should be real oop&quot;);</span>
  580     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  581   }
  582 #endif
  583   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  584   cbuf.insts()-&gt;emit_int64(d64);
  585 }
  586 
  587 // Access stack slot for load or store
  588 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  589 {
  590   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  591   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  592     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  593     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  594     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  595   } else {
  596     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  597     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  598     emit_d32(cbuf, disp);     // Displacement // R/M byte
  599   }
</pre>
<hr />
<pre>
  860   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  861     st-&gt;print(&quot;\n\t&quot;);
  862     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  863     st-&gt;print(&quot;\n\t&quot;);
  864     st-&gt;print(&quot;je      fast_entry\t&quot;);
  865     st-&gt;print(&quot;\n\t&quot;);
  866     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  867     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  868   }
  869   st-&gt;cr();
  870 }
  871 #endif
  872 
  873 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  874   Compile* C = ra_-&gt;C;
  875   MacroAssembler _masm(&amp;cbuf);
  876 
  877   int framesize = C-&gt;frame_size_in_bytes();
  878   int bangsize = C-&gt;bang_size_in_bytes();
  879 
<span class="line-added">  880   if (C-&gt;clinit_barrier_on_entry()) {</span>
<span class="line-added">  881     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);</span>
<span class="line-added">  882     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);</span>
<span class="line-added">  883 </span>
<span class="line-added">  884     Label L_skip_barrier;</span>
<span class="line-added">  885     Register klass = rscratch1;</span>
<span class="line-added">  886 </span>
<span class="line-added">  887     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());</span>
<span class="line-added">  888     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);</span>
<span class="line-added">  889 </span>
<span class="line-added">  890     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path</span>
<span class="line-added">  891 </span>
<span class="line-added">  892     __ bind(L_skip_barrier);</span>
<span class="line-added">  893   }</span>
<span class="line-added">  894 </span>
  895   __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);
  896 
  897   C-&gt;set_frame_complete(cbuf.insts_size());
  898 
  899   if (C-&gt;has_mach_constant_base_node()) {
  900     // NOTE: We set the table base offset here because users might be
  901     // emitted before MachConstantBaseNode.
  902     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
  903     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  904   }
  905 }
  906 
  907 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
  908 {
  909   return MachNode::size(ra_); // too many variables; just compute it
  910                               // the hard way
  911 }
  912 
  913 int MachPrologNode::reloc() const
  914 {
</pre>
<hr />
<pre>
  919 #ifndef PRODUCT
  920 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  921 {
  922   Compile* C = ra_-&gt;C;
  923   if (generate_vzeroupper(C)) {
  924     st-&gt;print(&quot;vzeroupper&quot;);
  925     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  926   }
  927 
  928   int framesize = C-&gt;frame_size_in_bytes();
  929   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  930   // Remove word for return adr already pushed
  931   // and RBP
  932   framesize -= 2*wordSize;
  933 
  934   if (framesize) {
  935     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  936     st-&gt;print(&quot;\t&quot;);
  937   }
  938 
<span class="line-modified">  939   st-&gt;print_cr(&quot;popq    rbp&quot;);</span>
  940   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  941     st-&gt;print(&quot;\t&quot;);
  942     if (SafepointMechanism::uses_thread_local_poll()) {
<span class="line-modified">  943       st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;</span>
<span class="line-modified">  944                    &quot;testl   rax, [rscratch1]\t&quot;</span>
  945                    &quot;# Safepoint: poll for GC&quot;);
  946     } else if (Assembler::is_polling_page_far()) {
<span class="line-modified">  947       st-&gt;print_cr(&quot;movq    rscratch1, #polling_page_address\n\t&quot;</span>
<span class="line-modified">  948                    &quot;testl   rax, [rscratch1]\t&quot;</span>
  949                    &quot;# Safepoint: poll for GC&quot;);
  950     } else {
<span class="line-modified">  951       st-&gt;print_cr(&quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;</span>
  952                    &quot;# Safepoint: poll for GC&quot;);
  953     }
  954   }
  955 }
  956 #endif
  957 
  958 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  959 {
  960   Compile* C = ra_-&gt;C;
  961   MacroAssembler _masm(&amp;cbuf);
  962 
  963   if (generate_vzeroupper(C)) {
  964     // Clear upper bits of YMM registers when current compiled code uses
  965     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  966     __ vzeroupper();
  967   }
  968 
  969   int framesize = C-&gt;frame_size_in_bytes();
  970   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  971   // Remove word for return adr already pushed
</pre>
<hr />
<pre>
 1044 };
 1045 
 1046 static enum RC rc_class(OptoReg::Name reg)
 1047 {
 1048   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1049 
 1050   if (OptoReg::is_stack(reg)) return rc_stack;
 1051 
 1052   VMReg r = OptoReg::as_VMReg(reg);
 1053 
 1054   if (r-&gt;is_Register()) return rc_int;
 1055 
 1056   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
 1057   return rc_float;
 1058 }
 1059 
 1060 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1061 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1062                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1063 
<span class="line-modified"> 1064 int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,</span>
<span class="line-modified"> 1065                      int stack_offset, int reg, uint ireg, outputStream* st);</span>
 1066 
 1067 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1068                                       int dst_offset, uint ireg, outputStream* st) {
 1069   if (cbuf) {
 1070     MacroAssembler _masm(cbuf);
 1071     switch (ireg) {
 1072     case Op_VecS:
 1073       __ movq(Address(rsp, -8), rax);
 1074       __ movl(rax, Address(rsp, src_offset));
 1075       __ movl(Address(rsp, dst_offset), rax);
 1076       __ movq(rax, Address(rsp, -8));
 1077       break;
 1078     case Op_VecD:
 1079       __ pushq(Address(rsp, src_offset));
 1080       __ popq (Address(rsp, dst_offset));
 1081       break;
 1082     case Op_VecX:
 1083       __ pushq(Address(rsp, src_offset));
 1084       __ popq (Address(rsp, dst_offset));
 1085       __ pushq(Address(rsp, src_offset+8));
</pre>
<hr />
<pre>
 1663 
 1664 bool Matcher::narrow_oop_use_complex_address() {
 1665   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1666   return (LogMinObjAlignmentInBytes &lt;= 3);
 1667 }
 1668 
 1669 bool Matcher::narrow_klass_use_complex_address() {
 1670   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1671   return (LogKlassAlignmentInBytes &lt;= 3);
 1672 }
 1673 
 1674 bool Matcher::const_oop_prefer_decode() {
 1675   // Prefer ConN+DecodeN over ConP.
 1676   return true;
 1677 }
 1678 
 1679 bool Matcher::const_klass_prefer_decode() {
 1680   // TODO: Either support matching DecodeNKlass (heap-based) in operand
 1681   //       or condisider the following:
 1682   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<span class="line-modified"> 1683   //return CompressedKlassPointers::base() == NULL;</span>
 1684   return true;
 1685 }
 1686 
 1687 // Is it better to copy float constants, or load them directly from
 1688 // memory?  Intel can load a float constant from a direct address,
 1689 // requiring no extra registers.  Most RISCs will have to materialize
 1690 // an address into a register first, so they would do better to copy
 1691 // the constant from stack.
 1692 const bool Matcher::rematerialize_float_constants = true; // XXX
 1693 
 1694 // If CPU can load and store mis-aligned doubles directly then no
 1695 // fixup is needed.  Else we split the double into 2 integer pieces
 1696 // and move it piece-by-piece.  Only happens when passing doubles into
 1697 // C code as the Java calling convention forces doubles to be aligned.
 1698 const bool Matcher::misaligned_doubles_ok = true;
 1699 
 1700 // No-op on amd64
 1701 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1702 
<span class="line-modified"> 1703 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>
<span class="line-modified"> 1704 const bool Matcher::strict_fp_requires_explicit_rounding = false;</span>

 1705 
 1706 // Are floats conerted to double when stored to stack during deoptimization?
 1707 // On x64 it is stored without convertion so we can use normal access.
 1708 bool Matcher::float_in_double() { return false; }
 1709 
 1710 // Do ints take an entire long register or just half?
 1711 const bool Matcher::int_in_long = true;
 1712 
 1713 // Return whether or not this register is ever used as an argument.
 1714 // This function is used on startup to build the trampoline stubs in
 1715 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1716 // call in the trampoline, and arguments in those registers not be
 1717 // available to the callee.
 1718 bool Matcher::can_be_java_arg(int reg)
 1719 {
 1720   return
 1721     reg ==  RDI_num || reg == RDI_H_num ||
 1722     reg ==  RSI_num || reg == RSI_H_num ||
 1723     reg ==  RDX_num || reg == RDX_H_num ||
 1724     reg ==  RCX_num || reg == RCX_H_num ||
</pre>
<hr />
<pre>
 3101 %{
 3102   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3103   match(ConL);
 3104 
 3105   op_cost(10);
 3106   format %{ %}
 3107   interface(CONST_INTER);
 3108 %}
 3109 
 3110 // Long Immediate 32-bit signed
 3111 operand immL32()
 3112 %{
 3113   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3114   match(ConL);
 3115 
 3116   op_cost(15);
 3117   format %{ %}
 3118   interface(CONST_INTER);
 3119 %}
 3120 
<span class="line-added"> 3121 operand immL_Pow2()</span>
<span class="line-added"> 3122 %{</span>
<span class="line-added"> 3123   predicate(is_power_of_2(n-&gt;get_long()));</span>
<span class="line-added"> 3124   match(ConL);</span>
<span class="line-added"> 3125 </span>
<span class="line-added"> 3126   op_cost(15);</span>
<span class="line-added"> 3127   format %{ %}</span>
<span class="line-added"> 3128   interface(CONST_INTER);</span>
<span class="line-added"> 3129 %}</span>
<span class="line-added"> 3130 </span>
<span class="line-added"> 3131 operand immL_NotPow2()</span>
<span class="line-added"> 3132 %{</span>
<span class="line-added"> 3133   predicate(is_power_of_2(~n-&gt;get_long()));</span>
<span class="line-added"> 3134   match(ConL);</span>
<span class="line-added"> 3135 </span>
<span class="line-added"> 3136   op_cost(15);</span>
<span class="line-added"> 3137   format %{ %}</span>
<span class="line-added"> 3138   interface(CONST_INTER);</span>
<span class="line-added"> 3139 %}</span>
<span class="line-added"> 3140 </span>
 3141 // Long Immediate zero
 3142 operand immL0()
 3143 %{
 3144   predicate(n-&gt;get_long() == 0L);
 3145   match(ConL);
 3146 
 3147   op_cost(10);
 3148   format %{ %}
 3149   interface(CONST_INTER);
 3150 %}
 3151 
 3152 // Constant for increment
 3153 operand immL1()
 3154 %{
 3155   predicate(n-&gt;get_long() == 1);
 3156   match(ConL);
 3157 
 3158   format %{ %}
 3159   interface(CONST_INTER);
 3160 %}
</pre>
<hr />
<pre>
 3515 operand rbx_RegP()
 3516 %{
 3517   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3518   match(RegP);
 3519   match(rRegP);
 3520 
 3521   format %{ %}
 3522   interface(REG_INTER);
 3523 %}
 3524 
 3525 operand rsi_RegP()
 3526 %{
 3527   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3528   match(RegP);
 3529   match(rRegP);
 3530 
 3531   format %{ %}
 3532   interface(REG_INTER);
 3533 %}
 3534 
<span class="line-added"> 3535 operand rbp_RegP()</span>
<span class="line-added"> 3536 %{</span>
<span class="line-added"> 3537   constraint(ALLOC_IN_RC(ptr_rbp_reg));</span>
<span class="line-added"> 3538   match(RegP);</span>
<span class="line-added"> 3539   match(rRegP);</span>
<span class="line-added"> 3540 </span>
<span class="line-added"> 3541   format %{ %}</span>
<span class="line-added"> 3542   interface(REG_INTER);</span>
<span class="line-added"> 3543 %}</span>
<span class="line-added"> 3544 </span>
 3545 // Used in rep stosq
 3546 operand rdi_RegP()
 3547 %{
 3548   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3549   match(RegP);
 3550   match(rRegP);
 3551 
 3552   format %{ %}
 3553   interface(REG_INTER);
 3554 %}
 3555 
 3556 operand r15_RegP()
 3557 %{
 3558   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3559   match(RegP);
 3560   match(rRegP);
 3561 
 3562   format %{ %}
 3563   interface(REG_INTER);
 3564 %}
</pre>
<hr />
<pre>
 3702 %}
 3703 
 3704 // Double register operands
 3705 operand legRegD() %{
 3706    constraint(ALLOC_IN_RC(double_reg_legacy));
 3707    match(RegD);
 3708 
 3709    format %{ %}
 3710    interface(REG_INTER);
 3711 %}
 3712 
 3713 // Double register operands
 3714 operand vlRegD() %{
 3715    constraint(ALLOC_IN_RC(double_reg_vl));
 3716    match(RegD);
 3717 
 3718    format %{ %}
 3719    interface(REG_INTER);
 3720 %}
 3721 


































































 3722 //----------Memory Operands----------------------------------------------------
 3723 // Direct Memory Operand
 3724 // operand direct(immP addr)
 3725 // %{
 3726 //   match(addr);
 3727 
 3728 //   format %{ &quot;[$addr]&quot; %}
 3729 //   interface(MEMORY_INTER) %{
 3730 //     base(0xFFFFFFFF);
 3731 //     index(0x4);
 3732 //     scale(0x0);
 3733 //     disp($addr);
 3734 //   %}
 3735 // %}
 3736 
 3737 // Indirect Memory Operand
 3738 operand indirect(any_RegP reg)
 3739 %{
 3740   constraint(ALLOC_IN_RC(ptr_reg));
 3741   match(reg);
</pre>
<hr />
<pre>
 3878 
 3879 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3880 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3881 %{
 3882   constraint(ALLOC_IN_RC(ptr_reg));
 3883   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3884   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3885 
 3886   op_cost(10);
 3887   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3888   interface(MEMORY_INTER) %{
 3889     base($reg);
 3890     index($idx);
 3891     scale($scale);
 3892     disp($off);
 3893   %}
 3894 %}
 3895 
 3896 // Indirect Narrow Oop Plus Offset Operand
 3897 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
<span class="line-modified"> 3898 // we can&#39;t free r12 even with CompressedOops::base() == NULL.</span>
 3899 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
<span class="line-modified"> 3900   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));</span>
 3901   constraint(ALLOC_IN_RC(ptr_reg));
 3902   match(AddP (DecodeN reg) off);
 3903 
 3904   op_cost(10);
 3905   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3906   interface(MEMORY_INTER) %{
 3907     base(0xc); // R12
 3908     index($reg);
 3909     scale(0x3);
 3910     disp($off);
 3911   %}
 3912 %}
 3913 
 3914 // Indirect Memory Operand
 3915 operand indirectNarrow(rRegN reg)
 3916 %{
<span class="line-modified"> 3917   predicate(CompressedOops::shift() == 0);</span>
 3918   constraint(ALLOC_IN_RC(ptr_reg));
 3919   match(DecodeN reg);
 3920 
 3921   format %{ &quot;[$reg]&quot; %}
 3922   interface(MEMORY_INTER) %{
 3923     base($reg);
 3924     index(0x4);
 3925     scale(0x0);
 3926     disp(0x0);
 3927   %}
 3928 %}
 3929 
 3930 // Indirect Memory Plus Short Offset Operand
 3931 operand indOffset8Narrow(rRegN reg, immL8 off)
 3932 %{
<span class="line-modified"> 3933   predicate(CompressedOops::shift() == 0);</span>
 3934   constraint(ALLOC_IN_RC(ptr_reg));
 3935   match(AddP (DecodeN reg) off);
 3936 
 3937   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3938   interface(MEMORY_INTER) %{
 3939     base($reg);
 3940     index(0x4);
 3941     scale(0x0);
 3942     disp($off);
 3943   %}
 3944 %}
 3945 
 3946 // Indirect Memory Plus Long Offset Operand
 3947 operand indOffset32Narrow(rRegN reg, immL32 off)
 3948 %{
<span class="line-modified"> 3949   predicate(CompressedOops::shift() == 0);</span>
 3950   constraint(ALLOC_IN_RC(ptr_reg));
 3951   match(AddP (DecodeN reg) off);
 3952 
 3953   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3954   interface(MEMORY_INTER) %{
 3955     base($reg);
 3956     index(0x4);
 3957     scale(0x0);
 3958     disp($off);
 3959   %}
 3960 %}
 3961 
 3962 // Indirect Memory Plus Index Register Plus Offset Operand
 3963 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3964 %{
<span class="line-modified"> 3965   predicate(CompressedOops::shift() == 0);</span>
 3966   constraint(ALLOC_IN_RC(ptr_reg));
 3967   match(AddP (AddP (DecodeN reg) lreg) off);
 3968 
 3969   op_cost(10);
 3970   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3971   interface(MEMORY_INTER) %{
 3972     base($reg);
 3973     index($lreg);
 3974     scale(0x0);
 3975     disp($off);
 3976   %}
 3977 %}
 3978 
 3979 // Indirect Memory Plus Index Register Plus Offset Operand
 3980 operand indIndexNarrow(rRegN reg, rRegL lreg)
 3981 %{
<span class="line-modified"> 3982   predicate(CompressedOops::shift() == 0);</span>
 3983   constraint(ALLOC_IN_RC(ptr_reg));
 3984   match(AddP (DecodeN reg) lreg);
 3985 
 3986   op_cost(10);
 3987   format %{&quot;[$reg + $lreg]&quot; %}
 3988   interface(MEMORY_INTER) %{
 3989     base($reg);
 3990     index($lreg);
 3991     scale(0x0);
 3992     disp(0x0);
 3993   %}
 3994 %}
 3995 
 3996 // Indirect Memory Times Scale Plus Index Register
 3997 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 3998 %{
<span class="line-modified"> 3999   predicate(CompressedOops::shift() == 0);</span>
 4000   constraint(ALLOC_IN_RC(ptr_reg));
 4001   match(AddP (DecodeN reg) (LShiftL lreg scale));
 4002 
 4003   op_cost(10);
 4004   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 4005   interface(MEMORY_INTER) %{
 4006     base($reg);
 4007     index($lreg);
 4008     scale($scale);
 4009     disp(0x0);
 4010   %}
 4011 %}
 4012 
 4013 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4014 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 4015 %{
<span class="line-modified"> 4016   predicate(CompressedOops::shift() == 0);</span>
 4017   constraint(ALLOC_IN_RC(ptr_reg));
 4018   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 4019 
 4020   op_cost(10);
 4021   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 4022   interface(MEMORY_INTER) %{
 4023     base($reg);
 4024     index($lreg);
 4025     scale($scale);
 4026     disp($off);
 4027   %}
 4028 %}
 4029 
 4030 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 4031 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4032 %{
 4033   constraint(ALLOC_IN_RC(ptr_reg));
<span class="line-modified"> 4034   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);</span>
 4035   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4036 
 4037   op_cost(10);
 4038   format %{&quot;[$reg + $off + $idx]&quot; %}
 4039   interface(MEMORY_INTER) %{
 4040     base($reg);
 4041     index($idx);
 4042     scale(0x0);
 4043     disp($off);
 4044   %}
 4045 %}
 4046 
 4047 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4048 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4049 %{
 4050   constraint(ALLOC_IN_RC(ptr_reg));
<span class="line-modified"> 4051   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);</span>
 4052   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4053 
 4054   op_cost(10);
 4055   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4056   interface(MEMORY_INTER) %{
 4057     base($reg);
 4058     index($idx);
 4059     scale($scale);
 4060     disp($off);
 4061   %}
 4062 %}
 4063 
 4064 //----------Special Memory Operands--------------------------------------------
 4065 // Stack Slot Operand - This operand is used for loading and storing temporary
 4066 //                      values on the stack where a match requires a value to
 4067 //                      flow through memory.
 4068 operand stackSlotP(sRegP reg)
 4069 %{
 4070   constraint(ALLOC_IN_RC(stack_slots));
 4071   // No match rule because this operand is only generated in matching
</pre>
<hr />
<pre>
 4209 
 4210 
 4211 // Floating comparisons that can be fixed up with extra conditional jumps
 4212 operand cmpOpUCF2() %{
 4213   match(Bool);
 4214   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4215             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4216   format %{ &quot;&quot; %}
 4217   interface(COND_INTER) %{
 4218     equal(0x4, &quot;e&quot;);
 4219     not_equal(0x5, &quot;ne&quot;);
 4220     less(0x2, &quot;b&quot;);
 4221     greater_equal(0x3, &quot;nb&quot;);
 4222     less_equal(0x6, &quot;be&quot;);
 4223     greater(0x7, &quot;nbe&quot;);
 4224     overflow(0x0, &quot;o&quot;);
 4225     no_overflow(0x1, &quot;no&quot;);
 4226   %}
 4227 %}
 4228 


































































































































































































 4229 //----------OPERAND CLASSES----------------------------------------------------
 4230 // Operand Classes are groups of operands that are used as to simplify
 4231 // instruction definitions by not requiring the AD writer to specify separate
 4232 // instructions for every form of operand when the instruction accepts
 4233 // multiple operand types with the same basic encoding and format.  The classic
 4234 // case of this is memory operands.
 4235 
 4236 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4237                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
 4238                indCompressedOopOffset,
 4239                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4240                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4241                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4242 
 4243 //----------PIPELINE-----------------------------------------------------------
 4244 // Rules which define the behavior of the target architectures pipeline.
 4245 pipeline %{
 4246 
 4247 //----------ATTRIBUTES---------------------------------------------------------
 4248 attributes %{
</pre>
<hr />
<pre>
 5101 
 5102   ins_pipe(ialu_reg_mem); // XXX
 5103 %}
 5104 
 5105 // Load Range
 5106 instruct loadRange(rRegI dst, memory mem)
 5107 %{
 5108   match(Set dst (LoadRange mem));
 5109 
 5110   ins_cost(125); // XXX
 5111   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5112   opcode(0x8B);
 5113   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5114   ins_pipe(ialu_reg_mem);
 5115 %}
 5116 
 5117 // Load Pointer
 5118 instruct loadP(rRegP dst, memory mem)
 5119 %{
 5120   match(Set dst (LoadP mem));
<span class="line-added"> 5121   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);</span>
 5122 
 5123   ins_cost(125); // XXX
 5124   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5125   opcode(0x8B);
 5126   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5127   ins_pipe(ialu_reg_mem); // XXX
 5128 %}
 5129 
 5130 // Load Compressed Pointer
 5131 instruct loadN(rRegN dst, memory mem)
 5132 %{
 5133    match(Set dst (LoadN mem));
 5134 
 5135    ins_cost(125); // XXX
 5136    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5137    ins_encode %{
 5138      __ movl($dst$$Register, $mem$$Address);
 5139    %}
 5140    ins_pipe(ialu_reg_mem); // XXX
 5141 %}
</pre>
<hr />
<pre>
 5299   match(Set dst (MaxF a b));
 5300   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5301   format %{
 5302      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5303      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5304      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5305      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5306      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5307   %}
 5308   ins_encode %{
 5309     int vector_len = Assembler::AVX_128bit;
 5310     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5311     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5312     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5313     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5314     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5315  %}
 5316   ins_pipe( pipe_slow );
 5317 %}
 5318 
<span class="line-modified"> 5319 instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{</span>
 5320   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5321   match(Set dst (MaxF a b));
 5322   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5323 
 5324   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5325   ins_encode %{
 5326     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5327                     false /*min*/, true /*single*/);
 5328   %}
 5329   ins_pipe( pipe_slow );
 5330 %}
 5331 
 5332 // max = java.lang.Math.max(double a, double b)
 5333 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5334   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5335   match(Set dst (MaxD a b));
 5336   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5337   format %{
 5338      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5339      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5340      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5341      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5342      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5343   %}
 5344   ins_encode %{
 5345     int vector_len = Assembler::AVX_128bit;
 5346     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5347     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5348     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5349     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5350     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5351   %}
 5352   ins_pipe( pipe_slow );
 5353 %}
 5354 
<span class="line-modified"> 5355 instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{</span>
 5356   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5357   match(Set dst (MaxD a b));
 5358   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5359 
 5360   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5361   ins_encode %{
 5362     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5363                     false /*min*/, false /*single*/);
 5364   %}
 5365   ins_pipe( pipe_slow );
 5366 %}
 5367 
 5368 // min = java.lang.Math.min(float a, float b)
 5369 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5370   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5371   match(Set dst (MinF a b));
 5372   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5373   format %{
 5374      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5375      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5376      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5377      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5378      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5379   %}
 5380   ins_encode %{
 5381     int vector_len = Assembler::AVX_128bit;
 5382     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5383     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5384     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5385     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5386     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5387   %}
 5388   ins_pipe( pipe_slow );
 5389 %}
 5390 
<span class="line-modified"> 5391 instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{</span>
 5392   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5393   match(Set dst (MinF a b));
 5394   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5395 
 5396   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5397   ins_encode %{
 5398     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5399                     true /*min*/, true /*single*/);
 5400   %}
 5401   ins_pipe( pipe_slow );
 5402 %}
 5403 
 5404 // min = java.lang.Math.min(double a, double b)
 5405 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5406   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5407   match(Set dst (MinD a b));
 5408   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5409   format %{
 5410      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5411      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5412      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5413      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5414      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5415   %}
 5416   ins_encode %{
 5417     int vector_len = Assembler::AVX_128bit;
 5418     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5419     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5420     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5421     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5422     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5423   %}
 5424   ins_pipe( pipe_slow );
 5425 %}
 5426 
<span class="line-modified"> 5427 instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{</span>
 5428   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5429   match(Set dst (MinD a b));
 5430   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5431 
 5432   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5433   ins_encode %{
 5434     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5435                     true /*min*/, false /*single*/);
 5436   %}
 5437   ins_pipe( pipe_slow );
 5438 %}
 5439 
 5440 // Load Effective Address
 5441 instruct leaP8(rRegP dst, indOffset8 mem)
 5442 %{
 5443   match(Set dst mem);
 5444 
 5445   ins_cost(110); // XXX
 5446   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5447   opcode(0x8D);
</pre>
<hr />
<pre>
 5523   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5524   opcode(0x8D);
 5525   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5526   ins_pipe(ialu_reg_reg_fat);
 5527 %}
 5528 
 5529 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5530 %{
 5531   match(Set dst mem);
 5532 
 5533   ins_cost(110);
 5534   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5535   opcode(0x8D);
 5536   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5537   ins_pipe(ialu_reg_reg_fat);
 5538 %}
 5539 
 5540 // Load Effective Address which uses Narrow (32-bits) oop
 5541 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5542 %{
<span class="line-modified"> 5543   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() != 0));</span>
 5544   match(Set dst mem);
 5545 
 5546   ins_cost(110);
 5547   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5548   opcode(0x8D);
 5549   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5550   ins_pipe(ialu_reg_reg_fat);
 5551 %}
 5552 
 5553 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5554 %{
<span class="line-modified"> 5555   predicate(CompressedOops::shift() == 0);</span>
 5556   match(Set dst mem);
 5557 
 5558   ins_cost(110); // XXX
 5559   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5560   opcode(0x8D);
 5561   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5562   ins_pipe(ialu_reg_reg_fat);
 5563 %}
 5564 
 5565 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5566 %{
<span class="line-modified"> 5567   predicate(CompressedOops::shift() == 0);</span>
 5568   match(Set dst mem);
 5569 
 5570   ins_cost(110);
 5571   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5572   opcode(0x8D);
 5573   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5574   ins_pipe(ialu_reg_reg_fat);
 5575 %}
 5576 
 5577 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5578 %{
<span class="line-modified"> 5579   predicate(CompressedOops::shift() == 0);</span>
 5580   match(Set dst mem);
 5581 
 5582   ins_cost(110);
 5583   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5584   opcode(0x8D);
 5585   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5586   ins_pipe(ialu_reg_reg_fat);
 5587 %}
 5588 
 5589 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5590 %{
<span class="line-modified"> 5591   predicate(CompressedOops::shift() == 0);</span>
 5592   match(Set dst mem);
 5593 
 5594   ins_cost(110);
 5595   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5596   opcode(0x8D);
 5597   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5598   ins_pipe(ialu_reg_reg_fat);
 5599 %}
 5600 
 5601 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5602 %{
<span class="line-modified"> 5603   predicate(CompressedOops::shift() == 0);</span>
 5604   match(Set dst mem);
 5605 
 5606   ins_cost(110);
 5607   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5608   opcode(0x8D);
 5609   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5610   ins_pipe(ialu_reg_reg_fat);
 5611 %}
 5612 
 5613 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5614 %{
<span class="line-modified"> 5615   predicate(CompressedOops::shift() == 0);</span>
 5616   match(Set dst mem);
 5617 
 5618   ins_cost(110);
 5619   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5620   opcode(0x8D);
 5621   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5622   ins_pipe(ialu_reg_reg_fat);
 5623 %}
 5624 
 5625 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5626 %{
<span class="line-modified"> 5627   predicate(CompressedOops::shift() == 0);</span>
 5628   match(Set dst mem);
 5629 
 5630   ins_cost(110);
 5631   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5632   opcode(0x8D);
 5633   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5634   ins_pipe(ialu_reg_reg_fat);
 5635 %}
 5636 
 5637 instruct loadConI(rRegI dst, immI src)
 5638 %{
 5639   match(Set dst src);
 5640 
 5641   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5642   ins_encode(load_immI(dst, src));
 5643   ins_pipe(ialu_reg_fat); // XXX
 5644 %}
 5645 
 5646 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5647 %{
</pre>
<hr />
<pre>
 5971   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5972   opcode(0x89);
 5973   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5974   ins_pipe(ialu_mem_reg); // XXX
 5975 %}
 5976 
 5977 // Store Pointer
 5978 instruct storeP(memory mem, any_RegP src)
 5979 %{
 5980   match(Set mem (StoreP mem src));
 5981 
 5982   ins_cost(125); // XXX
 5983   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5984   opcode(0x89);
 5985   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5986   ins_pipe(ialu_mem_reg);
 5987 %}
 5988 
 5989 instruct storeImmP0(memory mem, immP0 zero)
 5990 %{
<span class="line-modified"> 5991   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 5992   match(Set mem (StoreP mem zero));
 5993 
 5994   ins_cost(125); // XXX
 5995   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5996   ins_encode %{
 5997     __ movq($mem$$Address, r12);
 5998   %}
 5999   ins_pipe(ialu_mem_reg);
 6000 %}
 6001 
 6002 // Store NULL Pointer, mark word, or other simple pointer constant.
 6003 instruct storeImmP(memory mem, immP31 src)
 6004 %{
 6005   match(Set mem (StoreP mem src));
 6006 
 6007   ins_cost(150); // XXX
 6008   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 6009   opcode(0xC7); /* C7 /0 */
 6010   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6011   ins_pipe(ialu_mem_imm);
</pre>
<hr />
<pre>
 6021   ins_encode %{
 6022     __ movl($mem$$Address, $src$$Register);
 6023   %}
 6024   ins_pipe(ialu_mem_reg);
 6025 %}
 6026 
 6027 instruct storeNKlass(memory mem, rRegN src)
 6028 %{
 6029   match(Set mem (StoreNKlass mem src));
 6030 
 6031   ins_cost(125); // XXX
 6032   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6033   ins_encode %{
 6034     __ movl($mem$$Address, $src$$Register);
 6035   %}
 6036   ins_pipe(ialu_mem_reg);
 6037 %}
 6038 
 6039 instruct storeImmN0(memory mem, immN0 zero)
 6040 %{
<span class="line-modified"> 6041   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedKlassPointers::base() == NULL);</span>
 6042   match(Set mem (StoreN mem zero));
 6043 
 6044   ins_cost(125); // XXX
 6045   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6046   ins_encode %{
 6047     __ movl($mem$$Address, r12);
 6048   %}
 6049   ins_pipe(ialu_mem_reg);
 6050 %}
 6051 
 6052 instruct storeImmN(memory mem, immN src)
 6053 %{
 6054   match(Set mem (StoreN mem src));
 6055 
 6056   ins_cost(150); // XXX
 6057   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6058   ins_encode %{
 6059     address con = (address)$src$$constant;
 6060     if (con == NULL) {
 6061       __ movl($mem$$Address, (int32_t)0);
</pre>
<hr />
<pre>
 6064     }
 6065   %}
 6066   ins_pipe(ialu_mem_imm);
 6067 %}
 6068 
 6069 instruct storeImmNKlass(memory mem, immNKlass src)
 6070 %{
 6071   match(Set mem (StoreNKlass mem src));
 6072 
 6073   ins_cost(150); // XXX
 6074   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6075   ins_encode %{
 6076     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6077   %}
 6078   ins_pipe(ialu_mem_imm);
 6079 %}
 6080 
 6081 // Store Integer Immediate
 6082 instruct storeImmI0(memory mem, immI0 zero)
 6083 %{
<span class="line-modified"> 6084   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6085   match(Set mem (StoreI mem zero));
 6086 
 6087   ins_cost(125); // XXX
 6088   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6089   ins_encode %{
 6090     __ movl($mem$$Address, r12);
 6091   %}
 6092   ins_pipe(ialu_mem_reg);
 6093 %}
 6094 
 6095 instruct storeImmI(memory mem, immI src)
 6096 %{
 6097   match(Set mem (StoreI mem src));
 6098 
 6099   ins_cost(150);
 6100   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6101   opcode(0xC7); /* C7 /0 */
 6102   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6103   ins_pipe(ialu_mem_imm);
 6104 %}
 6105 
 6106 // Store Long Immediate
 6107 instruct storeImmL0(memory mem, immL0 zero)
 6108 %{
<span class="line-modified"> 6109   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6110   match(Set mem (StoreL mem zero));
 6111 
 6112   ins_cost(125); // XXX
 6113   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6114   ins_encode %{
 6115     __ movq($mem$$Address, r12);
 6116   %}
 6117   ins_pipe(ialu_mem_reg);
 6118 %}
 6119 
 6120 instruct storeImmL(memory mem, immL32 src)
 6121 %{
 6122   match(Set mem (StoreL mem src));
 6123 
 6124   ins_cost(150);
 6125   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6126   opcode(0xC7); /* C7 /0 */
 6127   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6128   ins_pipe(ialu_mem_imm);
 6129 %}
 6130 
 6131 // Store Short/Char Immediate
 6132 instruct storeImmC0(memory mem, immI0 zero)
 6133 %{
<span class="line-modified"> 6134   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6135   match(Set mem (StoreC mem zero));
 6136 
 6137   ins_cost(125); // XXX
 6138   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6139   ins_encode %{
 6140     __ movw($mem$$Address, r12);
 6141   %}
 6142   ins_pipe(ialu_mem_reg);
 6143 %}
 6144 
 6145 instruct storeImmI16(memory mem, immI16 src)
 6146 %{
 6147   predicate(UseStoreImmI16);
 6148   match(Set mem (StoreC mem src));
 6149 
 6150   ins_cost(150);
 6151   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6152   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6153   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6154   ins_pipe(ialu_mem_imm);
 6155 %}
 6156 
 6157 // Store Byte Immediate
 6158 instruct storeImmB0(memory mem, immI0 zero)
 6159 %{
<span class="line-modified"> 6160   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6161   match(Set mem (StoreB mem zero));
 6162 
 6163   ins_cost(125); // XXX
 6164   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6165   ins_encode %{
 6166     __ movb($mem$$Address, r12);
 6167   %}
 6168   ins_pipe(ialu_mem_reg);
 6169 %}
 6170 
 6171 instruct storeImmB(memory mem, immI8 src)
 6172 %{
 6173   match(Set mem (StoreB mem src));
 6174 
 6175   ins_cost(150); // XXX
 6176   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6177   opcode(0xC6); /* C6 /0 */
 6178   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6179   ins_pipe(ialu_mem_imm);
 6180 %}
 6181 
 6182 // Store CMS card-mark Immediate
 6183 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6184 %{
<span class="line-modified"> 6185   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6186   match(Set mem (StoreCM mem zero));
 6187 
 6188   ins_cost(125); // XXX
 6189   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6190   ins_encode %{
 6191     __ movb($mem$$Address, r12);
 6192   %}
 6193   ins_pipe(ialu_mem_reg);
 6194 %}
 6195 
 6196 instruct storeImmCM0(memory mem, immI0 src)
 6197 %{
 6198   match(Set mem (StoreCM mem src));
 6199 
 6200   ins_cost(150); // XXX
 6201   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6202   opcode(0xC6); /* C6 /0 */
 6203   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6204   ins_pipe(ialu_mem_imm);
 6205 %}
 6206 
 6207 // Store Float
 6208 instruct storeF(memory mem, regF src)
 6209 %{
 6210   match(Set mem (StoreF mem src));
 6211 
 6212   ins_cost(95); // XXX
 6213   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6214   ins_encode %{
 6215     __ movflt($mem$$Address, $src$$XMMRegister);
 6216   %}
 6217   ins_pipe(pipe_slow); // XXX
 6218 %}
 6219 
 6220 // Store immediate Float value (it is faster than store from XMM register)
 6221 instruct storeF0(memory mem, immF0 zero)
 6222 %{
<span class="line-modified"> 6223   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6224   match(Set mem (StoreF mem zero));
 6225 
 6226   ins_cost(25); // XXX
 6227   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6228   ins_encode %{
 6229     __ movl($mem$$Address, r12);
 6230   %}
 6231   ins_pipe(ialu_mem_reg);
 6232 %}
 6233 
 6234 instruct storeF_imm(memory mem, immF src)
 6235 %{
 6236   match(Set mem (StoreF mem src));
 6237 
 6238   ins_cost(50);
 6239   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6240   opcode(0xC7); /* C7 /0 */
 6241   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6242   ins_pipe(ialu_mem_imm);
 6243 %}
 6244 
 6245 // Store Double
 6246 instruct storeD(memory mem, regD src)
 6247 %{
 6248   match(Set mem (StoreD mem src));
 6249 
 6250   ins_cost(95); // XXX
 6251   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6252   ins_encode %{
 6253     __ movdbl($mem$$Address, $src$$XMMRegister);
 6254   %}
 6255   ins_pipe(pipe_slow); // XXX
 6256 %}
 6257 
 6258 // Store immediate double 0.0 (it is faster than store from XMM register)
 6259 instruct storeD0_imm(memory mem, immD0 src)
 6260 %{
<span class="line-modified"> 6261   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));</span>
 6262   match(Set mem (StoreD mem src));
 6263 
 6264   ins_cost(50);
 6265   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6266   opcode(0xC7); /* C7 /0 */
 6267   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6268   ins_pipe(ialu_mem_imm);
 6269 %}
 6270 
 6271 instruct storeD0(memory mem, immD0 zero)
 6272 %{
<span class="line-modified"> 6273   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6274   match(Set mem (StoreD mem zero));
 6275 
 6276   ins_cost(25); // XXX
 6277   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6278   ins_encode %{
 6279     __ movq($mem$$Address, r12);
 6280   %}
 6281   ins_pipe(ialu_mem_reg);
 6282 %}
 6283 
 6284 instruct storeSSI(stackSlotI dst, rRegI src)
 6285 %{
 6286   match(Set dst src);
 6287 
 6288   ins_cost(100);
 6289   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6290   opcode(0x89);
 6291   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6292   ins_pipe( ialu_mem_reg );
 6293 %}
</pre>
<hr />
<pre>
 6321   ins_cost(95); // XXX
 6322   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6323   ins_encode %{
 6324     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6325   %}
 6326   ins_pipe(pipe_slow); // XXX
 6327 %}
 6328 
 6329 instruct storeSSD(stackSlotD dst, regD src)
 6330 %{
 6331   match(Set dst src);
 6332 
 6333   ins_cost(95); // XXX
 6334   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6335   ins_encode %{
 6336     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6337   %}
 6338   ins_pipe(pipe_slow); // XXX
 6339 %}
 6340 
<span class="line-added"> 6341 instruct cacheWB(indirect addr)</span>
<span class="line-added"> 6342 %{</span>
<span class="line-added"> 6343   predicate(VM_Version::supports_data_cache_line_flush());</span>
<span class="line-added"> 6344   match(CacheWB addr);</span>
<span class="line-added"> 6345 </span>
<span class="line-added"> 6346   ins_cost(100);</span>
<span class="line-added"> 6347   format %{&quot;cache wb $addr&quot; %}</span>
<span class="line-added"> 6348   ins_encode %{</span>
<span class="line-added"> 6349     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);</span>
<span class="line-added"> 6350     assert($addr$$disp == 0, &quot;should be&quot;);</span>
<span class="line-added"> 6351     __ cache_wb(Address($addr$$base$$Register, 0));</span>
<span class="line-added"> 6352   %}</span>
<span class="line-added"> 6353   ins_pipe(pipe_slow); // XXX</span>
<span class="line-added"> 6354 %}</span>
<span class="line-added"> 6355 </span>
<span class="line-added"> 6356 instruct cacheWBPreSync()</span>
<span class="line-added"> 6357 %{</span>
<span class="line-added"> 6358   predicate(VM_Version::supports_data_cache_line_flush());</span>
<span class="line-added"> 6359   match(CacheWBPreSync);</span>
<span class="line-added"> 6360 </span>
<span class="line-added"> 6361   ins_cost(100);</span>
<span class="line-added"> 6362   format %{&quot;cache wb presync&quot; %}</span>
<span class="line-added"> 6363   ins_encode %{</span>
<span class="line-added"> 6364     __ cache_wbsync(true);</span>
<span class="line-added"> 6365   %}</span>
<span class="line-added"> 6366   ins_pipe(pipe_slow); // XXX</span>
<span class="line-added"> 6367 %}</span>
<span class="line-added"> 6368 </span>
<span class="line-added"> 6369 instruct cacheWBPostSync()</span>
<span class="line-added"> 6370 %{</span>
<span class="line-added"> 6371   predicate(VM_Version::supports_data_cache_line_flush());</span>
<span class="line-added"> 6372   match(CacheWBPostSync);</span>
<span class="line-added"> 6373 </span>
<span class="line-added"> 6374   ins_cost(100);</span>
<span class="line-added"> 6375   format %{&quot;cache wb postsync&quot; %}</span>
<span class="line-added"> 6376   ins_encode %{</span>
<span class="line-added"> 6377     __ cache_wbsync(false);</span>
<span class="line-added"> 6378   %}</span>
<span class="line-added"> 6379   ins_pipe(pipe_slow); // XXX</span>
<span class="line-added"> 6380 %}</span>
<span class="line-added"> 6381 </span>
 6382 //----------BSWAP Instructions-------------------------------------------------
 6383 instruct bytes_reverse_int(rRegI dst) %{
 6384   match(Set dst (ReverseBytesI dst));
 6385 
 6386   format %{ &quot;bswapl  $dst&quot; %}
 6387   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6388   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6389   ins_pipe( ialu_reg );
 6390 %}
 6391 
 6392 instruct bytes_reverse_long(rRegL dst) %{
 6393   match(Set dst (ReverseBytesL dst));
 6394 
 6395   format %{ &quot;bswapq  $dst&quot; %}
 6396   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6397   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6398   ins_pipe( ialu_reg);
 6399 %}
 6400 
 6401 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
</pre>
<hr />
<pre>
 6731   %}
 6732   ins_pipe(ialu_reg_reg); // XXX
 6733 %}
 6734 
 6735 // Convert oop into int for vectors alignment masking
 6736 instruct convP2I(rRegI dst, rRegP src)
 6737 %{
 6738   match(Set dst (ConvL2I (CastP2X src)));
 6739 
 6740   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6741   ins_encode %{
 6742     __ movl($dst$$Register, $src$$Register);
 6743   %}
 6744   ins_pipe(ialu_reg_reg); // XXX
 6745 %}
 6746 
 6747 // Convert compressed oop into int for vectors alignment masking
 6748 // in case of 32bit oops (heap &lt; 4Gb).
 6749 instruct convN2I(rRegI dst, rRegN src)
 6750 %{
<span class="line-modified"> 6751   predicate(CompressedOops::shift() == 0);</span>
 6752   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6753 
 6754   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6755   ins_encode %{
 6756     __ movl($dst$$Register, $src$$Register);
 6757   %}
 6758   ins_pipe(ialu_reg_reg); // XXX
 6759 %}
 6760 
 6761 // Convert oop pointer into compressed form
 6762 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6763   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6764   match(Set dst (EncodeP src));
 6765   effect(KILL cr);
 6766   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6767   ins_encode %{
 6768     Register s = $src$$Register;
 6769     Register d = $dst$$Register;
 6770     if (s != d) {
 6771       __ movq(d, s);
</pre>
<hr />
<pre>
 7519 %{
 7520   match(Set dst (CastPP dst));
 7521 
 7522   size(0);
 7523   format %{ &quot;# castPP of $dst&quot; %}
 7524   ins_encode(/* empty encoding */);
 7525   ins_pipe(empty);
 7526 %}
 7527 
 7528 instruct castII(rRegI dst)
 7529 %{
 7530   match(Set dst (CastII dst));
 7531 
 7532   size(0);
 7533   format %{ &quot;# castII of $dst&quot; %}
 7534   ins_encode(/* empty encoding */);
 7535   ins_cost(0);
 7536   ins_pipe(empty);
 7537 %}
 7538 
<span class="line-added"> 7539 instruct castLL(rRegL dst)</span>
<span class="line-added"> 7540 %{</span>
<span class="line-added"> 7541   match(Set dst (CastLL dst));</span>
<span class="line-added"> 7542 </span>
<span class="line-added"> 7543   size(0);</span>
<span class="line-added"> 7544   format %{ &quot;# castLL of $dst&quot; %}</span>
<span class="line-added"> 7545   ins_encode(/* empty encoding */);</span>
<span class="line-added"> 7546   ins_cost(0);</span>
<span class="line-added"> 7547   ins_pipe(empty);</span>
<span class="line-added"> 7548 %}</span>
<span class="line-added"> 7549 </span>
 7550 // LoadP-locked same as a regular LoadP when used with compare-swap
 7551 instruct loadPLocked(rRegP dst, memory mem)
 7552 %{
 7553   match(Set dst (LoadPLocked mem));
 7554 
 7555   ins_cost(125); // XXX
 7556   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7557   opcode(0x8B);
 7558   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7559   ins_pipe(ialu_reg_mem); // XXX
 7560 %}
 7561 
 7562 // Conditional-store of the updated heap-top.
 7563 // Used during allocation of the shared heap.
 7564 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7565 
 7566 instruct storePConditional(memory heap_top_ptr,
 7567                            rax_RegP oldval, rRegP newval,
 7568                            rFlagsReg cr)
 7569 %{
<span class="line-added"> 7570   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
 7571   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7572 
 7573   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7574             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7575   opcode(0x0F, 0xB1);
 7576   ins_encode(lock_prefix,
 7577              REX_reg_mem_wide(newval, heap_top_ptr),
 7578              OpcP, OpcS,
 7579              reg_mem(newval, heap_top_ptr));
 7580   ins_pipe(pipe_cmpxchg);
 7581 %}
 7582 
 7583 // Conditional-store of an int value.
 7584 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7585 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7586 %{
 7587   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7588   effect(KILL oldval);
 7589 
 7590   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
</pre>
<hr />
<pre>
 7602 %{
 7603   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7604   effect(KILL oldval);
 7605 
 7606   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7607   opcode(0x0F, 0xB1);
 7608   ins_encode(lock_prefix,
 7609              REX_reg_mem_wide(newval, mem),
 7610              OpcP, OpcS,
 7611              reg_mem(newval, mem));
 7612   ins_pipe(pipe_cmpxchg);
 7613 %}
 7614 
 7615 
 7616 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7617 instruct compareAndSwapP(rRegI res,
 7618                          memory mem_ptr,
 7619                          rax_RegP oldval, rRegP newval,
 7620                          rFlagsReg cr)
 7621 %{
<span class="line-modified"> 7622   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
 7623   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7624   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7625   effect(KILL cr, KILL oldval);
 7626 
 7627   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7628             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7629             &quot;sete    $res\n\t&quot;
 7630             &quot;movzbl  $res, $res&quot; %}
 7631   opcode(0x0F, 0xB1);
 7632   ins_encode(lock_prefix,
 7633              REX_reg_mem_wide(newval, mem_ptr),
 7634              OpcP, OpcS,
 7635              reg_mem(newval, mem_ptr),
 7636              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7637              REX_reg_breg(res, res), // movzbl
 7638              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7639   ins_pipe( pipe_cmpxchg );
 7640 %}
 7641 
 7642 instruct compareAndSwapL(rRegI res,
</pre>
<hr />
<pre>
 7844                           rFlagsReg cr) %{
 7845   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7846   effect(KILL cr);
 7847 
 7848   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7849             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7850   opcode(0x0F, 0xB1);
 7851   ins_encode(lock_prefix,
 7852              REX_reg_mem(newval, mem_ptr),
 7853              OpcP, OpcS,
 7854              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7855           );
 7856   ins_pipe( pipe_cmpxchg );
 7857 %}
 7858 
 7859 instruct compareAndExchangeP(
 7860                          memory mem_ptr,
 7861                          rax_RegP oldval, rRegP newval,
 7862                          rFlagsReg cr)
 7863 %{
<span class="line-modified"> 7864   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
 7865   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7866   effect(KILL cr);
 7867 
 7868   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7869             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7870   opcode(0x0F, 0xB1);
 7871   ins_encode(lock_prefix,
 7872              REX_reg_mem_wide(newval, mem_ptr),
 7873              OpcP, OpcS,
 7874              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7875           );
 7876   ins_pipe( pipe_cmpxchg );
 7877 %}
 7878 
 7879 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7880   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7881   match(Set dummy (GetAndAddB mem add));
 7882   effect(KILL cr);
 7883   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7884   ins_encode %{
</pre>
<hr />
<pre>
 7989 instruct xchgI( memory mem, rRegI newval) %{
 7990   match(Set newval (GetAndSetI mem newval));
 7991   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7992   ins_encode %{
 7993     __ xchgl($newval$$Register, $mem$$Address);
 7994   %}
 7995   ins_pipe( pipe_cmpxchg );
 7996 %}
 7997 
 7998 instruct xchgL( memory mem, rRegL newval) %{
 7999   match(Set newval (GetAndSetL mem newval));
 8000   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 8001   ins_encode %{
 8002     __ xchgq($newval$$Register, $mem$$Address);
 8003   %}
 8004   ins_pipe( pipe_cmpxchg );
 8005 %}
 8006 
 8007 instruct xchgP( memory mem, rRegP newval) %{
 8008   match(Set newval (GetAndSetP mem newval));
<span class="line-added"> 8009   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);</span>
 8010   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 8011   ins_encode %{
 8012     __ xchgq($newval$$Register, $mem$$Address);
 8013   %}
 8014   ins_pipe( pipe_cmpxchg );
 8015 %}
 8016 
 8017 instruct xchgN( memory mem, rRegN newval) %{
 8018   match(Set newval (GetAndSetN mem newval));
 8019   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 8020   ins_encode %{
 8021     __ xchgl($newval$$Register, $mem$$Address);
 8022   %}
 8023   ins_pipe( pipe_cmpxchg );
 8024 %}
 8025 
<span class="line-added"> 8026 //----------Abs Instructions-------------------------------------------</span>
<span class="line-added"> 8027 </span>
<span class="line-added"> 8028 // Integer Absolute Instructions</span>
<span class="line-added"> 8029 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)</span>
<span class="line-added"> 8030 %{</span>
<span class="line-added"> 8031   match(Set dst (AbsI src));</span>
<span class="line-added"> 8032   effect(TEMP dst, TEMP tmp, KILL cr);</span>
<span class="line-added"> 8033   format %{ &quot;movl $tmp, $src\n\t&quot;</span>
<span class="line-added"> 8034             &quot;sarl $tmp, 31\n\t&quot;</span>
<span class="line-added"> 8035             &quot;movl $dst, $src\n\t&quot;</span>
<span class="line-added"> 8036             &quot;xorl $dst, $tmp\n\t&quot;</span>
<span class="line-added"> 8037             &quot;subl $dst, $tmp\n&quot;</span>
<span class="line-added"> 8038           %}</span>
<span class="line-added"> 8039   ins_encode %{</span>
<span class="line-added"> 8040     __ movl($tmp$$Register, $src$$Register);</span>
<span class="line-added"> 8041     __ sarl($tmp$$Register, 31);</span>
<span class="line-added"> 8042     __ movl($dst$$Register, $src$$Register);</span>
<span class="line-added"> 8043     __ xorl($dst$$Register, $tmp$$Register);</span>
<span class="line-added"> 8044     __ subl($dst$$Register, $tmp$$Register);</span>
<span class="line-added"> 8045   %}</span>
<span class="line-added"> 8046 </span>
<span class="line-added"> 8047   ins_pipe(ialu_reg_reg);</span>
<span class="line-added"> 8048 %}</span>
<span class="line-added"> 8049 </span>
<span class="line-added"> 8050 // Long Absolute Instructions</span>
<span class="line-added"> 8051 instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)</span>
<span class="line-added"> 8052 %{</span>
<span class="line-added"> 8053   match(Set dst (AbsL src));</span>
<span class="line-added"> 8054   effect(TEMP dst, TEMP tmp, KILL cr);</span>
<span class="line-added"> 8055   format %{ &quot;movq $tmp, $src\n\t&quot;</span>
<span class="line-added"> 8056             &quot;sarq $tmp, 63\n\t&quot;</span>
<span class="line-added"> 8057             &quot;movq $dst, $src\n\t&quot;</span>
<span class="line-added"> 8058             &quot;xorq $dst, $tmp\n\t&quot;</span>
<span class="line-added"> 8059             &quot;subq $dst, $tmp\n&quot;</span>
<span class="line-added"> 8060           %}</span>
<span class="line-added"> 8061   ins_encode %{</span>
<span class="line-added"> 8062     __ movq($tmp$$Register, $src$$Register);</span>
<span class="line-added"> 8063     __ sarq($tmp$$Register, 63);</span>
<span class="line-added"> 8064     __ movq($dst$$Register, $src$$Register);</span>
<span class="line-added"> 8065     __ xorq($dst$$Register, $tmp$$Register);</span>
<span class="line-added"> 8066     __ subq($dst$$Register, $tmp$$Register);</span>
<span class="line-added"> 8067   %}</span>
<span class="line-added"> 8068 </span>
<span class="line-added"> 8069   ins_pipe(ialu_reg_reg);</span>
<span class="line-added"> 8070 %}</span>
<span class="line-added"> 8071 </span>
 8072 //----------Subtraction Instructions-------------------------------------------
 8073 
 8074 // Integer Subtraction Instructions
 8075 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8076 %{
 8077   match(Set dst (SubI dst src));
 8078   effect(KILL cr);
 8079 
 8080   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8081   opcode(0x2B);
 8082   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8083   ins_pipe(ialu_reg_reg);
 8084 %}
 8085 
 8086 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8087 %{
 8088   match(Set dst (SubI dst src));
 8089   effect(KILL cr);
 8090 
 8091   format %{ &quot;subl    $dst, $src\t# int&quot; %}
</pre>
<hr />
<pre>
 9790   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9791   opcode(0x21); /* Opcode 21 /r */
 9792   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9793   ins_pipe(ialu_mem_reg);
 9794 %}
 9795 
 9796 // And Memory with Immediate
 9797 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9798 %{
 9799   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9800   effect(KILL cr);
 9801 
 9802   ins_cost(125);
 9803   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9804   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9805   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9806              RM_opc_mem(secondary, dst), Con8or32(src));
 9807   ins_pipe(ialu_mem_imm);
 9808 %}
 9809 
<span class="line-added"> 9810 instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)</span>
<span class="line-added"> 9811 %{</span>
<span class="line-added"> 9812   // con should be a pure 64-bit immediate given that not(con) is a power of 2</span>
<span class="line-added"> 9813   // because AND/OR works well enough for 8/32-bit values.</span>
<span class="line-added"> 9814   predicate(log2_long(~n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 30);</span>
<span class="line-added"> 9815 </span>
<span class="line-added"> 9816   match(Set dst (StoreL dst (AndL (LoadL dst) con)));</span>
<span class="line-added"> 9817   effect(KILL cr);</span>
<span class="line-added"> 9818 </span>
<span class="line-added"> 9819   ins_cost(125);</span>
<span class="line-added"> 9820   format %{ &quot;btrq    $dst, log2(not($con))\t# long&quot; %}</span>
<span class="line-added"> 9821   ins_encode %{</span>
<span class="line-added"> 9822     __ btrq($dst$$Address, log2_long(~$con$$constant));</span>
<span class="line-added"> 9823   %}</span>
<span class="line-added"> 9824   ins_pipe(ialu_mem_imm);</span>
<span class="line-added"> 9825 %}</span>
<span class="line-added"> 9826 </span>
 9827 // BMI1 instructions
 9828 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9829   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9830   predicate(UseBMI1Instructions);
 9831   effect(KILL cr);
 9832 
 9833   ins_cost(125);
 9834   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9835 
 9836   ins_encode %{
 9837     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9838   %}
 9839   ins_pipe(ialu_reg_mem);
 9840 %}
 9841 
 9842 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9843   match(Set dst (AndL (XorL src1 minus_1) src2));
 9844   predicate(UseBMI1Instructions);
 9845   effect(KILL cr);
 9846 
</pre>
<hr />
<pre>
10000   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10001   opcode(0x09); /* Opcode 09 /r */
10002   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10003   ins_pipe(ialu_mem_reg);
10004 %}
10005 
10006 // Or Memory with Immediate
10007 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10008 %{
10009   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10010   effect(KILL cr);
10011 
10012   ins_cost(125);
10013   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10014   opcode(0x81, 0x1); /* Opcode 81 /1 id */
10015   ins_encode(REX_mem_wide(dst), OpcSE(src),
10016              RM_opc_mem(secondary, dst), Con8or32(src));
10017   ins_pipe(ialu_mem_imm);
10018 %}
10019 
<span class="line-added">10020 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)</span>
<span class="line-added">10021 %{</span>
<span class="line-added">10022   // con should be a pure 64-bit power of 2 immediate</span>
<span class="line-added">10023   // because AND/OR works well enough for 8/32-bit values.</span>
<span class="line-added">10024   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);</span>
<span class="line-added">10025 </span>
<span class="line-added">10026   match(Set dst (StoreL dst (OrL (LoadL dst) con)));</span>
<span class="line-added">10027   effect(KILL cr);</span>
<span class="line-added">10028 </span>
<span class="line-added">10029   ins_cost(125);</span>
<span class="line-added">10030   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}</span>
<span class="line-added">10031   ins_encode %{</span>
<span class="line-added">10032     __ btsq($dst$$Address, log2_long($con$$constant));</span>
<span class="line-added">10033   %}</span>
<span class="line-added">10034   ins_pipe(ialu_mem_imm);</span>
<span class="line-added">10035 %}</span>
<span class="line-added">10036 </span>
10037 // Xor Instructions
10038 // Xor Register with Register
10039 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10040 %{
10041   match(Set dst (XorL dst src));
10042   effect(KILL cr);
10043 
10044   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10045   opcode(0x33);
10046   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10047   ins_pipe(ialu_reg_reg);
10048 %}
10049 
10050 // Xor Register with Immediate -1
10051 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10052   match(Set dst (XorL dst imm));
10053 
10054   format %{ &quot;notq   $dst&quot; %}
10055   ins_encode %{
10056      __ notq($dst$$Register);
</pre>
<hr />
<pre>
10162 
10163 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10164 %{
10165   match(Set dst (CmpLTMask dst zero));
10166   effect(KILL cr);
10167 
10168   ins_cost(100);
10169   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10170   ins_encode %{
10171   __ sarl($dst$$Register, 31);
10172   %}
10173   ins_pipe(ialu_reg);
10174 %}
10175 
10176 /* Better to save a register than avoid a branch */
10177 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10178 %{
10179   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10180   effect(KILL cr);
10181   ins_cost(300);
<span class="line-modified">10182   format %{ &quot;subl    $p,$q\t# cadd_cmpLTMask\n\t&quot;</span>
<span class="line-modified">10183             &quot;jge     done\n\t&quot;</span>
<span class="line-modified">10184             &quot;addl    $p,$y\n&quot;</span>
<span class="line-modified">10185             &quot;done:   &quot; %}</span>
10186   ins_encode %{
10187     Register Rp = $p$$Register;
10188     Register Rq = $q$$Register;
10189     Register Ry = $y$$Register;
10190     Label done;
10191     __ subl(Rp, Rq);
10192     __ jccb(Assembler::greaterEqual, done);
10193     __ addl(Rp, Ry);
10194     __ bind(done);
10195   %}
10196   ins_pipe(pipe_cmplt);
10197 %}
10198 
10199 /* Better to save a register than avoid a branch */
10200 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10201 %{
10202   match(Set y (AndI (CmpLTMask p q) y));
10203   effect(KILL cr);
10204 
10205   ins_cost(300);
10206 
<span class="line-modified">10207   format %{ &quot;cmpl    $p, $q\t# and_cmpLTMask\n\t&quot;</span>
<span class="line-modified">10208             &quot;jlt     done\n\t&quot;</span>
<span class="line-modified">10209             &quot;xorl    $y, $y\n&quot;</span>
<span class="line-modified">10210             &quot;done:   &quot; %}</span>
10211   ins_encode %{
10212     Register Rp = $p$$Register;
10213     Register Rq = $q$$Register;
10214     Register Ry = $y$$Register;
10215     Label done;
10216     __ cmpl(Rp, Rq);
10217     __ jccb(Assembler::less, done);
10218     __ xorl(Ry, Ry);
10219     __ bind(done);
10220   %}
10221   ins_pipe(pipe_cmplt);
10222 %}
10223 
10224 
10225 //---------- FP Instructions------------------------------------------------
10226 
10227 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10228 %{
10229   match(Set cr (CmpF src1 src2));
10230 
</pre>
<hr />
<pre>
10503   match(Set dst (CmpD3 src con));
10504   effect(KILL cr);
10505 
10506   ins_cost(275);
10507   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10508             &quot;movl    $dst, #-1\n\t&quot;
10509             &quot;jp,s    done\n\t&quot;
10510             &quot;jb,s    done\n\t&quot;
10511             &quot;setne   $dst\n\t&quot;
10512             &quot;movzbl  $dst, $dst\n&quot;
10513     &quot;done:&quot; %}
10514   ins_encode %{
10515     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10516     emit_cmpfp3(_masm, $dst$$Register);
10517   %}
10518   ins_pipe(pipe_slow);
10519 %}
10520 
10521 //----------Arithmetic Conversion Instructions---------------------------------
10522 


















10523 instruct convF2D_reg_reg(regD dst, regF src)
10524 %{
10525   match(Set dst (ConvF2D src));
10526 
10527   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10528   ins_encode %{
10529     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10530   %}
10531   ins_pipe(pipe_slow); // XXX
10532 %}
10533 
10534 instruct convF2D_reg_mem(regD dst, memory src)
10535 %{
10536   match(Set dst (ConvF2D (LoadF src)));
10537 
10538   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10539   ins_encode %{
10540     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10541   %}
10542   ins_pipe(pipe_slow); // XXX
</pre>
<hr />
<pre>
10552   %}
10553   ins_pipe(pipe_slow); // XXX
10554 %}
10555 
10556 instruct convD2F_reg_mem(regF dst, memory src)
10557 %{
10558   match(Set dst (ConvD2F (LoadD src)));
10559 
10560   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10561   ins_encode %{
10562     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10563   %}
10564   ins_pipe(pipe_slow); // XXX
10565 %}
10566 
10567 // XXX do mem variants
10568 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10569 %{
10570   match(Set dst (ConvF2I src));
10571   effect(KILL cr);
<span class="line-modified">10572   format %{ &quot;convert_f2i $dst,$src&quot; %}</span>








10573   ins_encode %{
<span class="line-modified">10574     __ convert_f2i($dst$$Register, $src$$XMMRegister);</span>








10575   %}
10576   ins_pipe(pipe_slow);
10577 %}
10578 
10579 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10580 %{
10581   match(Set dst (ConvF2L src));
10582   effect(KILL cr);
<span class="line-modified">10583   format %{ &quot;convert_f2l $dst,$src&quot;%}</span>








10584   ins_encode %{
<span class="line-modified">10585     __ convert_f2l($dst$$Register, $src$$XMMRegister);</span>









10586   %}
10587   ins_pipe(pipe_slow);
10588 %}
10589 
10590 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10591 %{
10592   match(Set dst (ConvD2I src));
10593   effect(KILL cr);
<span class="line-modified">10594   format %{ &quot;convert_d2i $dst,$src&quot;%}</span>








10595   ins_encode %{
<span class="line-modified">10596     __ convert_d2i($dst$$Register, $src$$XMMRegister);</span>








10597   %}
10598   ins_pipe(pipe_slow);
10599 %}
10600 
10601 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10602 %{
10603   match(Set dst (ConvD2L src));
10604   effect(KILL cr);
<span class="line-modified">10605   format %{ &quot;convert_d2l $dst,$src&quot;%}</span>








10606   ins_encode %{
<span class="line-modified">10607     __ convert_d2l($dst$$Register, $src$$XMMRegister);</span>









10608   %}
10609   ins_pipe(pipe_slow);
10610 %}
10611 
10612 instruct convI2F_reg_reg(regF dst, rRegI src)
10613 %{
10614   predicate(!UseXmmI2F);
10615   match(Set dst (ConvI2F src));
10616 
10617   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10618   ins_encode %{
10619     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10620   %}
10621   ins_pipe(pipe_slow); // XXX
10622 %}
10623 
10624 instruct convI2F_reg_mem(regF dst, memory src)
10625 %{
10626   match(Set dst (ConvI2F (LoadI src)));
10627 
</pre>
<hr />
<pre>
11056        $$emit$$&quot;dec     rcx\n\t&quot;
11057        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11058        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11059        $$emit$$&quot;add     0x8,rax\n\t&quot;
11060        $$emit$$&quot;dec     rcx\n\t&quot;
11061        $$emit$$&quot;jge     L_sloop\n\t&quot;
11062        $$emit$$&quot;# L_end:\n\t&quot;
11063     } else {
11064        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
11065        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11066     }
11067   %}
11068   ins_encode %{
11069     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11070                  $tmp$$XMMRegister, true);
11071   %}
11072   ins_pipe(pipe_slow);
11073 %}
11074 
11075 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<span class="line-modified">11076                          rax_RegI result, legRegD tmp1, rFlagsReg cr)</span>
11077 %{
11078   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11079   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11080   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11081 
11082   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11083   ins_encode %{
11084     __ string_compare($str1$$Register, $str2$$Register,
11085                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11086                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11087   %}
11088   ins_pipe( pipe_slow );
11089 %}
11090 
11091 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<span class="line-modified">11092                          rax_RegI result, legRegD tmp1, rFlagsReg cr)</span>
11093 %{
11094   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11095   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11096   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11097 
11098   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11099   ins_encode %{
11100     __ string_compare($str1$$Register, $str2$$Register,
11101                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11102                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11103   %}
11104   ins_pipe( pipe_slow );
11105 %}
11106 
11107 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<span class="line-modified">11108                           rax_RegI result, legRegD tmp1, rFlagsReg cr)</span>
11109 %{
11110   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11111   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11112   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11113 
11114   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11115   ins_encode %{
11116     __ string_compare($str1$$Register, $str2$$Register,
11117                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11118                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11119   %}
11120   ins_pipe( pipe_slow );
11121 %}
11122 
11123 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
<span class="line-modified">11124                           rax_RegI result, legRegD tmp1, rFlagsReg cr)</span>
11125 %{
11126   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11127   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11128   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11129 
11130   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11131   ins_encode %{
11132     __ string_compare($str2$$Register, $str1$$Register,
11133                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11134                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11135   %}
11136   ins_pipe( pipe_slow );
11137 %}
11138 
11139 // fast search of substring with known size.
11140 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<span class="line-modified">11141                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
11142 %{
11143   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11144   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">11145   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11146 
<span class="line-modified">11147   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}</span>
11148   ins_encode %{
11149     int icnt2 = (int)$int_cnt2$$constant;
11150     if (icnt2 &gt;= 16) {
11151       // IndexOf for constant substrings with size &gt;= 16 elements
11152       // which don&#39;t need to be loaded through stack.
11153       __ string_indexofC8($str1$$Register, $str2$$Register,
11154                           $cnt1$$Register, $cnt2$$Register,
11155                           icnt2, $result$$Register,
<span class="line-modified">11156                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11157     } else {
11158       // Small strings are loaded through stack if they cross page boundary.
11159       __ string_indexof($str1$$Register, $str2$$Register,
11160                         $cnt1$$Register, $cnt2$$Register,
11161                         icnt2, $result$$Register,
<span class="line-modified">11162                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11163     }
11164   %}
11165   ins_pipe( pipe_slow );
11166 %}
11167 
11168 // fast search of substring with known size.
11169 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<span class="line-modified">11170                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
11171 %{
11172   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11173   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">11174   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11175 
<span class="line-modified">11176   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}</span>
11177   ins_encode %{
11178     int icnt2 = (int)$int_cnt2$$constant;
11179     if (icnt2 &gt;= 8) {
11180       // IndexOf for constant substrings with size &gt;= 8 elements
11181       // which don&#39;t need to be loaded through stack.
11182       __ string_indexofC8($str1$$Register, $str2$$Register,
11183                           $cnt1$$Register, $cnt2$$Register,
11184                           icnt2, $result$$Register,
<span class="line-modified">11185                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11186     } else {
11187       // Small strings are loaded through stack if they cross page boundary.
11188       __ string_indexof($str1$$Register, $str2$$Register,
11189                         $cnt1$$Register, $cnt2$$Register,
11190                         icnt2, $result$$Register,
<span class="line-modified">11191                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11192     }
11193   %}
11194   ins_pipe( pipe_slow );
11195 %}
11196 
11197 // fast search of substring with known size.
11198 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<span class="line-modified">11199                               rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
11200 %{
11201   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11202   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<span class="line-modified">11203   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11204 
<span class="line-modified">11205   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}</span>
11206   ins_encode %{
11207     int icnt2 = (int)$int_cnt2$$constant;
11208     if (icnt2 &gt;= 8) {
11209       // IndexOf for constant substrings with size &gt;= 8 elements
11210       // which don&#39;t need to be loaded through stack.
11211       __ string_indexofC8($str1$$Register, $str2$$Register,
11212                           $cnt1$$Register, $cnt2$$Register,
11213                           icnt2, $result$$Register,
<span class="line-modified">11214                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11215     } else {
11216       // Small strings are loaded through stack if they cross page boundary.
11217       __ string_indexof($str1$$Register, $str2$$Register,
11218                         $cnt1$$Register, $cnt2$$Register,
11219                         icnt2, $result$$Register,
<span class="line-modified">11220                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11221     }
11222   %}
11223   ins_pipe( pipe_slow );
11224 %}
11225 
11226 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<span class="line-modified">11227                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)</span>
11228 %{
11229   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11230   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">11231   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11232 
11233   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11234   ins_encode %{
11235     __ string_indexof($str1$$Register, $str2$$Register,
11236                       $cnt1$$Register, $cnt2$$Register,
11237                       (-1), $result$$Register,
<span class="line-modified">11238                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11239   %}
11240   ins_pipe( pipe_slow );
11241 %}
11242 
11243 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<span class="line-modified">11244                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)</span>
11245 %{
11246   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11247   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">11248   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11249 
11250   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11251   ins_encode %{
11252     __ string_indexof($str1$$Register, $str2$$Register,
11253                       $cnt1$$Register, $cnt2$$Register,
11254                       (-1), $result$$Register,
<span class="line-modified">11255                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11256   %}
11257   ins_pipe( pipe_slow );
11258 %}
11259 
11260 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<span class="line-modified">11261                           rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)</span>
11262 %{
11263   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11264   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<span class="line-modified">11265   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11266 
11267   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11268   ins_encode %{
11269     __ string_indexof($str1$$Register, $str2$$Register,
11270                       $cnt1$$Register, $cnt2$$Register,
11271                       (-1), $result$$Register,
<span class="line-modified">11272                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11273   %}
11274   ins_pipe( pipe_slow );
11275 %}
11276 
11277 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
<span class="line-modified">11278                               rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)</span>
11279 %{
11280   predicate(UseSSE42Intrinsics);
11281   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
<span class="line-modified">11282   effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);</span>
11283   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11284   ins_encode %{
11285     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
<span class="line-modified">11286                            $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);</span>
11287   %}
11288   ins_pipe( pipe_slow );
11289 %}
11290 
11291 // fast string equals
11292 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
<span class="line-modified">11293                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)</span>
11294 %{
11295   match(Set result (StrEquals (Binary str1 str2) cnt));
11296   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11297 
11298   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11299   ins_encode %{
11300     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11301                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11302                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11303   %}
11304   ins_pipe( pipe_slow );
11305 %}
11306 
11307 // fast array equals
11308 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
<span class="line-modified">11309                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)</span>
11310 %{
11311   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11312   match(Set result (AryEq ary1 ary2));
11313   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11314 
11315   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11316   ins_encode %{
11317     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11318                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11319                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11320   %}
11321   ins_pipe( pipe_slow );
11322 %}
11323 
11324 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
<span class="line-modified">11325                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)</span>
11326 %{
11327   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11328   match(Set result (AryEq ary1 ary2));
11329   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11330 
11331   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11332   ins_encode %{
11333     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11334                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11335                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11336   %}
11337   ins_pipe( pipe_slow );
11338 %}
11339 
11340 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
<span class="line-modified">11341                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)</span>
11342 %{
11343   match(Set result (HasNegatives ary1 len));
11344   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11345 
11346   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11347   ins_encode %{
11348     __ has_negatives($ary1$$Register, $len$$Register,
11349                      $result$$Register, $tmp3$$Register,
11350                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11351   %}
11352   ins_pipe( pipe_slow );
11353 %}
11354 
11355 // fast char[] to byte[] compression
<span class="line-modified">11356 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,</span>
11357                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11358   match(Set result (StrCompressedCopy src (Binary dst len)));
11359   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11360 
11361   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11362   ins_encode %{
11363     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11364                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11365                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11366   %}
11367   ins_pipe( pipe_slow );
11368 %}
11369 
11370 // fast byte[] to char[] inflation
11371 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
<span class="line-modified">11372                         legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{</span>
11373   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11374   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11375 
11376   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11377   ins_encode %{
11378     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11379                           $tmp1$$XMMRegister, $tmp2$$Register);
11380   %}
11381   ins_pipe( pipe_slow );
11382 %}
11383 
11384 // encode char[] to byte[] in ISO_8859_1
11385 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
<span class="line-modified">11386                           legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,</span>
11387                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11388   match(Set result (EncodeISOArray src (Binary dst len)));
11389   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11390 
11391   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11392   ins_encode %{
11393     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11394                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11395                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11396   %}
11397   ins_pipe( pipe_slow );
11398 %}
11399 
11400 //----------Overflow Math Instructions-----------------------------------------
11401 
11402 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11403 %{
11404   match(Set cr (OverflowAddI op1 op2));
11405   effect(DEF cr, USE_KILL op1, USE op2);
11406 
</pre>
<hr />
<pre>
11663   opcode(0x3B); /* Opcode 3B /r */
11664   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11665   ins_pipe(ialu_cr_reg_mem);
11666 %}
11667 
11668 // // // Cisc-spilled version of cmpU_rReg
11669 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11670 // //%{
11671 // //  match(Set cr (CmpU (LoadI op1) op2));
11672 // //
11673 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11674 // //  ins_cost(500);
11675 // //  opcode(0x39);  /* Opcode 39 /r */
11676 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11677 // //%}
11678 
11679 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11680 %{
11681   match(Set cr (CmpU src zero));
11682 
<span class="line-modified">11683   format %{ &quot;testl   $src, $src\t# unsigned&quot; %}</span>
11684   opcode(0x85);
11685   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11686   ins_pipe(ialu_cr_reg_imm);
11687 %}
11688 
11689 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11690 %{
11691   match(Set cr (CmpP op1 op2));
11692 
11693   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11694   opcode(0x3B); /* Opcode 3B /r */
11695   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11696   ins_pipe(ialu_cr_reg_reg);
11697 %}
11698 
11699 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11700 %{
11701   match(Set cr (CmpP op1 (LoadP op2)));
<span class="line-added">11702   predicate(n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);</span>
11703 
11704   ins_cost(500); // XXX
11705   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11706   opcode(0x3B); /* Opcode 3B /r */
11707   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11708   ins_pipe(ialu_cr_reg_mem);
11709 %}
11710 
11711 // // // Cisc-spilled version of cmpP_rReg
11712 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11713 // //%{
11714 // //  match(Set cr (CmpP (LoadP op1) op2));
11715 // //
11716 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11717 // //  ins_cost(500);
11718 // //  opcode(0x39);  /* Opcode 39 /r */
11719 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11720 // //%}
11721 
11722 // XXX this is generalized by compP_rReg_mem???
11723 // Compare raw pointer (used in out-of-heap check).
11724 // Only works because non-oop pointers must be raw pointers
11725 // and raw pointers have no anti-dependencies.
11726 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11727 %{
<span class="line-modified">11728   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none &amp;&amp;</span>
<span class="line-added">11729             n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);</span>
11730   match(Set cr (CmpP op1 (LoadP op2)));
11731 
11732   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11733   opcode(0x3B); /* Opcode 3B /r */
11734   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11735   ins_pipe(ialu_cr_reg_mem);
11736 %}
11737 
11738 // This will generate a signed flags result. This should be OK since
11739 // any compare to a zero should be eq/neq.
11740 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11741 %{
11742   match(Set cr (CmpP src zero));
11743 
11744   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11745   opcode(0x85);
11746   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11747   ins_pipe(ialu_cr_reg_imm);
11748 %}
11749 
11750 // This will generate a signed flags result. This should be OK since
11751 // any compare to a zero should be eq/neq.
11752 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11753 %{
<span class="line-modified">11754   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;</span>
<span class="line-added">11755             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);</span>
11756   match(Set cr (CmpP (LoadP op) zero));
11757 
11758   ins_cost(500); // XXX
11759   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11760   opcode(0xF7); /* Opcode F7 /0 */
11761   ins_encode(REX_mem_wide(op),
11762              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11763   ins_pipe(ialu_cr_reg_imm);
11764 %}
11765 
11766 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11767 %{
<span class="line-modified">11768   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;</span>
<span class="line-added">11769             (CompressedKlassPointers::base() == NULL) &amp;&amp;</span>
<span class="line-added">11770             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);</span>
11771   match(Set cr (CmpP (LoadP mem) zero));
11772 
11773   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11774   ins_encode %{
11775     __ cmpq(r12, $mem$$Address);
11776   %}
11777   ins_pipe(ialu_cr_reg_mem);
11778 %}
11779 
11780 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11781 %{
11782   match(Set cr (CmpN op1 op2));
11783 
11784   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11785   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11786   ins_pipe(ialu_cr_reg_reg);
11787 %}
11788 
11789 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11790 %{
</pre>
<hr />
<pre>
11832 %{
11833   match(Set cr (CmpN src (LoadNKlass mem)));
11834 
11835   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
11836   ins_encode %{
11837     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11838   %}
11839   ins_pipe(ialu_cr_reg_mem);
11840 %}
11841 
11842 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
11843   match(Set cr (CmpN src zero));
11844 
11845   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11846   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11847   ins_pipe(ialu_cr_reg_imm);
11848 %}
11849 
11850 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11851 %{
<span class="line-modified">11852   predicate(CompressedOops::base() != NULL);</span>
11853   match(Set cr (CmpN (LoadN mem) zero));
11854 
11855   ins_cost(500); // XXX
11856   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
11857   ins_encode %{
11858     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11859   %}
11860   ins_pipe(ialu_cr_reg_mem);
11861 %}
11862 
11863 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11864 %{
<span class="line-modified">11865   predicate(CompressedOops::base() == NULL &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
11866   match(Set cr (CmpN (LoadN mem) zero));
11867 
11868   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
11869   ins_encode %{
11870     __ cmpl(r12, $mem$$Address);
11871   %}
11872   ins_pipe(ialu_cr_reg_mem);
11873 %}
11874 
11875 // Yanked all unsigned pointer compare operations.
11876 // Pointer compares are done with CmpP which is already unsigned.
11877 
11878 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11879 %{
11880   match(Set cr (CmpL op1 op2));
11881 
11882   format %{ &quot;cmpq    $op1, $op2&quot; %}
11883   opcode(0x3B);  /* Opcode 3B /r */
11884   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11885   ins_pipe(ialu_cr_reg_reg);
</pre>
<hr />
<pre>
12211   effect(USE labl);
12212 
12213   ins_cost(300);
12214   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12215             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12216   size(10);
12217   ins_encode %{
12218     Label* L = $labl$$label;
12219     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12220     __ restorevectmask();
12221   %}
12222   ins_pipe(pipe_jcc);
12223 %}
12224 
12225 // Jump Direct Conditional - using unsigned comparison
12226 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12227   match(If cop cmp);
12228   effect(USE labl);
12229 
12230   ins_cost(300);
<span class="line-modified">12231   format %{ &quot;j$cop,u   $labl&quot; %}</span>
12232   size(6);
12233   ins_encode %{
12234     Label* L = $labl$$label;
12235     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12236   %}
12237   ins_pipe(pipe_jcc);
12238 %}
12239 
12240 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12241   match(If cop cmp);
12242   effect(USE labl);
12243 
12244   ins_cost(200);
<span class="line-modified">12245   format %{ &quot;j$cop,u   $labl&quot; %}</span>
12246   size(6);
12247   ins_encode %{
12248     Label* L = $labl$$label;
12249     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12250   %}
12251   ins_pipe(pipe_jcc);
12252 %}
12253 
12254 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12255   match(If cop cmp);
12256   effect(USE labl);
12257 
12258   ins_cost(200);
12259   format %{ $$template
12260     if ($cop$$cmpcode == Assembler::notEqual) {
<span class="line-modified">12261       $$emit$$&quot;jp,u    $labl\n\t&quot;</span>
12262       $$emit$$&quot;j$cop,u   $labl&quot;
12263     } else {
<span class="line-modified">12264       $$emit$$&quot;jp,u    done\n\t&quot;</span>
12265       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12266       $$emit$$&quot;done:&quot;
12267     }
12268   %}
12269   ins_encode %{
12270     Label* l = $labl$$label;
12271     if ($cop$$cmpcode == Assembler::notEqual) {
12272       __ jcc(Assembler::parity, *l, false);
12273       __ jcc(Assembler::notEqual, *l, false);
12274     } else if ($cop$$cmpcode == Assembler::equal) {
12275       Label done;
12276       __ jccb(Assembler::parity, done);
12277       __ jcc(Assembler::equal, *l, false);
12278       __ bind(done);
12279     } else {
12280        ShouldNotReachHere();
12281     }
12282   %}
12283   ins_pipe(pipe_jcc);
12284 %}
</pre>
<hr />
<pre>
12446   effect(USE labl);
12447 
12448   ins_cost(300);
12449   format %{ &quot;j$cop,us  $labl&quot; %}
12450   size(2);
12451   ins_encode %{
12452     Label* L = $labl$$label;
12453     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12454   %}
12455   ins_pipe(pipe_jcc);
12456   ins_short_branch(1);
12457 %}
12458 
12459 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12460   match(If cop cmp);
12461   effect(USE labl);
12462 
12463   ins_cost(300);
12464   format %{ $$template
12465     if ($cop$$cmpcode == Assembler::notEqual) {
<span class="line-modified">12466       $$emit$$&quot;jp,u,s  $labl\n\t&quot;</span>
<span class="line-modified">12467       $$emit$$&quot;j$cop,u,s  $labl&quot;</span>
12468     } else {
<span class="line-modified">12469       $$emit$$&quot;jp,u,s  done\n\t&quot;</span>
12470       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12471       $$emit$$&quot;done:&quot;
12472     }
12473   %}
12474   size(4);
12475   ins_encode %{
12476     Label* l = $labl$$label;
12477     if ($cop$$cmpcode == Assembler::notEqual) {
12478       __ jccb(Assembler::parity, *l);
12479       __ jccb(Assembler::notEqual, *l);
12480     } else if ($cop$$cmpcode == Assembler::equal) {
12481       Label done;
12482       __ jccb(Assembler::parity, done);
12483       __ jccb(Assembler::equal, *l);
12484       __ bind(done);
12485     } else {
12486        ShouldNotReachHere();
12487     }
12488   %}
12489   ins_pipe(pipe_jcc);
</pre>
<hr />
<pre>
12525 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12526   match(Set cr (FastUnlock object box));
12527   effect(TEMP tmp, USE_KILL box);
12528   ins_cost(300);
12529   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12530   ins_encode %{
12531     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12532   %}
12533   ins_pipe(pipe_slow);
12534 %}
12535 
12536 
12537 // ============================================================================
12538 // Safepoint Instructions
12539 instruct safePoint_poll(rFlagsReg cr)
12540 %{
12541   predicate(!Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
12542   match(SafePoint);
12543   effect(KILL cr);
12544 
<span class="line-modified">12545   format %{ &quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;</span>
12546             &quot;# Safepoint: poll for GC&quot; %}
12547   ins_cost(125);
12548   ins_encode %{
12549     AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
12550     __ testl(rax, addr);
12551   %}
12552   ins_pipe(ialu_reg_mem);
12553 %}
12554 
12555 instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)
12556 %{
12557   predicate(Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
12558   match(SafePoint poll);
12559   effect(KILL cr, USE poll);
12560 
<span class="line-modified">12561   format %{ &quot;testl   rax, [$poll]\t&quot;</span>
12562             &quot;# Safepoint: poll for GC&quot; %}
12563   ins_cost(125);
12564   ins_encode %{
12565     __ relocate(relocInfo::poll_type);
12566     __ testl(rax, Address($poll$$Register, 0));
12567   %}
12568   ins_pipe(ialu_reg_mem);
12569 %}
12570 
12571 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12572 %{
12573   predicate(SafepointMechanism::uses_thread_local_poll());
12574   match(SafePoint poll);
12575   effect(KILL cr, USE poll);
12576 
<span class="line-modified">12577   format %{ &quot;testl   rax, [$poll]\t&quot;</span>
12578             &quot;# Safepoint: poll for GC&quot; %}
12579   ins_cost(125);
12580   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12581   ins_encode %{
12582     __ relocate(relocInfo::poll_type);
12583     address pre_pc = __ pc();
12584     __ testl(rax, Address($poll$$Register, 0));
12585     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12586   %}
12587   ins_pipe(ialu_reg_mem);
12588 %}
12589 
12590 // ============================================================================
12591 // Procedure Call/Return Instructions
12592 // Call Java Static Instruction
12593 // Note: If this code changes, the corresponding ret_addr_offset() and
12594 //       compute_padding() functions will have to be adjusted.
12595 instruct CallStaticJavaDirect(method meth) %{
12596   match(CallStaticJava);
12597   effect(USE meth);
</pre>
</td>
</tr>
</table>
<center><a href="x86_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../zero/assembler_zero.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/interpreterRT_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/interp_masm.hpp&quot;
 27 #include &quot;interpreter/interpreter.hpp&quot;
 28 #include &quot;interpreter/interpreterRuntime.hpp&quot;
 29 #include &quot;memory/allocation.inline.hpp&quot;
 30 #include &quot;memory/universe.hpp&quot;
 31 #include &quot;oops/method.hpp&quot;
 32 #include &quot;oops/oop.inline.hpp&quot;
 33 #include &quot;runtime/handles.inline.hpp&quot;
 34 #include &quot;runtime/icache.hpp&quot;
 35 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 36 #include &quot;runtime/signature.hpp&quot;
 37 
 38 #define __ _masm-&gt;
 39 
 40 // Implementation of SignatureHandlerGenerator
 41 
 42 InterpreterRuntime::SignatureHandlerGenerator::SignatureHandlerGenerator(const methodHandle&amp; method, CodeBuffer* buffer) :
 43     NativeSignatureIterator(method) {
 44   _masm = new MacroAssembler(buffer);
 45 #ifdef AMD64
 46 #ifdef _WIN64
 47   _num_args = (method-&gt;is_static() ? 1 : 0);
 48   _stack_offset = (Argument::n_int_register_parameters_c+1)* wordSize; // don&#39;t overwrite return address
 49 #else
 50   _num_int_args = (method-&gt;is_static() ? 1 : 0);
 51   _num_fp_args = 0;
 52   _stack_offset = wordSize; // don&#39;t overwrite return address
 53 #endif // _WIN64
 54 #endif // AMD64
 55 }
 56 
 57 Register InterpreterRuntime::SignatureHandlerGenerator::from() { return r14; }
 58 Register InterpreterRuntime::SignatureHandlerGenerator::to()   { return rsp; }
 59 Register InterpreterRuntime::SignatureHandlerGenerator::temp() { return rscratch1; }
 60 
 61 void InterpreterRuntime::SignatureHandlerGenerator::pass_int() {
 62   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
 63 
 64 #ifdef _WIN64
 65   switch (_num_args) {
 66   case 0:
 67     __ movl(c_rarg1, src);
 68     _num_args++;
 69     break;
 70   case 1:
 71     __ movl(c_rarg2, src);
 72     _num_args++;
 73     break;
 74   case 2:
 75     __ movl(c_rarg3, src);
 76     _num_args++;
 77     break;
 78   default:
 79     __ movl(rax, src);
 80     __ movl(Address(to(), _stack_offset), rax);
 81     _stack_offset += wordSize;
 82     break;
 83   }
 84 #else
 85   switch (_num_int_args) {
 86   case 0:
 87     __ movl(c_rarg1, src);
 88     _num_int_args++;
 89     break;
 90   case 1:
 91     __ movl(c_rarg2, src);
 92     _num_int_args++;
 93     break;
 94   case 2:
 95     __ movl(c_rarg3, src);
 96     _num_int_args++;
 97     break;
 98   case 3:
 99     __ movl(c_rarg4, src);
100     _num_int_args++;
101     break;
102   case 4:
103     __ movl(c_rarg5, src);
104     _num_int_args++;
105     break;
106   default:
107     __ movl(rax, src);
108     __ movl(Address(to(), _stack_offset), rax);
109     _stack_offset += wordSize;
110     break;
111   }
112 #endif
113 }
114 
115 void InterpreterRuntime::SignatureHandlerGenerator::pass_long() {
116   const Address src(from(), Interpreter::local_offset_in_bytes(offset() + 1));
117 
118 #ifdef _WIN64
119   switch (_num_args) {
120   case 0:
121     __ movptr(c_rarg1, src);
122     _num_args++;
123     break;
124   case 1:
125     __ movptr(c_rarg2, src);
126     _num_args++;
127     break;
128   case 2:
129     __ movptr(c_rarg3, src);
130     _num_args++;
131     break;
132   case 3:
133   default:
134     __ movptr(rax, src);
135     __ movptr(Address(to(), _stack_offset), rax);
136     _stack_offset += wordSize;
137     break;
138   }
139 #else
140   switch (_num_int_args) {
141   case 0:
142     __ movptr(c_rarg1, src);
143     _num_int_args++;
144     break;
145   case 1:
146     __ movptr(c_rarg2, src);
147     _num_int_args++;
148     break;
149   case 2:
150     __ movptr(c_rarg3, src);
151     _num_int_args++;
152     break;
153   case 3:
154     __ movptr(c_rarg4, src);
155     _num_int_args++;
156     break;
157   case 4:
158     __ movptr(c_rarg5, src);
159     _num_int_args++;
160     break;
161   default:
162     __ movptr(rax, src);
163     __ movptr(Address(to(), _stack_offset), rax);
164     _stack_offset += wordSize;
165     break;
166   }
167 #endif
168 }
169 
170 void InterpreterRuntime::SignatureHandlerGenerator::pass_float() {
171   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
172 
173 #ifdef _WIN64
174   if (_num_args &lt; Argument::n_float_register_parameters_c-1) {
175     __ movflt(as_XMMRegister(++_num_args), src);
176   } else {
177     __ movl(rax, src);
178     __ movl(Address(to(), _stack_offset), rax);
179     _stack_offset += wordSize;
180   }
181 #else
182   if (_num_fp_args &lt; Argument::n_float_register_parameters_c) {
183     __ movflt(as_XMMRegister(_num_fp_args++), src);
184   } else {
185     __ movl(rax, src);
186     __ movl(Address(to(), _stack_offset), rax);
187     _stack_offset += wordSize;
188   }
189 #endif
190 }
191 
192 void InterpreterRuntime::SignatureHandlerGenerator::pass_double() {
193   const Address src(from(), Interpreter::local_offset_in_bytes(offset() + 1));
194 
195 #ifdef _WIN64
196   if (_num_args &lt; Argument::n_float_register_parameters_c-1) {
197     __ movdbl(as_XMMRegister(++_num_args), src);
198   } else {
199     __ movptr(rax, src);
200     __ movptr(Address(to(), _stack_offset), rax);
201     _stack_offset += wordSize;
202   }
203 #else
204   if (_num_fp_args &lt; Argument::n_float_register_parameters_c) {
205     __ movdbl(as_XMMRegister(_num_fp_args++), src);
206   } else {
207     __ movptr(rax, src);
208     __ movptr(Address(to(), _stack_offset), rax);
209     _stack_offset += wordSize;
210   }
211 #endif
212 }
213 
214 void InterpreterRuntime::SignatureHandlerGenerator::pass_object() {
215   const Address src(from(), Interpreter::local_offset_in_bytes(offset()));
216 
217 #ifdef _WIN64
218   switch (_num_args) {
219   case 0:
220     assert(offset() == 0, &quot;argument register 1 can only be (non-null) receiver&quot;);
221     __ lea(c_rarg1, src);
222     _num_args++;
223     break;
224   case 1:
225     __ lea(rax, src);
226     __ xorl(c_rarg2, c_rarg2);
227     __ cmpptr(src, 0);
228     __ cmov(Assembler::notEqual, c_rarg2, rax);
229     _num_args++;
230     break;
231   case 2:
232     __ lea(rax, src);
233     __ xorl(c_rarg3, c_rarg3);
234     __ cmpptr(src, 0);
235     __ cmov(Assembler::notEqual, c_rarg3, rax);
236     _num_args++;
237     break;
238   default:
239     __ lea(rax, src);
240     __ xorl(temp(), temp());
241     __ cmpptr(src, 0);
242     __ cmov(Assembler::notEqual, temp(), rax);
243     __ movptr(Address(to(), _stack_offset), temp());
244     _stack_offset += wordSize;
245     break;
246   }
247 #else
248   switch (_num_int_args) {
249   case 0:
250     assert(offset() == 0, &quot;argument register 1 can only be (non-null) receiver&quot;);
251     __ lea(c_rarg1, src);
252     _num_int_args++;
253     break;
254   case 1:
255     __ lea(rax, src);
256     __ xorl(c_rarg2, c_rarg2);
257     __ cmpptr(src, 0);
258     __ cmov(Assembler::notEqual, c_rarg2, rax);
259     _num_int_args++;
260     break;
261   case 2:
262     __ lea(rax, src);
263     __ xorl(c_rarg3, c_rarg3);
264     __ cmpptr(src, 0);
265     __ cmov(Assembler::notEqual, c_rarg3, rax);
266     _num_int_args++;
267     break;
268   case 3:
269     __ lea(rax, src);
270     __ xorl(c_rarg4, c_rarg4);
271     __ cmpptr(src, 0);
272     __ cmov(Assembler::notEqual, c_rarg4, rax);
273     _num_int_args++;
274     break;
275   case 4:
276     __ lea(rax, src);
277     __ xorl(c_rarg5, c_rarg5);
278     __ cmpptr(src, 0);
279     __ cmov(Assembler::notEqual, c_rarg5, rax);
280     _num_int_args++;
281     break;
282   default:
283     __ lea(rax, src);
284     __ xorl(temp(), temp());
285     __ cmpptr(src, 0);
286     __ cmov(Assembler::notEqual, temp(), rax);
287     __ movptr(Address(to(), _stack_offset), temp());
288     _stack_offset += wordSize;
289     break;
290   }
291 #endif
292 }
293 
294 void InterpreterRuntime::SignatureHandlerGenerator::generate(uint64_t fingerprint) {
295   // generate code to handle arguments
296   iterate(fingerprint);
297 
298   // return result handler
299   __ lea(rax, ExternalAddress(Interpreter::result_handler(method()-&gt;result_type())));
300   __ ret(0);
301 
302   __ flush();
303 }
304 
305 
306 // Implementation of SignatureHandlerLibrary
307 
308 void SignatureHandlerLibrary::pd_set_handler(address handler) {}
309 
310 
311 #ifdef _WIN64
312 class SlowSignatureHandler
313   : public NativeSignatureIterator {
314  private:
315   address   _from;
316   intptr_t* _to;
317   intptr_t* _reg_args;
318   intptr_t* _fp_identifiers;
319   unsigned int _num_args;
320 
321   virtual void pass_int()
322   {
323     jint from_obj = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));
324     _from -= Interpreter::stackElementSize;
325 
326     if (_num_args &lt; Argument::n_int_register_parameters_c-1) {
327       *_reg_args++ = from_obj;
328       _num_args++;
329     } else {
330       *_to++ = from_obj;
331     }
332   }
333 
334   virtual void pass_long()
335   {
336     intptr_t from_obj = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(1));
337     _from -= 2*Interpreter::stackElementSize;
338 
339     if (_num_args &lt; Argument::n_int_register_parameters_c-1) {
340       *_reg_args++ = from_obj;
341       _num_args++;
342     } else {
343       *_to++ = from_obj;
344     }
345   }
346 
347   virtual void pass_object()
348   {
349     intptr_t *from_addr = (intptr_t*)(_from + Interpreter::local_offset_in_bytes(0));
350     _from -= Interpreter::stackElementSize;
351     if (_num_args &lt; Argument::n_int_register_parameters_c-1) {
352       *_reg_args++ = (*from_addr == 0) ? NULL : (intptr_t) from_addr;
353       _num_args++;
354     } else {
355       *_to++ = (*from_addr == 0) ? NULL : (intptr_t) from_addr;
356     }
357   }
358 
359   virtual void pass_float()
360   {
361     jint from_obj = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));
362     _from -= Interpreter::stackElementSize;
363 
364     if (_num_args &lt; Argument::n_float_register_parameters_c-1) {
365       assert((_num_args*2) &lt; BitsPerWord, &quot;_num_args*2 is out of range&quot;);
366       *_reg_args++ = from_obj;
367       *_fp_identifiers |= ((intptr_t)0x01 &lt;&lt; (_num_args*2)); // mark as float
368       _num_args++;
369     } else {
370       *_to++ = from_obj;
371     }
372   }
373 
374   virtual void pass_double()
375   {
376     intptr_t from_obj = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(1));
377     _from -= 2*Interpreter::stackElementSize;
378 
379     if (_num_args &lt; Argument::n_float_register_parameters_c-1) {
380       assert((_num_args*2) &lt; BitsPerWord, &quot;_num_args*2 is out of range&quot;);
381       *_reg_args++ = from_obj;
382       *_fp_identifiers |= ((intptr_t)0x3 &lt;&lt; (_num_args*2)); // mark as double
383       _num_args++;
384     } else {
385       *_to++ = from_obj;
386     }
387   }
388 
389  public:
390   SlowSignatureHandler(const methodHandle&amp; method, address from, intptr_t* to)
391     : NativeSignatureIterator(method)
392   {
393     _from = from;
394     _to   = to;
395 
396     _reg_args = to - (method-&gt;is_static() ? 4 : 5);
397     _fp_identifiers = to - 2;
398     _to = _to + 4;  // Windows reserves stack space for register arguments
399     *(int*) _fp_identifiers = 0;
400     _num_args = (method-&gt;is_static() ? 1 : 0);
401   }
402 };
403 #else
404 class SlowSignatureHandler
405   : public NativeSignatureIterator {
406  private:
407   address   _from;
408   intptr_t* _to;
409   intptr_t* _int_args;
410   intptr_t* _fp_args;
411   intptr_t* _fp_identifiers;
412   unsigned int _num_int_args;
413   unsigned int _num_fp_args;
414 
415   virtual void pass_int()
416   {
417     jint from_obj = *(jint *)(_from+Interpreter::local_offset_in_bytes(0));
418     _from -= Interpreter::stackElementSize;
419 
420     if (_num_int_args &lt; Argument::n_int_register_parameters_c-1) {
421       *_int_args++ = from_obj;
422       _num_int_args++;
423     } else {
424       *_to++ = from_obj;
425     }
426   }
427 
428   virtual void pass_long()
429   {
430     intptr_t from_obj = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(1));
431     _from -= 2*Interpreter::stackElementSize;
432 
433     if (_num_int_args &lt; Argument::n_int_register_parameters_c-1) {
434       *_int_args++ = from_obj;
435       _num_int_args++;
436     } else {
437       *_to++ = from_obj;
438     }
439   }
440 
441   virtual void pass_object()
442   {
443     intptr_t *from_addr = (intptr_t*)(_from + Interpreter::local_offset_in_bytes(0));
444     _from -= Interpreter::stackElementSize;
445 
446     if (_num_int_args &lt; Argument::n_int_register_parameters_c-1) {
447       *_int_args++ = (*from_addr == 0) ? NULL : (intptr_t)from_addr;
448       _num_int_args++;
449     } else {
450       *_to++ = (*from_addr == 0) ? NULL : (intptr_t) from_addr;
451     }
452   }
453 
454   virtual void pass_float()
455   {
456     jint from_obj = *(jint*)(_from+Interpreter::local_offset_in_bytes(0));
457     _from -= Interpreter::stackElementSize;
458 
459     if (_num_fp_args &lt; Argument::n_float_register_parameters_c) {
460       *_fp_args++ = from_obj;
461       _num_fp_args++;
462     } else {
463       *_to++ = from_obj;
464     }
465   }
466 
467   virtual void pass_double()
468   {
469     intptr_t from_obj = *(intptr_t*)(_from+Interpreter::local_offset_in_bytes(1));
470     _from -= 2*Interpreter::stackElementSize;
471 
472     if (_num_fp_args &lt; Argument::n_float_register_parameters_c) {
473       *_fp_args++ = from_obj;
474       *_fp_identifiers |= (1 &lt;&lt; _num_fp_args); // mark as double
475       _num_fp_args++;
476     } else {
477       *_to++ = from_obj;
478     }
479   }
480 
481  public:
482   SlowSignatureHandler(const methodHandle&amp; method, address from, intptr_t* to)
483     : NativeSignatureIterator(method)
484   {
485     _from = from;
486     _to   = to;
487 
488     _int_args = to - (method-&gt;is_static() ? 14 : 15);
489     _fp_args =  to - 9;
490     _fp_identifiers = to - 10;
491     *(int*) _fp_identifiers = 0;
492     _num_int_args = (method-&gt;is_static() ? 1 : 0);
493     _num_fp_args = 0;
494   }
495 };
496 #endif
497 
498 
499 IRT_ENTRY(address,
500           InterpreterRuntime::slow_signature_handler(JavaThread* thread,
501                                                      Method* method,
502                                                      intptr_t* from,
503                                                      intptr_t* to))
504   methodHandle m(thread, (Method*)method);
505   assert(m-&gt;is_native(), &quot;sanity check&quot;);
506 
507   // handle arguments
508   SlowSignatureHandler(m, (address)from, to + 1).iterate((uint64_t)CONST64(-1));
509 
510   // return result handler
511   return Interpreter::result_handler(m-&gt;result_type());
512 IRT_END
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
    2 // Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // AMD64 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
   64 // used as byte registers)
   65 
   66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
   67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
   69 
   70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
   71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
   72 
   73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
   74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
   75 
   76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
   77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
   78 
   79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
   80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
   81 
   82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
   83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
   84 
   85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
   86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
   87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
   88 
   89 #ifdef _WIN64
   90 
   91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
   92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
   93 
   94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
   95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
   96 
   97 #else
   98 
   99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
  100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  101 
  102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
  103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  104 
  105 #endif
  106 
  107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
  108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
  109 
  110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
  111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
  112 
  113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
  114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
  115 
  116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
  117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
  118 
  119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
  120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
  121 
  122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
  123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
  124 
  125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
  126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
  127 
  128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
  129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
  130 
  131 
  132 // Floating Point Registers
  133 
  134 // Specify priority of register selection within phases of register
  135 // allocation.  Highest priority is first.  A useful heuristic is to
  136 // give registers a low priority when they are required by machine
  137 // instructions, like EAX and EDX on I486, and choose no-save registers
  138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
  139 // which participate in fixed calling sequences should come last.
  140 // Registers which are used as pairs must fall on an even boundary.
  141 
  142 alloc_class chunk0(R10,         R10_H,
  143                    R11,         R11_H,
  144                    R8,          R8_H,
  145                    R9,          R9_H,
  146                    R12,         R12_H,
  147                    RCX,         RCX_H,
  148                    RBX,         RBX_H,
  149                    RDI,         RDI_H,
  150                    RDX,         RDX_H,
  151                    RSI,         RSI_H,
  152                    RAX,         RAX_H,
  153                    RBP,         RBP_H,
  154                    R13,         R13_H,
  155                    R14,         R14_H,
  156                    R15,         R15_H,
  157                    RSP,         RSP_H);
  158 
  159 
  160 //----------Architecture Description Register Classes--------------------------
  161 // Several register classes are automatically defined based upon information in
  162 // this architecture description.
  163 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  164 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  165 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  166 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  167 //
  168 
  169 // Empty register class.
  170 reg_class no_reg();
  171 
  172 // Class for all pointer/long registers
  173 reg_class all_reg(RAX, RAX_H,
  174                   RDX, RDX_H,
  175                   RBP, RBP_H,
  176                   RDI, RDI_H,
  177                   RSI, RSI_H,
  178                   RCX, RCX_H,
  179                   RBX, RBX_H,
  180                   RSP, RSP_H,
  181                   R8,  R8_H,
  182                   R9,  R9_H,
  183                   R10, R10_H,
  184                   R11, R11_H,
  185                   R12, R12_H,
  186                   R13, R13_H,
  187                   R14, R14_H,
  188                   R15, R15_H);
  189 
  190 // Class for all int registers
  191 reg_class all_int_reg(RAX
  192                       RDX,
  193                       RBP,
  194                       RDI,
  195                       RSI,
  196                       RCX,
  197                       RBX,
  198                       R8,
  199                       R9,
  200                       R10,
  201                       R11,
  202                       R12,
  203                       R13,
  204                       R14);
  205 
  206 // Class for all pointer registers
  207 reg_class any_reg %{
  208   return _ANY_REG_mask;
  209 %}
  210 
  211 // Class for all pointer registers (excluding RSP)
  212 reg_class ptr_reg %{
  213   return _PTR_REG_mask;
  214 %}
  215 
  216 // Class for all pointer registers (excluding RSP and RBP)
  217 reg_class ptr_reg_no_rbp %{
  218   return _PTR_REG_NO_RBP_mask;
  219 %}
  220 
  221 // Class for all pointer registers (excluding RAX and RSP)
  222 reg_class ptr_no_rax_reg %{
  223   return _PTR_NO_RAX_REG_mask;
  224 %}
  225 
  226 // Class for all pointer registers (excluding RAX, RBX, and RSP)
  227 reg_class ptr_no_rax_rbx_reg %{
  228   return _PTR_NO_RAX_RBX_REG_mask;
  229 %}
  230 
  231 // Class for all long registers (excluding RSP)
  232 reg_class long_reg %{
  233   return _LONG_REG_mask;
  234 %}
  235 
  236 // Class for all long registers (excluding RAX, RDX and RSP)
  237 reg_class long_no_rax_rdx_reg %{
  238   return _LONG_NO_RAX_RDX_REG_mask;
  239 %}
  240 
  241 // Class for all long registers (excluding RCX and RSP)
  242 reg_class long_no_rcx_reg %{
  243   return _LONG_NO_RCX_REG_mask;
  244 %}
  245 
  246 // Class for all int registers (excluding RSP)
  247 reg_class int_reg %{
  248   return _INT_REG_mask;
  249 %}
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 
<a name="1" id="anc1"></a>


  270 // Singleton class for RDI pointer register
  271 reg_class ptr_rdi_reg(RDI, RDI_H);
  272 
  273 // Singleton class for stack pointer
  274 reg_class ptr_rsp_reg(RSP, RSP_H);
  275 
  276 // Singleton class for TLS pointer
  277 reg_class ptr_r15_reg(R15, R15_H);
  278 
  279 // Singleton class for RAX long register
  280 reg_class long_rax_reg(RAX, RAX_H);
  281 
  282 // Singleton class for RCX long register
  283 reg_class long_rcx_reg(RCX, RCX_H);
  284 
  285 // Singleton class for RDX long register
  286 reg_class long_rdx_reg(RDX, RDX_H);
  287 
  288 // Singleton class for RAX int register
  289 reg_class int_rax_reg(RAX);
  290 
  291 // Singleton class for RBX int register
  292 reg_class int_rbx_reg(RBX);
  293 
  294 // Singleton class for RCX int register
  295 reg_class int_rcx_reg(RCX);
  296 
  297 // Singleton class for RCX int register
  298 reg_class int_rdx_reg(RDX);
  299 
  300 // Singleton class for RCX int register
  301 reg_class int_rdi_reg(RDI);
  302 
  303 // Singleton class for instruction pointer
  304 // reg_class ip_reg(RIP);
  305 
  306 %}
  307 
  308 //----------SOURCE BLOCK-------------------------------------------------------
  309 // This is a block of C++ code which provides values, functions, and
  310 // definitions necessary in the rest of the architecture description
  311 source_hpp %{
  312 
  313 extern RegMask _ANY_REG_mask;
  314 extern RegMask _PTR_REG_mask;
  315 extern RegMask _PTR_REG_NO_RBP_mask;
  316 extern RegMask _PTR_NO_RAX_REG_mask;
  317 extern RegMask _PTR_NO_RAX_RBX_REG_mask;
  318 extern RegMask _LONG_REG_mask;
  319 extern RegMask _LONG_NO_RAX_RDX_REG_mask;
  320 extern RegMask _LONG_NO_RCX_REG_mask;
  321 extern RegMask _INT_REG_mask;
  322 extern RegMask _INT_NO_RAX_RDX_REG_mask;
  323 extern RegMask _INT_NO_RCX_REG_mask;
  324 
  325 extern RegMask _STACK_OR_PTR_REG_mask;
  326 extern RegMask _STACK_OR_LONG_REG_mask;
  327 extern RegMask _STACK_OR_INT_REG_mask;
  328 
  329 inline const RegMask&amp; STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }
  330 inline const RegMask&amp; STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }
  331 inline const RegMask&amp; STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }
  332 
  333 %}
  334 
  335 source %{
  336 #define   RELOC_IMM64    Assembler::imm_operand
  337 #define   RELOC_DISP32   Assembler::disp32_operand
  338 
  339 #define __ _masm.
  340 
  341 RegMask _ANY_REG_mask;
  342 RegMask _PTR_REG_mask;
  343 RegMask _PTR_REG_NO_RBP_mask;
  344 RegMask _PTR_NO_RAX_REG_mask;
  345 RegMask _PTR_NO_RAX_RBX_REG_mask;
  346 RegMask _LONG_REG_mask;
  347 RegMask _LONG_NO_RAX_RDX_REG_mask;
  348 RegMask _LONG_NO_RCX_REG_mask;
  349 RegMask _INT_REG_mask;
  350 RegMask _INT_NO_RAX_RDX_REG_mask;
  351 RegMask _INT_NO_RCX_REG_mask;
  352 RegMask _STACK_OR_PTR_REG_mask;
  353 RegMask _STACK_OR_LONG_REG_mask;
  354 RegMask _STACK_OR_INT_REG_mask;
  355 
  356 static bool need_r12_heapbase() {
  357   return UseCompressedOops || UseCompressedClassPointers;
  358 }
  359 
  360 void reg_mask_init() {
  361   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  362   // We derive a number of subsets from it.
  363   _ANY_REG_mask = _ALL_REG_mask;
  364 
  365   if (PreserveFramePointer) {
  366     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  367     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  368   }
  369   if (need_r12_heapbase()) {
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  371     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  372   }
  373 
  374   _PTR_REG_mask = _ANY_REG_mask;
  375   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  376   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  377   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()-&gt;next()));
  379 
  380   _STACK_OR_PTR_REG_mask = _PTR_REG_mask;
  381   _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  382 
  383   _PTR_REG_NO_RBP_mask = _PTR_REG_mask;
  384   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  385   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  386 
  387   _PTR_NO_RAX_REG_mask = _PTR_REG_mask;
  388   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  389   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  390 
  391   _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;
  392   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()));
  393   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()-&gt;next()));
  394 
  395   _LONG_REG_mask = _PTR_REG_mask;
  396   _STACK_OR_LONG_REG_mask = _LONG_REG_mask;
  397   _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  398 
  399   _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;
  400   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  401   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  402   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  403   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()-&gt;next()));
  404 
  405   _LONG_NO_RCX_REG_mask = _LONG_REG_mask;
  406   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  407   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()-&gt;next()));
  408 
  409   _INT_REG_mask = _ALL_INT_REG_mask;
  410   if (PreserveFramePointer) {
  411     _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  412   }
  413   if (need_r12_heapbase()) {
  414     _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  415   }
  416 
  417   _STACK_OR_INT_REG_mask = _INT_REG_mask;
  418   _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  419 
  420   _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;
  421   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  422   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  423 
  424   _INT_NO_RCX_REG_mask = _INT_REG_mask;
  425   _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  426 }
  427 
  428 static bool generate_vzeroupper(Compile* C) {
  429   return (VM_Version::supports_vzeroupper() &amp;&amp; (C-&gt;max_vector_size() &gt; 16 || C-&gt;clear_upper_avx() == true)) ? true: false;  // Generate vzeroupper
  430 }
  431 
  432 static int clear_avx_size() {
  433   return generate_vzeroupper(Compile::current()) ? 3: 0;  // vzeroupper
  434 }
  435 
  436 // !!!!! Special hack to get all types of calls to specify the byte offset
  437 //       from the start of the call to the point where the return address
  438 //       will point.
  439 int MachCallStaticJavaNode::ret_addr_offset()
  440 {
  441   int offset = 5; // 5 bytes from start of call to where return address points
  442   offset += clear_avx_size();
  443   return offset;
  444 }
  445 
  446 int MachCallDynamicJavaNode::ret_addr_offset()
  447 {
  448   int offset = 15; // 15 bytes from start of call to where return address points
  449   offset += clear_avx_size();
  450   return offset;
  451 }
  452 
  453 int MachCallRuntimeNode::ret_addr_offset() {
  454   int offset = 13; // movq r10,#addr; callq (r10)
  455   offset += clear_avx_size();
  456   return offset;
  457 }
  458 
  459 // Indicate if the safepoint node needs the polling page as an input,
  460 // it does if the polling page is more than disp32 away.
  461 bool SafePointNode::needs_polling_address_input()
  462 {
  463   return SafepointMechanism::uses_thread_local_poll() || Assembler::is_polling_page_far();
  464 }
  465 
  466 //
  467 // Compute padding required for nodes which need alignment
  468 //
  469 
  470 // The address of the call instruction needs to be 4-byte aligned to
  471 // ensure that it does not span a cache line so that it can be patched.
  472 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  473 {
  474   current_offset += clear_avx_size(); // skip vzeroupper
  475   current_offset += 1; // skip call opcode byte
  476   return align_up(current_offset, alignment_required()) - current_offset;
  477 }
  478 
  479 // The address of the call instruction needs to be 4-byte aligned to
  480 // ensure that it does not span a cache line so that it can be patched.
  481 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  482 {
  483   current_offset += clear_avx_size(); // skip vzeroupper
  484   current_offset += 11; // skip movq instruction + call opcode byte
  485   return align_up(current_offset, alignment_required()) - current_offset;
  486 }
  487 
  488 // EMIT_RM()
  489 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  490   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  491   cbuf.insts()-&gt;emit_int8(c);
  492 }
  493 
  494 // EMIT_CC()
  495 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  496   unsigned char c = (unsigned char) (f1 | f2);
  497   cbuf.insts()-&gt;emit_int8(c);
  498 }
  499 
  500 // EMIT_OPCODE()
  501 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  502   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  503 }
  504 
  505 // EMIT_OPCODE() w/ relocation information
  506 void emit_opcode(CodeBuffer &amp;cbuf,
  507                  int code, relocInfo::relocType reloc, int offset, int format)
  508 {
  509   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  510   emit_opcode(cbuf, code);
  511 }
  512 
  513 // EMIT_D8()
  514 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  515   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  516 }
  517 
  518 // EMIT_D16()
  519 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  520   cbuf.insts()-&gt;emit_int16(d16);
  521 }
  522 
  523 // EMIT_D32()
  524 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  525   cbuf.insts()-&gt;emit_int32(d32);
  526 }
  527 
  528 // EMIT_D64()
  529 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  530   cbuf.insts()-&gt;emit_int64(d64);
  531 }
  532 
  533 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  534 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  535                     int d32,
  536                     relocInfo::relocType reloc,
  537                     int format)
  538 {
  539   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  540   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  541   cbuf.insts()-&gt;emit_int32(d32);
  542 }
  543 
  544 // emit 32 bit value and construct relocation entry from RelocationHolder
  545 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  546 #ifdef ASSERT
  547   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  548       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
<a name="2" id="anc2"></a><span class="line-modified">  549     assert(Universe::heap()-&gt;is_in_reserved((address)(intptr_t)d32), &quot;should be real oop&quot;);</span>
  550     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  551   }
  552 #endif
  553   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  554   cbuf.insts()-&gt;emit_int32(d32);
  555 }
  556 
  557 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  558   address next_ip = cbuf.insts_end() + 4;
  559   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  560                  external_word_Relocation::spec(addr),
  561                  RELOC_DISP32);
  562 }
  563 
  564 
  565 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  566 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  567   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  568   cbuf.insts()-&gt;emit_int64(d64);
  569 }
  570 
  571 // emit 64 bit value and construct relocation entry from RelocationHolder
  572 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  573 #ifdef ASSERT
  574   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  575       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
<a name="3" id="anc3"></a><span class="line-modified">  576     assert(Universe::heap()-&gt;is_in_reserved((address)d64), &quot;should be real oop&quot;);</span>
  577     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  578   }
  579 #endif
  580   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  581   cbuf.insts()-&gt;emit_int64(d64);
  582 }
  583 
  584 // Access stack slot for load or store
  585 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  586 {
  587   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  588   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  589     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  590     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  591     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  592   } else {
  593     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  594     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  595     emit_d32(cbuf, disp);     // Displacement // R/M byte
  596   }
  597 }
  598 
  599    // rRegI ereg, memory mem) %{    // emit_reg_mem
  600 void encode_RegMem(CodeBuffer &amp;cbuf,
  601                    int reg,
  602                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
  603 {
  604   assert(disp_reloc == relocInfo::none, &quot;cannot have disp&quot;);
  605   int regenc = reg &amp; 7;
  606   int baseenc = base &amp; 7;
  607   int indexenc = index &amp; 7;
  608 
  609   // There is no index &amp; no scale, use form without SIB byte
  610   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
  611     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  612     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  613       emit_rm(cbuf, 0x0, regenc, baseenc); // *
  614     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  615       // If 8-bit displacement, mode 0x1
  616       emit_rm(cbuf, 0x1, regenc, baseenc); // *
  617       emit_d8(cbuf, disp);
  618     } else {
  619       // If 32-bit displacement
  620       if (base == -1) { // Special flag for absolute address
  621         emit_rm(cbuf, 0x0, regenc, 0x5); // *
  622         if (disp_reloc != relocInfo::none) {
  623           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  624         } else {
  625           emit_d32(cbuf, disp);
  626         }
  627       } else {
  628         // Normal base + offset
  629         emit_rm(cbuf, 0x2, regenc, baseenc); // *
  630         if (disp_reloc != relocInfo::none) {
  631           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  632         } else {
  633           emit_d32(cbuf, disp);
  634         }
  635       }
  636     }
  637   } else {
  638     // Else, encode with the SIB byte
  639     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  640     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  641       // If no displacement
  642       emit_rm(cbuf, 0x0, regenc, 0x4); // *
  643       emit_rm(cbuf, scale, indexenc, baseenc);
  644     } else {
  645       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  646         // If 8-bit displacement, mode 0x1
  647         emit_rm(cbuf, 0x1, regenc, 0x4); // *
  648         emit_rm(cbuf, scale, indexenc, baseenc);
  649         emit_d8(cbuf, disp);
  650       } else {
  651         // If 32-bit displacement
  652         if (base == 0x04 ) {
  653           emit_rm(cbuf, 0x2, regenc, 0x4);
  654           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
  655         } else {
  656           emit_rm(cbuf, 0x2, regenc, 0x4);
  657           emit_rm(cbuf, scale, indexenc, baseenc); // *
  658         }
  659         if (disp_reloc != relocInfo::none) {
  660           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  661         } else {
  662           emit_d32(cbuf, disp);
  663         }
  664       }
  665     }
  666   }
  667 }
  668 
  669 // This could be in MacroAssembler but it&#39;s fairly C2 specific
  670 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  671   Label exit;
  672   __ jccb(Assembler::noParity, exit);
  673   __ pushf();
  674   //
  675   // comiss/ucomiss instructions set ZF,PF,CF flags and
  676   // zero OF,AF,SF for NaN values.
  677   // Fixup flags by zeroing ZF,PF so that compare of NaN
  678   // values returns &#39;less than&#39; result (CF is set).
  679   // Leave the rest of flags unchanged.
  680   //
  681   //    7 6 5 4 3 2 1 0
  682   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  683   //    0 0 1 0 1 0 1 1   (0x2B)
  684   //
  685   __ andq(Address(rsp, 0), 0xffffff2b);
  686   __ popf();
  687   __ bind(exit);
  688 }
  689 
  690 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  691   Label done;
  692   __ movl(dst, -1);
  693   __ jcc(Assembler::parity, done);
  694   __ jcc(Assembler::below, done);
  695   __ setb(Assembler::notEqual, dst);
  696   __ movzbl(dst, dst);
  697   __ bind(done);
  698 }
  699 
  700 // Math.min()    # Math.max()
  701 // --------------------------
  702 // ucomis[s/d]   #
  703 // ja   -&gt; b     # a
  704 // jp   -&gt; NaN   # NaN
  705 // jb   -&gt; a     # b
  706 // je            #
  707 // |-jz -&gt; a | b # a &amp; b
  708 // |    -&gt; a     #
  709 void emit_fp_min_max(MacroAssembler&amp; _masm, XMMRegister dst,
  710                      XMMRegister a, XMMRegister b,
  711                      XMMRegister xmmt, Register rt,
  712                      bool min, bool single) {
  713 
  714   Label nan, zero, below, above, done;
  715 
  716   if (single)
  717     __ ucomiss(a, b);
  718   else
  719     __ ucomisd(a, b);
  720 
  721   if (dst-&gt;encoding() != (min ? b : a)-&gt;encoding())
  722     __ jccb(Assembler::above, above); // CF=0 &amp; ZF=0
  723   else
  724     __ jccb(Assembler::above, done);
  725 
  726   __ jccb(Assembler::parity, nan);  // PF=1
  727   __ jccb(Assembler::below, below); // CF=1
  728 
  729   // equal
  730   __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);
  731   if (single) {
  732     __ ucomiss(a, xmmt);
  733     __ jccb(Assembler::equal, zero);
  734 
  735     __ movflt(dst, a);
  736     __ jmp(done);
  737   }
  738   else {
  739     __ ucomisd(a, xmmt);
  740     __ jccb(Assembler::equal, zero);
  741 
  742     __ movdbl(dst, a);
  743     __ jmp(done);
  744   }
  745 
  746   __ bind(zero);
  747   if (min)
  748     __ vpor(dst, a, b, Assembler::AVX_128bit);
  749   else
  750     __ vpand(dst, a, b, Assembler::AVX_128bit);
  751 
  752   __ jmp(done);
  753 
  754   __ bind(above);
  755   if (single)
  756     __ movflt(dst, min ? b : a);
  757   else
  758     __ movdbl(dst, min ? b : a);
  759 
  760   __ jmp(done);
  761 
  762   __ bind(nan);
  763   if (single) {
  764     __ movl(rt, 0x7fc00000); // Float.NaN
  765     __ movdl(dst, rt);
  766   }
  767   else {
  768     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  769     __ movdq(dst, rt);
  770   }
  771   __ jmp(done);
  772 
  773   __ bind(below);
  774   if (single)
  775     __ movflt(dst, min ? a : b);
  776   else
  777     __ movdbl(dst, min ? a : b);
  778 
  779   __ bind(done);
  780 }
  781 
  782 //=============================================================================
  783 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  784 
  785 int Compile::ConstantTable::calculate_table_base_offset() const {
  786   return 0;  // absolute addressing, no offset
  787 }
  788 
  789 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  790 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  791   ShouldNotReachHere();
  792 }
  793 
  794 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  795   // Empty encoding
  796 }
  797 
  798 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  799   return 0;
  800 }
  801 
  802 #ifndef PRODUCT
  803 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  804   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  805 }
  806 #endif
  807 
  808 
  809 //=============================================================================
  810 #ifndef PRODUCT
  811 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  812   Compile* C = ra_-&gt;C;
  813 
  814   int framesize = C-&gt;frame_size_in_bytes();
  815   int bangsize = C-&gt;bang_size_in_bytes();
  816   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  817   // Remove wordSize for return addr which is already pushed.
  818   framesize -= wordSize;
  819 
  820   if (C-&gt;need_stack_bang(bangsize)) {
  821     framesize -= wordSize;
  822     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  823     st-&gt;print(&quot;\n\t&quot;);
  824     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  825     if (PreserveFramePointer) {
  826         st-&gt;print(&quot;\n\t&quot;);
  827         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  828     }
  829     if (framesize) {
  830       st-&gt;print(&quot;\n\t&quot;);
  831       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  832     }
  833   } else {
  834     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  835     st-&gt;print(&quot;\n\t&quot;);
  836     framesize -= wordSize;
  837     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  838     if (PreserveFramePointer) {
  839       st-&gt;print(&quot;\n\t&quot;);
  840       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  841       if (framesize &gt; 0) {
  842         st-&gt;print(&quot;\n\t&quot;);
  843         st-&gt;print(&quot;addq    rbp, #%d&quot;, framesize);
  844       }
  845     }
  846   }
  847 
  848   if (VerifyStackAtCalls) {
  849     st-&gt;print(&quot;\n\t&quot;);
  850     framesize -= wordSize;
  851     st-&gt;print(&quot;movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check&quot;,framesize);
  852 #ifdef ASSERT
  853     st-&gt;print(&quot;\n\t&quot;);
  854     st-&gt;print(&quot;# stack alignment check&quot;);
  855 #endif
  856   }
  857   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  860     st-&gt;print(&quot;\n\t&quot;);
  861     st-&gt;print(&quot;je      fast_entry\t&quot;);
  862     st-&gt;print(&quot;\n\t&quot;);
  863     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  864     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  865   }
  866   st-&gt;cr();
  867 }
  868 #endif
  869 
  870 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  871   Compile* C = ra_-&gt;C;
  872   MacroAssembler _masm(&amp;cbuf);
  873 
  874   int framesize = C-&gt;frame_size_in_bytes();
  875   int bangsize = C-&gt;bang_size_in_bytes();
  876 
<a name="4" id="anc4"></a>














  877   __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);
  878 
  879   C-&gt;set_frame_complete(cbuf.insts_size());
  880 
  881   if (C-&gt;has_mach_constant_base_node()) {
  882     // NOTE: We set the table base offset here because users might be
  883     // emitted before MachConstantBaseNode.
  884     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
  885     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  886   }
  887 }
  888 
  889 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
  890 {
  891   return MachNode::size(ra_); // too many variables; just compute it
  892                               // the hard way
  893 }
  894 
  895 int MachPrologNode::reloc() const
  896 {
  897   return 0; // a large enough number
  898 }
  899 
  900 //=============================================================================
  901 #ifndef PRODUCT
  902 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  903 {
  904   Compile* C = ra_-&gt;C;
  905   if (generate_vzeroupper(C)) {
  906     st-&gt;print(&quot;vzeroupper&quot;);
  907     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  908   }
  909 
  910   int framesize = C-&gt;frame_size_in_bytes();
  911   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  912   // Remove word for return adr already pushed
  913   // and RBP
  914   framesize -= 2*wordSize;
  915 
  916   if (framesize) {
  917     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  918     st-&gt;print(&quot;\t&quot;);
  919   }
  920 
<a name="5" id="anc5"></a><span class="line-modified">  921   st-&gt;print_cr(&quot;popq   rbp&quot;);</span>
  922   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  923     st-&gt;print(&quot;\t&quot;);
  924     if (SafepointMechanism::uses_thread_local_poll()) {
<a name="6" id="anc6"></a><span class="line-modified">  925       st-&gt;print_cr(&quot;movq   rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;</span>
<span class="line-modified">  926                    &quot;testl  rax, [rscratch1]\t&quot;</span>
  927                    &quot;# Safepoint: poll for GC&quot;);
  928     } else if (Assembler::is_polling_page_far()) {
<a name="7" id="anc7"></a><span class="line-modified">  929       st-&gt;print_cr(&quot;movq   rscratch1, #polling_page_address\n\t&quot;</span>
<span class="line-modified">  930                    &quot;testl  rax, [rscratch1]\t&quot;</span>
  931                    &quot;# Safepoint: poll for GC&quot;);
  932     } else {
<a name="8" id="anc8"></a><span class="line-modified">  933       st-&gt;print_cr(&quot;testl  rax, [rip + #offset_to_poll_page]\t&quot;</span>
  934                    &quot;# Safepoint: poll for GC&quot;);
  935     }
  936   }
  937 }
  938 #endif
  939 
  940 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  941 {
  942   Compile* C = ra_-&gt;C;
  943   MacroAssembler _masm(&amp;cbuf);
  944 
  945   if (generate_vzeroupper(C)) {
  946     // Clear upper bits of YMM registers when current compiled code uses
  947     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  948     __ vzeroupper();
  949   }
  950 
  951   int framesize = C-&gt;frame_size_in_bytes();
  952   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  953   // Remove word for return adr already pushed
  954   // and RBP
  955   framesize -= 2*wordSize;
  956 
  957   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  958 
  959   if (framesize) {
  960     emit_opcode(cbuf, Assembler::REX_W);
  961     if (framesize &lt; 0x80) {
  962       emit_opcode(cbuf, 0x83); // addq rsp, #framesize
  963       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  964       emit_d8(cbuf, framesize);
  965     } else {
  966       emit_opcode(cbuf, 0x81); // addq rsp, #framesize
  967       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  968       emit_d32(cbuf, framesize);
  969     }
  970   }
  971 
  972   // popq rbp
  973   emit_opcode(cbuf, 0x58 | RBP_enc);
  974 
  975   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  976     __ reserved_stack_check();
  977   }
  978 
  979   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  980     MacroAssembler _masm(&amp;cbuf);
  981     if (SafepointMechanism::uses_thread_local_poll()) {
  982       __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  983       __ relocate(relocInfo::poll_return_type);
  984       __ testl(rax, Address(rscratch1, 0));
  985     } else {
  986       AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
  987       if (Assembler::is_polling_page_far()) {
  988         __ lea(rscratch1, polling_page);
  989         __ relocate(relocInfo::poll_return_type);
  990         __ testl(rax, Address(rscratch1, 0));
  991       } else {
  992         __ testl(rax, polling_page);
  993       }
  994     }
  995   }
  996 }
  997 
  998 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
  999 {
 1000   return MachNode::size(ra_); // too many variables; just compute it
 1001                               // the hard way
 1002 }
 1003 
 1004 int MachEpilogNode::reloc() const
 1005 {
 1006   return 2; // a large enough number
 1007 }
 1008 
 1009 const Pipeline* MachEpilogNode::pipeline() const
 1010 {
 1011   return MachNode::pipeline_class();
 1012 }
 1013 
 1014 int MachEpilogNode::safepoint_offset() const
 1015 {
 1016   return 0;
 1017 }
 1018 
 1019 //=============================================================================
 1020 
 1021 enum RC {
 1022   rc_bad,
 1023   rc_int,
 1024   rc_float,
 1025   rc_stack
 1026 };
 1027 
 1028 static enum RC rc_class(OptoReg::Name reg)
 1029 {
 1030   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1031 
 1032   if (OptoReg::is_stack(reg)) return rc_stack;
 1033 
 1034   VMReg r = OptoReg::as_VMReg(reg);
 1035 
 1036   if (r-&gt;is_Register()) return rc_int;
 1037 
 1038   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
 1039   return rc_float;
 1040 }
 1041 
 1042 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1043 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1044                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1045 
<a name="9" id="anc9"></a><span class="line-modified"> 1046 static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,</span>
<span class="line-modified"> 1047                             int stack_offset, int reg, uint ireg, outputStream* st);</span>
 1048 
 1049 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1050                                       int dst_offset, uint ireg, outputStream* st) {
 1051   if (cbuf) {
 1052     MacroAssembler _masm(cbuf);
 1053     switch (ireg) {
 1054     case Op_VecS:
 1055       __ movq(Address(rsp, -8), rax);
 1056       __ movl(rax, Address(rsp, src_offset));
 1057       __ movl(Address(rsp, dst_offset), rax);
 1058       __ movq(rax, Address(rsp, -8));
 1059       break;
 1060     case Op_VecD:
 1061       __ pushq(Address(rsp, src_offset));
 1062       __ popq (Address(rsp, dst_offset));
 1063       break;
 1064     case Op_VecX:
 1065       __ pushq(Address(rsp, src_offset));
 1066       __ popq (Address(rsp, dst_offset));
 1067       __ pushq(Address(rsp, src_offset+8));
 1068       __ popq (Address(rsp, dst_offset+8));
 1069       break;
 1070     case Op_VecY:
 1071       __ vmovdqu(Address(rsp, -32), xmm0);
 1072       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1073       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1074       __ vmovdqu(xmm0, Address(rsp, -32));
 1075       break;
 1076     case Op_VecZ:
 1077       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1078       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1079       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1080       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1081       break;
 1082     default:
 1083       ShouldNotReachHere();
 1084     }
 1085 #ifndef PRODUCT
 1086   } else {
 1087     switch (ireg) {
 1088     case Op_VecS:
 1089       st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1090                 &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1091                 &quot;movl    [rsp + #%d], rax\n\t&quot;
 1092                 &quot;movq    rax, [rsp - #8]&quot;,
 1093                 src_offset, dst_offset);
 1094       break;
 1095     case Op_VecD:
 1096       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1097                 &quot;popq    [rsp + #%d]&quot;,
 1098                 src_offset, dst_offset);
 1099       break;
 1100      case Op_VecX:
 1101       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t&quot;
 1102                 &quot;popq    [rsp + #%d]\n\t&quot;
 1103                 &quot;pushq   [rsp + #%d]\n\t&quot;
 1104                 &quot;popq    [rsp + #%d]&quot;,
 1105                 src_offset, dst_offset, src_offset+8, dst_offset+8);
 1106       break;
 1107     case Op_VecY:
 1108       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1109                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1110                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1111                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1112                 src_offset, dst_offset);
 1113       break;
 1114     case Op_VecZ:
 1115       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1116                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1117                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1118                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1119                 src_offset, dst_offset);
 1120       break;
 1121     default:
 1122       ShouldNotReachHere();
 1123     }
 1124 #endif
 1125   }
 1126 }
 1127 
 1128 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
 1129                                        PhaseRegAlloc* ra_,
 1130                                        bool do_size,
 1131                                        outputStream* st) const {
 1132   assert(cbuf != NULL || st  != NULL, &quot;sanity&quot;);
 1133   // Get registers to move
 1134   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1135   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1136   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
 1137   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
 1138 
 1139   enum RC src_second_rc = rc_class(src_second);
 1140   enum RC src_first_rc = rc_class(src_first);
 1141   enum RC dst_second_rc = rc_class(dst_second);
 1142   enum RC dst_first_rc = rc_class(dst_first);
 1143 
 1144   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
 1145          &quot;must move at least 1 register&quot; );
 1146 
 1147   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1148     // Self copy, no move
 1149     return 0;
 1150   }
 1151   if (bottom_type()-&gt;isa_vect() != NULL) {
 1152     uint ireg = ideal_reg();
 1153     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1154     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1155     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1156       // mem -&gt; mem
 1157       int src_offset = ra_-&gt;reg2offset(src_first);
 1158       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1159       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
 1160     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1161       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
 1162     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1163       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1164       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
 1165     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
 1166       int stack_offset = ra_-&gt;reg2offset(src_first);
 1167       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
 1168     } else {
 1169       ShouldNotReachHere();
 1170     }
 1171     return 0;
 1172   }
 1173   if (src_first_rc == rc_stack) {
 1174     // mem -&gt;
 1175     if (dst_first_rc == rc_stack) {
 1176       // mem -&gt; mem
 1177       assert(src_second != dst_first, &quot;overlap&quot;);
 1178       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1179           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1180         // 64-bit
 1181         int src_offset = ra_-&gt;reg2offset(src_first);
 1182         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1183         if (cbuf) {
 1184           MacroAssembler _masm(cbuf);
 1185           __ pushq(Address(rsp, src_offset));
 1186           __ popq (Address(rsp, dst_offset));
 1187 #ifndef PRODUCT
 1188         } else {
 1189           st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1190                     &quot;popq    [rsp + #%d]&quot;,
 1191                      src_offset, dst_offset);
 1192 #endif
 1193         }
 1194       } else {
 1195         // 32-bit
 1196         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1197         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1198         // No pushl/popl, so:
 1199         int src_offset = ra_-&gt;reg2offset(src_first);
 1200         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1201         if (cbuf) {
 1202           MacroAssembler _masm(cbuf);
 1203           __ movq(Address(rsp, -8), rax);
 1204           __ movl(rax, Address(rsp, src_offset));
 1205           __ movl(Address(rsp, dst_offset), rax);
 1206           __ movq(rax, Address(rsp, -8));
 1207 #ifndef PRODUCT
 1208         } else {
 1209           st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1210                     &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1211                     &quot;movl    [rsp + #%d], rax\n\t&quot;
 1212                     &quot;movq    rax, [rsp - #8]&quot;,
 1213                      src_offset, dst_offset);
 1214 #endif
 1215         }
 1216       }
 1217       return 0;
 1218     } else if (dst_first_rc == rc_int) {
 1219       // mem -&gt; gpr
 1220       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1221           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1222         // 64-bit
 1223         int offset = ra_-&gt;reg2offset(src_first);
 1224         if (cbuf) {
 1225           MacroAssembler _masm(cbuf);
 1226           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1227 #ifndef PRODUCT
 1228         } else {
 1229           st-&gt;print(&quot;movq    %s, [rsp + #%d]\t# spill&quot;,
 1230                      Matcher::regName[dst_first],
 1231                      offset);
 1232 #endif
 1233         }
 1234       } else {
 1235         // 32-bit
 1236         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1237         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1238         int offset = ra_-&gt;reg2offset(src_first);
 1239         if (cbuf) {
 1240           MacroAssembler _masm(cbuf);
 1241           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1242 #ifndef PRODUCT
 1243         } else {
 1244           st-&gt;print(&quot;movl    %s, [rsp + #%d]\t# spill&quot;,
 1245                      Matcher::regName[dst_first],
 1246                      offset);
 1247 #endif
 1248         }
 1249       }
 1250       return 0;
 1251     } else if (dst_first_rc == rc_float) {
 1252       // mem-&gt; xmm
 1253       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1254           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1255         // 64-bit
 1256         int offset = ra_-&gt;reg2offset(src_first);
 1257         if (cbuf) {
 1258           MacroAssembler _masm(cbuf);
 1259           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1260 #ifndef PRODUCT
 1261         } else {
 1262           st-&gt;print(&quot;%s  %s, [rsp + #%d]\t# spill&quot;,
 1263                      UseXmmLoadAndClearUpper ? &quot;movsd &quot; : &quot;movlpd&quot;,
 1264                      Matcher::regName[dst_first],
 1265                      offset);
 1266 #endif
 1267         }
 1268       } else {
 1269         // 32-bit
 1270         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1271         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1272         int offset = ra_-&gt;reg2offset(src_first);
 1273         if (cbuf) {
 1274           MacroAssembler _masm(cbuf);
 1275           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1276 #ifndef PRODUCT
 1277         } else {
 1278           st-&gt;print(&quot;movss   %s, [rsp + #%d]\t# spill&quot;,
 1279                      Matcher::regName[dst_first],
 1280                      offset);
 1281 #endif
 1282         }
 1283       }
 1284       return 0;
 1285     }
 1286   } else if (src_first_rc == rc_int) {
 1287     // gpr -&gt;
 1288     if (dst_first_rc == rc_stack) {
 1289       // gpr -&gt; mem
 1290       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1291           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1292         // 64-bit
 1293         int offset = ra_-&gt;reg2offset(dst_first);
 1294         if (cbuf) {
 1295           MacroAssembler _masm(cbuf);
 1296           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1297 #ifndef PRODUCT
 1298         } else {
 1299           st-&gt;print(&quot;movq    [rsp + #%d], %s\t# spill&quot;,
 1300                      offset,
 1301                      Matcher::regName[src_first]);
 1302 #endif
 1303         }
 1304       } else {
 1305         // 32-bit
 1306         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1307         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1308         int offset = ra_-&gt;reg2offset(dst_first);
 1309         if (cbuf) {
 1310           MacroAssembler _masm(cbuf);
 1311           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1312 #ifndef PRODUCT
 1313         } else {
 1314           st-&gt;print(&quot;movl    [rsp + #%d], %s\t# spill&quot;,
 1315                      offset,
 1316                      Matcher::regName[src_first]);
 1317 #endif
 1318         }
 1319       }
 1320       return 0;
 1321     } else if (dst_first_rc == rc_int) {
 1322       // gpr -&gt; gpr
 1323       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1324           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1325         // 64-bit
 1326         if (cbuf) {
 1327           MacroAssembler _masm(cbuf);
 1328           __ movq(as_Register(Matcher::_regEncode[dst_first]),
 1329                   as_Register(Matcher::_regEncode[src_first]));
 1330 #ifndef PRODUCT
 1331         } else {
 1332           st-&gt;print(&quot;movq    %s, %s\t# spill&quot;,
 1333                      Matcher::regName[dst_first],
 1334                      Matcher::regName[src_first]);
 1335 #endif
 1336         }
 1337         return 0;
 1338       } else {
 1339         // 32-bit
 1340         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1341         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1342         if (cbuf) {
 1343           MacroAssembler _masm(cbuf);
 1344           __ movl(as_Register(Matcher::_regEncode[dst_first]),
 1345                   as_Register(Matcher::_regEncode[src_first]));
 1346 #ifndef PRODUCT
 1347         } else {
 1348           st-&gt;print(&quot;movl    %s, %s\t# spill&quot;,
 1349                      Matcher::regName[dst_first],
 1350                      Matcher::regName[src_first]);
 1351 #endif
 1352         }
 1353         return 0;
 1354       }
 1355     } else if (dst_first_rc == rc_float) {
 1356       // gpr -&gt; xmm
 1357       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1358           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1359         // 64-bit
 1360         if (cbuf) {
 1361           MacroAssembler _masm(cbuf);
 1362           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1363 #ifndef PRODUCT
 1364         } else {
 1365           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1366                      Matcher::regName[dst_first],
 1367                      Matcher::regName[src_first]);
 1368 #endif
 1369         }
 1370       } else {
 1371         // 32-bit
 1372         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1373         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1374         if (cbuf) {
 1375           MacroAssembler _masm(cbuf);
 1376           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1377 #ifndef PRODUCT
 1378         } else {
 1379           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1380                      Matcher::regName[dst_first],
 1381                      Matcher::regName[src_first]);
 1382 #endif
 1383         }
 1384       }
 1385       return 0;
 1386     }
 1387   } else if (src_first_rc == rc_float) {
 1388     // xmm -&gt;
 1389     if (dst_first_rc == rc_stack) {
 1390       // xmm -&gt; mem
 1391       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1392           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1393         // 64-bit
 1394         int offset = ra_-&gt;reg2offset(dst_first);
 1395         if (cbuf) {
 1396           MacroAssembler _masm(cbuf);
 1397           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1398 #ifndef PRODUCT
 1399         } else {
 1400           st-&gt;print(&quot;movsd   [rsp + #%d], %s\t# spill&quot;,
 1401                      offset,
 1402                      Matcher::regName[src_first]);
 1403 #endif
 1404         }
 1405       } else {
 1406         // 32-bit
 1407         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1408         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1409         int offset = ra_-&gt;reg2offset(dst_first);
 1410         if (cbuf) {
 1411           MacroAssembler _masm(cbuf);
 1412           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1413 #ifndef PRODUCT
 1414         } else {
 1415           st-&gt;print(&quot;movss   [rsp + #%d], %s\t# spill&quot;,
 1416                      offset,
 1417                      Matcher::regName[src_first]);
 1418 #endif
 1419         }
 1420       }
 1421       return 0;
 1422     } else if (dst_first_rc == rc_int) {
 1423       // xmm -&gt; gpr
 1424       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1425           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1426         // 64-bit
 1427         if (cbuf) {
 1428           MacroAssembler _masm(cbuf);
 1429           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1430 #ifndef PRODUCT
 1431         } else {
 1432           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1433                      Matcher::regName[dst_first],
 1434                      Matcher::regName[src_first]);
 1435 #endif
 1436         }
 1437       } else {
 1438         // 32-bit
 1439         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1440         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1441         if (cbuf) {
 1442           MacroAssembler _masm(cbuf);
 1443           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1444 #ifndef PRODUCT
 1445         } else {
 1446           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1447                      Matcher::regName[dst_first],
 1448                      Matcher::regName[src_first]);
 1449 #endif
 1450         }
 1451       }
 1452       return 0;
 1453     } else if (dst_first_rc == rc_float) {
 1454       // xmm -&gt; xmm
 1455       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1456           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1457         // 64-bit
 1458         if (cbuf) {
 1459           MacroAssembler _masm(cbuf);
 1460           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1461 #ifndef PRODUCT
 1462         } else {
 1463           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1464                      UseXmmRegToRegMoveAll ? &quot;movapd&quot; : &quot;movsd &quot;,
 1465                      Matcher::regName[dst_first],
 1466                      Matcher::regName[src_first]);
 1467 #endif
 1468         }
 1469       } else {
 1470         // 32-bit
 1471         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1472         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1473         if (cbuf) {
 1474           MacroAssembler _masm(cbuf);
 1475           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1476 #ifndef PRODUCT
 1477         } else {
 1478           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1479                      UseXmmRegToRegMoveAll ? &quot;movaps&quot; : &quot;movss &quot;,
 1480                      Matcher::regName[dst_first],
 1481                      Matcher::regName[src_first]);
 1482 #endif
 1483         }
 1484       }
 1485       return 0;
 1486     }
 1487   }
 1488 
 1489   assert(0,&quot; foo &quot;);
 1490   Unimplemented();
 1491   return 0;
 1492 }
 1493 
 1494 #ifndef PRODUCT
 1495 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1496   implementation(NULL, ra_, false, st);
 1497 }
 1498 #endif
 1499 
 1500 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1501   implementation(&amp;cbuf, ra_, false, NULL);
 1502 }
 1503 
 1504 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1505   return MachNode::size(ra_);
 1506 }
 1507 
 1508 //=============================================================================
 1509 #ifndef PRODUCT
 1510 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1511 {
 1512   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1513   int reg = ra_-&gt;get_reg_first(this);
 1514   st-&gt;print(&quot;leaq    %s, [rsp + #%d]\t# box lock&quot;,
 1515             Matcher::regName[reg], offset);
 1516 }
 1517 #endif
 1518 
 1519 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1520 {
 1521   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1522   int reg = ra_-&gt;get_encode(this);
 1523   if (offset &gt;= 0x80) {
 1524     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1525     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1526     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1527     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1528     emit_d32(cbuf, offset);
 1529   } else {
 1530     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1531     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1532     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1533     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1534     emit_d8(cbuf, offset);
 1535   }
 1536 }
 1537 
 1538 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1539 {
 1540   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1541   return (offset &lt; 0x80) ? 5 : 8; // REX
 1542 }
 1543 
 1544 //=============================================================================
 1545 #ifndef PRODUCT
 1546 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1547 {
 1548   if (UseCompressedClassPointers) {
 1549     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1550     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1551     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1552   } else {
 1553     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1554                  &quot;# Inline cache check&quot;);
 1555   }
 1556   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1557   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1558 }
 1559 #endif
 1560 
 1561 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1562 {
 1563   MacroAssembler masm(&amp;cbuf);
 1564   uint insts_size = cbuf.insts_size();
 1565   if (UseCompressedClassPointers) {
 1566     masm.load_klass(rscratch1, j_rarg0);
 1567     masm.cmpptr(rax, rscratch1);
 1568   } else {
 1569     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1570   }
 1571 
 1572   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1573 
 1574   /* WARNING these NOPs are critical so that verified entry point is properly
 1575      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1576   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1577   if (OptoBreakpoint) {
 1578     // Leave space for int3
 1579     nops_cnt -= 1;
 1580   }
 1581   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1582   if (nops_cnt &gt; 0)
 1583     masm.nop(nops_cnt);
 1584 }
 1585 
 1586 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
 1587 {
 1588   return MachNode::size(ra_); // too many variables; just compute it
 1589                               // the hard way
 1590 }
 1591 
 1592 
 1593 //=============================================================================
 1594 
 1595 int Matcher::regnum_to_fpu_offset(int regnum)
 1596 {
 1597   return regnum - 32; // The FP registers are in the second chunk
 1598 }
 1599 
 1600 // This is UltraSparc specific, true just means we have fast l2f conversion
 1601 const bool Matcher::convL2FSupported(void) {
 1602   return true;
 1603 }
 1604 
 1605 // Is this branch offset short enough that a short branch can be used?
 1606 //
 1607 // NOTE: If the platform does not provide any short branch variants, then
 1608 //       this method should return false for offset 0.
 1609 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1610   // The passed offset is relative to address of the branch.
 1611   // On 86 a branch displacement is calculated relative to address
 1612   // of a next instruction.
 1613   offset -= br_size;
 1614 
 1615   // the short version of jmpConUCF2 contains multiple branches,
 1616   // making the reach slightly less
 1617   if (rule == jmpConUCF2_rule)
 1618     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1619   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1620 }
 1621 
 1622 const bool Matcher::isSimpleConstant64(jlong value) {
 1623   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1624   //return value == (int) value;  // Cf. storeImmL and immL32.
 1625 
 1626   // Probably always true, even if a temp register is required.
 1627   return true;
 1628 }
 1629 
 1630 // The ecx parameter to rep stosq for the ClearArray node is in words.
 1631 const bool Matcher::init_array_count_is_in_bytes = false;
 1632 
 1633 // No additional cost for CMOVL.
 1634 const int Matcher::long_cmove_cost() { return 0; }
 1635 
 1636 // No CMOVF/CMOVD with SSE2
 1637 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1638 
 1639 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1640 const bool Matcher::require_postalloc_expand = false;
 1641 
 1642 // Do we need to mask the count passed to shift instructions or does
 1643 // the cpu only look at the lower 5/6 bits anyway?
 1644 const bool Matcher::need_masked_shift_count = false;
 1645 
 1646 bool Matcher::narrow_oop_use_complex_address() {
 1647   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1648   return (LogMinObjAlignmentInBytes &lt;= 3);
 1649 }
 1650 
 1651 bool Matcher::narrow_klass_use_complex_address() {
 1652   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1653   return (LogKlassAlignmentInBytes &lt;= 3);
 1654 }
 1655 
 1656 bool Matcher::const_oop_prefer_decode() {
 1657   // Prefer ConN+DecodeN over ConP.
 1658   return true;
 1659 }
 1660 
 1661 bool Matcher::const_klass_prefer_decode() {
 1662   // TODO: Either support matching DecodeNKlass (heap-based) in operand
 1663   //       or condisider the following:
 1664   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
<a name="10" id="anc10"></a><span class="line-modified"> 1665   //return Universe::narrow_klass_base() == NULL;</span>
 1666   return true;
 1667 }
 1668 
 1669 // Is it better to copy float constants, or load them directly from
 1670 // memory?  Intel can load a float constant from a direct address,
 1671 // requiring no extra registers.  Most RISCs will have to materialize
 1672 // an address into a register first, so they would do better to copy
 1673 // the constant from stack.
 1674 const bool Matcher::rematerialize_float_constants = true; // XXX
 1675 
 1676 // If CPU can load and store mis-aligned doubles directly then no
 1677 // fixup is needed.  Else we split the double into 2 integer pieces
 1678 // and move it piece-by-piece.  Only happens when passing doubles into
 1679 // C code as the Java calling convention forces doubles to be aligned.
 1680 const bool Matcher::misaligned_doubles_ok = true;
 1681 
 1682 // No-op on amd64
 1683 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1684 
<a name="11" id="anc11"></a><span class="line-modified"> 1685 // Advertise here if the CPU requires explicit rounding operations to</span>
<span class="line-modified"> 1686 // implement the UseStrictFP mode.</span>
<span class="line-removed"> 1687 const bool Matcher::strict_fp_requires_explicit_rounding = true;</span>
 1688 
 1689 // Are floats conerted to double when stored to stack during deoptimization?
 1690 // On x64 it is stored without convertion so we can use normal access.
 1691 bool Matcher::float_in_double() { return false; }
 1692 
 1693 // Do ints take an entire long register or just half?
 1694 const bool Matcher::int_in_long = true;
 1695 
 1696 // Return whether or not this register is ever used as an argument.
 1697 // This function is used on startup to build the trampoline stubs in
 1698 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1699 // call in the trampoline, and arguments in those registers not be
 1700 // available to the callee.
 1701 bool Matcher::can_be_java_arg(int reg)
 1702 {
 1703   return
 1704     reg ==  RDI_num || reg == RDI_H_num ||
 1705     reg ==  RSI_num || reg == RSI_H_num ||
 1706     reg ==  RDX_num || reg == RDX_H_num ||
 1707     reg ==  RCX_num || reg == RCX_H_num ||
 1708     reg ==   R8_num || reg ==  R8_H_num ||
 1709     reg ==   R9_num || reg ==  R9_H_num ||
 1710     reg ==  R12_num || reg == R12_H_num ||
 1711     reg == XMM0_num || reg == XMM0b_num ||
 1712     reg == XMM1_num || reg == XMM1b_num ||
 1713     reg == XMM2_num || reg == XMM2b_num ||
 1714     reg == XMM3_num || reg == XMM3b_num ||
 1715     reg == XMM4_num || reg == XMM4b_num ||
 1716     reg == XMM5_num || reg == XMM5b_num ||
 1717     reg == XMM6_num || reg == XMM6b_num ||
 1718     reg == XMM7_num || reg == XMM7b_num;
 1719 }
 1720 
 1721 bool Matcher::is_spillable_arg(int reg)
 1722 {
 1723   return can_be_java_arg(reg);
 1724 }
 1725 
 1726 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1727   // In 64 bit mode a code which use multiply when
 1728   // devisor is constant is faster than hardware
 1729   // DIV instruction (it uses MulHiL).
 1730   return false;
 1731 }
 1732 
 1733 // Register for DIVI projection of divmodI
 1734 RegMask Matcher::divI_proj_mask() {
 1735   return INT_RAX_REG_mask();
 1736 }
 1737 
 1738 // Register for MODI projection of divmodI
 1739 RegMask Matcher::modI_proj_mask() {
 1740   return INT_RDX_REG_mask();
 1741 }
 1742 
 1743 // Register for DIVL projection of divmodL
 1744 RegMask Matcher::divL_proj_mask() {
 1745   return LONG_RAX_REG_mask();
 1746 }
 1747 
 1748 // Register for MODL projection of divmodL
 1749 RegMask Matcher::modL_proj_mask() {
 1750   return LONG_RDX_REG_mask();
 1751 }
 1752 
 1753 // Register for saving SP into on method handle invokes. Not used on x86_64.
 1754 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1755     return NO_REG_mask();
 1756 }
 1757 
 1758 %}
 1759 
 1760 //----------ENCODING BLOCK-----------------------------------------------------
 1761 // This block specifies the encoding classes used by the compiler to
 1762 // output byte streams.  Encoding classes are parameterized macros
 1763 // used by Machine Instruction Nodes in order to generate the bit
 1764 // encoding of the instruction.  Operands specify their base encoding
 1765 // interface with the interface keyword.  There are currently
 1766 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
 1767 // COND_INTER.  REG_INTER causes an operand to generate a function
 1768 // which returns its register number when queried.  CONST_INTER causes
 1769 // an operand to generate a function which returns the value of the
 1770 // constant when queried.  MEMORY_INTER causes an operand to generate
 1771 // four functions which return the Base Register, the Index Register,
 1772 // the Scale Value, and the Offset Value of the operand when queried.
 1773 // COND_INTER causes an operand to generate six functions which return
 1774 // the encoding code (ie - encoding bits for the instruction)
 1775 // associated with each basic boolean condition for a conditional
 1776 // instruction.
 1777 //
 1778 // Instructions specify two basic values for encoding.  Again, a
 1779 // function is available to check if the constant displacement is an
 1780 // oop. They use the ins_encode keyword to specify their encoding
 1781 // classes (which must be a sequence of enc_class names, and their
 1782 // parameters, specified in the encoding block), and they use the
 1783 // opcode keyword to specify, in order, their primary, secondary, and
 1784 // tertiary opcode.  Only the opcode sections which a particular
 1785 // instruction needs for encoding need to be specified.
 1786 encode %{
 1787   // Build emit functions for each basic byte or larger field in the
 1788   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 1789   // from C++ code in the enc_class source block.  Emit functions will
 1790   // live in the main source block for now.  In future, we can
 1791   // generalize this by adding a syntax that specifies the sizes of
 1792   // fields in an order, so that the adlc can build the emit functions
 1793   // automagically
 1794 
 1795   // Emit primary opcode
 1796   enc_class OpcP
 1797   %{
 1798     emit_opcode(cbuf, $primary);
 1799   %}
 1800 
 1801   // Emit secondary opcode
 1802   enc_class OpcS
 1803   %{
 1804     emit_opcode(cbuf, $secondary);
 1805   %}
 1806 
 1807   // Emit tertiary opcode
 1808   enc_class OpcT
 1809   %{
 1810     emit_opcode(cbuf, $tertiary);
 1811   %}
 1812 
 1813   // Emit opcode directly
 1814   enc_class Opcode(immI d8)
 1815   %{
 1816     emit_opcode(cbuf, $d8$$constant);
 1817   %}
 1818 
 1819   // Emit size prefix
 1820   enc_class SizePrefix
 1821   %{
 1822     emit_opcode(cbuf, 0x66);
 1823   %}
 1824 
 1825   enc_class reg(rRegI reg)
 1826   %{
 1827     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
 1828   %}
 1829 
 1830   enc_class reg_reg(rRegI dst, rRegI src)
 1831   %{
 1832     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1833   %}
 1834 
 1835   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
 1836   %{
 1837     emit_opcode(cbuf, $opcode$$constant);
 1838     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1839   %}
 1840 
 1841   enc_class cdql_enc(no_rax_rdx_RegI div)
 1842   %{
 1843     // Full implementation of Java idiv and irem; checks for
 1844     // special case as described in JVM spec., p.243 &amp; p.271.
 1845     //
 1846     //         normal case                           special case
 1847     //
 1848     // input : rax: dividend                         min_int
 1849     //         reg: divisor                          -1
 1850     //
 1851     // output: rax: quotient  (= rax idiv reg)       min_int
 1852     //         rdx: remainder (= rax irem reg)       0
 1853     //
 1854     //  Code sequnce:
 1855     //
 1856     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
 1857     //    5:   75 07/08                jne    e &lt;normal&gt;
 1858     //    7:   33 d2                   xor    %edx,%edx
 1859     //  [div &gt;= 8 -&gt; offset + 1]
 1860     //  [REX_B]
 1861     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
 1862     //    c:   74 03/04                je     11 &lt;done&gt;
 1863     // 000000000000000e &lt;normal&gt;:
 1864     //    e:   99                      cltd
 1865     //  [div &gt;= 8 -&gt; offset + 1]
 1866     //  [REX_B]
 1867     //    f:   f7 f9                   idiv   $div
 1868     // 0000000000000011 &lt;done&gt;:
 1869 
 1870     // cmp    $0x80000000,%eax
 1871     emit_opcode(cbuf, 0x3d);
 1872     emit_d8(cbuf, 0x00);
 1873     emit_d8(cbuf, 0x00);
 1874     emit_d8(cbuf, 0x00);
 1875     emit_d8(cbuf, 0x80);
 1876 
 1877     // jne    e &lt;normal&gt;
 1878     emit_opcode(cbuf, 0x75);
 1879     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
 1880 
 1881     // xor    %edx,%edx
 1882     emit_opcode(cbuf, 0x33);
 1883     emit_d8(cbuf, 0xD2);
 1884 
 1885     // cmp    $0xffffffffffffffff,%ecx
 1886     if ($div$$reg &gt;= 8) {
 1887       emit_opcode(cbuf, Assembler::REX_B);
 1888     }
 1889     emit_opcode(cbuf, 0x83);
 1890     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1891     emit_d8(cbuf, 0xFF);
 1892 
 1893     // je     11 &lt;done&gt;
 1894     emit_opcode(cbuf, 0x74);
 1895     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
 1896 
 1897     // &lt;normal&gt;
 1898     // cltd
 1899     emit_opcode(cbuf, 0x99);
 1900 
 1901     // idivl (note: must be emitted by the user of this rule)
 1902     // &lt;done&gt;
 1903   %}
 1904 
 1905   enc_class cdqq_enc(no_rax_rdx_RegL div)
 1906   %{
 1907     // Full implementation of Java ldiv and lrem; checks for
 1908     // special case as described in JVM spec., p.243 &amp; p.271.
 1909     //
 1910     //         normal case                           special case
 1911     //
 1912     // input : rax: dividend                         min_long
 1913     //         reg: divisor                          -1
 1914     //
 1915     // output: rax: quotient  (= rax idiv reg)       min_long
 1916     //         rdx: remainder (= rax irem reg)       0
 1917     //
 1918     //  Code sequnce:
 1919     //
 1920     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
 1921     //    7:   00 00 80
 1922     //    a:   48 39 d0                cmp    %rdx,%rax
 1923     //    d:   75 08                   jne    17 &lt;normal&gt;
 1924     //    f:   33 d2                   xor    %edx,%edx
 1925     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
 1926     //   15:   74 05                   je     1c &lt;done&gt;
 1927     // 0000000000000017 &lt;normal&gt;:
 1928     //   17:   48 99                   cqto
 1929     //   19:   48 f7 f9                idiv   $div
 1930     // 000000000000001c &lt;done&gt;:
 1931 
 1932     // mov    $0x8000000000000000,%rdx
 1933     emit_opcode(cbuf, Assembler::REX_W);
 1934     emit_opcode(cbuf, 0xBA);
 1935     emit_d8(cbuf, 0x00);
 1936     emit_d8(cbuf, 0x00);
 1937     emit_d8(cbuf, 0x00);
 1938     emit_d8(cbuf, 0x00);
 1939     emit_d8(cbuf, 0x00);
 1940     emit_d8(cbuf, 0x00);
 1941     emit_d8(cbuf, 0x00);
 1942     emit_d8(cbuf, 0x80);
 1943 
 1944     // cmp    %rdx,%rax
 1945     emit_opcode(cbuf, Assembler::REX_W);
 1946     emit_opcode(cbuf, 0x39);
 1947     emit_d8(cbuf, 0xD0);
 1948 
 1949     // jne    17 &lt;normal&gt;
 1950     emit_opcode(cbuf, 0x75);
 1951     emit_d8(cbuf, 0x08);
 1952 
 1953     // xor    %edx,%edx
 1954     emit_opcode(cbuf, 0x33);
 1955     emit_d8(cbuf, 0xD2);
 1956 
 1957     // cmp    $0xffffffffffffffff,$div
 1958     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
 1959     emit_opcode(cbuf, 0x83);
 1960     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1961     emit_d8(cbuf, 0xFF);
 1962 
 1963     // je     1e &lt;done&gt;
 1964     emit_opcode(cbuf, 0x74);
 1965     emit_d8(cbuf, 0x05);
 1966 
 1967     // &lt;normal&gt;
 1968     // cqto
 1969     emit_opcode(cbuf, Assembler::REX_W);
 1970     emit_opcode(cbuf, 0x99);
 1971 
 1972     // idivq (note: must be emitted by the user of this rule)
 1973     // &lt;done&gt;
 1974   %}
 1975 
 1976   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1977   enc_class OpcSE(immI imm)
 1978   %{
 1979     // Emit primary opcode and set sign-extend bit
 1980     // Check for 8-bit immediate, and set sign extend bit in opcode
 1981     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1982       emit_opcode(cbuf, $primary | 0x02);
 1983     } else {
 1984       // 32-bit immediate
 1985       emit_opcode(cbuf, $primary);
 1986     }
 1987   %}
 1988 
 1989   enc_class OpcSErm(rRegI dst, immI imm)
 1990   %{
 1991     // OpcSEr/m
 1992     int dstenc = $dst$$reg;
 1993     if (dstenc &gt;= 8) {
 1994       emit_opcode(cbuf, Assembler::REX_B);
 1995       dstenc -= 8;
 1996     }
 1997     // Emit primary opcode and set sign-extend bit
 1998     // Check for 8-bit immediate, and set sign extend bit in opcode
 1999     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2000       emit_opcode(cbuf, $primary | 0x02);
 2001     } else {
 2002       // 32-bit immediate
 2003       emit_opcode(cbuf, $primary);
 2004     }
 2005     // Emit r/m byte with secondary opcode, after primary opcode.
 2006     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2007   %}
 2008 
 2009   enc_class OpcSErm_wide(rRegL dst, immI imm)
 2010   %{
 2011     // OpcSEr/m
 2012     int dstenc = $dst$$reg;
 2013     if (dstenc &lt; 8) {
 2014       emit_opcode(cbuf, Assembler::REX_W);
 2015     } else {
 2016       emit_opcode(cbuf, Assembler::REX_WB);
 2017       dstenc -= 8;
 2018     }
 2019     // Emit primary opcode and set sign-extend bit
 2020     // Check for 8-bit immediate, and set sign extend bit in opcode
 2021     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2022       emit_opcode(cbuf, $primary | 0x02);
 2023     } else {
 2024       // 32-bit immediate
 2025       emit_opcode(cbuf, $primary);
 2026     }
 2027     // Emit r/m byte with secondary opcode, after primary opcode.
 2028     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2029   %}
 2030 
 2031   enc_class Con8or32(immI imm)
 2032   %{
 2033     // Check for 8-bit immediate, and set sign extend bit in opcode
 2034     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2035       $$$emit8$imm$$constant;
 2036     } else {
 2037       // 32-bit immediate
 2038       $$$emit32$imm$$constant;
 2039     }
 2040   %}
 2041 
 2042   enc_class opc2_reg(rRegI dst)
 2043   %{
 2044     // BSWAP
 2045     emit_cc(cbuf, $secondary, $dst$$reg);
 2046   %}
 2047 
 2048   enc_class opc3_reg(rRegI dst)
 2049   %{
 2050     // BSWAP
 2051     emit_cc(cbuf, $tertiary, $dst$$reg);
 2052   %}
 2053 
 2054   enc_class reg_opc(rRegI div)
 2055   %{
 2056     // INC, DEC, IDIV, IMOD, JMP indirect, ...
 2057     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
 2058   %}
 2059 
 2060   enc_class enc_cmov(cmpOp cop)
 2061   %{
 2062     // CMOV
 2063     $$$emit8$primary;
 2064     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 2065   %}
 2066 
 2067   enc_class enc_PartialSubtypeCheck()
 2068   %{
 2069     Register Rrdi = as_Register(RDI_enc); // result register
 2070     Register Rrax = as_Register(RAX_enc); // super class
 2071     Register Rrcx = as_Register(RCX_enc); // killed
 2072     Register Rrsi = as_Register(RSI_enc); // sub class
 2073     Label miss;
 2074     const bool set_cond_codes = true;
 2075 
 2076     MacroAssembler _masm(&amp;cbuf);
 2077     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
 2078                                      NULL, &amp;miss,
 2079                                      /*set_cond_codes:*/ true);
 2080     if ($primary) {
 2081       __ xorptr(Rrdi, Rrdi);
 2082     }
 2083     __ bind(miss);
 2084   %}
 2085 
 2086   enc_class clear_avx %{
 2087     debug_only(int off0 = cbuf.insts_size());
 2088     if (generate_vzeroupper(Compile::current())) {
 2089       // Clear upper bits of YMM registers to avoid AVX &lt;-&gt; SSE transition penalty
 2090       // Clear upper bits of YMM registers when current compiled code uses
 2091       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 2092       MacroAssembler _masm(&amp;cbuf);
 2093       __ vzeroupper();
 2094     }
 2095     debug_only(int off1 = cbuf.insts_size());
 2096     assert(off1 - off0 == clear_avx_size(), &quot;correct size prediction&quot;);
 2097   %}
 2098 
 2099   enc_class Java_To_Runtime(method meth) %{
 2100     // No relocation needed
 2101     MacroAssembler _masm(&amp;cbuf);
 2102     __ mov64(r10, (int64_t) $meth$$method);
 2103     __ call(r10);
 2104   %}
 2105 
 2106   enc_class Java_To_Interpreter(method meth)
 2107   %{
 2108     // CALL Java_To_Interpreter
 2109     // This is the instruction starting address for relocation info.
 2110     cbuf.set_insts_mark();
 2111     $$$emit8$primary;
 2112     // CALL directly to the runtime
 2113     emit_d32_reloc(cbuf,
 2114                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2115                    runtime_call_Relocation::spec(),
 2116                    RELOC_DISP32);
 2117   %}
 2118 
 2119   enc_class Java_Static_Call(method meth)
 2120   %{
 2121     // JAVA STATIC CALL
 2122     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
 2123     // determine who we intended to call.
 2124     cbuf.set_insts_mark();
 2125     $$$emit8$primary;
 2126 
 2127     if (!_method) {
 2128       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2129                      runtime_call_Relocation::spec(),
 2130                      RELOC_DISP32);
 2131     } else {
 2132       int method_index = resolved_method_index(cbuf);
 2133       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2134                                                   : static_call_Relocation::spec(method_index);
 2135       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2136                      rspec, RELOC_DISP32);
 2137       // Emit stubs for static call.
 2138       address mark = cbuf.insts_mark();
 2139       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
 2140       if (stub == NULL) {
 2141         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2142         return;
 2143       }
 2144 #if INCLUDE_AOT
 2145       CompiledStaticCall::emit_to_aot_stub(cbuf, mark);
 2146 #endif
 2147     }
 2148   %}
 2149 
 2150   enc_class Java_Dynamic_Call(method meth) %{
 2151     MacroAssembler _masm(&amp;cbuf);
 2152     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 2153   %}
 2154 
 2155   enc_class Java_Compiled_Call(method meth)
 2156   %{
 2157     // JAVA COMPILED CALL
 2158     int disp = in_bytes(Method:: from_compiled_offset());
 2159 
 2160     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
 2161     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, &quot;compiled_code_offset isn&#39;t small&quot;);
 2162 
 2163     // callq *disp(%rax)
 2164     cbuf.set_insts_mark();
 2165     $$$emit8$primary;
 2166     if (disp &lt; 0x80) {
 2167       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
 2168       emit_d8(cbuf, disp); // Displacement
 2169     } else {
 2170       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
 2171       emit_d32(cbuf, disp); // Displacement
 2172     }
 2173   %}
 2174 
 2175   enc_class reg_opc_imm(rRegI dst, immI8 shift)
 2176   %{
 2177     // SAL, SAR, SHR
 2178     int dstenc = $dst$$reg;
 2179     if (dstenc &gt;= 8) {
 2180       emit_opcode(cbuf, Assembler::REX_B);
 2181       dstenc -= 8;
 2182     }
 2183     $$$emit8$primary;
 2184     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2185     $$$emit8$shift$$constant;
 2186   %}
 2187 
 2188   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
 2189   %{
 2190     // SAL, SAR, SHR
 2191     int dstenc = $dst$$reg;
 2192     if (dstenc &lt; 8) {
 2193       emit_opcode(cbuf, Assembler::REX_W);
 2194     } else {
 2195       emit_opcode(cbuf, Assembler::REX_WB);
 2196       dstenc -= 8;
 2197     }
 2198     $$$emit8$primary;
 2199     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2200     $$$emit8$shift$$constant;
 2201   %}
 2202 
 2203   enc_class load_immI(rRegI dst, immI src)
 2204   %{
 2205     int dstenc = $dst$$reg;
 2206     if (dstenc &gt;= 8) {
 2207       emit_opcode(cbuf, Assembler::REX_B);
 2208       dstenc -= 8;
 2209     }
 2210     emit_opcode(cbuf, 0xB8 | dstenc);
 2211     $$$emit32$src$$constant;
 2212   %}
 2213 
 2214   enc_class load_immL(rRegL dst, immL src)
 2215   %{
 2216     int dstenc = $dst$$reg;
 2217     if (dstenc &lt; 8) {
 2218       emit_opcode(cbuf, Assembler::REX_W);
 2219     } else {
 2220       emit_opcode(cbuf, Assembler::REX_WB);
 2221       dstenc -= 8;
 2222     }
 2223     emit_opcode(cbuf, 0xB8 | dstenc);
 2224     emit_d64(cbuf, $src$$constant);
 2225   %}
 2226 
 2227   enc_class load_immUL32(rRegL dst, immUL32 src)
 2228   %{
 2229     // same as load_immI, but this time we care about zeroes in the high word
 2230     int dstenc = $dst$$reg;
 2231     if (dstenc &gt;= 8) {
 2232       emit_opcode(cbuf, Assembler::REX_B);
 2233       dstenc -= 8;
 2234     }
 2235     emit_opcode(cbuf, 0xB8 | dstenc);
 2236     $$$emit32$src$$constant;
 2237   %}
 2238 
 2239   enc_class load_immL32(rRegL dst, immL32 src)
 2240   %{
 2241     int dstenc = $dst$$reg;
 2242     if (dstenc &lt; 8) {
 2243       emit_opcode(cbuf, Assembler::REX_W);
 2244     } else {
 2245       emit_opcode(cbuf, Assembler::REX_WB);
 2246       dstenc -= 8;
 2247     }
 2248     emit_opcode(cbuf, 0xC7);
 2249     emit_rm(cbuf, 0x03, 0x00, dstenc);
 2250     $$$emit32$src$$constant;
 2251   %}
 2252 
 2253   enc_class load_immP31(rRegP dst, immP32 src)
 2254   %{
 2255     // same as load_immI, but this time we care about zeroes in the high word
 2256     int dstenc = $dst$$reg;
 2257     if (dstenc &gt;= 8) {
 2258       emit_opcode(cbuf, Assembler::REX_B);
 2259       dstenc -= 8;
 2260     }
 2261     emit_opcode(cbuf, 0xB8 | dstenc);
 2262     $$$emit32$src$$constant;
 2263   %}
 2264 
 2265   enc_class load_immP(rRegP dst, immP src)
 2266   %{
 2267     int dstenc = $dst$$reg;
 2268     if (dstenc &lt; 8) {
 2269       emit_opcode(cbuf, Assembler::REX_W);
 2270     } else {
 2271       emit_opcode(cbuf, Assembler::REX_WB);
 2272       dstenc -= 8;
 2273     }
 2274     emit_opcode(cbuf, 0xB8 | dstenc);
 2275     // This next line should be generated from ADLC
 2276     if ($src-&gt;constant_reloc() != relocInfo::none) {
 2277       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
 2278     } else {
 2279       emit_d64(cbuf, $src$$constant);
 2280     }
 2281   %}
 2282 
 2283   enc_class Con32(immI src)
 2284   %{
 2285     // Output immediate
 2286     $$$emit32$src$$constant;
 2287   %}
 2288 
 2289   enc_class Con32F_as_bits(immF src)
 2290   %{
 2291     // Output Float immediate bits
 2292     jfloat jf = $src$$constant;
 2293     jint jf_as_bits = jint_cast(jf);
 2294     emit_d32(cbuf, jf_as_bits);
 2295   %}
 2296 
 2297   enc_class Con16(immI src)
 2298   %{
 2299     // Output immediate
 2300     $$$emit16$src$$constant;
 2301   %}
 2302 
 2303   // How is this different from Con32??? XXX
 2304   enc_class Con_d32(immI src)
 2305   %{
 2306     emit_d32(cbuf,$src$$constant);
 2307   %}
 2308 
 2309   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
 2310     // Output immediate memory reference
 2311     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2312     emit_d32(cbuf, 0x00);
 2313   %}
 2314 
 2315   enc_class lock_prefix()
 2316   %{
 2317     emit_opcode(cbuf, 0xF0); // lock
 2318   %}
 2319 
 2320   enc_class REX_mem(memory mem)
 2321   %{
 2322     if ($mem$$base &gt;= 8) {
 2323       if ($mem$$index &lt; 8) {
 2324         emit_opcode(cbuf, Assembler::REX_B);
 2325       } else {
 2326         emit_opcode(cbuf, Assembler::REX_XB);
 2327       }
 2328     } else {
 2329       if ($mem$$index &gt;= 8) {
 2330         emit_opcode(cbuf, Assembler::REX_X);
 2331       }
 2332     }
 2333   %}
 2334 
 2335   enc_class REX_mem_wide(memory mem)
 2336   %{
 2337     if ($mem$$base &gt;= 8) {
 2338       if ($mem$$index &lt; 8) {
 2339         emit_opcode(cbuf, Assembler::REX_WB);
 2340       } else {
 2341         emit_opcode(cbuf, Assembler::REX_WXB);
 2342       }
 2343     } else {
 2344       if ($mem$$index &lt; 8) {
 2345         emit_opcode(cbuf, Assembler::REX_W);
 2346       } else {
 2347         emit_opcode(cbuf, Assembler::REX_WX);
 2348       }
 2349     }
 2350   %}
 2351 
 2352   // for byte regs
 2353   enc_class REX_breg(rRegI reg)
 2354   %{
 2355     if ($reg$$reg &gt;= 4) {
 2356       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2357     }
 2358   %}
 2359 
 2360   // for byte regs
 2361   enc_class REX_reg_breg(rRegI dst, rRegI src)
 2362   %{
 2363     if ($dst$$reg &lt; 8) {
 2364       if ($src$$reg &gt;= 4) {
 2365         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2366       }
 2367     } else {
 2368       if ($src$$reg &lt; 8) {
 2369         emit_opcode(cbuf, Assembler::REX_R);
 2370       } else {
 2371         emit_opcode(cbuf, Assembler::REX_RB);
 2372       }
 2373     }
 2374   %}
 2375 
 2376   // for byte regs
 2377   enc_class REX_breg_mem(rRegI reg, memory mem)
 2378   %{
 2379     if ($reg$$reg &lt; 8) {
 2380       if ($mem$$base &lt; 8) {
 2381         if ($mem$$index &gt;= 8) {
 2382           emit_opcode(cbuf, Assembler::REX_X);
 2383         } else if ($reg$$reg &gt;= 4) {
 2384           emit_opcode(cbuf, Assembler::REX);
 2385         }
 2386       } else {
 2387         if ($mem$$index &lt; 8) {
 2388           emit_opcode(cbuf, Assembler::REX_B);
 2389         } else {
 2390           emit_opcode(cbuf, Assembler::REX_XB);
 2391         }
 2392       }
 2393     } else {
 2394       if ($mem$$base &lt; 8) {
 2395         if ($mem$$index &lt; 8) {
 2396           emit_opcode(cbuf, Assembler::REX_R);
 2397         } else {
 2398           emit_opcode(cbuf, Assembler::REX_RX);
 2399         }
 2400       } else {
 2401         if ($mem$$index &lt; 8) {
 2402           emit_opcode(cbuf, Assembler::REX_RB);
 2403         } else {
 2404           emit_opcode(cbuf, Assembler::REX_RXB);
 2405         }
 2406       }
 2407     }
 2408   %}
 2409 
 2410   enc_class REX_reg(rRegI reg)
 2411   %{
 2412     if ($reg$$reg &gt;= 8) {
 2413       emit_opcode(cbuf, Assembler::REX_B);
 2414     }
 2415   %}
 2416 
 2417   enc_class REX_reg_wide(rRegI reg)
 2418   %{
 2419     if ($reg$$reg &lt; 8) {
 2420       emit_opcode(cbuf, Assembler::REX_W);
 2421     } else {
 2422       emit_opcode(cbuf, Assembler::REX_WB);
 2423     }
 2424   %}
 2425 
 2426   enc_class REX_reg_reg(rRegI dst, rRegI src)
 2427   %{
 2428     if ($dst$$reg &lt; 8) {
 2429       if ($src$$reg &gt;= 8) {
 2430         emit_opcode(cbuf, Assembler::REX_B);
 2431       }
 2432     } else {
 2433       if ($src$$reg &lt; 8) {
 2434         emit_opcode(cbuf, Assembler::REX_R);
 2435       } else {
 2436         emit_opcode(cbuf, Assembler::REX_RB);
 2437       }
 2438     }
 2439   %}
 2440 
 2441   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
 2442   %{
 2443     if ($dst$$reg &lt; 8) {
 2444       if ($src$$reg &lt; 8) {
 2445         emit_opcode(cbuf, Assembler::REX_W);
 2446       } else {
 2447         emit_opcode(cbuf, Assembler::REX_WB);
 2448       }
 2449     } else {
 2450       if ($src$$reg &lt; 8) {
 2451         emit_opcode(cbuf, Assembler::REX_WR);
 2452       } else {
 2453         emit_opcode(cbuf, Assembler::REX_WRB);
 2454       }
 2455     }
 2456   %}
 2457 
 2458   enc_class REX_reg_mem(rRegI reg, memory mem)
 2459   %{
 2460     if ($reg$$reg &lt; 8) {
 2461       if ($mem$$base &lt; 8) {
 2462         if ($mem$$index &gt;= 8) {
 2463           emit_opcode(cbuf, Assembler::REX_X);
 2464         }
 2465       } else {
 2466         if ($mem$$index &lt; 8) {
 2467           emit_opcode(cbuf, Assembler::REX_B);
 2468         } else {
 2469           emit_opcode(cbuf, Assembler::REX_XB);
 2470         }
 2471       }
 2472     } else {
 2473       if ($mem$$base &lt; 8) {
 2474         if ($mem$$index &lt; 8) {
 2475           emit_opcode(cbuf, Assembler::REX_R);
 2476         } else {
 2477           emit_opcode(cbuf, Assembler::REX_RX);
 2478         }
 2479       } else {
 2480         if ($mem$$index &lt; 8) {
 2481           emit_opcode(cbuf, Assembler::REX_RB);
 2482         } else {
 2483           emit_opcode(cbuf, Assembler::REX_RXB);
 2484         }
 2485       }
 2486     }
 2487   %}
 2488 
 2489   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
 2490   %{
 2491     if ($reg$$reg &lt; 8) {
 2492       if ($mem$$base &lt; 8) {
 2493         if ($mem$$index &lt; 8) {
 2494           emit_opcode(cbuf, Assembler::REX_W);
 2495         } else {
 2496           emit_opcode(cbuf, Assembler::REX_WX);
 2497         }
 2498       } else {
 2499         if ($mem$$index &lt; 8) {
 2500           emit_opcode(cbuf, Assembler::REX_WB);
 2501         } else {
 2502           emit_opcode(cbuf, Assembler::REX_WXB);
 2503         }
 2504       }
 2505     } else {
 2506       if ($mem$$base &lt; 8) {
 2507         if ($mem$$index &lt; 8) {
 2508           emit_opcode(cbuf, Assembler::REX_WR);
 2509         } else {
 2510           emit_opcode(cbuf, Assembler::REX_WRX);
 2511         }
 2512       } else {
 2513         if ($mem$$index &lt; 8) {
 2514           emit_opcode(cbuf, Assembler::REX_WRB);
 2515         } else {
 2516           emit_opcode(cbuf, Assembler::REX_WRXB);
 2517         }
 2518       }
 2519     }
 2520   %}
 2521 
 2522   enc_class reg_mem(rRegI ereg, memory mem)
 2523   %{
 2524     // High registers handle in encode_RegMem
 2525     int reg = $ereg$$reg;
 2526     int base = $mem$$base;
 2527     int index = $mem$$index;
 2528     int scale = $mem$$scale;
 2529     int disp = $mem$$disp;
 2530     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2531 
 2532     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
 2533   %}
 2534 
 2535   enc_class RM_opc_mem(immI rm_opcode, memory mem)
 2536   %{
 2537     int rm_byte_opcode = $rm_opcode$$constant;
 2538 
 2539     // High registers handle in encode_RegMem
 2540     int base = $mem$$base;
 2541     int index = $mem$$index;
 2542     int scale = $mem$$scale;
 2543     int displace = $mem$$disp;
 2544 
 2545     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
 2546                                             // working with static
 2547                                             // globals
 2548     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
 2549                   disp_reloc);
 2550   %}
 2551 
 2552   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
 2553   %{
 2554     int reg_encoding = $dst$$reg;
 2555     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2556     int index        = 0x04;            // 0x04 indicates no index
 2557     int scale        = 0x00;            // 0x00 indicates no scale
 2558     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2559     relocInfo::relocType disp_reloc = relocInfo::none;
 2560     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
 2561                   disp_reloc);
 2562   %}
 2563 
 2564   enc_class neg_reg(rRegI dst)
 2565   %{
 2566     int dstenc = $dst$$reg;
 2567     if (dstenc &gt;= 8) {
 2568       emit_opcode(cbuf, Assembler::REX_B);
 2569       dstenc -= 8;
 2570     }
 2571     // NEG $dst
 2572     emit_opcode(cbuf, 0xF7);
 2573     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2574   %}
 2575 
 2576   enc_class neg_reg_wide(rRegI dst)
 2577   %{
 2578     int dstenc = $dst$$reg;
 2579     if (dstenc &lt; 8) {
 2580       emit_opcode(cbuf, Assembler::REX_W);
 2581     } else {
 2582       emit_opcode(cbuf, Assembler::REX_WB);
 2583       dstenc -= 8;
 2584     }
 2585     // NEG $dst
 2586     emit_opcode(cbuf, 0xF7);
 2587     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2588   %}
 2589 
 2590   enc_class setLT_reg(rRegI dst)
 2591   %{
 2592     int dstenc = $dst$$reg;
 2593     if (dstenc &gt;= 8) {
 2594       emit_opcode(cbuf, Assembler::REX_B);
 2595       dstenc -= 8;
 2596     } else if (dstenc &gt;= 4) {
 2597       emit_opcode(cbuf, Assembler::REX);
 2598     }
 2599     // SETLT $dst
 2600     emit_opcode(cbuf, 0x0F);
 2601     emit_opcode(cbuf, 0x9C);
 2602     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2603   %}
 2604 
 2605   enc_class setNZ_reg(rRegI dst)
 2606   %{
 2607     int dstenc = $dst$$reg;
 2608     if (dstenc &gt;= 8) {
 2609       emit_opcode(cbuf, Assembler::REX_B);
 2610       dstenc -= 8;
 2611     } else if (dstenc &gt;= 4) {
 2612       emit_opcode(cbuf, Assembler::REX);
 2613     }
 2614     // SETNZ $dst
 2615     emit_opcode(cbuf, 0x0F);
 2616     emit_opcode(cbuf, 0x95);
 2617     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2618   %}
 2619 
 2620 
 2621   // Compare the lonogs and set -1, 0, or 1 into dst
 2622   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
 2623   %{
 2624     int src1enc = $src1$$reg;
 2625     int src2enc = $src2$$reg;
 2626     int dstenc = $dst$$reg;
 2627 
 2628     // cmpq $src1, $src2
 2629     if (src1enc &lt; 8) {
 2630       if (src2enc &lt; 8) {
 2631         emit_opcode(cbuf, Assembler::REX_W);
 2632       } else {
 2633         emit_opcode(cbuf, Assembler::REX_WB);
 2634       }
 2635     } else {
 2636       if (src2enc &lt; 8) {
 2637         emit_opcode(cbuf, Assembler::REX_WR);
 2638       } else {
 2639         emit_opcode(cbuf, Assembler::REX_WRB);
 2640       }
 2641     }
 2642     emit_opcode(cbuf, 0x3B);
 2643     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
 2644 
 2645     // movl $dst, -1
 2646     if (dstenc &gt;= 8) {
 2647       emit_opcode(cbuf, Assembler::REX_B);
 2648     }
 2649     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
 2650     emit_d32(cbuf, -1);
 2651 
 2652     // jl,s done
 2653     emit_opcode(cbuf, 0x7C);
 2654     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
 2655 
 2656     // setne $dst
 2657     if (dstenc &gt;= 4) {
 2658       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2659     }
 2660     emit_opcode(cbuf, 0x0F);
 2661     emit_opcode(cbuf, 0x95);
 2662     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
 2663 
 2664     // movzbl $dst, $dst
 2665     if (dstenc &gt;= 4) {
 2666       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
 2667     }
 2668     emit_opcode(cbuf, 0x0F);
 2669     emit_opcode(cbuf, 0xB6);
 2670     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
 2671   %}
 2672 
 2673   enc_class Push_ResultXD(regD dst) %{
 2674     MacroAssembler _masm(&amp;cbuf);
 2675     __ fstp_d(Address(rsp, 0));
 2676     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2677     __ addptr(rsp, 8);
 2678   %}
 2679 
 2680   enc_class Push_SrcXD(regD src) %{
 2681     MacroAssembler _masm(&amp;cbuf);
 2682     __ subptr(rsp, 8);
 2683     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2684     __ fld_d(Address(rsp, 0));
 2685   %}
 2686 
 2687 
 2688   enc_class enc_rethrow()
 2689   %{
 2690     cbuf.set_insts_mark();
 2691     emit_opcode(cbuf, 0xE9); // jmp entry
 2692     emit_d32_reloc(cbuf,
 2693                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
 2694                    runtime_call_Relocation::spec(),
 2695                    RELOC_DISP32);
 2696   %}
 2697 
 2698 %}
 2699 
 2700 
 2701 
 2702 //----------FRAME--------------------------------------------------------------
 2703 // Definition of frame structure and management information.
 2704 //
 2705 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2706 //                             |   (to get allocators register number
 2707 //  G  Owned by    |        |  v    add OptoReg::stack0())
 2708 //  r   CALLER     |        |
 2709 //  o     |        +--------+      pad to even-align allocators stack-slot
 2710 //  w     V        |  pad0  |        numbers; owned by CALLER
 2711 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2712 //  h     ^        |   in   |  5
 2713 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2714 //  |     |        |        |  3
 2715 //  |     |        +--------+
 2716 //  V     |        | old out|      Empty on Intel, window on Sparc
 2717 //        |    old |preserve|      Must be even aligned.
 2718 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 2719 //        |        |   in   |  3   area for Intel ret address
 2720 //     Owned by    |preserve|      Empty on Sparc.
 2721 //       SELF      +--------+
 2722 //        |        |  pad2  |  2   pad to align old SP
 2723 //        |        +--------+  1
 2724 //        |        | locks  |  0
 2725 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 2726 //        |        |  pad1  | 11   pad to align new SP
 2727 //        |        +--------+
 2728 //        |        |        | 10
 2729 //        |        | spills |  9   spills
 2730 //        V        |        |  8   (pad0 slot for callee)
 2731 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2732 //        ^        |  out   |  7
 2733 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2734 //     Owned by    +--------+
 2735 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2736 //        |    new |preserve|      Must be even-aligned.
 2737 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2738 //        |        |        |
 2739 //
 2740 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2741 //         known from SELF&#39;s arguments and the Java calling convention.
 2742 //         Region 6-7 is determined per call site.
 2743 // Note 2: If the calling convention leaves holes in the incoming argument
 2744 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2745 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2746 //         incoming area, as the Java calling convention is completely under
 2747 //         the control of the AD file.  Doubles can be sorted and packed to
 2748 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 2749 //         varargs C calling conventions.
 2750 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2751 //         even aligned with pad0 as needed.
 2752 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2753 //         region 6-11 is even aligned; it may be padded out more so that
 2754 //         the region from SP to FP meets the minimum stack alignment.
 2755 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
 2756 //         alignment.  Region 11, pad1, may be dynamically extended so that
 2757 //         SP meets the minimum alignment.
 2758 
 2759 frame
 2760 %{
 2761   // What direction does stack grow in (assumed to be same for C &amp; Java)
 2762   stack_direction(TOWARDS_LOW);
 2763 
 2764   // These three registers define part of the calling convention
 2765   // between compiled code and the interpreter.
 2766   inline_cache_reg(RAX);                // Inline Cache Register
 2767   interpreter_method_oop_reg(RBX);      // Method Oop Register when
 2768                                         // calling interpreter
 2769 
 2770   // Optional: name the operand used by cisc-spilling to access
 2771   // [stack_pointer + offset]
 2772   cisc_spilling_operand_name(indOffset32);
 2773 
 2774   // Number of stack slots consumed by locking an object
 2775   sync_stack_slots(2);
 2776 
 2777   // Compiled code&#39;s Frame Pointer
 2778   frame_pointer(RSP);
 2779 
 2780   // Interpreter stores its frame pointer in a register which is
 2781   // stored to the stack by I2CAdaptors.
 2782   // I2CAdaptors convert from interpreted java to compiled java.
 2783   interpreter_frame_pointer(RBP);
 2784 
 2785   // Stack alignment requirement
 2786   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
 2787 
 2788   // Number of stack slots between incoming argument block and the start of
 2789   // a new frame.  The PROLOG must add this many slots to the stack.  The
 2790   // EPILOG must remove this many slots.  amd64 needs two slots for
 2791   // return address.
 2792   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
 2793 
 2794   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 2795   // for calls to C.  Supports the var-args backing area for register parms.
 2796   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
 2797 
 2798   // The after-PROLOG location of the return address.  Location of
 2799   // return address specifies a type (REG or STACK) and a number
 2800   // representing the register number (i.e. - use a register name) or
 2801   // stack slot.
 2802   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 2803   // Otherwise, it is above the locks and verification slot and alignment word
 2804   return_addr(STACK - 2 +
 2805               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 2806                         Compile::current()-&gt;fixed_slots()),
 2807                        stack_alignment_in_slots()));
 2808 
 2809   // Body of function which returns an integer array locating
 2810   // arguments either in registers or in stack slots.  Passed an array
 2811   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 2812   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2813   // arguments for a CALLEE.  Incoming stack arguments are
 2814   // automatically biased by the preserve_stack_slots field above.
 2815 
 2816   calling_convention
 2817   %{
 2818     // No difference between ingoing/outgoing just pass false
 2819     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2820   %}
 2821 
 2822   c_calling_convention
 2823   %{
 2824     // This is obviously always outgoing
 2825     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2826   %}
 2827 
 2828   // Location of compiled Java return values.  Same as C for now.
 2829   return_value
 2830   %{
 2831     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 2832            &quot;only return normal values&quot;);
 2833 
 2834     static const int lo[Op_RegL + 1] = {
 2835       0,
 2836       0,
 2837       RAX_num,  // Op_RegN
 2838       RAX_num,  // Op_RegI
 2839       RAX_num,  // Op_RegP
 2840       XMM0_num, // Op_RegF
 2841       XMM0_num, // Op_RegD
 2842       RAX_num   // Op_RegL
 2843     };
 2844     static const int hi[Op_RegL + 1] = {
 2845       0,
 2846       0,
 2847       OptoReg::Bad, // Op_RegN
 2848       OptoReg::Bad, // Op_RegI
 2849       RAX_H_num,    // Op_RegP
 2850       OptoReg::Bad, // Op_RegF
 2851       XMM0b_num,    // Op_RegD
 2852       RAX_H_num     // Op_RegL
 2853     };
 2854     // Excluded flags and vector registers.
 2855     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, &quot;missing type&quot;);
 2856     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 2857   %}
 2858 %}
 2859 
 2860 //----------ATTRIBUTES---------------------------------------------------------
 2861 //----------Operand Attributes-------------------------------------------------
 2862 op_attrib op_cost(0);        // Required cost attribute
 2863 
 2864 //----------Instruction Attributes---------------------------------------------
 2865 ins_attrib ins_cost(100);       // Required cost attribute
 2866 ins_attrib ins_size(8);         // Required size attribute (in bits)
 2867 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 2868                                 // a non-matching short branch variant
 2869                                 // of some long branch?
 2870 ins_attrib ins_alignment(1);    // Required alignment attribute (must
 2871                                 // be a power of 2) specifies the
 2872                                 // alignment that some part of the
 2873                                 // instruction (not necessarily the
 2874                                 // start) requires.  If &gt; 1, a
 2875                                 // compute_padding() function must be
 2876                                 // provided for the instruction
 2877 
 2878 //----------OPERANDS-----------------------------------------------------------
 2879 // Operand definitions must precede instruction definitions for correct parsing
 2880 // in the ADLC because operands constitute user defined types which are used in
 2881 // instruction definitions.
 2882 
 2883 //----------Simple Operands----------------------------------------------------
 2884 // Immediate Operands
 2885 // Integer Immediate
 2886 operand immI()
 2887 %{
 2888   match(ConI);
 2889 
 2890   op_cost(10);
 2891   format %{ %}
 2892   interface(CONST_INTER);
 2893 %}
 2894 
 2895 // Constant for test vs zero
 2896 operand immI0()
 2897 %{
 2898   predicate(n-&gt;get_int() == 0);
 2899   match(ConI);
 2900 
 2901   op_cost(0);
 2902   format %{ %}
 2903   interface(CONST_INTER);
 2904 %}
 2905 
 2906 // Constant for increment
 2907 operand immI1()
 2908 %{
 2909   predicate(n-&gt;get_int() == 1);
 2910   match(ConI);
 2911 
 2912   op_cost(0);
 2913   format %{ %}
 2914   interface(CONST_INTER);
 2915 %}
 2916 
 2917 // Constant for decrement
 2918 operand immI_M1()
 2919 %{
 2920   predicate(n-&gt;get_int() == -1);
 2921   match(ConI);
 2922 
 2923   op_cost(0);
 2924   format %{ %}
 2925   interface(CONST_INTER);
 2926 %}
 2927 
 2928 // Valid scale values for addressing modes
 2929 operand immI2()
 2930 %{
 2931   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 2932   match(ConI);
 2933 
 2934   format %{ %}
 2935   interface(CONST_INTER);
 2936 %}
 2937 
 2938 operand immI8()
 2939 %{
 2940   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
 2941   match(ConI);
 2942 
 2943   op_cost(5);
 2944   format %{ %}
 2945   interface(CONST_INTER);
 2946 %}
 2947 
 2948 operand immU8()
 2949 %{
 2950   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 2951   match(ConI);
 2952 
 2953   op_cost(5);
 2954   format %{ %}
 2955   interface(CONST_INTER);
 2956 %}
 2957 
 2958 operand immI16()
 2959 %{
 2960   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 2961   match(ConI);
 2962 
 2963   op_cost(10);
 2964   format %{ %}
 2965   interface(CONST_INTER);
 2966 %}
 2967 
 2968 // Int Immediate non-negative
 2969 operand immU31()
 2970 %{
 2971   predicate(n-&gt;get_int() &gt;= 0);
 2972   match(ConI);
 2973 
 2974   op_cost(0);
 2975   format %{ %}
 2976   interface(CONST_INTER);
 2977 %}
 2978 
 2979 // Constant for long shifts
 2980 operand immI_32()
 2981 %{
 2982   predicate( n-&gt;get_int() == 32 );
 2983   match(ConI);
 2984 
 2985   op_cost(0);
 2986   format %{ %}
 2987   interface(CONST_INTER);
 2988 %}
 2989 
 2990 // Constant for long shifts
 2991 operand immI_64()
 2992 %{
 2993   predicate( n-&gt;get_int() == 64 );
 2994   match(ConI);
 2995 
 2996   op_cost(0);
 2997   format %{ %}
 2998   interface(CONST_INTER);
 2999 %}
 3000 
 3001 // Pointer Immediate
 3002 operand immP()
 3003 %{
 3004   match(ConP);
 3005 
 3006   op_cost(10);
 3007   format %{ %}
 3008   interface(CONST_INTER);
 3009 %}
 3010 
 3011 // NULL Pointer Immediate
 3012 operand immP0()
 3013 %{
 3014   predicate(n-&gt;get_ptr() == 0);
 3015   match(ConP);
 3016 
 3017   op_cost(5);
 3018   format %{ %}
 3019   interface(CONST_INTER);
 3020 %}
 3021 
 3022 // Pointer Immediate
 3023 operand immN() %{
 3024   match(ConN);
 3025 
 3026   op_cost(10);
 3027   format %{ %}
 3028   interface(CONST_INTER);
 3029 %}
 3030 
 3031 operand immNKlass() %{
 3032   match(ConNKlass);
 3033 
 3034   op_cost(10);
 3035   format %{ %}
 3036   interface(CONST_INTER);
 3037 %}
 3038 
 3039 // NULL Pointer Immediate
 3040 operand immN0() %{
 3041   predicate(n-&gt;get_narrowcon() == 0);
 3042   match(ConN);
 3043 
 3044   op_cost(5);
 3045   format %{ %}
 3046   interface(CONST_INTER);
 3047 %}
 3048 
 3049 operand immP31()
 3050 %{
 3051   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
 3052             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
 3053   match(ConP);
 3054 
 3055   op_cost(5);
 3056   format %{ %}
 3057   interface(CONST_INTER);
 3058 %}
 3059 
 3060 
 3061 // Long Immediate
 3062 operand immL()
 3063 %{
 3064   match(ConL);
 3065 
 3066   op_cost(20);
 3067   format %{ %}
 3068   interface(CONST_INTER);
 3069 %}
 3070 
 3071 // Long Immediate 8-bit
 3072 operand immL8()
 3073 %{
 3074   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
 3075   match(ConL);
 3076 
 3077   op_cost(5);
 3078   format %{ %}
 3079   interface(CONST_INTER);
 3080 %}
 3081 
 3082 // Long Immediate 32-bit unsigned
 3083 operand immUL32()
 3084 %{
 3085   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3086   match(ConL);
 3087 
 3088   op_cost(10);
 3089   format %{ %}
 3090   interface(CONST_INTER);
 3091 %}
 3092 
 3093 // Long Immediate 32-bit signed
 3094 operand immL32()
 3095 %{
 3096   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3097   match(ConL);
 3098 
 3099   op_cost(15);
 3100   format %{ %}
 3101   interface(CONST_INTER);
 3102 %}
 3103 
<a name="12" id="anc12"></a>



















 3104 // Long Immediate zero
 3105 operand immL0()
 3106 %{
 3107   predicate(n-&gt;get_long() == 0L);
 3108   match(ConL);
 3109 
 3110   op_cost(10);
 3111   format %{ %}
 3112   interface(CONST_INTER);
 3113 %}
 3114 
 3115 // Constant for increment
 3116 operand immL1()
 3117 %{
 3118   predicate(n-&gt;get_long() == 1);
 3119   match(ConL);
 3120 
 3121   format %{ %}
 3122   interface(CONST_INTER);
 3123 %}
 3124 
 3125 // Constant for decrement
 3126 operand immL_M1()
 3127 %{
 3128   predicate(n-&gt;get_long() == -1);
 3129   match(ConL);
 3130 
 3131   format %{ %}
 3132   interface(CONST_INTER);
 3133 %}
 3134 
 3135 // Long Immediate: the value 10
 3136 operand immL10()
 3137 %{
 3138   predicate(n-&gt;get_long() == 10);
 3139   match(ConL);
 3140 
 3141   format %{ %}
 3142   interface(CONST_INTER);
 3143 %}
 3144 
 3145 // Long immediate from 0 to 127.
 3146 // Used for a shorter form of long mul by 10.
 3147 operand immL_127()
 3148 %{
 3149   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
 3150   match(ConL);
 3151 
 3152   op_cost(10);
 3153   format %{ %}
 3154   interface(CONST_INTER);
 3155 %}
 3156 
 3157 // Long Immediate: low 32-bit mask
 3158 operand immL_32bits()
 3159 %{
 3160   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3161   match(ConL);
 3162   op_cost(20);
 3163 
 3164   format %{ %}
 3165   interface(CONST_INTER);
 3166 %}
 3167 
 3168 // Float Immediate zero
 3169 operand immF0()
 3170 %{
 3171   predicate(jint_cast(n-&gt;getf()) == 0);
 3172   match(ConF);
 3173 
 3174   op_cost(5);
 3175   format %{ %}
 3176   interface(CONST_INTER);
 3177 %}
 3178 
 3179 // Float Immediate
 3180 operand immF()
 3181 %{
 3182   match(ConF);
 3183 
 3184   op_cost(15);
 3185   format %{ %}
 3186   interface(CONST_INTER);
 3187 %}
 3188 
 3189 // Double Immediate zero
 3190 operand immD0()
 3191 %{
 3192   predicate(jlong_cast(n-&gt;getd()) == 0);
 3193   match(ConD);
 3194 
 3195   op_cost(5);
 3196   format %{ %}
 3197   interface(CONST_INTER);
 3198 %}
 3199 
 3200 // Double Immediate
 3201 operand immD()
 3202 %{
 3203   match(ConD);
 3204 
 3205   op_cost(15);
 3206   format %{ %}
 3207   interface(CONST_INTER);
 3208 %}
 3209 
 3210 // Immediates for special shifts (sign extend)
 3211 
 3212 // Constants for increment
 3213 operand immI_16()
 3214 %{
 3215   predicate(n-&gt;get_int() == 16);
 3216   match(ConI);
 3217 
 3218   format %{ %}
 3219   interface(CONST_INTER);
 3220 %}
 3221 
 3222 operand immI_24()
 3223 %{
 3224   predicate(n-&gt;get_int() == 24);
 3225   match(ConI);
 3226 
 3227   format %{ %}
 3228   interface(CONST_INTER);
 3229 %}
 3230 
 3231 // Constant for byte-wide masking
 3232 operand immI_255()
 3233 %{
 3234   predicate(n-&gt;get_int() == 255);
 3235   match(ConI);
 3236 
 3237   format %{ %}
 3238   interface(CONST_INTER);
 3239 %}
 3240 
 3241 // Constant for short-wide masking
 3242 operand immI_65535()
 3243 %{
 3244   predicate(n-&gt;get_int() == 65535);
 3245   match(ConI);
 3246 
 3247   format %{ %}
 3248   interface(CONST_INTER);
 3249 %}
 3250 
 3251 // Constant for byte-wide masking
 3252 operand immL_255()
 3253 %{
 3254   predicate(n-&gt;get_long() == 255);
 3255   match(ConL);
 3256 
 3257   format %{ %}
 3258   interface(CONST_INTER);
 3259 %}
 3260 
 3261 // Constant for short-wide masking
 3262 operand immL_65535()
 3263 %{
 3264   predicate(n-&gt;get_long() == 65535);
 3265   match(ConL);
 3266 
 3267   format %{ %}
 3268   interface(CONST_INTER);
 3269 %}
 3270 
 3271 // Register Operands
 3272 // Integer Register
 3273 operand rRegI()
 3274 %{
 3275   constraint(ALLOC_IN_RC(int_reg));
 3276   match(RegI);
 3277 
 3278   match(rax_RegI);
 3279   match(rbx_RegI);
 3280   match(rcx_RegI);
 3281   match(rdx_RegI);
 3282   match(rdi_RegI);
 3283 
 3284   format %{ %}
 3285   interface(REG_INTER);
 3286 %}
 3287 
 3288 // Special Registers
 3289 operand rax_RegI()
 3290 %{
 3291   constraint(ALLOC_IN_RC(int_rax_reg));
 3292   match(RegI);
 3293   match(rRegI);
 3294 
 3295   format %{ &quot;RAX&quot; %}
 3296   interface(REG_INTER);
 3297 %}
 3298 
 3299 // Special Registers
 3300 operand rbx_RegI()
 3301 %{
 3302   constraint(ALLOC_IN_RC(int_rbx_reg));
 3303   match(RegI);
 3304   match(rRegI);
 3305 
 3306   format %{ &quot;RBX&quot; %}
 3307   interface(REG_INTER);
 3308 %}
 3309 
 3310 operand rcx_RegI()
 3311 %{
 3312   constraint(ALLOC_IN_RC(int_rcx_reg));
 3313   match(RegI);
 3314   match(rRegI);
 3315 
 3316   format %{ &quot;RCX&quot; %}
 3317   interface(REG_INTER);
 3318 %}
 3319 
 3320 operand rdx_RegI()
 3321 %{
 3322   constraint(ALLOC_IN_RC(int_rdx_reg));
 3323   match(RegI);
 3324   match(rRegI);
 3325 
 3326   format %{ &quot;RDX&quot; %}
 3327   interface(REG_INTER);
 3328 %}
 3329 
 3330 operand rdi_RegI()
 3331 %{
 3332   constraint(ALLOC_IN_RC(int_rdi_reg));
 3333   match(RegI);
 3334   match(rRegI);
 3335 
 3336   format %{ &quot;RDI&quot; %}
 3337   interface(REG_INTER);
 3338 %}
 3339 
 3340 operand no_rcx_RegI()
 3341 %{
 3342   constraint(ALLOC_IN_RC(int_no_rcx_reg));
 3343   match(RegI);
 3344   match(rax_RegI);
 3345   match(rbx_RegI);
 3346   match(rdx_RegI);
 3347   match(rdi_RegI);
 3348 
 3349   format %{ %}
 3350   interface(REG_INTER);
 3351 %}
 3352 
 3353 operand no_rax_rdx_RegI()
 3354 %{
 3355   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
 3356   match(RegI);
 3357   match(rbx_RegI);
 3358   match(rcx_RegI);
 3359   match(rdi_RegI);
 3360 
 3361   format %{ %}
 3362   interface(REG_INTER);
 3363 %}
 3364 
 3365 // Pointer Register
 3366 operand any_RegP()
 3367 %{
 3368   constraint(ALLOC_IN_RC(any_reg));
 3369   match(RegP);
 3370   match(rax_RegP);
 3371   match(rbx_RegP);
 3372   match(rdi_RegP);
 3373   match(rsi_RegP);
 3374   match(rbp_RegP);
 3375   match(r15_RegP);
 3376   match(rRegP);
 3377 
 3378   format %{ %}
 3379   interface(REG_INTER);
 3380 %}
 3381 
 3382 operand rRegP()
 3383 %{
 3384   constraint(ALLOC_IN_RC(ptr_reg));
 3385   match(RegP);
 3386   match(rax_RegP);
 3387   match(rbx_RegP);
 3388   match(rdi_RegP);
 3389   match(rsi_RegP);
 3390   match(rbp_RegP);  // See Q&amp;A below about
 3391   match(r15_RegP);  // r15_RegP and rbp_RegP.
 3392 
 3393   format %{ %}
 3394   interface(REG_INTER);
 3395 %}
 3396 
 3397 operand rRegN() %{
 3398   constraint(ALLOC_IN_RC(int_reg));
 3399   match(RegN);
 3400 
 3401   format %{ %}
 3402   interface(REG_INTER);
 3403 %}
 3404 
 3405 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
 3406 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
 3407 // It&#39;s fine for an instruction input that expects rRegP to match a r15_RegP.
 3408 // The output of an instruction is controlled by the allocator, which respects
 3409 // register class masks, not match rules.  Unless an instruction mentions
 3410 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
 3411 // by the allocator as an input.
 3412 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
 3413 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
 3414 // result, RBP is not included in the output of the instruction either.
 3415 
 3416 operand no_rax_RegP()
 3417 %{
 3418   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
 3419   match(RegP);
 3420   match(rbx_RegP);
 3421   match(rsi_RegP);
 3422   match(rdi_RegP);
 3423 
 3424   format %{ %}
 3425   interface(REG_INTER);
 3426 %}
 3427 
 3428 // This operand is not allowed to use RBP even if
 3429 // RBP is not used to hold the frame pointer.
 3430 operand no_rbp_RegP()
 3431 %{
 3432   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
 3433   match(RegP);
 3434   match(rbx_RegP);
 3435   match(rsi_RegP);
 3436   match(rdi_RegP);
 3437 
 3438   format %{ %}
 3439   interface(REG_INTER);
 3440 %}
 3441 
 3442 operand no_rax_rbx_RegP()
 3443 %{
 3444   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
 3445   match(RegP);
 3446   match(rsi_RegP);
 3447   match(rdi_RegP);
 3448 
 3449   format %{ %}
 3450   interface(REG_INTER);
 3451 %}
 3452 
 3453 // Special Registers
 3454 // Return a pointer value
 3455 operand rax_RegP()
 3456 %{
 3457   constraint(ALLOC_IN_RC(ptr_rax_reg));
 3458   match(RegP);
 3459   match(rRegP);
 3460 
 3461   format %{ %}
 3462   interface(REG_INTER);
 3463 %}
 3464 
 3465 // Special Registers
 3466 // Return a compressed pointer value
 3467 operand rax_RegN()
 3468 %{
 3469   constraint(ALLOC_IN_RC(int_rax_reg));
 3470   match(RegN);
 3471   match(rRegN);
 3472 
 3473   format %{ %}
 3474   interface(REG_INTER);
 3475 %}
 3476 
 3477 // Used in AtomicAdd
 3478 operand rbx_RegP()
 3479 %{
 3480   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3481   match(RegP);
 3482   match(rRegP);
 3483 
 3484   format %{ %}
 3485   interface(REG_INTER);
 3486 %}
 3487 
 3488 operand rsi_RegP()
 3489 %{
 3490   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3491   match(RegP);
 3492   match(rRegP);
 3493 
 3494   format %{ %}
 3495   interface(REG_INTER);
 3496 %}
 3497 
<a name="13" id="anc13"></a>









 3498 // Used in rep stosq
 3499 operand rdi_RegP()
 3500 %{
 3501   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3502   match(RegP);
 3503   match(rRegP);
 3504 
 3505   format %{ %}
 3506   interface(REG_INTER);
 3507 %}
 3508 
 3509 operand r15_RegP()
 3510 %{
 3511   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3512   match(RegP);
 3513   match(rRegP);
 3514 
 3515   format %{ %}
 3516   interface(REG_INTER);
 3517 %}
 3518 
 3519 operand rRegL()
 3520 %{
 3521   constraint(ALLOC_IN_RC(long_reg));
 3522   match(RegL);
 3523   match(rax_RegL);
 3524   match(rdx_RegL);
 3525 
 3526   format %{ %}
 3527   interface(REG_INTER);
 3528 %}
 3529 
 3530 // Special Registers
 3531 operand no_rax_rdx_RegL()
 3532 %{
 3533   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3534   match(RegL);
 3535   match(rRegL);
 3536 
 3537   format %{ %}
 3538   interface(REG_INTER);
 3539 %}
 3540 
 3541 operand no_rax_RegL()
 3542 %{
 3543   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3544   match(RegL);
 3545   match(rRegL);
 3546   match(rdx_RegL);
 3547 
 3548   format %{ %}
 3549   interface(REG_INTER);
 3550 %}
 3551 
 3552 operand no_rcx_RegL()
 3553 %{
 3554   constraint(ALLOC_IN_RC(long_no_rcx_reg));
 3555   match(RegL);
 3556   match(rRegL);
 3557 
 3558   format %{ %}
 3559   interface(REG_INTER);
 3560 %}
 3561 
 3562 operand rax_RegL()
 3563 %{
 3564   constraint(ALLOC_IN_RC(long_rax_reg));
 3565   match(RegL);
 3566   match(rRegL);
 3567 
 3568   format %{ &quot;RAX&quot; %}
 3569   interface(REG_INTER);
 3570 %}
 3571 
 3572 operand rcx_RegL()
 3573 %{
 3574   constraint(ALLOC_IN_RC(long_rcx_reg));
 3575   match(RegL);
 3576   match(rRegL);
 3577 
 3578   format %{ %}
 3579   interface(REG_INTER);
 3580 %}
 3581 
 3582 operand rdx_RegL()
 3583 %{
 3584   constraint(ALLOC_IN_RC(long_rdx_reg));
 3585   match(RegL);
 3586   match(rRegL);
 3587 
 3588   format %{ %}
 3589   interface(REG_INTER);
 3590 %}
 3591 
 3592 // Flags register, used as output of compare instructions
 3593 operand rFlagsReg()
 3594 %{
 3595   constraint(ALLOC_IN_RC(int_flags));
 3596   match(RegFlags);
 3597 
 3598   format %{ &quot;RFLAGS&quot; %}
 3599   interface(REG_INTER);
 3600 %}
 3601 
 3602 // Flags register, used as output of FLOATING POINT compare instructions
 3603 operand rFlagsRegU()
 3604 %{
 3605   constraint(ALLOC_IN_RC(int_flags));
 3606   match(RegFlags);
 3607 
 3608   format %{ &quot;RFLAGS_U&quot; %}
 3609   interface(REG_INTER);
 3610 %}
 3611 
 3612 operand rFlagsRegUCF() %{
 3613   constraint(ALLOC_IN_RC(int_flags));
 3614   match(RegFlags);
 3615   predicate(false);
 3616 
 3617   format %{ &quot;RFLAGS_U_CF&quot; %}
 3618   interface(REG_INTER);
 3619 %}
 3620 
 3621 // Float register operands
 3622 operand regF() %{
 3623    constraint(ALLOC_IN_RC(float_reg));
 3624    match(RegF);
 3625 
 3626    format %{ %}
 3627    interface(REG_INTER);
 3628 %}
 3629 
 3630 // Float register operands
 3631 operand legRegF() %{
 3632    constraint(ALLOC_IN_RC(float_reg_legacy));
 3633    match(RegF);
 3634 
 3635    format %{ %}
 3636    interface(REG_INTER);
 3637 %}
 3638 
 3639 // Float register operands
 3640 operand vlRegF() %{
 3641    constraint(ALLOC_IN_RC(float_reg_vl));
 3642    match(RegF);
 3643 
 3644    format %{ %}
 3645    interface(REG_INTER);
 3646 %}
 3647 
 3648 // Double register operands
 3649 operand regD() %{
 3650    constraint(ALLOC_IN_RC(double_reg));
 3651    match(RegD);
 3652 
 3653    format %{ %}
 3654    interface(REG_INTER);
 3655 %}
 3656 
 3657 // Double register operands
 3658 operand legRegD() %{
 3659    constraint(ALLOC_IN_RC(double_reg_legacy));
 3660    match(RegD);
 3661 
 3662    format %{ %}
 3663    interface(REG_INTER);
 3664 %}
 3665 
 3666 // Double register operands
 3667 operand vlRegD() %{
 3668    constraint(ALLOC_IN_RC(double_reg_vl));
 3669    match(RegD);
 3670 
 3671    format %{ %}
 3672    interface(REG_INTER);
 3673 %}
 3674 
<a name="14" id="anc14"></a><span class="line-removed"> 3675 // Vectors</span>
<span class="line-removed"> 3676 operand vecS() %{</span>
<span class="line-removed"> 3677   constraint(ALLOC_IN_RC(vectors_reg_vlbwdq));</span>
<span class="line-removed"> 3678   match(VecS);</span>
<span class="line-removed"> 3679 </span>
<span class="line-removed"> 3680   format %{ %}</span>
<span class="line-removed"> 3681   interface(REG_INTER);</span>
<span class="line-removed"> 3682 %}</span>
<span class="line-removed"> 3683 </span>
<span class="line-removed"> 3684 // Vectors</span>
<span class="line-removed"> 3685 operand legVecS() %{</span>
<span class="line-removed"> 3686   constraint(ALLOC_IN_RC(vectors_reg_legacy));</span>
<span class="line-removed"> 3687   match(VecS);</span>
<span class="line-removed"> 3688 </span>
<span class="line-removed"> 3689   format %{ %}</span>
<span class="line-removed"> 3690   interface(REG_INTER);</span>
<span class="line-removed"> 3691 %}</span>
<span class="line-removed"> 3692 </span>
<span class="line-removed"> 3693 operand vecD() %{</span>
<span class="line-removed"> 3694   constraint(ALLOC_IN_RC(vectord_reg_vlbwdq));</span>
<span class="line-removed"> 3695   match(VecD);</span>
<span class="line-removed"> 3696 </span>
<span class="line-removed"> 3697   format %{ %}</span>
<span class="line-removed"> 3698   interface(REG_INTER);</span>
<span class="line-removed"> 3699 %}</span>
<span class="line-removed"> 3700 </span>
<span class="line-removed"> 3701 operand legVecD() %{</span>
<span class="line-removed"> 3702   constraint(ALLOC_IN_RC(vectord_reg_legacy));</span>
<span class="line-removed"> 3703   match(VecD);</span>
<span class="line-removed"> 3704 </span>
<span class="line-removed"> 3705   format %{ %}</span>
<span class="line-removed"> 3706   interface(REG_INTER);</span>
<span class="line-removed"> 3707 %}</span>
<span class="line-removed"> 3708 </span>
<span class="line-removed"> 3709 operand vecX() %{</span>
<span class="line-removed"> 3710   constraint(ALLOC_IN_RC(vectorx_reg_vlbwdq));</span>
<span class="line-removed"> 3711   match(VecX);</span>
<span class="line-removed"> 3712 </span>
<span class="line-removed"> 3713   format %{ %}</span>
<span class="line-removed"> 3714   interface(REG_INTER);</span>
<span class="line-removed"> 3715 %}</span>
<span class="line-removed"> 3716 </span>
<span class="line-removed"> 3717 operand legVecX() %{</span>
<span class="line-removed"> 3718   constraint(ALLOC_IN_RC(vectorx_reg_legacy));</span>
<span class="line-removed"> 3719   match(VecX);</span>
<span class="line-removed"> 3720 </span>
<span class="line-removed"> 3721   format %{ %}</span>
<span class="line-removed"> 3722   interface(REG_INTER);</span>
<span class="line-removed"> 3723 %}</span>
<span class="line-removed"> 3724 </span>
<span class="line-removed"> 3725 operand vecY() %{</span>
<span class="line-removed"> 3726   constraint(ALLOC_IN_RC(vectory_reg_vlbwdq));</span>
<span class="line-removed"> 3727   match(VecY);</span>
<span class="line-removed"> 3728 </span>
<span class="line-removed"> 3729   format %{ %}</span>
<span class="line-removed"> 3730   interface(REG_INTER);</span>
<span class="line-removed"> 3731 %}</span>
<span class="line-removed"> 3732 </span>
<span class="line-removed"> 3733 operand legVecY() %{</span>
<span class="line-removed"> 3734   constraint(ALLOC_IN_RC(vectory_reg_legacy));</span>
<span class="line-removed"> 3735   match(VecY);</span>
<span class="line-removed"> 3736 </span>
<span class="line-removed"> 3737   format %{ %}</span>
<span class="line-removed"> 3738   interface(REG_INTER);</span>
<span class="line-removed"> 3739 %}</span>
<span class="line-removed"> 3740 </span>
 3741 //----------Memory Operands----------------------------------------------------
 3742 // Direct Memory Operand
 3743 // operand direct(immP addr)
 3744 // %{
 3745 //   match(addr);
 3746 
 3747 //   format %{ &quot;[$addr]&quot; %}
 3748 //   interface(MEMORY_INTER) %{
 3749 //     base(0xFFFFFFFF);
 3750 //     index(0x4);
 3751 //     scale(0x0);
 3752 //     disp($addr);
 3753 //   %}
 3754 // %}
 3755 
 3756 // Indirect Memory Operand
 3757 operand indirect(any_RegP reg)
 3758 %{
 3759   constraint(ALLOC_IN_RC(ptr_reg));
 3760   match(reg);
 3761 
 3762   format %{ &quot;[$reg]&quot; %}
 3763   interface(MEMORY_INTER) %{
 3764     base($reg);
 3765     index(0x4);
 3766     scale(0x0);
 3767     disp(0x0);
 3768   %}
 3769 %}
 3770 
 3771 // Indirect Memory Plus Short Offset Operand
 3772 operand indOffset8(any_RegP reg, immL8 off)
 3773 %{
 3774   constraint(ALLOC_IN_RC(ptr_reg));
 3775   match(AddP reg off);
 3776 
 3777   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3778   interface(MEMORY_INTER) %{
 3779     base($reg);
 3780     index(0x4);
 3781     scale(0x0);
 3782     disp($off);
 3783   %}
 3784 %}
 3785 
 3786 // Indirect Memory Plus Long Offset Operand
 3787 operand indOffset32(any_RegP reg, immL32 off)
 3788 %{
 3789   constraint(ALLOC_IN_RC(ptr_reg));
 3790   match(AddP reg off);
 3791 
 3792   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3793   interface(MEMORY_INTER) %{
 3794     base($reg);
 3795     index(0x4);
 3796     scale(0x0);
 3797     disp($off);
 3798   %}
 3799 %}
 3800 
 3801 // Indirect Memory Plus Index Register Plus Offset Operand
 3802 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
 3803 %{
 3804   constraint(ALLOC_IN_RC(ptr_reg));
 3805   match(AddP (AddP reg lreg) off);
 3806 
 3807   op_cost(10);
 3808   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3809   interface(MEMORY_INTER) %{
 3810     base($reg);
 3811     index($lreg);
 3812     scale(0x0);
 3813     disp($off);
 3814   %}
 3815 %}
 3816 
 3817 // Indirect Memory Plus Index Register Plus Offset Operand
 3818 operand indIndex(any_RegP reg, rRegL lreg)
 3819 %{
 3820   constraint(ALLOC_IN_RC(ptr_reg));
 3821   match(AddP reg lreg);
 3822 
 3823   op_cost(10);
 3824   format %{&quot;[$reg + $lreg]&quot; %}
 3825   interface(MEMORY_INTER) %{
 3826     base($reg);
 3827     index($lreg);
 3828     scale(0x0);
 3829     disp(0x0);
 3830   %}
 3831 %}
 3832 
 3833 // Indirect Memory Times Scale Plus Index Register
 3834 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
 3835 %{
 3836   constraint(ALLOC_IN_RC(ptr_reg));
 3837   match(AddP reg (LShiftL lreg scale));
 3838 
 3839   op_cost(10);
 3840   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3841   interface(MEMORY_INTER) %{
 3842     base($reg);
 3843     index($lreg);
 3844     scale($scale);
 3845     disp(0x0);
 3846   %}
 3847 %}
 3848 
 3849 operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)
 3850 %{
 3851   constraint(ALLOC_IN_RC(ptr_reg));
 3852   predicate(n-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3853   match(AddP reg (LShiftL (ConvI2L idx) scale));
 3854 
 3855   op_cost(10);
 3856   format %{&quot;[$reg + pos $idx &lt;&lt; $scale]&quot; %}
 3857   interface(MEMORY_INTER) %{
 3858     base($reg);
 3859     index($idx);
 3860     scale($scale);
 3861     disp(0x0);
 3862   %}
 3863 %}
 3864 
 3865 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3866 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
 3867 %{
 3868   constraint(ALLOC_IN_RC(ptr_reg));
 3869   match(AddP (AddP reg (LShiftL lreg scale)) off);
 3870 
 3871   op_cost(10);
 3872   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3873   interface(MEMORY_INTER) %{
 3874     base($reg);
 3875     index($lreg);
 3876     scale($scale);
 3877     disp($off);
 3878   %}
 3879 %}
 3880 
 3881 // Indirect Memory Plus Positive Index Register Plus Offset Operand
 3882 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
 3883 %{
 3884   constraint(ALLOC_IN_RC(ptr_reg));
 3885   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3886   match(AddP (AddP reg (ConvI2L idx)) off);
 3887 
 3888   op_cost(10);
 3889   format %{&quot;[$reg + $off + $idx]&quot; %}
 3890   interface(MEMORY_INTER) %{
 3891     base($reg);
 3892     index($idx);
 3893     scale(0x0);
 3894     disp($off);
 3895   %}
 3896 %}
 3897 
 3898 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3899 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3900 %{
 3901   constraint(ALLOC_IN_RC(ptr_reg));
 3902   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3903   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3904 
 3905   op_cost(10);
 3906   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3907   interface(MEMORY_INTER) %{
 3908     base($reg);
 3909     index($idx);
 3910     scale($scale);
 3911     disp($off);
 3912   %}
 3913 %}
 3914 
 3915 // Indirect Narrow Oop Plus Offset Operand
 3916 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
<a name="15" id="anc15"></a><span class="line-modified"> 3917 // we can&#39;t free r12 even with Universe::narrow_oop_base() == NULL.</span>
 3918 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
<a name="16" id="anc16"></a><span class="line-modified"> 3919   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() == Address::times_8));</span>
 3920   constraint(ALLOC_IN_RC(ptr_reg));
 3921   match(AddP (DecodeN reg) off);
 3922 
 3923   op_cost(10);
 3924   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3925   interface(MEMORY_INTER) %{
 3926     base(0xc); // R12
 3927     index($reg);
 3928     scale(0x3);
 3929     disp($off);
 3930   %}
 3931 %}
 3932 
 3933 // Indirect Memory Operand
 3934 operand indirectNarrow(rRegN reg)
 3935 %{
<a name="17" id="anc17"></a><span class="line-modified"> 3936   predicate(Universe::narrow_oop_shift() == 0);</span>
 3937   constraint(ALLOC_IN_RC(ptr_reg));
 3938   match(DecodeN reg);
 3939 
 3940   format %{ &quot;[$reg]&quot; %}
 3941   interface(MEMORY_INTER) %{
 3942     base($reg);
 3943     index(0x4);
 3944     scale(0x0);
 3945     disp(0x0);
 3946   %}
 3947 %}
 3948 
 3949 // Indirect Memory Plus Short Offset Operand
 3950 operand indOffset8Narrow(rRegN reg, immL8 off)
 3951 %{
<a name="18" id="anc18"></a><span class="line-modified"> 3952   predicate(Universe::narrow_oop_shift() == 0);</span>
 3953   constraint(ALLOC_IN_RC(ptr_reg));
 3954   match(AddP (DecodeN reg) off);
 3955 
 3956   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3957   interface(MEMORY_INTER) %{
 3958     base($reg);
 3959     index(0x4);
 3960     scale(0x0);
 3961     disp($off);
 3962   %}
 3963 %}
 3964 
 3965 // Indirect Memory Plus Long Offset Operand
 3966 operand indOffset32Narrow(rRegN reg, immL32 off)
 3967 %{
<a name="19" id="anc19"></a><span class="line-modified"> 3968   predicate(Universe::narrow_oop_shift() == 0);</span>
 3969   constraint(ALLOC_IN_RC(ptr_reg));
 3970   match(AddP (DecodeN reg) off);
 3971 
 3972   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3973   interface(MEMORY_INTER) %{
 3974     base($reg);
 3975     index(0x4);
 3976     scale(0x0);
 3977     disp($off);
 3978   %}
 3979 %}
 3980 
 3981 // Indirect Memory Plus Index Register Plus Offset Operand
 3982 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3983 %{
<a name="20" id="anc20"></a><span class="line-modified"> 3984   predicate(Universe::narrow_oop_shift() == 0);</span>
 3985   constraint(ALLOC_IN_RC(ptr_reg));
 3986   match(AddP (AddP (DecodeN reg) lreg) off);
 3987 
 3988   op_cost(10);
 3989   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3990   interface(MEMORY_INTER) %{
 3991     base($reg);
 3992     index($lreg);
 3993     scale(0x0);
 3994     disp($off);
 3995   %}
 3996 %}
 3997 
 3998 // Indirect Memory Plus Index Register Plus Offset Operand
 3999 operand indIndexNarrow(rRegN reg, rRegL lreg)
 4000 %{
<a name="21" id="anc21"></a><span class="line-modified"> 4001   predicate(Universe::narrow_oop_shift() == 0);</span>
 4002   constraint(ALLOC_IN_RC(ptr_reg));
 4003   match(AddP (DecodeN reg) lreg);
 4004 
 4005   op_cost(10);
 4006   format %{&quot;[$reg + $lreg]&quot; %}
 4007   interface(MEMORY_INTER) %{
 4008     base($reg);
 4009     index($lreg);
 4010     scale(0x0);
 4011     disp(0x0);
 4012   %}
 4013 %}
 4014 
 4015 // Indirect Memory Times Scale Plus Index Register
 4016 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 4017 %{
<a name="22" id="anc22"></a><span class="line-modified"> 4018   predicate(Universe::narrow_oop_shift() == 0);</span>
 4019   constraint(ALLOC_IN_RC(ptr_reg));
 4020   match(AddP (DecodeN reg) (LShiftL lreg scale));
 4021 
 4022   op_cost(10);
 4023   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 4024   interface(MEMORY_INTER) %{
 4025     base($reg);
 4026     index($lreg);
 4027     scale($scale);
 4028     disp(0x0);
 4029   %}
 4030 %}
 4031 
 4032 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4033 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 4034 %{
<a name="23" id="anc23"></a><span class="line-modified"> 4035   predicate(Universe::narrow_oop_shift() == 0);</span>
 4036   constraint(ALLOC_IN_RC(ptr_reg));
 4037   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 4038 
 4039   op_cost(10);
 4040   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 4041   interface(MEMORY_INTER) %{
 4042     base($reg);
 4043     index($lreg);
 4044     scale($scale);
 4045     disp($off);
 4046   %}
 4047 %}
 4048 
 4049 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 4050 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4051 %{
 4052   constraint(ALLOC_IN_RC(ptr_reg));
<a name="24" id="anc24"></a><span class="line-modified"> 4053   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);</span>
 4054   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4055 
 4056   op_cost(10);
 4057   format %{&quot;[$reg + $off + $idx]&quot; %}
 4058   interface(MEMORY_INTER) %{
 4059     base($reg);
 4060     index($idx);
 4061     scale(0x0);
 4062     disp($off);
 4063   %}
 4064 %}
 4065 
 4066 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4067 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4068 %{
 4069   constraint(ALLOC_IN_RC(ptr_reg));
<a name="25" id="anc25"></a><span class="line-modified"> 4070   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);</span>
 4071   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4072 
 4073   op_cost(10);
 4074   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4075   interface(MEMORY_INTER) %{
 4076     base($reg);
 4077     index($idx);
 4078     scale($scale);
 4079     disp($off);
 4080   %}
 4081 %}
 4082 
 4083 //----------Special Memory Operands--------------------------------------------
 4084 // Stack Slot Operand - This operand is used for loading and storing temporary
 4085 //                      values on the stack where a match requires a value to
 4086 //                      flow through memory.
 4087 operand stackSlotP(sRegP reg)
 4088 %{
 4089   constraint(ALLOC_IN_RC(stack_slots));
 4090   // No match rule because this operand is only generated in matching
 4091 
 4092   format %{ &quot;[$reg]&quot; %}
 4093   interface(MEMORY_INTER) %{
 4094     base(0x4);   // RSP
 4095     index(0x4);  // No Index
 4096     scale(0x0);  // No Scale
 4097     disp($reg);  // Stack Offset
 4098   %}
 4099 %}
 4100 
 4101 operand stackSlotI(sRegI reg)
 4102 %{
 4103   constraint(ALLOC_IN_RC(stack_slots));
 4104   // No match rule because this operand is only generated in matching
 4105 
 4106   format %{ &quot;[$reg]&quot; %}
 4107   interface(MEMORY_INTER) %{
 4108     base(0x4);   // RSP
 4109     index(0x4);  // No Index
 4110     scale(0x0);  // No Scale
 4111     disp($reg);  // Stack Offset
 4112   %}
 4113 %}
 4114 
 4115 operand stackSlotF(sRegF reg)
 4116 %{
 4117   constraint(ALLOC_IN_RC(stack_slots));
 4118   // No match rule because this operand is only generated in matching
 4119 
 4120   format %{ &quot;[$reg]&quot; %}
 4121   interface(MEMORY_INTER) %{
 4122     base(0x4);   // RSP
 4123     index(0x4);  // No Index
 4124     scale(0x0);  // No Scale
 4125     disp($reg);  // Stack Offset
 4126   %}
 4127 %}
 4128 
 4129 operand stackSlotD(sRegD reg)
 4130 %{
 4131   constraint(ALLOC_IN_RC(stack_slots));
 4132   // No match rule because this operand is only generated in matching
 4133 
 4134   format %{ &quot;[$reg]&quot; %}
 4135   interface(MEMORY_INTER) %{
 4136     base(0x4);   // RSP
 4137     index(0x4);  // No Index
 4138     scale(0x0);  // No Scale
 4139     disp($reg);  // Stack Offset
 4140   %}
 4141 %}
 4142 operand stackSlotL(sRegL reg)
 4143 %{
 4144   constraint(ALLOC_IN_RC(stack_slots));
 4145   // No match rule because this operand is only generated in matching
 4146 
 4147   format %{ &quot;[$reg]&quot; %}
 4148   interface(MEMORY_INTER) %{
 4149     base(0x4);   // RSP
 4150     index(0x4);  // No Index
 4151     scale(0x0);  // No Scale
 4152     disp($reg);  // Stack Offset
 4153   %}
 4154 %}
 4155 
 4156 //----------Conditional Branch Operands----------------------------------------
 4157 // Comparison Op  - This is the operation of the comparison, and is limited to
 4158 //                  the following set of codes:
 4159 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4160 //
 4161 // Other attributes of the comparison, such as unsignedness, are specified
 4162 // by the comparison instruction that sets a condition code flags register.
 4163 // That result is represented by a flags operand whose subtype is appropriate
 4164 // to the unsignedness (etc.) of the comparison.
 4165 //
 4166 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4167 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4168 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4169 
 4170 // Comparision Code
 4171 operand cmpOp()
 4172 %{
 4173   match(Bool);
 4174 
 4175   format %{ &quot;&quot; %}
 4176   interface(COND_INTER) %{
 4177     equal(0x4, &quot;e&quot;);
 4178     not_equal(0x5, &quot;ne&quot;);
 4179     less(0xC, &quot;l&quot;);
 4180     greater_equal(0xD, &quot;ge&quot;);
 4181     less_equal(0xE, &quot;le&quot;);
 4182     greater(0xF, &quot;g&quot;);
 4183     overflow(0x0, &quot;o&quot;);
 4184     no_overflow(0x1, &quot;no&quot;);
 4185   %}
 4186 %}
 4187 
 4188 // Comparison Code, unsigned compare.  Used by FP also, with
 4189 // C2 (unordered) turned into GT or LT already.  The other bits
 4190 // C0 and C3 are turned into Carry &amp; Zero flags.
 4191 operand cmpOpU()
 4192 %{
 4193   match(Bool);
 4194 
 4195   format %{ &quot;&quot; %}
 4196   interface(COND_INTER) %{
 4197     equal(0x4, &quot;e&quot;);
 4198     not_equal(0x5, &quot;ne&quot;);
 4199     less(0x2, &quot;b&quot;);
 4200     greater_equal(0x3, &quot;nb&quot;);
 4201     less_equal(0x6, &quot;be&quot;);
 4202     greater(0x7, &quot;nbe&quot;);
 4203     overflow(0x0, &quot;o&quot;);
 4204     no_overflow(0x1, &quot;no&quot;);
 4205   %}
 4206 %}
 4207 
 4208 
 4209 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4210 operand cmpOpUCF() %{
 4211   match(Bool);
 4212   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4213             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4214             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4215             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4216   format %{ &quot;&quot; %}
 4217   interface(COND_INTER) %{
 4218     equal(0x4, &quot;e&quot;);
 4219     not_equal(0x5, &quot;ne&quot;);
 4220     less(0x2, &quot;b&quot;);
 4221     greater_equal(0x3, &quot;nb&quot;);
 4222     less_equal(0x6, &quot;be&quot;);
 4223     greater(0x7, &quot;nbe&quot;);
 4224     overflow(0x0, &quot;o&quot;);
 4225     no_overflow(0x1, &quot;no&quot;);
 4226   %}
 4227 %}
 4228 
 4229 
 4230 // Floating comparisons that can be fixed up with extra conditional jumps
 4231 operand cmpOpUCF2() %{
 4232   match(Bool);
 4233   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4234             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4235   format %{ &quot;&quot; %}
 4236   interface(COND_INTER) %{
 4237     equal(0x4, &quot;e&quot;);
 4238     not_equal(0x5, &quot;ne&quot;);
 4239     less(0x2, &quot;b&quot;);
 4240     greater_equal(0x3, &quot;nb&quot;);
 4241     less_equal(0x6, &quot;be&quot;);
 4242     greater(0x7, &quot;nbe&quot;);
 4243     overflow(0x0, &quot;o&quot;);
 4244     no_overflow(0x1, &quot;no&quot;);
 4245   %}
 4246 %}
 4247 
<a name="26" id="anc26"></a><span class="line-removed"> 4248 // Operands for bound floating pointer register arguments</span>
<span class="line-removed"> 4249 operand rxmm0() %{</span>
<span class="line-removed"> 4250   constraint(ALLOC_IN_RC(xmm0_reg));</span>
<span class="line-removed"> 4251   match(VecX);</span>
<span class="line-removed"> 4252   format%{%}</span>
<span class="line-removed"> 4253   interface(REG_INTER);</span>
<span class="line-removed"> 4254 %}</span>
<span class="line-removed"> 4255 operand rxmm1() %{</span>
<span class="line-removed"> 4256   constraint(ALLOC_IN_RC(xmm1_reg));</span>
<span class="line-removed"> 4257   match(VecX);</span>
<span class="line-removed"> 4258   format%{%}</span>
<span class="line-removed"> 4259   interface(REG_INTER);</span>
<span class="line-removed"> 4260 %}</span>
<span class="line-removed"> 4261 operand rxmm2() %{</span>
<span class="line-removed"> 4262   constraint(ALLOC_IN_RC(xmm2_reg));</span>
<span class="line-removed"> 4263   match(VecX);</span>
<span class="line-removed"> 4264   format%{%}</span>
<span class="line-removed"> 4265   interface(REG_INTER);</span>
<span class="line-removed"> 4266 %}</span>
<span class="line-removed"> 4267 operand rxmm3() %{</span>
<span class="line-removed"> 4268   constraint(ALLOC_IN_RC(xmm3_reg));</span>
<span class="line-removed"> 4269   match(VecX);</span>
<span class="line-removed"> 4270   format%{%}</span>
<span class="line-removed"> 4271   interface(REG_INTER);</span>
<span class="line-removed"> 4272 %}</span>
<span class="line-removed"> 4273 operand rxmm4() %{</span>
<span class="line-removed"> 4274   constraint(ALLOC_IN_RC(xmm4_reg));</span>
<span class="line-removed"> 4275   match(VecX);</span>
<span class="line-removed"> 4276   format%{%}</span>
<span class="line-removed"> 4277   interface(REG_INTER);</span>
<span class="line-removed"> 4278 %}</span>
<span class="line-removed"> 4279 operand rxmm5() %{</span>
<span class="line-removed"> 4280   constraint(ALLOC_IN_RC(xmm5_reg));</span>
<span class="line-removed"> 4281   match(VecX);</span>
<span class="line-removed"> 4282   format%{%}</span>
<span class="line-removed"> 4283   interface(REG_INTER);</span>
<span class="line-removed"> 4284 %}</span>
<span class="line-removed"> 4285 operand rxmm6() %{</span>
<span class="line-removed"> 4286   constraint(ALLOC_IN_RC(xmm6_reg));</span>
<span class="line-removed"> 4287   match(VecX);</span>
<span class="line-removed"> 4288   format%{%}</span>
<span class="line-removed"> 4289   interface(REG_INTER);</span>
<span class="line-removed"> 4290 %}</span>
<span class="line-removed"> 4291 operand rxmm7() %{</span>
<span class="line-removed"> 4292   constraint(ALLOC_IN_RC(xmm7_reg));</span>
<span class="line-removed"> 4293   match(VecX);</span>
<span class="line-removed"> 4294   format%{%}</span>
<span class="line-removed"> 4295   interface(REG_INTER);</span>
<span class="line-removed"> 4296 %}</span>
<span class="line-removed"> 4297 operand rxmm8() %{</span>
<span class="line-removed"> 4298   constraint(ALLOC_IN_RC(xmm8_reg));</span>
<span class="line-removed"> 4299   match(VecX);</span>
<span class="line-removed"> 4300   format%{%}</span>
<span class="line-removed"> 4301   interface(REG_INTER);</span>
<span class="line-removed"> 4302 %}</span>
<span class="line-removed"> 4303 operand rxmm9() %{</span>
<span class="line-removed"> 4304   constraint(ALLOC_IN_RC(xmm9_reg));</span>
<span class="line-removed"> 4305   match(VecX);</span>
<span class="line-removed"> 4306   format%{%}</span>
<span class="line-removed"> 4307   interface(REG_INTER);</span>
<span class="line-removed"> 4308 %}</span>
<span class="line-removed"> 4309 operand rxmm10() %{</span>
<span class="line-removed"> 4310   constraint(ALLOC_IN_RC(xmm10_reg));</span>
<span class="line-removed"> 4311   match(VecX);</span>
<span class="line-removed"> 4312   format%{%}</span>
<span class="line-removed"> 4313   interface(REG_INTER);</span>
<span class="line-removed"> 4314 %}</span>
<span class="line-removed"> 4315 operand rxmm11() %{</span>
<span class="line-removed"> 4316   constraint(ALLOC_IN_RC(xmm11_reg));</span>
<span class="line-removed"> 4317   match(VecX);</span>
<span class="line-removed"> 4318   format%{%}</span>
<span class="line-removed"> 4319   interface(REG_INTER);</span>
<span class="line-removed"> 4320 %}</span>
<span class="line-removed"> 4321 operand rxmm12() %{</span>
<span class="line-removed"> 4322   constraint(ALLOC_IN_RC(xmm12_reg));</span>
<span class="line-removed"> 4323   match(VecX);</span>
<span class="line-removed"> 4324   format%{%}</span>
<span class="line-removed"> 4325   interface(REG_INTER);</span>
<span class="line-removed"> 4326 %}</span>
<span class="line-removed"> 4327 operand rxmm13() %{</span>
<span class="line-removed"> 4328   constraint(ALLOC_IN_RC(xmm13_reg));</span>
<span class="line-removed"> 4329   match(VecX);</span>
<span class="line-removed"> 4330   format%{%}</span>
<span class="line-removed"> 4331   interface(REG_INTER);</span>
<span class="line-removed"> 4332 %}</span>
<span class="line-removed"> 4333 operand rxmm14() %{</span>
<span class="line-removed"> 4334   constraint(ALLOC_IN_RC(xmm14_reg));</span>
<span class="line-removed"> 4335   match(VecX);</span>
<span class="line-removed"> 4336   format%{%}</span>
<span class="line-removed"> 4337   interface(REG_INTER);</span>
<span class="line-removed"> 4338 %}</span>
<span class="line-removed"> 4339 operand rxmm15() %{</span>
<span class="line-removed"> 4340   constraint(ALLOC_IN_RC(xmm15_reg));</span>
<span class="line-removed"> 4341   match(VecX);</span>
<span class="line-removed"> 4342   format%{%}</span>
<span class="line-removed"> 4343   interface(REG_INTER);</span>
<span class="line-removed"> 4344 %}</span>
<span class="line-removed"> 4345 operand rxmm16() %{</span>
<span class="line-removed"> 4346   constraint(ALLOC_IN_RC(xmm16_reg));</span>
<span class="line-removed"> 4347   match(VecX);</span>
<span class="line-removed"> 4348   format%{%}</span>
<span class="line-removed"> 4349   interface(REG_INTER);</span>
<span class="line-removed"> 4350 %}</span>
<span class="line-removed"> 4351 operand rxmm17() %{</span>
<span class="line-removed"> 4352   constraint(ALLOC_IN_RC(xmm17_reg));</span>
<span class="line-removed"> 4353   match(VecX);</span>
<span class="line-removed"> 4354   format%{%}</span>
<span class="line-removed"> 4355   interface(REG_INTER);</span>
<span class="line-removed"> 4356 %}</span>
<span class="line-removed"> 4357 operand rxmm18() %{</span>
<span class="line-removed"> 4358   constraint(ALLOC_IN_RC(xmm18_reg));</span>
<span class="line-removed"> 4359   match(VecX);</span>
<span class="line-removed"> 4360   format%{%}</span>
<span class="line-removed"> 4361   interface(REG_INTER);</span>
<span class="line-removed"> 4362 %}</span>
<span class="line-removed"> 4363 operand rxmm19() %{</span>
<span class="line-removed"> 4364   constraint(ALLOC_IN_RC(xmm19_reg));</span>
<span class="line-removed"> 4365   match(VecX);</span>
<span class="line-removed"> 4366   format%{%}</span>
<span class="line-removed"> 4367   interface(REG_INTER);</span>
<span class="line-removed"> 4368 %}</span>
<span class="line-removed"> 4369 operand rxmm20() %{</span>
<span class="line-removed"> 4370   constraint(ALLOC_IN_RC(xmm20_reg));</span>
<span class="line-removed"> 4371   match(VecX);</span>
<span class="line-removed"> 4372   format%{%}</span>
<span class="line-removed"> 4373   interface(REG_INTER);</span>
<span class="line-removed"> 4374 %}</span>
<span class="line-removed"> 4375 operand rxmm21() %{</span>
<span class="line-removed"> 4376   constraint(ALLOC_IN_RC(xmm21_reg));</span>
<span class="line-removed"> 4377   match(VecX);</span>
<span class="line-removed"> 4378   format%{%}</span>
<span class="line-removed"> 4379   interface(REG_INTER);</span>
<span class="line-removed"> 4380 %}</span>
<span class="line-removed"> 4381 operand rxmm22() %{</span>
<span class="line-removed"> 4382   constraint(ALLOC_IN_RC(xmm22_reg));</span>
<span class="line-removed"> 4383   match(VecX);</span>
<span class="line-removed"> 4384   format%{%}</span>
<span class="line-removed"> 4385   interface(REG_INTER);</span>
<span class="line-removed"> 4386 %}</span>
<span class="line-removed"> 4387 operand rxmm23() %{</span>
<span class="line-removed"> 4388   constraint(ALLOC_IN_RC(xmm23_reg));</span>
<span class="line-removed"> 4389   match(VecX);</span>
<span class="line-removed"> 4390   format%{%}</span>
<span class="line-removed"> 4391   interface(REG_INTER);</span>
<span class="line-removed"> 4392 %}</span>
<span class="line-removed"> 4393 operand rxmm24() %{</span>
<span class="line-removed"> 4394   constraint(ALLOC_IN_RC(xmm24_reg));</span>
<span class="line-removed"> 4395   match(VecX);</span>
<span class="line-removed"> 4396   format%{%}</span>
<span class="line-removed"> 4397   interface(REG_INTER);</span>
<span class="line-removed"> 4398 %}</span>
<span class="line-removed"> 4399 operand rxmm25() %{</span>
<span class="line-removed"> 4400   constraint(ALLOC_IN_RC(xmm25_reg));</span>
<span class="line-removed"> 4401   match(VecX);</span>
<span class="line-removed"> 4402   format%{%}</span>
<span class="line-removed"> 4403   interface(REG_INTER);</span>
<span class="line-removed"> 4404 %}</span>
<span class="line-removed"> 4405 operand rxmm26() %{</span>
<span class="line-removed"> 4406   constraint(ALLOC_IN_RC(xmm26_reg));</span>
<span class="line-removed"> 4407   match(VecX);</span>
<span class="line-removed"> 4408   format%{%}</span>
<span class="line-removed"> 4409   interface(REG_INTER);</span>
<span class="line-removed"> 4410 %}</span>
<span class="line-removed"> 4411 operand rxmm27() %{</span>
<span class="line-removed"> 4412   constraint(ALLOC_IN_RC(xmm27_reg));</span>
<span class="line-removed"> 4413   match(VecX);</span>
<span class="line-removed"> 4414   format%{%}</span>
<span class="line-removed"> 4415   interface(REG_INTER);</span>
<span class="line-removed"> 4416 %}</span>
<span class="line-removed"> 4417 operand rxmm28() %{</span>
<span class="line-removed"> 4418   constraint(ALLOC_IN_RC(xmm28_reg));</span>
<span class="line-removed"> 4419   match(VecX);</span>
<span class="line-removed"> 4420   format%{%}</span>
<span class="line-removed"> 4421   interface(REG_INTER);</span>
<span class="line-removed"> 4422 %}</span>
<span class="line-removed"> 4423 operand rxmm29() %{</span>
<span class="line-removed"> 4424   constraint(ALLOC_IN_RC(xmm29_reg));</span>
<span class="line-removed"> 4425   match(VecX);</span>
<span class="line-removed"> 4426   format%{%}</span>
<span class="line-removed"> 4427   interface(REG_INTER);</span>
<span class="line-removed"> 4428 %}</span>
<span class="line-removed"> 4429 operand rxmm30() %{</span>
<span class="line-removed"> 4430   constraint(ALLOC_IN_RC(xmm30_reg));</span>
<span class="line-removed"> 4431   match(VecX);</span>
<span class="line-removed"> 4432   format%{%}</span>
<span class="line-removed"> 4433   interface(REG_INTER);</span>
<span class="line-removed"> 4434 %}</span>
<span class="line-removed"> 4435 operand rxmm31() %{</span>
<span class="line-removed"> 4436   constraint(ALLOC_IN_RC(xmm31_reg));</span>
<span class="line-removed"> 4437   match(VecX);</span>
<span class="line-removed"> 4438   format%{%}</span>
<span class="line-removed"> 4439   interface(REG_INTER);</span>
<span class="line-removed"> 4440 %}</span>
<span class="line-removed"> 4441 </span>
 4442 //----------OPERAND CLASSES----------------------------------------------------
 4443 // Operand Classes are groups of operands that are used as to simplify
 4444 // instruction definitions by not requiring the AD writer to specify separate
 4445 // instructions for every form of operand when the instruction accepts
 4446 // multiple operand types with the same basic encoding and format.  The classic
 4447 // case of this is memory operands.
 4448 
 4449 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4450                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
 4451                indCompressedOopOffset,
 4452                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4453                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4454                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4455 
 4456 //----------PIPELINE-----------------------------------------------------------
 4457 // Rules which define the behavior of the target architectures pipeline.
 4458 pipeline %{
 4459 
 4460 //----------ATTRIBUTES---------------------------------------------------------
 4461 attributes %{
 4462   variable_size_instructions;        // Fixed size instructions
 4463   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4464   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4465   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4466   instruction_fetch_units = 1;       // of 16 bytes
 4467 
 4468   // List of nop instructions
 4469   nops( MachNop );
 4470 %}
 4471 
 4472 //----------RESOURCES----------------------------------------------------------
 4473 // Resources are the functional units available to the machine
 4474 
 4475 // Generic P2/P3 pipeline
 4476 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4477 // 3 instructions decoded per cycle.
 4478 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4479 // 3 ALU op, only ALU0 handles mul instructions.
 4480 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4481            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
 4482            BR, FPU,
 4483            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
 4484 
 4485 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4486 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4487 
 4488 // Generic P2/P3 pipeline
 4489 pipe_desc(S0, S1, S2, S3, S4, S5);
 4490 
 4491 //----------PIPELINE CLASSES---------------------------------------------------
 4492 // Pipeline Classes describe the stages in which input and output are
 4493 // referenced by the hardware pipeline.
 4494 
 4495 // Naming convention: ialu or fpu
 4496 // Then: _reg
 4497 // Then: _reg if there is a 2nd register
 4498 // Then: _long if it&#39;s a pair of instructions implementing a long
 4499 // Then: _fat if it requires the big decoder
 4500 //   Or: _mem if it requires the big decoder and a memory unit.
 4501 
 4502 // Integer ALU reg operation
 4503 pipe_class ialu_reg(rRegI dst)
 4504 %{
 4505     single_instruction;
 4506     dst    : S4(write);
 4507     dst    : S3(read);
 4508     DECODE : S0;        // any decoder
 4509     ALU    : S3;        // any alu
 4510 %}
 4511 
 4512 // Long ALU reg operation
 4513 pipe_class ialu_reg_long(rRegL dst)
 4514 %{
 4515     instruction_count(2);
 4516     dst    : S4(write);
 4517     dst    : S3(read);
 4518     DECODE : S0(2);     // any 2 decoders
 4519     ALU    : S3(2);     // both alus
 4520 %}
 4521 
 4522 // Integer ALU reg operation using big decoder
 4523 pipe_class ialu_reg_fat(rRegI dst)
 4524 %{
 4525     single_instruction;
 4526     dst    : S4(write);
 4527     dst    : S3(read);
 4528     D0     : S0;        // big decoder only
 4529     ALU    : S3;        // any alu
 4530 %}
 4531 
 4532 // Long ALU reg operation using big decoder
 4533 pipe_class ialu_reg_long_fat(rRegL dst)
 4534 %{
 4535     instruction_count(2);
 4536     dst    : S4(write);
 4537     dst    : S3(read);
 4538     D0     : S0(2);     // big decoder only; twice
 4539     ALU    : S3(2);     // any 2 alus
 4540 %}
 4541 
 4542 // Integer ALU reg-reg operation
 4543 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
 4544 %{
 4545     single_instruction;
 4546     dst    : S4(write);
 4547     src    : S3(read);
 4548     DECODE : S0;        // any decoder
 4549     ALU    : S3;        // any alu
 4550 %}
 4551 
 4552 // Long ALU reg-reg operation
 4553 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
 4554 %{
 4555     instruction_count(2);
 4556     dst    : S4(write);
 4557     src    : S3(read);
 4558     DECODE : S0(2);     // any 2 decoders
 4559     ALU    : S3(2);     // both alus
 4560 %}
 4561 
 4562 // Integer ALU reg-reg operation
 4563 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
 4564 %{
 4565     single_instruction;
 4566     dst    : S4(write);
 4567     src    : S3(read);
 4568     D0     : S0;        // big decoder only
 4569     ALU    : S3;        // any alu
 4570 %}
 4571 
 4572 // Long ALU reg-reg operation
 4573 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
 4574 %{
 4575     instruction_count(2);
 4576     dst    : S4(write);
 4577     src    : S3(read);
 4578     D0     : S0(2);     // big decoder only; twice
 4579     ALU    : S3(2);     // both alus
 4580 %}
 4581 
 4582 // Integer ALU reg-mem operation
 4583 pipe_class ialu_reg_mem(rRegI dst, memory mem)
 4584 %{
 4585     single_instruction;
 4586     dst    : S5(write);
 4587     mem    : S3(read);
 4588     D0     : S0;        // big decoder only
 4589     ALU    : S4;        // any alu
 4590     MEM    : S3;        // any mem
 4591 %}
 4592 
 4593 // Integer mem operation (prefetch)
 4594 pipe_class ialu_mem(memory mem)
 4595 %{
 4596     single_instruction;
 4597     mem    : S3(read);
 4598     D0     : S0;        // big decoder only
 4599     MEM    : S3;        // any mem
 4600 %}
 4601 
 4602 // Integer Store to Memory
 4603 pipe_class ialu_mem_reg(memory mem, rRegI src)
 4604 %{
 4605     single_instruction;
 4606     mem    : S3(read);
 4607     src    : S5(read);
 4608     D0     : S0;        // big decoder only
 4609     ALU    : S4;        // any alu
 4610     MEM    : S3;
 4611 %}
 4612 
 4613 // // Long Store to Memory
 4614 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
 4615 // %{
 4616 //     instruction_count(2);
 4617 //     mem    : S3(read);
 4618 //     src    : S5(read);
 4619 //     D0     : S0(2);          // big decoder only; twice
 4620 //     ALU    : S4(2);     // any 2 alus
 4621 //     MEM    : S3(2);  // Both mems
 4622 // %}
 4623 
 4624 // Integer Store to Memory
 4625 pipe_class ialu_mem_imm(memory mem)
 4626 %{
 4627     single_instruction;
 4628     mem    : S3(read);
 4629     D0     : S0;        // big decoder only
 4630     ALU    : S4;        // any alu
 4631     MEM    : S3;
 4632 %}
 4633 
 4634 // Integer ALU0 reg-reg operation
 4635 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
 4636 %{
 4637     single_instruction;
 4638     dst    : S4(write);
 4639     src    : S3(read);
 4640     D0     : S0;        // Big decoder only
 4641     ALU0   : S3;        // only alu0
 4642 %}
 4643 
 4644 // Integer ALU0 reg-mem operation
 4645 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
 4646 %{
 4647     single_instruction;
 4648     dst    : S5(write);
 4649     mem    : S3(read);
 4650     D0     : S0;        // big decoder only
 4651     ALU0   : S4;        // ALU0 only
 4652     MEM    : S3;        // any mem
 4653 %}
 4654 
 4655 // Integer ALU reg-reg operation
 4656 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
 4657 %{
 4658     single_instruction;
 4659     cr     : S4(write);
 4660     src1   : S3(read);
 4661     src2   : S3(read);
 4662     DECODE : S0;        // any decoder
 4663     ALU    : S3;        // any alu
 4664 %}
 4665 
 4666 // Integer ALU reg-imm operation
 4667 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
 4668 %{
 4669     single_instruction;
 4670     cr     : S4(write);
 4671     src1   : S3(read);
 4672     DECODE : S0;        // any decoder
 4673     ALU    : S3;        // any alu
 4674 %}
 4675 
 4676 // Integer ALU reg-mem operation
 4677 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
 4678 %{
 4679     single_instruction;
 4680     cr     : S4(write);
 4681     src1   : S3(read);
 4682     src2   : S3(read);
 4683     D0     : S0;        // big decoder only
 4684     ALU    : S4;        // any alu
 4685     MEM    : S3;
 4686 %}
 4687 
 4688 // Conditional move reg-reg
 4689 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
 4690 %{
 4691     instruction_count(4);
 4692     y      : S4(read);
 4693     q      : S3(read);
 4694     p      : S3(read);
 4695     DECODE : S0(4);     // any decoder
 4696 %}
 4697 
 4698 // Conditional move reg-reg
 4699 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
 4700 %{
 4701     single_instruction;
 4702     dst    : S4(write);
 4703     src    : S3(read);
 4704     cr     : S3(read);
 4705     DECODE : S0;        // any decoder
 4706 %}
 4707 
 4708 // Conditional move reg-mem
 4709 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
 4710 %{
 4711     single_instruction;
 4712     dst    : S4(write);
 4713     src    : S3(read);
 4714     cr     : S3(read);
 4715     DECODE : S0;        // any decoder
 4716     MEM    : S3;
 4717 %}
 4718 
 4719 // Conditional move reg-reg long
 4720 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
 4721 %{
 4722     single_instruction;
 4723     dst    : S4(write);
 4724     src    : S3(read);
 4725     cr     : S3(read);
 4726     DECODE : S0(2);     // any 2 decoders
 4727 %}
 4728 
 4729 // XXX
 4730 // // Conditional move double reg-reg
 4731 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
 4732 // %{
 4733 //     single_instruction;
 4734 //     dst    : S4(write);
 4735 //     src    : S3(read);
 4736 //     cr     : S3(read);
 4737 //     DECODE : S0;     // any decoder
 4738 // %}
 4739 
 4740 // Float reg-reg operation
 4741 pipe_class fpu_reg(regD dst)
 4742 %{
 4743     instruction_count(2);
 4744     dst    : S3(read);
 4745     DECODE : S0(2);     // any 2 decoders
 4746     FPU    : S3;
 4747 %}
 4748 
 4749 // Float reg-reg operation
 4750 pipe_class fpu_reg_reg(regD dst, regD src)
 4751 %{
 4752     instruction_count(2);
 4753     dst    : S4(write);
 4754     src    : S3(read);
 4755     DECODE : S0(2);     // any 2 decoders
 4756     FPU    : S3;
 4757 %}
 4758 
 4759 // Float reg-reg operation
 4760 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
 4761 %{
 4762     instruction_count(3);
 4763     dst    : S4(write);
 4764     src1   : S3(read);
 4765     src2   : S3(read);
 4766     DECODE : S0(3);     // any 3 decoders
 4767     FPU    : S3(2);
 4768 %}
 4769 
 4770 // Float reg-reg operation
 4771 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
 4772 %{
 4773     instruction_count(4);
 4774     dst    : S4(write);
 4775     src1   : S3(read);
 4776     src2   : S3(read);
 4777     src3   : S3(read);
 4778     DECODE : S0(4);     // any 3 decoders
 4779     FPU    : S3(2);
 4780 %}
 4781 
 4782 // Float reg-reg operation
 4783 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
 4784 %{
 4785     instruction_count(4);
 4786     dst    : S4(write);
 4787     src1   : S3(read);
 4788     src2   : S3(read);
 4789     src3   : S3(read);
 4790     DECODE : S1(3);     // any 3 decoders
 4791     D0     : S0;        // Big decoder only
 4792     FPU    : S3(2);
 4793     MEM    : S3;
 4794 %}
 4795 
 4796 // Float reg-mem operation
 4797 pipe_class fpu_reg_mem(regD dst, memory mem)
 4798 %{
 4799     instruction_count(2);
 4800     dst    : S5(write);
 4801     mem    : S3(read);
 4802     D0     : S0;        // big decoder only
 4803     DECODE : S1;        // any decoder for FPU POP
 4804     FPU    : S4;
 4805     MEM    : S3;        // any mem
 4806 %}
 4807 
 4808 // Float reg-mem operation
 4809 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
 4810 %{
 4811     instruction_count(3);
 4812     dst    : S5(write);
 4813     src1   : S3(read);
 4814     mem    : S3(read);
 4815     D0     : S0;        // big decoder only
 4816     DECODE : S1(2);     // any decoder for FPU POP
 4817     FPU    : S4;
 4818     MEM    : S3;        // any mem
 4819 %}
 4820 
 4821 // Float mem-reg operation
 4822 pipe_class fpu_mem_reg(memory mem, regD src)
 4823 %{
 4824     instruction_count(2);
 4825     src    : S5(read);
 4826     mem    : S3(read);
 4827     DECODE : S0;        // any decoder for FPU PUSH
 4828     D0     : S1;        // big decoder only
 4829     FPU    : S4;
 4830     MEM    : S3;        // any mem
 4831 %}
 4832 
 4833 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
 4834 %{
 4835     instruction_count(3);
 4836     src1   : S3(read);
 4837     src2   : S3(read);
 4838     mem    : S3(read);
 4839     DECODE : S0(2);     // any decoder for FPU PUSH
 4840     D0     : S1;        // big decoder only
 4841     FPU    : S4;
 4842     MEM    : S3;        // any mem
 4843 %}
 4844 
 4845 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
 4846 %{
 4847     instruction_count(3);
 4848     src1   : S3(read);
 4849     src2   : S3(read);
 4850     mem    : S4(read);
 4851     DECODE : S0;        // any decoder for FPU PUSH
 4852     D0     : S0(2);     // big decoder only
 4853     FPU    : S4;
 4854     MEM    : S3(2);     // any mem
 4855 %}
 4856 
 4857 pipe_class fpu_mem_mem(memory dst, memory src1)
 4858 %{
 4859     instruction_count(2);
 4860     src1   : S3(read);
 4861     dst    : S4(read);
 4862     D0     : S0(2);     // big decoder only
 4863     MEM    : S3(2);     // any mem
 4864 %}
 4865 
 4866 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
 4867 %{
 4868     instruction_count(3);
 4869     src1   : S3(read);
 4870     src2   : S3(read);
 4871     dst    : S4(read);
 4872     D0     : S0(3);     // big decoder only
 4873     FPU    : S4;
 4874     MEM    : S3(3);     // any mem
 4875 %}
 4876 
 4877 pipe_class fpu_mem_reg_con(memory mem, regD src1)
 4878 %{
 4879     instruction_count(3);
 4880     src1   : S4(read);
 4881     mem    : S4(read);
 4882     DECODE : S0;        // any decoder for FPU PUSH
 4883     D0     : S0(2);     // big decoder only
 4884     FPU    : S4;
 4885     MEM    : S3(2);     // any mem
 4886 %}
 4887 
 4888 // Float load constant
 4889 pipe_class fpu_reg_con(regD dst)
 4890 %{
 4891     instruction_count(2);
 4892     dst    : S5(write);
 4893     D0     : S0;        // big decoder only for the load
 4894     DECODE : S1;        // any decoder for FPU POP
 4895     FPU    : S4;
 4896     MEM    : S3;        // any mem
 4897 %}
 4898 
 4899 // Float load constant
 4900 pipe_class fpu_reg_reg_con(regD dst, regD src)
 4901 %{
 4902     instruction_count(3);
 4903     dst    : S5(write);
 4904     src    : S3(read);
 4905     D0     : S0;        // big decoder only for the load
 4906     DECODE : S1(2);     // any decoder for FPU POP
 4907     FPU    : S4;
 4908     MEM    : S3;        // any mem
 4909 %}
 4910 
 4911 // UnConditional branch
 4912 pipe_class pipe_jmp(label labl)
 4913 %{
 4914     single_instruction;
 4915     BR   : S3;
 4916 %}
 4917 
 4918 // Conditional branch
 4919 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
 4920 %{
 4921     single_instruction;
 4922     cr    : S1(read);
 4923     BR    : S3;
 4924 %}
 4925 
 4926 // Allocation idiom
 4927 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
 4928 %{
 4929     instruction_count(1); force_serialization;
 4930     fixed_latency(6);
 4931     heap_ptr : S3(read);
 4932     DECODE   : S0(3);
 4933     D0       : S2;
 4934     MEM      : S3;
 4935     ALU      : S3(2);
 4936     dst      : S5(write);
 4937     BR       : S5;
 4938 %}
 4939 
 4940 // Generic big/slow expanded idiom
 4941 pipe_class pipe_slow()
 4942 %{
 4943     instruction_count(10); multiple_bundles; force_serialization;
 4944     fixed_latency(100);
 4945     D0  : S0(2);
 4946     MEM : S3(2);
 4947 %}
 4948 
 4949 // The real do-nothing guy
 4950 pipe_class empty()
 4951 %{
 4952     instruction_count(0);
 4953 %}
 4954 
 4955 // Define the class for the Nop node
 4956 define
 4957 %{
 4958    MachNop = empty;
 4959 %}
 4960 
 4961 %}
 4962 
 4963 //----------INSTRUCTIONS-------------------------------------------------------
 4964 //
 4965 // match      -- States which machine-independent subtree may be replaced
 4966 //               by this instruction.
 4967 // ins_cost   -- The estimated cost of this instruction is used by instruction
 4968 //               selection to identify a minimum cost tree of machine
 4969 //               instructions that matches a tree of machine-independent
 4970 //               instructions.
 4971 // format     -- A string providing the disassembly for this instruction.
 4972 //               The value of an instruction&#39;s operand may be inserted
 4973 //               by referring to it with a &#39;$&#39; prefix.
 4974 // opcode     -- Three instruction opcodes may be provided.  These are referred
 4975 //               to within an encode class as $primary, $secondary, and $tertiary
 4976 //               rrspectively.  The primary opcode is commonly used to
 4977 //               indicate the type of machine instruction, while secondary
 4978 //               and tertiary are often used for prefix options or addressing
 4979 //               modes.
 4980 // ins_encode -- A list of encode classes with parameters. The encode class
 4981 //               name must have been defined in an &#39;enc_class&#39; specification
 4982 //               in the encode section of the architecture description.
 4983 
 4984 
 4985 //----------Load/Store/Move Instructions---------------------------------------
 4986 //----------Load Instructions--------------------------------------------------
 4987 
 4988 // Load Byte (8 bit signed)
 4989 instruct loadB(rRegI dst, memory mem)
 4990 %{
 4991   match(Set dst (LoadB mem));
 4992 
 4993   ins_cost(125);
 4994   format %{ &quot;movsbl  $dst, $mem\t# byte&quot; %}
 4995 
 4996   ins_encode %{
 4997     __ movsbl($dst$$Register, $mem$$Address);
 4998   %}
 4999 
 5000   ins_pipe(ialu_reg_mem);
 5001 %}
 5002 
 5003 // Load Byte (8 bit signed) into Long Register
 5004 instruct loadB2L(rRegL dst, memory mem)
 5005 %{
 5006   match(Set dst (ConvI2L (LoadB mem)));
 5007 
 5008   ins_cost(125);
 5009   format %{ &quot;movsbq  $dst, $mem\t# byte -&gt; long&quot; %}
 5010 
 5011   ins_encode %{
 5012     __ movsbq($dst$$Register, $mem$$Address);
 5013   %}
 5014 
 5015   ins_pipe(ialu_reg_mem);
 5016 %}
 5017 
 5018 // Load Unsigned Byte (8 bit UNsigned)
 5019 instruct loadUB(rRegI dst, memory mem)
 5020 %{
 5021   match(Set dst (LoadUB mem));
 5022 
 5023   ins_cost(125);
 5024   format %{ &quot;movzbl  $dst, $mem\t# ubyte&quot; %}
 5025 
 5026   ins_encode %{
 5027     __ movzbl($dst$$Register, $mem$$Address);
 5028   %}
 5029 
 5030   ins_pipe(ialu_reg_mem);
 5031 %}
 5032 
 5033 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 5034 instruct loadUB2L(rRegL dst, memory mem)
 5035 %{
 5036   match(Set dst (ConvI2L (LoadUB mem)));
 5037 
 5038   ins_cost(125);
 5039   format %{ &quot;movzbq  $dst, $mem\t# ubyte -&gt; long&quot; %}
 5040 
 5041   ins_encode %{
 5042     __ movzbq($dst$$Register, $mem$$Address);
 5043   %}
 5044 
 5045   ins_pipe(ialu_reg_mem);
 5046 %}
 5047 
 5048 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 5049 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 5050   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 5051   effect(KILL cr);
 5052 
 5053   format %{ &quot;movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 5054             &quot;andl    $dst, right_n_bits($mask, 8)&quot; %}
 5055   ins_encode %{
 5056     Register Rdst = $dst$$Register;
 5057     __ movzbq(Rdst, $mem$$Address);
 5058     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 5059   %}
 5060   ins_pipe(ialu_reg_mem);
 5061 %}
 5062 
 5063 // Load Short (16 bit signed)
 5064 instruct loadS(rRegI dst, memory mem)
 5065 %{
 5066   match(Set dst (LoadS mem));
 5067 
 5068   ins_cost(125);
 5069   format %{ &quot;movswl $dst, $mem\t# short&quot; %}
 5070 
 5071   ins_encode %{
 5072     __ movswl($dst$$Register, $mem$$Address);
 5073   %}
 5074 
 5075   ins_pipe(ialu_reg_mem);
 5076 %}
 5077 
 5078 // Load Short (16 bit signed) to Byte (8 bit signed)
 5079 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5080   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 5081 
 5082   ins_cost(125);
 5083   format %{ &quot;movsbl $dst, $mem\t# short -&gt; byte&quot; %}
 5084   ins_encode %{
 5085     __ movsbl($dst$$Register, $mem$$Address);
 5086   %}
 5087   ins_pipe(ialu_reg_mem);
 5088 %}
 5089 
 5090 // Load Short (16 bit signed) into Long Register
 5091 instruct loadS2L(rRegL dst, memory mem)
 5092 %{
 5093   match(Set dst (ConvI2L (LoadS mem)));
 5094 
 5095   ins_cost(125);
 5096   format %{ &quot;movswq $dst, $mem\t# short -&gt; long&quot; %}
 5097 
 5098   ins_encode %{
 5099     __ movswq($dst$$Register, $mem$$Address);
 5100   %}
 5101 
 5102   ins_pipe(ialu_reg_mem);
 5103 %}
 5104 
 5105 // Load Unsigned Short/Char (16 bit UNsigned)
 5106 instruct loadUS(rRegI dst, memory mem)
 5107 %{
 5108   match(Set dst (LoadUS mem));
 5109 
 5110   ins_cost(125);
 5111   format %{ &quot;movzwl  $dst, $mem\t# ushort/char&quot; %}
 5112 
 5113   ins_encode %{
 5114     __ movzwl($dst$$Register, $mem$$Address);
 5115   %}
 5116 
 5117   ins_pipe(ialu_reg_mem);
 5118 %}
 5119 
 5120 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 5121 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5122   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 5123 
 5124   ins_cost(125);
 5125   format %{ &quot;movsbl $dst, $mem\t# ushort -&gt; byte&quot; %}
 5126   ins_encode %{
 5127     __ movsbl($dst$$Register, $mem$$Address);
 5128   %}
 5129   ins_pipe(ialu_reg_mem);
 5130 %}
 5131 
 5132 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 5133 instruct loadUS2L(rRegL dst, memory mem)
 5134 %{
 5135   match(Set dst (ConvI2L (LoadUS mem)));
 5136 
 5137   ins_cost(125);
 5138   format %{ &quot;movzwq  $dst, $mem\t# ushort/char -&gt; long&quot; %}
 5139 
 5140   ins_encode %{
 5141     __ movzwq($dst$$Register, $mem$$Address);
 5142   %}
 5143 
 5144   ins_pipe(ialu_reg_mem);
 5145 %}
 5146 
 5147 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 5148 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 5149   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5150 
 5151   format %{ &quot;movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long&quot; %}
 5152   ins_encode %{
 5153     __ movzbq($dst$$Register, $mem$$Address);
 5154   %}
 5155   ins_pipe(ialu_reg_mem);
 5156 %}
 5157 
 5158 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
 5159 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 5160   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5161   effect(KILL cr);
 5162 
 5163   format %{ &quot;movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 5164             &quot;andl    $dst, right_n_bits($mask, 16)&quot; %}
 5165   ins_encode %{
 5166     Register Rdst = $dst$$Register;
 5167     __ movzwq(Rdst, $mem$$Address);
 5168     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 5169   %}
 5170   ins_pipe(ialu_reg_mem);
 5171 %}
 5172 
 5173 // Load Integer
 5174 instruct loadI(rRegI dst, memory mem)
 5175 %{
 5176   match(Set dst (LoadI mem));
 5177 
 5178   ins_cost(125);
 5179   format %{ &quot;movl    $dst, $mem\t# int&quot; %}
 5180 
 5181   ins_encode %{
 5182     __ movl($dst$$Register, $mem$$Address);
 5183   %}
 5184 
 5185   ins_pipe(ialu_reg_mem);
 5186 %}
 5187 
 5188 // Load Integer (32 bit signed) to Byte (8 bit signed)
 5189 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5190   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 5191 
 5192   ins_cost(125);
 5193   format %{ &quot;movsbl  $dst, $mem\t# int -&gt; byte&quot; %}
 5194   ins_encode %{
 5195     __ movsbl($dst$$Register, $mem$$Address);
 5196   %}
 5197   ins_pipe(ialu_reg_mem);
 5198 %}
 5199 
 5200 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 5201 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 5202   match(Set dst (AndI (LoadI mem) mask));
 5203 
 5204   ins_cost(125);
 5205   format %{ &quot;movzbl  $dst, $mem\t# int -&gt; ubyte&quot; %}
 5206   ins_encode %{
 5207     __ movzbl($dst$$Register, $mem$$Address);
 5208   %}
 5209   ins_pipe(ialu_reg_mem);
 5210 %}
 5211 
 5212 // Load Integer (32 bit signed) to Short (16 bit signed)
 5213 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 5214   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5215 
 5216   ins_cost(125);
 5217   format %{ &quot;movswl  $dst, $mem\t# int -&gt; short&quot; %}
 5218   ins_encode %{
 5219     __ movswl($dst$$Register, $mem$$Address);
 5220   %}
 5221   ins_pipe(ialu_reg_mem);
 5222 %}
 5223 
 5224 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 5225 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 5226   match(Set dst (AndI (LoadI mem) mask));
 5227 
 5228   ins_cost(125);
 5229   format %{ &quot;movzwl  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 5230   ins_encode %{
 5231     __ movzwl($dst$$Register, $mem$$Address);
 5232   %}
 5233   ins_pipe(ialu_reg_mem);
 5234 %}
 5235 
 5236 // Load Integer into Long Register
 5237 instruct loadI2L(rRegL dst, memory mem)
 5238 %{
 5239   match(Set dst (ConvI2L (LoadI mem)));
 5240 
 5241   ins_cost(125);
 5242   format %{ &quot;movslq  $dst, $mem\t# int -&gt; long&quot; %}
 5243 
 5244   ins_encode %{
 5245     __ movslq($dst$$Register, $mem$$Address);
 5246   %}
 5247 
 5248   ins_pipe(ialu_reg_mem);
 5249 %}
 5250 
 5251 // Load Integer with mask 0xFF into Long Register
 5252 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 5253   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5254 
 5255   format %{ &quot;movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long&quot; %}
 5256   ins_encode %{
 5257     __ movzbq($dst$$Register, $mem$$Address);
 5258   %}
 5259   ins_pipe(ialu_reg_mem);
 5260 %}
 5261 
 5262 // Load Integer with mask 0xFFFF into Long Register
 5263 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
 5264   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5265 
 5266   format %{ &quot;movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long&quot; %}
 5267   ins_encode %{
 5268     __ movzwq($dst$$Register, $mem$$Address);
 5269   %}
 5270   ins_pipe(ialu_reg_mem);
 5271 %}
 5272 
 5273 // Load Integer with a 31-bit mask into Long Register
 5274 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
 5275   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5276   effect(KILL cr);
 5277 
 5278   format %{ &quot;movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5279             &quot;andl    $dst, $mask&quot; %}
 5280   ins_encode %{
 5281     Register Rdst = $dst$$Register;
 5282     __ movl(Rdst, $mem$$Address);
 5283     __ andl(Rdst, $mask$$constant);
 5284   %}
 5285   ins_pipe(ialu_reg_mem);
 5286 %}
 5287 
 5288 // Load Unsigned Integer into Long Register
 5289 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
 5290 %{
 5291   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5292 
 5293   ins_cost(125);
 5294   format %{ &quot;movl    $dst, $mem\t# uint -&gt; long&quot; %}
 5295 
 5296   ins_encode %{
 5297     __ movl($dst$$Register, $mem$$Address);
 5298   %}
 5299 
 5300   ins_pipe(ialu_reg_mem);
 5301 %}
 5302 
 5303 // Load Long
 5304 instruct loadL(rRegL dst, memory mem)
 5305 %{
 5306   match(Set dst (LoadL mem));
 5307 
 5308   ins_cost(125);
 5309   format %{ &quot;movq    $dst, $mem\t# long&quot; %}
 5310 
 5311   ins_encode %{
 5312     __ movq($dst$$Register, $mem$$Address);
 5313   %}
 5314 
 5315   ins_pipe(ialu_reg_mem); // XXX
 5316 %}
 5317 
 5318 // Load Range
 5319 instruct loadRange(rRegI dst, memory mem)
 5320 %{
 5321   match(Set dst (LoadRange mem));
 5322 
 5323   ins_cost(125); // XXX
 5324   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5325   opcode(0x8B);
 5326   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5327   ins_pipe(ialu_reg_mem);
 5328 %}
 5329 
 5330 // Load Pointer
 5331 instruct loadP(rRegP dst, memory mem)
 5332 %{
 5333   match(Set dst (LoadP mem));
<a name="27" id="anc27"></a>
 5334 
 5335   ins_cost(125); // XXX
 5336   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5337   opcode(0x8B);
 5338   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5339   ins_pipe(ialu_reg_mem); // XXX
 5340 %}
 5341 
 5342 // Load Compressed Pointer
 5343 instruct loadN(rRegN dst, memory mem)
 5344 %{
 5345    match(Set dst (LoadN mem));
 5346 
 5347    ins_cost(125); // XXX
 5348    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5349    ins_encode %{
 5350      __ movl($dst$$Register, $mem$$Address);
 5351    %}
 5352    ins_pipe(ialu_reg_mem); // XXX
 5353 %}
 5354 
 5355 
 5356 // Load Klass Pointer
 5357 instruct loadKlass(rRegP dst, memory mem)
 5358 %{
 5359   match(Set dst (LoadKlass mem));
 5360 
 5361   ins_cost(125); // XXX
 5362   format %{ &quot;movq    $dst, $mem\t# class&quot; %}
 5363   opcode(0x8B);
 5364   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5365   ins_pipe(ialu_reg_mem); // XXX
 5366 %}
 5367 
 5368 // Load narrow Klass Pointer
 5369 instruct loadNKlass(rRegN dst, memory mem)
 5370 %{
 5371   match(Set dst (LoadNKlass mem));
 5372 
 5373   ins_cost(125); // XXX
 5374   format %{ &quot;movl    $dst, $mem\t# compressed klass ptr&quot; %}
 5375   ins_encode %{
 5376     __ movl($dst$$Register, $mem$$Address);
 5377   %}
 5378   ins_pipe(ialu_reg_mem); // XXX
 5379 %}
 5380 
 5381 // Load Float
 5382 instruct loadF(regF dst, memory mem)
 5383 %{
 5384   match(Set dst (LoadF mem));
 5385 
 5386   ins_cost(145); // XXX
 5387   format %{ &quot;movss   $dst, $mem\t# float&quot; %}
 5388   ins_encode %{
 5389     __ movflt($dst$$XMMRegister, $mem$$Address);
 5390   %}
 5391   ins_pipe(pipe_slow); // XXX
 5392 %}
 5393 
 5394 // Load Float
 5395 instruct MoveF2VL(vlRegF dst, regF src) %{
 5396   match(Set dst src);
 5397   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5398   ins_encode %{
 5399     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5400   %}
 5401   ins_pipe( fpu_reg_reg );
 5402 %}
 5403 
 5404 // Load Float
 5405 instruct MoveF2LEG(legRegF dst, regF src) %{
 5406   match(Set dst src);
 5407   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5408   ins_encode %{
 5409     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5410   %}
 5411   ins_pipe( fpu_reg_reg );
 5412 %}
 5413 
 5414 // Load Float
 5415 instruct MoveVL2F(regF dst, vlRegF src) %{
 5416   match(Set dst src);
 5417   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5418   ins_encode %{
 5419     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5420   %}
 5421   ins_pipe( fpu_reg_reg );
 5422 %}
 5423 
 5424 // Load Float
 5425 instruct MoveLEG2F(regF dst, legRegF src) %{
 5426   match(Set dst src);
 5427   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5428   ins_encode %{
 5429     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5430   %}
 5431   ins_pipe( fpu_reg_reg );
 5432 %}
 5433 
 5434 // Load Double
 5435 instruct loadD_partial(regD dst, memory mem)
 5436 %{
 5437   predicate(!UseXmmLoadAndClearUpper);
 5438   match(Set dst (LoadD mem));
 5439 
 5440   ins_cost(145); // XXX
 5441   format %{ &quot;movlpd  $dst, $mem\t# double&quot; %}
 5442   ins_encode %{
 5443     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5444   %}
 5445   ins_pipe(pipe_slow); // XXX
 5446 %}
 5447 
 5448 instruct loadD(regD dst, memory mem)
 5449 %{
 5450   predicate(UseXmmLoadAndClearUpper);
 5451   match(Set dst (LoadD mem));
 5452 
 5453   ins_cost(145); // XXX
 5454   format %{ &quot;movsd   $dst, $mem\t# double&quot; %}
 5455   ins_encode %{
 5456     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5457   %}
 5458   ins_pipe(pipe_slow); // XXX
 5459 %}
 5460 
 5461 // Load Double
 5462 instruct MoveD2VL(vlRegD dst, regD src) %{
 5463   match(Set dst src);
 5464   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5465   ins_encode %{
 5466     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5467   %}
 5468   ins_pipe( fpu_reg_reg );
 5469 %}
 5470 
 5471 // Load Double
 5472 instruct MoveD2LEG(legRegD dst, regD src) %{
 5473   match(Set dst src);
 5474   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5475   ins_encode %{
 5476     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5477   %}
 5478   ins_pipe( fpu_reg_reg );
 5479 %}
 5480 
 5481 // Load Double
 5482 instruct MoveVL2D(regD dst, vlRegD src) %{
 5483   match(Set dst src);
 5484   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5485   ins_encode %{
 5486     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5487   %}
 5488   ins_pipe( fpu_reg_reg );
 5489 %}
 5490 
 5491 // Load Double
 5492 instruct MoveLEG2D(regD dst, legRegD src) %{
 5493   match(Set dst src);
 5494   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5495   ins_encode %{
 5496     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5497   %}
 5498   ins_pipe( fpu_reg_reg );
 5499 %}
 5500 
 5501 // Following pseudo code describes the algorithm for max[FD]:
 5502 // Min algorithm is on similar lines
 5503 //  btmp = (b &lt; +0.0) ? a : b
 5504 //  atmp = (b &lt; +0.0) ? b : a
 5505 //  Tmp  = Max_Float(atmp , btmp)
 5506 //  Res  = (atmp == NaN) ? atmp : Tmp
 5507 
 5508 // max = java.lang.Math.max(float a, float b)
 5509 instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5510   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5511   match(Set dst (MaxF a b));
 5512   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5513   format %{
 5514      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5515      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5516      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5517      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5518      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5519   %}
 5520   ins_encode %{
 5521     int vector_len = Assembler::AVX_128bit;
 5522     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5523     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5524     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5525     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5526     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5527  %}
 5528   ins_pipe( pipe_slow );
 5529 %}
 5530 
<a name="28" id="anc28"></a><span class="line-modified"> 5531 instruct maxF_reduction_reg(regF dst, regF a, regF b, regF xmmt, rRegI tmp, rFlagsReg cr) %{</span>
 5532   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5533   match(Set dst (MaxF a b));
 5534   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5535 
 5536   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5537   ins_encode %{
 5538     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5539                     false /*min*/, true /*single*/);
 5540   %}
 5541   ins_pipe( pipe_slow );
 5542 %}
 5543 
 5544 // max = java.lang.Math.max(double a, double b)
 5545 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5546   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5547   match(Set dst (MaxD a b));
 5548   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5549   format %{
 5550      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5551      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5552      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5553      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5554      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5555   %}
 5556   ins_encode %{
 5557     int vector_len = Assembler::AVX_128bit;
 5558     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5559     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5560     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5561     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5562     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5563   %}
 5564   ins_pipe( pipe_slow );
 5565 %}
 5566 
<a name="29" id="anc29"></a><span class="line-modified"> 5567 instruct maxD_reduction_reg(regD dst, regD a, regD b, regD xmmt, rRegL tmp, rFlagsReg cr) %{</span>
 5568   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5569   match(Set dst (MaxD a b));
 5570   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5571 
 5572   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5573   ins_encode %{
 5574     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5575                     false /*min*/, false /*single*/);
 5576   %}
 5577   ins_pipe( pipe_slow );
 5578 %}
 5579 
 5580 // min = java.lang.Math.min(float a, float b)
 5581 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5582   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5583   match(Set dst (MinF a b));
 5584   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5585   format %{
 5586      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5587      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5588      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5589      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5590      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5591   %}
 5592   ins_encode %{
 5593     int vector_len = Assembler::AVX_128bit;
 5594     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5595     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5596     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5597     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5598     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5599   %}
 5600   ins_pipe( pipe_slow );
 5601 %}
 5602 
<a name="30" id="anc30"></a><span class="line-modified"> 5603 instruct minF_reduction_reg(regF dst, regF a, regF b, regF xmmt, rRegI tmp, rFlagsReg cr) %{</span>
 5604   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5605   match(Set dst (MinF a b));
 5606   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5607 
 5608   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5609   ins_encode %{
 5610     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5611                     true /*min*/, true /*single*/);
 5612   %}
 5613   ins_pipe( pipe_slow );
 5614 %}
 5615 
 5616 // min = java.lang.Math.min(double a, double b)
 5617 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5618   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5619   match(Set dst (MinD a b));
 5620   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5621   format %{
 5622      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5623      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5624      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5625      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5626      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5627   %}
 5628   ins_encode %{
 5629     int vector_len = Assembler::AVX_128bit;
 5630     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5631     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5632     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5633     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5634     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5635   %}
 5636   ins_pipe( pipe_slow );
 5637 %}
 5638 
<a name="31" id="anc31"></a><span class="line-modified"> 5639 instruct minD_reduction_reg(regD dst, regD a, regD b, regD xmmt, rRegL tmp, rFlagsReg cr) %{</span>
 5640   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5641   match(Set dst (MinD a b));
 5642   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5643 
 5644   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5645   ins_encode %{
 5646     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5647                     true /*min*/, false /*single*/);
 5648   %}
 5649   ins_pipe( pipe_slow );
 5650 %}
 5651 
 5652 // Load Effective Address
 5653 instruct leaP8(rRegP dst, indOffset8 mem)
 5654 %{
 5655   match(Set dst mem);
 5656 
 5657   ins_cost(110); // XXX
 5658   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5659   opcode(0x8D);
 5660   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5661   ins_pipe(ialu_reg_reg_fat);
 5662 %}
 5663 
 5664 instruct leaP32(rRegP dst, indOffset32 mem)
 5665 %{
 5666   match(Set dst mem);
 5667 
 5668   ins_cost(110);
 5669   format %{ &quot;leaq    $dst, $mem\t# ptr 32&quot; %}
 5670   opcode(0x8D);
 5671   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5672   ins_pipe(ialu_reg_reg_fat);
 5673 %}
 5674 
 5675 // instruct leaPIdx(rRegP dst, indIndex mem)
 5676 // %{
 5677 //   match(Set dst mem);
 5678 
 5679 //   ins_cost(110);
 5680 //   format %{ &quot;leaq    $dst, $mem\t# ptr idx&quot; %}
 5681 //   opcode(0x8D);
 5682 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5683 //   ins_pipe(ialu_reg_reg_fat);
 5684 // %}
 5685 
 5686 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
 5687 %{
 5688   match(Set dst mem);
 5689 
 5690   ins_cost(110);
 5691   format %{ &quot;leaq    $dst, $mem\t# ptr idxoff&quot; %}
 5692   opcode(0x8D);
 5693   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5694   ins_pipe(ialu_reg_reg_fat);
 5695 %}
 5696 
 5697 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
 5698 %{
 5699   match(Set dst mem);
 5700 
 5701   ins_cost(110);
 5702   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5703   opcode(0x8D);
 5704   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5705   ins_pipe(ialu_reg_reg_fat);
 5706 %}
 5707 
 5708 instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)
 5709 %{
 5710   match(Set dst mem);
 5711 
 5712   ins_cost(110);
 5713   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5714   opcode(0x8D);
 5715   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5716   ins_pipe(ialu_reg_reg_fat);
 5717 %}
 5718 
 5719 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
 5720 %{
 5721   match(Set dst mem);
 5722 
 5723   ins_cost(110);
 5724   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoff&quot; %}
 5725   opcode(0x8D);
 5726   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5727   ins_pipe(ialu_reg_reg_fat);
 5728 %}
 5729 
 5730 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
 5731 %{
 5732   match(Set dst mem);
 5733 
 5734   ins_cost(110);
 5735   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5736   opcode(0x8D);
 5737   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5738   ins_pipe(ialu_reg_reg_fat);
 5739 %}
 5740 
 5741 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5742 %{
 5743   match(Set dst mem);
 5744 
 5745   ins_cost(110);
 5746   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5747   opcode(0x8D);
 5748   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5749   ins_pipe(ialu_reg_reg_fat);
 5750 %}
 5751 
 5752 // Load Effective Address which uses Narrow (32-bits) oop
 5753 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5754 %{
<a name="32" id="anc32"></a><span class="line-modified"> 5755   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() != 0));</span>
 5756   match(Set dst mem);
 5757 
 5758   ins_cost(110);
 5759   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5760   opcode(0x8D);
 5761   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5762   ins_pipe(ialu_reg_reg_fat);
 5763 %}
 5764 
 5765 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5766 %{
<a name="33" id="anc33"></a><span class="line-modified"> 5767   predicate(Universe::narrow_oop_shift() == 0);</span>
 5768   match(Set dst mem);
 5769 
 5770   ins_cost(110); // XXX
 5771   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5772   opcode(0x8D);
 5773   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5774   ins_pipe(ialu_reg_reg_fat);
 5775 %}
 5776 
 5777 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5778 %{
<a name="34" id="anc34"></a><span class="line-modified"> 5779   predicate(Universe::narrow_oop_shift() == 0);</span>
 5780   match(Set dst mem);
 5781 
 5782   ins_cost(110);
 5783   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5784   opcode(0x8D);
 5785   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5786   ins_pipe(ialu_reg_reg_fat);
 5787 %}
 5788 
 5789 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5790 %{
<a name="35" id="anc35"></a><span class="line-modified"> 5791   predicate(Universe::narrow_oop_shift() == 0);</span>
 5792   match(Set dst mem);
 5793 
 5794   ins_cost(110);
 5795   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5796   opcode(0x8D);
 5797   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5798   ins_pipe(ialu_reg_reg_fat);
 5799 %}
 5800 
 5801 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5802 %{
<a name="36" id="anc36"></a><span class="line-modified"> 5803   predicate(Universe::narrow_oop_shift() == 0);</span>
 5804   match(Set dst mem);
 5805 
 5806   ins_cost(110);
 5807   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5808   opcode(0x8D);
 5809   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5810   ins_pipe(ialu_reg_reg_fat);
 5811 %}
 5812 
 5813 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5814 %{
<a name="37" id="anc37"></a><span class="line-modified"> 5815   predicate(Universe::narrow_oop_shift() == 0);</span>
 5816   match(Set dst mem);
 5817 
 5818   ins_cost(110);
 5819   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5820   opcode(0x8D);
 5821   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5822   ins_pipe(ialu_reg_reg_fat);
 5823 %}
 5824 
 5825 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5826 %{
<a name="38" id="anc38"></a><span class="line-modified"> 5827   predicate(Universe::narrow_oop_shift() == 0);</span>
 5828   match(Set dst mem);
 5829 
 5830   ins_cost(110);
 5831   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5832   opcode(0x8D);
 5833   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5834   ins_pipe(ialu_reg_reg_fat);
 5835 %}
 5836 
 5837 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5838 %{
<a name="39" id="anc39"></a><span class="line-modified"> 5839   predicate(Universe::narrow_oop_shift() == 0);</span>
 5840   match(Set dst mem);
 5841 
 5842   ins_cost(110);
 5843   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5844   opcode(0x8D);
 5845   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5846   ins_pipe(ialu_reg_reg_fat);
 5847 %}
 5848 
 5849 instruct loadConI(rRegI dst, immI src)
 5850 %{
 5851   match(Set dst src);
 5852 
 5853   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5854   ins_encode(load_immI(dst, src));
 5855   ins_pipe(ialu_reg_fat); // XXX
 5856 %}
 5857 
 5858 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5859 %{
 5860   match(Set dst src);
 5861   effect(KILL cr);
 5862 
 5863   ins_cost(50);
 5864   format %{ &quot;xorl    $dst, $dst\t# int&quot; %}
 5865   opcode(0x33); /* + rd */
 5866   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5867   ins_pipe(ialu_reg);
 5868 %}
 5869 
 5870 instruct loadConL(rRegL dst, immL src)
 5871 %{
 5872   match(Set dst src);
 5873 
 5874   ins_cost(150);
 5875   format %{ &quot;movq    $dst, $src\t# long&quot; %}
 5876   ins_encode(load_immL(dst, src));
 5877   ins_pipe(ialu_reg);
 5878 %}
 5879 
 5880 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
 5881 %{
 5882   match(Set dst src);
 5883   effect(KILL cr);
 5884 
 5885   ins_cost(50);
 5886   format %{ &quot;xorl    $dst, $dst\t# long&quot; %}
 5887   opcode(0x33); /* + rd */
 5888   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5889   ins_pipe(ialu_reg); // XXX
 5890 %}
 5891 
 5892 instruct loadConUL32(rRegL dst, immUL32 src)
 5893 %{
 5894   match(Set dst src);
 5895 
 5896   ins_cost(60);
 5897   format %{ &quot;movl    $dst, $src\t# long (unsigned 32-bit)&quot; %}
 5898   ins_encode(load_immUL32(dst, src));
 5899   ins_pipe(ialu_reg);
 5900 %}
 5901 
 5902 instruct loadConL32(rRegL dst, immL32 src)
 5903 %{
 5904   match(Set dst src);
 5905 
 5906   ins_cost(70);
 5907   format %{ &quot;movq    $dst, $src\t# long (32-bit)&quot; %}
 5908   ins_encode(load_immL32(dst, src));
 5909   ins_pipe(ialu_reg);
 5910 %}
 5911 
 5912 instruct loadConP(rRegP dst, immP con) %{
 5913   match(Set dst con);
 5914 
 5915   format %{ &quot;movq    $dst, $con\t# ptr&quot; %}
 5916   ins_encode(load_immP(dst, con));
 5917   ins_pipe(ialu_reg_fat); // XXX
 5918 %}
 5919 
 5920 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
 5921 %{
 5922   match(Set dst src);
 5923   effect(KILL cr);
 5924 
 5925   ins_cost(50);
 5926   format %{ &quot;xorl    $dst, $dst\t# ptr&quot; %}
 5927   opcode(0x33); /* + rd */
 5928   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5929   ins_pipe(ialu_reg);
 5930 %}
 5931 
 5932 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
 5933 %{
 5934   match(Set dst src);
 5935   effect(KILL cr);
 5936 
 5937   ins_cost(60);
 5938   format %{ &quot;movl    $dst, $src\t# ptr (positive 32-bit)&quot; %}
 5939   ins_encode(load_immP31(dst, src));
 5940   ins_pipe(ialu_reg);
 5941 %}
 5942 
 5943 instruct loadConF(regF dst, immF con) %{
 5944   match(Set dst con);
 5945   ins_cost(125);
 5946   format %{ &quot;movss   $dst, [$constantaddress]\t# load from constant table: float=$con&quot; %}
 5947   ins_encode %{
 5948     __ movflt($dst$$XMMRegister, $constantaddress($con));
 5949   %}
 5950   ins_pipe(pipe_slow);
 5951 %}
 5952 
 5953 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
 5954   match(Set dst src);
 5955   effect(KILL cr);
 5956   format %{ &quot;xorq    $dst, $src\t# compressed NULL ptr&quot; %}
 5957   ins_encode %{
 5958     __ xorq($dst$$Register, $dst$$Register);
 5959   %}
 5960   ins_pipe(ialu_reg);
 5961 %}
 5962 
 5963 instruct loadConN(rRegN dst, immN src) %{
 5964   match(Set dst src);
 5965 
 5966   ins_cost(125);
 5967   format %{ &quot;movl    $dst, $src\t# compressed ptr&quot; %}
 5968   ins_encode %{
 5969     address con = (address)$src$$constant;
 5970     if (con == NULL) {
 5971       ShouldNotReachHere();
 5972     } else {
 5973       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
 5974     }
 5975   %}
 5976   ins_pipe(ialu_reg_fat); // XXX
 5977 %}
 5978 
 5979 instruct loadConNKlass(rRegN dst, immNKlass src) %{
 5980   match(Set dst src);
 5981 
 5982   ins_cost(125);
 5983   format %{ &quot;movl    $dst, $src\t# compressed klass ptr&quot; %}
 5984   ins_encode %{
 5985     address con = (address)$src$$constant;
 5986     if (con == NULL) {
 5987       ShouldNotReachHere();
 5988     } else {
 5989       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
 5990     }
 5991   %}
 5992   ins_pipe(ialu_reg_fat); // XXX
 5993 %}
 5994 
 5995 instruct loadConF0(regF dst, immF0 src)
 5996 %{
 5997   match(Set dst src);
 5998   ins_cost(100);
 5999 
 6000   format %{ &quot;xorps   $dst, $dst\t# float 0.0&quot; %}
 6001   ins_encode %{
 6002     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 6003   %}
 6004   ins_pipe(pipe_slow);
 6005 %}
 6006 
 6007 // Use the same format since predicate() can not be used here.
 6008 instruct loadConD(regD dst, immD con) %{
 6009   match(Set dst con);
 6010   ins_cost(125);
 6011   format %{ &quot;movsd   $dst, [$constantaddress]\t# load from constant table: double=$con&quot; %}
 6012   ins_encode %{
 6013     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 6014   %}
 6015   ins_pipe(pipe_slow);
 6016 %}
 6017 
 6018 instruct loadConD0(regD dst, immD0 src)
 6019 %{
 6020   match(Set dst src);
 6021   ins_cost(100);
 6022 
 6023   format %{ &quot;xorpd   $dst, $dst\t# double 0.0&quot; %}
 6024   ins_encode %{
 6025     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 6026   %}
 6027   ins_pipe(pipe_slow);
 6028 %}
 6029 
 6030 instruct loadSSI(rRegI dst, stackSlotI src)
 6031 %{
 6032   match(Set dst src);
 6033 
 6034   ins_cost(125);
 6035   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6036   opcode(0x8B);
 6037   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 6038   ins_pipe(ialu_reg_mem);
 6039 %}
 6040 
 6041 instruct loadSSL(rRegL dst, stackSlotL src)
 6042 %{
 6043   match(Set dst src);
 6044 
 6045   ins_cost(125);
 6046   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 6047   opcode(0x8B);
 6048   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 6049   ins_pipe(ialu_reg_mem);
 6050 %}
 6051 
 6052 instruct loadSSP(rRegP dst, stackSlotP src)
 6053 %{
 6054   match(Set dst src);
 6055 
 6056   ins_cost(125);
 6057   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 6058   opcode(0x8B);
 6059   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 6060   ins_pipe(ialu_reg_mem);
 6061 %}
 6062 
 6063 instruct loadSSF(regF dst, stackSlotF src)
 6064 %{
 6065   match(Set dst src);
 6066 
 6067   ins_cost(125);
 6068   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6069   ins_encode %{
 6070     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
 6071   %}
 6072   ins_pipe(pipe_slow); // XXX
 6073 %}
 6074 
 6075 // Use the same format since predicate() can not be used here.
 6076 instruct loadSSD(regD dst, stackSlotD src)
 6077 %{
 6078   match(Set dst src);
 6079 
 6080   ins_cost(125);
 6081   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6082   ins_encode  %{
 6083     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
 6084   %}
 6085   ins_pipe(pipe_slow); // XXX
 6086 %}
 6087 
 6088 // Prefetch instructions for allocation.
 6089 // Must be safe to execute with invalid address (cannot fault).
 6090 
 6091 instruct prefetchAlloc( memory mem ) %{
 6092   predicate(AllocatePrefetchInstr==3);
 6093   match(PrefetchAllocation mem);
 6094   ins_cost(125);
 6095 
 6096   format %{ &quot;PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified&quot; %}
 6097   ins_encode %{
 6098     __ prefetchw($mem$$Address);
 6099   %}
 6100   ins_pipe(ialu_mem);
 6101 %}
 6102 
 6103 instruct prefetchAllocNTA( memory mem ) %{
 6104   predicate(AllocatePrefetchInstr==0);
 6105   match(PrefetchAllocation mem);
 6106   ins_cost(125);
 6107 
 6108   format %{ &quot;PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write&quot; %}
 6109   ins_encode %{
 6110     __ prefetchnta($mem$$Address);
 6111   %}
 6112   ins_pipe(ialu_mem);
 6113 %}
 6114 
 6115 instruct prefetchAllocT0( memory mem ) %{
 6116   predicate(AllocatePrefetchInstr==1);
 6117   match(PrefetchAllocation mem);
 6118   ins_cost(125);
 6119 
 6120   format %{ &quot;PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write&quot; %}
 6121   ins_encode %{
 6122     __ prefetcht0($mem$$Address);
 6123   %}
 6124   ins_pipe(ialu_mem);
 6125 %}
 6126 
 6127 instruct prefetchAllocT2( memory mem ) %{
 6128   predicate(AllocatePrefetchInstr==2);
 6129   match(PrefetchAllocation mem);
 6130   ins_cost(125);
 6131 
 6132   format %{ &quot;PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write&quot; %}
 6133   ins_encode %{
 6134     __ prefetcht2($mem$$Address);
 6135   %}
 6136   ins_pipe(ialu_mem);
 6137 %}
 6138 
 6139 //----------Store Instructions-------------------------------------------------
 6140 
 6141 // Store Byte
 6142 instruct storeB(memory mem, rRegI src)
 6143 %{
 6144   match(Set mem (StoreB mem src));
 6145 
 6146   ins_cost(125); // XXX
 6147   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6148   opcode(0x88);
 6149   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
 6150   ins_pipe(ialu_mem_reg);
 6151 %}
 6152 
 6153 // Store Char/Short
 6154 instruct storeC(memory mem, rRegI src)
 6155 %{
 6156   match(Set mem (StoreC mem src));
 6157 
 6158   ins_cost(125); // XXX
 6159   format %{ &quot;movw    $mem, $src\t# char/short&quot; %}
 6160   opcode(0x89);
 6161   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 6162   ins_pipe(ialu_mem_reg);
 6163 %}
 6164 
 6165 // Store Integer
 6166 instruct storeI(memory mem, rRegI src)
 6167 %{
 6168   match(Set mem (StoreI mem src));
 6169 
 6170   ins_cost(125); // XXX
 6171   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6172   opcode(0x89);
 6173   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 6174   ins_pipe(ialu_mem_reg);
 6175 %}
 6176 
 6177 // Store Long
 6178 instruct storeL(memory mem, rRegL src)
 6179 %{
 6180   match(Set mem (StoreL mem src));
 6181 
 6182   ins_cost(125); // XXX
 6183   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6184   opcode(0x89);
 6185   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 6186   ins_pipe(ialu_mem_reg); // XXX
 6187 %}
 6188 
 6189 // Store Pointer
 6190 instruct storeP(memory mem, any_RegP src)
 6191 %{
 6192   match(Set mem (StoreP mem src));
 6193 
 6194   ins_cost(125); // XXX
 6195   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 6196   opcode(0x89);
 6197   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 6198   ins_pipe(ialu_mem_reg);
 6199 %}
 6200 
 6201 instruct storeImmP0(memory mem, immP0 zero)
 6202 %{
<a name="40" id="anc40"></a><span class="line-modified"> 6203   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6204   match(Set mem (StoreP mem zero));
 6205 
 6206   ins_cost(125); // XXX
 6207   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 6208   ins_encode %{
 6209     __ movq($mem$$Address, r12);
 6210   %}
 6211   ins_pipe(ialu_mem_reg);
 6212 %}
 6213 
 6214 // Store NULL Pointer, mark word, or other simple pointer constant.
 6215 instruct storeImmP(memory mem, immP31 src)
 6216 %{
 6217   match(Set mem (StoreP mem src));
 6218 
 6219   ins_cost(150); // XXX
 6220   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 6221   opcode(0xC7); /* C7 /0 */
 6222   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6223   ins_pipe(ialu_mem_imm);
 6224 %}
 6225 
 6226 // Store Compressed Pointer
 6227 instruct storeN(memory mem, rRegN src)
 6228 %{
 6229   match(Set mem (StoreN mem src));
 6230 
 6231   ins_cost(125); // XXX
 6232   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6233   ins_encode %{
 6234     __ movl($mem$$Address, $src$$Register);
 6235   %}
 6236   ins_pipe(ialu_mem_reg);
 6237 %}
 6238 
 6239 instruct storeNKlass(memory mem, rRegN src)
 6240 %{
 6241   match(Set mem (StoreNKlass mem src));
 6242 
 6243   ins_cost(125); // XXX
 6244   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6245   ins_encode %{
 6246     __ movl($mem$$Address, $src$$Register);
 6247   %}
 6248   ins_pipe(ialu_mem_reg);
 6249 %}
 6250 
 6251 instruct storeImmN0(memory mem, immN0 zero)
 6252 %{
<a name="41" id="anc41"></a><span class="line-modified"> 6253   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_klass_base() == NULL);</span>
 6254   match(Set mem (StoreN mem zero));
 6255 
 6256   ins_cost(125); // XXX
 6257   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6258   ins_encode %{
 6259     __ movl($mem$$Address, r12);
 6260   %}
 6261   ins_pipe(ialu_mem_reg);
 6262 %}
 6263 
 6264 instruct storeImmN(memory mem, immN src)
 6265 %{
 6266   match(Set mem (StoreN mem src));
 6267 
 6268   ins_cost(150); // XXX
 6269   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6270   ins_encode %{
 6271     address con = (address)$src$$constant;
 6272     if (con == NULL) {
 6273       __ movl($mem$$Address, (int32_t)0);
 6274     } else {
 6275       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
 6276     }
 6277   %}
 6278   ins_pipe(ialu_mem_imm);
 6279 %}
 6280 
 6281 instruct storeImmNKlass(memory mem, immNKlass src)
 6282 %{
 6283   match(Set mem (StoreNKlass mem src));
 6284 
 6285   ins_cost(150); // XXX
 6286   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6287   ins_encode %{
 6288     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6289   %}
 6290   ins_pipe(ialu_mem_imm);
 6291 %}
 6292 
 6293 // Store Integer Immediate
 6294 instruct storeImmI0(memory mem, immI0 zero)
 6295 %{
<a name="42" id="anc42"></a><span class="line-modified"> 6296   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6297   match(Set mem (StoreI mem zero));
 6298 
 6299   ins_cost(125); // XXX
 6300   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6301   ins_encode %{
 6302     __ movl($mem$$Address, r12);
 6303   %}
 6304   ins_pipe(ialu_mem_reg);
 6305 %}
 6306 
 6307 instruct storeImmI(memory mem, immI src)
 6308 %{
 6309   match(Set mem (StoreI mem src));
 6310 
 6311   ins_cost(150);
 6312   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6313   opcode(0xC7); /* C7 /0 */
 6314   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6315   ins_pipe(ialu_mem_imm);
 6316 %}
 6317 
 6318 // Store Long Immediate
 6319 instruct storeImmL0(memory mem, immL0 zero)
 6320 %{
<a name="43" id="anc43"></a><span class="line-modified"> 6321   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6322   match(Set mem (StoreL mem zero));
 6323 
 6324   ins_cost(125); // XXX
 6325   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6326   ins_encode %{
 6327     __ movq($mem$$Address, r12);
 6328   %}
 6329   ins_pipe(ialu_mem_reg);
 6330 %}
 6331 
 6332 instruct storeImmL(memory mem, immL32 src)
 6333 %{
 6334   match(Set mem (StoreL mem src));
 6335 
 6336   ins_cost(150);
 6337   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6338   opcode(0xC7); /* C7 /0 */
 6339   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6340   ins_pipe(ialu_mem_imm);
 6341 %}
 6342 
 6343 // Store Short/Char Immediate
 6344 instruct storeImmC0(memory mem, immI0 zero)
 6345 %{
<a name="44" id="anc44"></a><span class="line-modified"> 6346   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6347   match(Set mem (StoreC mem zero));
 6348 
 6349   ins_cost(125); // XXX
 6350   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6351   ins_encode %{
 6352     __ movw($mem$$Address, r12);
 6353   %}
 6354   ins_pipe(ialu_mem_reg);
 6355 %}
 6356 
 6357 instruct storeImmI16(memory mem, immI16 src)
 6358 %{
 6359   predicate(UseStoreImmI16);
 6360   match(Set mem (StoreC mem src));
 6361 
 6362   ins_cost(150);
 6363   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6364   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6365   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6366   ins_pipe(ialu_mem_imm);
 6367 %}
 6368 
 6369 // Store Byte Immediate
 6370 instruct storeImmB0(memory mem, immI0 zero)
 6371 %{
<a name="45" id="anc45"></a><span class="line-modified"> 6372   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6373   match(Set mem (StoreB mem zero));
 6374 
 6375   ins_cost(125); // XXX
 6376   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6377   ins_encode %{
 6378     __ movb($mem$$Address, r12);
 6379   %}
 6380   ins_pipe(ialu_mem_reg);
 6381 %}
 6382 
 6383 instruct storeImmB(memory mem, immI8 src)
 6384 %{
 6385   match(Set mem (StoreB mem src));
 6386 
 6387   ins_cost(150); // XXX
 6388   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6389   opcode(0xC6); /* C6 /0 */
 6390   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6391   ins_pipe(ialu_mem_imm);
 6392 %}
 6393 
 6394 // Store CMS card-mark Immediate
 6395 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6396 %{
<a name="46" id="anc46"></a><span class="line-modified"> 6397   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6398   match(Set mem (StoreCM mem zero));
 6399 
 6400   ins_cost(125); // XXX
 6401   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6402   ins_encode %{
 6403     __ movb($mem$$Address, r12);
 6404   %}
 6405   ins_pipe(ialu_mem_reg);
 6406 %}
 6407 
 6408 instruct storeImmCM0(memory mem, immI0 src)
 6409 %{
 6410   match(Set mem (StoreCM mem src));
 6411 
 6412   ins_cost(150); // XXX
 6413   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6414   opcode(0xC6); /* C6 /0 */
 6415   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6416   ins_pipe(ialu_mem_imm);
 6417 %}
 6418 
 6419 // Store Float
 6420 instruct storeF(memory mem, regF src)
 6421 %{
 6422   match(Set mem (StoreF mem src));
 6423 
 6424   ins_cost(95); // XXX
 6425   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6426   ins_encode %{
 6427     __ movflt($mem$$Address, $src$$XMMRegister);
 6428   %}
 6429   ins_pipe(pipe_slow); // XXX
 6430 %}
 6431 
 6432 // Store immediate Float value (it is faster than store from XMM register)
 6433 instruct storeF0(memory mem, immF0 zero)
 6434 %{
<a name="47" id="anc47"></a><span class="line-modified"> 6435   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6436   match(Set mem (StoreF mem zero));
 6437 
 6438   ins_cost(25); // XXX
 6439   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6440   ins_encode %{
 6441     __ movl($mem$$Address, r12);
 6442   %}
 6443   ins_pipe(ialu_mem_reg);
 6444 %}
 6445 
 6446 instruct storeF_imm(memory mem, immF src)
 6447 %{
 6448   match(Set mem (StoreF mem src));
 6449 
 6450   ins_cost(50);
 6451   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6452   opcode(0xC7); /* C7 /0 */
 6453   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6454   ins_pipe(ialu_mem_imm);
 6455 %}
 6456 
 6457 // Store Double
 6458 instruct storeD(memory mem, regD src)
 6459 %{
 6460   match(Set mem (StoreD mem src));
 6461 
 6462   ins_cost(95); // XXX
 6463   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6464   ins_encode %{
 6465     __ movdbl($mem$$Address, $src$$XMMRegister);
 6466   %}
 6467   ins_pipe(pipe_slow); // XXX
 6468 %}
 6469 
 6470 // Store immediate double 0.0 (it is faster than store from XMM register)
 6471 instruct storeD0_imm(memory mem, immD0 src)
 6472 %{
<a name="48" id="anc48"></a><span class="line-modified"> 6473   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));</span>
 6474   match(Set mem (StoreD mem src));
 6475 
 6476   ins_cost(50);
 6477   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6478   opcode(0xC7); /* C7 /0 */
 6479   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6480   ins_pipe(ialu_mem_imm);
 6481 %}
 6482 
 6483 instruct storeD0(memory mem, immD0 zero)
 6484 %{
<a name="49" id="anc49"></a><span class="line-modified"> 6485   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
 6486   match(Set mem (StoreD mem zero));
 6487 
 6488   ins_cost(25); // XXX
 6489   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6490   ins_encode %{
 6491     __ movq($mem$$Address, r12);
 6492   %}
 6493   ins_pipe(ialu_mem_reg);
 6494 %}
 6495 
 6496 instruct storeSSI(stackSlotI dst, rRegI src)
 6497 %{
 6498   match(Set dst src);
 6499 
 6500   ins_cost(100);
 6501   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6502   opcode(0x89);
 6503   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6504   ins_pipe( ialu_mem_reg );
 6505 %}
 6506 
 6507 instruct storeSSL(stackSlotL dst, rRegL src)
 6508 %{
 6509   match(Set dst src);
 6510 
 6511   ins_cost(100);
 6512   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 6513   opcode(0x89);
 6514   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6515   ins_pipe(ialu_mem_reg);
 6516 %}
 6517 
 6518 instruct storeSSP(stackSlotP dst, rRegP src)
 6519 %{
 6520   match(Set dst src);
 6521 
 6522   ins_cost(100);
 6523   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 6524   opcode(0x89);
 6525   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6526   ins_pipe(ialu_mem_reg);
 6527 %}
 6528 
 6529 instruct storeSSF(stackSlotF dst, regF src)
 6530 %{
 6531   match(Set dst src);
 6532 
 6533   ins_cost(95); // XXX
 6534   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6535   ins_encode %{
 6536     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6537   %}
 6538   ins_pipe(pipe_slow); // XXX
 6539 %}
 6540 
 6541 instruct storeSSD(stackSlotD dst, regD src)
 6542 %{
 6543   match(Set dst src);
 6544 
 6545   ins_cost(95); // XXX
 6546   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6547   ins_encode %{
 6548     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6549   %}
 6550   ins_pipe(pipe_slow); // XXX
 6551 %}
 6552 
<a name="50" id="anc50"></a>








































 6553 //----------BSWAP Instructions-------------------------------------------------
 6554 instruct bytes_reverse_int(rRegI dst) %{
 6555   match(Set dst (ReverseBytesI dst));
 6556 
 6557   format %{ &quot;bswapl  $dst&quot; %}
 6558   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6559   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6560   ins_pipe( ialu_reg );
 6561 %}
 6562 
 6563 instruct bytes_reverse_long(rRegL dst) %{
 6564   match(Set dst (ReverseBytesL dst));
 6565 
 6566   format %{ &quot;bswapq  $dst&quot; %}
 6567   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6568   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6569   ins_pipe( ialu_reg);
 6570 %}
 6571 
 6572 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
 6573   match(Set dst (ReverseBytesUS dst));
 6574   effect(KILL cr);
 6575 
 6576   format %{ &quot;bswapl  $dst\n\t&quot;
 6577             &quot;shrl    $dst,16\n\t&quot; %}
 6578   ins_encode %{
 6579     __ bswapl($dst$$Register);
 6580     __ shrl($dst$$Register, 16);
 6581   %}
 6582   ins_pipe( ialu_reg );
 6583 %}
 6584 
 6585 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
 6586   match(Set dst (ReverseBytesS dst));
 6587   effect(KILL cr);
 6588 
 6589   format %{ &quot;bswapl  $dst\n\t&quot;
 6590             &quot;sar     $dst,16\n\t&quot; %}
 6591   ins_encode %{
 6592     __ bswapl($dst$$Register);
 6593     __ sarl($dst$$Register, 16);
 6594   %}
 6595   ins_pipe( ialu_reg );
 6596 %}
 6597 
 6598 //---------- Zeros Count Instructions ------------------------------------------
 6599 
 6600 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6601   predicate(UseCountLeadingZerosInstruction);
 6602   match(Set dst (CountLeadingZerosI src));
 6603   effect(KILL cr);
 6604 
 6605   format %{ &quot;lzcntl  $dst, $src\t# count leading zeros (int)&quot; %}
 6606   ins_encode %{
 6607     __ lzcntl($dst$$Register, $src$$Register);
 6608   %}
 6609   ins_pipe(ialu_reg);
 6610 %}
 6611 
 6612 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
 6613   predicate(!UseCountLeadingZerosInstruction);
 6614   match(Set dst (CountLeadingZerosI src));
 6615   effect(KILL cr);
 6616 
 6617   format %{ &quot;bsrl    $dst, $src\t# count leading zeros (int)\n\t&quot;
 6618             &quot;jnz     skip\n\t&quot;
 6619             &quot;movl    $dst, -1\n&quot;
 6620       &quot;skip:\n\t&quot;
 6621             &quot;negl    $dst\n\t&quot;
 6622             &quot;addl    $dst, 31&quot; %}
 6623   ins_encode %{
 6624     Register Rdst = $dst$$Register;
 6625     Register Rsrc = $src$$Register;
 6626     Label skip;
 6627     __ bsrl(Rdst, Rsrc);
 6628     __ jccb(Assembler::notZero, skip);
 6629     __ movl(Rdst, -1);
 6630     __ bind(skip);
 6631     __ negl(Rdst);
 6632     __ addl(Rdst, BitsPerInt - 1);
 6633   %}
 6634   ins_pipe(ialu_reg);
 6635 %}
 6636 
 6637 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6638   predicate(UseCountLeadingZerosInstruction);
 6639   match(Set dst (CountLeadingZerosL src));
 6640   effect(KILL cr);
 6641 
 6642   format %{ &quot;lzcntq  $dst, $src\t# count leading zeros (long)&quot; %}
 6643   ins_encode %{
 6644     __ lzcntq($dst$$Register, $src$$Register);
 6645   %}
 6646   ins_pipe(ialu_reg);
 6647 %}
 6648 
 6649 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
 6650   predicate(!UseCountLeadingZerosInstruction);
 6651   match(Set dst (CountLeadingZerosL src));
 6652   effect(KILL cr);
 6653 
 6654   format %{ &quot;bsrq    $dst, $src\t# count leading zeros (long)\n\t&quot;
 6655             &quot;jnz     skip\n\t&quot;
 6656             &quot;movl    $dst, -1\n&quot;
 6657       &quot;skip:\n\t&quot;
 6658             &quot;negl    $dst\n\t&quot;
 6659             &quot;addl    $dst, 63&quot; %}
 6660   ins_encode %{
 6661     Register Rdst = $dst$$Register;
 6662     Register Rsrc = $src$$Register;
 6663     Label skip;
 6664     __ bsrq(Rdst, Rsrc);
 6665     __ jccb(Assembler::notZero, skip);
 6666     __ movl(Rdst, -1);
 6667     __ bind(skip);
 6668     __ negl(Rdst);
 6669     __ addl(Rdst, BitsPerLong - 1);
 6670   %}
 6671   ins_pipe(ialu_reg);
 6672 %}
 6673 
 6674 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6675   predicate(UseCountTrailingZerosInstruction);
 6676   match(Set dst (CountTrailingZerosI src));
 6677   effect(KILL cr);
 6678 
 6679   format %{ &quot;tzcntl    $dst, $src\t# count trailing zeros (int)&quot; %}
 6680   ins_encode %{
 6681     __ tzcntl($dst$$Register, $src$$Register);
 6682   %}
 6683   ins_pipe(ialu_reg);
 6684 %}
 6685 
 6686 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
 6687   predicate(!UseCountTrailingZerosInstruction);
 6688   match(Set dst (CountTrailingZerosI src));
 6689   effect(KILL cr);
 6690 
 6691   format %{ &quot;bsfl    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 6692             &quot;jnz     done\n\t&quot;
 6693             &quot;movl    $dst, 32\n&quot;
 6694       &quot;done:&quot; %}
 6695   ins_encode %{
 6696     Register Rdst = $dst$$Register;
 6697     Label done;
 6698     __ bsfl(Rdst, $src$$Register);
 6699     __ jccb(Assembler::notZero, done);
 6700     __ movl(Rdst, BitsPerInt);
 6701     __ bind(done);
 6702   %}
 6703   ins_pipe(ialu_reg);
 6704 %}
 6705 
 6706 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6707   predicate(UseCountTrailingZerosInstruction);
 6708   match(Set dst (CountTrailingZerosL src));
 6709   effect(KILL cr);
 6710 
 6711   format %{ &quot;tzcntq    $dst, $src\t# count trailing zeros (long)&quot; %}
 6712   ins_encode %{
 6713     __ tzcntq($dst$$Register, $src$$Register);
 6714   %}
 6715   ins_pipe(ialu_reg);
 6716 %}
 6717 
 6718 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
 6719   predicate(!UseCountTrailingZerosInstruction);
 6720   match(Set dst (CountTrailingZerosL src));
 6721   effect(KILL cr);
 6722 
 6723   format %{ &quot;bsfq    $dst, $src\t# count trailing zeros (long)\n\t&quot;
 6724             &quot;jnz     done\n\t&quot;
 6725             &quot;movl    $dst, 64\n&quot;
 6726       &quot;done:&quot; %}
 6727   ins_encode %{
 6728     Register Rdst = $dst$$Register;
 6729     Label done;
 6730     __ bsfq(Rdst, $src$$Register);
 6731     __ jccb(Assembler::notZero, done);
 6732     __ movl(Rdst, BitsPerLong);
 6733     __ bind(done);
 6734   %}
 6735   ins_pipe(ialu_reg);
 6736 %}
 6737 
 6738 
 6739 //---------- Population Count Instructions -------------------------------------
 6740 
 6741 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6742   predicate(UsePopCountInstruction);
 6743   match(Set dst (PopCountI src));
 6744   effect(KILL cr);
 6745 
 6746   format %{ &quot;popcnt  $dst, $src&quot; %}
 6747   ins_encode %{
 6748     __ popcntl($dst$$Register, $src$$Register);
 6749   %}
 6750   ins_pipe(ialu_reg);
 6751 %}
 6752 
 6753 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6754   predicate(UsePopCountInstruction);
 6755   match(Set dst (PopCountI (LoadI mem)));
 6756   effect(KILL cr);
 6757 
 6758   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6759   ins_encode %{
 6760     __ popcntl($dst$$Register, $mem$$Address);
 6761   %}
 6762   ins_pipe(ialu_reg);
 6763 %}
 6764 
 6765 // Note: Long.bitCount(long) returns an int.
 6766 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6767   predicate(UsePopCountInstruction);
 6768   match(Set dst (PopCountL src));
 6769   effect(KILL cr);
 6770 
 6771   format %{ &quot;popcnt  $dst, $src&quot; %}
 6772   ins_encode %{
 6773     __ popcntq($dst$$Register, $src$$Register);
 6774   %}
 6775   ins_pipe(ialu_reg);
 6776 %}
 6777 
 6778 // Note: Long.bitCount(long) returns an int.
 6779 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6780   predicate(UsePopCountInstruction);
 6781   match(Set dst (PopCountL (LoadL mem)));
 6782   effect(KILL cr);
 6783 
 6784   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6785   ins_encode %{
 6786     __ popcntq($dst$$Register, $mem$$Address);
 6787   %}
 6788   ins_pipe(ialu_reg);
 6789 %}
 6790 
 6791 
 6792 //----------MemBar Instructions-----------------------------------------------
 6793 // Memory barrier flavors
 6794 
 6795 instruct membar_acquire()
 6796 %{
 6797   match(MemBarAcquire);
 6798   match(LoadFence);
 6799   ins_cost(0);
 6800 
 6801   size(0);
 6802   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6803   ins_encode();
 6804   ins_pipe(empty);
 6805 %}
 6806 
 6807 instruct membar_acquire_lock()
 6808 %{
 6809   match(MemBarAcquireLock);
 6810   ins_cost(0);
 6811 
 6812   size(0);
 6813   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6814   ins_encode();
 6815   ins_pipe(empty);
 6816 %}
 6817 
 6818 instruct membar_release()
 6819 %{
 6820   match(MemBarRelease);
 6821   match(StoreFence);
 6822   ins_cost(0);
 6823 
 6824   size(0);
 6825   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6826   ins_encode();
 6827   ins_pipe(empty);
 6828 %}
 6829 
 6830 instruct membar_release_lock()
 6831 %{
 6832   match(MemBarReleaseLock);
 6833   ins_cost(0);
 6834 
 6835   size(0);
 6836   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6837   ins_encode();
 6838   ins_pipe(empty);
 6839 %}
 6840 
 6841 instruct membar_volatile(rFlagsReg cr) %{
 6842   match(MemBarVolatile);
 6843   effect(KILL cr);
 6844   ins_cost(400);
 6845 
 6846   format %{
 6847     $$template
 6848     $$emit$$&quot;lock addl [rsp + #0], 0\t! membar_volatile&quot;
 6849   %}
 6850   ins_encode %{
 6851     __ membar(Assembler::StoreLoad);
 6852   %}
 6853   ins_pipe(pipe_slow);
 6854 %}
 6855 
 6856 instruct unnecessary_membar_volatile()
 6857 %{
 6858   match(MemBarVolatile);
 6859   predicate(Matcher::post_store_load_barrier(n));
 6860   ins_cost(0);
 6861 
 6862   size(0);
 6863   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6864   ins_encode();
 6865   ins_pipe(empty);
 6866 %}
 6867 
 6868 instruct membar_storestore() %{
 6869   match(MemBarStoreStore);
 6870   ins_cost(0);
 6871 
 6872   size(0);
 6873   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6874   ins_encode( );
 6875   ins_pipe(empty);
 6876 %}
 6877 
 6878 //----------Move Instructions--------------------------------------------------
 6879 
 6880 instruct castX2P(rRegP dst, rRegL src)
 6881 %{
 6882   match(Set dst (CastX2P src));
 6883 
 6884   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6885   ins_encode %{
 6886     if ($dst$$reg != $src$$reg) {
 6887       __ movptr($dst$$Register, $src$$Register);
 6888     }
 6889   %}
 6890   ins_pipe(ialu_reg_reg); // XXX
 6891 %}
 6892 
 6893 instruct castP2X(rRegL dst, rRegP src)
 6894 %{
 6895   match(Set dst (CastP2X src));
 6896 
 6897   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6898   ins_encode %{
 6899     if ($dst$$reg != $src$$reg) {
 6900       __ movptr($dst$$Register, $src$$Register);
 6901     }
 6902   %}
 6903   ins_pipe(ialu_reg_reg); // XXX
 6904 %}
 6905 
 6906 // Convert oop into int for vectors alignment masking
 6907 instruct convP2I(rRegI dst, rRegP src)
 6908 %{
 6909   match(Set dst (ConvL2I (CastP2X src)));
 6910 
 6911   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6912   ins_encode %{
 6913     __ movl($dst$$Register, $src$$Register);
 6914   %}
 6915   ins_pipe(ialu_reg_reg); // XXX
 6916 %}
 6917 
 6918 // Convert compressed oop into int for vectors alignment masking
 6919 // in case of 32bit oops (heap &lt; 4Gb).
 6920 instruct convN2I(rRegI dst, rRegN src)
 6921 %{
<a name="51" id="anc51"></a><span class="line-modified"> 6922   predicate(Universe::narrow_oop_shift() == 0);</span>
 6923   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6924 
 6925   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6926   ins_encode %{
 6927     __ movl($dst$$Register, $src$$Register);
 6928   %}
 6929   ins_pipe(ialu_reg_reg); // XXX
 6930 %}
 6931 
 6932 // Convert oop pointer into compressed form
 6933 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6934   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6935   match(Set dst (EncodeP src));
 6936   effect(KILL cr);
 6937   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6938   ins_encode %{
 6939     Register s = $src$$Register;
 6940     Register d = $dst$$Register;
 6941     if (s != d) {
 6942       __ movq(d, s);
 6943     }
 6944     __ encode_heap_oop(d);
 6945   %}
 6946   ins_pipe(ialu_reg_long);
 6947 %}
 6948 
 6949 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6950   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6951   match(Set dst (EncodeP src));
 6952   effect(KILL cr);
 6953   format %{ &quot;encode_heap_oop_not_null $dst,$src&quot; %}
 6954   ins_encode %{
 6955     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
 6956   %}
 6957   ins_pipe(ialu_reg_long);
 6958 %}
 6959 
 6960 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
 6961   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6962             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
 6963   match(Set dst (DecodeN src));
 6964   effect(KILL cr);
 6965   format %{ &quot;decode_heap_oop $dst,$src&quot; %}
 6966   ins_encode %{
 6967     Register s = $src$$Register;
 6968     Register d = $dst$$Register;
 6969     if (s != d) {
 6970       __ movq(d, s);
 6971     }
 6972     __ decode_heap_oop(d);
 6973   %}
 6974   ins_pipe(ialu_reg_long);
 6975 %}
 6976 
 6977 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6978   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6979             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6980   match(Set dst (DecodeN src));
 6981   effect(KILL cr);
 6982   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6983   ins_encode %{
 6984     Register s = $src$$Register;
 6985     Register d = $dst$$Register;
 6986     if (s != d) {
 6987       __ decode_heap_oop_not_null(d, s);
 6988     } else {
 6989       __ decode_heap_oop_not_null(d);
 6990     }
 6991   %}
 6992   ins_pipe(ialu_reg_long);
 6993 %}
 6994 
 6995 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6996   match(Set dst (EncodePKlass src));
 6997   effect(KILL cr);
 6998   format %{ &quot;encode_klass_not_null $dst,$src&quot; %}
 6999   ins_encode %{
 7000     __ encode_klass_not_null($dst$$Register, $src$$Register);
 7001   %}
 7002   ins_pipe(ialu_reg_long);
 7003 %}
 7004 
 7005 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 7006   match(Set dst (DecodeNKlass src));
 7007   effect(KILL cr);
 7008   format %{ &quot;decode_klass_not_null $dst,$src&quot; %}
 7009   ins_encode %{
 7010     Register s = $src$$Register;
 7011     Register d = $dst$$Register;
 7012     if (s != d) {
 7013       __ decode_klass_not_null(d, s);
 7014     } else {
 7015       __ decode_klass_not_null(d);
 7016     }
 7017   %}
 7018   ins_pipe(ialu_reg_long);
 7019 %}
 7020 
 7021 
 7022 //----------Conditional Move---------------------------------------------------
 7023 // Jump
 7024 // dummy instruction for generating temp registers
 7025 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 7026   match(Jump (LShiftL switch_val shift));
 7027   ins_cost(350);
 7028   predicate(false);
 7029   effect(TEMP dest);
 7030 
 7031   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 7032             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 7033   ins_encode %{
 7034     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 7035     // to do that and the compiler is using that register as one it can allocate.
 7036     // So we build it all by hand.
 7037     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 7038     // ArrayAddress dispatch(table, index);
 7039     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 7040     __ lea($dest$$Register, $constantaddress);
 7041     __ jmp(dispatch);
 7042   %}
 7043   ins_pipe(pipe_jmp);
 7044 %}
 7045 
 7046 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
 7047   match(Jump (AddL (LShiftL switch_val shift) offset));
 7048   ins_cost(350);
 7049   effect(TEMP dest);
 7050 
 7051   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 7052             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t&quot; %}
 7053   ins_encode %{
 7054     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 7055     // to do that and the compiler is using that register as one it can allocate.
 7056     // So we build it all by hand.
 7057     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 7058     // ArrayAddress dispatch(table, index);
 7059     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 7060     __ lea($dest$$Register, $constantaddress);
 7061     __ jmp(dispatch);
 7062   %}
 7063   ins_pipe(pipe_jmp);
 7064 %}
 7065 
 7066 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
 7067   match(Jump switch_val);
 7068   ins_cost(350);
 7069   effect(TEMP dest);
 7070 
 7071   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 7072             &quot;jmp     [$dest + $switch_val]\n\t&quot; %}
 7073   ins_encode %{
 7074     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 7075     // to do that and the compiler is using that register as one it can allocate.
 7076     // So we build it all by hand.
 7077     // Address index(noreg, switch_reg, Address::times_1);
 7078     // ArrayAddress dispatch(table, index);
 7079     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
 7080     __ lea($dest$$Register, $constantaddress);
 7081     __ jmp(dispatch);
 7082   %}
 7083   ins_pipe(pipe_jmp);
 7084 %}
 7085 
 7086 // Conditional move
 7087 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
 7088 %{
 7089   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 7090 
 7091   ins_cost(200); // XXX
 7092   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 7093   opcode(0x0F, 0x40);
 7094   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7095   ins_pipe(pipe_cmov_reg);
 7096 %}
 7097 
 7098 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
 7099   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 7100 
 7101   ins_cost(200); // XXX
 7102   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 7103   opcode(0x0F, 0x40);
 7104   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7105   ins_pipe(pipe_cmov_reg);
 7106 %}
 7107 
 7108 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
 7109   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 7110   ins_cost(200);
 7111   expand %{
 7112     cmovI_regU(cop, cr, dst, src);
 7113   %}
 7114 %}
 7115 
 7116 // Conditional move
 7117 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
 7118   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 7119 
 7120   ins_cost(250); // XXX
 7121   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 7122   opcode(0x0F, 0x40);
 7123   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7124   ins_pipe(pipe_cmov_mem);
 7125 %}
 7126 
 7127 // Conditional move
 7128 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
 7129 %{
 7130   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 7131 
 7132   ins_cost(250); // XXX
 7133   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 7134   opcode(0x0F, 0x40);
 7135   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7136   ins_pipe(pipe_cmov_mem);
 7137 %}
 7138 
 7139 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
 7140   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 7141   ins_cost(250);
 7142   expand %{
 7143     cmovI_memU(cop, cr, dst, src);
 7144   %}
 7145 %}
 7146 
 7147 // Conditional move
 7148 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
 7149 %{
 7150   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7151 
 7152   ins_cost(200); // XXX
 7153   format %{ &quot;cmovl$cop $dst, $src\t# signed, compressed ptr&quot; %}
 7154   opcode(0x0F, 0x40);
 7155   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7156   ins_pipe(pipe_cmov_reg);
 7157 %}
 7158 
 7159 // Conditional move
 7160 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
 7161 %{
 7162   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7163 
 7164   ins_cost(200); // XXX
 7165   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, compressed ptr&quot; %}
 7166   opcode(0x0F, 0x40);
 7167   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7168   ins_pipe(pipe_cmov_reg);
 7169 %}
 7170 
 7171 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
 7172   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7173   ins_cost(200);
 7174   expand %{
 7175     cmovN_regU(cop, cr, dst, src);
 7176   %}
 7177 %}
 7178 
 7179 // Conditional move
 7180 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
 7181 %{
 7182   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7183 
 7184   ins_cost(200); // XXX
 7185   format %{ &quot;cmovq$cop $dst, $src\t# signed, ptr&quot; %}
 7186   opcode(0x0F, 0x40);
 7187   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7188   ins_pipe(pipe_cmov_reg);  // XXX
 7189 %}
 7190 
 7191 // Conditional move
 7192 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
 7193 %{
 7194   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7195 
 7196   ins_cost(200); // XXX
 7197   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, ptr&quot; %}
 7198   opcode(0x0F, 0x40);
 7199   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7200   ins_pipe(pipe_cmov_reg); // XXX
 7201 %}
 7202 
 7203 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
 7204   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7205   ins_cost(200);
 7206   expand %{
 7207     cmovP_regU(cop, cr, dst, src);
 7208   %}
 7209 %}
 7210 
 7211 // DISABLED: Requires the ADLC to emit a bottom_type call that
 7212 // correctly meets the two pointer arguments; one is an incoming
 7213 // register but the other is a memory operand.  ALSO appears to
 7214 // be buggy with implicit null checks.
 7215 //
 7216 //// Conditional move
 7217 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
 7218 //%{
 7219 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7220 //  ins_cost(250);
 7221 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7222 //  opcode(0x0F,0x40);
 7223 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7224 //  ins_pipe( pipe_cmov_mem );
 7225 //%}
 7226 //
 7227 //// Conditional move
 7228 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
 7229 //%{
 7230 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7231 //  ins_cost(250);
 7232 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7233 //  opcode(0x0F,0x40);
 7234 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7235 //  ins_pipe( pipe_cmov_mem );
 7236 //%}
 7237 
 7238 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
 7239 %{
 7240   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7241 
 7242   ins_cost(200); // XXX
 7243   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7244   opcode(0x0F, 0x40);
 7245   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7246   ins_pipe(pipe_cmov_reg);  // XXX
 7247 %}
 7248 
 7249 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
 7250 %{
 7251   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7252 
 7253   ins_cost(200); // XXX
 7254   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7255   opcode(0x0F, 0x40);
 7256   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7257   ins_pipe(pipe_cmov_mem);  // XXX
 7258 %}
 7259 
 7260 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
 7261 %{
 7262   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7263 
 7264   ins_cost(200); // XXX
 7265   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7266   opcode(0x0F, 0x40);
 7267   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7268   ins_pipe(pipe_cmov_reg); // XXX
 7269 %}
 7270 
 7271 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
 7272   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7273   ins_cost(200);
 7274   expand %{
 7275     cmovL_regU(cop, cr, dst, src);
 7276   %}
 7277 %}
 7278 
 7279 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
 7280 %{
 7281   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7282 
 7283   ins_cost(200); // XXX
 7284   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7285   opcode(0x0F, 0x40);
 7286   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7287   ins_pipe(pipe_cmov_mem); // XXX
 7288 %}
 7289 
 7290 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
 7291   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7292   ins_cost(200);
 7293   expand %{
 7294     cmovL_memU(cop, cr, dst, src);
 7295   %}
 7296 %}
 7297 
 7298 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
 7299 %{
 7300   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7301 
 7302   ins_cost(200); // XXX
 7303   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7304             &quot;movss     $dst, $src\n&quot;
 7305     &quot;skip:&quot; %}
 7306   ins_encode %{
 7307     Label Lskip;
 7308     // Invert sense of branch from sense of CMOV
 7309     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7310     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7311     __ bind(Lskip);
 7312   %}
 7313   ins_pipe(pipe_slow);
 7314 %}
 7315 
 7316 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
 7317 // %{
 7318 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
 7319 
 7320 //   ins_cost(200); // XXX
 7321 //   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7322 //             &quot;movss     $dst, $src\n&quot;
 7323 //     &quot;skip:&quot; %}
 7324 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
 7325 //   ins_pipe(pipe_slow);
 7326 // %}
 7327 
 7328 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
 7329 %{
 7330   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7331 
 7332   ins_cost(200); // XXX
 7333   format %{ &quot;jn$cop    skip\t# unsigned cmove float\n\t&quot;
 7334             &quot;movss     $dst, $src\n&quot;
 7335     &quot;skip:&quot; %}
 7336   ins_encode %{
 7337     Label Lskip;
 7338     // Invert sense of branch from sense of CMOV
 7339     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7340     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7341     __ bind(Lskip);
 7342   %}
 7343   ins_pipe(pipe_slow);
 7344 %}
 7345 
 7346 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
 7347   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7348   ins_cost(200);
 7349   expand %{
 7350     cmovF_regU(cop, cr, dst, src);
 7351   %}
 7352 %}
 7353 
 7354 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
 7355 %{
 7356   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7357 
 7358   ins_cost(200); // XXX
 7359   format %{ &quot;jn$cop    skip\t# signed cmove double\n\t&quot;
 7360             &quot;movsd     $dst, $src\n&quot;
 7361     &quot;skip:&quot; %}
 7362   ins_encode %{
 7363     Label Lskip;
 7364     // Invert sense of branch from sense of CMOV
 7365     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7366     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7367     __ bind(Lskip);
 7368   %}
 7369   ins_pipe(pipe_slow);
 7370 %}
 7371 
 7372 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
 7373 %{
 7374   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7375 
 7376   ins_cost(200); // XXX
 7377   format %{ &quot;jn$cop    skip\t# unsigned cmove double\n\t&quot;
 7378             &quot;movsd     $dst, $src\n&quot;
 7379     &quot;skip:&quot; %}
 7380   ins_encode %{
 7381     Label Lskip;
 7382     // Invert sense of branch from sense of CMOV
 7383     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7384     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7385     __ bind(Lskip);
 7386   %}
 7387   ins_pipe(pipe_slow);
 7388 %}
 7389 
 7390 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
 7391   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7392   ins_cost(200);
 7393   expand %{
 7394     cmovD_regU(cop, cr, dst, src);
 7395   %}
 7396 %}
 7397 
 7398 //----------Arithmetic Instructions--------------------------------------------
 7399 //----------Addition Instructions----------------------------------------------
 7400 
 7401 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 7402 %{
 7403   match(Set dst (AddI dst src));
 7404   effect(KILL cr);
 7405 
 7406   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7407   opcode(0x03);
 7408   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 7409   ins_pipe(ialu_reg_reg);
 7410 %}
 7411 
 7412 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 7413 %{
 7414   match(Set dst (AddI dst src));
 7415   effect(KILL cr);
 7416 
 7417   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7418   opcode(0x81, 0x00); /* /0 id */
 7419   ins_encode(OpcSErm(dst, src), Con8or32(src));
 7420   ins_pipe( ialu_reg );
 7421 %}
 7422 
 7423 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 7424 %{
 7425   match(Set dst (AddI dst (LoadI src)));
 7426   effect(KILL cr);
 7427 
 7428   ins_cost(125); // XXX
 7429   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7430   opcode(0x03);
 7431   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 7432   ins_pipe(ialu_reg_mem);
 7433 %}
 7434 
 7435 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 7436 %{
 7437   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7438   effect(KILL cr);
 7439 
 7440   ins_cost(150); // XXX
 7441   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7442   opcode(0x01); /* Opcode 01 /r */
 7443   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 7444   ins_pipe(ialu_mem_reg);
 7445 %}
 7446 
 7447 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
 7448 %{
 7449   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7450   effect(KILL cr);
 7451 
 7452   ins_cost(125); // XXX
 7453   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7454   opcode(0x81); /* Opcode 81 /0 id */
 7455   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7456   ins_pipe(ialu_mem_imm);
 7457 %}
 7458 
 7459 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
 7460 %{
 7461   predicate(UseIncDec);
 7462   match(Set dst (AddI dst src));
 7463   effect(KILL cr);
 7464 
 7465   format %{ &quot;incl    $dst\t# int&quot; %}
 7466   opcode(0xFF, 0x00); // FF /0
 7467   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7468   ins_pipe(ialu_reg);
 7469 %}
 7470 
 7471 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
 7472 %{
 7473   predicate(UseIncDec);
 7474   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7475   effect(KILL cr);
 7476 
 7477   ins_cost(125); // XXX
 7478   format %{ &quot;incl    $dst\t# int&quot; %}
 7479   opcode(0xFF); /* Opcode FF /0 */
 7480   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
 7481   ins_pipe(ialu_mem_imm);
 7482 %}
 7483 
 7484 // XXX why does that use AddI
 7485 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
 7486 %{
 7487   predicate(UseIncDec);
 7488   match(Set dst (AddI dst src));
 7489   effect(KILL cr);
 7490 
 7491   format %{ &quot;decl    $dst\t# int&quot; %}
 7492   opcode(0xFF, 0x01); // FF /1
 7493   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7494   ins_pipe(ialu_reg);
 7495 %}
 7496 
 7497 // XXX why does that use AddI
 7498 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
 7499 %{
 7500   predicate(UseIncDec);
 7501   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7502   effect(KILL cr);
 7503 
 7504   ins_cost(125); // XXX
 7505   format %{ &quot;decl    $dst\t# int&quot; %}
 7506   opcode(0xFF); /* Opcode FF /1 */
 7507   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
 7508   ins_pipe(ialu_mem_imm);
 7509 %}
 7510 
 7511 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
 7512 %{
 7513   match(Set dst (AddI src0 src1));
 7514 
 7515   ins_cost(110);
 7516   format %{ &quot;addr32 leal $dst, [$src0 + $src1]\t# int&quot; %}
 7517   opcode(0x8D); /* 0x8D /r */
 7518   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7519   ins_pipe(ialu_reg_reg);
 7520 %}
 7521 
 7522 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 7523 %{
 7524   match(Set dst (AddL dst src));
 7525   effect(KILL cr);
 7526 
 7527   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7528   opcode(0x03);
 7529   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7530   ins_pipe(ialu_reg_reg);
 7531 %}
 7532 
 7533 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 7534 %{
 7535   match(Set dst (AddL dst src));
 7536   effect(KILL cr);
 7537 
 7538   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7539   opcode(0x81, 0x00); /* /0 id */
 7540   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7541   ins_pipe( ialu_reg );
 7542 %}
 7543 
 7544 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 7545 %{
 7546   match(Set dst (AddL dst (LoadL src)));
 7547   effect(KILL cr);
 7548 
 7549   ins_cost(125); // XXX
 7550   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7551   opcode(0x03);
 7552   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 7553   ins_pipe(ialu_reg_mem);
 7554 %}
 7555 
 7556 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 7557 %{
 7558   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7559   effect(KILL cr);
 7560 
 7561   ins_cost(150); // XXX
 7562   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7563   opcode(0x01); /* Opcode 01 /r */
 7564   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 7565   ins_pipe(ialu_mem_reg);
 7566 %}
 7567 
 7568 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 7569 %{
 7570   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7571   effect(KILL cr);
 7572 
 7573   ins_cost(125); // XXX
 7574   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7575   opcode(0x81); /* Opcode 81 /0 id */
 7576   ins_encode(REX_mem_wide(dst),
 7577              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7578   ins_pipe(ialu_mem_imm);
 7579 %}
 7580 
 7581 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
 7582 %{
 7583   predicate(UseIncDec);
 7584   match(Set dst (AddL dst src));
 7585   effect(KILL cr);
 7586 
 7587   format %{ &quot;incq    $dst\t# long&quot; %}
 7588   opcode(0xFF, 0x00); // FF /0
 7589   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7590   ins_pipe(ialu_reg);
 7591 %}
 7592 
 7593 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
 7594 %{
 7595   predicate(UseIncDec);
 7596   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7597   effect(KILL cr);
 7598 
 7599   ins_cost(125); // XXX
 7600   format %{ &quot;incq    $dst\t# long&quot; %}
 7601   opcode(0xFF); /* Opcode FF /0 */
 7602   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
 7603   ins_pipe(ialu_mem_imm);
 7604 %}
 7605 
 7606 // XXX why does that use AddL
 7607 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
 7608 %{
 7609   predicate(UseIncDec);
 7610   match(Set dst (AddL dst src));
 7611   effect(KILL cr);
 7612 
 7613   format %{ &quot;decq    $dst\t# long&quot; %}
 7614   opcode(0xFF, 0x01); // FF /1
 7615   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7616   ins_pipe(ialu_reg);
 7617 %}
 7618 
 7619 // XXX why does that use AddL
 7620 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
 7621 %{
 7622   predicate(UseIncDec);
 7623   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7624   effect(KILL cr);
 7625 
 7626   ins_cost(125); // XXX
 7627   format %{ &quot;decq    $dst\t# long&quot; %}
 7628   opcode(0xFF); /* Opcode FF /1 */
 7629   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
 7630   ins_pipe(ialu_mem_imm);
 7631 %}
 7632 
 7633 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
 7634 %{
 7635   match(Set dst (AddL src0 src1));
 7636 
 7637   ins_cost(110);
 7638   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# long&quot; %}
 7639   opcode(0x8D); /* 0x8D /r */
 7640   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7641   ins_pipe(ialu_reg_reg);
 7642 %}
 7643 
 7644 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
 7645 %{
 7646   match(Set dst (AddP dst src));
 7647   effect(KILL cr);
 7648 
 7649   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7650   opcode(0x03);
 7651   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7652   ins_pipe(ialu_reg_reg);
 7653 %}
 7654 
 7655 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
 7656 %{
 7657   match(Set dst (AddP dst src));
 7658   effect(KILL cr);
 7659 
 7660   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7661   opcode(0x81, 0x00); /* /0 id */
 7662   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7663   ins_pipe( ialu_reg );
 7664 %}
 7665 
 7666 // XXX addP mem ops ????
 7667 
 7668 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
 7669 %{
 7670   match(Set dst (AddP src0 src1));
 7671 
 7672   ins_cost(110);
 7673   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# ptr&quot; %}
 7674   opcode(0x8D); /* 0x8D /r */
 7675   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
 7676   ins_pipe(ialu_reg_reg);
 7677 %}
 7678 
 7679 instruct checkCastPP(rRegP dst)
 7680 %{
 7681   match(Set dst (CheckCastPP dst));
 7682 
 7683   size(0);
 7684   format %{ &quot;# checkcastPP of $dst&quot; %}
 7685   ins_encode(/* empty encoding */);
 7686   ins_pipe(empty);
 7687 %}
 7688 
 7689 instruct castPP(rRegP dst)
 7690 %{
 7691   match(Set dst (CastPP dst));
 7692 
 7693   size(0);
 7694   format %{ &quot;# castPP of $dst&quot; %}
 7695   ins_encode(/* empty encoding */);
 7696   ins_pipe(empty);
 7697 %}
 7698 
 7699 instruct castII(rRegI dst)
 7700 %{
 7701   match(Set dst (CastII dst));
 7702 
 7703   size(0);
 7704   format %{ &quot;# castII of $dst&quot; %}
 7705   ins_encode(/* empty encoding */);
 7706   ins_cost(0);
 7707   ins_pipe(empty);
 7708 %}
 7709 
<a name="52" id="anc52"></a>










 7710 // LoadP-locked same as a regular LoadP when used with compare-swap
 7711 instruct loadPLocked(rRegP dst, memory mem)
 7712 %{
 7713   match(Set dst (LoadPLocked mem));
 7714 
 7715   ins_cost(125); // XXX
 7716   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7717   opcode(0x8B);
 7718   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7719   ins_pipe(ialu_reg_mem); // XXX
 7720 %}
 7721 
 7722 // Conditional-store of the updated heap-top.
 7723 // Used during allocation of the shared heap.
 7724 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7725 
 7726 instruct storePConditional(memory heap_top_ptr,
 7727                            rax_RegP oldval, rRegP newval,
 7728                            rFlagsReg cr)
 7729 %{
<a name="53" id="anc53"></a>
 7730   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7731 
 7732   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7733             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7734   opcode(0x0F, 0xB1);
 7735   ins_encode(lock_prefix,
 7736              REX_reg_mem_wide(newval, heap_top_ptr),
 7737              OpcP, OpcS,
 7738              reg_mem(newval, heap_top_ptr));
 7739   ins_pipe(pipe_cmpxchg);
 7740 %}
 7741 
 7742 // Conditional-store of an int value.
 7743 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7744 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7745 %{
 7746   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7747   effect(KILL oldval);
 7748 
 7749   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7750   opcode(0x0F, 0xB1);
 7751   ins_encode(lock_prefix,
 7752              REX_reg_mem(newval, mem),
 7753              OpcP, OpcS,
 7754              reg_mem(newval, mem));
 7755   ins_pipe(pipe_cmpxchg);
 7756 %}
 7757 
 7758 // Conditional-store of a long value.
 7759 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7760 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
 7761 %{
 7762   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7763   effect(KILL oldval);
 7764 
 7765   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7766   opcode(0x0F, 0xB1);
 7767   ins_encode(lock_prefix,
 7768              REX_reg_mem_wide(newval, mem),
 7769              OpcP, OpcS,
 7770              reg_mem(newval, mem));
 7771   ins_pipe(pipe_cmpxchg);
 7772 %}
 7773 
 7774 
 7775 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7776 instruct compareAndSwapP(rRegI res,
 7777                          memory mem_ptr,
 7778                          rax_RegP oldval, rRegP newval,
 7779                          rFlagsReg cr)
 7780 %{
<a name="54" id="anc54"></a><span class="line-modified"> 7781   predicate(VM_Version::supports_cx8());</span>
 7782   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7783   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7784   effect(KILL cr, KILL oldval);
 7785 
 7786   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7787             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7788             &quot;sete    $res\n\t&quot;
 7789             &quot;movzbl  $res, $res&quot; %}
 7790   opcode(0x0F, 0xB1);
 7791   ins_encode(lock_prefix,
 7792              REX_reg_mem_wide(newval, mem_ptr),
 7793              OpcP, OpcS,
 7794              reg_mem(newval, mem_ptr),
 7795              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7796              REX_reg_breg(res, res), // movzbl
 7797              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7798   ins_pipe( pipe_cmpxchg );
 7799 %}
 7800 
 7801 instruct compareAndSwapL(rRegI res,
 7802                          memory mem_ptr,
 7803                          rax_RegL oldval, rRegL newval,
 7804                          rFlagsReg cr)
 7805 %{
 7806   predicate(VM_Version::supports_cx8());
 7807   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7808   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7809   effect(KILL cr, KILL oldval);
 7810 
 7811   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7812             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7813             &quot;sete    $res\n\t&quot;
 7814             &quot;movzbl  $res, $res&quot; %}
 7815   opcode(0x0F, 0xB1);
 7816   ins_encode(lock_prefix,
 7817              REX_reg_mem_wide(newval, mem_ptr),
 7818              OpcP, OpcS,
 7819              reg_mem(newval, mem_ptr),
 7820              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7821              REX_reg_breg(res, res), // movzbl
 7822              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7823   ins_pipe( pipe_cmpxchg );
 7824 %}
 7825 
 7826 instruct compareAndSwapI(rRegI res,
 7827                          memory mem_ptr,
 7828                          rax_RegI oldval, rRegI newval,
 7829                          rFlagsReg cr)
 7830 %{
 7831   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7832   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7833   effect(KILL cr, KILL oldval);
 7834 
 7835   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7836             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7837             &quot;sete    $res\n\t&quot;
 7838             &quot;movzbl  $res, $res&quot; %}
 7839   opcode(0x0F, 0xB1);
 7840   ins_encode(lock_prefix,
 7841              REX_reg_mem(newval, mem_ptr),
 7842              OpcP, OpcS,
 7843              reg_mem(newval, mem_ptr),
 7844              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7845              REX_reg_breg(res, res), // movzbl
 7846              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7847   ins_pipe( pipe_cmpxchg );
 7848 %}
 7849 
 7850 instruct compareAndSwapB(rRegI res,
 7851                          memory mem_ptr,
 7852                          rax_RegI oldval, rRegI newval,
 7853                          rFlagsReg cr)
 7854 %{
 7855   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7856   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7857   effect(KILL cr, KILL oldval);
 7858 
 7859   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7860             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7861             &quot;sete    $res\n\t&quot;
 7862             &quot;movzbl  $res, $res&quot; %}
 7863   opcode(0x0F, 0xB0);
 7864   ins_encode(lock_prefix,
 7865              REX_breg_mem(newval, mem_ptr),
 7866              OpcP, OpcS,
 7867              reg_mem(newval, mem_ptr),
 7868              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7869              REX_reg_breg(res, res), // movzbl
 7870              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7871   ins_pipe( pipe_cmpxchg );
 7872 %}
 7873 
 7874 instruct compareAndSwapS(rRegI res,
 7875                          memory mem_ptr,
 7876                          rax_RegI oldval, rRegI newval,
 7877                          rFlagsReg cr)
 7878 %{
 7879   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7880   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7881   effect(KILL cr, KILL oldval);
 7882 
 7883   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7884             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7885             &quot;sete    $res\n\t&quot;
 7886             &quot;movzbl  $res, $res&quot; %}
 7887   opcode(0x0F, 0xB1);
 7888   ins_encode(lock_prefix,
 7889              SizePrefix,
 7890              REX_reg_mem(newval, mem_ptr),
 7891              OpcP, OpcS,
 7892              reg_mem(newval, mem_ptr),
 7893              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7894              REX_reg_breg(res, res), // movzbl
 7895              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7896   ins_pipe( pipe_cmpxchg );
 7897 %}
 7898 
 7899 instruct compareAndSwapN(rRegI res,
 7900                           memory mem_ptr,
 7901                           rax_RegN oldval, rRegN newval,
 7902                           rFlagsReg cr) %{
 7903   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7904   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7905   effect(KILL cr, KILL oldval);
 7906 
 7907   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7908             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7909             &quot;sete    $res\n\t&quot;
 7910             &quot;movzbl  $res, $res&quot; %}
 7911   opcode(0x0F, 0xB1);
 7912   ins_encode(lock_prefix,
 7913              REX_reg_mem(newval, mem_ptr),
 7914              OpcP, OpcS,
 7915              reg_mem(newval, mem_ptr),
 7916              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7917              REX_reg_breg(res, res), // movzbl
 7918              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7919   ins_pipe( pipe_cmpxchg );
 7920 %}
 7921 
 7922 instruct compareAndExchangeB(
 7923                          memory mem_ptr,
 7924                          rax_RegI oldval, rRegI newval,
 7925                          rFlagsReg cr)
 7926 %{
 7927   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7928   effect(KILL cr);
 7929 
 7930   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7931             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7932   opcode(0x0F, 0xB0);
 7933   ins_encode(lock_prefix,
 7934              REX_breg_mem(newval, mem_ptr),
 7935              OpcP, OpcS,
 7936              reg_mem(newval, mem_ptr) // lock cmpxchg
 7937              );
 7938   ins_pipe( pipe_cmpxchg );
 7939 %}
 7940 
 7941 instruct compareAndExchangeS(
 7942                          memory mem_ptr,
 7943                          rax_RegI oldval, rRegI newval,
 7944                          rFlagsReg cr)
 7945 %{
 7946   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7947   effect(KILL cr);
 7948 
 7949   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7950             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7951   opcode(0x0F, 0xB1);
 7952   ins_encode(lock_prefix,
 7953              SizePrefix,
 7954              REX_reg_mem(newval, mem_ptr),
 7955              OpcP, OpcS,
 7956              reg_mem(newval, mem_ptr) // lock cmpxchg
 7957              );
 7958   ins_pipe( pipe_cmpxchg );
 7959 %}
 7960 
 7961 instruct compareAndExchangeI(
 7962                          memory mem_ptr,
 7963                          rax_RegI oldval, rRegI newval,
 7964                          rFlagsReg cr)
 7965 %{
 7966   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7967   effect(KILL cr);
 7968 
 7969   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7970             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7971   opcode(0x0F, 0xB1);
 7972   ins_encode(lock_prefix,
 7973              REX_reg_mem(newval, mem_ptr),
 7974              OpcP, OpcS,
 7975              reg_mem(newval, mem_ptr) // lock cmpxchg
 7976              );
 7977   ins_pipe( pipe_cmpxchg );
 7978 %}
 7979 
 7980 instruct compareAndExchangeL(
 7981                          memory mem_ptr,
 7982                          rax_RegL oldval, rRegL newval,
 7983                          rFlagsReg cr)
 7984 %{
 7985   predicate(VM_Version::supports_cx8());
 7986   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7987   effect(KILL cr);
 7988 
 7989   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7990             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7991   opcode(0x0F, 0xB1);
 7992   ins_encode(lock_prefix,
 7993              REX_reg_mem_wide(newval, mem_ptr),
 7994              OpcP, OpcS,
 7995              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7996             );
 7997   ins_pipe( pipe_cmpxchg );
 7998 %}
 7999 
 8000 instruct compareAndExchangeN(
 8001                           memory mem_ptr,
 8002                           rax_RegN oldval, rRegN newval,
 8003                           rFlagsReg cr) %{
 8004   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 8005   effect(KILL cr);
 8006 
 8007   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 8008             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 8009   opcode(0x0F, 0xB1);
 8010   ins_encode(lock_prefix,
 8011              REX_reg_mem(newval, mem_ptr),
 8012              OpcP, OpcS,
 8013              reg_mem(newval, mem_ptr)  // lock cmpxchg
 8014           );
 8015   ins_pipe( pipe_cmpxchg );
 8016 %}
 8017 
 8018 instruct compareAndExchangeP(
 8019                          memory mem_ptr,
 8020                          rax_RegP oldval, rRegP newval,
 8021                          rFlagsReg cr)
 8022 %{
<a name="55" id="anc55"></a><span class="line-modified"> 8023   predicate(VM_Version::supports_cx8());</span>
 8024   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 8025   effect(KILL cr);
 8026 
 8027   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 8028             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 8029   opcode(0x0F, 0xB1);
 8030   ins_encode(lock_prefix,
 8031              REX_reg_mem_wide(newval, mem_ptr),
 8032              OpcP, OpcS,
 8033              reg_mem(newval, mem_ptr)  // lock cmpxchg
 8034           );
 8035   ins_pipe( pipe_cmpxchg );
 8036 %}
 8037 
 8038 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 8039   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 8040   match(Set dummy (GetAndAddB mem add));
 8041   effect(KILL cr);
 8042   format %{ &quot;ADDB  [$mem],$add&quot; %}
 8043   ins_encode %{
 8044     __ lock();
 8045     __ addb($mem$$Address, $add$$constant);
 8046   %}
 8047   ins_pipe( pipe_cmpxchg );
 8048 %}
 8049 
 8050 instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{
 8051   match(Set newval (GetAndAddB mem newval));
 8052   effect(KILL cr);
 8053   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 8054   ins_encode %{
 8055     __ lock();
 8056     __ xaddb($mem$$Address, $newval$$Register);
 8057   %}
 8058   ins_pipe( pipe_cmpxchg );
 8059 %}
 8060 
 8061 instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 8062   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 8063   match(Set dummy (GetAndAddS mem add));
 8064   effect(KILL cr);
 8065   format %{ &quot;ADDW  [$mem],$add&quot; %}
 8066   ins_encode %{
 8067     __ lock();
 8068     __ addw($mem$$Address, $add$$constant);
 8069   %}
 8070   ins_pipe( pipe_cmpxchg );
 8071 %}
 8072 
 8073 instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{
 8074   match(Set newval (GetAndAddS mem newval));
 8075   effect(KILL cr);
 8076   format %{ &quot;XADDW  [$mem],$newval&quot; %}
 8077   ins_encode %{
 8078     __ lock();
 8079     __ xaddw($mem$$Address, $newval$$Register);
 8080   %}
 8081   ins_pipe( pipe_cmpxchg );
 8082 %}
 8083 
 8084 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 8085   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 8086   match(Set dummy (GetAndAddI mem add));
 8087   effect(KILL cr);
 8088   format %{ &quot;ADDL  [$mem],$add&quot; %}
 8089   ins_encode %{
 8090     __ lock();
 8091     __ addl($mem$$Address, $add$$constant);
 8092   %}
 8093   ins_pipe( pipe_cmpxchg );
 8094 %}
 8095 
 8096 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
 8097   match(Set newval (GetAndAddI mem newval));
 8098   effect(KILL cr);
 8099   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 8100   ins_encode %{
 8101     __ lock();
 8102     __ xaddl($mem$$Address, $newval$$Register);
 8103   %}
 8104   ins_pipe( pipe_cmpxchg );
 8105 %}
 8106 
 8107 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
 8108   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 8109   match(Set dummy (GetAndAddL mem add));
 8110   effect(KILL cr);
 8111   format %{ &quot;ADDQ  [$mem],$add&quot; %}
 8112   ins_encode %{
 8113     __ lock();
 8114     __ addq($mem$$Address, $add$$constant);
 8115   %}
 8116   ins_pipe( pipe_cmpxchg );
 8117 %}
 8118 
 8119 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
 8120   match(Set newval (GetAndAddL mem newval));
 8121   effect(KILL cr);
 8122   format %{ &quot;XADDQ  [$mem],$newval&quot; %}
 8123   ins_encode %{
 8124     __ lock();
 8125     __ xaddq($mem$$Address, $newval$$Register);
 8126   %}
 8127   ins_pipe( pipe_cmpxchg );
 8128 %}
 8129 
 8130 instruct xchgB( memory mem, rRegI newval) %{
 8131   match(Set newval (GetAndSetB mem newval));
 8132   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 8133   ins_encode %{
 8134     __ xchgb($newval$$Register, $mem$$Address);
 8135   %}
 8136   ins_pipe( pipe_cmpxchg );
 8137 %}
 8138 
 8139 instruct xchgS( memory mem, rRegI newval) %{
 8140   match(Set newval (GetAndSetS mem newval));
 8141   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 8142   ins_encode %{
 8143     __ xchgw($newval$$Register, $mem$$Address);
 8144   %}
 8145   ins_pipe( pipe_cmpxchg );
 8146 %}
 8147 
 8148 instruct xchgI( memory mem, rRegI newval) %{
 8149   match(Set newval (GetAndSetI mem newval));
 8150   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 8151   ins_encode %{
 8152     __ xchgl($newval$$Register, $mem$$Address);
 8153   %}
 8154   ins_pipe( pipe_cmpxchg );
 8155 %}
 8156 
 8157 instruct xchgL( memory mem, rRegL newval) %{
 8158   match(Set newval (GetAndSetL mem newval));
 8159   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 8160   ins_encode %{
 8161     __ xchgq($newval$$Register, $mem$$Address);
 8162   %}
 8163   ins_pipe( pipe_cmpxchg );
 8164 %}
 8165 
 8166 instruct xchgP( memory mem, rRegP newval) %{
 8167   match(Set newval (GetAndSetP mem newval));
<a name="56" id="anc56"></a>
 8168   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 8169   ins_encode %{
 8170     __ xchgq($newval$$Register, $mem$$Address);
 8171   %}
 8172   ins_pipe( pipe_cmpxchg );
 8173 %}
 8174 
 8175 instruct xchgN( memory mem, rRegN newval) %{
 8176   match(Set newval (GetAndSetN mem newval));
 8177   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 8178   ins_encode %{
 8179     __ xchgl($newval$$Register, $mem$$Address);
 8180   %}
 8181   ins_pipe( pipe_cmpxchg );
 8182 %}
 8183 
<a name="57" id="anc57"></a>













































 8184 //----------Subtraction Instructions-------------------------------------------
 8185 
 8186 // Integer Subtraction Instructions
 8187 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8188 %{
 8189   match(Set dst (SubI dst src));
 8190   effect(KILL cr);
 8191 
 8192   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8193   opcode(0x2B);
 8194   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8195   ins_pipe(ialu_reg_reg);
 8196 %}
 8197 
 8198 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8199 %{
 8200   match(Set dst (SubI dst src));
 8201   effect(KILL cr);
 8202 
 8203   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8204   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8205   ins_encode(OpcSErm(dst, src), Con8or32(src));
 8206   ins_pipe(ialu_reg);
 8207 %}
 8208 
 8209 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 8210 %{
 8211   match(Set dst (SubI dst (LoadI src)));
 8212   effect(KILL cr);
 8213 
 8214   ins_cost(125);
 8215   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8216   opcode(0x2B);
 8217   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 8218   ins_pipe(ialu_reg_mem);
 8219 %}
 8220 
 8221 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 8222 %{
 8223   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8224   effect(KILL cr);
 8225 
 8226   ins_cost(150);
 8227   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8228   opcode(0x29); /* Opcode 29 /r */
 8229   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 8230   ins_pipe(ialu_mem_reg);
 8231 %}
 8232 
 8233 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
 8234 %{
 8235   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8236   effect(KILL cr);
 8237 
 8238   ins_cost(125); // XXX
 8239   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8240   opcode(0x81); /* Opcode 81 /5 id */
 8241   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8242   ins_pipe(ialu_mem_imm);
 8243 %}
 8244 
 8245 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8246 %{
 8247   match(Set dst (SubL dst src));
 8248   effect(KILL cr);
 8249 
 8250   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8251   opcode(0x2B);
 8252   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8253   ins_pipe(ialu_reg_reg);
 8254 %}
 8255 
 8256 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
 8257 %{
 8258   match(Set dst (SubL dst src));
 8259   effect(KILL cr);
 8260 
 8261   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8262   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8263   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 8264   ins_pipe(ialu_reg);
 8265 %}
 8266 
 8267 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 8268 %{
 8269   match(Set dst (SubL dst (LoadL src)));
 8270   effect(KILL cr);
 8271 
 8272   ins_cost(125);
 8273   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8274   opcode(0x2B);
 8275   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 8276   ins_pipe(ialu_reg_mem);
 8277 %}
 8278 
 8279 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 8280 %{
 8281   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8282   effect(KILL cr);
 8283 
 8284   ins_cost(150);
 8285   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8286   opcode(0x29); /* Opcode 29 /r */
 8287   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 8288   ins_pipe(ialu_mem_reg);
 8289 %}
 8290 
 8291 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 8292 %{
 8293   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8294   effect(KILL cr);
 8295 
 8296   ins_cost(125); // XXX
 8297   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8298   opcode(0x81); /* Opcode 81 /5 id */
 8299   ins_encode(REX_mem_wide(dst),
 8300              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8301   ins_pipe(ialu_mem_imm);
 8302 %}
 8303 
 8304 // Subtract from a pointer
 8305 // XXX hmpf???
 8306 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
 8307 %{
 8308   match(Set dst (AddP dst (SubI zero src)));
 8309   effect(KILL cr);
 8310 
 8311   format %{ &quot;subq    $dst, $src\t# ptr - int&quot; %}
 8312   opcode(0x2B);
 8313   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8314   ins_pipe(ialu_reg_reg);
 8315 %}
 8316 
 8317 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
 8318 %{
 8319   match(Set dst (SubI zero dst));
 8320   effect(KILL cr);
 8321 
 8322   format %{ &quot;negl    $dst\t# int&quot; %}
 8323   opcode(0xF7, 0x03);  // Opcode F7 /3
 8324   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8325   ins_pipe(ialu_reg);
 8326 %}
 8327 
 8328 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
 8329 %{
 8330   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
 8331   effect(KILL cr);
 8332 
 8333   format %{ &quot;negl    $dst\t# int&quot; %}
 8334   opcode(0xF7, 0x03);  // Opcode F7 /3
 8335   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8336   ins_pipe(ialu_reg);
 8337 %}
 8338 
 8339 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
 8340 %{
 8341   match(Set dst (SubL zero dst));
 8342   effect(KILL cr);
 8343 
 8344   format %{ &quot;negq    $dst\t# long&quot; %}
 8345   opcode(0xF7, 0x03);  // Opcode F7 /3
 8346   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8347   ins_pipe(ialu_reg);
 8348 %}
 8349 
 8350 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
 8351 %{
 8352   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
 8353   effect(KILL cr);
 8354 
 8355   format %{ &quot;negq    $dst\t# long&quot; %}
 8356   opcode(0xF7, 0x03);  // Opcode F7 /3
 8357   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8358   ins_pipe(ialu_reg);
 8359 %}
 8360 
 8361 //----------Multiplication/Division Instructions-------------------------------
 8362 // Integer Multiplication Instructions
 8363 // Multiply Register
 8364 
 8365 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8366 %{
 8367   match(Set dst (MulI dst src));
 8368   effect(KILL cr);
 8369 
 8370   ins_cost(300);
 8371   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8372   opcode(0x0F, 0xAF);
 8373   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8374   ins_pipe(ialu_reg_reg_alu0);
 8375 %}
 8376 
 8377 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
 8378 %{
 8379   match(Set dst (MulI src imm));
 8380   effect(KILL cr);
 8381 
 8382   ins_cost(300);
 8383   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8384   opcode(0x69); /* 69 /r id */
 8385   ins_encode(REX_reg_reg(dst, src),
 8386              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8387   ins_pipe(ialu_reg_reg_alu0);
 8388 %}
 8389 
 8390 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
 8391 %{
 8392   match(Set dst (MulI dst (LoadI src)));
 8393   effect(KILL cr);
 8394 
 8395   ins_cost(350);
 8396   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8397   opcode(0x0F, 0xAF);
 8398   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8399   ins_pipe(ialu_reg_mem_alu0);
 8400 %}
 8401 
 8402 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
 8403 %{
 8404   match(Set dst (MulI (LoadI src) imm));
 8405   effect(KILL cr);
 8406 
 8407   ins_cost(300);
 8408   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8409   opcode(0x69); /* 69 /r id */
 8410   ins_encode(REX_reg_mem(dst, src),
 8411              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8412   ins_pipe(ialu_reg_mem_alu0);
 8413 %}
 8414 
 8415 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)
 8416 %{
 8417   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 8418   effect(KILL cr, KILL src2);
 8419 
 8420   expand %{ mulI_rReg(dst, src1, cr);
 8421            mulI_rReg(src2, src3, cr);
 8422            addI_rReg(dst, src2, cr); %}
 8423 %}
 8424 
 8425 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8426 %{
 8427   match(Set dst (MulL dst src));
 8428   effect(KILL cr);
 8429 
 8430   ins_cost(300);
 8431   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8432   opcode(0x0F, 0xAF);
 8433   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8434   ins_pipe(ialu_reg_reg_alu0);
 8435 %}
 8436 
 8437 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
 8438 %{
 8439   match(Set dst (MulL src imm));
 8440   effect(KILL cr);
 8441 
 8442   ins_cost(300);
 8443   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8444   opcode(0x69); /* 69 /r id */
 8445   ins_encode(REX_reg_reg_wide(dst, src),
 8446              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8447   ins_pipe(ialu_reg_reg_alu0);
 8448 %}
 8449 
 8450 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
 8451 %{
 8452   match(Set dst (MulL dst (LoadL src)));
 8453   effect(KILL cr);
 8454 
 8455   ins_cost(350);
 8456   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8457   opcode(0x0F, 0xAF);
 8458   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8459   ins_pipe(ialu_reg_mem_alu0);
 8460 %}
 8461 
 8462 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
 8463 %{
 8464   match(Set dst (MulL (LoadL src) imm));
 8465   effect(KILL cr);
 8466 
 8467   ins_cost(300);
 8468   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8469   opcode(0x69); /* 69 /r id */
 8470   ins_encode(REX_reg_mem_wide(dst, src),
 8471              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8472   ins_pipe(ialu_reg_mem_alu0);
 8473 %}
 8474 
 8475 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8476 %{
 8477   match(Set dst (MulHiL src rax));
 8478   effect(USE_KILL rax, KILL cr);
 8479 
 8480   ins_cost(300);
 8481   format %{ &quot;imulq   RDX:RAX, RAX, $src\t# mulhi&quot; %}
 8482   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8483   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8484   ins_pipe(ialu_reg_reg_alu0);
 8485 %}
 8486 
 8487 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8488                    rFlagsReg cr)
 8489 %{
 8490   match(Set rax (DivI rax div));
 8491   effect(KILL rdx, KILL cr);
 8492 
 8493   ins_cost(30*100+10*100); // XXX
 8494   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8495             &quot;jne,s   normal\n\t&quot;
 8496             &quot;xorl    rdx, rdx\n\t&quot;
 8497             &quot;cmpl    $div, -1\n\t&quot;
 8498             &quot;je,s    done\n&quot;
 8499     &quot;normal: cdql\n\t&quot;
 8500             &quot;idivl   $div\n&quot;
 8501     &quot;done:&quot;        %}
 8502   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8503   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8504   ins_pipe(ialu_reg_reg_alu0);
 8505 %}
 8506 
 8507 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8508                    rFlagsReg cr)
 8509 %{
 8510   match(Set rax (DivL rax div));
 8511   effect(KILL rdx, KILL cr);
 8512 
 8513   ins_cost(30*100+10*100); // XXX
 8514   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8515             &quot;cmpq    rax, rdx\n\t&quot;
 8516             &quot;jne,s   normal\n\t&quot;
 8517             &quot;xorl    rdx, rdx\n\t&quot;
 8518             &quot;cmpq    $div, -1\n\t&quot;
 8519             &quot;je,s    done\n&quot;
 8520     &quot;normal: cdqq\n\t&quot;
 8521             &quot;idivq   $div\n&quot;
 8522     &quot;done:&quot;        %}
 8523   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8524   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8525   ins_pipe(ialu_reg_reg_alu0);
 8526 %}
 8527 
 8528 // Integer DIVMOD with Register, both quotient and mod results
 8529 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8530                              rFlagsReg cr)
 8531 %{
 8532   match(DivModI rax div);
 8533   effect(KILL cr);
 8534 
 8535   ins_cost(30*100+10*100); // XXX
 8536   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8537             &quot;jne,s   normal\n\t&quot;
 8538             &quot;xorl    rdx, rdx\n\t&quot;
 8539             &quot;cmpl    $div, -1\n\t&quot;
 8540             &quot;je,s    done\n&quot;
 8541     &quot;normal: cdql\n\t&quot;
 8542             &quot;idivl   $div\n&quot;
 8543     &quot;done:&quot;        %}
 8544   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8545   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8546   ins_pipe(pipe_slow);
 8547 %}
 8548 
 8549 // Long DIVMOD with Register, both quotient and mod results
 8550 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8551                              rFlagsReg cr)
 8552 %{
 8553   match(DivModL rax div);
 8554   effect(KILL cr);
 8555 
 8556   ins_cost(30*100+10*100); // XXX
 8557   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8558             &quot;cmpq    rax, rdx\n\t&quot;
 8559             &quot;jne,s   normal\n\t&quot;
 8560             &quot;xorl    rdx, rdx\n\t&quot;
 8561             &quot;cmpq    $div, -1\n\t&quot;
 8562             &quot;je,s    done\n&quot;
 8563     &quot;normal: cdqq\n\t&quot;
 8564             &quot;idivq   $div\n&quot;
 8565     &quot;done:&quot;        %}
 8566   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8567   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8568   ins_pipe(pipe_slow);
 8569 %}
 8570 
 8571 //----------- DivL-By-Constant-Expansions--------------------------------------
 8572 // DivI cases are handled by the compiler
 8573 
 8574 // Magic constant, reciprocal of 10
 8575 instruct loadConL_0x6666666666666667(rRegL dst)
 8576 %{
 8577   effect(DEF dst);
 8578 
 8579   format %{ &quot;movq    $dst, #0x666666666666667\t# Used in div-by-10&quot; %}
 8580   ins_encode(load_immL(dst, 0x6666666666666667));
 8581   ins_pipe(ialu_reg);
 8582 %}
 8583 
 8584 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8585 %{
 8586   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
 8587 
 8588   format %{ &quot;imulq   rdx:rax, rax, $src\t# Used in div-by-10&quot; %}
 8589   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8590   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8591   ins_pipe(ialu_reg_reg_alu0);
 8592 %}
 8593 
 8594 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
 8595 %{
 8596   effect(USE_DEF dst, KILL cr);
 8597 
 8598   format %{ &quot;sarq    $dst, #63\t# Used in div-by-10&quot; %}
 8599   opcode(0xC1, 0x7); /* C1 /7 ib */
 8600   ins_encode(reg_opc_imm_wide(dst, 0x3F));
 8601   ins_pipe(ialu_reg);
 8602 %}
 8603 
 8604 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
 8605 %{
 8606   effect(USE_DEF dst, KILL cr);
 8607 
 8608   format %{ &quot;sarq    $dst, #2\t# Used in div-by-10&quot; %}
 8609   opcode(0xC1, 0x7); /* C1 /7 ib */
 8610   ins_encode(reg_opc_imm_wide(dst, 0x2));
 8611   ins_pipe(ialu_reg);
 8612 %}
 8613 
 8614 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
 8615 %{
 8616   match(Set dst (DivL src div));
 8617 
 8618   ins_cost((5+8)*100);
 8619   expand %{
 8620     rax_RegL rax;                     // Killed temp
 8621     rFlagsReg cr;                     // Killed
 8622     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
 8623     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
 8624     sarL_rReg_63(src, cr);            // sarq  src, 63
 8625     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
 8626     subL_rReg(dst, src, cr);          // subl  rdx, src
 8627   %}
 8628 %}
 8629 
 8630 //-----------------------------------------------------------------------------
 8631 
 8632 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
 8633                    rFlagsReg cr)
 8634 %{
 8635   match(Set rdx (ModI rax div));
 8636   effect(KILL rax, KILL cr);
 8637 
 8638   ins_cost(300); // XXX
 8639   format %{ &quot;cmpl    rax, 0x80000000\t# irem\n\t&quot;
 8640             &quot;jne,s   normal\n\t&quot;
 8641             &quot;xorl    rdx, rdx\n\t&quot;
 8642             &quot;cmpl    $div, -1\n\t&quot;
 8643             &quot;je,s    done\n&quot;
 8644     &quot;normal: cdql\n\t&quot;
 8645             &quot;idivl   $div\n&quot;
 8646     &quot;done:&quot;        %}
 8647   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8648   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8649   ins_pipe(ialu_reg_reg_alu0);
 8650 %}
 8651 
 8652 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
 8653                    rFlagsReg cr)
 8654 %{
 8655   match(Set rdx (ModL rax div));
 8656   effect(KILL rax, KILL cr);
 8657 
 8658   ins_cost(300); // XXX
 8659   format %{ &quot;movq    rdx, 0x8000000000000000\t# lrem\n\t&quot;
 8660             &quot;cmpq    rax, rdx\n\t&quot;
 8661             &quot;jne,s   normal\n\t&quot;
 8662             &quot;xorl    rdx, rdx\n\t&quot;
 8663             &quot;cmpq    $div, -1\n\t&quot;
 8664             &quot;je,s    done\n&quot;
 8665     &quot;normal: cdqq\n\t&quot;
 8666             &quot;idivq   $div\n&quot;
 8667     &quot;done:&quot;        %}
 8668   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8669   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8670   ins_pipe(ialu_reg_reg_alu0);
 8671 %}
 8672 
 8673 // Integer Shift Instructions
 8674 // Shift Left by one
 8675 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8676 %{
 8677   match(Set dst (LShiftI dst shift));
 8678   effect(KILL cr);
 8679 
 8680   format %{ &quot;sall    $dst, $shift&quot; %}
 8681   opcode(0xD1, 0x4); /* D1 /4 */
 8682   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8683   ins_pipe(ialu_reg);
 8684 %}
 8685 
 8686 // Shift Left by one
 8687 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8688 %{
 8689   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8690   effect(KILL cr);
 8691 
 8692   format %{ &quot;sall    $dst, $shift\t&quot; %}
 8693   opcode(0xD1, 0x4); /* D1 /4 */
 8694   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8695   ins_pipe(ialu_mem_imm);
 8696 %}
 8697 
 8698 // Shift Left by 8-bit immediate
 8699 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8700 %{
 8701   match(Set dst (LShiftI dst shift));
 8702   effect(KILL cr);
 8703 
 8704   format %{ &quot;sall    $dst, $shift&quot; %}
 8705   opcode(0xC1, 0x4); /* C1 /4 ib */
 8706   ins_encode(reg_opc_imm(dst, shift));
 8707   ins_pipe(ialu_reg);
 8708 %}
 8709 
 8710 // Shift Left by 8-bit immediate
 8711 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8712 %{
 8713   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8714   effect(KILL cr);
 8715 
 8716   format %{ &quot;sall    $dst, $shift&quot; %}
 8717   opcode(0xC1, 0x4); /* C1 /4 ib */
 8718   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8719   ins_pipe(ialu_mem_imm);
 8720 %}
 8721 
 8722 // Shift Left by variable
 8723 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8724 %{
 8725   match(Set dst (LShiftI dst shift));
 8726   effect(KILL cr);
 8727 
 8728   format %{ &quot;sall    $dst, $shift&quot; %}
 8729   opcode(0xD3, 0x4); /* D3 /4 */
 8730   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8731   ins_pipe(ialu_reg_reg);
 8732 %}
 8733 
 8734 // Shift Left by variable
 8735 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8736 %{
 8737   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8738   effect(KILL cr);
 8739 
 8740   format %{ &quot;sall    $dst, $shift&quot; %}
 8741   opcode(0xD3, 0x4); /* D3 /4 */
 8742   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8743   ins_pipe(ialu_mem_reg);
 8744 %}
 8745 
 8746 // Arithmetic shift right by one
 8747 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8748 %{
 8749   match(Set dst (RShiftI dst shift));
 8750   effect(KILL cr);
 8751 
 8752   format %{ &quot;sarl    $dst, $shift&quot; %}
 8753   opcode(0xD1, 0x7); /* D1 /7 */
 8754   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8755   ins_pipe(ialu_reg);
 8756 %}
 8757 
 8758 // Arithmetic shift right by one
 8759 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8760 %{
 8761   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8762   effect(KILL cr);
 8763 
 8764   format %{ &quot;sarl    $dst, $shift&quot; %}
 8765   opcode(0xD1, 0x7); /* D1 /7 */
 8766   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8767   ins_pipe(ialu_mem_imm);
 8768 %}
 8769 
 8770 // Arithmetic Shift Right by 8-bit immediate
 8771 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8772 %{
 8773   match(Set dst (RShiftI dst shift));
 8774   effect(KILL cr);
 8775 
 8776   format %{ &quot;sarl    $dst, $shift&quot; %}
 8777   opcode(0xC1, 0x7); /* C1 /7 ib */
 8778   ins_encode(reg_opc_imm(dst, shift));
 8779   ins_pipe(ialu_mem_imm);
 8780 %}
 8781 
 8782 // Arithmetic Shift Right by 8-bit immediate
 8783 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8784 %{
 8785   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8786   effect(KILL cr);
 8787 
 8788   format %{ &quot;sarl    $dst, $shift&quot; %}
 8789   opcode(0xC1, 0x7); /* C1 /7 ib */
 8790   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8791   ins_pipe(ialu_mem_imm);
 8792 %}
 8793 
 8794 // Arithmetic Shift Right by variable
 8795 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8796 %{
 8797   match(Set dst (RShiftI dst shift));
 8798   effect(KILL cr);
 8799 
 8800   format %{ &quot;sarl    $dst, $shift&quot; %}
 8801   opcode(0xD3, 0x7); /* D3 /7 */
 8802   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8803   ins_pipe(ialu_reg_reg);
 8804 %}
 8805 
 8806 // Arithmetic Shift Right by variable
 8807 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8808 %{
 8809   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8810   effect(KILL cr);
 8811 
 8812   format %{ &quot;sarl    $dst, $shift&quot; %}
 8813   opcode(0xD3, 0x7); /* D3 /7 */
 8814   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8815   ins_pipe(ialu_mem_reg);
 8816 %}
 8817 
 8818 // Logical shift right by one
 8819 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8820 %{
 8821   match(Set dst (URShiftI dst shift));
 8822   effect(KILL cr);
 8823 
 8824   format %{ &quot;shrl    $dst, $shift&quot; %}
 8825   opcode(0xD1, 0x5); /* D1 /5 */
 8826   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8827   ins_pipe(ialu_reg);
 8828 %}
 8829 
 8830 // Logical shift right by one
 8831 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8832 %{
 8833   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8834   effect(KILL cr);
 8835 
 8836   format %{ &quot;shrl    $dst, $shift&quot; %}
 8837   opcode(0xD1, 0x5); /* D1 /5 */
 8838   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8839   ins_pipe(ialu_mem_imm);
 8840 %}
 8841 
 8842 // Logical Shift Right by 8-bit immediate
 8843 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8844 %{
 8845   match(Set dst (URShiftI dst shift));
 8846   effect(KILL cr);
 8847 
 8848   format %{ &quot;shrl    $dst, $shift&quot; %}
 8849   opcode(0xC1, 0x5); /* C1 /5 ib */
 8850   ins_encode(reg_opc_imm(dst, shift));
 8851   ins_pipe(ialu_reg);
 8852 %}
 8853 
 8854 // Logical Shift Right by 8-bit immediate
 8855 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8856 %{
 8857   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8858   effect(KILL cr);
 8859 
 8860   format %{ &quot;shrl    $dst, $shift&quot; %}
 8861   opcode(0xC1, 0x5); /* C1 /5 ib */
 8862   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8863   ins_pipe(ialu_mem_imm);
 8864 %}
 8865 
 8866 // Logical Shift Right by variable
 8867 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8868 %{
 8869   match(Set dst (URShiftI dst shift));
 8870   effect(KILL cr);
 8871 
 8872   format %{ &quot;shrl    $dst, $shift&quot; %}
 8873   opcode(0xD3, 0x5); /* D3 /5 */
 8874   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8875   ins_pipe(ialu_reg_reg);
 8876 %}
 8877 
 8878 // Logical Shift Right by variable
 8879 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8880 %{
 8881   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8882   effect(KILL cr);
 8883 
 8884   format %{ &quot;shrl    $dst, $shift&quot; %}
 8885   opcode(0xD3, 0x5); /* D3 /5 */
 8886   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8887   ins_pipe(ialu_mem_reg);
 8888 %}
 8889 
 8890 // Long Shift Instructions
 8891 // Shift Left by one
 8892 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8893 %{
 8894   match(Set dst (LShiftL dst shift));
 8895   effect(KILL cr);
 8896 
 8897   format %{ &quot;salq    $dst, $shift&quot; %}
 8898   opcode(0xD1, 0x4); /* D1 /4 */
 8899   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8900   ins_pipe(ialu_reg);
 8901 %}
 8902 
 8903 // Shift Left by one
 8904 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8905 %{
 8906   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8907   effect(KILL cr);
 8908 
 8909   format %{ &quot;salq    $dst, $shift&quot; %}
 8910   opcode(0xD1, 0x4); /* D1 /4 */
 8911   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8912   ins_pipe(ialu_mem_imm);
 8913 %}
 8914 
 8915 // Shift Left by 8-bit immediate
 8916 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8917 %{
 8918   match(Set dst (LShiftL dst shift));
 8919   effect(KILL cr);
 8920 
 8921   format %{ &quot;salq    $dst, $shift&quot; %}
 8922   opcode(0xC1, 0x4); /* C1 /4 ib */
 8923   ins_encode(reg_opc_imm_wide(dst, shift));
 8924   ins_pipe(ialu_reg);
 8925 %}
 8926 
 8927 // Shift Left by 8-bit immediate
 8928 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8929 %{
 8930   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8931   effect(KILL cr);
 8932 
 8933   format %{ &quot;salq    $dst, $shift&quot; %}
 8934   opcode(0xC1, 0x4); /* C1 /4 ib */
 8935   ins_encode(REX_mem_wide(dst), OpcP,
 8936              RM_opc_mem(secondary, dst), Con8or32(shift));
 8937   ins_pipe(ialu_mem_imm);
 8938 %}
 8939 
 8940 // Shift Left by variable
 8941 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8942 %{
 8943   match(Set dst (LShiftL dst shift));
 8944   effect(KILL cr);
 8945 
 8946   format %{ &quot;salq    $dst, $shift&quot; %}
 8947   opcode(0xD3, 0x4); /* D3 /4 */
 8948   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8949   ins_pipe(ialu_reg_reg);
 8950 %}
 8951 
 8952 // Shift Left by variable
 8953 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8954 %{
 8955   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8956   effect(KILL cr);
 8957 
 8958   format %{ &quot;salq    $dst, $shift&quot; %}
 8959   opcode(0xD3, 0x4); /* D3 /4 */
 8960   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8961   ins_pipe(ialu_mem_reg);
 8962 %}
 8963 
 8964 // Arithmetic shift right by one
 8965 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8966 %{
 8967   match(Set dst (RShiftL dst shift));
 8968   effect(KILL cr);
 8969 
 8970   format %{ &quot;sarq    $dst, $shift&quot; %}
 8971   opcode(0xD1, 0x7); /* D1 /7 */
 8972   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8973   ins_pipe(ialu_reg);
 8974 %}
 8975 
 8976 // Arithmetic shift right by one
 8977 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8978 %{
 8979   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8980   effect(KILL cr);
 8981 
 8982   format %{ &quot;sarq    $dst, $shift&quot; %}
 8983   opcode(0xD1, 0x7); /* D1 /7 */
 8984   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8985   ins_pipe(ialu_mem_imm);
 8986 %}
 8987 
 8988 // Arithmetic Shift Right by 8-bit immediate
 8989 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8990 %{
 8991   match(Set dst (RShiftL dst shift));
 8992   effect(KILL cr);
 8993 
 8994   format %{ &quot;sarq    $dst, $shift&quot; %}
 8995   opcode(0xC1, 0x7); /* C1 /7 ib */
 8996   ins_encode(reg_opc_imm_wide(dst, shift));
 8997   ins_pipe(ialu_mem_imm);
 8998 %}
 8999 
 9000 // Arithmetic Shift Right by 8-bit immediate
 9001 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 9002 %{
 9003   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 9004   effect(KILL cr);
 9005 
 9006   format %{ &quot;sarq    $dst, $shift&quot; %}
 9007   opcode(0xC1, 0x7); /* C1 /7 ib */
 9008   ins_encode(REX_mem_wide(dst), OpcP,
 9009              RM_opc_mem(secondary, dst), Con8or32(shift));
 9010   ins_pipe(ialu_mem_imm);
 9011 %}
 9012 
 9013 // Arithmetic Shift Right by variable
 9014 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 9015 %{
 9016   match(Set dst (RShiftL dst shift));
 9017   effect(KILL cr);
 9018 
 9019   format %{ &quot;sarq    $dst, $shift&quot; %}
 9020   opcode(0xD3, 0x7); /* D3 /7 */
 9021   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9022   ins_pipe(ialu_reg_reg);
 9023 %}
 9024 
 9025 // Arithmetic Shift Right by variable
 9026 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 9027 %{
 9028   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 9029   effect(KILL cr);
 9030 
 9031   format %{ &quot;sarq    $dst, $shift&quot; %}
 9032   opcode(0xD3, 0x7); /* D3 /7 */
 9033   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 9034   ins_pipe(ialu_mem_reg);
 9035 %}
 9036 
 9037 // Logical shift right by one
 9038 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 9039 %{
 9040   match(Set dst (URShiftL dst shift));
 9041   effect(KILL cr);
 9042 
 9043   format %{ &quot;shrq    $dst, $shift&quot; %}
 9044   opcode(0xD1, 0x5); /* D1 /5 */
 9045   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
 9046   ins_pipe(ialu_reg);
 9047 %}
 9048 
 9049 // Logical shift right by one
 9050 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 9051 %{
 9052   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 9053   effect(KILL cr);
 9054 
 9055   format %{ &quot;shrq    $dst, $shift&quot; %}
 9056   opcode(0xD1, 0x5); /* D1 /5 */
 9057   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 9058   ins_pipe(ialu_mem_imm);
 9059 %}
 9060 
 9061 // Logical Shift Right by 8-bit immediate
 9062 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 9063 %{
 9064   match(Set dst (URShiftL dst shift));
 9065   effect(KILL cr);
 9066 
 9067   format %{ &quot;shrq    $dst, $shift&quot; %}
 9068   opcode(0xC1, 0x5); /* C1 /5 ib */
 9069   ins_encode(reg_opc_imm_wide(dst, shift));
 9070   ins_pipe(ialu_reg);
 9071 %}
 9072 
 9073 
 9074 // Logical Shift Right by 8-bit immediate
 9075 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 9076 %{
 9077   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 9078   effect(KILL cr);
 9079 
 9080   format %{ &quot;shrq    $dst, $shift&quot; %}
 9081   opcode(0xC1, 0x5); /* C1 /5 ib */
 9082   ins_encode(REX_mem_wide(dst), OpcP,
 9083              RM_opc_mem(secondary, dst), Con8or32(shift));
 9084   ins_pipe(ialu_mem_imm);
 9085 %}
 9086 
 9087 // Logical Shift Right by variable
 9088 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 9089 %{
 9090   match(Set dst (URShiftL dst shift));
 9091   effect(KILL cr);
 9092 
 9093   format %{ &quot;shrq    $dst, $shift&quot; %}
 9094   opcode(0xD3, 0x5); /* D3 /5 */
 9095   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9096   ins_pipe(ialu_reg_reg);
 9097 %}
 9098 
 9099 // Logical Shift Right by variable
 9100 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 9101 %{
 9102   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 9103   effect(KILL cr);
 9104 
 9105   format %{ &quot;shrq    $dst, $shift&quot; %}
 9106   opcode(0xD3, 0x5); /* D3 /5 */
 9107   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 9108   ins_pipe(ialu_mem_reg);
 9109 %}
 9110 
 9111 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 9112 // This idiom is used by the compiler for the i2b bytecode.
 9113 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
 9114 %{
 9115   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 9116 
 9117   format %{ &quot;movsbl  $dst, $src\t# i2b&quot; %}
 9118   opcode(0x0F, 0xBE);
 9119   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9120   ins_pipe(ialu_reg_reg);
 9121 %}
 9122 
 9123 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 9124 // This idiom is used by the compiler the i2s bytecode.
 9125 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
 9126 %{
 9127   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 9128 
 9129   format %{ &quot;movswl  $dst, $src\t# i2s&quot; %}
 9130   opcode(0x0F, 0xBF);
 9131   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9132   ins_pipe(ialu_reg_reg);
 9133 %}
 9134 
 9135 // ROL/ROR instructions
 9136 
 9137 // ROL expand
 9138 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
 9139   effect(KILL cr, USE_DEF dst);
 9140 
 9141   format %{ &quot;roll    $dst&quot; %}
 9142   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9143   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9144   ins_pipe(ialu_reg);
 9145 %}
 9146 
 9147 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
 9148   effect(USE_DEF dst, USE shift, KILL cr);
 9149 
 9150   format %{ &quot;roll    $dst, $shift&quot; %}
 9151   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9152   ins_encode( reg_opc_imm(dst, shift) );
 9153   ins_pipe(ialu_reg);
 9154 %}
 9155 
 9156 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9157 %{
 9158   effect(USE_DEF dst, USE shift, KILL cr);
 9159 
 9160   format %{ &quot;roll    $dst, $shift&quot; %}
 9161   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9162   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9163   ins_pipe(ialu_reg_reg);
 9164 %}
 9165 // end of ROL expand
 9166 
 9167 // Rotate Left by one
 9168 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9169 %{
 9170   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9171 
 9172   expand %{
 9173     rolI_rReg_imm1(dst, cr);
 9174   %}
 9175 %}
 9176 
 9177 // Rotate Left by 8-bit immediate
 9178 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9179 %{
 9180   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9181   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9182 
 9183   expand %{
 9184     rolI_rReg_imm8(dst, lshift, cr);
 9185   %}
 9186 %}
 9187 
 9188 // Rotate Left by variable
 9189 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9190 %{
 9191   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 9192 
 9193   expand %{
 9194     rolI_rReg_CL(dst, shift, cr);
 9195   %}
 9196 %}
 9197 
 9198 // Rotate Left by variable
 9199 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9200 %{
 9201   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 9202 
 9203   expand %{
 9204     rolI_rReg_CL(dst, shift, cr);
 9205   %}
 9206 %}
 9207 
 9208 // ROR expand
 9209 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
 9210 %{
 9211   effect(USE_DEF dst, KILL cr);
 9212 
 9213   format %{ &quot;rorl    $dst&quot; %}
 9214   opcode(0xD1, 0x1); /* D1 /1 */
 9215   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9216   ins_pipe(ialu_reg);
 9217 %}
 9218 
 9219 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
 9220 %{
 9221   effect(USE_DEF dst, USE shift, KILL cr);
 9222 
 9223   format %{ &quot;rorl    $dst, $shift&quot; %}
 9224   opcode(0xC1, 0x1); /* C1 /1 ib */
 9225   ins_encode(reg_opc_imm(dst, shift));
 9226   ins_pipe(ialu_reg);
 9227 %}
 9228 
 9229 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9230 %{
 9231   effect(USE_DEF dst, USE shift, KILL cr);
 9232 
 9233   format %{ &quot;rorl    $dst, $shift&quot; %}
 9234   opcode(0xD3, 0x1); /* D3 /1 */
 9235   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9236   ins_pipe(ialu_reg_reg);
 9237 %}
 9238 // end of ROR expand
 9239 
 9240 // Rotate Right by one
 9241 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9242 %{
 9243   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9244 
 9245   expand %{
 9246     rorI_rReg_imm1(dst, cr);
 9247   %}
 9248 %}
 9249 
 9250 // Rotate Right by 8-bit immediate
 9251 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9252 %{
 9253   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9254   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9255 
 9256   expand %{
 9257     rorI_rReg_imm8(dst, rshift, cr);
 9258   %}
 9259 %}
 9260 
 9261 // Rotate Right by variable
 9262 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9263 %{
 9264   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 9265 
 9266   expand %{
 9267     rorI_rReg_CL(dst, shift, cr);
 9268   %}
 9269 %}
 9270 
 9271 // Rotate Right by variable
 9272 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9273 %{
 9274   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 9275 
 9276   expand %{
 9277     rorI_rReg_CL(dst, shift, cr);
 9278   %}
 9279 %}
 9280 
 9281 // for long rotate
 9282 // ROL expand
 9283 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
 9284   effect(USE_DEF dst, KILL cr);
 9285 
 9286   format %{ &quot;rolq    $dst&quot; %}
 9287   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9288   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9289   ins_pipe(ialu_reg);
 9290 %}
 9291 
 9292 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
 9293   effect(USE_DEF dst, USE shift, KILL cr);
 9294 
 9295   format %{ &quot;rolq    $dst, $shift&quot; %}
 9296   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9297   ins_encode( reg_opc_imm_wide(dst, shift) );
 9298   ins_pipe(ialu_reg);
 9299 %}
 9300 
 9301 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9302 %{
 9303   effect(USE_DEF dst, USE shift, KILL cr);
 9304 
 9305   format %{ &quot;rolq    $dst, $shift&quot; %}
 9306   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9307   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9308   ins_pipe(ialu_reg_reg);
 9309 %}
 9310 // end of ROL expand
 9311 
 9312 // Rotate Left by one
 9313 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9314 %{
 9315   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9316 
 9317   expand %{
 9318     rolL_rReg_imm1(dst, cr);
 9319   %}
 9320 %}
 9321 
 9322 // Rotate Left by 8-bit immediate
 9323 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9324 %{
 9325   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9326   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9327 
 9328   expand %{
 9329     rolL_rReg_imm8(dst, lshift, cr);
 9330   %}
 9331 %}
 9332 
 9333 // Rotate Left by variable
 9334 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9335 %{
 9336   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
 9337 
 9338   expand %{
 9339     rolL_rReg_CL(dst, shift, cr);
 9340   %}
 9341 %}
 9342 
 9343 // Rotate Left by variable
 9344 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9345 %{
 9346   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
 9347 
 9348   expand %{
 9349     rolL_rReg_CL(dst, shift, cr);
 9350   %}
 9351 %}
 9352 
 9353 // ROR expand
 9354 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
 9355 %{
 9356   effect(USE_DEF dst, KILL cr);
 9357 
 9358   format %{ &quot;rorq    $dst&quot; %}
 9359   opcode(0xD1, 0x1); /* D1 /1 */
 9360   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9361   ins_pipe(ialu_reg);
 9362 %}
 9363 
 9364 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
 9365 %{
 9366   effect(USE_DEF dst, USE shift, KILL cr);
 9367 
 9368   format %{ &quot;rorq    $dst, $shift&quot; %}
 9369   opcode(0xC1, 0x1); /* C1 /1 ib */
 9370   ins_encode(reg_opc_imm_wide(dst, shift));
 9371   ins_pipe(ialu_reg);
 9372 %}
 9373 
 9374 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9375 %{
 9376   effect(USE_DEF dst, USE shift, KILL cr);
 9377 
 9378   format %{ &quot;rorq    $dst, $shift&quot; %}
 9379   opcode(0xD3, 0x1); /* D3 /1 */
 9380   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9381   ins_pipe(ialu_reg_reg);
 9382 %}
 9383 // end of ROR expand
 9384 
 9385 // Rotate Right by one
 9386 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9387 %{
 9388   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9389 
 9390   expand %{
 9391     rorL_rReg_imm1(dst, cr);
 9392   %}
 9393 %}
 9394 
 9395 // Rotate Right by 8-bit immediate
 9396 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9397 %{
 9398   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9399   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9400 
 9401   expand %{
 9402     rorL_rReg_imm8(dst, rshift, cr);
 9403   %}
 9404 %}
 9405 
 9406 // Rotate Right by variable
 9407 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9408 %{
 9409   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
 9410 
 9411   expand %{
 9412     rorL_rReg_CL(dst, shift, cr);
 9413   %}
 9414 %}
 9415 
 9416 // Rotate Right by variable
 9417 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9418 %{
 9419   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
 9420 
 9421   expand %{
 9422     rorL_rReg_CL(dst, shift, cr);
 9423   %}
 9424 %}
 9425 
 9426 // Logical Instructions
 9427 
 9428 // Integer Logical Instructions
 9429 
 9430 // And Instructions
 9431 // And Register with Register
 9432 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9433 %{
 9434   match(Set dst (AndI dst src));
 9435   effect(KILL cr);
 9436 
 9437   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9438   opcode(0x23);
 9439   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9440   ins_pipe(ialu_reg_reg);
 9441 %}
 9442 
 9443 // And Register with Immediate 255
 9444 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
 9445 %{
 9446   match(Set dst (AndI dst src));
 9447 
 9448   format %{ &quot;movzbl  $dst, $dst\t# int &amp; 0xFF&quot; %}
 9449   opcode(0x0F, 0xB6);
 9450   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9451   ins_pipe(ialu_reg);
 9452 %}
 9453 
 9454 // And Register with Immediate 255 and promote to long
 9455 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
 9456 %{
 9457   match(Set dst (ConvI2L (AndI src mask)));
 9458 
 9459   format %{ &quot;movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long&quot; %}
 9460   opcode(0x0F, 0xB6);
 9461   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9462   ins_pipe(ialu_reg);
 9463 %}
 9464 
 9465 // And Register with Immediate 65535
 9466 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
 9467 %{
 9468   match(Set dst (AndI dst src));
 9469 
 9470   format %{ &quot;movzwl  $dst, $dst\t# int &amp; 0xFFFF&quot; %}
 9471   opcode(0x0F, 0xB7);
 9472   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9473   ins_pipe(ialu_reg);
 9474 %}
 9475 
 9476 // And Register with Immediate 65535 and promote to long
 9477 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
 9478 %{
 9479   match(Set dst (ConvI2L (AndI src mask)));
 9480 
 9481   format %{ &quot;movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long&quot; %}
 9482   opcode(0x0F, 0xB7);
 9483   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9484   ins_pipe(ialu_reg);
 9485 %}
 9486 
 9487 // And Register with Immediate
 9488 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9489 %{
 9490   match(Set dst (AndI dst src));
 9491   effect(KILL cr);
 9492 
 9493   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9494   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9495   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9496   ins_pipe(ialu_reg);
 9497 %}
 9498 
 9499 // And Register with Memory
 9500 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9501 %{
 9502   match(Set dst (AndI dst (LoadI src)));
 9503   effect(KILL cr);
 9504 
 9505   ins_cost(125);
 9506   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9507   opcode(0x23);
 9508   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9509   ins_pipe(ialu_reg_mem);
 9510 %}
 9511 
 9512 // And Memory with Register
 9513 instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9514 %{
 9515   match(Set dst (StoreB dst (AndI (LoadB dst) src)));
 9516   effect(KILL cr);
 9517 
 9518   ins_cost(150);
 9519   format %{ &quot;andb    $dst, $src\t# byte&quot; %}
 9520   opcode(0x20);
 9521   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9522   ins_pipe(ialu_mem_reg);
 9523 %}
 9524 
 9525 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9526 %{
 9527   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9528   effect(KILL cr);
 9529 
 9530   ins_cost(150);
 9531   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9532   opcode(0x21); /* Opcode 21 /r */
 9533   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9534   ins_pipe(ialu_mem_reg);
 9535 %}
 9536 
 9537 // And Memory with Immediate
 9538 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9539 %{
 9540   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9541   effect(KILL cr);
 9542 
 9543   ins_cost(125);
 9544   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9545   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9546   ins_encode(REX_mem(dst), OpcSE(src),
 9547              RM_opc_mem(secondary, dst), Con8or32(src));
 9548   ins_pipe(ialu_mem_imm);
 9549 %}
 9550 
 9551 // BMI1 instructions
 9552 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
 9553   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
 9554   predicate(UseBMI1Instructions);
 9555   effect(KILL cr);
 9556 
 9557   ins_cost(125);
 9558   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9559 
 9560   ins_encode %{
 9561     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 9562   %}
 9563   ins_pipe(ialu_reg_mem);
 9564 %}
 9565 
 9566 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
 9567   match(Set dst (AndI (XorI src1 minus_1) src2));
 9568   predicate(UseBMI1Instructions);
 9569   effect(KILL cr);
 9570 
 9571   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9572 
 9573   ins_encode %{
 9574     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 9575   %}
 9576   ins_pipe(ialu_reg);
 9577 %}
 9578 
 9579 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
 9580   match(Set dst (AndI (SubI imm_zero src) src));
 9581   predicate(UseBMI1Instructions);
 9582   effect(KILL cr);
 9583 
 9584   format %{ &quot;blsil  $dst, $src&quot; %}
 9585 
 9586   ins_encode %{
 9587     __ blsil($dst$$Register, $src$$Register);
 9588   %}
 9589   ins_pipe(ialu_reg);
 9590 %}
 9591 
 9592 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
 9593   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 9594   predicate(UseBMI1Instructions);
 9595   effect(KILL cr);
 9596 
 9597   ins_cost(125);
 9598   format %{ &quot;blsil  $dst, $src&quot; %}
 9599 
 9600   ins_encode %{
 9601     __ blsil($dst$$Register, $src$$Address);
 9602   %}
 9603   ins_pipe(ialu_reg_mem);
 9604 %}
 9605 
 9606 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9607 %{
 9608   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9609   predicate(UseBMI1Instructions);
 9610   effect(KILL cr);
 9611 
 9612   ins_cost(125);
 9613   format %{ &quot;blsmskl $dst, $src&quot; %}
 9614 
 9615   ins_encode %{
 9616     __ blsmskl($dst$$Register, $src$$Address);
 9617   %}
 9618   ins_pipe(ialu_reg_mem);
 9619 %}
 9620 
 9621 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9622 %{
 9623   match(Set dst (XorI (AddI src minus_1) src));
 9624   predicate(UseBMI1Instructions);
 9625   effect(KILL cr);
 9626 
 9627   format %{ &quot;blsmskl $dst, $src&quot; %}
 9628 
 9629   ins_encode %{
 9630     __ blsmskl($dst$$Register, $src$$Register);
 9631   %}
 9632 
 9633   ins_pipe(ialu_reg);
 9634 %}
 9635 
 9636 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9637 %{
 9638   match(Set dst (AndI (AddI src minus_1) src) );
 9639   predicate(UseBMI1Instructions);
 9640   effect(KILL cr);
 9641 
 9642   format %{ &quot;blsrl  $dst, $src&quot; %}
 9643 
 9644   ins_encode %{
 9645     __ blsrl($dst$$Register, $src$$Register);
 9646   %}
 9647 
 9648   ins_pipe(ialu_reg_mem);
 9649 %}
 9650 
 9651 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9652 %{
 9653   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9654   predicate(UseBMI1Instructions);
 9655   effect(KILL cr);
 9656 
 9657   ins_cost(125);
 9658   format %{ &quot;blsrl  $dst, $src&quot; %}
 9659 
 9660   ins_encode %{
 9661     __ blsrl($dst$$Register, $src$$Address);
 9662   %}
 9663 
 9664   ins_pipe(ialu_reg);
 9665 %}
 9666 
 9667 // Or Instructions
 9668 // Or Register with Register
 9669 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9670 %{
 9671   match(Set dst (OrI dst src));
 9672   effect(KILL cr);
 9673 
 9674   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9675   opcode(0x0B);
 9676   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9677   ins_pipe(ialu_reg_reg);
 9678 %}
 9679 
 9680 // Or Register with Immediate
 9681 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9682 %{
 9683   match(Set dst (OrI dst src));
 9684   effect(KILL cr);
 9685 
 9686   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9687   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9688   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9689   ins_pipe(ialu_reg);
 9690 %}
 9691 
 9692 // Or Register with Memory
 9693 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9694 %{
 9695   match(Set dst (OrI dst (LoadI src)));
 9696   effect(KILL cr);
 9697 
 9698   ins_cost(125);
 9699   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9700   opcode(0x0B);
 9701   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9702   ins_pipe(ialu_reg_mem);
 9703 %}
 9704 
 9705 // Or Memory with Register
 9706 instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9707 %{
 9708   match(Set dst (StoreB dst (OrI (LoadB dst) src)));
 9709   effect(KILL cr);
 9710 
 9711   ins_cost(150);
 9712   format %{ &quot;orb    $dst, $src\t# byte&quot; %}
 9713   opcode(0x08);
 9714   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9715   ins_pipe(ialu_mem_reg);
 9716 %}
 9717 
 9718 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9719 %{
 9720   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9721   effect(KILL cr);
 9722 
 9723   ins_cost(150);
 9724   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9725   opcode(0x09); /* Opcode 09 /r */
 9726   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9727   ins_pipe(ialu_mem_reg);
 9728 %}
 9729 
 9730 // Or Memory with Immediate
 9731 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9732 %{
 9733   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9734   effect(KILL cr);
 9735 
 9736   ins_cost(125);
 9737   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9738   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9739   ins_encode(REX_mem(dst), OpcSE(src),
 9740              RM_opc_mem(secondary, dst), Con8or32(src));
 9741   ins_pipe(ialu_mem_imm);
 9742 %}
 9743 
 9744 // Xor Instructions
 9745 // Xor Register with Register
 9746 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9747 %{
 9748   match(Set dst (XorI dst src));
 9749   effect(KILL cr);
 9750 
 9751   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9752   opcode(0x33);
 9753   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9754   ins_pipe(ialu_reg_reg);
 9755 %}
 9756 
 9757 // Xor Register with Immediate -1
 9758 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
 9759   match(Set dst (XorI dst imm));
 9760 
 9761   format %{ &quot;not    $dst&quot; %}
 9762   ins_encode %{
 9763      __ notl($dst$$Register);
 9764   %}
 9765   ins_pipe(ialu_reg);
 9766 %}
 9767 
 9768 // Xor Register with Immediate
 9769 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9770 %{
 9771   match(Set dst (XorI dst src));
 9772   effect(KILL cr);
 9773 
 9774   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9775   opcode(0x81, 0x06); /* Opcode 81 /6 id */
 9776   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9777   ins_pipe(ialu_reg);
 9778 %}
 9779 
 9780 // Xor Register with Memory
 9781 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9782 %{
 9783   match(Set dst (XorI dst (LoadI src)));
 9784   effect(KILL cr);
 9785 
 9786   ins_cost(125);
 9787   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9788   opcode(0x33);
 9789   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9790   ins_pipe(ialu_reg_mem);
 9791 %}
 9792 
 9793 // Xor Memory with Register
 9794 instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9795 %{
 9796   match(Set dst (StoreB dst (XorI (LoadB dst) src)));
 9797   effect(KILL cr);
 9798 
 9799   ins_cost(150);
 9800   format %{ &quot;xorb    $dst, $src\t# byte&quot; %}
 9801   opcode(0x30);
 9802   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9803   ins_pipe(ialu_mem_reg);
 9804 %}
 9805 
 9806 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9807 %{
 9808   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9809   effect(KILL cr);
 9810 
 9811   ins_cost(150);
 9812   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9813   opcode(0x31); /* Opcode 31 /r */
 9814   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9815   ins_pipe(ialu_mem_reg);
 9816 %}
 9817 
 9818 // Xor Memory with Immediate
 9819 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9820 %{
 9821   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9822   effect(KILL cr);
 9823 
 9824   ins_cost(125);
 9825   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9826   opcode(0x81, 0x6); /* Opcode 81 /6 id */
 9827   ins_encode(REX_mem(dst), OpcSE(src),
 9828              RM_opc_mem(secondary, dst), Con8or32(src));
 9829   ins_pipe(ialu_mem_imm);
 9830 %}
 9831 
 9832 
 9833 // Long Logical Instructions
 9834 
 9835 // And Instructions
 9836 // And Register with Register
 9837 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9838 %{
 9839   match(Set dst (AndL dst src));
 9840   effect(KILL cr);
 9841 
 9842   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9843   opcode(0x23);
 9844   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9845   ins_pipe(ialu_reg_reg);
 9846 %}
 9847 
 9848 // And Register with Immediate 255
 9849 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
 9850 %{
 9851   match(Set dst (AndL dst src));
 9852 
 9853   format %{ &quot;movzbq  $dst, $dst\t# long &amp; 0xFF&quot; %}
 9854   opcode(0x0F, 0xB6);
 9855   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9856   ins_pipe(ialu_reg);
 9857 %}
 9858 
 9859 // And Register with Immediate 65535
 9860 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
 9861 %{
 9862   match(Set dst (AndL dst src));
 9863 
 9864   format %{ &quot;movzwq  $dst, $dst\t# long &amp; 0xFFFF&quot; %}
 9865   opcode(0x0F, 0xB7);
 9866   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9867   ins_pipe(ialu_reg);
 9868 %}
 9869 
 9870 // And Register with Immediate
 9871 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9872 %{
 9873   match(Set dst (AndL dst src));
 9874   effect(KILL cr);
 9875 
 9876   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9877   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9878   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9879   ins_pipe(ialu_reg);
 9880 %}
 9881 
 9882 // And Register with Memory
 9883 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9884 %{
 9885   match(Set dst (AndL dst (LoadL src)));
 9886   effect(KILL cr);
 9887 
 9888   ins_cost(125);
 9889   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9890   opcode(0x23);
 9891   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9892   ins_pipe(ialu_reg_mem);
 9893 %}
 9894 
 9895 // And Memory with Register
 9896 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9897 %{
 9898   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9899   effect(KILL cr);
 9900 
 9901   ins_cost(150);
 9902   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9903   opcode(0x21); /* Opcode 21 /r */
 9904   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9905   ins_pipe(ialu_mem_reg);
 9906 %}
 9907 
 9908 // And Memory with Immediate
 9909 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9910 %{
 9911   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9912   effect(KILL cr);
 9913 
 9914   ins_cost(125);
 9915   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9916   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9917   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9918              RM_opc_mem(secondary, dst), Con8or32(src));
 9919   ins_pipe(ialu_mem_imm);
 9920 %}
 9921 
<a name="58" id="anc58"></a>
















 9922 // BMI1 instructions
 9923 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9924   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9925   predicate(UseBMI1Instructions);
 9926   effect(KILL cr);
 9927 
 9928   ins_cost(125);
 9929   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9930 
 9931   ins_encode %{
 9932     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9933   %}
 9934   ins_pipe(ialu_reg_mem);
 9935 %}
 9936 
 9937 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9938   match(Set dst (AndL (XorL src1 minus_1) src2));
 9939   predicate(UseBMI1Instructions);
 9940   effect(KILL cr);
 9941 
 9942   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9943 
 9944   ins_encode %{
 9945   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
 9946   %}
 9947   ins_pipe(ialu_reg_mem);
 9948 %}
 9949 
 9950 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
 9951   match(Set dst (AndL (SubL imm_zero src) src));
 9952   predicate(UseBMI1Instructions);
 9953   effect(KILL cr);
 9954 
 9955   format %{ &quot;blsiq  $dst, $src&quot; %}
 9956 
 9957   ins_encode %{
 9958     __ blsiq($dst$$Register, $src$$Register);
 9959   %}
 9960   ins_pipe(ialu_reg);
 9961 %}
 9962 
 9963 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
 9964   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9965   predicate(UseBMI1Instructions);
 9966   effect(KILL cr);
 9967 
 9968   ins_cost(125);
 9969   format %{ &quot;blsiq  $dst, $src&quot; %}
 9970 
 9971   ins_encode %{
 9972     __ blsiq($dst$$Register, $src$$Address);
 9973   %}
 9974   ins_pipe(ialu_reg_mem);
 9975 %}
 9976 
 9977 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9978 %{
 9979   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
 9980   predicate(UseBMI1Instructions);
 9981   effect(KILL cr);
 9982 
 9983   ins_cost(125);
 9984   format %{ &quot;blsmskq $dst, $src&quot; %}
 9985 
 9986   ins_encode %{
 9987     __ blsmskq($dst$$Register, $src$$Address);
 9988   %}
 9989   ins_pipe(ialu_reg_mem);
 9990 %}
 9991 
 9992 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9993 %{
 9994   match(Set dst (XorL (AddL src minus_1) src));
 9995   predicate(UseBMI1Instructions);
 9996   effect(KILL cr);
 9997 
 9998   format %{ &quot;blsmskq $dst, $src&quot; %}
 9999 
10000   ins_encode %{
10001     __ blsmskq($dst$$Register, $src$$Register);
10002   %}
10003 
10004   ins_pipe(ialu_reg);
10005 %}
10006 
10007 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
10008 %{
10009   match(Set dst (AndL (AddL src minus_1) src) );
10010   predicate(UseBMI1Instructions);
10011   effect(KILL cr);
10012 
10013   format %{ &quot;blsrq  $dst, $src&quot; %}
10014 
10015   ins_encode %{
10016     __ blsrq($dst$$Register, $src$$Register);
10017   %}
10018 
10019   ins_pipe(ialu_reg);
10020 %}
10021 
10022 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
10023 %{
10024   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
10025   predicate(UseBMI1Instructions);
10026   effect(KILL cr);
10027 
10028   ins_cost(125);
10029   format %{ &quot;blsrq  $dst, $src&quot; %}
10030 
10031   ins_encode %{
10032     __ blsrq($dst$$Register, $src$$Address);
10033   %}
10034 
10035   ins_pipe(ialu_reg);
10036 %}
10037 
10038 // Or Instructions
10039 // Or Register with Register
10040 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10041 %{
10042   match(Set dst (OrL dst src));
10043   effect(KILL cr);
10044 
10045   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10046   opcode(0x0B);
10047   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10048   ins_pipe(ialu_reg_reg);
10049 %}
10050 
10051 // Use any_RegP to match R15 (TLS register) without spilling.
10052 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
10053   match(Set dst (OrL dst (CastP2X src)));
10054   effect(KILL cr);
10055 
10056   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10057   opcode(0x0B);
10058   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10059   ins_pipe(ialu_reg_reg);
10060 %}
10061 
10062 
10063 // Or Register with Immediate
10064 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10065 %{
10066   match(Set dst (OrL dst src));
10067   effect(KILL cr);
10068 
10069   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10070   opcode(0x81, 0x01); /* Opcode 81 /1 id */
10071   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10072   ins_pipe(ialu_reg);
10073 %}
10074 
10075 // Or Register with Memory
10076 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10077 %{
10078   match(Set dst (OrL dst (LoadL src)));
10079   effect(KILL cr);
10080 
10081   ins_cost(125);
10082   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10083   opcode(0x0B);
10084   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10085   ins_pipe(ialu_reg_mem);
10086 %}
10087 
10088 // Or Memory with Register
10089 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10090 %{
10091   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10092   effect(KILL cr);
10093 
10094   ins_cost(150);
10095   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10096   opcode(0x09); /* Opcode 09 /r */
10097   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10098   ins_pipe(ialu_mem_reg);
10099 %}
10100 
10101 // Or Memory with Immediate
10102 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10103 %{
10104   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10105   effect(KILL cr);
10106 
10107   ins_cost(125);
10108   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10109   opcode(0x81, 0x1); /* Opcode 81 /1 id */
10110   ins_encode(REX_mem_wide(dst), OpcSE(src),
10111              RM_opc_mem(secondary, dst), Con8or32(src));
10112   ins_pipe(ialu_mem_imm);
10113 %}
10114 
<a name="59" id="anc59"></a>
















10115 // Xor Instructions
10116 // Xor Register with Register
10117 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10118 %{
10119   match(Set dst (XorL dst src));
10120   effect(KILL cr);
10121 
10122   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10123   opcode(0x33);
10124   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10125   ins_pipe(ialu_reg_reg);
10126 %}
10127 
10128 // Xor Register with Immediate -1
10129 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10130   match(Set dst (XorL dst imm));
10131 
10132   format %{ &quot;notq   $dst&quot; %}
10133   ins_encode %{
10134      __ notq($dst$$Register);
10135   %}
10136   ins_pipe(ialu_reg);
10137 %}
10138 
10139 // Xor Register with Immediate
10140 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10141 %{
10142   match(Set dst (XorL dst src));
10143   effect(KILL cr);
10144 
10145   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10146   opcode(0x81, 0x06); /* Opcode 81 /6 id */
10147   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10148   ins_pipe(ialu_reg);
10149 %}
10150 
10151 // Xor Register with Memory
10152 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10153 %{
10154   match(Set dst (XorL dst (LoadL src)));
10155   effect(KILL cr);
10156 
10157   ins_cost(125);
10158   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10159   opcode(0x33);
10160   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10161   ins_pipe(ialu_reg_mem);
10162 %}
10163 
10164 // Xor Memory with Register
10165 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10166 %{
10167   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10168   effect(KILL cr);
10169 
10170   ins_cost(150);
10171   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10172   opcode(0x31); /* Opcode 31 /r */
10173   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10174   ins_pipe(ialu_mem_reg);
10175 %}
10176 
10177 // Xor Memory with Immediate
10178 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10179 %{
10180   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10181   effect(KILL cr);
10182 
10183   ins_cost(125);
10184   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10185   opcode(0x81, 0x6); /* Opcode 81 /6 id */
10186   ins_encode(REX_mem_wide(dst), OpcSE(src),
10187              RM_opc_mem(secondary, dst), Con8or32(src));
10188   ins_pipe(ialu_mem_imm);
10189 %}
10190 
10191 // Convert Int to Boolean
10192 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
10193 %{
10194   match(Set dst (Conv2B src));
10195   effect(KILL cr);
10196 
10197   format %{ &quot;testl   $src, $src\t# ci2b\n\t&quot;
10198             &quot;setnz   $dst\n\t&quot;
10199             &quot;movzbl  $dst, $dst&quot; %}
10200   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
10201              setNZ_reg(dst),
10202              REX_reg_breg(dst, dst), // movzbl
10203              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10204   ins_pipe(pipe_slow); // XXX
10205 %}
10206 
10207 // Convert Pointer to Boolean
10208 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
10209 %{
10210   match(Set dst (Conv2B src));
10211   effect(KILL cr);
10212 
10213   format %{ &quot;testq   $src, $src\t# cp2b\n\t&quot;
10214             &quot;setnz   $dst\n\t&quot;
10215             &quot;movzbl  $dst, $dst&quot; %}
10216   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
10217              setNZ_reg(dst),
10218              REX_reg_breg(dst, dst), // movzbl
10219              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10220   ins_pipe(pipe_slow); // XXX
10221 %}
10222 
10223 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
10224 %{
10225   match(Set dst (CmpLTMask p q));
10226   effect(KILL cr);
10227 
10228   ins_cost(400);
10229   format %{ &quot;cmpl    $p, $q\t# cmpLTMask\n\t&quot;
10230             &quot;setlt   $dst\n\t&quot;
10231             &quot;movzbl  $dst, $dst\n\t&quot;
10232             &quot;negl    $dst&quot; %}
10233   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
10234              setLT_reg(dst),
10235              REX_reg_breg(dst, dst), // movzbl
10236              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
10237              neg_reg(dst));
10238   ins_pipe(pipe_slow);
10239 %}
10240 
10241 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10242 %{
10243   match(Set dst (CmpLTMask dst zero));
10244   effect(KILL cr);
10245 
10246   ins_cost(100);
10247   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10248   ins_encode %{
10249   __ sarl($dst$$Register, 31);
10250   %}
10251   ins_pipe(ialu_reg);
10252 %}
10253 
10254 /* Better to save a register than avoid a branch */
10255 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10256 %{
10257   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10258   effect(KILL cr);
10259   ins_cost(300);
<a name="60" id="anc60"></a><span class="line-modified">10260   format %{ &quot;subl   $p,$q\t# cadd_cmpLTMask\n\t&quot;</span>
<span class="line-modified">10261             &quot;jge    done\n\t&quot;</span>
<span class="line-modified">10262             &quot;addl   $p,$y\n&quot;</span>
<span class="line-modified">10263             &quot;done:  &quot; %}</span>
10264   ins_encode %{
10265     Register Rp = $p$$Register;
10266     Register Rq = $q$$Register;
10267     Register Ry = $y$$Register;
10268     Label done;
10269     __ subl(Rp, Rq);
10270     __ jccb(Assembler::greaterEqual, done);
10271     __ addl(Rp, Ry);
10272     __ bind(done);
10273   %}
10274   ins_pipe(pipe_cmplt);
10275 %}
10276 
10277 /* Better to save a register than avoid a branch */
10278 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10279 %{
10280   match(Set y (AndI (CmpLTMask p q) y));
10281   effect(KILL cr);
10282 
10283   ins_cost(300);
10284 
<a name="61" id="anc61"></a><span class="line-modified">10285   format %{ &quot;cmpl     $p, $q\t# and_cmpLTMask\n\t&quot;</span>
<span class="line-modified">10286             &quot;jlt      done\n\t&quot;</span>
<span class="line-modified">10287             &quot;xorl     $y, $y\n&quot;</span>
<span class="line-modified">10288             &quot;done:  &quot; %}</span>
10289   ins_encode %{
10290     Register Rp = $p$$Register;
10291     Register Rq = $q$$Register;
10292     Register Ry = $y$$Register;
10293     Label done;
10294     __ cmpl(Rp, Rq);
10295     __ jccb(Assembler::less, done);
10296     __ xorl(Ry, Ry);
10297     __ bind(done);
10298   %}
10299   ins_pipe(pipe_cmplt);
10300 %}
10301 
10302 
10303 //---------- FP Instructions------------------------------------------------
10304 
10305 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10306 %{
10307   match(Set cr (CmpF src1 src2));
10308 
10309   ins_cost(145);
10310   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10311             &quot;jnp,s   exit\n\t&quot;
10312             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10313             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10314             &quot;popfq\n&quot;
10315     &quot;exit:&quot; %}
10316   ins_encode %{
10317     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10318     emit_cmpfp_fixup(_masm);
10319   %}
10320   ins_pipe(pipe_slow);
10321 %}
10322 
10323 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
10324   match(Set cr (CmpF src1 src2));
10325 
10326   ins_cost(100);
10327   format %{ &quot;ucomiss $src1, $src2&quot; %}
10328   ins_encode %{
10329     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10330   %}
10331   ins_pipe(pipe_slow);
10332 %}
10333 
10334 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
10335 %{
10336   match(Set cr (CmpF src1 (LoadF src2)));
10337 
10338   ins_cost(145);
10339   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10340             &quot;jnp,s   exit\n\t&quot;
10341             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10342             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10343             &quot;popfq\n&quot;
10344     &quot;exit:&quot; %}
10345   ins_encode %{
10346     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10347     emit_cmpfp_fixup(_masm);
10348   %}
10349   ins_pipe(pipe_slow);
10350 %}
10351 
10352 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
10353   match(Set cr (CmpF src1 (LoadF src2)));
10354 
10355   ins_cost(100);
10356   format %{ &quot;ucomiss $src1, $src2&quot; %}
10357   ins_encode %{
10358     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10359   %}
10360   ins_pipe(pipe_slow);
10361 %}
10362 
10363 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
10364   match(Set cr (CmpF src con));
10365 
10366   ins_cost(145);
10367   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10368             &quot;jnp,s   exit\n\t&quot;
10369             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10370             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10371             &quot;popfq\n&quot;
10372     &quot;exit:&quot; %}
10373   ins_encode %{
10374     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10375     emit_cmpfp_fixup(_masm);
10376   %}
10377   ins_pipe(pipe_slow);
10378 %}
10379 
10380 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
10381   match(Set cr (CmpF src con));
10382   ins_cost(100);
10383   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con&quot; %}
10384   ins_encode %{
10385     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10386   %}
10387   ins_pipe(pipe_slow);
10388 %}
10389 
10390 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
10391 %{
10392   match(Set cr (CmpD src1 src2));
10393 
10394   ins_cost(145);
10395   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10396             &quot;jnp,s   exit\n\t&quot;
10397             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10398             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10399             &quot;popfq\n&quot;
10400     &quot;exit:&quot; %}
10401   ins_encode %{
10402     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10403     emit_cmpfp_fixup(_masm);
10404   %}
10405   ins_pipe(pipe_slow);
10406 %}
10407 
10408 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
10409   match(Set cr (CmpD src1 src2));
10410 
10411   ins_cost(100);
10412   format %{ &quot;ucomisd $src1, $src2 test&quot; %}
10413   ins_encode %{
10414     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10415   %}
10416   ins_pipe(pipe_slow);
10417 %}
10418 
10419 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
10420 %{
10421   match(Set cr (CmpD src1 (LoadD src2)));
10422 
10423   ins_cost(145);
10424   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10425             &quot;jnp,s   exit\n\t&quot;
10426             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10427             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10428             &quot;popfq\n&quot;
10429     &quot;exit:&quot; %}
10430   ins_encode %{
10431     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10432     emit_cmpfp_fixup(_masm);
10433   %}
10434   ins_pipe(pipe_slow);
10435 %}
10436 
10437 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
10438   match(Set cr (CmpD src1 (LoadD src2)));
10439 
10440   ins_cost(100);
10441   format %{ &quot;ucomisd $src1, $src2&quot; %}
10442   ins_encode %{
10443     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10444   %}
10445   ins_pipe(pipe_slow);
10446 %}
10447 
10448 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
10449   match(Set cr (CmpD src con));
10450 
10451   ins_cost(145);
10452   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10453             &quot;jnp,s   exit\n\t&quot;
10454             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10455             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10456             &quot;popfq\n&quot;
10457     &quot;exit:&quot; %}
10458   ins_encode %{
10459     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10460     emit_cmpfp_fixup(_masm);
10461   %}
10462   ins_pipe(pipe_slow);
10463 %}
10464 
10465 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
10466   match(Set cr (CmpD src con));
10467   ins_cost(100);
10468   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con&quot; %}
10469   ins_encode %{
10470     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10471   %}
10472   ins_pipe(pipe_slow);
10473 %}
10474 
10475 // Compare into -1,0,1
10476 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
10477 %{
10478   match(Set dst (CmpF3 src1 src2));
10479   effect(KILL cr);
10480 
10481   ins_cost(275);
10482   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10483             &quot;movl    $dst, #-1\n\t&quot;
10484             &quot;jp,s    done\n\t&quot;
10485             &quot;jb,s    done\n\t&quot;
10486             &quot;setne   $dst\n\t&quot;
10487             &quot;movzbl  $dst, $dst\n&quot;
10488     &quot;done:&quot; %}
10489   ins_encode %{
10490     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10491     emit_cmpfp3(_masm, $dst$$Register);
10492   %}
10493   ins_pipe(pipe_slow);
10494 %}
10495 
10496 // Compare into -1,0,1
10497 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
10498 %{
10499   match(Set dst (CmpF3 src1 (LoadF src2)));
10500   effect(KILL cr);
10501 
10502   ins_cost(275);
10503   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10504             &quot;movl    $dst, #-1\n\t&quot;
10505             &quot;jp,s    done\n\t&quot;
10506             &quot;jb,s    done\n\t&quot;
10507             &quot;setne   $dst\n\t&quot;
10508             &quot;movzbl  $dst, $dst\n&quot;
10509     &quot;done:&quot; %}
10510   ins_encode %{
10511     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10512     emit_cmpfp3(_masm, $dst$$Register);
10513   %}
10514   ins_pipe(pipe_slow);
10515 %}
10516 
10517 // Compare into -1,0,1
10518 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
10519   match(Set dst (CmpF3 src con));
10520   effect(KILL cr);
10521 
10522   ins_cost(275);
10523   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10524             &quot;movl    $dst, #-1\n\t&quot;
10525             &quot;jp,s    done\n\t&quot;
10526             &quot;jb,s    done\n\t&quot;
10527             &quot;setne   $dst\n\t&quot;
10528             &quot;movzbl  $dst, $dst\n&quot;
10529     &quot;done:&quot; %}
10530   ins_encode %{
10531     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10532     emit_cmpfp3(_masm, $dst$$Register);
10533   %}
10534   ins_pipe(pipe_slow);
10535 %}
10536 
10537 // Compare into -1,0,1
10538 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
10539 %{
10540   match(Set dst (CmpD3 src1 src2));
10541   effect(KILL cr);
10542 
10543   ins_cost(275);
10544   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10545             &quot;movl    $dst, #-1\n\t&quot;
10546             &quot;jp,s    done\n\t&quot;
10547             &quot;jb,s    done\n\t&quot;
10548             &quot;setne   $dst\n\t&quot;
10549             &quot;movzbl  $dst, $dst\n&quot;
10550     &quot;done:&quot; %}
10551   ins_encode %{
10552     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10553     emit_cmpfp3(_masm, $dst$$Register);
10554   %}
10555   ins_pipe(pipe_slow);
10556 %}
10557 
10558 // Compare into -1,0,1
10559 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
10560 %{
10561   match(Set dst (CmpD3 src1 (LoadD src2)));
10562   effect(KILL cr);
10563 
10564   ins_cost(275);
10565   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10566             &quot;movl    $dst, #-1\n\t&quot;
10567             &quot;jp,s    done\n\t&quot;
10568             &quot;jb,s    done\n\t&quot;
10569             &quot;setne   $dst\n\t&quot;
10570             &quot;movzbl  $dst, $dst\n&quot;
10571     &quot;done:&quot; %}
10572   ins_encode %{
10573     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10574     emit_cmpfp3(_masm, $dst$$Register);
10575   %}
10576   ins_pipe(pipe_slow);
10577 %}
10578 
10579 // Compare into -1,0,1
10580 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
10581   match(Set dst (CmpD3 src con));
10582   effect(KILL cr);
10583 
10584   ins_cost(275);
10585   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10586             &quot;movl    $dst, #-1\n\t&quot;
10587             &quot;jp,s    done\n\t&quot;
10588             &quot;jb,s    done\n\t&quot;
10589             &quot;setne   $dst\n\t&quot;
10590             &quot;movzbl  $dst, $dst\n&quot;
10591     &quot;done:&quot; %}
10592   ins_encode %{
10593     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10594     emit_cmpfp3(_masm, $dst$$Register);
10595   %}
10596   ins_pipe(pipe_slow);
10597 %}
10598 
10599 //----------Arithmetic Conversion Instructions---------------------------------
10600 
<a name="62" id="anc62"></a><span class="line-removed">10601 instruct roundFloat_nop(regF dst)</span>
<span class="line-removed">10602 %{</span>
<span class="line-removed">10603   match(Set dst (RoundFloat dst));</span>
<span class="line-removed">10604 </span>
<span class="line-removed">10605   ins_cost(0);</span>
<span class="line-removed">10606   ins_encode();</span>
<span class="line-removed">10607   ins_pipe(empty);</span>
<span class="line-removed">10608 %}</span>
<span class="line-removed">10609 </span>
<span class="line-removed">10610 instruct roundDouble_nop(regD dst)</span>
<span class="line-removed">10611 %{</span>
<span class="line-removed">10612   match(Set dst (RoundDouble dst));</span>
<span class="line-removed">10613 </span>
<span class="line-removed">10614   ins_cost(0);</span>
<span class="line-removed">10615   ins_encode();</span>
<span class="line-removed">10616   ins_pipe(empty);</span>
<span class="line-removed">10617 %}</span>
<span class="line-removed">10618 </span>
10619 instruct convF2D_reg_reg(regD dst, regF src)
10620 %{
10621   match(Set dst (ConvF2D src));
10622 
10623   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10624   ins_encode %{
10625     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10626   %}
10627   ins_pipe(pipe_slow); // XXX
10628 %}
10629 
10630 instruct convF2D_reg_mem(regD dst, memory src)
10631 %{
10632   match(Set dst (ConvF2D (LoadF src)));
10633 
10634   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10635   ins_encode %{
10636     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10637   %}
10638   ins_pipe(pipe_slow); // XXX
10639 %}
10640 
10641 instruct convD2F_reg_reg(regF dst, regD src)
10642 %{
10643   match(Set dst (ConvD2F src));
10644 
10645   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10646   ins_encode %{
10647     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10648   %}
10649   ins_pipe(pipe_slow); // XXX
10650 %}
10651 
10652 instruct convD2F_reg_mem(regF dst, memory src)
10653 %{
10654   match(Set dst (ConvD2F (LoadD src)));
10655 
10656   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10657   ins_encode %{
10658     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10659   %}
10660   ins_pipe(pipe_slow); // XXX
10661 %}
10662 
10663 // XXX do mem variants
10664 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10665 %{
10666   match(Set dst (ConvF2I src));
10667   effect(KILL cr);
<a name="63" id="anc63"></a><span class="line-modified">10668 </span>
<span class="line-removed">10669   format %{ &quot;cvttss2sil $dst, $src\t# f2i\n\t&quot;</span>
<span class="line-removed">10670             &quot;cmpl    $dst, #0x80000000\n\t&quot;</span>
<span class="line-removed">10671             &quot;jne,s   done\n\t&quot;</span>
<span class="line-removed">10672             &quot;subq    rsp, #8\n\t&quot;</span>
<span class="line-removed">10673             &quot;movss   [rsp], $src\n\t&quot;</span>
<span class="line-removed">10674             &quot;call    f2i_fixup\n\t&quot;</span>
<span class="line-removed">10675             &quot;popq    $dst\n&quot;</span>
<span class="line-removed">10676     &quot;done:   &quot;%}</span>
10677   ins_encode %{
<a name="64" id="anc64"></a><span class="line-modified">10678     Label done;</span>
<span class="line-removed">10679     __ cvttss2sil($dst$$Register, $src$$XMMRegister);</span>
<span class="line-removed">10680     __ cmpl($dst$$Register, 0x80000000);</span>
<span class="line-removed">10681     __ jccb(Assembler::notEqual, done);</span>
<span class="line-removed">10682     __ subptr(rsp, 8);</span>
<span class="line-removed">10683     __ movflt(Address(rsp, 0), $src$$XMMRegister);</span>
<span class="line-removed">10684     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));</span>
<span class="line-removed">10685     __ pop($dst$$Register);</span>
<span class="line-removed">10686     __ bind(done);</span>
10687   %}
10688   ins_pipe(pipe_slow);
10689 %}
10690 
10691 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10692 %{
10693   match(Set dst (ConvF2L src));
10694   effect(KILL cr);
<a name="65" id="anc65"></a><span class="line-modified">10695 </span>
<span class="line-removed">10696   format %{ &quot;cvttss2siq $dst, $src\t# f2l\n\t&quot;</span>
<span class="line-removed">10697             &quot;cmpq    $dst, [0x8000000000000000]\n\t&quot;</span>
<span class="line-removed">10698             &quot;jne,s   done\n\t&quot;</span>
<span class="line-removed">10699             &quot;subq    rsp, #8\n\t&quot;</span>
<span class="line-removed">10700             &quot;movss   [rsp], $src\n\t&quot;</span>
<span class="line-removed">10701             &quot;call    f2l_fixup\n\t&quot;</span>
<span class="line-removed">10702             &quot;popq    $dst\n&quot;</span>
<span class="line-removed">10703     &quot;done:   &quot;%}</span>
10704   ins_encode %{
<a name="66" id="anc66"></a><span class="line-modified">10705     Label done;</span>
<span class="line-removed">10706     __ cvttss2siq($dst$$Register, $src$$XMMRegister);</span>
<span class="line-removed">10707     __ cmp64($dst$$Register,</span>
<span class="line-removed">10708              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));</span>
<span class="line-removed">10709     __ jccb(Assembler::notEqual, done);</span>
<span class="line-removed">10710     __ subptr(rsp, 8);</span>
<span class="line-removed">10711     __ movflt(Address(rsp, 0), $src$$XMMRegister);</span>
<span class="line-removed">10712     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));</span>
<span class="line-removed">10713     __ pop($dst$$Register);</span>
<span class="line-removed">10714     __ bind(done);</span>
10715   %}
10716   ins_pipe(pipe_slow);
10717 %}
10718 
10719 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10720 %{
10721   match(Set dst (ConvD2I src));
10722   effect(KILL cr);
<a name="67" id="anc67"></a><span class="line-modified">10723 </span>
<span class="line-removed">10724   format %{ &quot;cvttsd2sil $dst, $src\t# d2i\n\t&quot;</span>
<span class="line-removed">10725             &quot;cmpl    $dst, #0x80000000\n\t&quot;</span>
<span class="line-removed">10726             &quot;jne,s   done\n\t&quot;</span>
<span class="line-removed">10727             &quot;subq    rsp, #8\n\t&quot;</span>
<span class="line-removed">10728             &quot;movsd   [rsp], $src\n\t&quot;</span>
<span class="line-removed">10729             &quot;call    d2i_fixup\n\t&quot;</span>
<span class="line-removed">10730             &quot;popq    $dst\n&quot;</span>
<span class="line-removed">10731     &quot;done:   &quot;%}</span>
10732   ins_encode %{
<a name="68" id="anc68"></a><span class="line-modified">10733     Label done;</span>
<span class="line-removed">10734     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);</span>
<span class="line-removed">10735     __ cmpl($dst$$Register, 0x80000000);</span>
<span class="line-removed">10736     __ jccb(Assembler::notEqual, done);</span>
<span class="line-removed">10737     __ subptr(rsp, 8);</span>
<span class="line-removed">10738     __ movdbl(Address(rsp, 0), $src$$XMMRegister);</span>
<span class="line-removed">10739     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));</span>
<span class="line-removed">10740     __ pop($dst$$Register);</span>
<span class="line-removed">10741     __ bind(done);</span>
10742   %}
10743   ins_pipe(pipe_slow);
10744 %}
10745 
10746 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10747 %{
10748   match(Set dst (ConvD2L src));
10749   effect(KILL cr);
<a name="69" id="anc69"></a><span class="line-modified">10750 </span>
<span class="line-removed">10751   format %{ &quot;cvttsd2siq $dst, $src\t# d2l\n\t&quot;</span>
<span class="line-removed">10752             &quot;cmpq    $dst, [0x8000000000000000]\n\t&quot;</span>
<span class="line-removed">10753             &quot;jne,s   done\n\t&quot;</span>
<span class="line-removed">10754             &quot;subq    rsp, #8\n\t&quot;</span>
<span class="line-removed">10755             &quot;movsd   [rsp], $src\n\t&quot;</span>
<span class="line-removed">10756             &quot;call    d2l_fixup\n\t&quot;</span>
<span class="line-removed">10757             &quot;popq    $dst\n&quot;</span>
<span class="line-removed">10758     &quot;done:   &quot;%}</span>
10759   ins_encode %{
<a name="70" id="anc70"></a><span class="line-modified">10760     Label done;</span>
<span class="line-removed">10761     __ cvttsd2siq($dst$$Register, $src$$XMMRegister);</span>
<span class="line-removed">10762     __ cmp64($dst$$Register,</span>
<span class="line-removed">10763              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));</span>
<span class="line-removed">10764     __ jccb(Assembler::notEqual, done);</span>
<span class="line-removed">10765     __ subptr(rsp, 8);</span>
<span class="line-removed">10766     __ movdbl(Address(rsp, 0), $src$$XMMRegister);</span>
<span class="line-removed">10767     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));</span>
<span class="line-removed">10768     __ pop($dst$$Register);</span>
<span class="line-removed">10769     __ bind(done);</span>
10770   %}
10771   ins_pipe(pipe_slow);
10772 %}
10773 
10774 instruct convI2F_reg_reg(regF dst, rRegI src)
10775 %{
10776   predicate(!UseXmmI2F);
10777   match(Set dst (ConvI2F src));
10778 
10779   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10780   ins_encode %{
10781     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10782   %}
10783   ins_pipe(pipe_slow); // XXX
10784 %}
10785 
10786 instruct convI2F_reg_mem(regF dst, memory src)
10787 %{
10788   match(Set dst (ConvI2F (LoadI src)));
10789 
10790   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10791   ins_encode %{
10792     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10793   %}
10794   ins_pipe(pipe_slow); // XXX
10795 %}
10796 
10797 instruct convI2D_reg_reg(regD dst, rRegI src)
10798 %{
10799   predicate(!UseXmmI2D);
10800   match(Set dst (ConvI2D src));
10801 
10802   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10803   ins_encode %{
10804     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10805   %}
10806   ins_pipe(pipe_slow); // XXX
10807 %}
10808 
10809 instruct convI2D_reg_mem(regD dst, memory src)
10810 %{
10811   match(Set dst (ConvI2D (LoadI src)));
10812 
10813   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10814   ins_encode %{
10815     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10816   %}
10817   ins_pipe(pipe_slow); // XXX
10818 %}
10819 
10820 instruct convXI2F_reg(regF dst, rRegI src)
10821 %{
10822   predicate(UseXmmI2F);
10823   match(Set dst (ConvI2F src));
10824 
10825   format %{ &quot;movdl $dst, $src\n\t&quot;
10826             &quot;cvtdq2psl $dst, $dst\t# i2f&quot; %}
10827   ins_encode %{
10828     __ movdl($dst$$XMMRegister, $src$$Register);
10829     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10830   %}
10831   ins_pipe(pipe_slow); // XXX
10832 %}
10833 
10834 instruct convXI2D_reg(regD dst, rRegI src)
10835 %{
10836   predicate(UseXmmI2D);
10837   match(Set dst (ConvI2D src));
10838 
10839   format %{ &quot;movdl $dst, $src\n\t&quot;
10840             &quot;cvtdq2pdl $dst, $dst\t# i2d&quot; %}
10841   ins_encode %{
10842     __ movdl($dst$$XMMRegister, $src$$Register);
10843     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10844   %}
10845   ins_pipe(pipe_slow); // XXX
10846 %}
10847 
10848 instruct convL2F_reg_reg(regF dst, rRegL src)
10849 %{
10850   match(Set dst (ConvL2F src));
10851 
10852   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10853   ins_encode %{
10854     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10855   %}
10856   ins_pipe(pipe_slow); // XXX
10857 %}
10858 
10859 instruct convL2F_reg_mem(regF dst, memory src)
10860 %{
10861   match(Set dst (ConvL2F (LoadL src)));
10862 
10863   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10864   ins_encode %{
10865     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10866   %}
10867   ins_pipe(pipe_slow); // XXX
10868 %}
10869 
10870 instruct convL2D_reg_reg(regD dst, rRegL src)
10871 %{
10872   match(Set dst (ConvL2D src));
10873 
10874   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10875   ins_encode %{
10876     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10877   %}
10878   ins_pipe(pipe_slow); // XXX
10879 %}
10880 
10881 instruct convL2D_reg_mem(regD dst, memory src)
10882 %{
10883   match(Set dst (ConvL2D (LoadL src)));
10884 
10885   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10886   ins_encode %{
10887     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10888   %}
10889   ins_pipe(pipe_slow); // XXX
10890 %}
10891 
10892 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10893 %{
10894   match(Set dst (ConvI2L src));
10895 
10896   ins_cost(125);
10897   format %{ &quot;movslq  $dst, $src\t# i2l&quot; %}
10898   ins_encode %{
10899     __ movslq($dst$$Register, $src$$Register);
10900   %}
10901   ins_pipe(ialu_reg_reg);
10902 %}
10903 
10904 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10905 // %{
10906 //   match(Set dst (ConvI2L src));
10907 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10908 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10909 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10910 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10911 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10912 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10913 
10914 //   format %{ &quot;movl    $dst, $src\t# unsigned i2l&quot; %}
10915 //   ins_encode(enc_copy(dst, src));
10916 // //   opcode(0x63); // needs REX.W
10917 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10918 //   ins_pipe(ialu_reg_reg);
10919 // %}
10920 
10921 // Zero-extend convert int to long
10922 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10923 %{
10924   match(Set dst (AndL (ConvI2L src) mask));
10925 
10926   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10927   ins_encode %{
10928     if ($dst$$reg != $src$$reg) {
10929       __ movl($dst$$Register, $src$$Register);
10930     }
10931   %}
10932   ins_pipe(ialu_reg_reg);
10933 %}
10934 
10935 // Zero-extend convert int to long
10936 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10937 %{
10938   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10939 
10940   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10941   ins_encode %{
10942     __ movl($dst$$Register, $src$$Address);
10943   %}
10944   ins_pipe(ialu_reg_mem);
10945 %}
10946 
10947 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10948 %{
10949   match(Set dst (AndL src mask));
10950 
10951   format %{ &quot;movl    $dst, $src\t# zero-extend long&quot; %}
10952   ins_encode %{
10953     __ movl($dst$$Register, $src$$Register);
10954   %}
10955   ins_pipe(ialu_reg_reg);
10956 %}
10957 
10958 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10959 %{
10960   match(Set dst (ConvL2I src));
10961 
10962   format %{ &quot;movl    $dst, $src\t# l2i&quot; %}
10963   ins_encode %{
10964     __ movl($dst$$Register, $src$$Register);
10965   %}
10966   ins_pipe(ialu_reg_reg);
10967 %}
10968 
10969 
10970 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10971   match(Set dst (MoveF2I src));
10972   effect(DEF dst, USE src);
10973 
10974   ins_cost(125);
10975   format %{ &quot;movl    $dst, $src\t# MoveF2I_stack_reg&quot; %}
10976   ins_encode %{
10977     __ movl($dst$$Register, Address(rsp, $src$$disp));
10978   %}
10979   ins_pipe(ialu_reg_mem);
10980 %}
10981 
10982 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10983   match(Set dst (MoveI2F src));
10984   effect(DEF dst, USE src);
10985 
10986   ins_cost(125);
10987   format %{ &quot;movss   $dst, $src\t# MoveI2F_stack_reg&quot; %}
10988   ins_encode %{
10989     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10990   %}
10991   ins_pipe(pipe_slow);
10992 %}
10993 
10994 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10995   match(Set dst (MoveD2L src));
10996   effect(DEF dst, USE src);
10997 
10998   ins_cost(125);
10999   format %{ &quot;movq    $dst, $src\t# MoveD2L_stack_reg&quot; %}
11000   ins_encode %{
11001     __ movq($dst$$Register, Address(rsp, $src$$disp));
11002   %}
11003   ins_pipe(ialu_reg_mem);
11004 %}
11005 
11006 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
11007   predicate(!UseXmmLoadAndClearUpper);
11008   match(Set dst (MoveL2D src));
11009   effect(DEF dst, USE src);
11010 
11011   ins_cost(125);
11012   format %{ &quot;movlpd  $dst, $src\t# MoveL2D_stack_reg&quot; %}
11013   ins_encode %{
11014     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11015   %}
11016   ins_pipe(pipe_slow);
11017 %}
11018 
11019 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
11020   predicate(UseXmmLoadAndClearUpper);
11021   match(Set dst (MoveL2D src));
11022   effect(DEF dst, USE src);
11023 
11024   ins_cost(125);
11025   format %{ &quot;movsd   $dst, $src\t# MoveL2D_stack_reg&quot; %}
11026   ins_encode %{
11027     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11028   %}
11029   ins_pipe(pipe_slow);
11030 %}
11031 
11032 
11033 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
11034   match(Set dst (MoveF2I src));
11035   effect(DEF dst, USE src);
11036 
11037   ins_cost(95); // XXX
11038   format %{ &quot;movss   $dst, $src\t# MoveF2I_reg_stack&quot; %}
11039   ins_encode %{
11040     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
11041   %}
11042   ins_pipe(pipe_slow);
11043 %}
11044 
11045 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
11046   match(Set dst (MoveI2F src));
11047   effect(DEF dst, USE src);
11048 
11049   ins_cost(100);
11050   format %{ &quot;movl    $dst, $src\t# MoveI2F_reg_stack&quot; %}
11051   ins_encode %{
11052     __ movl(Address(rsp, $dst$$disp), $src$$Register);
11053   %}
11054   ins_pipe( ialu_mem_reg );
11055 %}
11056 
11057 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
11058   match(Set dst (MoveD2L src));
11059   effect(DEF dst, USE src);
11060 
11061   ins_cost(95); // XXX
11062   format %{ &quot;movsd   $dst, $src\t# MoveL2D_reg_stack&quot; %}
11063   ins_encode %{
11064     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
11065   %}
11066   ins_pipe(pipe_slow);
11067 %}
11068 
11069 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
11070   match(Set dst (MoveL2D src));
11071   effect(DEF dst, USE src);
11072 
11073   ins_cost(100);
11074   format %{ &quot;movq    $dst, $src\t# MoveL2D_reg_stack&quot; %}
11075   ins_encode %{
11076     __ movq(Address(rsp, $dst$$disp), $src$$Register);
11077   %}
11078   ins_pipe(ialu_mem_reg);
11079 %}
11080 
11081 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
11082   match(Set dst (MoveF2I src));
11083   effect(DEF dst, USE src);
11084   ins_cost(85);
11085   format %{ &quot;movd    $dst,$src\t# MoveF2I&quot; %}
11086   ins_encode %{
11087     __ movdl($dst$$Register, $src$$XMMRegister);
11088   %}
11089   ins_pipe( pipe_slow );
11090 %}
11091 
11092 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
11093   match(Set dst (MoveD2L src));
11094   effect(DEF dst, USE src);
11095   ins_cost(85);
11096   format %{ &quot;movd    $dst,$src\t# MoveD2L&quot; %}
11097   ins_encode %{
11098     __ movdq($dst$$Register, $src$$XMMRegister);
11099   %}
11100   ins_pipe( pipe_slow );
11101 %}
11102 
11103 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
11104   match(Set dst (MoveI2F src));
11105   effect(DEF dst, USE src);
11106   ins_cost(100);
11107   format %{ &quot;movd    $dst,$src\t# MoveI2F&quot; %}
11108   ins_encode %{
11109     __ movdl($dst$$XMMRegister, $src$$Register);
11110   %}
11111   ins_pipe( pipe_slow );
11112 %}
11113 
11114 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
11115   match(Set dst (MoveL2D src));
11116   effect(DEF dst, USE src);
11117   ins_cost(100);
11118   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
11119   ins_encode %{
11120      __ movdq($dst$$XMMRegister, $src$$Register);
11121   %}
11122   ins_pipe( pipe_slow );
11123 %}
11124 
11125 
11126 // =======================================================================
11127 // fast clearing of an array
11128 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,
11129                   Universe dummy, rFlagsReg cr)
11130 %{
11131   predicate(!((ClearArrayNode*)n)-&gt;is_large());
11132   match(Set dummy (ClearArray cnt base));
11133   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11134 
11135   format %{ $$template
11136     $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
11137     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
11138     $$emit$$&quot;jg      LARGE\n\t&quot;
11139     $$emit$$&quot;dec     rcx\n\t&quot;
11140     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
11141     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
11142     $$emit$$&quot;dec     rcx\n\t&quot;
11143     $$emit$$&quot;jge     LOOP\n\t&quot;
11144     $$emit$$&quot;jmp     DONE\n\t&quot;
11145     $$emit$$&quot;# LARGE:\n\t&quot;
11146     if (UseFastStosb) {
11147        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11148        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
11149     } else if (UseXMMForObjInit) {
11150        $$emit$$&quot;mov     rdi,rax\n\t&quot;
11151        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;
11152        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11153        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11154        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
11155        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;
11156        $$emit$$&quot;add     0x40,rax\n\t&quot;
11157        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11158        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11159        $$emit$$&quot;jge     L_loop\n\t&quot;
11160        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11161        $$emit$$&quot;jl      L_tail\n\t&quot;
11162        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
11163        $$emit$$&quot;add     0x20,rax\n\t&quot;
11164        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11165        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11166        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11167        $$emit$$&quot;jle     L_end\n\t&quot;
11168        $$emit$$&quot;dec     rcx\n\t&quot;
11169        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11170        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11171        $$emit$$&quot;add     0x8,rax\n\t&quot;
11172        $$emit$$&quot;dec     rcx\n\t&quot;
11173        $$emit$$&quot;jge     L_sloop\n\t&quot;
11174        $$emit$$&quot;# L_end:\n\t&quot;
11175     } else {
11176        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11177     }
11178     $$emit$$&quot;# DONE&quot;
11179   %}
11180   ins_encode %{
11181     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11182                  $tmp$$XMMRegister, false);
11183   %}
11184   ins_pipe(pipe_slow);
11185 %}
11186 
11187 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,
11188                         Universe dummy, rFlagsReg cr)
11189 %{
11190   predicate(((ClearArrayNode*)n)-&gt;is_large());
11191   match(Set dummy (ClearArray cnt base));
11192   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11193 
11194   format %{ $$template
11195     if (UseFastStosb) {
11196        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
11197        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11198        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
11199     } else if (UseXMMForObjInit) {
11200        $$emit$$&quot;mov     rdi,rax\t# ClearArray:\n\t&quot;
11201        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;
11202        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11203        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11204        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
11205        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;
11206        $$emit$$&quot;add     0x40,rax\n\t&quot;
11207        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11208        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11209        $$emit$$&quot;jge     L_loop\n\t&quot;
11210        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11211        $$emit$$&quot;jl      L_tail\n\t&quot;
11212        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
11213        $$emit$$&quot;add     0x20,rax\n\t&quot;
11214        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11215        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11216        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11217        $$emit$$&quot;jle     L_end\n\t&quot;
11218        $$emit$$&quot;dec     rcx\n\t&quot;
11219        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11220        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11221        $$emit$$&quot;add     0x8,rax\n\t&quot;
11222        $$emit$$&quot;dec     rcx\n\t&quot;
11223        $$emit$$&quot;jge     L_sloop\n\t&quot;
11224        $$emit$$&quot;# L_end:\n\t&quot;
11225     } else {
11226        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
11227        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11228     }
11229   %}
11230   ins_encode %{
11231     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11232                  $tmp$$XMMRegister, true);
11233   %}
11234   ins_pipe(pipe_slow);
11235 %}
11236 
11237 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<a name="71" id="anc71"></a><span class="line-modified">11238                          rax_RegI result, legVecS tmp1, rFlagsReg cr)</span>
11239 %{
11240   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11241   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11242   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11243 
11244   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11245   ins_encode %{
11246     __ string_compare($str1$$Register, $str2$$Register,
11247                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11248                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11249   %}
11250   ins_pipe( pipe_slow );
11251 %}
11252 
11253 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<a name="72" id="anc72"></a><span class="line-modified">11254                          rax_RegI result, legVecS tmp1, rFlagsReg cr)</span>
11255 %{
11256   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11257   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11258   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11259 
11260   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11261   ins_encode %{
11262     __ string_compare($str1$$Register, $str2$$Register,
11263                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11264                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11265   %}
11266   ins_pipe( pipe_slow );
11267 %}
11268 
11269 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
<a name="73" id="anc73"></a><span class="line-modified">11270                           rax_RegI result, legVecS tmp1, rFlagsReg cr)</span>
11271 %{
11272   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11273   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11274   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11275 
11276   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11277   ins_encode %{
11278     __ string_compare($str1$$Register, $str2$$Register,
11279                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11280                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11281   %}
11282   ins_pipe( pipe_slow );
11283 %}
11284 
11285 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
<a name="74" id="anc74"></a><span class="line-modified">11286                           rax_RegI result, legVecS tmp1, rFlagsReg cr)</span>
11287 %{
11288   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11289   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11290   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11291 
11292   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11293   ins_encode %{
11294     __ string_compare($str2$$Register, $str1$$Register,
11295                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11296                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11297   %}
11298   ins_pipe( pipe_slow );
11299 %}
11300 
11301 // fast search of substring with known size.
11302 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<a name="75" id="anc75"></a><span class="line-modified">11303                              rbx_RegI result, legVecS vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
11304 %{
11305   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11306   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<a name="76" id="anc76"></a><span class="line-modified">11307   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11308 
<a name="77" id="anc77"></a><span class="line-modified">11309   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
11310   ins_encode %{
11311     int icnt2 = (int)$int_cnt2$$constant;
11312     if (icnt2 &gt;= 16) {
11313       // IndexOf for constant substrings with size &gt;= 16 elements
11314       // which don&#39;t need to be loaded through stack.
11315       __ string_indexofC8($str1$$Register, $str2$$Register,
11316                           $cnt1$$Register, $cnt2$$Register,
11317                           icnt2, $result$$Register,
<a name="78" id="anc78"></a><span class="line-modified">11318                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11319     } else {
11320       // Small strings are loaded through stack if they cross page boundary.
11321       __ string_indexof($str1$$Register, $str2$$Register,
11322                         $cnt1$$Register, $cnt2$$Register,
11323                         icnt2, $result$$Register,
<a name="79" id="anc79"></a><span class="line-modified">11324                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11325     }
11326   %}
11327   ins_pipe( pipe_slow );
11328 %}
11329 
11330 // fast search of substring with known size.
11331 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<a name="80" id="anc80"></a><span class="line-modified">11332                              rbx_RegI result, legVecS vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
11333 %{
11334   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11335   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<a name="81" id="anc81"></a><span class="line-modified">11336   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11337 
<a name="82" id="anc82"></a><span class="line-modified">11338   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
11339   ins_encode %{
11340     int icnt2 = (int)$int_cnt2$$constant;
11341     if (icnt2 &gt;= 8) {
11342       // IndexOf for constant substrings with size &gt;= 8 elements
11343       // which don&#39;t need to be loaded through stack.
11344       __ string_indexofC8($str1$$Register, $str2$$Register,
11345                           $cnt1$$Register, $cnt2$$Register,
11346                           icnt2, $result$$Register,
<a name="83" id="anc83"></a><span class="line-modified">11347                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11348     } else {
11349       // Small strings are loaded through stack if they cross page boundary.
11350       __ string_indexof($str1$$Register, $str2$$Register,
11351                         $cnt1$$Register, $cnt2$$Register,
11352                         icnt2, $result$$Register,
<a name="84" id="anc84"></a><span class="line-modified">11353                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11354     }
11355   %}
11356   ins_pipe( pipe_slow );
11357 %}
11358 
11359 // fast search of substring with known size.
11360 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
<a name="85" id="anc85"></a><span class="line-modified">11361                              rbx_RegI result, legVecS vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)</span>
11362 %{
11363   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11364   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
<a name="86" id="anc86"></a><span class="line-modified">11365   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);</span>
11366 
<a name="87" id="anc87"></a><span class="line-modified">11367   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp&quot; %}</span>
11368   ins_encode %{
11369     int icnt2 = (int)$int_cnt2$$constant;
11370     if (icnt2 &gt;= 8) {
11371       // IndexOf for constant substrings with size &gt;= 8 elements
11372       // which don&#39;t need to be loaded through stack.
11373       __ string_indexofC8($str1$$Register, $str2$$Register,
11374                           $cnt1$$Register, $cnt2$$Register,
11375                           icnt2, $result$$Register,
<a name="88" id="anc88"></a><span class="line-modified">11376                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11377     } else {
11378       // Small strings are loaded through stack if they cross page boundary.
11379       __ string_indexof($str1$$Register, $str2$$Register,
11380                         $cnt1$$Register, $cnt2$$Register,
11381                         icnt2, $result$$Register,
<a name="89" id="anc89"></a><span class="line-modified">11382                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11383     }
11384   %}
11385   ins_pipe( pipe_slow );
11386 %}
11387 
11388 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<a name="90" id="anc90"></a><span class="line-modified">11389                          rbx_RegI result, legVecS vec, rcx_RegI tmp, rFlagsReg cr)</span>
11390 %{
11391   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11392   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<a name="91" id="anc91"></a><span class="line-modified">11393   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11394 
11395   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11396   ins_encode %{
11397     __ string_indexof($str1$$Register, $str2$$Register,
11398                       $cnt1$$Register, $cnt2$$Register,
11399                       (-1), $result$$Register,
<a name="92" id="anc92"></a><span class="line-modified">11400                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);</span>
11401   %}
11402   ins_pipe( pipe_slow );
11403 %}
11404 
11405 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<a name="93" id="anc93"></a><span class="line-modified">11406                          rbx_RegI result, legVecS vec, rcx_RegI tmp, rFlagsReg cr)</span>
11407 %{
11408   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11409   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<a name="94" id="anc94"></a><span class="line-modified">11410   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11411 
11412   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11413   ins_encode %{
11414     __ string_indexof($str1$$Register, $str2$$Register,
11415                       $cnt1$$Register, $cnt2$$Register,
11416                       (-1), $result$$Register,
<a name="95" id="anc95"></a><span class="line-modified">11417                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);</span>
11418   %}
11419   ins_pipe( pipe_slow );
11420 %}
11421 
11422 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
<a name="96" id="anc96"></a><span class="line-modified">11423                          rbx_RegI result, legVecS vec, rcx_RegI tmp, rFlagsReg cr)</span>
11424 %{
11425   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11426   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
<a name="97" id="anc97"></a><span class="line-modified">11427   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);</span>
11428 
11429   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11430   ins_encode %{
11431     __ string_indexof($str1$$Register, $str2$$Register,
11432                       $cnt1$$Register, $cnt2$$Register,
11433                       (-1), $result$$Register,
<a name="98" id="anc98"></a><span class="line-modified">11434                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);</span>
11435   %}
11436   ins_pipe( pipe_slow );
11437 %}
11438 
11439 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
<a name="99" id="anc99"></a><span class="line-modified">11440                               rbx_RegI result, legVecS vec1, legVecS vec2, legVecS vec3, rcx_RegI tmp, rFlagsReg cr)</span>
11441 %{
11442   predicate(UseSSE42Intrinsics);
11443   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
<a name="100" id="anc100"></a><span class="line-modified">11444   effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);</span>
11445   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11446   ins_encode %{
11447     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
<a name="101" id="anc101"></a><span class="line-modified">11448                            $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);</span>
11449   %}
11450   ins_pipe( pipe_slow );
11451 %}
11452 
11453 // fast string equals
11454 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
<a name="102" id="anc102"></a><span class="line-modified">11455                        legVecS tmp1, legVecS tmp2, rbx_RegI tmp3, rFlagsReg cr)</span>
11456 %{
11457   match(Set result (StrEquals (Binary str1 str2) cnt));
11458   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11459 
11460   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11461   ins_encode %{
11462     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11463                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11464                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11465   %}
11466   ins_pipe( pipe_slow );
11467 %}
11468 
11469 // fast array equals
11470 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
<a name="103" id="anc103"></a><span class="line-modified">11471                        legVecS tmp1, legVecS tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)</span>
11472 %{
11473   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11474   match(Set result (AryEq ary1 ary2));
11475   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11476 
11477   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11478   ins_encode %{
11479     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11480                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11481                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11482   %}
11483   ins_pipe( pipe_slow );
11484 %}
11485 
11486 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
<a name="104" id="anc104"></a><span class="line-modified">11487                       legVecS tmp1, legVecS tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)</span>
11488 %{
11489   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11490   match(Set result (AryEq ary1 ary2));
11491   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11492 
11493   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11494   ins_encode %{
11495     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11496                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11497                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11498   %}
11499   ins_pipe( pipe_slow );
11500 %}
11501 
11502 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
<a name="105" id="anc105"></a><span class="line-modified">11503                       legVecS tmp1, legVecS tmp2, rbx_RegI tmp3, rFlagsReg cr)</span>
11504 %{
11505   match(Set result (HasNegatives ary1 len));
11506   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11507 
11508   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11509   ins_encode %{
11510     __ has_negatives($ary1$$Register, $len$$Register,
11511                      $result$$Register, $tmp3$$Register,
11512                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11513   %}
11514   ins_pipe( pipe_slow );
11515 %}
11516 
11517 // fast char[] to byte[] compression
<a name="106" id="anc106"></a><span class="line-modified">11518 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legVecS tmp1, legVecS tmp2, legVecS tmp3, legVecS tmp4,</span>
11519                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11520   match(Set result (StrCompressedCopy src (Binary dst len)));
11521   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11522 
11523   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11524   ins_encode %{
11525     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11526                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11527                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11528   %}
11529   ins_pipe( pipe_slow );
11530 %}
11531 
11532 // fast byte[] to char[] inflation
11533 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
<a name="107" id="anc107"></a><span class="line-modified">11534                         legVecS tmp1, rcx_RegI tmp2, rFlagsReg cr) %{</span>
11535   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11536   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11537 
11538   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11539   ins_encode %{
11540     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11541                           $tmp1$$XMMRegister, $tmp2$$Register);
11542   %}
11543   ins_pipe( pipe_slow );
11544 %}
11545 
11546 // encode char[] to byte[] in ISO_8859_1
11547 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
<a name="108" id="anc108"></a><span class="line-modified">11548                           legVecS tmp1, legVecS tmp2, legVecS tmp3, legVecS tmp4,</span>
11549                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11550   match(Set result (EncodeISOArray src (Binary dst len)));
11551   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11552 
11553   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11554   ins_encode %{
11555     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11556                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11557                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11558   %}
11559   ins_pipe( pipe_slow );
11560 %}
11561 
11562 //----------Overflow Math Instructions-----------------------------------------
11563 
11564 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11565 %{
11566   match(Set cr (OverflowAddI op1 op2));
11567   effect(DEF cr, USE_KILL op1, USE op2);
11568 
11569   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11570 
11571   ins_encode %{
11572     __ addl($op1$$Register, $op2$$Register);
11573   %}
11574   ins_pipe(ialu_reg_reg);
11575 %}
11576 
11577 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
11578 %{
11579   match(Set cr (OverflowAddI op1 op2));
11580   effect(DEF cr, USE_KILL op1, USE op2);
11581 
11582   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11583 
11584   ins_encode %{
11585     __ addl($op1$$Register, $op2$$constant);
11586   %}
11587   ins_pipe(ialu_reg_reg);
11588 %}
11589 
11590 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11591 %{
11592   match(Set cr (OverflowAddL op1 op2));
11593   effect(DEF cr, USE_KILL op1, USE op2);
11594 
11595   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11596   ins_encode %{
11597     __ addq($op1$$Register, $op2$$Register);
11598   %}
11599   ins_pipe(ialu_reg_reg);
11600 %}
11601 
11602 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
11603 %{
11604   match(Set cr (OverflowAddL op1 op2));
11605   effect(DEF cr, USE_KILL op1, USE op2);
11606 
11607   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11608   ins_encode %{
11609     __ addq($op1$$Register, $op2$$constant);
11610   %}
11611   ins_pipe(ialu_reg_reg);
11612 %}
11613 
11614 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11615 %{
11616   match(Set cr (OverflowSubI op1 op2));
11617 
11618   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11619   ins_encode %{
11620     __ cmpl($op1$$Register, $op2$$Register);
11621   %}
11622   ins_pipe(ialu_reg_reg);
11623 %}
11624 
11625 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11626 %{
11627   match(Set cr (OverflowSubI op1 op2));
11628 
11629   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11630   ins_encode %{
11631     __ cmpl($op1$$Register, $op2$$constant);
11632   %}
11633   ins_pipe(ialu_reg_reg);
11634 %}
11635 
11636 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11637 %{
11638   match(Set cr (OverflowSubL op1 op2));
11639 
11640   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11641   ins_encode %{
11642     __ cmpq($op1$$Register, $op2$$Register);
11643   %}
11644   ins_pipe(ialu_reg_reg);
11645 %}
11646 
11647 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11648 %{
11649   match(Set cr (OverflowSubL op1 op2));
11650 
11651   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11652   ins_encode %{
11653     __ cmpq($op1$$Register, $op2$$constant);
11654   %}
11655   ins_pipe(ialu_reg_reg);
11656 %}
11657 
11658 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
11659 %{
11660   match(Set cr (OverflowSubI zero op2));
11661   effect(DEF cr, USE_KILL op2);
11662 
11663   format %{ &quot;negl    $op2\t# overflow check int&quot; %}
11664   ins_encode %{
11665     __ negl($op2$$Register);
11666   %}
11667   ins_pipe(ialu_reg_reg);
11668 %}
11669 
11670 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
11671 %{
11672   match(Set cr (OverflowSubL zero op2));
11673   effect(DEF cr, USE_KILL op2);
11674 
11675   format %{ &quot;negq    $op2\t# overflow check long&quot; %}
11676   ins_encode %{
11677     __ negq($op2$$Register);
11678   %}
11679   ins_pipe(ialu_reg_reg);
11680 %}
11681 
11682 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11683 %{
11684   match(Set cr (OverflowMulI op1 op2));
11685   effect(DEF cr, USE_KILL op1, USE op2);
11686 
11687   format %{ &quot;imull    $op1, $op2\t# overflow check int&quot; %}
11688   ins_encode %{
11689     __ imull($op1$$Register, $op2$$Register);
11690   %}
11691   ins_pipe(ialu_reg_reg_alu0);
11692 %}
11693 
11694 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
11695 %{
11696   match(Set cr (OverflowMulI op1 op2));
11697   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11698 
11699   format %{ &quot;imull    $tmp, $op1, $op2\t# overflow check int&quot; %}
11700   ins_encode %{
11701     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
11702   %}
11703   ins_pipe(ialu_reg_reg_alu0);
11704 %}
11705 
11706 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11707 %{
11708   match(Set cr (OverflowMulL op1 op2));
11709   effect(DEF cr, USE_KILL op1, USE op2);
11710 
11711   format %{ &quot;imulq    $op1, $op2\t# overflow check long&quot; %}
11712   ins_encode %{
11713     __ imulq($op1$$Register, $op2$$Register);
11714   %}
11715   ins_pipe(ialu_reg_reg_alu0);
11716 %}
11717 
11718 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
11719 %{
11720   match(Set cr (OverflowMulL op1 op2));
11721   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11722 
11723   format %{ &quot;imulq    $tmp, $op1, $op2\t# overflow check long&quot; %}
11724   ins_encode %{
11725     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
11726   %}
11727   ins_pipe(ialu_reg_reg_alu0);
11728 %}
11729 
11730 
11731 //----------Control Flow Instructions------------------------------------------
11732 // Signed compare Instructions
11733 
11734 // XXX more variants!!
11735 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11736 %{
11737   match(Set cr (CmpI op1 op2));
11738   effect(DEF cr, USE op1, USE op2);
11739 
11740   format %{ &quot;cmpl    $op1, $op2&quot; %}
11741   opcode(0x3B);  /* Opcode 3B /r */
11742   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11743   ins_pipe(ialu_cr_reg_reg);
11744 %}
11745 
11746 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11747 %{
11748   match(Set cr (CmpI op1 op2));
11749 
11750   format %{ &quot;cmpl    $op1, $op2&quot; %}
11751   opcode(0x81, 0x07); /* Opcode 81 /7 */
11752   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11753   ins_pipe(ialu_cr_reg_imm);
11754 %}
11755 
11756 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
11757 %{
11758   match(Set cr (CmpI op1 (LoadI op2)));
11759 
11760   ins_cost(500); // XXX
11761   format %{ &quot;cmpl    $op1, $op2&quot; %}
11762   opcode(0x3B); /* Opcode 3B /r */
11763   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11764   ins_pipe(ialu_cr_reg_mem);
11765 %}
11766 
11767 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
11768 %{
11769   match(Set cr (CmpI src zero));
11770 
11771   format %{ &quot;testl   $src, $src&quot; %}
11772   opcode(0x85);
11773   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11774   ins_pipe(ialu_cr_reg_imm);
11775 %}
11776 
11777 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11778 %{
11779   match(Set cr (CmpI (AndI src con) zero));
11780 
11781   format %{ &quot;testl   $src, $con&quot; %}
11782   opcode(0xF7, 0x00);
11783   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11784   ins_pipe(ialu_cr_reg_imm);
11785 %}
11786 
11787 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11788 %{
11789   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11790 
11791   format %{ &quot;testl   $src, $mem&quot; %}
11792   opcode(0x85);
11793   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11794   ins_pipe(ialu_cr_reg_mem);
11795 %}
11796 
11797 // Unsigned compare Instructions; really, same as signed except they
11798 // produce an rFlagsRegU instead of rFlagsReg.
11799 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11800 %{
11801   match(Set cr (CmpU op1 op2));
11802 
11803   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11804   opcode(0x3B); /* Opcode 3B /r */
11805   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11806   ins_pipe(ialu_cr_reg_reg);
11807 %}
11808 
11809 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11810 %{
11811   match(Set cr (CmpU op1 op2));
11812 
11813   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11814   opcode(0x81,0x07); /* Opcode 81 /7 */
11815   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11816   ins_pipe(ialu_cr_reg_imm);
11817 %}
11818 
11819 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
11820 %{
11821   match(Set cr (CmpU op1 (LoadI op2)));
11822 
11823   ins_cost(500); // XXX
11824   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11825   opcode(0x3B); /* Opcode 3B /r */
11826   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11827   ins_pipe(ialu_cr_reg_mem);
11828 %}
11829 
11830 // // // Cisc-spilled version of cmpU_rReg
11831 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11832 // //%{
11833 // //  match(Set cr (CmpU (LoadI op1) op2));
11834 // //
11835 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11836 // //  ins_cost(500);
11837 // //  opcode(0x39);  /* Opcode 39 /r */
11838 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11839 // //%}
11840 
11841 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11842 %{
11843   match(Set cr (CmpU src zero));
11844 
<a name="109" id="anc109"></a><span class="line-modified">11845   format %{ &quot;testl  $src, $src\t# unsigned&quot; %}</span>
11846   opcode(0x85);
11847   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11848   ins_pipe(ialu_cr_reg_imm);
11849 %}
11850 
11851 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11852 %{
11853   match(Set cr (CmpP op1 op2));
11854 
11855   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11856   opcode(0x3B); /* Opcode 3B /r */
11857   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11858   ins_pipe(ialu_cr_reg_reg);
11859 %}
11860 
11861 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11862 %{
11863   match(Set cr (CmpP op1 (LoadP op2)));
<a name="110" id="anc110"></a>
11864 
11865   ins_cost(500); // XXX
11866   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11867   opcode(0x3B); /* Opcode 3B /r */
11868   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11869   ins_pipe(ialu_cr_reg_mem);
11870 %}
11871 
11872 // // // Cisc-spilled version of cmpP_rReg
11873 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11874 // //%{
11875 // //  match(Set cr (CmpP (LoadP op1) op2));
11876 // //
11877 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11878 // //  ins_cost(500);
11879 // //  opcode(0x39);  /* Opcode 39 /r */
11880 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11881 // //%}
11882 
11883 // XXX this is generalized by compP_rReg_mem???
11884 // Compare raw pointer (used in out-of-heap check).
11885 // Only works because non-oop pointers must be raw pointers
11886 // and raw pointers have no anti-dependencies.
11887 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11888 %{
<a name="111" id="anc111"></a><span class="line-modified">11889   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none);</span>

11890   match(Set cr (CmpP op1 (LoadP op2)));
11891 
11892   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11893   opcode(0x3B); /* Opcode 3B /r */
11894   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11895   ins_pipe(ialu_cr_reg_mem);
11896 %}
11897 
11898 // This will generate a signed flags result. This should be OK since
11899 // any compare to a zero should be eq/neq.
11900 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11901 %{
11902   match(Set cr (CmpP src zero));
11903 
11904   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11905   opcode(0x85);
11906   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11907   ins_pipe(ialu_cr_reg_imm);
11908 %}
11909 
11910 // This will generate a signed flags result. This should be OK since
11911 // any compare to a zero should be eq/neq.
11912 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11913 %{
<a name="112" id="anc112"></a><span class="line-modified">11914   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));</span>

11915   match(Set cr (CmpP (LoadP op) zero));
11916 
11917   ins_cost(500); // XXX
11918   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11919   opcode(0xF7); /* Opcode F7 /0 */
11920   ins_encode(REX_mem_wide(op),
11921              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11922   ins_pipe(ialu_cr_reg_imm);
11923 %}
11924 
11925 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11926 %{
<a name="113" id="anc113"></a><span class="line-modified">11927   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>


11928   match(Set cr (CmpP (LoadP mem) zero));
11929 
11930   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11931   ins_encode %{
11932     __ cmpq(r12, $mem$$Address);
11933   %}
11934   ins_pipe(ialu_cr_reg_mem);
11935 %}
11936 
11937 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11938 %{
11939   match(Set cr (CmpN op1 op2));
11940 
11941   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11942   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11943   ins_pipe(ialu_cr_reg_reg);
11944 %}
11945 
11946 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11947 %{
11948   match(Set cr (CmpN src (LoadN mem)));
11949 
11950   format %{ &quot;cmpl    $src, $mem\t# compressed ptr&quot; %}
11951   ins_encode %{
11952     __ cmpl($src$$Register, $mem$$Address);
11953   %}
11954   ins_pipe(ialu_cr_reg_mem);
11955 %}
11956 
11957 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
11958   match(Set cr (CmpN op1 op2));
11959 
11960   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11961   ins_encode %{
11962     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
11963   %}
11964   ins_pipe(ialu_cr_reg_imm);
11965 %}
11966 
11967 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
11968 %{
11969   match(Set cr (CmpN src (LoadN mem)));
11970 
11971   format %{ &quot;cmpl    $mem, $src\t# compressed ptr&quot; %}
11972   ins_encode %{
11973     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
11974   %}
11975   ins_pipe(ialu_cr_reg_mem);
11976 %}
11977 
11978 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
11979   match(Set cr (CmpN op1 op2));
11980 
11981   format %{ &quot;cmpl    $op1, $op2\t# compressed klass ptr&quot; %}
11982   ins_encode %{
11983     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
11984   %}
11985   ins_pipe(ialu_cr_reg_imm);
11986 %}
11987 
11988 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
11989 %{
11990   match(Set cr (CmpN src (LoadNKlass mem)));
11991 
11992   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
11993   ins_encode %{
11994     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11995   %}
11996   ins_pipe(ialu_cr_reg_mem);
11997 %}
11998 
11999 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
12000   match(Set cr (CmpN src zero));
12001 
12002   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
12003   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
12004   ins_pipe(ialu_cr_reg_imm);
12005 %}
12006 
12007 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
12008 %{
<a name="114" id="anc114"></a><span class="line-modified">12009   predicate(Universe::narrow_oop_base() != NULL);</span>
12010   match(Set cr (CmpN (LoadN mem) zero));
12011 
12012   ins_cost(500); // XXX
12013   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
12014   ins_encode %{
12015     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
12016   %}
12017   ins_pipe(ialu_cr_reg_mem);
12018 %}
12019 
12020 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
12021 %{
<a name="115" id="anc115"></a><span class="line-modified">12022   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; (Universe::narrow_klass_base() == NULL));</span>
12023   match(Set cr (CmpN (LoadN mem) zero));
12024 
12025   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
12026   ins_encode %{
12027     __ cmpl(r12, $mem$$Address);
12028   %}
12029   ins_pipe(ialu_cr_reg_mem);
12030 %}
12031 
12032 // Yanked all unsigned pointer compare operations.
12033 // Pointer compares are done with CmpP which is already unsigned.
12034 
12035 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
12036 %{
12037   match(Set cr (CmpL op1 op2));
12038 
12039   format %{ &quot;cmpq    $op1, $op2&quot; %}
12040   opcode(0x3B);  /* Opcode 3B /r */
12041   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
12042   ins_pipe(ialu_cr_reg_reg);
12043 %}
12044 
12045 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
12046 %{
12047   match(Set cr (CmpL op1 op2));
12048 
12049   format %{ &quot;cmpq    $op1, $op2&quot; %}
12050   opcode(0x81, 0x07); /* Opcode 81 /7 */
12051   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
12052   ins_pipe(ialu_cr_reg_imm);
12053 %}
12054 
12055 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
12056 %{
12057   match(Set cr (CmpL op1 (LoadL op2)));
12058 
12059   format %{ &quot;cmpq    $op1, $op2&quot; %}
12060   opcode(0x3B); /* Opcode 3B /r */
12061   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
12062   ins_pipe(ialu_cr_reg_mem);
12063 %}
12064 
12065 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
12066 %{
12067   match(Set cr (CmpL src zero));
12068 
12069   format %{ &quot;testq   $src, $src&quot; %}
12070   opcode(0x85);
12071   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
12072   ins_pipe(ialu_cr_reg_imm);
12073 %}
12074 
12075 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
12076 %{
12077   match(Set cr (CmpL (AndL src con) zero));
12078 
12079   format %{ &quot;testq   $src, $con\t# long&quot; %}
12080   opcode(0xF7, 0x00);
12081   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
12082   ins_pipe(ialu_cr_reg_imm);
12083 %}
12084 
12085 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
12086 %{
12087   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
12088 
12089   format %{ &quot;testq   $src, $mem&quot; %}
12090   opcode(0x85);
12091   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12092   ins_pipe(ialu_cr_reg_mem);
12093 %}
12094 
12095 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
12096 %{
12097   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
12098 
12099   format %{ &quot;testq   $src, $mem&quot; %}
12100   opcode(0x85);
12101   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12102   ins_pipe(ialu_cr_reg_mem);
12103 %}
12104 
12105 // Manifest a CmpL result in an integer register.  Very painful.
12106 // This is the test to avoid.
12107 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
12108 %{
12109   match(Set dst (CmpL3 src1 src2));
12110   effect(KILL flags);
12111 
12112   ins_cost(275); // XXX
12113   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
12114             &quot;movl    $dst, -1\n\t&quot;
12115             &quot;jl,s    done\n\t&quot;
12116             &quot;setne   $dst\n\t&quot;
12117             &quot;movzbl  $dst, $dst\n\t&quot;
12118     &quot;done:&quot; %}
12119   ins_encode(cmpl3_flag(src1, src2, dst));
12120   ins_pipe(pipe_slow);
12121 %}
12122 
12123 // Unsigned long compare Instructions; really, same as signed long except they
12124 // produce an rFlagsRegU instead of rFlagsReg.
12125 instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)
12126 %{
12127   match(Set cr (CmpUL op1 op2));
12128 
12129   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12130   opcode(0x3B);  /* Opcode 3B /r */
12131   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
12132   ins_pipe(ialu_cr_reg_reg);
12133 %}
12134 
12135 instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)
12136 %{
12137   match(Set cr (CmpUL op1 op2));
12138 
12139   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12140   opcode(0x81, 0x07); /* Opcode 81 /7 */
12141   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
12142   ins_pipe(ialu_cr_reg_imm);
12143 %}
12144 
12145 instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)
12146 %{
12147   match(Set cr (CmpUL op1 (LoadL op2)));
12148 
12149   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12150   opcode(0x3B); /* Opcode 3B /r */
12151   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
12152   ins_pipe(ialu_cr_reg_mem);
12153 %}
12154 
12155 instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)
12156 %{
12157   match(Set cr (CmpUL src zero));
12158 
12159   format %{ &quot;testq   $src, $src\t# unsigned&quot; %}
12160   opcode(0x85);
12161   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
12162   ins_pipe(ialu_cr_reg_imm);
12163 %}
12164 
12165 instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)
12166 %{
12167   match(Set cr (CmpI (LoadB mem) imm));
12168 
12169   ins_cost(125);
12170   format %{ &quot;cmpb    $mem, $imm&quot; %}
12171   ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}
12172   ins_pipe(ialu_cr_reg_mem);
12173 %}
12174 
12175 instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU8 imm, immI0 zero)
12176 %{
12177   match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));
12178 
12179   ins_cost(125);
12180   format %{ &quot;testb   $mem, $imm\t# ubyte&quot; %}
12181   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12182   ins_pipe(ialu_cr_reg_mem);
12183 %}
12184 
12185 instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI0 zero)
12186 %{
12187   match(Set cr (CmpI (AndI (LoadB mem) imm) zero));
12188 
12189   ins_cost(125);
12190   format %{ &quot;testb   $mem, $imm\t# byte&quot; %}
12191   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12192   ins_pipe(ialu_cr_reg_mem);
12193 %}
12194 
12195 //----------Max and Min--------------------------------------------------------
12196 // Min Instructions
12197 
12198 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
12199 %{
12200   effect(USE_DEF dst, USE src, USE cr);
12201 
12202   format %{ &quot;cmovlgt $dst, $src\t# min&quot; %}
12203   opcode(0x0F, 0x4F);
12204   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12205   ins_pipe(pipe_cmov_reg);
12206 %}
12207 
12208 
12209 instruct minI_rReg(rRegI dst, rRegI src)
12210 %{
12211   match(Set dst (MinI dst src));
12212 
12213   ins_cost(200);
12214   expand %{
12215     rFlagsReg cr;
12216     compI_rReg(cr, dst, src);
12217     cmovI_reg_g(dst, src, cr);
12218   %}
12219 %}
12220 
12221 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
12222 %{
12223   effect(USE_DEF dst, USE src, USE cr);
12224 
12225   format %{ &quot;cmovllt $dst, $src\t# max&quot; %}
12226   opcode(0x0F, 0x4C);
12227   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12228   ins_pipe(pipe_cmov_reg);
12229 %}
12230 
12231 
12232 instruct maxI_rReg(rRegI dst, rRegI src)
12233 %{
12234   match(Set dst (MaxI dst src));
12235 
12236   ins_cost(200);
12237   expand %{
12238     rFlagsReg cr;
12239     compI_rReg(cr, dst, src);
12240     cmovI_reg_l(dst, src, cr);
12241   %}
12242 %}
12243 
12244 // ============================================================================
12245 // Branch Instructions
12246 
12247 // Jump Direct - Label defines a relative address from JMP+1
12248 instruct jmpDir(label labl)
12249 %{
12250   match(Goto);
12251   effect(USE labl);
12252 
12253   ins_cost(300);
12254   format %{ &quot;jmp     $labl&quot; %}
12255   size(5);
12256   ins_encode %{
12257     Label* L = $labl$$label;
12258     __ jmp(*L, false); // Always long jump
12259   %}
12260   ins_pipe(pipe_jmp);
12261 %}
12262 
12263 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12264 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
12265 %{
12266   match(If cop cr);
12267   effect(USE labl);
12268 
12269   ins_cost(300);
12270   format %{ &quot;j$cop     $labl&quot; %}
12271   size(6);
12272   ins_encode %{
12273     Label* L = $labl$$label;
12274     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12275   %}
12276   ins_pipe(pipe_jcc);
12277 %}
12278 
12279 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12280 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
12281 %{
12282   predicate(!n-&gt;has_vector_mask_set());
12283   match(CountedLoopEnd cop cr);
12284   effect(USE labl);
12285 
12286   ins_cost(300);
12287   format %{ &quot;j$cop     $labl\t# loop end&quot; %}
12288   size(6);
12289   ins_encode %{
12290     Label* L = $labl$$label;
12291     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12292   %}
12293   ins_pipe(pipe_jcc);
12294 %}
12295 
12296 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12297 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12298   predicate(!n-&gt;has_vector_mask_set());
12299   match(CountedLoopEnd cop cmp);
12300   effect(USE labl);
12301 
12302   ins_cost(300);
12303   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12304   size(6);
12305   ins_encode %{
12306     Label* L = $labl$$label;
12307     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12308   %}
12309   ins_pipe(pipe_jcc);
12310 %}
12311 
12312 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12313   predicate(!n-&gt;has_vector_mask_set());
12314   match(CountedLoopEnd cop cmp);
12315   effect(USE labl);
12316 
12317   ins_cost(200);
12318   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12319   size(6);
12320   ins_encode %{
12321     Label* L = $labl$$label;
12322     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12323   %}
12324   ins_pipe(pipe_jcc);
12325 %}
12326 
12327 // mask version
12328 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12329 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, rFlagsReg cr, label labl)
12330 %{
12331   predicate(n-&gt;has_vector_mask_set());
12332   match(CountedLoopEnd cop cr);
12333   effect(USE labl);
12334 
12335   ins_cost(400);
12336   format %{ &quot;j$cop     $labl\t# loop end\n\t&quot;
12337             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12338   size(10);
12339   ins_encode %{
12340     Label* L = $labl$$label;
12341     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12342     __ restorevectmask();
12343   %}
12344   ins_pipe(pipe_jcc);
12345 %}
12346 
12347 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12348 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12349   predicate(n-&gt;has_vector_mask_set());
12350   match(CountedLoopEnd cop cmp);
12351   effect(USE labl);
12352 
12353   ins_cost(400);
12354   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12355             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12356   size(10);
12357   ins_encode %{
12358     Label* L = $labl$$label;
12359     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12360     __ restorevectmask();
12361   %}
12362   ins_pipe(pipe_jcc);
12363 %}
12364 
12365 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12366   predicate(n-&gt;has_vector_mask_set());
12367   match(CountedLoopEnd cop cmp);
12368   effect(USE labl);
12369 
12370   ins_cost(300);
12371   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12372             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12373   size(10);
12374   ins_encode %{
12375     Label* L = $labl$$label;
12376     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12377     __ restorevectmask();
12378   %}
12379   ins_pipe(pipe_jcc);
12380 %}
12381 
12382 // Jump Direct Conditional - using unsigned comparison
12383 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12384   match(If cop cmp);
12385   effect(USE labl);
12386 
12387   ins_cost(300);
<a name="116" id="anc116"></a><span class="line-modified">12388   format %{ &quot;j$cop,u  $labl&quot; %}</span>
12389   size(6);
12390   ins_encode %{
12391     Label* L = $labl$$label;
12392     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12393   %}
12394   ins_pipe(pipe_jcc);
12395 %}
12396 
12397 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12398   match(If cop cmp);
12399   effect(USE labl);
12400 
12401   ins_cost(200);
<a name="117" id="anc117"></a><span class="line-modified">12402   format %{ &quot;j$cop,u  $labl&quot; %}</span>
12403   size(6);
12404   ins_encode %{
12405     Label* L = $labl$$label;
12406     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12407   %}
12408   ins_pipe(pipe_jcc);
12409 %}
12410 
12411 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12412   match(If cop cmp);
12413   effect(USE labl);
12414 
12415   ins_cost(200);
12416   format %{ $$template
12417     if ($cop$$cmpcode == Assembler::notEqual) {
<a name="118" id="anc118"></a><span class="line-modified">12418       $$emit$$&quot;jp,u   $labl\n\t&quot;</span>
12419       $$emit$$&quot;j$cop,u   $labl&quot;
12420     } else {
<a name="119" id="anc119"></a><span class="line-modified">12421       $$emit$$&quot;jp,u   done\n\t&quot;</span>
12422       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12423       $$emit$$&quot;done:&quot;
12424     }
12425   %}
12426   ins_encode %{
12427     Label* l = $labl$$label;
12428     if ($cop$$cmpcode == Assembler::notEqual) {
12429       __ jcc(Assembler::parity, *l, false);
12430       __ jcc(Assembler::notEqual, *l, false);
12431     } else if ($cop$$cmpcode == Assembler::equal) {
12432       Label done;
12433       __ jccb(Assembler::parity, done);
12434       __ jcc(Assembler::equal, *l, false);
12435       __ bind(done);
12436     } else {
12437        ShouldNotReachHere();
12438     }
12439   %}
12440   ins_pipe(pipe_jcc);
12441 %}
12442 
12443 // ============================================================================
12444 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary
12445 // superklass array for an instance of the superklass.  Set a hidden
12446 // internal cache on a hit (cache is checked with exposed code in
12447 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
12448 // encoding ALSO sets flags.
12449 
12450 instruct partialSubtypeCheck(rdi_RegP result,
12451                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12452                              rFlagsReg cr)
12453 %{
12454   match(Set result (PartialSubtypeCheck sub super));
12455   effect(KILL rcx, KILL cr);
12456 
12457   ins_cost(1100);  // slightly larger than the next version
12458   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12459             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12460             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12461             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t&quot;
12462             &quot;jne,s   miss\t\t# Missed: rdi not-zero\n\t&quot;
12463             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12464             &quot;xorq    $result, $result\t\t Hit: rdi zero\n\t&quot;
12465     &quot;miss:\t&quot; %}
12466 
12467   opcode(0x1); // Force a XOR of RDI
12468   ins_encode(enc_PartialSubtypeCheck());
12469   ins_pipe(pipe_slow);
12470 %}
12471 
12472 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
12473                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12474                                      immP0 zero,
12475                                      rdi_RegP result)
12476 %{
12477   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12478   effect(KILL rcx, KILL result);
12479 
12480   ins_cost(1000);
12481   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12482             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12483             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12484             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t&quot;
12485             &quot;jne,s   miss\t\t# Missed: flags nz\n\t&quot;
12486             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12487     &quot;miss:\t&quot; %}
12488 
12489   opcode(0x0); // No need to XOR RDI
12490   ins_encode(enc_PartialSubtypeCheck());
12491   ins_pipe(pipe_slow);
12492 %}
12493 
12494 // ============================================================================
12495 // Branch Instructions -- short offset versions
12496 //
12497 // These instructions are used to replace jumps of a long offset (the default
12498 // match) with jumps of a shorter offset.  These instructions are all tagged
12499 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12500 // match rules in general matching.  Instead, the ADLC generates a conversion
12501 // method in the MachNode which can be used to do in-place replacement of the
12502 // long variant with the shorter variant.  The compiler will determine if a
12503 // branch can be taken by the is_short_branch_offset() predicate in the machine
12504 // specific code section of the file.
12505 
12506 // Jump Direct - Label defines a relative address from JMP+1
12507 instruct jmpDir_short(label labl) %{
12508   match(Goto);
12509   effect(USE labl);
12510 
12511   ins_cost(300);
12512   format %{ &quot;jmp,s   $labl&quot; %}
12513   size(2);
12514   ins_encode %{
12515     Label* L = $labl$$label;
12516     __ jmpb(*L);
12517   %}
12518   ins_pipe(pipe_jmp);
12519   ins_short_branch(1);
12520 %}
12521 
12522 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12523 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
12524   match(If cop cr);
12525   effect(USE labl);
12526 
12527   ins_cost(300);
12528   format %{ &quot;j$cop,s   $labl&quot; %}
12529   size(2);
12530   ins_encode %{
12531     Label* L = $labl$$label;
12532     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12533   %}
12534   ins_pipe(pipe_jcc);
12535   ins_short_branch(1);
12536 %}
12537 
12538 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12539 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
12540   match(CountedLoopEnd cop cr);
12541   effect(USE labl);
12542 
12543   ins_cost(300);
12544   format %{ &quot;j$cop,s   $labl\t# loop end&quot; %}
12545   size(2);
12546   ins_encode %{
12547     Label* L = $labl$$label;
12548     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12549   %}
12550   ins_pipe(pipe_jcc);
12551   ins_short_branch(1);
12552 %}
12553 
12554 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12555 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12556   match(CountedLoopEnd cop cmp);
12557   effect(USE labl);
12558 
12559   ins_cost(300);
12560   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12561   size(2);
12562   ins_encode %{
12563     Label* L = $labl$$label;
12564     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12565   %}
12566   ins_pipe(pipe_jcc);
12567   ins_short_branch(1);
12568 %}
12569 
12570 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12571   match(CountedLoopEnd cop cmp);
12572   effect(USE labl);
12573 
12574   ins_cost(300);
12575   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12576   size(2);
12577   ins_encode %{
12578     Label* L = $labl$$label;
12579     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12580   %}
12581   ins_pipe(pipe_jcc);
12582   ins_short_branch(1);
12583 %}
12584 
12585 // Jump Direct Conditional - using unsigned comparison
12586 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12587   match(If cop cmp);
12588   effect(USE labl);
12589 
12590   ins_cost(300);
12591   format %{ &quot;j$cop,us  $labl&quot; %}
12592   size(2);
12593   ins_encode %{
12594     Label* L = $labl$$label;
12595     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12596   %}
12597   ins_pipe(pipe_jcc);
12598   ins_short_branch(1);
12599 %}
12600 
12601 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12602   match(If cop cmp);
12603   effect(USE labl);
12604 
12605   ins_cost(300);
12606   format %{ &quot;j$cop,us  $labl&quot; %}
12607   size(2);
12608   ins_encode %{
12609     Label* L = $labl$$label;
12610     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12611   %}
12612   ins_pipe(pipe_jcc);
12613   ins_short_branch(1);
12614 %}
12615 
12616 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12617   match(If cop cmp);
12618   effect(USE labl);
12619 
12620   ins_cost(300);
12621   format %{ $$template
12622     if ($cop$$cmpcode == Assembler::notEqual) {
<a name="120" id="anc120"></a><span class="line-modified">12623       $$emit$$&quot;jp,u,s   $labl\n\t&quot;</span>
<span class="line-modified">12624       $$emit$$&quot;j$cop,u,s   $labl&quot;</span>
12625     } else {
<a name="121" id="anc121"></a><span class="line-modified">12626       $$emit$$&quot;jp,u,s   done\n\t&quot;</span>
12627       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12628       $$emit$$&quot;done:&quot;
12629     }
12630   %}
12631   size(4);
12632   ins_encode %{
12633     Label* l = $labl$$label;
12634     if ($cop$$cmpcode == Assembler::notEqual) {
12635       __ jccb(Assembler::parity, *l);
12636       __ jccb(Assembler::notEqual, *l);
12637     } else if ($cop$$cmpcode == Assembler::equal) {
12638       Label done;
12639       __ jccb(Assembler::parity, done);
12640       __ jccb(Assembler::equal, *l);
12641       __ bind(done);
12642     } else {
12643        ShouldNotReachHere();
12644     }
12645   %}
12646   ins_pipe(pipe_jcc);
12647   ins_short_branch(1);
12648 %}
12649 
12650 // ============================================================================
12651 // inlined locking and unlocking
12652 
12653 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12654   predicate(Compile::current()-&gt;use_rtm());
12655   match(Set cr (FastLock object box));
12656   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12657   ins_cost(300);
12658   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12659   ins_encode %{
12660     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12661                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12662                  _counters, _rtm_counters, _stack_rtm_counters,
12663                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12664                  true, ra_-&gt;C-&gt;profile_rtm());
12665   %}
12666   ins_pipe(pipe_slow);
12667 %}
12668 
12669 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{
12670   predicate(!Compile::current()-&gt;use_rtm());
12671   match(Set cr (FastLock object box));
12672   effect(TEMP tmp, TEMP scr, USE_KILL box);
12673   ins_cost(300);
12674   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12675   ins_encode %{
12676     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12677                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
12678   %}
12679   ins_pipe(pipe_slow);
12680 %}
12681 
12682 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12683   match(Set cr (FastUnlock object box));
12684   effect(TEMP tmp, USE_KILL box);
12685   ins_cost(300);
12686   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12687   ins_encode %{
12688     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12689   %}
12690   ins_pipe(pipe_slow);
12691 %}
12692 
12693 
12694 // ============================================================================
12695 // Safepoint Instructions
12696 instruct safePoint_poll(rFlagsReg cr)
12697 %{
12698   predicate(!Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
12699   match(SafePoint);
12700   effect(KILL cr);
12701 
<a name="122" id="anc122"></a><span class="line-modified">12702   format %{ &quot;testl  rax, [rip + #offset_to_poll_page]\t&quot;</span>
12703             &quot;# Safepoint: poll for GC&quot; %}
12704   ins_cost(125);
12705   ins_encode %{
12706     AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
12707     __ testl(rax, addr);
12708   %}
12709   ins_pipe(ialu_reg_mem);
12710 %}
12711 
12712 instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)
12713 %{
12714   predicate(Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
12715   match(SafePoint poll);
12716   effect(KILL cr, USE poll);
12717 
<a name="123" id="anc123"></a><span class="line-modified">12718   format %{ &quot;testl  rax, [$poll]\t&quot;</span>
12719             &quot;# Safepoint: poll for GC&quot; %}
12720   ins_cost(125);
12721   ins_encode %{
12722     __ relocate(relocInfo::poll_type);
12723     __ testl(rax, Address($poll$$Register, 0));
12724   %}
12725   ins_pipe(ialu_reg_mem);
12726 %}
12727 
12728 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12729 %{
12730   predicate(SafepointMechanism::uses_thread_local_poll());
12731   match(SafePoint poll);
12732   effect(KILL cr, USE poll);
12733 
<a name="124" id="anc124"></a><span class="line-modified">12734   format %{ &quot;testl  rax, [$poll]\t&quot;</span>
12735             &quot;# Safepoint: poll for GC&quot; %}
12736   ins_cost(125);
12737   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12738   ins_encode %{
12739     __ relocate(relocInfo::poll_type);
12740     address pre_pc = __ pc();
12741     __ testl(rax, Address($poll$$Register, 0));
12742     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12743   %}
12744   ins_pipe(ialu_reg_mem);
12745 %}
12746 
12747 // ============================================================================
12748 // Procedure Call/Return Instructions
12749 // Call Java Static Instruction
12750 // Note: If this code changes, the corresponding ret_addr_offset() and
12751 //       compute_padding() functions will have to be adjusted.
12752 instruct CallStaticJavaDirect(method meth) %{
12753   match(CallStaticJava);
12754   effect(USE meth);
12755 
12756   ins_cost(300);
12757   format %{ &quot;call,static &quot; %}
12758   opcode(0xE8); /* E8 cd */
12759   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
12760   ins_pipe(pipe_slow);
12761   ins_alignment(4);
12762 %}
12763 
12764 // Call Java Dynamic Instruction
12765 // Note: If this code changes, the corresponding ret_addr_offset() and
12766 //       compute_padding() functions will have to be adjusted.
12767 instruct CallDynamicJavaDirect(method meth)
12768 %{
12769   match(CallDynamicJava);
12770   effect(USE meth);
12771 
12772   ins_cost(300);
12773   format %{ &quot;movq    rax, #Universe::non_oop_word()\n\t&quot;
12774             &quot;call,dynamic &quot; %}
12775   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
12776   ins_pipe(pipe_slow);
12777   ins_alignment(4);
12778 %}
12779 
12780 // Call Runtime Instruction
12781 instruct CallRuntimeDirect(method meth)
12782 %{
12783   match(CallRuntime);
12784   effect(USE meth);
12785 
12786   ins_cost(300);
12787   format %{ &quot;call,runtime &quot; %}
12788   ins_encode(clear_avx, Java_To_Runtime(meth));
12789   ins_pipe(pipe_slow);
12790 %}
12791 
12792 // Call runtime without safepoint
12793 instruct CallLeafDirect(method meth)
12794 %{
12795   match(CallLeaf);
12796   effect(USE meth);
12797 
12798   ins_cost(300);
12799   format %{ &quot;call_leaf,runtime &quot; %}
12800   ins_encode(clear_avx, Java_To_Runtime(meth));
12801   ins_pipe(pipe_slow);
12802 %}
12803 
12804 // Call runtime without safepoint
12805 instruct CallLeafNoFPDirect(method meth)
12806 %{
12807   match(CallLeafNoFP);
12808   effect(USE meth);
12809 
12810   ins_cost(300);
12811   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12812   ins_encode(clear_avx, Java_To_Runtime(meth));
12813   ins_pipe(pipe_slow);
12814 %}
12815 
12816 // Return Instruction
12817 // Remove the return address &amp; jump to it.
12818 // Notice: We always emit a nop after a ret to make sure there is room
12819 // for safepoint patching
12820 instruct Ret()
12821 %{
12822   match(Return);
12823 
12824   format %{ &quot;ret&quot; %}
12825   opcode(0xC3);
12826   ins_encode(OpcP);
12827   ins_pipe(pipe_jmp);
12828 %}
12829 
12830 // Tail Call; Jump from runtime stub to Java code.
12831 // Also known as an &#39;interprocedural jump&#39;.
12832 // Target of jump will eventually return to caller.
12833 // TailJump below removes the return address.
12834 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
12835 %{
12836   match(TailCall jump_target method_oop);
12837 
12838   ins_cost(300);
12839   format %{ &quot;jmp     $jump_target\t# rbx holds method oop&quot; %}
12840   opcode(0xFF, 0x4); /* Opcode FF /4 */
12841   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
12842   ins_pipe(pipe_jmp);
12843 %}
12844 
12845 // Tail Jump; remove the return address; jump to target.
12846 // TailCall above leaves the return address around.
12847 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
12848 %{
12849   match(TailJump jump_target ex_oop);
12850 
12851   ins_cost(300);
12852   format %{ &quot;popq    rdx\t# pop return address\n\t&quot;
12853             &quot;jmp     $jump_target&quot; %}
12854   opcode(0xFF, 0x4); /* Opcode FF /4 */
12855   ins_encode(Opcode(0x5a), // popq rdx
12856              REX_reg(jump_target), OpcP, reg_opc(jump_target));
12857   ins_pipe(pipe_jmp);
12858 %}
12859 
12860 // Create exception oop: created by stack-crawling runtime code.
12861 // Created exception is now available to this handler, and is setup
12862 // just prior to jumping to this handler.  No code emitted.
12863 instruct CreateException(rax_RegP ex_oop)
12864 %{
12865   match(Set ex_oop (CreateEx));
12866 
12867   size(0);
12868   // use the following format syntax
12869   format %{ &quot;# exception oop is in rax; no code emitted&quot; %}
12870   ins_encode();
12871   ins_pipe(empty);
12872 %}
12873 
12874 // Rethrow exception:
12875 // The exception oop will come in the first argument position.
12876 // Then JUMP (not call) to the rethrow stub code.
12877 instruct RethrowException()
12878 %{
12879   match(Rethrow);
12880 
12881   // use the following format syntax
12882   format %{ &quot;jmp     rethrow_stub&quot; %}
12883   ins_encode(enc_rethrow);
12884   ins_pipe(pipe_jmp);
12885 %}
12886 
12887 // ============================================================================
12888 // This name is KNOWN by the ADLC and cannot be changed.
12889 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
12890 // for this guy.
12891 instruct tlsLoadP(r15_RegP dst) %{
12892   match(Set dst (ThreadLocal));
12893   effect(DEF dst);
12894 
12895   size(0);
12896   format %{ &quot;# TLS is in R15&quot; %}
12897   ins_encode( /*empty encoding*/ );
12898   ins_pipe(ialu_reg_reg);
12899 %}
12900 
12901 
12902 //----------PEEPHOLE RULES-----------------------------------------------------
12903 // These must follow all instruction definitions as they use the names
12904 // defined in the instructions definitions.
12905 //
12906 // peepmatch ( root_instr_name [preceding_instruction]* );
12907 //
12908 // peepconstraint %{
12909 // (instruction_number.operand_name relational_op instruction_number.operand_name
12910 //  [, ...] );
12911 // // instruction numbers are zero-based using left to right order in peepmatch
12912 //
12913 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
12914 // // provide an instruction_number.operand_name for each operand that appears
12915 // // in the replacement instruction&#39;s match rule
12916 //
12917 // ---------VM FLAGS---------------------------------------------------------
12918 //
12919 // All peephole optimizations can be turned off using -XX:-OptoPeephole
12920 //
12921 // Each peephole rule is given an identifying number starting with zero and
12922 // increasing by one in the order seen by the parser.  An individual peephole
12923 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
12924 // on the command-line.
12925 //
12926 // ---------CURRENT LIMITATIONS----------------------------------------------
12927 //
12928 // Only match adjacent instructions in same basic block
12929 // Only equality constraints
12930 // Only constraints between operands, not (0.dest_reg == RAX_enc)
12931 // Only one replacement instruction
12932 //
12933 // ---------EXAMPLE----------------------------------------------------------
12934 //
12935 // // pertinent parts of existing instructions in architecture description
12936 // instruct movI(rRegI dst, rRegI src)
12937 // %{
12938 //   match(Set dst (CopyI src));
12939 // %}
12940 //
12941 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
12942 // %{
12943 //   match(Set dst (AddI dst src));
12944 //   effect(KILL cr);
12945 // %}
12946 //
12947 // // Change (inc mov) to lea
12948 // peephole %{
12949 //   // increment preceeded by register-register move
12950 //   peepmatch ( incI_rReg movI );
12951 //   // require that the destination register of the increment
12952 //   // match the destination register of the move
12953 //   peepconstraint ( 0.dst == 1.dst );
12954 //   // construct a replacement instruction that sets
12955 //   // the destination to ( move&#39;s source register + one )
12956 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
12957 // %}
12958 //
12959 
12960 // Implementation no longer uses movX instructions since
12961 // machine-independent system no longer uses CopyX nodes.
12962 //
12963 // peephole
12964 // %{
12965 //   peepmatch (incI_rReg movI);
12966 //   peepconstraint (0.dst == 1.dst);
12967 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12968 // %}
12969 
12970 // peephole
12971 // %{
12972 //   peepmatch (decI_rReg movI);
12973 //   peepconstraint (0.dst == 1.dst);
12974 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12975 // %}
12976 
12977 // peephole
12978 // %{
12979 //   peepmatch (addI_rReg_imm movI);
12980 //   peepconstraint (0.dst == 1.dst);
12981 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12982 // %}
12983 
12984 // peephole
12985 // %{
12986 //   peepmatch (incL_rReg movL);
12987 //   peepconstraint (0.dst == 1.dst);
12988 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12989 // %}
12990 
12991 // peephole
12992 // %{
12993 //   peepmatch (decL_rReg movL);
12994 //   peepconstraint (0.dst == 1.dst);
12995 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12996 // %}
12997 
12998 // peephole
12999 // %{
13000 //   peepmatch (addL_rReg_imm movL);
13001 //   peepconstraint (0.dst == 1.dst);
13002 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
13003 // %}
13004 
13005 // peephole
13006 // %{
13007 //   peepmatch (addP_rReg_imm movP);
13008 //   peepconstraint (0.dst == 1.dst);
13009 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
13010 // %}
13011 
13012 // // Change load of spilled value to only a spill
13013 // instruct storeI(memory mem, rRegI src)
13014 // %{
13015 //   match(Set mem (StoreI mem src));
13016 // %}
13017 //
13018 // instruct loadI(rRegI dst, memory mem)
13019 // %{
13020 //   match(Set dst (LoadI mem));
13021 // %}
13022 //
13023 
13024 peephole
13025 %{
13026   peepmatch (loadI storeI);
13027   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
13028   peepreplace (storeI(1.mem 1.mem 1.src));
13029 %}
13030 
13031 peephole
13032 %{
13033   peepmatch (loadL storeL);
13034   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
13035   peepreplace (storeL(1.mem 1.mem 1.src));
13036 %}
13037 
13038 //----------SMARTSPILL RULES---------------------------------------------------
13039 // These must follow all instruction definitions as they use the names
13040 // defined in the instructions definitions.
<a name="125" id="anc125"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="125" type="hidden" />
</body>
</html>
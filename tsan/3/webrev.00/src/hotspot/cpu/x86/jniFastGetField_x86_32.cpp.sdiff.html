<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/jniFastGetField_x86_32.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interpreterRT_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniFastGetField_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/jniFastGetField_x86_32.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 58     default:        ShouldNotReachHere();
 59   }
 60   ResourceMark rm;
 61   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE*wordSize);
 62   CodeBuffer cbuf(blob);
 63   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);
 64   address fast_entry = __ pc();
 65 
 66   Label slow;
 67 
 68   // stack layout:    offset from rsp (in words):
 69   //  return pc        0
 70   //  jni env          1
 71   //  obj              2
 72   //  jfieldID         3
 73 
 74   ExternalAddress counter(SafepointSynchronize::safepoint_counter_addr());
 75   __ mov32 (rcx, counter);
 76   __ testb (rcx, 1);
 77   __ jcc (Assembler::notZero, slow);








 78   __ mov(rax, rcx);
 79   __ andptr(rax, 1);                         // rax, must end up 0
 80   __ movptr(rdx, Address(rsp, rax, Address::times_1, 2*wordSize));
 81                                             // obj, notice rax, is 0.
 82                                             // rdx is data dependent on rcx.
 83   __ movptr(rax, Address(rsp, 3*wordSize));  // jfieldID
 84 
 85   __ clear_jweak_tag(rdx);
 86 
 87   __ movptr(rdx, Address(rdx, 0));           // *obj
 88   __ shrptr (rax, 2);                         // offset
 89 
 90   assert(count &lt; LIST_CAPACITY, &quot;LIST_CAPACITY too small&quot;);
 91   speculative_load_pclist[count] = __ pc();
 92   switch (type) {
 93     case T_BOOLEAN: __ movzbl (rax, Address(rdx, rax, Address::times_1)); break;
 94     case T_BYTE:    __ movsbl (rax, Address(rdx, rax, Address::times_1)); break;
 95     case T_CHAR:    __ movzwl (rax, Address(rdx, rax, Address::times_1)); break;
 96     case T_SHORT:   __ movswl (rax, Address(rdx, rax, Address::times_1)); break;
 97     case T_INT:     __ movl   (rax, Address(rdx, rax, Address::times_1)); break;
</pre>
<hr />
<pre>
171   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE*wordSize);
172   CodeBuffer cbuf(blob);
173   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);
174   address fast_entry = __ pc();
175 
176   Label slow;
177 
178   // stack layout:    offset from rsp (in words):
179   //  old rsi          0
180   //  return pc        1
181   //  jni env          2
182   //  obj              3
183   //  jfieldID         4
184 
185   ExternalAddress counter(SafepointSynchronize::safepoint_counter_addr());
186 
187   __ push  (rsi);
188   __ mov32 (rcx, counter);
189   __ testb (rcx, 1);
190   __ jcc (Assembler::notZero, slow);








191   __ mov(rax, rcx);
192   __ andptr(rax, 1);                         // rax, must end up 0
193   __ movptr(rdx, Address(rsp, rax, Address::times_1, 3*wordSize));
194                                             // obj, notice rax, is 0.
195                                             // rdx is data dependent on rcx.
196   __ movptr(rsi, Address(rsp, 4*wordSize));  // jfieldID
197 
198   __ clear_jweak_tag(rdx);
199 
200   __ movptr(rdx, Address(rdx, 0));           // *obj
201   __ shrptr(rsi, 2);                         // offset
202 
203   assert(count &lt; LIST_CAPACITY-1, &quot;LIST_CAPACITY too small&quot;);
204   speculative_load_pclist[count++] = __ pc();
205   __ movptr(rax, Address(rdx, rsi, Address::times_1));
206 #ifndef _LP64
207   speculative_load_pclist[count] = __ pc();
208   __ movl(rdx, Address(rdx, rsi, Address::times_1, 4));
209 #endif // _LP64
210 
</pre>
<hr />
<pre>
255   }
256   ResourceMark rm;
257   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE*wordSize);
258   CodeBuffer cbuf(blob);
259   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);
260   address fast_entry = __ pc();
261 
262   Label slow_with_pop, slow;
263 
264   // stack layout:    offset from rsp (in words):
265   //  return pc        0
266   //  jni env          1
267   //  obj              2
268   //  jfieldID         3
269 
270   ExternalAddress counter(SafepointSynchronize::safepoint_counter_addr());
271 
272   __ mov32 (rcx, counter);
273   __ testb (rcx, 1);
274   __ jcc (Assembler::notZero, slow);








275   __ mov(rax, rcx);
276   __ andptr(rax, 1);                         // rax, must end up 0
277   __ movptr(rdx, Address(rsp, rax, Address::times_1, 2*wordSize));
278                                             // obj, notice rax, is 0.
279                                             // rdx is data dependent on rcx.
280   __ movptr(rax, Address(rsp, 3*wordSize));  // jfieldID
281 
282   __ clear_jweak_tag(rdx);
283 
284   __ movptr(rdx, Address(rdx, 0));           // *obj
285   __ shrptr(rax, 2);                         // offset
286 
287   assert(count &lt; LIST_CAPACITY, &quot;LIST_CAPACITY too small&quot;);
288   speculative_load_pclist[count] = __ pc();
289   switch (type) {
290 #ifndef _LP64
291     case T_FLOAT:  __ fld_s (Address(rdx, rax, Address::times_1)); break;
292     case T_DOUBLE: __ fld_d (Address(rdx, rax, Address::times_1)); break;
293 #else
294     case T_FLOAT:  __ movflt (xmm0, Address(robj, roffset, Address::times_1)); break;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 58     default:        ShouldNotReachHere();
 59   }
 60   ResourceMark rm;
 61   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE*wordSize);
 62   CodeBuffer cbuf(blob);
 63   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);
 64   address fast_entry = __ pc();
 65 
 66   Label slow;
 67 
 68   // stack layout:    offset from rsp (in words):
 69   //  return pc        0
 70   //  jni env          1
 71   //  obj              2
 72   //  jfieldID         3
 73 
 74   ExternalAddress counter(SafepointSynchronize::safepoint_counter_addr());
 75   __ mov32 (rcx, counter);
 76   __ testb (rcx, 1);
 77   __ jcc (Assembler::notZero, slow);
<span class="line-added"> 78 </span>
<span class="line-added"> 79   if (JvmtiExport::can_post_field_access()) {</span>
<span class="line-added"> 80     // Check to see if a field access watch has been set before we</span>
<span class="line-added"> 81     // take the fast path.</span>
<span class="line-added"> 82     __ cmp32(ExternalAddress((address) JvmtiExport::get_field_access_count_addr()), 0);</span>
<span class="line-added"> 83     __ jcc(Assembler::notZero, slow);</span>
<span class="line-added"> 84   }</span>
<span class="line-added"> 85 </span>
 86   __ mov(rax, rcx);
 87   __ andptr(rax, 1);                         // rax, must end up 0
 88   __ movptr(rdx, Address(rsp, rax, Address::times_1, 2*wordSize));
 89                                             // obj, notice rax, is 0.
 90                                             // rdx is data dependent on rcx.
 91   __ movptr(rax, Address(rsp, 3*wordSize));  // jfieldID
 92 
 93   __ clear_jweak_tag(rdx);
 94 
 95   __ movptr(rdx, Address(rdx, 0));           // *obj
 96   __ shrptr (rax, 2);                         // offset
 97 
 98   assert(count &lt; LIST_CAPACITY, &quot;LIST_CAPACITY too small&quot;);
 99   speculative_load_pclist[count] = __ pc();
100   switch (type) {
101     case T_BOOLEAN: __ movzbl (rax, Address(rdx, rax, Address::times_1)); break;
102     case T_BYTE:    __ movsbl (rax, Address(rdx, rax, Address::times_1)); break;
103     case T_CHAR:    __ movzwl (rax, Address(rdx, rax, Address::times_1)); break;
104     case T_SHORT:   __ movswl (rax, Address(rdx, rax, Address::times_1)); break;
105     case T_INT:     __ movl   (rax, Address(rdx, rax, Address::times_1)); break;
</pre>
<hr />
<pre>
179   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE*wordSize);
180   CodeBuffer cbuf(blob);
181   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);
182   address fast_entry = __ pc();
183 
184   Label slow;
185 
186   // stack layout:    offset from rsp (in words):
187   //  old rsi          0
188   //  return pc        1
189   //  jni env          2
190   //  obj              3
191   //  jfieldID         4
192 
193   ExternalAddress counter(SafepointSynchronize::safepoint_counter_addr());
194 
195   __ push  (rsi);
196   __ mov32 (rcx, counter);
197   __ testb (rcx, 1);
198   __ jcc (Assembler::notZero, slow);
<span class="line-added">199 </span>
<span class="line-added">200   if (JvmtiExport::can_post_field_access()) {</span>
<span class="line-added">201     // Check to see if a field access watch has been set before we</span>
<span class="line-added">202     // take the fast path.</span>
<span class="line-added">203     __ cmp32(ExternalAddress((address) JvmtiExport::get_field_access_count_addr()), 0);</span>
<span class="line-added">204     __ jcc(Assembler::notZero, slow);</span>
<span class="line-added">205   }</span>
<span class="line-added">206 </span>
207   __ mov(rax, rcx);
208   __ andptr(rax, 1);                         // rax, must end up 0
209   __ movptr(rdx, Address(rsp, rax, Address::times_1, 3*wordSize));
210                                             // obj, notice rax, is 0.
211                                             // rdx is data dependent on rcx.
212   __ movptr(rsi, Address(rsp, 4*wordSize));  // jfieldID
213 
214   __ clear_jweak_tag(rdx);
215 
216   __ movptr(rdx, Address(rdx, 0));           // *obj
217   __ shrptr(rsi, 2);                         // offset
218 
219   assert(count &lt; LIST_CAPACITY-1, &quot;LIST_CAPACITY too small&quot;);
220   speculative_load_pclist[count++] = __ pc();
221   __ movptr(rax, Address(rdx, rsi, Address::times_1));
222 #ifndef _LP64
223   speculative_load_pclist[count] = __ pc();
224   __ movl(rdx, Address(rdx, rsi, Address::times_1, 4));
225 #endif // _LP64
226 
</pre>
<hr />
<pre>
271   }
272   ResourceMark rm;
273   BufferBlob* blob = BufferBlob::create(name, BUFFER_SIZE*wordSize);
274   CodeBuffer cbuf(blob);
275   MacroAssembler* masm = new MacroAssembler(&amp;cbuf);
276   address fast_entry = __ pc();
277 
278   Label slow_with_pop, slow;
279 
280   // stack layout:    offset from rsp (in words):
281   //  return pc        0
282   //  jni env          1
283   //  obj              2
284   //  jfieldID         3
285 
286   ExternalAddress counter(SafepointSynchronize::safepoint_counter_addr());
287 
288   __ mov32 (rcx, counter);
289   __ testb (rcx, 1);
290   __ jcc (Assembler::notZero, slow);
<span class="line-added">291 </span>
<span class="line-added">292   if (JvmtiExport::can_post_field_access()) {</span>
<span class="line-added">293     // Check to see if a field access watch has been set before we</span>
<span class="line-added">294     // take the fast path.</span>
<span class="line-added">295     __ cmp32(ExternalAddress((address) JvmtiExport::get_field_access_count_addr()), 0);</span>
<span class="line-added">296     __ jcc(Assembler::notZero, slow);</span>
<span class="line-added">297   }</span>
<span class="line-added">298 </span>
299   __ mov(rax, rcx);
300   __ andptr(rax, 1);                         // rax, must end up 0
301   __ movptr(rdx, Address(rsp, rax, Address::times_1, 2*wordSize));
302                                             // obj, notice rax, is 0.
303                                             // rdx is data dependent on rcx.
304   __ movptr(rax, Address(rsp, 3*wordSize));  // jfieldID
305 
306   __ clear_jweak_tag(rdx);
307 
308   __ movptr(rdx, Address(rdx, 0));           // *obj
309   __ shrptr(rax, 2);                         // offset
310 
311   assert(count &lt; LIST_CAPACITY, &quot;LIST_CAPACITY too small&quot;);
312   speculative_load_pclist[count] = __ pc();
313   switch (type) {
314 #ifndef _LP64
315     case T_FLOAT:  __ fld_s (Address(rdx, rax, Address::times_1)); break;
316     case T_DOUBLE: __ fld_d (Address(rdx, rax, Address::times_1)); break;
317 #else
318     case T_FLOAT:  __ movflt (xmm0, Address(robj, roffset, Address::times_1)); break;
</pre>
</td>
</tr>
</table>
<center><a href="interpreterRT_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jniFastGetField_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>